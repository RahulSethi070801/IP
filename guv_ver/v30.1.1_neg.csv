,func_oldfunccode,func_newfunccode,func_newdoc,func_newJdoc,func_olddoc,func_oldJdoc,func_addlines,func_addcode,func_dellines,func_delcode,func_path,func_pathinproj,func_methodsig,doc_oldfunccode,doc_newfunccode,doc_newdoc,doc_newJdoc,doc_olddoc,doc_oldJdoc,doc_addlines,doc_addcode,doc_dellines,doc_delcode,doc_path,doc_pathinproj,doc_methodsig,id,flag,commit
1,,4276ecb1e6f53b3c7460d2c599b4bcdab6f493af/Codes_neg/Match_newfunccode_4276ecb1e6f53b3c7460d2c599b4bcdab6f493af_1.txt," Can't use Streams.stream() from base
",4276ecb1e6f53b3c7460d2c599b4bcdab6f493af/Codes_neg/Match_newfuncnewJdoc_4276ecb1e6f53b3c7460d2c599b4bcdab6f493af_1.txt,,,"[435, 436, 438, 439]","['  @Beta\n', '  public Stream<String> splitToStream(CharSequence sequence) {\n', '    return StreamSupport.stream(split(sequence).spliterator(), false);\n', '  }\n']",[],[],/home/pritish/Documents/IP work/guv_ver/v30.1.1/4276ecb1e6f53b3c7460d2c599b4bcdab6f493af/Splitter,guava/src/com/google/common/base/Splitter.java,public Stream<String> splitToStream(CharSequence sequence),4276ecb1e6f53b3c7460d2c599b4bcdab6f493af/Codes_neg/Match_olddocfunccode_4276ecb1e6f53b3c7460d2c599b4bcdab6f493af_1.txt,4276ecb1e6f53b3c7460d2c599b4bcdab6f493af/Codes_neg/Match_newdocfunccode_4276ecb1e6f53b3c7460d2c599b4bcdab6f493af_1.txt,,4276ecb1e6f53b3c7460d2c599b4bcdab6f493af/Codes_neg/Match_newdocnewJdoc_4276ecb1e6f53b3c7460d2c599b4bcdab6f493af_1.txt,,4276ecb1e6f53b3c7460d2c599b4bcdab6f493af/Codes_neg/Match_olddocJdoc_4276ecb1e6f53b3c7460d2c599b4bcdab6f493af_1.txt,[377],['   * {@link #splitToList(CharSequence)}. Java 8 users may prefer {@link #splitToStream} instead.\n'],[375],[],/home/pritish/Documents/IP work/guv_ver/v30.1.1/4276ecb1e6f53b3c7460d2c599b4bcdab6f493af/Splitter,guava/src/com/google/common/base/Splitter.java,public Iterable<String> split(final CharSequence sequence),1,1,4276ecb1e6f53b3c7460d2c599b4bcdab6f493af
2,,e1ec6968a7d584281f56a38674d6722bea83811c/Codes_neg/Match_newfunccode_e1ec6968a7d584281f56a38674d6722bea83811c_1.txt," Add target first; it must be last in the chain because its entry hasn't yet been created
 Loop over current hashtable
 Rebuild hash using entry hashPrefix and tableIndex (""hashSuffix"")
",,,,"[449, 450, 387, 453, 454, 392, 457, 458, 459, 396, 460, 461, 397, 462, 398, 463, 399, 400, 464, 401, 402, 466, 403, 404, 469, 470, 407, 473, 410, 411, 414, 432, 436, 441, 445, 383]","['  private int resizeTable(int oldMask, int newCapacity, int targetHash, int targetEntryIndex) {\n', '    Object oldTable = requireTable();\n', '    for (int oldTableIndex = 0; oldTableIndex <= oldMask; oldTableIndex++) {\n', '      int oldNext = CompactHashing.tableGet(oldTable, oldTableIndex);\n', '      while (oldNext != UNSET) {\n', '        int entryIndex = oldNext - 1;\n', '        int oldEntry = entries[entryIndex];\n', '        int hash = CompactHashing.getHashPrefix(oldEntry, oldMask) | oldTableIndex;\n', '        CompactHashing.tableSet(newTable, newTableIndex, oldNext);\n', '        oldNext = CompactHashing.getNext(oldEntry, oldMask);\n', '  private int resizeTable(int oldMask, int newCapacity, int targetHash, int targetEntryIndex) {\n', '    Object oldTable = requireTable();\n', '    for (int oldTableIndex = 0; oldTableIndex <= oldMask; oldTableIndex++) {\n', '      int oldNext = CompactHashing.tableGet(oldTable, oldTableIndex);\n', '      while (oldNext != UNSET) {\n', '        int entryIndex = oldNext - 1;\n', '        int oldEntry = entries[entryIndex];\n', '\n', '        int hash = CompactHashing.getHashPrefix(oldEntry, oldMask) | oldTableIndex;\n', '        CompactHashing.tableSet(newTable, newTableIndex, oldNext);\n', '        oldNext = CompactHashing.getNext(oldEntry, oldMask);\n', '  private int resizeTable(int oldMask, int newCapacity, int targetHash, int targetEntryIndex) {\n', '    Object oldTable = requireTable();\n', '    for (int oldTableIndex = 0; oldTableIndex <= oldMask; oldTableIndex++) {\n', '      int oldNext = CompactHashing.tableGet(oldTable, oldTableIndex);\n', '      while (oldNext != UNSET) {\n', '        int entryIndex = oldNext - 1;\n', '        int oldEntry = entries[entryIndex];\n', '        int hash = CompactHashing.getHashPrefix(oldEntry, oldMask) | oldTableIndex;\n', '        CompactHashing.tableSet(newTable, newTableIndex, oldNext);\n', '        oldNext = CompactHashing.getNext(oldEntry, oldMask);\n', '  private int resizeTable(int oldMask, int newCapacity, int targetHash, int targetEntryIndex) {\n', '    Object oldTable = requireTable();\n', '    for (int oldTableIndex = 0; oldTableIndex <= oldMask; oldTableIndex++) {\n', '      int oldNext = CompactHashing.tableGet(oldTable, oldTableIndex);\n', '      while (oldNext != UNSET) {\n', '        int entryIndex = oldNext - 1;\n', '        int oldEntry = entries[entryIndex];\n', '\n', '        int hash = CompactHashing.getHashPrefix(oldEntry, oldMask) | oldTableIndex;\n', '        CompactHashing.tableSet(newTable, newTableIndex, oldNext);\n', '        oldNext = CompactHashing.getNext(oldEntry, oldMask);\n']",[],[],/home/pritish/Documents/IP work/guv_ver/v30.1.1/e1ec6968a7d584281f56a38674d6722bea83811c/CompactHashSet_2,guava/src/com/google/common/collect/CompactHashSet.java,"private int resizeTable(int oldMask, int newCapacity, int targetHash, int targetEntryIndex)",e1ec6968a7d584281f56a38674d6722bea83811c/Codes_neg/Match_olddocfunccode_e1ec6968a7d584281f56a38674d6722bea83811c_1.txt,e1ec6968a7d584281f56a38674d6722bea83811c/Codes_neg/Match_newdocfunccode_e1ec6968a7d584281f56a38674d6722bea83811c_1.txt," unsigned read
 unsigned read
",e1ec6968a7d584281f56a38674d6722bea83811c/Codes_neg/Match_newdocnewJdoc_e1ec6968a7d584281f56a38674d6722bea83811c_1.txt," unsigned read
 unsigned read
",,"[101, 102, 103, 104, 105]","['  /**\n', '   * Returns {@code table[index]}, where {@code table} is actually a {@code byte[]}, {@code\n', '   * short[]}, or {@code int[]}. When it is a {@code byte[]} or {@code short[]}, the returned value\n', '   * is unsigned, so the range of possible returned values is 0–255 or 0–65535, respectively.\n', '   */\n', '  /**\n', '   * Returns {@code table[index]}, where {@code table} is actually a {@code byte[]}, {@code\n', '   * short[]}, or {@code int[]}. When it is a {@code byte[]} or {@code short[]}, the returned value\n', '   * is unsigned, so the range of possible returned values is 0–255 or 0–65535, respectively.\n', '   */\n']",[],[],/home/pritish/Documents/IP work/guv_ver/v30.1.1/e1ec6968a7d584281f56a38674d6722bea83811c/CompactHashing,android/guava/src/com/google/common/collect/CompactHashing.java," static int tableGet(Object table, int index)",1,1,e1ec6968a7d584281f56a38674d6722bea83811c
3,e1ec6968a7d584281f56a38674d6722bea83811c/Codes_neg/Match_oldfunccode_e1ec6968a7d584281f56a38674d6722bea83811c_2.txt,,,," Add target first; it must be last in the chain because its entry hasn't yet been created
 Loop over current hashtable
 Rebuild hash using entry hashPrefix and tableIndex (""hashSuffix"")
",,[],[],"[386, 388, 390, 392, 393, 394, 395, 396, 397, 398, 399, 400, 401, 402, 403, 404, 405, 406, 407, 408, 410, 413, 414, 417, 379, 383]","['  private int resizeTable(int mask, int newCapacity, int targetHash, int targetEntryIndex) {\n', '    Object table = requireTable();\n', '    for (int tableIndex = 0; tableIndex <= mask; tableIndex++) {\n', '      int next = CompactHashing.tableGet(table, tableIndex);\n', '      while (next != UNSET) {\n', '        int entryIndex = next - 1;\n', '        int entry = entries[entryIndex];\n', '        int hash = CompactHashing.getHashPrefix(entry, mask) | tableIndex;\n', '        CompactHashing.tableSet(newTable, newTableIndex, next);\n', '        next = CompactHashing.getNext(entry, mask);\n', '  private int resizeTable(int mask, int newCapacity, int targetHash, int targetEntryIndex) {\n', '    Object table = requireTable();\n', '    for (int tableIndex = 0; tableIndex <= mask; tableIndex++) {\n', '      int next = CompactHashing.tableGet(table, tableIndex);\n', '      while (next != UNSET) {\n', '        int entryIndex = next - 1;\n', '        int entry = entries[entryIndex];\n', '\n', '        int hash = CompactHashing.getHashPrefix(entry, mask) | tableIndex;\n', '        CompactHashing.tableSet(newTable, newTableIndex, next);\n', '        next = CompactHashing.getNext(entry, mask);\n', '  private int resizeTable(int mask, int newCapacity, int targetHash, int targetEntryIndex) {\n', '    Object table = requireTable();\n', '    for (int tableIndex = 0; tableIndex <= mask; tableIndex++) {\n', '      int next = CompactHashing.tableGet(table, tableIndex);\n', '      while (next != UNSET) {\n', '        int entryIndex = next - 1;\n', '        int entry = entries[entryIndex];\n', '        int hash = CompactHashing.getHashPrefix(entry, mask) | tableIndex;\n', '        CompactHashing.tableSet(newTable, newTableIndex, next);\n', '        next = CompactHashing.getNext(entry, mask);\n', '  private int resizeTable(int mask, int newCapacity, int targetHash, int targetEntryIndex) {\n', '    Object table = requireTable();\n', '    for (int tableIndex = 0; tableIndex <= mask; tableIndex++) {\n', '      int next = CompactHashing.tableGet(table, tableIndex);\n', '      while (next != UNSET) {\n', '        int entryIndex = next - 1;\n', '        int entry = entries[entryIndex];\n', '\n', '        int hash = CompactHashing.getHashPrefix(entry, mask) | tableIndex;\n', '        CompactHashing.tableSet(newTable, newTableIndex, next);\n', '        next = CompactHashing.getNext(entry, mask);\n']",/home/pritish/Documents/IP work/guv_ver/v30.1.1/e1ec6968a7d584281f56a38674d6722bea83811c/CompactHashSet_2,guava/src/com/google/common/collect/CompactHashSet.java,"private int resizeTable(int mask, int newCapacity, int targetHash, int targetEntryIndex)",e1ec6968a7d584281f56a38674d6722bea83811c/Codes_neg/Match_olddocfunccode_e1ec6968a7d584281f56a38674d6722bea83811c_2.txt,e1ec6968a7d584281f56a38674d6722bea83811c/Codes_neg/Match_newdocfunccode_e1ec6968a7d584281f56a38674d6722bea83811c_2.txt," unsigned read
 unsigned read
 unsigned read
 unsigned read
",e1ec6968a7d584281f56a38674d6722bea83811c/Codes_neg/Match_newdocnewJdoc_e1ec6968a7d584281f56a38674d6722bea83811c_2.txt," unsigned read
 unsigned read
 unsigned read
 unsigned read
",,"[101, 102, 103, 104, 105]","['  /**\n', '   * Returns {@code table[index]}, where {@code table} is actually a {@code byte[]}, {@code\n', '   * short[]}, or {@code int[]}. When it is a {@code byte[]} or {@code short[]}, the returned value\n', '   * is unsigned, so the range of possible returned values is 0–255 or 0–65535, respectively.\n', '   */\n', '  /**\n', '   * Returns {@code table[index]}, where {@code table} is actually a {@code byte[]}, {@code\n', '   * short[]}, or {@code int[]}. When it is a {@code byte[]} or {@code short[]}, the returned value\n', '   * is unsigned, so the range of possible returned values is 0–255 or 0–65535, respectively.\n', '   */\n']",[],"['  private int resizeTable(int mask, int newCapacity, int targetHash, int targetEntryIndex) {\n', '    Object table = requireTable();\n', '    for (int tableIndex = 0; tableIndex <= mask; tableIndex++) {\n', '      int next = CompactHashing.tableGet(table, tableIndex);\n', '      while (next != UNSET) {\n', '        int entryIndex = next - 1;\n', '        int entry = entries[entryIndex];\n', '        int hash = CompactHashing.getHashPrefix(entry, mask) | tableIndex;\n', '        CompactHashing.tableSet(newTable, newTableIndex, next);\n', '        next = CompactHashing.getNext(entry, mask);\n', '  private int resizeTable(int mask, int newCapacity, int targetHash, int targetEntryIndex) {\n', '    Object table = requireTable();\n', '    for (int tableIndex = 0; tableIndex <= mask; tableIndex++) {\n', '      int next = CompactHashing.tableGet(table, tableIndex);\n', '      while (next != UNSET) {\n', '        int entryIndex = next - 1;\n', '        int entry = entries[entryIndex];\n', '\n', '        int hash = CompactHashing.getHashPrefix(entry, mask) | tableIndex;\n', '        CompactHashing.tableSet(newTable, newTableIndex, next);\n', '        next = CompactHashing.getNext(entry, mask);\n', '  private int resizeTable(int mask, int newCapacity, int targetHash, int targetEntryIndex) {\n', '    Object table = requireTable();\n', '    for (int tableIndex = 0; tableIndex <= mask; tableIndex++) {\n', '      int next = CompactHashing.tableGet(table, tableIndex);\n', '      while (next != UNSET) {\n', '        int entryIndex = next - 1;\n', '        int entry = entries[entryIndex];\n', '        int hash = CompactHashing.getHashPrefix(entry, mask) | tableIndex;\n', '        CompactHashing.tableSet(newTable, newTableIndex, next);\n', '        next = CompactHashing.getNext(entry, mask);\n', '  private int resizeTable(int mask, int newCapacity, int targetHash, int targetEntryIndex) {\n', '    Object table = requireTable();\n', '    for (int tableIndex = 0; tableIndex <= mask; tableIndex++) {\n', '      int next = CompactHashing.tableGet(table, tableIndex);\n', '      while (next != UNSET) {\n', '        int entryIndex = next - 1;\n', '        int entry = entries[entryIndex];\n', '\n', '        int hash = CompactHashing.getHashPrefix(entry, mask) | tableIndex;\n', '        CompactHashing.tableSet(newTable, newTableIndex, next);\n', '        next = CompactHashing.getNext(entry, mask);\n']",/home/pritish/Documents/IP work/guv_ver/v30.1.1/e1ec6968a7d584281f56a38674d6722bea83811c/CompactHashing,android/guava/src/com/google/common/collect/CompactHashing.java," static int tableGet(Object table, int index)",1,1,e1ec6968a7d584281f56a38674d6722bea83811c
4,786c3d84f11482451217a9fd76b886a0d2a8afe3/Codes_neg/Match_oldfunccode_786c3d84f11482451217a9fd76b886a0d2a8afe3_1.txt,786c3d84f11482451217a9fd76b886a0d2a8afe3/Codes_neg/Match_newfunccode_786c3d84f11482451217a9fd76b886a0d2a8afe3_1.txt," Calculate the quotients and remainders in the integer division x = k * (N - 1) / q, i.e.
 index * (dataset.length - 1) / scale for each index in indexes. For each, if there is no
 remainder, we can just select the value whose index in the sorted dataset equals the
 quotient; if there is a remainder, we interpolate between that and the next value.
 The indexes to select. In the worst case, we'll need one each side of each quantile.
 Since index and (dataset.length - 1) are non-negative ints, their product can be
 Since scale is a positive int, index is in [0, scale], and (dataset.length - 1) is a
 non-negative int, we can do long-arithmetic on index * (dataset.length - 1) / scale to
 get a rounded ratio and a remainder which can be expressed as ints, without risk of
 expressed as a long, without risk of overflow:
 overflow:
",786c3d84f11482451217a9fd76b886a0d2a8afe3/Codes_neg/Match_newfuncnewJdoc_786c3d84f11482451217a9fd76b886a0d2a8afe3_1.txt," Calculate the quotients and remainders in the integer division x = k * (N - 1) / q, i.e.
 index * (dataset.length - 1) / scale for each index in indexes. For each, if there is no
 remainder, we can just select the value whose index in the sorted dataset equals the
 quotient; if there is a remainder, we interpolate between that and the next value.
 The indexes to select. In the worst case, we'll need one each side of each quantile.
 Since index and (dataset.length - 1) are non-negative ints, their product can be
 Since scale is a positive int, index is in [0, scale], and (dataset.length - 1) is a
 non-negative int, we can do long-arithmetic on index * (dataset.length - 1) / scale to
 get a rounded ratio and a remainder which can be expressed as ints, without risk of
 expressed as a long, without risk of overflow:
 overflow:
",786c3d84f11482451217a9fd76b886a0d2a8afe3/Codes_neg/Match_oldfuncoldJdoc_786c3d84f11482451217a9fd76b886a0d2a8afe3_1.txt,"[438, 399]","['        Map<Integer, Double> nanMap = new LinkedHashMap<>();\n', '      Map<Integer, Double> ret = new LinkedHashMap<>();\n', '        Map<Integer, Double> nanMap = new LinkedHashMap<>();\n', '      Map<Integer, Double> ret = new LinkedHashMap<>();\n']","[389, 428]","['        Map<Integer, Double> nanMap = new HashMap<>();\n', '      Map<Integer, Double> ret = new HashMap<>();\n', '        Map<Integer, Double> nanMap = new HashMap<>();\n', '      Map<Integer, Double> ret = new HashMap<>();\n']",/home/pritish/Documents/IP work/guv_ver/v30.1.1/786c3d84f11482451217a9fd76b886a0d2a8afe3/Quantiles,android/guava/src/com/google/common/math/Quantiles.java,"public Map<Integer, Double> computeInPlace(double... dataset)",786c3d84f11482451217a9fd76b886a0d2a8afe3/Codes_neg/Match_olddocfunccode_786c3d84f11482451217a9fd76b886a0d2a8afe3_1.txt,786c3d84f11482451217a9fd76b886a0d2a8afe3/Codes_neg/Match_newdocfunccode_786c3d84f11482451217a9fd76b886a0d2a8afe3_1.txt,,786c3d84f11482451217a9fd76b886a0d2a8afe3/Codes_neg/Match_newdocnewJdoc_786c3d84f11482451217a9fd76b886a0d2a8afe3_1.txt,,786c3d84f11482451217a9fd76b886a0d2a8afe3/Codes_neg/Match_olddocJdoc_786c3d84f11482451217a9fd76b886a0d2a8afe3_1.txt,"[377, 378, 379, 380]","['     * @return an unmodifiable, ordered map of results: the keys will be the specified quantile\n', '     *     indexes, and the values the corresponding quantile values. When iterating, entries in the\n', '     *     map are ordered by quantile index in the same order they were passed to the {@code\n', '     *     indexes} method.\n', '     * @return an unmodifiable, ordered map of results: the keys will be the specified quantile\n', '     *     indexes, and the values the corresponding quantile values. When iterating, entries in the\n', '     *     map are ordered by quantile index in the same order they were passed to the {@code\n', '     *     indexes} method.\n']","[371, 372]","['        Map<Integer, Double> nanMap = new HashMap<>();\n', '      Map<Integer, Double> ret = new HashMap<>();\n', '        Map<Integer, Double> nanMap = new HashMap<>();\n', '      Map<Integer, Double> ret = new HashMap<>();\n']",/home/pritish/Documents/IP work/guv_ver/v30.1.1/786c3d84f11482451217a9fd76b886a0d2a8afe3/Quantiles,android/guava/src/com/google/common/math/Quantiles.java,"public Map<Integer, Double> compute(int... dataset)",1,1,786c3d84f11482451217a9fd76b886a0d2a8afe3
5,786c3d84f11482451217a9fd76b886a0d2a8afe3/Codes_neg/Match_oldfunccode_786c3d84f11482451217a9fd76b886a0d2a8afe3_2.txt,786c3d84f11482451217a9fd76b886a0d2a8afe3/Codes_neg/Match_newfunccode_786c3d84f11482451217a9fd76b886a0d2a8afe3_2.txt," Calculate the quotients and remainders in the integer division x = k * (N - 1) / q, i.e.
 index * (dataset.length - 1) / scale for each index in indexes. For each, if there is no
 remainder, we can just select the value whose index in the sorted dataset equals the
 quotient; if there is a remainder, we interpolate between that and the next value.
 The indexes to select. In the worst case, we'll need one each side of each quantile.
 Since index and (dataset.length - 1) are non-negative ints, their product can be
 Since scale is a positive int, index is in [0, scale], and (dataset.length - 1) is a
 non-negative int, we can do long-arithmetic on index * (dataset.length - 1) / scale to
 get a rounded ratio and a remainder which can be expressed as ints, without risk of
 expressed as a long, without risk of overflow:
 overflow:
 Calculate the quotients and remainders in the integer division x = k * (N - 1) / q, i.e.
 index * (dataset.length - 1) / scale for each index in indexes. For each, if there is no
 remainder, we can just select the value whose index in the sorted dataset equals the
 quotient; if there is a remainder, we interpolate between that and the next value.
 The indexes to select. In the worst case, we'll need one each side of each quantile.
 Since index and (dataset.length - 1) are non-negative ints, their product can be
 Since scale is a positive int, index is in [0, scale], and (dataset.length - 1) is a
 non-negative int, we can do long-arithmetic on index * (dataset.length - 1) / scale to
 get a rounded ratio and a remainder which can be expressed as ints, without risk of
 expressed as a long, without risk of overflow:
 overflow:
",786c3d84f11482451217a9fd76b886a0d2a8afe3/Codes_neg/Match_newfuncnewJdoc_786c3d84f11482451217a9fd76b886a0d2a8afe3_2.txt," Calculate the quotients and remainders in the integer division x = k * (N - 1) / q, i.e.
 index * (dataset.length - 1) / scale for each index in indexes. For each, if there is no
 remainder, we can just select the value whose index in the sorted dataset equals the
 quotient; if there is a remainder, we interpolate between that and the next value.
 The indexes to select. In the worst case, we'll need one each side of each quantile.
 Since index and (dataset.length - 1) are non-negative ints, their product can be
 Since scale is a positive int, index is in [0, scale], and (dataset.length - 1) is a
 non-negative int, we can do long-arithmetic on index * (dataset.length - 1) / scale to
 get a rounded ratio and a remainder which can be expressed as ints, without risk of
 expressed as a long, without risk of overflow:
 overflow:
 Calculate the quotients and remainders in the integer division x = k * (N - 1) / q, i.e.
 index * (dataset.length - 1) / scale for each index in indexes. For each, if there is no
 remainder, we can just select the value whose index in the sorted dataset equals the
 quotient; if there is a remainder, we interpolate between that and the next value.
 The indexes to select. In the worst case, we'll need one each side of each quantile.
 Since index and (dataset.length - 1) are non-negative ints, their product can be
 Since scale is a positive int, index is in [0, scale], and (dataset.length - 1) is a
 non-negative int, we can do long-arithmetic on index * (dataset.length - 1) / scale to
 get a rounded ratio and a remainder which can be expressed as ints, without risk of
 expressed as a long, without risk of overflow:
 overflow:
",786c3d84f11482451217a9fd76b886a0d2a8afe3/Codes_neg/Match_oldfuncoldJdoc_786c3d84f11482451217a9fd76b886a0d2a8afe3_2.txt,"[438, 399]","['        Map<Integer, Double> nanMap = new LinkedHashMap<>();\n', '      Map<Integer, Double> ret = new LinkedHashMap<>();\n', '        Map<Integer, Double> nanMap = new LinkedHashMap<>();\n', '      Map<Integer, Double> ret = new LinkedHashMap<>();\n']","[389, 428]","['        Map<Integer, Double> nanMap = new HashMap<>();\n', '      Map<Integer, Double> ret = new HashMap<>();\n', '        Map<Integer, Double> nanMap = new HashMap<>();\n', '      Map<Integer, Double> ret = new HashMap<>();\n']",/home/pritish/Documents/IP work/guv_ver/v30.1.1/786c3d84f11482451217a9fd76b886a0d2a8afe3/Quantiles,android/guava/src/com/google/common/math/Quantiles.java,"public Map<Integer, Double> computeInPlace(double... dataset)",786c3d84f11482451217a9fd76b886a0d2a8afe3/Codes_neg/Match_olddocfunccode_786c3d84f11482451217a9fd76b886a0d2a8afe3_2.txt,786c3d84f11482451217a9fd76b886a0d2a8afe3/Codes_neg/Match_newdocfunccode_786c3d84f11482451217a9fd76b886a0d2a8afe3_2.txt,,786c3d84f11482451217a9fd76b886a0d2a8afe3/Codes_neg/Match_newdocnewJdoc_786c3d84f11482451217a9fd76b886a0d2a8afe3_2.txt,,786c3d84f11482451217a9fd76b886a0d2a8afe3/Codes_neg/Match_olddocJdoc_786c3d84f11482451217a9fd76b886a0d2a8afe3_2.txt,"[348, 349, 350, 351]","['     * @return an unmodifiable, ordered map of results: the keys will be the specified quantile\n', '     *     indexes, and the values the corresponding quantile values. When iterating, entries in the\n', '     *     map are ordered by quantile index in the same order they were passed to the {@code\n', '     *     indexes} method.\n', '     * @return an unmodifiable, ordered map of results: the keys will be the specified quantile\n', '     *     indexes, and the values the corresponding quantile values. When iterating, entries in the\n', '     *     map are ordered by quantile index in the same order they were passed to the {@code\n', '     *     indexes} method.\n']","[346, 347]","['        Map<Integer, Double> nanMap = new HashMap<>();\n', '      Map<Integer, Double> ret = new HashMap<>();\n', '        Map<Integer, Double> nanMap = new HashMap<>();\n', '      Map<Integer, Double> ret = new HashMap<>();\n']",/home/pritish/Documents/IP work/guv_ver/v30.1.1/786c3d84f11482451217a9fd76b886a0d2a8afe3/Quantiles,android/guava/src/com/google/common/math/Quantiles.java,"public Map<Integer, Double> compute(double... dataset)",1,1,786c3d84f11482451217a9fd76b886a0d2a8afe3
6,fcca066e6d1ea878d1d5703524a67c3cdeb1d586/Codes_neg/Match_oldfunccode_fcca066e6d1ea878d1d5703524a67c3cdeb1d586_1.txt,fcca066e6d1ea878d1d5703524a67c3cdeb1d586/Codes_neg/Match_newfunccode_fcca066e6d1ea878d1d5703524a67c3cdeb1d586_1.txt," To avoid a race, make sure the refreshed value is set into loadingValueReference
 *before* returning newValue from the cache query.
",," To avoid a race, make sure the refreshed value is set into loadingValueReference
 *before* returning newValue from the cache query.
",,"[3450, 3451, 3532, 3452, 3533, 3534]","['            newResult -> {\n', '              LoadingValueReference.this.set(newResult);\n', '              return newResult;\n', '            newResult -> {\n', '              LoadingValueReference.this.set(newResult);\n', '              return newResult;\n']","[3462, 3463, 3544, 3464, 3545, 3465, 3546, 3466, 3547, 3467, 3548, 3549]","['            new com.google.common.base.Function<V, V>() {\n', '              @Override\n', '              public V apply(V newValue) {\n', '                LoadingValueReference.this.set(newValue);\n', '                return newValue;\n', '              }\n', '            new Function<V, V>() {\n', '              @Override\n', '              public V apply(V newValue) {\n', '                LoadingValueReference.this.set(newValue);\n', '                return newValue;\n', '              }\n']",/home/pritish/Documents/IP work/guv_ver/v30.1.1/fcca066e6d1ea878d1d5703524a67c3cdeb1d586/LocalCache_2,guava/src/com/google/common/cache/LocalCache.java,"public ListenableFuture<V> loadFuture(K key, CacheLoader<? super K, V> loader)",fcca066e6d1ea878d1d5703524a67c3cdeb1d586/Codes_neg/Match_olddocfunccode_fcca066e6d1ea878d1d5703524a67c3cdeb1d586_1.txt,fcca066e6d1ea878d1d5703524a67c3cdeb1d586/Codes_neg/Match_newdocfunccode_fcca066e6d1ea878d1d5703524a67c3cdeb1d586_1.txt,,fcca066e6d1ea878d1d5703524a67c3cdeb1d586/Codes_neg/Match_newdocnewJdoc_fcca066e6d1ea878d1d5703524a67c3cdeb1d586_1.txt,,fcca066e6d1ea878d1d5703524a67c3cdeb1d586/Codes_neg/Match_olddocJdoc_fcca066e6d1ea878d1d5703524a67c3cdeb1d586_1.txt,"[663, 664, 666, 667]","['     * Returns true if a new value is currently loading, regardless of whether there is an existing\n', '     * value. It is assumed that the return value of this method is constant for any given\n', '     * Returns true if a new value is currently loading, regardless of whether there is an existing\n', '     * value. It is assumed that the return value of this method is constant for any given\n']","[664, 665, 666, 667]","['            new com.google.common.base.Function<V, V>() {\n', '              @Override\n', '              public V apply(V newValue) {\n', '                LoadingValueReference.this.set(newValue);\n', '                return newValue;\n', '              }\n', '            new Function<V, V>() {\n', '              @Override\n', '              public V apply(V newValue) {\n', '                LoadingValueReference.this.set(newValue);\n', '                return newValue;\n', '              }\n']",/home/pritish/Documents/IP work/guv_ver/v30.1.1/fcca066e6d1ea878d1d5703524a67c3cdeb1d586/LocalCache_2,guava/src/com/google/common/cache/LocalCache.java, boolean isLoading(),1,1,fcca066e6d1ea878d1d5703524a67c3cdeb1d586
7,fcca066e6d1ea878d1d5703524a67c3cdeb1d586/Codes_neg/Match_oldfunccode_fcca066e6d1ea878d1d5703524a67c3cdeb1d586_2.txt,fcca066e6d1ea878d1d5703524a67c3cdeb1d586/Codes_neg/Match_newfunccode_fcca066e6d1ea878d1d5703524a67c3cdeb1d586_2.txt," To avoid a race, make sure the refreshed value is set into loadingValueReference
 *before* returning newValue from the cache query.
 To avoid a race, make sure the refreshed value is set into loadingValueReference
 *before* returning newValue from the cache query.
",," To avoid a race, make sure the refreshed value is set into loadingValueReference
 *before* returning newValue from the cache query.
 To avoid a race, make sure the refreshed value is set into loadingValueReference
 *before* returning newValue from the cache query.
",,"[3450, 3451, 3532, 3452, 3533, 3534]","['            newResult -> {\n', '              LoadingValueReference.this.set(newResult);\n', '              return newResult;\n', '            newResult -> {\n', '              LoadingValueReference.this.set(newResult);\n', '              return newResult;\n']","[3462, 3463, 3544, 3464, 3545, 3465, 3546, 3466, 3547, 3467, 3548, 3549]","['            new com.google.common.base.Function<V, V>() {\n', '              @Override\n', '              public V apply(V newValue) {\n', '                LoadingValueReference.this.set(newValue);\n', '                return newValue;\n', '              }\n', '            new Function<V, V>() {\n', '              @Override\n', '              public V apply(V newValue) {\n', '                LoadingValueReference.this.set(newValue);\n', '                return newValue;\n', '              }\n']",/home/pritish/Documents/IP work/guv_ver/v30.1.1/fcca066e6d1ea878d1d5703524a67c3cdeb1d586/LocalCache_2,guava/src/com/google/common/cache/LocalCache.java,"public ListenableFuture<V> loadFuture(K key, CacheLoader<? super K, V> loader)",fcca066e6d1ea878d1d5703524a67c3cdeb1d586/Codes_neg/Match_olddocfunccode_fcca066e6d1ea878d1d5703524a67c3cdeb1d586_2.txt,fcca066e6d1ea878d1d5703524a67c3cdeb1d586/Codes_neg/Match_newdocfunccode_fcca066e6d1ea878d1d5703524a67c3cdeb1d586_2.txt," safely limiting the kinds of caches this can produce
",fcca066e6d1ea878d1d5703524a67c3cdeb1d586/Codes_neg/Match_newdocnewJdoc_fcca066e6d1ea878d1d5703524a67c3cdeb1d586_2.txt," safely limiting the kinds of caches this can produce
",fcca066e6d1ea878d1d5703524a67c3cdeb1d586/Codes_neg/Match_olddocJdoc_fcca066e6d1ea878d1d5703524a67c3cdeb1d586_2.txt,"[832, 833, 834, 835, 932, 933, 934, 935, 936, 831]","['   * same instance, but only the returned reference has the correct generic type information to\n', '   * ensure type safety. For best results, use the standard method-chaining idiom illustrated in the\n', '   * class documentation above, configuring a builder and building your cache in a single statement.\n', '   * Failure to heed this advice can result in a {@link ClassCastException} being thrown by a cache\n', '   * operation at some <i>undefined</i> point in the future.\n', '   * same instance, but only the returned reference has the correct generic type information to\n', '   * ensure type safety. For best results, use the standard method-chaining idiom illustrated in the\n', '   * class documentation above, configuring a builder and building your cache in a single statement.\n', '   * Failure to heed this advice can result in a {@link ClassCastException} being thrown by a cache\n', '   * operation at some <i>undefined</i> point in the future.\n']","[832, 929, 930, 931, 932, 933, 828, 829, 830, 831]","['            new com.google.common.base.Function<V, V>() {\n', '              @Override\n', '              public V apply(V newValue) {\n', '                LoadingValueReference.this.set(newValue);\n', '                return newValue;\n', '              }\n', '            new Function<V, V>() {\n', '              @Override\n', '              public V apply(V newValue) {\n', '                LoadingValueReference.this.set(newValue);\n', '                return newValue;\n', '              }\n']",/home/pritish/Documents/IP work/guv_ver/v30.1.1/fcca066e6d1ea878d1d5703524a67c3cdeb1d586/CacheBuilder,android/guava/src/com/google/common/cache/CacheBuilder.java,"public CacheBuilder<K1, V1> removalListener(RemovalListener<? super K1, ? super V1> listener)",1,1,fcca066e6d1ea878d1d5703524a67c3cdeb1d586
8,36d53edd09f561ec14464a897a03f2b4f26fc0b3/Codes_neg/Match_oldfunccode_36d53edd09f561ec14464a897a03f2b4f26fc0b3_1.txt,,,," Can't use Streams.stream() from base
",36d53edd09f561ec14464a897a03f2b4f26fc0b3/Codes_neg/Match_oldfuncoldJdoc_36d53edd09f561ec14464a897a03f2b4f26fc0b3_1.txt,[],[],"[435, 436, 438, 439]","['  @Beta\n', '  public Stream<String> splitToStream(CharSequence sequence) {\n', '    return StreamSupport.stream(split(sequence).spliterator(), false);\n', '  }\n']",/home/pritish/Documents/IP work/guv_ver/v30.1.1/36d53edd09f561ec14464a897a03f2b4f26fc0b3/Splitter,guava/src/com/google/common/base/Splitter.java,public Stream<String> splitToStream(CharSequence sequence),36d53edd09f561ec14464a897a03f2b4f26fc0b3/Codes_neg/Match_olddocfunccode_36d53edd09f561ec14464a897a03f2b4f26fc0b3_1.txt,36d53edd09f561ec14464a897a03f2b4f26fc0b3/Codes_neg/Match_newdocfunccode_36d53edd09f561ec14464a897a03f2b4f26fc0b3_1.txt,,36d53edd09f561ec14464a897a03f2b4f26fc0b3/Codes_neg/Match_newdocnewJdoc_36d53edd09f561ec14464a897a03f2b4f26fc0b3_1.txt,,36d53edd09f561ec14464a897a03f2b4f26fc0b3/Codes_neg/Match_olddocJdoc_36d53edd09f561ec14464a897a03f2b4f26fc0b3_1.txt,[375],['   * {@link #splitToList(CharSequence)}.\n'],[377],"['  @Beta\n', '  public Stream<String> splitToStream(CharSequence sequence) {\n', '    return StreamSupport.stream(split(sequence).spliterator(), false);\n', '  }\n']",/home/pritish/Documents/IP work/guv_ver/v30.1.1/36d53edd09f561ec14464a897a03f2b4f26fc0b3/Splitter,guava/src/com/google/common/base/Splitter.java,public Iterable<String> split(final CharSequence sequence),1,1,36d53edd09f561ec14464a897a03f2b4f26fc0b3
9,32f2d770f7117015385083ec6e755336ddf18f21/Codes_neg/Match_oldfunccode_32f2d770f7117015385083ec6e755336ddf18f21_1.txt,,,,,,[],[],"[419, 420, 421, 422, 423, 424, 425, 426, 427, 428, 529, 530, 531, 532, 533, 534]","['      @Override\n', '      public N next() {\n', '        N current = queue.remove();\n', '        for (N neighbor : graph.successors(current)) {\n', '          if (visited.add(neighbor)) {\n', '            queue.add(neighbor);\n', '          }\n', '        }\n', '        return current;\n', '      }\n', '      @Override\n', '      public N next() {\n', '        N current = queue.remove();\n', '        Iterables.addAll(queue, tree.successors(current));\n', '        return current;\n', '      }\n', '      @Override\n', '      public N next() {\n', '        N current = queue.remove();\n', '        for (N neighbor : graph.successors(current)) {\n', '          if (visited.add(neighbor)) {\n', '            queue.add(neighbor);\n', '          }\n', '        }\n', '        return current;\n', '      }\n', '      @Override\n', '      public N next() {\n', '        N current = queue.remove();\n', '        Iterables.addAll(queue, tree.successors(current));\n', '        return current;\n', '      }\n']",/home/pritish/Documents/IP work/guv_ver/v30.1.1/32f2d770f7117015385083ec6e755336ddf18f21/Traverser,android/guava/src/com/google/common/graph/Traverser.java,public N next(),32f2d770f7117015385083ec6e755336ddf18f21/Codes_neg/Match_olddocfunccode_32f2d770f7117015385083ec6e755336ddf18f21_1.txt,32f2d770f7117015385083ec6e755336ddf18f21/Codes_neg/Match_newdocfunccode_32f2d770f7117015385083ec6e755336ddf18f21_1.txt,,32f2d770f7117015385083ec6e755336ddf18f21/Codes_neg/Match_newdocnewJdoc_32f2d770f7117015385083ec6e755336ddf18f21_1.txt,,32f2d770f7117015385083ec6e755336ddf18f21/Codes_neg/Match_olddocJdoc_32f2d770f7117015385083ec6e755336ddf18f21_1.txt,[469],"['     * Null is returned to indicate reaching the end of the top iterator.\n', '     * Null is returned to indicate reaching the end of the top iterator.\n']","[625, 626, 627]","['      @Override\n', '      public N next() {\n', '        N current = queue.remove();\n', '        for (N neighbor : graph.successors(current)) {\n', '          if (visited.add(neighbor)) {\n', '            queue.add(neighbor);\n', '          }\n', '        }\n', '        return current;\n', '      }\n', '      @Override\n', '      public N next() {\n', '        N current = queue.remove();\n', '        Iterables.addAll(queue, tree.successors(current));\n', '        return current;\n', '      }\n', '      @Override\n', '      public N next() {\n', '        N current = queue.remove();\n', '        for (N neighbor : graph.successors(current)) {\n', '          if (visited.add(neighbor)) {\n', '            queue.add(neighbor);\n', '          }\n', '        }\n', '        return current;\n', '      }\n', '      @Override\n', '      public N next() {\n', '        N current = queue.remove();\n', '        Iterables.addAll(queue, tree.successors(current));\n', '        return current;\n', '      }\n']",/home/pritish/Documents/IP work/guv_ver/v30.1.1/32f2d770f7117015385083ec6e755336ddf18f21/Traverser,android/guava/src/com/google/common/graph/Traverser.java, abstract N visitNext(Deque<Iterator<? extends N>> horizon),1,1,32f2d770f7117015385083ec6e755336ddf18f21
10,ba44e3996d619f506f53f4c26309abe16f688cc2/Codes_neg/Match_oldfunccode_ba44e3996d619f506f53f4c26309abe16f688cc2_1.txt,ba44e3996d619f506f53f4c26309abe16f688cc2/Codes_neg/Match_newfunccode_ba44e3996d619f506f53f4c26309abe16f688cc2_1.txt,,ba44e3996d619f506f53f4c26309abe16f688cc2/Codes_neg/Match_newfuncnewJdoc_ba44e3996d619f506f53f4c26309abe16f688cc2_1.txt,,ba44e3996d619f506f53f4c26309abe16f688cc2/Codes_neg/Match_oldfuncoldJdoc_ba44e3996d619f506f53f4c26309abe16f688cc2_1.txt,[1747],"['  @Nullable V getLiveValue(ReferenceEntry<K, V> entry, long now) {\n']","[1747, 1748]","['  @Nullable\n', '  V getLiveValue(ReferenceEntry<K, V> entry, long now) {\n']",/home/pritish/Documents/IP work/guv_ver/v30.1.1/ba44e3996d619f506f53f4c26309abe16f688cc2/LocalCache_2,guava/src/com/google/common/cache/LocalCache.java," V getLiveValue(ReferenceEntry<K, V> entry, long now)",ba44e3996d619f506f53f4c26309abe16f688cc2/Codes_neg/Match_olddocfunccode_ba44e3996d619f506f53f4c26309abe16f688cc2_1.txt,ba44e3996d619f506f53f4c26309abe16f688cc2/Codes_neg/Match_newdocfunccode_ba44e3996d619f506f53f4c26309abe16f688cc2_1.txt," safely limiting the kinds of caches this can produce
",ba44e3996d619f506f53f4c26309abe16f688cc2/Codes_neg/Match_newdocnewJdoc_ba44e3996d619f506f53f4c26309abe16f688cc2_1.txt," safely limiting the kinds of caches this can produce
",ba44e3996d619f506f53f4c26309abe16f688cc2/Codes_neg/Match_olddocJdoc_ba44e3996d619f506f53f4c26309abe16f688cc2_1.txt,"[822, 823, 824, 825, 826, 923, 924, 925, 926, 927]","['   * same instance, but only the returned reference has the correct generic type information to\n', '   * ensure type safety. For best results, use the standard method-chaining idiom illustrated in the\n', '   * class documentation above, configuring a builder and building your cache in a single statement.\n', '   * Failure to heed this advice can result in a {@link ClassCastException} being thrown by a cache\n', '   * operation at some <i>undefined</i> point in the future.\n', '   * same instance, but only the returned reference has the correct generic type information to\n', '   * ensure type safety. For best results, use the standard method-chaining idiom illustrated in the\n', '   * class documentation above, configuring a builder and building your cache in a single statement.\n', '   * Failure to heed this advice can result in a {@link ClassCastException} being thrown by a cache\n', '   * operation at some <i>undefined</i> point in the future.\n']","[832, 929, 930, 931, 932, 933, 828, 829, 830, 831]","['  @Nullable\n', '  V getLiveValue(ReferenceEntry<K, V> entry, long now) {\n']",/home/pritish/Documents/IP work/guv_ver/v30.1.1/ba44e3996d619f506f53f4c26309abe16f688cc2/CacheBuilder,android/guava/src/com/google/common/cache/CacheBuilder.java,"public CacheBuilder<K1, V1> removalListener(RemovalListener<? super K1, ? super V1> listener)",1,1,ba44e3996d619f506f53f4c26309abe16f688cc2
11,53fd1d7612a96053e6e0b68dac86531b0d697497/Codes_neg/Match_oldfunccode_53fd1d7612a96053e6e0b68dac86531b0d697497_1.txt,53fd1d7612a96053e6e0b68dac86531b0d697497/Codes_neg/Match_newfunccode_53fd1d7612a96053e6e0b68dac86531b0d697497_1.txt," Exactly 1 colon. Split into host:port.
 0 or 2+ colons. Bare hostname or IPv6 literal.
 Try to parse the whole port string as a number.
 JDK7 accepts leading plus signs. We don't want to.
",53fd1d7612a96053e6e0b68dac86531b0d697497/Codes_neg/Match_newfuncnewJdoc_53fd1d7612a96053e6e0b68dac86531b0d697497_1.txt," Exactly 1 colon. Split into host:port.
 0 or 2+ colons. Bare hostname or IPv6 literal.
 Try to parse the whole port string as a number.
 JDK7 accepts leading plus signs. We don't want to.
",53fd1d7612a96053e6e0b68dac86531b0d697497/Codes_neg/Match_oldfuncoldJdoc_53fd1d7612a96053e6e0b68dac86531b0d697497_1.txt,"[194, 195, 196, 197]","['      checkArgument(\n', '          !portString.startsWith(""+"") && CharMatcher.ascii().matchesAllOf(portString),\n', '          ""Unparseable port number: %s"",\n', '          hostPortString);\n', '      checkArgument(\n', '          !portString.startsWith(""+"") && CharMatcher.ascii().matchesAllOf(portString),\n', '          ""Unparseable port number: %s"",\n', '          hostPortString);\n']",[193],"['      checkArgument(!portString.startsWith(""+""), ""Unparseable port number: %s"", hostPortString);\n', '      checkArgument(!portString.startsWith(""+""), ""Unparseable port number: %s"", hostPortString);\n']",/home/pritish/Documents/IP work/guv_ver/v30.1.1/53fd1d7612a96053e6e0b68dac86531b0d697497/HostAndPort_2,guava/src/com/google/common/net/HostAndPort.java,public static HostAndPort fromString(String hostPortString),53fd1d7612a96053e6e0b68dac86531b0d697497/Codes_neg/Match_olddocfunccode_53fd1d7612a96053e6e0b68dac86531b0d697497_1.txt,53fd1d7612a96053e6e0b68dac86531b0d697497/Codes_neg/Match_newdocfunccode_53fd1d7612a96053e6e0b68dac86531b0d697497_1.txt,,53fd1d7612a96053e6e0b68dac86531b0d697497/Codes_neg/Match_newdocnewJdoc_53fd1d7612a96053e6e0b68dac86531b0d697497_1.txt,,53fd1d7612a96053e6e0b68dac86531b0d697497/Codes_neg/Match_olddocJdoc_53fd1d7612a96053e6e0b68dac86531b0d697497_1.txt,"[162, 163, 164, 165, 166]","['   * <p>This method accepts non-ASCII digits, for example {@code ""１９２.１６８.０.１""} (those are fullwidth\n', '   * characters). That is consistent with {@link InetAddress}, but not with various RFCs. If you\n', '   * want to accept ASCII digits only, you can use something like {@code\n', '   * CharMatcher.ascii().matchesAllOf(ipString)}.\n', '   *\n', '   * <p>This method accepts non-ASCII digits, for example {@code ""１９２.１６８.０.１""} (those are fullwidth\n', '   * characters). That is consistent with {@link InetAddress}, but not with various RFCs. If you\n', '   * want to accept ASCII digits only, you can use something like {@code\n', '   * CharMatcher.ascii().matchesAllOf(ipString)}.\n', '   *\n']",[],"['      checkArgument(!portString.startsWith(""+""), ""Unparseable port number: %s"", hostPortString);\n', '      checkArgument(!portString.startsWith(""+""), ""Unparseable port number: %s"", hostPortString);\n']",/home/pritish/Documents/IP work/guv_ver/v30.1.1/53fd1d7612a96053e6e0b68dac86531b0d697497/InetAddresses_2,guava/src/com/google/common/net/InetAddresses.java,public static boolean isInetAddress(String ipString),1,1,53fd1d7612a96053e6e0b68dac86531b0d697497
12,53fd1d7612a96053e6e0b68dac86531b0d697497/Codes_neg/Match_oldfunccode_53fd1d7612a96053e6e0b68dac86531b0d697497_2.txt,53fd1d7612a96053e6e0b68dac86531b0d697497/Codes_neg/Match_newfunccode_53fd1d7612a96053e6e0b68dac86531b0d697497_2.txt," Exactly 1 colon. Split into host:port.
 0 or 2+ colons. Bare hostname or IPv6 literal.
 Try to parse the whole port string as a number.
 JDK7 accepts leading plus signs. We don't want to.
 Exactly 1 colon. Split into host:port.
 0 or 2+ colons. Bare hostname or IPv6 literal.
 Try to parse the whole port string as a number.
 JDK7 accepts leading plus signs. We don't want to.
",53fd1d7612a96053e6e0b68dac86531b0d697497/Codes_neg/Match_newfuncnewJdoc_53fd1d7612a96053e6e0b68dac86531b0d697497_2.txt," Exactly 1 colon. Split into host:port.
 0 or 2+ colons. Bare hostname or IPv6 literal.
 Try to parse the whole port string as a number.
 JDK7 accepts leading plus signs. We don't want to.
 Exactly 1 colon. Split into host:port.
 0 or 2+ colons. Bare hostname or IPv6 literal.
 Try to parse the whole port string as a number.
 JDK7 accepts leading plus signs. We don't want to.
",53fd1d7612a96053e6e0b68dac86531b0d697497/Codes_neg/Match_oldfuncoldJdoc_53fd1d7612a96053e6e0b68dac86531b0d697497_2.txt,"[194, 195, 196, 197]","['      checkArgument(\n', '          !portString.startsWith(""+"") && CharMatcher.ascii().matchesAllOf(portString),\n', '          ""Unparseable port number: %s"",\n', '          hostPortString);\n', '      checkArgument(\n', '          !portString.startsWith(""+"") && CharMatcher.ascii().matchesAllOf(portString),\n', '          ""Unparseable port number: %s"",\n', '          hostPortString);\n']",[193],"['      checkArgument(!portString.startsWith(""+""), ""Unparseable port number: %s"", hostPortString);\n', '      checkArgument(!portString.startsWith(""+""), ""Unparseable port number: %s"", hostPortString);\n']",/home/pritish/Documents/IP work/guv_ver/v30.1.1/53fd1d7612a96053e6e0b68dac86531b0d697497/HostAndPort_2,guava/src/com/google/common/net/HostAndPort.java,public static HostAndPort fromString(String hostPortString),53fd1d7612a96053e6e0b68dac86531b0d697497/Codes_neg/Match_olddocfunccode_53fd1d7612a96053e6e0b68dac86531b0d697497_2.txt,53fd1d7612a96053e6e0b68dac86531b0d697497/Codes_neg/Match_newdocfunccode_53fd1d7612a96053e6e0b68dac86531b0d697497_2.txt," Fixup to avoid some ""illegal"" values. Currently the only potential
 Special cases:
 ::1
 ::0
 Just extract the high 64 bits (assuming the rest is user-modifiable).
 Many strategies for hashing are possible. This might suffice for now.
 Squash into 224/4 Multicast and 240/4 Reserved space (i.e. 224/3).
 illegal value is 255.255.255.255.
",53fd1d7612a96053e6e0b68dac86531b0d697497/Codes_neg/Match_newdocnewJdoc_53fd1d7612a96053e6e0b68dac86531b0d697497_2.txt," Fixup to avoid some ""illegal"" values. Currently the only potential
 Special cases:
 ::1
 ::0
 Just extract the high 64 bits (assuming the rest is user-modifiable).
 Many strategies for hashing are possible. This might suffice for now.
 Squash into 224/4 Multicast and 240/4 Reserved space (i.e. 224/3).
 illegal value is 255.255.255.255.
",53fd1d7612a96053e6e0b68dac86531b0d697497/Codes_neg/Match_olddocJdoc_53fd1d7612a96053e6e0b68dac86531b0d697497_2.txt,"[898, 908]","['   * This method does so by hashing 64 bits of the IPv6 address into {@code 224.0.0.0/3} (64 bits\n', '   * <p>NOTE: This method is failsafe for security purposes: ALL IPv6 addresses (except localhost\n', '   * This method does so by hashing 64 bits of the IPv6 address into {@code 224.0.0.0/3} (64 bits\n', '   * <p>NOTE: This method is failsafe for security purposes: ALL IPv6 addresses (except localhost\n']","[884, 874]","['      checkArgument(!portString.startsWith(""+""), ""Unparseable port number: %s"", hostPortString);\n', '      checkArgument(!portString.startsWith(""+""), ""Unparseable port number: %s"", hostPortString);\n']",/home/pritish/Documents/IP work/guv_ver/v30.1.1/53fd1d7612a96053e6e0b68dac86531b0d697497/InetAddresses_2,guava/src/com/google/common/net/InetAddresses.java,public static Inet4Address getCoercedIPv4Address(InetAddress ip),1,1,53fd1d7612a96053e6e0b68dac86531b0d697497
13,,845c97429eb25924c2d7f6749b533fa6297aaee1/Codes_neg/Match_newfunccode_845c97429eb25924c2d7f6749b533fa6297aaee1_1.txt,,845c97429eb25924c2d7f6749b533fa6297aaee1/Codes_neg/Match_newfuncnewJdoc_845c97429eb25924c2d7f6749b533fa6297aaee1_1.txt,,,"[163, 164, 165, 166, 167, 168, 169, 170, 171, 172, 173]","['  <N1 extends N> ValueGraphBuilder<N1, V> incidentEdgeOrder(ElementOrder<N1> incidentEdgeOrder) {\n', '    checkArgument(\n', '        incidentEdgeOrder.type() == ElementOrder.Type.UNORDERED\n', '            || incidentEdgeOrder.type() == ElementOrder.Type.STABLE,\n', '        ""The given elementOrder (%s) is unsupported. incidentEdgeOrder() only supports""\n', '            + "" ElementOrder.unordered() and ElementOrder.stable()."",\n', '        incidentEdgeOrder);\n', '    ValueGraphBuilder<N1, V> newBuilder = cast();\n', '    newBuilder.incidentEdgeOrder = checkNotNull(incidentEdgeOrder);\n', '    return newBuilder;\n', '  }\n', '  <N1 extends N> ValueGraphBuilder<N1, V> incidentEdgeOrder(ElementOrder<N1> incidentEdgeOrder) {\n', '    checkArgument(\n', '        incidentEdgeOrder.type() == ElementOrder.Type.UNORDERED\n', '            || incidentEdgeOrder.type() == ElementOrder.Type.STABLE,\n', '        ""The given elementOrder (%s) is unsupported. incidentEdgeOrder() only supports""\n', '            + "" ElementOrder.unordered() and ElementOrder.stable()."",\n', '        incidentEdgeOrder);\n', '    ValueGraphBuilder<N1, V> newBuilder = cast();\n', '    newBuilder.incidentEdgeOrder = checkNotNull(incidentEdgeOrder);\n', '    return newBuilder;\n', '  }\n']",[],[],/home/pritish/Documents/IP work/guv_ver/v30.1.1/845c97429eb25924c2d7f6749b533fa6297aaee1/ValueGraphBuilder_2,guava/src/com/google/common/graph/ValueGraphBuilder.java," ValueGraphBuilder<N1, V> incidentEdgeOrder(ElementOrder<N1> incidentEdgeOrder)",845c97429eb25924c2d7f6749b533fa6297aaee1/Codes_neg/Match_olddocfunccode_845c97429eb25924c2d7f6749b533fa6297aaee1_1.txt,845c97429eb25924c2d7f6749b533fa6297aaee1/Codes_neg/Match_newdocfunccode_845c97429eb25924c2d7f6749b533fa6297aaee1_1.txt,,845c97429eb25924c2d7f6749b533fa6297aaee1/Codes_neg/Match_newdocnewJdoc_845c97429eb25924c2d7f6749b533fa6297aaee1_1.txt,,845c97429eb25924c2d7f6749b533fa6297aaee1/Codes_neg/Match_olddocJdoc_845c97429eb25924c2d7f6749b533fa6297aaee1_1.txt,"[107, 108, 109]","['   * <p>Note that the returned builder will always have {@link #incidentEdgeOrder} set to {@link\n', '   * ElementOrder#stable()}, regardless of the value that was set in this builder.\n', '   *\n', '   * <p>Note that the returned builder will always have {@link #incidentEdgeOrder} set to {@link\n', '   * ElementOrder#stable()}, regardless of the value that was set in this builder.\n', '   *\n']",[],[],/home/pritish/Documents/IP work/guv_ver/v30.1.1/845c97429eb25924c2d7f6749b533fa6297aaee1/ValueGraphBuilder_2,guava/src/com/google/common/graph/ValueGraphBuilder.java,"public ImmutableValueGraph.Builder<N1, V1> immutable()",1,1,845c97429eb25924c2d7f6749b533fa6297aaee1
14,,0c40611d201488ee016fd132c90a636323f9f42c/Codes_neg/Match_newfunccode_0c40611d201488ee016fd132c90a636323f9f42c_1.txt,,0c40611d201488ee016fd132c90a636323f9f42c/Codes_neg/Match_newfuncnewJdoc_0c40611d201488ee016fd132c90a636323f9f42c_1.txt,,,[687],"['  public final boolean remove(@CheckForNull Object key, @CheckForNull Object value) {\n']",[],[],/home/pritish/Documents/IP work/guv_ver/v30.1.1/0c40611d201488ee016fd132c90a636323f9f42c/ImmutableMap_2,guava/src/com/google/common/collect/ImmutableMap.java,"public final boolean remove(@CheckForNull Object key, @CheckForNull Object value)",0c40611d201488ee016fd132c90a636323f9f42c/Codes_neg/Match_olddocfunccode_0c40611d201488ee016fd132c90a636323f9f42c_1.txt,0c40611d201488ee016fd132c90a636323f9f42c/Codes_neg/Match_newdocfunccode_0c40611d201488ee016fd132c90a636323f9f42c_1.txt," Safe as long as the javadocs are followed
",0c40611d201488ee016fd132c90a636323f9f42c/Codes_neg/Match_newdocnewJdoc_0c40611d201488ee016fd132c90a636323f9f42c_1.txt," Safe as long as the javadocs are followed
",0c40611d201488ee016fd132c90a636323f9f42c/Codes_neg/Match_olddocJdoc_0c40611d201488ee016fd132c90a636323f9f42c_1.txt,"[41, 42, 43, 44, 45]","['   *\n', ""   * <p>The returned array has all its elements set to their initial null values. However, we don't\n"", ""   * declare it as {@code @Nullable ImmutableMapEntry[]} because our checker doesn't require newly\n"", ""   * created arrays to have a {@code @Nullable} element type even when they're created directly with\n"", '   * {@code new ImmutableMapEntry[...]}, so it seems silly to insist on that only here.\n']",[],[],/home/pritish/Documents/IP work/guv_ver/v30.1.1/0c40611d201488ee016fd132c90a636323f9f42c/ImmutableMapEntry,guava/src/com/google/common/collect/ImmutableMapEntry.java," static ImmutableMapEntry<K, V>[] createEntryArray(int size)",1,1,0c40611d201488ee016fd132c90a636323f9f42c
15,,5a8f19bd3556012ed9e65cd4268a85ddde95733f/Codes_neg/Match_newfunccode_5a8f19bd3556012ed9e65cd4268a85ddde95733f_1.txt," Can't use Streams.stream() from base
",5a8f19bd3556012ed9e65cd4268a85ddde95733f/Codes_neg/Match_newfuncnewJdoc_5a8f19bd3556012ed9e65cd4268a85ddde95733f_1.txt,,,"[435, 436, 438, 439]","['  @Beta\n', '  public Stream<String> splitToStream(CharSequence sequence) {\n', '    return StreamSupport.stream(split(sequence).spliterator(), false);\n', '  }\n']",[],[],/home/pritish/Documents/IP work/guv_ver/v30.1.1/5a8f19bd3556012ed9e65cd4268a85ddde95733f/Splitter,guava/src/com/google/common/base/Splitter.java,public Stream<String> splitToStream(CharSequence sequence),5a8f19bd3556012ed9e65cd4268a85ddde95733f/Codes_neg/Match_olddocfunccode_5a8f19bd3556012ed9e65cd4268a85ddde95733f_1.txt,5a8f19bd3556012ed9e65cd4268a85ddde95733f/Codes_neg/Match_newdocfunccode_5a8f19bd3556012ed9e65cd4268a85ddde95733f_1.txt,,5a8f19bd3556012ed9e65cd4268a85ddde95733f/Codes_neg/Match_newdocnewJdoc_5a8f19bd3556012ed9e65cd4268a85ddde95733f_1.txt,,5a8f19bd3556012ed9e65cd4268a85ddde95733f/Codes_neg/Match_olddocJdoc_5a8f19bd3556012ed9e65cd4268a85ddde95733f_1.txt,[377],['   * {@link #splitToList(CharSequence)}. Java 8 users may prefer {@link #splitToStream} instead.\n'],[375],[],/home/pritish/Documents/IP work/guv_ver/v30.1.1/5a8f19bd3556012ed9e65cd4268a85ddde95733f/Splitter,guava/src/com/google/common/base/Splitter.java,public Iterable<String> split(final CharSequence sequence),1,1,5a8f19bd3556012ed9e65cd4268a85ddde95733f
16,,571bd573ef8c308d63819c8d1bb30b07c2bf0ec8/Codes_neg/Match_newfunccode_571bd573ef8c308d63819c8d1bb30b07c2bf0ec8_1.txt,,571bd573ef8c308d63819c8d1bb30b07c2bf0ec8/Codes_neg/Match_newfuncnewJdoc_571bd573ef8c308d63819c8d1bb30b07c2bf0ec8_1.txt,,,"[193, 164]","['    abstract Cancellable schedule(\n', '    abstract Cancellable schedule(\n']",[],[],/home/pritish/Documents/IP work/guv_ver/v30.1.1/571bd573ef8c308d63819c8d1bb30b07c2bf0ec8/AbstractScheduledService,android/guava/src/com/google/common/util/concurrent/AbstractScheduledService.java," abstract Cancellable schedule(AbstractService service, ScheduledExecutorService executor, Runnable runnable)",571bd573ef8c308d63819c8d1bb30b07c2bf0ec8/Codes_neg/Match_olddocfunccode_571bd573ef8c308d63819c8d1bb30b07c2bf0ec8_1.txt,571bd573ef8c308d63819c8d1bb30b07c2bf0ec8/Codes_neg/Match_newdocfunccode_571bd573ef8c308d63819c8d1bb30b07c2bf0ec8_1.txt,"
         * Lock to ensure that a task cannot be rescheduled while a cancel is ongoing.
         *
         * In theory, cancel() could execute arbitrary listeners -- bad to do while holding a lock.
         * However, we don't expose currentFuture to users, so they can't attach listeners. And the
         * Future might not even be a ListenableFuture, just a plain Future. That said, similar
         * problems can exist with methods like FutureTask.done(), not to mention slow calls to
         * Thread.interrupt() (as discussed in InterruptibleTask). At the end of the day, it's
         * unlikely that cancel() will be slow, so we can probably get away with calling it while
         * holding a lock. Still, it would be nice to avoid somehow.
         
",," Ensure that a task cannot be rescheduled while a cancel is ongoing.
",571bd573ef8c308d63819c8d1bb30b07c2bf0ec8/Codes_neg/Match_olddocJdoc_571bd573ef8c308d63819c8d1bb30b07c2bf0ec8_1.txt,[],[],"[564, 524]",[],/home/pritish/Documents/IP work/guv_ver/v30.1.1/571bd573ef8c308d63819c8d1bb30b07c2bf0ec8/AbstractScheduledService,android/guava/src/com/google/common/util/concurrent/AbstractScheduledService.java,public boolean cancel(boolean mayInterruptIfRunning),1,1,571bd573ef8c308d63819c8d1bb30b07c2bf0ec8
17,,571bd573ef8c308d63819c8d1bb30b07c2bf0ec8/Codes_neg/Match_newfunccode_571bd573ef8c308d63819c8d1bb30b07c2bf0ec8_2.txt," We reschedule ourselves with a lock held for two reasons. 1. we want to make sure that
 cancel calls cancel on the correct future. 2. we want to make sure that the assignment
 to currentFuture doesn't race with itself so that currentFuture is assigned in the
 invoke the callback outside the lock, prevents some shenanigans.
 correct order.
 If an exception is thrown by the subclass then we need to make sure that the service
 notices and transitions to the FAILED state. We do it by calling notifyFailed directly
 because the service does not monitor the state of the future so if the exception is not
 caught and forwarded to the service the task would stop executing but the service would
 have no idea.
 TODO(lukes): consider building everything in terms of ListenableScheduledFuture then
 the AbstractService could monitor the future directly. Rescheduling is still hard...
 but it would help with some of these lock ordering issues.
 Call notifyFailed outside the lock to avoid lock ordering issues.
",571bd573ef8c308d63819c8d1bb30b07c2bf0ec8/Codes_neg/Match_newfuncnewJdoc_571bd573ef8c308d63819c8d1bb30b07c2bf0ec8_2.txt,,,"[544, 576, 545, 515, 547, 548, 584, 585, 522, 555, 525, 562, 565, 536, 507, 508]","['      @CanIgnoreReturnValue\n', '      public Cancellable reschedule() {\n', '          return new FutureAsCancellable<>(immediateCancelledFuture());\n', '        Cancellable toReturn;\n', '          toReturn = initializeOrUpdateCancellationDelegate(schedule);\n', '          toReturn = new FutureAsCancellable<>(immediateCancelledFuture());\n', '        return toReturn;\n', '      }\n', '      @CanIgnoreReturnValue\n', '      public Cancellable reschedule() {\n', '          return new FutureAsCancellable<>(immediateCancelledFuture());\n', '        Cancellable toReturn;\n', '          toReturn = initializeOrUpdateCancellationDelegate(schedule);\n', '          toReturn = new FutureAsCancellable<>(immediateCancelledFuture());\n', '        return toReturn;\n', '      }\n']",[],[],/home/pritish/Documents/IP work/guv_ver/v30.1.1/571bd573ef8c308d63819c8d1bb30b07c2bf0ec8/AbstractScheduledService,android/guava/src/com/google/common/util/concurrent/AbstractScheduledService.java,public Cancellable reschedule(),571bd573ef8c308d63819c8d1bb30b07c2bf0ec8/Codes_neg/Match_olddocfunccode_571bd573ef8c308d63819c8d1bb30b07c2bf0ec8_2.txt,571bd573ef8c308d63819c8d1bb30b07c2bf0ec8/Codes_neg/Match_newdocfunccode_571bd573ef8c308d63819c8d1bb30b07c2bf0ec8_2.txt,"
         * Lock to ensure that a task cannot be rescheduled while a cancel is ongoing.
         *
         * In theory, cancel() could execute arbitrary listeners -- bad to do while holding a lock.
         * However, we don't expose currentFuture to users, so they can't attach listeners. And the
         * Future might not even be a ListenableFuture, just a plain Future. That said, similar
         * problems can exist with methods like FutureTask.done(), not to mention slow calls to
         * Thread.interrupt() (as discussed in InterruptibleTask). At the end of the day, it's
         * unlikely that cancel() will be slow, so we can probably get away with calling it while
         * holding a lock. Still, it would be nice to avoid somehow.
         

         * Lock to ensure that a task cannot be rescheduled while a cancel is ongoing.
         *
         * In theory, cancel() could execute arbitrary listeners -- bad to do while holding a lock.
         * However, we don't expose currentFuture to users, so they can't attach listeners. And the
         * Future might not even be a ListenableFuture, just a plain Future. That said, similar
         * problems can exist with methods like FutureTask.done(), not to mention slow calls to
         * Thread.interrupt() (as discussed in InterruptibleTask). At the end of the day, it's
         * unlikely that cancel() will be slow, so we can probably get away with calling it while
         * holding a lock. Still, it would be nice to avoid somehow.
         
",," Ensure that a task cannot be rescheduled while a cancel is ongoing.
 Ensure that a task cannot be rescheduled while a cancel is ongoing.
",571bd573ef8c308d63819c8d1bb30b07c2bf0ec8/Codes_neg/Match_olddocJdoc_571bd573ef8c308d63819c8d1bb30b07c2bf0ec8_2.txt,[],[],"[564, 524]",[],/home/pritish/Documents/IP work/guv_ver/v30.1.1/571bd573ef8c308d63819c8d1bb30b07c2bf0ec8/AbstractScheduledService,android/guava/src/com/google/common/util/concurrent/AbstractScheduledService.java,public boolean cancel(boolean mayInterruptIfRunning),1,1,571bd573ef8c308d63819c8d1bb30b07c2bf0ec8
18,,2fee65ef8b48a354b1cae71ec32d57c8c8b2d695/Codes_neg/Match_newfunccode_2fee65ef8b48a354b1cae71ec32d57c8c8b2d695_1.txt,,,,,"[176, 177, 178, 179, 180, 181, 174, 175]","['  GraphBuilder<N> copy() {\n', '    GraphBuilder<N> newBuilder = new GraphBuilder<>(directed);\n', '    newBuilder.allowsSelfLoops = allowsSelfLoops;\n', '    newBuilder.nodeOrder = nodeOrder;\n', '    newBuilder.expectedNodeCount = expectedNodeCount;\n', '    newBuilder.incidentEdgeOrder = incidentEdgeOrder;\n', '    return newBuilder;\n', '  }\n', '  GraphBuilder<N> copy() {\n', '    GraphBuilder<N> newBuilder = new GraphBuilder<>(directed);\n', '    newBuilder.allowsSelfLoops = allowsSelfLoops;\n', '    newBuilder.nodeOrder = nodeOrder;\n', '    newBuilder.expectedNodeCount = expectedNodeCount;\n', '    newBuilder.incidentEdgeOrder = incidentEdgeOrder;\n', '    return newBuilder;\n', '  }\n']",[],[],/home/pritish/Documents/IP work/guv_ver/v30.1.1/2fee65ef8b48a354b1cae71ec32d57c8c8b2d695/GraphBuilder_2,guava/src/com/google/common/graph/GraphBuilder.java, GraphBuilder<N> copy(),2fee65ef8b48a354b1cae71ec32d57c8c8b2d695/Codes_neg/Match_olddocfunccode_2fee65ef8b48a354b1cae71ec32d57c8c8b2d695_1.txt,2fee65ef8b48a354b1cae71ec32d57c8c8b2d695/Codes_neg/Match_newdocfunccode_2fee65ef8b48a354b1cae71ec32d57c8c8b2d695_1.txt,,2fee65ef8b48a354b1cae71ec32d57c8c8b2d695/Codes_neg/Match_newdocnewJdoc_2fee65ef8b48a354b1cae71ec32d57c8c8b2d695_1.txt,,2fee65ef8b48a354b1cae71ec32d57c8c8b2d695/Codes_neg/Match_olddocJdoc_2fee65ef8b48a354b1cae71ec32d57c8c8b2d695_1.txt,"[101, 102, 103]","['   * <p>Note that the returned builder will always have {@link #incidentEdgeOrder} set to {@link\n', '   * ElementOrder#stable()}, regardless of the value that was set in this builder.\n', '   *\n', '   * <p>Note that the returned builder will always have {@link #incidentEdgeOrder} set to {@link\n', '   * ElementOrder#stable()}, regardless of the value that was set in this builder.\n', '   *\n']",[],[],/home/pritish/Documents/IP work/guv_ver/v30.1.1/2fee65ef8b48a354b1cae71ec32d57c8c8b2d695/GraphBuilder_2,guava/src/com/google/common/graph/GraphBuilder.java,public ImmutableGraph.Builder<N1> immutable(),1,1,2fee65ef8b48a354b1cae71ec32d57c8c8b2d695
19,88b1bdcb613de9f985cf3f873b7eec0a2e13741b/Codes_neg/Match_oldfunccode_88b1bdcb613de9f985cf3f873b7eec0a2e13741b_1.txt,,,,,,[],[],"[439, 360]","['        public Map<Range, Object> asDescendingMapOfRanges() {\n', '        public Map<Range, Object> asDescendingMapOfRanges() {\n']",/home/pritish/Documents/IP work/guv_ver/v30.1.1/88b1bdcb613de9f985cf3f873b7eec0a2e13741b/TreeRangeMap_2,guava/src/com/google/common/collect/TreeRangeMap.java,"public Map<Range, Object> asDescendingMapOfRanges()",88b1bdcb613de9f985cf3f873b7eec0a2e13741b/Codes_neg/Match_olddocfunccode_88b1bdcb613de9f985cf3f873b7eec0a2e13741b_1.txt,88b1bdcb613de9f985cf3f873b7eec0a2e13741b/Codes_neg/Match_newdocfunccode_88b1bdcb613de9f985cf3f873b7eec0a2e13741b_1.txt,,88b1bdcb613de9f985cf3f873b7eec0a2e13741b/Codes_neg/Match_newdocnewJdoc_88b1bdcb613de9f985cf3f873b7eec0a2e13741b_1.txt,,88b1bdcb613de9f985cf3f873b7eec0a2e13741b/Codes_neg/Match_olddocJdoc_88b1bdcb613de9f985cf3f873b7eec0a2e13741b_1.txt,"[180, 155]","['  // TODO(cpovirk): Consider documenting that IAE on the various methods that can throw it.\n', '  // TODO(cpovirk): Consider documenting that IAE on the various methods that can throw it.\n']",[],"['        public Map<Range, Object> asDescendingMapOfRanges() {\n', '        public Map<Range, Object> asDescendingMapOfRanges() {\n']",/home/pritish/Documents/IP work/guv_ver/v30.1.1/88b1bdcb613de9f985cf3f873b7eec0a2e13741b/RangeMap,android/guava/src/com/google/common/collect/RangeMap.java," RangeMap<K, V> subRangeMap(Range<K> range)",1,1,88b1bdcb613de9f985cf3f873b7eec0a2e13741b
20,,88b1bdcb613de9f985cf3f873b7eec0a2e13741b/Codes_neg/Match_newfunccode_88b1bdcb613de9f985cf3f873b7eec0a2e13741b_2.txt,,,,,"[436, 437, 438, 439]","['        public void merge(\n', '            Range<Comparable<?>> range,\n', '            @CheckForNull Object value,\n', '            BiFunction<? super Object, ? super Object, ? extends Object> remappingFunction) {\n']",[],[],/home/pritish/Documents/IP work/guv_ver/v30.1.1/88b1bdcb613de9f985cf3f873b7eec0a2e13741b/TreeRangeMap_2,guava/src/com/google/common/collect/TreeRangeMap.java,"public void merge(Range<Comparable<?>> range, @CheckForNull Object value, BiFunction<? super Object, ? super Object, ? extends Object> remappingFunction)",88b1bdcb613de9f985cf3f873b7eec0a2e13741b/Codes_neg/Match_olddocfunccode_88b1bdcb613de9f985cf3f873b7eec0a2e13741b_2.txt,88b1bdcb613de9f985cf3f873b7eec0a2e13741b/Codes_neg/Match_newdocfunccode_88b1bdcb613de9f985cf3f873b7eec0a2e13741b_2.txt,,88b1bdcb613de9f985cf3f873b7eec0a2e13741b/Codes_neg/Match_newdocnewJdoc_88b1bdcb613de9f985cf3f873b7eec0a2e13741b_2.txt,,88b1bdcb613de9f985cf3f873b7eec0a2e13741b/Codes_neg/Match_olddocJdoc_88b1bdcb613de9f985cf3f873b7eec0a2e13741b_2.txt,"[180, 155]","['  // TODO(cpovirk): Consider documenting that IAE on the various methods that can throw it.\n', '  // TODO(cpovirk): Consider documenting that IAE on the various methods that can throw it.\n']",[],[],/home/pritish/Documents/IP work/guv_ver/v30.1.1/88b1bdcb613de9f985cf3f873b7eec0a2e13741b/RangeMap,android/guava/src/com/google/common/collect/RangeMap.java," RangeMap<K, V> subRangeMap(Range<K> range)",1,1,88b1bdcb613de9f985cf3f873b7eec0a2e13741b
21,,8149922bb0da0296e819b0c1508a455335e2876e/Codes_neg/Match_newfunccode_8149922bb0da0296e819b0c1508a455335e2876e_1.txt,,8149922bb0da0296e819b0c1508a455335e2876e/Codes_neg/Match_newfuncnewJdoc_8149922bb0da0296e819b0c1508a455335e2876e_1.txt,,,"[65, 66]","['  @CheckForNull\n', '  public final Object invoke(Object proxy, Method method, @CheckForNull @Nullable Object[] args)\n', '  @CheckForNull\n', '  public final Object invoke(Object proxy, Method method, @CheckForNull @Nullable Object[] args)\n']",[],[],/home/pritish/Documents/IP work/guv_ver/v30.1.1/8149922bb0da0296e819b0c1508a455335e2876e/AbstractInvocationHandler_2,guava/src/com/google/common/reflect/AbstractInvocationHandler.java,"public final Object invoke(Object proxy, Method method, @CheckForNull @Nullable Object[] args) throws Throwable",8149922bb0da0296e819b0c1508a455335e2876e/Codes_neg/Match_olddocfunccode_8149922bb0da0296e819b0c1508a455335e2876e_1.txt,8149922bb0da0296e819b0c1508a455335e2876e/Codes_neg/Match_newdocfunccode_8149922bb0da0296e819b0c1508a455335e2876e_1.txt," If there's any type error, we'd report now rather than later.
",8149922bb0da0296e819b0c1508a455335e2876e/Codes_neg/Match_newdocnewJdoc_8149922bb0da0296e819b0c1508a455335e2876e_1.txt," If there's any type error, we'd report now rather than later.
",8149922bb0da0296e819b0c1508a455335e2876e/Codes_neg/Match_olddocJdoc_8149922bb0da0296e819b0c1508a455335e2876e_1.txt,"[225, 226, 227, 228, 229, 230, 231, 232, 233, 234, 235]","['  /*\n', '   * TODO(cpovirk): Is there any way for us to support TypeParameter instances for type parameters\n', '   * that have nullable bounds? Unfortunately, if we change the parameter to TypeParameter<? extends\n', '   * @Nullable X>, then users might pass a TypeParameter<Y>, where Y is a subtype of X, while still\n', '   * passing a TypeToken<X>. This would be invalid. Maybe we could accept a TypeParameter<@PolyNull\n', '   * X> if we support such a thing? It would be weird or misleading for users to be able to pass\n', '   * `new TypeParameter<@Nullable T>() {}` and have it act as a plain `TypeParameter<T>`, but\n', '   * hopefully no one would do that, anyway. See also the comment on TypeParameter itself.\n', '   *\n', '   * TODO(cpovirk): Elaborate on this / merge with other comment?\n', '   */\n', '  /*\n', '   * TODO(cpovirk): Is there any way for us to support TypeParameter instances for type parameters\n', '   * that have nullable bounds? Unfortunately, if we change the parameter to TypeParameter<? extends\n', '   * @Nullable X>, then users might pass a TypeParameter<Y>, where Y is a subtype of X, while still\n', '   * passing a TypeToken<X>. This would be invalid. Maybe we could accept a TypeParameter<@PolyNull\n', '   * X> if we support such a thing? It would be weird or misleading for users to be able to pass\n', '   * `new TypeParameter<@Nullable T>() {}` and have it act as a plain `TypeParameter<T>`, but\n', '   * hopefully no one would do that, anyway. See also the comment on TypeParameter itself.\n', '   *\n', '   * TODO(cpovirk): Elaborate on this / merge with other comment?\n', '   */\n']",[],[],/home/pritish/Documents/IP work/guv_ver/v30.1.1/8149922bb0da0296e819b0c1508a455335e2876e/TypeToken,android/guava/src/com/google/common/reflect/TypeToken.java,"public final TypeToken<T> where(TypeParameter<X> typeParam, TypeToken<X> typeArg)",1,1,8149922bb0da0296e819b0c1508a455335e2876e
22,8149922bb0da0296e819b0c1508a455335e2876e/Codes_neg/Match_oldfunccode_8149922bb0da0296e819b0c1508a455335e2876e_2.txt,8149922bb0da0296e819b0c1508a455335e2876e/Codes_neg/Match_newfunccode_8149922bb0da0296e819b0c1508a455335e2876e_2.txt,,,,,"[112, 119]","['      @CheckForNull\n', '      @CheckForNull\n', '      @CheckForNull\n', '      @CheckForNull\n']","[116, 109]","['      @Nullable\n', '      @Nullable\n', '      @NullableDecl\n', '      @NullableDecl\n']",/home/pritish/Documents/IP work/guv_ver/v30.1.1/8149922bb0da0296e819b0c1508a455335e2876e/Types_2,guava/src/com/google/common/reflect/Types.java, Class<?> getOwnerType(Class<?> rawType),8149922bb0da0296e819b0c1508a455335e2876e/Codes_neg/Match_olddocfunccode_8149922bb0da0296e819b0c1508a455335e2876e_2.txt,8149922bb0da0296e819b0c1508a455335e2876e/Codes_neg/Match_newdocfunccode_8149922bb0da0296e819b0c1508a455335e2876e_2.txt," local and anonymous classes are prefixed with number (1,2,3...), anonymous classes are
 entirely numeric whereas local classes have the user supplied name as a suffix
 Since this is a top level class, its simple name is always the part after package name.
",8149922bb0da0296e819b0c1508a455335e2876e/Codes_neg/Match_newdocnewJdoc_8149922bb0da0296e819b0c1508a455335e2876e_2.txt," local and anonymous classes are prefixed with number (1,2,3...), anonymous classes are
 entirely numeric whereas local classes have the user supplied name as a suffix
 Since this is a top level class, its simple name is always the part after package name.
",8149922bb0da0296e819b0c1508a455335e2876e/Codes_neg/Match_olddocJdoc_8149922bb0da0296e819b0c1508a455335e2876e_2.txt,"[320, 316, 318, 319]","['     * <p>Behaves similarly to {@link Class#getSimpleName()} but does not require the class to be\n', '     *\n', '     * <p>But note that this class uses heuristics to identify the simple name. See a related\n', '     * discussion in <a href=""https://github.com/google/guava/issues/3349"">issue 3349</a>.\n', '     * <p>Behaves similarly to {@link Class#getSimpleName()} but does not require the class to be\n', '     *\n', '     * <p>But note that this class uses heuristics to identify the simple name. See a related\n', '     * discussion in <a href=""https://github.com/google/guava/issues/3349"">issue 3349</a>.\n']",[310],"['      @Nullable\n', '      @Nullable\n', '      @NullableDecl\n', '      @NullableDecl\n']",/home/pritish/Documents/IP work/guv_ver/v30.1.1/8149922bb0da0296e819b0c1508a455335e2876e/ClassPath_2,guava/src/com/google/common/reflect/ClassPath.java,public String getSimpleName(),1,1,8149922bb0da0296e819b0c1508a455335e2876e
