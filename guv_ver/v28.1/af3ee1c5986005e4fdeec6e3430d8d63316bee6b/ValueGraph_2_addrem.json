{
    "addition": {
        "238": "   * Returns true if there is an edge that directly connects {@code nodeU} to {@code nodeV}. This is\n",
        "249": "   * Returns true if there is an edge that directly connects {@code endpoints} (in the order, if\n",
        "250": "   * any, specified by {@code endpoints}). This is equivalent to {@code\n",
        "251": "   * edges().contains(endpoints)}.\n",
        "253": "   * <p>Unlike the other {@code EndpointPair}-accepting methods, this method does not throw if the\n",
        "254": "   * endpoints are unordered and the graph is directed; it simply returns {@code false}. This is for\n",
        "255": "   * consistency with the behavior of {@link Collection#contains(Object)} (which does not generally\n",
        "256": "   * throw if the object cannot be present in the collection), and the desire to have this method's\n",
        "257": "   * behavior be compatible with {@code edges().contains(endpoints)}.\n",
        "258": "   *\n",
        "259": "   * @since NEXT\n",
        "260": "   */\n",
        "261": "  @Override\n",
        "262": "  boolean hasEdgeConnecting(EndpointPair<N> endpoints);\n",
        "263": "\n",
        "264": "  /**\n",
        "265": "   * Returns the value of the edge that connects {@code nodeU} to {@code nodeV} (in the order, if\n",
        "266": "   * any, specified by {@code endpoints}), if one is present;\n",
        "267": "   * otherwise, returns {@code Optional.empty()}.\n",
        "276": "   * Returns the value of the edge that connects {@code endpoints} (in the order, if any, specified\n",
        "277": "   * by {@code endpoints}), if one is present; otherwise, returns {@code Optional.empty()}.\n",
        "278": "   *\n",
        "279": "   * <p>If this graph is directed, the endpoints must be ordered.\n",
        "280": "   *\n",
        "281": "   * @throws IllegalArgumentException if either endpoint is not an element of this graph\n",
        "282": "   * @throws IllegalArgumentException if the endpoints are unordered and the graph is directed\n",
        "283": "   * @since NEXT\n",
        "284": "   */\n",
        "285": "  Optional<V> edgeValue(EndpointPair<N> endpoints);\n",
        "286": "\n",
        "287": "  /**\n",
        "288": "   * Returns the value of the edge that connects {@code nodeU} to {@code nodeV}, if one is present;\n",
        "300": "  /**\n",
        "301": "   * Returns the value of the edge that connects {@code endpoints} (in the order, if any, specified\n",
        "302": "   * by {@code endpoints}), if one is present; otherwise, returns {@code defaultValue}.\n",
        "303": "   *\n",
        "304": "   * <p>If this graph is directed, the endpoints must be ordered.\n",
        "305": "   *\n",
        "306": "   * @throws IllegalArgumentException if either endpoint is not an element of this graph\n",
        "307": "   * @throws IllegalArgumentException if the endpoints are unordered and the graph is directed\n",
        "308": "   * @since NEXT\n",
        "309": "   */\n",
        "310": "  @Nullable\n",
        "311": "  V edgeValueOrDefault(EndpointPair<N> endpoints, @Nullable V defaultValue);\n",
        "312": "\n"
    },
    "removed": {
        "238": "   * Returns true if there is an edge directly connecting {@code nodeU} to {@code nodeV}. This is\n",
        "249": "   * Returns the value of the edge connecting {@code nodeU} to {@code nodeV}, if one is present;\n",
        "250": "   * otherwise, returns {@code Optional.empty()}.\n",
        "252": "   * <p>In an undirected graph, this is equal to {@code edgeValue(nodeV, nodeU)}.\n",
        "261": "   * Returns the value of the edge connecting {@code nodeU} to {@code nodeV}, if one is present;\n"
    }
}