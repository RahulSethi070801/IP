{"id": "af3ee1c5986005e4fdeec6e3430d8d63316bee6b", "code": [{"0": "android/guava-tests/test/com/google/common/graph/AbstractDirectedGraphTest.java", "added": {"1": ["import static com.google.common.graph.GraphConstants.ENDPOINTS_MISMATCH;\n", "import static org.junit.Assert.fail;\n"], "2": ["  @Test\n", "  public void hasEdgeConnecting_correct() {\n", "    putEdge(N1, N2);\n", "    assertThat(graph.hasEdgeConnecting(EndpointPair.ordered(N1, N2))).isTrue();\n", "  }\n", "\n", "  @Test\n", "  public void hasEdgeConnecting_backwards() {\n", "    putEdge(N1, N2);\n", "    assertThat(graph.hasEdgeConnecting(EndpointPair.ordered(N2, N1))).isFalse();\n", "  }\n", "\n", "  @Test\n", "  public void hasEdgeConnecting_mismatch() {\n", "    putEdge(N1, N2);\n", "    assertThat(graph.hasEdgeConnecting(EndpointPair.unordered(N1, N2))).isFalse();\n", "    assertThat(graph.hasEdgeConnecting(EndpointPair.unordered(N2, N1))).isFalse();\n", "  }\n", "\n", "  public void putEdge_existingNodes() {\n"], "3": ["  public void putEdge_existingEdgeBetweenSameNodes() {\n", "    assertThat(putEdge(N1, N2)).isTrue();\n", "  @Test\n", "  public void putEdge_orderMismatch() {\n", "    EndpointPair<Integer> endpoints = EndpointPair.unordered(N1, N2);\n", "    try {\n", "      putEdge(endpoints);\n", "      fail(\"Expected IllegalArgumentException: \" + ENDPOINTS_MISMATCH);\n", "    } catch (IllegalArgumentException e) {\n", "      assertThat(e).hasMessageThat().contains(ENDPOINTS_MISMATCH);\n", "    }\n", "  }\n", "\n"], "4": ["\n", "  @Test\n", "  public void removeEdge_orderMismatch() {\n", "    putEdge(N1, N2);\n", "    EndpointPair<Integer> endpoints = EndpointPair.unordered(N1, N2);\n", "    try {\n", "      graph.removeEdge(endpoints);\n", "      fail(\"Expected IllegalArgumentException: \" + ENDPOINTS_MISMATCH);\n", "    } catch (IllegalArgumentException e) {\n", "      assertThat(e).hasMessageThat().contains(ENDPOINTS_MISMATCH);\n", "    }\n", "  }\n"]}, "removed": {"2": ["  public void addEdge_existingNodes() {\n"], "3": ["  public void addEdge_existingEdgeBetweenSameNodes() {\n", "    putEdge(N1, N2);\n"]}, "added_lines": {"1": [19, 21], "2": [73, 74, 75, 76, 77, 78, 79, 80, 81, 82, 83, 84, 85, 86, 87, 88, 89, 90, 91, 95], "3": [104, 105, 109, 110, 111, 112, 113, 114, 115, 116, 117, 118, 119], "4": [134, 135, 136, 137, 138, 139, 140, 141, 142, 143, 144, 145]}, "removed_lines": {"2": [74], "3": [83, 84]}}, {"1": "android/guava-tests/test/com/google/common/graph/AbstractDirectedNetworkTest.java", "added": {"1": ["import static com.google.common.graph.GraphConstants.ENDPOINTS_MISMATCH;\n"], "2": ["  @Test\n", "  public void edges_containsOrderMismatch() {\n", "    addEdge(N1, N2, E12);\n", "    EndpointPair<Integer> endpointsN1N2 = EndpointPair.unordered(N1, N2);\n", "    EndpointPair<Integer> endpointsN2N1 = EndpointPair.unordered(N2, N1);\n", "    assertThat(network.asGraph().edges()).doesNotContain(endpointsN1N2);\n", "    assertThat(network.asGraph().edges()).doesNotContain(endpointsN2N1);\n", "  }\n", "\n", "  @Test\n", "  public void edgesConnecting_orderMismatch() {\n", "    addEdge(N1, N2, E12);\n", "    try {\n", "      Set<String> unused = network.edgesConnecting(EndpointPair.unordered(N1, N2));\n", "      fail(\"Expected IllegalArgumentException: \" + ENDPOINTS_MISMATCH);\n", "    } catch (IllegalArgumentException e) {\n", "      assertThat(e).hasMessageThat().contains(ENDPOINTS_MISMATCH);\n", "    }\n", "  }\n", "\n", "  @Test\n", "  public void edgeConnectingOrNull_orderMismatch() {\n", "    addEdge(N1, N2, E12);\n", "    try {\n", "      String unused = network.edgeConnectingOrNull(EndpointPair.unordered(N1, N2));\n", "      fail(\"Expected IllegalArgumentException: \" + ENDPOINTS_MISMATCH);\n", "    } catch (IllegalArgumentException e) {\n", "      assertThat(e).hasMessageThat().contains(ENDPOINTS_MISMATCH);\n", "    }\n", "  }\n", "\n"], "3": ["      assertThat(e).hasMessageThat().contains(ERROR_REUSE_EDGE);\n", "      assertThat(e).hasMessageThat().contains(ERROR_REUSE_EDGE);\n"], "4": ["      assertThat(e).hasMessageThat().contains(ERROR_PARALLEL_EDGE);\n", "    }\n", "  }\n", "\n", "  @Test\n", "  public void addEdge_orderMismatch() {\n", "    EndpointPair<Integer> endpoints = EndpointPair.unordered(N1, N2);\n", "    try {\n", "      addEdge(endpoints, E12);\n", "      fail(\"Expected IllegalArgumentException: \" + ENDPOINTS_MISMATCH);\n", "    } catch (IllegalArgumentException e) {\n", "      assertThat(e).hasMessageThat().contains(ENDPOINTS_MISMATCH);\n"]}, "removed": {"3": ["      assertThat(e.getMessage()).contains(ERROR_REUSE_EDGE);\n", "      assertThat(e.getMessage()).contains(ERROR_REUSE_EDGE);\n"], "4": ["      assertThat(e.getMessage()).contains(ERROR_PARALLEL_EDGE);\n"]}, "added_lines": {"1": [19], "2": [63, 64, 65, 66, 67, 68, 69, 70, 71, 72, 73, 74, 75, 76, 77, 78, 79, 80, 81, 82, 83, 84, 85, 86, 87, 88, 89, 90, 91, 92, 93], "3": [222, 229], "4": [240, 241, 242, 243, 244, 245, 246, 247, 248, 249, 250, 251]}, "removed_lines": {"3": [190, 197], "4": [208]}}, {"2": "android/guava-tests/test/com/google/common/graph/AbstractGraphTest.java", "added": {"1": ["  @CanIgnoreReturnValue\n", "  protected boolean putEdge(EndpointPair<Integer> endpoints) {\n", "    graph.addNode(endpoints.nodeU());\n", "    graph.addNode(endpoints.nodeV());\n", "    return graph.putEdge(endpoints);\n", "  }\n", "\n"]}, "removed": {}, "added_lines": {"1": [106, 107, 108, 109, 110, 111, 112]}, "removed_lines": {}}, {"3": "android/guava-tests/test/com/google/common/graph/AbstractNetworkTest.java", "added": {"1": ["   * TODO(user): remove the addNode() calls, that's now contractually guaranteed\n", "   *\n"], "2": ["  protected boolean addEdge(EndpointPair<Integer> endpoints, String e) {\n", "    network.addNode(endpoints.nodeU());\n", "    network.addNode(endpoints.nodeV());\n", "    return network.addEdge(endpoints, e);\n", "  }\n", "\n"]}, "removed": {}, "added_lines": {"1": [123, 124], "2": [134, 135, 136, 137, 138, 139]}, "removed_lines": {}}, {"4": "android/guava-tests/test/com/google/common/graph/AbstractUndirectedGraphTest.java", "added": {"1": ["  @Test\n", "  public void hasEdgeConnecting_correct() {\n", "    putEdge(N1, N2);\n", "    assertThat(graph.hasEdgeConnecting(EndpointPair.unordered(N1, N2))).isTrue();\n", "    assertThat(graph.hasEdgeConnecting(EndpointPair.unordered(N2, N1))).isTrue();\n", "  }\n", "\n", "  @Test\n", "  public void hasEdgeConnecting_mismatch() {\n", "    putEdge(N1, N2);\n", "    assertThat(graph.hasEdgeConnecting(EndpointPair.ordered(N1, N2))).isTrue();\n", "    assertThat(graph.hasEdgeConnecting(EndpointPair.ordered(N2, N1))).isTrue();\n", "  }\n", "\n"]}, "removed": {}, "added_lines": {"1": [80, 81, 82, 83, 84, 85, 86, 87, 88, 89, 90, 91, 92, 93]}, "removed_lines": {}}, {"5": "android/guava-tests/test/com/google/common/graph/AbstractUndirectedNetworkTest.java", "added": {"1": ["  private static final EndpointPair<Integer> ENDPOINTS_N1N2 = EndpointPair.ordered(N1, N2);\n", "  private static final EndpointPair<Integer> ENDPOINTS_N2N1 = EndpointPair.ordered(N2, N1);\n"], "2": ["  @Test\n", "  public void edges_containsOrderMismatch() {\n", "    addEdge(N1, N2, E12);\n", "    assertThat(network.asGraph().edges()).contains(ENDPOINTS_N2N1);\n", "    assertThat(network.asGraph().edges()).contains(ENDPOINTS_N1N2);\n", "  }\n", "\n", "  @Test\n", "  public void edgesConnecting_orderMismatch() {\n", "    addEdge(N1, N2, E12);\n", "    assertThat(network.edgesConnecting(ENDPOINTS_N2N1)).containsExactly(E12);\n", "    assertThat(network.edgesConnecting(ENDPOINTS_N1N2)).containsExactly(E12);\n", "  }\n", "\n", "  @Test\n", "  public void edgeConnectingOrNull_orderMismatch() {\n", "    addEdge(N1, N2, E12);\n", "    assertThat(network.edgeConnectingOrNull(ENDPOINTS_N2N1)).isEqualTo(E12);\n", "    assertThat(network.edgeConnectingOrNull(ENDPOINTS_N1N2)).isEqualTo(E12);\n", "  }\n", "\n"], "3": ["    assertThat(addEdge(N1, N2, E12)).isTrue();\n"], "4": ["\n", "  @Test\n", "  public void addEdge_orderMismatch() {\n", "    EndpointPair<Integer> endpoints = EndpointPair.ordered(N1, N2);\n", "    assertThat(addEdge(endpoints, E12)).isTrue();\n", "  }\n"]}, "removed": {"3": ["    addEdge(N1, N2, E12);\n"]}, "added_lines": {"1": [35, 36], "2": [57, 58, 59, 60, 61, 62, 63, 64, 65, 66, 67, 68, 69, 70, 71, 72, 73, 74, 75, 76, 77], "3": [143], "4": [179, 180, 181, 182, 183, 184]}, "removed_lines": {"3": [120]}}, {"6": "android/guava-tests/test/com/google/common/graph/EndpointPairTest.java", "added": {"1": ["  public void endpointPair_undirected_contains() {\n"], "2": ["    // ordered endpoints OK for undirected graph (because ordering is irrelevant)\n", "    assertThat(edges).contains(EndpointPair.ordered(N1, N2));\n", "\n", "    assertThat(edges).doesNotContain(EndpointPair.unordered(N2, N2)); // edge not present\n", "  @Test\n", "  public void endpointPair_directed_contains() {\n", "    MutableGraph<Integer> directedGraph = GraphBuilder.directed().allowsSelfLoops(true).build();\n", "    directedGraph.putEdge(N1, N1);\n", "    directedGraph.putEdge(N1, N2);\n", "    Set<EndpointPair<Integer>> edges = directedGraph.edges();\n", "\n", "    assertThat(edges).hasSize(2);\n", "    assertThat(edges).contains(EndpointPair.ordered(N1, N1));\n", "    assertThat(edges).contains(EndpointPair.ordered(N1, N2));\n", "\n", "    // unordered endpoints not OK for directed graph (undefined behavior)\n", "    assertThat(edges).doesNotContain(EndpointPair.unordered(N1, N2));\n", "\n", "    assertThat(edges).doesNotContain(EndpointPair.ordered(N2, N1)); // wrong order\n", "    assertThat(edges).doesNotContain(EndpointPair.ordered(N2, N2)); // edge not present\n", "    assertThat(edges).doesNotContain(EndpointPair.ordered(N3, N4)); // nodes not in graph\n", "  }\n", "\n"]}, "removed": {"1": ["  public void endpointPair_containment() {\n"], "2": ["    assertThat(edges).doesNotContain(EndpointPair.unordered(N2, N2));\n", "    assertThat(edges).doesNotContain(EndpointPair.ordered(N1, N2)); // graph not directed\n"]}, "added_lines": {"1": [206], "2": [217, 218, 219, 220, 224, 225, 226, 227, 228, 229, 230, 231, 232, 233, 234, 235, 236, 237, 238, 239, 240, 241, 242]}, "removed_lines": {"1": [206], "2": [217, 218]}}, {"7": "android/guava-tests/test/com/google/common/graph/ValueGraphTest.java", "added": {"1": ["import static com.google.common.graph.GraphConstants.ENDPOINTS_MISMATCH;\n", "import static org.junit.Assert.fail;\n"], "2": ["  @Test\n", "  public void hasEdgeConnecting_directed_correct() {\n", "    graph = ValueGraphBuilder.directed().build();\n", "    graph.putEdgeValue(1, 2, \"A\");\n", "    assertThat(graph.hasEdgeConnecting(EndpointPair.ordered(1, 2))).isTrue();\n", "  }\n", "\n", "  @Test\n", "  public void hasEdgeConnecting_directed_backwards() {\n", "    graph = ValueGraphBuilder.directed().build();\n", "    graph.putEdgeValue(1, 2, \"A\");\n", "    assertThat(graph.hasEdgeConnecting(EndpointPair.ordered(2, 1))).isFalse();\n", "  }\n", "\n", "  @Test\n", "  public void hasEdgeConnecting_directed_mismatch() {\n", "    graph = ValueGraphBuilder.directed().build();\n", "    graph.putEdgeValue(1, 2, \"A\");\n", "    assertThat(graph.hasEdgeConnecting(EndpointPair.unordered(1, 2))).isFalse();\n", "    assertThat(graph.hasEdgeConnecting(EndpointPair.unordered(2, 1))).isFalse();\n", "  }\n", "\n", "  @Test\n", "  public void hasEdgeConnecting_undirected_correct() {\n", "    graph = ValueGraphBuilder.undirected().build();\n", "    graph.putEdgeValue(1, 2, \"A\");\n", "    assertThat(graph.hasEdgeConnecting(EndpointPair.unordered(1, 2))).isTrue();\n", "  }\n", "\n", "  @Test\n", "  public void hasEdgeConnecting_undirected_backwards() {\n", "    graph = ValueGraphBuilder.undirected().build();\n", "    graph.putEdgeValue(1, 2, \"A\");\n", "    assertThat(graph.hasEdgeConnecting(EndpointPair.unordered(2, 1))).isTrue();\n", "  }\n", "\n", "  @Test\n", "  public void hasEdgeConnecting_undirected_mismatch() {\n", "    graph = ValueGraphBuilder.undirected().build();\n", "    graph.putEdgeValue(1, 2, \"A\");\n", "    assertThat(graph.hasEdgeConnecting(EndpointPair.ordered(1, 2))).isTrue();\n", "    assertThat(graph.hasEdgeConnecting(EndpointPair.ordered(2, 1))).isTrue();\n", "  }\n", "\n", "  @Test\n", "  public void edgeValueOrDefault_directed_correct() {\n", "    graph = ValueGraphBuilder.directed().build();\n", "    graph.putEdgeValue(1, 2, \"A\");\n", "    assertThat(graph.edgeValueOrDefault(EndpointPair.ordered(1, 2), \"default\")).isEqualTo(\"A\");\n", "  }\n", "\n", "  @Test\n", "  public void edgeValueOrDefault_directed_backwards() {\n", "    graph = ValueGraphBuilder.directed().build();\n", "    graph.putEdgeValue(1, 2, \"A\");\n", "    assertThat(graph.edgeValueOrDefault(EndpointPair.ordered(2, 1), \"default\"))\n", "        .isEqualTo(\"default\");\n", "  }\n", "\n", "  @Test\n", "  public void edgeValueOrDefault_directed_mismatch() {\n", "    graph = ValueGraphBuilder.directed().build();\n", "    graph.putEdgeValue(1, 2, \"A\");\n", "    try {\n", "      String unused = graph.edgeValueOrDefault(EndpointPair.unordered(1, 2), \"default\");\n", "      unused = graph.edgeValueOrDefault(EndpointPair.unordered(2, 1), \"default\");\n", "      fail(\"Expected IllegalArgumentException: \" + ENDPOINTS_MISMATCH);\n", "    } catch (IllegalArgumentException e) {\n", "      assertThat(e).hasMessageThat().contains(ENDPOINTS_MISMATCH);\n", "    }\n", "  }\n", "\n", "  @Test\n", "  public void edgeValueOrDefault_undirected_correct() {\n", "    graph = ValueGraphBuilder.undirected().build();\n", "    graph.putEdgeValue(1, 2, \"A\");\n", "    assertThat(graph.edgeValueOrDefault(EndpointPair.unordered(1, 2), \"default\")).isEqualTo(\"A\");\n", "  }\n", "\n", "  @Test\n", "  public void edgeValueOrDefault_undirected_backwards() {\n", "    graph = ValueGraphBuilder.undirected().build();\n", "    graph.putEdgeValue(1, 2, \"A\");\n", "    assertThat(graph.edgeValueOrDefault(EndpointPair.unordered(2, 1), \"default\")).isEqualTo(\"A\");\n", "  }\n", "\n", "  @Test\n", "  public void edgeValueOrDefault_undirected_mismatch() {\n", "    graph = ValueGraphBuilder.undirected().build();\n", "    graph.putEdgeValue(1, 2, \"A\");\n", "    assertThat(graph.edgeValueOrDefault(EndpointPair.ordered(2, 1), \"default\")).isEqualTo(\"A\");\n", "    assertThat(graph.edgeValueOrDefault(EndpointPair.ordered(2, 1), \"default\")).isEqualTo(\"A\");\n", "  }\n", "\n"], "3": ["  @Test\n", "  public void putEdgeValue_directed_orderMismatch() {\n", "    graph = ValueGraphBuilder.directed().build();\n", "    try {\n", "      graph.putEdgeValue(EndpointPair.unordered(1, 2), \"irrelevant\");\n", "      fail(\"Expected IllegalArgumentException: \" + ENDPOINTS_MISMATCH);\n", "    } catch (IllegalArgumentException e) {\n", "      assertThat(e).hasMessageThat().contains(ENDPOINTS_MISMATCH);\n", "    }\n", "  }\n", "\n", "  @Test\n", "  public void putEdgeValue_undirected_orderMismatch() {\n", "    graph = ValueGraphBuilder.undirected().build();\n", "    assertThat(graph.putEdgeValue(EndpointPair.ordered(1, 2), \"irrelevant\")).isNull();\n", "  }\n", "\n"], "4": ["  @Test\n", "  public void removeEdge_directed_orderMismatch() {\n", "    graph = ValueGraphBuilder.directed().build();\n", "    graph.putEdgeValue(1, 2, \"1->2\");\n", "    graph.putEdgeValue(2, 1, \"2->1\");\n", "    try {\n", "      graph.removeEdge(EndpointPair.unordered(1, 2));\n", "      graph.removeEdge(EndpointPair.unordered(2, 1));\n", "      fail(\"Expected IllegalArgumentException: \" + ENDPOINTS_MISMATCH);\n", "    } catch (IllegalArgumentException e) {\n", "      assertThat(e).hasMessageThat().contains(ENDPOINTS_MISMATCH);\n", "    }\n", "  }\n", "\n", "  @Test\n", "  public void removeEdge_undirected_orderMismatch() {\n", "    graph = ValueGraphBuilder.undirected().build();\n", "    graph.putEdgeValue(1, 2, \"1-2\");\n", "    assertThat(graph.removeEdge(EndpointPair.ordered(1, 2))).isEqualTo(\"1-2\");\n", "  }\n", "\n"]}, "removed": {}, "added_lines": {"1": [19, 22], "2": [116, 117, 118, 119, 120, 121, 122, 123, 124, 125, 126, 127, 128, 129, 130, 131, 132, 133, 134, 135, 136, 137, 138, 139, 140, 141, 142, 143, 144, 145, 146, 147, 148, 149, 150, 151, 152, 153, 154, 155, 156, 157, 158, 159, 160, 161, 162, 163, 164, 165, 166, 167, 168, 169, 170, 171, 172, 173, 174, 175, 176, 177, 178, 179, 180, 181, 182, 183, 184, 185, 186, 187, 188, 189, 190, 191, 192, 193, 194, 195, 196, 197, 198, 199, 200, 201, 202, 203, 204, 205, 206, 207, 208, 209], "3": [220, 221, 222, 223, 224, 225, 226, 227, 228, 229, 230, 231, 232, 233, 234, 235, 236], "4": [276, 277, 278, 279, 280, 281, 282, 283, 284, 285, 286, 287, 288, 289, 290, 291, 292, 293, 294, 295, 296]}, "removed_lines": {}}, {"8": "android/guava/src/com/google/common/graph/AbstractBaseGraph.java", "added": {"1": ["import static com.google.common.graph.GraphConstants.ENDPOINTS_MISMATCH;\n"], "2": ["        return isOrderingCompatible(endpointPair)\n"], "3": ["  @Override\n", "  public boolean hasEdgeConnecting(EndpointPair<N> endpoints) {\n", "    checkNotNull(endpoints);\n", "    if (!isOrderingCompatible(endpoints)) {\n", "      return false;\n", "    }\n", "    N nodeU = endpoints.nodeU();\n", "    N nodeV = endpoints.nodeV();\n", "    return nodes().contains(nodeU) && successors(nodeU).contains(nodeV);\n", "  }\n", "\n", "  /**\n", "   * Throws {@code IllegalArgumentException} if the ordering of {@code endpoints} is not compatible\n", "   * with the directionality of this graph.\n", "   */\n", "  protected final void validateEndpoints(EndpointPair<?> endpoints) {\n", "    checkNotNull(endpoints);\n", "    checkArgument(isOrderingCompatible(endpoints), ENDPOINTS_MISMATCH);\n", "  }\n", "\n", "  protected final boolean isOrderingCompatible(EndpointPair<?> endpoints) {\n", "    return endpoints.isOrdered() || !this.isDirected();\n", "  }\n", "\n"]}, "removed": {"2": ["        return isDirected() == endpointPair.isOrdered()\n"]}, "added_lines": {"1": [22], "2": [93], "3": [135, 136, 137, 138, 139, 140, 141, 142, 143, 144, 145, 146, 147, 148, 149, 150, 151, 152, 153, 154, 155, 156, 157, 158]}, "removed_lines": {"2": [92]}}, {"9": "android/guava/src/com/google/common/graph/AbstractNetwork.java", "added": {"1": ["import static com.google.common.base.Preconditions.checkArgument;\n", "import static com.google.common.base.Preconditions.checkNotNull;\n", "import static com.google.common.graph.GraphConstants.ENDPOINTS_MISMATCH;\n"], "2": ["            return isOrderingCompatible(endpointPair)\n"], "3": ["  @Override\n", "  public Set<E> edgesConnecting(EndpointPair<N> endpoints) {\n", "    validateEndpoints(endpoints);\n", "    return edgesConnecting(endpoints.nodeU(), endpoints.nodeV());\n", "  }\n", "\n"], "4": ["  @Override\n", "  @NullableDecl\n", "  public E edgeConnectingOrNull(EndpointPair<N> endpoints) {\n", "    validateEndpoints(endpoints);\n", "    return edgeConnectingOrNull(endpoints.nodeU(), endpoints.nodeV());\n", "  }\n", "\n", "  @Override\n", "  public boolean hasEdgeConnecting(EndpointPair<N> endpoints) {\n", "    checkNotNull(endpoints);\n", "    if (!isOrderingCompatible(endpoints)) {\n", "      return false;\n", "    }\n", "    return !edgesConnecting(endpoints.nodeU(), endpoints.nodeV()).isEmpty();\n", "  }\n", "\n", "  /**\n", "   * Throws an IllegalArgumentException if the ordering of {@code endpoints} is not compatible\n", "   * with the directionality of this graph.\n", "   */\n", "  protected final void validateEndpoints(EndpointPair<?> endpoints) {\n", "    checkNotNull(endpoints);\n", "    checkArgument(isOrderingCompatible(endpoints), ENDPOINTS_MISMATCH);\n", "  }\n", "\n", "  protected final boolean isOrderingCompatible(EndpointPair<?> endpoints) {\n", "    return endpoints.isOrdered() || !this.isDirected();\n", "  }\n", "\n"]}, "removed": {"2": ["            return isDirected() == endpointPair.isOrdered()\n"]}, "added_lines": {"1": [19, 20, 21], "2": [97], "3": [174, 175, 176, 177, 178, 179], "4": [203, 204, 205, 206, 207, 208, 209, 215, 216, 217, 218, 219, 220, 221, 222, 223, 224, 225, 226, 227, 228, 229, 230, 231, 232, 233, 234, 235, 236]}, "removed_lines": {"2": [94]}}, {"10": "android/guava/src/com/google/common/graph/BaseGraph.java", "added": {"1": ["   * Returns true if there is an edge that directly connects {@code nodeU} to {@code nodeV}. This is\n"], "2": ["\n", "  /**\n", "   * Returns true if there is an edge that directly connects {@code endpoints} (in the order, if\n", "   * any, specified by {@code endpoints}). This is equivalent to {@code\n", "   * edges().contains(endpoints)}.\n", "   *\n", "   * <p>Unlike the other {@code EndpointPair}-accepting methods, this method does not throw if the\n", "   * endpoints are unordered; it simply returns false. This is for consistency with the behavior of\n", "   * {@link Collection#contains(Object)} (which does not generally throw if the object cannot be\n", "   * present in the collection), and the desire to have this method's behavior be compatible with\n", "   * {@code edges().contains(endpoints)}.\n", "   *\n", "   * @since NEXT\n", "   */\n", "  boolean hasEdgeConnecting(EndpointPair<N> endpoints);\n"]}, "removed": {"1": ["   * Returns true if there is an edge directly connecting {@code nodeU} to {@code nodeV}. This is\n"]}, "added_lines": {"1": [139], "2": [147, 148, 149, 150, 151, 152, 153, 154, 155, 156, 157, 158, 159, 160, 161]}, "removed_lines": {"1": [139]}}, {"11": "android/guava/src/com/google/common/graph/ConfigurableMutableGraph.java", "added": {"1": ["  @Override\n", "  public boolean putEdge(EndpointPair<N> endpoints) {\n", "    validateEndpoints(endpoints);\n", "    return putEdge(endpoints.nodeU(), endpoints.nodeV());\n", "  }\n", "\n"], "2": ["\n", "  @Override\n", "  public boolean removeEdge(EndpointPair<N> endpoints) {\n", "    validateEndpoints(endpoints);\n", "    return removeEdge(endpoints.nodeU(), endpoints.nodeV());\n", "  }\n"]}, "removed": {}, "added_lines": {"1": [54, 55, 56, 57, 58, 59], "2": [69, 70, 71, 72, 73, 74]}, "removed_lines": {}}, {"12": "android/guava/src/com/google/common/graph/ConfigurableMutableNetwork.java", "added": {"1": ["  @Override\n", "  @CanIgnoreReturnValue\n", "  public boolean addEdge(EndpointPair<N> endpoints, E edge) {\n", "    validateEndpoints(endpoints);\n", "    return addEdge(endpoints.nodeU(), endpoints.nodeV(), edge);\n", "  }\n", "\n"]}, "removed": {}, "added_lines": {"1": [119, 120, 121, 122, 123, 124, 125]}, "removed_lines": {}}, {"13": "android/guava/src/com/google/common/graph/ConfigurableMutableValueGraph.java", "added": {"1": ["  @Override\n", "  @CanIgnoreReturnValue\n", "  public V putEdgeValue(EndpointPair<N> endpoints, V value) {\n", "    validateEndpoints(endpoints);\n", "    return putEdgeValue(endpoints.nodeU(), endpoints.nodeV(), value);\n", "  }\n", "\n"], "2": ["  @Override\n", "  @CanIgnoreReturnValue\n", "  public V removeEdge(EndpointPair<N> endpoints) {\n", "    validateEndpoints(endpoints);\n", "    return removeEdge(endpoints.nodeU(), endpoints.nodeV());\n", "  }\n", "\n"]}, "removed": {}, "added_lines": {"1": [101, 102, 103, 104, 105, 106, 107], "2": [161, 162, 163, 164, 165, 166, 167]}, "removed_lines": {}}, {"14": "android/guava/src/com/google/common/graph/ConfigurableValueGraph.java", "added": {"1": ["    return hasEdgeConnecting_internal(checkNotNull(nodeU), checkNotNull(nodeV));\n", "  }\n", "\n", "  @Override\n", "  public boolean hasEdgeConnecting(EndpointPair<N> endpoints) {\n", "    checkNotNull(endpoints);\n", "    return isOrderingCompatible(endpoints)\n", "        && hasEdgeConnecting_internal(endpoints.nodeU(), endpoints.nodeV());\n", "    return edgeValueOrDefault_internal(checkNotNull(nodeU), checkNotNull(nodeV), defaultValue);\n", "  }\n", "\n", "  @Override\n", "  @NullableDecl\n", "  public V edgeValueOrDefault(EndpointPair<N> endpoints, @NullableDecl V defaultValue) {\n", "    validateEndpoints(endpoints);\n", "    return edgeValueOrDefault_internal(endpoints.nodeU(), endpoints.nodeV(), defaultValue);\n"], "2": ["\n", "  protected final boolean hasEdgeConnecting_internal(N nodeU, N nodeV) {\n", "    GraphConnections<N, V> connectionsU = nodeConnections.get(nodeU);\n", "    return (connectionsU != null) && connectionsU.successors().contains(nodeV);\n", "  }\n", "\n", "  protected final V edgeValueOrDefault_internal(N nodeU, N nodeV, V defaultValue) {\n", "    GraphConnections<N, V> connectionsU = nodeConnections.get(nodeU);\n", "    V value = (connectionsU == null) ? null : connectionsU.value(nodeV);\n", "    return value == null ? defaultValue : value;\n", "  }\n"]}, "removed": {"1": ["    checkNotNull(nodeU);\n", "    checkNotNull(nodeV);\n", "    GraphConnections<N, V> connectionsU = nodeConnections.get(nodeU);\n", "    return (connectionsU != null) && connectionsU.successors().contains(nodeV);\n", "    checkNotNull(nodeU);\n", "    checkNotNull(nodeV);\n", "    GraphConnections<N, V> connectionsU = nodeConnections.get(nodeU);\n", "    V value = (connectionsU == null) ? null : connectionsU.value(nodeV);\n", "    return value == null ? defaultValue : value;\n"]}, "added_lines": {"1": [119, 120, 121, 122, 123, 124, 125, 126, 132, 133, 134, 135, 136, 137, 138, 139], "2": [159, 160, 161, 162, 163, 164, 165, 166, 167, 168, 169]}, "removed_lines": {"1": [119, 120, 121, 122, 128, 129, 130, 131, 132]}}, {"15": "android/guava/src/com/google/common/graph/ForwardingGraph.java", "added": {"1": ["\n", "  @Override\n", "  public boolean hasEdgeConnecting(EndpointPair<N> endpoints) {\n", "    return delegate().hasEdgeConnecting(endpoints);\n", "  }\n"]}, "removed": {}, "added_lines": {"1": [94, 95, 96, 97, 98]}, "removed_lines": {}}, {"16": "android/guava/src/com/google/common/graph/ForwardingNetwork.java", "added": {"1": ["  @Override\n", "  public Set<E> edgesConnecting(EndpointPair<N> endpoints) {\n", "    return delegate().edgesConnecting(endpoints);\n", "  }\n", "\n", "  @Override\n", "  public E edgeConnectingOrNull(EndpointPair<N> endpoints) {\n", "    return delegate().edgeConnectingOrNull(endpoints);\n", "  }\n", "\n", "\n", "  @Override\n", "  public boolean hasEdgeConnecting(EndpointPair<N> endpoints) {\n", "    return delegate().hasEdgeConnecting(endpoints);\n", "  }\n"]}, "removed": {}, "added_lines": {"1": [127, 128, 129, 130, 131, 137, 138, 139, 140, 141, 146, 147, 148, 149, 150]}, "removed_lines": {}}, {"17": "android/guava/src/com/google/common/graph/ForwardingValueGraph.java", "added": {"1": ["  @Override\n", "  public boolean hasEdgeConnecting(EndpointPair<N> endpoints) {\n", "    return delegate().hasEdgeConnecting(endpoints);\n", "  }\n", "\n", "\n", "  @Override\n", "  @NullableDecl\n", "  public V edgeValueOrDefault(EndpointPair<N> endpoints, @NullableDecl V defaultValue) {\n", "    return delegate().edgeValueOrDefault(endpoints, defaultValue);\n", "  }\n"]}, "removed": {}, "added_lines": {"1": [97, 98, 99, 100, 101, 107, 108, 109, 110, 111, 112]}, "removed_lines": {}}, {"18": "android/guava/src/com/google/common/graph/Graph.java", "added": {"1": ["   * Returns true if there is an edge that directly connects {@code nodeU} to {@code nodeV}. This is\n"], "2": ["  /**\n", "   * Returns true if there is an edge that directly connects {@code endpoints} (in the order, if\n", "   * any, specified by {@code endpoints}). This is equivalent to {@code\n", "   * edges().contains(endpoints)}.\n", "   *\n", "   * <p>Unlike the other {@code EndpointPair}-accepting methods, this method does not throw if the\n", "   * endpoints are unordered and the graph is directed; it simply returns {@code false}. This is for\n", "   * consistency with the behavior of {@link Collection#contains(Object)} (which does not generally\n", "   * throw if the object cannot be present in the collection), and the desire to have this method's\n", "   * behavior be compatible with {@code edges().contains(endpoints)}.\n", "   *\n", "   * @since NEXT\n", "   */\n", "  @Override\n", "  boolean hasEdgeConnecting(EndpointPair<N> endpoints);\n", "\n"]}, "removed": {"1": ["   * Returns true if there is an edge directly connecting {@code nodeU} to {@code nodeV}. This is\n"]}, "added_lines": {"1": [225], "2": [235, 236, 237, 238, 239, 240, 241, 242, 243, 244, 245, 246, 247, 248, 249, 250]}, "removed_lines": {"1": [225]}}, {"19": "android/guava/src/com/google/common/graph/GraphConstants.java", "added": {"1": ["  static final String ENDPOINTS_MISMATCH =\n", "      \"Mismatch: unordered endpoints cannot be used with directed graphs\";\n"]}, "removed": {}, "added_lines": {"1": [52, 53]}, "removed_lines": {}}, {"20": "android/guava/src/com/google/common/graph/Graphs.java", "added": {"1": ["  static <N> EndpointPair<N> transpose(EndpointPair<N> endpoints) {\n", "    if (endpoints.isOrdered()) {\n", "      return EndpointPair.ordered(endpoints.target(), endpoints.source());\n", "    }\n", "    return endpoints;\n", "  }\n", "\n"], "2": ["\n", "    @Override\n", "    public boolean hasEdgeConnecting(EndpointPair<N> endpoints) {\n", "      return delegate().hasEdgeConnecting(transpose(endpoints));\n", "    }\n"], "3": ["    @Override\n", "    public boolean hasEdgeConnecting(EndpointPair<N> endpoints) {\n", "      return delegate().hasEdgeConnecting(transpose(endpoints));\n", "    }\n", "\n", "\n", "    @Override\n", "    @NullableDecl\n", "    public V edgeValueOrDefault(EndpointPair<N> endpoints, @NullableDecl V defaultValue) {\n", "      return delegate().edgeValueOrDefault(transpose(endpoints), defaultValue);\n", "    }\n"], "4": ["    @Override\n", "    public Set<E> edgesConnecting(EndpointPair<N> endpoints) {\n", "      return delegate().edgesConnecting(transpose(endpoints));\n", "    }\n", "\n", "    @Override\n", "    public E edgeConnectingOrNull(EndpointPair<N> endpoints) {\n", "      return delegate().edgeConnectingOrNull(transpose(endpoints));\n", "    }\n", "\n", "\n", "    @Override\n", "    public boolean hasEdgeConnecting(EndpointPair<N> endpoints) {\n", "      return delegate().hasEdgeConnecting(transpose(endpoints));\n", "    }\n"]}, "removed": {}, "added_lines": {"1": [264, 265, 266, 267, 268, 269, 270], "2": [309, 310, 311, 312, 313], "3": [355, 356, 357, 358, 359, 365, 366, 367, 368, 369, 370], "4": [426, 427, 428, 429, 430, 436, 437, 438, 439, 440, 445, 446, 447, 448, 449]}, "removed_lines": {}}, {"21": "android/guava/src/com/google/common/graph/MutableGraph.java", "added": {"1": ["   * Adds an edge connecting {@code nodeU} to {@code nodeV} if one is not already present.\n", "   *\n", "   * <p>If the graph is directed, the resultant edge will be directed; otherwise, it will be\n", "   * undirected.\n"], "2": ["  /**\n", "   * Adds an edge connecting {@code endpoints} (in the order, if any, specified by {@code\n", "   * endpoints}) if one is not already present.\n", "   *\n", "   * <p>If this graph is directed, {@code endpoints} must be ordered and the added edge will be\n", "   * directed; if it is undirected, the added edge will be undirected.\n", "   *\n", "   * <p>If this graph is directed, {@code endpoints} must be ordered.\n", "   *\n", "   * <p>If either or both endpoints are not already present in this graph, this method will silently\n", "   * {@link #addNode(Object) add} each missing endpoint to the graph.\n", "   *\n", "   * @return {@code true} if the graph was modified as a result of this call\n", "   * @throws IllegalArgumentException if the introduction of the edge would violate {@link\n", "   *     #allowsSelfLoops()}\n", "   * @throws IllegalArgumentException if the endpoints are unordered and the graph is directed\n", "   */\n", "  @CanIgnoreReturnValue\n", "  boolean putEdge(EndpointPair<N> endpoints);\n", "\n"], "3": ["\n", "  /**\n", "   * Removes the edge connecting {@code endpoints}, if it is present.\n", "   *\n", "   * <p>If this graph is directed, {@code endpoints} must be ordered.\n", "   *\n", "   * @throws IllegalArgumentException if the endpoints are unordered and the graph is directed\n", "   * @return {@code true} if the graph was modified as a result of this call\n", "   */\n", "  @CanIgnoreReturnValue\n", "  boolean removeEdge(EndpointPair<N> endpoints);\n"]}, "removed": {"1": ["   * Adds an edge connecting {@code nodeU} to {@code nodeV} if one is not already present. In an\n", "   * undirected graph, the edge will also connect {@code nodeV} to {@code nodeU}.\n"]}, "added_lines": {"1": [45, 46, 47, 48], "2": [60, 61, 62, 63, 64, 65, 66, 67, 68, 69, 70, 71, 72, 73, 74, 75, 76, 77, 78, 79], "3": [95, 96, 97, 98, 99, 100, 101, 102, 103, 104, 105]}, "removed_lines": {"1": [45, 46]}}, {"22": "android/guava/src/com/google/common/graph/MutableNetwork.java", "added": {"1": ["   * Adds {@code edge} connecting {@code nodeU} to {@code nodeV}.\n", "   * <p>If the graph is directed, {@code edge} will be directed in this graph; otherwise, it will be\n", "   * undirected.\n", "   *\n", "   * <p><b>{@code edge} must be unique to this graph</b>, just as a {@code Map} key must be. It must\n", "   * also be non-null.\n"], "2": ["   * @throws IllegalArgumentException if {@code edge} already exists in the graph and does not\n", "   *     connect {@code nodeU} to {@code nodeV}\n", "   * @throws IllegalArgumentException if the introduction of the edge would violate {@link\n", "  /**\n", "   * Adds {@code edge} connecting {@code endpoints}. In an undirected network, {@code edge} will\n", "   * also connect {@code nodeV} to {@code nodeU}.\n", "   *\n", "   * <p>If this graph is directed, {@code edge} will be directed in this graph; if it is undirected,\n", "   * {@code edge} will be undirected in this graph.\n", "   *\n", "   * <p>If this graph is directed, {@code endpoints} must be ordered.\n", "   *\n", "   * <p><b>{@code edge} must be unique to this graph</b>, just as a {@code Map} key must be. It must\n", "   * also be non-null.\n", "   *\n", "   * <p>If either or both endpoints are not already present in this graph, this method will silently\n", "   * {@link #addNode(Object) add} each missing endpoint to the graph.\n", "   *\n", "   * <p>If {@code edge} already connects an endpoint pair equal to {@code endpoints}, then this\n", "   * method will have no effect.\n", "   *\n", "   * @return {@code true} if the network was modified as a result of this call\n", "   * @throws IllegalArgumentException if {@code edge} already exists in the graph and connects some\n", "   *     other endpoint pair that is not equal to {@code endpoints}\n", "   * @throws IllegalArgumentException if the introduction of the edge would violate {@link\n", "   *     #allowsParallelEdges()} or {@link #allowsSelfLoops()}\n", "   * @throws IllegalArgumentException if the endpoints are unordered and the graph is directed\n", "   */\n", "  @CanIgnoreReturnValue\n", "  boolean addEdge(EndpointPair<N> endpoints, E edge);\n", "\n"]}, "removed": {"1": ["   * Adds {@code edge} connecting {@code nodeU} to {@code nodeV}. In an undirected network, the edge\n", "   * will also connect {@code nodeV} to {@code nodeU}.\n", "   * <p><b>Edges must be unique</b>, just as {@code Map} keys must be. They must also be non-null.\n"], "2": ["   * @throws IllegalArgumentException if {@code edge} already exists and does not connect {@code\n", "   *     nodeU} to {@code nodeV}, or if the introduction of the edge would violate {@link\n"]}, "added_lines": {"1": [46, 48, 49, 50, 51, 52], "2": [61, 62, 63, 69, 70, 71, 72, 73, 74, 75, 76, 77, 78, 79, 80, 81, 82, 83, 84, 85, 86, 87, 88, 89, 90, 91, 92, 93, 94, 95, 96]}, "removed_lines": {"1": [46, 47, 49], "2": [58, 59]}}, {"23": "android/guava/src/com/google/common/graph/MutableValueGraph.java", "added": {"1": ["   * Adds an edge connecting {@code nodeU} to {@code nodeV} if one is not already present, and\n", "   * sets a value for that edge to {@code value} (overwriting the existing value, if any).\n", "   *\n", "   * <p>If the graph is directed, the resultant edge will be directed; otherwise, it will be\n", "   * undirected.\n"], "2": ["  /**\n", "   * Adds an edge connecting {@code endpoints} if one is not already present, and sets a value for\n", "   * that edge to {@code value} (overwriting the existing value, if any).\n", "   *\n", "   * <p>If the graph is directed, the resultant edge will be directed; otherwise, it will be\n", "   * undirected.\n", "   *\n", "   * <p>If this graph is directed, {@code endpoints} must be ordered.\n", "   *\n", "   * <p>Values do not have to be unique. However, values must be non-null.\n", "   *\n", "   * <p>If either or both endpoints are not already present in this graph, this method will silently\n", "   * {@link #addNode(Object) add} each missing endpoint to the graph.\n", "   *\n", "   * @return the value previously associated with the edge connecting {@code nodeU} to {@code\n", "   *     nodeV}, or null if there was no such edge.\n", "   * @throws IllegalArgumentException if the introduction of the edge would violate {@link\n", "   *     #allowsSelfLoops()}\n", "   * @throws IllegalArgumentException if the endpoints are unordered and the graph is directed\n", "   */\n", "  @CanIgnoreReturnValue\n", "  V putEdgeValue(EndpointPair<N> endpoints, V value);\n", "\n"], "3": ["\n", "  /**\n", "   * Removes the edge connecting {@code endpoints}, if it is present.\n", "   *\n", "   * <p>If this graph is directed, {@code endpoints} must be ordered.\n", "   *\n", "   * @return the value previously associated with the edge connecting {@code endpoints}, or null if\n", "   *     there was no such edge.\n", "   */\n", "  @CanIgnoreReturnValue\n", "  V removeEdge(EndpointPair<N> endpoints);\n"]}, "removed": {"1": ["   * Adds an edge connecting {@code nodeU} to {@code nodeV} if one is not already present; associate\n", "   * that edge with {@code value}. In an undirected graph, the edge will also connect {@code nodeV}\n", "   * to {@code nodeU}.\n"]}, "added_lines": {"1": [45, 46, 47, 48, 49], "2": [64, 65, 66, 67, 68, 69, 70, 71, 72, 73, 74, 75, 76, 77, 78, 79, 80, 81, 82, 83, 84, 85, 86], "3": [103, 104, 105, 106, 107, 108, 109, 110, 111, 112, 113]}, "removed_lines": {"1": [45, 46, 47]}}, {"24": "android/guava/src/com/google/common/graph/Network.java", "added": {"1": ["   * Returns the set of edges that each directly connect {@code nodeU} to {@code nodeV}.\n"], "2": ["   * Returns the set of edges that each directly connect {@code endpoints} (in the order, if any,\n", "   * specified by {@code endpoints}).\n", "   *\n", "   * <p>The resulting set of edges will be parallel (i.e. have equal {@link #incidentNodes(Object)}.\n", "   * If this network does not {@link #allowsParallelEdges() allow parallel edges}, the resulting set\n", "   * will contain at most one edge (equivalent to {@code edgeConnecting(endpoints).asSet()}).\n", "   *\n", "   * <p>If this network is directed, {@code endpoints} must be ordered.\n", "   *\n", "   * @throws IllegalArgumentException if either endpoint is not an element of this network\n", "   * @throws IllegalArgumentException if the endpoints are unordered and the graph is directed\n", "   * @since NEXT\n", "   */\n", "  Set<E> edgesConnecting(EndpointPair<N> endpoints);\n", "\n", "  /**\n", "   * Returns the single edge that directly connects {@code nodeU} to {@code nodeV}, if one is\n", "   * present, or {@code null} if no such edge exists.\n"], "3": ["   * Returns the single edge that directly connects {@code endpoints} (in the order, if any,\n", "   * specified by {@code endpoints}), if one is present, or {@code null} if no such edge exists.\n", "   *\n", "   * <p>If this graph is directed, the endpoints must be ordered.\n", "   *\n", "   * @throws IllegalArgumentException if there are multiple parallel edges connecting {@code nodeU}\n", "   *     to {@code nodeV}\n", "   * @throws IllegalArgumentException if either endpoint is not an element of this network\n", "   * @throws IllegalArgumentException if the endpoints are unordered and the graph is directed\n", "   * @since NEXT\n", "   */\n", "  @NullableDecl\n", "  E edgeConnectingOrNull(EndpointPair<N> endpoints);\n", "\n", "  /**\n", "   * Returns true if there is an edge that directly connects {@code nodeU} to {@code nodeV}. This is\n"], "4": ["  /**\n", "   * Returns true if there is an edge that directly connects {@code endpoints} (in the order, if\n", "   * any, specified by {@code endpoints}).\n", "   *\n", "   * <p>Unlike the other {@code EndpointPair}-accepting methods, this method does not throw if the\n", "   * endpoints are unordered and the graph is directed; it simply returns {@code false}. This is for\n", "   * consistency with {@link Graph#hasEdgeConnecting(EndpointPair)} and {@link\n", "   * ValueGraph#hasEdgeConnecting(EndpointPair)}.\n", "   *\n", "   * @since NEXT\n", "   */\n", "  boolean hasEdgeConnecting(EndpointPair<N> endpoints);\n", "\n"]}, "removed": {"1": ["   * Returns the set of edges directly connecting {@code nodeU} to {@code nodeV}.\n"], "2": ["   * Returns the single edge directly connecting {@code nodeU} to {@code nodeV}, if one is present,\n", "   * or {@code null} if no such edge exists.\n"], "3": ["   * Returns true if there is an edge directly connecting {@code nodeU} to {@code nodeV}. This is\n"]}, "added_lines": {"1": [274], "2": [288, 289, 290, 291, 292, 293, 294, 295, 296, 297, 298, 299, 300, 301, 302, 303, 304, 305], "3": [319, 320, 321, 322, 323, 324, 325, 326, 327, 328, 329, 330, 331, 332, 333, 334], "4": [344, 345, 346, 347, 348, 349, 350, 351, 352, 353, 354, 355, 356]}, "removed_lines": {"1": [274], "2": [288, 289], "3": [303]}}, {"25": "android/guava/src/com/google/common/graph/ValueGraph.java", "added": {"1": ["   * Returns true if there is an edge that directly connects {@code nodeU} to {@code nodeV}. This is\n"], "2": ["   * Returns true if there is an edge that directly connects {@code endpoints} (in the order, if\n", "   * any, specified by {@code endpoints}). This is equivalent to {@code\n", "   * edges().contains(endpoints)}.\n", "   *\n", "   * <p>Unlike the other {@code EndpointPair}-accepting methods, this method does not throw if the\n", "   * endpoints are unordered and the graph is directed; it simply returns {@code false}. This is for\n", "   * consistency with the behavior of {@link Collection#contains(Object)} (which does not generally\n", "   * throw if the object cannot be present in the collection), and the desire to have this method's\n", "   * behavior be compatible with {@code edges().contains(endpoints)}.\n", "   *\n", "   * @since NEXT\n", "   */\n", "  @Override\n", "  boolean hasEdgeConnecting(EndpointPair<N> endpoints);\n", "\n", "  /**\n", "   * Returns the value of the edge that connects {@code nodeU} to {@code nodeV}, if one is present;\n"], "3": ["  /**\n", "   * Returns the value of the edge that connects {@code endpoints} (in the order, if any, specified\n", "   * by {@code endpoints}), if one is present; otherwise, returns {@code defaultValue}.\n", "   *\n", "   * <p>If this graph is directed, the endpoints must be ordered.\n", "   *\n", "   * @throws IllegalArgumentException if either endpoint is not an element of this graph\n", "   * @throws IllegalArgumentException if the endpoints are unordered and the graph is directed\n", "   * @since NEXT\n", "   */\n", "  @NullableDecl\n", "  V edgeValueOrDefault(EndpointPair<N> endpoints, @NullableDecl V defaultValue);\n", "\n"]}, "removed": {"1": ["   * Returns true if there is an edge directly connecting {@code nodeU} to {@code nodeV}. This is\n"], "2": ["   * Returns the value of the edge connecting {@code nodeU} to {@code nodeV}, if one is present;\n"]}, "added_lines": {"1": [237], "2": [248, 249, 250, 251, 252, 253, 254, 255, 256, 257, 258, 259, 260, 261, 262, 263, 264], "3": [276, 277, 278, 279, 280, 281, 282, 283, 284, 285, 286, 287, 288]}, "removed_lines": {"1": [237], "2": [248]}}, {"26": "guava-tests/test/com/google/common/graph/AbstractDirectedGraphTest.java", "added": {"1": ["import static com.google.common.graph.GraphConstants.ENDPOINTS_MISMATCH;\n", "import static org.junit.Assert.fail;\n"], "2": ["  @Test\n", "  public void hasEdgeConnecting_correct() {\n", "    putEdge(N1, N2);\n", "    assertThat(graph.hasEdgeConnecting(EndpointPair.ordered(N1, N2))).isTrue();\n", "  }\n", "\n", "  @Test\n", "  public void hasEdgeConnecting_backwards() {\n", "    putEdge(N1, N2);\n", "    assertThat(graph.hasEdgeConnecting(EndpointPair.ordered(N2, N1))).isFalse();\n", "  }\n", "\n", "  @Test\n", "  public void hasEdgeConnecting_mismatch() {\n", "    putEdge(N1, N2);\n", "    assertThat(graph.hasEdgeConnecting(EndpointPair.unordered(N1, N2))).isFalse();\n", "    assertThat(graph.hasEdgeConnecting(EndpointPair.unordered(N2, N1))).isFalse();\n", "  }\n", "\n", "  public void putEdge_existingNodes() {\n"], "3": ["  public void putEdge_existingEdgeBetweenSameNodes() {\n", "    assertThat(putEdge(N1, N2)).isTrue();\n", "  @Test\n", "  public void putEdge_orderMismatch() {\n", "    EndpointPair<Integer> endpoints = EndpointPair.unordered(N1, N2);\n", "    try {\n", "      putEdge(endpoints);\n", "      fail(\"Expected IllegalArgumentException: \" + ENDPOINTS_MISMATCH);\n", "    } catch (IllegalArgumentException e) {\n", "      assertThat(e).hasMessageThat().contains(ENDPOINTS_MISMATCH);\n", "    }\n", "  }\n", "\n"], "4": ["\n", "  @Test\n", "  public void removeEdge_orderMismatch() {\n", "    putEdge(N1, N2);\n", "    EndpointPair<Integer> endpoints = EndpointPair.unordered(N1, N2);\n", "    try {\n", "      graph.removeEdge(endpoints);\n", "      fail(\"Expected IllegalArgumentException: \" + ENDPOINTS_MISMATCH);\n", "    } catch (IllegalArgumentException e) {\n", "      assertThat(e).hasMessageThat().contains(ENDPOINTS_MISMATCH);\n", "    }\n", "  }\n"]}, "removed": {"2": ["  public void addEdge_existingNodes() {\n"], "3": ["  public void addEdge_existingEdgeBetweenSameNodes() {\n", "    putEdge(N1, N2);\n"]}, "added_lines": {"1": [19, 21], "2": [73, 74, 75, 76, 77, 78, 79, 80, 81, 82, 83, 84, 85, 86, 87, 88, 89, 90, 91, 95], "3": [104, 105, 109, 110, 111, 112, 113, 114, 115, 116, 117, 118, 119], "4": [134, 135, 136, 137, 138, 139, 140, 141, 142, 143, 144, 145]}, "removed_lines": {"2": [74], "3": [83, 84]}}, {"27": "guava-tests/test/com/google/common/graph/AbstractDirectedNetworkTest.java", "added": {"1": ["import static com.google.common.graph.GraphConstants.ENDPOINTS_MISMATCH;\n", "import java.util.Optional;\n"], "2": ["  @Test\n", "  public void edges_containsOrderMismatch() {\n", "    addEdge(N1, N2, E12);\n", "    EndpointPair<Integer> endpointsN1N2 = EndpointPair.unordered(N1, N2);\n", "    EndpointPair<Integer> endpointsN2N1 = EndpointPair.unordered(N2, N1);\n", "    assertThat(network.asGraph().edges()).doesNotContain(endpointsN1N2);\n", "    assertThat(network.asGraph().edges()).doesNotContain(endpointsN2N1);\n", "  }\n", "\n", "  @Test\n", "  public void edgesConnecting_orderMismatch() {\n", "    addEdge(N1, N2, E12);\n", "    try {\n", "      Set<String> unused = network.edgesConnecting(EndpointPair.unordered(N1, N2));\n", "      fail(\"Expected IllegalArgumentException: \" + ENDPOINTS_MISMATCH);\n", "    } catch (IllegalArgumentException e) {\n", "      assertThat(e).hasMessageThat().contains(ENDPOINTS_MISMATCH);\n", "    }\n", "  }\n", "\n", "  @Test\n", "  public void edgeConnecting_orderMismatch() {\n", "    addEdge(N1, N2, E12);\n", "    try {\n", "      Optional<String> unused = network.edgeConnecting(EndpointPair.unordered(N1, N2));\n", "      fail(\"Expected IllegalArgumentException: \" + ENDPOINTS_MISMATCH);\n", "    } catch (IllegalArgumentException e) {\n", "      assertThat(e).hasMessageThat().contains(ENDPOINTS_MISMATCH);\n", "    }\n", "  }\n", "\n", "  @Test\n", "  public void edgeConnectingOrNull_orderMismatch() {\n", "    addEdge(N1, N2, E12);\n", "    try {\n", "      String unused = network.edgeConnectingOrNull(EndpointPair.unordered(N1, N2));\n", "      fail(\"Expected IllegalArgumentException: \" + ENDPOINTS_MISMATCH);\n", "    } catch (IllegalArgumentException e) {\n", "      assertThat(e).hasMessageThat().contains(ENDPOINTS_MISMATCH);\n", "    }\n", "  }\n", "\n"], "3": ["      assertThat(e).hasMessageThat().contains(ERROR_REUSE_EDGE);\n", "      assertThat(e).hasMessageThat().contains(ERROR_REUSE_EDGE);\n"], "4": ["      assertThat(e).hasMessageThat().contains(ERROR_PARALLEL_EDGE);\n", "    }\n", "  }\n", "\n", "  @Test\n", "  public void addEdge_orderMismatch() {\n", "    EndpointPair<Integer> endpoints = EndpointPair.unordered(N1, N2);\n", "    try {\n", "      addEdge(endpoints, E12);\n", "      fail(\"Expected IllegalArgumentException: \" + ENDPOINTS_MISMATCH);\n", "    } catch (IllegalArgumentException e) {\n", "      assertThat(e).hasMessageThat().contains(ENDPOINTS_MISMATCH);\n"]}, "removed": {"3": ["      assertThat(e.getMessage()).contains(ERROR_REUSE_EDGE);\n", "      assertThat(e.getMessage()).contains(ERROR_REUSE_EDGE);\n"], "4": ["      assertThat(e.getMessage()).contains(ERROR_PARALLEL_EDGE);\n"]}, "added_lines": {"1": [19, 26], "2": [64, 65, 66, 67, 68, 69, 70, 71, 72, 73, 74, 75, 76, 77, 78, 79, 80, 81, 82, 83, 84, 85, 86, 87, 88, 89, 90, 91, 92, 93, 94, 95, 96, 97, 98, 99, 100, 101, 102, 103, 104, 105], "3": [234, 241], "4": [252, 253, 254, 255, 256, 257, 258, 259, 260, 261, 262, 263]}, "removed_lines": {"3": [190, 197], "4": [208]}}, {"28": "guava-tests/test/com/google/common/graph/AbstractGraphTest.java", "added": {"1": ["  @CanIgnoreReturnValue\n", "  protected boolean putEdge(EndpointPair<Integer> endpoints) {\n", "    graph.addNode(endpoints.nodeU());\n", "    graph.addNode(endpoints.nodeV());\n", "    return graph.putEdge(endpoints);\n", "  }\n", "\n"]}, "removed": {}, "added_lines": {"1": [106, 107, 108, 109, 110, 111, 112]}, "removed_lines": {}}, {"29": "guava-tests/test/com/google/common/graph/AbstractNetworkTest.java", "added": {"1": ["   * TODO(user): remove the addNode() calls, that's now contractually guaranteed\n", "   *\n"], "2": ["  protected boolean addEdge(EndpointPair<Integer> endpoints, String e) {\n", "    network.addNode(endpoints.nodeU());\n", "    network.addNode(endpoints.nodeV());\n", "    return network.addEdge(endpoints, e);\n", "  }\n", "\n"]}, "removed": {}, "added_lines": {"1": [123, 124], "2": [134, 135, 136, 137, 138, 139]}, "removed_lines": {}}, {"30": "guava-tests/test/com/google/common/graph/AbstractUndirectedGraphTest.java", "added": {"1": ["  @Test\n", "  public void hasEdgeConnecting_correct() {\n", "    putEdge(N1, N2);\n", "    assertThat(graph.hasEdgeConnecting(EndpointPair.unordered(N1, N2))).isTrue();\n", "    assertThat(graph.hasEdgeConnecting(EndpointPair.unordered(N2, N1))).isTrue();\n", "  }\n", "\n", "  @Test\n", "  public void hasEdgeConnecting_mismatch() {\n", "    putEdge(N1, N2);\n", "    assertThat(graph.hasEdgeConnecting(EndpointPair.ordered(N1, N2))).isTrue();\n", "    assertThat(graph.hasEdgeConnecting(EndpointPair.ordered(N2, N1))).isTrue();\n", "  }\n", "\n"]}, "removed": {}, "added_lines": {"1": [80, 81, 82, 83, 84, 85, 86, 87, 88, 89, 90, 91, 92, 93]}, "removed_lines": {}}, {"31": "guava-tests/test/com/google/common/graph/AbstractUndirectedNetworkTest.java", "added": {"1": ["import static com.google.common.truth.Truth8.assertThat;\n"], "2": ["  private static final EndpointPair<Integer> ENDPOINTS_N1N2 = EndpointPair.ordered(N1, N2);\n", "  private static final EndpointPair<Integer> ENDPOINTS_N2N1 = EndpointPair.ordered(N2, N1);\n"], "3": ["  @Test\n", "  public void edges_containsOrderMismatch() {\n", "    addEdge(N1, N2, E12);\n", "    assertThat(network.asGraph().edges()).contains(ENDPOINTS_N2N1);\n", "    assertThat(network.asGraph().edges()).contains(ENDPOINTS_N1N2);\n", "  }\n", "\n", "  @Test\n", "  public void edgesConnecting_orderMismatch() {\n", "    addEdge(N1, N2, E12);\n", "    assertThat(network.edgesConnecting(ENDPOINTS_N2N1)).containsExactly(E12);\n", "    assertThat(network.edgesConnecting(ENDPOINTS_N1N2)).containsExactly(E12);\n", "  }\n", "\n", "  @Test\n", "  public void edgeConnecting_orderMismatch() {\n", "    addEdge(N1, N2, E12);\n", "    assertThat(network.edgeConnecting(ENDPOINTS_N2N1)).hasValue(E12);\n", "    assertThat(network.edgeConnecting(ENDPOINTS_N1N2)).hasValue(E12);\n", "  }\n", "\n", "  @Test\n", "  public void edgeConnectingOrNull_orderMismatch() {\n", "    addEdge(N1, N2, E12);\n", "    assertThat(network.edgeConnectingOrNull(ENDPOINTS_N2N1)).isEqualTo(E12);\n", "    assertThat(network.edgeConnectingOrNull(ENDPOINTS_N1N2)).isEqualTo(E12);\n", "  }\n", "\n"], "4": ["    assertThat(addEdge(N1, N2, E12)).isTrue();\n"], "5": ["\n", "  @Test\n", "  public void addEdge_orderMismatch() {\n", "    EndpointPair<Integer> endpoints = EndpointPair.ordered(N1, N2);\n", "    assertThat(addEdge(endpoints, E12)).isTrue();\n", "  }\n"]}, "removed": {"4": ["    addEdge(N1, N2, E12);\n"]}, "added_lines": {"1": [20], "2": [36, 37], "3": [58, 59, 60, 61, 62, 63, 64, 65, 66, 67, 68, 69, 70, 71, 72, 73, 74, 75, 76, 77, 78, 79, 80, 81, 82, 83, 84, 85], "4": [151], "5": [187, 188, 189, 190, 191, 192]}, "removed_lines": {"4": [120]}}, {"32": "guava-tests/test/com/google/common/graph/EndpointPairTest.java", "added": {"1": ["  public void endpointPair_undirected_contains() {\n"], "2": ["    // ordered endpoints OK for undirected graph (because ordering is irrelevant)\n", "    assertThat(edges).contains(EndpointPair.ordered(N1, N2));\n", "\n", "    assertThat(edges).doesNotContain(EndpointPair.unordered(N2, N2)); // edge not present\n", "  @Test\n", "  public void endpointPair_directed_contains() {\n", "    MutableGraph<Integer> directedGraph = GraphBuilder.directed().allowsSelfLoops(true).build();\n", "    directedGraph.putEdge(N1, N1);\n", "    directedGraph.putEdge(N1, N2);\n", "    Set<EndpointPair<Integer>> edges = directedGraph.edges();\n", "\n", "    assertThat(edges).hasSize(2);\n", "    assertThat(edges).contains(EndpointPair.ordered(N1, N1));\n", "    assertThat(edges).contains(EndpointPair.ordered(N1, N2));\n", "\n", "    // unordered endpoints not OK for directed graph (undefined behavior)\n", "    assertThat(edges).doesNotContain(EndpointPair.unordered(N1, N2));\n", "\n", "    assertThat(edges).doesNotContain(EndpointPair.ordered(N2, N1)); // wrong order\n", "    assertThat(edges).doesNotContain(EndpointPair.ordered(N2, N2)); // edge not present\n", "    assertThat(edges).doesNotContain(EndpointPair.ordered(N3, N4)); // nodes not in graph\n", "  }\n", "\n"]}, "removed": {"1": ["  public void endpointPair_containment() {\n"], "2": ["    assertThat(edges).doesNotContain(EndpointPair.unordered(N2, N2));\n", "    assertThat(edges).doesNotContain(EndpointPair.ordered(N1, N2)); // graph not directed\n"]}, "added_lines": {"1": [206], "2": [217, 218, 219, 220, 224, 225, 226, 227, 228, 229, 230, 231, 232, 233, 234, 235, 236, 237, 238, 239, 240, 241, 242]}, "removed_lines": {"1": [206], "2": [217, 218]}}, {"33": "guava-tests/test/com/google/common/graph/ValueGraphTest.java", "added": {"1": ["import static com.google.common.graph.GraphConstants.ENDPOINTS_MISMATCH;\n", "import static com.google.common.truth.Truth8.assertThat;\n", "import static org.junit.Assert.fail;\n", "import java.util.Optional;\n"], "2": ["  @Test\n", "  public void hasEdgeConnecting_directed_correct() {\n", "    graph = ValueGraphBuilder.directed().build();\n", "    graph.putEdgeValue(1, 2, \"A\");\n", "    assertThat(graph.hasEdgeConnecting(EndpointPair.ordered(1, 2))).isTrue();\n", "  }\n", "\n", "  @Test\n", "  public void hasEdgeConnecting_directed_backwards() {\n", "    graph = ValueGraphBuilder.directed().build();\n", "    graph.putEdgeValue(1, 2, \"A\");\n", "    assertThat(graph.hasEdgeConnecting(EndpointPair.ordered(2, 1))).isFalse();\n", "  }\n", "\n", "  @Test\n", "  public void hasEdgeConnecting_directed_mismatch() {\n", "    graph = ValueGraphBuilder.directed().build();\n", "    graph.putEdgeValue(1, 2, \"A\");\n", "    assertThat(graph.hasEdgeConnecting(EndpointPair.unordered(1, 2))).isFalse();\n", "    assertThat(graph.hasEdgeConnecting(EndpointPair.unordered(2, 1))).isFalse();\n", "  }\n", "\n", "  @Test\n", "  public void hasEdgeConnecting_undirected_correct() {\n", "    graph = ValueGraphBuilder.undirected().build();\n", "    graph.putEdgeValue(1, 2, \"A\");\n", "    assertThat(graph.hasEdgeConnecting(EndpointPair.unordered(1, 2))).isTrue();\n", "  }\n", "\n", "  @Test\n", "  public void hasEdgeConnecting_undirected_backwards() {\n", "    graph = ValueGraphBuilder.undirected().build();\n", "    graph.putEdgeValue(1, 2, \"A\");\n", "    assertThat(graph.hasEdgeConnecting(EndpointPair.unordered(2, 1))).isTrue();\n", "  }\n", "\n", "  @Test\n", "  public void hasEdgeConnecting_undirected_mismatch() {\n", "    graph = ValueGraphBuilder.undirected().build();\n", "    graph.putEdgeValue(1, 2, \"A\");\n", "    assertThat(graph.hasEdgeConnecting(EndpointPair.ordered(1, 2))).isTrue();\n", "    assertThat(graph.hasEdgeConnecting(EndpointPair.ordered(2, 1))).isTrue();\n", "  }\n", "\n", "  @Test\n", "  public void edgeValue_directed_correct() {\n", "    graph = ValueGraphBuilder.directed().build();\n", "    graph.putEdgeValue(1, 2, \"A\");\n", "    assertThat(graph.edgeValue(EndpointPair.ordered(1, 2))).hasValue(\"A\");\n", "  }\n", "\n", "  @Test\n", "  public void edgeValue_directed_backwards() {\n", "    graph = ValueGraphBuilder.directed().build();\n", "    graph.putEdgeValue(1, 2, \"A\");\n", "    assertThat(graph.edgeValue(EndpointPair.ordered(2, 1))).isEmpty();\n", "  }\n", "\n", "  @Test\n", "  public void edgeValue_directed_mismatch() {\n", "    graph = ValueGraphBuilder.directed().build();\n", "    graph.putEdgeValue(1, 2, \"A\");\n", "    try {\n", "      Optional<String> unused = graph.edgeValue(EndpointPair.unordered(1, 2));\n", "      unused = graph.edgeValue(EndpointPair.unordered(2, 1));\n", "      fail(\"Expected IllegalArgumentException: \" + ENDPOINTS_MISMATCH);\n", "    } catch (IllegalArgumentException e) {\n", "      assertThat(e).hasMessageThat().contains(ENDPOINTS_MISMATCH);\n", "    }\n", "  }\n", "\n", "  @Test\n", "  public void edgeValue_undirected_correct() {\n", "    graph = ValueGraphBuilder.undirected().build();\n", "    graph.putEdgeValue(1, 2, \"A\");\n", "    assertThat(graph.edgeValue(EndpointPair.unordered(1, 2))).hasValue(\"A\");\n", "  }\n", "\n", "  @Test\n", "  public void edgeValue_undirected_backwards() {\n", "    graph = ValueGraphBuilder.undirected().build();\n", "    graph.putEdgeValue(1, 2, \"A\");\n", "    assertThat(graph.edgeValue(EndpointPair.unordered(2, 1))).hasValue(\"A\");\n", "  }\n", "\n", "  @Test\n", "  public void edgeValue_undirected_mismatch() {\n", "    graph = ValueGraphBuilder.undirected().build();\n", "    graph.putEdgeValue(1, 2, \"A\");\n", "    assertThat(graph.edgeValue(EndpointPair.ordered(1, 2))).hasValue(\"A\");\n", "    assertThat(graph.edgeValue(EndpointPair.ordered(2, 1))).hasValue(\"A\");\n", "  }\n", "\n", "  @Test\n", "  public void edgeValueOrDefault_directed_correct() {\n", "    graph = ValueGraphBuilder.directed().build();\n", "    graph.putEdgeValue(1, 2, \"A\");\n", "    assertThat(graph.edgeValueOrDefault(EndpointPair.ordered(1, 2), \"default\")).isEqualTo(\"A\");\n", "  }\n", "\n", "  @Test\n", "  public void edgeValueOrDefault_directed_backwards() {\n", "    graph = ValueGraphBuilder.directed().build();\n", "    graph.putEdgeValue(1, 2, \"A\");\n", "    assertThat(graph.edgeValueOrDefault(EndpointPair.ordered(2, 1), \"default\"))\n", "        .isEqualTo(\"default\");\n", "  }\n", "\n", "  @Test\n", "  public void edgeValueOrDefault_directed_mismatch() {\n", "    graph = ValueGraphBuilder.directed().build();\n", "    graph.putEdgeValue(1, 2, \"A\");\n", "    try {\n", "      String unused = graph.edgeValueOrDefault(EndpointPair.unordered(1, 2), \"default\");\n", "      unused = graph.edgeValueOrDefault(EndpointPair.unordered(2, 1), \"default\");\n", "      fail(\"Expected IllegalArgumentException: \" + ENDPOINTS_MISMATCH);\n", "    } catch (IllegalArgumentException e) {\n", "      assertThat(e).hasMessageThat().contains(ENDPOINTS_MISMATCH);\n", "    }\n", "  }\n", "\n", "  @Test\n", "  public void edgeValueOrDefault_undirected_correct() {\n", "    graph = ValueGraphBuilder.undirected().build();\n", "    graph.putEdgeValue(1, 2, \"A\");\n", "    assertThat(graph.edgeValueOrDefault(EndpointPair.unordered(1, 2), \"default\")).isEqualTo(\"A\");\n", "  }\n", "\n", "  @Test\n", "  public void edgeValueOrDefault_undirected_backwards() {\n", "    graph = ValueGraphBuilder.undirected().build();\n", "    graph.putEdgeValue(1, 2, \"A\");\n", "    assertThat(graph.edgeValueOrDefault(EndpointPair.unordered(2, 1), \"default\")).isEqualTo(\"A\");\n", "  }\n", "\n", "  @Test\n", "  public void edgeValueOrDefault_undirected_mismatch() {\n", "    graph = ValueGraphBuilder.undirected().build();\n", "    graph.putEdgeValue(1, 2, \"A\");\n", "    assertThat(graph.edgeValueOrDefault(EndpointPair.ordered(2, 1), \"default\")).isEqualTo(\"A\");\n", "    assertThat(graph.edgeValueOrDefault(EndpointPair.ordered(2, 1), \"default\")).isEqualTo(\"A\");\n", "  }\n", "\n"], "3": ["  @Test\n", "  public void putEdgeValue_directed_orderMismatch() {\n", "    graph = ValueGraphBuilder.directed().build();\n", "    try {\n", "      graph.putEdgeValue(EndpointPair.unordered(1, 2), \"irrelevant\");\n", "      fail(\"Expected IllegalArgumentException: \" + ENDPOINTS_MISMATCH);\n", "    } catch (IllegalArgumentException e) {\n", "      assertThat(e).hasMessageThat().contains(ENDPOINTS_MISMATCH);\n", "    }\n", "  }\n", "\n", "  @Test\n", "  public void putEdgeValue_undirected_orderMismatch() {\n", "    graph = ValueGraphBuilder.undirected().build();\n", "    assertThat(graph.putEdgeValue(EndpointPair.ordered(1, 2), \"irrelevant\")).isNull();\n", "  }\n", "\n"], "4": ["  @Test\n", "  public void removeEdge_directed_orderMismatch() {\n", "    graph = ValueGraphBuilder.directed().build();\n", "    graph.putEdgeValue(1, 2, \"1->2\");\n", "    graph.putEdgeValue(2, 1, \"2->1\");\n", "    try {\n", "      graph.removeEdge(EndpointPair.unordered(1, 2));\n", "      graph.removeEdge(EndpointPair.unordered(2, 1));\n", "      fail(\"Expected IllegalArgumentException: \" + ENDPOINTS_MISMATCH);\n", "    } catch (IllegalArgumentException e) {\n", "      assertThat(e).hasMessageThat().contains(ENDPOINTS_MISMATCH);\n", "    }\n", "  }\n", "\n", "  @Test\n", "  public void removeEdge_undirected_orderMismatch() {\n", "    graph = ValueGraphBuilder.undirected().build();\n", "    graph.putEdgeValue(1, 2, \"1-2\");\n", "    assertThat(graph.removeEdge(EndpointPair.ordered(1, 2))).isEqualTo(\"1-2\");\n", "  }\n", "\n"]}, "removed": {}, "added_lines": {"1": [19, 22, 23, 25], "2": [118, 119, 120, 121, 122, 123, 124, 125, 126, 127, 128, 129, 130, 131, 132, 133, 134, 135, 136, 137, 138, 139, 140, 141, 142, 143, 144, 145, 146, 147, 148, 149, 150, 151, 152, 153, 154, 155, 156, 157, 158, 159, 160, 161, 162, 163, 164, 165, 166, 167, 168, 169, 170, 171, 172, 173, 174, 175, 176, 177, 178, 179, 180, 181, 182, 183, 184, 185, 186, 187, 188, 189, 190, 191, 192, 193, 194, 195, 196, 197, 198, 199, 200, 201, 202, 203, 204, 205, 206, 207, 208, 209, 210, 211, 212, 213, 214, 215, 216, 217, 218, 219, 220, 221, 222, 223, 224, 225, 226, 227, 228, 229, 230, 231, 232, 233, 234, 235, 236, 237, 238, 239, 240, 241, 242, 243, 244, 245, 246, 247, 248, 249, 250, 251, 252, 253, 254, 255, 256, 257, 258, 259, 260], "3": [271, 272, 273, 274, 275, 276, 277, 278, 279, 280, 281, 282, 283, 284, 285, 286, 287], "4": [327, 328, 329, 330, 331, 332, 333, 334, 335, 336, 337, 338, 339, 340, 341, 342, 343, 344, 345, 346, 347]}, "removed_lines": {}}, {"34": "guava/src/com/google/common/graph/AbstractBaseGraph.java", "added": {"1": ["import static com.google.common.graph.GraphConstants.ENDPOINTS_MISMATCH;\n"], "2": ["        return isOrderingCompatible(endpointPair)\n"], "3": ["  @Override\n", "  public boolean hasEdgeConnecting(EndpointPair<N> endpoints) {\n", "    checkNotNull(endpoints);\n", "    if (!isOrderingCompatible(endpoints)) {\n", "      return false;\n", "    }\n", "    N nodeU = endpoints.nodeU();\n", "    N nodeV = endpoints.nodeV();\n", "    return nodes().contains(nodeU) && successors(nodeU).contains(nodeV);\n", "  }\n", "\n", "  /**\n", "   * Throws {@code IllegalArgumentException} if the ordering of {@code endpoints} is not compatible\n", "   * with the directionality of this graph.\n", "   */\n", "  protected final void validateEndpoints(EndpointPair<?> endpoints) {\n", "    checkNotNull(endpoints);\n", "    checkArgument(isOrderingCompatible(endpoints), ENDPOINTS_MISMATCH);\n", "  }\n", "\n", "  protected final boolean isOrderingCompatible(EndpointPair<?> endpoints) {\n", "    return endpoints.isOrdered() || !this.isDirected();\n", "  }\n", "\n"]}, "removed": {"2": ["        return isDirected() == endpointPair.isOrdered()\n"]}, "added_lines": {"1": [22], "2": [93], "3": [135, 136, 137, 138, 139, 140, 141, 142, 143, 144, 145, 146, 147, 148, 149, 150, 151, 152, 153, 154, 155, 156, 157, 158]}, "removed_lines": {"2": [92]}}, {"35": "guava/src/com/google/common/graph/AbstractNetwork.java", "added": {"1": ["import static com.google.common.base.Preconditions.checkArgument;\n", "import static com.google.common.base.Preconditions.checkNotNull;\n", "import static com.google.common.graph.GraphConstants.ENDPOINTS_MISMATCH;\n"], "2": ["            return isOrderingCompatible(endpointPair)\n"], "3": ["  @Override\n", "  public Set<E> edgesConnecting(EndpointPair<N> endpoints) {\n", "    validateEndpoints(endpoints);\n", "    return edgesConnecting(endpoints.nodeU(), endpoints.nodeV());\n", "  }\n", "\n"], "4": ["    return Optional.ofNullable(edgeConnectingOrNull(nodeU, nodeV));\n", "  }\n", "\n", "  @Override\n", "  public Optional<E> edgeConnecting(EndpointPair<N> endpoints) {\n", "    validateEndpoints(endpoints);\n", "    return edgeConnecting(endpoints.nodeU(), endpoints.nodeV());\n", "  }\n", "\n", "  @Override\n", "  public @Nullable E edgeConnectingOrNull(N nodeU, N nodeV) {\n", "        return null;\n", "        return edgesConnecting.iterator().next();\n", "  public @Nullable E edgeConnectingOrNull(EndpointPair<N> endpoints) {\n", "    validateEndpoints(endpoints);\n", "    return edgeConnectingOrNull(endpoints.nodeU(), endpoints.nodeV());\n"], "5": ["  @Override\n", "  public boolean hasEdgeConnecting(EndpointPair<N> endpoints) {\n", "    checkNotNull(endpoints);\n", "    if (!isOrderingCompatible(endpoints)) {\n", "      return false;\n", "    }\n", "    return !edgesConnecting(endpoints.nodeU(), endpoints.nodeV()).isEmpty();\n", "  }\n", "\n", "  /**\n", "   * Throws an IllegalArgumentException if the ordering of {@code endpoints} is not compatible\n", "   * with the directionality of this graph.\n", "   */\n", "  protected final void validateEndpoints(EndpointPair<?> endpoints) {\n", "    checkNotNull(endpoints);\n", "    checkArgument(isOrderingCompatible(endpoints), ENDPOINTS_MISMATCH);\n", "  }\n", "\n", "  protected final boolean isOrderingCompatible(EndpointPair<?> endpoints) {\n", "    return endpoints.isOrdered() || !this.isDirected();\n", "  }\n", "\n"]}, "removed": {"2": ["            return isDirected() == endpointPair.isOrdered()\n"], "4": ["        return Optional.empty();\n", "        return Optional.of(edgesConnecting.iterator().next());\n", "  public @Nullable E edgeConnectingOrNull(N nodeU, N nodeV) {\n", "    return edgeConnecting(nodeU, nodeV).orElse(null);\n"]}, "added_lines": {"1": [19, 20, 21], "2": [98], "3": [175, 176, 177, 178, 179, 180], "4": [192, 193, 194, 195, 196, 197, 198, 199, 200, 201, 202, 206, 208, 215, 216, 217], "5": [225, 226, 227, 228, 229, 230, 231, 232, 233, 234, 235, 236, 237, 238, 239, 240, 241, 242, 243, 244, 245, 246]}, "removed_lines": {"2": [95], "4": [186, 188, 195, 196]}}, {"36": "guava/src/com/google/common/graph/AbstractValueGraph.java", "added": {"1": ["  @Override\n", "  public Optional<V> edgeValue(EndpointPair<N> endpoints) {\n", "    return Optional.ofNullable(edgeValueOrDefault(endpoints, null));\n", "  }\n", "\n"]}, "removed": {}, "added_lines": {"1": [108, 109, 110, 111, 112]}, "removed_lines": {}}, {"37": "guava/src/com/google/common/graph/BaseGraph.java", "added": {"1": ["   * Returns true if there is an edge that directly connects {@code nodeU} to {@code nodeV}. This is\n"], "2": ["\n", "  /**\n", "   * Returns true if there is an edge that directly connects {@code endpoints} (in the order, if\n", "   * any, specified by {@code endpoints}). This is equivalent to {@code\n", "   * edges().contains(endpoints)}.\n", "   *\n", "   * <p>Unlike the other {@code EndpointPair}-accepting methods, this method does not throw if the\n", "   * endpoints are unordered; it simply returns false. This is for consistency with the behavior of\n", "   * {@link Collection#contains(Object)} (which does not generally throw if the object cannot be\n", "   * present in the collection), and the desire to have this method's behavior be compatible with\n", "   * {@code edges().contains(endpoints)}.\n", "   *\n", "   * @since NEXT\n", "   */\n", "  boolean hasEdgeConnecting(EndpointPair<N> endpoints);\n"]}, "removed": {"1": ["   * Returns true if there is an edge directly connecting {@code nodeU} to {@code nodeV}. This is\n"]}, "added_lines": {"1": [139], "2": [147, 148, 149, 150, 151, 152, 153, 154, 155, 156, 157, 158, 159, 160, 161]}, "removed_lines": {"1": [139]}}, {"38": "guava/src/com/google/common/graph/ConfigurableMutableGraph.java", "added": {"1": ["  @Override\n", "  public boolean putEdge(EndpointPair<N> endpoints) {\n", "    validateEndpoints(endpoints);\n", "    return putEdge(endpoints.nodeU(), endpoints.nodeV());\n", "  }\n", "\n"], "2": ["\n", "  @Override\n", "  public boolean removeEdge(EndpointPair<N> endpoints) {\n", "    validateEndpoints(endpoints);\n", "    return removeEdge(endpoints.nodeU(), endpoints.nodeV());\n", "  }\n"]}, "removed": {}, "added_lines": {"1": [54, 55, 56, 57, 58, 59], "2": [69, 70, 71, 72, 73, 74]}, "removed_lines": {}}, {"39": "guava/src/com/google/common/graph/ConfigurableMutableNetwork.java", "added": {"1": ["  @Override\n", "  @CanIgnoreReturnValue\n", "  public boolean addEdge(EndpointPair<N> endpoints, E edge) {\n", "    validateEndpoints(endpoints);\n", "    return addEdge(endpoints.nodeU(), endpoints.nodeV(), edge);\n", "  }\n", "\n"]}, "removed": {}, "added_lines": {"1": [119, 120, 121, 122, 123, 124, 125]}, "removed_lines": {}}, {"40": "guava/src/com/google/common/graph/ConfigurableMutableValueGraph.java", "added": {"1": ["  @Override\n", "  @CanIgnoreReturnValue\n", "  public V putEdgeValue(EndpointPair<N> endpoints, V value) {\n", "    validateEndpoints(endpoints);\n", "    return putEdgeValue(endpoints.nodeU(), endpoints.nodeV(), value);\n", "  }\n", "\n"], "2": ["  @Override\n", "  @CanIgnoreReturnValue\n", "  public V removeEdge(EndpointPair<N> endpoints) {\n", "    validateEndpoints(endpoints);\n", "    return removeEdge(endpoints.nodeU(), endpoints.nodeV());\n", "  }\n", "\n"]}, "removed": {}, "added_lines": {"1": [101, 102, 103, 104, 105, 106, 107], "2": [161, 162, 163, 164, 165, 166, 167]}, "removed_lines": {}}, {"41": "guava/src/com/google/common/graph/ConfigurableValueGraph.java", "added": {"1": ["    return hasEdgeConnecting_internal(checkNotNull(nodeU), checkNotNull(nodeV));\n", "  }\n", "\n", "  @Override\n", "  public boolean hasEdgeConnecting(EndpointPair<N> endpoints) {\n", "    checkNotNull(endpoints);\n", "    return isOrderingCompatible(endpoints)\n", "        && hasEdgeConnecting_internal(endpoints.nodeU(), endpoints.nodeV());\n", "    return edgeValueOrDefault_internal(checkNotNull(nodeU), checkNotNull(nodeV), defaultValue);\n", "  }\n", "\n", "  @Override\n", "  public @Nullable V edgeValueOrDefault(EndpointPair<N> endpoints, @Nullable V defaultValue) {\n", "    validateEndpoints(endpoints);\n", "    return edgeValueOrDefault_internal(endpoints.nodeU(), endpoints.nodeV(), defaultValue);\n"], "2": ["\n", "  protected final boolean hasEdgeConnecting_internal(N nodeU, N nodeV) {\n", "    GraphConnections<N, V> connectionsU = nodeConnections.get(nodeU);\n", "    return (connectionsU != null) && connectionsU.successors().contains(nodeV);\n", "  }\n", "\n", "  protected final V edgeValueOrDefault_internal(N nodeU, N nodeV, V defaultValue) {\n", "    GraphConnections<N, V> connectionsU = nodeConnections.get(nodeU);\n", "    V value = (connectionsU == null) ? null : connectionsU.value(nodeV);\n", "    return value == null ? defaultValue : value;\n", "  }\n"]}, "removed": {"1": ["    checkNotNull(nodeU);\n", "    checkNotNull(nodeV);\n", "    GraphConnections<N, V> connectionsU = nodeConnections.get(nodeU);\n", "    return (connectionsU != null) && connectionsU.successors().contains(nodeV);\n", "    checkNotNull(nodeU);\n", "    checkNotNull(nodeV);\n", "    GraphConnections<N, V> connectionsU = nodeConnections.get(nodeU);\n", "    V value = (connectionsU == null) ? null : connectionsU.value(nodeV);\n", "    return value == null ? defaultValue : value;\n"]}, "added_lines": {"1": [119, 120, 121, 122, 123, 124, 125, 126, 131, 132, 133, 134, 135, 136, 137], "2": [157, 158, 159, 160, 161, 162, 163, 164, 165, 166, 167]}, "removed_lines": {"1": [119, 120, 121, 122, 127, 128, 129, 130, 131]}}, {"42": "guava/src/com/google/common/graph/ForwardingGraph.java", "added": {"1": ["\n", "  @Override\n", "  public boolean hasEdgeConnecting(EndpointPair<N> endpoints) {\n", "    return delegate().hasEdgeConnecting(endpoints);\n", "  }\n"]}, "removed": {}, "added_lines": {"1": [94, 95, 96, 97, 98]}, "removed_lines": {}}, {"43": "guava/src/com/google/common/graph/ForwardingNetwork.java", "added": {"1": ["  @Override\n", "  public Set<E> edgesConnecting(EndpointPair<N> endpoints) {\n", "    return delegate().edgesConnecting(endpoints);\n", "  }\n", "\n", "  @Override\n", "  public Optional<E> edgeConnecting(EndpointPair<N> endpoints) {\n", "    return delegate().edgeConnecting(endpoints);\n", "  }\n", "\n", "  @Override\n", "  public E edgeConnectingOrNull(EndpointPair<N> endpoints) {\n", "    return delegate().edgeConnectingOrNull(endpoints);\n", "  }\n", "\n", "\n", "  @Override\n", "  public boolean hasEdgeConnecting(EndpointPair<N> endpoints) {\n", "    return delegate().hasEdgeConnecting(endpoints);\n", "  }\n"]}, "removed": {}, "added_lines": {"1": [128, 129, 130, 131, 132, 138, 139, 140, 141, 142, 148, 149, 150, 151, 152, 157, 158, 159, 160, 161]}, "removed_lines": {}}, {"44": "guava/src/com/google/common/graph/ForwardingValueGraph.java", "added": {"1": ["  @Override\n", "  public boolean hasEdgeConnecting(EndpointPair<N> endpoints) {\n", "    return delegate().hasEdgeConnecting(endpoints);\n", "  }\n", "\n", "  @Override\n", "  public Optional<V> edgeValue(EndpointPair<N> endpoints) {\n", "    return delegate().edgeValue(endpoints);\n", "  }\n", "\n", "\n", "  @Override\n", "  public @Nullable V edgeValueOrDefault(EndpointPair<N> endpoints, @Nullable V defaultValue) {\n", "    return delegate().edgeValueOrDefault(endpoints, defaultValue);\n", "  }\n"]}, "removed": {}, "added_lines": {"1": [98, 99, 100, 101, 102, 108, 109, 110, 111, 112, 117, 118, 119, 120, 121]}, "removed_lines": {}}, {"45": "guava/src/com/google/common/graph/Graph.java", "added": {"1": ["   * Returns true if there is an edge that directly connects {@code nodeU} to {@code nodeV}. This is\n"], "2": ["  /**\n", "   * Returns true if there is an edge that directly connects {@code endpoints} (in the order, if\n", "   * any, specified by {@code endpoints}). This is equivalent to {@code\n", "   * edges().contains(endpoints)}.\n", "   *\n", "   * <p>Unlike the other {@code EndpointPair}-accepting methods, this method does not throw if the\n", "   * endpoints are unordered and the graph is directed; it simply returns {@code false}. This is for\n", "   * consistency with the behavior of {@link Collection#contains(Object)} (which does not generally\n", "   * throw if the object cannot be present in the collection), and the desire to have this method's\n", "   * behavior be compatible with {@code edges().contains(endpoints)}.\n", "   *\n", "   * @since NEXT\n", "   */\n", "  @Override\n", "  boolean hasEdgeConnecting(EndpointPair<N> endpoints);\n", "\n"]}, "removed": {"1": ["   * Returns true if there is an edge directly connecting {@code nodeU} to {@code nodeV}. This is\n"]}, "added_lines": {"1": [225], "2": [235, 236, 237, 238, 239, 240, 241, 242, 243, 244, 245, 246, 247, 248, 249, 250]}, "removed_lines": {"1": [225]}}, {"46": "guava/src/com/google/common/graph/GraphConstants.java", "added": {"1": ["  static final String ENDPOINTS_MISMATCH =\n", "      \"Mismatch: unordered endpoints cannot be used with directed graphs\";\n"]}, "removed": {}, "added_lines": {"1": [52, 53]}, "removed_lines": {}}, {"47": "guava/src/com/google/common/graph/Graphs.java", "added": {"1": ["  static <N> EndpointPair<N> transpose(EndpointPair<N> endpoints) {\n", "    if (endpoints.isOrdered()) {\n", "      return EndpointPair.ordered(endpoints.target(), endpoints.source());\n", "    }\n", "    return endpoints;\n", "  }\n", "\n"], "2": ["\n", "    @Override\n", "    public boolean hasEdgeConnecting(EndpointPair<N> endpoints) {\n", "      return delegate().hasEdgeConnecting(transpose(endpoints));\n", "    }\n"], "3": ["    @Override\n", "    public boolean hasEdgeConnecting(EndpointPair<N> endpoints) {\n", "      return delegate().hasEdgeConnecting(transpose(endpoints));\n", "    }\n", "\n", "    @Override\n", "    public Optional<V> edgeValue(EndpointPair<N> endpoints) {\n", "      return delegate().edgeValue(transpose(endpoints));\n", "    }\n", "\n", "\n", "    @Override\n", "    public @Nullable V edgeValueOrDefault(EndpointPair<N> endpoints, @Nullable V defaultValue) {\n", "      return delegate().edgeValueOrDefault(transpose(endpoints), defaultValue);\n", "    }\n"], "4": ["    @Override\n", "    public Set<E> edgesConnecting(EndpointPair<N> endpoints) {\n", "      return delegate().edgesConnecting(transpose(endpoints));\n", "    }\n", "\n", "    @Override\n", "    public Optional<E> edgeConnecting(EndpointPair<N> endpoints) {\n", "      return delegate().edgeConnecting(transpose(endpoints));\n", "    }\n", "\n", "    @Override\n", "    public E edgeConnectingOrNull(EndpointPair<N> endpoints) {\n", "      return delegate().edgeConnectingOrNull(transpose(endpoints));\n", "    }\n", "\n", "\n", "    @Override\n", "    public boolean hasEdgeConnecting(EndpointPair<N> endpoints) {\n", "      return delegate().hasEdgeConnecting(transpose(endpoints));\n", "    }\n"]}, "removed": {}, "added_lines": {"1": [262, 263, 264, 265, 266, 267, 268], "2": [307, 308, 309, 310, 311], "3": [353, 354, 355, 356, 357, 363, 364, 365, 366, 367, 372, 373, 374, 375, 376], "4": [432, 433, 434, 435, 436, 442, 443, 444, 445, 446, 452, 453, 454, 455, 456, 461, 462, 463, 464, 465]}, "removed_lines": {}}, {"48": "guava/src/com/google/common/graph/MutableGraph.java", "added": {"1": ["   * Adds an edge connecting {@code nodeU} to {@code nodeV} if one is not already present.\n", "   *\n", "   * <p>If the graph is directed, the resultant edge will be directed; otherwise, it will be\n", "   * undirected.\n"], "2": ["  /**\n", "   * Adds an edge connecting {@code endpoints} (in the order, if any, specified by {@code\n", "   * endpoints}) if one is not already present.\n", "   *\n", "   * <p>If this graph is directed, {@code endpoints} must be ordered and the added edge will be\n", "   * directed; if it is undirected, the added edge will be undirected.\n", "   *\n", "   * <p>If this graph is directed, {@code endpoints} must be ordered.\n", "   *\n", "   * <p>If either or both endpoints are not already present in this graph, this method will silently\n", "   * {@link #addNode(Object) add} each missing endpoint to the graph.\n", "   *\n", "   * @return {@code true} if the graph was modified as a result of this call\n", "   * @throws IllegalArgumentException if the introduction of the edge would violate {@link\n", "   *     #allowsSelfLoops()}\n", "   * @throws IllegalArgumentException if the endpoints are unordered and the graph is directed\n", "   */\n", "  @CanIgnoreReturnValue\n", "  boolean putEdge(EndpointPair<N> endpoints);\n", "\n"], "3": ["\n", "  /**\n", "   * Removes the edge connecting {@code endpoints}, if it is present.\n", "   *\n", "   * <p>If this graph is directed, {@code endpoints} must be ordered.\n", "   *\n", "   * @throws IllegalArgumentException if the endpoints are unordered and the graph is directed\n", "   * @return {@code true} if the graph was modified as a result of this call\n", "   */\n", "  @CanIgnoreReturnValue\n", "  boolean removeEdge(EndpointPair<N> endpoints);\n"]}, "removed": {"1": ["   * Adds an edge connecting {@code nodeU} to {@code nodeV} if one is not already present. In an\n", "   * undirected graph, the edge will also connect {@code nodeV} to {@code nodeU}.\n"]}, "added_lines": {"1": [45, 46, 47, 48], "2": [60, 61, 62, 63, 64, 65, 66, 67, 68, 69, 70, 71, 72, 73, 74, 75, 76, 77, 78, 79], "3": [95, 96, 97, 98, 99, 100, 101, 102, 103, 104, 105]}, "removed_lines": {"1": [45, 46]}}, {"49": "guava/src/com/google/common/graph/MutableNetwork.java", "added": {"1": ["   * Adds {@code edge} connecting {@code nodeU} to {@code nodeV}.\n", "   * <p>If the graph is directed, {@code edge} will be directed in this graph; otherwise, it will be\n", "   * undirected.\n", "   *\n", "   * <p><b>{@code edge} must be unique to this graph</b>, just as a {@code Map} key must be. It must\n", "   * also be non-null.\n"], "2": ["   * @throws IllegalArgumentException if {@code edge} already exists in the graph and does not\n", "   *     connect {@code nodeU} to {@code nodeV}\n", "   * @throws IllegalArgumentException if the introduction of the edge would violate {@link\n", "  /**\n", "   * Adds {@code edge} connecting {@code endpoints}. In an undirected network, {@code edge} will\n", "   * also connect {@code nodeV} to {@code nodeU}.\n", "   *\n", "   * <p>If this graph is directed, {@code edge} will be directed in this graph; if it is undirected,\n", "   * {@code edge} will be undirected in this graph.\n", "   *\n", "   * <p>If this graph is directed, {@code endpoints} must be ordered.\n", "   *\n", "   * <p><b>{@code edge} must be unique to this graph</b>, just as a {@code Map} key must be. It must\n", "   * also be non-null.\n", "   *\n", "   * <p>If either or both endpoints are not already present in this graph, this method will silently\n", "   * {@link #addNode(Object) add} each missing endpoint to the graph.\n", "   *\n", "   * <p>If {@code edge} already connects an endpoint pair equal to {@code endpoints}, then this\n", "   * method will have no effect.\n", "   *\n", "   * @return {@code true} if the network was modified as a result of this call\n", "   * @throws IllegalArgumentException if {@code edge} already exists in the graph and connects some\n", "   *     other endpoint pair that is not equal to {@code endpoints}\n", "   * @throws IllegalArgumentException if the introduction of the edge would violate {@link\n", "   *     #allowsParallelEdges()} or {@link #allowsSelfLoops()}\n", "   * @throws IllegalArgumentException if the endpoints are unordered and the graph is directed\n", "   */\n", "  @CanIgnoreReturnValue\n", "  boolean addEdge(EndpointPair<N> endpoints, E edge);\n", "\n"]}, "removed": {"1": ["   * Adds {@code edge} connecting {@code nodeU} to {@code nodeV}. In an undirected network, the edge\n", "   * will also connect {@code nodeV} to {@code nodeU}.\n", "   * <p><b>Edges must be unique</b>, just as {@code Map} keys must be. They must also be non-null.\n"], "2": ["   * @throws IllegalArgumentException if {@code edge} already exists and does not connect {@code\n", "   *     nodeU} to {@code nodeV}, or if the introduction of the edge would violate {@link\n"]}, "added_lines": {"1": [46, 48, 49, 50, 51, 52], "2": [61, 62, 63, 69, 70, 71, 72, 73, 74, 75, 76, 77, 78, 79, 80, 81, 82, 83, 84, 85, 86, 87, 88, 89, 90, 91, 92, 93, 94, 95, 96]}, "removed_lines": {"1": [46, 47, 49], "2": [58, 59]}}, {"50": "guava/src/com/google/common/graph/MutableValueGraph.java", "added": {"1": ["   * Adds an edge connecting {@code nodeU} to {@code nodeV} if one is not already present, and\n", "   * sets a value for that edge to {@code value} (overwriting the existing value, if any).\n", "   *\n", "   * <p>If the graph is directed, the resultant edge will be directed; otherwise, it will be\n", "   * undirected.\n"], "2": ["  /**\n", "   * Adds an edge connecting {@code endpoints} if one is not already present, and sets a value for\n", "   * that edge to {@code value} (overwriting the existing value, if any).\n", "   *\n", "   * <p>If the graph is directed, the resultant edge will be directed; otherwise, it will be\n", "   * undirected.\n", "   *\n", "   * <p>If this graph is directed, {@code endpoints} must be ordered.\n", "   *\n", "   * <p>Values do not have to be unique. However, values must be non-null.\n", "   *\n", "   * <p>If either or both endpoints are not already present in this graph, this method will silently\n", "   * {@link #addNode(Object) add} each missing endpoint to the graph.\n", "   *\n", "   * @return the value previously associated with the edge connecting {@code nodeU} to {@code\n", "   *     nodeV}, or null if there was no such edge.\n", "   * @throws IllegalArgumentException if the introduction of the edge would violate {@link\n", "   *     #allowsSelfLoops()}\n", "   * @throws IllegalArgumentException if the endpoints are unordered and the graph is directed\n", "   */\n", "  @CanIgnoreReturnValue\n", "  V putEdgeValue(EndpointPair<N> endpoints, V value);\n", "\n"], "3": ["\n", "  /**\n", "   * Removes the edge connecting {@code endpoints}, if it is present.\n", "   *\n", "   * <p>If this graph is directed, {@code endpoints} must be ordered.\n", "   *\n", "   * @return the value previously associated with the edge connecting {@code endpoints}, or null if\n", "   *     there was no such edge.\n", "   */\n", "  @CanIgnoreReturnValue\n", "  V removeEdge(EndpointPair<N> endpoints);\n"]}, "removed": {"1": ["   * Adds an edge connecting {@code nodeU} to {@code nodeV} if one is not already present; associate\n", "   * that edge with {@code value}. In an undirected graph, the edge will also connect {@code nodeV}\n", "   * to {@code nodeU}.\n"]}, "added_lines": {"1": [45, 46, 47, 48, 49], "2": [64, 65, 66, 67, 68, 69, 70, 71, 72, 73, 74, 75, 76, 77, 78, 79, 80, 81, 82, 83, 84, 85, 86], "3": [103, 104, 105, 106, 107, 108, 109, 110, 111, 112, 113]}, "removed_lines": {"1": [45, 46, 47]}}, {"51": "guava/src/com/google/common/graph/Network.java", "added": {"1": ["   * Returns the set of edges that each directly connect {@code nodeU} to {@code nodeV}.\n"], "2": ["   * Returns the set of edges that each directly connect {@code endpoints} (in the order, if any,\n", "   * specified by {@code endpoints}).\n", "   *\n", "   * <p>The resulting set of edges will be parallel (i.e. have equal {@link #incidentNodes(Object)}.\n", "   * If this network does not {@link #allowsParallelEdges() allow parallel edges}, the resulting set\n", "   * will contain at most one edge (equivalent to {@code edgeConnecting(endpoints).asSet()}).\n", "   *\n", "   * <p>If this network is directed, {@code endpoints} must be ordered.\n", "   *\n", "   * @throws IllegalArgumentException if either endpoint is not an element of this network\n", "   * @throws IllegalArgumentException if the endpoints are unordered and the graph is directed\n", "   * @since NEXT\n", "   */\n", "  Set<E> edgesConnecting(EndpointPair<N> endpoints);\n", "\n", "  /**\n", "   * Returns the single edge that directly connects {@code nodeU} to {@code nodeV}, if one is\n", "   * present, or {@code Optional.empty()} if no such edge exists.\n"], "3": ["   * Returns the single edge that directly connects {@code endpoints} (in the order, if any,\n", "   * specified by {@code endpoints}), if one is present, or {@code Optional.empty()} if no such edge\n", "   * exists.\n", "   *\n", "   * <p>If this graph is directed, the endpoints must be ordered.\n", "   *\n", "   * @throws IllegalArgumentException if there are multiple parallel edges connecting {@code nodeU}\n", "   *     to {@code nodeV}\n", "   * @throws IllegalArgumentException if either endpoint is not an element of this network\n", "   * @throws IllegalArgumentException if the endpoints are unordered and the graph is directed\n", "   * @since NEXT\n", "   */\n", "  Optional<E> edgeConnecting(EndpointPair<N> endpoints);\n", "\n", "  /**\n", "   * Returns the single edge that directly connects {@code nodeU} to {@code nodeV}, if one is\n", "   * present, or {@code null} if no such edge exists.\n"], "4": ["   * Returns the single edge that directly connects {@code endpoints} (in the order, if any,\n", "   * specified by {@code endpoints}), if one is present, or {@code null} if no such edge exists.\n", "   *\n", "   * <p>If this graph is directed, the endpoints must be ordered.\n", "   *\n", "   * @throws IllegalArgumentException if there are multiple parallel edges connecting {@code nodeU}\n", "   *     to {@code nodeV}\n", "   * @throws IllegalArgumentException if either endpoint is not an element of this network\n", "   * @throws IllegalArgumentException if the endpoints are unordered and the graph is directed\n", "   * @since NEXT\n", "   */\n", "  @Nullable\n", "  E edgeConnectingOrNull(EndpointPair<N> endpoints);\n", "\n", "  /**\n", "   * Returns true if there is an edge that directly connects {@code nodeU} to {@code nodeV}. This is\n"], "5": ["  /**\n", "   * Returns true if there is an edge that directly connects {@code endpoints} (in the order, if\n", "   * any, specified by {@code endpoints}).\n", "   *\n", "   * <p>Unlike the other {@code EndpointPair}-accepting methods, this method does not throw if the\n", "   * endpoints are unordered and the graph is directed; it simply returns {@code false}. This is for\n", "   * consistency with {@link Graph#hasEdgeConnecting(EndpointPair)} and {@link\n", "   * ValueGraph#hasEdgeConnecting(EndpointPair)}.\n", "   *\n", "   * @since NEXT\n", "   */\n", "  boolean hasEdgeConnecting(EndpointPair<N> endpoints);\n", "\n"]}, "removed": {"1": ["   * Returns the set of edges directly connecting {@code nodeU} to {@code nodeV}.\n"], "2": ["   * Returns the single edge directly connecting {@code nodeU} to {@code nodeV}, if one is present,\n", "   * or {@code Optional.empty()} if no such edge exists.\n"], "3": ["   * Returns the single edge directly connecting {@code nodeU} to {@code nodeV}, if one is present,\n", "   * or {@code null} if no such edge exists.\n"], "4": ["   * Returns true if there is an edge directly connecting {@code nodeU} to {@code nodeV}. This is\n"]}, "added_lines": {"1": [275], "2": [289, 290, 291, 292, 293, 294, 295, 296, 297, 298, 299, 300, 301, 302, 303, 304, 305, 306], "3": [319, 320, 321, 322, 323, 324, 325, 326, 327, 328, 329, 330, 331, 332, 333, 334, 335], "4": [349, 350, 351, 352, 353, 354, 355, 356, 357, 358, 359, 360, 361, 362, 363, 364], "5": [374, 375, 376, 377, 378, 379, 380, 381, 382, 383, 384, 385, 386]}, "removed_lines": {"1": [275], "2": [289, 290], "3": [303, 304], "4": [318]}}, {"52": "guava/src/com/google/common/graph/ValueGraph.java", "added": {"1": ["   * Returns true if there is an edge that directly connects {@code nodeU} to {@code nodeV}. This is\n"], "2": ["   * Returns true if there is an edge that directly connects {@code endpoints} (in the order, if\n", "   * any, specified by {@code endpoints}). This is equivalent to {@code\n", "   * edges().contains(endpoints)}.\n", "   * <p>Unlike the other {@code EndpointPair}-accepting methods, this method does not throw if the\n", "   * endpoints are unordered and the graph is directed; it simply returns {@code false}. This is for\n", "   * consistency with the behavior of {@link Collection#contains(Object)} (which does not generally\n", "   * throw if the object cannot be present in the collection), and the desire to have this method's\n", "   * behavior be compatible with {@code edges().contains(endpoints)}.\n", "   *\n", "   * @since NEXT\n", "   */\n", "  @Override\n", "  boolean hasEdgeConnecting(EndpointPair<N> endpoints);\n", "\n", "  /**\n", "   * Returns the value of the edge that connects {@code nodeU} to {@code nodeV} (in the order, if\n", "   * any, specified by {@code endpoints}), if one is present;\n", "   * otherwise, returns {@code Optional.empty()}.\n"], "3": ["   * Returns the value of the edge that connects {@code endpoints} (in the order, if any, specified\n", "   * by {@code endpoints}), if one is present; otherwise, returns {@code Optional.empty()}.\n", "   *\n", "   * <p>If this graph is directed, the endpoints must be ordered.\n", "   *\n", "   * @throws IllegalArgumentException if either endpoint is not an element of this graph\n", "   * @throws IllegalArgumentException if the endpoints are unordered and the graph is directed\n", "   * @since NEXT\n", "   */\n", "  Optional<V> edgeValue(EndpointPair<N> endpoints);\n", "\n", "  /**\n", "   * Returns the value of the edge that connects {@code nodeU} to {@code nodeV}, if one is present;\n"], "4": ["  /**\n", "   * Returns the value of the edge that connects {@code endpoints} (in the order, if any, specified\n", "   * by {@code endpoints}), if one is present; otherwise, returns {@code defaultValue}.\n", "   *\n", "   * <p>If this graph is directed, the endpoints must be ordered.\n", "   *\n", "   * @throws IllegalArgumentException if either endpoint is not an element of this graph\n", "   * @throws IllegalArgumentException if the endpoints are unordered and the graph is directed\n", "   * @since NEXT\n", "   */\n", "  @Nullable\n", "  V edgeValueOrDefault(EndpointPair<N> endpoints, @Nullable V defaultValue);\n", "\n"]}, "removed": {"1": ["   * Returns true if there is an edge directly connecting {@code nodeU} to {@code nodeV}. This is\n"], "2": ["   * Returns the value of the edge connecting {@code nodeU} to {@code nodeV}, if one is present;\n", "   * otherwise, returns {@code Optional.empty()}.\n", "   * <p>In an undirected graph, this is equal to {@code edgeValue(nodeV, nodeU)}.\n"], "3": ["   * Returns the value of the edge connecting {@code nodeU} to {@code nodeV}, if one is present;\n"]}, "added_lines": {"1": [238], "2": [249, 250, 251, 253, 254, 255, 256, 257, 258, 259, 260, 261, 262, 263, 264, 265, 266, 267], "3": [276, 277, 278, 279, 280, 281, 282, 283, 284, 285, 286, 287, 288], "4": [300, 301, 302, 303, 304, 305, 306, 307, 308, 309, 310, 311, 312]}, "removed_lines": {"1": [238], "2": [249, 250, 252], "3": [261]}}]}
