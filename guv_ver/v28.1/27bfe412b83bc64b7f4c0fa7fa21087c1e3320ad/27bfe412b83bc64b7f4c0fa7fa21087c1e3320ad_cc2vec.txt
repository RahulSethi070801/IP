{"id": "27bfe412b83bc64b7f4c0fa7fa21087c1e3320ad", "code": [{"0": "android/guava-tests/test/com/google/common/util/concurrent/ServiceManagerTest.java", "added": {"1": ["  public void testDoCancelStart() throws TimeoutException {\n", "    Service a =\n", "        new AbstractService() {\n", "          @Override\n", "          protected void doStart() {\n", "            // Never starts!\n", "          }\n", "\n", "          @Override\n", "          protected void doCancelStart() {\n", "            assertThat(state()).isEqualTo(Service.State.STOPPING);\n", "            notifyStopped();\n", "          }\n", "\n", "          @Override\n", "          protected void doStop() {\n", "            throw new AssertionError(); // Should not be called.\n", "          }\n", "        };\n", "\n", "    final ServiceManager manager = new ServiceManager(asList(a));\n", "    manager.startAsync();\n", "    manager.stopAsync();\n", "    manager.awaitStopped(10, TimeUnit.MILLISECONDS);\n", "    assertThat(manager.servicesByState().keySet()).containsExactly(Service.State.TERMINATED);\n", "  }\n", "\n", "  public void testNotifyStoppedAfterFailure() throws TimeoutException {\n", "    Service a =\n", "        new AbstractService() {\n", "          @Override\n", "          protected void doStart() {\n", "            notifyFailed(new IllegalStateException(\"start failure\"));\n", "            notifyStopped(); // This will be a no-op.\n", "          }\n", "\n", "          @Override\n", "          protected void doStop() {\n", "            notifyStopped();\n", "          }\n", "        };\n", "    final ServiceManager manager = new ServiceManager(asList(a));\n", "    manager.startAsync();\n", "    manager.awaitStopped(10, TimeUnit.MILLISECONDS);\n", "    assertThat(manager.servicesByState().keySet()).containsExactly(Service.State.FAILED);\n", "  }\n", "\n"]}, "removed": {}, "added_lines": {"1": [342, 343, 344, 345, 346, 347, 348, 349, 350, 351, 352, 353, 354, 355, 356, 357, 358, 359, 360, 361, 362, 363, 364, 365, 366, 367, 368, 369, 370, 371, 372, 373, 374, 375, 376, 377, 378, 379, 380, 381, 382, 383, 384, 385, 386, 387, 388]}, "removed_lines": {}}, {"1": "android/guava/src/com/google/common/util/concurrent/AbstractService.java", "added": {"1": ["  private static final ListenerCallQueue.Event<Listener> TERMINATED_FROM_STARTING_EVENT =\n", "      terminatedEvent(STARTING);\n"], "2": ["   *\n", "   * <p>If {@link #stopAsync} is called on a {@link State#STARTING} service, this method is not\n", "   * invoked immediately. Instead, it will be deferred until after the service is {@link\n", "   * State#RUNNING}. Services that need to cancel startup work can override {#link #doCancelStart}.\n", "  /**\n", "   * This method is called by {@link #stopAsync} when the service is still starting (i.e. {@link\n", "   * #startAsync} has been called but {@link #notifyStarted} has not). Subclasses can override the\n", "   * method to cancel pending work and then call {@link #notifyStopped} to stop the service.\n", "   *\n", "   * <p>This method should return promptly; prefer to do work on a different thread where it is\n", "   * convenient. It is invoked exactly once on service shutdown, even when {@link #stopAsync} is\n", "   * called multiple times.\n", "   *\n", "   * <p>When this method is called {@link #state()} will return {@link State#STOPPING}, which\n", "   * is the external state observable by the caller of {@link #stopAsync}.\n", "   *\n", "   * @since NEXT\n", "   */\n", "  @ForOverride\n", "  protected void doCancelStart() {}\n", "\n"], "3": ["            doCancelStart();\n"], "5": ["   * the service to transition from {@link State#STARTING} or {@link State#STOPPING} to {@link\n", "   * State#TERMINATED}.\n", "   * @throws IllegalStateException if the service is not one of {@link State#STOPPING}, {@link\n", "   *     State#STARTING}, or {@link State#RUNNING}.\n", "      State previous = state();\n", "      switch (previous) {\n", "        case NEW:\n", "        case TERMINATED:\n", "        case FAILED:\n", "          throw new IllegalStateException(\"Cannot notifyStopped() when the service is \" + previous);\n", "        case RUNNING:\n", "        case STARTING:\n", "        case STOPPING:\n", "          snapshot = new StateSnapshot(TERMINATED);\n", "          enqueueTerminatedEvent(previous);\n", "          break;\n"], "7": ["      case STARTING:\n", "        listeners.enqueue(TERMINATED_FROM_STARTING_EVENT);\n", "        break;\n"]}, "removed": {"4": ["          default:\n", "            throw new AssertionError(\"Unexpected state: \" + previous);\n"], "5": ["   * the service to transition from {@link State#STOPPING} to {@link State#TERMINATED}.\n", "   * @throws IllegalStateException if the service is neither {@link State#STOPPING} nor {@link\n", "   *     State#RUNNING}.\n", "      // We check the internal state of the snapshot instead of state() directly so we don't allow\n", "      // notifyStopped() to be called while STARTING, even if stop() has already been called.\n", "      State previous = snapshot.state;\n", "      if (previous != STOPPING && previous != RUNNING) {\n", "        IllegalStateException failure =\n", "            new IllegalStateException(\"Cannot notifyStopped() when the service is \" + previous);\n", "        notifyFailed(failure);\n", "        throw failure;\n", "      snapshot = new StateSnapshot(TERMINATED);\n", "      enqueueTerminatedEvent(previous);\n"], "6": ["        default:\n", "          throw new AssertionError(\"Unexpected state: \" + previous);\n"], "7": ["      case STARTING:\n", "      default:\n"]}, "added_lines": {"1": [84, 85], "2": [216, 217, 218, 219, 224, 225, 226, 227, 228, 229, 230, 231, 232, 233, 234, 235, 236, 237, 238, 239, 240], "3": [275], "5": [409, 410, 412, 413, 418, 419, 420, 421, 422, 423, 424, 425, 426, 427, 428, 429], "7": [528, 529, 530]}, "removed_lines": {"4": [263, 264], "5": [387, 389, 390, 395, 396, 397, 398, 399, 400, 401, 402, 404, 405], "6": [436, 437], "7": [511, 514]}}, {"2": "android/guava/src/com/google/common/util/concurrent/Service.java", "added": {"1": ["     * @param from The previous state that is being transitioned from. Failure can occur in any\n", "     *     state with the exception of {@linkplain State#FAILED FAILED} and {@linkplain\n", "     *     State#TERMINATED TERMINATED}.\n"]}, "removed": {"1": ["     * @param from The previous state that is being transitioned from. The only valid values for\n", "     *     this are {@linkplain State#NEW NEW}, {@linkplain State#RUNNING RUNNING} or {@linkplain\n", "     *     State#STOPPING STOPPING}.\n"]}, "added_lines": {"1": [272, 273, 274]}, "removed_lines": {"1": [272, 273, 274]}}, {"3": "guava-tests/test/com/google/common/util/concurrent/ServiceManagerTest.java", "added": {"1": ["  public void testDoCancelStart() throws TimeoutException {\n", "    Service a =\n", "        new AbstractService() {\n", "          @Override\n", "          protected void doStart() {\n", "            // Never starts!\n", "          }\n", "\n", "          @Override\n", "          protected void doCancelStart() {\n", "            assertThat(state()).isEqualTo(Service.State.STOPPING);\n", "            notifyStopped();\n", "          }\n", "\n", "          @Override\n", "          protected void doStop() {\n", "            throw new AssertionError(); // Should not be called.\n", "          }\n", "        };\n", "\n", "    final ServiceManager manager = new ServiceManager(asList(a));\n", "    manager.startAsync();\n", "    manager.stopAsync();\n", "    manager.awaitStopped(10, TimeUnit.MILLISECONDS);\n", "    assertThat(manager.servicesByState().keySet()).containsExactly(Service.State.TERMINATED);\n", "  }\n", "\n", "  public void testNotifyStoppedAfterFailure() throws TimeoutException {\n", "    Service a =\n", "        new AbstractService() {\n", "          @Override\n", "          protected void doStart() {\n", "            notifyFailed(new IllegalStateException(\"start failure\"));\n", "            notifyStopped(); // This will be a no-op.\n", "          }\n", "\n", "          @Override\n", "          protected void doStop() {\n", "            notifyStopped();\n", "          }\n", "        };\n", "    final ServiceManager manager = new ServiceManager(asList(a));\n", "    manager.startAsync();\n", "    manager.awaitStopped(10, TimeUnit.MILLISECONDS);\n", "    assertThat(manager.servicesByState().keySet()).containsExactly(Service.State.FAILED);\n", "  }\n", "\n"]}, "removed": {}, "added_lines": {"1": [342, 343, 344, 345, 346, 347, 348, 349, 350, 351, 352, 353, 354, 355, 356, 357, 358, 359, 360, 361, 362, 363, 364, 365, 366, 367, 368, 369, 370, 371, 372, 373, 374, 375, 376, 377, 378, 379, 380, 381, 382, 383, 384, 385, 386, 387, 388]}, "removed_lines": {}}, {"4": "guava/src/com/google/common/util/concurrent/AbstractService.java", "added": {"1": ["  private static final ListenerCallQueue.Event<Listener> TERMINATED_FROM_STARTING_EVENT =\n", "      terminatedEvent(STARTING);\n"], "2": ["   *\n", "   * <p>If {@link #stopAsync} is called on a {@link State#STARTING} service, this method is not\n", "   * invoked immediately. Instead, it will be deferred until after the service is {@link\n", "   * State#RUNNING}. Services that need to cancel startup work can override {#link #doCancelStart}.\n", "  /**\n", "   * This method is called by {@link #stopAsync} when the service is still starting (i.e. {@link\n", "   * #startAsync} has been called but {@link #notifyStarted} has not). Subclasses can override the\n", "   * method to cancel pending work and then call {@link #notifyStopped} to stop the service.\n", "   *\n", "   * <p>This method should return promptly; prefer to do work on a different thread where it is\n", "   * convenient. It is invoked exactly once on service shutdown, even when {@link #stopAsync} is\n", "   * called multiple times.\n", "   *\n", "   * <p>When this method is called {@link #state()} will return {@link State#STOPPING}, which\n", "   * is the external state observable by the caller of {@link #stopAsync}.\n", "   *\n", "   * @since NEXT\n", "   */\n", "  @ForOverride\n", "  protected void doCancelStart() {}\n", "\n"], "3": ["            doCancelStart();\n"], "5": ["   * the service to transition from {@link State#STARTING} or {@link State#STOPPING} to {@link\n", "   * State#TERMINATED}.\n", "   * @throws IllegalStateException if the service is not one of {@link State#STOPPING}, {@link\n", "   *     State#STARTING}, or {@link State#RUNNING}.\n", "      State previous = state();\n", "      switch (previous) {\n", "        case NEW:\n", "        case TERMINATED:\n", "        case FAILED:\n", "          throw new IllegalStateException(\"Cannot notifyStopped() when the service is \" + previous);\n", "        case RUNNING:\n", "        case STARTING:\n", "        case STOPPING:\n", "          snapshot = new StateSnapshot(TERMINATED);\n", "          enqueueTerminatedEvent(previous);\n", "          break;\n"], "7": ["      case STARTING:\n", "        listeners.enqueue(TERMINATED_FROM_STARTING_EVENT);\n", "        break;\n"]}, "removed": {"4": ["          default:\n", "            throw new AssertionError(\"Unexpected state: \" + previous);\n"], "5": ["   * the service to transition from {@link State#STOPPING} to {@link State#TERMINATED}.\n", "   * @throws IllegalStateException if the service is neither {@link State#STOPPING} nor {@link\n", "   *     State#RUNNING}.\n", "      // We check the internal state of the snapshot instead of state() directly so we don't allow\n", "      // notifyStopped() to be called while STARTING, even if stop() has already been called.\n", "      State previous = snapshot.state;\n", "      if (previous != STOPPING && previous != RUNNING) {\n", "        IllegalStateException failure =\n", "            new IllegalStateException(\"Cannot notifyStopped() when the service is \" + previous);\n", "        notifyFailed(failure);\n", "        throw failure;\n", "      snapshot = new StateSnapshot(TERMINATED);\n", "      enqueueTerminatedEvent(previous);\n"], "6": ["        default:\n", "          throw new AssertionError(\"Unexpected state: \" + previous);\n"], "7": ["      case STARTING:\n", "      default:\n"]}, "added_lines": {"1": [84, 85], "2": [216, 217, 218, 219, 224, 225, 226, 227, 228, 229, 230, 231, 232, 233, 234, 235, 236, 237, 238, 239, 240], "3": [275], "5": [409, 410, 412, 413, 418, 419, 420, 421, 422, 423, 424, 425, 426, 427, 428, 429], "7": [528, 529, 530]}, "removed_lines": {"4": [263, 264], "5": [387, 389, 390, 395, 396, 397, 398, 399, 400, 401, 402, 404, 405], "6": [436, 437], "7": [511, 514]}}, {"5": "guava/src/com/google/common/util/concurrent/Service.java", "added": {"1": ["     * @param from The previous state that is being transitioned from. Failure can occur in any\n", "     *     state with the exception of {@linkplain State#FAILED FAILED} and {@linkplain\n", "     *     State#TERMINATED TERMINATED}.\n"]}, "removed": {"1": ["     * @param from The previous state that is being transitioned from. The only valid values for\n", "     *     this are {@linkplain State#NEW NEW}, {@linkplain State#RUNNING RUNNING} or {@linkplain\n", "     *     State#STOPPING STOPPING}.\n"]}, "added_lines": {"1": [272, 273, 274]}, "removed_lines": {"1": [272, 273, 274]}}]}
