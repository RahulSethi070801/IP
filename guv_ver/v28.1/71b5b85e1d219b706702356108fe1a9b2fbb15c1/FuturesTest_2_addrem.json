{
    "addition": {
        "41": "import static com.google.common.util.concurrent.Futures.scheduleAsync;\n",
        "42": "import static com.google.common.util.concurrent.Futures.submitAsync;\n",
        "56": "import static java.util.concurrent.Executors.newSingleThreadScheduledExecutor;\n",
        "85": "import java.util.concurrent.ScheduledExecutorService;\n",
        "1734": "    executor.execute(\n",
        "1735": "        new Runnable() {\n",
        "1736": "          @Override\n",
        "1737": "          public void run() {\n",
        "1738": "            awaitUninterruptibly(beforeFunction);\n",
        "1739": "          }\n",
        "1740": "        });\n",
        "1748": "    executor.shutdown();\n",
        "1749": "    assertTrue(executor.awaitTermination(5, SECONDS));\n",
        "1754": "  public void testSubmitAsync_asyncCallable_error() throws InterruptedException {\n",
        "1755": "    final Error error = new Error(\"deliberate\");\n",
        "1756": "    AsyncCallable<Integer> callable =\n",
        "1757": "        new AsyncCallable<Integer>() {\n",
        "1758": "          @Override\n",
        "1759": "          public ListenableFuture<Integer> call() {\n",
        "1760": "            throw error;\n",
        "1761": "          }\n",
        "1762": "        };\n",
        "1763": "    SettableFuture<String> inputFuture = SettableFuture.create();\n",
        "1764": "    ListenableFuture<Integer> outputFuture = submitAsync(callable, directExecutor());\n",
        "1765": "    inputFuture.set(\"value\");\n",
        "1766": "    try {\n",
        "1767": "      getDone(outputFuture);\n",
        "1768": "      fail();\n",
        "1769": "    } catch (ExecutionException expected) {\n",
        "1770": "      assertSame(error, expected.getCause());\n",
        "1771": "    }\n",
        "1772": "  }\n",
        "1773": "\n",
        "1774": "  public void testSubmitAsync_asyncCallable_nullInsteadOfFuture() throws Exception {\n",
        "1775": "    ListenableFuture<?> chainedFuture = submitAsync(constantAsyncCallable(null), directExecutor());\n",
        "1776": "    try {\n",
        "1777": "      getDone(chainedFuture);\n",
        "1778": "      fail();\n",
        "1779": "    } catch (ExecutionException expected) {\n",
        "1780": "      NullPointerException cause = (NullPointerException) expected.getCause();\n",
        "1781": "      assertThat(cause)\n",
        "1782": "          .hasMessage(\n",
        "1783": "              \"AsyncCallable.call returned null instead of a Future. \"\n",
        "1784": "                  + \"Did you mean to return immediateFuture(null)?\");\n",
        "1785": "    }\n",
        "1786": "  }\n",
        "1787": "\n",
        "1788": "  @GwtIncompatible // threads\n",
        "1789": "\n",
        "1790": "  public void testSubmitAsync_asyncCallable_cancelledWhileApplyingFunction()\n",
        "1791": "      throws InterruptedException, ExecutionException {\n",
        "1792": "    final CountDownLatch inFunction = new CountDownLatch(1);\n",
        "1793": "    final CountDownLatch callableDone = new CountDownLatch(1);\n",
        "1794": "    final SettableFuture<Integer> resultFuture = SettableFuture.create();\n",
        "1795": "    AsyncCallable<Integer> callable =\n",
        "1796": "        new AsyncCallable<Integer>() {\n",
        "1797": "          @Override\n",
        "1798": "          public ListenableFuture<Integer> call() throws InterruptedException {\n",
        "1799": "            inFunction.countDown();\n",
        "1800": "            callableDone.await();\n",
        "1801": "            return resultFuture;\n",
        "1802": "          }\n",
        "1803": "        };\n",
        "1804": "    SettableFuture<String> inputFuture = SettableFuture.create();\n",
        "1805": "    ListenableFuture<Integer> future = submitAsync(callable, newSingleThreadExecutor());\n",
        "1806": "    inputFuture.set(\"value\");\n",
        "1807": "    inFunction.await();\n",
        "1808": "    future.cancel(false);\n",
        "1809": "    callableDone.countDown();\n",
        "1810": "    try {\n",
        "1811": "      future.get();\n",
        "1812": "      fail();\n",
        "1813": "    } catch (CancellationException expected) {\n",
        "1814": "    }\n",
        "1815": "    try {\n",
        "1816": "      resultFuture.get();\n",
        "1817": "      fail();\n",
        "1818": "    } catch (CancellationException expected) {\n",
        "1819": "    }\n",
        "1820": "  }\n",
        "1821": "\n",
        "1822": "  @GwtIncompatible // threads\n",
        "1823": "\n",
        "1824": "  public void testSubmitAsync_asyncCallable_cancelledBeforeApplyingFunction()\n",
        "1825": "      throws InterruptedException {\n",
        "1826": "    final AtomicBoolean callableCalled = new AtomicBoolean();\n",
        "1827": "    AsyncCallable<Integer> callable =\n",
        "1828": "        new AsyncCallable<Integer>() {\n",
        "1829": "          @Override\n",
        "1830": "          public ListenableFuture<Integer> call() {\n",
        "1831": "            callableCalled.set(true);\n",
        "1832": "            return immediateFuture(1);\n",
        "1833": "          }\n",
        "1834": "        };\n",
        "1835": "    ExecutorService executor = newSingleThreadExecutor();\n",
        "1836": "    // Pause the executor.\n",
        "1837": "    final CountDownLatch beforeFunction = new CountDownLatch(1);\n",
        "1838": "    executor.execute(\n",
        "1839": "        new Runnable() {\n",
        "1840": "          @Override\n",
        "1841": "          public void run() {\n",
        "1842": "            awaitUninterruptibly(beforeFunction);\n",
        "1843": "          }\n",
        "1844": "        });\n",
        "1845": "    ListenableFuture<Integer> future = submitAsync(callable, executor);\n",
        "1846": "    future.cancel(false);\n",
        "1847": "\n",
        "1848": "    // Unpause the executor.\n",
        "1849": "    beforeFunction.countDown();\n",
        "1850": "    executor.shutdown();\n",
        "1851": "    assertTrue(executor.awaitTermination(5, SECONDS));\n",
        "1852": "\n",
        "1853": "    assertFalse(callableCalled.get());\n",
        "1854": "  }\n",
        "1855": "\n",
        "1856": "  @GwtIncompatible // threads\n",
        "1857": "\n",
        "1858": "  public void testScheduleAsync_asyncCallable_error() throws InterruptedException {\n",
        "1859": "    final Error error = new Error(\"deliberate\");\n",
        "1860": "    AsyncCallable<Integer> callable =\n",
        "1861": "        new AsyncCallable<Integer>() {\n",
        "1862": "          @Override\n",
        "1863": "          public ListenableFuture<Integer> call() {\n",
        "1864": "            throw error;\n",
        "1865": "          }\n",
        "1866": "        };\n",
        "1867": "    SettableFuture<String> inputFuture = SettableFuture.create();\n",
        "1868": "    ListenableFuture<Integer> outputFuture = submitAsync(callable, directExecutor());\n",
        "1869": "    inputFuture.set(\"value\");\n",
        "1870": "    try {\n",
        "1871": "      getDone(outputFuture);\n",
        "1872": "      fail();\n",
        "1873": "    } catch (ExecutionException expected) {\n",
        "1874": "      assertSame(error, expected.getCause());\n",
        "1875": "    }\n",
        "1876": "  }\n",
        "1877": "\n",
        "1878": "  @GwtIncompatible // threads\n",
        "1879": "\n",
        "1880": "  public void testScheduleAsync_asyncCallable_nullInsteadOfFuture() throws Exception {\n",
        "1881": "    ListenableFuture<?> chainedFuture =\n",
        "1882": "        scheduleAsync(\n",
        "1883": "            constantAsyncCallable(null),\n",
        "1884": "            1,\n",
        "1885": "            TimeUnit.NANOSECONDS,\n",
        "1886": "            newSingleThreadScheduledExecutor());\n",
        "1887": "    try {\n",
        "1888": "      chainedFuture.get();\n",
        "1889": "      fail();\n",
        "1890": "    } catch (ExecutionException expected) {\n",
        "1891": "      NullPointerException cause = (NullPointerException) expected.getCause();\n",
        "1892": "      assertThat(cause)\n",
        "1893": "          .hasMessage(\n",
        "1894": "              \"AsyncCallable.call returned null instead of a Future. \"\n",
        "1895": "                  + \"Did you mean to return immediateFuture(null)?\");\n",
        "1896": "    }\n",
        "1897": "  }\n",
        "1898": "\n",
        "1899": "  @GwtIncompatible // threads\n",
        "1900": "\n",
        "1901": "  public void testScheduleAsync_asyncCallable_cancelledWhileApplyingFunction()\n",
        "1902": "      throws InterruptedException, ExecutionException {\n",
        "1903": "    final CountDownLatch inFunction = new CountDownLatch(1);\n",
        "1904": "    final CountDownLatch callableDone = new CountDownLatch(1);\n",
        "1905": "    final SettableFuture<Integer> resultFuture = SettableFuture.create();\n",
        "1906": "    AsyncCallable<Integer> callable =\n",
        "1907": "        new AsyncCallable<Integer>() {\n",
        "1908": "          @Override\n",
        "1909": "          public ListenableFuture<Integer> call() throws InterruptedException {\n",
        "1910": "            inFunction.countDown();\n",
        "1911": "            callableDone.await();\n",
        "1912": "            return resultFuture;\n",
        "1913": "          }\n",
        "1914": "        };\n",
        "1915": "    ListenableFuture<Integer> future =\n",
        "1916": "        scheduleAsync(callable, 1, TimeUnit.NANOSECONDS, newSingleThreadScheduledExecutor());\n",
        "1917": "    inFunction.await();\n",
        "1918": "    future.cancel(false);\n",
        "1919": "    callableDone.countDown();\n",
        "1920": "    try {\n",
        "1921": "      future.get();\n",
        "1922": "      fail();\n",
        "1923": "    } catch (CancellationException expected) {\n",
        "1924": "    }\n",
        "1925": "    try {\n",
        "1926": "      resultFuture.get();\n",
        "1927": "      fail();\n",
        "1928": "    } catch (CancellationException expected) {\n",
        "1929": "    }\n",
        "1930": "  }\n",
        "1931": "\n",
        "1932": "  @GwtIncompatible // threads\n",
        "1933": "\n",
        "1934": "  public void testScheduleAsync_asyncCallable_cancelledBeforeCallingFunction()\n",
        "1935": "      throws InterruptedException {\n",
        "1936": "    final AtomicBoolean callableCalled = new AtomicBoolean();\n",
        "1937": "    AsyncCallable<Integer> callable =\n",
        "1938": "        new AsyncCallable<Integer>() {\n",
        "1939": "          @Override\n",
        "1940": "          public ListenableFuture<Integer> call() {\n",
        "1941": "            callableCalled.set(true);\n",
        "1942": "            return immediateFuture(1);\n",
        "1943": "          }\n",
        "1944": "        };\n",
        "1945": "    ScheduledExecutorService executor = newSingleThreadScheduledExecutor();\n",
        "1946": "    // Pause the executor.\n",
        "1947": "    final CountDownLatch beforeFunction = new CountDownLatch(1);\n",
        "1948": "    executor.execute(\n",
        "1949": "        new Runnable() {\n",
        "1950": "          @Override\n",
        "1951": "          public void run() {\n",
        "1952": "            awaitUninterruptibly(beforeFunction);\n",
        "1953": "          }\n",
        "1954": "        });\n",
        "1955": "    ListenableFuture<Integer> future = scheduleAsync(callable, 1, TimeUnit.NANOSECONDS, executor);\n",
        "1956": "    future.cancel(false);\n",
        "1957": "\n",
        "1958": "    // Unpause the executor.\n",
        "1959": "    beforeFunction.countDown();\n",
        "1960": "    executor.shutdown();\n",
        "1961": "    assertTrue(executor.awaitTermination(5, SECONDS));\n",
        "1962": "\n",
        "1963": "    assertFalse(callableCalled.get());\n",
        "1964": "  }\n",
        "1965": "\n",
        "1966": "  private static <T> AsyncCallable<T> constantAsyncCallable(final ListenableFuture<T> returnValue) {\n",
        "1967": "    return new AsyncCallable<T>() {\n",
        "1968": "      @Override\n",
        "1969": "      public ListenableFuture<T> call() {\n",
        "1970": "        return returnValue;\n",
        "1971": "      }\n",
        "1972": "    };\n",
        "1973": "  }\n",
        "1974": "\n"
    },
    "removed": {
        "1730": "    @SuppressWarnings(\"unused\") // go/futurereturn-lsc\n",
        "1731": "    Future<?> possiblyIgnoredError =\n",
        "1732": "        executor.submit(\n",
        "1733": "            new Runnable() {\n",
        "1734": "              @Override\n",
        "1735": "              public void run() {\n",
        "1736": "                awaitUninterruptibly(beforeFunction);\n",
        "1737": "              }\n",
        "1738": "            });\n",
        "1746": "    executor.awaitTermination(5, SECONDS);\n"
    }
}