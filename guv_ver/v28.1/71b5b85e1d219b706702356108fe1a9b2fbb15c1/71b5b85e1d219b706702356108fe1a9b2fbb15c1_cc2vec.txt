{"id": "71b5b85e1d219b706702356108fe1a9b2fbb15c1", "code": [{"0": "android/guava-tests/test/com/google/common/util/concurrent/FuturesTest.java", "added": {"1": ["import static com.google.common.util.concurrent.Futures.scheduleAsync;\n", "import static com.google.common.util.concurrent.Futures.submitAsync;\n"], "2": ["import static java.util.concurrent.Executors.newSingleThreadScheduledExecutor;\n"], "3": ["import java.util.concurrent.ScheduledExecutorService;\n"], "4": ["    executor.execute(\n", "        new Runnable() {\n", "          @Override\n", "          public void run() {\n", "            awaitUninterruptibly(beforeFunction);\n", "          }\n", "        });\n"], "5": ["    executor.shutdown();\n", "    assertTrue(executor.awaitTermination(5, SECONDS));\n", "  public void testSubmitAsync_asyncCallable_error() throws InterruptedException {\n", "    final Error error = new Error(\"deliberate\");\n", "    AsyncCallable<Integer> callable =\n", "        new AsyncCallable<Integer>() {\n", "          @Override\n", "          public ListenableFuture<Integer> call() {\n", "            throw error;\n", "          }\n", "        };\n", "    SettableFuture<String> inputFuture = SettableFuture.create();\n", "    ListenableFuture<Integer> outputFuture = submitAsync(callable, directExecutor());\n", "    inputFuture.set(\"value\");\n", "    try {\n", "      getDone(outputFuture);\n", "      fail();\n", "    } catch (ExecutionException expected) {\n", "      assertSame(error, expected.getCause());\n", "    }\n", "  }\n", "\n", "  public void testSubmitAsync_asyncCallable_nullInsteadOfFuture() throws Exception {\n", "    ListenableFuture<?> chainedFuture = submitAsync(constantAsyncCallable(null), directExecutor());\n", "    try {\n", "      getDone(chainedFuture);\n", "      fail();\n", "    } catch (ExecutionException expected) {\n", "      NullPointerException cause = (NullPointerException) expected.getCause();\n", "      assertThat(cause)\n", "          .hasMessage(\n", "              \"AsyncCallable.call returned null instead of a Future. \"\n", "                  + \"Did you mean to return immediateFuture(null)?\");\n", "    }\n", "  }\n", "\n", "  @GwtIncompatible // threads\n", "\n", "  public void testSubmitAsync_asyncCallable_cancelledWhileApplyingFunction()\n", "      throws InterruptedException, ExecutionException {\n", "    final CountDownLatch inFunction = new CountDownLatch(1);\n", "    final CountDownLatch callableDone = new CountDownLatch(1);\n", "    final SettableFuture<Integer> resultFuture = SettableFuture.create();\n", "    AsyncCallable<Integer> callable =\n", "        new AsyncCallable<Integer>() {\n", "          @Override\n", "          public ListenableFuture<Integer> call() throws InterruptedException {\n", "            inFunction.countDown();\n", "            callableDone.await();\n", "            return resultFuture;\n", "          }\n", "        };\n", "    SettableFuture<String> inputFuture = SettableFuture.create();\n", "    ListenableFuture<Integer> future = submitAsync(callable, newSingleThreadExecutor());\n", "    inputFuture.set(\"value\");\n", "    inFunction.await();\n", "    future.cancel(false);\n", "    callableDone.countDown();\n", "    try {\n", "      future.get();\n", "      fail();\n", "    } catch (CancellationException expected) {\n", "    }\n", "    try {\n", "      resultFuture.get();\n", "      fail();\n", "    } catch (CancellationException expected) {\n", "    }\n", "  }\n", "\n", "  @GwtIncompatible // threads\n", "\n", "  public void testSubmitAsync_asyncCallable_cancelledBeforeApplyingFunction()\n", "      throws InterruptedException {\n", "    final AtomicBoolean callableCalled = new AtomicBoolean();\n", "    AsyncCallable<Integer> callable =\n", "        new AsyncCallable<Integer>() {\n", "          @Override\n", "          public ListenableFuture<Integer> call() {\n", "            callableCalled.set(true);\n", "            return immediateFuture(1);\n", "          }\n", "        };\n", "    ExecutorService executor = newSingleThreadExecutor();\n", "    // Pause the executor.\n", "    final CountDownLatch beforeFunction = new CountDownLatch(1);\n", "    executor.execute(\n", "        new Runnable() {\n", "          @Override\n", "          public void run() {\n", "            awaitUninterruptibly(beforeFunction);\n", "          }\n", "        });\n", "    ListenableFuture<Integer> future = submitAsync(callable, executor);\n", "    future.cancel(false);\n", "\n", "    // Unpause the executor.\n", "    beforeFunction.countDown();\n", "    executor.shutdown();\n", "    assertTrue(executor.awaitTermination(5, SECONDS));\n", "\n", "    assertFalse(callableCalled.get());\n", "  }\n", "\n", "  @GwtIncompatible // threads\n", "\n", "  public void testScheduleAsync_asyncCallable_error() throws InterruptedException {\n", "    final Error error = new Error(\"deliberate\");\n", "    AsyncCallable<Integer> callable =\n", "        new AsyncCallable<Integer>() {\n", "          @Override\n", "          public ListenableFuture<Integer> call() {\n", "            throw error;\n", "          }\n", "        };\n", "    SettableFuture<String> inputFuture = SettableFuture.create();\n", "    ListenableFuture<Integer> outputFuture = submitAsync(callable, directExecutor());\n", "    inputFuture.set(\"value\");\n", "    try {\n", "      getDone(outputFuture);\n", "      fail();\n", "    } catch (ExecutionException expected) {\n", "      assertSame(error, expected.getCause());\n", "    }\n", "  }\n", "\n", "  @GwtIncompatible // threads\n", "\n", "  public void testScheduleAsync_asyncCallable_nullInsteadOfFuture() throws Exception {\n", "    ListenableFuture<?> chainedFuture =\n", "        scheduleAsync(\n", "            constantAsyncCallable(null),\n", "            1,\n", "            TimeUnit.NANOSECONDS,\n", "            newSingleThreadScheduledExecutor());\n", "    try {\n", "      chainedFuture.get();\n", "      fail();\n", "    } catch (ExecutionException expected) {\n", "      NullPointerException cause = (NullPointerException) expected.getCause();\n", "      assertThat(cause)\n", "          .hasMessage(\n", "              \"AsyncCallable.call returned null instead of a Future. \"\n", "                  + \"Did you mean to return immediateFuture(null)?\");\n", "    }\n", "  }\n", "\n", "  @GwtIncompatible // threads\n", "\n", "  public void testScheduleAsync_asyncCallable_cancelledWhileApplyingFunction()\n", "      throws InterruptedException, ExecutionException {\n", "    final CountDownLatch inFunction = new CountDownLatch(1);\n", "    final CountDownLatch callableDone = new CountDownLatch(1);\n", "    final SettableFuture<Integer> resultFuture = SettableFuture.create();\n", "    AsyncCallable<Integer> callable =\n", "        new AsyncCallable<Integer>() {\n", "          @Override\n", "          public ListenableFuture<Integer> call() throws InterruptedException {\n", "            inFunction.countDown();\n", "            callableDone.await();\n", "            return resultFuture;\n", "          }\n", "        };\n", "    ListenableFuture<Integer> future =\n", "        scheduleAsync(callable, 1, TimeUnit.NANOSECONDS, newSingleThreadScheduledExecutor());\n", "    inFunction.await();\n", "    future.cancel(false);\n", "    callableDone.countDown();\n", "    try {\n", "      future.get();\n", "      fail();\n", "    } catch (CancellationException expected) {\n", "    }\n", "    try {\n", "      resultFuture.get();\n", "      fail();\n", "    } catch (CancellationException expected) {\n", "    }\n", "  }\n", "\n", "  @GwtIncompatible // threads\n", "\n", "  public void testScheduleAsync_asyncCallable_cancelledBeforeCallingFunction()\n", "      throws InterruptedException {\n", "    final AtomicBoolean callableCalled = new AtomicBoolean();\n", "    AsyncCallable<Integer> callable =\n", "        new AsyncCallable<Integer>() {\n", "          @Override\n", "          public ListenableFuture<Integer> call() {\n", "            callableCalled.set(true);\n", "            return immediateFuture(1);\n", "          }\n", "        };\n", "    ScheduledExecutorService executor = newSingleThreadScheduledExecutor();\n", "    // Pause the executor.\n", "    final CountDownLatch beforeFunction = new CountDownLatch(1);\n", "    executor.execute(\n", "        new Runnable() {\n", "          @Override\n", "          public void run() {\n", "            awaitUninterruptibly(beforeFunction);\n", "          }\n", "        });\n", "    ListenableFuture<Integer> future = scheduleAsync(callable, 1, TimeUnit.NANOSECONDS, executor);\n", "    future.cancel(false);\n", "\n", "    // Unpause the executor.\n", "    beforeFunction.countDown();\n", "    executor.shutdown();\n", "    assertTrue(executor.awaitTermination(5, SECONDS));\n", "\n", "    assertFalse(callableCalled.get());\n", "  }\n", "\n", "  private static <T> AsyncCallable<T> constantAsyncCallable(final ListenableFuture<T> returnValue) {\n", "    return new AsyncCallable<T>() {\n", "      @Override\n", "      public ListenableFuture<T> call() {\n", "        return returnValue;\n", "      }\n", "    };\n", "  }\n", "\n"]}, "removed": {"4": ["    @SuppressWarnings(\"unused\") // go/futurereturn-lsc\n", "    Future<?> possiblyIgnoredError =\n", "        executor.submit(\n", "            new Runnable() {\n", "              @Override\n", "              public void run() {\n", "                awaitUninterruptibly(beforeFunction);\n", "              }\n", "            });\n"], "5": ["    executor.awaitTermination(5, SECONDS);\n"]}, "added_lines": {"1": [41, 42], "2": [56], "3": [85], "4": [1734, 1735, 1736, 1737, 1738, 1739, 1740], "5": [1748, 1749, 1754, 1755, 1756, 1757, 1758, 1759, 1760, 1761, 1762, 1763, 1764, 1765, 1766, 1767, 1768, 1769, 1770, 1771, 1772, 1773, 1774, 1775, 1776, 1777, 1778, 1779, 1780, 1781, 1782, 1783, 1784, 1785, 1786, 1787, 1788, 1789, 1790, 1791, 1792, 1793, 1794, 1795, 1796, 1797, 1798, 1799, 1800, 1801, 1802, 1803, 1804, 1805, 1806, 1807, 1808, 1809, 1810, 1811, 1812, 1813, 1814, 1815, 1816, 1817, 1818, 1819, 1820, 1821, 1822, 1823, 1824, 1825, 1826, 1827, 1828, 1829, 1830, 1831, 1832, 1833, 1834, 1835, 1836, 1837, 1838, 1839, 1840, 1841, 1842, 1843, 1844, 1845, 1846, 1847, 1848, 1849, 1850, 1851, 1852, 1853, 1854, 1855, 1856, 1857, 1858, 1859, 1860, 1861, 1862, 1863, 1864, 1865, 1866, 1867, 1868, 1869, 1870, 1871, 1872, 1873, 1874, 1875, 1876, 1877, 1878, 1879, 1880, 1881, 1882, 1883, 1884, 1885, 1886, 1887, 1888, 1889, 1890, 1891, 1892, 1893, 1894, 1895, 1896, 1897, 1898, 1899, 1900, 1901, 1902, 1903, 1904, 1905, 1906, 1907, 1908, 1909, 1910, 1911, 1912, 1913, 1914, 1915, 1916, 1917, 1918, 1919, 1920, 1921, 1922, 1923, 1924, 1925, 1926, 1927, 1928, 1929, 1930, 1931, 1932, 1933, 1934, 1935, 1936, 1937, 1938, 1939, 1940, 1941, 1942, 1943, 1944, 1945, 1946, 1947, 1948, 1949, 1950, 1951, 1952, 1953, 1954, 1955, 1956, 1957, 1958, 1959, 1960, 1961, 1962, 1963, 1964, 1965, 1966, 1967, 1968, 1969, 1970, 1971, 1972, 1973, 1974]}, "removed_lines": {"4": [1730, 1731, 1732, 1733, 1734, 1735, 1736, 1737, 1738], "5": [1746]}}, {"1": "android/guava/src/com/google/common/util/concurrent/Futures.java", "added": {"1": ["  /**\n", "   * Executes {@code callable} on the specified {@code executor}, returning a {@code Future}.\n", "   *\n", "   * @throws RejectedExecutionException if the task cannot be scheduled for execution\n", "   * @since 23.0\n", "   */\n", "  public static <O> ListenableFuture<O> submitAsync(AsyncCallable<O> callable, Executor executor) {\n", "    TrustedListenableFutureTask<O> task = TrustedListenableFutureTask.create(callable);\n", "    executor.execute(task);\n", "    return task;\n", "  }\n", "\n", "  /**\n", "   * Schedules {@code callable} on the specified {@code executor}, returning a {@code Future}.\n", "   *\n", "   * @throws RejectedExecutionException if the task cannot be scheduled for execution\n", "   * @since 23.0\n", "   */\n", "  @GwtIncompatible // java.util.concurrent.ScheduledExecutorService\n", "  public static <O> ListenableFuture<O> scheduleAsync(\n", "      AsyncCallable<O> callable,\n", "      long delay,\n", "      TimeUnit timeUnit,\n", "      ScheduledExecutorService executorService) {\n", "    TrustedListenableFutureTask<O> task = TrustedListenableFutureTask.create(callable);\n", "    final Future<?> scheduled = executorService.schedule(task, delay, timeUnit);\n", "    task.addListener(\n", "        new Runnable() {\n", "          @Override\n", "          public void run() {\n", "            // Don't want to interrupt twice\n", "            scheduled.cancel(false);\n", "          }\n", "        },\n", "        directExecutor());\n", "    return task;\n", "  }\n", "\n"]}, "removed": {}, "added_lines": {"1": [243, 244, 245, 246, 247, 248, 249, 250, 251, 252, 253, 254, 255, 256, 257, 258, 259, 260, 261, 262, 263, 264, 265, 266, 267, 268, 269, 270, 271, 272, 273, 274, 275, 276, 277, 278, 279, 280]}, "removed_lines": {}}, {"2": "android/guava/src/com/google/common/util/concurrent/TrustedListenableFutureTask.java", "added": {"1": ["  static <V> TrustedListenableFutureTask<V> create(AsyncCallable<V> callable) {\n", "    return new TrustedListenableFutureTask<V>(callable);\n", "  }\n", "\n"], "2": ["  private InterruptibleTask task;\n", "  TrustedListenableFutureTask(AsyncCallable<V> callable) {\n", "    this.task = new TrustedFutureInterruptibleAsyncTask(callable);\n", "  }\n", "\n", "    InterruptibleTask localTask = task;\n"], "3": ["      InterruptibleTask localTask = task;\n"], "4": ["    InterruptibleTask localTask = task;\n"], "5": ["\n", "  @WeakOuter\n", "  private final class TrustedFutureInterruptibleAsyncTask extends InterruptibleTask {\n", "    private final AsyncCallable<V> callable;\n", "\n", "    TrustedFutureInterruptibleAsyncTask(AsyncCallable<V> callable) {\n", "      this.callable = checkNotNull(callable);\n", "    }\n", "\n", "    @Override\n", "    void runInterruptibly() {\n", "      // Ensure we haven't been cancelled or already run.\n", "      if (!isDone()) {\n", "        try {\n", "          ListenableFuture<V> result = callable.call();\n", "          checkNotNull(\n", "              result,\n", "              \"AsyncCallable.call returned null instead of a Future. \"\n", "                  + \"Did you mean to return immediateFuture(null)?\");\n", "          setFuture(result);\n", "        } catch (Throwable t) {\n", "          setException(t);\n", "        }\n", "      }\n", "    }\n", "\n", "    @Override\n", "    boolean wasInterrupted() {\n", "      return TrustedListenableFutureTask.this.wasInterrupted();\n", "    }\n", "\n", "    @Override\n", "    public String toString() {\n", "      return callable.toString();\n", "    }\n", "  }\n"]}, "removed": {"1": ["  /**\n", "   * Creates a {@code ListenableFutureTask} that will upon running, execute the given\n", "   * {@code Callable}.\n", "   *\n", "   * @param callable the callable task\n", "   */\n"], "2": ["  private TrustedFutureInterruptibleTask task;\n", "    TrustedFutureInterruptibleTask localTask = task;\n"], "3": ["      TrustedFutureInterruptibleTask localTask = task;\n"], "4": ["    TrustedFutureInterruptibleTask localTask = task;\n"]}, "added_lines": {"1": [36, 37, 38, 39], "2": [63, 69, 70, 71, 72, 75], "3": [86], "4": [97], "5": [134, 135, 136, 137, 138, 139, 140, 141, 142, 143, 144, 145, 146, 147, 148, 149, 150, 151, 152, 153, 154, 155, 156, 157, 158, 159, 160, 161, 162, 163, 164, 165, 166, 167, 168, 169]}, "removed_lines": {"1": [36, 37, 38, 39, 40, 41], "2": [65, 73], "3": [84], "4": [95]}}, {"3": "guava-gwt/test/com/google/common/util/concurrent/FuturesTest_gwt.java", "added": {"1": ["public void testSubmitAsync_asyncCallable_error() throws Exception {\n", "  com.google.common.util.concurrent.FuturesTest testCase = new com.google.common.util.concurrent.FuturesTest();\n", "  testCase.setUp();\n", "  Throwable failure = null;\n", "  try {\n", "    testCase.testSubmitAsync_asyncCallable_error();\n", "  } catch (Throwable t) {\n", "    failure = t;\n", "  }\n", "  try {\n", "    testCase.tearDown();\n", "  } catch (Throwable t) {\n", "    if (failure == null) {\n", "      failure = t;\n", "    }\n", "  }\n", "  if (failure instanceof Exception) {\n", "    throw (Exception) failure;\n", "  }\n", "  if (failure instanceof Error) {\n", "    throw (Error) failure;\n", "  }\n", "  if (failure != null) {\n", "    throw new RuntimeException(failure);\n", "  }\n", "}\n", "\n", "public void testSubmitAsync_asyncCallable_nullInsteadOfFuture() throws Exception {\n", "  com.google.common.util.concurrent.FuturesTest testCase = new com.google.common.util.concurrent.FuturesTest();\n", "  testCase.setUp();\n", "  Throwable failure = null;\n", "  try {\n", "    testCase.testSubmitAsync_asyncCallable_nullInsteadOfFuture();\n", "  } catch (Throwable t) {\n", "    failure = t;\n", "  }\n", "  try {\n", "    testCase.tearDown();\n", "  } catch (Throwable t) {\n", "    if (failure == null) {\n", "      failure = t;\n", "    }\n", "  }\n", "  if (failure instanceof Exception) {\n", "    throw (Exception) failure;\n", "  }\n", "  if (failure instanceof Error) {\n", "    throw (Error) failure;\n", "  }\n", "  if (failure != null) {\n", "    throw new RuntimeException(failure);\n", "  }\n", "}\n", "\n"]}, "removed": {}, "added_lines": {"1": [1992, 1993, 1994, 1995, 1996, 1997, 1998, 1999, 2000, 2001, 2002, 2003, 2004, 2005, 2006, 2007, 2008, 2009, 2010, 2011, 2012, 2013, 2014, 2015, 2016, 2017, 2018, 2019, 2020, 2021, 2022, 2023, 2024, 2025, 2026, 2027, 2028, 2029, 2030, 2031, 2032, 2033, 2034, 2035, 2036, 2037, 2038, 2039, 2040, 2041, 2042, 2043, 2044, 2045]}, "removed_lines": {}}, {"4": "guava-tests/test/com/google/common/util/concurrent/FuturesTest.java", "added": {"1": ["import static com.google.common.util.concurrent.Futures.scheduleAsync;\n", "import static com.google.common.util.concurrent.Futures.submitAsync;\n"], "2": ["import static java.util.concurrent.Executors.newSingleThreadScheduledExecutor;\n"], "3": ["import java.util.concurrent.ScheduledExecutorService;\n"], "4": ["    executor.execute(\n", "        new Runnable() {\n", "          @Override\n", "          public void run() {\n", "            awaitUninterruptibly(beforeFunction);\n", "          }\n", "        });\n"], "5": ["    executor.shutdown();\n", "    assertTrue(executor.awaitTermination(5, SECONDS));\n", "  public void testSubmitAsync_asyncCallable_error() throws InterruptedException {\n", "    final Error error = new Error(\"deliberate\");\n", "    AsyncCallable<Integer> callable =\n", "        new AsyncCallable<Integer>() {\n", "          @Override\n", "          public ListenableFuture<Integer> call() {\n", "            throw error;\n", "          }\n", "        };\n", "    SettableFuture<String> inputFuture = SettableFuture.create();\n", "    ListenableFuture<Integer> outputFuture = submitAsync(callable, directExecutor());\n", "    inputFuture.set(\"value\");\n", "    try {\n", "      getDone(outputFuture);\n", "      fail();\n", "    } catch (ExecutionException expected) {\n", "      assertSame(error, expected.getCause());\n", "    }\n", "  }\n", "\n", "  public void testSubmitAsync_asyncCallable_nullInsteadOfFuture() throws Exception {\n", "    ListenableFuture<?> chainedFuture = submitAsync(constantAsyncCallable(null), directExecutor());\n", "    try {\n", "      getDone(chainedFuture);\n", "      fail();\n", "    } catch (ExecutionException expected) {\n", "      NullPointerException cause = (NullPointerException) expected.getCause();\n", "      assertThat(cause)\n", "          .hasMessage(\n", "              \"AsyncCallable.call returned null instead of a Future. \"\n", "                  + \"Did you mean to return immediateFuture(null)?\");\n", "    }\n", "  }\n", "\n", "  @GwtIncompatible // threads\n", "\n", "  public void testSubmitAsync_asyncCallable_cancelledWhileApplyingFunction()\n", "      throws InterruptedException, ExecutionException {\n", "    final CountDownLatch inFunction = new CountDownLatch(1);\n", "    final CountDownLatch callableDone = new CountDownLatch(1);\n", "    final SettableFuture<Integer> resultFuture = SettableFuture.create();\n", "    AsyncCallable<Integer> callable =\n", "        new AsyncCallable<Integer>() {\n", "          @Override\n", "          public ListenableFuture<Integer> call() throws InterruptedException {\n", "            inFunction.countDown();\n", "            callableDone.await();\n", "            return resultFuture;\n", "          }\n", "        };\n", "    SettableFuture<String> inputFuture = SettableFuture.create();\n", "    ListenableFuture<Integer> future = submitAsync(callable, newSingleThreadExecutor());\n", "    inputFuture.set(\"value\");\n", "    inFunction.await();\n", "    future.cancel(false);\n", "    callableDone.countDown();\n", "    try {\n", "      future.get();\n", "      fail();\n", "    } catch (CancellationException expected) {\n", "    }\n", "    try {\n", "      resultFuture.get();\n", "      fail();\n", "    } catch (CancellationException expected) {\n", "    }\n", "  }\n", "\n", "  @GwtIncompatible // threads\n", "\n", "  public void testSubmitAsync_asyncCallable_cancelledBeforeApplyingFunction()\n", "      throws InterruptedException {\n", "    final AtomicBoolean callableCalled = new AtomicBoolean();\n", "    AsyncCallable<Integer> callable =\n", "        new AsyncCallable<Integer>() {\n", "          @Override\n", "          public ListenableFuture<Integer> call() {\n", "            callableCalled.set(true);\n", "            return immediateFuture(1);\n", "          }\n", "        };\n", "    ExecutorService executor = newSingleThreadExecutor();\n", "    // Pause the executor.\n", "    final CountDownLatch beforeFunction = new CountDownLatch(1);\n", "    executor.execute(\n", "        new Runnable() {\n", "          @Override\n", "          public void run() {\n", "            awaitUninterruptibly(beforeFunction);\n", "          }\n", "        });\n", "    ListenableFuture<Integer> future = submitAsync(callable, executor);\n", "    future.cancel(false);\n", "\n", "    // Unpause the executor.\n", "    beforeFunction.countDown();\n", "    executor.shutdown();\n", "    assertTrue(executor.awaitTermination(5, SECONDS));\n", "\n", "    assertFalse(callableCalled.get());\n", "  }\n", "\n", "  @GwtIncompatible // threads\n", "\n", "  public void testScheduleAsync_asyncCallable_error() throws InterruptedException {\n", "    final Error error = new Error(\"deliberate\");\n", "    AsyncCallable<Integer> callable =\n", "        new AsyncCallable<Integer>() {\n", "          @Override\n", "          public ListenableFuture<Integer> call() {\n", "            throw error;\n", "          }\n", "        };\n", "    SettableFuture<String> inputFuture = SettableFuture.create();\n", "    ListenableFuture<Integer> outputFuture = submitAsync(callable, directExecutor());\n", "    inputFuture.set(\"value\");\n", "    try {\n", "      getDone(outputFuture);\n", "      fail();\n", "    } catch (ExecutionException expected) {\n", "      assertSame(error, expected.getCause());\n", "    }\n", "  }\n", "\n", "  @GwtIncompatible // threads\n", "\n", "  public void testScheduleAsync_asyncCallable_nullInsteadOfFuture() throws Exception {\n", "    ListenableFuture<?> chainedFuture =\n", "        scheduleAsync(\n", "            constantAsyncCallable(null),\n", "            1,\n", "            TimeUnit.NANOSECONDS,\n", "            newSingleThreadScheduledExecutor());\n", "    try {\n", "      chainedFuture.get();\n", "      fail();\n", "    } catch (ExecutionException expected) {\n", "      NullPointerException cause = (NullPointerException) expected.getCause();\n", "      assertThat(cause)\n", "          .hasMessage(\n", "              \"AsyncCallable.call returned null instead of a Future. \"\n", "                  + \"Did you mean to return immediateFuture(null)?\");\n", "    }\n", "  }\n", "\n", "  @GwtIncompatible // threads\n", "\n", "  public void testScheduleAsync_asyncCallable_cancelledWhileApplyingFunction()\n", "      throws InterruptedException, ExecutionException {\n", "    final CountDownLatch inFunction = new CountDownLatch(1);\n", "    final CountDownLatch callableDone = new CountDownLatch(1);\n", "    final SettableFuture<Integer> resultFuture = SettableFuture.create();\n", "    AsyncCallable<Integer> callable =\n", "        new AsyncCallable<Integer>() {\n", "          @Override\n", "          public ListenableFuture<Integer> call() throws InterruptedException {\n", "            inFunction.countDown();\n", "            callableDone.await();\n", "            return resultFuture;\n", "          }\n", "        };\n", "    ListenableFuture<Integer> future =\n", "        scheduleAsync(callable, 1, TimeUnit.NANOSECONDS, newSingleThreadScheduledExecutor());\n", "    inFunction.await();\n", "    future.cancel(false);\n", "    callableDone.countDown();\n", "    try {\n", "      future.get();\n", "      fail();\n", "    } catch (CancellationException expected) {\n", "    }\n", "    try {\n", "      resultFuture.get();\n", "      fail();\n", "    } catch (CancellationException expected) {\n", "    }\n", "  }\n", "\n", "  @GwtIncompatible // threads\n", "\n", "  public void testScheduleAsync_asyncCallable_cancelledBeforeCallingFunction()\n", "      throws InterruptedException {\n", "    final AtomicBoolean callableCalled = new AtomicBoolean();\n", "    AsyncCallable<Integer> callable =\n", "        new AsyncCallable<Integer>() {\n", "          @Override\n", "          public ListenableFuture<Integer> call() {\n", "            callableCalled.set(true);\n", "            return immediateFuture(1);\n", "          }\n", "        };\n", "    ScheduledExecutorService executor = newSingleThreadScheduledExecutor();\n", "    // Pause the executor.\n", "    final CountDownLatch beforeFunction = new CountDownLatch(1);\n", "    executor.execute(\n", "        new Runnable() {\n", "          @Override\n", "          public void run() {\n", "            awaitUninterruptibly(beforeFunction);\n", "          }\n", "        });\n", "    ListenableFuture<Integer> future = scheduleAsync(callable, 1, TimeUnit.NANOSECONDS, executor);\n", "    future.cancel(false);\n", "\n", "    // Unpause the executor.\n", "    beforeFunction.countDown();\n", "    executor.shutdown();\n", "    assertTrue(executor.awaitTermination(5, SECONDS));\n", "\n", "    assertFalse(callableCalled.get());\n", "  }\n", "\n", "  private static <T> AsyncCallable<T> constantAsyncCallable(final ListenableFuture<T> returnValue) {\n", "    return new AsyncCallable<T>() {\n", "      @Override\n", "      public ListenableFuture<T> call() {\n", "        return returnValue;\n", "      }\n", "    };\n", "  }\n", "\n"]}, "removed": {"4": ["    @SuppressWarnings(\"unused\") // go/futurereturn-lsc\n", "    Future<?> possiblyIgnoredError =\n", "        executor.submit(\n", "            new Runnable() {\n", "              @Override\n", "              public void run() {\n", "                awaitUninterruptibly(beforeFunction);\n", "              }\n", "            });\n"], "5": ["    executor.awaitTermination(5, SECONDS);\n"]}, "added_lines": {"1": [41, 42], "2": [56], "3": [85], "4": [1734, 1735, 1736, 1737, 1738, 1739, 1740], "5": [1748, 1749, 1754, 1755, 1756, 1757, 1758, 1759, 1760, 1761, 1762, 1763, 1764, 1765, 1766, 1767, 1768, 1769, 1770, 1771, 1772, 1773, 1774, 1775, 1776, 1777, 1778, 1779, 1780, 1781, 1782, 1783, 1784, 1785, 1786, 1787, 1788, 1789, 1790, 1791, 1792, 1793, 1794, 1795, 1796, 1797, 1798, 1799, 1800, 1801, 1802, 1803, 1804, 1805, 1806, 1807, 1808, 1809, 1810, 1811, 1812, 1813, 1814, 1815, 1816, 1817, 1818, 1819, 1820, 1821, 1822, 1823, 1824, 1825, 1826, 1827, 1828, 1829, 1830, 1831, 1832, 1833, 1834, 1835, 1836, 1837, 1838, 1839, 1840, 1841, 1842, 1843, 1844, 1845, 1846, 1847, 1848, 1849, 1850, 1851, 1852, 1853, 1854, 1855, 1856, 1857, 1858, 1859, 1860, 1861, 1862, 1863, 1864, 1865, 1866, 1867, 1868, 1869, 1870, 1871, 1872, 1873, 1874, 1875, 1876, 1877, 1878, 1879, 1880, 1881, 1882, 1883, 1884, 1885, 1886, 1887, 1888, 1889, 1890, 1891, 1892, 1893, 1894, 1895, 1896, 1897, 1898, 1899, 1900, 1901, 1902, 1903, 1904, 1905, 1906, 1907, 1908, 1909, 1910, 1911, 1912, 1913, 1914, 1915, 1916, 1917, 1918, 1919, 1920, 1921, 1922, 1923, 1924, 1925, 1926, 1927, 1928, 1929, 1930, 1931, 1932, 1933, 1934, 1935, 1936, 1937, 1938, 1939, 1940, 1941, 1942, 1943, 1944, 1945, 1946, 1947, 1948, 1949, 1950, 1951, 1952, 1953, 1954, 1955, 1956, 1957, 1958, 1959, 1960, 1961, 1962, 1963, 1964, 1965, 1966, 1967, 1968, 1969, 1970, 1971, 1972, 1973, 1974]}, "removed_lines": {"4": [1730, 1731, 1732, 1733, 1734, 1735, 1736, 1737, 1738], "5": [1746]}}, {"5": "guava/src/com/google/common/util/concurrent/Futures.java", "added": {"1": ["  /**\n", "   * Executes {@code callable} on the specified {@code executor}, returning a {@code Future}.\n", "   *\n", "   * @throws RejectedExecutionException if the task cannot be scheduled for execution\n", "   * @since 23.0\n", "   */\n", "  public static <O> ListenableFuture<O> submitAsync(AsyncCallable<O> callable, Executor executor) {\n", "    TrustedListenableFutureTask<O> task = TrustedListenableFutureTask.create(callable);\n", "    executor.execute(task);\n", "    return task;\n", "  }\n", "\n", "  /**\n", "   * Schedules {@code callable} on the specified {@code executor}, returning a {@code Future}.\n", "   *\n", "   * @throws RejectedExecutionException if the task cannot be scheduled for execution\n", "   * @since 23.0\n", "   */\n", "  @GwtIncompatible // java.util.concurrent.ScheduledExecutorService\n", "  public static <O> ListenableFuture<O> scheduleAsync(\n", "      AsyncCallable<O> callable,\n", "      long delay,\n", "      TimeUnit timeUnit,\n", "      ScheduledExecutorService executorService) {\n", "    TrustedListenableFutureTask<O> task = TrustedListenableFutureTask.create(callable);\n", "    final Future<?> scheduled = executorService.schedule(task, delay, timeUnit);\n", "    task.addListener(\n", "        new Runnable() {\n", "          @Override\n", "          public void run() {\n", "            // Don't want to interrupt twice\n", "            scheduled.cancel(false);\n", "          }\n", "        },\n", "        directExecutor());\n", "    return task;\n", "  }\n", "\n"]}, "removed": {}, "added_lines": {"1": [243, 244, 245, 246, 247, 248, 249, 250, 251, 252, 253, 254, 255, 256, 257, 258, 259, 260, 261, 262, 263, 264, 265, 266, 267, 268, 269, 270, 271, 272, 273, 274, 275, 276, 277, 278, 279, 280]}, "removed_lines": {}}, {"6": "guava/src/com/google/common/util/concurrent/TrustedListenableFutureTask.java", "added": {"1": ["  static <V> TrustedListenableFutureTask<V> create(AsyncCallable<V> callable) {\n", "    return new TrustedListenableFutureTask<V>(callable);\n", "  }\n", "\n"], "2": ["  private InterruptibleTask task;\n", "  TrustedListenableFutureTask(AsyncCallable<V> callable) {\n", "    this.task = new TrustedFutureInterruptibleAsyncTask(callable);\n", "  }\n", "\n", "    InterruptibleTask localTask = task;\n"], "3": ["      InterruptibleTask localTask = task;\n"], "4": ["    InterruptibleTask localTask = task;\n"], "5": ["\n", "  @WeakOuter\n", "  private final class TrustedFutureInterruptibleAsyncTask extends InterruptibleTask {\n", "    private final AsyncCallable<V> callable;\n", "\n", "    TrustedFutureInterruptibleAsyncTask(AsyncCallable<V> callable) {\n", "      this.callable = checkNotNull(callable);\n", "    }\n", "\n", "    @Override\n", "    void runInterruptibly() {\n", "      // Ensure we haven't been cancelled or already run.\n", "      if (!isDone()) {\n", "        try {\n", "          ListenableFuture<V> result = callable.call();\n", "          checkNotNull(\n", "              result,\n", "              \"AsyncCallable.call returned null instead of a Future. \"\n", "                  + \"Did you mean to return immediateFuture(null)?\");\n", "          setFuture(result);\n", "        } catch (Throwable t) {\n", "          setException(t);\n", "        }\n", "      }\n", "    }\n", "\n", "    @Override\n", "    boolean wasInterrupted() {\n", "      return TrustedListenableFutureTask.this.wasInterrupted();\n", "    }\n", "\n", "    @Override\n", "    public String toString() {\n", "      return callable.toString();\n", "    }\n", "  }\n"]}, "removed": {"1": ["  /**\n", "   * Creates a {@code ListenableFutureTask} that will upon running, execute the given\n", "   * {@code Callable}.\n", "   *\n", "   * @param callable the callable task\n", "   */\n"], "2": ["  private TrustedFutureInterruptibleTask task;\n", "    TrustedFutureInterruptibleTask localTask = task;\n"], "3": ["      TrustedFutureInterruptibleTask localTask = task;\n"], "4": ["    TrustedFutureInterruptibleTask localTask = task;\n"]}, "added_lines": {"1": [36, 37, 38, 39], "2": [63, 69, 70, 71, 72, 75], "3": [86], "4": [97], "5": [134, 135, 136, 137, 138, 139, 140, 141, 142, 143, 144, 145, 146, 147, 148, 149, 150, 151, 152, 153, 154, 155, 156, 157, 158, 159, 160, 161, 162, 163, 164, 165, 166, 167, 168, 169]}, "removed_lines": {"1": [36, 37, 38, 39, 40, 41], "2": [65, 73], "3": [84], "4": [95]}}]}
