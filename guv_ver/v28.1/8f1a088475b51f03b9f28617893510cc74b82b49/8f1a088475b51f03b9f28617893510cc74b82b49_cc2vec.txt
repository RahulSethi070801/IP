{"id": "8f1a088475b51f03b9f28617893510cc74b82b49", "code": [{"0": "guava-tests/test/com/google/common/collect/StreamsTest.java", "added": {"1": ["import java.util.concurrent.atomic.AtomicInteger;\n"], "2": ["  public void testForEachPair() {\n", "    List<String> list = new ArrayList<>();\n", "    Streams.forEachPair(\n", "        Stream.of(\"a\", \"b\", \"c\"), Stream.of(1, 2, 3), (a, b) -> list.add(a + \":\" + b));\n", "    Truth.assertThat(list).containsExactly(\"a:1\", \"b:2\", \"c:3\");\n", "  }\n", "\n", "  public void testForEachPair_differingLengths1() {\n", "    List<String> list = new ArrayList<>();\n", "    Streams.forEachPair(\n", "        Stream.of(\"a\", \"b\", \"c\", \"d\"), Stream.of(1, 2, 3), (a, b) -> list.add(a + \":\" + b));\n", "    Truth.assertThat(list).containsExactly(\"a:1\", \"b:2\", \"c:3\");\n", "  }\n", "\n", "  public void testForEachPair_differingLengths2() {\n", "    List<String> list = new ArrayList<>();\n", "    Streams.forEachPair(\n", "        Stream.of(\"a\", \"b\", \"c\"), Stream.of(1, 2, 3, 4), (a, b) -> list.add(a + \":\" + b));\n", "    Truth.assertThat(list).containsExactly(\"a:1\", \"b:2\", \"c:3\");\n", "  }\n", "\n", "  public void testForEachPair_oneEmpty() {\n", "    Streams.forEachPair(Stream.of(\"a\"), Stream.empty(), (a, b) -> fail());\n", "  }\n", "\n", "  public void testForEachPair_finiteWithInfinite() {\n", "    List<String> list = new ArrayList<>();\n", "    Streams.forEachPair(\n", "        Stream.of(\"a\", \"b\", \"c\"), Stream.iterate(1, i -> i + 1), (a, b) -> list.add(a + \":\" + b));\n", "    Truth.assertThat(list).containsExactly(\"a:1\", \"b:2\", \"c:3\");\n", "  }\n", "\n", "  public void testForEachPair_parallel() {\n", "    Stream<String> streamA = IntStream.range(0, 100000).mapToObj(String::valueOf).parallel();\n", "    Stream<Integer> streamB = IntStream.range(0, 100000).mapToObj(i -> i).parallel();\n", "\n", "    AtomicInteger count = new AtomicInteger(0);\n", "    Streams.forEachPair(\n", "        streamA,\n", "        streamB,\n", "        (a, b) -> {\n", "          count.incrementAndGet();\n", "          Truth.assertThat(a.equals(String.valueOf(b))).isTrue();\n", "        });\n", "    Truth.assertThat(count.get()).isEqualTo(100000);\n", "    // of course, this test doesn't prove that anything actually happened in parallel...\n", "  }\n", "\n"]}, "removed": {}, "added_lines": {"1": [34], "2": [268, 269, 270, 271, 272, 273, 274, 275, 276, 277, 278, 279, 280, 281, 282, 283, 284, 285, 286, 287, 288, 289, 290, 291, 292, 293, 294, 295, 296, 297, 298, 299, 300, 301, 302, 303, 304, 305, 306, 307, 308, 309, 310, 311, 312, 313, 314, 315]}, "removed_lines": {}}, {"1": "guava/src/com/google/common/collect/Streams.java", "added": {"1": ["import java.util.function.BiConsumer;\n"], "2": ["   * Returns a stream in which each element is the result of passing the corresponding elementY of\n"], "3": ["   * <p>Note that if you are calling {@link Stream#forEach} on the resulting stream, you might want\n", "   * to consider using {@link #forEachPair} instead of this method.\n", "   *\n", "   * <p><b>Performance note:</b> The resulting stream is not <a\n"], "4": ["  /**\n", "   * Invokes {@code consumer} once for each pair of <i>corresponding</i> elements in {@code streamA}\n", "   * and {@code streamB}. If one stream is longer than the other, the extra elements are silently\n", "   * ignored. Elements passed to the consumer are guaranteed to come from the same position in their\n", "   * respective source streams. For example:\n", "   *\n", "   * <pre>{@code\n", "   * Streams.forEachPair(\n", "   *   Stream.of(\"foo1\", \"foo2\", \"foo3\"),\n", "   *   Stream.of(\"bar1\", \"bar2\"),\n", "   *   (arg1, arg2) -> System.out.println(arg1 + \":\" + arg2)\n", "   * }</pre>\n", "   *\n", "   * <p>will print:\n", "   *\n", "   * <pre>{@code\n", "   * foo1:bar1\n", "   * foo2:bar2\n", "   * }</pre>\n", "   *\n", "   * <p><b>Warning:</b> If either supplied stream is a parallel stream, the same correspondence\n", "   * between elements will be made, but the order in which those pairs of elements are passed to the\n", "   * consumer is <i>not</i> defined.\n", "   *\n", "   * <p>Note that many usages of this method can be replaced with simpler calls to {@link #zip}.\n", "   * This method behaves equivalently to {@linkplain #zip zipping} the stream elements into\n", "   * temporary pair objects and then using {@link Stream#forEach} on that stream.\n", "   */\n", "  public static <A, B> void forEachPair(\n", "      Stream<A> streamA, Stream<B> streamB, BiConsumer<? super A, ? super B> consumer) {\n", "    checkNotNull(consumer);\n", "\n", "    if (streamA.isParallel() || streamB.isParallel()) {\n", "      zip(streamA, streamB, TemporaryPair::new).forEach(pair -> consumer.accept(pair.a, pair.b));\n", "    } else {\n", "      Iterator<A> iterA = streamA.iterator();\n", "      Iterator<B> iterB = streamB.iterator();\n", "      while (iterA.hasNext() && iterB.hasNext()) {\n", "        consumer.accept(iterA.next(), iterB.next());\n", "      }\n", "    }\n", "  }\n", "\n", "  private static class TemporaryPair<A, B> {\n", "    final A a;\n", "    final B b;\n", "\n", "    TemporaryPair(A a, B b) {\n", "      this.a = a;\n", "      this.b = b;\n", "    }\n", "  }\n", "\n"]}, "removed": {"2": ["   * Returns a stream in which each element is the result of passing the corresponding element of\n"], "3": ["   * <p>The resulting stream is not <a\n"]}, "added_lines": {"1": [36], "2": [209], "3": [226, 227, 228, 229], "4": [262, 263, 264, 265, 266, 267, 268, 269, 270, 271, 272, 273, 274, 275, 276, 277, 278, 279, 280, 281, 282, 283, 284, 285, 286, 287, 288, 289, 290, 291, 292, 293, 294, 295, 296, 297, 298, 299, 300, 301, 302, 303, 304, 305, 306, 307, 308, 309, 310, 311, 312, 313, 314]}, "removed_lines": {"2": [208], "3": [225]}}]}
