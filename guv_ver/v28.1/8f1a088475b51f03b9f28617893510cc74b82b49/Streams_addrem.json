{
    "addition": {
        "36": "import java.util.function.BiConsumer;\n",
        "209": "   * Returns a stream in which each element is the result of passing the corresponding elementY of\n",
        "226": "   * <p>Note that if you are calling {@link Stream#forEach} on the resulting stream, you might want\n",
        "227": "   * to consider using {@link #forEachPair} instead of this method.\n",
        "228": "   *\n",
        "229": "   * <p><b>Performance note:</b> The resulting stream is not <a\n",
        "262": "  /**\n",
        "263": "   * Invokes {@code consumer} once for each pair of <i>corresponding</i> elements in {@code streamA}\n",
        "264": "   * and {@code streamB}. If one stream is longer than the other, the extra elements are silently\n",
        "265": "   * ignored. Elements passed to the consumer are guaranteed to come from the same position in their\n",
        "266": "   * respective source streams. For example:\n",
        "267": "   *\n",
        "268": "   * <pre>{@code\n",
        "269": "   * Streams.forEachPair(\n",
        "270": "   *   Stream.of(\"foo1\", \"foo2\", \"foo3\"),\n",
        "271": "   *   Stream.of(\"bar1\", \"bar2\"),\n",
        "272": "   *   (arg1, arg2) -> System.out.println(arg1 + \":\" + arg2)\n",
        "273": "   * }</pre>\n",
        "274": "   *\n",
        "275": "   * <p>will print:\n",
        "276": "   *\n",
        "277": "   * <pre>{@code\n",
        "278": "   * foo1:bar1\n",
        "279": "   * foo2:bar2\n",
        "280": "   * }</pre>\n",
        "281": "   *\n",
        "282": "   * <p><b>Warning:</b> If either supplied stream is a parallel stream, the same correspondence\n",
        "283": "   * between elements will be made, but the order in which those pairs of elements are passed to the\n",
        "284": "   * consumer is <i>not</i> defined.\n",
        "285": "   *\n",
        "286": "   * <p>Note that many usages of this method can be replaced with simpler calls to {@link #zip}.\n",
        "287": "   * This method behaves equivalently to {@linkplain #zip zipping} the stream elements into\n",
        "288": "   * temporary pair objects and then using {@link Stream#forEach} on that stream.\n",
        "289": "   */\n",
        "290": "  public static <A, B> void forEachPair(\n",
        "291": "      Stream<A> streamA, Stream<B> streamB, BiConsumer<? super A, ? super B> consumer) {\n",
        "292": "    checkNotNull(consumer);\n",
        "293": "\n",
        "294": "    if (streamA.isParallel() || streamB.isParallel()) {\n",
        "295": "      zip(streamA, streamB, TemporaryPair::new).forEach(pair -> consumer.accept(pair.a, pair.b));\n",
        "296": "    } else {\n",
        "297": "      Iterator<A> iterA = streamA.iterator();\n",
        "298": "      Iterator<B> iterB = streamB.iterator();\n",
        "299": "      while (iterA.hasNext() && iterB.hasNext()) {\n",
        "300": "        consumer.accept(iterA.next(), iterB.next());\n",
        "301": "      }\n",
        "302": "    }\n",
        "303": "  }\n",
        "304": "\n",
        "305": "  private static class TemporaryPair<A, B> {\n",
        "306": "    final A a;\n",
        "307": "    final B b;\n",
        "308": "\n",
        "309": "    TemporaryPair(A a, B b) {\n",
        "310": "      this.a = a;\n",
        "311": "      this.b = b;\n",
        "312": "    }\n",
        "313": "  }\n",
        "314": "\n"
    },
    "removed": {
        "208": "   * Returns a stream in which each element is the result of passing the corresponding element of\n",
        "225": "   * <p>The resulting stream is not <a\n"
    }
}