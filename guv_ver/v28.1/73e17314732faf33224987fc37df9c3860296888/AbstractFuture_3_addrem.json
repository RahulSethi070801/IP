{
    "addition": {
        "66": "@SuppressWarnings(\"ShortCircuitBoolean\") // we use non-short circuiting comparisons intentionally\n",
        "274": "    // constants to use when GENERATE_CANCELLATION_CAUSES = false\n",
        "275": "    static final Cancellation CAUSELESS_INTERRUPTED;\n",
        "276": "    static final Cancellation CAUSELESS_CANCELLED;\n",
        "277": "\n",
        "278": "    static {\n",
        "279": "      if (GENERATE_CANCELLATION_CAUSES) {\n",
        "280": "        CAUSELESS_CANCELLED = null;\n",
        "281": "        CAUSELESS_INTERRUPTED = null;\n",
        "282": "      } else {\n",
        "283": "        CAUSELESS_CANCELLED = new Cancellation(false, null);\n",
        "284": "        CAUSELESS_INTERRUPTED = new Cancellation(true, null);\n",
        "285": "      }\n",
        "286": "    }\n",
        "287": "\n",
        "561": "      Object valueToSet =\n",
        "563": "              ? new Cancellation(\n",
        "564": "                  mayInterruptIfRunning, new CancellationException(\"Future.cancel() was called.\"))\n",
        "565": "              : (mayInterruptIfRunning\n",
        "566": "                  ? Cancellation.CAUSELESS_INTERRUPTED\n",
        "567": "                  : Cancellation.CAUSELESS_CANCELLED);\n",
        "725": "   * <p>Note that, even if the supplied future is cancelled and it causes this future to complete,\n",
        "726": "   * it will never trigger interruption behavior. In particular, it will not cause this future to\n",
        "727": "   * invoke the {@link #interruptTask} method, and the {@link #wasInterrupted} method will not\n",
        "728": "   * return {@code true}.\n",
        "729": "   *\n",
        "782": "   * Returns a value that satisfies the contract of the {@link #value} field based on the state of\n",
        "783": "   * given future.\n",
        "794": "      Object v = ((AbstractFuture<?>) future).value;\n",
        "795": "      if (v instanceof Cancellation) {\n",
        "796": "        // If the other future was interrupted, clear the interrupted bit while preserving the cause\n",
        "797": "        // this will make it consistent with how non-trustedfutures work which cannot propagate the\n",
        "798": "        // wasInterrupted bit\n",
        "799": "        Cancellation c = (Cancellation) v;\n",
        "800": "        if (c.wasInterrupted) {\n",
        "801": "          v =\n",
        "802": "              c.cause != null\n",
        "803": "                  ? new Cancellation(/* wasInterrupted= */ false, c.cause)\n",
        "804": "                  : Cancellation.CAUSELESS_CANCELLED;\n",
        "805": "        }\n",
        "806": "      }\n",
        "807": "      return v;\n"
    },
    "removed": {
        "546": "      Throwable cause =\n",
        "548": "              ? new CancellationException(\"Future.cancel() was called.\")\n",
        "549": "              : null;\n",
        "550": "      Object valueToSet = new Cancellation(mayInterruptIfRunning, cause);\n",
        "760": "   * Returns a value, suitable for storing in the {@link #value} field. From the given future,\n",
        "761": "   * which is assumed to be done.\n",
        "772": "      return ((AbstractFuture<?>) future).value;\n"
    }
}