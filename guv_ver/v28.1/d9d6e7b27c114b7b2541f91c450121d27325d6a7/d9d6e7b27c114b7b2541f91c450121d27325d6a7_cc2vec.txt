{"id": "d9d6e7b27c114b7b2541f91c450121d27325d6a7", "code": [{"0": "android/guava-tests/benchmark/com/google/common/hash/HashStringBenchmark.java", "added": {"1": ["/*\n", " * Copyright (C) 2017 The Guava Authors\n", " *\n", " * Licensed under the Apache License, Version 2.0 (the \"License\");\n", " * you may not use this file except in compliance with the License.\n", " * You may obtain a copy of the License at\n", " *\n", " * http://www.apache.org/licenses/LICENSE-2.0\n", " *\n", " * Unless required by applicable law or agreed to in writing, software\n", " * distributed under the License is distributed on an \"AS IS\" BASIS,\n", " * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n", " * See the License for the specific language governing permissions and\n", " * limitations under the License.\n", " */\n", "\n", "package com.google.common.hash;\n", "\n", "import com.google.caliper.BeforeExperiment;\n", "import com.google.caliper.Benchmark;\n", "import com.google.caliper.Param;\n", "import java.nio.charset.StandardCharsets;\n", "import java.util.Random;\n", "\n", "/**\n", " * Benchmarks for the hashing of UTF-8 strings.\n", " */\n", "public class HashStringBenchmark {\n", "  static class MaxCodePoint {\n", "    final int value;\n", "\n", "    /**\n", "     * Convert the input string to a code point. Accepts regular decimal numerals, hex strings, and\n", "     * some symbolic names meaningful to humans.\n", "     */\n", "    private static int decode(String userFriendly) {\n", "      try {\n", "        return Integer.decode(userFriendly);\n", "      } catch (NumberFormatException ignored) {\n", "        if (userFriendly.matches(\"(?i)(?:American|English|ASCII)\")) {\n", "          // 1-byte UTF-8 sequences - \"American\" ASCII text\n", "          return 0x80;\n", "        } else if (userFriendly.matches(\"(?i)(?:French|Latin|Western.*European)\")) {\n", "          // Mostly 1-byte UTF-8 sequences, mixed with occasional 2-byte\n", "          // sequences - \"Western European\" text\n", "          return 0x90;\n", "        } else if (userFriendly.matches(\"(?i)(?:Branch.*Prediction.*Hostile)\")) {\n", "          // Defeat branch predictor for: c < 0x80 ; branch taken 50% of the time.\n", "          return 0x100;\n", "        } else if (userFriendly.matches(\"(?i)(?:Greek|Cyrillic|European|ISO.?8859)\")) {\n", "          // Mostly 2-byte UTF-8 sequences - \"European\" text\n", "          return 0x800;\n", "        } else if (userFriendly.matches(\"(?i)(?:Chinese|Han|Asian|BMP)\")) {\n", "          // Mostly 3-byte UTF-8 sequences - \"Asian\" text\n", "          return Character.MIN_SUPPLEMENTARY_CODE_POINT;\n", "        } else if (userFriendly.matches(\"(?i)(?:Cuneiform|rare|exotic|supplementary.*)\")) {\n", "          // Mostly 4-byte UTF-8 sequences - \"rare exotic\" text\n", "          return Character.MAX_CODE_POINT;\n", "        } else {\n", "          throw new IllegalArgumentException(\"Can't decode codepoint \" + userFriendly);\n", "        }\n", "      }\n", "    }\n", "\n", "    public static MaxCodePoint valueOf(String userFriendly) {\n", "      return new MaxCodePoint(userFriendly);\n", "    }\n", "\n", "    public MaxCodePoint(String userFriendly) {\n", "      value = decode(userFriendly);\n", "    }\n", "  }\n", "\n", "  /**\n", "   * The default values of maxCodePoint below provide pretty good performance models of different\n", "   * kinds of common human text.\n", "   *\n", "   * @see MaxCodePoint#decode\n", "   */\n", "  @Param({\"0x80\", \"0x90\", \"0x100\", \"0x800\", \"0x10000\", \"0x10ffff\"})\n", "  MaxCodePoint maxCodePoint;\n", "\n", "  @Param({\"16384\"})\n", "  int charCount;\n", "\n", "  @Param({\"MURMUR3_32\", \"MURMUR3_128\", \"SHA1\"})\n", "  HashFunctionEnum hashFunctionEnum;\n", "\n", "  private String[] strings;\n", "\n", "  static final int SAMPLES = 0x100;\n", "  static final int SAMPLE_MASK = 0xFF;\n", "\n", "  /**\n", "   * Compute arrays of valid unicode text, and store it in 3 forms: byte arrays, Strings, and\n", "   * StringBuilders (in a CharSequence[] to make it a little harder for the JVM).\n", "   */\n", "  @BeforeExperiment\n", "  void setUp() {\n", "    final long seed = 99;\n", "    final Random rnd = new Random(seed);\n", "    strings = new String[SAMPLES];\n", "    for (int i = 0; i < SAMPLES; i++) {\n", "      StringBuilder sb = new StringBuilder();\n", "      for (int j = 0; j < charCount; j++) {\n", "        int codePoint;\n", "        // discard illegal surrogate \"codepoints\"\n", "        do {\n", "          codePoint = rnd.nextInt(maxCodePoint.value);\n", "        } while (Character.isSurrogate((char) codePoint));\n", "        sb.appendCodePoint(codePoint);\n", "      }\n", "      strings[i] = sb.toString();\n", "    }\n", "  }\n", "\n", "  @Benchmark\n", "  int hashUtf8(int reps) {\n", "    int res = 0;\n", "    for (int i = 0; i < reps; i++) {\n", "      res +=\n", "          System.identityHashCode(\n", "              hashFunctionEnum\n", "                  .getHashFunction()\n", "                  .hashString(strings[i & SAMPLE_MASK], StandardCharsets.UTF_8));\n", "    }\n", "    return res;\n", "  }\n", "\n", "  @Benchmark\n", "  int hashUtf8Hasher(int reps) {\n", "    int res = 0;\n", "    for (int i = 0; i < reps; i++) {\n", "      res +=\n", "          System.identityHashCode(\n", "              hashFunctionEnum\n", "                  .getHashFunction()\n", "                  .newHasher()\n", "                  .putString(strings[i & SAMPLE_MASK], StandardCharsets.UTF_8)\n", "                  .hash());\n", "    }\n", "    return res;\n", "  }\n", "\n", "  @Benchmark\n", "  int hashUtf8GetBytes(int reps) {\n", "    int res = 0;\n", "    for (int i = 0; i < reps; i++) {\n", "      res +=\n", "          System.identityHashCode(\n", "              hashFunctionEnum\n", "                  .getHashFunction()\n", "                  .hashBytes(strings[i & SAMPLE_MASK].getBytes(StandardCharsets.UTF_8)));\n", "    }\n", "    return res;\n", "  }\n", "\n", "  @Benchmark\n", "  int hashUtf8GetBytesHasher(int reps) {\n", "    int res = 0;\n", "    for (int i = 0; i < reps; i++) {\n", "      res +=\n", "          System.identityHashCode(\n", "              hashFunctionEnum\n", "                  .getHashFunction()\n", "                  .newHasher()\n", "                  .putBytes(strings[i & SAMPLE_MASK].getBytes(StandardCharsets.UTF_8))\n", "                  .hash());\n", "    }\n", "    return res;\n", "  }\n", "}\n"]}, "removed": {}, "added_lines": {"1": [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 58, 59, 60, 61, 62, 63, 64, 65, 66, 67, 68, 69, 70, 71, 72, 73, 74, 75, 76, 77, 78, 79, 80, 81, 82, 83, 84, 85, 86, 87, 88, 89, 90, 91, 92, 93, 94, 95, 96, 97, 98, 99, 100, 101, 102, 103, 104, 105, 106, 107, 108, 109, 110, 111, 112, 113, 114, 115, 116, 117, 118, 119, 120, 121, 122, 123, 124, 125, 126, 127, 128, 129, 130, 131, 132, 133, 134, 135, 136, 137, 138, 139, 140, 141, 142, 143, 144, 145, 146, 147, 148, 149, 150, 151, 152, 153, 154, 155, 156, 157, 158, 159, 160, 161, 162, 163, 164, 165, 166, 167, 168, 169, 170, 171, 172]}, "removed_lines": {}}, {"1": "android/guava-tests/test/com/google/common/hash/HashTestUtils.java", "added": {"1": ["    String string = new String(bytes, Charsets.US_ASCII);\n"]}, "removed": {"1": ["    String string = new String(bytes);\n"]}, "added_lines": {"1": [622]}, "removed_lines": {"1": [622]}}, {"2": "android/guava-tests/test/com/google/common/hash/Murmur3Hash32Test.java", "added": {"1": ["import com.google.common.base.Charsets;\n", "import java.util.Random;\n"], "2": ["  @SuppressWarnings(\"deprecation\")\n", "  public void testSimpleStringUtf8() {\n", "    assertEquals(\n", "        murmur3_32().hashBytes(\"ABCDefGHI\\u0799\".getBytes(Charsets.UTF_8)),\n", "        murmur3_32().hashString(\"ABCDefGHI\\u0799\", Charsets.UTF_8));\n", "  }\n", "\n", "  @SuppressWarnings(\"deprecation\")\n", "  public void testStringInputsUtf8() {\n", "    Random rng = new Random(0);\n", "    for (int z = 0; z < 100; z++) {\n", "      String str;\n", "      int[] codePoints = new int[rng.nextInt(8)];\n", "      for (int i = 0; i < codePoints.length; i++) {\n", "        do {\n", "          codePoints[i] = rng.nextInt(0x800);\n", "        } while (!Character.isValidCodePoint(codePoints[i])\n", "            || (codePoints[i] >= Character.MIN_SURROGATE\n", "                && codePoints[i] <= Character.MAX_SURROGATE));\n", "      }\n", "      StringBuilder builder = new StringBuilder();\n", "      for (int i = 0; i < codePoints.length; i++) {\n", "        builder.appendCodePoint(codePoints[i]);\n", "      }\n", "      str = builder.toString();\n", "      assertEquals(\n", "          murmur3_32().hashBytes(str.getBytes(Charsets.UTF_8)),\n", "          murmur3_32().hashString(str, Charsets.UTF_8));\n", "    }\n", "  }\n", "\n"], "3": ["\n", "  @SuppressWarnings(\"deprecation\")\n", "  public void testInvalidUnicodeHashString() {\n", "    String str =\n", "        new String(\n", "            new char[] {'a', Character.MIN_HIGH_SURROGATE, Character.MIN_HIGH_SURROGATE, 'z'});\n", "    assertEquals(\n", "        murmur3_32().hashBytes(str.getBytes(Charsets.UTF_8)),\n", "        murmur3_32().hashString(str, Charsets.UTF_8));\n", "  }\n", "\n", "  public void testInvalidUnicodeHasherPutString() {\n", "    String str =\n", "        new String(\n", "            new char[] {'a', Character.MIN_HIGH_SURROGATE, Character.MIN_HIGH_SURROGATE, 'z'});\n", "    assertEquals(\n", "        murmur3_32().hashBytes(str.getBytes(Charsets.UTF_8)),\n", "        murmur3_32().newHasher().putString(str, Charsets.UTF_8).hash());\n", "  }\n"]}, "removed": {}, "added_lines": {"1": [21, 23], "2": [56, 57, 58, 59, 60, 61, 62, 63, 64, 65, 66, 67, 68, 69, 70, 71, 72, 73, 74, 75, 76, 77, 78, 79, 80, 81, 82, 83, 84, 85, 86], "3": [118, 119, 120, 121, 122, 123, 124, 125, 126, 127, 128, 129, 130, 131, 132, 133, 134, 135, 136]}, "removed_lines": {}}, {"3": "android/guava/src/com/google/common/hash/Murmur3_32HashFunction.java", "added": {"1": ["import static com.google.common.base.Preconditions.checkState;\n", "import com.google.common.base.Charsets;\n", "import com.google.errorprone.annotations.CanIgnoreReturnValue;\n", "import java.nio.ByteOrder;\n", " * See MurmurHash3_x86_32 in <a\n", " * href=\"https://github.com/aappleby/smhasher/blob/master/src/MurmurHash3.cpp\">the C++\n"], "3": ["  @SuppressWarnings(\"deprecation\") // need to use Charsets for Android tests to pass\n", "    if (Charsets.UTF_8.equals(charset)) {\n", "      int utf16Length = input.length();\n", "      int h1 = seed;\n", "      int i = 0;\n", "      int len = 0;\n", "\n", "      // This loop optimizes for pure ASCII.\n", "      while (i + 4 <= utf16Length) {\n", "        char c0 = input.charAt(i);\n", "        char c1 = input.charAt(i + 1);\n", "        char c2 = input.charAt(i + 2);\n", "        char c3 = input.charAt(i + 3);\n", "        if (c0 < 0x80 && c1 < 0x80 && c2 < 0x80 && c3 < 0x80) {\n", "          int k1 = c0 | (c1 << 8) | (c2 << 16) | (c3 << 24);\n", "          k1 = mixK1(k1);\n", "          h1 = mixH1(h1, k1);\n", "          i += 4;\n", "          len += 4;\n", "        } else {\n", "          break;\n", "        }\n", "      }\n", "\n", "      long buffer = 0;\n", "      int shift = 0;\n", "      for (; i < utf16Length; i++) {\n", "        char c = input.charAt(i);\n", "        if (c < 0x80) {\n", "          buffer |= (long) c << shift;\n", "          shift += 8;\n", "          len++;\n", "        } else if (c < 0x800) {\n", "          buffer |= charToTwoUtf8Bytes(c) << shift;\n", "          shift += 16;\n", "          len += 2;\n", "        } else if (c < Character.MIN_SURROGATE || c > Character.MAX_SURROGATE) {\n", "          buffer |= charToThreeUtf8Bytes(c) << shift;\n", "          shift += 24;\n", "          len += 3;\n", "        } else {\n", "          int codePoint = Character.codePointAt(input, i);\n", "          if (codePoint == c) {\n", "            // not a valid code point; let the JDK handle invalid Unicode\n", "            return hashBytes(input.toString().getBytes(charset));\n", "          }\n", "          i++;\n", "          buffer |= codePointToFourUtf8Bytes(codePoint) << shift;\n", "          len += 4;\n", "        }\n", "\n", "        if (shift >= 32) {\n", "          int k1 = mixK1((int) buffer);\n", "          h1 = mixH1(h1, k1);\n", "          buffer = buffer >>> 32;\n", "          shift -= 32;\n", "        }\n", "      }\n", "\n", "      int k1 = mixK1((int) buffer);\n", "      h1 ^= k1;\n", "      return fmix(h1, len);\n", "    } else {\n", "      return hashBytes(input.toString().getBytes(charset));\n", "    }\n"], "4": ["  @CanIgnoreReturnValue\n", "  private static final class Murmur3_32Hasher extends AbstractHasher {\n", "    private long buffer;\n", "    private int shift;\n", "    private boolean isDone;\n", "      isDone = false;\n", "    }\n", "\n", "    private void update(int nBytes, long update) {\n", "      // 1 <= nBytes <= 4\n", "      buffer |= (update & 0xFFFFFFFFL) << shift;\n", "      shift += nBytes * 8;\n", "      length += nBytes;\n", "\n", "      if (shift >= 32) {\n", "        h1 = mixH1(h1, mixK1((int) buffer));\n", "        buffer >>>= 32;\n", "        shift -= 32;\n", "      }\n", "    public Hasher putByte(byte b) {\n", "      update(1, b & 0xFF);\n", "      return this;\n", "    public Hasher putBytes(byte[] bytes, int off, int len) {\n", "      checkPositionIndexes(off, off + len, bytes.length);\n", "      int i;\n", "      for (i = 0; i + 4 <= len; i += 4) {\n", "        update(4, getIntLittleEndian(bytes, off + i));\n", "      }\n", "      for (; i < len; i++) {\n", "        putByte(bytes[off + i]);\n", "      return this;\n", "    public Hasher putBytes(ByteBuffer buffer) {\n", "      ByteOrder bo = buffer.order();\n", "      buffer.order(ByteOrder.LITTLE_ENDIAN);\n", "      while (buffer.remaining() >= 4) {\n", "        putInt(buffer.getInt());\n", "      }\n", "      while (buffer.hasRemaining()) {\n", "        putByte(buffer.get());\n", "      }\n", "      buffer.order(bo);\n", "      return this;\n", "\n", "    @Override\n", "    public Hasher putInt(int i) {\n", "      update(4, i);\n", "      return this;\n", "    }\n", "\n", "    @Override\n", "    public Hasher putLong(long l) {\n", "      update(4, (int) l);\n", "      update(4, l >>> 32);\n", "      return this;\n", "    }\n", "\n", "    @Override\n", "    public Hasher putChar(char c) {\n", "      update(2, c);\n", "      return this;\n", "    }\n", "\n", "    @SuppressWarnings(\"deprecation\") // need to use Charsets for Android tests to pass\n", "    @Override\n", "    public Hasher putString(CharSequence input, Charset charset) {\n", "      if (Charsets.UTF_8.equals(charset)) {\n", "        int utf16Length = input.length();\n", "        int i = 0;\n", "\n", "        // This loop optimizes for pure ASCII.\n", "        while (i + 4 <= utf16Length) {\n", "          char c0 = input.charAt(i);\n", "          char c1 = input.charAt(i + 1);\n", "          char c2 = input.charAt(i + 2);\n", "          char c3 = input.charAt(i + 3);\n", "          if (c0 < 0x80 && c1 < 0x80 && c2 < 0x80 && c3 < 0x80) {\n", "            update(4, c0 | (c1 << 8) | (c2 << 16) | (c3 << 24));\n", "            i += 4;\n", "          } else {\n", "            break;\n", "          }\n", "        }\n", "\n", "        for (; i < utf16Length; i++) {\n", "          char c = input.charAt(i);\n", "          if (c < 0x80) {\n", "            update(1, c);\n", "          } else if (c < 0x800) {\n", "            update(2, charToTwoUtf8Bytes(c));\n", "          } else if (c < Character.MIN_SURROGATE || c > Character.MAX_SURROGATE) {\n", "            update(3, charToThreeUtf8Bytes(c));\n", "          } else {\n", "            int codePoint = Character.codePointAt(input, i);\n", "            if (codePoint == c) {\n", "              // fall back to JDK getBytes instead of trying to handle invalid surrogates ourselves\n", "              putBytes(input.subSequence(i, utf16Length).toString().getBytes(charset));\n", "              return this;\n", "            }\n", "            i++;\n", "            update(4, codePointToFourUtf8Bytes(codePoint));\n", "          }\n", "        }\n", "        return this;\n", "      } else {\n", "        return super.putString(input, charset);\n", "      }\n", "    }\n", "\n", "    @Override\n", "    public HashCode hash() {\n", "      checkState(!isDone);\n", "      isDone = true;\n", "      h1 ^= mixK1((int) buffer);\n", "      return fmix(h1, length);\n", "    }\n", "  }\n", "\n", "  private static long codePointToFourUtf8Bytes(int codePoint) {\n", "    return (((0xFL << 4) | (codePoint >>> 18)) & 0xFF)\n", "        | ((0x80L | (0x3F & (codePoint >>> 12))) << 8)\n", "        | ((0x80L | (0x3F & (codePoint >>> 6))) << 16)\n", "        | ((0x80L | (0x3F & codePoint)) << 24);\n", "  }\n", "\n", "  private static long charToThreeUtf8Bytes(char c) {\n", "    return (((0xF << 5) | (c >>> 12)) & 0xFF)\n", "        | ((0x80 | (0x3F & (c >>> 6))) << 8)\n", "        | ((0x80 | (0x3F & c)) << 16);\n", "  }\n", "\n", "  private static long charToTwoUtf8Bytes(char c) {\n", "    return (((0xF << 6) | (c >>> 6)) & 0xFF) | ((0x80 | (0x3F & c)) << 8);\n"]}, "removed": {"1": [" * See MurmurHash3_x86_32 in\n", " * <a href=\"https://github.com/aappleby/smhasher/blob/master/src/MurmurHash3.cpp\">the C++\n"], "2": ["  // TODO(kak): Maybe implement #hashBytes instead?\n"], "3": ["    return hashBytes(input.toString().getBytes(charset));\n"], "4": ["  private static final class Murmur3_32Hasher extends AbstractStreamingHasher {\n", "      super(CHUNK_SIZE);\n", "    protected void process(ByteBuffer bb) {\n", "      int k1 = Murmur3_32HashFunction.mixK1(bb.getInt());\n", "      h1 = Murmur3_32HashFunction.mixH1(h1, k1);\n", "      length += CHUNK_SIZE;\n", "    protected void processRemaining(ByteBuffer bb) {\n", "      length += bb.remaining();\n", "      int k1 = 0;\n", "      for (int i = 0; bb.hasRemaining(); i += 8) {\n", "        k1 ^= toInt(bb.get()) << i;\n", "      h1 ^= Murmur3_32HashFunction.mixK1(k1);\n", "    public HashCode makeHash() {\n", "      return Murmur3_32HashFunction.fmix(h1, length);\n"]}, "added_lines": {"1": [29, 32, 36, 39, 44, 45], "3": [141, 144, 145, 146, 147, 148, 149, 150, 151, 152, 153, 154, 155, 156, 157, 158, 159, 160, 161, 162, 163, 164, 165, 166, 167, 168, 169, 170, 171, 172, 173, 174, 175, 176, 177, 178, 179, 180, 181, 182, 183, 184, 185, 186, 187, 188, 189, 190, 191, 192, 193, 194, 195, 196, 197, 198, 199, 200, 201, 202, 203, 204, 205, 206, 207], "4": [257, 258, 260, 261, 263, 268, 269, 270, 271, 272, 273, 274, 275, 276, 277, 278, 279, 280, 281, 285, 286, 287, 291, 292, 293, 294, 295, 296, 297, 298, 300, 304, 305, 306, 307, 308, 309, 310, 311, 312, 313, 314, 316, 317, 318, 319, 320, 321, 322, 323, 324, 325, 326, 327, 328, 329, 330, 331, 332, 333, 334, 335, 336, 337, 338, 339, 340, 341, 342, 343, 344, 345, 346, 347, 348, 349, 350, 351, 352, 353, 354, 355, 356, 357, 358, 359, 360, 361, 362, 363, 364, 365, 366, 367, 368, 369, 370, 371, 372, 373, 374, 375, 376, 377, 378, 379, 380, 381, 382, 383, 384, 385, 386, 387, 388, 389, 390, 391, 392, 393, 394, 395, 396, 397, 398, 399, 400, 401, 402, 403, 404, 405]}, "removed_lines": {"1": [40, 41], "2": [116], "3": [140], "4": [190, 195, 201, 202, 203, 204, 208, 209, 210, 211, 212, 214, 218, 219]}}, {"4": "guava-tests/benchmark/com/google/common/hash/HashStringBenchmark.java", "added": {"1": ["/*\n", " * Copyright (C) 2017 The Guava Authors\n", " *\n", " * Licensed under the Apache License, Version 2.0 (the \"License\");\n", " * you may not use this file except in compliance with the License.\n", " * You may obtain a copy of the License at\n", " *\n", " * http://www.apache.org/licenses/LICENSE-2.0\n", " *\n", " * Unless required by applicable law or agreed to in writing, software\n", " * distributed under the License is distributed on an \"AS IS\" BASIS,\n", " * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n", " * See the License for the specific language governing permissions and\n", " * limitations under the License.\n", " */\n", "\n", "package com.google.common.hash;\n", "\n", "import com.google.caliper.BeforeExperiment;\n", "import com.google.caliper.Benchmark;\n", "import com.google.caliper.Param;\n", "import java.nio.charset.StandardCharsets;\n", "import java.util.Random;\n", "\n", "/**\n", " * Benchmarks for the hashing of UTF-8 strings.\n", " */\n", "public class HashStringBenchmark {\n", "  static class MaxCodePoint {\n", "    final int value;\n", "\n", "    /**\n", "     * Convert the input string to a code point. Accepts regular decimal numerals, hex strings, and\n", "     * some symbolic names meaningful to humans.\n", "     */\n", "    private static int decode(String userFriendly) {\n", "      try {\n", "        return Integer.decode(userFriendly);\n", "      } catch (NumberFormatException ignored) {\n", "        if (userFriendly.matches(\"(?i)(?:American|English|ASCII)\")) {\n", "          // 1-byte UTF-8 sequences - \"American\" ASCII text\n", "          return 0x80;\n", "        } else if (userFriendly.matches(\"(?i)(?:French|Latin|Western.*European)\")) {\n", "          // Mostly 1-byte UTF-8 sequences, mixed with occasional 2-byte\n", "          // sequences - \"Western European\" text\n", "          return 0x90;\n", "        } else if (userFriendly.matches(\"(?i)(?:Branch.*Prediction.*Hostile)\")) {\n", "          // Defeat branch predictor for: c < 0x80 ; branch taken 50% of the time.\n", "          return 0x100;\n", "        } else if (userFriendly.matches(\"(?i)(?:Greek|Cyrillic|European|ISO.?8859)\")) {\n", "          // Mostly 2-byte UTF-8 sequences - \"European\" text\n", "          return 0x800;\n", "        } else if (userFriendly.matches(\"(?i)(?:Chinese|Han|Asian|BMP)\")) {\n", "          // Mostly 3-byte UTF-8 sequences - \"Asian\" text\n", "          return Character.MIN_SUPPLEMENTARY_CODE_POINT;\n", "        } else if (userFriendly.matches(\"(?i)(?:Cuneiform|rare|exotic|supplementary.*)\")) {\n", "          // Mostly 4-byte UTF-8 sequences - \"rare exotic\" text\n", "          return Character.MAX_CODE_POINT;\n", "        } else {\n", "          throw new IllegalArgumentException(\"Can't decode codepoint \" + userFriendly);\n", "        }\n", "      }\n", "    }\n", "\n", "    public static MaxCodePoint valueOf(String userFriendly) {\n", "      return new MaxCodePoint(userFriendly);\n", "    }\n", "\n", "    public MaxCodePoint(String userFriendly) {\n", "      value = decode(userFriendly);\n", "    }\n", "  }\n", "\n", "  /**\n", "   * The default values of maxCodePoint below provide pretty good performance models of different\n", "   * kinds of common human text.\n", "   *\n", "   * @see MaxCodePoint#decode\n", "   */\n", "  @Param({\"0x80\", \"0x90\", \"0x100\", \"0x800\", \"0x10000\", \"0x10ffff\"})\n", "  MaxCodePoint maxCodePoint;\n", "\n", "  @Param({\"16384\"})\n", "  int charCount;\n", "\n", "  @Param({\"MURMUR3_32\", \"MURMUR3_128\", \"SHA1\"})\n", "  HashFunctionEnum hashFunctionEnum;\n", "\n", "  private String[] strings;\n", "\n", "  static final int SAMPLES = 0x100;\n", "  static final int SAMPLE_MASK = 0xFF;\n", "\n", "  /**\n", "   * Compute arrays of valid unicode text, and store it in 3 forms: byte arrays, Strings, and\n", "   * StringBuilders (in a CharSequence[] to make it a little harder for the JVM).\n", "   */\n", "  @BeforeExperiment\n", "  void setUp() {\n", "    final long seed = 99;\n", "    final Random rnd = new Random(seed);\n", "    strings = new String[SAMPLES];\n", "    for (int i = 0; i < SAMPLES; i++) {\n", "      StringBuilder sb = new StringBuilder();\n", "      for (int j = 0; j < charCount; j++) {\n", "        int codePoint;\n", "        // discard illegal surrogate \"codepoints\"\n", "        do {\n", "          codePoint = rnd.nextInt(maxCodePoint.value);\n", "        } while (Character.isSurrogate((char) codePoint));\n", "        sb.appendCodePoint(codePoint);\n", "      }\n", "      strings[i] = sb.toString();\n", "    }\n", "  }\n", "\n", "  @Benchmark\n", "  int hashUtf8(int reps) {\n", "    int res = 0;\n", "    for (int i = 0; i < reps; i++) {\n", "      res +=\n", "          System.identityHashCode(\n", "              hashFunctionEnum\n", "                  .getHashFunction()\n", "                  .hashString(strings[i & SAMPLE_MASK], StandardCharsets.UTF_8));\n", "    }\n", "    return res;\n", "  }\n", "\n", "  @Benchmark\n", "  int hashUtf8Hasher(int reps) {\n", "    int res = 0;\n", "    for (int i = 0; i < reps; i++) {\n", "      res +=\n", "          System.identityHashCode(\n", "              hashFunctionEnum\n", "                  .getHashFunction()\n", "                  .newHasher()\n", "                  .putString(strings[i & SAMPLE_MASK], StandardCharsets.UTF_8)\n", "                  .hash());\n", "    }\n", "    return res;\n", "  }\n", "\n", "  @Benchmark\n", "  int hashUtf8GetBytes(int reps) {\n", "    int res = 0;\n", "    for (int i = 0; i < reps; i++) {\n", "      res +=\n", "          System.identityHashCode(\n", "              hashFunctionEnum\n", "                  .getHashFunction()\n", "                  .hashBytes(strings[i & SAMPLE_MASK].getBytes(StandardCharsets.UTF_8)));\n", "    }\n", "    return res;\n", "  }\n", "\n", "  @Benchmark\n", "  int hashUtf8GetBytesHasher(int reps) {\n", "    int res = 0;\n", "    for (int i = 0; i < reps; i++) {\n", "      res +=\n", "          System.identityHashCode(\n", "              hashFunctionEnum\n", "                  .getHashFunction()\n", "                  .newHasher()\n", "                  .putBytes(strings[i & SAMPLE_MASK].getBytes(StandardCharsets.UTF_8))\n", "                  .hash());\n", "    }\n", "    return res;\n", "  }\n", "}\n"]}, "removed": {}, "added_lines": {"1": [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 58, 59, 60, 61, 62, 63, 64, 65, 66, 67, 68, 69, 70, 71, 72, 73, 74, 75, 76, 77, 78, 79, 80, 81, 82, 83, 84, 85, 86, 87, 88, 89, 90, 91, 92, 93, 94, 95, 96, 97, 98, 99, 100, 101, 102, 103, 104, 105, 106, 107, 108, 109, 110, 111, 112, 113, 114, 115, 116, 117, 118, 119, 120, 121, 122, 123, 124, 125, 126, 127, 128, 129, 130, 131, 132, 133, 134, 135, 136, 137, 138, 139, 140, 141, 142, 143, 144, 145, 146, 147, 148, 149, 150, 151, 152, 153, 154, 155, 156, 157, 158, 159, 160, 161, 162, 163, 164, 165, 166, 167, 168, 169, 170, 171, 172]}, "removed_lines": {}}, {"5": "guava-tests/test/com/google/common/hash/HashTestUtils.java", "added": {"1": ["    String string = new String(bytes, Charsets.US_ASCII);\n"]}, "removed": {"1": ["    String string = new String(bytes);\n"]}, "added_lines": {"1": [622]}, "removed_lines": {"1": [622]}}, {"6": "guava-tests/test/com/google/common/hash/Murmur3Hash32Test.java", "added": {"1": ["import com.google.common.base.Charsets;\n", "import java.util.Random;\n"], "2": ["  @SuppressWarnings(\"deprecation\")\n", "  public void testSimpleStringUtf8() {\n", "    assertEquals(\n", "        murmur3_32().hashBytes(\"ABCDefGHI\\u0799\".getBytes(Charsets.UTF_8)),\n", "        murmur3_32().hashString(\"ABCDefGHI\\u0799\", Charsets.UTF_8));\n", "  }\n", "\n", "  @SuppressWarnings(\"deprecation\")\n", "  public void testStringInputsUtf8() {\n", "    Random rng = new Random(0);\n", "    for (int z = 0; z < 100; z++) {\n", "      String str;\n", "      int[] codePoints = new int[rng.nextInt(8)];\n", "      for (int i = 0; i < codePoints.length; i++) {\n", "        do {\n", "          codePoints[i] = rng.nextInt(0x800);\n", "        } while (!Character.isValidCodePoint(codePoints[i])\n", "            || (codePoints[i] >= Character.MIN_SURROGATE\n", "                && codePoints[i] <= Character.MAX_SURROGATE));\n", "      }\n", "      StringBuilder builder = new StringBuilder();\n", "      for (int i = 0; i < codePoints.length; i++) {\n", "        builder.appendCodePoint(codePoints[i]);\n", "      }\n", "      str = builder.toString();\n", "      assertEquals(\n", "          murmur3_32().hashBytes(str.getBytes(Charsets.UTF_8)),\n", "          murmur3_32().hashString(str, Charsets.UTF_8));\n", "    }\n", "  }\n", "\n"], "3": ["\n", "  @SuppressWarnings(\"deprecation\")\n", "  public void testInvalidUnicodeHashString() {\n", "    String str =\n", "        new String(\n", "            new char[] {'a', Character.MIN_HIGH_SURROGATE, Character.MIN_HIGH_SURROGATE, 'z'});\n", "    assertEquals(\n", "        murmur3_32().hashBytes(str.getBytes(Charsets.UTF_8)),\n", "        murmur3_32().hashString(str, Charsets.UTF_8));\n", "  }\n", "\n", "  public void testInvalidUnicodeHasherPutString() {\n", "    String str =\n", "        new String(\n", "            new char[] {'a', Character.MIN_HIGH_SURROGATE, Character.MIN_HIGH_SURROGATE, 'z'});\n", "    assertEquals(\n", "        murmur3_32().hashBytes(str.getBytes(Charsets.UTF_8)),\n", "        murmur3_32().newHasher().putString(str, Charsets.UTF_8).hash());\n", "  }\n"]}, "removed": {}, "added_lines": {"1": [21, 23], "2": [56, 57, 58, 59, 60, 61, 62, 63, 64, 65, 66, 67, 68, 69, 70, 71, 72, 73, 74, 75, 76, 77, 78, 79, 80, 81, 82, 83, 84, 85, 86], "3": [118, 119, 120, 121, 122, 123, 124, 125, 126, 127, 128, 129, 130, 131, 132, 133, 134, 135, 136]}, "removed_lines": {}}, {"7": "guava/src/com/google/common/hash/Murmur3_32HashFunction.java", "added": {"1": ["import static com.google.common.base.Preconditions.checkState;\n", "import com.google.common.base.Charsets;\n", "import com.google.errorprone.annotations.CanIgnoreReturnValue;\n", "import java.nio.ByteOrder;\n", " * See MurmurHash3_x86_32 in <a\n", " * href=\"https://github.com/aappleby/smhasher/blob/master/src/MurmurHash3.cpp\">the C++\n"], "3": ["  @SuppressWarnings(\"deprecation\") // need to use Charsets for Android tests to pass\n", "    if (Charsets.UTF_8.equals(charset)) {\n", "      int utf16Length = input.length();\n", "      int h1 = seed;\n", "      int i = 0;\n", "      int len = 0;\n", "\n", "      // This loop optimizes for pure ASCII.\n", "      while (i + 4 <= utf16Length) {\n", "        char c0 = input.charAt(i);\n", "        char c1 = input.charAt(i + 1);\n", "        char c2 = input.charAt(i + 2);\n", "        char c3 = input.charAt(i + 3);\n", "        if (c0 < 0x80 && c1 < 0x80 && c2 < 0x80 && c3 < 0x80) {\n", "          int k1 = c0 | (c1 << 8) | (c2 << 16) | (c3 << 24);\n", "          k1 = mixK1(k1);\n", "          h1 = mixH1(h1, k1);\n", "          i += 4;\n", "          len += 4;\n", "        } else {\n", "          break;\n", "        }\n", "      }\n", "\n", "      long buffer = 0;\n", "      int shift = 0;\n", "      for (; i < utf16Length; i++) {\n", "        char c = input.charAt(i);\n", "        if (c < 0x80) {\n", "          buffer |= (long) c << shift;\n", "          shift += 8;\n", "          len++;\n", "        } else if (c < 0x800) {\n", "          buffer |= charToTwoUtf8Bytes(c) << shift;\n", "          shift += 16;\n", "          len += 2;\n", "        } else if (c < Character.MIN_SURROGATE || c > Character.MAX_SURROGATE) {\n", "          buffer |= charToThreeUtf8Bytes(c) << shift;\n", "          shift += 24;\n", "          len += 3;\n", "        } else {\n", "          int codePoint = Character.codePointAt(input, i);\n", "          if (codePoint == c) {\n", "            // not a valid code point; let the JDK handle invalid Unicode\n", "            return hashBytes(input.toString().getBytes(charset));\n", "          }\n", "          i++;\n", "          buffer |= codePointToFourUtf8Bytes(codePoint) << shift;\n", "          len += 4;\n", "        }\n", "\n", "        if (shift >= 32) {\n", "          int k1 = mixK1((int) buffer);\n", "          h1 = mixH1(h1, k1);\n", "          buffer = buffer >>> 32;\n", "          shift -= 32;\n", "        }\n", "      }\n", "\n", "      int k1 = mixK1((int) buffer);\n", "      h1 ^= k1;\n", "      return fmix(h1, len);\n", "    } else {\n", "      return hashBytes(input.toString().getBytes(charset));\n", "    }\n"], "4": ["  @CanIgnoreReturnValue\n", "  private static final class Murmur3_32Hasher extends AbstractHasher {\n", "    private long buffer;\n", "    private int shift;\n", "    private boolean isDone;\n", "      isDone = false;\n", "    }\n", "\n", "    private void update(int nBytes, long update) {\n", "      // 1 <= nBytes <= 4\n", "      buffer |= (update & 0xFFFFFFFFL) << shift;\n", "      shift += nBytes * 8;\n", "      length += nBytes;\n", "\n", "      if (shift >= 32) {\n", "        h1 = mixH1(h1, mixK1((int) buffer));\n", "        buffer >>>= 32;\n", "        shift -= 32;\n", "      }\n", "    public Hasher putByte(byte b) {\n", "      update(1, b & 0xFF);\n", "      return this;\n", "    public Hasher putBytes(byte[] bytes, int off, int len) {\n", "      checkPositionIndexes(off, off + len, bytes.length);\n", "      int i;\n", "      for (i = 0; i + 4 <= len; i += 4) {\n", "        update(4, getIntLittleEndian(bytes, off + i));\n", "      }\n", "      for (; i < len; i++) {\n", "        putByte(bytes[off + i]);\n", "      return this;\n", "    public Hasher putBytes(ByteBuffer buffer) {\n", "      ByteOrder bo = buffer.order();\n", "      buffer.order(ByteOrder.LITTLE_ENDIAN);\n", "      while (buffer.remaining() >= 4) {\n", "        putInt(buffer.getInt());\n", "      }\n", "      while (buffer.hasRemaining()) {\n", "        putByte(buffer.get());\n", "      }\n", "      buffer.order(bo);\n", "      return this;\n", "\n", "    @Override\n", "    public Hasher putInt(int i) {\n", "      update(4, i);\n", "      return this;\n", "    }\n", "\n", "    @Override\n", "    public Hasher putLong(long l) {\n", "      update(4, (int) l);\n", "      update(4, l >>> 32);\n", "      return this;\n", "    }\n", "\n", "    @Override\n", "    public Hasher putChar(char c) {\n", "      update(2, c);\n", "      return this;\n", "    }\n", "\n", "    @SuppressWarnings(\"deprecation\") // need to use Charsets for Android tests to pass\n", "    @Override\n", "    public Hasher putString(CharSequence input, Charset charset) {\n", "      if (Charsets.UTF_8.equals(charset)) {\n", "        int utf16Length = input.length();\n", "        int i = 0;\n", "\n", "        // This loop optimizes for pure ASCII.\n", "        while (i + 4 <= utf16Length) {\n", "          char c0 = input.charAt(i);\n", "          char c1 = input.charAt(i + 1);\n", "          char c2 = input.charAt(i + 2);\n", "          char c3 = input.charAt(i + 3);\n", "          if (c0 < 0x80 && c1 < 0x80 && c2 < 0x80 && c3 < 0x80) {\n", "            update(4, c0 | (c1 << 8) | (c2 << 16) | (c3 << 24));\n", "            i += 4;\n", "          } else {\n", "            break;\n", "          }\n", "        }\n", "\n", "        for (; i < utf16Length; i++) {\n", "          char c = input.charAt(i);\n", "          if (c < 0x80) {\n", "            update(1, c);\n", "          } else if (c < 0x800) {\n", "            update(2, charToTwoUtf8Bytes(c));\n", "          } else if (c < Character.MIN_SURROGATE || c > Character.MAX_SURROGATE) {\n", "            update(3, charToThreeUtf8Bytes(c));\n", "          } else {\n", "            int codePoint = Character.codePointAt(input, i);\n", "            if (codePoint == c) {\n", "              // fall back to JDK getBytes instead of trying to handle invalid surrogates ourselves\n", "              putBytes(input.subSequence(i, utf16Length).toString().getBytes(charset));\n", "              return this;\n", "            }\n", "            i++;\n", "            update(4, codePointToFourUtf8Bytes(codePoint));\n", "          }\n", "        }\n", "        return this;\n", "      } else {\n", "        return super.putString(input, charset);\n", "      }\n", "    }\n", "\n", "    @Override\n", "    public HashCode hash() {\n", "      checkState(!isDone);\n", "      isDone = true;\n", "      h1 ^= mixK1((int) buffer);\n", "      return fmix(h1, length);\n", "    }\n", "  }\n", "\n", "  private static long codePointToFourUtf8Bytes(int codePoint) {\n", "    return (((0xFL << 4) | (codePoint >>> 18)) & 0xFF)\n", "        | ((0x80L | (0x3F & (codePoint >>> 12))) << 8)\n", "        | ((0x80L | (0x3F & (codePoint >>> 6))) << 16)\n", "        | ((0x80L | (0x3F & codePoint)) << 24);\n", "  }\n", "\n", "  private static long charToThreeUtf8Bytes(char c) {\n", "    return (((0xF << 5) | (c >>> 12)) & 0xFF)\n", "        | ((0x80 | (0x3F & (c >>> 6))) << 8)\n", "        | ((0x80 | (0x3F & c)) << 16);\n", "  }\n", "\n", "  private static long charToTwoUtf8Bytes(char c) {\n", "    return (((0xF << 6) | (c >>> 6)) & 0xFF) | ((0x80 | (0x3F & c)) << 8);\n"]}, "removed": {"1": [" * See MurmurHash3_x86_32 in\n", " * <a href=\"https://github.com/aappleby/smhasher/blob/master/src/MurmurHash3.cpp\">the C++\n"], "2": ["  // TODO(kak): Maybe implement #hashBytes instead?\n"], "3": ["    return hashBytes(input.toString().getBytes(charset));\n"], "4": ["  private static final class Murmur3_32Hasher extends AbstractStreamingHasher {\n", "      super(CHUNK_SIZE);\n", "    protected void process(ByteBuffer bb) {\n", "      int k1 = Murmur3_32HashFunction.mixK1(bb.getInt());\n", "      h1 = Murmur3_32HashFunction.mixH1(h1, k1);\n", "      length += CHUNK_SIZE;\n", "    protected void processRemaining(ByteBuffer bb) {\n", "      length += bb.remaining();\n", "      int k1 = 0;\n", "      for (int i = 0; bb.hasRemaining(); i += 8) {\n", "        k1 ^= toInt(bb.get()) << i;\n", "      h1 ^= Murmur3_32HashFunction.mixK1(k1);\n", "    public HashCode makeHash() {\n", "      return Murmur3_32HashFunction.fmix(h1, length);\n"]}, "added_lines": {"1": [29, 32, 36, 39, 44, 45], "3": [141, 144, 145, 146, 147, 148, 149, 150, 151, 152, 153, 154, 155, 156, 157, 158, 159, 160, 161, 162, 163, 164, 165, 166, 167, 168, 169, 170, 171, 172, 173, 174, 175, 176, 177, 178, 179, 180, 181, 182, 183, 184, 185, 186, 187, 188, 189, 190, 191, 192, 193, 194, 195, 196, 197, 198, 199, 200, 201, 202, 203, 204, 205, 206, 207], "4": [257, 258, 260, 261, 263, 268, 269, 270, 271, 272, 273, 274, 275, 276, 277, 278, 279, 280, 281, 285, 286, 287, 291, 292, 293, 294, 295, 296, 297, 298, 300, 304, 305, 306, 307, 308, 309, 310, 311, 312, 313, 314, 316, 317, 318, 319, 320, 321, 322, 323, 324, 325, 326, 327, 328, 329, 330, 331, 332, 333, 334, 335, 336, 337, 338, 339, 340, 341, 342, 343, 344, 345, 346, 347, 348, 349, 350, 351, 352, 353, 354, 355, 356, 357, 358, 359, 360, 361, 362, 363, 364, 365, 366, 367, 368, 369, 370, 371, 372, 373, 374, 375, 376, 377, 378, 379, 380, 381, 382, 383, 384, 385, 386, 387, 388, 389, 390, 391, 392, 393, 394, 395, 396, 397, 398, 399, 400, 401, 402, 403, 404, 405]}, "removed_lines": {"1": [40, 41], "2": [116], "3": [140], "4": [190, 195, 201, 202, 203, 204, 208, 209, 210, 211, 212, 214, 218, 219]}}]}
