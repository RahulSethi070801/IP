{
    "addition": {
        "29": "import static com.google.common.base.Preconditions.checkState;\n",
        "32": "import com.google.common.base.Charsets;\n",
        "36": "import com.google.errorprone.annotations.CanIgnoreReturnValue;\n",
        "39": "import java.nio.ByteOrder;\n",
        "44": " * See MurmurHash3_x86_32 in <a\n",
        "45": " * href=\"https://github.com/aappleby/smhasher/blob/master/src/MurmurHash3.cpp\">the C++\n",
        "141": "  @SuppressWarnings(\"deprecation\") // need to use Charsets for Android tests to pass\n",
        "144": "    if (Charsets.UTF_8.equals(charset)) {\n",
        "145": "      int utf16Length = input.length();\n",
        "146": "      int h1 = seed;\n",
        "147": "      int i = 0;\n",
        "148": "      int len = 0;\n",
        "149": "\n",
        "150": "      // This loop optimizes for pure ASCII.\n",
        "151": "      while (i + 4 <= utf16Length) {\n",
        "152": "        char c0 = input.charAt(i);\n",
        "153": "        char c1 = input.charAt(i + 1);\n",
        "154": "        char c2 = input.charAt(i + 2);\n",
        "155": "        char c3 = input.charAt(i + 3);\n",
        "156": "        if (c0 < 0x80 && c1 < 0x80 && c2 < 0x80 && c3 < 0x80) {\n",
        "157": "          int k1 = c0 | (c1 << 8) | (c2 << 16) | (c3 << 24);\n",
        "158": "          k1 = mixK1(k1);\n",
        "159": "          h1 = mixH1(h1, k1);\n",
        "160": "          i += 4;\n",
        "161": "          len += 4;\n",
        "162": "        } else {\n",
        "163": "          break;\n",
        "164": "        }\n",
        "165": "      }\n",
        "166": "\n",
        "167": "      long buffer = 0;\n",
        "168": "      int shift = 0;\n",
        "169": "      for (; i < utf16Length; i++) {\n",
        "170": "        char c = input.charAt(i);\n",
        "171": "        if (c < 0x80) {\n",
        "172": "          buffer |= (long) c << shift;\n",
        "173": "          shift += 8;\n",
        "174": "          len++;\n",
        "175": "        } else if (c < 0x800) {\n",
        "176": "          buffer |= charToTwoUtf8Bytes(c) << shift;\n",
        "177": "          shift += 16;\n",
        "178": "          len += 2;\n",
        "179": "        } else if (c < Character.MIN_SURROGATE || c > Character.MAX_SURROGATE) {\n",
        "180": "          buffer |= charToThreeUtf8Bytes(c) << shift;\n",
        "181": "          shift += 24;\n",
        "182": "          len += 3;\n",
        "183": "        } else {\n",
        "184": "          int codePoint = Character.codePointAt(input, i);\n",
        "185": "          if (codePoint == c) {\n",
        "186": "            // not a valid code point; let the JDK handle invalid Unicode\n",
        "187": "            return hashBytes(input.toString().getBytes(charset));\n",
        "188": "          }\n",
        "189": "          i++;\n",
        "190": "          buffer |= codePointToFourUtf8Bytes(codePoint) << shift;\n",
        "191": "          len += 4;\n",
        "192": "        }\n",
        "193": "\n",
        "194": "        if (shift >= 32) {\n",
        "195": "          int k1 = mixK1((int) buffer);\n",
        "196": "          h1 = mixH1(h1, k1);\n",
        "197": "          buffer = buffer >>> 32;\n",
        "198": "          shift -= 32;\n",
        "199": "        }\n",
        "200": "      }\n",
        "201": "\n",
        "202": "      int k1 = mixK1((int) buffer);\n",
        "203": "      h1 ^= k1;\n",
        "204": "      return fmix(h1, len);\n",
        "205": "    } else {\n",
        "206": "      return hashBytes(input.toString().getBytes(charset));\n",
        "207": "    }\n",
        "257": "  @CanIgnoreReturnValue\n",
        "258": "  private static final class Murmur3_32Hasher extends AbstractHasher {\n",
        "260": "    private long buffer;\n",
        "261": "    private int shift;\n",
        "263": "    private boolean isDone;\n",
        "268": "      isDone = false;\n",
        "269": "    }\n",
        "270": "\n",
        "271": "    private void update(int nBytes, long update) {\n",
        "272": "      // 1 <= nBytes <= 4\n",
        "273": "      buffer |= (update & 0xFFFFFFFFL) << shift;\n",
        "274": "      shift += nBytes * 8;\n",
        "275": "      length += nBytes;\n",
        "276": "\n",
        "277": "      if (shift >= 32) {\n",
        "278": "        h1 = mixH1(h1, mixK1((int) buffer));\n",
        "279": "        buffer >>>= 32;\n",
        "280": "        shift -= 32;\n",
        "281": "      }\n",
        "285": "    public Hasher putByte(byte b) {\n",
        "286": "      update(1, b & 0xFF);\n",
        "287": "      return this;\n",
        "291": "    public Hasher putBytes(byte[] bytes, int off, int len) {\n",
        "292": "      checkPositionIndexes(off, off + len, bytes.length);\n",
        "293": "      int i;\n",
        "294": "      for (i = 0; i + 4 <= len; i += 4) {\n",
        "295": "        update(4, getIntLittleEndian(bytes, off + i));\n",
        "296": "      }\n",
        "297": "      for (; i < len; i++) {\n",
        "298": "        putByte(bytes[off + i]);\n",
        "300": "      return this;\n",
        "304": "    public Hasher putBytes(ByteBuffer buffer) {\n",
        "305": "      ByteOrder bo = buffer.order();\n",
        "306": "      buffer.order(ByteOrder.LITTLE_ENDIAN);\n",
        "307": "      while (buffer.remaining() >= 4) {\n",
        "308": "        putInt(buffer.getInt());\n",
        "309": "      }\n",
        "310": "      while (buffer.hasRemaining()) {\n",
        "311": "        putByte(buffer.get());\n",
        "312": "      }\n",
        "313": "      buffer.order(bo);\n",
        "314": "      return this;\n",
        "316": "\n",
        "317": "    @Override\n",
        "318": "    public Hasher putInt(int i) {\n",
        "319": "      update(4, i);\n",
        "320": "      return this;\n",
        "321": "    }\n",
        "322": "\n",
        "323": "    @Override\n",
        "324": "    public Hasher putLong(long l) {\n",
        "325": "      update(4, (int) l);\n",
        "326": "      update(4, l >>> 32);\n",
        "327": "      return this;\n",
        "328": "    }\n",
        "329": "\n",
        "330": "    @Override\n",
        "331": "    public Hasher putChar(char c) {\n",
        "332": "      update(2, c);\n",
        "333": "      return this;\n",
        "334": "    }\n",
        "335": "\n",
        "336": "    @SuppressWarnings(\"deprecation\") // need to use Charsets for Android tests to pass\n",
        "337": "    @Override\n",
        "338": "    public Hasher putString(CharSequence input, Charset charset) {\n",
        "339": "      if (Charsets.UTF_8.equals(charset)) {\n",
        "340": "        int utf16Length = input.length();\n",
        "341": "        int i = 0;\n",
        "342": "\n",
        "343": "        // This loop optimizes for pure ASCII.\n",
        "344": "        while (i + 4 <= utf16Length) {\n",
        "345": "          char c0 = input.charAt(i);\n",
        "346": "          char c1 = input.charAt(i + 1);\n",
        "347": "          char c2 = input.charAt(i + 2);\n",
        "348": "          char c3 = input.charAt(i + 3);\n",
        "349": "          if (c0 < 0x80 && c1 < 0x80 && c2 < 0x80 && c3 < 0x80) {\n",
        "350": "            update(4, c0 | (c1 << 8) | (c2 << 16) | (c3 << 24));\n",
        "351": "            i += 4;\n",
        "352": "          } else {\n",
        "353": "            break;\n",
        "354": "          }\n",
        "355": "        }\n",
        "356": "\n",
        "357": "        for (; i < utf16Length; i++) {\n",
        "358": "          char c = input.charAt(i);\n",
        "359": "          if (c < 0x80) {\n",
        "360": "            update(1, c);\n",
        "361": "          } else if (c < 0x800) {\n",
        "362": "            update(2, charToTwoUtf8Bytes(c));\n",
        "363": "          } else if (c < Character.MIN_SURROGATE || c > Character.MAX_SURROGATE) {\n",
        "364": "            update(3, charToThreeUtf8Bytes(c));\n",
        "365": "          } else {\n",
        "366": "            int codePoint = Character.codePointAt(input, i);\n",
        "367": "            if (codePoint == c) {\n",
        "368": "              // fall back to JDK getBytes instead of trying to handle invalid surrogates ourselves\n",
        "369": "              putBytes(input.subSequence(i, utf16Length).toString().getBytes(charset));\n",
        "370": "              return this;\n",
        "371": "            }\n",
        "372": "            i++;\n",
        "373": "            update(4, codePointToFourUtf8Bytes(codePoint));\n",
        "374": "          }\n",
        "375": "        }\n",
        "376": "        return this;\n",
        "377": "      } else {\n",
        "378": "        return super.putString(input, charset);\n",
        "379": "      }\n",
        "380": "    }\n",
        "381": "\n",
        "382": "    @Override\n",
        "383": "    public HashCode hash() {\n",
        "384": "      checkState(!isDone);\n",
        "385": "      isDone = true;\n",
        "386": "      h1 ^= mixK1((int) buffer);\n",
        "387": "      return fmix(h1, length);\n",
        "388": "    }\n",
        "389": "  }\n",
        "390": "\n",
        "391": "  private static long codePointToFourUtf8Bytes(int codePoint) {\n",
        "392": "    return (((0xFL << 4) | (codePoint >>> 18)) & 0xFF)\n",
        "393": "        | ((0x80L | (0x3F & (codePoint >>> 12))) << 8)\n",
        "394": "        | ((0x80L | (0x3F & (codePoint >>> 6))) << 16)\n",
        "395": "        | ((0x80L | (0x3F & codePoint)) << 24);\n",
        "396": "  }\n",
        "397": "\n",
        "398": "  private static long charToThreeUtf8Bytes(char c) {\n",
        "399": "    return (((0xF << 5) | (c >>> 12)) & 0xFF)\n",
        "400": "        | ((0x80 | (0x3F & (c >>> 6))) << 8)\n",
        "401": "        | ((0x80 | (0x3F & c)) << 16);\n",
        "402": "  }\n",
        "403": "\n",
        "404": "  private static long charToTwoUtf8Bytes(char c) {\n",
        "405": "    return (((0xF << 6) | (c >>> 6)) & 0xFF) | ((0x80 | (0x3F & c)) << 8);\n"
    },
    "removed": {
        "40": " * See MurmurHash3_x86_32 in\n",
        "41": " * <a href=\"https://github.com/aappleby/smhasher/blob/master/src/MurmurHash3.cpp\">the C++\n",
        "116": "  // TODO(kak): Maybe implement #hashBytes instead?\n",
        "140": "    return hashBytes(input.toString().getBytes(charset));\n",
        "190": "  private static final class Murmur3_32Hasher extends AbstractStreamingHasher {\n",
        "195": "      super(CHUNK_SIZE);\n",
        "201": "    protected void process(ByteBuffer bb) {\n",
        "202": "      int k1 = Murmur3_32HashFunction.mixK1(bb.getInt());\n",
        "203": "      h1 = Murmur3_32HashFunction.mixH1(h1, k1);\n",
        "204": "      length += CHUNK_SIZE;\n",
        "208": "    protected void processRemaining(ByteBuffer bb) {\n",
        "209": "      length += bb.remaining();\n",
        "210": "      int k1 = 0;\n",
        "211": "      for (int i = 0; bb.hasRemaining(); i += 8) {\n",
        "212": "        k1 ^= toInt(bb.get()) << i;\n",
        "214": "      h1 ^= Murmur3_32HashFunction.mixK1(k1);\n",
        "218": "    public HashCode makeHash() {\n",
        "219": "      return Murmur3_32HashFunction.fmix(h1, length);\n"
    }
}