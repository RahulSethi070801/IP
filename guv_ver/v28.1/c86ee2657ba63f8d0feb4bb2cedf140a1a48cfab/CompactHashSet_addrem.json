{
    "addition": {
        "74": "    return new CompactHashSet<>();\n",
        "113": "    return new CompactHashSet<>(expectedSize);\n",
        "116": "  private static final float LOAD_FACTOR = 1.0f;\n",
        "127": "  // used to indicate blank table entries\n",
        "131": "   * The hashtable. Its values are indexes to the elements and entries arrays.\n",
        "148": "  /**\n",
        "149": "   * The elements contained in the set, in the range of [0, size()). The elements in [size(),\n",
        "150": "   * elements.length) are all {@code null}.\n",
        "151": "   */\n",
        "166": "    init(DEFAULT_SIZE);\n",
        "175": "    init(expectedSize);\n",
        "179": "  void init(int expectedSize) {\n",
        "181": "    this.modCount = Math.max(1, expectedSize); // Save expectedSize for use in allocArrays()\n",
        "193": "    int expectedSize = modCount;\n",
        "194": "    int buckets = Hashing.closedTableSize(expectedSize, LOAD_FACTOR);\n",
        "198": "    this.elements = new Object[expectedSize];\n",
        "213": "  private int hashTableMask() {\n",
        "214": "    return table.length - 1;\n",
        "215": "  }\n",
        "216": "\n",
        "266": "    int oldCapacity = table.length;\n",
        "267": "    if (Hashing.needsResizing(newEntryIndex, oldCapacity, LOAD_FACTOR)) {\n",
        "268": "      resizeTable(2 * oldCapacity);\n",
        "303": "    int oldCapacity = entries.length;\n",
        "305": "    if (newCapacity > oldCapacity) {\n",
        "306": "      Arrays.fill(entries, oldCapacity, newCapacity, UNSET);\n",
        "372": "        moveLastEntry(next);\n",
        "386": "  void moveLastEntry(int dstIndex) {\n",
        "443": "      int currentIndex = firstEntryIndex();\n",
        "448": "        return currentIndex >= 0;\n",
        "458": "        indexToRemove = currentIndex;\n",
        "459": "        E result = (E) elements[currentIndex];\n",
        "460": "        currentIndex = getSuccessor(currentIndex);\n",
        "470": "        currentIndex = adjustAfterRemove(currentIndex, indexToRemove);\n",
        "524": "    int minimumTableSize = Hashing.closedTableSize(size, LOAD_FACTOR);\n",
        "561": "    init(elementCount);\n"
    },
    "removed": {
        "74": "    return new CompactHashSet<E>();\n",
        "113": "    return new CompactHashSet<E>(expectedSize);\n",
        "116": "  private static final int MAXIMUM_CAPACITY = 1 << 30;\n",
        "117": "\n",
        "118": "  // TODO(user): decide, and inline, load factor. 0.75?\n",
        "119": "  private static final float DEFAULT_LOAD_FACTOR = 1.0f;\n",
        "133": "   * The hashtable. Its values are indexes to both the elements and entries arrays.\n",
        "150": "  /** The elements contained in the set, in the range of [0, size()). */\n",
        "153": "  /** The load factor. */\n",
        "154": "  transient float loadFactor;\n",
        "155": "\n",
        "163": "  /** When we have this many elements, resize the hashtable. */\n",
        "164": "  private transient int threshold;\n",
        "165": "\n",
        "171": "    init(DEFAULT_SIZE, DEFAULT_LOAD_FACTOR);\n",
        "180": "    init(expectedSize, DEFAULT_LOAD_FACTOR);\n",
        "184": "  void init(int expectedSize, float loadFactor) {\n",
        "186": "    Preconditions.checkArgument(loadFactor > 0, \"Illegal load factor\");\n",
        "187": "    this.loadFactor = loadFactor;\n",
        "188": "    this.threshold = Math.max(1, expectedSize); // Save expectedSize for use in allocArrays()\n",
        "200": "    int expectedSize = threshold;\n",
        "201": "    int buckets = Hashing.closedTableSize(expectedSize, loadFactor);\n",
        "204": "    this.elements = new Object[expectedSize];\n",
        "205": "\n",
        "207": "    this.threshold = Math.max(1, (int) (buckets * loadFactor));\n",
        "236": "  private int hashTableMask() {\n",
        "237": "    return table.length - 1;\n",
        "238": "  }\n",
        "239": "\n",
        "274": "    if (newEntryIndex >= threshold) {\n",
        "275": "      resizeTable(2 * table.length);\n",
        "310": "    int oldSize = entries.length;\n",
        "312": "    if (newCapacity > oldSize) {\n",
        "313": "      Arrays.fill(entries, oldSize, newCapacity, UNSET);\n",
        "319": "    int[] oldTable = table;\n",
        "320": "    int oldCapacity = oldTable.length;\n",
        "321": "    if (oldCapacity >= MAXIMUM_CAPACITY) {\n",
        "322": "      threshold = Integer.MAX_VALUE;\n",
        "323": "      return;\n",
        "324": "    }\n",
        "325": "    int newThreshold = 1 + (int) (newCapacity * loadFactor);\n",
        "339": "    this.threshold = newThreshold;\n",
        "387": "        moveEntry(next);\n",
        "401": "  void moveEntry(int dstIndex) {\n",
        "458": "      int index = firstEntryIndex();\n",
        "463": "        return index >= 0;\n",
        "473": "        indexToRemove = index;\n",
        "474": "        E result = (E) elements[index];\n",
        "475": "        index = getSuccessor(index);\n",
        "485": "        index = adjustAfterRemove(index, indexToRemove);\n",
        "539": "    // size / loadFactor gives the table size of the appropriate load factor,\n",
        "540": "    // but that may not be a power of two. We floor it to a power of two by\n",
        "541": "    // keeping its highest bit. But the smaller table may have a load factor\n",
        "542": "    // larger than what we want; then we want to go to the next power of 2 if we can\n",
        "543": "    int minimumTableSize = Math.max(1, Integer.highestOneBit((int) (size / loadFactor)));\n",
        "544": "    if (minimumTableSize < MAXIMUM_CAPACITY) {\n",
        "545": "      double load = (double) size / minimumTableSize;\n",
        "546": "      if (load > loadFactor) {\n",
        "547": "        minimumTableSize <<= 1; // increase to next power if possible\n",
        "548": "      }\n",
        "549": "    }\n",
        "550": "\n",
        "587": "    init(elementCount, DEFAULT_LOAD_FACTOR);\n"
    }
}