{
    "addition": {
        "104": "  private static final float LOAD_FACTOR = 1.0f;\n",
        "160": "    init(DEFAULT_SIZE);\n",
        "168": "  CompactHashMap(int expectedSize) {\n",
        "169": "    init(expectedSize);\n",
        "173": "  void init(int expectedSize) {\n",
        "175": "    this.modCount = Math.max(1, expectedSize); // Save expectedSize for use in allocArrays()\n",
        "187": "    int expectedSize = modCount;\n",
        "188": "    int buckets = Hashing.closedTableSize(expectedSize, LOAD_FACTOR);\n",
        "191": "    this.entries = newEntries(expectedSize);\n",
        "248": "    if (next == UNSET) { // uninitialized bucket\n",
        "276": "    int oldCapacity = table.length;\n",
        "277": "    if (Hashing.needsResizing(newEntryIndex, oldCapacity, LOAD_FACTOR)) {\n",
        "278": "      resizeTable(2 * oldCapacity);\n",
        "386": "      if (getHash(entries[next]) == hash && Objects.equal(key, keys[next])) {\n",
        "387": "        @SuppressWarnings(\"unchecked\") // values only contains Vs\n",
        "388": "        @Nullable\n",
        "389": "        V oldValue = (V) values[next];\n",
        "390": "\n",
        "391": "        if (last == UNSET) {\n",
        "392": "          // we need to update the root link from table[]\n",
        "393": "          table[tableIndex] = getNext(entries[next]);\n",
        "394": "        } else {\n",
        "395": "          // we need to update the link from the chain\n",
        "396": "          entries[last] = swapNext(entries[last], getNext(entries[next]));\n",
        "398": "\n",
        "399": "        moveLastEntry(next);\n",
        "400": "        size--;\n",
        "401": "        modCount++;\n",
        "402": "        return oldValue;\n",
        "586": "      for (int i = firstEntryIndex(); i >= 0; i = getSuccessor(i)) {\n",
        "605": "    for (int i = firstEntryIndex(); i >= 0; i = getSuccessor(i)) {\n",
        "763": "      for (int i = firstEntryIndex(); i >= 0; i = getSuccessor(i)) {\n",
        "818": "    int minimumTableSize = Hashing.closedTableSize(size, LOAD_FACTOR);\n",
        "857": "    init(elementCount);\n"
    },
    "removed": {
        "104": "  private static final int MAXIMUM_CAPACITY = 1 << 30;\n",
        "105": "\n",
        "106": "  // TODO(user): decide, and inline, load factor. 0.75?\n",
        "107": "  static final float DEFAULT_LOAD_FACTOR = 1.0f;\n",
        "151": "  /** The load factor. */\n",
        "152": "  transient float loadFactor;\n",
        "153": "\n",
        "161": "  /** When we have this many elements, resize the hashtable. */\n",
        "162": "  private transient int threshold;\n",
        "163": "\n",
        "169": "    init(DEFAULT_SIZE, DEFAULT_LOAD_FACTOR);\n",
        "177": "  CompactHashMap(int capacity) {\n",
        "178": "    init(capacity, DEFAULT_LOAD_FACTOR);\n",
        "179": "  }\n",
        "180": "\n",
        "181": "  /**\n",
        "182": "   * Constructs a new instance of {@code CompactHashMap} with the specified capacity and load\n",
        "183": "   * factor.\n",
        "184": "   *\n",
        "185": "   * @param capacity the initial capacity of this {@code CompactHashMap}.\n",
        "186": "   * @param loadFactor the load factor of this {@code CompactHashMap}.\n",
        "187": "   */\n",
        "188": "  CompactHashMap(int capacity, float loadFactor) {\n",
        "189": "    init(capacity, loadFactor);\n",
        "193": "  void init(int expectedSize, float loadFactor) {\n",
        "195": "    Preconditions.checkArgument(loadFactor > 0, \"Illegal load factor\");\n",
        "196": "    this.loadFactor = loadFactor;\n",
        "197": "    this.threshold = Math.max(1, expectedSize); // Save expectedSize for use in allocArrays()\n",
        "209": "    int expectedSize = threshold;\n",
        "210": "    int buckets = Hashing.closedTableSize(expectedSize, loadFactor);\n",
        "215": "\n",
        "216": "    this.entries = newEntries(expectedSize);\n",
        "217": "    this.threshold = Math.max(1, (int) (buckets * loadFactor));\n",
        "272": "    if (next == UNSET) {\n",
        "300": "    if (newEntryIndex >= threshold) {\n",
        "301": "      resizeTable(2 * table.length);\n",
        "347": "    int[] oldTable = table;\n",
        "348": "    int oldCapacity = oldTable.length;\n",
        "349": "    if (oldCapacity >= MAXIMUM_CAPACITY) {\n",
        "350": "      threshold = Integer.MAX_VALUE;\n",
        "351": "      return;\n",
        "352": "    }\n",
        "353": "    int newThreshold = 1 + (int) (newCapacity * loadFactor);\n",
        "367": "    this.threshold = newThreshold;\n",
        "417": "      if (getHash(entries[next]) == hash) {\n",
        "418": "        if (Objects.equal(key, keys[next])) {\n",
        "419": "          @SuppressWarnings(\"unchecked\") // values only contains Vs\n",
        "420": "          @Nullable\n",
        "421": "          V oldValue = (V) values[next];\n",
        "422": "\n",
        "423": "          if (last == UNSET) {\n",
        "424": "            // we need to update the root link from table[]\n",
        "425": "            table[tableIndex] = getNext(entries[next]);\n",
        "426": "          } else {\n",
        "427": "            // we need to update the link from the chain\n",
        "428": "            entries[last] = swapNext(entries[last], getNext(entries[next]));\n",
        "429": "          }\n",
        "430": "\n",
        "431": "          moveLastEntry(next);\n",
        "432": "          size--;\n",
        "433": "          modCount++;\n",
        "434": "          return oldValue;\n",
        "619": "      for (int i = 0; i < size; i++) {\n",
        "638": "    for (int i = 0; i < size; i++) {\n",
        "796": "      for (int i = 0; i < size; i++) {\n",
        "851": "    // size / loadFactor gives the table size of the appropriate load factor,\n",
        "852": "    // but that may not be a power of two. We floor it to a power of two by\n",
        "853": "    // keeping its highest bit. But the smaller table may have a load factor\n",
        "854": "    // larger than what we want; then we want to go to the next power of 2 if we can\n",
        "855": "    int minimumTableSize = Math.max(1, Integer.highestOneBit((int) (size / loadFactor)));\n",
        "856": "    if (minimumTableSize < MAXIMUM_CAPACITY) {\n",
        "857": "      double load = (double) size / minimumTableSize;\n",
        "858": "      if (load > loadFactor) {\n",
        "859": "        minimumTableSize <<= 1; // increase to next power if possible\n",
        "860": "      }\n",
        "861": "    }\n",
        "862": "\n",
        "901": "    init(elementCount, DEFAULT_LOAD_FACTOR);\n"
    }
}