{
    "addition": {
        "78": "    return new CompactHashSet<>();\n",
        "117": "    return new CompactHashSet<>(expectedSize);\n",
        "120": "  private static final float LOAD_FACTOR = 1.0f;\n",
        "131": "  // used to indicate blank table entries\n",
        "135": "   * The hashtable. Its values are indexes to the elements and entries arrays.\n",
        "152": "  /**\n",
        "153": "   * The elements contained in the set, in the range of [0, size()). The elements in [size(),\n",
        "154": "   * elements.length) are all {@code null}.\n",
        "155": "   */\n",
        "170": "    init(DEFAULT_SIZE);\n",
        "179": "    init(expectedSize);\n",
        "183": "  void init(int expectedSize) {\n",
        "185": "    this.modCount = Math.max(1, expectedSize); // Save expectedSize for use in allocArrays()\n",
        "197": "    int expectedSize = modCount;\n",
        "198": "    int buckets = Hashing.closedTableSize(expectedSize, LOAD_FACTOR);\n",
        "202": "    this.elements = new Object[expectedSize];\n",
        "217": "  private int hashTableMask() {\n",
        "218": "    return table.length - 1;\n",
        "219": "  }\n",
        "220": "\n",
        "270": "    int oldCapacity = table.length;\n",
        "271": "    if (Hashing.needsResizing(newEntryIndex, oldCapacity, LOAD_FACTOR)) {\n",
        "272": "      resizeTable(2 * oldCapacity);\n",
        "307": "    int oldCapacity = entries.length;\n",
        "309": "    if (newCapacity > oldCapacity) {\n",
        "310": "      Arrays.fill(entries, oldCapacity, newCapacity, UNSET);\n",
        "376": "        moveLastEntry(next);\n",
        "390": "  void moveLastEntry(int dstIndex) {\n",
        "447": "      int currentIndex = firstEntryIndex();\n",
        "452": "        return currentIndex >= 0;\n",
        "462": "        indexToRemove = currentIndex;\n",
        "463": "        E result = (E) elements[currentIndex];\n",
        "464": "        currentIndex = getSuccessor(currentIndex);\n",
        "474": "        currentIndex = adjustAfterRemove(currentIndex, indexToRemove);\n",
        "497": "    for (int i = firstEntryIndex(); i >= 0; i = getSuccessor(i)) {\n",
        "544": "    int minimumTableSize = Hashing.closedTableSize(size, LOAD_FACTOR);\n",
        "581": "    init(elementCount);\n"
    },
    "removed": {
        "78": "    return new CompactHashSet<E>();\n",
        "117": "    return new CompactHashSet<E>(expectedSize);\n",
        "120": "  private static final int MAXIMUM_CAPACITY = 1 << 30;\n",
        "121": "\n",
        "122": "  // TODO(user): decide, and inline, load factor. 0.75?\n",
        "123": "  private static final float DEFAULT_LOAD_FACTOR = 1.0f;\n",
        "137": "   * The hashtable. Its values are indexes to both the elements and entries arrays.\n",
        "154": "  /** The elements contained in the set, in the range of [0, size()). */\n",
        "157": "  /** The load factor. */\n",
        "158": "  transient float loadFactor;\n",
        "159": "\n",
        "167": "  /** When we have this many elements, resize the hashtable. */\n",
        "168": "  private transient int threshold;\n",
        "169": "\n",
        "175": "    init(DEFAULT_SIZE, DEFAULT_LOAD_FACTOR);\n",
        "184": "    init(expectedSize, DEFAULT_LOAD_FACTOR);\n",
        "188": "  void init(int expectedSize, float loadFactor) {\n",
        "190": "    Preconditions.checkArgument(loadFactor > 0, \"Illegal load factor\");\n",
        "191": "    this.loadFactor = loadFactor;\n",
        "192": "    this.threshold = Math.max(1, expectedSize); // Save expectedSize for use in allocArrays()\n",
        "204": "    int expectedSize = threshold;\n",
        "205": "    int buckets = Hashing.closedTableSize(expectedSize, loadFactor);\n",
        "208": "    this.elements = new Object[expectedSize];\n",
        "209": "\n",
        "211": "    this.threshold = Math.max(1, (int) (buckets * loadFactor));\n",
        "240": "  private int hashTableMask() {\n",
        "241": "    return table.length - 1;\n",
        "242": "  }\n",
        "243": "\n",
        "278": "    if (newEntryIndex >= threshold) {\n",
        "279": "      resizeTable(2 * table.length);\n",
        "314": "    int oldSize = entries.length;\n",
        "316": "    if (newCapacity > oldSize) {\n",
        "317": "      Arrays.fill(entries, oldSize, newCapacity, UNSET);\n",
        "323": "    int[] oldTable = table;\n",
        "324": "    int oldCapacity = oldTable.length;\n",
        "325": "    if (oldCapacity >= MAXIMUM_CAPACITY) {\n",
        "326": "      threshold = Integer.MAX_VALUE;\n",
        "327": "      return;\n",
        "328": "    }\n",
        "329": "    int newThreshold = 1 + (int) (newCapacity * loadFactor);\n",
        "343": "    this.threshold = newThreshold;\n",
        "391": "        moveEntry(next);\n",
        "405": "  void moveEntry(int dstIndex) {\n",
        "462": "      int index = firstEntryIndex();\n",
        "467": "        return index >= 0;\n",
        "477": "        indexToRemove = index;\n",
        "478": "        E result = (E) elements[index];\n",
        "479": "        index = getSuccessor(index);\n",
        "489": "        index = adjustAfterRemove(index, indexToRemove);\n",
        "512": "    for (int i = 0; i < size; i++) {\n",
        "559": "    // size / loadFactor gives the table size of the appropriate load factor,\n",
        "560": "    // but that may not be a power of two. We floor it to a power of two by\n",
        "561": "    // keeping its highest bit. But the smaller table may have a load factor\n",
        "562": "    // larger than what we want; then we want to go to the next power of 2 if we can\n",
        "563": "    int minimumTableSize = Math.max(1, Integer.highestOneBit((int) (size / loadFactor)));\n",
        "564": "    if (minimumTableSize < MAXIMUM_CAPACITY) {\n",
        "565": "      double load = (double) size / minimumTableSize;\n",
        "566": "      if (load > loadFactor) {\n",
        "567": "        minimumTableSize <<= 1; // increase to next power if possible\n",
        "568": "      }\n",
        "569": "    }\n",
        "570": "\n",
        "607": "    init(elementCount, DEFAULT_LOAD_FACTOR);\n"
    }
}