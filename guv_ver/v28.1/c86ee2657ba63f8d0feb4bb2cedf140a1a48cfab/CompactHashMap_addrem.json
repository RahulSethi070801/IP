{
    "addition": {
        "99": "  private static final float LOAD_FACTOR = 1.0f;\n",
        "155": "    init(DEFAULT_SIZE);\n",
        "163": "  CompactHashMap(int expectedSize) {\n",
        "164": "    init(expectedSize);\n",
        "168": "  void init(int expectedSize) {\n",
        "170": "    this.modCount = Math.max(1, expectedSize); // Save expectedSize for use in allocArrays()\n",
        "182": "    int expectedSize = modCount;\n",
        "183": "    int buckets = Hashing.closedTableSize(expectedSize, LOAD_FACTOR);\n",
        "186": "    this.entries = newEntries(expectedSize);\n",
        "244": "    if (next == UNSET) { // uninitialized bucket\n",
        "272": "    int oldCapacity = table.length;\n",
        "273": "    if (Hashing.needsResizing(newEntryIndex, oldCapacity, LOAD_FACTOR)) {\n",
        "274": "      resizeTable(2 * oldCapacity);\n",
        "384": "      if (getHash(entries[next]) == hash && Objects.equal(key, keys[next])) {\n",
        "385": "        @SuppressWarnings(\"unchecked\") // values only contains Vs\n",
        "386": "        @NullableDecl\n",
        "387": "        V oldValue = (V) values[next];\n",
        "388": "\n",
        "389": "        if (last == UNSET) {\n",
        "390": "          // we need to update the root link from table[]\n",
        "391": "          table[tableIndex] = getNext(entries[next]);\n",
        "392": "        } else {\n",
        "393": "          // we need to update the link from the chain\n",
        "394": "          entries[last] = swapNext(entries[last], getNext(entries[next]));\n",
        "396": "\n",
        "397": "        moveLastEntry(next);\n",
        "398": "        size--;\n",
        "399": "        modCount++;\n",
        "400": "        return oldValue;\n",
        "747": "    int minimumTableSize = Hashing.closedTableSize(size, LOAD_FACTOR);\n",
        "786": "    init(elementCount);\n"
    },
    "removed": {
        "99": "  private static final int MAXIMUM_CAPACITY = 1 << 30;\n",
        "100": "\n",
        "101": "  // TODO(user): decide, and inline, load factor. 0.75?\n",
        "102": "  static final float DEFAULT_LOAD_FACTOR = 1.0f;\n",
        "146": "  /** The load factor. */\n",
        "147": "  transient float loadFactor;\n",
        "148": "\n",
        "156": "  /** When we have this many elements, resize the hashtable. */\n",
        "157": "  private transient int threshold;\n",
        "158": "\n",
        "164": "    init(DEFAULT_SIZE, DEFAULT_LOAD_FACTOR);\n",
        "172": "  CompactHashMap(int capacity) {\n",
        "173": "    init(capacity, DEFAULT_LOAD_FACTOR);\n",
        "174": "  }\n",
        "175": "\n",
        "176": "  /**\n",
        "177": "   * Constructs a new instance of {@code CompactHashMap} with the specified capacity and load\n",
        "178": "   * factor.\n",
        "179": "   *\n",
        "180": "   * @param capacity the initial capacity of this {@code CompactHashMap}.\n",
        "181": "   * @param loadFactor the load factor of this {@code CompactHashMap}.\n",
        "182": "   */\n",
        "183": "  CompactHashMap(int capacity, float loadFactor) {\n",
        "184": "    init(capacity, loadFactor);\n",
        "188": "  void init(int expectedSize, float loadFactor) {\n",
        "190": "    Preconditions.checkArgument(loadFactor > 0, \"Illegal load factor\");\n",
        "191": "    this.loadFactor = loadFactor;\n",
        "192": "    this.threshold = Math.max(1, expectedSize); // Save expectedSize for use in allocArrays()\n",
        "204": "    int expectedSize = threshold;\n",
        "205": "    int buckets = Hashing.closedTableSize(expectedSize, loadFactor);\n",
        "210": "\n",
        "211": "    this.entries = newEntries(expectedSize);\n",
        "212": "    this.threshold = Math.max(1, (int) (buckets * loadFactor));\n",
        "268": "    if (next == UNSET) {\n",
        "296": "    if (newEntryIndex >= threshold) {\n",
        "297": "      resizeTable(2 * table.length);\n",
        "343": "    int[] oldTable = table;\n",
        "344": "    int oldCapacity = oldTable.length;\n",
        "345": "    if (oldCapacity >= MAXIMUM_CAPACITY) {\n",
        "346": "      threshold = Integer.MAX_VALUE;\n",
        "347": "      return;\n",
        "348": "    }\n",
        "349": "    int newThreshold = 1 + (int) (newCapacity * loadFactor);\n",
        "363": "    this.threshold = newThreshold;\n",
        "415": "      if (getHash(entries[next]) == hash) {\n",
        "416": "        if (Objects.equal(key, keys[next])) {\n",
        "417": "          @SuppressWarnings(\"unchecked\") // values only contains Vs\n",
        "418": "          @NullableDecl\n",
        "419": "          V oldValue = (V) values[next];\n",
        "420": "\n",
        "421": "          if (last == UNSET) {\n",
        "422": "            // we need to update the root link from table[]\n",
        "423": "            table[tableIndex] = getNext(entries[next]);\n",
        "424": "          } else {\n",
        "425": "            // we need to update the link from the chain\n",
        "426": "            entries[last] = swapNext(entries[last], getNext(entries[next]));\n",
        "427": "          }\n",
        "428": "\n",
        "429": "          moveLastEntry(next);\n",
        "430": "          size--;\n",
        "431": "          modCount++;\n",
        "432": "          return oldValue;\n",
        "780": "    // size / loadFactor gives the table size of the appropriate load factor,\n",
        "781": "    // but that may not be a power of two. We floor it to a power of two by\n",
        "782": "    // keeping its highest bit. But the smaller table may have a load factor\n",
        "783": "    // larger than what we want; then we want to go to the next power of 2 if we can\n",
        "784": "    int minimumTableSize = Math.max(1, Integer.highestOneBit((int) (size / loadFactor)));\n",
        "785": "    if (minimumTableSize < MAXIMUM_CAPACITY) {\n",
        "786": "      double load = (double) size / minimumTableSize;\n",
        "787": "      if (load > loadFactor) {\n",
        "788": "        minimumTableSize <<= 1; // increase to next power if possible\n",
        "789": "      }\n",
        "790": "    }\n",
        "791": "\n",
        "830": "    init(elementCount, DEFAULT_LOAD_FACTOR);\n"
    }
}