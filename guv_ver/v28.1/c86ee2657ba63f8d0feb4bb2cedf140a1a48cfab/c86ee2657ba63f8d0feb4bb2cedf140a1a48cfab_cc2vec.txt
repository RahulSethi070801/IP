{"id": "c86ee2657ba63f8d0feb4bb2cedf140a1a48cfab", "code": [{"0": "android/guava/src/com/google/common/collect/CompactHashMap.java", "added": {"1": ["  private static final float LOAD_FACTOR = 1.0f;\n"], "3": ["    init(DEFAULT_SIZE);\n"], "4": ["  CompactHashMap(int expectedSize) {\n", "    init(expectedSize);\n", "  void init(int expectedSize) {\n", "    this.modCount = Math.max(1, expectedSize); // Save expectedSize for use in allocArrays()\n"], "5": ["    int expectedSize = modCount;\n", "    int buckets = Hashing.closedTableSize(expectedSize, LOAD_FACTOR);\n", "    this.entries = newEntries(expectedSize);\n"], "6": ["    if (next == UNSET) { // uninitialized bucket\n"], "7": ["    int oldCapacity = table.length;\n", "    if (Hashing.needsResizing(newEntryIndex, oldCapacity, LOAD_FACTOR)) {\n", "      resizeTable(2 * oldCapacity);\n"], "10": ["      if (getHash(entries[next]) == hash && Objects.equal(key, keys[next])) {\n", "        @SuppressWarnings(\"unchecked\") // values only contains Vs\n", "        @NullableDecl\n", "        V oldValue = (V) values[next];\n", "\n", "        if (last == UNSET) {\n", "          // we need to update the root link from table[]\n", "          table[tableIndex] = getNext(entries[next]);\n", "        } else {\n", "          // we need to update the link from the chain\n", "          entries[last] = swapNext(entries[last], getNext(entries[next]));\n", "\n", "        moveLastEntry(next);\n", "        size--;\n", "        modCount++;\n", "        return oldValue;\n"], "11": ["    int minimumTableSize = Hashing.closedTableSize(size, LOAD_FACTOR);\n"], "12": ["    init(elementCount);\n"]}, "removed": {"1": ["  private static final int MAXIMUM_CAPACITY = 1 << 30;\n", "\n", "  // TODO(user): decide, and inline, load factor. 0.75?\n", "  static final float DEFAULT_LOAD_FACTOR = 1.0f;\n"], "2": ["  /** The load factor. */\n", "  transient float loadFactor;\n", "\n"], "3": ["  /** When we have this many elements, resize the hashtable. */\n", "  private transient int threshold;\n", "\n", "    init(DEFAULT_SIZE, DEFAULT_LOAD_FACTOR);\n"], "4": ["  CompactHashMap(int capacity) {\n", "    init(capacity, DEFAULT_LOAD_FACTOR);\n", "  }\n", "\n", "  /**\n", "   * Constructs a new instance of {@code CompactHashMap} with the specified capacity and load\n", "   * factor.\n", "   *\n", "   * @param capacity the initial capacity of this {@code CompactHashMap}.\n", "   * @param loadFactor the load factor of this {@code CompactHashMap}.\n", "   */\n", "  CompactHashMap(int capacity, float loadFactor) {\n", "    init(capacity, loadFactor);\n", "  void init(int expectedSize, float loadFactor) {\n", "    Preconditions.checkArgument(loadFactor > 0, \"Illegal load factor\");\n", "    this.loadFactor = loadFactor;\n", "    this.threshold = Math.max(1, expectedSize); // Save expectedSize for use in allocArrays()\n"], "5": ["    int expectedSize = threshold;\n", "    int buckets = Hashing.closedTableSize(expectedSize, loadFactor);\n", "\n", "    this.entries = newEntries(expectedSize);\n", "    this.threshold = Math.max(1, (int) (buckets * loadFactor));\n"], "6": ["    if (next == UNSET) {\n"], "7": ["    if (newEntryIndex >= threshold) {\n", "      resizeTable(2 * table.length);\n"], "8": ["    int[] oldTable = table;\n", "    int oldCapacity = oldTable.length;\n", "    if (oldCapacity >= MAXIMUM_CAPACITY) {\n", "      threshold = Integer.MAX_VALUE;\n", "      return;\n", "    }\n", "    int newThreshold = 1 + (int) (newCapacity * loadFactor);\n"], "9": ["    this.threshold = newThreshold;\n"], "10": ["      if (getHash(entries[next]) == hash) {\n", "        if (Objects.equal(key, keys[next])) {\n", "          @SuppressWarnings(\"unchecked\") // values only contains Vs\n", "          @NullableDecl\n", "          V oldValue = (V) values[next];\n", "\n", "          if (last == UNSET) {\n", "            // we need to update the root link from table[]\n", "            table[tableIndex] = getNext(entries[next]);\n", "          } else {\n", "            // we need to update the link from the chain\n", "            entries[last] = swapNext(entries[last], getNext(entries[next]));\n", "          }\n", "\n", "          moveLastEntry(next);\n", "          size--;\n", "          modCount++;\n", "          return oldValue;\n"], "11": ["    // size / loadFactor gives the table size of the appropriate load factor,\n", "    // but that may not be a power of two. We floor it to a power of two by\n", "    // keeping its highest bit. But the smaller table may have a load factor\n", "    // larger than what we want; then we want to go to the next power of 2 if we can\n", "    int minimumTableSize = Math.max(1, Integer.highestOneBit((int) (size / loadFactor)));\n", "    if (minimumTableSize < MAXIMUM_CAPACITY) {\n", "      double load = (double) size / minimumTableSize;\n", "      if (load > loadFactor) {\n", "        minimumTableSize <<= 1; // increase to next power if possible\n", "      }\n", "    }\n", "\n"], "12": ["    init(elementCount, DEFAULT_LOAD_FACTOR);\n"]}, "added_lines": {"1": [99], "3": [155], "4": [163, 164, 168, 170], "5": [182, 183, 186], "6": [244], "7": [272, 273, 274], "10": [384, 385, 386, 387, 388, 389, 390, 391, 392, 393, 394, 396, 397, 398, 399, 400], "11": [747], "12": [786]}, "removed_lines": {"1": [99, 100, 101, 102], "2": [146, 147, 148], "3": [156, 157, 158, 164], "4": [172, 173, 174, 175, 176, 177, 178, 179, 180, 181, 182, 183, 184, 188, 190, 191, 192], "5": [204, 205, 210, 211, 212], "6": [268], "7": [296, 297], "8": [343, 344, 345, 346, 347, 348, 349], "9": [363], "10": [415, 416, 417, 418, 419, 420, 421, 422, 423, 424, 425, 426, 427, 428, 429, 430, 431, 432], "11": [780, 781, 782, 783, 784, 785, 786, 787, 788, 789, 790, 791], "12": [830]}}, {"1": "android/guava/src/com/google/common/collect/CompactHashSet.java", "added": {"1": ["    return new CompactHashSet<>();\n"], "2": ["    return new CompactHashSet<>(expectedSize);\n", "  private static final float LOAD_FACTOR = 1.0f;\n"], "3": ["  // used to indicate blank table entries\n", "   * The hashtable. Its values are indexes to the elements and entries arrays.\n"], "4": ["  /**\n", "   * The elements contained in the set, in the range of [0, size()). The elements in [size(),\n", "   * elements.length) are all {@code null}.\n", "   */\n"], "5": ["    init(DEFAULT_SIZE);\n"], "6": ["    init(expectedSize);\n", "  void init(int expectedSize) {\n", "    this.modCount = Math.max(1, expectedSize); // Save expectedSize for use in allocArrays()\n"], "7": ["    int expectedSize = modCount;\n", "    int buckets = Hashing.closedTableSize(expectedSize, LOAD_FACTOR);\n", "    this.elements = new Object[expectedSize];\n"], "8": ["  private int hashTableMask() {\n", "    return table.length - 1;\n", "  }\n", "\n"], "10": ["    int oldCapacity = table.length;\n", "    if (Hashing.needsResizing(newEntryIndex, oldCapacity, LOAD_FACTOR)) {\n", "      resizeTable(2 * oldCapacity);\n"], "11": ["    int oldCapacity = entries.length;\n", "    if (newCapacity > oldCapacity) {\n", "      Arrays.fill(entries, oldCapacity, newCapacity, UNSET);\n"], "13": ["        moveLastEntry(next);\n"], "14": ["  void moveLastEntry(int dstIndex) {\n"], "15": ["      int currentIndex = firstEntryIndex();\n", "        return currentIndex >= 0;\n"], "16": ["        indexToRemove = currentIndex;\n", "        E result = (E) elements[currentIndex];\n", "        currentIndex = getSuccessor(currentIndex);\n"], "17": ["        currentIndex = adjustAfterRemove(currentIndex, indexToRemove);\n"], "18": ["    int minimumTableSize = Hashing.closedTableSize(size, LOAD_FACTOR);\n"], "19": ["    init(elementCount);\n"]}, "removed": {"1": ["    return new CompactHashSet<E>();\n"], "2": ["    return new CompactHashSet<E>(expectedSize);\n", "  private static final int MAXIMUM_CAPACITY = 1 << 30;\n", "\n", "  // TODO(user): decide, and inline, load factor. 0.75?\n", "  private static final float DEFAULT_LOAD_FACTOR = 1.0f;\n"], "3": ["   * The hashtable. Its values are indexes to both the elements and entries arrays.\n"], "4": ["  /** The elements contained in the set, in the range of [0, size()). */\n", "  /** The load factor. */\n", "  transient float loadFactor;\n", "\n"], "5": ["  /** When we have this many elements, resize the hashtable. */\n", "  private transient int threshold;\n", "\n", "    init(DEFAULT_SIZE, DEFAULT_LOAD_FACTOR);\n"], "6": ["    init(expectedSize, DEFAULT_LOAD_FACTOR);\n", "  void init(int expectedSize, float loadFactor) {\n", "    Preconditions.checkArgument(loadFactor > 0, \"Illegal load factor\");\n", "    this.loadFactor = loadFactor;\n", "    this.threshold = Math.max(1, expectedSize); // Save expectedSize for use in allocArrays()\n"], "7": ["    int expectedSize = threshold;\n", "    int buckets = Hashing.closedTableSize(expectedSize, loadFactor);\n", "    this.elements = new Object[expectedSize];\n", "\n", "    this.threshold = Math.max(1, (int) (buckets * loadFactor));\n"], "9": ["  private int hashTableMask() {\n", "    return table.length - 1;\n", "  }\n", "\n"], "10": ["    if (newEntryIndex >= threshold) {\n", "      resizeTable(2 * table.length);\n"], "11": ["    int oldSize = entries.length;\n", "    if (newCapacity > oldSize) {\n", "      Arrays.fill(entries, oldSize, newCapacity, UNSET);\n", "    int[] oldTable = table;\n", "    int oldCapacity = oldTable.length;\n", "    if (oldCapacity >= MAXIMUM_CAPACITY) {\n", "      threshold = Integer.MAX_VALUE;\n", "      return;\n", "    }\n", "    int newThreshold = 1 + (int) (newCapacity * loadFactor);\n"], "12": ["    this.threshold = newThreshold;\n"], "13": ["        moveEntry(next);\n"], "14": ["  void moveEntry(int dstIndex) {\n"], "15": ["      int index = firstEntryIndex();\n", "        return index >= 0;\n"], "16": ["        indexToRemove = index;\n", "        E result = (E) elements[index];\n", "        index = getSuccessor(index);\n"], "17": ["        index = adjustAfterRemove(index, indexToRemove);\n"], "18": ["    // size / loadFactor gives the table size of the appropriate load factor,\n", "    // but that may not be a power of two. We floor it to a power of two by\n", "    // keeping its highest bit. But the smaller table may have a load factor\n", "    // larger than what we want; then we want to go to the next power of 2 if we can\n", "    int minimumTableSize = Math.max(1, Integer.highestOneBit((int) (size / loadFactor)));\n", "    if (minimumTableSize < MAXIMUM_CAPACITY) {\n", "      double load = (double) size / minimumTableSize;\n", "      if (load > loadFactor) {\n", "        minimumTableSize <<= 1; // increase to next power if possible\n", "      }\n", "    }\n", "\n"], "19": ["    init(elementCount, DEFAULT_LOAD_FACTOR);\n"]}, "added_lines": {"1": [74], "2": [113, 116], "3": [127, 131], "4": [148, 149, 150, 151], "5": [166], "6": [175, 179, 181], "7": [193, 194, 198], "8": [213, 214, 215, 216], "10": [266, 267, 268], "11": [303, 305, 306], "13": [372], "14": [386], "15": [443, 448], "16": [458, 459, 460], "17": [470], "18": [524], "19": [561]}, "removed_lines": {"1": [74], "2": [113, 116, 117, 118, 119], "3": [133], "4": [150, 153, 154, 155], "5": [163, 164, 165, 171], "6": [180, 184, 186, 187, 188], "7": [200, 201, 204, 205, 207], "9": [236, 237, 238, 239], "10": [274, 275], "11": [310, 312, 313, 319, 320, 321, 322, 323, 324, 325], "12": [339], "13": [387], "14": [401], "15": [458, 463], "16": [473, 474, 475], "17": [485], "18": [539, 540, 541, 542, 543, 544, 545, 546, 547, 548, 549, 550], "19": [587]}}, {"2": "android/guava/src/com/google/common/collect/CompactLinkedHashMap.java", "added": {"1": ["   * <i>should</i> hold {@code expectedSize} elements without rebuilding internal data structures.\n"], "2": ["    this(expectedSize, false);\n", "  CompactLinkedHashMap(int expectedSize, boolean accessOrder) {\n", "    super(expectedSize);\n", "  void init(int expectedSize) {\n", "    super.init(expectedSize);\n", "    this.firstEntry = ENDPOINT;\n", "    this.lastEntry = ENDPOINT;\n", "    this.links = new long[expectedSize];\n"], "3": ["    super.moveLastEntry(dstIndex);\n", "\n"]}, "removed": {"1": ["   * <i>should</i> hold {@code expectedSize} elements without growth.\n"], "2": ["    this(expectedSize, DEFAULT_LOAD_FACTOR, false);\n", "  CompactLinkedHashMap(int expectedSize, float loadFactor, boolean accessOrder) {\n", "    super(expectedSize, loadFactor);\n", "  void init(int expectedSize, float loadFactor) {\n", "    super.init(expectedSize, loadFactor);\n", "    firstEntry = ENDPOINT;\n", "    lastEntry = ENDPOINT;\n", "    links = new long[expectedSize];\n"], "3": ["    super.moveLastEntry(dstIndex);\n"]}, "added_lines": {"1": [55], "2": [92, 95, 96, 101, 102, 103, 104, 111], "3": [170, 171]}, "removed_lines": {"1": [54], "2": [91, 94, 95, 100, 101, 102, 103, 110], "3": [174]}}, {"3": "android/guava/src/com/google/common/collect/CompactLinkedHashSet.java", "added": {"1": ["    return new CompactLinkedHashSet<>();\n"], "2": ["    return new CompactLinkedHashSet<>(expectedSize);\n"], "3": ["  /** Pointer to the first node in the linked list, or {@code ENDPOINT} if there are no entries. */\n", "\n", "  /** Pointer to the last node in the linked list, or {@code ENDPOINT} if there are no entries. */\n"], "4": ["  void init(int expectedSize) {\n", "    super.init(expectedSize);\n", "    this.firstEntry = ENDPOINT;\n", "    this.lastEntry = ENDPOINT;\n"], "5": ["  private int getPredecessor(int entry) {\n", "    return predecessor[entry];\n", "  }\n", "\n", "  @Override\n", "  int getSuccessor(int entry) {\n", "    return successor[entry];\n", "  }\n", "\n", "  private void setSuccessor(int entry, int succ) {\n", "    successor[entry] = succ;\n", "  }\n", "\n", "  private void setPredecessor(int entry, int pred) {\n", "    predecessor[entry] = pred;\n", "  }\n", "\n", "  private void setSucceeds(int pred, int succ) {\n", "      setSuccessor(pred, succ);\n", "      setPredecessor(succ, pred);\n", "    setSucceeds(lastEntry, entryIndex);\n", "    setSucceeds(entryIndex, ENDPOINT);\n", "  void moveLastEntry(int dstIndex) {\n", "    super.moveLastEntry(dstIndex);\n", "    setSucceeds(getPredecessor(dstIndex), getSuccessor(dstIndex));\n", "    if (dstIndex < srcIndex) {\n", "      setSucceeds(getPredecessor(srcIndex), dstIndex);\n", "      setSucceeds(dstIndex, getSuccessor(srcIndex));\n"], "6": ["  int firstEntryIndex() {\n", "    return firstEntry;\n", "  int adjustAfterRemove(int indexBeforeRemove, int indexRemoved) {\n", "    return (indexBeforeRemove >= size()) ? indexRemoved : indexBeforeRemove;\n", "  public Object[] toArray() {\n", "    return ObjectArrays.toArrayImpl(this);\n", "  public <T> T[] toArray(T[] a) {\n", "    return ObjectArrays.toArrayImpl(this, a);\n", "  public void clear() {\n", "    if (needsAllocArrays()) {\n", "      return;\n", "    }\n", "    this.firstEntry = ENDPOINT;\n", "    this.lastEntry = ENDPOINT;\n", "    Arrays.fill(predecessor, 0, size(), UNSET);\n", "    Arrays.fill(successor, 0, size(), UNSET);\n", "    super.clear();\n"]}, "removed": {"1": ["    return new CompactLinkedHashSet<E>();\n"], "2": ["    return new CompactLinkedHashSet<E>(expectedSize);\n"], "4": ["  void init(int expectedSize, float loadFactor) {\n", "    super.init(expectedSize, loadFactor);\n", "    firstEntry = ENDPOINT;\n", "    lastEntry = ENDPOINT;\n"], "5": ["  private void succeeds(int pred, int succ) {\n", "      successor[pred] = succ;\n", "      predecessor[succ] = pred;\n", "    succeeds(lastEntry, entryIndex);\n", "    succeeds(entryIndex, ENDPOINT);\n", "  void moveEntry(int dstIndex) {\n", "    super.moveEntry(dstIndex);\n", "    succeeds(predecessor[dstIndex], successor[dstIndex]);\n", "    if (srcIndex != dstIndex) {\n", "      succeeds(predecessor[srcIndex], dstIndex);\n", "      succeeds(dstIndex, successor[srcIndex]);\n", "  @Override\n", "  public void clear() {\n", "    if (needsAllocArrays()) {\n", "      return;\n", "    }\n", "    firstEntry = ENDPOINT;\n", "    lastEntry = ENDPOINT;\n", "    Arrays.fill(predecessor, 0, size(), UNSET);\n", "    Arrays.fill(successor, 0, size(), UNSET);\n", "    super.clear();\n", "  }\n", "\n"], "6": ["  public Object[] toArray() {\n", "    return ObjectArrays.toArrayImpl(this);\n", "  public <T> T[] toArray(T[] a) {\n", "    return ObjectArrays.toArrayImpl(this, a);\n", "  int firstEntryIndex() {\n", "    return firstEntry;\n", "  int adjustAfterRemove(int indexBeforeRemove, int indexRemoved) {\n", "    return (indexBeforeRemove == size()) ? indexRemoved : indexBeforeRemove;\n", "  int getSuccessor(int entryIndex) {\n", "    return successor[entryIndex];\n"]}, "added_lines": {"1": [51], "2": [90], "3": [111, 113, 114], "4": [126, 127, 128, 129], "5": [142, 143, 144, 145, 146, 147, 148, 149, 150, 151, 152, 153, 154, 155, 156, 157, 158, 159, 163, 169, 176, 177, 181, 183, 185, 186, 187, 188], "6": [207, 208, 212, 213, 217, 218, 222, 223, 227, 228, 229, 230, 231, 232, 233, 234, 235]}, "removed_lines": {"1": [51], "2": [90], "4": [123, 124, 125, 126], "5": [140, 144, 150, 157, 158, 162, 164, 166, 167, 168, 169, 175, 176, 177, 178, 179, 180, 181, 182, 183, 184, 185, 186], "6": [201, 202, 206, 207, 211, 212, 216, 217, 221, 222]}}, {"4": "guava/src/com/google/common/collect/CompactHashMap.java", "added": {"1": ["  private static final float LOAD_FACTOR = 1.0f;\n"], "3": ["    init(DEFAULT_SIZE);\n"], "4": ["  CompactHashMap(int expectedSize) {\n", "    init(expectedSize);\n", "  void init(int expectedSize) {\n", "    this.modCount = Math.max(1, expectedSize); // Save expectedSize for use in allocArrays()\n"], "5": ["    int expectedSize = modCount;\n", "    int buckets = Hashing.closedTableSize(expectedSize, LOAD_FACTOR);\n", "    this.entries = newEntries(expectedSize);\n"], "6": ["    if (next == UNSET) { // uninitialized bucket\n"], "7": ["    int oldCapacity = table.length;\n", "    if (Hashing.needsResizing(newEntryIndex, oldCapacity, LOAD_FACTOR)) {\n", "      resizeTable(2 * oldCapacity);\n"], "10": ["      if (getHash(entries[next]) == hash && Objects.equal(key, keys[next])) {\n", "        @SuppressWarnings(\"unchecked\") // values only contains Vs\n", "        @Nullable\n", "        V oldValue = (V) values[next];\n", "\n", "        if (last == UNSET) {\n", "          // we need to update the root link from table[]\n", "          table[tableIndex] = getNext(entries[next]);\n", "        } else {\n", "          // we need to update the link from the chain\n", "          entries[last] = swapNext(entries[last], getNext(entries[next]));\n", "\n", "        moveLastEntry(next);\n", "        size--;\n", "        modCount++;\n", "        return oldValue;\n"], "11": ["      for (int i = firstEntryIndex(); i >= 0; i = getSuccessor(i)) {\n"], "12": ["    for (int i = firstEntryIndex(); i >= 0; i = getSuccessor(i)) {\n"], "13": ["      for (int i = firstEntryIndex(); i >= 0; i = getSuccessor(i)) {\n"], "14": ["    int minimumTableSize = Hashing.closedTableSize(size, LOAD_FACTOR);\n"], "15": ["    init(elementCount);\n"]}, "removed": {"1": ["  private static final int MAXIMUM_CAPACITY = 1 << 30;\n", "\n", "  // TODO(user): decide, and inline, load factor. 0.75?\n", "  static final float DEFAULT_LOAD_FACTOR = 1.0f;\n"], "2": ["  /** The load factor. */\n", "  transient float loadFactor;\n", "\n"], "3": ["  /** When we have this many elements, resize the hashtable. */\n", "  private transient int threshold;\n", "\n", "    init(DEFAULT_SIZE, DEFAULT_LOAD_FACTOR);\n"], "4": ["  CompactHashMap(int capacity) {\n", "    init(capacity, DEFAULT_LOAD_FACTOR);\n", "  }\n", "\n", "  /**\n", "   * Constructs a new instance of {@code CompactHashMap} with the specified capacity and load\n", "   * factor.\n", "   *\n", "   * @param capacity the initial capacity of this {@code CompactHashMap}.\n", "   * @param loadFactor the load factor of this {@code CompactHashMap}.\n", "   */\n", "  CompactHashMap(int capacity, float loadFactor) {\n", "    init(capacity, loadFactor);\n", "  void init(int expectedSize, float loadFactor) {\n", "    Preconditions.checkArgument(loadFactor > 0, \"Illegal load factor\");\n", "    this.loadFactor = loadFactor;\n", "    this.threshold = Math.max(1, expectedSize); // Save expectedSize for use in allocArrays()\n"], "5": ["    int expectedSize = threshold;\n", "    int buckets = Hashing.closedTableSize(expectedSize, loadFactor);\n", "\n", "    this.entries = newEntries(expectedSize);\n", "    this.threshold = Math.max(1, (int) (buckets * loadFactor));\n"], "6": ["    if (next == UNSET) {\n"], "7": ["    if (newEntryIndex >= threshold) {\n", "      resizeTable(2 * table.length);\n"], "8": ["    int[] oldTable = table;\n", "    int oldCapacity = oldTable.length;\n", "    if (oldCapacity >= MAXIMUM_CAPACITY) {\n", "      threshold = Integer.MAX_VALUE;\n", "      return;\n", "    }\n", "    int newThreshold = 1 + (int) (newCapacity * loadFactor);\n"], "9": ["    this.threshold = newThreshold;\n"], "10": ["      if (getHash(entries[next]) == hash) {\n", "        if (Objects.equal(key, keys[next])) {\n", "          @SuppressWarnings(\"unchecked\") // values only contains Vs\n", "          @Nullable\n", "          V oldValue = (V) values[next];\n", "\n", "          if (last == UNSET) {\n", "            // we need to update the root link from table[]\n", "            table[tableIndex] = getNext(entries[next]);\n", "          } else {\n", "            // we need to update the link from the chain\n", "            entries[last] = swapNext(entries[last], getNext(entries[next]));\n", "          }\n", "\n", "          moveLastEntry(next);\n", "          size--;\n", "          modCount++;\n", "          return oldValue;\n"], "11": ["      for (int i = 0; i < size; i++) {\n"], "12": ["    for (int i = 0; i < size; i++) {\n"], "13": ["      for (int i = 0; i < size; i++) {\n"], "14": ["    // size / loadFactor gives the table size of the appropriate load factor,\n", "    // but that may not be a power of two. We floor it to a power of two by\n", "    // keeping its highest bit. But the smaller table may have a load factor\n", "    // larger than what we want; then we want to go to the next power of 2 if we can\n", "    int minimumTableSize = Math.max(1, Integer.highestOneBit((int) (size / loadFactor)));\n", "    if (minimumTableSize < MAXIMUM_CAPACITY) {\n", "      double load = (double) size / minimumTableSize;\n", "      if (load > loadFactor) {\n", "        minimumTableSize <<= 1; // increase to next power if possible\n", "      }\n", "    }\n", "\n"], "15": ["    init(elementCount, DEFAULT_LOAD_FACTOR);\n"]}, "added_lines": {"1": [104], "3": [160], "4": [168, 169, 173, 175], "5": [187, 188, 191], "6": [248], "7": [276, 277, 278], "10": [386, 387, 388, 389, 390, 391, 392, 393, 394, 395, 396, 398, 399, 400, 401, 402], "11": [586], "12": [605], "13": [763], "14": [818], "15": [857]}, "removed_lines": {"1": [104, 105, 106, 107], "2": [151, 152, 153], "3": [161, 162, 163, 169], "4": [177, 178, 179, 180, 181, 182, 183, 184, 185, 186, 187, 188, 189, 193, 195, 196, 197], "5": [209, 210, 215, 216, 217], "6": [272], "7": [300, 301], "8": [347, 348, 349, 350, 351, 352, 353], "9": [367], "10": [417, 418, 419, 420, 421, 422, 423, 424, 425, 426, 427, 428, 429, 430, 431, 432, 433, 434], "11": [619], "12": [638], "13": [796], "14": [851, 852, 853, 854, 855, 856, 857, 858, 859, 860, 861, 862], "15": [901]}}, {"5": "guava/src/com/google/common/collect/CompactHashSet.java", "added": {"1": ["    return new CompactHashSet<>();\n"], "2": ["    return new CompactHashSet<>(expectedSize);\n", "  private static final float LOAD_FACTOR = 1.0f;\n"], "3": ["  // used to indicate blank table entries\n", "   * The hashtable. Its values are indexes to the elements and entries arrays.\n"], "4": ["  /**\n", "   * The elements contained in the set, in the range of [0, size()). The elements in [size(),\n", "   * elements.length) are all {@code null}.\n", "   */\n"], "5": ["    init(DEFAULT_SIZE);\n"], "6": ["    init(expectedSize);\n", "  void init(int expectedSize) {\n", "    this.modCount = Math.max(1, expectedSize); // Save expectedSize for use in allocArrays()\n"], "7": ["    int expectedSize = modCount;\n", "    int buckets = Hashing.closedTableSize(expectedSize, LOAD_FACTOR);\n", "    this.elements = new Object[expectedSize];\n"], "8": ["  private int hashTableMask() {\n", "    return table.length - 1;\n", "  }\n", "\n"], "10": ["    int oldCapacity = table.length;\n", "    if (Hashing.needsResizing(newEntryIndex, oldCapacity, LOAD_FACTOR)) {\n", "      resizeTable(2 * oldCapacity);\n"], "11": ["    int oldCapacity = entries.length;\n", "    if (newCapacity > oldCapacity) {\n", "      Arrays.fill(entries, oldCapacity, newCapacity, UNSET);\n"], "13": ["        moveLastEntry(next);\n"], "14": ["  void moveLastEntry(int dstIndex) {\n"], "15": ["      int currentIndex = firstEntryIndex();\n", "        return currentIndex >= 0;\n"], "16": ["        indexToRemove = currentIndex;\n", "        E result = (E) elements[currentIndex];\n", "        currentIndex = getSuccessor(currentIndex);\n"], "17": ["        currentIndex = adjustAfterRemove(currentIndex, indexToRemove);\n"], "18": ["    for (int i = firstEntryIndex(); i >= 0; i = getSuccessor(i)) {\n"], "19": ["    int minimumTableSize = Hashing.closedTableSize(size, LOAD_FACTOR);\n"], "20": ["    init(elementCount);\n"]}, "removed": {"1": ["    return new CompactHashSet<E>();\n"], "2": ["    return new CompactHashSet<E>(expectedSize);\n", "  private static final int MAXIMUM_CAPACITY = 1 << 30;\n", "\n", "  // TODO(user): decide, and inline, load factor. 0.75?\n", "  private static final float DEFAULT_LOAD_FACTOR = 1.0f;\n"], "3": ["   * The hashtable. Its values are indexes to both the elements and entries arrays.\n"], "4": ["  /** The elements contained in the set, in the range of [0, size()). */\n", "  /** The load factor. */\n", "  transient float loadFactor;\n", "\n"], "5": ["  /** When we have this many elements, resize the hashtable. */\n", "  private transient int threshold;\n", "\n", "    init(DEFAULT_SIZE, DEFAULT_LOAD_FACTOR);\n"], "6": ["    init(expectedSize, DEFAULT_LOAD_FACTOR);\n", "  void init(int expectedSize, float loadFactor) {\n", "    Preconditions.checkArgument(loadFactor > 0, \"Illegal load factor\");\n", "    this.loadFactor = loadFactor;\n", "    this.threshold = Math.max(1, expectedSize); // Save expectedSize for use in allocArrays()\n"], "7": ["    int expectedSize = threshold;\n", "    int buckets = Hashing.closedTableSize(expectedSize, loadFactor);\n", "    this.elements = new Object[expectedSize];\n", "\n", "    this.threshold = Math.max(1, (int) (buckets * loadFactor));\n"], "9": ["  private int hashTableMask() {\n", "    return table.length - 1;\n", "  }\n", "\n"], "10": ["    if (newEntryIndex >= threshold) {\n", "      resizeTable(2 * table.length);\n"], "11": ["    int oldSize = entries.length;\n", "    if (newCapacity > oldSize) {\n", "      Arrays.fill(entries, oldSize, newCapacity, UNSET);\n", "    int[] oldTable = table;\n", "    int oldCapacity = oldTable.length;\n", "    if (oldCapacity >= MAXIMUM_CAPACITY) {\n", "      threshold = Integer.MAX_VALUE;\n", "      return;\n", "    }\n", "    int newThreshold = 1 + (int) (newCapacity * loadFactor);\n"], "12": ["    this.threshold = newThreshold;\n"], "13": ["        moveEntry(next);\n"], "14": ["  void moveEntry(int dstIndex) {\n"], "15": ["      int index = firstEntryIndex();\n", "        return index >= 0;\n"], "16": ["        indexToRemove = index;\n", "        E result = (E) elements[index];\n", "        index = getSuccessor(index);\n"], "17": ["        index = adjustAfterRemove(index, indexToRemove);\n"], "18": ["    for (int i = 0; i < size; i++) {\n"], "19": ["    // size / loadFactor gives the table size of the appropriate load factor,\n", "    // but that may not be a power of two. We floor it to a power of two by\n", "    // keeping its highest bit. But the smaller table may have a load factor\n", "    // larger than what we want; then we want to go to the next power of 2 if we can\n", "    int minimumTableSize = Math.max(1, Integer.highestOneBit((int) (size / loadFactor)));\n", "    if (minimumTableSize < MAXIMUM_CAPACITY) {\n", "      double load = (double) size / minimumTableSize;\n", "      if (load > loadFactor) {\n", "        minimumTableSize <<= 1; // increase to next power if possible\n", "      }\n", "    }\n", "\n"], "20": ["    init(elementCount, DEFAULT_LOAD_FACTOR);\n"]}, "added_lines": {"1": [78], "2": [117, 120], "3": [131, 135], "4": [152, 153, 154, 155], "5": [170], "6": [179, 183, 185], "7": [197, 198, 202], "8": [217, 218, 219, 220], "10": [270, 271, 272], "11": [307, 309, 310], "13": [376], "14": [390], "15": [447, 452], "16": [462, 463, 464], "17": [474], "18": [497], "19": [544], "20": [581]}, "removed_lines": {"1": [78], "2": [117, 120, 121, 122, 123], "3": [137], "4": [154, 157, 158, 159], "5": [167, 168, 169, 175], "6": [184, 188, 190, 191, 192], "7": [204, 205, 208, 209, 211], "9": [240, 241, 242, 243], "10": [278, 279], "11": [314, 316, 317, 323, 324, 325, 326, 327, 328, 329], "12": [343], "13": [391], "14": [405], "15": [462, 467], "16": [477, 478, 479], "17": [489], "18": [512], "19": [559, 560, 561, 562, 563, 564, 565, 566, 567, 568, 569, 570], "20": [607]}}, {"6": "guava/src/com/google/common/collect/CompactLinkedHashMap.java", "added": {"1": ["package com.google.common.collect;\n"], "3": ["   * <i>should</i> hold {@code expectedSize} elements without rebuilding internal data structures.\n"], "4": ["    this(expectedSize, false);\n", "  CompactLinkedHashMap(int expectedSize, boolean accessOrder) {\n", "    super(expectedSize);\n", "  void init(int expectedSize) {\n", "    super.init(expectedSize);\n", "    this.firstEntry = ENDPOINT;\n", "    this.lastEntry = ENDPOINT;\n", "    this.links = new long[expectedSize];\n"], "5": ["    super.moveLastEntry(dstIndex);\n", "\n"]}, "removed": {"1": ["package com.google.common.collect;\n", "import static com.google.common.base.Preconditions.checkNotNull;\n"], "2": ["import java.util.function.BiConsumer;\n", "import java.util.function.Consumer;\n"], "3": ["   * <i>should</i> hold {@code expectedSize} elements without growth.\n"], "4": ["    this(expectedSize, DEFAULT_LOAD_FACTOR, false);\n", "  CompactLinkedHashMap(int expectedSize, float loadFactor, boolean accessOrder) {\n", "    super(expectedSize, loadFactor);\n", "  void init(int expectedSize, float loadFactor) {\n", "    super.init(expectedSize, loadFactor);\n", "    firstEntry = ENDPOINT;\n", "    lastEntry = ENDPOINT;\n", "    links = new long[expectedSize];\n"], "5": ["    super.moveLastEntry(dstIndex);\n"], "6": ["  @Override\n", "  public void forEach(BiConsumer<? super K, ? super V> action) {\n", "    checkNotNull(action);\n", "    for (int i = firstEntry; i != ENDPOINT; i = getSuccessor(i)) {\n", "      action.accept((K) keys[i], (V) values[i]);\n", "    }\n", "  }\n", "\n"], "7": ["\n", "      @Override\n", "      public void forEach(Consumer<? super K> action) {\n", "        checkNotNull(action);\n", "        for (int i = firstEntry; i != ENDPOINT; i = getSuccessor(i)) {\n", "          action.accept((K) keys[i]);\n", "        }\n", "      }\n"], "8": ["\n", "      @Override\n", "      public void forEach(Consumer<? super V> action) {\n", "        checkNotNull(action);\n", "        for (int i = firstEntry; i != ENDPOINT; i = getSuccessor(i)) {\n", "          action.accept((V) values[i]);\n", "        }\n", "      }\n"]}, "added_lines": {"1": [17], "3": [60], "4": [97, 100, 101, 106, 107, 108, 109, 116], "5": [175, 176]}, "removed_lines": {"1": [16, 18], "2": [28, 29], "3": [63], "4": [100, 103, 104, 109, 110, 111, 112, 119], "5": [183], "6": [206, 207, 208, 209, 210, 211, 212, 213], "7": [244, 245, 246, 247, 248, 249, 250, 251], "8": [274, 275, 276, 277, 278, 279, 280, 281]}}, {"7": "guava/src/com/google/common/collect/CompactLinkedHashSet.java", "added": {"2": ["    return new CompactLinkedHashSet<>();\n"], "3": ["    return new CompactLinkedHashSet<>(expectedSize);\n"], "4": ["  /** Pointer to the first node in the linked list, or {@code ENDPOINT} if there are no entries. */\n", "\n", "  /** Pointer to the last node in the linked list, or {@code ENDPOINT} if there are no entries. */\n"], "5": ["  void init(int expectedSize) {\n", "    super.init(expectedSize);\n", "    this.firstEntry = ENDPOINT;\n", "    this.lastEntry = ENDPOINT;\n"], "6": ["  private int getPredecessor(int entry) {\n", "    return predecessor[entry];\n", "  }\n", "\n", "  @Override\n", "  int getSuccessor(int entry) {\n", "    return successor[entry];\n", "  }\n", "\n", "  private void setSuccessor(int entry, int succ) {\n", "    successor[entry] = succ;\n", "  }\n", "\n", "  private void setPredecessor(int entry, int pred) {\n", "    predecessor[entry] = pred;\n", "  }\n", "\n", "  private void setSucceeds(int pred, int succ) {\n", "      setSuccessor(pred, succ);\n", "      setPredecessor(succ, pred);\n", "    setSucceeds(lastEntry, entryIndex);\n", "    setSucceeds(entryIndex, ENDPOINT);\n", "  void moveLastEntry(int dstIndex) {\n", "    super.moveLastEntry(dstIndex);\n", "    setSucceeds(getPredecessor(dstIndex), getSuccessor(dstIndex));\n", "    if (dstIndex < srcIndex) {\n", "      setSucceeds(getPredecessor(srcIndex), dstIndex);\n", "      setSucceeds(dstIndex, getSuccessor(srcIndex));\n"], "8": ["    return (indexBeforeRemove >= size()) ? indexRemoved : indexBeforeRemove;\n", "  public Object[] toArray() {\n", "    return ObjectArrays.toArrayImpl(this);\n", "  }\n", "\n", "  @Override\n", "  public <T> T[] toArray(T[] a) {\n", "    return ObjectArrays.toArrayImpl(this, a);\n"], "9": ["  public void clear() {\n", "    if (needsAllocArrays()) {\n", "      return;\n", "    this.firstEntry = ENDPOINT;\n", "    this.lastEntry = ENDPOINT;\n", "    Arrays.fill(predecessor, 0, size(), UNSET);\n", "    Arrays.fill(successor, 0, size(), UNSET);\n", "    super.clear();\n"]}, "removed": {"1": ["import static com.google.common.base.Preconditions.checkNotNull;\n", "\n", "import java.util.function.Consumer;\n"], "2": ["    return new CompactLinkedHashSet<E>();\n"], "3": ["    return new CompactLinkedHashSet<E>(expectedSize);\n"], "5": ["  void init(int expectedSize, float loadFactor) {\n", "    super.init(expectedSize, loadFactor);\n", "    firstEntry = ENDPOINT;\n", "    lastEntry = ENDPOINT;\n"], "6": ["  private void succeeds(int pred, int succ) {\n", "      successor[pred] = succ;\n", "      predecessor[succ] = pred;\n", "    succeeds(lastEntry, entryIndex);\n", "    succeeds(entryIndex, ENDPOINT);\n", "  void moveEntry(int dstIndex) {\n", "    super.moveEntry(dstIndex);\n", "    succeeds(predecessor[dstIndex], successor[dstIndex]);\n", "    if (srcIndex != dstIndex) {\n", "      succeeds(predecessor[srcIndex], dstIndex);\n", "      succeeds(dstIndex, successor[srcIndex]);\n", "  @Override\n", "  public void clear() {\n", "    if (needsAllocArrays()) {\n", "      return;\n", "    }\n", "    firstEntry = ENDPOINT;\n", "    lastEntry = ENDPOINT;\n", "    Arrays.fill(predecessor, 0, size(), UNSET);\n", "    Arrays.fill(successor, 0, size(), UNSET);\n", "    super.clear();\n", "  }\n", "\n"], "7": ["  @Override\n", "  public Object[] toArray() {\n", "    return ObjectArrays.toArrayImpl(this);\n", "  }\n", "\n", "  @Override\n", "  public <T> T[] toArray(T[] a) {\n", "    return ObjectArrays.toArrayImpl(this, a);\n", "  }\n", "\n"], "8": ["    return (indexBeforeRemove == size()) ? indexRemoved : indexBeforeRemove;\n", "  int getSuccessor(int entryIndex) {\n", "    return successor[entryIndex];\n"], "9": ["  public void forEach(Consumer<? super E> action) {\n", "    checkNotNull(action);\n", "    for (int i = firstEntry; i != ENDPOINT; i = successor[i]) {\n", "      action.accept((E) elements[i]);\n"]}, "added_lines": {"2": [53], "3": [92], "4": [113, 115, 116], "5": [128, 129, 130, 131], "6": [144, 145, 146, 147, 148, 149, 150, 151, 152, 153, 154, 155, 156, 157, 158, 159, 160, 161, 165, 171, 178, 179, 183, 185, 187, 188, 189, 190], "8": [215, 219, 220, 221, 222, 223, 224, 225], "9": [234, 235, 236, 238, 239, 240, 241, 242]}, "removed_lines": {"1": [19, 20, 27], "2": [56], "3": [95], "5": [128, 129, 130, 131], "6": [145, 149, 155, 162, 163, 167, 169, 171, 172, 173, 174, 180, 181, 182, 183, 184, 185, 186, 187, 188, 189, 190, 191], "7": [205, 206, 207, 208, 209, 210, 211, 212, 213, 214], "8": [222, 226, 227], "9": [236, 237, 238, 239]}}]}
