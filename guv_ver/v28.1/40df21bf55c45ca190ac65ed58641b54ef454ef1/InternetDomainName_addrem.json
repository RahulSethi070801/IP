{
    "addition": {
        "26": "import com.google.common.base.Optional;\n",
        "30": "import com.google.thirdparty.publicsuffix.PublicSuffixType;\n",
        "35": " * An immutable well-formed internet domain name, such as {@code com} or {@code foo.co.uk}. Only\n",
        "36": " * syntactic analysis is performed; no DNS lookups or other network interactions take place. Thus\n",
        "37": " * there is no guarantee that the domain actually exists on the internet.\n",
        "45": " * Using the subset of public suffixes that are {@linkplain #isRegistrySuffix() registry suffixes},\n",
        "46": " * one can get a better result, as only a few registry suffixes are addressable. However, the most\n",
        "47": " * useful test to determine if a domain is a plausible web host is {@link #hasPublicSuffix()}. This\n",
        "48": " * will return {@code true} for many domains which (currently) are not hosts, such as {@code \"com\"},\n",
        "49": " * but given that any public suffix may become a host without warning, it is better to err on the\n",
        "50": " * side of permissiveness and thus avoid spurious rejection of valid sites. Of course, to actually\n",
        "51": " * determine addressability of any host, clients of this class will need to perform their own DNS\n",
        "52": " * lookups.\n",
        "57": " *   <li>ASCII uppercase characters are converted to lowercase.\n",
        "58": " *   <li>Unicode dot separators other than the ASCII period ({@code '.'}) are converted to the ASCII\n",
        "59": " *       period.\n",
        "66": " * names</a> such as {@code \u7f51\u7edc.cn} are supported, as are the equivalent <a\n",
        "67": " * href=\"http://en.wikipedia.org/wiki/Internationalized_domain_name\">IDNA Punycode-encoded</a>\n",
        "82": "   * Value of {@link #publicSuffixIndex} or {@link #registrySuffixIndex} which indicates that no\n",
        "83": "   * relevant suffix was found.\n",
        "85": "  private static final int NO_SUFFIX_FOUND = -1;\n",
        "121": "   * domain name {@code myblog.blogspot.co.uk}, the value would be 1 (the index of the {@code\n",
        "122": "   * blogspot} part). The value is negative (specifically, {@link #NO_SUFFIX_FOUND}) if no public\n",
        "123": "   * suffix was found.\n",
        "127": "  /**\n",
        "128": "   * The index in the {@link #parts()} list at which the registry suffix begins. For example, for\n",
        "129": "   * the domain name {@code myblog.blogspot.co.uk}, the value would be 2 (the index of the {@code\n",
        "130": "   * co} part). The value is negative (specifically, {@link #NO_SUFFIX_FOUND}) if no registry suffix\n",
        "131": "   * was found.\n",
        "132": "   */\n",
        "133": "  private final int registrySuffixIndex;\n",
        "134": "\n",
        "157": "    this.publicSuffixIndex = findSuffixOfType(Optional.<PublicSuffixType>absent());\n",
        "158": "    this.registrySuffixIndex = findSuffixOfType(Optional.of(PublicSuffixType.REGISTRY));\n",
        "162": "   * Returns the index of the leftmost part of the suffix, or -1 if not found. Note that the value\n",
        "163": "   * defined as a suffix may not produce {@code true} results from {@link #isPublicSuffix()} or\n",
        "164": "   * {@link #isRegistrySuffix()} if the domain ends with an excluded domain pattern such as {@code\n",
        "165": "   * \"nhs.uk\"}.\n",
        "166": "   *\n",
        "167": "   * <p>If a {@code desiredType} is specified, this method only finds suffixes of the given type.\n",
        "168": "   * Otherwise, it finds the first suffix of any type.\n",
        "170": "  private int findSuffixOfType(Optional<PublicSuffixType> desiredType) {\n",
        "176": "      if (matchesType(\n",
        "177": "          desiredType, Optional.fromNullable(PublicSuffixPatterns.EXACT.get(ancestorName)))) {\n",
        "188": "      if (matchesWildcardSuffixType(desiredType, ancestorName)) {\n",
        "193": "    return NO_SUFFIX_FOUND;\n",
        "199": "   * (\"Internationalizing Domain Names in Applications\") is skipped, while validation against <a\n",
        "200": "   * href=\"http://www.ietf.org/rfc/rfc1035.txt\">RFC 1035</a> is relaxed in the following ways:\n",
        "201": "   *\n",
        "203": "   *   <li>Any part containing non-ASCII characters is considered valid.\n",
        "204": "   *   <li>Underscores ('_') are permitted wherever dashes ('-') are permitted.\n",
        "205": "   *   <li>Parts other than the final part may start with a digit, as mandated by <a\n",
        "206": "   *       href=\"https://tools.ietf.org/html/rfc1123#section-2\">RFC 1123</a>.\n",
        "211": "   * @throws IllegalArgumentException if {@code name} is not syntactically valid according to {@link\n",
        "212": "   *     #isValid}\n",
        "315": "   * is one under which Internet users can directly register names, such as {@code com}, {@code\n",
        "316": "   * co.uk} or {@code pvt.k12.wy.us}. Examples of domain names that are <i>not</i> public suffixes\n",
        "317": "   * include {@code google.com}, {@code foo.co.uk}, and {@code myblog.blogspot.com}.\n",
        "318": "   *\n",
        "319": "   * <p>Public suffixes are a proper superset of {@linkplain #isRegistrySuffix() registry suffixes}.\n",
        "320": "   * The list of public suffixes additionally contains privately owned domain names under which\n",
        "321": "   * Internet users can register subdomains. An example of a public suffix that is not a registry\n",
        "322": "   * suffix is {@code blogspot.com}. Note that it is true that all public suffixes <i>have</i>\n",
        "323": "   * registry suffixes, since domain name registries collectively control all internet domain names.\n",
        "324": "   *\n",
        "325": "   * <p>For considerations on whether the public suffix or registry suffix designation is more\n",
        "326": "   * suitable for your application, see <a\n",
        "327": "   * href=\"https://github.com/google/guava/wiki/InternetDomainNameExplained\">this article</a>.\n",
        "338": "   * including if it is a public suffix itself. For example, returns {@code true} for {@code\n",
        "339": "   * www.google.com}, {@code foo.co.uk} and {@code com}, but not for {@code invalid} or {@code\n",
        "340": "   * google.invalid}. This is the recommended method for determining whether a domain is potentially\n",
        "341": "   * an addressable host.\n",
        "342": "   *\n",
        "343": "   * <p>Note that this method is equivalent to {@link #hasRegistrySuffix()} because all registry\n",
        "344": "   * suffixes are public suffixes <i>and</i> all public suffixes have registry suffixes.\n",
        "349": "    return publicSuffixIndex != NO_SUFFIX_FOUND;\n",
        "364": "   * while not being a public suffix itself. For example, returns {@code true} for {@code\n",
        "365": "   * www.google.com}, {@code foo.co.uk} and {@code myblog.blogspot.com}, but not for {@code com},\n",
        "366": "   * {@code co.uk}, {@code google.invalid}, or {@code blogspot.com}.\n",
        "380": "   * {@linkplain #isPublicSuffix() public suffix}. For example, returns {@code true} for {@code\n",
        "381": "   * google.com} {@code foo.co.uk}, and {@code myblog.blogspot.com}, but not for {@code\n",
        "382": "   * www.google.com}, {@code co.uk}, or {@code blogspot.com}.\n",
        "395": "   * Returns the portion of this domain name that is one level beneath the {@linkplain\n",
        "396": "   * #isPublicSuffix() public suffix}. For example, for {@code x.adwords.google.co.uk} it returns\n",
        "397": "   * {@code google.co.uk}, since {@code co.uk} is a public suffix. Similarly, for {@code\n",
        "398": "   * myblog.blogspot.com} it returns the same domain, {@code myblog.blogspot.com}, since {@code\n",
        "399": "   * blogspot.com} is a public suffix.\n",
        "418": "  /**\n",
        "419": "   * Indicates whether this domain name represents a <i>registry suffix</i>, as defined by a subset\n",
        "420": "   * of the Mozilla Foundation's <a href=\"http://publicsuffix.org/\">Public Suffix List</a> (PSL). A\n",
        "421": "   * registry suffix is one under which Internet users can directly register names via a domain name\n",
        "422": "   * registrar, and have such registrations lawfully protected by internet-governing bodies such as\n",
        "423": "   * ICANN. Examples of registry suffixes include {@code com}, {@code co.uk}, and {@code\n",
        "424": "   * pvt.k12.wy.us}. Examples of domain names that are <i>not</i> registry suffixes include {@code\n",
        "425": "   * google.com} and {@code foo.co.uk}.\n",
        "426": "   *\n",
        "427": "   * <p>Registry suffixes are a proper subset of {@linkplain #isPublicSuffix() public suffixes}. The\n",
        "428": "   * list of public suffixes additionally contains privately owned domain names under which Internet\n",
        "429": "   * users can register subdomains. An example of a public suffix that is not a registry suffix is\n",
        "430": "   * {@code blogspot.com}. Note that it is true that all public suffixes <i>have</i> registry\n",
        "431": "   * suffixes, since domain name registries collectively control all internet domain names.\n",
        "432": "   *\n",
        "433": "   * <p>For considerations on whether the public suffix or registry suffix designation is more\n",
        "434": "   * suitable for your application, see <a\n",
        "435": "   * href=\"https://github.com/google/guava/wiki/InternetDomainNameExplained\">this article</a>.\n",
        "436": "   *\n",
        "437": "   * @return {@code true} if this domain name appears exactly on the public suffix list as part of\n",
        "438": "   *     the registry suffix section (labelled \"ICANN\").\n",
        "439": "   * @since NEXT\n",
        "440": "   */\n",
        "441": "  public boolean isRegistrySuffix() {\n",
        "442": "    return registrySuffixIndex == 0;\n",
        "443": "  }\n",
        "444": "\n",
        "445": "  /**\n",
        "446": "   * Indicates whether this domain name ends in a {@linkplain #isRegistrySuffix() registry suffix},\n",
        "447": "   * including if it is a registry suffix itself. For example, returns {@code true} for {@code\n",
        "448": "   * www.google.com}, {@code foo.co.uk} and {@code com}, but not for {@code invalid} or {@code\n",
        "449": "   * google.invalid}.\n",
        "450": "   *\n",
        "451": "   * <p>Note that this method is equivalent to {@link #hasPublicSuffix()} because all registry\n",
        "452": "   * suffixes are public suffixes <i>and</i> all public suffixes have registry suffixes.\n",
        "453": "   *\n",
        "454": "   * @since NEXT\n",
        "455": "   */\n",
        "456": "  public boolean hasRegistrySuffix() {\n",
        "457": "    return registrySuffixIndex != NO_SUFFIX_FOUND;\n",
        "458": "  }\n",
        "459": "\n",
        "460": "  /**\n",
        "461": "   * Returns the {@linkplain #isRegistrySuffix() registry suffix} portion of the domain name, or\n",
        "462": "   * {@code null} if no registry suffix is present.\n",
        "463": "   *\n",
        "464": "   * @since NEXT\n",
        "465": "   */\n",
        "466": "  public InternetDomainName registrySuffix() {\n",
        "467": "    return hasRegistrySuffix() ? ancestor(registrySuffixIndex) : null;\n",
        "468": "  }\n",
        "469": "\n",
        "470": "  /**\n",
        "471": "   * Indicates whether this domain name ends in a {@linkplain #isRegistrySuffix() registry suffix},\n",
        "472": "   * while not being a registry suffix itself. For example, returns {@code true} for {@code\n",
        "473": "   * www.google.com}, {@code foo.co.uk} and {@code blogspot.com}, but not for {@code com}, {@code\n",
        "474": "   * co.uk}, or {@code google.invalid}.\n",
        "475": "   *\n",
        "476": "   * @since NEXT\n",
        "477": "   */\n",
        "478": "  public boolean isUnderRegistrySuffix() {\n",
        "479": "    return registrySuffixIndex > 0;\n",
        "480": "  }\n",
        "481": "\n",
        "482": "  /**\n",
        "483": "   * Indicates whether this domain name is composed of exactly one subdomain component followed by a\n",
        "484": "   * {@linkplain #isRegistrySuffix() registry suffix}. For example, returns {@code true} for {@code\n",
        "485": "   * google.com}, {@code foo.co.uk}, and {@code blogspot.com}, but not for {@code www.google.com},\n",
        "486": "   * {@code co.uk}, or {@code myblog.blogspot.com}.\n",
        "487": "   *\n",
        "488": "   * <p><b>Warning:</b> This method should not be used to determine the probable highest level\n",
        "489": "   * parent domain for which cookies may be set. Use {@link #topPrivateDomain()} for that purpose.\n",
        "490": "   *\n",
        "491": "   * @since NEXT\n",
        "492": "   */\n",
        "493": "  public boolean isTopDomainUnderRegistrySuffix() {\n",
        "494": "    return registrySuffixIndex == 1;\n",
        "495": "  }\n",
        "496": "\n",
        "497": "  /**\n",
        "498": "   * Returns the portion of this domain name that is one level beneath the {@linkplain\n",
        "499": "   * #isRegistrySuffix() registry suffix}. For example, for {@code x.adwords.google.co.uk} it\n",
        "500": "   * returns {@code google.co.uk}, since {@code co.uk} is a registry suffix. Similarly, for {@code\n",
        "501": "   * myblog.blogspot.com} it returns {@code blogspot.com}, since {@code com} is a registry suffix.\n",
        "502": "   *\n",
        "503": "   * <p>If {@link #isTopDomainUnderRegistrySuffix()} is true, the current domain name instance is\n",
        "504": "   * returned.\n",
        "505": "   *\n",
        "506": "   * <p><b>Warning:</b> This method should not be used to determine whether a domain is probably the\n",
        "507": "   * highest level for which cookies may be set. Use {@link #isTopPrivateDomain()} for that purpose.\n",
        "508": "   *\n",
        "509": "   * @throws IllegalStateException if this domain does not end with a registry suffix\n",
        "510": "   * @since NEXT\n",
        "511": "   */\n",
        "512": "  public InternetDomainName topDomainUnderRegistrySuffix() {\n",
        "513": "    if (isTopDomainUnderRegistrySuffix()) {\n",
        "514": "      return this;\n",
        "515": "    }\n",
        "516": "    checkState(isUnderRegistrySuffix(), \"Not under a registry suffix: %s\", name);\n",
        "517": "    return ancestor(registrySuffixIndex - 1);\n",
        "518": "  }\n",
        "519": "\n",
        "595": "   * Does the domain name match one of the \"wildcard\" patterns (e.g. {@code \"*.ar\"})? If a {@code\n",
        "596": "   * desiredType} is specified, the wildcard pattern must also match that type.\n",
        "598": "  private static boolean matchesWildcardSuffixType(\n",
        "599": "      Optional<PublicSuffixType> desiredType, String domain) {\n",
        "601": "    return pieces.length == 2\n",
        "602": "        && matchesType(\n",
        "603": "            desiredType, Optional.fromNullable(PublicSuffixPatterns.UNDER.get(pieces[1])));\n",
        "604": "  }\n",
        "605": "\n",
        "606": "  /**\n",
        "607": "   * If a {@code desiredType} is specified, returns true only if the {@code actualType} is\n",
        "608": "   * identical. Otherwise, returns true as long as {@code actualType} is present.\n",
        "609": "   */\n",
        "610": "  private static boolean matchesType(\n",
        "611": "      Optional<PublicSuffixType> desiredType, Optional<PublicSuffixType> actualType) {\n",
        "612": "    return desiredType.isPresent() ? desiredType.equals(actualType) : actualType.isPresent();\n"
    },
    "removed": {
        "33": " * An immutable well-formed internet domain name, such as {@code com} or {@code\n",
        "34": " * foo.co.uk}. Only syntactic analysis is performed; no DNS lookups or other network interactions\n",
        "35": " * take place. Thus there is no guarantee that the domain actually exists on the internet.\n",
        "43": " * As a result, the only useful test to determine if a domain is a plausible web host is\n",
        "44": " * {@link #hasPublicSuffix()}. This will return {@code true} for many domains which (currently) are\n",
        "45": " * not hosts, such as {@code \"com\"}, but given that any public suffix may become a host without\n",
        "46": " * warning, it is better to err on the side of permissiveness and thus avoid spurious rejection of\n",
        "47": " * valid sites.\n",
        "52": " * <li>ASCII uppercase characters are converted to lowercase.\n",
        "53": " * <li>Unicode dot separators other than the ASCII period ({@code '.'}) are converted to the ASCII\n",
        "54": " *     period.\n",
        "61": " * names</a> such as {@code \u7f51\u7edc.cn} are supported, as are the equivalent\n",
        "62": " * <a href=\"http://en.wikipedia.org/wiki/Internationalized_domain_name\">IDNA Punycode-encoded</a>\n",
        "77": "   * Value of {@link #publicSuffixIndex} which indicates that no public suffix was found.\n",
        "79": "  private static final int NO_PUBLIC_SUFFIX_FOUND = -1;\n",
        "115": "   * domain name {@code www.google.co.uk}, the value would be 2 (the index of the {@code co} part).\n",
        "116": "   * The value is negative (specifically, {@link #NO_PUBLIC_SUFFIX_FOUND}) if no public suffix was\n",
        "117": "   * found.\n",
        "143": "    this.publicSuffixIndex = findPublicSuffix();\n",
        "147": "   * Returns the index of the leftmost part of the public suffix, or -1 if not found. Note that the\n",
        "148": "   * value defined as the \"public suffix\" may not be a public suffix according to\n",
        "149": "   * {@link #isPublicSuffix()} if the domain ends with an excluded domain pattern such as\n",
        "150": "   * {@code \"nhs.uk\"}.\n",
        "152": "  private int findPublicSuffix() {\n",
        "158": "      if (PublicSuffixPatterns.EXACT.containsKey(ancestorName)) {\n",
        "169": "      if (matchesWildcardPublicSuffix(ancestorName)) {\n",
        "174": "    return NO_PUBLIC_SUFFIX_FOUND;\n",
        "180": "   * (\"Internationalizing Domain Names in Applications\") is skipped, while validation against\n",
        "181": "   * <a href=\"http://www.ietf.org/rfc/rfc1035.txt\">RFC 1035</a> is relaxed in the following ways:\n",
        "183": "   * <li>Any part containing non-ASCII characters is considered valid.\n",
        "184": "   * <li>Underscores ('_') are permitted wherever dashes ('-') are permitted.\n",
        "185": "   * <li>Parts other than the final part may start with a digit, as mandated by\n",
        "186": "   * <a href=\"https://tools.ietf.org/html/rfc1123#section-2\">RFC 1123</a>.\n",
        "191": "   * @throws IllegalArgumentException if {@code name} is not syntactically valid according to\n",
        "192": "   *     {@link #isValid}\n",
        "295": "   * is one under which Internet users can directly register names, such as {@code com},\n",
        "296": "   * {@code co.uk} or {@code pvt.k12.wy.us}. Examples of domain names that are <i>not</i> public\n",
        "297": "   * suffixes include {@code google}, {@code google.com} and {@code foo.co.uk}.\n",
        "308": "   * including if it is a public suffix itself. For example, returns {@code true} for\n",
        "309": "   * {@code www.google.com}, {@code foo.co.uk} and {@code com}, but not for {@code invalid} or\n",
        "310": "   * {@code google.invalid}. This is the recommended method for determining whether a domain is\n",
        "311": "   * potentially an addressable host.\n",
        "316": "    return publicSuffixIndex != NO_PUBLIC_SUFFIX_FOUND;\n",
        "331": "   * while not being a public suffix itself. For example, returns {@code true} for\n",
        "332": "   * {@code www.google.com}, {@code foo.co.uk} and {@code bar.ca.us}, but not for {@code google},\n",
        "333": "   * {@code com}, or {@code\n",
        "334": "   * google.foo}.\n",
        "335": "   *\n",
        "336": "   * <p><b>Warning:</b> a {@code false} result from this method does not imply that the domain does\n",
        "337": "   * not represent an addressable host, as many public suffixes are also addressable hosts. Use\n",
        "338": "   * {@link #hasPublicSuffix()} for that test.\n",
        "352": "   * {@linkplain #isPublicSuffix() public suffix}. For example, returns {@code true} for\n",
        "353": "   * {@code google.com} and {@code foo.co.uk}, but not for {@code www.google.com} or {@code co.uk}.\n",
        "354": "   *\n",
        "355": "   * <p><b>Warning:</b> A {@code true} result from this method does not imply that the domain is at\n",
        "356": "   * the highest level which is addressable as a host, as many public suffixes are also addressable\n",
        "357": "   * hosts. For example, the domain {@code bar.uk.com} has a public suffix of {@code uk.com}, so it\n",
        "358": "   * would return {@code true} from this method. But {@code uk.com} is itself an addressable host.\n",
        "371": "   * Returns the portion of this domain name that is one level beneath the public suffix. For\n",
        "372": "   * example, for {@code x.adwords.google.co.uk} it returns {@code google.co.uk}, since\n",
        "373": "   * {@code co.uk} is a public suffix.\n",
        "377": "   * <p>This method should not be used to determine the topmost parent domain which is addressable\n",
        "378": "   * as a host, as many public suffixes are also addressable hosts. For example, the domain\n",
        "379": "   * {@code foo.bar.uk.com} has a public suffix of {@code uk.com}, so it would return\n",
        "380": "   * {@code bar.uk.com} from this method. But {@code uk.com} is itself an addressable host.\n",
        "381": "   *\n",
        "472": "   * Does the domain name match one of the \"wildcard\" patterns (e.g. {@code \"*.ar\"})?\n",
        "474": "  private static boolean matchesWildcardPublicSuffix(String domain) {\n",
        "476": "    return pieces.length == 2 && PublicSuffixPatterns.UNDER.containsKey(pieces[1]);\n"
    }
}