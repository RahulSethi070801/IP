{"id": "40df21bf55c45ca190ac65ed58641b54ef454ef1", "code": [{"0": "android/guava-tests/test/com/google/common/net/InternetDomainNameTest.java", "added": {"1": ["  private static final ImmutableSet<String> RS =\n", "      ImmutableSet.of(\n", "          \"com\",\n", "          \"co.uk\",\n", "          \"foo.bd\",\n", "          \"xxxxxx.bd\",\n", "          \"org.mK\",\n", "          \"us\",\n", "          \"co.uk.\", // Trailing dot\n", "          \"co\\uFF61uk\", // Alternate dot character\n", "          \"\\u7f51\\u7edc.Cn\", // \"\u7f51\u7edc.Cn\"\n", "          \"j\\u00f8rpeland.no\", // \"jorpeland.no\" (first o slashed)\n", "          \"xn--jrpeland-54a.no\"); // IDNA (punycode) encoding of above\n", "\n", "  private static final ImmutableSet<String> PS_NOT_RS =\n", "      ImmutableSet.of(\"blogspot.com\", \"blogspot.co.uk\", \"uk.com\");\n", "\n", "  private static final ImmutableSet<String> PS =\n", "      ImmutableSet.<String>builder().addAll(RS).addAll(PS_NOT_RS).build();\n", "  /**\n", "   * Having a public suffix is equivalent to having a registry suffix, because all registry suffixes\n", "   * are public suffixes, and all public suffixes have registry suffixes.\n", "   */\n", "  private static final ImmutableSet<String> NO_RS = NO_PS;\n", "  private static final ImmutableSet<String> NON_PS =\n", "      ImmutableSet.of(\n", "          \"foo.bar.com\",\n", "          \"foo.ca\",\n", "          \"foo.bar.ca\",\n", "          \"foo.blogspot.com\",\n", "          \"foo.blogspot.co.uk\",\n", "          \"foo.uk.com\",\n", "          \"foo.bar.co.il\",\n", "          \"state.CA.us\",\n", "          \"www.state.pa.us\",\n", "          \"pvt.k12.ca.us\",\n", "          \"www.google.com\",\n", "          \"www4.yahoo.co.uk\",\n", "          \"home.netscape.com\",\n", "          \"web.MIT.edu\",\n", "          \"foo.eDu.au\",\n", "          \"utenti.blah.IT\",\n", "          \"dominio.com.co\");\n", "\n", "  private static final ImmutableSet<String> NON_RS =\n", "      ImmutableSet.<String>builder().addAll(NON_PS).addAll(PS_NOT_RS).build();\n", "\n", "  private static final ImmutableSet<String> TOP_UNDER_REGISTRY_SUFFIX =\n", "  private static final ImmutableSet<String> TOP_PRIVATE_DOMAIN =\n", "      ImmutableSet.of(\"google.com\", \"foo.Co.uk\", \"foo.ca.us.\", \"foo.blogspot.com\");\n", "\n", "  private static final ImmutableSet<String> UNDER_TOP_UNDER_REGISTRY_SUFFIX =\n", "  private static final ImmutableSet<String> UNDER_PRIVATE_DOMAIN =\n", "      ImmutableSet.of(\"foo.bar.google.com\", \"a.b.co.uk\", \"x.y.ca.us\", \"a.b.blogspot.com\");\n", "\n"], "2": ["  private static final ImmutableSet<String> SOMEWHERE_UNDER_RS =\n", "      ImmutableSet.<String>builder().addAll(SOMEWHERE_UNDER_PS).addAll(PS_NOT_RS).build();\n", "\n"], "3": ["  public void testRegistrySuffix() {\n", "    for (String name : RS) {\n", "      final InternetDomainName domain = InternetDomainName.from(name);\n", "      assertTrue(name, domain.isRegistrySuffix());\n", "      assertTrue(name, domain.hasRegistrySuffix());\n", "      assertFalse(name, domain.isUnderRegistrySuffix());\n", "      assertFalse(name, domain.isTopDomainUnderRegistrySuffix());\n", "      assertEquals(domain, domain.registrySuffix());\n", "    }\n", "\n", "    for (String name : NO_RS) {\n", "      final InternetDomainName domain = InternetDomainName.from(name);\n", "      assertFalse(name, domain.isRegistrySuffix());\n", "      assertFalse(name, domain.hasRegistrySuffix());\n", "      assertFalse(name, domain.isUnderRegistrySuffix());\n", "      assertFalse(name, domain.isTopDomainUnderRegistrySuffix());\n", "      assertNull(domain.registrySuffix());\n", "    }\n", "\n", "    for (String name : NON_RS) {\n", "      final InternetDomainName domain = InternetDomainName.from(name);\n", "      assertFalse(name, domain.isRegistrySuffix());\n", "      assertTrue(name, domain.hasRegistrySuffix());\n", "      assertTrue(name, domain.isUnderRegistrySuffix());\n", "    }\n", "  }\n", "\n", "  public void testUnderRegistrySuffix() {\n", "    for (String name : SOMEWHERE_UNDER_RS) {\n", "      final InternetDomainName domain = InternetDomainName.from(name);\n", "      assertFalse(name, domain.isRegistrySuffix());\n", "      assertTrue(name, domain.hasRegistrySuffix());\n", "      assertTrue(name, domain.isUnderRegistrySuffix());\n", "    }\n", "  }\n", "\n", "  public void testTopDomainUnderRegistrySuffix() {\n", "    for (String name : TOP_UNDER_REGISTRY_SUFFIX) {\n", "      final InternetDomainName domain = InternetDomainName.from(name);\n", "      assertFalse(name, domain.isRegistrySuffix());\n", "      assertTrue(name, domain.hasRegistrySuffix());\n", "      assertTrue(name, domain.isUnderRegistrySuffix());\n", "      assertTrue(name, domain.isTopDomainUnderRegistrySuffix());\n", "      assertEquals(domain.parent(), domain.registrySuffix());\n", "    }\n", "  }\n", "\n", "  public void testUnderTopDomainUnderRegistrySuffix() {\n", "    for (String name : UNDER_TOP_UNDER_REGISTRY_SUFFIX) {\n", "      final InternetDomainName domain = InternetDomainName.from(name);\n", "      assertFalse(name, domain.isRegistrySuffix());\n", "      assertTrue(name, domain.hasRegistrySuffix());\n", "      assertTrue(name, domain.isUnderRegistrySuffix());\n", "      assertFalse(name, domain.isTopDomainUnderRegistrySuffix());\n", "    }\n", "  }\n", "\n"], "4": ["  public void testPublicSuffixExclusion() {\n"], "5": ["  public void testPublicSuffixMultipleUnders() {\n"], "6": ["  public void testRegistrySuffixExclusion() {\n", "    InternetDomainName domain = InternetDomainName.from(\"foo.city.yokohama.jp\");\n", "    assertTrue(domain.hasRegistrySuffix());\n", "    assertEquals(\"yokohama.jp\", domain.registrySuffix().toString());\n", "\n", "    // Behold the weirdness!\n", "    assertFalse(domain.registrySuffix().isRegistrySuffix());\n", "  }\n", "\n", "  public void testRegistrySuffixMultipleUnders() {\n", "    // PSL has both *.uk and *.sch.uk; the latter should win.\n", "    // See http://code.google.com/p/guava-libraries/issues/detail?id=1176\n", "\n", "    InternetDomainName domain = InternetDomainName.from(\"www.essex.sch.uk\");\n", "    assertTrue(domain.hasRegistrySuffix());\n", "    assertEquals(\"essex.sch.uk\", domain.registrySuffix().toString());\n", "    assertEquals(\"www.essex.sch.uk\", domain.topDomainUnderRegistrySuffix().toString());\n", "  }\n", "\n"]}, "removed": {"1": ["  private static final ImmutableSet<String> PS = ImmutableSet.of(\n", "      \"com\",\n", "      \"co.uk\",\n", "      \"foo.bd\",\n", "      \"xxxxxx.bd\",\n", "      \"org.mK\",\n", "      \"us\",\n", "      \"uk\\uFF61com.\",  // Alternate dot character\n", "      \"\\u7f51\\u7edc.Cn\",  // \"\u7f51\u7edc.Cn\"\n", "      \"j\\u00f8rpeland.no\",  // \"jorpeland.no\" (first o slashed)\n", "      \"xn--jrpeland-54a.no\"  // IDNA (punycode) encoding of above\n", "  );\n", "  private static final ImmutableSet<String> NON_PS = ImmutableSet.of(\n", "      \"foo.bar.com\", \"foo.ca\", \"foo.bar.ca\",\n", "      \"foo.bar.co.il\", \"state.CA.us\", \"www.state.pa.us\", \"pvt.k12.ca.us\",\n", "      \"www.google.com\", \"www4.yahoo.co.uk\", \"home.netscape.com\",\n", "      \"web.MIT.edu\", \"foo.eDu.au\", \"utenti.blah.IT\", \"dominio.com.co\");\n", "  private static final ImmutableSet<String> TOP_PRIVATE_DOMAIN =\n", "  private static final ImmutableSet<String> UNDER_PRIVATE_DOMAIN =\n"], "4": ["  public void testExclusion() {\n"], "5": ["  public void testMultipleUnders() {\n"]}, "added_lines": {"1": [99, 100, 101, 102, 103, 104, 105, 106, 107, 108, 109, 110, 111, 112, 113, 114, 115, 116, 117, 122, 123, 124, 125, 126, 128, 129, 130, 131, 132, 133, 134, 135, 136, 137, 138, 139, 140, 141, 142, 143, 144, 145, 146, 147, 148, 149, 150, 151, 154, 155, 156, 157, 160, 161, 162], "2": [231, 232, 233], "3": [307, 308, 309, 310, 311, 312, 313, 314, 315, 316, 317, 318, 319, 320, 321, 322, 323, 324, 325, 326, 327, 328, 329, 330, 331, 332, 333, 334, 335, 336, 337, 338, 339, 340, 341, 342, 343, 344, 345, 346, 347, 348, 349, 350, 351, 352, 353, 354, 355, 356, 357, 358, 359, 360, 361, 362, 363], "4": [462], "5": [471], "6": [481, 482, 483, 484, 485, 486, 487, 488, 489, 490, 491, 492, 493, 494, 495, 496, 497, 498, 499]}, "removed_lines": {"1": [99, 100, 101, 102, 103, 104, 105, 106, 107, 108, 109, 110, 115, 116, 117, 118, 119, 121, 124], "4": [366], "5": [375]}}, {"1": "android/guava/src/com/google/common/net/InternetDomainName.java", "added": {"1": ["import com.google.common.base.Optional;\n", "import com.google.thirdparty.publicsuffix.PublicSuffixType;\n", " * An immutable well-formed internet domain name, such as {@code com} or {@code foo.co.uk}. Only\n", " * syntactic analysis is performed; no DNS lookups or other network interactions take place. Thus\n", " * there is no guarantee that the domain actually exists on the internet.\n"], "2": [" * Using the subset of public suffixes that are {@linkplain #isRegistrySuffix() registry suffixes},\n", " * one can get a better result, as only a few registry suffixes are addressable. However, the most\n", " * useful test to determine if a domain is a plausible web host is {@link #hasPublicSuffix()}. This\n", " * will return {@code true} for many domains which (currently) are not hosts, such as {@code \"com\"},\n", " * but given that any public suffix may become a host without warning, it is better to err on the\n", " * side of permissiveness and thus avoid spurious rejection of valid sites. Of course, to actually\n", " * determine addressability of any host, clients of this class will need to perform their own DNS\n", " * lookups.\n", " *   <li>ASCII uppercase characters are converted to lowercase.\n", " *   <li>Unicode dot separators other than the ASCII period ({@code '.'}) are converted to the ASCII\n", " *       period.\n", " * names</a> such as {@code \u7f51\u7edc.cn} are supported, as are the equivalent <a\n", " * href=\"http://en.wikipedia.org/wiki/Internationalized_domain_name\">IDNA Punycode-encoded</a>\n"], "3": ["   * Value of {@link #publicSuffixIndex} or {@link #registrySuffixIndex} which indicates that no\n", "   * relevant suffix was found.\n", "  private static final int NO_SUFFIX_FOUND = -1;\n"], "4": ["   * domain name {@code myblog.blogspot.co.uk}, the value would be 1 (the index of the {@code\n", "   * blogspot} part). The value is negative (specifically, {@link #NO_SUFFIX_FOUND}) if no public\n", "   * suffix was found.\n", "  /**\n", "   * The index in the {@link #parts()} list at which the registry suffix begins. For example, for\n", "   * the domain name {@code myblog.blogspot.co.uk}, the value would be 2 (the index of the {@code\n", "   * co} part). The value is negative (specifically, {@link #NO_SUFFIX_FOUND}) if no registry suffix\n", "   * was found.\n", "   */\n", "  private final int registrySuffixIndex;\n", "\n"], "5": ["    this.publicSuffixIndex = findSuffixOfType(Optional.<PublicSuffixType>absent());\n", "    this.registrySuffixIndex = findSuffixOfType(Optional.of(PublicSuffixType.REGISTRY));\n", "   * Returns the index of the leftmost part of the suffix, or -1 if not found. Note that the value\n", "   * defined as a suffix may not produce {@code true} results from {@link #isPublicSuffix()} or\n", "   * {@link #isRegistrySuffix()} if the domain ends with an excluded domain pattern such as {@code\n", "   * \"nhs.uk\"}.\n", "   *\n", "   * <p>If a {@code desiredType} is specified, this method only finds suffixes of the given type.\n", "   * Otherwise, it finds the first suffix of any type.\n", "  private int findSuffixOfType(Optional<PublicSuffixType> desiredType) {\n", "      if (matchesType(\n", "          desiredType, Optional.fromNullable(PublicSuffixPatterns.EXACT.get(ancestorName)))) {\n"], "6": ["      if (matchesWildcardSuffixType(desiredType, ancestorName)) {\n", "    return NO_SUFFIX_FOUND;\n", "   * (\"Internationalizing Domain Names in Applications\") is skipped, while validation against <a\n", "   * href=\"http://www.ietf.org/rfc/rfc1035.txt\">RFC 1035</a> is relaxed in the following ways:\n", "   *\n", "   *   <li>Any part containing non-ASCII characters is considered valid.\n", "   *   <li>Underscores ('_') are permitted wherever dashes ('-') are permitted.\n", "   *   <li>Parts other than the final part may start with a digit, as mandated by <a\n", "   *       href=\"https://tools.ietf.org/html/rfc1123#section-2\">RFC 1123</a>.\n", "   * @throws IllegalArgumentException if {@code name} is not syntactically valid according to {@link\n", "   *     #isValid}\n"], "7": ["   * is one under which Internet users can directly register names, such as {@code com}, {@code\n", "   * co.uk} or {@code pvt.k12.wy.us}. Examples of domain names that are <i>not</i> public suffixes\n", "   * include {@code google.com}, {@code foo.co.uk}, and {@code myblog.blogspot.com}.\n", "   *\n", "   * <p>Public suffixes are a proper superset of {@linkplain #isRegistrySuffix() registry suffixes}.\n", "   * The list of public suffixes additionally contains privately owned domain names under which\n", "   * Internet users can register subdomains. An example of a public suffix that is not a registry\n", "   * suffix is {@code blogspot.com}. Note that it is true that all public suffixes <i>have</i>\n", "   * registry suffixes, since domain name registries collectively control all internet domain names.\n", "   *\n", "   * <p>For considerations on whether the public suffix or registry suffix designation is more\n", "   * suitable for your application, see <a\n", "   * href=\"https://github.com/google/guava/wiki/InternetDomainNameExplained\">this article</a>.\n"], "8": ["   * including if it is a public suffix itself. For example, returns {@code true} for {@code\n", "   * www.google.com}, {@code foo.co.uk} and {@code com}, but not for {@code invalid} or {@code\n", "   * google.invalid}. This is the recommended method for determining whether a domain is potentially\n", "   * an addressable host.\n", "   *\n", "   * <p>Note that this method is equivalent to {@link #hasRegistrySuffix()} because all registry\n", "   * suffixes are public suffixes <i>and</i> all public suffixes have registry suffixes.\n", "    return publicSuffixIndex != NO_SUFFIX_FOUND;\n"], "9": ["   * while not being a public suffix itself. For example, returns {@code true} for {@code\n", "   * www.google.com}, {@code foo.co.uk} and {@code myblog.blogspot.com}, but not for {@code com},\n", "   * {@code co.uk}, {@code google.invalid}, or {@code blogspot.com}.\n"], "10": ["   * {@linkplain #isPublicSuffix() public suffix}. For example, returns {@code true} for {@code\n", "   * google.com} {@code foo.co.uk}, and {@code myblog.blogspot.com}, but not for {@code\n", "   * www.google.com}, {@code co.uk}, or {@code blogspot.com}.\n"], "11": ["   * Returns the portion of this domain name that is one level beneath the {@linkplain\n", "   * #isPublicSuffix() public suffix}. For example, for {@code x.adwords.google.co.uk} it returns\n", "   * {@code google.co.uk}, since {@code co.uk} is a public suffix. Similarly, for {@code\n", "   * myblog.blogspot.com} it returns the same domain, {@code myblog.blogspot.com}, since {@code\n", "   * blogspot.com} is a public suffix.\n"], "12": ["  /**\n", "   * Indicates whether this domain name represents a <i>registry suffix</i>, as defined by a subset\n", "   * of the Mozilla Foundation's <a href=\"http://publicsuffix.org/\">Public Suffix List</a> (PSL). A\n", "   * registry suffix is one under which Internet users can directly register names via a domain name\n", "   * registrar, and have such registrations lawfully protected by internet-governing bodies such as\n", "   * ICANN. Examples of registry suffixes include {@code com}, {@code co.uk}, and {@code\n", "   * pvt.k12.wy.us}. Examples of domain names that are <i>not</i> registry suffixes include {@code\n", "   * google.com} and {@code foo.co.uk}.\n", "   *\n", "   * <p>Registry suffixes are a proper subset of {@linkplain #isPublicSuffix() public suffixes}. The\n", "   * list of public suffixes additionally contains privately owned domain names under which Internet\n", "   * users can register subdomains. An example of a public suffix that is not a registry suffix is\n", "   * {@code blogspot.com}. Note that it is true that all public suffixes <i>have</i> registry\n", "   * suffixes, since domain name registries collectively control all internet domain names.\n", "   *\n", "   * <p>For considerations on whether the public suffix or registry suffix designation is more\n", "   * suitable for your application, see <a\n", "   * href=\"https://github.com/google/guava/wiki/InternetDomainNameExplained\">this article</a>.\n", "   *\n", "   * @return {@code true} if this domain name appears exactly on the public suffix list as part of\n", "   *     the registry suffix section (labelled \"ICANN\").\n", "   * @since NEXT\n", "   */\n", "  public boolean isRegistrySuffix() {\n", "    return registrySuffixIndex == 0;\n", "  }\n", "\n", "  /**\n", "   * Indicates whether this domain name ends in a {@linkplain #isRegistrySuffix() registry suffix},\n", "   * including if it is a registry suffix itself. For example, returns {@code true} for {@code\n", "   * www.google.com}, {@code foo.co.uk} and {@code com}, but not for {@code invalid} or {@code\n", "   * google.invalid}.\n", "   *\n", "   * <p>Note that this method is equivalent to {@link #hasPublicSuffix()} because all registry\n", "   * suffixes are public suffixes <i>and</i> all public suffixes have registry suffixes.\n", "   *\n", "   * @since NEXT\n", "   */\n", "  public boolean hasRegistrySuffix() {\n", "    return registrySuffixIndex != NO_SUFFIX_FOUND;\n", "  }\n", "\n", "  /**\n", "   * Returns the {@linkplain #isRegistrySuffix() registry suffix} portion of the domain name, or\n", "   * {@code null} if no registry suffix is present.\n", "   *\n", "   * @since NEXT\n", "   */\n", "  public InternetDomainName registrySuffix() {\n", "    return hasRegistrySuffix() ? ancestor(registrySuffixIndex) : null;\n", "  }\n", "\n", "  /**\n", "   * Indicates whether this domain name ends in a {@linkplain #isRegistrySuffix() registry suffix},\n", "   * while not being a registry suffix itself. For example, returns {@code true} for {@code\n", "   * www.google.com}, {@code foo.co.uk} and {@code blogspot.com}, but not for {@code com}, {@code\n", "   * co.uk}, or {@code google.invalid}.\n", "   *\n", "   * @since NEXT\n", "   */\n", "  public boolean isUnderRegistrySuffix() {\n", "    return registrySuffixIndex > 0;\n", "  }\n", "\n", "  /**\n", "   * Indicates whether this domain name is composed of exactly one subdomain component followed by a\n", "   * {@linkplain #isRegistrySuffix() registry suffix}. For example, returns {@code true} for {@code\n", "   * google.com}, {@code foo.co.uk}, and {@code blogspot.com}, but not for {@code www.google.com},\n", "   * {@code co.uk}, or {@code myblog.blogspot.com}.\n", "   *\n", "   * <p><b>Warning:</b> This method should not be used to determine the probable highest level\n", "   * parent domain for which cookies may be set. Use {@link #topPrivateDomain()} for that purpose.\n", "   *\n", "   * @since NEXT\n", "   */\n", "  public boolean isTopDomainUnderRegistrySuffix() {\n", "    return registrySuffixIndex == 1;\n", "  }\n", "\n", "  /**\n", "   * Returns the portion of this domain name that is one level beneath the {@linkplain\n", "   * #isRegistrySuffix() registry suffix}. For example, for {@code x.adwords.google.co.uk} it\n", "   * returns {@code google.co.uk}, since {@code co.uk} is a registry suffix. Similarly, for {@code\n", "   * myblog.blogspot.com} it returns {@code blogspot.com}, since {@code com} is a registry suffix.\n", "   *\n", "   * <p>If {@link #isTopDomainUnderRegistrySuffix()} is true, the current domain name instance is\n", "   * returned.\n", "   *\n", "   * <p><b>Warning:</b> This method should not be used to determine whether a domain is probably the\n", "   * highest level for which cookies may be set. Use {@link #isTopPrivateDomain()} for that purpose.\n", "   *\n", "   * @throws IllegalStateException if this domain does not end with a registry suffix\n", "   * @since NEXT\n", "   */\n", "  public InternetDomainName topDomainUnderRegistrySuffix() {\n", "    if (isTopDomainUnderRegistrySuffix()) {\n", "      return this;\n", "    }\n", "    checkState(isUnderRegistrySuffix(), \"Not under a registry suffix: %s\", name);\n", "    return ancestor(registrySuffixIndex - 1);\n", "  }\n", "\n"], "13": ["   * Does the domain name match one of the \"wildcard\" patterns (e.g. {@code \"*.ar\"})? If a {@code\n", "   * desiredType} is specified, the wildcard pattern must also match that type.\n", "  private static boolean matchesWildcardSuffixType(\n", "      Optional<PublicSuffixType> desiredType, String domain) {\n", "    return pieces.length == 2\n", "        && matchesType(\n", "            desiredType, Optional.fromNullable(PublicSuffixPatterns.UNDER.get(pieces[1])));\n", "  }\n", "\n", "  /**\n", "   * If a {@code desiredType} is specified, returns true only if the {@code actualType} is\n", "   * identical. Otherwise, returns true as long as {@code actualType} is present.\n", "   */\n", "  private static boolean matchesType(\n", "      Optional<PublicSuffixType> desiredType, Optional<PublicSuffixType> actualType) {\n", "    return desiredType.isPresent() ? desiredType.equals(actualType) : actualType.isPresent();\n"]}, "removed": {"1": [" * An immutable well-formed internet domain name, such as {@code com} or {@code\n", " * foo.co.uk}. Only syntactic analysis is performed; no DNS lookups or other network interactions\n", " * take place. Thus there is no guarantee that the domain actually exists on the internet.\n"], "2": [" * As a result, the only useful test to determine if a domain is a plausible web host is\n", " * {@link #hasPublicSuffix()}. This will return {@code true} for many domains which (currently) are\n", " * not hosts, such as {@code \"com\"}, but given that any public suffix may become a host without\n", " * warning, it is better to err on the side of permissiveness and thus avoid spurious rejection of\n", " * valid sites.\n", " * <li>ASCII uppercase characters are converted to lowercase.\n", " * <li>Unicode dot separators other than the ASCII period ({@code '.'}) are converted to the ASCII\n", " *     period.\n", " * names</a> such as {@code \u7f51\u7edc.cn} are supported, as are the equivalent\n", " * <a href=\"http://en.wikipedia.org/wiki/Internationalized_domain_name\">IDNA Punycode-encoded</a>\n"], "3": ["   * Value of {@link #publicSuffixIndex} which indicates that no public suffix was found.\n", "  private static final int NO_PUBLIC_SUFFIX_FOUND = -1;\n"], "4": ["   * domain name {@code www.google.co.uk}, the value would be 2 (the index of the {@code co} part).\n", "   * The value is negative (specifically, {@link #NO_PUBLIC_SUFFIX_FOUND}) if no public suffix was\n", "   * found.\n"], "5": ["    this.publicSuffixIndex = findPublicSuffix();\n", "   * Returns the index of the leftmost part of the public suffix, or -1 if not found. Note that the\n", "   * value defined as the \"public suffix\" may not be a public suffix according to\n", "   * {@link #isPublicSuffix()} if the domain ends with an excluded domain pattern such as\n", "   * {@code \"nhs.uk\"}.\n", "  private int findPublicSuffix() {\n", "      if (PublicSuffixPatterns.EXACT.containsKey(ancestorName)) {\n"], "6": ["      if (matchesWildcardPublicSuffix(ancestorName)) {\n", "    return NO_PUBLIC_SUFFIX_FOUND;\n", "   * (\"Internationalizing Domain Names in Applications\") is skipped, while validation against\n", "   * <a href=\"http://www.ietf.org/rfc/rfc1035.txt\">RFC 1035</a> is relaxed in the following ways:\n", "   * <li>Any part containing non-ASCII characters is considered valid.\n", "   * <li>Underscores ('_') are permitted wherever dashes ('-') are permitted.\n", "   * <li>Parts other than the final part may start with a digit, as mandated by\n", "   * <a href=\"https://tools.ietf.org/html/rfc1123#section-2\">RFC 1123</a>.\n", "   * @throws IllegalArgumentException if {@code name} is not syntactically valid according to\n", "   *     {@link #isValid}\n"], "7": ["   * is one under which Internet users can directly register names, such as {@code com},\n", "   * {@code co.uk} or {@code pvt.k12.wy.us}. Examples of domain names that are <i>not</i> public\n", "   * suffixes include {@code google}, {@code google.com} and {@code foo.co.uk}.\n"], "8": ["   * including if it is a public suffix itself. For example, returns {@code true} for\n", "   * {@code www.google.com}, {@code foo.co.uk} and {@code com}, but not for {@code invalid} or\n", "   * {@code google.invalid}. This is the recommended method for determining whether a domain is\n", "   * potentially an addressable host.\n", "    return publicSuffixIndex != NO_PUBLIC_SUFFIX_FOUND;\n"], "9": ["   * while not being a public suffix itself. For example, returns {@code true} for\n", "   * {@code www.google.com}, {@code foo.co.uk} and {@code bar.ca.us}, but not for {@code google},\n", "   * {@code com}, or {@code\n", "   * google.foo}.\n", "   *\n", "   * <p><b>Warning:</b> a {@code false} result from this method does not imply that the domain does\n", "   * not represent an addressable host, as many public suffixes are also addressable hosts. Use\n", "   * {@link #hasPublicSuffix()} for that test.\n"], "10": ["   * {@linkplain #isPublicSuffix() public suffix}. For example, returns {@code true} for\n", "   * {@code google.com} and {@code foo.co.uk}, but not for {@code www.google.com} or {@code co.uk}.\n", "   *\n", "   * <p><b>Warning:</b> A {@code true} result from this method does not imply that the domain is at\n", "   * the highest level which is addressable as a host, as many public suffixes are also addressable\n", "   * hosts. For example, the domain {@code bar.uk.com} has a public suffix of {@code uk.com}, so it\n", "   * would return {@code true} from this method. But {@code uk.com} is itself an addressable host.\n"], "11": ["   * Returns the portion of this domain name that is one level beneath the public suffix. For\n", "   * example, for {@code x.adwords.google.co.uk} it returns {@code google.co.uk}, since\n", "   * {@code co.uk} is a public suffix.\n", "   * <p>This method should not be used to determine the topmost parent domain which is addressable\n", "   * as a host, as many public suffixes are also addressable hosts. For example, the domain\n", "   * {@code foo.bar.uk.com} has a public suffix of {@code uk.com}, so it would return\n", "   * {@code bar.uk.com} from this method. But {@code uk.com} is itself an addressable host.\n", "   *\n"], "13": ["   * Does the domain name match one of the \"wildcard\" patterns (e.g. {@code \"*.ar\"})?\n", "  private static boolean matchesWildcardPublicSuffix(String domain) {\n", "    return pieces.length == 2 && PublicSuffixPatterns.UNDER.containsKey(pieces[1]);\n"]}, "added_lines": {"1": [26, 30, 35, 36, 37], "2": [45, 46, 47, 48, 49, 50, 51, 52, 57, 58, 59, 66, 67], "3": [82, 83, 85], "4": [121, 122, 123, 127, 128, 129, 130, 131, 132, 133, 134], "5": [157, 158, 162, 163, 164, 165, 166, 167, 168, 170, 176, 177], "6": [188, 193, 199, 200, 201, 203, 204, 205, 206, 211, 212], "7": [315, 316, 317, 318, 319, 320, 321, 322, 323, 324, 325, 326, 327], "8": [338, 339, 340, 341, 342, 343, 344, 349], "9": [364, 365, 366], "10": [380, 381, 382], "11": [395, 396, 397, 398, 399], "12": [418, 419, 420, 421, 422, 423, 424, 425, 426, 427, 428, 429, 430, 431, 432, 433, 434, 435, 436, 437, 438, 439, 440, 441, 442, 443, 444, 445, 446, 447, 448, 449, 450, 451, 452, 453, 454, 455, 456, 457, 458, 459, 460, 461, 462, 463, 464, 465, 466, 467, 468, 469, 470, 471, 472, 473, 474, 475, 476, 477, 478, 479, 480, 481, 482, 483, 484, 485, 486, 487, 488, 489, 490, 491, 492, 493, 494, 495, 496, 497, 498, 499, 500, 501, 502, 503, 504, 505, 506, 507, 508, 509, 510, 511, 512, 513, 514, 515, 516, 517, 518, 519], "13": [595, 596, 598, 599, 601, 602, 603, 604, 605, 606, 607, 608, 609, 610, 611, 612]}, "removed_lines": {"1": [33, 34, 35], "2": [43, 44, 45, 46, 47, 52, 53, 54, 61, 62], "3": [77, 79], "4": [115, 116, 117], "5": [143, 147, 148, 149, 150, 152, 158], "6": [169, 174, 180, 181, 183, 184, 185, 186, 191, 192], "7": [295, 296, 297], "8": [308, 309, 310, 311, 316], "9": [331, 332, 333, 334, 335, 336, 337, 338], "10": [352, 353, 354, 355, 356, 357, 358], "11": [371, 372, 373, 377, 378, 379, 380, 381], "13": [472, 474, 476]}}, {"2": "android/guava/src/com/google/thirdparty/publicsuffix/PublicSuffixType.java", "added": {"1": ["import com.google.common.annotations.Beta;\n", " * <b>Do not use this class directly. For access to public-suffix information,\n", " * use {@link com.google.common.net.InternetDomainName}.</b>\n", " *\n", " * <p>Specifies the type of a top-level domain definition.\n", " *\n", " * @since NEXT\n", "@Beta\n", "public enum PublicSuffixType {\n", "  /** Public suffix that is provided by a private company, e.g. \"blogspot.com\" */\n", "  /** Public suffix that is backed by an ICANN-style domain name registry */\n", "  REGISTRY('!', '?');\n"], "2": ["    return isPrivate ? PRIVATE : REGISTRY;\n"]}, "removed": {"1": [" * Specifies the type of a top-level domain definition.\n", "enum PublicSuffixType {\n", "  /** private definition of a top-level domain */\n", "  /** ICANN definition of a top-level domain */\n", "  ICANN('!', '?');\n"], "2": ["    return isPrivate ? PRIVATE : ICANN;\n"]}, "added_lines": {"1": [17, 21, 22, 23, 24, 25, 26, 28, 30, 32, 34, 35], "2": [67]}, "removed_lines": {"1": [20, 23, 25, 27, 28], "2": [60]}}, {"3": "android/guava/src/com/google/thirdparty/publicsuffix/TrieParser.java", "added": {"1": ["      // '!' represents an interior node that represents a REGISTRY entry in the map.\n", "      // '?' represents a leaf node, which represents a REGISTRY entry in map.\n"]}, "removed": {"1": ["      // '!' represents an interior node that represents an ICANN entry in the map.\n", "      // '?' represents a leaf node, which represents an ICANN entry in map.\n"]}, "added_lines": {"1": [76, 77]}, "removed_lines": {"1": [77, 78]}}, {"4": "guava-gwt/src/com/google/common/net/Net.gwt.xml", "added": {"1": ["  <inherits name=\"com.google.thirdparty.publicsuffix.PublicSuffixType\"/>\n", "     \n"]}, "removed": {}, "added_lines": {"1": [29, 30]}, "removed_lines": {}}, {"5": "guava-gwt/test/com/google/common/net/InternetDomainNameTest_gwt.java", "added": {"3": ["public void testPublicSuffixExclusion() throws Exception {\n", "  com.google.common.net.InternetDomainNameTest testCase = new com.google.common.net.InternetDomainNameTest();\n", "  testCase.testPublicSuffixExclusion();\n", "}\n", "\n", "public void testPublicSuffixMultipleUnders() throws Exception {\n", "  com.google.common.net.InternetDomainNameTest testCase = new com.google.common.net.InternetDomainNameTest();\n", "  testCase.testPublicSuffixMultipleUnders();\n", "}\n", "\n", "public void testRegistrySuffix() throws Exception {\n", "  com.google.common.net.InternetDomainNameTest testCase = new com.google.common.net.InternetDomainNameTest();\n", "  testCase.testRegistrySuffix();\n", "}\n", "\n", "public void testRegistrySuffixExclusion() throws Exception {\n", "  com.google.common.net.InternetDomainNameTest testCase = new com.google.common.net.InternetDomainNameTest();\n", "  testCase.testRegistrySuffixExclusion();\n", "}\n", "\n", "public void testRegistrySuffixMultipleUnders() throws Exception {\n", "  com.google.common.net.InternetDomainNameTest testCase = new com.google.common.net.InternetDomainNameTest();\n", "  testCase.testRegistrySuffixMultipleUnders();\n", "}\n", "\n", "public void testTopDomainUnderRegistrySuffix() throws Exception {\n", "  com.google.common.net.InternetDomainNameTest testCase = new com.google.common.net.InternetDomainNameTest();\n", "  testCase.testTopDomainUnderRegistrySuffix();\n", "}\n", "\n"], "4": ["public void testUnderRegistrySuffix() throws Exception {\n", "  com.google.common.net.InternetDomainNameTest testCase = new com.google.common.net.InternetDomainNameTest();\n", "  testCase.testUnderRegistrySuffix();\n", "}\n", "\n", "public void testUnderTopDomainUnderRegistrySuffix() throws Exception {\n", "  com.google.common.net.InternetDomainNameTest testCase = new com.google.common.net.InternetDomainNameTest();\n", "  testCase.testUnderTopDomainUnderRegistrySuffix();\n", "}\n", "\n"]}, "removed": {"1": ["public void testExclusion() throws Exception {\n", "  com.google.common.net.InternetDomainNameTest testCase = new com.google.common.net.InternetDomainNameTest();\n", "  testCase.testExclusion();\n", "}\n", "\n"], "2": ["public void testMultipleUnders() throws Exception {\n", "  com.google.common.net.InternetDomainNameTest testCase = new com.google.common.net.InternetDomainNameTest();\n", "  testCase.testMultipleUnders();\n", "}\n", "\n"]}, "added_lines": {"3": [61, 62, 63, 64, 65, 66, 67, 68, 69, 70, 71, 72, 73, 74, 75, 76, 77, 78, 79, 80, 81, 82, 83, 84, 85, 91, 92, 93, 94, 95], "4": [111, 112, 113, 114, 115, 116, 117, 118, 119, 120]}, "removed_lines": {"1": [31, 32, 33, 34, 35], "2": [51, 52, 53, 54, 55]}}, {"6": "guava-tests/test/com/google/common/net/InternetDomainNameTest.java", "added": {"1": ["  private static final ImmutableSet<String> RS =\n", "      ImmutableSet.of(\n", "          \"com\",\n", "          \"co.uk\",\n", "          \"foo.bd\",\n", "          \"xxxxxx.bd\",\n", "          \"org.mK\",\n", "          \"us\",\n", "          \"co.uk.\", // Trailing dot\n", "          \"co\\uFF61uk\", // Alternate dot character\n", "          \"\\u7f51\\u7edc.Cn\", // \"\u7f51\u7edc.Cn\"\n", "          \"j\\u00f8rpeland.no\", // \"jorpeland.no\" (first o slashed)\n", "          \"xn--jrpeland-54a.no\"); // IDNA (punycode) encoding of above\n", "\n", "  private static final ImmutableSet<String> PS_NOT_RS =\n", "      ImmutableSet.of(\"blogspot.com\", \"blogspot.co.uk\", \"uk.com\");\n", "\n", "  private static final ImmutableSet<String> PS =\n", "      ImmutableSet.<String>builder().addAll(RS).addAll(PS_NOT_RS).build();\n", "  /**\n", "   * Having a public suffix is equivalent to having a registry suffix, because all registry suffixes\n", "   * are public suffixes, and all public suffixes have registry suffixes.\n", "   */\n", "  private static final ImmutableSet<String> NO_RS = NO_PS;\n", "  private static final ImmutableSet<String> NON_PS =\n", "      ImmutableSet.of(\n", "          \"foo.bar.com\",\n", "          \"foo.ca\",\n", "          \"foo.bar.ca\",\n", "          \"foo.blogspot.com\",\n", "          \"foo.blogspot.co.uk\",\n", "          \"foo.uk.com\",\n", "          \"foo.bar.co.il\",\n", "          \"state.CA.us\",\n", "          \"www.state.pa.us\",\n", "          \"pvt.k12.ca.us\",\n", "          \"www.google.com\",\n", "          \"www4.yahoo.co.uk\",\n", "          \"home.netscape.com\",\n", "          \"web.MIT.edu\",\n", "          \"foo.eDu.au\",\n", "          \"utenti.blah.IT\",\n", "          \"dominio.com.co\");\n", "\n", "  private static final ImmutableSet<String> NON_RS =\n", "      ImmutableSet.<String>builder().addAll(NON_PS).addAll(PS_NOT_RS).build();\n", "\n", "  private static final ImmutableSet<String> TOP_UNDER_REGISTRY_SUFFIX =\n", "  private static final ImmutableSet<String> TOP_PRIVATE_DOMAIN =\n", "      ImmutableSet.of(\"google.com\", \"foo.Co.uk\", \"foo.ca.us.\", \"foo.blogspot.com\");\n", "\n", "  private static final ImmutableSet<String> UNDER_TOP_UNDER_REGISTRY_SUFFIX =\n", "  private static final ImmutableSet<String> UNDER_PRIVATE_DOMAIN =\n", "      ImmutableSet.of(\"foo.bar.google.com\", \"a.b.co.uk\", \"x.y.ca.us\", \"a.b.blogspot.com\");\n", "\n"], "2": ["  private static final ImmutableSet<String> SOMEWHERE_UNDER_RS =\n", "      ImmutableSet.<String>builder().addAll(SOMEWHERE_UNDER_PS).addAll(PS_NOT_RS).build();\n", "\n"], "3": ["  public void testRegistrySuffix() {\n", "    for (String name : RS) {\n", "      final InternetDomainName domain = InternetDomainName.from(name);\n", "      assertTrue(name, domain.isRegistrySuffix());\n", "      assertTrue(name, domain.hasRegistrySuffix());\n", "      assertFalse(name, domain.isUnderRegistrySuffix());\n", "      assertFalse(name, domain.isTopDomainUnderRegistrySuffix());\n", "      assertEquals(domain, domain.registrySuffix());\n", "    }\n", "\n", "    for (String name : NO_RS) {\n", "      final InternetDomainName domain = InternetDomainName.from(name);\n", "      assertFalse(name, domain.isRegistrySuffix());\n", "      assertFalse(name, domain.hasRegistrySuffix());\n", "      assertFalse(name, domain.isUnderRegistrySuffix());\n", "      assertFalse(name, domain.isTopDomainUnderRegistrySuffix());\n", "      assertNull(domain.registrySuffix());\n", "    }\n", "\n", "    for (String name : NON_RS) {\n", "      final InternetDomainName domain = InternetDomainName.from(name);\n", "      assertFalse(name, domain.isRegistrySuffix());\n", "      assertTrue(name, domain.hasRegistrySuffix());\n", "      assertTrue(name, domain.isUnderRegistrySuffix());\n", "    }\n", "  }\n", "\n", "  public void testUnderRegistrySuffix() {\n", "    for (String name : SOMEWHERE_UNDER_RS) {\n", "      final InternetDomainName domain = InternetDomainName.from(name);\n", "      assertFalse(name, domain.isRegistrySuffix());\n", "      assertTrue(name, domain.hasRegistrySuffix());\n", "      assertTrue(name, domain.isUnderRegistrySuffix());\n", "    }\n", "  }\n", "\n", "  public void testTopDomainUnderRegistrySuffix() {\n", "    for (String name : TOP_UNDER_REGISTRY_SUFFIX) {\n", "      final InternetDomainName domain = InternetDomainName.from(name);\n", "      assertFalse(name, domain.isRegistrySuffix());\n", "      assertTrue(name, domain.hasRegistrySuffix());\n", "      assertTrue(name, domain.isUnderRegistrySuffix());\n", "      assertTrue(name, domain.isTopDomainUnderRegistrySuffix());\n", "      assertEquals(domain.parent(), domain.registrySuffix());\n", "    }\n", "  }\n", "\n", "  public void testUnderTopDomainUnderRegistrySuffix() {\n", "    for (String name : UNDER_TOP_UNDER_REGISTRY_SUFFIX) {\n", "      final InternetDomainName domain = InternetDomainName.from(name);\n", "      assertFalse(name, domain.isRegistrySuffix());\n", "      assertTrue(name, domain.hasRegistrySuffix());\n", "      assertTrue(name, domain.isUnderRegistrySuffix());\n", "      assertFalse(name, domain.isTopDomainUnderRegistrySuffix());\n", "    }\n", "  }\n", "\n"], "4": ["  public void testPublicSuffixExclusion() {\n"], "5": ["  public void testPublicSuffixMultipleUnders() {\n"], "6": ["  public void testRegistrySuffixExclusion() {\n", "    InternetDomainName domain = InternetDomainName.from(\"foo.city.yokohama.jp\");\n", "    assertTrue(domain.hasRegistrySuffix());\n", "    assertEquals(\"yokohama.jp\", domain.registrySuffix().toString());\n", "\n", "    // Behold the weirdness!\n", "    assertFalse(domain.registrySuffix().isRegistrySuffix());\n", "  }\n", "\n", "  public void testRegistrySuffixMultipleUnders() {\n", "    // PSL has both *.uk and *.sch.uk; the latter should win.\n", "    // See http://code.google.com/p/guava-libraries/issues/detail?id=1176\n", "\n", "    InternetDomainName domain = InternetDomainName.from(\"www.essex.sch.uk\");\n", "    assertTrue(domain.hasRegistrySuffix());\n", "    assertEquals(\"essex.sch.uk\", domain.registrySuffix().toString());\n", "    assertEquals(\"www.essex.sch.uk\", domain.topDomainUnderRegistrySuffix().toString());\n", "  }\n", "\n"]}, "removed": {"1": ["  private static final ImmutableSet<String> PS = ImmutableSet.of(\n", "      \"com\",\n", "      \"co.uk\",\n", "      \"foo.bd\",\n", "      \"xxxxxx.bd\",\n", "      \"org.mK\",\n", "      \"us\",\n", "      \"uk\\uFF61com.\",  // Alternate dot character\n", "      \"\\u7f51\\u7edc.Cn\",  // \"\u7f51\u7edc.Cn\"\n", "      \"j\\u00f8rpeland.no\",  // \"jorpeland.no\" (first o slashed)\n", "      \"xn--jrpeland-54a.no\"  // IDNA (punycode) encoding of above\n", "  );\n", "  private static final ImmutableSet<String> NON_PS = ImmutableSet.of(\n", "      \"foo.bar.com\", \"foo.ca\", \"foo.bar.ca\",\n", "      \"foo.bar.co.il\", \"state.CA.us\", \"www.state.pa.us\", \"pvt.k12.ca.us\",\n", "      \"www.google.com\", \"www4.yahoo.co.uk\", \"home.netscape.com\",\n", "      \"web.MIT.edu\", \"foo.eDu.au\", \"utenti.blah.IT\", \"dominio.com.co\");\n", "  private static final ImmutableSet<String> TOP_PRIVATE_DOMAIN =\n", "  private static final ImmutableSet<String> UNDER_PRIVATE_DOMAIN =\n"], "4": ["  public void testExclusion() {\n"], "5": ["  public void testMultipleUnders() {\n"]}, "added_lines": {"1": [99, 100, 101, 102, 103, 104, 105, 106, 107, 108, 109, 110, 111, 112, 113, 114, 115, 116, 117, 122, 123, 124, 125, 126, 128, 129, 130, 131, 132, 133, 134, 135, 136, 137, 138, 139, 140, 141, 142, 143, 144, 145, 146, 147, 148, 149, 150, 151, 154, 155, 156, 157, 160, 161, 162], "2": [231, 232, 233], "3": [307, 308, 309, 310, 311, 312, 313, 314, 315, 316, 317, 318, 319, 320, 321, 322, 323, 324, 325, 326, 327, 328, 329, 330, 331, 332, 333, 334, 335, 336, 337, 338, 339, 340, 341, 342, 343, 344, 345, 346, 347, 348, 349, 350, 351, 352, 353, 354, 355, 356, 357, 358, 359, 360, 361, 362, 363], "4": [462], "5": [471], "6": [481, 482, 483, 484, 485, 486, 487, 488, 489, 490, 491, 492, 493, 494, 495, 496, 497, 498, 499]}, "removed_lines": {"1": [99, 100, 101, 102, 103, 104, 105, 106, 107, 108, 109, 110, 115, 116, 117, 118, 119, 121, 124], "4": [366], "5": [375]}}, {"7": "guava/src/com/google/common/net/InternetDomainName.java", "added": {"1": ["import com.google.common.base.Optional;\n", "import com.google.thirdparty.publicsuffix.PublicSuffixType;\n", " * An immutable well-formed internet domain name, such as {@code com} or {@code foo.co.uk}. Only\n", " * syntactic analysis is performed; no DNS lookups or other network interactions take place. Thus\n", " * there is no guarantee that the domain actually exists on the internet.\n"], "2": [" * Using the subset of public suffixes that are {@linkplain #isRegistrySuffix() registry suffixes},\n", " * one can get a better result, as only a few registry suffixes are addressable. However, the most\n", " * useful test to determine if a domain is a plausible web host is {@link #hasPublicSuffix()}. This\n", " * will return {@code true} for many domains which (currently) are not hosts, such as {@code \"com\"},\n", " * but given that any public suffix may become a host without warning, it is better to err on the\n", " * side of permissiveness and thus avoid spurious rejection of valid sites. Of course, to actually\n", " * determine addressability of any host, clients of this class will need to perform their own DNS\n", " * lookups.\n", " *   <li>ASCII uppercase characters are converted to lowercase.\n", " *   <li>Unicode dot separators other than the ASCII period ({@code '.'}) are converted to the ASCII\n", " *       period.\n", " * names</a> such as {@code \u7f51\u7edc.cn} are supported, as are the equivalent <a\n", " * href=\"http://en.wikipedia.org/wiki/Internationalized_domain_name\">IDNA Punycode-encoded</a>\n"], "3": ["   * Value of {@link #publicSuffixIndex} or {@link #registrySuffixIndex} which indicates that no\n", "   * relevant suffix was found.\n", "  private static final int NO_SUFFIX_FOUND = -1;\n"], "4": ["   * domain name {@code myblog.blogspot.co.uk}, the value would be 1 (the index of the {@code\n", "   * blogspot} part). The value is negative (specifically, {@link #NO_SUFFIX_FOUND}) if no public\n", "   * suffix was found.\n", "  /**\n", "   * The index in the {@link #parts()} list at which the registry suffix begins. For example, for\n", "   * the domain name {@code myblog.blogspot.co.uk}, the value would be 2 (the index of the {@code\n", "   * co} part). The value is negative (specifically, {@link #NO_SUFFIX_FOUND}) if no registry suffix\n", "   * was found.\n", "   */\n", "  private final int registrySuffixIndex;\n", "\n"], "5": ["    this.publicSuffixIndex = findSuffixOfType(Optional.<PublicSuffixType>absent());\n", "    this.registrySuffixIndex = findSuffixOfType(Optional.of(PublicSuffixType.REGISTRY));\n", "   * Returns the index of the leftmost part of the suffix, or -1 if not found. Note that the value\n", "   * defined as a suffix may not produce {@code true} results from {@link #isPublicSuffix()} or\n", "   * {@link #isRegistrySuffix()} if the domain ends with an excluded domain pattern such as {@code\n", "   * \"nhs.uk\"}.\n", "   *\n", "   * <p>If a {@code desiredType} is specified, this method only finds suffixes of the given type.\n", "   * Otherwise, it finds the first suffix of any type.\n", "  private int findSuffixOfType(Optional<PublicSuffixType> desiredType) {\n", "      if (matchesType(\n", "          desiredType, Optional.fromNullable(PublicSuffixPatterns.EXACT.get(ancestorName)))) {\n"], "6": ["      if (matchesWildcardSuffixType(desiredType, ancestorName)) {\n", "    return NO_SUFFIX_FOUND;\n", "   * (\"Internationalizing Domain Names in Applications\") is skipped, while validation against <a\n", "   * href=\"http://www.ietf.org/rfc/rfc1035.txt\">RFC 1035</a> is relaxed in the following ways:\n", "   *\n", "   *   <li>Any part containing non-ASCII characters is considered valid.\n", "   *   <li>Underscores ('_') are permitted wherever dashes ('-') are permitted.\n", "   *   <li>Parts other than the final part may start with a digit, as mandated by <a\n", "   *       href=\"https://tools.ietf.org/html/rfc1123#section-2\">RFC 1123</a>.\n", "   * @throws IllegalArgumentException if {@code name} is not syntactically valid according to {@link\n", "   *     #isValid}\n"], "7": ["   * is one under which Internet users can directly register names, such as {@code com}, {@code\n", "   * co.uk} or {@code pvt.k12.wy.us}. Examples of domain names that are <i>not</i> public suffixes\n", "   * include {@code google.com}, {@code foo.co.uk}, and {@code myblog.blogspot.com}.\n", "   *\n", "   * <p>Public suffixes are a proper superset of {@linkplain #isRegistrySuffix() registry suffixes}.\n", "   * The list of public suffixes additionally contains privately owned domain names under which\n", "   * Internet users can register subdomains. An example of a public suffix that is not a registry\n", "   * suffix is {@code blogspot.com}. Note that it is true that all public suffixes <i>have</i>\n", "   * registry suffixes, since domain name registries collectively control all internet domain names.\n", "   *\n", "   * <p>For considerations on whether the public suffix or registry suffix designation is more\n", "   * suitable for your application, see <a\n", "   * href=\"https://github.com/google/guava/wiki/InternetDomainNameExplained\">this article</a>.\n"], "8": ["   * including if it is a public suffix itself. For example, returns {@code true} for {@code\n", "   * www.google.com}, {@code foo.co.uk} and {@code com}, but not for {@code invalid} or {@code\n", "   * google.invalid}. This is the recommended method for determining whether a domain is potentially\n", "   * an addressable host.\n", "   *\n", "   * <p>Note that this method is equivalent to {@link #hasRegistrySuffix()} because all registry\n", "   * suffixes are public suffixes <i>and</i> all public suffixes have registry suffixes.\n", "    return publicSuffixIndex != NO_SUFFIX_FOUND;\n"], "9": ["   * while not being a public suffix itself. For example, returns {@code true} for {@code\n", "   * www.google.com}, {@code foo.co.uk} and {@code myblog.blogspot.com}, but not for {@code com},\n", "   * {@code co.uk}, {@code google.invalid}, or {@code blogspot.com}.\n"], "10": ["   * {@linkplain #isPublicSuffix() public suffix}. For example, returns {@code true} for {@code\n", "   * google.com} {@code foo.co.uk}, and {@code myblog.blogspot.com}, but not for {@code\n", "   * www.google.com}, {@code co.uk}, or {@code blogspot.com}.\n"], "11": ["   * Returns the portion of this domain name that is one level beneath the {@linkplain\n", "   * #isPublicSuffix() public suffix}. For example, for {@code x.adwords.google.co.uk} it returns\n", "   * {@code google.co.uk}, since {@code co.uk} is a public suffix. Similarly, for {@code\n", "   * myblog.blogspot.com} it returns the same domain, {@code myblog.blogspot.com}, since {@code\n", "   * blogspot.com} is a public suffix.\n"], "12": ["  /**\n", "   * Indicates whether this domain name represents a <i>registry suffix</i>, as defined by a subset\n", "   * of the Mozilla Foundation's <a href=\"http://publicsuffix.org/\">Public Suffix List</a> (PSL). A\n", "   * registry suffix is one under which Internet users can directly register names via a domain name\n", "   * registrar, and have such registrations lawfully protected by internet-governing bodies such as\n", "   * ICANN. Examples of registry suffixes include {@code com}, {@code co.uk}, and {@code\n", "   * pvt.k12.wy.us}. Examples of domain names that are <i>not</i> registry suffixes include {@code\n", "   * google.com} and {@code foo.co.uk}.\n", "   *\n", "   * <p>Registry suffixes are a proper subset of {@linkplain #isPublicSuffix() public suffixes}. The\n", "   * list of public suffixes additionally contains privately owned domain names under which Internet\n", "   * users can register subdomains. An example of a public suffix that is not a registry suffix is\n", "   * {@code blogspot.com}. Note that it is true that all public suffixes <i>have</i> registry\n", "   * suffixes, since domain name registries collectively control all internet domain names.\n", "   *\n", "   * <p>For considerations on whether the public suffix or registry suffix designation is more\n", "   * suitable for your application, see <a\n", "   * href=\"https://github.com/google/guava/wiki/InternetDomainNameExplained\">this article</a>.\n", "   *\n", "   * @return {@code true} if this domain name appears exactly on the public suffix list as part of\n", "   *     the registry suffix section (labelled \"ICANN\").\n", "   * @since NEXT\n", "   */\n", "  public boolean isRegistrySuffix() {\n", "    return registrySuffixIndex == 0;\n", "  }\n", "\n", "  /**\n", "   * Indicates whether this domain name ends in a {@linkplain #isRegistrySuffix() registry suffix},\n", "   * including if it is a registry suffix itself. For example, returns {@code true} for {@code\n", "   * www.google.com}, {@code foo.co.uk} and {@code com}, but not for {@code invalid} or {@code\n", "   * google.invalid}.\n", "   *\n", "   * <p>Note that this method is equivalent to {@link #hasPublicSuffix()} because all registry\n", "   * suffixes are public suffixes <i>and</i> all public suffixes have registry suffixes.\n", "   *\n", "   * @since NEXT\n", "   */\n", "  public boolean hasRegistrySuffix() {\n", "    return registrySuffixIndex != NO_SUFFIX_FOUND;\n", "  }\n", "\n", "  /**\n", "   * Returns the {@linkplain #isRegistrySuffix() registry suffix} portion of the domain name, or\n", "   * {@code null} if no registry suffix is present.\n", "   *\n", "   * @since NEXT\n", "   */\n", "  public InternetDomainName registrySuffix() {\n", "    return hasRegistrySuffix() ? ancestor(registrySuffixIndex) : null;\n", "  }\n", "\n", "  /**\n", "   * Indicates whether this domain name ends in a {@linkplain #isRegistrySuffix() registry suffix},\n", "   * while not being a registry suffix itself. For example, returns {@code true} for {@code\n", "   * www.google.com}, {@code foo.co.uk} and {@code blogspot.com}, but not for {@code com}, {@code\n", "   * co.uk}, or {@code google.invalid}.\n", "   *\n", "   * @since NEXT\n", "   */\n", "  public boolean isUnderRegistrySuffix() {\n", "    return registrySuffixIndex > 0;\n", "  }\n", "\n", "  /**\n", "   * Indicates whether this domain name is composed of exactly one subdomain component followed by a\n", "   * {@linkplain #isRegistrySuffix() registry suffix}. For example, returns {@code true} for {@code\n", "   * google.com}, {@code foo.co.uk}, and {@code blogspot.com}, but not for {@code www.google.com},\n", "   * {@code co.uk}, or {@code myblog.blogspot.com}.\n", "   *\n", "   * <p><b>Warning:</b> This method should not be used to determine the probable highest level\n", "   * parent domain for which cookies may be set. Use {@link #topPrivateDomain()} for that purpose.\n", "   *\n", "   * @since NEXT\n", "   */\n", "  public boolean isTopDomainUnderRegistrySuffix() {\n", "    return registrySuffixIndex == 1;\n", "  }\n", "\n", "  /**\n", "   * Returns the portion of this domain name that is one level beneath the {@linkplain\n", "   * #isRegistrySuffix() registry suffix}. For example, for {@code x.adwords.google.co.uk} it\n", "   * returns {@code google.co.uk}, since {@code co.uk} is a registry suffix. Similarly, for {@code\n", "   * myblog.blogspot.com} it returns {@code blogspot.com}, since {@code com} is a registry suffix.\n", "   *\n", "   * <p>If {@link #isTopDomainUnderRegistrySuffix()} is true, the current domain name instance is\n", "   * returned.\n", "   *\n", "   * <p><b>Warning:</b> This method should not be used to determine whether a domain is probably the\n", "   * highest level for which cookies may be set. Use {@link #isTopPrivateDomain()} for that purpose.\n", "   *\n", "   * @throws IllegalStateException if this domain does not end with a registry suffix\n", "   * @since NEXT\n", "   */\n", "  public InternetDomainName topDomainUnderRegistrySuffix() {\n", "    if (isTopDomainUnderRegistrySuffix()) {\n", "      return this;\n", "    }\n", "    checkState(isUnderRegistrySuffix(), \"Not under a registry suffix: %s\", name);\n", "    return ancestor(registrySuffixIndex - 1);\n", "  }\n", "\n"], "13": ["   * Does the domain name match one of the \"wildcard\" patterns (e.g. {@code \"*.ar\"})? If a {@code\n", "   * desiredType} is specified, the wildcard pattern must also match that type.\n", "  private static boolean matchesWildcardSuffixType(\n", "      Optional<PublicSuffixType> desiredType, String domain) {\n", "    return pieces.length == 2\n", "        && matchesType(\n", "            desiredType, Optional.fromNullable(PublicSuffixPatterns.UNDER.get(pieces[1])));\n", "  }\n", "\n", "  /**\n", "   * If a {@code desiredType} is specified, returns true only if the {@code actualType} is\n", "   * identical. Otherwise, returns true as long as {@code actualType} is present.\n", "   */\n", "  private static boolean matchesType(\n", "      Optional<PublicSuffixType> desiredType, Optional<PublicSuffixType> actualType) {\n", "    return desiredType.isPresent() ? desiredType.equals(actualType) : actualType.isPresent();\n"]}, "removed": {"1": [" * An immutable well-formed internet domain name, such as {@code com} or {@code\n", " * foo.co.uk}. Only syntactic analysis is performed; no DNS lookups or other network interactions\n", " * take place. Thus there is no guarantee that the domain actually exists on the internet.\n"], "2": [" * As a result, the only useful test to determine if a domain is a plausible web host is\n", " * {@link #hasPublicSuffix()}. This will return {@code true} for many domains which (currently) are\n", " * not hosts, such as {@code \"com\"}, but given that any public suffix may become a host without\n", " * warning, it is better to err on the side of permissiveness and thus avoid spurious rejection of\n", " * valid sites.\n", " * <li>ASCII uppercase characters are converted to lowercase.\n", " * <li>Unicode dot separators other than the ASCII period ({@code '.'}) are converted to the ASCII\n", " *     period.\n", " * names</a> such as {@code \u7f51\u7edc.cn} are supported, as are the equivalent\n", " * <a href=\"http://en.wikipedia.org/wiki/Internationalized_domain_name\">IDNA Punycode-encoded</a>\n"], "3": ["   * Value of {@link #publicSuffixIndex} which indicates that no public suffix was found.\n", "  private static final int NO_PUBLIC_SUFFIX_FOUND = -1;\n"], "4": ["   * domain name {@code www.google.co.uk}, the value would be 2 (the index of the {@code co} part).\n", "   * The value is negative (specifically, {@link #NO_PUBLIC_SUFFIX_FOUND}) if no public suffix was\n", "   * found.\n"], "5": ["    this.publicSuffixIndex = findPublicSuffix();\n", "   * Returns the index of the leftmost part of the public suffix, or -1 if not found. Note that the\n", "   * value defined as the \"public suffix\" may not be a public suffix according to\n", "   * {@link #isPublicSuffix()} if the domain ends with an excluded domain pattern such as\n", "   * {@code \"nhs.uk\"}.\n", "  private int findPublicSuffix() {\n", "      if (PublicSuffixPatterns.EXACT.containsKey(ancestorName)) {\n"], "6": ["      if (matchesWildcardPublicSuffix(ancestorName)) {\n", "    return NO_PUBLIC_SUFFIX_FOUND;\n", "   * (\"Internationalizing Domain Names in Applications\") is skipped, while validation against\n", "   * <a href=\"http://www.ietf.org/rfc/rfc1035.txt\">RFC 1035</a> is relaxed in the following ways:\n", "   * <li>Any part containing non-ASCII characters is considered valid.\n", "   * <li>Underscores ('_') are permitted wherever dashes ('-') are permitted.\n", "   * <li>Parts other than the final part may start with a digit, as mandated by\n", "   * <a href=\"https://tools.ietf.org/html/rfc1123#section-2\">RFC 1123</a>.\n", "   * @throws IllegalArgumentException if {@code name} is not syntactically valid according to\n", "   *     {@link #isValid}\n"], "7": ["   * is one under which Internet users can directly register names, such as {@code com},\n", "   * {@code co.uk} or {@code pvt.k12.wy.us}. Examples of domain names that are <i>not</i> public\n", "   * suffixes include {@code google}, {@code google.com} and {@code foo.co.uk}.\n"], "8": ["   * including if it is a public suffix itself. For example, returns {@code true} for\n", "   * {@code www.google.com}, {@code foo.co.uk} and {@code com}, but not for {@code invalid} or\n", "   * {@code google.invalid}. This is the recommended method for determining whether a domain is\n", "   * potentially an addressable host.\n", "    return publicSuffixIndex != NO_PUBLIC_SUFFIX_FOUND;\n"], "9": ["   * while not being a public suffix itself. For example, returns {@code true} for\n", "   * {@code www.google.com}, {@code foo.co.uk} and {@code bar.ca.us}, but not for {@code google},\n", "   * {@code com}, or {@code\n", "   * google.foo}.\n", "   *\n", "   * <p><b>Warning:</b> a {@code false} result from this method does not imply that the domain does\n", "   * not represent an addressable host, as many public suffixes are also addressable hosts. Use\n", "   * {@link #hasPublicSuffix()} for that test.\n"], "10": ["   * {@linkplain #isPublicSuffix() public suffix}. For example, returns {@code true} for\n", "   * {@code google.com} and {@code foo.co.uk}, but not for {@code www.google.com} or {@code co.uk}.\n", "   *\n", "   * <p><b>Warning:</b> A {@code true} result from this method does not imply that the domain is at\n", "   * the highest level which is addressable as a host, as many public suffixes are also addressable\n", "   * hosts. For example, the domain {@code bar.uk.com} has a public suffix of {@code uk.com}, so it\n", "   * would return {@code true} from this method. But {@code uk.com} is itself an addressable host.\n"], "11": ["   * Returns the portion of this domain name that is one level beneath the public suffix. For\n", "   * example, for {@code x.adwords.google.co.uk} it returns {@code google.co.uk}, since\n", "   * {@code co.uk} is a public suffix.\n", "   * <p>This method should not be used to determine the topmost parent domain which is addressable\n", "   * as a host, as many public suffixes are also addressable hosts. For example, the domain\n", "   * {@code foo.bar.uk.com} has a public suffix of {@code uk.com}, so it would return\n", "   * {@code bar.uk.com} from this method. But {@code uk.com} is itself an addressable host.\n", "   *\n"], "13": ["   * Does the domain name match one of the \"wildcard\" patterns (e.g. {@code \"*.ar\"})?\n", "  private static boolean matchesWildcardPublicSuffix(String domain) {\n", "    return pieces.length == 2 && PublicSuffixPatterns.UNDER.containsKey(pieces[1]);\n"]}, "added_lines": {"1": [26, 30, 35, 36, 37], "2": [45, 46, 47, 48, 49, 50, 51, 52, 57, 58, 59, 66, 67], "3": [82, 83, 85], "4": [121, 122, 123, 127, 128, 129, 130, 131, 132, 133, 134], "5": [157, 158, 162, 163, 164, 165, 166, 167, 168, 170, 176, 177], "6": [188, 193, 199, 200, 201, 203, 204, 205, 206, 211, 212], "7": [315, 316, 317, 318, 319, 320, 321, 322, 323, 324, 325, 326, 327], "8": [338, 339, 340, 341, 342, 343, 344, 349], "9": [364, 365, 366], "10": [380, 381, 382], "11": [395, 396, 397, 398, 399], "12": [418, 419, 420, 421, 422, 423, 424, 425, 426, 427, 428, 429, 430, 431, 432, 433, 434, 435, 436, 437, 438, 439, 440, 441, 442, 443, 444, 445, 446, 447, 448, 449, 450, 451, 452, 453, 454, 455, 456, 457, 458, 459, 460, 461, 462, 463, 464, 465, 466, 467, 468, 469, 470, 471, 472, 473, 474, 475, 476, 477, 478, 479, 480, 481, 482, 483, 484, 485, 486, 487, 488, 489, 490, 491, 492, 493, 494, 495, 496, 497, 498, 499, 500, 501, 502, 503, 504, 505, 506, 507, 508, 509, 510, 511, 512, 513, 514, 515, 516, 517, 518, 519], "13": [595, 596, 598, 599, 601, 602, 603, 604, 605, 606, 607, 608, 609, 610, 611, 612]}, "removed_lines": {"1": [33, 34, 35], "2": [43, 44, 45, 46, 47, 52, 53, 54, 61, 62], "3": [77, 79], "4": [115, 116, 117], "5": [143, 147, 148, 149, 150, 152, 158], "6": [169, 174, 180, 181, 183, 184, 185, 186, 191, 192], "7": [295, 296, 297], "8": [308, 309, 310, 311, 316], "9": [331, 332, 333, 334, 335, 336, 337, 338], "10": [352, 353, 354, 355, 356, 357, 358], "11": [371, 372, 373, 377, 378, 379, 380, 381], "13": [472, 474, 476]}}, {"8": "guava/src/com/google/thirdparty/publicsuffix/PublicSuffixType.java", "added": {"1": ["import com.google.common.annotations.Beta;\n", " * <b>Do not use this class directly. For access to public-suffix information,\n", " * use {@link com.google.common.net.InternetDomainName}.</b>\n", " *\n", " * <p>Specifies the type of a top-level domain definition.\n", " *\n", " * @since NEXT\n", "@Beta\n", "public enum PublicSuffixType {\n", "  /** Public suffix that is provided by a private company, e.g. \"blogspot.com\" */\n", "  /** Public suffix that is backed by an ICANN-style domain name registry */\n", "  REGISTRY('!', '?');\n"], "2": ["    return isPrivate ? PRIVATE : REGISTRY;\n"]}, "removed": {"1": [" * Specifies the type of a top-level domain definition.\n", "enum PublicSuffixType {\n", "  /** private definition of a top-level domain */\n", "  /** ICANN definition of a top-level domain */\n", "  ICANN('!', '?');\n"], "2": ["    return isPrivate ? PRIVATE : ICANN;\n"]}, "added_lines": {"1": [17, 21, 22, 23, 24, 25, 26, 28, 30, 32, 34, 35], "2": [67]}, "removed_lines": {"1": [20, 23, 25, 27, 28], "2": [60]}}, {"9": "guava/src/com/google/thirdparty/publicsuffix/TrieParser.java", "added": {"1": ["      // '!' represents an interior node that represents a REGISTRY entry in the map.\n", "      // '?' represents a leaf node, which represents a REGISTRY entry in map.\n"]}, "removed": {"1": ["      // '!' represents an interior node that represents an ICANN entry in the map.\n", "      // '?' represents a leaf node, which represents an ICANN entry in map.\n"]}, "added_lines": {"1": [76, 77]}, "removed_lines": {"1": [77, 78]}}]}
