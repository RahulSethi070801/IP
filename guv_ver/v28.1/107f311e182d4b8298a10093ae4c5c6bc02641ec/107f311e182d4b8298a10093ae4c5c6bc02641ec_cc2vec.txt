{"id": "107f311e182d4b8298a10093ae4c5c6bc02641ec", "code": [{"0": "android/guava-tests/test/com/google/common/util/concurrent/FluentFutureTest.java", "added": {"1": ["/*\n", " * Copyright (C) 2016 The Guava Authors\n", " *\n", " * Licensed under the Apache License, Version 2.0 (the \"License\");\n", " * you may not use this file except in compliance with the License.\n", " * You may obtain a copy of the License at\n", " *\n", " * http://www.apache.org/licenses/LICENSE-2.0\n", " *\n", " * Unless required by applicable law or agreed to in writing, software\n", " * distributed under the License is distributed on an \"AS IS\" BASIS,\n", " * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n", " * See the License for the specific language governing permissions and\n", " * limitations under the License.\n", " */\n", "\n", "package com.google.common.util.concurrent;\n", "\n", "import static com.google.common.base.Verify.verify;\n", "import static com.google.common.truth.Truth.assertThat;\n", "import static com.google.common.util.concurrent.Futures.immediateFailedFuture;\n", "import static com.google.common.util.concurrent.Futures.immediateFuture;\n", "import static com.google.common.util.concurrent.MoreExecutors.directExecutor;\n", "import static java.util.concurrent.Executors.newScheduledThreadPool;\n", "import static java.util.concurrent.TimeUnit.SECONDS;\n", "\n", "import com.google.common.annotations.GwtCompatible;\n", "import com.google.common.annotations.GwtIncompatible;\n", "import com.google.common.base.Function;\n", "import com.google.common.util.concurrent.ForwardingListenableFuture.SimpleForwardingListenableFuture;\n", "import java.util.concurrent.ExecutionException;\n", "import java.util.concurrent.ScheduledExecutorService;\n", "import java.util.concurrent.TimeoutException;\n", "import junit.framework.TestCase;\n", "\n", "/**\n", " * Tests for {@link FluentFuture}. The tests cover only the basics for the API. The actual logic is\n", " * tested in {@link FuturesTest}.\n", " */\n", "@GwtCompatible(emulated = true)\n", "public class FluentFutureTest extends TestCase {\n", "  public void testFromFluentFuture() {\n", "    FluentFuture<String> f = SettableFuture.create();\n", "    assertThat(FluentFuture.from(f)).isSameAs(f);\n", "  }\n", "\n", "  public void testFromNonFluentFuture() throws Exception {\n", "    ListenableFuture<String> f =\n", "        new SimpleForwardingListenableFuture<String>(immediateFuture(\"a\")) {};\n", "    verify(!(f instanceof FluentFuture));\n", "    assertThat(FluentFuture.from(f).get()).isEqualTo(\"a\");\n", "    // TODO(cpovirk): Test forwarding more extensively.\n", "  }\n", "\n", "  public void testAddCallback() {\n", "    FluentFuture<String> f = FluentFuture.from(immediateFuture(\"a\"));\n", "    final boolean[] called = new boolean[1];\n", "    f.addCallback(\n", "        new FutureCallback<String>() {\n", "          @Override\n", "          public void onSuccess(String result) {\n", "            called[0] = true;\n", "          }\n", "\n", "          @Override\n", "          public void onFailure(Throwable t) {}\n", "        },\n", "        directExecutor());\n", "    assertThat(called[0]).isTrue();\n", "  }\n", "\n", "  public void testCatching() throws Exception {\n", "    FluentFuture<?> f =\n", "        FluentFuture.from(immediateFailedFuture(new RuntimeException()))\n", "            .catching(\n", "                Throwable.class,\n", "                new Function<Throwable, Class<?>>() {\n", "                  @Override\n", "                  public Class<?> apply(Throwable input) {\n", "                    return input.getClass();\n", "                  }\n", "                },\n", "                directExecutor());\n", "    assertThat(f.get()).isEqualTo(RuntimeException.class);\n", "  }\n", "\n", "  public void testCatchingAsync() throws Exception {\n", "    FluentFuture<?> f =\n", "        FluentFuture.from(immediateFailedFuture(new RuntimeException()))\n", "            .catchingAsync(\n", "                Throwable.class,\n", "                new AsyncFunction<Throwable, Class<?>>() {\n", "                  @Override\n", "                  public ListenableFuture<Class<?>> apply(Throwable input) {\n", "                    return Futures.<Class<?>>immediateFuture(input.getClass());\n", "                  }\n", "                },\n", "                directExecutor());\n", "    assertThat(f.get()).isEqualTo(RuntimeException.class);\n", "  }\n", "\n", "  public void testTransform() throws Exception {\n", "    FluentFuture<Integer> f =\n", "        FluentFuture.from(immediateFuture(1))\n", "            .transform(\n", "                new Function<Integer, Integer>() {\n", "                  @Override\n", "                  public Integer apply(Integer input) {\n", "                    return input + 1;\n", "                  }\n", "                },\n", "                directExecutor());\n", "    assertThat(f.get()).isEqualTo(2);\n", "  }\n", "\n", "  public void testTransformAsync() throws Exception {\n", "    FluentFuture<Integer> f =\n", "        FluentFuture.from(immediateFuture(1))\n", "            .transformAsync(\n", "                new AsyncFunction<Integer, Integer>() {\n", "                  @Override\n", "                  public ListenableFuture<Integer> apply(Integer input) {\n", "                    return immediateFuture(input + 1);\n", "                  }\n", "                },\n", "                directExecutor());\n", "    assertThat(f.get()).isEqualTo(2);\n", "  }\n", "\n", "  @GwtIncompatible // withTimeout\n", "  public void testWithTimeout() throws Exception {\n", "    ScheduledExecutorService executor = newScheduledThreadPool(1);\n", "    try {\n", "      FluentFuture<?> f = SettableFuture.create().withTimeout(0, SECONDS, executor);\n", "      try {\n", "        f.get();\n", "        fail();\n", "      } catch (ExecutionException e) {\n", "        assertThat(e.getCause()).isInstanceOf(TimeoutException.class);\n", "      }\n", "    } finally {\n", "      executor.shutdown();\n", "    }\n", "  }\n", "}\n"]}, "removed": {}, "added_lines": {"1": [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 58, 59, 60, 61, 62, 63, 64, 65, 66, 67, 68, 69, 70, 71, 72, 73, 74, 75, 76, 77, 78, 79, 80, 81, 82, 83, 84, 85, 86, 87, 88, 89, 90, 91, 92, 93, 94, 95, 96, 97, 98, 99, 100, 101, 102, 103, 104, 105, 106, 107, 108, 109, 110, 111, 112, 113, 114, 115, 116, 117, 118, 119, 120, 121, 122, 123, 124, 125, 126, 127, 128, 129, 130, 131, 132, 133, 134, 135, 136, 137, 138, 139, 140, 141, 142, 143, 144, 145]}, "removed_lines": {}}, {"1": "android/guava/src/com/google/common/util/concurrent/AbstractFuture.java", "added": {"1": ["public abstract class AbstractFuture<V> extends FluentFuture<V> {\n"]}, "removed": {"1": ["public abstract class AbstractFuture<V> implements ListenableFuture<V> {\n"]}, "added_lines": {"1": [65]}, "removed_lines": {"1": [65]}}, {"2": "android/guava/src/com/google/common/util/concurrent/FluentFuture.java", "added": {"1": ["/*\n", " * Copyright (C) 2006 The Guava Authors\n", " *\n", " * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not use this file except\n", " * in compliance with the License. You may obtain a copy of the License at\n", " *\n", " * http://www.apache.org/licenses/LICENSE-2.0\n", " *\n", " * Unless required by applicable law or agreed to in writing, software distributed under the License\n", " * is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express\n", " * or implied. See the License for the specific language governing permissions and limitations under\n", " * the License.\n", " */\n", "\n", "package com.google.common.util.concurrent;\n", "\n", "import com.google.common.annotations.Beta;\n", "import com.google.common.annotations.GwtCompatible;\n", "import com.google.common.annotations.GwtIncompatible;\n", "import com.google.common.base.Function;\n", "import com.google.errorprone.annotations.DoNotMock;\n", "import java.util.concurrent.ExecutionException;\n", "import java.util.concurrent.Executor;\n", "import java.util.concurrent.ScheduledExecutorService;\n", "import java.util.concurrent.TimeUnit;\n", "import java.util.concurrent.TimeoutException;\n", "\n", "/**\n", " * A {@link ListenableFuture} that supports fluent chains of operations. For example:\n", " *\n", " * <pre>{@code\n", " * ListenableFuture<Boolean> adminIsLoggedIn =\n", " *     FluentFuture.from(usersDatabase.getAdminUser())\n", " *         .transform(User::getId, directExecutor())\n", " *         .transform(ActivityService::isLoggedIn, threadPool)\n", " *         .catching(RpcException.class, e -> false, directExecutor());\n", " * }</pre>\n", " *\n", " * <h3>Alternatives</h3>\n", " *\n", " * <h4>Frameworks</h4>\n", " *\n", " * <p>When chaining together a graph of asynchronous operations, you will often find it easier to\n", " * use a framework. Frameworks automate the process, often adding features like monitoring,\n", " * debugging, and cancellation. Examples of frameworks include:\n", " *\n", " * <ul>\n", " *   <li><a href=\"http://google.github.io/dagger/producers.html\">Dagger Producers</a>\n", " * </ul>\n", " *\n", " * <h4>{@link java.util.concurrent.CompletableFuture} / {@link java.util.concurrent.CompletionStage}\n", " * </h4>\n", " *\n", " * <p>Users of {@code CompletableFuture} will likely want to continue using {@code\n", " * CompletableFuture}. {@code FluentFuture} is targeted at people who use {@code ListenableFuture},\n", " * who can't use Java 8, or who want an API more focused than {@code CompletableFuture}. (If you\n", " * need to adapt between {@code CompletableFuture} and {@code ListenableFuture}, consider <a\n", " * href=\"https://github.com/lukas-krecan/future-converter\">Future Converter</a>.)\n", " *\n", " * <h3>Extension</h3>\n", " *\n", " * If you want a class like {@code FluentFuture} but with extra methods, we recommend declaring your\n", " * own subclass of {@link ListenableFuture}, complete with a method like {@link #from} to adapt an\n", " * existing {@code ListenableFuture}, implemented atop a {@link ForwardingListenableFuture} that\n", " * forwards to that future and adds the desired methods.\n", " *\n", " * @since 22.0\n", " */\n", "@Beta\n", "@DoNotMock(\"Use FluentFuture.from(Futures.immediate*Future) or SettableFuture\")\n", "@GwtCompatible(emulated = true)\n", "public abstract class FluentFuture<V> extends GwtFluentFutureCatchingSpecialization<V> {\n", "  FluentFuture() {}\n", "\n", "  /**\n", "   * Converts the given {@code ListenableFuture} to an equivalent {@code FluentFuture}.\n", "   *\n", "   * <p>If the given {@code ListenableFuture} is already a {@code FluentFuture}, it is returned\n", "   * directly. If not, it is wrapped in a {@code FluentFuture} that delegates all calls to the\n", "   * original {@code ListenableFuture}.\n", "   */\n", "  public static <V> FluentFuture<V> from(ListenableFuture<V> future) {\n", "    return future instanceof FluentFuture\n", "        ? (FluentFuture<V>) future\n", "        : new ForwardingFluentFuture<V>(future);\n", "  }\n", "\n", "  /**\n", "   * Returns a {@code Future} whose result is taken from this {@code Future} or, if this {@code\n", "   * Future} fails with the given {@code exceptionType}, from the result provided by the {@code\n", "   * fallback}. {@link Function#apply} is not invoked until the primary input has failed, so if the\n", "   * primary input succeeds, it is never invoked. If, during the invocation of {@code fallback}, an\n", "   * exception is thrown, this exception is used as the result of the output {@code Future}.\n", "   *\n", "   * <p>Usage example:\n", "   *\n", "   * <pre>{@code\n", "   * // Falling back to a zero counter in case an exception happens when processing the RPC to fetch\n", "   * // counters.\n", "   * ListenableFuture<Integer> faultTolerantFuture =\n", "   *     fetchCounters().catching(FetchException.class, x -> 0, directExecutor());\n", "   * }</pre>\n", "   *\n", "   * <p>When selecting an executor, note that {@code directExecutor} is dangerous in some cases. See\n", "   * the discussion in the {@link #addListener} documentation. All its warnings about heavyweight\n", "   * listeners are also applicable to heavyweight functions passed to this method.\n", "   *\n", "   * <p>This method is similar to {@link java.util.concurrent.CompletableFuture#exceptionally}. It\n", "   * can also serve some of the use cases of {@link java.util.concurrent.CompletableFuture#handle}\n", "   * and {@link java.util.concurrent.CompletableFuture#handleAsync} when used along with {@link\n", "   * #transform}.\n", "   *\n", "   * @param exceptionType the exception type that triggers use of {@code fallback}. The exception\n", "   *     type is matched against the input's exception. \"The input's exception\" means the cause of\n", "   *     the {@link ExecutionException} thrown by {@code input.get()} or, if {@code get()} throws a\n", "   *     different kind of exception, that exception itself. To avoid hiding bugs and other\n", "   *     unrecoverable errors, callers should prefer more specific types, avoiding {@code\n", "   *     Throwable.class} in particular.\n", "   * @param fallback the {@link Function} to be called if the input fails with the expected\n", "   *     exception type. The function's argument is the input's exception. \"The input's exception\"\n", "   *     means the cause of the {@link ExecutionException} thrown by {@code this.get()} or, if\n", "   *     {@code get()} throws a different kind of exception, that exception itself.\n", "   * @param executor the executor that runs {@code fallback} if the input fails\n", "   */\n", "  @Partially.GwtIncompatible(\"AVAILABLE but requires exceptionType to be Throwable.class\")\n", "  public final <X extends Throwable> FluentFuture<V> catching(\n", "      Class<X> exceptionType, Function<? super X, ? extends V> fallback, Executor executor) {\n", "    return (FluentFuture<V>) Futures.catching(this, exceptionType, fallback, executor);\n", "  }\n", "\n", "  /**\n", "   * Returns a {@code Future} whose result is taken from this {@code Future} or, if the this {@code\n", "   * Future} fails with the given {@code exceptionType}, from the result provided by the {@code\n", "   * fallback}. {@link AsyncFunction#apply} is not invoked until the primary input has failed, so if\n", "   * the primary input succeeds, it is never invoked. If, during the invocation of {@code fallback},\n", "   * an exception is thrown, this exception is used as the result of the output {@code Future}.\n", "   *\n", "   * <p>Usage examples:\n", "   *\n", "   * <pre>{@code\n", "   * // Falling back to a zero counter in case an exception happens when processing the RPC to fetch\n", "   * // counters.\n", "   * ListenableFuture<Integer> faultTolerantFuture =\n", "   *     fetchCounters().catchingAsync(\n", "   *         FetchException.class, x -> immediateFuture(0), directExecutor());\n", "   * }</pre>\n", "   *\n", "   * <p>The fallback can also choose to propagate the original exception when desired:\n", "   *\n", "   * <pre>{@code\n", "   * // Falling back to a zero counter only in case the exception was a\n", "   * // TimeoutException.\n", "   * ListenableFuture<Integer> faultTolerantFuture =\n", "   *     fetchCounters().catchingAsync(\n", "   *         fetchCounterFuture,\n", "   *         FetchException.class,\n", "   *         e -> {\n", "   *           if (omitDataOnFetchFailure) {\n", "   *             return immediateFuture(0);\n", "   *           }\n", "   *           throw e;\n", "   *         },\n", "   *         directExecutor());\n", "   * }</pre>\n", "   *\n", "   * <p>When selecting an executor, note that {@code directExecutor} is dangerous in some cases. See\n", "   * the discussion in the {@link #addListener} documentation. All its warnings about heavyweight\n", "   * listeners are also applicable to heavyweight functions passed to this method. (Specifically,\n", "   * {@code directExecutor} functions should avoid heavyweight operations inside {@code\n", "   * AsyncFunction.apply}. Any heavyweight operations should occur in other threads responsible for\n", "   * completing the returned {@code Future}.)\n", "   *\n", "   * <p>This method is similar to {@link java.util.concurrent.CompletableFuture#exceptionally}. It\n", "   * can also serve some of the use cases of {@link java.util.concurrent.CompletableFuture#handle}\n", "   * and {@link java.util.concurrent.CompletableFuture#handleAsync} when used along with {@link\n", "   * #transform}.\n", "   *\n", "   * @param exceptionType the exception type that triggers use of {@code fallback}. The exception\n", "   *     type is matched against the input's exception. \"The input's exception\" means the cause of\n", "   *     the {@link ExecutionException} thrown by {@code this.get()} or, if {@code get()} throws a\n", "   *     different kind of exception, that exception itself. To avoid hiding bugs and other\n", "   *     unrecoverable errors, callers should prefer more specific types, avoiding {@code\n", "   *     Throwable.class} in particular.\n", "   * @param fallback the {@link AsyncFunction} to be called if the input fails with the expected\n", "   *     exception type. The function's argument is the input's exception. \"The input's exception\"\n", "   *     means the cause of the {@link ExecutionException} thrown by {@code input.get()} or, if\n", "   *     {@code get()} throws a different kind of exception, that exception itself.\n", "   * @param executor the executor that runs {@code fallback} if the input fails\n", "   */\n", "  @Partially.GwtIncompatible(\"AVAILABLE but requires exceptionType to be Throwable.class\")\n", "  public final <X extends Throwable> FluentFuture<V> catchingAsync(\n", "      Class<X> exceptionType, AsyncFunction<? super X, ? extends V> fallback, Executor executor) {\n", "    return (FluentFuture<V>) Futures.catchingAsync(this, exceptionType, fallback, executor);\n", "  }\n", "\n", "  /**\n", "   * Returns a future that delegates to this future but will finish early (via a {@link\n", "   * TimeoutException} wrapped in an {@link ExecutionException}) if the specified timeout expires.\n", "   * If the timeout expires, not only will the output future finish, but also the input future\n", "   * ({@code this}) will be cancelled and interrupted.\n", "   *\n", "   * @param timeout when to time out the future\n", "   * @param unit the time unit of the time parameter\n", "   * @param scheduledExecutor The executor service to enforce the timeout.\n", "   */\n", "  @GwtIncompatible // ScheduledExecutorService\n", "  public final FluentFuture<V> withTimeout(\n", "      long timeout, TimeUnit unit, ScheduledExecutorService scheduledExecutor) {\n", "    return (FluentFuture<V>) Futures.withTimeout(this, timeout, unit, scheduledExecutor);\n", "  }\n", "\n", "  /**\n", "   * Returns a new {@code Future} whose result is asynchronously derived from the result of this\n", "   * {@code Future}. If the input {@code Future} fails, the returned {@code Future} fails with the\n", "   * same exception (and the function is not invoked).\n", "   *\n", "   * <p>More precisely, the returned {@code Future} takes its result from a {@code Future} produced\n", "   * by applying the given {@code AsyncFunction} to the result of the original {@code Future}.\n", "   * Example usage:\n", "   *\n", "   * <pre>{@code\n", "   * FluentFuture<RowKey> rowKeyFuture = FluentFuture.from(indexService.lookUp(query));\n", "   * ListenableFuture<QueryResult> queryFuture =\n", "   *     rowKeyFuture.transformAsync(dataService::readFuture, executor);\n", "   * }</pre>\n", "   *\n", "   * <p>When selecting an executor, note that {@code directExecutor} is dangerous in some cases. See\n", "   * the discussion in the {@link #addListener} documentation. All its warnings about heavyweight\n", "   * listeners are also applicable to heavyweight functions passed to this method. (Specifically,\n", "   * {@code directExecutor} functions should avoid heavyweight operations inside {@code\n", "   * AsyncFunction.apply}. Any heavyweight operations should occur in other threads responsible for\n", "   * completing the returned {@code Future}.)\n", "   *\n", "   * <p>The returned {@code Future} attempts to keep its cancellation state in sync with that of the\n", "   * input future and that of the future returned by the chain function. That is, if the returned\n", "   * {@code Future} is cancelled, it will attempt to cancel the other two, and if either of the\n", "   * other two is cancelled, the returned {@code Future} will receive a callback in which it will\n", "   * attempt to cancel itself.\n", "   *\n", "   * <p>This method is similar to {@link java.util.concurrent.CompletableFuture#thenCompose} and\n", "   * {@link java.util.concurrent.CompletableFuture#thenComposeAsync}. It can also serve some of the\n", "   * use cases of {@link java.util.concurrent.CompletableFuture#handle} and {@link\n", "   * java.util.concurrent.CompletableFuture#handleAsync} when used along with {@link #catching}.\n", "   *\n", "   * @param function A function to transform the result of this future to the result of the output\n", "   *     future\n", "   * @param executor Executor to run the function in.\n", "   * @return A future that holds result of the function (if the input succeeded) or the original\n", "   *     input's failure (if not)\n", "   */\n", "  public final <T> FluentFuture<T> transformAsync(\n", "      AsyncFunction<? super V, T> function, Executor executor) {\n", "    return (FluentFuture<T>) Futures.transformAsync(this, function, executor);\n", "  }\n", "\n", "  /**\n", "   * Returns a new {@code Future} whose result is derived from the result of this {@code Future}. If\n", "   * this input {@code Future} fails, the returned {@code Future} fails with the same exception (and\n", "   * the function is not invoked). Example usage:\n", "   *\n", "   * <pre>{@code\n", "   * ListenableFuture<List<Row>> rowsFuture =\n", "   *     queryFuture.transform(QueryResult::getRows, executor);\n", "   * }</pre>\n", "   *\n", "   * <p>When selecting an executor, note that {@code directExecutor} is dangerous in some cases. See\n", "   * the discussion in the {@link #addListener} documentation. All its warnings about heavyweight\n", "   * listeners are also applicable to heavyweight functions passed to this method.\n", "   *\n", "   * <p>The returned {@code Future} attempts to keep its cancellation state in sync with that of the\n", "   * input future. That is, if the returned {@code Future} is cancelled, it will attempt to cancel\n", "   * the input, and if the input is cancelled, the returned {@code Future} will receive a callback\n", "   * in which it will attempt to cancel itself.\n", "   *\n", "   * <p>An example use of this method is to convert a serializable object returned from an RPC into\n", "   * a POJO.\n", "   *\n", "   * <p>This method is similar to {@link java.util.concurrent.CompletableFuture#thenApply} and\n", "   * {@link java.util.concurrent.CompletableFuture#thenApplyAsync}. It can also serve some of the\n", "   * use cases of {@link java.util.concurrent.CompletableFuture#handle} and {@link\n", "   * java.util.concurrent.CompletableFuture#handleAsync} when used along with {@link #catching}.\n", "   *\n", "   * @param function A Function to transform the results of this future to the results of the\n", "   *     returned future.\n", "   * @param executor Executor to run the function in.\n", "   * @return A future that holds result of the transformation.\n", "   */\n", "  public final <T> FluentFuture<T> transform(Function<? super V, T> function, Executor executor) {\n", "    return (FluentFuture<T>) Futures.transform(this, function, executor);\n", "  }\n", "\n", "  /**\n", "   * Registers separate success and failure callbacks to be run when this {@code Future}'s\n", "   * computation is {@linkplain java.util.concurrent.Future#isDone() complete} or, if the\n", "   * computation is already complete, immediately.\n", "   *\n", "   * <p>The callback is run on {@code executor}. There is no guaranteed ordering of execution of\n", "   * callbacks, but any callback added through this method is guaranteed to be called once the\n", "   * computation is complete.\n", "   *\n", "   * <p>Example:\n", "   *\n", "   * <pre>{@code\n", "   * future.addCallback(\n", "   *     new FutureCallback<QueryResult>() {\n", "   *       public void onSuccess(QueryResult result) {\n", "   *         storeInCache(result);\n", "   *       }\n", "   *       public void onFailure(Throwable t) {\n", "   *         reportError(t);\n", "   *       }\n", "   *     }, executor);\n", "   * }</pre>\n", "   *\n", "   * <p>When selecting an executor, note that {@code directExecutor} is dangerous in some cases. See\n", "   * the discussion in the {@link #addListener} documentation. All its warnings about heavyweight\n", "   * listeners are also applicable to heavyweight callbacks passed to this method.\n", "   *\n", "   * <p>For a more general interface to attach a completion listener, see {@link #addListener}.\n", "   *\n", "   * <p>This method is similar to {@link java.util.concurrent.CompletableFuture#whenComplete} and\n", "   * {@link java.util.concurrent.CompletableFuture#whenCompleteAsync}. It also serves the use case\n", "   * of {@link java.util.concurrent.CompletableFuture#thenAccept} and {@link\n", "   * java.util.concurrent.CompletableFuture#thenAcceptAsync}.\n", "   *\n", "   * @param callback The callback to invoke when this {@code Future} is completed.\n", "   * @param executor The executor to run {@code callback} when the future completes.\n", "   */\n", "  public final void addCallback(FutureCallback<? super V> callback, Executor executor) {\n", "    Futures.addCallback(this, callback, executor);\n", "  }\n", "}\n"]}, "removed": {}, "added_lines": {"1": [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 58, 59, 60, 61, 62, 63, 64, 65, 66, 67, 68, 69, 70, 71, 72, 73, 74, 75, 76, 77, 78, 79, 80, 81, 82, 83, 84, 85, 86, 87, 88, 89, 90, 91, 92, 93, 94, 95, 96, 97, 98, 99, 100, 101, 102, 103, 104, 105, 106, 107, 108, 109, 110, 111, 112, 113, 114, 115, 116, 117, 118, 119, 120, 121, 122, 123, 124, 125, 126, 127, 128, 129, 130, 131, 132, 133, 134, 135, 136, 137, 138, 139, 140, 141, 142, 143, 144, 145, 146, 147, 148, 149, 150, 151, 152, 153, 154, 155, 156, 157, 158, 159, 160, 161, 162, 163, 164, 165, 166, 167, 168, 169, 170, 171, 172, 173, 174, 175, 176, 177, 178, 179, 180, 181, 182, 183, 184, 185, 186, 187, 188, 189, 190, 191, 192, 193, 194, 195, 196, 197, 198, 199, 200, 201, 202, 203, 204, 205, 206, 207, 208, 209, 210, 211, 212, 213, 214, 215, 216, 217, 218, 219, 220, 221, 222, 223, 224, 225, 226, 227, 228, 229, 230, 231, 232, 233, 234, 235, 236, 237, 238, 239, 240, 241, 242, 243, 244, 245, 246, 247, 248, 249, 250, 251, 252, 253, 254, 255, 256, 257, 258, 259, 260, 261, 262, 263, 264, 265, 266, 267, 268, 269, 270, 271, 272, 273, 274, 275, 276, 277, 278, 279, 280, 281, 282, 283, 284, 285, 286, 287, 288, 289, 290, 291, 292, 293, 294, 295, 296, 297, 298, 299, 300, 301, 302, 303, 304, 305, 306, 307, 308, 309, 310, 311, 312, 313, 314, 315, 316, 317, 318, 319, 320, 321, 322, 323, 324, 325, 326, 327, 328, 329, 330, 331, 332]}, "removed_lines": {}}, {"3": "android/guava/src/com/google/common/util/concurrent/ForwardingFluentFuture.java", "added": {"1": ["/*\n", " * Copyright (C) 2009 The Guava Authors\n", " *\n", " * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not use this file except\n", " * in compliance with the License. You may obtain a copy of the License at\n", " *\n", " * http://www.apache.org/licenses/LICENSE-2.0\n", " *\n", " * Unless required by applicable law or agreed to in writing, software distributed under the License\n", " * is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express\n", " * or implied. See the License for the specific language governing permissions and limitations under\n", " * the License.\n", " */\n", "\n", "package com.google.common.util.concurrent;\n", "\n", "import static com.google.common.base.Preconditions.checkNotNull;\n", "\n", "import com.google.common.annotations.GwtCompatible;\n", "import java.util.concurrent.ExecutionException;\n", "import java.util.concurrent.Executor;\n", "import java.util.concurrent.TimeUnit;\n", "import java.util.concurrent.TimeoutException;\n", "\n", "/**\n", " * {@link FluentFuture} that forwards all calls to a delegate.\n", " *\n", " * <h3>Extension</h3>\n", " *\n", " * If you want a class like {@code FluentFuture} but with extra methods, we recommend declaring your\n", " * own subclass of {@link ListenableFuture}, complete with a method like {@link #from} to adapt an\n", " * existing {@code ListenableFuture}, implemented atop a {@link ForwardingListenableFuture} that\n", " * forwards to that future and adds the desired methods.\n", " */\n", "@GwtCompatible\n", "final class ForwardingFluentFuture<V> extends FluentFuture<V> {\n", "  private final ListenableFuture<V> delegate;\n", "\n", "  ForwardingFluentFuture(ListenableFuture<V> delegate) {\n", "    this.delegate = checkNotNull(delegate);\n", "  }\n", "\n", "  @Override\n", "  public void addListener(Runnable listener, Executor executor) {\n", "    delegate.addListener(listener, executor);\n", "  }\n", "\n", "  @Override\n", "  public boolean cancel(boolean mayInterruptIfRunning) {\n", "    return delegate.cancel(mayInterruptIfRunning);\n", "  }\n", "\n", "  @Override\n", "  public boolean isCancelled() {\n", "    return delegate.isCancelled();\n", "  }\n", "\n", "  @Override\n", "  public boolean isDone() {\n", "    return delegate.isDone();\n", "  }\n", "\n", "  @Override\n", "  public V get() throws InterruptedException, ExecutionException {\n", "    return delegate.get();\n", "  }\n", "\n", "  @Override\n", "  public V get(long timeout, TimeUnit unit)\n", "      throws InterruptedException, ExecutionException, TimeoutException {\n", "    return delegate.get(timeout, unit);\n", "  }\n", "}\n"]}, "removed": {}, "added_lines": {"1": [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 58, 59, 60, 61, 62, 63, 64, 65, 66, 67, 68, 69, 70, 71, 72, 73]}, "removed_lines": {}}, {"4": "android/guava/src/com/google/common/util/concurrent/Futures.java", "added": {"1": [" * article on <a href=\"https://github.com/google/guava/wiki/ListenableFutureExplained\">{@code\n", " * ListenableFuture}</a>.\n", " *\n", " * <p>The main purpose of {@code ListenableFuture} is to help you chain together a graph of\n", " * asynchronous operations. You can chain them together manually with calls to methods like {@link\n", " * Futures#transform(ListenableFuture, Function, Executor) Futures.transform}, but you will often\n", " * find it easier to use a framework. Frameworks automate the process, often adding features like\n", " * monitoring, debugging, and cancellation. Examples of frameworks include:\n", " *\n", " * <ul>\n", " *   <li><a href=\"http://google.github.io/dagger/producers.html\">Dagger Producers</a>\n", " * </ul>\n", " *\n", " * <p>If you do chain your operations manually, you may want to use {@link FluentFuture}.\n"], "2": ["   *     fetchCounterFuture, FetchException.class, x -> 0);\n", "   * ListenableFuture.addListener} documentation. All its warnings about heavyweight listeners are\n", "   * also applicable to heavyweight functions passed to this method.\n"], "3": ["   * <pre>{@code\n", "   * ListenableFuture<Integer> fetchCounterFuture = ...;\n", "   *\n", "   * // Falling back to a zero counter in case an exception happens when\n", "   * // processing the RPC to fetch counters.\n", "   * ListenableFuture<Integer> faultTolerantFuture = Futures.catching(\n", "   *     fetchCounterFuture, FetchException.class, x -> 0, directExecutor());\n", "   * }</pre>\n", "   * documentation. All its warnings about heavyweight listeners are also applicable to heavyweight\n", "   * functions passed to this method.\n"], "4": ["   *     fetchCounterFuture, FetchException.class, x -> immediateFuture(0));\n"], "5": ["   *     fetchCounterFuture,\n", "   *     FetchException.class,\n", "   *     e -> {\n", "   *       if (omitDataOnFetchFailure) {\n", "   *         return immediateFuture(0);\n", "   *       throw e;\n", "   * ListenableFuture.addListener} documentation. All its warnings about heavyweight listeners are\n", "   * also applicable to heavyweight functions passed to this method. (Specifically, {@code\n", "   * directExecutor} functions should avoid heavyweight operations inside {@code\n", "   * AsyncFunction.apply}. Any heavyweight operations should occur in other threads responsible for\n", "   * completing the returned {@code Future}.)\n"], "6": ["   * <pre>{@code\n", "   * ListenableFuture<Integer> fetchCounterFuture = ...;\n", "   *\n", "   * // Falling back to a zero counter in case an exception happens when\n", "   * // processing the RPC to fetch counters.\n", "   * ListenableFuture<Integer> faultTolerantFuture = Futures.catchingAsync(\n", "   *     fetchCounterFuture, FetchException.class, x -> immediateFuture(0), directExecutor());\n", "   * }</pre>\n", "   * <pre>{@code\n", "   * ListenableFuture<Integer> fetchCounterFuture = ...;\n", "   *\n", "   * // Falling back to a zero counter only in case the exception was a\n", "   * // TimeoutException.\n", "   * ListenableFuture<Integer> faultTolerantFuture = Futures.catchingAsync(\n", "   *     fetchCounterFuture,\n", "   *     FetchException.class,\n", "   *     e -> {\n", "   *       if (omitDataOnFetchFailure) {\n", "   *         return immediateFuture(0);\n", "   *       }\n", "   *       throw e;\n", "   *     },\n", "   *     directExecutor());\n", "   * }</pre>\n", "   * documentation. All its warnings about heavyweight listeners are also applicable to heavyweight\n", "   * functions passed to this method. (Specifically, {@code directExecutor} functions should avoid\n", "   * heavyweight operations inside {@code AsyncFunction.apply}. Any heavyweight operations should\n", "   * occur in other threads responsible for completing the returned {@code Future}.)\n"], "8": ["   *     transformAsync(rowKeyFuture, dataService::readFuture);\n", "   * ListenableFuture.addListener} documentation. All its warnings about heavyweight listeners are\n", "   * also applicable to heavyweight functions passed to this method. (Specifically, {@code\n", "   * directExecutor} functions should avoid heavyweight operations inside {@code\n", "   * AsyncFunction.apply}. Any heavyweight operations should occur in other threads responsible for\n", "   * completing the returned {@code Future}.)\n"], "9": ["   * <pre>{@code\n", "   * ListenableFuture<RowKey> rowKeyFuture = indexService.lookUp(query);\n", "   * ListenableFuture<QueryResult> queryFuture =\n", "   *     transformAsync(rowKeyFuture, dataService::readFuture, executor);\n", "   * }</pre>\n", "   * documentation. All its warnings about heavyweight listeners are also applicable to heavyweight\n", "   * functions passed to this method. (Specifically, {@code directExecutor} functions should avoid\n", "   * heavyweight operations inside {@code AsyncFunction.apply}. Any heavyweight operations should\n", "   * occur in other threads responsible for completing the returned {@code Future}.)\n"], "10": ["   *     transform(queryFuture, QueryResult::getRows);\n", "   * ListenableFuture.addListener} documentation. All its warnings about heavyweight listeners are\n", "   * also applicable to heavyweight functions passed to this method.\n"], "11": ["   * <pre>{@code\n", "   * ListenableFuture<QueryResult> queryFuture = ...;\n", "   * ListenableFuture<List<Row>> rowsFuture =\n", "   *     transform(queryFuture, QueryResult::getRows, executor);\n", "   * }</pre>\n", "   * documentation. All its warnings about heavyweight listeners are also applicable to heavyweight\n", "   * functions passed to this method.\n"], "12": ["   * ListenableFuture.addListener} documentation. All its warnings about heavyweight listeners are\n", "   * also applicable to heavyweight callbacks passed to this method.\n"], "13": ["   * <p>The callback is run on {@code executor}. There is no guaranteed ordering of execution of\n", "   * <p>Example:\n", "   *\n", "   * <pre>{@code\n"], "14": ["   *     }, e);\n", "   * }</pre>\n", "   * documentation. All its warnings about heavyweight listeners are also applicable to heavyweight\n", "   * callbacks passed to this method.\n"]}, "removed": {"1": [" * article on <a href=\"https://github.com/google/guava/wiki/ListenableFutureExplained\">\n", " * {@code ListenableFuture}</a>.\n"], "2": ["   *     fetchCounterFuture, FetchException.class,\n", "   *     new Function<FetchException, Integer>() {\n", "   *       public Integer apply(FetchException e) {\n", "   *         return 0;\n", "   *       }\n", "   *     });\n", "   * ListenableFuture.addListener} documentation. The documentation's warnings about \"lightweight\n", "   * listeners\" refer here to the work done during {@code Function.apply}.\n"], "3": ["   * <pre>   {@code\n", "   *   ListenableFuture<Integer> fetchCounterFuture = ...;\n", "   *\n", "   *   // Falling back to a zero counter in case an exception happens when\n", "   *   // processing the RPC to fetch counters.\n", "   *   ListenableFuture<Integer> faultTolerantFuture = Futures.catching(\n", "   *       fetchCounterFuture, FetchException.class,\n", "   *       new Function<FetchException, Integer>() {\n", "   *         public Integer apply(FetchException e) {\n", "   *           return 0;\n", "   *         }\n", "   *       }, directExecutor());}</pre>\n", "   * documentation. The documentation's warnings about \"lightweight listeners\" refer here to the\n", "   * work done during {@code Function.apply}.\n"], "4": ["   *     fetchCounterFuture, FetchException.class,\n", "   *     new AsyncFunction<FetchException, Integer>() {\n", "   *       public ListenableFuture<Integer> apply(FetchException e) {\n", "   *         return immediateFuture(0);\n", "   *       }\n", "   *     });\n"], "5": ["   *     fetchCounterFuture, FetchException.class,\n", "   *     new AsyncFunction<FetchException, Integer>() {\n", "   *       public ListenableFuture<Integer> apply(FetchException e)\n", "   *           throws FetchException {\n", "   *         if (omitDataOnFetchFailure) {\n", "   *           return immediateFuture(0);\n", "   *         }\n", "   *         throw e;\n", "   * ListenableFuture.addListener} documentation. The documentation's warnings about \"lightweight\n", "   * listeners\" refer here to the work done during {@code AsyncFunction.apply}, not to any work done\n", "   * to complete the returned {@code Future}.\n"], "6": ["   * <pre>   {@code\n", "   *   ListenableFuture<Integer> fetchCounterFuture = ...;\n", "   *\n", "   *   // Falling back to a zero counter in case an exception happens when\n", "   *   // processing the RPC to fetch counters.\n", "   *   ListenableFuture<Integer> faultTolerantFuture = Futures.catchingAsync(\n", "   *       fetchCounterFuture, FetchException.class,\n", "   *       new AsyncFunction<FetchException, Integer>() {\n", "   *         public ListenableFuture<Integer> apply(FetchException e) {\n", "   *           return immediateFuture(0);\n", "   *         }\n", "   *       }, directExecutor());}</pre>\n", "   * <pre>   {@code\n", "   *   ListenableFuture<Integer> fetchCounterFuture = ...;\n", "   *\n", "   *   // Falling back to a zero counter only in case the exception was a\n", "   *   // TimeoutException.\n", "   *   ListenableFuture<Integer> faultTolerantFuture = Futures.catchingAsync(\n", "   *       fetchCounterFuture, FetchException.class,\n", "   *       new AsyncFunction<FetchException, Integer>() {\n", "   *         public ListenableFuture<Integer> apply(FetchException e)\n", "   *             throws FetchException {\n", "   *           if (omitDataOnFetchFailure) {\n", "   *             return immediateFuture(0);\n", "   *           }\n", "   *           throw e;\n", "   *         }\n", "   *       }, directExecutor());}</pre>\n", "   * documentation. The documentation's warnings about \"lightweight listeners\" refer here to the\n", "   * work done during {@code AsyncFunction.apply}, not to any work done to complete the returned\n", "   * {@code Future}.\n"], "7": ["   *\n"], "8": ["   * AsyncFunction<RowKey, QueryResult> queryFunction =\n", "   *     new AsyncFunction<RowKey, QueryResult>() {\n", "   *       public ListenableFuture<QueryResult> apply(RowKey rowKey) {\n", "   *         return dataService.read(rowKey);\n", "   *       }\n", "   *     };\n", "   *     transformAsync(rowKeyFuture, queryFunction);\n", "   * ListenableFuture.addListener} documentation. The documentation's warnings about \"lightweight\n", "   * listeners\" refer here to the work done during {@code AsyncFunction.apply}, not to any work done\n", "   * to complete the returned {@code Future}.\n"], "9": ["   * <pre>   {@code\n", "   *   ListenableFuture<RowKey> rowKeyFuture = indexService.lookUp(query);\n", "   *   AsyncFunction<RowKey, QueryResult> queryFunction =\n", "   *       new AsyncFunction<RowKey, QueryResult>() {\n", "   *         public ListenableFuture<QueryResult> apply(RowKey rowKey) {\n", "   *           return dataService.read(rowKey);\n", "   *         }\n", "   *       };\n", "   *   ListenableFuture<QueryResult> queryFuture =\n", "   *       transformAsync(rowKeyFuture, queryFunction, executor);}</pre>\n", "   * documentation. The documentation's warnings about \"lightweight listeners\" refer here to the\n", "   * work done during {@code AsyncFunction.apply}, not to any work done to complete the returned\n", "   * {@code Future}.\n"], "10": ["   * Function<QueryResult, List<Row>> rowsFunction =\n", "   *     new Function<QueryResult, List<Row>>() {\n", "   *       public List<Row> apply(QueryResult queryResult) {\n", "   *         return queryResult.getRows();\n", "   *       }\n", "   *     };\n", "   *     transform(queryFuture, rowsFunction);\n", "   * ListenableFuture.addListener} documentation. The documentation's warnings about \"lightweight\n", "   * listeners\" refer here to the work done during {@code Function.apply}.\n"], "11": ["   * <pre>   {@code\n", "   *   ListenableFuture<QueryResult> queryFuture = ...;\n", "   *   Function<QueryResult, List<Row>> rowsFunction =\n", "   *       new Function<QueryResult, List<Row>>() {\n", "   *         public List<Row> apply(QueryResult queryResult) {\n", "   *           return queryResult.getRows();\n", "   *         }\n", "   *       };\n", "   *   ListenableFuture<List<Row>> rowsFuture =\n", "   *       transform(queryFuture, rowsFunction, executor);}</pre>\n", "   * documentation. The documentation's warnings about \"lightweight listeners\" refer here to the\n", "   * work done during {@code Function.apply}.\n"], "12": ["   * ListenableFuture.addListener} documentation.\n"], "13": ["   * <p>The callback is run in {@code executor}. There is no guaranteed ordering of execution of\n", "   * Example: <pre> {@code\n"], "14": ["   *     }, e);}</pre>\n", "   * documentation.\n"]}, "added_lines": {"1": [54, 55, 56, 57, 58, 59, 60, 61, 62, 63, 64, 65, 66, 67], "2": [258, 263, 264], "3": [303, 304, 305, 306, 307, 308, 309, 310, 314, 315], "4": [356], "5": [367, 368, 369, 370, 371, 373, 379, 380, 381, 382, 383], "6": [423, 424, 425, 426, 427, 428, 429, 430, 434, 435, 436, 437, 438, 439, 440, 441, 442, 443, 444, 445, 446, 447, 448, 449, 453, 454, 455, 456], "8": [515, 520, 521, 522, 523, 524], "9": [559, 560, 561, 562, 563, 567, 568, 569, 570], "10": [601, 606, 607], "11": [639, 640, 641, 642, 643, 647, 648], "12": [1126, 1127], "13": [1152, 1156, 1157, 1158], "14": [1169, 1170, 1174, 1175]}, "removed_lines": {"1": [54, 55], "2": [246, 247, 248, 249, 250, 251, 256, 257], "3": [296, 297, 298, 299, 300, 301, 302, 303, 304, 305, 306, 307, 311, 312], "4": [353, 354, 355, 356, 357, 358], "5": [369, 370, 371, 372, 373, 374, 375, 376, 383, 384, 385], "6": [425, 426, 427, 428, 429, 430, 431, 432, 433, 434, 435, 436, 440, 441, 442, 443, 444, 445, 446, 447, 448, 449, 450, 451, 452, 453, 454, 455, 459, 460, 461], "7": [497], "8": [520, 521, 522, 523, 524, 525, 527, 532, 533, 534], "9": [569, 570, 571, 572, 573, 574, 575, 576, 577, 578, 582, 583, 584], "10": [614, 615, 616, 617, 618, 619, 621, 626, 627], "11": [659, 660, 661, 662, 663, 664, 665, 666, 667, 668, 672, 673], "12": [1151], "13": [1176, 1180], "14": [1191, 1195]}}, {"5": "android/guava/src/com/google/common/util/concurrent/GwtFluentFutureCatchingSpecialization.java", "added": {"1": ["/*\n", " * Copyright (C) 2006 The Guava Authors\n", " *\n", " * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not use this file except\n", " * in compliance with the License. You may obtain a copy of the License at\n", " *\n", " * http://www.apache.org/licenses/LICENSE-2.0\n", " *\n", " * Unless required by applicable law or agreed to in writing, software distributed under the License\n", " * is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express\n", " * or implied. See the License for the specific language governing permissions and limitations under\n", " * the License.\n", " */\n", "\n", "package com.google.common.util.concurrent;\n", "\n", "import com.google.common.annotations.GwtCompatible;\n", "\n", "/**\n", " * Hidden superclass of {@link FluentFuture} that provides us a place to declare special GWT\n", " * versions of the {@link FluentFuture#catching(Class, com.google.common.base.Function)\n", " * FluentFuture.catching} family of methods. Those versions have slightly different signatures.\n", " */\n", "@GwtCompatible(emulated = true)\n", "abstract class GwtFluentFutureCatchingSpecialization<V> implements ListenableFuture<V> {\n", "  /*\n", "   * This server copy of the class is empty. The corresponding GWT copy contains alternative\n", "   * versions of catching() and catchingAsync() with slightly different signatures from the ones\n", "   * found in FluentFuture.java.\n", "   */\n", "}\n"]}, "removed": {}, "added_lines": {"1": [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31]}, "removed_lines": {}}, {"6": "android/guava/src/com/google/common/util/concurrent/ImmediateFuture.java", "added": {"1": ["/** Implementations of {@code Futures.immediate*}. */\n", "abstract class ImmediateFuture<V> extends FluentFuture<V> {\n"]}, "removed": {"1": ["/**\n", " * Implementations of {@code Futures.immediate*}.\n", " */\n", "abstract class ImmediateFuture<V> implements ListenableFuture<V> {\n"]}, "added_lines": {"1": [29, 31]}, "removed_lines": {"1": [29, 30, 31, 33]}}, {"7": "guava-gwt/src-super/com/google/common/util/concurrent/super/com/google/common/util/concurrent/AbstractFuture.java", "added": {"1": ["/** Emulation for AbstractFuture in GWT. */\n", "public abstract class AbstractFuture<V> extends FluentFuture<V> {\n"]}, "removed": {"1": ["/**\n", " * Emulation for AbstractFuture in GWT.\n", " */\n", "public abstract class AbstractFuture<V> implements ListenableFuture<V> {\n"]}, "added_lines": {"1": [36, 37]}, "removed_lines": {"1": [36, 37, 38, 39]}}, {"8": "guava-gwt/src-super/com/google/common/util/concurrent/super/com/google/common/util/concurrent/GwtFluentFutureCatchingSpecialization.java", "added": {"1": ["/*\n", " * Copyright (C) 2006 The Guava Authors\n", " *\n", " * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not use this file except\n", " * in compliance with the License. You may obtain a copy of the License at\n", " *\n", " * http://www.apache.org/licenses/LICENSE-2.0\n", " *\n", " * Unless required by applicable law or agreed to in writing, software distributed under the License\n", " * is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express\n", " * or implied. See the License for the specific language governing permissions and limitations under\n", " * the License.\n", " */\n", "\n", "package com.google.common.util.concurrent;\n", "\n", "import com.google.common.base.Function;\n", "import java.util.concurrent.Executor;\n", "\n", "/**\n", " * Hidden superclass of {@link FluentFuture} that provides us a place to declare special GWT\n", " * versions of the {@link FluentFuture#catching(Class, com.google.common.base.Function)\n", " * FluentFuture.catching} family of methods. Those versions have slightly different signatures.\n", " */\n", "abstract class GwtFluentFutureCatchingSpecialization<V> implements ListenableFuture<V> {\n", "  /*\n", "   * In the GWT versions of the methods (below), every exceptionType parameter is required to be\n", "   * Class<Throwable>. To handle only certain kinds of exceptions under GWT, you'll need to write\n", "   * your own instanceof tests.\n", "   */\n", "\n", "  public final FluentFuture<V> catching(\n", "      Class<Throwable> exceptionType,\n", "      Function<? super Throwable, ? extends V> fallback,\n", "      Executor executor) {\n", "    return (FluentFuture<V>) Futures.catching(this, exceptionType, fallback, executor);\n", "  }\n", "\n", "  public final FluentFuture<V> catchingAsync(\n", "      Class<Throwable> exceptionType,\n", "      AsyncFunction<? super Throwable, ? extends V> fallback,\n", "      Executor executor) {\n", "    return (FluentFuture<V>) Futures.catchingAsync(this, exceptionType, fallback, executor);\n", "  }\n", "}\n"]}, "removed": {}, "added_lines": {"1": [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45]}, "removed_lines": {}}, {"9": "guava-gwt/test/com/google/common/util/concurrent/FluentFutureTest_gwt.java", "added": {"1": ["/*\n", " * Copyright (C) 2008 The Guava Authors\n", " *\n", " * Licensed under the Apache License, Version 2.0 (the \"License\");\n", " * you may not use this file except in compliance with the License.\n", " * You may obtain a copy of the License at\n", " *\n", " * http://www.apache.org/licenses/LICENSE-2.0\n", " *\n", " * Unless required by applicable law or agreed to in writing, software\n", " * distributed under the License is distributed on an \"AS IS\" BASIS,\n", " * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n", " * See the License for the specific language governing permissions and\n", " * limitations under the License.\n", " */\n", "package com.google.common.util.concurrent;\n", "public class FluentFutureTest_gwt extends com.google.gwt.junit.client.GWTTestCase {\n", "@Override public String getModuleName() {\n", "  return \"com.google.common.util.concurrent.testModule\";\n", "}\n", "public void testAddCallback() throws Exception {\n", "  com.google.common.util.concurrent.FluentFutureTest testCase = new com.google.common.util.concurrent.FluentFutureTest();\n", "  testCase.testAddCallback();\n", "}\n", "\n", "public void testCatching() throws Exception {\n", "  com.google.common.util.concurrent.FluentFutureTest testCase = new com.google.common.util.concurrent.FluentFutureTest();\n", "  testCase.testCatching();\n", "}\n", "\n", "public void testCatchingAsync() throws Exception {\n", "  com.google.common.util.concurrent.FluentFutureTest testCase = new com.google.common.util.concurrent.FluentFutureTest();\n", "  testCase.testCatchingAsync();\n", "}\n", "\n", "public void testFromFluentFuture() throws Exception {\n", "  com.google.common.util.concurrent.FluentFutureTest testCase = new com.google.common.util.concurrent.FluentFutureTest();\n", "  testCase.testFromFluentFuture();\n", "}\n", "\n", "public void testFromNonFluentFuture() throws Exception {\n", "  com.google.common.util.concurrent.FluentFutureTest testCase = new com.google.common.util.concurrent.FluentFutureTest();\n", "  testCase.testFromNonFluentFuture();\n", "}\n", "\n", "public void testTransform() throws Exception {\n", "  com.google.common.util.concurrent.FluentFutureTest testCase = new com.google.common.util.concurrent.FluentFutureTest();\n", "  testCase.testTransform();\n", "}\n", "\n", "public void testTransformAsync() throws Exception {\n", "  com.google.common.util.concurrent.FluentFutureTest testCase = new com.google.common.util.concurrent.FluentFutureTest();\n", "  testCase.testTransformAsync();\n", "}\n", "}\n"]}, "removed": {}, "added_lines": {"1": [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51, 52, 53, 54, 55]}, "removed_lines": {}}, {"10": "guava-tests/test/com/google/common/util/concurrent/FluentFutureTest.java", "added": {"1": ["/*\n", " * Copyright (C) 2016 The Guava Authors\n", " *\n", " * Licensed under the Apache License, Version 2.0 (the \"License\");\n", " * you may not use this file except in compliance with the License.\n", " * You may obtain a copy of the License at\n", " *\n", " * http://www.apache.org/licenses/LICENSE-2.0\n", " *\n", " * Unless required by applicable law or agreed to in writing, software\n", " * distributed under the License is distributed on an \"AS IS\" BASIS,\n", " * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n", " * See the License for the specific language governing permissions and\n", " * limitations under the License.\n", " */\n", "\n", "package com.google.common.util.concurrent;\n", "\n", "import static com.google.common.base.Verify.verify;\n", "import static com.google.common.truth.Truth.assertThat;\n", "import static com.google.common.util.concurrent.Futures.immediateFailedFuture;\n", "import static com.google.common.util.concurrent.Futures.immediateFuture;\n", "import static com.google.common.util.concurrent.MoreExecutors.directExecutor;\n", "import static java.util.concurrent.Executors.newScheduledThreadPool;\n", "import static java.util.concurrent.TimeUnit.SECONDS;\n", "\n", "import com.google.common.annotations.GwtCompatible;\n", "import com.google.common.annotations.GwtIncompatible;\n", "import com.google.common.base.Function;\n", "import com.google.common.util.concurrent.ForwardingListenableFuture.SimpleForwardingListenableFuture;\n", "import java.util.concurrent.ExecutionException;\n", "import java.util.concurrent.ScheduledExecutorService;\n", "import java.util.concurrent.TimeoutException;\n", "import junit.framework.TestCase;\n", "\n", "/**\n", " * Tests for {@link FluentFuture}. The tests cover only the basics for the API. The actual logic is\n", " * tested in {@link FuturesTest}.\n", " */\n", "@GwtCompatible(emulated = true)\n", "public class FluentFutureTest extends TestCase {\n", "  public void testFromFluentFuture() {\n", "    FluentFuture<String> f = SettableFuture.create();\n", "    assertThat(FluentFuture.from(f)).isSameAs(f);\n", "  }\n", "\n", "  public void testFromNonFluentFuture() throws Exception {\n", "    ListenableFuture<String> f =\n", "        new SimpleForwardingListenableFuture<String>(immediateFuture(\"a\")) {};\n", "    verify(!(f instanceof FluentFuture));\n", "    assertThat(FluentFuture.from(f).get()).isEqualTo(\"a\");\n", "    // TODO(cpovirk): Test forwarding more extensively.\n", "  }\n", "\n", "  public void testAddCallback() {\n", "    FluentFuture<String> f = FluentFuture.from(immediateFuture(\"a\"));\n", "    final boolean[] called = new boolean[1];\n", "    f.addCallback(\n", "        new FutureCallback<String>() {\n", "          @Override\n", "          public void onSuccess(String result) {\n", "            called[0] = true;\n", "          }\n", "\n", "          @Override\n", "          public void onFailure(Throwable t) {}\n", "        },\n", "        directExecutor());\n", "    assertThat(called[0]).isTrue();\n", "  }\n", "\n", "  public void testCatching() throws Exception {\n", "    FluentFuture<?> f =\n", "        FluentFuture.from(immediateFailedFuture(new RuntimeException()))\n", "            .catching(\n", "                Throwable.class,\n", "                new Function<Throwable, Class<?>>() {\n", "                  @Override\n", "                  public Class<?> apply(Throwable input) {\n", "                    return input.getClass();\n", "                  }\n", "                },\n", "                directExecutor());\n", "    assertThat(f.get()).isEqualTo(RuntimeException.class);\n", "  }\n", "\n", "  public void testCatchingAsync() throws Exception {\n", "    FluentFuture<?> f =\n", "        FluentFuture.from(immediateFailedFuture(new RuntimeException()))\n", "            .catchingAsync(\n", "                Throwable.class,\n", "                new AsyncFunction<Throwable, Class<?>>() {\n", "                  @Override\n", "                  public ListenableFuture<Class<?>> apply(Throwable input) {\n", "                    return Futures.<Class<?>>immediateFuture(input.getClass());\n", "                  }\n", "                },\n", "                directExecutor());\n", "    assertThat(f.get()).isEqualTo(RuntimeException.class);\n", "  }\n", "\n", "  public void testTransform() throws Exception {\n", "    FluentFuture<Integer> f =\n", "        FluentFuture.from(immediateFuture(1))\n", "            .transform(\n", "                new Function<Integer, Integer>() {\n", "                  @Override\n", "                  public Integer apply(Integer input) {\n", "                    return input + 1;\n", "                  }\n", "                },\n", "                directExecutor());\n", "    assertThat(f.get()).isEqualTo(2);\n", "  }\n", "\n", "  public void testTransformAsync() throws Exception {\n", "    FluentFuture<Integer> f =\n", "        FluentFuture.from(immediateFuture(1))\n", "            .transformAsync(\n", "                new AsyncFunction<Integer, Integer>() {\n", "                  @Override\n", "                  public ListenableFuture<Integer> apply(Integer input) {\n", "                    return immediateFuture(input + 1);\n", "                  }\n", "                },\n", "                directExecutor());\n", "    assertThat(f.get()).isEqualTo(2);\n", "  }\n", "\n", "  @GwtIncompatible // withTimeout\n", "  public void testWithTimeout() throws Exception {\n", "    ScheduledExecutorService executor = newScheduledThreadPool(1);\n", "    try {\n", "      FluentFuture<?> f = SettableFuture.create().withTimeout(0, SECONDS, executor);\n", "      try {\n", "        f.get();\n", "        fail();\n", "      } catch (ExecutionException e) {\n", "        assertThat(e.getCause()).isInstanceOf(TimeoutException.class);\n", "      }\n", "    } finally {\n", "      executor.shutdown();\n", "    }\n", "  }\n", "}\n"]}, "removed": {}, "added_lines": {"1": [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 58, 59, 60, 61, 62, 63, 64, 65, 66, 67, 68, 69, 70, 71, 72, 73, 74, 75, 76, 77, 78, 79, 80, 81, 82, 83, 84, 85, 86, 87, 88, 89, 90, 91, 92, 93, 94, 95, 96, 97, 98, 99, 100, 101, 102, 103, 104, 105, 106, 107, 108, 109, 110, 111, 112, 113, 114, 115, 116, 117, 118, 119, 120, 121, 122, 123, 124, 125, 126, 127, 128, 129, 130, 131, 132, 133, 134, 135, 136, 137, 138, 139, 140, 141, 142, 143, 144, 145]}, "removed_lines": {}}, {"11": "guava/src/com/google/common/util/concurrent/AbstractFuture.java", "added": {"1": ["public abstract class AbstractFuture<V> extends FluentFuture<V> {\n"]}, "removed": {"1": ["public abstract class AbstractFuture<V> implements ListenableFuture<V> {\n"]}, "added_lines": {"1": [65]}, "removed_lines": {"1": [65]}}, {"12": "guava/src/com/google/common/util/concurrent/FluentFuture.java", "added": {"1": ["/*\n", " * Copyright (C) 2006 The Guava Authors\n", " *\n", " * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not use this file except\n", " * in compliance with the License. You may obtain a copy of the License at\n", " *\n", " * http://www.apache.org/licenses/LICENSE-2.0\n", " *\n", " * Unless required by applicable law or agreed to in writing, software distributed under the License\n", " * is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express\n", " * or implied. See the License for the specific language governing permissions and limitations under\n", " * the License.\n", " */\n", "\n", "package com.google.common.util.concurrent;\n", "\n", "import com.google.common.annotations.Beta;\n", "import com.google.common.annotations.GwtCompatible;\n", "import com.google.common.annotations.GwtIncompatible;\n", "import com.google.common.base.Function;\n", "import com.google.errorprone.annotations.DoNotMock;\n", "import java.util.concurrent.ExecutionException;\n", "import java.util.concurrent.Executor;\n", "import java.util.concurrent.ScheduledExecutorService;\n", "import java.util.concurrent.TimeUnit;\n", "import java.util.concurrent.TimeoutException;\n", "\n", "/**\n", " * A {@link ListenableFuture} that supports fluent chains of operations. For example:\n", " *\n", " * <pre>{@code\n", " * ListenableFuture<Boolean> adminIsLoggedIn =\n", " *     FluentFuture.from(usersDatabase.getAdminUser())\n", " *         .transform(User::getId, directExecutor())\n", " *         .transform(ActivityService::isLoggedIn, threadPool)\n", " *         .catching(RpcException.class, e -> false, directExecutor());\n", " * }</pre>\n", " *\n", " * <h3>Alternatives</h3>\n", " *\n", " * <h4>Frameworks</h4>\n", " *\n", " * <p>When chaining together a graph of asynchronous operations, you will often find it easier to\n", " * use a framework. Frameworks automate the process, often adding features like monitoring,\n", " * debugging, and cancellation. Examples of frameworks include:\n", " *\n", " * <ul>\n", " *   <li><a href=\"http://google.github.io/dagger/producers.html\">Dagger Producers</a>\n", " * </ul>\n", " *\n", " * <h4>{@link java.util.concurrent.CompletableFuture} / {@link java.util.concurrent.CompletionStage}\n", " * </h4>\n", " *\n", " * <p>Users of {@code CompletableFuture} will likely want to continue using {@code\n", " * CompletableFuture}. {@code FluentFuture} is targeted at people who use {@code ListenableFuture},\n", " * who can't use Java 8, or who want an API more focused than {@code CompletableFuture}. (If you\n", " * need to adapt between {@code CompletableFuture} and {@code ListenableFuture}, consider <a\n", " * href=\"https://github.com/lukas-krecan/future-converter\">Future Converter</a>.)\n", " *\n", " * <h3>Extension</h3>\n", " *\n", " * If you want a class like {@code FluentFuture} but with extra methods, we recommend declaring your\n", " * own subclass of {@link ListenableFuture}, complete with a method like {@link #from} to adapt an\n", " * existing {@code ListenableFuture}, implemented atop a {@link ForwardingListenableFuture} that\n", " * forwards to that future and adds the desired methods.\n", " *\n", " * @since 22.0\n", " */\n", "@Beta\n", "@DoNotMock(\"Use FluentFuture.from(Futures.immediate*Future) or SettableFuture\")\n", "@GwtCompatible(emulated = true)\n", "public abstract class FluentFuture<V> extends GwtFluentFutureCatchingSpecialization<V> {\n", "  FluentFuture() {}\n", "\n", "  /**\n", "   * Converts the given {@code ListenableFuture} to an equivalent {@code FluentFuture}.\n", "   *\n", "   * <p>If the given {@code ListenableFuture} is already a {@code FluentFuture}, it is returned\n", "   * directly. If not, it is wrapped in a {@code FluentFuture} that delegates all calls to the\n", "   * original {@code ListenableFuture}.\n", "   */\n", "  public static <V> FluentFuture<V> from(ListenableFuture<V> future) {\n", "    return future instanceof FluentFuture\n", "        ? (FluentFuture<V>) future\n", "        : new ForwardingFluentFuture<V>(future);\n", "  }\n", "\n", "  /**\n", "   * Returns a {@code Future} whose result is taken from this {@code Future} or, if this {@code\n", "   * Future} fails with the given {@code exceptionType}, from the result provided by the {@code\n", "   * fallback}. {@link Function#apply} is not invoked until the primary input has failed, so if the\n", "   * primary input succeeds, it is never invoked. If, during the invocation of {@code fallback}, an\n", "   * exception is thrown, this exception is used as the result of the output {@code Future}.\n", "   *\n", "   * <p>Usage example:\n", "   *\n", "   * <pre>{@code\n", "   * // Falling back to a zero counter in case an exception happens when processing the RPC to fetch\n", "   * // counters.\n", "   * ListenableFuture<Integer> faultTolerantFuture =\n", "   *     fetchCounters().catching(FetchException.class, x -> 0, directExecutor());\n", "   * }</pre>\n", "   *\n", "   * <p>When selecting an executor, note that {@code directExecutor} is dangerous in some cases. See\n", "   * the discussion in the {@link #addListener} documentation. All its warnings about heavyweight\n", "   * listeners are also applicable to heavyweight functions passed to this method.\n", "   *\n", "   * <p>This method is similar to {@link java.util.concurrent.CompletableFuture#exceptionally}. It\n", "   * can also serve some of the use cases of {@link java.util.concurrent.CompletableFuture#handle}\n", "   * and {@link java.util.concurrent.CompletableFuture#handleAsync} when used along with {@link\n", "   * #transform}.\n", "   *\n", "   * @param exceptionType the exception type that triggers use of {@code fallback}. The exception\n", "   *     type is matched against the input's exception. \"The input's exception\" means the cause of\n", "   *     the {@link ExecutionException} thrown by {@code input.get()} or, if {@code get()} throws a\n", "   *     different kind of exception, that exception itself. To avoid hiding bugs and other\n", "   *     unrecoverable errors, callers should prefer more specific types, avoiding {@code\n", "   *     Throwable.class} in particular.\n", "   * @param fallback the {@link Function} to be called if the input fails with the expected\n", "   *     exception type. The function's argument is the input's exception. \"The input's exception\"\n", "   *     means the cause of the {@link ExecutionException} thrown by {@code this.get()} or, if\n", "   *     {@code get()} throws a different kind of exception, that exception itself.\n", "   * @param executor the executor that runs {@code fallback} if the input fails\n", "   */\n", "  @Partially.GwtIncompatible(\"AVAILABLE but requires exceptionType to be Throwable.class\")\n", "  public final <X extends Throwable> FluentFuture<V> catching(\n", "      Class<X> exceptionType, Function<? super X, ? extends V> fallback, Executor executor) {\n", "    return (FluentFuture<V>) Futures.catching(this, exceptionType, fallback, executor);\n", "  }\n", "\n", "  /**\n", "   * Returns a {@code Future} whose result is taken from this {@code Future} or, if the this {@code\n", "   * Future} fails with the given {@code exceptionType}, from the result provided by the {@code\n", "   * fallback}. {@link AsyncFunction#apply} is not invoked until the primary input has failed, so if\n", "   * the primary input succeeds, it is never invoked. If, during the invocation of {@code fallback},\n", "   * an exception is thrown, this exception is used as the result of the output {@code Future}.\n", "   *\n", "   * <p>Usage examples:\n", "   *\n", "   * <pre>{@code\n", "   * // Falling back to a zero counter in case an exception happens when processing the RPC to fetch\n", "   * // counters.\n", "   * ListenableFuture<Integer> faultTolerantFuture =\n", "   *     fetchCounters().catchingAsync(\n", "   *         FetchException.class, x -> immediateFuture(0), directExecutor());\n", "   * }</pre>\n", "   *\n", "   * <p>The fallback can also choose to propagate the original exception when desired:\n", "   *\n", "   * <pre>{@code\n", "   * // Falling back to a zero counter only in case the exception was a\n", "   * // TimeoutException.\n", "   * ListenableFuture<Integer> faultTolerantFuture =\n", "   *     fetchCounters().catchingAsync(\n", "   *         fetchCounterFuture,\n", "   *         FetchException.class,\n", "   *         e -> {\n", "   *           if (omitDataOnFetchFailure) {\n", "   *             return immediateFuture(0);\n", "   *           }\n", "   *           throw e;\n", "   *         },\n", "   *         directExecutor());\n", "   * }</pre>\n", "   *\n", "   * <p>When selecting an executor, note that {@code directExecutor} is dangerous in some cases. See\n", "   * the discussion in the {@link #addListener} documentation. All its warnings about heavyweight\n", "   * listeners are also applicable to heavyweight functions passed to this method. (Specifically,\n", "   * {@code directExecutor} functions should avoid heavyweight operations inside {@code\n", "   * AsyncFunction.apply}. Any heavyweight operations should occur in other threads responsible for\n", "   * completing the returned {@code Future}.)\n", "   *\n", "   * <p>This method is similar to {@link java.util.concurrent.CompletableFuture#exceptionally}. It\n", "   * can also serve some of the use cases of {@link java.util.concurrent.CompletableFuture#handle}\n", "   * and {@link java.util.concurrent.CompletableFuture#handleAsync} when used along with {@link\n", "   * #transform}.\n", "   *\n", "   * @param exceptionType the exception type that triggers use of {@code fallback}. The exception\n", "   *     type is matched against the input's exception. \"The input's exception\" means the cause of\n", "   *     the {@link ExecutionException} thrown by {@code this.get()} or, if {@code get()} throws a\n", "   *     different kind of exception, that exception itself. To avoid hiding bugs and other\n", "   *     unrecoverable errors, callers should prefer more specific types, avoiding {@code\n", "   *     Throwable.class} in particular.\n", "   * @param fallback the {@link AsyncFunction} to be called if the input fails with the expected\n", "   *     exception type. The function's argument is the input's exception. \"The input's exception\"\n", "   *     means the cause of the {@link ExecutionException} thrown by {@code input.get()} or, if\n", "   *     {@code get()} throws a different kind of exception, that exception itself.\n", "   * @param executor the executor that runs {@code fallback} if the input fails\n", "   */\n", "  @Partially.GwtIncompatible(\"AVAILABLE but requires exceptionType to be Throwable.class\")\n", "  public final <X extends Throwable> FluentFuture<V> catchingAsync(\n", "      Class<X> exceptionType, AsyncFunction<? super X, ? extends V> fallback, Executor executor) {\n", "    return (FluentFuture<V>) Futures.catchingAsync(this, exceptionType, fallback, executor);\n", "  }\n", "\n", "  /**\n", "   * Returns a future that delegates to this future but will finish early (via a {@link\n", "   * TimeoutException} wrapped in an {@link ExecutionException}) if the specified timeout expires.\n", "   * If the timeout expires, not only will the output future finish, but also the input future\n", "   * ({@code this}) will be cancelled and interrupted.\n", "   *\n", "   * @param timeout when to time out the future\n", "   * @param unit the time unit of the time parameter\n", "   * @param scheduledExecutor The executor service to enforce the timeout.\n", "   */\n", "  @GwtIncompatible // ScheduledExecutorService\n", "  public final FluentFuture<V> withTimeout(\n", "      long timeout, TimeUnit unit, ScheduledExecutorService scheduledExecutor) {\n", "    return (FluentFuture<V>) Futures.withTimeout(this, timeout, unit, scheduledExecutor);\n", "  }\n", "\n", "  /**\n", "   * Returns a new {@code Future} whose result is asynchronously derived from the result of this\n", "   * {@code Future}. If the input {@code Future} fails, the returned {@code Future} fails with the\n", "   * same exception (and the function is not invoked).\n", "   *\n", "   * <p>More precisely, the returned {@code Future} takes its result from a {@code Future} produced\n", "   * by applying the given {@code AsyncFunction} to the result of the original {@code Future}.\n", "   * Example usage:\n", "   *\n", "   * <pre>{@code\n", "   * FluentFuture<RowKey> rowKeyFuture = FluentFuture.from(indexService.lookUp(query));\n", "   * ListenableFuture<QueryResult> queryFuture =\n", "   *     rowKeyFuture.transformAsync(dataService::readFuture, executor);\n", "   * }</pre>\n", "   *\n", "   * <p>When selecting an executor, note that {@code directExecutor} is dangerous in some cases. See\n", "   * the discussion in the {@link #addListener} documentation. All its warnings about heavyweight\n", "   * listeners are also applicable to heavyweight functions passed to this method. (Specifically,\n", "   * {@code directExecutor} functions should avoid heavyweight operations inside {@code\n", "   * AsyncFunction.apply}. Any heavyweight operations should occur in other threads responsible for\n", "   * completing the returned {@code Future}.)\n", "   *\n", "   * <p>The returned {@code Future} attempts to keep its cancellation state in sync with that of the\n", "   * input future and that of the future returned by the chain function. That is, if the returned\n", "   * {@code Future} is cancelled, it will attempt to cancel the other two, and if either of the\n", "   * other two is cancelled, the returned {@code Future} will receive a callback in which it will\n", "   * attempt to cancel itself.\n", "   *\n", "   * <p>This method is similar to {@link java.util.concurrent.CompletableFuture#thenCompose} and\n", "   * {@link java.util.concurrent.CompletableFuture#thenComposeAsync}. It can also serve some of the\n", "   * use cases of {@link java.util.concurrent.CompletableFuture#handle} and {@link\n", "   * java.util.concurrent.CompletableFuture#handleAsync} when used along with {@link #catching}.\n", "   *\n", "   * @param function A function to transform the result of this future to the result of the output\n", "   *     future\n", "   * @param executor Executor to run the function in.\n", "   * @return A future that holds result of the function (if the input succeeded) or the original\n", "   *     input's failure (if not)\n", "   */\n", "  public final <T> FluentFuture<T> transformAsync(\n", "      AsyncFunction<? super V, T> function, Executor executor) {\n", "    return (FluentFuture<T>) Futures.transformAsync(this, function, executor);\n", "  }\n", "\n", "  /**\n", "   * Returns a new {@code Future} whose result is derived from the result of this {@code Future}. If\n", "   * this input {@code Future} fails, the returned {@code Future} fails with the same exception (and\n", "   * the function is not invoked). Example usage:\n", "   *\n", "   * <pre>{@code\n", "   * ListenableFuture<List<Row>> rowsFuture =\n", "   *     queryFuture.transform(QueryResult::getRows, executor);\n", "   * }</pre>\n", "   *\n", "   * <p>When selecting an executor, note that {@code directExecutor} is dangerous in some cases. See\n", "   * the discussion in the {@link #addListener} documentation. All its warnings about heavyweight\n", "   * listeners are also applicable to heavyweight functions passed to this method.\n", "   *\n", "   * <p>The returned {@code Future} attempts to keep its cancellation state in sync with that of the\n", "   * input future. That is, if the returned {@code Future} is cancelled, it will attempt to cancel\n", "   * the input, and if the input is cancelled, the returned {@code Future} will receive a callback\n", "   * in which it will attempt to cancel itself.\n", "   *\n", "   * <p>An example use of this method is to convert a serializable object returned from an RPC into\n", "   * a POJO.\n", "   *\n", "   * <p>This method is similar to {@link java.util.concurrent.CompletableFuture#thenApply} and\n", "   * {@link java.util.concurrent.CompletableFuture#thenApplyAsync}. It can also serve some of the\n", "   * use cases of {@link java.util.concurrent.CompletableFuture#handle} and {@link\n", "   * java.util.concurrent.CompletableFuture#handleAsync} when used along with {@link #catching}.\n", "   *\n", "   * @param function A Function to transform the results of this future to the results of the\n", "   *     returned future.\n", "   * @param executor Executor to run the function in.\n", "   * @return A future that holds result of the transformation.\n", "   */\n", "  public final <T> FluentFuture<T> transform(Function<? super V, T> function, Executor executor) {\n", "    return (FluentFuture<T>) Futures.transform(this, function, executor);\n", "  }\n", "\n", "  /**\n", "   * Registers separate success and failure callbacks to be run when this {@code Future}'s\n", "   * computation is {@linkplain java.util.concurrent.Future#isDone() complete} or, if the\n", "   * computation is already complete, immediately.\n", "   *\n", "   * <p>The callback is run on {@code executor}. There is no guaranteed ordering of execution of\n", "   * callbacks, but any callback added through this method is guaranteed to be called once the\n", "   * computation is complete.\n", "   *\n", "   * <p>Example:\n", "   *\n", "   * <pre>{@code\n", "   * future.addCallback(\n", "   *     new FutureCallback<QueryResult>() {\n", "   *       public void onSuccess(QueryResult result) {\n", "   *         storeInCache(result);\n", "   *       }\n", "   *       public void onFailure(Throwable t) {\n", "   *         reportError(t);\n", "   *       }\n", "   *     }, executor);\n", "   * }</pre>\n", "   *\n", "   * <p>When selecting an executor, note that {@code directExecutor} is dangerous in some cases. See\n", "   * the discussion in the {@link #addListener} documentation. All its warnings about heavyweight\n", "   * listeners are also applicable to heavyweight callbacks passed to this method.\n", "   *\n", "   * <p>For a more general interface to attach a completion listener, see {@link #addListener}.\n", "   *\n", "   * <p>This method is similar to {@link java.util.concurrent.CompletableFuture#whenComplete} and\n", "   * {@link java.util.concurrent.CompletableFuture#whenCompleteAsync}. It also serves the use case\n", "   * of {@link java.util.concurrent.CompletableFuture#thenAccept} and {@link\n", "   * java.util.concurrent.CompletableFuture#thenAcceptAsync}.\n", "   *\n", "   * @param callback The callback to invoke when this {@code Future} is completed.\n", "   * @param executor The executor to run {@code callback} when the future completes.\n", "   */\n", "  public final void addCallback(FutureCallback<? super V> callback, Executor executor) {\n", "    Futures.addCallback(this, callback, executor);\n", "  }\n", "}\n"]}, "removed": {}, "added_lines": {"1": [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 58, 59, 60, 61, 62, 63, 64, 65, 66, 67, 68, 69, 70, 71, 72, 73, 74, 75, 76, 77, 78, 79, 80, 81, 82, 83, 84, 85, 86, 87, 88, 89, 90, 91, 92, 93, 94, 95, 96, 97, 98, 99, 100, 101, 102, 103, 104, 105, 106, 107, 108, 109, 110, 111, 112, 113, 114, 115, 116, 117, 118, 119, 120, 121, 122, 123, 124, 125, 126, 127, 128, 129, 130, 131, 132, 133, 134, 135, 136, 137, 138, 139, 140, 141, 142, 143, 144, 145, 146, 147, 148, 149, 150, 151, 152, 153, 154, 155, 156, 157, 158, 159, 160, 161, 162, 163, 164, 165, 166, 167, 168, 169, 170, 171, 172, 173, 174, 175, 176, 177, 178, 179, 180, 181, 182, 183, 184, 185, 186, 187, 188, 189, 190, 191, 192, 193, 194, 195, 196, 197, 198, 199, 200, 201, 202, 203, 204, 205, 206, 207, 208, 209, 210, 211, 212, 213, 214, 215, 216, 217, 218, 219, 220, 221, 222, 223, 224, 225, 226, 227, 228, 229, 230, 231, 232, 233, 234, 235, 236, 237, 238, 239, 240, 241, 242, 243, 244, 245, 246, 247, 248, 249, 250, 251, 252, 253, 254, 255, 256, 257, 258, 259, 260, 261, 262, 263, 264, 265, 266, 267, 268, 269, 270, 271, 272, 273, 274, 275, 276, 277, 278, 279, 280, 281, 282, 283, 284, 285, 286, 287, 288, 289, 290, 291, 292, 293, 294, 295, 296, 297, 298, 299, 300, 301, 302, 303, 304, 305, 306, 307, 308, 309, 310, 311, 312, 313, 314, 315, 316, 317, 318, 319, 320, 321, 322, 323, 324, 325, 326, 327, 328, 329, 330, 331, 332]}, "removed_lines": {}}, {"13": "guava/src/com/google/common/util/concurrent/ForwardingFluentFuture.java", "added": {"1": ["/*\n", " * Copyright (C) 2009 The Guava Authors\n", " *\n", " * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not use this file except\n", " * in compliance with the License. You may obtain a copy of the License at\n", " *\n", " * http://www.apache.org/licenses/LICENSE-2.0\n", " *\n", " * Unless required by applicable law or agreed to in writing, software distributed under the License\n", " * is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express\n", " * or implied. See the License for the specific language governing permissions and limitations under\n", " * the License.\n", " */\n", "\n", "package com.google.common.util.concurrent;\n", "\n", "import static com.google.common.base.Preconditions.checkNotNull;\n", "\n", "import com.google.common.annotations.GwtCompatible;\n", "import java.util.concurrent.ExecutionException;\n", "import java.util.concurrent.Executor;\n", "import java.util.concurrent.TimeUnit;\n", "import java.util.concurrent.TimeoutException;\n", "\n", "/**\n", " * {@link FluentFuture} that forwards all calls to a delegate.\n", " *\n", " * <h3>Extension</h3>\n", " *\n", " * If you want a class like {@code FluentFuture} but with extra methods, we recommend declaring your\n", " * own subclass of {@link ListenableFuture}, complete with a method like {@link #from} to adapt an\n", " * existing {@code ListenableFuture}, implemented atop a {@link ForwardingListenableFuture} that\n", " * forwards to that future and adds the desired methods.\n", " */\n", "@GwtCompatible\n", "final class ForwardingFluentFuture<V> extends FluentFuture<V> {\n", "  private final ListenableFuture<V> delegate;\n", "\n", "  ForwardingFluentFuture(ListenableFuture<V> delegate) {\n", "    this.delegate = checkNotNull(delegate);\n", "  }\n", "\n", "  @Override\n", "  public void addListener(Runnable listener, Executor executor) {\n", "    delegate.addListener(listener, executor);\n", "  }\n", "\n", "  @Override\n", "  public boolean cancel(boolean mayInterruptIfRunning) {\n", "    return delegate.cancel(mayInterruptIfRunning);\n", "  }\n", "\n", "  @Override\n", "  public boolean isCancelled() {\n", "    return delegate.isCancelled();\n", "  }\n", "\n", "  @Override\n", "  public boolean isDone() {\n", "    return delegate.isDone();\n", "  }\n", "\n", "  @Override\n", "  public V get() throws InterruptedException, ExecutionException {\n", "    return delegate.get();\n", "  }\n", "\n", "  @Override\n", "  public V get(long timeout, TimeUnit unit)\n", "      throws InterruptedException, ExecutionException, TimeoutException {\n", "    return delegate.get(timeout, unit);\n", "  }\n", "}\n"]}, "removed": {}, "added_lines": {"1": [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 58, 59, 60, 61, 62, 63, 64, 65, 66, 67, 68, 69, 70, 71, 72, 73]}, "removed_lines": {}}, {"14": "guava/src/com/google/common/util/concurrent/Futures.java", "added": {"1": [" * article on <a href=\"https://github.com/google/guava/wiki/ListenableFutureExplained\">{@code\n", " * ListenableFuture}</a>.\n", " *\n", " * <p>The main purpose of {@code ListenableFuture} is to help you chain together a graph of\n", " * asynchronous operations. You can chain them together manually with calls to methods like {@link\n", " * Futures#transform(ListenableFuture, Function, Executor) Futures.transform}, but you will often\n", " * find it easier to use a framework. Frameworks automate the process, often adding features like\n", " * monitoring, debugging, and cancellation. Examples of frameworks include:\n", " *\n", " * <ul>\n", " *   <li><a href=\"http://google.github.io/dagger/producers.html\">Dagger Producers</a>\n", " * </ul>\n", " *\n", " * <p>If you do chain your operations manually, you may want to use {@link FluentFuture}.\n"], "2": ["   *     fetchCounterFuture, FetchException.class, x -> 0);\n", "   * ListenableFuture.addListener} documentation. All its warnings about heavyweight listeners are\n", "   * also applicable to heavyweight functions passed to this method.\n"], "3": ["   * <pre>{@code\n", "   * ListenableFuture<Integer> fetchCounterFuture = ...;\n", "   *\n", "   * // Falling back to a zero counter in case an exception happens when\n", "   * // processing the RPC to fetch counters.\n", "   * ListenableFuture<Integer> faultTolerantFuture = Futures.catching(\n", "   *     fetchCounterFuture, FetchException.class, x -> 0, directExecutor());\n", "   * }</pre>\n", "   * documentation. All its warnings about heavyweight listeners are also applicable to heavyweight\n", "   * functions passed to this method.\n"], "4": ["   *     fetchCounterFuture, FetchException.class, x -> immediateFuture(0));\n"], "5": ["   *     fetchCounterFuture,\n", "   *     FetchException.class,\n", "   *     e -> {\n", "   *       if (omitDataOnFetchFailure) {\n", "   *         return immediateFuture(0);\n", "   *       throw e;\n", "   * ListenableFuture.addListener} documentation. All its warnings about heavyweight listeners are\n", "   * also applicable to heavyweight functions passed to this method. (Specifically, {@code\n", "   * directExecutor} functions should avoid heavyweight operations inside {@code\n", "   * AsyncFunction.apply}. Any heavyweight operations should occur in other threads responsible for\n", "   * completing the returned {@code Future}.)\n"], "6": ["   * <pre>{@code\n", "   * ListenableFuture<Integer> fetchCounterFuture = ...;\n", "   *\n", "   * // Falling back to a zero counter in case an exception happens when\n", "   * // processing the RPC to fetch counters.\n", "   * ListenableFuture<Integer> faultTolerantFuture = Futures.catchingAsync(\n", "   *     fetchCounterFuture, FetchException.class, x -> immediateFuture(0), directExecutor());\n", "   * }</pre>\n", "   * <pre>{@code\n", "   * ListenableFuture<Integer> fetchCounterFuture = ...;\n", "   *\n", "   * // Falling back to a zero counter only in case the exception was a\n", "   * // TimeoutException.\n", "   * ListenableFuture<Integer> faultTolerantFuture = Futures.catchingAsync(\n", "   *     fetchCounterFuture,\n", "   *     FetchException.class,\n", "   *     e -> {\n", "   *       if (omitDataOnFetchFailure) {\n", "   *         return immediateFuture(0);\n", "   *       }\n", "   *       throw e;\n", "   *     },\n", "   *     directExecutor());\n", "   * }</pre>\n", "   * documentation. All its warnings about heavyweight listeners are also applicable to heavyweight\n", "   * functions passed to this method. (Specifically, {@code directExecutor} functions should avoid\n", "   * heavyweight operations inside {@code AsyncFunction.apply}. Any heavyweight operations should\n", "   * occur in other threads responsible for completing the returned {@code Future}.)\n"], "8": ["   *     transformAsync(rowKeyFuture, dataService::readFuture);\n", "   * ListenableFuture.addListener} documentation. All its warnings about heavyweight listeners are\n", "   * also applicable to heavyweight functions passed to this method. (Specifically, {@code\n", "   * directExecutor} functions should avoid heavyweight operations inside {@code\n", "   * AsyncFunction.apply}. Any heavyweight operations should occur in other threads responsible for\n", "   * completing the returned {@code Future}.)\n"], "9": ["   * <pre>{@code\n", "   * ListenableFuture<RowKey> rowKeyFuture = indexService.lookUp(query);\n", "   * ListenableFuture<QueryResult> queryFuture =\n", "   *     transformAsync(rowKeyFuture, dataService::readFuture, executor);\n", "   * }</pre>\n", "   * documentation. All its warnings about heavyweight listeners are also applicable to heavyweight\n", "   * functions passed to this method. (Specifically, {@code directExecutor} functions should avoid\n", "   * heavyweight operations inside {@code AsyncFunction.apply}. Any heavyweight operations should\n", "   * occur in other threads responsible for completing the returned {@code Future}.)\n"], "10": ["   *     transform(queryFuture, QueryResult::getRows);\n", "   * ListenableFuture.addListener} documentation. All its warnings about heavyweight listeners are\n", "   * also applicable to heavyweight functions passed to this method.\n"], "11": ["   * <pre>{@code\n", "   * ListenableFuture<QueryResult> queryFuture = ...;\n", "   * ListenableFuture<List<Row>> rowsFuture =\n", "   *     transform(queryFuture, QueryResult::getRows, executor);\n", "   * }</pre>\n", "   * documentation. All its warnings about heavyweight listeners are also applicable to heavyweight\n", "   * functions passed to this method.\n"], "12": ["   * ListenableFuture.addListener} documentation. All its warnings about heavyweight listeners are\n", "   * also applicable to heavyweight callbacks passed to this method.\n"], "13": ["   * <p>The callback is run on {@code executor}. There is no guaranteed ordering of execution of\n", "   * <p>Example:\n", "   *\n", "   * <pre>{@code\n"], "14": ["   *     }, e);\n", "   * }</pre>\n", "   * documentation. All its warnings about heavyweight listeners are also applicable to heavyweight\n", "   * callbacks passed to this method.\n"]}, "removed": {"1": [" * article on <a href=\"https://github.com/google/guava/wiki/ListenableFutureExplained\">\n", " * {@code ListenableFuture}</a>.\n"], "2": ["   *     fetchCounterFuture, FetchException.class,\n", "   *     new Function<FetchException, Integer>() {\n", "   *       public Integer apply(FetchException e) {\n", "   *         return 0;\n", "   *       }\n", "   *     });\n", "   * ListenableFuture.addListener} documentation. The documentation's warnings about \"lightweight\n", "   * listeners\" refer here to the work done during {@code Function.apply}.\n"], "3": ["   * <pre>   {@code\n", "   *   ListenableFuture<Integer> fetchCounterFuture = ...;\n", "   *\n", "   *   // Falling back to a zero counter in case an exception happens when\n", "   *   // processing the RPC to fetch counters.\n", "   *   ListenableFuture<Integer> faultTolerantFuture = Futures.catching(\n", "   *       fetchCounterFuture, FetchException.class,\n", "   *       new Function<FetchException, Integer>() {\n", "   *         public Integer apply(FetchException e) {\n", "   *           return 0;\n", "   *         }\n", "   *       }, directExecutor());}</pre>\n", "   * documentation. The documentation's warnings about \"lightweight listeners\" refer here to the\n", "   * work done during {@code Function.apply}.\n"], "4": ["   *     fetchCounterFuture, FetchException.class,\n", "   *     new AsyncFunction<FetchException, Integer>() {\n", "   *       public ListenableFuture<Integer> apply(FetchException e) {\n", "   *         return immediateFuture(0);\n", "   *       }\n", "   *     });\n"], "5": ["   *     fetchCounterFuture, FetchException.class,\n", "   *     new AsyncFunction<FetchException, Integer>() {\n", "   *       public ListenableFuture<Integer> apply(FetchException e)\n", "   *           throws FetchException {\n", "   *         if (omitDataOnFetchFailure) {\n", "   *           return immediateFuture(0);\n", "   *         }\n", "   *         throw e;\n", "   * ListenableFuture.addListener} documentation. The documentation's warnings about \"lightweight\n", "   * listeners\" refer here to the work done during {@code AsyncFunction.apply}, not to any work done\n", "   * to complete the returned {@code Future}.\n"], "6": ["   * <pre>   {@code\n", "   *   ListenableFuture<Integer> fetchCounterFuture = ...;\n", "   *\n", "   *   // Falling back to a zero counter in case an exception happens when\n", "   *   // processing the RPC to fetch counters.\n", "   *   ListenableFuture<Integer> faultTolerantFuture = Futures.catchingAsync(\n", "   *       fetchCounterFuture, FetchException.class,\n", "   *       new AsyncFunction<FetchException, Integer>() {\n", "   *         public ListenableFuture<Integer> apply(FetchException e) {\n", "   *           return immediateFuture(0);\n", "   *         }\n", "   *       }, directExecutor());}</pre>\n", "   * <pre>   {@code\n", "   *   ListenableFuture<Integer> fetchCounterFuture = ...;\n", "   *\n", "   *   // Falling back to a zero counter only in case the exception was a\n", "   *   // TimeoutException.\n", "   *   ListenableFuture<Integer> faultTolerantFuture = Futures.catchingAsync(\n", "   *       fetchCounterFuture, FetchException.class,\n", "   *       new AsyncFunction<FetchException, Integer>() {\n", "   *         public ListenableFuture<Integer> apply(FetchException e)\n", "   *             throws FetchException {\n", "   *           if (omitDataOnFetchFailure) {\n", "   *             return immediateFuture(0);\n", "   *           }\n", "   *           throw e;\n", "   *         }\n", "   *       }, directExecutor());}</pre>\n", "   * documentation. The documentation's warnings about \"lightweight listeners\" refer here to the\n", "   * work done during {@code AsyncFunction.apply}, not to any work done to complete the returned\n", "   * {@code Future}.\n"], "7": ["   *\n"], "8": ["   * AsyncFunction<RowKey, QueryResult> queryFunction =\n", "   *     new AsyncFunction<RowKey, QueryResult>() {\n", "   *       public ListenableFuture<QueryResult> apply(RowKey rowKey) {\n", "   *         return dataService.read(rowKey);\n", "   *       }\n", "   *     };\n", "   *     transformAsync(rowKeyFuture, queryFunction);\n", "   * ListenableFuture.addListener} documentation. The documentation's warnings about \"lightweight\n", "   * listeners\" refer here to the work done during {@code AsyncFunction.apply}, not to any work done\n", "   * to complete the returned {@code Future}.\n"], "9": ["   * <pre>   {@code\n", "   *   ListenableFuture<RowKey> rowKeyFuture = indexService.lookUp(query);\n", "   *   AsyncFunction<RowKey, QueryResult> queryFunction =\n", "   *       new AsyncFunction<RowKey, QueryResult>() {\n", "   *         public ListenableFuture<QueryResult> apply(RowKey rowKey) {\n", "   *           return dataService.read(rowKey);\n", "   *         }\n", "   *       };\n", "   *   ListenableFuture<QueryResult> queryFuture =\n", "   *       transformAsync(rowKeyFuture, queryFunction, executor);}</pre>\n", "   * documentation. The documentation's warnings about \"lightweight listeners\" refer here to the\n", "   * work done during {@code AsyncFunction.apply}, not to any work done to complete the returned\n", "   * {@code Future}.\n"], "10": ["   * Function<QueryResult, List<Row>> rowsFunction =\n", "   *     new Function<QueryResult, List<Row>>() {\n", "   *       public List<Row> apply(QueryResult queryResult) {\n", "   *         return queryResult.getRows();\n", "   *       }\n", "   *     };\n", "   *     transform(queryFuture, rowsFunction);\n", "   * ListenableFuture.addListener} documentation. The documentation's warnings about \"lightweight\n", "   * listeners\" refer here to the work done during {@code Function.apply}.\n"], "11": ["   * <pre>   {@code\n", "   *   ListenableFuture<QueryResult> queryFuture = ...;\n", "   *   Function<QueryResult, List<Row>> rowsFunction =\n", "   *       new Function<QueryResult, List<Row>>() {\n", "   *         public List<Row> apply(QueryResult queryResult) {\n", "   *           return queryResult.getRows();\n", "   *         }\n", "   *       };\n", "   *   ListenableFuture<List<Row>> rowsFuture =\n", "   *       transform(queryFuture, rowsFunction, executor);}</pre>\n", "   * documentation. The documentation's warnings about \"lightweight listeners\" refer here to the\n", "   * work done during {@code Function.apply}.\n"], "12": ["   * ListenableFuture.addListener} documentation.\n"], "13": ["   * <p>The callback is run in {@code executor}. There is no guaranteed ordering of execution of\n", "   * Example: <pre> {@code\n"], "14": ["   *     }, e);}</pre>\n", "   * documentation.\n"]}, "added_lines": {"1": [54, 55, 56, 57, 58, 59, 60, 61, 62, 63, 64, 65, 66, 67], "2": [258, 263, 264], "3": [303, 304, 305, 306, 307, 308, 309, 310, 314, 315], "4": [356], "5": [367, 368, 369, 370, 371, 373, 379, 380, 381, 382, 383], "6": [423, 424, 425, 426, 427, 428, 429, 430, 434, 435, 436, 437, 438, 439, 440, 441, 442, 443, 444, 445, 446, 447, 448, 449, 453, 454, 455, 456], "8": [515, 520, 521, 522, 523, 524], "9": [559, 560, 561, 562, 563, 567, 568, 569, 570], "10": [601, 606, 607], "11": [639, 640, 641, 642, 643, 647, 648], "12": [1126, 1127], "13": [1152, 1156, 1157, 1158], "14": [1169, 1170, 1174, 1175]}, "removed_lines": {"1": [54, 55], "2": [246, 247, 248, 249, 250, 251, 256, 257], "3": [296, 297, 298, 299, 300, 301, 302, 303, 304, 305, 306, 307, 311, 312], "4": [353, 354, 355, 356, 357, 358], "5": [369, 370, 371, 372, 373, 374, 375, 376, 383, 384, 385], "6": [425, 426, 427, 428, 429, 430, 431, 432, 433, 434, 435, 436, 440, 441, 442, 443, 444, 445, 446, 447, 448, 449, 450, 451, 452, 453, 454, 455, 459, 460, 461], "7": [497], "8": [520, 521, 522, 523, 524, 525, 527, 532, 533, 534], "9": [569, 570, 571, 572, 573, 574, 575, 576, 577, 578, 582, 583, 584], "10": [614, 615, 616, 617, 618, 619, 621, 626, 627], "11": [659, 660, 661, 662, 663, 664, 665, 666, 667, 668, 672, 673], "12": [1151], "13": [1176, 1180], "14": [1191, 1195]}}, {"15": "guava/src/com/google/common/util/concurrent/GwtFluentFutureCatchingSpecialization.java", "added": {"1": ["/*\n", " * Copyright (C) 2006 The Guava Authors\n", " *\n", " * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not use this file except\n", " * in compliance with the License. You may obtain a copy of the License at\n", " *\n", " * http://www.apache.org/licenses/LICENSE-2.0\n", " *\n", " * Unless required by applicable law or agreed to in writing, software distributed under the License\n", " * is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express\n", " * or implied. See the License for the specific language governing permissions and limitations under\n", " * the License.\n", " */\n", "\n", "package com.google.common.util.concurrent;\n", "\n", "import com.google.common.annotations.GwtCompatible;\n", "\n", "/**\n", " * Hidden superclass of {@link FluentFuture} that provides us a place to declare special GWT\n", " * versions of the {@link FluentFuture#catching(Class, com.google.common.base.Function)\n", " * FluentFuture.catching} family of methods. Those versions have slightly different signatures.\n", " */\n", "@GwtCompatible(emulated = true)\n", "abstract class GwtFluentFutureCatchingSpecialization<V> implements ListenableFuture<V> {\n", "  /*\n", "   * This server copy of the class is empty. The corresponding GWT copy contains alternative\n", "   * versions of catching() and catchingAsync() with slightly different signatures from the ones\n", "   * found in FluentFuture.java.\n", "   */\n", "}\n"]}, "removed": {}, "added_lines": {"1": [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31]}, "removed_lines": {}}, {"16": "guava/src/com/google/common/util/concurrent/ImmediateFuture.java", "added": {"1": ["/** Implementations of {@code Futures.immediate*}. */\n", "abstract class ImmediateFuture<V> extends FluentFuture<V> {\n"]}, "removed": {"1": ["/**\n", " * Implementations of {@code Futures.immediate*}.\n", " */\n", "abstract class ImmediateFuture<V> implements ListenableFuture<V> {\n"]}, "added_lines": {"1": [29, 31]}, "removed_lines": {"1": [29, 30, 31, 33]}}]}
