{"id": "1dee5c1bb5dcfec9ea9c7703262638fda07a7e16", "code": [{"0": "android/guava/src/com/google/common/io/Files.java", "added": {}, "removed": {"1": ["   * <p>If available, consider using {@link MoreFiles#fileTraverser()} instead. It behaves the same\n", "   * except that it doesn't follow symbolic links and returns {@code Path} instances.\n", "   *\n"]}, "added_lines": {}, "removed_lines": {"1": [855, 856, 857]}}, {"1": "guava-tests/test/com/google/common/io/MoreFilesFileTraverserTest.java", "added": {}, "removed": {"1": ["/*\n", " * Copyright (C) 2017 The Guava Authors\n", " *\n", " * Licensed under the Apache License, Version 2.0 (the \"License\");\n", " * you may not use this file except in compliance with the License.\n", " * You may obtain a copy of the License at\n", " *\n", " * http://www.apache.org/licenses/LICENSE-2.0\n", " *\n", " * Unless required by applicable law or agreed to in writing, software\n", " * distributed under the License is distributed on an \"AS IS\" BASIS,\n", " * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n", " * See the License for the specific language governing permissions and\n", " * limitations under the License.\n", " */\n", "\n", "package com.google.common.io;\n", "\n", "import static com.google.common.truth.Truth.assertThat;\n", "\n", "import com.google.common.collect.Iterables;\n", "import com.google.errorprone.annotations.CanIgnoreReturnValue;\n", "import java.io.IOException;\n", "import java.nio.file.Path;\n", "import junit.framework.TestCase;\n", "\n", "/**\n", " * Tests for {@link MoreFiles#fileTraverser()}.\n", " *\n", " * @author Jens Nyman\n", " */\n", "\n", "public class MoreFilesFileTraverserTest extends TestCase {\n", "\n", "  private Path rootDir;\n", "\n", "  @Override\n", "  public void setUp() throws IOException {\n", "    rootDir = Files.createTempDir().toPath();\n", "  }\n", "\n", "  @Override\n", "  public void tearDown() throws IOException {\n", "    MoreFiles.deleteRecursively(rootDir);\n", "  }\n", "\n", "  public void testFileTraverser_emptyDirectory() throws Exception {\n", "    assertThat(MoreFiles.fileTraverser().breadthFirst(rootDir)).containsExactly(rootDir);\n", "  }\n", "\n", "  public void testFileTraverser_nonExistingFile() throws Exception {\n", "    Path file = rootDir.resolve(\"file-that-doesnt-exist\");\n", "\n", "    assertThat(MoreFiles.fileTraverser().breadthFirst(file)).containsExactly(file);\n", "  }\n", "\n", "  public void testFileTraverser_file() throws Exception {\n", "    Path file = newFile(\"some-file\");\n", "\n", "    assertThat(MoreFiles.fileTraverser().breadthFirst(file)).containsExactly(file);\n", "  }\n", "\n", "  public void testFileTraverser_singleFile() throws Exception {\n", "    Path file = newFile(\"some-file\");\n", "\n", "    assertThat(MoreFiles.fileTraverser().breadthFirst(rootDir)).containsExactly(rootDir, file);\n", "  }\n", "\n", "  public void testFileTraverser_singleDirectory() throws Exception {\n", "    Path file = newDir(\"some-dir\");\n", "\n", "    assertThat(MoreFiles.fileTraverser().breadthFirst(rootDir)).containsExactly(rootDir, file);\n", "  }\n", "\n", "  public void testFileTraverser_multipleFilesAndDirectories() throws Exception {\n", "    Path fileA = newFile(\"file-a\");\n", "    Path fileB = newFile(\"file-b\");\n", "    Path dir1 = newDir(\"dir-1\");\n", "    Path dir2 = newDir(\"dir-2\");\n", "\n", "    assertThat(MoreFiles.fileTraverser().breadthFirst(rootDir))\n", "        .containsExactly(rootDir, fileA, fileB, dir1, dir2);\n", "  }\n", "\n", "  public void testFileTraverser_multipleDirectoryLayers_breadthFirstStartsWithTopLayer()\n", "      throws Exception {\n", "    Path fileA = newFile(\"file-a\");\n", "    Path dir1 = newDir(\"dir-1\");\n", "    newFile(\"dir-1/file-b\");\n", "    newFile(\"dir-1/dir-2\");\n", "\n", "    assertThat(Iterables.limit(MoreFiles.fileTraverser().breadthFirst(rootDir), 3))\n", "        .containsExactly(rootDir, fileA, dir1);\n", "  }\n", "\n", "  public void testFileTraverser_multipleDirectoryLayers_traversalReturnsAll() throws Exception {\n", "    Path fileA = newFile(\"file-a\");\n", "    Path dir1 = newDir(\"dir-1\");\n", "    Path fileB = newFile(\"dir-1/file-b\");\n", "    Path dir2 = newFile(\"dir-1/dir-2\");\n", "\n", "    assertThat(MoreFiles.fileTraverser().breadthFirst(rootDir))\n", "        .containsExactly(rootDir, fileA, fileB, dir1, dir2);\n", "  }\n", "\n", "  @CanIgnoreReturnValue\n", "  private Path newDir(String name) {\n", "    Path dir = rootDir.resolve(name);\n", "    dir.toFile().mkdir();\n", "    return dir;\n", "  }\n", "\n", "  @CanIgnoreReturnValue\n", "  private Path newFile(String name) throws IOException {\n", "    Path file = rootDir.resolve(name);\n", "    file.toFile().createNewFile();\n", "    return file;\n", "  }\n", "}\n"]}, "added_lines": {}, "removed_lines": {"1": [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 58, 59, 60, 61, 62, 63, 64, 65, 66, 67, 68, 69, 70, 71, 72, 73, 74, 75, 76, 77, 78, 79, 80, 81, 82, 83, 84, 85, 86, 87, 88, 89, 90, 91, 92, 93, 94, 95, 96, 97, 98, 99, 100, 101, 102, 103, 104, 105, 106, 107, 108, 109, 110, 111, 112, 113, 114, 115, 116, 117, 118, 119]}}, {"2": "guava-tests/test/com/google/common/io/MoreFilesTest.java", "added": {}, "removed": {"1": [" * <p>Note: {@link MoreFiles#fileTraverser()} is tested in {@link MoreFilesFileTraverserTest}.\n", " *\n"]}, "added_lines": {}, "removed_lines": {"1": [51, 52]}}, {"3": "guava/src/com/google/common/io/Files.java", "added": {}, "removed": {"1": ["   * <p>If available, consider using {@link MoreFiles#fileTraverser()} instead. It behaves the same\n", "   * except that it doesn't follow symbolic links and returns {@code Path} instances.\n", "   *\n"]}, "added_lines": {}, "removed_lines": {"1": [855, 856, 857]}}, {"4": "guava/src/com/google/common/io/MoreFiles.java", "added": {"2": ["      if (Files.isDirectory(dir, NOFOLLOW_LINKS)) {\n", "        try {\n", "          return listFiles(dir);\n", "        } catch (IOException e) {\n", "          // the exception thrown when iterating a DirectoryStream if an I/O exception occurs\n", "          throw new DirectoryIteratorException(e);\n", "      return ImmutableList.of();\n"]}, "removed": {"1": ["import com.google.common.graph.SuccessorsFunction;\n", "import com.google.common.graph.Traverser;\n"], "2": ["      return fileTreeChildren(dir);\n", "    }\n", "  }\n", "\n", "  /**\n", "   * Returns a {@link Traverser} instance for the file and directory tree. The returned traverser\n", "   * starts from a {@link Path} and will return all files and directories it encounters.\n", "   *\n", "   * <p>The returned traverser attempts to avoid following symbolic links to directories. However,\n", "   * the traverser cannot guarantee that it will not follow symbolic links to directories as it is\n", "   * possible for a directory to be replaced with a symbolic link between checking if the file is a\n", "   * directory and actually reading the contents of that directory.\n", "   *\n", "   * <p>If the {@link Path} passed to one of the traversal methods does not exist or is not a\n", "   * directory, no exception will be thrown and the returned {@link Iterable} will contain a single\n", "   * element: that path.\n", "   *\n", "   * <p>{@link DirectoryIteratorException} may be thrown when iterating {@link Iterable} instances\n", "   * created by this traverser if an {@link IOException} is thrown by a call to {@link\n", "   * #listFiles(Path)}.\n", "   *\n", "   * <p>Example: {@code MoreFiles.fileTraverser().breadhFirst(\"/\")} may return files with the\n", "   * following paths: {@code [\"/\", \"/etc\", \"/home\", \"/usr\", \"/etc/config.txt\", \"/etc/fonts\", ...]}\n", "   */\n", "  public static Traverser<Path> fileTraverser() {\n", "    return Traverser.forTree(FILE_TREE);\n", "  }\n", "\n", "  private static final SuccessorsFunction<Path> FILE_TREE =\n", "      new SuccessorsFunction<Path>() {\n", "        @Override\n", "        public Iterable<Path> successors(Path path) {\n", "          return fileTreeChildren(path);\n", "      };\n", "\n", "  private static Iterable<Path> fileTreeChildren(Path dir) {\n", "    if (Files.isDirectory(dir, NOFOLLOW_LINKS)) {\n", "      try {\n", "        return listFiles(dir);\n", "      } catch (IOException e) {\n", "        // the exception thrown when iterating a DirectoryStream if an I/O exception occurs\n", "        throw new DirectoryIteratorException(e);\n", "    return ImmutableList.of();\n"]}, "added_lines": {"2": [294, 295, 296, 297, 298, 299, 302]}, "removed_lines": {"1": [28, 29], "2": [296, 297, 298, 299, 300, 301, 302, 303, 304, 305, 306, 307, 308, 309, 310, 311, 312, 313, 314, 315, 316, 317, 318, 319, 320, 321, 322, 323, 324, 325, 326, 327, 328, 330, 331, 332, 333, 334, 335, 336, 337, 338, 341]}}]}
