{
    "addition": {
        "19": "import static com.google.common.base.Preconditions.checkArgument;\n",
        "23": "import com.google.common.base.Function;\n",
        "24": "import com.google.common.collect.ImmutableSet;\n",
        "25": "import com.google.common.collect.Iterators;\n",
        "26": "import com.google.common.collect.Sets;\n",
        "77": "      @Override\n",
        "78": "      public boolean remove(Object o) {\n",
        "79": "        throw new UnsupportedOperationException();\n",
        "80": "      }\n",
        "81": "\n",
        "99": "  @Override\n",
        "100": "  public Set<EndpointPair<N>> incidentEdges(N node) {\n",
        "101": "    checkNotNull(node);\n",
        "102": "    checkArgument(nodes().contains(node), \"Node %s is not an element of this graph.\", node);\n",
        "103": "    return IncidentEdgeSet.of(this, node);\n",
        "104": "  }\n",
        "105": "\n",
        "133": "\n",
        "134": "  private abstract static class IncidentEdgeSet<N> extends AbstractSet<EndpointPair<N>> {\n",
        "135": "    protected final N node;\n",
        "136": "    protected final BaseGraph<N> graph;\n",
        "137": "\n",
        "138": "    public static <N> IncidentEdgeSet<N> of(BaseGraph<N> graph, N node) {\n",
        "139": "      return graph.isDirected() ? new Directed<>(graph, node) : new Undirected<>(graph, node);\n",
        "140": "    }\n",
        "141": "\n",
        "142": "    private IncidentEdgeSet(BaseGraph<N> graph, N node) {\n",
        "143": "      this.graph = graph;\n",
        "144": "      this.node = node;\n",
        "145": "    }\n",
        "146": "\n",
        "147": "    @Override\n",
        "148": "    public boolean remove(Object o) {\n",
        "149": "      throw new UnsupportedOperationException();\n",
        "150": "    }\n",
        "151": "\n",
        "152": "    private static final class Directed<N> extends IncidentEdgeSet<N> {\n",
        "153": "\n",
        "154": "      private Directed(BaseGraph<N> graph, N node) {\n",
        "155": "        super(graph, node);\n",
        "156": "      }\n",
        "157": "\n",
        "158": "      @Override\n",
        "159": "      public UnmodifiableIterator<EndpointPair<N>> iterator() {\n",
        "160": "        return Iterators.unmodifiableIterator(\n",
        "161": "            Iterators.concat(\n",
        "162": "                Iterators.transform(\n",
        "163": "                    graph.predecessors(node).iterator(),\n",
        "164": "                    new Function<N, EndpointPair<N>>() {\n",
        "165": "                      @Override\n",
        "166": "                      public EndpointPair<N> apply(N predecessor) {\n",
        "167": "                        return EndpointPair.ordered(predecessor, node);\n",
        "168": "                      }\n",
        "169": "                    }),\n",
        "170": "                Iterators.transform(\n",
        "171": "                    // filter out 'node' from successors (already covered by predecessors, above)\n",
        "172": "                    Sets.difference(graph.successors(node), ImmutableSet.of(node)).iterator(),\n",
        "173": "                    new Function<N, EndpointPair<N>>() {\n",
        "174": "                      @Override\n",
        "175": "                      public EndpointPair<N> apply(N successor) {\n",
        "176": "                        return EndpointPair.ordered(node, successor);\n",
        "177": "                      }\n",
        "178": "                    })));\n",
        "179": "      }\n",
        "180": "\n",
        "181": "      @Override\n",
        "182": "      public int size() {\n",
        "183": "        return graph.inDegree(node)\n",
        "184": "            + graph.outDegree(node)\n",
        "185": "            - (graph.successors(node).contains(node) ? 1 : 0);\n",
        "186": "      }\n",
        "187": "\n",
        "188": "      @Override\n",
        "189": "      public boolean contains(@NullableDecl Object obj) {\n",
        "190": "        if (!(obj instanceof EndpointPair)) {\n",
        "191": "          return false;\n",
        "192": "        }\n",
        "193": "\n",
        "194": "        EndpointPair<?> endpointPair = (EndpointPair<?>) obj;\n",
        "195": "        if (!endpointPair.isOrdered()) {\n",
        "196": "          return false;\n",
        "197": "        }\n",
        "198": "\n",
        "199": "        Object source = endpointPair.source();\n",
        "200": "        Object target = endpointPair.target();\n",
        "201": "        return (node.equals(source) && graph.successors(node).contains(target))\n",
        "202": "            || (node.equals(target) && graph.predecessors(node).contains(source));\n",
        "203": "      }\n",
        "204": "    }\n",
        "205": "\n",
        "206": "    private static final class Undirected<N> extends IncidentEdgeSet<N> {\n",
        "207": "      private Undirected(BaseGraph<N> graph, N node) {\n",
        "208": "        super(graph, node);\n",
        "209": "      }\n",
        "210": "\n",
        "211": "      @Override\n",
        "212": "      public UnmodifiableIterator<EndpointPair<N>> iterator() {\n",
        "213": "        return Iterators.unmodifiableIterator(\n",
        "214": "            Iterators.transform(\n",
        "215": "                graph.adjacentNodes(node).iterator(),\n",
        "216": "                new Function<N, EndpointPair<N>>() {\n",
        "217": "                  @Override\n",
        "218": "                  public EndpointPair<N> apply(N adjacentNode) {\n",
        "219": "                    return EndpointPair.unordered(node, adjacentNode);\n",
        "220": "                  }\n",
        "221": "                }));\n",
        "222": "      }\n",
        "223": "\n",
        "224": "      @Override\n",
        "225": "      public int size() {\n",
        "226": "        return graph.adjacentNodes(node).size();\n",
        "227": "      }\n",
        "228": "\n",
        "229": "      @Override\n",
        "230": "      public boolean contains(@NullableDecl Object obj) {\n",
        "231": "        if (!(obj instanceof EndpointPair)) {\n",
        "232": "          return false;\n",
        "233": "        }\n",
        "234": "\n",
        "235": "        EndpointPair<?> endpointPair = (EndpointPair<?>) obj;\n",
        "236": "        if (endpointPair.isOrdered()) {\n",
        "237": "          return false;\n",
        "238": "        }\n",
        "239": "        Set<N> adjacent = graph.adjacentNodes(node);\n",
        "240": "        Object nodeU = endpointPair.nodeU();\n",
        "241": "        Object nodeV = endpointPair.nodeV();\n",
        "242": "\n",
        "243": "        return (node.equals(nodeV) && adjacent.contains(nodeU))\n",
        "244": "            || (node.equals(nodeU) && adjacent.contains(nodeV));\n",
        "245": "      }\n",
        "246": "    }\n",
        "247": "  }\n"
    },
    "removed": {}
}