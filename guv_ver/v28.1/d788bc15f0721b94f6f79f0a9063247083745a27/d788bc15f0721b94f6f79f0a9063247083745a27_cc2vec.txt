{"id": "d788bc15f0721b94f6f79f0a9063247083745a27", "code": [{"0": "android/guava-tests/test/com/google/common/graph/AbstractDirectedGraphTest.java", "added": {"1": ["  @Test\n", "  public void incidentEdges_oneEdge() {\n", "    putEdge(N1, N2);\n", "    EndpointPair<Integer> expectedEndpoints = EndpointPair.ordered(N1, N2);\n", "    assertThat(graph.incidentEdges(N1)).containsExactly(expectedEndpoints);\n", "    assertThat(graph.incidentEdges(N2)).containsExactly(expectedEndpoints);\n", "  }\n", "\n"]}, "removed": {}, "added_lines": {"1": [47, 48, 49, 50, 51, 52, 53, 54]}, "removed_lines": {}}, {"1": "android/guava-tests/test/com/google/common/graph/AbstractGraphTest.java", "added": {"1": ["        assertThat(graph.incidentEdges(node)).contains(EndpointPair.of(graph, predecessor, node));\n", "        assertThat(graph.incidentEdges(node)).contains(EndpointPair.of(graph, node, successor));\n", "      }\n", "\n", "      for (EndpointPair<N> endpoints : sanityCheckSet(graph.incidentEdges(node))) {\n", "        if (graph.isDirected()) {\n", "          assertThat(graph.hasEdgeConnecting(endpoints.source(), endpoints.target())).isTrue();\n", "        } else {\n", "          assertThat(graph.hasEdgeConnecting(endpoints.nodeU(), endpoints.nodeV())).isTrue();\n", "        }\n"], "2": ["  /**\n", "   * Verifies that the {@code Set} returned by {@code incidentEdges} has the expected mutability\n", "   * property (see the {@code Graph} documentation for more information).\n", "   */\n", "  @Test\n", "  public abstract void incidentEdges_checkReturnedSetMutability();\n", "\n"], "3": ["  @Test\n", "  public void incidentEdges_noIncidentEdges() {\n", "    addNode(N1);\n", "    assertThat(graph.incidentEdges(N1)).isEmpty();\n", "  }\n", "\n", "  @Test\n", "  public void incidentEdges_nodeNotInGraph() {\n", "    try {\n", "      graph.incidentEdges(NODE_NOT_IN_GRAPH);\n", "      fail(ERROR_NODE_NOT_IN_GRAPH);\n", "    } catch (IllegalArgumentException e) {\n", "      assertNodeNotInGraphErrorMessage(e);\n", "    }\n", "  }\n", "\n"]}, "removed": {}, "added_lines": {"1": [159, 166, 167, 168, 169, 170, 171, 172, 173, 174], "2": [211, 212, 213, 214, 215, 216, 217], "3": [284, 285, 286, 287, 288, 289, 290, 291, 292, 293, 294, 295, 296, 297, 298, 299]}, "removed_lines": {}}, {"2": "android/guava-tests/test/com/google/common/graph/AbstractUndirectedGraphTest.java", "added": {"1": ["  @Test\n", "  public void incidentEdges_oneEdge() {\n", "    putEdge(N1, N2);\n", "    EndpointPair<Integer> expectedEndpoints = EndpointPair.unordered(N1, N2);\n", "    assertThat(graph.incidentEdges(N1)).containsExactly(expectedEndpoints);\n", "    assertThat(graph.incidentEdges(N2)).containsExactly(expectedEndpoints);\n", "  }\n", "\n"]}, "removed": {}, "added_lines": {"1": [58, 59, 60, 61, 62, 63, 64, 65]}, "removed_lines": {}}, {"3": "android/guava-tests/test/com/google/common/graph/ConfigurableDirectedGraphTest.java", "added": {"1": ["  @Test\n", "  public void incidentEdges_selfLoop() {\n", "    putEdge(N1, N1);\n", "    assertThat(graph.incidentEdges(N1)).containsExactly(EndpointPair.ordered(N1, N1));\n", "    putEdge(N1, N2);\n", "    assertThat(graph.incidentEdges(N1)).containsExactly(\n", "        EndpointPair.ordered(N1, N1),\n", "        EndpointPair.ordered(N1, N2));\n", "  }\n", "\n"]}, "removed": {}, "added_lines": {"1": [57, 58, 59, 60, 61, 62, 63, 64, 65, 66]}, "removed_lines": {}}, {"4": "android/guava-tests/test/com/google/common/graph/ConfigurableSimpleDirectedGraphTest.java", "added": {"1": ["  @Override\n", "  @Test\n", "  public void incidentEdges_checkReturnedSetMutability() {\n", "    addNode(N1);\n", "    Set<EndpointPair<Integer>> incidentEdges = graph.incidentEdges(N1);\n", "    try {\n", "      incidentEdges.add(EndpointPair.ordered(N1, N2));\n", "      fail(ERROR_MODIFIABLE_SET);\n", "    } catch (UnsupportedOperationException e) {\n", "      putEdge(N1, N2);\n", "      assertThat(incidentEdges).containsExactlyElementsIn(graph.incidentEdges(N1));\n", "    }\n", "  }\n", "\n"]}, "removed": {}, "added_lines": {"1": [95, 96, 97, 98, 99, 100, 101, 102, 103, 104, 105, 106, 107, 108]}, "removed_lines": {}}, {"5": "android/guava-tests/test/com/google/common/graph/ConfigurableSimpleUndirectedGraphTest.java", "added": {"1": ["  @Override\n", "  @Test\n", "  public void incidentEdges_checkReturnedSetMutability() {\n", "    addNode(N1);\n", "    Set<EndpointPair<Integer>> incidentEdges = graph.incidentEdges(N1);\n", "    try {\n", "      incidentEdges.add(EndpointPair.unordered(N1, N2));\n", "      fail(ERROR_MODIFIABLE_SET);\n", "    } catch (UnsupportedOperationException e) {\n", "      putEdge(N1, N2);\n", "      assertThat(incidentEdges).containsExactlyElementsIn(graph.incidentEdges(N1));\n", "    }\n", "  }\n", "\n"]}, "removed": {}, "added_lines": {"1": [95, 96, 97, 98, 99, 100, 101, 102, 103, 104, 105, 106, 107, 108]}, "removed_lines": {}}, {"6": "android/guava-tests/test/com/google/common/graph/ConfigurableUndirectedGraphTest.java", "added": {"1": ["  @Test\n", "  public void incidentEdges_selfLoop() {\n", "    putEdge(N1, N1);\n", "    assertThat(graph.incidentEdges(N1)).containsExactly(EndpointPair.unordered(N1, N1));\n", "    putEdge(N1, N2);\n", "    assertThat(graph.incidentEdges(N1)).containsExactly(\n", "        EndpointPair.unordered(N1, N1),\n", "        EndpointPair.unordered(N1, N2));\n", "  }\n", "\n"]}, "removed": {}, "added_lines": {"1": [57, 58, 59, 60, 61, 62, 63, 64, 65, 66]}, "removed_lines": {}}, {"7": "android/guava/src/com/google/common/graph/AbstractBaseGraph.java", "added": {"1": ["import static com.google.common.base.Preconditions.checkArgument;\n", "import com.google.common.base.Function;\n", "import com.google.common.collect.ImmutableSet;\n", "import com.google.common.collect.Iterators;\n", "import com.google.common.collect.Sets;\n"], "2": ["      @Override\n", "      public boolean remove(Object o) {\n", "        throw new UnsupportedOperationException();\n", "      }\n", "\n"], "3": ["  @Override\n", "  public Set<EndpointPair<N>> incidentEdges(N node) {\n", "    checkNotNull(node);\n", "    checkArgument(nodes().contains(node), \"Node %s is not an element of this graph.\", node);\n", "    return IncidentEdgeSet.of(this, node);\n", "  }\n", "\n"], "4": ["\n", "  private abstract static class IncidentEdgeSet<N> extends AbstractSet<EndpointPair<N>> {\n", "    protected final N node;\n", "    protected final BaseGraph<N> graph;\n", "\n", "    public static <N> IncidentEdgeSet<N> of(BaseGraph<N> graph, N node) {\n", "      return graph.isDirected() ? new Directed<>(graph, node) : new Undirected<>(graph, node);\n", "    }\n", "\n", "    private IncidentEdgeSet(BaseGraph<N> graph, N node) {\n", "      this.graph = graph;\n", "      this.node = node;\n", "    }\n", "\n", "    @Override\n", "    public boolean remove(Object o) {\n", "      throw new UnsupportedOperationException();\n", "    }\n", "\n", "    private static final class Directed<N> extends IncidentEdgeSet<N> {\n", "\n", "      private Directed(BaseGraph<N> graph, N node) {\n", "        super(graph, node);\n", "      }\n", "\n", "      @Override\n", "      public UnmodifiableIterator<EndpointPair<N>> iterator() {\n", "        return Iterators.unmodifiableIterator(\n", "            Iterators.concat(\n", "                Iterators.transform(\n", "                    graph.predecessors(node).iterator(),\n", "                    new Function<N, EndpointPair<N>>() {\n", "                      @Override\n", "                      public EndpointPair<N> apply(N predecessor) {\n", "                        return EndpointPair.ordered(predecessor, node);\n", "                      }\n", "                    }),\n", "                Iterators.transform(\n", "                    // filter out 'node' from successors (already covered by predecessors, above)\n", "                    Sets.difference(graph.successors(node), ImmutableSet.of(node)).iterator(),\n", "                    new Function<N, EndpointPair<N>>() {\n", "                      @Override\n", "                      public EndpointPair<N> apply(N successor) {\n", "                        return EndpointPair.ordered(node, successor);\n", "                      }\n", "                    })));\n", "      }\n", "\n", "      @Override\n", "      public int size() {\n", "        return graph.inDegree(node)\n", "            + graph.outDegree(node)\n", "            - (graph.successors(node).contains(node) ? 1 : 0);\n", "      }\n", "\n", "      @Override\n", "      public boolean contains(@NullableDecl Object obj) {\n", "        if (!(obj instanceof EndpointPair)) {\n", "          return false;\n", "        }\n", "\n", "        EndpointPair<?> endpointPair = (EndpointPair<?>) obj;\n", "        if (!endpointPair.isOrdered()) {\n", "          return false;\n", "        }\n", "\n", "        Object source = endpointPair.source();\n", "        Object target = endpointPair.target();\n", "        return (node.equals(source) && graph.successors(node).contains(target))\n", "            || (node.equals(target) && graph.predecessors(node).contains(source));\n", "      }\n", "    }\n", "\n", "    private static final class Undirected<N> extends IncidentEdgeSet<N> {\n", "      private Undirected(BaseGraph<N> graph, N node) {\n", "        super(graph, node);\n", "      }\n", "\n", "      @Override\n", "      public UnmodifiableIterator<EndpointPair<N>> iterator() {\n", "        return Iterators.unmodifiableIterator(\n", "            Iterators.transform(\n", "                graph.adjacentNodes(node).iterator(),\n", "                new Function<N, EndpointPair<N>>() {\n", "                  @Override\n", "                  public EndpointPair<N> apply(N adjacentNode) {\n", "                    return EndpointPair.unordered(node, adjacentNode);\n", "                  }\n", "                }));\n", "      }\n", "\n", "      @Override\n", "      public int size() {\n", "        return graph.adjacentNodes(node).size();\n", "      }\n", "\n", "      @Override\n", "      public boolean contains(@NullableDecl Object obj) {\n", "        if (!(obj instanceof EndpointPair)) {\n", "          return false;\n", "        }\n", "\n", "        EndpointPair<?> endpointPair = (EndpointPair<?>) obj;\n", "        if (endpointPair.isOrdered()) {\n", "          return false;\n", "        }\n", "        Set<N> adjacent = graph.adjacentNodes(node);\n", "        Object nodeU = endpointPair.nodeU();\n", "        Object nodeV = endpointPair.nodeV();\n", "\n", "        return (node.equals(nodeV) && adjacent.contains(nodeU))\n", "            || (node.equals(nodeU) && adjacent.contains(nodeV));\n", "      }\n", "    }\n", "  }\n"]}, "removed": {}, "added_lines": {"1": [19, 23, 24, 25, 26], "2": [77, 78, 79, 80, 81], "3": [99, 100, 101, 102, 103, 104, 105], "4": [133, 134, 135, 136, 137, 138, 139, 140, 141, 142, 143, 144, 145, 146, 147, 148, 149, 150, 151, 152, 153, 154, 155, 156, 157, 158, 159, 160, 161, 162, 163, 164, 165, 166, 167, 168, 169, 170, 171, 172, 173, 174, 175, 176, 177, 178, 179, 180, 181, 182, 183, 184, 185, 186, 187, 188, 189, 190, 191, 192, 193, 194, 195, 196, 197, 198, 199, 200, 201, 202, 203, 204, 205, 206, 207, 208, 209, 210, 211, 212, 213, 214, 215, 216, 217, 218, 219, 220, 221, 222, 223, 224, 225, 226, 227, 228, 229, 230, 231, 232, 233, 234, 235, 236, 237, 238, 239, 240, 241, 242, 243, 244, 245, 246, 247]}, "removed_lines": {}}, {"8": "android/guava/src/com/google/common/graph/BaseGraph.java", "added": {"1": ["  /**\n", "   * Returns the edges in this graph whose endpoints include {@code node}.\n", "   *\n", "   * @throws IllegalArgumentException if {@code node} is not an element of this graph\n", "   */\n", "  Set<EndpointPair<N>> incidentEdges(N node);\n", "\n", "   * <p>For undirected graphs, this is equal to {@code incidentEdges(node).size()} + (number of\n", "   * self-loops incident to {@code node}).\n"]}, "removed": {"1": ["   * <p>For undirected graphs, this is equal to {@code adjacentNodes(node).size()} + (1 if {@code\n", "   * node} has an incident self-loop, 0 otherwise).\n"]}, "added_lines": {"1": [95, 96, 97, 98, 99, 100, 101, 108, 109]}, "removed_lines": {"1": [101, 102]}}, {"9": "android/guava/src/com/google/common/graph/Graph.java", "added": {"1": ["  /** {@inheritDoc} */\n", "  @Override\n", "  Set<EndpointPair<N>> incidentEdges(N node);\n", "\n"]}, "removed": {}, "added_lines": {"1": [148, 149, 150, 151]}, "removed_lines": {}}, {"10": "android/guava/src/com/google/common/graph/ValueGraph.java", "added": {"1": ["  /** {@inheritDoc} */\n", "  @Override\n", "  Set<EndpointPair<N>> incidentEdges(N node);\n", "\n"]}, "removed": {}, "added_lines": {"1": [160, 161, 162, 163]}, "removed_lines": {}}, {"11": "guava-tests/test/com/google/common/graph/AbstractDirectedGraphTest.java", "added": {"1": ["  @Test\n", "  public void incidentEdges_oneEdge() {\n", "    putEdge(N1, N2);\n", "    EndpointPair<Integer> expectedEndpoints = EndpointPair.ordered(N1, N2);\n", "    assertThat(graph.incidentEdges(N1)).containsExactly(expectedEndpoints);\n", "    assertThat(graph.incidentEdges(N2)).containsExactly(expectedEndpoints);\n", "  }\n", "\n"]}, "removed": {}, "added_lines": {"1": [47, 48, 49, 50, 51, 52, 53, 54]}, "removed_lines": {}}, {"12": "guava-tests/test/com/google/common/graph/AbstractGraphTest.java", "added": {"1": ["        assertThat(graph.incidentEdges(node)).contains(EndpointPair.of(graph, predecessor, node));\n", "        assertThat(graph.incidentEdges(node)).contains(EndpointPair.of(graph, node, successor));\n", "      }\n", "\n", "      for (EndpointPair<N> endpoints : sanityCheckSet(graph.incidentEdges(node))) {\n", "        if (graph.isDirected()) {\n", "          assertThat(graph.hasEdgeConnecting(endpoints.source(), endpoints.target())).isTrue();\n", "        } else {\n", "          assertThat(graph.hasEdgeConnecting(endpoints.nodeU(), endpoints.nodeV())).isTrue();\n", "        }\n"], "2": ["  /**\n", "   * Verifies that the {@code Set} returned by {@code incidentEdges} has the expected mutability\n", "   * property (see the {@code Graph} documentation for more information).\n", "   */\n", "  @Test\n", "  public abstract void incidentEdges_checkReturnedSetMutability();\n", "\n"], "3": ["  @Test\n", "  public void incidentEdges_noIncidentEdges() {\n", "    addNode(N1);\n", "    assertThat(graph.incidentEdges(N1)).isEmpty();\n", "  }\n", "\n", "  @Test\n", "  public void incidentEdges_nodeNotInGraph() {\n", "    try {\n", "      graph.incidentEdges(NODE_NOT_IN_GRAPH);\n", "      fail(ERROR_NODE_NOT_IN_GRAPH);\n", "    } catch (IllegalArgumentException e) {\n", "      assertNodeNotInGraphErrorMessage(e);\n", "    }\n", "  }\n", "\n"]}, "removed": {}, "added_lines": {"1": [159, 166, 167, 168, 169, 170, 171, 172, 173, 174], "2": [211, 212, 213, 214, 215, 216, 217], "3": [284, 285, 286, 287, 288, 289, 290, 291, 292, 293, 294, 295, 296, 297, 298, 299]}, "removed_lines": {}}, {"13": "guava-tests/test/com/google/common/graph/AbstractUndirectedGraphTest.java", "added": {"1": ["  @Test\n", "  public void incidentEdges_oneEdge() {\n", "    putEdge(N1, N2);\n", "    EndpointPair<Integer> expectedEndpoints = EndpointPair.unordered(N1, N2);\n", "    assertThat(graph.incidentEdges(N1)).containsExactly(expectedEndpoints);\n", "    assertThat(graph.incidentEdges(N2)).containsExactly(expectedEndpoints);\n", "  }\n", "\n"]}, "removed": {}, "added_lines": {"1": [58, 59, 60, 61, 62, 63, 64, 65]}, "removed_lines": {}}, {"14": "guava-tests/test/com/google/common/graph/ConfigurableDirectedGraphTest.java", "added": {"1": ["  @Test\n", "  public void incidentEdges_selfLoop() {\n", "    putEdge(N1, N1);\n", "    assertThat(graph.incidentEdges(N1)).containsExactly(EndpointPair.ordered(N1, N1));\n", "    putEdge(N1, N2);\n", "    assertThat(graph.incidentEdges(N1)).containsExactly(\n", "        EndpointPair.ordered(N1, N1),\n", "        EndpointPair.ordered(N1, N2));\n", "  }\n", "\n"]}, "removed": {}, "added_lines": {"1": [57, 58, 59, 60, 61, 62, 63, 64, 65, 66]}, "removed_lines": {}}, {"15": "guava-tests/test/com/google/common/graph/ConfigurableSimpleDirectedGraphTest.java", "added": {"1": ["  @Override\n", "  @Test\n", "  public void incidentEdges_checkReturnedSetMutability() {\n", "    addNode(N1);\n", "    Set<EndpointPair<Integer>> incidentEdges = graph.incidentEdges(N1);\n", "    try {\n", "      incidentEdges.add(EndpointPair.ordered(N1, N2));\n", "      fail(ERROR_MODIFIABLE_SET);\n", "    } catch (UnsupportedOperationException e) {\n", "      putEdge(N1, N2);\n", "      assertThat(incidentEdges).containsExactlyElementsIn(graph.incidentEdges(N1));\n", "    }\n", "  }\n", "\n"]}, "removed": {}, "added_lines": {"1": [95, 96, 97, 98, 99, 100, 101, 102, 103, 104, 105, 106, 107, 108]}, "removed_lines": {}}, {"16": "guava-tests/test/com/google/common/graph/ConfigurableSimpleUndirectedGraphTest.java", "added": {"1": ["  @Override\n", "  @Test\n", "  public void incidentEdges_checkReturnedSetMutability() {\n", "    addNode(N1);\n", "    Set<EndpointPair<Integer>> incidentEdges = graph.incidentEdges(N1);\n", "    try {\n", "      incidentEdges.add(EndpointPair.unordered(N1, N2));\n", "      fail(ERROR_MODIFIABLE_SET);\n", "    } catch (UnsupportedOperationException e) {\n", "      putEdge(N1, N2);\n", "      assertThat(incidentEdges).containsExactlyElementsIn(graph.incidentEdges(N1));\n", "    }\n", "  }\n", "\n"]}, "removed": {}, "added_lines": {"1": [95, 96, 97, 98, 99, 100, 101, 102, 103, 104, 105, 106, 107, 108]}, "removed_lines": {}}, {"17": "guava-tests/test/com/google/common/graph/ConfigurableUndirectedGraphTest.java", "added": {"1": ["  @Test\n", "  public void incidentEdges_selfLoop() {\n", "    putEdge(N1, N1);\n", "    assertThat(graph.incidentEdges(N1)).containsExactly(EndpointPair.unordered(N1, N1));\n", "    putEdge(N1, N2);\n", "    assertThat(graph.incidentEdges(N1)).containsExactly(\n", "        EndpointPair.unordered(N1, N1),\n", "        EndpointPair.unordered(N1, N2));\n", "  }\n", "\n"]}, "removed": {}, "added_lines": {"1": [57, 58, 59, 60, 61, 62, 63, 64, 65, 66]}, "removed_lines": {}}, {"18": "guava/src/com/google/common/graph/AbstractBaseGraph.java", "added": {"1": ["import static com.google.common.base.Preconditions.checkArgument;\n", "import com.google.common.base.Function;\n", "import com.google.common.collect.ImmutableSet;\n", "import com.google.common.collect.Iterators;\n", "import com.google.common.collect.Sets;\n"], "2": ["      @Override\n", "      public boolean remove(Object o) {\n", "        throw new UnsupportedOperationException();\n", "      }\n", "\n"], "3": ["  @Override\n", "  public Set<EndpointPair<N>> incidentEdges(N node) {\n", "    checkNotNull(node);\n", "    checkArgument(nodes().contains(node), \"Node %s is not an element of this graph.\", node);\n", "    return IncidentEdgeSet.of(this, node);\n", "  }\n", "\n"], "4": ["\n", "  private abstract static class IncidentEdgeSet<N> extends AbstractSet<EndpointPair<N>> {\n", "    protected final N node;\n", "    protected final BaseGraph<N> graph;\n", "\n", "    public static <N> IncidentEdgeSet<N> of(BaseGraph<N> graph, N node) {\n", "      return graph.isDirected() ? new Directed<>(graph, node) : new Undirected<>(graph, node);\n", "    }\n", "\n", "    private IncidentEdgeSet(BaseGraph<N> graph, N node) {\n", "      this.graph = graph;\n", "      this.node = node;\n", "    }\n", "\n", "    @Override\n", "    public boolean remove(Object o) {\n", "      throw new UnsupportedOperationException();\n", "    }\n", "\n", "    private static final class Directed<N> extends IncidentEdgeSet<N> {\n", "\n", "      private Directed(BaseGraph<N> graph, N node) {\n", "        super(graph, node);\n", "      }\n", "\n", "      @Override\n", "      public UnmodifiableIterator<EndpointPair<N>> iterator() {\n", "        return Iterators.unmodifiableIterator(\n", "            Iterators.concat(\n", "                Iterators.transform(\n", "                    graph.predecessors(node).iterator(),\n", "                    new Function<N, EndpointPair<N>>() {\n", "                      @Override\n", "                      public EndpointPair<N> apply(N predecessor) {\n", "                        return EndpointPair.ordered(predecessor, node);\n", "                      }\n", "                    }),\n", "                Iterators.transform(\n", "                    // filter out 'node' from successors (already covered by predecessors, above)\n", "                    Sets.difference(graph.successors(node), ImmutableSet.of(node)).iterator(),\n", "                    new Function<N, EndpointPair<N>>() {\n", "                      @Override\n", "                      public EndpointPair<N> apply(N successor) {\n", "                        return EndpointPair.ordered(node, successor);\n", "                      }\n", "                    })));\n", "      }\n", "\n", "      @Override\n", "      public int size() {\n", "        return graph.inDegree(node)\n", "            + graph.outDegree(node)\n", "            - (graph.successors(node).contains(node) ? 1 : 0);\n", "      }\n", "\n", "      @Override\n", "      public boolean contains(@NullableDecl Object obj) {\n", "        if (!(obj instanceof EndpointPair)) {\n", "          return false;\n", "        }\n", "\n", "        EndpointPair<?> endpointPair = (EndpointPair<?>) obj;\n", "        if (!endpointPair.isOrdered()) {\n", "          return false;\n", "        }\n", "\n", "        Object source = endpointPair.source();\n", "        Object target = endpointPair.target();\n", "        return (node.equals(source) && graph.successors(node).contains(target))\n", "            || (node.equals(target) && graph.predecessors(node).contains(source));\n", "      }\n", "    }\n", "\n", "    private static final class Undirected<N> extends IncidentEdgeSet<N> {\n", "      private Undirected(BaseGraph<N> graph, N node) {\n", "        super(graph, node);\n", "      }\n", "\n", "      @Override\n", "      public UnmodifiableIterator<EndpointPair<N>> iterator() {\n", "        return Iterators.unmodifiableIterator(\n", "            Iterators.transform(\n", "                graph.adjacentNodes(node).iterator(),\n", "                new Function<N, EndpointPair<N>>() {\n", "                  @Override\n", "                  public EndpointPair<N> apply(N adjacentNode) {\n", "                    return EndpointPair.unordered(node, adjacentNode);\n", "                  }\n", "                }));\n", "      }\n", "\n", "      @Override\n", "      public int size() {\n", "        return graph.adjacentNodes(node).size();\n", "      }\n", "\n", "      @Override\n", "      public boolean contains(@NullableDecl Object obj) {\n", "        if (!(obj instanceof EndpointPair)) {\n", "          return false;\n", "        }\n", "\n", "        EndpointPair<?> endpointPair = (EndpointPair<?>) obj;\n", "        if (endpointPair.isOrdered()) {\n", "          return false;\n", "        }\n", "        Set<N> adjacent = graph.adjacentNodes(node);\n", "        Object nodeU = endpointPair.nodeU();\n", "        Object nodeV = endpointPair.nodeV();\n", "\n", "        return (node.equals(nodeV) && adjacent.contains(nodeU))\n", "            || (node.equals(nodeU) && adjacent.contains(nodeV));\n", "      }\n", "    }\n", "  }\n"]}, "removed": {}, "added_lines": {"1": [19, 23, 24, 25, 26], "2": [77, 78, 79, 80, 81], "3": [99, 100, 101, 102, 103, 104, 105], "4": [133, 134, 135, 136, 137, 138, 139, 140, 141, 142, 143, 144, 145, 146, 147, 148, 149, 150, 151, 152, 153, 154, 155, 156, 157, 158, 159, 160, 161, 162, 163, 164, 165, 166, 167, 168, 169, 170, 171, 172, 173, 174, 175, 176, 177, 178, 179, 180, 181, 182, 183, 184, 185, 186, 187, 188, 189, 190, 191, 192, 193, 194, 195, 196, 197, 198, 199, 200, 201, 202, 203, 204, 205, 206, 207, 208, 209, 210, 211, 212, 213, 214, 215, 216, 217, 218, 219, 220, 221, 222, 223, 224, 225, 226, 227, 228, 229, 230, 231, 232, 233, 234, 235, 236, 237, 238, 239, 240, 241, 242, 243, 244, 245, 246, 247]}, "removed_lines": {}}, {"19": "guava/src/com/google/common/graph/BaseGraph.java", "added": {"1": ["  /**\n", "   * Returns the edges in this graph whose endpoints include {@code node}.\n", "   *\n", "   * @throws IllegalArgumentException if {@code node} is not an element of this graph\n", "   */\n", "  Set<EndpointPair<N>> incidentEdges(N node);\n", "\n", "   * <p>For undirected graphs, this is equal to {@code incidentEdges(node).size()} + (number of\n", "   * self-loops incident to {@code node}).\n"]}, "removed": {"1": ["   * <p>For undirected graphs, this is equal to {@code adjacentNodes(node).size()} + (1 if {@code\n", "   * node} has an incident self-loop, 0 otherwise).\n"]}, "added_lines": {"1": [95, 96, 97, 98, 99, 100, 101, 108, 109]}, "removed_lines": {"1": [101, 102]}}, {"20": "guava/src/com/google/common/graph/Graph.java", "added": {"1": ["  /** {@inheritDoc} */\n", "  @Override\n", "  Set<EndpointPair<N>> incidentEdges(N node);\n", "\n"]}, "removed": {}, "added_lines": {"1": [148, 149, 150, 151]}, "removed_lines": {}}, {"21": "guava/src/com/google/common/graph/ValueGraph.java", "added": {"1": ["  /** {@inheritDoc} */\n", "  @Override\n", "  Set<EndpointPair<N>> incidentEdges(N node);\n", "\n"]}, "removed": {}, "added_lines": {"1": [161, 162, 163, 164]}, "removed_lines": {}}]}
