{"id": "cbc53084465d3a95cdb8cbd79da21624e3086d5d", "code": [{"0": "android/guava-tests/test/com/google/common/graph/TraverserTest.java", "added": {"1": ["import static com.google.common.collect.Lists.charactersOf;\n"], "2": ["  @Test\n", "  public void forGraph_breadthFirstIterable_javadocExample_canBeIteratedMultipleTimes() {\n", "    Iterable<Character> result = Traverser.forGraph(JAVADOC_GRAPH).breadthFirst(charactersOf(\"bf\"));\n", "\n", "    assertEqualCharNodes(result, \"bfaecd\");\n", "    assertEqualCharNodes(result, \"bfaecd\");\n", "  }\n", "\n"], "3": ["  @Test\n", "  public void forGraph_breadthFirstIterable_diamond() {\n", "    Traverser<Character> traverser = Traverser.forGraph(DIAMOND_GRAPH);\n", "    assertEqualCharNodes(traverser.breadthFirst(charactersOf(\"\")), \"\");\n", "    assertEqualCharNodes(traverser.breadthFirst(charactersOf(\"bc\")), \"bcd\");\n", "    assertEqualCharNodes(traverser.breadthFirst(charactersOf(\"a\")), \"abcd\");\n", "    assertEqualCharNodes(traverser.breadthFirst(charactersOf(\"acdb\")), \"acdb\");\n", "    assertEqualCharNodes(traverser.breadthFirst(charactersOf(\"db\")), \"db\");\n", "  }\n", "\n"], "4": ["  @Test\n", "  public void forGraph_breadthFirstIterable_multiGraph() {\n", "    Traverser<Character> traverser = Traverser.forGraph(MULTI_GRAPH);\n", "    assertEqualCharNodes(traverser.breadthFirst(charactersOf(\"ac\")), \"acbd\");\n", "    assertEqualCharNodes(traverser.breadthFirst(charactersOf(\"cb\")), \"cbad\");\n", "    assertEqualCharNodes(traverser.breadthFirst(charactersOf(\"db\")), \"db\");\n", "    assertEqualCharNodes(traverser.breadthFirst(charactersOf(\"d\")), \"d\");\n", "  }\n", "\n"], "5": ["  @Test\n", "  public void forGraph_breadthFirstIterable_cycle() {\n", "    Traverser<Character> traverser = Traverser.forGraph(CYCLE_GRAPH);\n", "    assertEqualCharNodes(traverser.breadthFirst(charactersOf(\"a\")), \"abcd\");\n", "    assertEqualCharNodes(traverser.breadthFirst(charactersOf(\"bd\")), \"bdca\");\n", "    assertEqualCharNodes(traverser.breadthFirst(charactersOf(\"dc\")), \"dcab\");\n", "    assertEqualCharNodes(traverser.breadthFirst(charactersOf(\"bc\")), \"bcda\");\n", "  }\n", "\n"], "6": ["  @Test\n", "  public void forGraph_breadthFirstIterable_twoCycles() {\n", "    Traverser<Character> traverser = Traverser.forGraph(TWO_CYCLES_GRAPH);\n", "    assertEqualCharNodes(traverser.breadthFirst(charactersOf(\"a\")), \"abcd\");\n", "    assertEqualCharNodes(traverser.breadthFirst(charactersOf(\"bd\")), \"bdca\");\n", "    assertEqualCharNodes(traverser.breadthFirst(charactersOf(\"dc\")), \"dcab\");\n", "    assertEqualCharNodes(traverser.breadthFirst(charactersOf(\"bc\")), \"bcda\");\n", "  }\n", "\n"], "7": ["  @Test\n", "  public void forGraph_breadthFirstIterable_tree() throws Exception {\n", "    Traverser<Character> traverser = Traverser.forGraph(TREE);\n", "\n", "    assertEqualCharNodes(traverser.breadthFirst(charactersOf(\"hg\")), \"hgdefabc\");\n", "    assertEqualCharNodes(traverser.breadthFirst(charactersOf(\"gd\")), \"gdfabc\");\n", "    assertEqualCharNodes(traverser.breadthFirst(charactersOf(\"bdgh\")), \"bdghacfe\");\n", "  }\n", "\n"], "8": ["  @Test\n", "  public void forGraph_breadthFirstIterable_twoTrees() {\n", "    assertEqualCharNodes(Traverser.forGraph(TWO_TREES).breadthFirst(charactersOf(\"a\")), \"ab\");\n", "    assertEqualCharNodes(Traverser.forGraph(TWO_TREES).breadthFirst(charactersOf(\"ac\")), \"acbd\");\n", "  }\n", "\n"], "9": ["  @Test\n", "  public void forGraph_breadthFirstIterable_singleRoot() {\n", "    Iterable<Character> result = Traverser.forGraph(SINGLE_ROOT).breadthFirst(charactersOf(\"a\"));\n", "\n", "    assertEqualCharNodes(result, \"a\");\n", "  }\n", "\n"], "10": ["  /**\n", "   * Checks that the elements of the iterable are calculated on the fly. Concretely, that means that\n", "   * {@link SuccessorsFunction#successors(Object)} can only be called for a subset of all nodes.\n", "   */\n", "  @Test\n", "  public void forGraph_breadthFirstIterable_emptyGraph() {\n", "    assertEqualCharNodes(\n", "        Traverser.forGraph(createDirectedGraph()).breadthFirst(charactersOf(\"\")), \"\");\n", "    try {\n", "      Traverser.forGraph(createDirectedGraph()).breadthFirst(charactersOf(\"a\"));\n", "      fail(\"Expected IllegalArgumentException\");\n", "    } catch (IllegalArgumentException expected) {\n", "    }\n", "  }\n", "\n"], "11": ["  @Test\n", "  public void forGraph_breadthFirstIterable_iterableIsLazy() {\n", "    RequestSavingGraph graph = new RequestSavingGraph(DIAMOND_GRAPH);\n", "    Iterable<Character> result = Traverser.forGraph(graph).breadthFirst(charactersOf(\"ab\"));\n", "\n", "    assertEqualCharNodes(Iterables.limit(result, 2), \"ab\");\n", "    assertThat(graph.requestedNodes).containsExactly('a', 'a', 'b', 'b');\n", "\n", "    // Iterate again to see if calculation is done again\n", "    assertEqualCharNodes(Iterables.limit(result, 2), \"ab\");\n", "    assertThat(graph.requestedNodes).containsExactly('a', 'a', 'a', 'b', 'b', 'b');\n", "  }\n", "\n"], "12": ["  @Test\n", "  public void forGraph_depthFirstPreOrderIterable_javadocExample_canBeIteratedMultipleTimes() {\n", "    Iterable<Character> result =\n", "        Traverser.forGraph(JAVADOC_GRAPH).depthFirstPreOrder(charactersOf(\"bc\"));\n", "\n", "    assertEqualCharNodes(result, \"bacefd\");\n", "    assertEqualCharNodes(result, \"bacefd\");\n", "  }\n", "\n"], "13": ["  @Test\n", "  public void forGraph_depthFirstPreOrderIterable_diamond() {\n", "    Traverser<Character> traverser = Traverser.forGraph(DIAMOND_GRAPH);\n", "    assertEqualCharNodes(traverser.depthFirstPreOrder(charactersOf(\"\")), \"\");\n", "    assertEqualCharNodes(traverser.depthFirstPreOrder(charactersOf(\"bc\")), \"bdc\");\n", "    assertEqualCharNodes(traverser.depthFirstPreOrder(charactersOf(\"a\")), \"abdc\");\n", "    assertEqualCharNodes(traverser.depthFirstPreOrder(charactersOf(\"acdb\")), \"abdc\");\n", "    assertEqualCharNodes(traverser.depthFirstPreOrder(charactersOf(\"db\")), \"db\");\n", "  }\n", "\n"], "14": ["  @Test\n", "  public void forGraph_depthFirstPreOrderIterable_multigraph() {\n", "    Traverser<Character> traverser = Traverser.forGraph(MULTI_GRAPH);\n", "    assertEqualCharNodes(traverser.depthFirstPreOrder(charactersOf(\"ac\")), \"abdc\");\n", "    assertEqualCharNodes(traverser.depthFirstPreOrder(charactersOf(\"cb\")), \"cabd\");\n", "    assertEqualCharNodes(traverser.depthFirstPreOrder(charactersOf(\"db\")), \"db\");\n", "    assertEqualCharNodes(traverser.depthFirstPreOrder(charactersOf(\"d\")), \"d\");\n", "  }\n", "\n"], "15": ["  @Test\n", "  public void forGraph_depthFirstPreOrderIterable_cycle() {\n", "    Traverser<Character> traverser = Traverser.forGraph(CYCLE_GRAPH);\n", "    assertEqualCharNodes(traverser.depthFirstPreOrder(charactersOf(\"a\")), \"abcd\");\n", "    assertEqualCharNodes(traverser.depthFirstPreOrder(charactersOf(\"bd\")), \"bcda\");\n", "    assertEqualCharNodes(traverser.depthFirstPreOrder(charactersOf(\"dc\")), \"dabc\");\n", "    assertEqualCharNodes(traverser.depthFirstPreOrder(charactersOf(\"bc\")), \"bcda\");\n", "  }\n", "\n"], "16": ["  @Test\n", "  public void forGraph_depthFirstPreOrderIterable_twoCycles() {\n", "    Traverser<Character> traverser = Traverser.forGraph(TWO_CYCLES_GRAPH);\n", "    assertEqualCharNodes(traverser.depthFirstPreOrder(charactersOf(\"a\")), \"abcd\");\n", "    assertEqualCharNodes(traverser.depthFirstPreOrder(charactersOf(\"bd\")), \"bcda\");\n", "    assertEqualCharNodes(traverser.depthFirstPreOrder(charactersOf(\"dc\")), \"dabc\");\n", "    assertEqualCharNodes(traverser.depthFirstPreOrder(charactersOf(\"bc\")), \"bcda\");\n", "  }\n", "\n"], "17": ["  @Test\n", "  public void forGraph_depthFirstPreOrderIterable_tree() throws Exception {\n", "    Traverser<Character> traverser = Traverser.forGraph(TREE);\n", "\n", "    assertEqualCharNodes(traverser.depthFirstPreOrder(charactersOf(\"hg\")), \"hdabcegf\");\n", "    assertEqualCharNodes(traverser.depthFirstPreOrder(charactersOf(\"gd\")), \"gfdabc\");\n", "    assertEqualCharNodes(traverser.depthFirstPreOrder(charactersOf(\"bdgh\")), \"bdacgfhe\");\n", "  }\n", "\n"], "18": ["  @Test\n", "  public void forGraph_depthFirstPreOrderIterable_twoTrees() {\n", "    assertEqualCharNodes(Traverser.forGraph(TWO_TREES).depthFirstPreOrder(charactersOf(\"a\")), \"ab\");\n", "    assertEqualCharNodes(\n", "        Traverser.forGraph(TWO_TREES).depthFirstPreOrder(charactersOf(\"ac\")), \"abcd\");\n", "  }\n", "\n"], "19": ["  @Test\n", "  public void forGraph_depthFirstPreOrderIterable_singleRoot() {\n", "    Iterable<Character> result =\n", "        Traverser.forGraph(SINGLE_ROOT).depthFirstPreOrder(charactersOf(\"a\"));\n", "\n", "    assertEqualCharNodes(result, \"a\");\n", "  }\n", "\n"], "20": ["  @Test\n", "  public void forGraph_depthFirstPreOrderIterable_emptyGraph() {\n", "    assertEqualCharNodes(\n", "        Traverser.forGraph(createDirectedGraph()).depthFirstPreOrder(charactersOf(\"\")), \"\");\n", "    try {\n", "      Traverser.forGraph(createDirectedGraph()).depthFirstPreOrder(charactersOf(\"a\"));\n", "      fail(\"Expected IllegalArgumentException\");\n", "    } catch (IllegalArgumentException expected) {\n", "    }\n", "  }\n", "\n"], "21": ["  @Test\n", "  public void forGraph_depthFirstPreOrderIterable_iterableIsLazy() {\n", "    RequestSavingGraph graph = new RequestSavingGraph(DIAMOND_GRAPH);\n", "    Iterable<Character> result = Traverser.forGraph(graph).depthFirstPreOrder(charactersOf(\"ac\"));\n", "\n", "    assertEqualCharNodes(Iterables.limit(result, 2), \"ab\");\n", "    assertThat(graph.requestedNodes).containsExactly('a', 'a', 'b', 'c', 'd');\n", "\n", "    // Iterate again to see if calculation is done again\n", "    assertEqualCharNodes(Iterables.limit(result, 2), \"ab\");\n", "    assertThat(graph.requestedNodes).containsExactly('a', 'a', 'a', 'b', 'b', 'c', 'd', 'd');\n", "  }\n", "\n"], "22": ["  @Test\n", "  public void forGraph_depthFirstPostOrderIterable_javadocExample_canBeIteratedMultipleTimes() {\n", "    Iterable<Character> result =\n", "        Traverser.forGraph(JAVADOC_GRAPH).depthFirstPostOrder(charactersOf(\"bf\"));\n", "    assertEqualCharNodes(result, \"efcdab\");\n", "    assertEqualCharNodes(result, \"efcdab\");\n", "  }\n", "\n"], "23": ["  @Test\n", "  public void forGraph_depthFirstPostOrderIterable_diamond() {\n", "    Traverser<Character> traverser = Traverser.forGraph(DIAMOND_GRAPH);\n", "    assertEqualCharNodes(traverser.depthFirstPostOrder(charactersOf(\"\")), \"\");\n", "    assertEqualCharNodes(traverser.depthFirstPostOrder(charactersOf(\"bc\")), \"dbc\");\n", "    assertEqualCharNodes(traverser.depthFirstPostOrder(charactersOf(\"a\")), \"dbca\");\n", "    assertEqualCharNodes(traverser.depthFirstPostOrder(charactersOf(\"acdb\")), \"dbca\");\n", "    assertEqualCharNodes(traverser.depthFirstPostOrder(charactersOf(\"db\")), \"db\");\n", "  }\n", "\n"], "24": ["  @Test\n", "  public void forGraph_depthFirstPostOrderIterable_multigraph() {\n", "    Traverser<Character> traverser = Traverser.forGraph(MULTI_GRAPH);\n", "    assertEqualCharNodes(traverser.depthFirstPostOrder(charactersOf(\"ac\")), \"dbca\");\n", "    assertEqualCharNodes(traverser.depthFirstPostOrder(charactersOf(\"cb\")), \"dbac\");\n", "    assertEqualCharNodes(traverser.depthFirstPostOrder(charactersOf(\"db\")), \"db\");\n", "    assertEqualCharNodes(traverser.depthFirstPostOrder(charactersOf(\"d\")), \"d\");\n", "  }\n", "\n"], "25": ["  @Test\n", "  public void forGraph_depthFirstPostOrderIterable_cycle() {\n", "    Traverser<Character> traverser = Traverser.forGraph(CYCLE_GRAPH);\n", "    assertEqualCharNodes(traverser.depthFirstPostOrder(charactersOf(\"a\")), \"dcba\");\n", "    assertEqualCharNodes(traverser.depthFirstPostOrder(charactersOf(\"bd\")), \"adcb\");\n", "    assertEqualCharNodes(traverser.depthFirstPostOrder(charactersOf(\"dc\")), \"cbad\");\n", "    assertEqualCharNodes(traverser.depthFirstPostOrder(charactersOf(\"bc\")), \"adcb\");\n", "  }\n", "\n"], "26": ["  @Test\n", "  public void forGraph_depthFirstPostOrderIterable_twoCycles() {\n", "    Traverser<Character> traverser = Traverser.forGraph(TWO_CYCLES_GRAPH);\n", "    assertEqualCharNodes(traverser.depthFirstPostOrder(charactersOf(\"a\")), \"dcba\");\n", "    assertEqualCharNodes(traverser.depthFirstPostOrder(charactersOf(\"bd\")), \"adcb\");\n", "    assertEqualCharNodes(traverser.depthFirstPostOrder(charactersOf(\"dc\")), \"cbad\");\n", "    assertEqualCharNodes(traverser.depthFirstPostOrder(charactersOf(\"bc\")), \"adcb\");\n", "  }\n", "\n"], "27": ["  @Test\n", "  public void forGraph_depthFirstPostOrderIterable_tree() throws Exception {\n", "    Traverser<Character> traverser = Traverser.forGraph(TREE);\n", "\n", "    assertEqualCharNodes(traverser.depthFirstPostOrder(charactersOf(\"hg\")), \"abcdefgh\");\n", "    assertEqualCharNodes(traverser.depthFirstPostOrder(charactersOf(\"gd\")), \"fgabcd\");\n", "    assertEqualCharNodes(traverser.depthFirstPostOrder(charactersOf(\"bdgh\")), \"bacdfgeh\");\n", "  }\n", "\n"], "28": ["  @Test\n", "  public void forGraph_depthFirstPostOrderIterable_twoTrees() {\n", "    assertEqualCharNodes(\n", "        Traverser.forGraph(TWO_TREES).depthFirstPostOrder(charactersOf(\"a\")), \"ba\");\n", "    assertEqualCharNodes(\n", "        Traverser.forGraph(TWO_TREES).depthFirstPostOrder(charactersOf(\"ac\")), \"badc\");\n", "  }\n", "\n"], "29": ["  @Test\n", "  public void forGraph_depthFirstPostOrderIterable_singleRoot() {\n", "    Iterable<Character> result =\n", "        Traverser.forGraph(SINGLE_ROOT).depthFirstPostOrder(charactersOf(\"a\"));\n", "\n", "    assertEqualCharNodes(result, \"a\");\n", "  }\n", "\n"], "30": ["  @Test\n", "  public void forGraph_depthFirstPostOrderIterable_emptyGraph() {\n", "    assertEqualCharNodes(\n", "        Traverser.forGraph(createDirectedGraph()).depthFirstPostOrder(charactersOf(\"\")), \"\");\n", "    try {\n", "      Traverser.forGraph(createDirectedGraph()).depthFirstPostOrder(charactersOf(\"a\"));\n", "      fail(\"Expected IllegalArgumentException\");\n", "    } catch (IllegalArgumentException expected) {\n", "    }\n", "  }\n", "\n"], "31": ["  @Test\n", "  public void forGraph_depthFirstPostOrderIterable_iterableIsLazy() {\n", "    RequestSavingGraph graph = new RequestSavingGraph(DIAMOND_GRAPH);\n", "    Iterable<Character> result = Traverser.forGraph(graph).depthFirstPostOrder(charactersOf(\"ac\"));\n", "\n", "    assertEqualCharNodes(Iterables.limit(result, 2), \"db\");\n", "    assertThat(graph.requestedNodes).containsExactly('a', 'a', 'b', 'c', 'd');\n", "\n", "    // Iterate again to see if calculation is done again\n", "    assertEqualCharNodes(Iterables.limit(result, 2), \"db\");\n", "    assertThat(graph.requestedNodes).containsExactly('a', 'a', 'a', 'b', 'b', 'c', 'd', 'd');\n", "  }\n", "\n"], "32": ["  @Test\n", "  public void forTree_breadthFirstIterable_tree() throws Exception {\n", "    Traverser<Character> traverser = Traverser.forTree(TREE);\n", "\n", "    assertEqualCharNodes(traverser.breadthFirst(charactersOf(\"\")), \"\");\n", "    assertEqualCharNodes(traverser.breadthFirst(charactersOf(\"h\")), \"hdegabcf\");\n", "    assertEqualCharNodes(traverser.breadthFirst(charactersOf(\"gd\")), \"gdfabc\");\n", "    assertEqualCharNodes(traverser.breadthFirst(charactersOf(\"age\")), \"agef\");\n", "  }\n", "\n"], "33": ["  @Test\n", "  public void forTree_breadthFirstIterable_cyclicGraphContainingTree() throws Exception {\n", "    Traverser<Character> traverser = Traverser.forTree(CYCLIC_GRAPH_CONTAINING_TREE);\n", "\n", "    assertEqualCharNodes(traverser.breadthFirst(charactersOf(\"a\")), \"abcd\");\n", "    assertEqualCharNodes(traverser.breadthFirst(charactersOf(\"b\")), \"bcd\");\n", "    assertEqualCharNodes(traverser.breadthFirst(charactersOf(\"cd\")), \"cd\");\n", "  }\n", "\n"], "34": ["  @Test\n", "  public void forTree_breadthFirstIterable_graphContainingTreeAndDiamond() throws Exception {\n", "    Traverser<Character> traverser = Traverser.forTree(GRAPH_CONTAINING_TREE_AND_DIAMOND);\n", "\n", "    assertEqualCharNodes(traverser.breadthFirst(charactersOf(\"a\")), \"abcd\");\n", "    assertEqualCharNodes(traverser.breadthFirst(charactersOf(\"bg\")), \"bgcdh\");\n", "    assertEqualCharNodes(traverser.breadthFirst(charactersOf(\"ga\")), \"gahbcd\");\n", "  }\n", "\n"], "35": ["  @Test\n", "  public void forTree_breadthFirstIterable_twoTrees() {\n", "    assertEqualCharNodes(Traverser.forTree(TWO_TREES).breadthFirst(charactersOf(\"a\")), \"ab\");\n", "    assertEqualCharNodes(Traverser.forTree(TWO_TREES).breadthFirst(charactersOf(\"ca\")), \"cadb\");\n", "  }\n", "\n"], "36": ["  @Test\n", "  public void forTree_breadthFirstIterable_singleRoot() {\n", "    Iterable<Character> result = Traverser.forTree(SINGLE_ROOT).breadthFirst(charactersOf(\"a\"));\n", "\n", "    assertEqualCharNodes(result, \"a\");\n", "  }\n", "\n"], "37": ["  @Test\n", "  public void forTree_breadthFirstIterable_emptyGraph() {\n", "    assertEqualCharNodes(\n", "        Traverser.forTree(createDirectedGraph()).breadthFirst(charactersOf(\"\")), \"\");\n", "    try {\n", "      Traverser.forTree(createDirectedGraph()).breadthFirst(charactersOf(\"a\"));\n", "      fail(\"Expected IllegalArgumentException\");\n", "    } catch (IllegalArgumentException expected) {\n", "    }\n", "  }\n", "\n"], "38": ["  public void forTree_breadthFirstIterable_iterableIsLazy() {\n", "    RequestSavingGraph graph = new RequestSavingGraph(TREE);\n", "    Iterable<Character> result = Traverser.forGraph(graph).breadthFirst(charactersOf(\"dg\"));\n", "\n", "    assertEqualCharNodes(Iterables.limit(result, 3), \"dga\");\n", "    assertThat(graph.requestedNodes).containsExactly('a', 'd', 'd', 'g', 'g');\n", "\n", "    // Iterate again to see if calculation is done again\n", "    assertEqualCharNodes(Iterables.limit(result, 3), \"dga\");\n", "    assertThat(graph.requestedNodes).containsExactly('a', 'a', 'd', 'd', 'd', 'g', 'g', 'g');\n", "  }\n", "\n", "  @Test\n", "  public void forTree_depthFirstPreOrderIterable_tree() throws Exception {\n", "    assertEqualCharNodes(traverser.depthFirstPreOrder(charactersOf(\"h\")), \"hdabcegf\");\n", "    assertEqualCharNodes(traverser.depthFirstPreOrder(charactersOf(\"d\")), \"dabc\");\n", "    assertEqualCharNodes(traverser.depthFirstPreOrder(charactersOf(\"a\")), \"a\");\n", "  }\n", "\n", "  @Test\n", "  public void forTree_depthFirstPreOrderIterableIterable_tree() throws Exception {\n", "    Traverser<Character> traverser = Traverser.forTree(TREE);\n", "\n", "    assertEqualCharNodes(traverser.depthFirstPreOrder(charactersOf(\"\")), \"\");\n", "    assertEqualCharNodes(traverser.depthFirstPreOrder(charactersOf(\"h\")), \"hdabcegf\");\n", "    assertEqualCharNodes(traverser.depthFirstPreOrder(charactersOf(\"gd\")), \"gfdabc\");\n", "    assertEqualCharNodes(traverser.depthFirstPreOrder(charactersOf(\"age\")), \"agfe\");\n"], "39": ["  @Test\n", "  public void forTree_depthFirstPreOrderIterable_cyclicGraphContainingTree() throws Exception {\n", "    Traverser<Character> traverser = Traverser.forTree(CYCLIC_GRAPH_CONTAINING_TREE);\n", "\n", "    assertEqualCharNodes(traverser.depthFirstPreOrder(charactersOf(\"a\")), \"abcd\");\n", "    assertEqualCharNodes(traverser.depthFirstPreOrder(charactersOf(\"b\")), \"bcd\");\n", "    assertEqualCharNodes(traverser.depthFirstPreOrder(charactersOf(\"cd\")), \"cd\");\n", "  }\n", "\n"], "40": ["  @Test\n", "  public void forTree_depthFirstPreOrderIterable_graphContainingTreeAndDiamond() throws Exception {\n", "    Traverser<Character> traverser = Traverser.forTree(GRAPH_CONTAINING_TREE_AND_DIAMOND);\n", "\n", "    assertEqualCharNodes(traverser.depthFirstPreOrder(charactersOf(\"a\")), \"abcd\");\n", "    assertEqualCharNodes(traverser.depthFirstPreOrder(charactersOf(\"bg\")), \"bcdgh\");\n", "    assertEqualCharNodes(traverser.depthFirstPreOrder(charactersOf(\"ga\")), \"ghabcd\");\n", "  }\n", "\n"], "41": ["  @Test\n", "  public void forTree_depthFirstPreOrderIterable_twoTrees() {\n", "    assertEqualCharNodes(Traverser.forTree(TWO_TREES).depthFirstPreOrder(charactersOf(\"a\")), \"ab\");\n", "    assertEqualCharNodes(\n", "        Traverser.forTree(TWO_TREES).depthFirstPreOrder(charactersOf(\"ca\")), \"cdab\");\n", "  }\n", "\n"], "42": ["  @Test\n", "  public void forTree_depthFirstPreOrderIterable_singleRoot() {\n", "    Iterable<Character> result =\n", "        Traverser.forTree(SINGLE_ROOT).depthFirstPreOrder(charactersOf(\"a\"));\n", "\n", "    assertEqualCharNodes(result, \"a\");\n", "  }\n", "\n"], "43": ["  @Test\n", "  public void forTree_depthFirstPreOrderIterable_emptyGraph() {\n", "    assertEqualCharNodes(\n", "        Traverser.forTree(createDirectedGraph()).depthFirstPreOrder(charactersOf(\"\")), \"\");\n", "    try {\n", "      Traverser.forTree(createDirectedGraph()).depthFirstPreOrder(charactersOf(\"a\"));\n", "      fail(\"Expected IllegalArgumentException\");\n", "    } catch (IllegalArgumentException expected) {\n", "    }\n", "  }\n", "\n"], "44": ["  @Test\n", "  public void forTree_depthFirstPreOrderIterable_iterableIsLazy() {\n", "    RequestSavingGraph graph = new RequestSavingGraph(TREE);\n", "    Iterable<Character> result = Traverser.forGraph(graph).depthFirstPreOrder(charactersOf(\"dg\"));\n", "\n", "    assertEqualCharNodes(Iterables.limit(result, 2), \"da\");\n", "    assertThat(graph.requestedNodes).containsExactly('a', 'd', 'd', 'g');\n", "\n", "    // Iterate again to see if calculation is done again\n", "    assertEqualCharNodes(Iterables.limit(result, 2), \"da\");\n", "    assertThat(graph.requestedNodes).containsExactly('a', 'a', 'd', 'd', 'd', 'g');\n", "  }\n", "\n"], "45": ["  @Test\n", "  public void forTree_depthFirstPostOrderIterable_tree() throws Exception {\n", "    Traverser<Character> traverser = Traverser.forTree(TREE);\n", "\n", "    assertEqualCharNodes(traverser.depthFirstPostOrder(charactersOf(\"\")), \"\");\n", "    assertEqualCharNodes(traverser.depthFirstPostOrder(charactersOf(\"h\")), \"abcdefgh\");\n", "    assertEqualCharNodes(traverser.depthFirstPostOrder(charactersOf(\"gd\")), \"fgabcd\");\n", "    assertEqualCharNodes(traverser.depthFirstPostOrder(charactersOf(\"age\")), \"afge\");\n", "  }\n", "\n"], "46": ["  @Test\n", "  public void forTree_depthFirstPostOrderIterable_cyclicGraphContainingTree() throws Exception {\n", "    Traverser<Character> traverser = Traverser.forTree(CYCLIC_GRAPH_CONTAINING_TREE);\n", "\n", "    assertEqualCharNodes(traverser.depthFirstPostOrder(charactersOf(\"a\")), \"cdba\");\n", "    assertEqualCharNodes(traverser.depthFirstPostOrder(charactersOf(\"b\")), \"cdb\");\n", "    assertEqualCharNodes(traverser.depthFirstPostOrder(charactersOf(\"cd\")), \"cd\");\n", "  }\n", "\n"], "47": ["  @Test\n", "  public void forTree_depthFirstPostOrderIterable_graphContainingTreeAndDiamond() throws Exception {\n", "    Traverser<Character> traverser = Traverser.forTree(GRAPH_CONTAINING_TREE_AND_DIAMOND);\n", "\n", "    assertEqualCharNodes(traverser.depthFirstPostOrder(charactersOf(\"a\")), \"cdba\");\n", "    assertEqualCharNodes(traverser.depthFirstPostOrder(charactersOf(\"bg\")), \"cdbhg\");\n", "    assertEqualCharNodes(traverser.depthFirstPostOrder(charactersOf(\"ga\")), \"hgcdba\");\n", "  }\n", "\n"], "48": ["  @Test\n", "  public void forTree_depthFirstPostOrderIterable_twoTrees() {\n", "    assertEqualCharNodes(Traverser.forTree(TWO_TREES).depthFirstPostOrder(charactersOf(\"a\")), \"ba\");\n", "    assertEqualCharNodes(\n", "        Traverser.forTree(TWO_TREES).depthFirstPostOrder(charactersOf(\"ca\")), \"dcba\");\n", "  }\n", "\n"], "49": ["  @Test\n", "  public void forTree_depthFirstPostOrderIterable_singleRoot() {\n", "    Iterable<Character> result =\n", "        Traverser.forTree(SINGLE_ROOT).depthFirstPostOrder(charactersOf(\"a\"));\n", "\n", "    assertEqualCharNodes(result, \"a\");\n", "  }\n", "\n"], "50": ["  @Test\n", "  public void forTree_depthFirstPostOrderIterable_emptyGraph() {\n", "    assertEqualCharNodes(\n", "        Traverser.forTree(createDirectedGraph()).depthFirstPostOrder(charactersOf(\"\")), \"\");\n", "    try {\n", "      Traverser.forTree(createDirectedGraph()).depthFirstPostOrder(charactersOf(\"a\"));\n", "      fail(\"Expected IllegalArgumentException\");\n", "    } catch (IllegalArgumentException expected) {\n", "    }\n", "  }\n", "\n"], "51": ["  @Test\n", "  public void forTree_depthFirstPostOrderIterable_iterableIsLazy() {\n", "    RequestSavingGraph graph = new RequestSavingGraph(TREE);\n", "    Iterable<Character> result = Traverser.forGraph(graph).depthFirstPostOrder(charactersOf(\"dg\"));\n", "\n", "    assertEqualCharNodes(Iterables.limit(result, 2), \"ab\");\n", "    assertThat(graph.requestedNodes).containsExactly('a', 'b', 'd', 'd', 'g');\n", "\n", "    // Iterate again to see if calculation is done again\n", "    assertEqualCharNodes(Iterables.limit(result, 2), \"ab\");\n", "    assertThat(graph.requestedNodes).containsExactly('a', 'a', 'b', 'b', 'd', 'd', 'd', 'g');\n", "  }\n", "\n"]}, "removed": {"38": ["  public void forTree_depthFirstPreOrder_tree() throws Exception {\n", "    assertEqualCharNodes(traverser.depthFirstPreOrder('h'), \"hdabcegf\");\n", "    assertEqualCharNodes(traverser.depthFirstPreOrder('d'), \"dabc\");\n", "    assertEqualCharNodes(traverser.depthFirstPreOrder('a'), \"a\");\n"]}, "added_lines": {"1": [22], "2": [179, 180, 181, 182, 183, 184, 185, 186], "3": [196, 197, 198, 199, 200, 201, 202, 203, 204, 205], "4": [215, 216, 217, 218, 219, 220, 221, 222, 223], "5": [233, 234, 235, 236, 237, 238, 239, 240, 241], "6": [251, 252, 253, 254, 255, 256, 257, 258, 259], "7": [269, 270, 271, 272, 273, 274, 275, 276, 277], "8": [285, 286, 287, 288, 289, 290], "9": [298, 299, 300, 301, 302, 303, 304], "10": [314, 315, 316, 317, 318, 319, 320, 321, 322, 323, 324, 325, 326, 327, 328], "11": [346, 347, 348, 349, 350, 351, 352, 353, 354, 355, 356, 357, 358], "12": [367, 368, 369, 370, 371, 372, 373, 374, 375], "13": [385, 386, 387, 388, 389, 390, 391, 392, 393, 394], "14": [404, 405, 406, 407, 408, 409, 410, 411, 412], "15": [422, 423, 424, 425, 426, 427, 428, 429, 430], "16": [440, 441, 442, 443, 444, 445, 446, 447, 448], "17": [458, 459, 460, 461, 462, 463, 464, 465, 466], "18": [474, 475, 476, 477, 478, 479, 480], "19": [488, 489, 490, 491, 492, 493, 494, 495], "20": [505, 506, 507, 508, 509, 510, 511, 512, 513, 514, 515], "21": [529, 530, 531, 532, 533, 534, 535, 536, 537, 538, 539, 540, 541], "22": [549, 550, 551, 552, 553, 554, 555, 556], "23": [566, 567, 568, 569, 570, 571, 572, 573, 574, 575], "24": [585, 586, 587, 588, 589, 590, 591, 592, 593], "25": [603, 604, 605, 606, 607, 608, 609, 610, 611], "26": [621, 622, 623, 624, 625, 626, 627, 628, 629], "27": [639, 640, 641, 642, 643, 644, 645, 646, 647], "28": [655, 656, 657, 658, 659, 660, 661, 662], "29": [670, 671, 672, 673, 674, 675, 676, 677], "30": [687, 688, 689, 690, 691, 692, 693, 694, 695, 696, 697], "31": [711, 712, 713, 714, 715, 716, 717, 718, 719, 720, 721, 722, 723], "32": [796, 797, 798, 799, 800, 801, 802, 803, 804, 805], "33": [815, 816, 817, 818, 819, 820, 821, 822, 823], "34": [833, 834, 835, 836, 837, 838, 839, 840, 841], "35": [849, 850, 851, 852, 853, 854], "36": [862, 863, 864, 865, 866, 867, 868], "37": [878, 879, 880, 881, 882, 883, 884, 885, 886, 887, 888], "38": [903, 904, 905, 906, 907, 908, 909, 910, 911, 912, 913, 914, 915, 916, 919, 920, 921, 922, 923, 924, 925, 926, 927, 928, 929, 930, 931], "39": [943, 944, 945, 946, 947, 948, 949, 950, 951], "40": [961, 962, 963, 964, 965, 966, 967, 968, 969], "41": [977, 978, 979, 980, 981, 982, 983], "42": [991, 992, 993, 994, 995, 996, 997, 998], "43": [1008, 1009, 1010, 1011, 1012, 1013, 1014, 1015, 1016, 1017, 1018], "44": [1032, 1033, 1034, 1035, 1036, 1037, 1038, 1039, 1040, 1041, 1042, 1043, 1044], "45": [1054, 1055, 1056, 1057, 1058, 1059, 1060, 1061, 1062, 1063], "46": [1073, 1074, 1075, 1076, 1077, 1078, 1079, 1080, 1081], "47": [1091, 1092, 1093, 1094, 1095, 1096, 1097, 1098, 1099], "48": [1107, 1108, 1109, 1110, 1111, 1112, 1113], "49": [1121, 1122, 1123, 1124, 1125, 1126, 1127, 1128], "50": [1138, 1139, 1140, 1141, 1142, 1143, 1144, 1145, 1146, 1147, 1148], "51": [1162, 1163, 1164, 1165, 1166, 1167, 1168, 1169, 1170, 1171, 1172, 1173, 1174]}, "removed_lines": {"38": [567, 570, 571, 572]}}, {"1": "android/guava/src/com/google/common/graph/Traverser.java", "added": {"1": ["import com.google.common.collect.ImmutableSet;\n"], "2": ["import org.checkerframework.checker.nullness.compatqual.NullableDecl;\n", " * An object that can traverse the nodes that are reachable from a specified (set of) start node(s)\n", " * using a specified {@link SuccessorsFunction}.\n", " *\n", " * <p>There are two entry points for creating a {@code Traverser}: {@link\n", " * #forTree(SuccessorsFunction)} and {@link #forGraph(SuccessorsFunction)}. You should choose one\n", " * based on your answers to the following questions:\n", " *\n", " * <ol>\n", " *   <li>Is there only one path to any node that's reachable from any start node? (If so, the\n", " *       graph to be traversed is a tree or forest even if it is a subgraph of a graph which is\n", " *       neither.)\n", " *   <li>Are the node objects' implementations of {@code equals()}/{@code hashCode()} <a\n", " *       href=\"https://github.com/google/guava/wiki/GraphsExplained#non-recursiveness\">recursive</a>?\n", " * </ol>\n", " *\n", " * <p>If your answers are:\n", " *\n", " * <ul>\n", " *   <li>(1) \"no\" and (2) \"no\", use {@link #forGraph(SuccessorsFunction)}.\n", " *   <li>(1) \"yes\" and (2) \"yes\", use {@link #forTree(SuccessorsFunction)}.\n", " *   <li>(1) \"yes\" and (2) \"no\", you can use either, but {@code forTree()} will be more efficient.\n", " *   <li>(1) \"no\" and (2) \"yes\", <b><i>neither will work</i></b>, but if you transform your node\n", " *       objects into a non-recursive form, you can use {@code forGraph()}.\n", " * </ul>\n"], "3": ["   * <p>Traversers created using this method are guaranteed to visit each node reachable from the\n", "   * start node(s) at most once.\n", "   *\n", "   * <p>If you know that no node in {@code graph} is reachable by more than one path from the start\n", "   * node(s), consider using {@link #forTree(SuccessorsFunction)} instead.\n", "   *       {@code hashCode()} implementations. (See the <a\n", "   *       href=\"https://github.com/google/guava/wiki/GraphsExplained#elements-must-be-useable-as-map-keys\">\n", "   *       notes on element objects</a> for more information.)\n"], "4": ["   * node(s) to any node reachable from the start node(s), and has no paths from any start node to\n", "   * any other start node, such as a tree or forest.\n", "   *\n", "   * <p>{@code forTree()} is especially useful (versus {@code forGraph()}) in cases where the data\n", "   * structure being traversed is, in addition to being a tree/forest, also defined <a\n", "   * href=\"https://github.com/google/guava/wiki/GraphsExplained#non-recursiveness\">recursively</a>.\n", "   * This is because the {@code forTree()}-based implementations don't keep track of visited nodes,\n", "   * and therefore don't need to call `equals()` or `hashCode()` on the node objects; this saves\n", "   * both time and space versus traversing the same graph using {@code forGraph()}.\n", "   * <p>Providing a graph to be traversed for which there is more than one path from the start\n", "   * node(s) to any node may lead to:\n", "   *   <li>Nodes being visited multiple times (if multiple paths exist from any start node to any\n", "   *       node reachable from any start node)\n"], "5": ["   * <p><b>Examples</b> (all edges are directed facing downwards)\n", "   * <p>The graph below would be valid input with start nodes of {@code a, f, c}. However, if {@code\n", "   * b} were <i>also</i> a start node, then there would be multiple paths to reach {@code e} and\n", "   * {@code h}.\n"], "6": ["   * <p>.\n", "   *\n", "   * <p>The graph below would be a valid input with start nodes of {@code a, f}. However, if {@code\n", "   * b} were a start node, there would be multiple paths to {@code f}.\n"], "8": ["  /**\n", "   * Returns an unmodifiable {@code Iterable} over the nodes reachable from any of the {@code\n", "   * startNodes}, in the order of a breadth-first traversal. This is equivalent to a breadth-first\n", "   * traversal of a graph with an additional root node whose successors are the listed {@code\n", "   * startNodes}.\n", "   *\n", "   * @throws IllegalArgumentException if any of {@code startNodes} is not an element of the graph\n", "   * @see #breadthFirst(Object)\n", "   */\n", "  public abstract Iterable<N> breadthFirst(Iterable<? extends N> startNodes);\n", "\n"], "9": ["  /**\n", "   * Returns an unmodifiable {@code Iterable} over the nodes reachable from any of the {@code\n", "   * startNodes}, in the order of a depth-first pre-order traversal. This is equivalent to a\n", "   * depth-first pre-order traversal of a graph with an additional root node whose successors are\n", "   * the listed {@code startNodes}.\n", "   *\n", "   * @throws IllegalArgumentException if any of {@code startNodes} is not an element of the graph\n", "   * @see #depthFirstPreOrder(Object)\n", "   */\n", "  public abstract Iterable<N> depthFirstPreOrder(Iterable<? extends N> startNodes);\n", "\n"], "10": ["  /**\n", "   * Returns an unmodifiable {@code Iterable} over the nodes reachable from any of the {@code\n", "   * startNodes}, in the order of a depth-first post-order traversal. This is equivalent to a\n", "   * depth-first post-order traversal of a graph with an additional root node whose successors are\n", "   * the listed {@code startNodes}.\n", "   *\n", "   * @throws IllegalArgumentException if any of {@code startNodes} is not an element of the graph\n", "   * @see #depthFirstPostOrder(Object)\n", "   */\n", "  public abstract Iterable<N> depthFirstPostOrder(Iterable<? extends N> startNodes);\n", "\n"], "11": ["      return breadthFirst(ImmutableSet.of(startNode));\n", "    }\n", "\n", "    @Override\n", "    public Iterable<N> breadthFirst(final Iterable<? extends N> startNodes) {\n", "      checkNotNull(startNodes);\n", "      if (Iterables.isEmpty(startNodes)) {\n", "        return ImmutableSet.of();\n", "      }\n", "      for (N startNode : startNodes) {\n", "        checkThatNodeIsInGraph(startNode);\n", "      }\n", "          return new BreadthFirstIterator(startNodes);\n"], "12": ["      return depthFirstPreOrder(ImmutableSet.of(startNode));\n", "    }\n", "\n", "    @Override\n", "    public Iterable<N> depthFirstPreOrder(final Iterable<? extends N> startNodes) {\n", "      checkNotNull(startNodes);\n", "      if (Iterables.isEmpty(startNodes)) {\n", "        return ImmutableSet.of();\n", "      }\n", "      for (N startNode : startNodes) {\n", "        checkThatNodeIsInGraph(startNode);\n", "      }\n", "          return new DepthFirstIterator(startNodes, Order.PREORDER);\n"], "13": ["      return depthFirstPostOrder(ImmutableSet.of(startNode));\n", "    }\n", "\n", "    @Override\n", "    public Iterable<N> depthFirstPostOrder(final Iterable<? extends N> startNodes) {\n", "      checkNotNull(startNodes);\n", "      if (Iterables.isEmpty(startNodes)) {\n", "        return ImmutableSet.of();\n", "      }\n", "      for (N startNode : startNodes) {\n", "        checkThatNodeIsInGraph(startNode);\n", "      }\n", "          return new DepthFirstIterator(startNodes, Order.POSTORDER);\n"], "14": ["      BreadthFirstIterator(Iterable<? extends N> roots) {\n", "        for (N root : roots) {\n", "          // add all roots to the queue, skipping duplicates\n", "          if (visited.add(root)) {\n", "            queue.add(root);\n", "          }\n", "        }\n"], "15": ["      DepthFirstIterator(Iterable<? extends N> roots, Order order) {\n", "        stack.push(new NodeAndSuccessors(null, roots));\n"], "16": ["          NodeAndSuccessors nodeAndSuccessors = stack.getFirst();\n", "          boolean firstVisit = visited.add(nodeAndSuccessors.node);\n", "          boolean lastVisit = !nodeAndSuccessors.successorIterator.hasNext();\n", "            N successor = nodeAndSuccessors.successorIterator.next();\n", "          if (produceNode && nodeAndSuccessors.node != null) {\n", "            return nodeAndSuccessors.node;\n"], "17": ["        @NullableDecl final N node;\n", "        NodeAndSuccessors(@NullableDecl N node, Iterable<? extends N> successors) {\n"], "18": ["      return breadthFirst(ImmutableSet.of(startNode));\n", "    }\n", "\n", "    @Override\n", "    public Iterable<N> breadthFirst(final Iterable<? extends N> startNodes) {\n", "      checkNotNull(startNodes);\n", "      if (Iterables.isEmpty(startNodes)) {\n", "        return ImmutableSet.of();\n", "      }\n", "      for (N startNode : startNodes) {\n", "        checkThatNodeIsInTree(startNode);\n", "      }\n", "          return new BreadthFirstIterator(startNodes);\n"], "19": ["      return depthFirstPreOrder(ImmutableSet.of(startNode));\n", "    }\n", "\n", "    @Override\n", "    public Iterable<N> depthFirstPreOrder(final Iterable<? extends N> startNodes) {\n", "      checkNotNull(startNodes);\n", "      if (Iterables.isEmpty(startNodes)) {\n", "        return ImmutableSet.of();\n", "      }\n", "      for (N node : startNodes) {\n", "        checkThatNodeIsInTree(node);\n", "      }\n", "          return new DepthFirstPreOrderIterator(startNodes);\n"], "20": ["      return depthFirstPostOrder(ImmutableSet.of(startNode));\n", "    }\n", "\n", "    @Override\n", "    public Iterable<N> depthFirstPostOrder(final Iterable<? extends N> startNodes) {\n", "      checkNotNull(startNodes);\n", "      if (Iterables.isEmpty(startNodes)) {\n", "        return ImmutableSet.of();\n", "      }\n", "      for (N startNode : startNodes) {\n", "        checkThatNodeIsInTree(startNode);\n", "      }\n", "          return new DepthFirstPostOrderIterator(startNodes);\n"], "21": ["      BreadthFirstIterator(Iterable<? extends N> roots) {\n", "        for (N root : roots) {\n", "          queue.add(root);\n", "        }\n"], "22": ["      DepthFirstPreOrderIterator(Iterable<? extends N> roots) {\n", "        stack.addLast(roots.iterator());\n"], "23": ["      DepthFirstPostOrderIterator(Iterable<? extends N> roots) {\n", "        stack.addLast(new NodeAndChildren(null, roots));\n"], "24": ["            if (top.node != null) {\n", "              return top.node;\n", "            }\n"], "25": ["        @NullableDecl final N node;\n", "        NodeAndChildren(@NullableDecl N node, Iterable<? extends N> children) {\n"]}, "removed": {"1": ["import static com.google.common.collect.Iterators.singletonIterator;\n"], "2": [" * Provides methods for traversing a graph.\n"], "3": ["   * <p>If {@code graph} is known to be tree-shaped, consider using {@link\n", "   * #forTree(SuccessorsFunction)} instead.\n", "   *       {@code hashCode()} implementations.\n"], "4": ["   * node to any node reachable from the start node, such as a tree.\n", "   * <p>Providing graphs that don't conform to the above description may lead to:\n", "   *   <li>Nodes being visited multiple times (if multiple paths exist from the start node to any\n", "   *       node reachable from it)\n", "   * In these cases, use {@link #forGraph(SuccessorsFunction)} instead.\n", "   *\n"], "5": ["   * <p><b>Examples</b>\n", "   * <p>This is a valid input graph (all edges are directed facing downwards):\n"], "6": ["   * <p>This is <b>not</b> a valid input graph (all edges are directed facing downwards):\n"], "7": ["   * <p>because there are two paths from {@code b} to {@code f} ({@code b->d->f} and {@code\n", "   * b->e->f}).\n", "   *\n"], "11": ["      checkThatNodeIsInGraph(startNode);\n", "          return new BreadthFirstIterator(startNode);\n"], "12": ["      checkThatNodeIsInGraph(startNode);\n", "          return new DepthFirstIterator(startNode, Order.PREORDER);\n"], "13": ["      checkThatNodeIsInGraph(startNode);\n", "          return new DepthFirstIterator(startNode, Order.POSTORDER);\n"], "14": ["      BreadthFirstIterator(N root) {\n", "        queue.add(root);\n", "        visited.add(root);\n"], "15": ["      DepthFirstIterator(N root, Order order) {\n", "        // our invariant is that in computeNext we call next on the iterator at the top first, so we\n", "        // need to start with one additional item on that iterator\n", "        stack.push(withSuccessors(root));\n"], "16": ["          NodeAndSuccessors node = stack.getFirst();\n", "          boolean firstVisit = visited.add(node.node);\n", "          boolean lastVisit = !node.successorIterator.hasNext();\n", "            N successor = node.successorIterator.next();\n", "          if (produceNode) {\n", "            return node.node;\n"], "17": ["        final N node;\n", "        NodeAndSuccessors(N node, Iterable<? extends N> successors) {\n"], "18": ["      checkThatNodeIsInTree(startNode);\n", "          return new BreadthFirstIterator(startNode);\n"], "19": ["      checkThatNodeIsInTree(startNode);\n", "          return new DepthFirstPreOrderIterator(startNode);\n"], "20": ["      checkThatNodeIsInTree(startNode);\n", "          return new DepthFirstPostOrderIterator(startNode);\n"], "21": ["      BreadthFirstIterator(N root) {\n", "        queue.add(root);\n"], "22": ["      DepthFirstPreOrderIterator(N root) {\n", "        stack.addLast(singletonIterator(checkNotNull(root)));\n"], "23": ["      DepthFirstPostOrderIterator(N root) {\n", "        stack.addLast(withChildren(root));\n"], "24": ["            return top.node;\n"], "25": ["        final N node;\n", "        NodeAndChildren(N node, Iterable<? extends N> children) {\n"]}, "added_lines": {"1": [24], "2": [33, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 58, 59], "3": [71, 72, 73, 74, 75, 82, 83, 84], "4": [99, 100, 101, 102, 103, 104, 105, 106, 107, 109, 110, 114, 115], "5": [127, 129, 130, 131], "6": [143, 144, 145, 146], "8": [214, 215, 216, 217, 218, 219, 220, 221, 222, 223, 224], "9": [258, 259, 260, 261, 262, 263, 264, 265, 266, 267, 268], "10": [302, 303, 304, 305, 306, 307, 308, 309, 310, 311, 312], "11": [326, 327, 328, 329, 330, 331, 332, 333, 334, 335, 336, 337, 341], "12": [349, 350, 351, 352, 353, 354, 355, 356, 357, 358, 359, 360, 364], "13": [372, 373, 374, 375, 376, 377, 378, 379, 380, 381, 382, 383, 387], "14": [403, 404, 405, 406, 407, 408, 409], "15": [434, 435], "16": [445, 446, 447, 454, 459, 460], "17": [471, 474], "18": [492, 493, 494, 495, 496, 497, 498, 499, 500, 501, 502, 503, 507], "19": [515, 516, 517, 518, 519, 520, 521, 522, 523, 524, 525, 526, 530], "20": [538, 539, 540, 541, 542, 543, 544, 545, 546, 547, 548, 549, 553], "21": [568, 569, 570, 571], "22": [590, 591], "23": [617, 618], "24": [630, 631, 632], "25": [644, 647]}, "removed_lines": {"1": [21], "2": [35], "3": [47, 48, 55], "4": [70, 72, 76, 77, 80, 81], "5": [91, 93], "6": [105], "7": [117, 118, 119], "11": [255, 259], "12": [267, 271], "13": [279, 283], "14": [299, 300, 301], "15": [326, 327, 328, 329], "16": [339, 340, 341, 348, 353, 354], "17": [365, 368], "18": [386, 390], "19": [398, 402], "20": [410, 414], "21": [429, 430], "22": [449, 450], "23": [476, 477], "24": [489], "25": [501, 504]}}, {"2": "guava-tests/test/com/google/common/graph/TraverserTest.java", "added": {"1": ["import static com.google.common.collect.Lists.charactersOf;\n"], "2": ["  @Test\n", "  public void forGraph_breadthFirstIterable_javadocExample_canBeIteratedMultipleTimes() {\n", "    Iterable<Character> result = Traverser.forGraph(JAVADOC_GRAPH).breadthFirst(charactersOf(\"bf\"));\n", "\n", "    assertEqualCharNodes(result, \"bfaecd\");\n", "    assertEqualCharNodes(result, \"bfaecd\");\n", "  }\n", "\n"], "3": ["  @Test\n", "  public void forGraph_breadthFirstIterable_diamond() {\n", "    Traverser<Character> traverser = Traverser.forGraph(DIAMOND_GRAPH);\n", "    assertEqualCharNodes(traverser.breadthFirst(charactersOf(\"\")), \"\");\n", "    assertEqualCharNodes(traverser.breadthFirst(charactersOf(\"bc\")), \"bcd\");\n", "    assertEqualCharNodes(traverser.breadthFirst(charactersOf(\"a\")), \"abcd\");\n", "    assertEqualCharNodes(traverser.breadthFirst(charactersOf(\"acdb\")), \"acdb\");\n", "    assertEqualCharNodes(traverser.breadthFirst(charactersOf(\"db\")), \"db\");\n", "  }\n", "\n"], "4": ["  @Test\n", "  public void forGraph_breadthFirstIterable_multiGraph() {\n", "    Traverser<Character> traverser = Traverser.forGraph(MULTI_GRAPH);\n", "    assertEqualCharNodes(traverser.breadthFirst(charactersOf(\"ac\")), \"acbd\");\n", "    assertEqualCharNodes(traverser.breadthFirst(charactersOf(\"cb\")), \"cbad\");\n", "    assertEqualCharNodes(traverser.breadthFirst(charactersOf(\"db\")), \"db\");\n", "    assertEqualCharNodes(traverser.breadthFirst(charactersOf(\"d\")), \"d\");\n", "  }\n", "\n"], "5": ["  @Test\n", "  public void forGraph_breadthFirstIterable_cycle() {\n", "    Traverser<Character> traverser = Traverser.forGraph(CYCLE_GRAPH);\n", "    assertEqualCharNodes(traverser.breadthFirst(charactersOf(\"a\")), \"abcd\");\n", "    assertEqualCharNodes(traverser.breadthFirst(charactersOf(\"bd\")), \"bdca\");\n", "    assertEqualCharNodes(traverser.breadthFirst(charactersOf(\"dc\")), \"dcab\");\n", "    assertEqualCharNodes(traverser.breadthFirst(charactersOf(\"bc\")), \"bcda\");\n", "  }\n", "\n"], "6": ["  @Test\n", "  public void forGraph_breadthFirstIterable_twoCycles() {\n", "    Traverser<Character> traverser = Traverser.forGraph(TWO_CYCLES_GRAPH);\n", "    assertEqualCharNodes(traverser.breadthFirst(charactersOf(\"a\")), \"abcd\");\n", "    assertEqualCharNodes(traverser.breadthFirst(charactersOf(\"bd\")), \"bdca\");\n", "    assertEqualCharNodes(traverser.breadthFirst(charactersOf(\"dc\")), \"dcab\");\n", "    assertEqualCharNodes(traverser.breadthFirst(charactersOf(\"bc\")), \"bcda\");\n", "  }\n", "\n"], "7": ["  @Test\n", "  public void forGraph_breadthFirstIterable_tree() throws Exception {\n", "    Traverser<Character> traverser = Traverser.forGraph(TREE);\n", "\n", "    assertEqualCharNodes(traverser.breadthFirst(charactersOf(\"hg\")), \"hgdefabc\");\n", "    assertEqualCharNodes(traverser.breadthFirst(charactersOf(\"gd\")), \"gdfabc\");\n", "    assertEqualCharNodes(traverser.breadthFirst(charactersOf(\"bdgh\")), \"bdghacfe\");\n", "  }\n", "\n"], "8": ["  @Test\n", "  public void forGraph_breadthFirstIterable_twoTrees() {\n", "    assertEqualCharNodes(Traverser.forGraph(TWO_TREES).breadthFirst(charactersOf(\"a\")), \"ab\");\n", "    assertEqualCharNodes(Traverser.forGraph(TWO_TREES).breadthFirst(charactersOf(\"ac\")), \"acbd\");\n", "  }\n", "\n"], "9": ["  @Test\n", "  public void forGraph_breadthFirstIterable_singleRoot() {\n", "    Iterable<Character> result = Traverser.forGraph(SINGLE_ROOT).breadthFirst(charactersOf(\"a\"));\n", "\n", "    assertEqualCharNodes(result, \"a\");\n", "  }\n", "\n"], "10": ["  /**\n", "   * Checks that the elements of the iterable are calculated on the fly. Concretely, that means that\n", "   * {@link SuccessorsFunction#successors(Object)} can only be called for a subset of all nodes.\n", "   */\n", "  @Test\n", "  public void forGraph_breadthFirstIterable_emptyGraph() {\n", "    assertEqualCharNodes(\n", "        Traverser.forGraph(createDirectedGraph()).breadthFirst(charactersOf(\"\")), \"\");\n", "    try {\n", "      Traverser.forGraph(createDirectedGraph()).breadthFirst(charactersOf(\"a\"));\n", "      fail(\"Expected IllegalArgumentException\");\n", "    } catch (IllegalArgumentException expected) {\n", "    }\n", "  }\n", "\n"], "11": ["  @Test\n", "  public void forGraph_breadthFirstIterable_iterableIsLazy() {\n", "    RequestSavingGraph graph = new RequestSavingGraph(DIAMOND_GRAPH);\n", "    Iterable<Character> result = Traverser.forGraph(graph).breadthFirst(charactersOf(\"ab\"));\n", "\n", "    assertEqualCharNodes(Iterables.limit(result, 2), \"ab\");\n", "    assertThat(graph.requestedNodes).containsExactly('a', 'a', 'b', 'b');\n", "\n", "    // Iterate again to see if calculation is done again\n", "    assertEqualCharNodes(Iterables.limit(result, 2), \"ab\");\n", "    assertThat(graph.requestedNodes).containsExactly('a', 'a', 'a', 'b', 'b', 'b');\n", "  }\n", "\n"], "12": ["  @Test\n", "  public void forGraph_depthFirstPreOrderIterable_javadocExample_canBeIteratedMultipleTimes() {\n", "    Iterable<Character> result =\n", "        Traverser.forGraph(JAVADOC_GRAPH).depthFirstPreOrder(charactersOf(\"bc\"));\n", "\n", "    assertEqualCharNodes(result, \"bacefd\");\n", "    assertEqualCharNodes(result, \"bacefd\");\n", "  }\n", "\n"], "13": ["  @Test\n", "  public void forGraph_depthFirstPreOrderIterable_diamond() {\n", "    Traverser<Character> traverser = Traverser.forGraph(DIAMOND_GRAPH);\n", "    assertEqualCharNodes(traverser.depthFirstPreOrder(charactersOf(\"\")), \"\");\n", "    assertEqualCharNodes(traverser.depthFirstPreOrder(charactersOf(\"bc\")), \"bdc\");\n", "    assertEqualCharNodes(traverser.depthFirstPreOrder(charactersOf(\"a\")), \"abdc\");\n", "    assertEqualCharNodes(traverser.depthFirstPreOrder(charactersOf(\"acdb\")), \"abdc\");\n", "    assertEqualCharNodes(traverser.depthFirstPreOrder(charactersOf(\"db\")), \"db\");\n", "  }\n", "\n"], "14": ["  @Test\n", "  public void forGraph_depthFirstPreOrderIterable_multigraph() {\n", "    Traverser<Character> traverser = Traverser.forGraph(MULTI_GRAPH);\n", "    assertEqualCharNodes(traverser.depthFirstPreOrder(charactersOf(\"ac\")), \"abdc\");\n", "    assertEqualCharNodes(traverser.depthFirstPreOrder(charactersOf(\"cb\")), \"cabd\");\n", "    assertEqualCharNodes(traverser.depthFirstPreOrder(charactersOf(\"db\")), \"db\");\n", "    assertEqualCharNodes(traverser.depthFirstPreOrder(charactersOf(\"d\")), \"d\");\n", "  }\n", "\n"], "15": ["  @Test\n", "  public void forGraph_depthFirstPreOrderIterable_cycle() {\n", "    Traverser<Character> traverser = Traverser.forGraph(CYCLE_GRAPH);\n", "    assertEqualCharNodes(traverser.depthFirstPreOrder(charactersOf(\"a\")), \"abcd\");\n", "    assertEqualCharNodes(traverser.depthFirstPreOrder(charactersOf(\"bd\")), \"bcda\");\n", "    assertEqualCharNodes(traverser.depthFirstPreOrder(charactersOf(\"dc\")), \"dabc\");\n", "    assertEqualCharNodes(traverser.depthFirstPreOrder(charactersOf(\"bc\")), \"bcda\");\n", "  }\n", "\n"], "16": ["  @Test\n", "  public void forGraph_depthFirstPreOrderIterable_twoCycles() {\n", "    Traverser<Character> traverser = Traverser.forGraph(TWO_CYCLES_GRAPH);\n", "    assertEqualCharNodes(traverser.depthFirstPreOrder(charactersOf(\"a\")), \"abcd\");\n", "    assertEqualCharNodes(traverser.depthFirstPreOrder(charactersOf(\"bd\")), \"bcda\");\n", "    assertEqualCharNodes(traverser.depthFirstPreOrder(charactersOf(\"dc\")), \"dabc\");\n", "    assertEqualCharNodes(traverser.depthFirstPreOrder(charactersOf(\"bc\")), \"bcda\");\n", "  }\n", "\n"], "17": ["  @Test\n", "  public void forGraph_depthFirstPreOrderIterable_tree() throws Exception {\n", "    Traverser<Character> traverser = Traverser.forGraph(TREE);\n", "\n", "    assertEqualCharNodes(traverser.depthFirstPreOrder(charactersOf(\"hg\")), \"hdabcegf\");\n", "    assertEqualCharNodes(traverser.depthFirstPreOrder(charactersOf(\"gd\")), \"gfdabc\");\n", "    assertEqualCharNodes(traverser.depthFirstPreOrder(charactersOf(\"bdgh\")), \"bdacgfhe\");\n", "  }\n", "\n"], "18": ["  @Test\n", "  public void forGraph_depthFirstPreOrderIterable_twoTrees() {\n", "    assertEqualCharNodes(Traverser.forGraph(TWO_TREES).depthFirstPreOrder(charactersOf(\"a\")), \"ab\");\n", "    assertEqualCharNodes(\n", "        Traverser.forGraph(TWO_TREES).depthFirstPreOrder(charactersOf(\"ac\")), \"abcd\");\n", "  }\n", "\n"], "19": ["  @Test\n", "  public void forGraph_depthFirstPreOrderIterable_singleRoot() {\n", "    Iterable<Character> result =\n", "        Traverser.forGraph(SINGLE_ROOT).depthFirstPreOrder(charactersOf(\"a\"));\n", "\n", "    assertEqualCharNodes(result, \"a\");\n", "  }\n", "\n"], "20": ["  @Test\n", "  public void forGraph_depthFirstPreOrderIterable_emptyGraph() {\n", "    assertEqualCharNodes(\n", "        Traverser.forGraph(createDirectedGraph()).depthFirstPreOrder(charactersOf(\"\")), \"\");\n", "    try {\n", "      Traverser.forGraph(createDirectedGraph()).depthFirstPreOrder(charactersOf(\"a\"));\n", "      fail(\"Expected IllegalArgumentException\");\n", "    } catch (IllegalArgumentException expected) {\n", "    }\n", "  }\n", "\n"], "21": ["  @Test\n", "  public void forGraph_depthFirstPreOrderIterable_iterableIsLazy() {\n", "    RequestSavingGraph graph = new RequestSavingGraph(DIAMOND_GRAPH);\n", "    Iterable<Character> result = Traverser.forGraph(graph).depthFirstPreOrder(charactersOf(\"ac\"));\n", "\n", "    assertEqualCharNodes(Iterables.limit(result, 2), \"ab\");\n", "    assertThat(graph.requestedNodes).containsExactly('a', 'a', 'b', 'c', 'd');\n", "\n", "    // Iterate again to see if calculation is done again\n", "    assertEqualCharNodes(Iterables.limit(result, 2), \"ab\");\n", "    assertThat(graph.requestedNodes).containsExactly('a', 'a', 'a', 'b', 'b', 'c', 'd', 'd');\n", "  }\n", "\n"], "22": ["  @Test\n", "  public void forGraph_depthFirstPostOrderIterable_javadocExample_canBeIteratedMultipleTimes() {\n", "    Iterable<Character> result =\n", "        Traverser.forGraph(JAVADOC_GRAPH).depthFirstPostOrder(charactersOf(\"bf\"));\n", "    assertEqualCharNodes(result, \"efcdab\");\n", "    assertEqualCharNodes(result, \"efcdab\");\n", "  }\n", "\n"], "23": ["  @Test\n", "  public void forGraph_depthFirstPostOrderIterable_diamond() {\n", "    Traverser<Character> traverser = Traverser.forGraph(DIAMOND_GRAPH);\n", "    assertEqualCharNodes(traverser.depthFirstPostOrder(charactersOf(\"\")), \"\");\n", "    assertEqualCharNodes(traverser.depthFirstPostOrder(charactersOf(\"bc\")), \"dbc\");\n", "    assertEqualCharNodes(traverser.depthFirstPostOrder(charactersOf(\"a\")), \"dbca\");\n", "    assertEqualCharNodes(traverser.depthFirstPostOrder(charactersOf(\"acdb\")), \"dbca\");\n", "    assertEqualCharNodes(traverser.depthFirstPostOrder(charactersOf(\"db\")), \"db\");\n", "  }\n", "\n"], "24": ["  @Test\n", "  public void forGraph_depthFirstPostOrderIterable_multigraph() {\n", "    Traverser<Character> traverser = Traverser.forGraph(MULTI_GRAPH);\n", "    assertEqualCharNodes(traverser.depthFirstPostOrder(charactersOf(\"ac\")), \"dbca\");\n", "    assertEqualCharNodes(traverser.depthFirstPostOrder(charactersOf(\"cb\")), \"dbac\");\n", "    assertEqualCharNodes(traverser.depthFirstPostOrder(charactersOf(\"db\")), \"db\");\n", "    assertEqualCharNodes(traverser.depthFirstPostOrder(charactersOf(\"d\")), \"d\");\n", "  }\n", "\n"], "25": ["  @Test\n", "  public void forGraph_depthFirstPostOrderIterable_cycle() {\n", "    Traverser<Character> traverser = Traverser.forGraph(CYCLE_GRAPH);\n", "    assertEqualCharNodes(traverser.depthFirstPostOrder(charactersOf(\"a\")), \"dcba\");\n", "    assertEqualCharNodes(traverser.depthFirstPostOrder(charactersOf(\"bd\")), \"adcb\");\n", "    assertEqualCharNodes(traverser.depthFirstPostOrder(charactersOf(\"dc\")), \"cbad\");\n", "    assertEqualCharNodes(traverser.depthFirstPostOrder(charactersOf(\"bc\")), \"adcb\");\n", "  }\n", "\n"], "26": ["  @Test\n", "  public void forGraph_depthFirstPostOrderIterable_twoCycles() {\n", "    Traverser<Character> traverser = Traverser.forGraph(TWO_CYCLES_GRAPH);\n", "    assertEqualCharNodes(traverser.depthFirstPostOrder(charactersOf(\"a\")), \"dcba\");\n", "    assertEqualCharNodes(traverser.depthFirstPostOrder(charactersOf(\"bd\")), \"adcb\");\n", "    assertEqualCharNodes(traverser.depthFirstPostOrder(charactersOf(\"dc\")), \"cbad\");\n", "    assertEqualCharNodes(traverser.depthFirstPostOrder(charactersOf(\"bc\")), \"adcb\");\n", "  }\n", "\n"], "27": ["  @Test\n", "  public void forGraph_depthFirstPostOrderIterable_tree() throws Exception {\n", "    Traverser<Character> traverser = Traverser.forGraph(TREE);\n", "\n", "    assertEqualCharNodes(traverser.depthFirstPostOrder(charactersOf(\"hg\")), \"abcdefgh\");\n", "    assertEqualCharNodes(traverser.depthFirstPostOrder(charactersOf(\"gd\")), \"fgabcd\");\n", "    assertEqualCharNodes(traverser.depthFirstPostOrder(charactersOf(\"bdgh\")), \"bacdfgeh\");\n", "  }\n", "\n"], "28": ["  @Test\n", "  public void forGraph_depthFirstPostOrderIterable_twoTrees() {\n", "    assertEqualCharNodes(\n", "        Traverser.forGraph(TWO_TREES).depthFirstPostOrder(charactersOf(\"a\")), \"ba\");\n", "    assertEqualCharNodes(\n", "        Traverser.forGraph(TWO_TREES).depthFirstPostOrder(charactersOf(\"ac\")), \"badc\");\n", "  }\n", "\n"], "29": ["  @Test\n", "  public void forGraph_depthFirstPostOrderIterable_singleRoot() {\n", "    Iterable<Character> result =\n", "        Traverser.forGraph(SINGLE_ROOT).depthFirstPostOrder(charactersOf(\"a\"));\n", "\n", "    assertEqualCharNodes(result, \"a\");\n", "  }\n", "\n"], "30": ["  @Test\n", "  public void forGraph_depthFirstPostOrderIterable_emptyGraph() {\n", "    assertEqualCharNodes(\n", "        Traverser.forGraph(createDirectedGraph()).depthFirstPostOrder(charactersOf(\"\")), \"\");\n", "    try {\n", "      Traverser.forGraph(createDirectedGraph()).depthFirstPostOrder(charactersOf(\"a\"));\n", "      fail(\"Expected IllegalArgumentException\");\n", "    } catch (IllegalArgumentException expected) {\n", "    }\n", "  }\n", "\n"], "31": ["  @Test\n", "  public void forGraph_depthFirstPostOrderIterable_iterableIsLazy() {\n", "    RequestSavingGraph graph = new RequestSavingGraph(DIAMOND_GRAPH);\n", "    Iterable<Character> result = Traverser.forGraph(graph).depthFirstPostOrder(charactersOf(\"ac\"));\n", "\n", "    assertEqualCharNodes(Iterables.limit(result, 2), \"db\");\n", "    assertThat(graph.requestedNodes).containsExactly('a', 'a', 'b', 'c', 'd');\n", "\n", "    // Iterate again to see if calculation is done again\n", "    assertEqualCharNodes(Iterables.limit(result, 2), \"db\");\n", "    assertThat(graph.requestedNodes).containsExactly('a', 'a', 'a', 'b', 'b', 'c', 'd', 'd');\n", "  }\n", "\n"], "32": ["  @Test\n", "  public void forTree_breadthFirstIterable_tree() throws Exception {\n", "    Traverser<Character> traverser = Traverser.forTree(TREE);\n", "\n", "    assertEqualCharNodes(traverser.breadthFirst(charactersOf(\"\")), \"\");\n", "    assertEqualCharNodes(traverser.breadthFirst(charactersOf(\"h\")), \"hdegabcf\");\n", "    assertEqualCharNodes(traverser.breadthFirst(charactersOf(\"gd\")), \"gdfabc\");\n", "    assertEqualCharNodes(traverser.breadthFirst(charactersOf(\"age\")), \"agef\");\n", "  }\n", "\n"], "33": ["  @Test\n", "  public void forTree_breadthFirstIterable_cyclicGraphContainingTree() throws Exception {\n", "    Traverser<Character> traverser = Traverser.forTree(CYCLIC_GRAPH_CONTAINING_TREE);\n", "\n", "    assertEqualCharNodes(traverser.breadthFirst(charactersOf(\"a\")), \"abcd\");\n", "    assertEqualCharNodes(traverser.breadthFirst(charactersOf(\"b\")), \"bcd\");\n", "    assertEqualCharNodes(traverser.breadthFirst(charactersOf(\"cd\")), \"cd\");\n", "  }\n", "\n"], "34": ["  @Test\n", "  public void forTree_breadthFirstIterable_graphContainingTreeAndDiamond() throws Exception {\n", "    Traverser<Character> traverser = Traverser.forTree(GRAPH_CONTAINING_TREE_AND_DIAMOND);\n", "\n", "    assertEqualCharNodes(traverser.breadthFirst(charactersOf(\"a\")), \"abcd\");\n", "    assertEqualCharNodes(traverser.breadthFirst(charactersOf(\"bg\")), \"bgcdh\");\n", "    assertEqualCharNodes(traverser.breadthFirst(charactersOf(\"ga\")), \"gahbcd\");\n", "  }\n", "\n"], "35": ["  @Test\n", "  public void forTree_breadthFirstIterable_twoTrees() {\n", "    assertEqualCharNodes(Traverser.forTree(TWO_TREES).breadthFirst(charactersOf(\"a\")), \"ab\");\n", "    assertEqualCharNodes(Traverser.forTree(TWO_TREES).breadthFirst(charactersOf(\"ca\")), \"cadb\");\n", "  }\n", "\n"], "36": ["  @Test\n", "  public void forTree_breadthFirstIterable_singleRoot() {\n", "    Iterable<Character> result = Traverser.forTree(SINGLE_ROOT).breadthFirst(charactersOf(\"a\"));\n", "\n", "    assertEqualCharNodes(result, \"a\");\n", "  }\n", "\n"], "37": ["  @Test\n", "  public void forTree_breadthFirstIterable_emptyGraph() {\n", "    assertEqualCharNodes(\n", "        Traverser.forTree(createDirectedGraph()).breadthFirst(charactersOf(\"\")), \"\");\n", "    try {\n", "      Traverser.forTree(createDirectedGraph()).breadthFirst(charactersOf(\"a\"));\n", "      fail(\"Expected IllegalArgumentException\");\n", "    } catch (IllegalArgumentException expected) {\n", "    }\n", "  }\n", "\n"], "38": ["  public void forTree_breadthFirstIterable_iterableIsLazy() {\n", "    RequestSavingGraph graph = new RequestSavingGraph(TREE);\n", "    Iterable<Character> result = Traverser.forGraph(graph).breadthFirst(charactersOf(\"dg\"));\n", "\n", "    assertEqualCharNodes(Iterables.limit(result, 3), \"dga\");\n", "    assertThat(graph.requestedNodes).containsExactly('a', 'd', 'd', 'g', 'g');\n", "\n", "    // Iterate again to see if calculation is done again\n", "    assertEqualCharNodes(Iterables.limit(result, 3), \"dga\");\n", "    assertThat(graph.requestedNodes).containsExactly('a', 'a', 'd', 'd', 'd', 'g', 'g', 'g');\n", "  }\n", "\n", "  @Test\n", "  public void forTree_depthFirstPreOrderIterable_tree() throws Exception {\n", "    assertEqualCharNodes(traverser.depthFirstPreOrder(charactersOf(\"h\")), \"hdabcegf\");\n", "    assertEqualCharNodes(traverser.depthFirstPreOrder(charactersOf(\"d\")), \"dabc\");\n", "    assertEqualCharNodes(traverser.depthFirstPreOrder(charactersOf(\"a\")), \"a\");\n", "  }\n", "\n", "  @Test\n", "  public void forTree_depthFirstPreOrderIterableIterable_tree() throws Exception {\n", "    Traverser<Character> traverser = Traverser.forTree(TREE);\n", "\n", "    assertEqualCharNodes(traverser.depthFirstPreOrder(charactersOf(\"\")), \"\");\n", "    assertEqualCharNodes(traverser.depthFirstPreOrder(charactersOf(\"h\")), \"hdabcegf\");\n", "    assertEqualCharNodes(traverser.depthFirstPreOrder(charactersOf(\"gd\")), \"gfdabc\");\n", "    assertEqualCharNodes(traverser.depthFirstPreOrder(charactersOf(\"age\")), \"agfe\");\n"], "39": ["  @Test\n", "  public void forTree_depthFirstPreOrderIterable_cyclicGraphContainingTree() throws Exception {\n", "    Traverser<Character> traverser = Traverser.forTree(CYCLIC_GRAPH_CONTAINING_TREE);\n", "\n", "    assertEqualCharNodes(traverser.depthFirstPreOrder(charactersOf(\"a\")), \"abcd\");\n", "    assertEqualCharNodes(traverser.depthFirstPreOrder(charactersOf(\"b\")), \"bcd\");\n", "    assertEqualCharNodes(traverser.depthFirstPreOrder(charactersOf(\"cd\")), \"cd\");\n", "  }\n", "\n"], "40": ["  @Test\n", "  public void forTree_depthFirstPreOrderIterable_graphContainingTreeAndDiamond() throws Exception {\n", "    Traverser<Character> traverser = Traverser.forTree(GRAPH_CONTAINING_TREE_AND_DIAMOND);\n", "\n", "    assertEqualCharNodes(traverser.depthFirstPreOrder(charactersOf(\"a\")), \"abcd\");\n", "    assertEqualCharNodes(traverser.depthFirstPreOrder(charactersOf(\"bg\")), \"bcdgh\");\n", "    assertEqualCharNodes(traverser.depthFirstPreOrder(charactersOf(\"ga\")), \"ghabcd\");\n", "  }\n", "\n"], "41": ["  @Test\n", "  public void forTree_depthFirstPreOrderIterable_twoTrees() {\n", "    assertEqualCharNodes(Traverser.forTree(TWO_TREES).depthFirstPreOrder(charactersOf(\"a\")), \"ab\");\n", "    assertEqualCharNodes(\n", "        Traverser.forTree(TWO_TREES).depthFirstPreOrder(charactersOf(\"ca\")), \"cdab\");\n", "  }\n", "\n"], "42": ["  @Test\n", "  public void forTree_depthFirstPreOrderIterable_singleRoot() {\n", "    Iterable<Character> result =\n", "        Traverser.forTree(SINGLE_ROOT).depthFirstPreOrder(charactersOf(\"a\"));\n", "\n", "    assertEqualCharNodes(result, \"a\");\n", "  }\n", "\n"], "43": ["  @Test\n", "  public void forTree_depthFirstPreOrderIterable_emptyGraph() {\n", "    assertEqualCharNodes(\n", "        Traverser.forTree(createDirectedGraph()).depthFirstPreOrder(charactersOf(\"\")), \"\");\n", "    try {\n", "      Traverser.forTree(createDirectedGraph()).depthFirstPreOrder(charactersOf(\"a\"));\n", "      fail(\"Expected IllegalArgumentException\");\n", "    } catch (IllegalArgumentException expected) {\n", "    }\n", "  }\n", "\n"], "44": ["  @Test\n", "  public void forTree_depthFirstPreOrderIterable_iterableIsLazy() {\n", "    RequestSavingGraph graph = new RequestSavingGraph(TREE);\n", "    Iterable<Character> result = Traverser.forGraph(graph).depthFirstPreOrder(charactersOf(\"dg\"));\n", "\n", "    assertEqualCharNodes(Iterables.limit(result, 2), \"da\");\n", "    assertThat(graph.requestedNodes).containsExactly('a', 'd', 'd', 'g');\n", "\n", "    // Iterate again to see if calculation is done again\n", "    assertEqualCharNodes(Iterables.limit(result, 2), \"da\");\n", "    assertThat(graph.requestedNodes).containsExactly('a', 'a', 'd', 'd', 'd', 'g');\n", "  }\n", "\n"], "45": ["  @Test\n", "  public void forTree_depthFirstPostOrderIterable_tree() throws Exception {\n", "    Traverser<Character> traverser = Traverser.forTree(TREE);\n", "\n", "    assertEqualCharNodes(traverser.depthFirstPostOrder(charactersOf(\"\")), \"\");\n", "    assertEqualCharNodes(traverser.depthFirstPostOrder(charactersOf(\"h\")), \"abcdefgh\");\n", "    assertEqualCharNodes(traverser.depthFirstPostOrder(charactersOf(\"gd\")), \"fgabcd\");\n", "    assertEqualCharNodes(traverser.depthFirstPostOrder(charactersOf(\"age\")), \"afge\");\n", "  }\n", "\n"], "46": ["  @Test\n", "  public void forTree_depthFirstPostOrderIterable_cyclicGraphContainingTree() throws Exception {\n", "    Traverser<Character> traverser = Traverser.forTree(CYCLIC_GRAPH_CONTAINING_TREE);\n", "\n", "    assertEqualCharNodes(traverser.depthFirstPostOrder(charactersOf(\"a\")), \"cdba\");\n", "    assertEqualCharNodes(traverser.depthFirstPostOrder(charactersOf(\"b\")), \"cdb\");\n", "    assertEqualCharNodes(traverser.depthFirstPostOrder(charactersOf(\"cd\")), \"cd\");\n", "  }\n", "\n"], "47": ["  @Test\n", "  public void forTree_depthFirstPostOrderIterable_graphContainingTreeAndDiamond() throws Exception {\n", "    Traverser<Character> traverser = Traverser.forTree(GRAPH_CONTAINING_TREE_AND_DIAMOND);\n", "\n", "    assertEqualCharNodes(traverser.depthFirstPostOrder(charactersOf(\"a\")), \"cdba\");\n", "    assertEqualCharNodes(traverser.depthFirstPostOrder(charactersOf(\"bg\")), \"cdbhg\");\n", "    assertEqualCharNodes(traverser.depthFirstPostOrder(charactersOf(\"ga\")), \"hgcdba\");\n", "  }\n", "\n"], "48": ["  @Test\n", "  public void forTree_depthFirstPostOrderIterable_twoTrees() {\n", "    assertEqualCharNodes(Traverser.forTree(TWO_TREES).depthFirstPostOrder(charactersOf(\"a\")), \"ba\");\n", "    assertEqualCharNodes(\n", "        Traverser.forTree(TWO_TREES).depthFirstPostOrder(charactersOf(\"ca\")), \"dcba\");\n", "  }\n", "\n"], "49": ["  @Test\n", "  public void forTree_depthFirstPostOrderIterable_singleRoot() {\n", "    Iterable<Character> result =\n", "        Traverser.forTree(SINGLE_ROOT).depthFirstPostOrder(charactersOf(\"a\"));\n", "\n", "    assertEqualCharNodes(result, \"a\");\n", "  }\n", "\n"], "50": ["  @Test\n", "  public void forTree_depthFirstPostOrderIterable_emptyGraph() {\n", "    assertEqualCharNodes(\n", "        Traverser.forTree(createDirectedGraph()).depthFirstPostOrder(charactersOf(\"\")), \"\");\n", "    try {\n", "      Traverser.forTree(createDirectedGraph()).depthFirstPostOrder(charactersOf(\"a\"));\n", "      fail(\"Expected IllegalArgumentException\");\n", "    } catch (IllegalArgumentException expected) {\n", "    }\n", "  }\n", "\n"], "51": ["  @Test\n", "  public void forTree_depthFirstPostOrderIterable_iterableIsLazy() {\n", "    RequestSavingGraph graph = new RequestSavingGraph(TREE);\n", "    Iterable<Character> result = Traverser.forGraph(graph).depthFirstPostOrder(charactersOf(\"dg\"));\n", "\n", "    assertEqualCharNodes(Iterables.limit(result, 2), \"ab\");\n", "    assertThat(graph.requestedNodes).containsExactly('a', 'b', 'd', 'd', 'g');\n", "\n", "    // Iterate again to see if calculation is done again\n", "    assertEqualCharNodes(Iterables.limit(result, 2), \"ab\");\n", "    assertThat(graph.requestedNodes).containsExactly('a', 'a', 'b', 'b', 'd', 'd', 'd', 'g');\n", "  }\n", "\n"]}, "removed": {"38": ["  public void forTree_depthFirstPreOrder_tree() throws Exception {\n", "    assertEqualCharNodes(traverser.depthFirstPreOrder('h'), \"hdabcegf\");\n", "    assertEqualCharNodes(traverser.depthFirstPreOrder('d'), \"dabc\");\n", "    assertEqualCharNodes(traverser.depthFirstPreOrder('a'), \"a\");\n"]}, "added_lines": {"1": [22], "2": [179, 180, 181, 182, 183, 184, 185, 186], "3": [196, 197, 198, 199, 200, 201, 202, 203, 204, 205], "4": [215, 216, 217, 218, 219, 220, 221, 222, 223], "5": [233, 234, 235, 236, 237, 238, 239, 240, 241], "6": [251, 252, 253, 254, 255, 256, 257, 258, 259], "7": [269, 270, 271, 272, 273, 274, 275, 276, 277], "8": [285, 286, 287, 288, 289, 290], "9": [298, 299, 300, 301, 302, 303, 304], "10": [314, 315, 316, 317, 318, 319, 320, 321, 322, 323, 324, 325, 326, 327, 328], "11": [346, 347, 348, 349, 350, 351, 352, 353, 354, 355, 356, 357, 358], "12": [367, 368, 369, 370, 371, 372, 373, 374, 375], "13": [385, 386, 387, 388, 389, 390, 391, 392, 393, 394], "14": [404, 405, 406, 407, 408, 409, 410, 411, 412], "15": [422, 423, 424, 425, 426, 427, 428, 429, 430], "16": [440, 441, 442, 443, 444, 445, 446, 447, 448], "17": [458, 459, 460, 461, 462, 463, 464, 465, 466], "18": [474, 475, 476, 477, 478, 479, 480], "19": [488, 489, 490, 491, 492, 493, 494, 495], "20": [505, 506, 507, 508, 509, 510, 511, 512, 513, 514, 515], "21": [529, 530, 531, 532, 533, 534, 535, 536, 537, 538, 539, 540, 541], "22": [549, 550, 551, 552, 553, 554, 555, 556], "23": [566, 567, 568, 569, 570, 571, 572, 573, 574, 575], "24": [585, 586, 587, 588, 589, 590, 591, 592, 593], "25": [603, 604, 605, 606, 607, 608, 609, 610, 611], "26": [621, 622, 623, 624, 625, 626, 627, 628, 629], "27": [639, 640, 641, 642, 643, 644, 645, 646, 647], "28": [655, 656, 657, 658, 659, 660, 661, 662], "29": [670, 671, 672, 673, 674, 675, 676, 677], "30": [687, 688, 689, 690, 691, 692, 693, 694, 695, 696, 697], "31": [711, 712, 713, 714, 715, 716, 717, 718, 719, 720, 721, 722, 723], "32": [796, 797, 798, 799, 800, 801, 802, 803, 804, 805], "33": [815, 816, 817, 818, 819, 820, 821, 822, 823], "34": [833, 834, 835, 836, 837, 838, 839, 840, 841], "35": [849, 850, 851, 852, 853, 854], "36": [862, 863, 864, 865, 866, 867, 868], "37": [878, 879, 880, 881, 882, 883, 884, 885, 886, 887, 888], "38": [903, 904, 905, 906, 907, 908, 909, 910, 911, 912, 913, 914, 915, 916, 919, 920, 921, 922, 923, 924, 925, 926, 927, 928, 929, 930, 931], "39": [943, 944, 945, 946, 947, 948, 949, 950, 951], "40": [961, 962, 963, 964, 965, 966, 967, 968, 969], "41": [977, 978, 979, 980, 981, 982, 983], "42": [991, 992, 993, 994, 995, 996, 997, 998], "43": [1008, 1009, 1010, 1011, 1012, 1013, 1014, 1015, 1016, 1017, 1018], "44": [1032, 1033, 1034, 1035, 1036, 1037, 1038, 1039, 1040, 1041, 1042, 1043, 1044], "45": [1054, 1055, 1056, 1057, 1058, 1059, 1060, 1061, 1062, 1063], "46": [1073, 1074, 1075, 1076, 1077, 1078, 1079, 1080, 1081], "47": [1091, 1092, 1093, 1094, 1095, 1096, 1097, 1098, 1099], "48": [1107, 1108, 1109, 1110, 1111, 1112, 1113], "49": [1121, 1122, 1123, 1124, 1125, 1126, 1127, 1128], "50": [1138, 1139, 1140, 1141, 1142, 1143, 1144, 1145, 1146, 1147, 1148], "51": [1162, 1163, 1164, 1165, 1166, 1167, 1168, 1169, 1170, 1171, 1172, 1173, 1174]}, "removed_lines": {"38": [567, 570, 571, 572]}}, {"3": "guava/src/com/google/common/graph/Traverser.java", "added": {"1": ["import com.google.common.collect.ImmutableSet;\n"], "2": ["import org.checkerframework.checker.nullness.compatqual.NullableDecl;\n", " * An object that can traverse the nodes that are reachable from a specified (set of) start node(s)\n", " * using a specified {@link SuccessorsFunction}.\n", " *\n", " * <p>There are two entry points for creating a {@code Traverser}: {@link\n", " * #forTree(SuccessorsFunction)} and {@link #forGraph(SuccessorsFunction)}. You should choose one\n", " * based on your answers to the following questions:\n", " *\n", " * <ol>\n", " *   <li>Is there only one path to any node that's reachable from any start node? (If so, the\n", " *       graph to be traversed is a tree or forest even if it is a subgraph of a graph which is\n", " *       neither.)\n", " *   <li>Are the node objects' implementations of {@code equals()}/{@code hashCode()} <a\n", " *       href=\"https://github.com/google/guava/wiki/GraphsExplained#non-recursiveness\">recursive</a>?\n", " * </ol>\n", " *\n", " * <p>If your answers are:\n", " *\n", " * <ul>\n", " *   <li>(1) \"no\" and (2) \"no\", use {@link #forGraph(SuccessorsFunction)}.\n", " *   <li>(1) \"yes\" and (2) \"yes\", use {@link #forTree(SuccessorsFunction)}.\n", " *   <li>(1) \"yes\" and (2) \"no\", you can use either, but {@code forTree()} will be more efficient.\n", " *   <li>(1) \"no\" and (2) \"yes\", <b><i>neither will work</i></b>, but if you transform your node\n", " *       objects into a non-recursive form, you can use {@code forGraph()}.\n", " * </ul>\n"], "3": ["   * <p>Traversers created using this method are guaranteed to visit each node reachable from the\n", "   * start node(s) at most once.\n", "   *\n", "   * <p>If you know that no node in {@code graph} is reachable by more than one path from the start\n", "   * node(s), consider using {@link #forTree(SuccessorsFunction)} instead.\n", "   *       {@code hashCode()} implementations. (See the <a\n", "   *       href=\"https://github.com/google/guava/wiki/GraphsExplained#elements-must-be-useable-as-map-keys\">\n", "   *       notes on element objects</a> for more information.)\n"], "4": ["   * node(s) to any node reachable from the start node(s), and has no paths from any start node to\n", "   * any other start node, such as a tree or forest.\n", "   *\n", "   * <p>{@code forTree()} is especially useful (versus {@code forGraph()}) in cases where the data\n", "   * structure being traversed is, in addition to being a tree/forest, also defined <a\n", "   * href=\"https://github.com/google/guava/wiki/GraphsExplained#non-recursiveness\">recursively</a>.\n", "   * This is because the {@code forTree()}-based implementations don't keep track of visited nodes,\n", "   * and therefore don't need to call `equals()` or `hashCode()` on the node objects; this saves\n", "   * both time and space versus traversing the same graph using {@code forGraph()}.\n", "   * <p>Providing a graph to be traversed for which there is more than one path from the start\n", "   * node(s) to any node may lead to:\n", "   *   <li>Nodes being visited multiple times (if multiple paths exist from any start node to any\n", "   *       node reachable from any start node)\n"], "5": ["   * <p><b>Examples</b> (all edges are directed facing downwards)\n", "   * <p>The graph below would be valid input with start nodes of {@code a, f, c}. However, if {@code\n", "   * b} were <i>also</i> a start node, then there would be multiple paths to reach {@code e} and\n", "   * {@code h}.\n"], "6": ["   * <p>.\n", "   *\n", "   * <p>The graph below would be a valid input with start nodes of {@code a, f}. However, if {@code\n", "   * b} were a start node, there would be multiple paths to {@code f}.\n"], "8": ["  /**\n", "   * Returns an unmodifiable {@code Iterable} over the nodes reachable from any of the {@code\n", "   * startNodes}, in the order of a breadth-first traversal. This is equivalent to a breadth-first\n", "   * traversal of a graph with an additional root node whose successors are the listed {@code\n", "   * startNodes}.\n", "   *\n", "   * @throws IllegalArgumentException if any of {@code startNodes} is not an element of the graph\n", "   * @see #breadthFirst(Object)\n", "   */\n", "  public abstract Iterable<N> breadthFirst(Iterable<? extends N> startNodes);\n", "\n"], "9": ["  /**\n", "   * Returns an unmodifiable {@code Iterable} over the nodes reachable from any of the {@code\n", "   * startNodes}, in the order of a depth-first pre-order traversal. This is equivalent to a\n", "   * depth-first pre-order traversal of a graph with an additional root node whose successors are\n", "   * the listed {@code startNodes}.\n", "   *\n", "   * @throws IllegalArgumentException if any of {@code startNodes} is not an element of the graph\n", "   * @see #depthFirstPreOrder(Object)\n", "   */\n", "  public abstract Iterable<N> depthFirstPreOrder(Iterable<? extends N> startNodes);\n", "\n"], "10": ["  /**\n", "   * Returns an unmodifiable {@code Iterable} over the nodes reachable from any of the {@code\n", "   * startNodes}, in the order of a depth-first post-order traversal. This is equivalent to a\n", "   * depth-first post-order traversal of a graph with an additional root node whose successors are\n", "   * the listed {@code startNodes}.\n", "   *\n", "   * @throws IllegalArgumentException if any of {@code startNodes} is not an element of the graph\n", "   * @see #depthFirstPostOrder(Object)\n", "   */\n", "  public abstract Iterable<N> depthFirstPostOrder(Iterable<? extends N> startNodes);\n", "\n"], "11": ["      return breadthFirst(ImmutableSet.of(startNode));\n", "    }\n", "\n", "    @Override\n", "    public Iterable<N> breadthFirst(final Iterable<? extends N> startNodes) {\n", "      checkNotNull(startNodes);\n", "      if (Iterables.isEmpty(startNodes)) {\n", "        return ImmutableSet.of();\n", "      }\n", "      for (N startNode : startNodes) {\n", "        checkThatNodeIsInGraph(startNode);\n", "      }\n", "          return new BreadthFirstIterator(startNodes);\n"], "12": ["      return depthFirstPreOrder(ImmutableSet.of(startNode));\n", "    }\n", "\n", "    @Override\n", "    public Iterable<N> depthFirstPreOrder(final Iterable<? extends N> startNodes) {\n", "      checkNotNull(startNodes);\n", "      if (Iterables.isEmpty(startNodes)) {\n", "        return ImmutableSet.of();\n", "      }\n", "      for (N startNode : startNodes) {\n", "        checkThatNodeIsInGraph(startNode);\n", "      }\n", "          return new DepthFirstIterator(startNodes, Order.PREORDER);\n"], "13": ["      return depthFirstPostOrder(ImmutableSet.of(startNode));\n", "    }\n", "\n", "    @Override\n", "    public Iterable<N> depthFirstPostOrder(final Iterable<? extends N> startNodes) {\n", "      checkNotNull(startNodes);\n", "      if (Iterables.isEmpty(startNodes)) {\n", "        return ImmutableSet.of();\n", "      }\n", "      for (N startNode : startNodes) {\n", "        checkThatNodeIsInGraph(startNode);\n", "      }\n", "          return new DepthFirstIterator(startNodes, Order.POSTORDER);\n"], "14": ["      BreadthFirstIterator(Iterable<? extends N> roots) {\n", "        for (N root : roots) {\n", "          // add all roots to the queue, skipping duplicates\n", "          if (visited.add(root)) {\n", "            queue.add(root);\n", "          }\n", "        }\n"], "15": ["      DepthFirstIterator(Iterable<? extends N> roots, Order order) {\n", "        stack.push(new NodeAndSuccessors(null, roots));\n"], "16": ["          NodeAndSuccessors nodeAndSuccessors = stack.getFirst();\n", "          boolean firstVisit = visited.add(nodeAndSuccessors.node);\n", "          boolean lastVisit = !nodeAndSuccessors.successorIterator.hasNext();\n", "            N successor = nodeAndSuccessors.successorIterator.next();\n", "          if (produceNode && nodeAndSuccessors.node != null) {\n", "            return nodeAndSuccessors.node;\n"], "17": ["        @NullableDecl final N node;\n", "        NodeAndSuccessors(@NullableDecl N node, Iterable<? extends N> successors) {\n"], "18": ["      return breadthFirst(ImmutableSet.of(startNode));\n", "    }\n", "\n", "    @Override\n", "    public Iterable<N> breadthFirst(final Iterable<? extends N> startNodes) {\n", "      checkNotNull(startNodes);\n", "      if (Iterables.isEmpty(startNodes)) {\n", "        return ImmutableSet.of();\n", "      }\n", "      for (N startNode : startNodes) {\n", "        checkThatNodeIsInTree(startNode);\n", "      }\n", "          return new BreadthFirstIterator(startNodes);\n"], "19": ["      return depthFirstPreOrder(ImmutableSet.of(startNode));\n", "    }\n", "\n", "    @Override\n", "    public Iterable<N> depthFirstPreOrder(final Iterable<? extends N> startNodes) {\n", "      checkNotNull(startNodes);\n", "      if (Iterables.isEmpty(startNodes)) {\n", "        return ImmutableSet.of();\n", "      }\n", "      for (N node : startNodes) {\n", "        checkThatNodeIsInTree(node);\n", "      }\n", "          return new DepthFirstPreOrderIterator(startNodes);\n"], "20": ["      return depthFirstPostOrder(ImmutableSet.of(startNode));\n", "    }\n", "\n", "    @Override\n", "    public Iterable<N> depthFirstPostOrder(final Iterable<? extends N> startNodes) {\n", "      checkNotNull(startNodes);\n", "      if (Iterables.isEmpty(startNodes)) {\n", "        return ImmutableSet.of();\n", "      }\n", "      for (N startNode : startNodes) {\n", "        checkThatNodeIsInTree(startNode);\n", "      }\n", "          return new DepthFirstPostOrderIterator(startNodes);\n"], "21": ["      BreadthFirstIterator(Iterable<? extends N> roots) {\n", "        for (N root : roots) {\n", "          queue.add(root);\n", "        }\n"], "22": ["      DepthFirstPreOrderIterator(Iterable<? extends N> roots) {\n", "        stack.addLast(roots.iterator());\n"], "23": ["      DepthFirstPostOrderIterator(Iterable<? extends N> roots) {\n", "        stack.addLast(new NodeAndChildren(null, roots));\n"], "24": ["            if (top.node != null) {\n", "              return top.node;\n", "            }\n"], "25": ["        @NullableDecl final N node;\n", "        NodeAndChildren(@NullableDecl N node, Iterable<? extends N> children) {\n"]}, "removed": {"1": ["import static com.google.common.collect.Iterators.singletonIterator;\n"], "2": [" * Provides methods for traversing a graph.\n"], "3": ["   * <p>If {@code graph} is known to be tree-shaped, consider using {@link\n", "   * #forTree(SuccessorsFunction)} instead.\n", "   *       {@code hashCode()} implementations.\n"], "4": ["   * node to any node reachable from the start node, such as a tree.\n", "   * <p>Providing graphs that don't conform to the above description may lead to:\n", "   *   <li>Nodes being visited multiple times (if multiple paths exist from the start node to any\n", "   *       node reachable from it)\n", "   * In these cases, use {@link #forGraph(SuccessorsFunction)} instead.\n", "   *\n"], "5": ["   * <p><b>Examples</b>\n", "   * <p>This is a valid input graph (all edges are directed facing downwards):\n"], "6": ["   * <p>This is <b>not</b> a valid input graph (all edges are directed facing downwards):\n"], "7": ["   * <p>because there are two paths from {@code b} to {@code f} ({@code b->d->f} and {@code\n", "   * b->e->f}).\n", "   *\n"], "11": ["      checkThatNodeIsInGraph(startNode);\n", "          return new BreadthFirstIterator(startNode);\n"], "12": ["      checkThatNodeIsInGraph(startNode);\n", "          return new DepthFirstIterator(startNode, Order.PREORDER);\n"], "13": ["      checkThatNodeIsInGraph(startNode);\n", "          return new DepthFirstIterator(startNode, Order.POSTORDER);\n"], "14": ["      BreadthFirstIterator(N root) {\n", "        queue.add(root);\n", "        visited.add(root);\n"], "15": ["      DepthFirstIterator(N root, Order order) {\n", "        // our invariant is that in computeNext we call next on the iterator at the top first, so we\n", "        // need to start with one additional item on that iterator\n", "        stack.push(withSuccessors(root));\n"], "16": ["          NodeAndSuccessors node = stack.getFirst();\n", "          boolean firstVisit = visited.add(node.node);\n", "          boolean lastVisit = !node.successorIterator.hasNext();\n", "            N successor = node.successorIterator.next();\n", "          if (produceNode) {\n", "            return node.node;\n"], "17": ["        final N node;\n", "        NodeAndSuccessors(N node, Iterable<? extends N> successors) {\n"], "18": ["      checkThatNodeIsInTree(startNode);\n", "          return new BreadthFirstIterator(startNode);\n"], "19": ["      checkThatNodeIsInTree(startNode);\n", "          return new DepthFirstPreOrderIterator(startNode);\n"], "20": ["      checkThatNodeIsInTree(startNode);\n", "          return new DepthFirstPostOrderIterator(startNode);\n"], "21": ["      BreadthFirstIterator(N root) {\n", "        queue.add(root);\n"], "22": ["      DepthFirstPreOrderIterator(N root) {\n", "        stack.addLast(singletonIterator(checkNotNull(root)));\n"], "23": ["      DepthFirstPostOrderIterator(N root) {\n", "        stack.addLast(withChildren(root));\n"], "24": ["            return top.node;\n"], "25": ["        final N node;\n", "        NodeAndChildren(N node, Iterable<? extends N> children) {\n"]}, "added_lines": {"1": [24], "2": [33, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 58, 59], "3": [71, 72, 73, 74, 75, 82, 83, 84], "4": [99, 100, 101, 102, 103, 104, 105, 106, 107, 109, 110, 114, 115], "5": [127, 129, 130, 131], "6": [143, 144, 145, 146], "8": [214, 215, 216, 217, 218, 219, 220, 221, 222, 223, 224], "9": [258, 259, 260, 261, 262, 263, 264, 265, 266, 267, 268], "10": [302, 303, 304, 305, 306, 307, 308, 309, 310, 311, 312], "11": [326, 327, 328, 329, 330, 331, 332, 333, 334, 335, 336, 337, 341], "12": [349, 350, 351, 352, 353, 354, 355, 356, 357, 358, 359, 360, 364], "13": [372, 373, 374, 375, 376, 377, 378, 379, 380, 381, 382, 383, 387], "14": [403, 404, 405, 406, 407, 408, 409], "15": [434, 435], "16": [445, 446, 447, 454, 459, 460], "17": [471, 474], "18": [492, 493, 494, 495, 496, 497, 498, 499, 500, 501, 502, 503, 507], "19": [515, 516, 517, 518, 519, 520, 521, 522, 523, 524, 525, 526, 530], "20": [538, 539, 540, 541, 542, 543, 544, 545, 546, 547, 548, 549, 553], "21": [568, 569, 570, 571], "22": [590, 591], "23": [617, 618], "24": [630, 631, 632], "25": [644, 647]}, "removed_lines": {"1": [21], "2": [35], "3": [47, 48, 55], "4": [70, 72, 76, 77, 80, 81], "5": [91, 93], "6": [105], "7": [117, 118, 119], "11": [255, 259], "12": [267, 271], "13": [279, 283], "14": [299, 300, 301], "15": [326, 327, 328, 329], "16": [339, 340, 341, 348, 353, 354], "17": [365, 368], "18": [386, 390], "19": [398, 402], "20": [410, 414], "21": [429, 430], "22": [449, 450], "23": [476, 477], "24": [489], "25": [501, 504]}}]}
