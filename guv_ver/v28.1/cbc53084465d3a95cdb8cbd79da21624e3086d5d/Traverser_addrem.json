{
    "addition": {
        "24": "import com.google.common.collect.ImmutableSet;\n",
        "33": "import org.checkerframework.checker.nullness.compatqual.NullableDecl;\n",
        "36": " * An object that can traverse the nodes that are reachable from a specified (set of) start node(s)\n",
        "37": " * using a specified {@link SuccessorsFunction}.\n",
        "38": " *\n",
        "39": " * <p>There are two entry points for creating a {@code Traverser}: {@link\n",
        "40": " * #forTree(SuccessorsFunction)} and {@link #forGraph(SuccessorsFunction)}. You should choose one\n",
        "41": " * based on your answers to the following questions:\n",
        "42": " *\n",
        "43": " * <ol>\n",
        "44": " *   <li>Is there only one path to any node that's reachable from any start node? (If so, the\n",
        "45": " *       graph to be traversed is a tree or forest even if it is a subgraph of a graph which is\n",
        "46": " *       neither.)\n",
        "47": " *   <li>Are the node objects' implementations of {@code equals()}/{@code hashCode()} <a\n",
        "48": " *       href=\"https://github.com/google/guava/wiki/GraphsExplained#non-recursiveness\">recursive</a>?\n",
        "49": " * </ol>\n",
        "50": " *\n",
        "51": " * <p>If your answers are:\n",
        "52": " *\n",
        "53": " * <ul>\n",
        "54": " *   <li>(1) \"no\" and (2) \"no\", use {@link #forGraph(SuccessorsFunction)}.\n",
        "55": " *   <li>(1) \"yes\" and (2) \"yes\", use {@link #forTree(SuccessorsFunction)}.\n",
        "56": " *   <li>(1) \"yes\" and (2) \"no\", you can use either, but {@code forTree()} will be more efficient.\n",
        "57": " *   <li>(1) \"no\" and (2) \"yes\", <b><i>neither will work</i></b>, but if you transform your node\n",
        "58": " *       objects into a non-recursive form, you can use {@code forGraph()}.\n",
        "59": " * </ul>\n",
        "71": "   * <p>Traversers created using this method are guaranteed to visit each node reachable from the\n",
        "72": "   * start node(s) at most once.\n",
        "73": "   *\n",
        "74": "   * <p>If you know that no node in {@code graph} is reachable by more than one path from the start\n",
        "75": "   * node(s), consider using {@link #forTree(SuccessorsFunction)} instead.\n",
        "82": "   *       {@code hashCode()} implementations. (See the <a\n",
        "83": "   *       href=\"https://github.com/google/guava/wiki/GraphsExplained#elements-must-be-useable-as-map-keys\">\n",
        "84": "   *       notes on element objects</a> for more information.)\n",
        "99": "   * node(s) to any node reachable from the start node(s), and has no paths from any start node to\n",
        "100": "   * any other start node, such as a tree or forest.\n",
        "101": "   *\n",
        "102": "   * <p>{@code forTree()} is especially useful (versus {@code forGraph()}) in cases where the data\n",
        "103": "   * structure being traversed is, in addition to being a tree/forest, also defined <a\n",
        "104": "   * href=\"https://github.com/google/guava/wiki/GraphsExplained#non-recursiveness\">recursively</a>.\n",
        "105": "   * This is because the {@code forTree()}-based implementations don't keep track of visited nodes,\n",
        "106": "   * and therefore don't need to call `equals()` or `hashCode()` on the node objects; this saves\n",
        "107": "   * both time and space versus traversing the same graph using {@code forGraph()}.\n",
        "109": "   * <p>Providing a graph to be traversed for which there is more than one path from the start\n",
        "110": "   * node(s) to any node may lead to:\n",
        "114": "   *   <li>Nodes being visited multiple times (if multiple paths exist from any start node to any\n",
        "115": "   *       node reachable from any start node)\n",
        "127": "   * <p><b>Examples</b> (all edges are directed facing downwards)\n",
        "129": "   * <p>The graph below would be valid input with start nodes of {@code a, f, c}. However, if {@code\n",
        "130": "   * b} were <i>also</i> a start node, then there would be multiple paths to reach {@code e} and\n",
        "131": "   * {@code h}.\n",
        "143": "   * <p>.\n",
        "144": "   *\n",
        "145": "   * <p>The graph below would be a valid input with start nodes of {@code a, f}. However, if {@code\n",
        "146": "   * b} were a start node, there would be multiple paths to {@code f}.\n",
        "214": "  /**\n",
        "215": "   * Returns an unmodifiable {@code Iterable} over the nodes reachable from any of the {@code\n",
        "216": "   * startNodes}, in the order of a breadth-first traversal. This is equivalent to a breadth-first\n",
        "217": "   * traversal of a graph with an additional root node whose successors are the listed {@code\n",
        "218": "   * startNodes}.\n",
        "219": "   *\n",
        "220": "   * @throws IllegalArgumentException if any of {@code startNodes} is not an element of the graph\n",
        "221": "   * @see #breadthFirst(Object)\n",
        "222": "   */\n",
        "223": "  public abstract Iterable<N> breadthFirst(Iterable<? extends N> startNodes);\n",
        "224": "\n",
        "258": "  /**\n",
        "259": "   * Returns an unmodifiable {@code Iterable} over the nodes reachable from any of the {@code\n",
        "260": "   * startNodes}, in the order of a depth-first pre-order traversal. This is equivalent to a\n",
        "261": "   * depth-first pre-order traversal of a graph with an additional root node whose successors are\n",
        "262": "   * the listed {@code startNodes}.\n",
        "263": "   *\n",
        "264": "   * @throws IllegalArgumentException if any of {@code startNodes} is not an element of the graph\n",
        "265": "   * @see #depthFirstPreOrder(Object)\n",
        "266": "   */\n",
        "267": "  public abstract Iterable<N> depthFirstPreOrder(Iterable<? extends N> startNodes);\n",
        "268": "\n",
        "302": "  /**\n",
        "303": "   * Returns an unmodifiable {@code Iterable} over the nodes reachable from any of the {@code\n",
        "304": "   * startNodes}, in the order of a depth-first post-order traversal. This is equivalent to a\n",
        "305": "   * depth-first post-order traversal of a graph with an additional root node whose successors are\n",
        "306": "   * the listed {@code startNodes}.\n",
        "307": "   *\n",
        "308": "   * @throws IllegalArgumentException if any of {@code startNodes} is not an element of the graph\n",
        "309": "   * @see #depthFirstPostOrder(Object)\n",
        "310": "   */\n",
        "311": "  public abstract Iterable<N> depthFirstPostOrder(Iterable<? extends N> startNodes);\n",
        "312": "\n",
        "326": "      return breadthFirst(ImmutableSet.of(startNode));\n",
        "327": "    }\n",
        "328": "\n",
        "329": "    @Override\n",
        "330": "    public Iterable<N> breadthFirst(final Iterable<? extends N> startNodes) {\n",
        "331": "      checkNotNull(startNodes);\n",
        "332": "      if (Iterables.isEmpty(startNodes)) {\n",
        "333": "        return ImmutableSet.of();\n",
        "334": "      }\n",
        "335": "      for (N startNode : startNodes) {\n",
        "336": "        checkThatNodeIsInGraph(startNode);\n",
        "337": "      }\n",
        "341": "          return new BreadthFirstIterator(startNodes);\n",
        "349": "      return depthFirstPreOrder(ImmutableSet.of(startNode));\n",
        "350": "    }\n",
        "351": "\n",
        "352": "    @Override\n",
        "353": "    public Iterable<N> depthFirstPreOrder(final Iterable<? extends N> startNodes) {\n",
        "354": "      checkNotNull(startNodes);\n",
        "355": "      if (Iterables.isEmpty(startNodes)) {\n",
        "356": "        return ImmutableSet.of();\n",
        "357": "      }\n",
        "358": "      for (N startNode : startNodes) {\n",
        "359": "        checkThatNodeIsInGraph(startNode);\n",
        "360": "      }\n",
        "364": "          return new DepthFirstIterator(startNodes, Order.PREORDER);\n",
        "372": "      return depthFirstPostOrder(ImmutableSet.of(startNode));\n",
        "373": "    }\n",
        "374": "\n",
        "375": "    @Override\n",
        "376": "    public Iterable<N> depthFirstPostOrder(final Iterable<? extends N> startNodes) {\n",
        "377": "      checkNotNull(startNodes);\n",
        "378": "      if (Iterables.isEmpty(startNodes)) {\n",
        "379": "        return ImmutableSet.of();\n",
        "380": "      }\n",
        "381": "      for (N startNode : startNodes) {\n",
        "382": "        checkThatNodeIsInGraph(startNode);\n",
        "383": "      }\n",
        "387": "          return new DepthFirstIterator(startNodes, Order.POSTORDER);\n",
        "403": "      BreadthFirstIterator(Iterable<? extends N> roots) {\n",
        "404": "        for (N root : roots) {\n",
        "405": "          // add all roots to the queue, skipping duplicates\n",
        "406": "          if (visited.add(root)) {\n",
        "407": "            queue.add(root);\n",
        "408": "          }\n",
        "409": "        }\n",
        "434": "      DepthFirstIterator(Iterable<? extends N> roots, Order order) {\n",
        "435": "        stack.push(new NodeAndSuccessors(null, roots));\n",
        "445": "          NodeAndSuccessors nodeAndSuccessors = stack.getFirst();\n",
        "446": "          boolean firstVisit = visited.add(nodeAndSuccessors.node);\n",
        "447": "          boolean lastVisit = !nodeAndSuccessors.successorIterator.hasNext();\n",
        "454": "            N successor = nodeAndSuccessors.successorIterator.next();\n",
        "459": "          if (produceNode && nodeAndSuccessors.node != null) {\n",
        "460": "            return nodeAndSuccessors.node;\n",
        "471": "        @NullableDecl final N node;\n",
        "474": "        NodeAndSuccessors(@NullableDecl N node, Iterable<? extends N> successors) {\n",
        "492": "      return breadthFirst(ImmutableSet.of(startNode));\n",
        "493": "    }\n",
        "494": "\n",
        "495": "    @Override\n",
        "496": "    public Iterable<N> breadthFirst(final Iterable<? extends N> startNodes) {\n",
        "497": "      checkNotNull(startNodes);\n",
        "498": "      if (Iterables.isEmpty(startNodes)) {\n",
        "499": "        return ImmutableSet.of();\n",
        "500": "      }\n",
        "501": "      for (N startNode : startNodes) {\n",
        "502": "        checkThatNodeIsInTree(startNode);\n",
        "503": "      }\n",
        "507": "          return new BreadthFirstIterator(startNodes);\n",
        "515": "      return depthFirstPreOrder(ImmutableSet.of(startNode));\n",
        "516": "    }\n",
        "517": "\n",
        "518": "    @Override\n",
        "519": "    public Iterable<N> depthFirstPreOrder(final Iterable<? extends N> startNodes) {\n",
        "520": "      checkNotNull(startNodes);\n",
        "521": "      if (Iterables.isEmpty(startNodes)) {\n",
        "522": "        return ImmutableSet.of();\n",
        "523": "      }\n",
        "524": "      for (N node : startNodes) {\n",
        "525": "        checkThatNodeIsInTree(node);\n",
        "526": "      }\n",
        "530": "          return new DepthFirstPreOrderIterator(startNodes);\n",
        "538": "      return depthFirstPostOrder(ImmutableSet.of(startNode));\n",
        "539": "    }\n",
        "540": "\n",
        "541": "    @Override\n",
        "542": "    public Iterable<N> depthFirstPostOrder(final Iterable<? extends N> startNodes) {\n",
        "543": "      checkNotNull(startNodes);\n",
        "544": "      if (Iterables.isEmpty(startNodes)) {\n",
        "545": "        return ImmutableSet.of();\n",
        "546": "      }\n",
        "547": "      for (N startNode : startNodes) {\n",
        "548": "        checkThatNodeIsInTree(startNode);\n",
        "549": "      }\n",
        "553": "          return new DepthFirstPostOrderIterator(startNodes);\n",
        "568": "      BreadthFirstIterator(Iterable<? extends N> roots) {\n",
        "569": "        for (N root : roots) {\n",
        "570": "          queue.add(root);\n",
        "571": "        }\n",
        "590": "      DepthFirstPreOrderIterator(Iterable<? extends N> roots) {\n",
        "591": "        stack.addLast(roots.iterator());\n",
        "617": "      DepthFirstPostOrderIterator(Iterable<? extends N> roots) {\n",
        "618": "        stack.addLast(new NodeAndChildren(null, roots));\n",
        "630": "            if (top.node != null) {\n",
        "631": "              return top.node;\n",
        "632": "            }\n",
        "644": "        @NullableDecl final N node;\n",
        "647": "        NodeAndChildren(@NullableDecl N node, Iterable<? extends N> children) {\n"
    },
    "removed": {
        "21": "import static com.google.common.collect.Iterators.singletonIterator;\n",
        "35": " * Provides methods for traversing a graph.\n",
        "47": "   * <p>If {@code graph} is known to be tree-shaped, consider using {@link\n",
        "48": "   * #forTree(SuccessorsFunction)} instead.\n",
        "55": "   *       {@code hashCode()} implementations.\n",
        "70": "   * node to any node reachable from the start node, such as a tree.\n",
        "72": "   * <p>Providing graphs that don't conform to the above description may lead to:\n",
        "76": "   *   <li>Nodes being visited multiple times (if multiple paths exist from the start node to any\n",
        "77": "   *       node reachable from it)\n",
        "80": "   * In these cases, use {@link #forGraph(SuccessorsFunction)} instead.\n",
        "81": "   *\n",
        "91": "   * <p><b>Examples</b>\n",
        "93": "   * <p>This is a valid input graph (all edges are directed facing downwards):\n",
        "105": "   * <p>This is <b>not</b> a valid input graph (all edges are directed facing downwards):\n",
        "117": "   * <p>because there are two paths from {@code b} to {@code f} ({@code b->d->f} and {@code\n",
        "118": "   * b->e->f}).\n",
        "119": "   *\n",
        "255": "      checkThatNodeIsInGraph(startNode);\n",
        "259": "          return new BreadthFirstIterator(startNode);\n",
        "267": "      checkThatNodeIsInGraph(startNode);\n",
        "271": "          return new DepthFirstIterator(startNode, Order.PREORDER);\n",
        "279": "      checkThatNodeIsInGraph(startNode);\n",
        "283": "          return new DepthFirstIterator(startNode, Order.POSTORDER);\n",
        "299": "      BreadthFirstIterator(N root) {\n",
        "300": "        queue.add(root);\n",
        "301": "        visited.add(root);\n",
        "326": "      DepthFirstIterator(N root, Order order) {\n",
        "327": "        // our invariant is that in computeNext we call next on the iterator at the top first, so we\n",
        "328": "        // need to start with one additional item on that iterator\n",
        "329": "        stack.push(withSuccessors(root));\n",
        "339": "          NodeAndSuccessors node = stack.getFirst();\n",
        "340": "          boolean firstVisit = visited.add(node.node);\n",
        "341": "          boolean lastVisit = !node.successorIterator.hasNext();\n",
        "348": "            N successor = node.successorIterator.next();\n",
        "353": "          if (produceNode) {\n",
        "354": "            return node.node;\n",
        "365": "        final N node;\n",
        "368": "        NodeAndSuccessors(N node, Iterable<? extends N> successors) {\n",
        "386": "      checkThatNodeIsInTree(startNode);\n",
        "390": "          return new BreadthFirstIterator(startNode);\n",
        "398": "      checkThatNodeIsInTree(startNode);\n",
        "402": "          return new DepthFirstPreOrderIterator(startNode);\n",
        "410": "      checkThatNodeIsInTree(startNode);\n",
        "414": "          return new DepthFirstPostOrderIterator(startNode);\n",
        "429": "      BreadthFirstIterator(N root) {\n",
        "430": "        queue.add(root);\n",
        "449": "      DepthFirstPreOrderIterator(N root) {\n",
        "450": "        stack.addLast(singletonIterator(checkNotNull(root)));\n",
        "476": "      DepthFirstPostOrderIterator(N root) {\n",
        "477": "        stack.addLast(withChildren(root));\n",
        "489": "            return top.node;\n",
        "501": "        final N node;\n",
        "504": "        NodeAndChildren(N node, Iterable<? extends N> children) {\n"
    }
}