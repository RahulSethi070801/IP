[{"func":{"oldfunccode":"","newfunccode":"cbc53084465d3a95cdb8cbd79da21624e3086d5d/Codes/Match_newfunccode_cbc53084465d3a95cdb8cbd79da21624e3086d5d_1.txt","newdoc":"","newJdoc":"","olddoc":"","oldJdoc":"","path":"/home/pritish/Documents/IP work/guv_ver/v28.1/cbc53084465d3a95cdb8cbd79da21624e3086d5d/Traverser","pathinproj":"android/guava/src/com/google/common/graph/Traverser.java","addlines":[329,330,331,332,333,334,335,495,336,496,337,497,498,499,500,341,501,502,503,507],"dellines":[],"addcode":["    @Override\n","    public Iterable<N> breadthFirst(final Iterable<? extends N> startNodes) {\n","      checkNotNull(startNodes);\n","      if (Iterables.isEmpty(startNodes)) {\n","        return ImmutableSet.of();\n","      }\n","      for (N startNode : startNodes) {\n","        checkThatNodeIsInGraph(startNode);\n","      }\n","          return new BreadthFirstIterator(startNodes);\n","    @Override\n","    public Iterable<N> breadthFirst(final Iterable<? extends N> startNodes) {\n","      checkNotNull(startNodes);\n","      if (Iterables.isEmpty(startNodes)) {\n","        return ImmutableSet.of();\n","      }\n","      for (N startNode : startNodes) {\n","        checkThatNodeIsInTree(startNode);\n","      }\n","          return new BreadthFirstIterator(startNodes);\n","    @Override\n","    public Iterable<N> breadthFirst(final Iterable<? extends N> startNodes) {\n","      checkNotNull(startNodes);\n","      if (Iterables.isEmpty(startNodes)) {\n","        return ImmutableSet.of();\n","      }\n","      for (N startNode : startNodes) {\n","        checkThatNodeIsInGraph(startNode);\n","      }\n","          return new BreadthFirstIterator(startNodes);\n","    @Override\n","    public Iterable<N> breadthFirst(final Iterable<? extends N> startNodes) {\n","      checkNotNull(startNodes);\n","      if (Iterables.isEmpty(startNodes)) {\n","        return ImmutableSet.of();\n","      }\n","      for (N startNode : startNodes) {\n","        checkThatNodeIsInTree(startNode);\n","      }\n","          return new BreadthFirstIterator(startNodes);\n"],"delcode":[],"methodSig":"public Iterable<N> breadthFirst(final Iterable<? extends N> startNodes)"},"doc":{"oldfunccode":"cbc53084465d3a95cdb8cbd79da21624e3086d5d/Codes/Match_olddocfunccode_cbc53084465d3a95cdb8cbd79da21624e3086d5d_1.txt","newfunccode":"cbc53084465d3a95cdb8cbd79da21624e3086d5d/Codes/Match_newdocfunccode_cbc53084465d3a95cdb8cbd79da21624e3086d5d_1.txt","newdoc":"","newJdoc":"cbc53084465d3a95cdb8cbd79da21624e3086d5d/Codes/Match_newdocnewJdoc_cbc53084465d3a95cdb8cbd79da21624e3086d5d_1.txt","olddoc":"","oldJdoc":"cbc53084465d3a95cdb8cbd79da21624e3086d5d/Codes/Match_olddocJdoc_cbc53084465d3a95cdb8cbd79da21624e3086d5d_1.txt","path":"/home/pritish/Documents/IP work/guv_ver/v28.1/cbc53084465d3a95cdb8cbd79da21624e3086d5d/Traverser","pathinproj":"android/guava/src/com/google/common/graph/Traverser.java","addlines":[129,130,99,131,100,101,102,103,104,105,106,107,109,110,143,144,145,114,146,115,127],"dellines":[80,81,117,70,118,119,72,105,91,76,77,93],"addcode":["   * node(s) to any node reachable from the start node(s), and has no paths from any start node to\n","   * any other start node, such as a tree or forest.\n","   *\n","   * <p>{@code forTree()} is especially useful (versus {@code forGraph()}) in cases where the data\n","   * structure being traversed is, in addition to being a tree/forest, also defined <a\n","   * href=\"https://github.com/google/guava/wiki/GraphsExplained#non-recursiveness\">recursively</a>.\n","   * This is because the {@code forTree()}-based implementations don't keep track of visited nodes,\n","   * and therefore don't need to call `equals()` or `hashCode()` on the node objects; this saves\n","   * both time and space versus traversing the same graph using {@code forGraph()}.\n","   * <p>Providing a graph to be traversed for which there is more than one path from the start\n","   * node(s) to any node may lead to:\n","   *   <li>Nodes being visited multiple times (if multiple paths exist from any start node to any\n","   *       node reachable from any start node)\n","   * <p><b>Examples</b> (all edges are directed facing downwards)\n","   * <p>The graph below would be valid input with start nodes of {@code a, f, c}. However, if {@code\n","   * b} were <i>also</i> a start node, then there would be multiple paths to reach {@code e} and\n","   * {@code h}.\n","   * <p>.\n","   *\n","   * <p>The graph below would be a valid input with start nodes of {@code a, f}. However, if {@code\n","   * b} were a start node, there would be multiple paths to {@code f}.\n","   * node(s) to any node reachable from the start node(s), and has no paths from any start node to\n","   * any other start node, such as a tree or forest.\n","   *\n","   * <p>{@code forTree()} is especially useful (versus {@code forGraph()}) in cases where the data\n","   * structure being traversed is, in addition to being a tree/forest, also defined <a\n","   * href=\"https://github.com/google/guava/wiki/GraphsExplained#non-recursiveness\">recursively</a>.\n","   * This is because the {@code forTree()}-based implementations don't keep track of visited nodes,\n","   * and therefore don't need to call `equals()` or `hashCode()` on the node objects; this saves\n","   * both time and space versus traversing the same graph using {@code forGraph()}.\n","   * <p>Providing a graph to be traversed for which there is more than one path from the start\n","   * node(s) to any node may lead to:\n","   *   <li>Nodes being visited multiple times (if multiple paths exist from any start node to any\n","   *       node reachable from any start node)\n","   * <p><b>Examples</b> (all edges are directed facing downwards)\n","   * <p>The graph below would be valid input with start nodes of {@code a, f, c}. However, if {@code\n","   * b} were <i>also</i> a start node, then there would be multiple paths to reach {@code e} and\n","   * {@code h}.\n","   * <p>.\n","   *\n","   * <p>The graph below would be a valid input with start nodes of {@code a, f}. However, if {@code\n","   * b} were a start node, there would be multiple paths to {@code f}.\n"],"delcode":["   * node to any node reachable from the start node, such as a tree.\n","   * <p>Providing graphs that don't conform to the above description may lead to:\n","   *   <li>Nodes being visited multiple times (if multiple paths exist from the start node to any\n","   *       node reachable from it)\n","   * In these cases, use {@link #forGraph(SuccessorsFunction)} instead.\n","   *\n","   * <p><b>Examples</b>\n","   * <p>This is a valid input graph (all edges are directed facing downwards):\n","   * <p>This is <b>not</b> a valid input graph (all edges are directed facing downwards):\n","   * <p>because there are two paths from {@code b} to {@code f} ({@code b->d->f} and {@code\n","   * b->e->f}).\n","   *\n","   * node to any node reachable from the start node, such as a tree.\n","   * <p>Providing graphs that don't conform to the above description may lead to:\n","   *   <li>Nodes being visited multiple times (if multiple paths exist from the start node to any\n","   *       node reachable from it)\n","   * In these cases, use {@link #forGraph(SuccessorsFunction)} instead.\n","   *\n","   * <p><b>Examples</b>\n","   * <p>This is a valid input graph (all edges are directed facing downwards):\n","   * <p>This is <b>not</b> a valid input graph (all edges are directed facing downwards):\n","   * <p>because there are two paths from {@code b} to {@code f} ({@code b->d->f} and {@code\n","   * b->e->f}).\n","   *\n"],"methodSig":"public static Traverser<N> forTree(SuccessorsFunction<N> tree)"},"id":3,"flag":1,"commit":"cbc53084465d3a95cdb8cbd79da21624e3086d5d"},{"func":{"oldfunccode":"cbc53084465d3a95cdb8cbd79da21624e3086d5d/Codes/Match_oldfunccode_cbc53084465d3a95cdb8cbd79da21624e3086d5d_2.txt","newfunccode":"cbc53084465d3a95cdb8cbd79da21624e3086d5d/Codes/Match_newfunccode_cbc53084465d3a95cdb8cbd79da21624e3086d5d_2.txt","newdoc":"","newJdoc":"","olddoc":"","oldJdoc":"","path":"/home/pritish/Documents/IP work/guv_ver/v28.1/cbc53084465d3a95cdb8cbd79da21624e3086d5d/Traverser","pathinproj":"android/guava/src/com/google/common/graph/Traverser.java","addlines":[492,493],"dellines":[386,259,390,255],"addcode":["      return breadthFirst(ImmutableSet.of(startNode));\n","    }\n","      return breadthFirst(ImmutableSet.of(startNode));\n","    }\n"],"delcode":["      checkThatNodeIsInGraph(startNode);\n","          return new BreadthFirstIterator(startNode);\n","      checkThatNodeIsInTree(startNode);\n","          return new BreadthFirstIterator(startNode);\n","      checkThatNodeIsInGraph(startNode);\n","          return new BreadthFirstIterator(startNode);\n","      checkThatNodeIsInTree(startNode);\n","          return new BreadthFirstIterator(startNode);\n"],"methodSig":"public Iterable<N> breadthFirst(final N startNode)"},"doc":{"oldfunccode":"cbc53084465d3a95cdb8cbd79da21624e3086d5d/Codes/Match_olddocfunccode_cbc53084465d3a95cdb8cbd79da21624e3086d5d_2.txt","newfunccode":"cbc53084465d3a95cdb8cbd79da21624e3086d5d/Codes/Match_newdocfunccode_cbc53084465d3a95cdb8cbd79da21624e3086d5d_2.txt","newdoc":"","newJdoc":"cbc53084465d3a95cdb8cbd79da21624e3086d5d/Codes/Match_newdocnewJdoc_cbc53084465d3a95cdb8cbd79da21624e3086d5d_2.txt","olddoc":"","oldJdoc":"cbc53084465d3a95cdb8cbd79da21624e3086d5d/Codes/Match_olddocJdoc_cbc53084465d3a95cdb8cbd79da21624e3086d5d_2.txt","path":"/home/pritish/Documents/IP work/guv_ver/v28.1/cbc53084465d3a95cdb8cbd79da21624e3086d5d/Traverser","pathinproj":"android/guava/src/com/google/common/graph/Traverser.java","addlines":[129,130,99,131,100,101,102,103,104,105,106,107,109,110,143,144,145,114,146,115,127],"dellines":[80,81,117,70,118,119,72,105,91,76,77,93],"addcode":["   * node(s) to any node reachable from the start node(s), and has no paths from any start node to\n","   * any other start node, such as a tree or forest.\n","   *\n","   * <p>{@code forTree()} is especially useful (versus {@code forGraph()}) in cases where the data\n","   * structure being traversed is, in addition to being a tree/forest, also defined <a\n","   * href=\"https://github.com/google/guava/wiki/GraphsExplained#non-recursiveness\">recursively</a>.\n","   * This is because the {@code forTree()}-based implementations don't keep track of visited nodes,\n","   * and therefore don't need to call `equals()` or `hashCode()` on the node objects; this saves\n","   * both time and space versus traversing the same graph using {@code forGraph()}.\n","   * <p>Providing a graph to be traversed for which there is more than one path from the start\n","   * node(s) to any node may lead to:\n","   *   <li>Nodes being visited multiple times (if multiple paths exist from any start node to any\n","   *       node reachable from any start node)\n","   * <p><b>Examples</b> (all edges are directed facing downwards)\n","   * <p>The graph below would be valid input with start nodes of {@code a, f, c}. However, if {@code\n","   * b} were <i>also</i> a start node, then there would be multiple paths to reach {@code e} and\n","   * {@code h}.\n","   * <p>.\n","   *\n","   * <p>The graph below would be a valid input with start nodes of {@code a, f}. However, if {@code\n","   * b} were a start node, there would be multiple paths to {@code f}.\n","   * node(s) to any node reachable from the start node(s), and has no paths from any start node to\n","   * any other start node, such as a tree or forest.\n","   *\n","   * <p>{@code forTree()} is especially useful (versus {@code forGraph()}) in cases where the data\n","   * structure being traversed is, in addition to being a tree/forest, also defined <a\n","   * href=\"https://github.com/google/guava/wiki/GraphsExplained#non-recursiveness\">recursively</a>.\n","   * This is because the {@code forTree()}-based implementations don't keep track of visited nodes,\n","   * and therefore don't need to call `equals()` or `hashCode()` on the node objects; this saves\n","   * both time and space versus traversing the same graph using {@code forGraph()}.\n","   * <p>Providing a graph to be traversed for which there is more than one path from the start\n","   * node(s) to any node may lead to:\n","   *   <li>Nodes being visited multiple times (if multiple paths exist from any start node to any\n","   *       node reachable from any start node)\n","   * <p><b>Examples</b> (all edges are directed facing downwards)\n","   * <p>The graph below would be valid input with start nodes of {@code a, f, c}. However, if {@code\n","   * b} were <i>also</i> a start node, then there would be multiple paths to reach {@code e} and\n","   * {@code h}.\n","   * <p>.\n","   *\n","   * <p>The graph below would be a valid input with start nodes of {@code a, f}. However, if {@code\n","   * b} were a start node, there would be multiple paths to {@code f}.\n"],"delcode":["   * node to any node reachable from the start node, such as a tree.\n","   * <p>Providing graphs that don't conform to the above description may lead to:\n","   *   <li>Nodes being visited multiple times (if multiple paths exist from the start node to any\n","   *       node reachable from it)\n","   * In these cases, use {@link #forGraph(SuccessorsFunction)} instead.\n","   *\n","   * <p><b>Examples</b>\n","   * <p>This is a valid input graph (all edges are directed facing downwards):\n","   * <p>This is <b>not</b> a valid input graph (all edges are directed facing downwards):\n","   * <p>because there are two paths from {@code b} to {@code f} ({@code b->d->f} and {@code\n","   * b->e->f}).\n","   *\n","   * node to any node reachable from the start node, such as a tree.\n","   * <p>Providing graphs that don't conform to the above description may lead to:\n","   *   <li>Nodes being visited multiple times (if multiple paths exist from the start node to any\n","   *       node reachable from it)\n","   * In these cases, use {@link #forGraph(SuccessorsFunction)} instead.\n","   *\n","   * <p><b>Examples</b>\n","   * <p>This is a valid input graph (all edges are directed facing downwards):\n","   * <p>This is <b>not</b> a valid input graph (all edges are directed facing downwards):\n","   * <p>because there are two paths from {@code b} to {@code f} ({@code b->d->f} and {@code\n","   * b->e->f}).\n","   *\n"],"methodSig":"public static Traverser<N> forTree(SuccessorsFunction<N> tree)"},"id":3,"flag":1,"commit":"cbc53084465d3a95cdb8cbd79da21624e3086d5d"},{"func":{"oldfunccode":"","newfunccode":"cbc53084465d3a95cdb8cbd79da21624e3086d5d/Codes/Match_newfunccode_cbc53084465d3a95cdb8cbd79da21624e3086d5d_3.txt","newdoc":"","newJdoc":"cbc53084465d3a95cdb8cbd79da21624e3086d5d/Codes/Match_newfuncnewJdoc_cbc53084465d3a95cdb8cbd79da21624e3086d5d_3.txt","olddoc":"","oldJdoc":"","path":"/home/pritish/Documents/IP work/guv_ver/v28.1/cbc53084465d3a95cdb8cbd79da21624e3086d5d/Traverser","pathinproj":"android/guava/src/com/google/common/graph/Traverser.java","addlines":[267],"dellines":[],"addcode":["  public abstract Iterable<N> depthFirstPreOrder(Iterable<? extends N> startNodes);\n","  public abstract Iterable<N> depthFirstPreOrder(Iterable<? extends N> startNodes);\n"],"delcode":[],"methodSig":"public abstract Iterable<N> depthFirstPreOrder(Iterable<? extends N> startNodes)"},"doc":{"oldfunccode":"cbc53084465d3a95cdb8cbd79da21624e3086d5d/Codes/Match_olddocfunccode_cbc53084465d3a95cdb8cbd79da21624e3086d5d_3.txt","newfunccode":"cbc53084465d3a95cdb8cbd79da21624e3086d5d/Codes/Match_newdocfunccode_cbc53084465d3a95cdb8cbd79da21624e3086d5d_3.txt","newdoc":"","newJdoc":"cbc53084465d3a95cdb8cbd79da21624e3086d5d/Codes/Match_newdocnewJdoc_cbc53084465d3a95cdb8cbd79da21624e3086d5d_3.txt","olddoc":"","oldJdoc":"cbc53084465d3a95cdb8cbd79da21624e3086d5d/Codes/Match_olddocJdoc_cbc53084465d3a95cdb8cbd79da21624e3086d5d_3.txt","path":"/home/pritish/Documents/IP work/guv_ver/v28.1/cbc53084465d3a95cdb8cbd79da21624e3086d5d/Traverser","pathinproj":"android/guava/src/com/google/common/graph/Traverser.java","addlines":[129,130,99,131,100,101,102,103,104,105,106,107,109,110,143,144,145,114,146,115,127],"dellines":[80,81,117,70,118,119,72,105,91,76,77,93],"addcode":["   * node(s) to any node reachable from the start node(s), and has no paths from any start node to\n","   * any other start node, such as a tree or forest.\n","   *\n","   * <p>{@code forTree()} is especially useful (versus {@code forGraph()}) in cases where the data\n","   * structure being traversed is, in addition to being a tree/forest, also defined <a\n","   * href=\"https://github.com/google/guava/wiki/GraphsExplained#non-recursiveness\">recursively</a>.\n","   * This is because the {@code forTree()}-based implementations don't keep track of visited nodes,\n","   * and therefore don't need to call `equals()` or `hashCode()` on the node objects; this saves\n","   * both time and space versus traversing the same graph using {@code forGraph()}.\n","   * <p>Providing a graph to be traversed for which there is more than one path from the start\n","   * node(s) to any node may lead to:\n","   *   <li>Nodes being visited multiple times (if multiple paths exist from any start node to any\n","   *       node reachable from any start node)\n","   * <p><b>Examples</b> (all edges are directed facing downwards)\n","   * <p>The graph below would be valid input with start nodes of {@code a, f, c}. However, if {@code\n","   * b} were <i>also</i> a start node, then there would be multiple paths to reach {@code e} and\n","   * {@code h}.\n","   * <p>.\n","   *\n","   * <p>The graph below would be a valid input with start nodes of {@code a, f}. However, if {@code\n","   * b} were a start node, there would be multiple paths to {@code f}.\n","   * node(s) to any node reachable from the start node(s), and has no paths from any start node to\n","   * any other start node, such as a tree or forest.\n","   *\n","   * <p>{@code forTree()} is especially useful (versus {@code forGraph()}) in cases where the data\n","   * structure being traversed is, in addition to being a tree/forest, also defined <a\n","   * href=\"https://github.com/google/guava/wiki/GraphsExplained#non-recursiveness\">recursively</a>.\n","   * This is because the {@code forTree()}-based implementations don't keep track of visited nodes,\n","   * and therefore don't need to call `equals()` or `hashCode()` on the node objects; this saves\n","   * both time and space versus traversing the same graph using {@code forGraph()}.\n","   * <p>Providing a graph to be traversed for which there is more than one path from the start\n","   * node(s) to any node may lead to:\n","   *   <li>Nodes being visited multiple times (if multiple paths exist from any start node to any\n","   *       node reachable from any start node)\n","   * <p><b>Examples</b> (all edges are directed facing downwards)\n","   * <p>The graph below would be valid input with start nodes of {@code a, f, c}. However, if {@code\n","   * b} were <i>also</i> a start node, then there would be multiple paths to reach {@code e} and\n","   * {@code h}.\n","   * <p>.\n","   *\n","   * <p>The graph below would be a valid input with start nodes of {@code a, f}. However, if {@code\n","   * b} were a start node, there would be multiple paths to {@code f}.\n"],"delcode":["   * node to any node reachable from the start node, such as a tree.\n","   * <p>Providing graphs that don't conform to the above description may lead to:\n","   *   <li>Nodes being visited multiple times (if multiple paths exist from the start node to any\n","   *       node reachable from it)\n","   * In these cases, use {@link #forGraph(SuccessorsFunction)} instead.\n","   *\n","   * <p><b>Examples</b>\n","   * <p>This is a valid input graph (all edges are directed facing downwards):\n","   * <p>This is <b>not</b> a valid input graph (all edges are directed facing downwards):\n","   * <p>because there are two paths from {@code b} to {@code f} ({@code b->d->f} and {@code\n","   * b->e->f}).\n","   *\n","   * node to any node reachable from the start node, such as a tree.\n","   * <p>Providing graphs that don't conform to the above description may lead to:\n","   *   <li>Nodes being visited multiple times (if multiple paths exist from the start node to any\n","   *       node reachable from it)\n","   * In these cases, use {@link #forGraph(SuccessorsFunction)} instead.\n","   *\n","   * <p><b>Examples</b>\n","   * <p>This is a valid input graph (all edges are directed facing downwards):\n","   * <p>This is <b>not</b> a valid input graph (all edges are directed facing downwards):\n","   * <p>because there are two paths from {@code b} to {@code f} ({@code b->d->f} and {@code\n","   * b->e->f}).\n","   *\n"],"methodSig":"public static Traverser<N> forTree(SuccessorsFunction<N> tree)"},"id":3,"flag":1,"commit":"cbc53084465d3a95cdb8cbd79da21624e3086d5d"},{"func":{"oldfunccode":"cbc53084465d3a95cdb8cbd79da21624e3086d5d/Codes/Match_oldfunccode_cbc53084465d3a95cdb8cbd79da21624e3086d5d_4.txt","newfunccode":"cbc53084465d3a95cdb8cbd79da21624e3086d5d/Codes/Match_newfunccode_cbc53084465d3a95cdb8cbd79da21624e3086d5d_4.txt","newdoc":"","newJdoc":"","olddoc":"","oldJdoc":"","path":"/home/pritish/Documents/IP work/guv_ver/v28.1/cbc53084465d3a95cdb8cbd79da21624e3086d5d/Traverser","pathinproj":"android/guava/src/com/google/common/graph/Traverser.java","addlines":[515,516],"dellines":[402,267,398,271],"addcode":["      return depthFirstPreOrder(ImmutableSet.of(startNode));\n","    }\n","      return depthFirstPreOrder(ImmutableSet.of(startNode));\n","    }\n"],"delcode":["      checkThatNodeIsInGraph(startNode);\n","          return new DepthFirstIterator(startNode, Order.PREORDER);\n","      checkThatNodeIsInTree(startNode);\n","          return new DepthFirstPreOrderIterator(startNode);\n","      checkThatNodeIsInGraph(startNode);\n","          return new DepthFirstIterator(startNode, Order.PREORDER);\n","      checkThatNodeIsInTree(startNode);\n","          return new DepthFirstPreOrderIterator(startNode);\n"],"methodSig":"public Iterable<N> depthFirstPreOrder(final N startNode)"},"doc":{"oldfunccode":"cbc53084465d3a95cdb8cbd79da21624e3086d5d/Codes/Match_olddocfunccode_cbc53084465d3a95cdb8cbd79da21624e3086d5d_4.txt","newfunccode":"cbc53084465d3a95cdb8cbd79da21624e3086d5d/Codes/Match_newdocfunccode_cbc53084465d3a95cdb8cbd79da21624e3086d5d_4.txt","newdoc":"","newJdoc":"cbc53084465d3a95cdb8cbd79da21624e3086d5d/Codes/Match_newdocnewJdoc_cbc53084465d3a95cdb8cbd79da21624e3086d5d_4.txt","olddoc":"","oldJdoc":"cbc53084465d3a95cdb8cbd79da21624e3086d5d/Codes/Match_olddocJdoc_cbc53084465d3a95cdb8cbd79da21624e3086d5d_4.txt","path":"/home/pritish/Documents/IP work/guv_ver/v28.1/cbc53084465d3a95cdb8cbd79da21624e3086d5d/Traverser","pathinproj":"android/guava/src/com/google/common/graph/Traverser.java","addlines":[129,130,99,131,100,101,102,103,104,105,106,107,109,110,143,144,145,114,146,115,127],"dellines":[80,81,117,70,118,119,72,105,91,76,77,93],"addcode":["   * node(s) to any node reachable from the start node(s), and has no paths from any start node to\n","   * any other start node, such as a tree or forest.\n","   *\n","   * <p>{@code forTree()} is especially useful (versus {@code forGraph()}) in cases where the data\n","   * structure being traversed is, in addition to being a tree/forest, also defined <a\n","   * href=\"https://github.com/google/guava/wiki/GraphsExplained#non-recursiveness\">recursively</a>.\n","   * This is because the {@code forTree()}-based implementations don't keep track of visited nodes,\n","   * and therefore don't need to call `equals()` or `hashCode()` on the node objects; this saves\n","   * both time and space versus traversing the same graph using {@code forGraph()}.\n","   * <p>Providing a graph to be traversed for which there is more than one path from the start\n","   * node(s) to any node may lead to:\n","   *   <li>Nodes being visited multiple times (if multiple paths exist from any start node to any\n","   *       node reachable from any start node)\n","   * <p><b>Examples</b> (all edges are directed facing downwards)\n","   * <p>The graph below would be valid input with start nodes of {@code a, f, c}. However, if {@code\n","   * b} were <i>also</i> a start node, then there would be multiple paths to reach {@code e} and\n","   * {@code h}.\n","   * <p>.\n","   *\n","   * <p>The graph below would be a valid input with start nodes of {@code a, f}. However, if {@code\n","   * b} were a start node, there would be multiple paths to {@code f}.\n","   * node(s) to any node reachable from the start node(s), and has no paths from any start node to\n","   * any other start node, such as a tree or forest.\n","   *\n","   * <p>{@code forTree()} is especially useful (versus {@code forGraph()}) in cases where the data\n","   * structure being traversed is, in addition to being a tree/forest, also defined <a\n","   * href=\"https://github.com/google/guava/wiki/GraphsExplained#non-recursiveness\">recursively</a>.\n","   * This is because the {@code forTree()}-based implementations don't keep track of visited nodes,\n","   * and therefore don't need to call `equals()` or `hashCode()` on the node objects; this saves\n","   * both time and space versus traversing the same graph using {@code forGraph()}.\n","   * <p>Providing a graph to be traversed for which there is more than one path from the start\n","   * node(s) to any node may lead to:\n","   *   <li>Nodes being visited multiple times (if multiple paths exist from any start node to any\n","   *       node reachable from any start node)\n","   * <p><b>Examples</b> (all edges are directed facing downwards)\n","   * <p>The graph below would be valid input with start nodes of {@code a, f, c}. However, if {@code\n","   * b} were <i>also</i> a start node, then there would be multiple paths to reach {@code e} and\n","   * {@code h}.\n","   * <p>.\n","   *\n","   * <p>The graph below would be a valid input with start nodes of {@code a, f}. However, if {@code\n","   * b} were a start node, there would be multiple paths to {@code f}.\n"],"delcode":["   * node to any node reachable from the start node, such as a tree.\n","   * <p>Providing graphs that don't conform to the above description may lead to:\n","   *   <li>Nodes being visited multiple times (if multiple paths exist from the start node to any\n","   *       node reachable from it)\n","   * In these cases, use {@link #forGraph(SuccessorsFunction)} instead.\n","   *\n","   * <p><b>Examples</b>\n","   * <p>This is a valid input graph (all edges are directed facing downwards):\n","   * <p>This is <b>not</b> a valid input graph (all edges are directed facing downwards):\n","   * <p>because there are two paths from {@code b} to {@code f} ({@code b->d->f} and {@code\n","   * b->e->f}).\n","   *\n","   * node to any node reachable from the start node, such as a tree.\n","   * <p>Providing graphs that don't conform to the above description may lead to:\n","   *   <li>Nodes being visited multiple times (if multiple paths exist from the start node to any\n","   *       node reachable from it)\n","   * In these cases, use {@link #forGraph(SuccessorsFunction)} instead.\n","   *\n","   * <p><b>Examples</b>\n","   * <p>This is a valid input graph (all edges are directed facing downwards):\n","   * <p>This is <b>not</b> a valid input graph (all edges are directed facing downwards):\n","   * <p>because there are two paths from {@code b} to {@code f} ({@code b->d->f} and {@code\n","   * b->e->f}).\n","   *\n"],"methodSig":"public static Traverser<N> forTree(SuccessorsFunction<N> tree)"},"id":3,"flag":1,"commit":"cbc53084465d3a95cdb8cbd79da21624e3086d5d"},{"func":{"oldfunccode":"","newfunccode":"cbc53084465d3a95cdb8cbd79da21624e3086d5d/Codes/Match_newfunccode_cbc53084465d3a95cdb8cbd79da21624e3086d5d_5.txt","newdoc":"","newJdoc":"","olddoc":"","oldJdoc":"","path":"/home/pritish/Documents/IP work/guv_ver/v28.1/cbc53084465d3a95cdb8cbd79da21624e3086d5d/Traverser","pathinproj":"android/guava/src/com/google/common/graph/Traverser.java","addlines":[544,545,546,387,547,548,549,553,375,376,377,378,379,380,381,541,382,542,383,543],"dellines":[],"addcode":["    @Override\n","    public Iterable<N> depthFirstPostOrder(final Iterable<? extends N> startNodes) {\n","      checkNotNull(startNodes);\n","      if (Iterables.isEmpty(startNodes)) {\n","        return ImmutableSet.of();\n","      }\n","      for (N startNode : startNodes) {\n","        checkThatNodeIsInGraph(startNode);\n","      }\n","          return new DepthFirstIterator(startNodes, Order.POSTORDER);\n","    @Override\n","    public Iterable<N> depthFirstPostOrder(final Iterable<? extends N> startNodes) {\n","      checkNotNull(startNodes);\n","      if (Iterables.isEmpty(startNodes)) {\n","        return ImmutableSet.of();\n","      }\n","      for (N startNode : startNodes) {\n","        checkThatNodeIsInTree(startNode);\n","      }\n","          return new DepthFirstPostOrderIterator(startNodes);\n","    @Override\n","    public Iterable<N> depthFirstPostOrder(final Iterable<? extends N> startNodes) {\n","      checkNotNull(startNodes);\n","      if (Iterables.isEmpty(startNodes)) {\n","        return ImmutableSet.of();\n","      }\n","      for (N startNode : startNodes) {\n","        checkThatNodeIsInGraph(startNode);\n","      }\n","          return new DepthFirstIterator(startNodes, Order.POSTORDER);\n","    @Override\n","    public Iterable<N> depthFirstPostOrder(final Iterable<? extends N> startNodes) {\n","      checkNotNull(startNodes);\n","      if (Iterables.isEmpty(startNodes)) {\n","        return ImmutableSet.of();\n","      }\n","      for (N startNode : startNodes) {\n","        checkThatNodeIsInTree(startNode);\n","      }\n","          return new DepthFirstPostOrderIterator(startNodes);\n"],"delcode":[],"methodSig":"public Iterable<N> depthFirstPostOrder(final Iterable<? extends N> startNodes)"},"doc":{"oldfunccode":"cbc53084465d3a95cdb8cbd79da21624e3086d5d/Codes/Match_olddocfunccode_cbc53084465d3a95cdb8cbd79da21624e3086d5d_5.txt","newfunccode":"cbc53084465d3a95cdb8cbd79da21624e3086d5d/Codes/Match_newdocfunccode_cbc53084465d3a95cdb8cbd79da21624e3086d5d_5.txt","newdoc":"","newJdoc":"cbc53084465d3a95cdb8cbd79da21624e3086d5d/Codes/Match_newdocnewJdoc_cbc53084465d3a95cdb8cbd79da21624e3086d5d_5.txt","olddoc":"","oldJdoc":"cbc53084465d3a95cdb8cbd79da21624e3086d5d/Codes/Match_olddocJdoc_cbc53084465d3a95cdb8cbd79da21624e3086d5d_5.txt","path":"/home/pritish/Documents/IP work/guv_ver/v28.1/cbc53084465d3a95cdb8cbd79da21624e3086d5d/Traverser","pathinproj":"android/guava/src/com/google/common/graph/Traverser.java","addlines":[129,130,99,131,100,101,102,103,104,105,106,107,109,110,143,144,145,114,146,115,127],"dellines":[80,81,117,70,118,119,72,105,91,76,77,93],"addcode":["   * node(s) to any node reachable from the start node(s), and has no paths from any start node to\n","   * any other start node, such as a tree or forest.\n","   *\n","   * <p>{@code forTree()} is especially useful (versus {@code forGraph()}) in cases where the data\n","   * structure being traversed is, in addition to being a tree/forest, also defined <a\n","   * href=\"https://github.com/google/guava/wiki/GraphsExplained#non-recursiveness\">recursively</a>.\n","   * This is because the {@code forTree()}-based implementations don't keep track of visited nodes,\n","   * and therefore don't need to call `equals()` or `hashCode()` on the node objects; this saves\n","   * both time and space versus traversing the same graph using {@code forGraph()}.\n","   * <p>Providing a graph to be traversed for which there is more than one path from the start\n","   * node(s) to any node may lead to:\n","   *   <li>Nodes being visited multiple times (if multiple paths exist from any start node to any\n","   *       node reachable from any start node)\n","   * <p><b>Examples</b> (all edges are directed facing downwards)\n","   * <p>The graph below would be valid input with start nodes of {@code a, f, c}. However, if {@code\n","   * b} were <i>also</i> a start node, then there would be multiple paths to reach {@code e} and\n","   * {@code h}.\n","   * <p>.\n","   *\n","   * <p>The graph below would be a valid input with start nodes of {@code a, f}. However, if {@code\n","   * b} were a start node, there would be multiple paths to {@code f}.\n","   * node(s) to any node reachable from the start node(s), and has no paths from any start node to\n","   * any other start node, such as a tree or forest.\n","   *\n","   * <p>{@code forTree()} is especially useful (versus {@code forGraph()}) in cases where the data\n","   * structure being traversed is, in addition to being a tree/forest, also defined <a\n","   * href=\"https://github.com/google/guava/wiki/GraphsExplained#non-recursiveness\">recursively</a>.\n","   * This is because the {@code forTree()}-based implementations don't keep track of visited nodes,\n","   * and therefore don't need to call `equals()` or `hashCode()` on the node objects; this saves\n","   * both time and space versus traversing the same graph using {@code forGraph()}.\n","   * <p>Providing a graph to be traversed for which there is more than one path from the start\n","   * node(s) to any node may lead to:\n","   *   <li>Nodes being visited multiple times (if multiple paths exist from any start node to any\n","   *       node reachable from any start node)\n","   * <p><b>Examples</b> (all edges are directed facing downwards)\n","   * <p>The graph below would be valid input with start nodes of {@code a, f, c}. However, if {@code\n","   * b} were <i>also</i> a start node, then there would be multiple paths to reach {@code e} and\n","   * {@code h}.\n","   * <p>.\n","   *\n","   * <p>The graph below would be a valid input with start nodes of {@code a, f}. However, if {@code\n","   * b} were a start node, there would be multiple paths to {@code f}.\n"],"delcode":["   * node to any node reachable from the start node, such as a tree.\n","   * <p>Providing graphs that don't conform to the above description may lead to:\n","   *   <li>Nodes being visited multiple times (if multiple paths exist from the start node to any\n","   *       node reachable from it)\n","   * In these cases, use {@link #forGraph(SuccessorsFunction)} instead.\n","   *\n","   * <p><b>Examples</b>\n","   * <p>This is a valid input graph (all edges are directed facing downwards):\n","   * <p>This is <b>not</b> a valid input graph (all edges are directed facing downwards):\n","   * <p>because there are two paths from {@code b} to {@code f} ({@code b->d->f} and {@code\n","   * b->e->f}).\n","   *\n","   * node to any node reachable from the start node, such as a tree.\n","   * <p>Providing graphs that don't conform to the above description may lead to:\n","   *   <li>Nodes being visited multiple times (if multiple paths exist from the start node to any\n","   *       node reachable from it)\n","   * In these cases, use {@link #forGraph(SuccessorsFunction)} instead.\n","   *\n","   * <p><b>Examples</b>\n","   * <p>This is a valid input graph (all edges are directed facing downwards):\n","   * <p>This is <b>not</b> a valid input graph (all edges are directed facing downwards):\n","   * <p>because there are two paths from {@code b} to {@code f} ({@code b->d->f} and {@code\n","   * b->e->f}).\n","   *\n"],"methodSig":"public static Traverser<N> forTree(SuccessorsFunction<N> tree)"},"id":3,"flag":1,"commit":"cbc53084465d3a95cdb8cbd79da21624e3086d5d"},{"func":{"oldfunccode":"cbc53084465d3a95cdb8cbd79da21624e3086d5d/Codes/Match_oldfunccode_cbc53084465d3a95cdb8cbd79da21624e3086d5d_6.txt","newfunccode":"cbc53084465d3a95cdb8cbd79da21624e3086d5d/Codes/Match_newfunccode_cbc53084465d3a95cdb8cbd79da21624e3086d5d_6.txt","newdoc":"","newJdoc":"","olddoc":"","oldJdoc":"","path":"/home/pritish/Documents/IP work/guv_ver/v28.1/cbc53084465d3a95cdb8cbd79da21624e3086d5d/Traverser","pathinproj":"android/guava/src/com/google/common/graph/Traverser.java","addlines":[538,539],"dellines":[279,410,283,414],"addcode":["      return depthFirstPostOrder(ImmutableSet.of(startNode));\n","    }\n","      return depthFirstPostOrder(ImmutableSet.of(startNode));\n","    }\n"],"delcode":["      checkThatNodeIsInGraph(startNode);\n","          return new DepthFirstIterator(startNode, Order.POSTORDER);\n","      checkThatNodeIsInTree(startNode);\n","          return new DepthFirstPostOrderIterator(startNode);\n","      checkThatNodeIsInGraph(startNode);\n","          return new DepthFirstIterator(startNode, Order.POSTORDER);\n","      checkThatNodeIsInTree(startNode);\n","          return new DepthFirstPostOrderIterator(startNode);\n"],"methodSig":"public Iterable<N> depthFirstPostOrder(final N startNode)"},"doc":{"oldfunccode":"cbc53084465d3a95cdb8cbd79da21624e3086d5d/Codes/Match_olddocfunccode_cbc53084465d3a95cdb8cbd79da21624e3086d5d_6.txt","newfunccode":"cbc53084465d3a95cdb8cbd79da21624e3086d5d/Codes/Match_newdocfunccode_cbc53084465d3a95cdb8cbd79da21624e3086d5d_6.txt","newdoc":"","newJdoc":"cbc53084465d3a95cdb8cbd79da21624e3086d5d/Codes/Match_newdocnewJdoc_cbc53084465d3a95cdb8cbd79da21624e3086d5d_6.txt","olddoc":"","oldJdoc":"cbc53084465d3a95cdb8cbd79da21624e3086d5d/Codes/Match_olddocJdoc_cbc53084465d3a95cdb8cbd79da21624e3086d5d_6.txt","path":"/home/pritish/Documents/IP work/guv_ver/v28.1/cbc53084465d3a95cdb8cbd79da21624e3086d5d/Traverser","pathinproj":"android/guava/src/com/google/common/graph/Traverser.java","addlines":[129,130,99,131,100,101,102,103,104,105,106,107,109,110,143,144,145,114,146,115,127],"dellines":[80,81,117,70,118,119,72,105,91,76,77,93],"addcode":["   * node(s) to any node reachable from the start node(s), and has no paths from any start node to\n","   * any other start node, such as a tree or forest.\n","   *\n","   * <p>{@code forTree()} is especially useful (versus {@code forGraph()}) in cases where the data\n","   * structure being traversed is, in addition to being a tree/forest, also defined <a\n","   * href=\"https://github.com/google/guava/wiki/GraphsExplained#non-recursiveness\">recursively</a>.\n","   * This is because the {@code forTree()}-based implementations don't keep track of visited nodes,\n","   * and therefore don't need to call `equals()` or `hashCode()` on the node objects; this saves\n","   * both time and space versus traversing the same graph using {@code forGraph()}.\n","   * <p>Providing a graph to be traversed for which there is more than one path from the start\n","   * node(s) to any node may lead to:\n","   *   <li>Nodes being visited multiple times (if multiple paths exist from any start node to any\n","   *       node reachable from any start node)\n","   * <p><b>Examples</b> (all edges are directed facing downwards)\n","   * <p>The graph below would be valid input with start nodes of {@code a, f, c}. However, if {@code\n","   * b} were <i>also</i> a start node, then there would be multiple paths to reach {@code e} and\n","   * {@code h}.\n","   * <p>.\n","   *\n","   * <p>The graph below would be a valid input with start nodes of {@code a, f}. However, if {@code\n","   * b} were a start node, there would be multiple paths to {@code f}.\n","   * node(s) to any node reachable from the start node(s), and has no paths from any start node to\n","   * any other start node, such as a tree or forest.\n","   *\n","   * <p>{@code forTree()} is especially useful (versus {@code forGraph()}) in cases where the data\n","   * structure being traversed is, in addition to being a tree/forest, also defined <a\n","   * href=\"https://github.com/google/guava/wiki/GraphsExplained#non-recursiveness\">recursively</a>.\n","   * This is because the {@code forTree()}-based implementations don't keep track of visited nodes,\n","   * and therefore don't need to call `equals()` or `hashCode()` on the node objects; this saves\n","   * both time and space versus traversing the same graph using {@code forGraph()}.\n","   * <p>Providing a graph to be traversed for which there is more than one path from the start\n","   * node(s) to any node may lead to:\n","   *   <li>Nodes being visited multiple times (if multiple paths exist from any start node to any\n","   *       node reachable from any start node)\n","   * <p><b>Examples</b> (all edges are directed facing downwards)\n","   * <p>The graph below would be valid input with start nodes of {@code a, f, c}. However, if {@code\n","   * b} were <i>also</i> a start node, then there would be multiple paths to reach {@code e} and\n","   * {@code h}.\n","   * <p>.\n","   *\n","   * <p>The graph below would be a valid input with start nodes of {@code a, f}. However, if {@code\n","   * b} were a start node, there would be multiple paths to {@code f}.\n"],"delcode":["   * node to any node reachable from the start node, such as a tree.\n","   * <p>Providing graphs that don't conform to the above description may lead to:\n","   *   <li>Nodes being visited multiple times (if multiple paths exist from the start node to any\n","   *       node reachable from it)\n","   * In these cases, use {@link #forGraph(SuccessorsFunction)} instead.\n","   *\n","   * <p><b>Examples</b>\n","   * <p>This is a valid input graph (all edges are directed facing downwards):\n","   * <p>This is <b>not</b> a valid input graph (all edges are directed facing downwards):\n","   * <p>because there are two paths from {@code b} to {@code f} ({@code b->d->f} and {@code\n","   * b->e->f}).\n","   *\n","   * node to any node reachable from the start node, such as a tree.\n","   * <p>Providing graphs that don't conform to the above description may lead to:\n","   *   <li>Nodes being visited multiple times (if multiple paths exist from the start node to any\n","   *       node reachable from it)\n","   * In these cases, use {@link #forGraph(SuccessorsFunction)} instead.\n","   *\n","   * <p><b>Examples</b>\n","   * <p>This is a valid input graph (all edges are directed facing downwards):\n","   * <p>This is <b>not</b> a valid input graph (all edges are directed facing downwards):\n","   * <p>because there are two paths from {@code b} to {@code f} ({@code b->d->f} and {@code\n","   * b->e->f}).\n","   *\n"],"methodSig":"public static Traverser<N> forTree(SuccessorsFunction<N> tree)"},"id":3,"flag":1,"commit":"cbc53084465d3a95cdb8cbd79da21624e3086d5d"},{"func":{"oldfunccode":"","newfunccode":"cbc53084465d3a95cdb8cbd79da21624e3086d5d/Codes/Match_newfunccode_cbc53084465d3a95cdb8cbd79da21624e3086d5d_7.txt","newdoc":"","newJdoc":"cbc53084465d3a95cdb8cbd79da21624e3086d5d/Codes/Match_newfuncnewJdoc_cbc53084465d3a95cdb8cbd79da21624e3086d5d_7.txt","olddoc":"","oldJdoc":"","path":"/home/pritish/Documents/IP work/guv_ver/v28.1/cbc53084465d3a95cdb8cbd79da21624e3086d5d/Traverser","pathinproj":"android/guava/src/com/google/common/graph/Traverser.java","addlines":[223],"dellines":[],"addcode":["  public abstract Iterable<N> breadthFirst(Iterable<? extends N> startNodes);\n","  public abstract Iterable<N> breadthFirst(Iterable<? extends N> startNodes);\n"],"delcode":[],"methodSig":"public abstract Iterable<N> breadthFirst(Iterable<? extends N> startNodes)"},"doc":{"oldfunccode":"cbc53084465d3a95cdb8cbd79da21624e3086d5d/Codes/Match_olddocfunccode_cbc53084465d3a95cdb8cbd79da21624e3086d5d_7.txt","newfunccode":"cbc53084465d3a95cdb8cbd79da21624e3086d5d/Codes/Match_newdocfunccode_cbc53084465d3a95cdb8cbd79da21624e3086d5d_7.txt","newdoc":"","newJdoc":"cbc53084465d3a95cdb8cbd79da21624e3086d5d/Codes/Match_newdocnewJdoc_cbc53084465d3a95cdb8cbd79da21624e3086d5d_7.txt","olddoc":"","oldJdoc":"cbc53084465d3a95cdb8cbd79da21624e3086d5d/Codes/Match_olddocJdoc_cbc53084465d3a95cdb8cbd79da21624e3086d5d_7.txt","path":"/home/pritish/Documents/IP work/guv_ver/v28.1/cbc53084465d3a95cdb8cbd79da21624e3086d5d/Traverser","pathinproj":"android/guava/src/com/google/common/graph/Traverser.java","addlines":[129,130,99,131,100,101,102,103,104,105,106,107,109,110,143,144,145,114,146,115,127],"dellines":[80,81,117,70,118,119,72,105,91,76,77,93],"addcode":["   * node(s) to any node reachable from the start node(s), and has no paths from any start node to\n","   * any other start node, such as a tree or forest.\n","   *\n","   * <p>{@code forTree()} is especially useful (versus {@code forGraph()}) in cases where the data\n","   * structure being traversed is, in addition to being a tree/forest, also defined <a\n","   * href=\"https://github.com/google/guava/wiki/GraphsExplained#non-recursiveness\">recursively</a>.\n","   * This is because the {@code forTree()}-based implementations don't keep track of visited nodes,\n","   * and therefore don't need to call `equals()` or `hashCode()` on the node objects; this saves\n","   * both time and space versus traversing the same graph using {@code forGraph()}.\n","   * <p>Providing a graph to be traversed for which there is more than one path from the start\n","   * node(s) to any node may lead to:\n","   *   <li>Nodes being visited multiple times (if multiple paths exist from any start node to any\n","   *       node reachable from any start node)\n","   * <p><b>Examples</b> (all edges are directed facing downwards)\n","   * <p>The graph below would be valid input with start nodes of {@code a, f, c}. However, if {@code\n","   * b} were <i>also</i> a start node, then there would be multiple paths to reach {@code e} and\n","   * {@code h}.\n","   * <p>.\n","   *\n","   * <p>The graph below would be a valid input with start nodes of {@code a, f}. However, if {@code\n","   * b} were a start node, there would be multiple paths to {@code f}.\n","   * node(s) to any node reachable from the start node(s), and has no paths from any start node to\n","   * any other start node, such as a tree or forest.\n","   *\n","   * <p>{@code forTree()} is especially useful (versus {@code forGraph()}) in cases where the data\n","   * structure being traversed is, in addition to being a tree/forest, also defined <a\n","   * href=\"https://github.com/google/guava/wiki/GraphsExplained#non-recursiveness\">recursively</a>.\n","   * This is because the {@code forTree()}-based implementations don't keep track of visited nodes,\n","   * and therefore don't need to call `equals()` or `hashCode()` on the node objects; this saves\n","   * both time and space versus traversing the same graph using {@code forGraph()}.\n","   * <p>Providing a graph to be traversed for which there is more than one path from the start\n","   * node(s) to any node may lead to:\n","   *   <li>Nodes being visited multiple times (if multiple paths exist from any start node to any\n","   *       node reachable from any start node)\n","   * <p><b>Examples</b> (all edges are directed facing downwards)\n","   * <p>The graph below would be valid input with start nodes of {@code a, f, c}. However, if {@code\n","   * b} were <i>also</i> a start node, then there would be multiple paths to reach {@code e} and\n","   * {@code h}.\n","   * <p>.\n","   *\n","   * <p>The graph below would be a valid input with start nodes of {@code a, f}. However, if {@code\n","   * b} were a start node, there would be multiple paths to {@code f}.\n"],"delcode":["   * node to any node reachable from the start node, such as a tree.\n","   * <p>Providing graphs that don't conform to the above description may lead to:\n","   *   <li>Nodes being visited multiple times (if multiple paths exist from the start node to any\n","   *       node reachable from it)\n","   * In these cases, use {@link #forGraph(SuccessorsFunction)} instead.\n","   *\n","   * <p><b>Examples</b>\n","   * <p>This is a valid input graph (all edges are directed facing downwards):\n","   * <p>This is <b>not</b> a valid input graph (all edges are directed facing downwards):\n","   * <p>because there are two paths from {@code b} to {@code f} ({@code b->d->f} and {@code\n","   * b->e->f}).\n","   *\n","   * node to any node reachable from the start node, such as a tree.\n","   * <p>Providing graphs that don't conform to the above description may lead to:\n","   *   <li>Nodes being visited multiple times (if multiple paths exist from the start node to any\n","   *       node reachable from it)\n","   * In these cases, use {@link #forGraph(SuccessorsFunction)} instead.\n","   *\n","   * <p><b>Examples</b>\n","   * <p>This is a valid input graph (all edges are directed facing downwards):\n","   * <p>This is <b>not</b> a valid input graph (all edges are directed facing downwards):\n","   * <p>because there are two paths from {@code b} to {@code f} ({@code b->d->f} and {@code\n","   * b->e->f}).\n","   *\n"],"methodSig":"public static Traverser<N> forTree(SuccessorsFunction<N> tree)"},"id":3,"flag":1,"commit":"cbc53084465d3a95cdb8cbd79da21624e3086d5d"},{"func":{"oldfunccode":"","newfunccode":"cbc53084465d3a95cdb8cbd79da21624e3086d5d/Codes/Match_newfunccode_cbc53084465d3a95cdb8cbd79da21624e3086d5d_8.txt","newdoc":"","newJdoc":"cbc53084465d3a95cdb8cbd79da21624e3086d5d/Codes/Match_newfuncnewJdoc_cbc53084465d3a95cdb8cbd79da21624e3086d5d_8.txt","olddoc":"","oldJdoc":"","path":"/home/pritish/Documents/IP work/guv_ver/v28.1/cbc53084465d3a95cdb8cbd79da21624e3086d5d/Traverser","pathinproj":"android/guava/src/com/google/common/graph/Traverser.java","addlines":[311],"dellines":[],"addcode":["  public abstract Iterable<N> depthFirstPostOrder(Iterable<? extends N> startNodes);\n","  public abstract Iterable<N> depthFirstPostOrder(Iterable<? extends N> startNodes);\n"],"delcode":[],"methodSig":"public abstract Iterable<N> depthFirstPostOrder(Iterable<? extends N> startNodes)"},"doc":{"oldfunccode":"cbc53084465d3a95cdb8cbd79da21624e3086d5d/Codes/Match_olddocfunccode_cbc53084465d3a95cdb8cbd79da21624e3086d5d_8.txt","newfunccode":"cbc53084465d3a95cdb8cbd79da21624e3086d5d/Codes/Match_newdocfunccode_cbc53084465d3a95cdb8cbd79da21624e3086d5d_8.txt","newdoc":"","newJdoc":"cbc53084465d3a95cdb8cbd79da21624e3086d5d/Codes/Match_newdocnewJdoc_cbc53084465d3a95cdb8cbd79da21624e3086d5d_8.txt","olddoc":"","oldJdoc":"cbc53084465d3a95cdb8cbd79da21624e3086d5d/Codes/Match_olddocJdoc_cbc53084465d3a95cdb8cbd79da21624e3086d5d_8.txt","path":"/home/pritish/Documents/IP work/guv_ver/v28.1/cbc53084465d3a95cdb8cbd79da21624e3086d5d/Traverser","pathinproj":"android/guava/src/com/google/common/graph/Traverser.java","addlines":[129,130,99,131,100,101,102,103,104,105,106,107,109,110,143,144,145,114,146,115,127],"dellines":[80,81,117,70,118,119,72,105,91,76,77,93],"addcode":["   * node(s) to any node reachable from the start node(s), and has no paths from any start node to\n","   * any other start node, such as a tree or forest.\n","   *\n","   * <p>{@code forTree()} is especially useful (versus {@code forGraph()}) in cases where the data\n","   * structure being traversed is, in addition to being a tree/forest, also defined <a\n","   * href=\"https://github.com/google/guava/wiki/GraphsExplained#non-recursiveness\">recursively</a>.\n","   * This is because the {@code forTree()}-based implementations don't keep track of visited nodes,\n","   * and therefore don't need to call `equals()` or `hashCode()` on the node objects; this saves\n","   * both time and space versus traversing the same graph using {@code forGraph()}.\n","   * <p>Providing a graph to be traversed for which there is more than one path from the start\n","   * node(s) to any node may lead to:\n","   *   <li>Nodes being visited multiple times (if multiple paths exist from any start node to any\n","   *       node reachable from any start node)\n","   * <p><b>Examples</b> (all edges are directed facing downwards)\n","   * <p>The graph below would be valid input with start nodes of {@code a, f, c}. However, if {@code\n","   * b} were <i>also</i> a start node, then there would be multiple paths to reach {@code e} and\n","   * {@code h}.\n","   * <p>.\n","   *\n","   * <p>The graph below would be a valid input with start nodes of {@code a, f}. However, if {@code\n","   * b} were a start node, there would be multiple paths to {@code f}.\n","   * node(s) to any node reachable from the start node(s), and has no paths from any start node to\n","   * any other start node, such as a tree or forest.\n","   *\n","   * <p>{@code forTree()} is especially useful (versus {@code forGraph()}) in cases where the data\n","   * structure being traversed is, in addition to being a tree/forest, also defined <a\n","   * href=\"https://github.com/google/guava/wiki/GraphsExplained#non-recursiveness\">recursively</a>.\n","   * This is because the {@code forTree()}-based implementations don't keep track of visited nodes,\n","   * and therefore don't need to call `equals()` or `hashCode()` on the node objects; this saves\n","   * both time and space versus traversing the same graph using {@code forGraph()}.\n","   * <p>Providing a graph to be traversed for which there is more than one path from the start\n","   * node(s) to any node may lead to:\n","   *   <li>Nodes being visited multiple times (if multiple paths exist from any start node to any\n","   *       node reachable from any start node)\n","   * <p><b>Examples</b> (all edges are directed facing downwards)\n","   * <p>The graph below would be valid input with start nodes of {@code a, f, c}. However, if {@code\n","   * b} were <i>also</i> a start node, then there would be multiple paths to reach {@code e} and\n","   * {@code h}.\n","   * <p>.\n","   *\n","   * <p>The graph below would be a valid input with start nodes of {@code a, f}. However, if {@code\n","   * b} were a start node, there would be multiple paths to {@code f}.\n"],"delcode":["   * node to any node reachable from the start node, such as a tree.\n","   * <p>Providing graphs that don't conform to the above description may lead to:\n","   *   <li>Nodes being visited multiple times (if multiple paths exist from the start node to any\n","   *       node reachable from it)\n","   * In these cases, use {@link #forGraph(SuccessorsFunction)} instead.\n","   *\n","   * <p><b>Examples</b>\n","   * <p>This is a valid input graph (all edges are directed facing downwards):\n","   * <p>This is <b>not</b> a valid input graph (all edges are directed facing downwards):\n","   * <p>because there are two paths from {@code b} to {@code f} ({@code b->d->f} and {@code\n","   * b->e->f}).\n","   *\n","   * node to any node reachable from the start node, such as a tree.\n","   * <p>Providing graphs that don't conform to the above description may lead to:\n","   *   <li>Nodes being visited multiple times (if multiple paths exist from the start node to any\n","   *       node reachable from it)\n","   * In these cases, use {@link #forGraph(SuccessorsFunction)} instead.\n","   *\n","   * <p><b>Examples</b>\n","   * <p>This is a valid input graph (all edges are directed facing downwards):\n","   * <p>This is <b>not</b> a valid input graph (all edges are directed facing downwards):\n","   * <p>because there are two paths from {@code b} to {@code f} ({@code b->d->f} and {@code\n","   * b->e->f}).\n","   *\n"],"methodSig":"public static Traverser<N> forTree(SuccessorsFunction<N> tree)"},"id":3,"flag":1,"commit":"cbc53084465d3a95cdb8cbd79da21624e3086d5d"},{"func":{"oldfunccode":"","newfunccode":"cbc53084465d3a95cdb8cbd79da21624e3086d5d/Codes/Match_newfunccode_cbc53084465d3a95cdb8cbd79da21624e3086d5d_9.txt","newdoc":"","newJdoc":"","olddoc":"","oldJdoc":"","path":"/home/pritish/Documents/IP work/guv_ver/v28.1/cbc53084465d3a95cdb8cbd79da21624e3086d5d/Traverser","pathinproj":"android/guava/src/com/google/common/graph/Traverser.java","addlines":[352,353,354,355,356,357,358,518,359,519,360,520,521,522,523,364,524,525,526,530],"dellines":[],"addcode":["    @Override\n","    public Iterable<N> depthFirstPreOrder(final Iterable<? extends N> startNodes) {\n","      checkNotNull(startNodes);\n","      if (Iterables.isEmpty(startNodes)) {\n","        return ImmutableSet.of();\n","      }\n","      for (N startNode : startNodes) {\n","        checkThatNodeIsInGraph(startNode);\n","      }\n","          return new DepthFirstIterator(startNodes, Order.PREORDER);\n","    @Override\n","    public Iterable<N> depthFirstPreOrder(final Iterable<? extends N> startNodes) {\n","      checkNotNull(startNodes);\n","      if (Iterables.isEmpty(startNodes)) {\n","        return ImmutableSet.of();\n","      }\n","      for (N node : startNodes) {\n","        checkThatNodeIsInTree(node);\n","      }\n","          return new DepthFirstPreOrderIterator(startNodes);\n","    @Override\n","    public Iterable<N> depthFirstPreOrder(final Iterable<? extends N> startNodes) {\n","      checkNotNull(startNodes);\n","      if (Iterables.isEmpty(startNodes)) {\n","        return ImmutableSet.of();\n","      }\n","      for (N startNode : startNodes) {\n","        checkThatNodeIsInGraph(startNode);\n","      }\n","          return new DepthFirstIterator(startNodes, Order.PREORDER);\n","    @Override\n","    public Iterable<N> depthFirstPreOrder(final Iterable<? extends N> startNodes) {\n","      checkNotNull(startNodes);\n","      if (Iterables.isEmpty(startNodes)) {\n","        return ImmutableSet.of();\n","      }\n","      for (N node : startNodes) {\n","        checkThatNodeIsInTree(node);\n","      }\n","          return new DepthFirstPreOrderIterator(startNodes);\n"],"delcode":[],"methodSig":"public Iterable<N> depthFirstPreOrder(final Iterable<? extends N> startNodes)"},"doc":{"oldfunccode":"cbc53084465d3a95cdb8cbd79da21624e3086d5d/Codes/Match_olddocfunccode_cbc53084465d3a95cdb8cbd79da21624e3086d5d_9.txt","newfunccode":"cbc53084465d3a95cdb8cbd79da21624e3086d5d/Codes/Match_newdocfunccode_cbc53084465d3a95cdb8cbd79da21624e3086d5d_9.txt","newdoc":"","newJdoc":"cbc53084465d3a95cdb8cbd79da21624e3086d5d/Codes/Match_newdocnewJdoc_cbc53084465d3a95cdb8cbd79da21624e3086d5d_9.txt","olddoc":"","oldJdoc":"cbc53084465d3a95cdb8cbd79da21624e3086d5d/Codes/Match_olddocJdoc_cbc53084465d3a95cdb8cbd79da21624e3086d5d_9.txt","path":"/home/pritish/Documents/IP work/guv_ver/v28.1/cbc53084465d3a95cdb8cbd79da21624e3086d5d/Traverser","pathinproj":"android/guava/src/com/google/common/graph/Traverser.java","addlines":[129,130,99,131,100,101,102,103,104,105,106,107,109,110,143,144,145,114,146,115,127],"dellines":[80,81,117,70,118,119,72,105,91,76,77,93],"addcode":["   * node(s) to any node reachable from the start node(s), and has no paths from any start node to\n","   * any other start node, such as a tree or forest.\n","   *\n","   * <p>{@code forTree()} is especially useful (versus {@code forGraph()}) in cases where the data\n","   * structure being traversed is, in addition to being a tree/forest, also defined <a\n","   * href=\"https://github.com/google/guava/wiki/GraphsExplained#non-recursiveness\">recursively</a>.\n","   * This is because the {@code forTree()}-based implementations don't keep track of visited nodes,\n","   * and therefore don't need to call `equals()` or `hashCode()` on the node objects; this saves\n","   * both time and space versus traversing the same graph using {@code forGraph()}.\n","   * <p>Providing a graph to be traversed for which there is more than one path from the start\n","   * node(s) to any node may lead to:\n","   *   <li>Nodes being visited multiple times (if multiple paths exist from any start node to any\n","   *       node reachable from any start node)\n","   * <p><b>Examples</b> (all edges are directed facing downwards)\n","   * <p>The graph below would be valid input with start nodes of {@code a, f, c}. However, if {@code\n","   * b} were <i>also</i> a start node, then there would be multiple paths to reach {@code e} and\n","   * {@code h}.\n","   * <p>.\n","   *\n","   * <p>The graph below would be a valid input with start nodes of {@code a, f}. However, if {@code\n","   * b} were a start node, there would be multiple paths to {@code f}.\n","   * node(s) to any node reachable from the start node(s), and has no paths from any start node to\n","   * any other start node, such as a tree or forest.\n","   *\n","   * <p>{@code forTree()} is especially useful (versus {@code forGraph()}) in cases where the data\n","   * structure being traversed is, in addition to being a tree/forest, also defined <a\n","   * href=\"https://github.com/google/guava/wiki/GraphsExplained#non-recursiveness\">recursively</a>.\n","   * This is because the {@code forTree()}-based implementations don't keep track of visited nodes,\n","   * and therefore don't need to call `equals()` or `hashCode()` on the node objects; this saves\n","   * both time and space versus traversing the same graph using {@code forGraph()}.\n","   * <p>Providing a graph to be traversed for which there is more than one path from the start\n","   * node(s) to any node may lead to:\n","   *   <li>Nodes being visited multiple times (if multiple paths exist from any start node to any\n","   *       node reachable from any start node)\n","   * <p><b>Examples</b> (all edges are directed facing downwards)\n","   * <p>The graph below would be valid input with start nodes of {@code a, f, c}. However, if {@code\n","   * b} were <i>also</i> a start node, then there would be multiple paths to reach {@code e} and\n","   * {@code h}.\n","   * <p>.\n","   *\n","   * <p>The graph below would be a valid input with start nodes of {@code a, f}. However, if {@code\n","   * b} were a start node, there would be multiple paths to {@code f}.\n"],"delcode":["   * node to any node reachable from the start node, such as a tree.\n","   * <p>Providing graphs that don't conform to the above description may lead to:\n","   *   <li>Nodes being visited multiple times (if multiple paths exist from the start node to any\n","   *       node reachable from it)\n","   * In these cases, use {@link #forGraph(SuccessorsFunction)} instead.\n","   *\n","   * <p><b>Examples</b>\n","   * <p>This is a valid input graph (all edges are directed facing downwards):\n","   * <p>This is <b>not</b> a valid input graph (all edges are directed facing downwards):\n","   * <p>because there are two paths from {@code b} to {@code f} ({@code b->d->f} and {@code\n","   * b->e->f}).\n","   *\n","   * node to any node reachable from the start node, such as a tree.\n","   * <p>Providing graphs that don't conform to the above description may lead to:\n","   *   <li>Nodes being visited multiple times (if multiple paths exist from the start node to any\n","   *       node reachable from it)\n","   * In these cases, use {@link #forGraph(SuccessorsFunction)} instead.\n","   *\n","   * <p><b>Examples</b>\n","   * <p>This is a valid input graph (all edges are directed facing downwards):\n","   * <p>This is <b>not</b> a valid input graph (all edges are directed facing downwards):\n","   * <p>because there are two paths from {@code b} to {@code f} ({@code b->d->f} and {@code\n","   * b->e->f}).\n","   *\n"],"methodSig":"public static Traverser<N> forTree(SuccessorsFunction<N> tree)"},"id":3,"flag":1,"commit":"cbc53084465d3a95cdb8cbd79da21624e3086d5d"}]