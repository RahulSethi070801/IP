{"id": "63898e263ddcdae00fc760fdaf97d90c8a656608", "code": [{"0": "android/guava-tests/test/com/google/common/reflect/ClassPathTest.java", "added": {"1": ["import static com.google.common.base.StandardSystemProperty.JAVA_CLASS_PATH;\n", "import static com.google.common.base.StandardSystemProperty.PATH_SEPARATOR;\n", "import com.google.common.base.Joiner;\n"], "2": ["import java.security.PermissionCollection;\n"], "3": ["  public void testGetClassPathUrls() throws Exception {\n", "    String oldPathSeparator = PATH_SEPARATOR.value();\n", "    String oldClassPath = JAVA_CLASS_PATH.value();\n", "    System.setProperty(PATH_SEPARATOR.key(), \":\");\n", "    System.setProperty(\n", "        JAVA_CLASS_PATH.key(),\n", "        Joiner.on(\":\")\n", "            .join(\n", "                \"relative/path/to/some.jar\",\n", "                \"/absolute/path/to/some.jar\",\n", "                \"relative/path/to/class/root\",\n", "                \"/absolute/path/to/class/root\"));\n", "    try {\n", "      ImmutableList<URL> urls = ClassPath.Scanner.parseJavaClassPath();\n", "\n", "      assertThat(urls.get(0).getProtocol()).isEqualTo(\"file\");\n", "      assertThat(urls.get(0).getAuthority()).isNull();\n", "      assertThat(urls.get(0).getPath()).endsWith(\"/relative/path/to/some.jar\");\n", "\n", "      assertThat(urls.get(1)).isEqualTo(new URL(\"file:///absolute/path/to/some.jar\"));\n", "\n", "      assertThat(urls.get(2).getProtocol()).isEqualTo(\"file\");\n", "      assertThat(urls.get(2).getAuthority()).isNull();\n", "      assertThat(urls.get(2).getPath()).endsWith(\"/relative/path/to/class/root\");\n", "\n", "      assertThat(urls.get(3)).isEqualTo(new URL(\"file:///absolute/path/to/class/root\"));\n", "\n", "      assertThat(urls).hasSize(4);\n", "    } finally {\n", "      System.setProperty(PATH_SEPARATOR.key(), oldPathSeparator);\n", "      System.setProperty(JAVA_CLASS_PATH.key(), oldClassPath);\n", "    }\n", "  }\n", "\n"], "4": ["    File file = null;\n", "    // In Java 9, Logger may read the TZ database. Only disallow reading the class path URLs.\n", "    final PermissionCollection readClassPathFiles =\n", "        new FilePermission(\"\", \"read\").newPermissionCollection();\n", "    for (URL url : ClassPath.Scanner.parseJavaClassPath()) {\n", "        file = new File(url.toURI());\n", "        readClassPathFiles.add(new FilePermission(file.getAbsolutePath(), \"read\"));\n", "    assertThat(file).isNotNull();\n", "    SecurityManager disallowFilesSecurityManager =\n", "        new SecurityManager() {\n", "          @Override\n", "          public void checkPermission(Permission p) {\n", "            if (readClassPathFiles.implies(p)) {\n", "              throw new SecurityException(\"Disallowed: \" + p);\n", "            }\n", "          }\n", "        };\n", "      file.exists();\n", "    ClassPath classPath = ClassPath.from(getClass().getClassLoader());\n", "    // ClassPath may contain resources from the boot class loader; just not from the class path.\n", "    for (ResourceInfo resource : classPath.getResources()) {\n", "      assertThat(resource.getResourceName()).doesNotContain(\"com/google/common/reflect/\");\n", "    }\n"]}, "removed": {"4": ["    URLClassLoader myLoader = (URLClassLoader) getClass().getClassLoader();\n", "    URL[] urls = myLoader.getURLs();\n", "    ImmutableList.Builder<File> filesBuilder = ImmutableList.builder();\n", "    for (URL url : urls) {\n", "        filesBuilder.add(new File(url.toURI()));\n", "    ImmutableList<File> files = filesBuilder.build();\n", "    assertThat(files).isNotEmpty();\n", "    SecurityManager disallowFilesSecurityManager = new SecurityManager() {\n", "      @Override\n", "      public void checkPermission(Permission p) {\n", "        if (p instanceof FilePermission) {\n", "          throw new SecurityException(\"Disallowed: \" + p);\n", "        }\n", "      }\n", "    };\n", "      files.get(0).exists();\n", "    ClassPath classPath = ClassPath.from(myLoader);\n", "    assertThat(classPath.getResources()).isEmpty();\n"]}, "added_lines": {"1": [20, 21, 24], "2": [45], "3": [366, 367, 368, 369, 370, 371, 372, 373, 374, 375, 376, 377, 378, 379, 380, 381, 382, 383, 384, 385, 386, 387, 388, 389, 390, 391, 392, 393, 394, 395, 396, 397, 398, 399], "4": [428, 429, 430, 431, 432, 434, 435, 438, 439, 440, 441, 442, 443, 444, 445, 446, 447, 450, 454, 455, 456, 457, 458]}, "removed_lines": {"4": [390, 391, 392, 393, 395, 398, 399, 400, 401, 402, 403, 404, 405, 406, 407, 410, 414, 415]}}, {"1": "android/guava/src/com/google/common/reflect/ClassPath.java", "added": {"1": ["import static com.google.common.base.StandardSystemProperty.JAVA_CLASS_PATH;\n", "import static com.google.common.base.StandardSystemProperty.PATH_SEPARATOR;\n", "import static java.util.logging.Level.WARNING;\n"], "2": ["import com.google.common.collect.ImmutableList;\n"], "3": [" * <p><b>Warning:</b> Current limitations:\n", " *\n", " * <ul>\n", " *   <li>Looks only for files and JARs in URLs available from {@link URLClassLoader} instances or\n", " *       the {@linkplain ClassLoader#getSystemClassLoader() system class loader}.\n", " *   <li>Only understands {@code file:} URLs.\n", " * </ul>\n"], "4": ["   * classloader} and its ancestor class loaders.\n", "   *\n", "   * <p><b>Warning:</b> {@code ClassPath} can find classes and resources only from:\n", "   * <ul>\n", "   *   <li>{@link URLClassLoader} instances' {@code file:} URLs\n", "   *   <li>the {@linkplain ClassLoader#getSystemClassLoader() system class loader}. To search the\n", "   *       system class loader even when it is not a {@link URLClassLoader} (as in Java 9), {@code\n", "   *       ClassPath} searches the files from the {@code java.class.path} system property.\n", "   * </ul>\n"], "5": ["      for (URL url : getClassLoaderUrls(classloader)) {\n", "        if (url.getProtocol().equals(\"file\")) {\n", "          File file = toFile(url);\n", "          if (!entries.containsKey(file)) {\n", "            entries.put(file, classloader);\n", "    private static ImmutableList<URL> getClassLoaderUrls(ClassLoader classloader) {\n", "      if (classloader instanceof URLClassLoader) {\n", "        return ImmutableList.copyOf(((URLClassLoader) classloader).getURLs());\n", "      }\n", "      if (classloader.equals(ClassLoader.getSystemClassLoader())) {\n", "        return parseJavaClassPath();\n", "      }\n", "      return ImmutableList.of();\n", "    }\n", "\n", "    /**\n", "     * Returns the URLs in the class path specified by the {@code java.class.path} {@linkplain\n", "     * System#getProperty system property}.\n", "     */\n", "    @VisibleForTesting // TODO(b/65488446): Make this a public API.\n", "    static ImmutableList<URL> parseJavaClassPath() {\n", "      ImmutableList.Builder<URL> urls = ImmutableList.builder();\n", "      for (String entry : Splitter.on(PATH_SEPARATOR.value()).split(JAVA_CLASS_PATH.value())) {\n", "        try {\n", "          try {\n", "            urls.add(new File(entry).toURI().toURL());\n", "          } catch (SecurityException e) { // File.toURI checks to see if the file is a directory\n", "            urls.add(new URL(\"file\", null, new File(entry).getAbsolutePath()));\n", "          }\n", "        } catch (MalformedURLException e) {\n", "          logger.log(WARNING, \"malformed classpath entry: \" + entry, e);\n", "        }\n", "      }\n", "      return urls.build();\n", "    }\n", "\n"]}, "removed": {"3": [" * <p><b>Warning:</b> Currently only {@link URLClassLoader} and only {@code file://} urls are\n", " * supported.\n"], "4": ["   * classloader} and its parent class loaders.\n", "   * <p><b>Warning:</b> Currently only {@link URLClassLoader} and only {@code file://} urls are\n", "   * supported.\n"], "5": ["      if (classloader instanceof URLClassLoader) {\n", "        URLClassLoader urlClassLoader = (URLClassLoader) classloader;\n", "        for (URL entry : urlClassLoader.getURLs()) {\n", "          if (entry.getProtocol().equals(\"file\")) {\n", "            File file = toFile(entry);\n", "            if (!entries.containsKey(file)) {\n", "              entries.put(file, classloader);\n", "            }\n"]}, "added_lines": {"1": [19, 20, 21], "2": [29], "3": [62, 63, 64, 65, 66, 67, 68], "4": [103, 104, 105, 107, 108, 109, 110, 111, 112], "5": [450, 451, 452, 453, 454, 461, 462, 463, 464, 465, 466, 467, 468, 469, 470, 471, 472, 473, 474, 475, 476, 477, 478, 479, 480, 481, 482, 483, 484, 485, 486, 487, 488, 489, 490, 491]}, "removed_lines": {"3": [58, 59], "4": [94, 96, 97], "5": [435, 436, 437, 438, 439, 440, 441, 442]}}, {"2": "guava-tests/test/com/google/common/reflect/ClassPathTest.java", "added": {"1": ["import static com.google.common.base.StandardSystemProperty.JAVA_CLASS_PATH;\n", "import static com.google.common.base.StandardSystemProperty.PATH_SEPARATOR;\n"], "2": ["import com.google.common.base.Joiner;\n"], "3": ["import java.security.PermissionCollection;\n"], "4": ["  public void testGetClassPathUrls() throws Exception {\n", "    String oldPathSeparator = PATH_SEPARATOR.value();\n", "    String oldClassPath = JAVA_CLASS_PATH.value();\n", "    System.setProperty(PATH_SEPARATOR.key(), \":\");\n", "    System.setProperty(\n", "        JAVA_CLASS_PATH.key(),\n", "        Joiner.on(\":\")\n", "            .join(\n", "                \"relative/path/to/some.jar\",\n", "                \"/absolute/path/to/some.jar\",\n", "                \"relative/path/to/class/root\",\n", "                \"/absolute/path/to/class/root\"));\n", "    try {\n", "      ImmutableList<URL> urls = ClassPath.Scanner.parseJavaClassPath();\n", "\n", "      assertThat(urls.get(0).getProtocol()).isEqualTo(\"file\");\n", "      assertThat(urls.get(0).getAuthority()).isNull();\n", "      assertThat(urls.get(0).getPath()).endsWith(\"/relative/path/to/some.jar\");\n", "\n", "      assertThat(urls.get(1)).isEqualTo(new URL(\"file:///absolute/path/to/some.jar\"));\n", "\n", "      assertThat(urls.get(2).getProtocol()).isEqualTo(\"file\");\n", "      assertThat(urls.get(2).getAuthority()).isNull();\n", "      assertThat(urls.get(2).getPath()).endsWith(\"/relative/path/to/class/root\");\n", "\n", "      assertThat(urls.get(3)).isEqualTo(new URL(\"file:///absolute/path/to/class/root\"));\n", "\n", "      assertThat(urls).hasSize(4);\n", "    } finally {\n", "      System.setProperty(PATH_SEPARATOR.key(), oldPathSeparator);\n", "      System.setProperty(JAVA_CLASS_PATH.key(), oldClassPath);\n", "    }\n", "  }\n", "\n"], "5": ["    File file = null;\n", "    // In Java 9, Logger may read the TZ database. Only disallow reading the class path URLs.\n", "    final PermissionCollection readClassPathFiles =\n", "        new FilePermission(\"\", \"read\").newPermissionCollection();\n", "    for (URL url : ClassPath.Scanner.parseJavaClassPath()) {\n", "        file = new File(url.toURI());\n", "        readClassPathFiles.add(new FilePermission(file.getAbsolutePath(), \"read\"));\n", "    assertThat(file).isNotNull();\n", "    SecurityManager disallowFilesSecurityManager =\n", "        new SecurityManager() {\n", "          @Override\n", "          public void checkPermission(Permission p) {\n", "            if (readClassPathFiles.implies(p)) {\n", "              throw new SecurityException(\"Disallowed: \" + p);\n", "            }\n", "          }\n", "        };\n", "      file.exists();\n", "    ClassPath classPath = ClassPath.from(getClass().getClassLoader());\n", "    // ClassPath may contain resources from the boot class loader; just not from the class path.\n", "    for (ResourceInfo resource : classPath.getResources()) {\n", "      assertThat(resource.getResourceName()).doesNotContain(\"com/google/common/reflect/\");\n", "    }\n"]}, "removed": {"5": ["    URLClassLoader myLoader = (URLClassLoader) getClass().getClassLoader();\n", "    URL[] urls = myLoader.getURLs();\n", "    ImmutableList.Builder<File> filesBuilder = ImmutableList.builder();\n", "    for (URL url : urls) {\n", "        filesBuilder.add(new File(url.toURI()));\n", "    ImmutableList<File> files = filesBuilder.build();\n", "    assertThat(files).isNotEmpty();\n", "    SecurityManager disallowFilesSecurityManager = new SecurityManager() {\n", "      @Override\n", "      public void checkPermission(Permission p) {\n", "        if (p instanceof FilePermission) {\n", "          throw new SecurityException(\"Disallowed: \" + p);\n", "        }\n", "      }\n", "    };\n", "      files.get(0).exists();\n", "    ClassPath classPath = ClassPath.from(myLoader);\n", "    assertThat(classPath.getResources()).isEmpty();\n"]}, "added_lines": {"1": [20, 21], "2": [30], "3": [52], "4": [432, 433, 434, 435, 436, 437, 438, 439, 440, 441, 442, 443, 444, 445, 446, 447, 448, 449, 450, 451, 452, 453, 454, 455, 456, 457, 458, 459, 460, 461, 462, 463, 464, 465], "5": [494, 495, 496, 497, 498, 500, 501, 504, 505, 506, 507, 508, 509, 510, 511, 512, 513, 516, 520, 521, 522, 523, 524]}, "removed_lines": {"5": [456, 457, 458, 459, 461, 464, 465, 466, 467, 468, 469, 470, 471, 472, 473, 476, 480, 481]}}, {"3": "guava/src/com/google/common/reflect/ClassPath.java", "added": {"1": ["import static com.google.common.base.StandardSystemProperty.JAVA_CLASS_PATH;\n", "import static com.google.common.base.StandardSystemProperty.PATH_SEPARATOR;\n", "import static java.util.logging.Level.WARNING;\n"], "2": ["import com.google.common.collect.ImmutableList;\n"], "3": [" * <p><b>Warning:</b> Current limitations:\n", " *\n", " * <ul>\n", " *   <li>Looks only for files and JARs in URLs available from {@link URLClassLoader} instances or\n", " *       the {@linkplain ClassLoader#getSystemClassLoader() system class loader}.\n", " *   <li>Only understands {@code file:} URLs.\n", " * </ul>\n"], "4": ["   * classloader} and its ancestor class loaders.\n", "   *\n", "   * <p><b>Warning:</b> {@code ClassPath} can find classes and resources only from:\n", "   * <ul>\n", "   *   <li>{@link URLClassLoader} instances' {@code file:} URLs\n", "   *   <li>the {@linkplain ClassLoader#getSystemClassLoader() system class loader}. To search the\n", "   *       system class loader even when it is not a {@link URLClassLoader} (as in Java 9), {@code\n", "   *       ClassPath} searches the files from the {@code java.class.path} system property.\n", "   * </ul>\n"], "5": ["      for (URL url : getClassLoaderUrls(classloader)) {\n", "        if (url.getProtocol().equals(\"file\")) {\n", "          File file = toFile(url);\n", "          if (!entries.containsKey(file)) {\n", "            entries.put(file, classloader);\n", "    private static ImmutableList<URL> getClassLoaderUrls(ClassLoader classloader) {\n", "      if (classloader instanceof URLClassLoader) {\n", "        return ImmutableList.copyOf(((URLClassLoader) classloader).getURLs());\n", "      }\n", "      if (classloader.equals(ClassLoader.getSystemClassLoader())) {\n", "        return parseJavaClassPath();\n", "      }\n", "      return ImmutableList.of();\n", "    }\n", "\n", "    /**\n", "     * Returns the URLs in the class path specified by the {@code java.class.path} {@linkplain\n", "     * System#getProperty system property}.\n", "     */\n", "    @VisibleForTesting // TODO(b/65488446): Make this a public API.\n", "    static ImmutableList<URL> parseJavaClassPath() {\n", "      ImmutableList.Builder<URL> urls = ImmutableList.builder();\n", "      for (String entry : Splitter.on(PATH_SEPARATOR.value()).split(JAVA_CLASS_PATH.value())) {\n", "        try {\n", "          try {\n", "            urls.add(new File(entry).toURI().toURL());\n", "          } catch (SecurityException e) { // File.toURI checks to see if the file is a directory\n", "            urls.add(new URL(\"file\", null, new File(entry).getAbsolutePath()));\n", "          }\n", "        } catch (MalformedURLException e) {\n", "          logger.log(WARNING, \"malformed classpath entry: \" + entry, e);\n", "        }\n", "      }\n", "      return urls.build();\n", "    }\n", "\n"]}, "removed": {"3": [" * <p><b>Warning:</b> Currently only {@link URLClassLoader} and only {@code file://} urls are\n", " * supported.\n"], "4": ["   * classloader} and its parent class loaders.\n", "   * <p><b>Warning:</b> Currently only {@link URLClassLoader} and only {@code file://} urls are\n", "   * supported.\n"], "5": ["      if (classloader instanceof URLClassLoader) {\n", "        URLClassLoader urlClassLoader = (URLClassLoader) classloader;\n", "        for (URL entry : urlClassLoader.getURLs()) {\n", "          if (entry.getProtocol().equals(\"file\")) {\n", "            File file = toFile(entry);\n", "            if (!entries.containsKey(file)) {\n", "              entries.put(file, classloader);\n", "            }\n"]}, "added_lines": {"1": [19, 20, 21], "2": [29], "3": [62, 63, 64, 65, 66, 67, 68], "4": [103, 104, 105, 107, 108, 109, 110, 111, 112], "5": [450, 451, 452, 453, 454, 461, 462, 463, 464, 465, 466, 467, 468, 469, 470, 471, 472, 473, 474, 475, 476, 477, 478, 479, 480, 481, 482, 483, 484, 485, 486, 487, 488, 489, 490, 491]}, "removed_lines": {"3": [58, 59], "4": [94, 96, 97], "5": [435, 436, 437, 438, 439, 440, 441, 442]}}]}
