{
    "addition": {
        "35": " * A builder of {@link ConcurrentMap} instances that can have keys or values automatically wrapped\n",
        "36": " * in {@linkplain WeakReference weak} references.\n",
        "38": " * <p>Usage example:\n",
        "40": " * <pre>{@code\n",
        "41": " * ConcurrentMap<Request, Stopwatch> timers = new MapMaker()\n",
        "42": " *     .concurrencyLevel(4)\n",
        "43": " *     .weakKeys()\n",
        "44": " *     .makeMap();\n",
        "45": " * }</pre>\n",
        "56": " * specified, the map uses identity ({@code ==}) comparisons instead for keys. Likewise, if {@link\n",
        "57": " * #weakValues} was specified, the map uses identity comparisons for values.\n",
        "65": " * present in the map to be reclaimed by the garbage collector. Entries with reclaimed keys or\n",
        "66": " * values may be removed from the map on each map modification or on occasional map accesses; such\n",
        "67": " * entries may be counted by {@link Map#size}, but will never be visible to read or write\n",
        "68": " * operations. A partially-reclaimed entry is never exposed to the user. Any {@link java.util.Entry}\n",
        "69": " * instance retrieved from the map's {@linkplain Map#entrySet entry set} is a snapshot of that\n",
        "70": " * entry's state at the time of retrieval; such entries do, however, support {@link\n",
        "71": " * java.util.Entry#setValue}, which simply calls {@link Map#put} on the entry's key.\n",
        "78": " * <p>{@code new MapMaker().weakKeys().makeMap()} is a recommended replacement for {@link\n",
        "79": " * java.util.WeakHashMap}, but note that it compares keys using object identity whereas {@code\n",
        "80": " * WeakHashMap} uses {@link Object#equals}.\n",
        "114": "   * <p>By default, the map uses {@link Equivalence#identity} to determine key equality when {@link\n",
        "115": "   * #weakKeys} is specified, and {@link Equivalence#equals()} otherwise. The only place this is\n",
        "116": "   * used is in {@link Interners.WeakInterner}.\n",
        "191": "   * Specifies that each key (not value) stored in the map should be wrapped in a {@link\n",
        "192": "   * WeakReference} (by default, strong references are used).\n",
        "222": "   * Specifies that each value (not key) stored in the map should be wrapped in a {@link\n",
        "223": "   * WeakReference} (by default, strong references are used).\n",
        "246": "   * <p>{@link MapMakerInternalMap} can optimize for memory usage in this case; see {@link\n",
        "247": "   * MapMakerInternalMap#createWithDummyValues}.\n",
        "272": "   * be performed atomically on the returned map. Additionally, {@code size} and {@code\n",
        "273": "   * containsValue} are implemented as bulk read operations, and thus may fail to observe concurrent\n",
        "274": "   * writes.\n"
    },
    "removed": {
        "35": " * <p>A builder of {@link ConcurrentMap} instances that can have keys or values automatically\n",
        "36": " * wrapped in {@linkplain WeakReference weak} references.\n",
        "38": " * <p>Usage example: <pre>   {@code\n",
        "40": " *   ConcurrentMap<Request, Stopwatch> timers = new MapMaker()\n",
        "41": " *       .concurrencyLevel(4)\n",
        "42": " *       .weakKeys()\n",
        "43": " *       .makeMap();}</pre>\n",
        "54": " * specified, the map uses identity ({@code ==}) comparisons instead for keys. Likewise, if\n",
        "55": " * {@link #weakValues} was specified, the map uses identity comparisons for values.\n",
        "63": " * present in the map to be reclaimed by the\n",
        "64": " * garbage collector. Entries with reclaimed keys or values may be removed from the map on each map\n",
        "65": " * modification or on occasional map accesses; such entries may be counted by {@link Map#size}, but\n",
        "66": " * will never be visible to read or write operations. A partially-reclaimed entry is never exposed\n",
        "67": " * to the user. Any {@link java.util.Entry} instance retrieved from the map's\n",
        "68": " * {@linkplain Map#entrySet entry set} is a snapshot of that entry's state at the time of retrieval;\n",
        "69": " * such entries do, however, support {@link java.util.Entry#setValue}, which simply calls\n",
        "70": " * {@link Map#put} on the entry's key.\n",
        "77": " * <p>{@code new MapMaker().weakKeys().makeMap()} is a recommended replacement for\n",
        "78": " * {@link java.util.WeakHashMap}, but note that it compares keys using object identity whereas\n",
        "79": " * {@code WeakHashMap} uses {@link Object#equals}.\n",
        "113": "   * <p>By default, the map uses {@link Equivalence#identity} to determine key equality when\n",
        "114": "   * {@link #weakKeys} is specified, and {@link Equivalence#equals()} otherwise. The only place this\n",
        "115": "   * is used is in {@link Interners.WeakInterner}.\n",
        "190": "   * Specifies that each key (not value) stored in the map should be wrapped in a\n",
        "191": "   * {@link WeakReference} (by default, strong references are used).\n",
        "221": "   * Specifies that each value (not key) stored in the map should be wrapped in a\n",
        "222": "   * {@link WeakReference} (by default, strong references are used).\n",
        "245": "   * <p>{@link MapMakerInternalMap} can optimize for memory usage in this case; see\n",
        "246": "   * {@link MapMakerInternalMap#createWithDummyValues}.\n",
        "271": "   * be performed atomically on the returned map. Additionally, {@code size} and\n",
        "272": "   * {@code containsValue} are implemented as bulk read operations, and thus may fail to observe\n",
        "273": "   * concurrent writes.\n"
    }
}