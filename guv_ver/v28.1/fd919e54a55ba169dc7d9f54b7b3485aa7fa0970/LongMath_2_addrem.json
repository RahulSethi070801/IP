{
    "addition": {
        "43": " * <p>Similar functionality for {@code int} and for {@link BigInteger} can be found in {@link\n",
        "44": " * IntMath} and {@link BigIntegerMath} respectively. For other common operations on {@code long}\n",
        "45": " * values, see {@link com.google.common.primitives.Longs}.\n",
        "57": "   * Returns the smallest power of two greater than or equal to {@code x}. This is equivalent to\n",
        "61": "   * @throws ArithmeticException of the next-higher power of two is not representable as a {@code\n",
        "62": "   *     long}, i.e. when {@code x > 2^62}\n",
        "75": "   * Returns the largest power of two less than or equal to {@code x}. This is equivalent to {@code\n",
        "76": "   * checkedPow(2, log2(x, FLOOR))}.\n",
        "93": "   * <p>This differs from {@code Long.bitCount(x) == 1}, because {@code\n",
        "94": "   * Long.bitCount(Long.MIN_VALUE) == 1}, but {@link Long#MIN_VALUE} is not a power of two.\n",
        "307": "   * @throws ArithmeticException if {@code mode} is {@link RoundingMode#UNNECESSARY} and {@code\n",
        "308": "   *     sqrt(x)} is not an integer\n",
        "376": "   * Returns the result of dividing {@code p} by {@code q}, rounding using the specified {@code\n",
        "377": "   * RoundingMode}.\n",
        "438": "   * Returns {@code x mod m}, a non-negative value less than {@code m}. This differs from {@code x %\n",
        "439": "   * m}, which might be negative.\n",
        "443": "   * <pre>{@code\n",
        "448": "   * mod(8, 4) == 0\n",
        "449": "   * }</pre>\n",
        "462": "   * Returns {@code x mod m}, a non-negative value less than {@code m}. This differs from {@code x %\n",
        "463": "   * m}, which might be negative.\n",
        "467": "   * <pre>{@code\n",
        "472": "   * mod(8, 4) == 0\n",
        "473": "   * }</pre>\n",
        "489": "   * Returns the greatest common divisor of {@code a, b}. Returns {@code 0} if {@code a == 0 && b ==\n",
        "490": "   * 0}.\n",
        "599": "   * @throws ArithmeticException if {@code b} to the {@code k}th power overflows in signed {@code\n",
        "600": "   *     long} arithmetic\n",
        "868": "  /** Returns (x * numerator / denominator), which is assumed to come out to an integral value. */\n",
        "985": "      ~((1 << 1) | (1 << 7) | (1 << 11) | (1 << 13) | (1 << 17) | (1 << 19) | (1 << 23)\n",
        "986": "          | (1 << 29));\n",
        "989": "   * Returns {@code true} if {@code n} is a <a\n",
        "990": "   * href=\"http://mathworld.wolfram.com/PrimeNumber.html\">prime number</a>: an integer <i>greater\n",
        "992": "   * Returns {@code false} if {@code n} is zero, one, or a composite number (one which <i>can</i> be\n",
        "993": "   * factored into smaller positive integers).\n",
        "1085": "    /** Works for all nonnegative signed longs. */\n",
        "1092": "      /** Returns (a * 2^32) mod m. a may be any unsigned long. */\n",
        "1128": "        return plusMod(result, UnsignedLongs.remainder(aLo * bLo /* < 2^64 */, m), m);\n",
        "1151": "        return plusMod(result, UnsignedLongs.remainder(aLo * aLo /* < 2^64 */, m), m);\n",
        "1161": "    /** Returns a * b mod m. */\n",
        "1164": "    /** Returns a^2 mod m. */\n",
        "1167": "    /** Returns a^p mod m. */\n",
        "1179": "    /** Returns true if n is a strong probable prime relative to the specified base. */\n"
    },
    "removed": {
        "43": " * <p>Similar functionality for {@code int} and for {@link BigInteger} can be found in\n",
        "44": " * {@link IntMath} and {@link BigIntegerMath} respectively. For other common operations on\n",
        "45": " * {@code long} values, see {@link com.google.common.primitives.Longs}.\n",
        "57": "   * Returns the smallest power of two greater than or equal to {@code x}.  This is equivalent to\n",
        "61": "   * @throws ArithmeticException of the next-higher power of two is not representable as a\n",
        "62": "   *         {@code long}, i.e. when {@code x > 2^62}\n",
        "75": "   * Returns the largest power of two less than or equal to {@code x}.  This is equivalent to\n",
        "76": "   * {@code checkedPow(2, log2(x, FLOOR))}.\n",
        "93": "   * <p>This differs from {@code Long.bitCount(x) == 1}, because\n",
        "94": "   * {@code Long.bitCount(Long.MIN_VALUE) == 1}, but {@link Long#MIN_VALUE} is not a power of two.\n",
        "307": "   * @throws ArithmeticException if {@code mode} is {@link RoundingMode#UNNECESSARY} and\n",
        "308": "   *     {@code sqrt(x)} is not an integer\n",
        "376": "   * Returns the result of dividing {@code p} by {@code q}, rounding using the specified\n",
        "377": "   * {@code RoundingMode}.\n",
        "438": "   * Returns {@code x mod m}, a non-negative value less than {@code m}. This differs from\n",
        "439": "   * {@code x % m}, which might be negative.\n",
        "443": "   * <pre> {@code\n",
        "444": "   *\n",
        "449": "   * mod(8, 4) == 0}</pre>\n",
        "462": "   * Returns {@code x mod m}, a non-negative value less than {@code m}. This differs from\n",
        "463": "   * {@code x % m}, which might be negative.\n",
        "467": "   * <pre> {@code\n",
        "468": "   *\n",
        "473": "   * mod(8, 4) == 0}</pre>\n",
        "489": "   * Returns the greatest common divisor of {@code a, b}. Returns {@code 0} if\n",
        "490": "   * {@code a == 0 && b == 0}.\n",
        "599": "   * @throws ArithmeticException if {@code b} to the {@code k}th power overflows in signed\n",
        "600": "   *     {@code long} arithmetic\n",
        "868": "  /**\n",
        "869": "   * Returns (x * numerator / denominator), which is assumed to come out to an integral value.\n",
        "870": "   */\n",
        "987": "      ~((1 << 1) | (1 << 7) | (1 << 11) | (1 << 13)\n",
        "988": "          | (1 << 17) | (1 << 19) | (1 << 23) | (1 << 29));\n",
        "991": "   * Returns {@code true} if {@code n} is a\n",
        "992": "   * <a href=\"http://mathworld.wolfram.com/PrimeNumber.html\">prime number</a>: an integer <i>greater\n",
        "994": "   * Returns {@code false} if {@code n} is zero, one, or a composite number (one which <i>can</i>\n",
        "995": "   * be factored into smaller positive integers).\n",
        "1087": "    /**\n",
        "1088": "     * Works for all nonnegative signed longs.\n",
        "1089": "     */\n",
        "1096": "      /**\n",
        "1097": "       * Returns (a * 2^32) mod m. a may be any unsigned long.\n",
        "1098": "       */\n",
        "1134": "        return plusMod(\n",
        "1135": "            result,\n",
        "1136": "            UnsignedLongs.remainder(aLo * bLo /* < 2^64 */, m),\n",
        "1137": "            m);\n",
        "1160": "        return plusMod(\n",
        "1161": "            result,\n",
        "1162": "            UnsignedLongs.remainder(aLo * aLo /* < 2^64 */, m),\n",
        "1163": "            m);\n",
        "1173": "    /**\n",
        "1174": "     * Returns a * b mod m.\n",
        "1175": "     */\n",
        "1178": "    /**\n",
        "1179": "     * Returns a^2 mod m.\n",
        "1180": "     */\n",
        "1183": "    /**\n",
        "1184": "     * Returns a^p mod m.\n",
        "1185": "     */\n",
        "1197": "    /**\n",
        "1198": "     * Returns true if n is a strong probable prime relative to the specified base.\n",
        "1199": "     */\n"
    }
}