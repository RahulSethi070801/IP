{
    "addition": {
        "18": " * A package-local class holding common representation and mechanics for classes supporting dynamic\n",
        "19": " * striping on 64bit values. The class extends Number so that concrete subclasses must publicly do\n",
        "20": " * so.\n",
        "24": "  /*\n",
        "25": "   * This class maintains a lazily-initialized table of atomically\n",
        "26": "   * updated variables, plus an extra \"base\" field. The table size\n",
        "27": "   * is a power of two. Indexing uses masked per-thread hash codes.\n",
        "28": "   * Nearly all declarations in this class are package-private,\n",
        "29": "   * accessed directly by subclasses.\n",
        "30": "   *\n",
        "31": "   * Table entries are of class Cell; a variant of AtomicLong padded\n",
        "32": "   * to reduce cache contention on most processors. Padding is\n",
        "33": "   * overkill for most Atomics because they are usually irregularly\n",
        "34": "   * scattered in memory and thus don't interfere much with each\n",
        "35": "   * other. But Atomic objects residing in arrays will tend to be\n",
        "36": "   * placed adjacent to each other, and so will most often share\n",
        "37": "   * cache lines (with a huge negative performance impact) without\n",
        "38": "   * this precaution.\n",
        "39": "   *\n",
        "40": "   * In part because Cells are relatively large, we avoid creating\n",
        "41": "   * them until they are needed.  When there is no contention, all\n",
        "42": "   * updates are made to the base field.  Upon first contention (a\n",
        "43": "   * failed CAS on base update), the table is initialized to size 2.\n",
        "44": "   * The table size is doubled upon further contention until\n",
        "45": "   * reaching the nearest power of two greater than or equal to the\n",
        "46": "   * number of CPUS. Table slots remain empty (null) until they are\n",
        "47": "   * needed.\n",
        "48": "   *\n",
        "49": "   * A single spinlock (\"busy\") is used for initializing and\n",
        "50": "   * resizing the table, as well as populating slots with new Cells.\n",
        "51": "   * There is no need for a blocking lock; when the lock is not\n",
        "52": "   * available, threads try other slots (or the base).  During these\n",
        "53": "   * retries, there is increased contention and reduced locality,\n",
        "54": "   * which is still better than alternatives.\n",
        "55": "   *\n",
        "56": "   * Per-thread hash codes are initialized to random values.\n",
        "57": "   * Contention and/or table collisions are indicated by failed\n",
        "58": "   * CASes when performing an update operation (see method\n",
        "59": "   * retryUpdate). Upon a collision, if the table size is less than\n",
        "60": "   * the capacity, it is doubled in size unless some other thread\n",
        "61": "   * holds the lock. If a hashed slot is empty, and lock is\n",
        "62": "   * available, a new Cell is created. Otherwise, if the slot\n",
        "63": "   * exists, a CAS is tried.  Retries proceed by \"double hashing\",\n",
        "64": "   * using a secondary hash (Marsaglia XorShift) to try to find a\n",
        "65": "   * free slot.\n",
        "66": "   *\n",
        "67": "   * The table size is capped because, when there are more threads\n",
        "68": "   * than CPUs, supposing that each thread were bound to a CPU,\n",
        "69": "   * there would exist a perfect hash function mapping threads to\n",
        "70": "   * slots that eliminates collisions. When we reach capacity, we\n",
        "71": "   * search for this mapping by randomly varying the hash codes of\n",
        "72": "   * colliding threads.  Because search is random, and collisions\n",
        "73": "   * only become known via CAS failures, convergence can be slow,\n",
        "74": "   * and because threads are typically not bound to CPUS forever,\n",
        "75": "   * may not occur at all. However, despite these limitations,\n",
        "76": "   * observed contention rates are typically low in these cases.\n",
        "77": "   *\n",
        "78": "   * It is possible for a Cell to become unused when threads that\n",
        "79": "   * once hashed to it terminate, as well as in the case where\n",
        "80": "   * doubling the table causes no thread to hash to it under\n",
        "81": "   * expanded mask.  We do not try to detect or remove such cells,\n",
        "82": "   * under the assumption that for long-running instances, observed\n",
        "83": "   * contention levels will recur, so the cells will eventually be\n",
        "84": "   * needed again; and for short-lived ones, it does not matter.\n",
        "85": "   */\n",
        "87": "  /**\n",
        "88": "   * Padded variant of AtomicLong supporting only raw accesses plus CAS. The value field is placed\n",
        "89": "   * between pads, hoping that the JVM doesn't reorder them.\n",
        "90": "   *\n",
        "91": "   * <p>JVM intrinsics note: It would be possible to use a release-only form of CAS here, if it were\n",
        "92": "   * provided.\n",
        "93": "   */\n",
        "94": "  static final class Cell {\n",
        "95": "    volatile long p0, p1, p2, p3, p4, p5, p6;\n",
        "96": "    volatile long value;\n",
        "97": "    volatile long q0, q1, q2, q3, q4, q5, q6;\n",
        "99": "    Cell(long x) {\n",
        "100": "      value = x;\n",
        "101": "    }\n",
        "103": "    final boolean cas(long cmp, long val) {\n",
        "104": "      return UNSAFE.compareAndSwapLong(this, valueOffset, cmp, val);\n",
        "105": "    }\n",
        "107": "    // Unsafe mechanics\n",
        "108": "    private static final sun.misc.Unsafe UNSAFE;\n",
        "109": "    private static final long valueOffset;\n",
        "110": "\n",
        "111": "    static {\n",
        "112": "      try {\n",
        "113": "        UNSAFE = getUnsafe();\n",
        "114": "        Class<?> ak = Cell.class;\n",
        "115": "        valueOffset = UNSAFE.objectFieldOffset(ak.getDeclaredField(\"value\"));\n",
        "116": "      } catch (Exception e) {\n",
        "117": "        throw new Error(e);\n",
        "118": "      }\n",
        "120": "  }\n",
        "129": "  /** Generator of new random hash codes */\n",
        "130": "  static final Random rng = new Random();\n",
        "132": "  /** Number of CPUS, to place bound on table size */\n",
        "133": "  static final int NCPU = Runtime.getRuntime().availableProcessors();\n",
        "135": "  /** Table of cells. When non-null, size is a power of 2. */\n",
        "136": "  transient volatile Cell[] cells;\n",
        "138": "  /**\n",
        "139": "   * Base value, used mainly when there is no contention, but also as a fallback during table\n",
        "140": "   * initialization races. Updated via CAS.\n",
        "141": "   */\n",
        "142": "  transient volatile long base;\n",
        "144": "  /** Spinlock (locked via CAS) used when resizing and/or creating Cells. */\n",
        "145": "  transient volatile int busy;\n",
        "147": "  /** Package-private default constructor */\n",
        "148": "  Striped64() {}\n",
        "150": "  /** CASes the base field. */\n",
        "151": "  final boolean casBase(long cmp, long val) {\n",
        "152": "    return UNSAFE.compareAndSwapLong(this, baseOffset, cmp, val);\n",
        "153": "  }\n",
        "155": "  /** CASes the busy field from 0 to 1 to acquire lock. */\n",
        "156": "  final boolean casBusy() {\n",
        "157": "    return UNSAFE.compareAndSwapInt(this, busyOffset, 0, 1);\n",
        "158": "  }\n",
        "160": "  /**\n",
        "161": "   * Computes the function of current and new value. Subclasses should open-code this update\n",
        "162": "   * function for most uses, but the virtualized form is needed within retryUpdate.\n",
        "163": "   *\n",
        "164": "   * @param currentValue the current value (of either base or a cell)\n",
        "165": "   * @param newValue the argument from a user update call\n",
        "166": "   * @return result of the update function\n",
        "167": "   */\n",
        "168": "  abstract long fn(long currentValue, long newValue);\n",
        "170": "  /**\n",
        "171": "   * Handles cases of updates involving initialization, resizing, creating new Cells, and/or\n",
        "172": "   * contention. See above for explanation. This method suffers the usual non-modularity problems of\n",
        "173": "   * optimistic retry code, relying on rechecked sets of reads.\n",
        "174": "   *\n",
        "175": "   * @param x the value\n",
        "176": "   * @param hc the hash code holder\n",
        "177": "   * @param wasUncontended false if CAS failed before call\n",
        "178": "   */\n",
        "179": "  final void retryUpdate(long x, int[] hc, boolean wasUncontended) {\n",
        "180": "    int h;\n",
        "181": "    if (hc == null) {\n",
        "182": "      threadHashCode.set(hc = new int[1]); // Initialize randomly\n",
        "183": "      int r = rng.nextInt(); // Avoid zero to allow xorShift rehash\n",
        "184": "      h = hc[0] = (r == 0) ? 1 : r;\n",
        "185": "    } else h = hc[0];\n",
        "186": "    boolean collide = false; // True if last slot nonempty\n",
        "187": "    for (; ; ) {\n",
        "188": "      Cell[] as;\n",
        "189": "      Cell a;\n",
        "190": "      int n;\n",
        "191": "      long v;\n",
        "192": "      if ((as = cells) != null && (n = as.length) > 0) {\n",
        "193": "        if ((a = as[(n - 1) & h]) == null) {\n",
        "194": "          if (busy == 0) { // Try to attach new Cell\n",
        "195": "            Cell r = new Cell(x); // Optimistically create\n",
        "196": "            if (busy == 0 && casBusy()) {\n",
        "197": "              boolean created = false;\n",
        "198": "              try { // Recheck under lock\n",
        "199": "                Cell[] rs;\n",
        "200": "                int m, j;\n",
        "201": "                if ((rs = cells) != null && (m = rs.length) > 0 && rs[j = (m - 1) & h] == null) {\n",
        "202": "                  rs[j] = r;\n",
        "203": "                  created = true;\n",
        "205": "              } finally {\n",
        "206": "                busy = 0;\n",
        "207": "              }\n",
        "208": "              if (created) break;\n",
        "209": "              continue; // Slot is now non-empty\n",
        "211": "          }\n",
        "212": "          collide = false;\n",
        "213": "        } else if (!wasUncontended) // CAS already known to fail\n",
        "214": "        wasUncontended = true; // Continue after rehash\n",
        "215": "        else if (a.cas(v = a.value, fn(v, x))) break;\n",
        "216": "        else if (n >= NCPU || cells != as) collide = false; // At max size or stale\n",
        "217": "        else if (!collide) collide = true;\n",
        "218": "        else if (busy == 0 && casBusy()) {\n",
        "219": "          try {\n",
        "220": "            if (cells == as) { // Expand table unless stale\n",
        "221": "              Cell[] rs = new Cell[n << 1];\n",
        "222": "              for (int i = 0; i < n; ++i) rs[i] = as[i];\n",
        "223": "              cells = rs;\n",
        "225": "          } finally {\n",
        "226": "            busy = 0;\n",
        "227": "          }\n",
        "228": "          collide = false;\n",
        "229": "          continue; // Retry with expanded table\n",
        "231": "        h ^= h << 13; // Rehash\n",
        "232": "        h ^= h >>> 17;\n",
        "233": "        h ^= h << 5;\n",
        "234": "        hc[0] = h; // Record index for next time\n",
        "235": "      } else if (busy == 0 && cells == as && casBusy()) {\n",
        "236": "        boolean init = false;\n",
        "237": "        try { // Initialize table\n",
        "238": "          if (cells == as) {\n",
        "239": "            Cell[] rs = new Cell[2];\n",
        "240": "            rs[h & 1] = new Cell(x);\n",
        "241": "            cells = rs;\n",
        "242": "            init = true;\n",
        "243": "          }\n",
        "244": "        } finally {\n",
        "245": "          busy = 0;\n",
        "246": "        }\n",
        "247": "        if (init) break;\n",
        "248": "      } else if (casBase(v = base, fn(v, x))) break; // Fall back on using base\n",
        "250": "  }\n",
        "252": "  /** Sets base and all cells to the given value. */\n",
        "253": "  final void internalReset(long initialValue) {\n",
        "254": "    Cell[] as = cells;\n",
        "255": "    base = initialValue;\n",
        "256": "    if (as != null) {\n",
        "257": "      int n = as.length;\n",
        "258": "      for (int i = 0; i < n; ++i) {\n",
        "259": "        Cell a = as[i];\n",
        "260": "        if (a != null) a.value = initialValue;\n",
        "261": "      }\n",
        "263": "  }\n",
        "265": "  // Unsafe mechanics\n",
        "266": "  private static final sun.misc.Unsafe UNSAFE;\n",
        "267": "  private static final long baseOffset;\n",
        "268": "  private static final long busyOffset;\n",
        "269": "\n",
        "270": "  static {\n",
        "271": "    try {\n",
        "272": "      UNSAFE = getUnsafe();\n",
        "273": "      Class<?> sk = Striped64.class;\n",
        "274": "      baseOffset = UNSAFE.objectFieldOffset(sk.getDeclaredField(\"base\"));\n",
        "275": "      busyOffset = UNSAFE.objectFieldOffset(sk.getDeclaredField(\"busy\"));\n",
        "276": "    } catch (Exception e) {\n",
        "277": "      throw new Error(e);\n",
        "279": "  }\n",
        "281": "  /**\n",
        "282": "   * Returns a sun.misc.Unsafe. Suitable for use in a 3rd party package. Replace with a simple call\n",
        "283": "   * to Unsafe.getUnsafe when integrating into a jdk.\n",
        "284": "   *\n",
        "285": "   * @return a sun.misc.Unsafe\n",
        "286": "   */\n",
        "287": "  private static sun.misc.Unsafe getUnsafe() {\n",
        "288": "    try {\n",
        "289": "      return sun.misc.Unsafe.getUnsafe();\n",
        "290": "    } catch (SecurityException tryReflectionInstead) {\n",
        "291": "    }\n",
        "292": "    try {\n",
        "293": "      return java.security.AccessController.doPrivileged(\n",
        "294": "          new java.security.PrivilegedExceptionAction<sun.misc.Unsafe>() {\n",
        "295": "            public sun.misc.Unsafe run() throws Exception {\n",
        "296": "              Class<sun.misc.Unsafe> k = sun.misc.Unsafe.class;\n",
        "297": "              for (java.lang.reflect.Field f : k.getDeclaredFields()) {\n",
        "298": "                f.setAccessible(true);\n",
        "299": "                Object x = f.get(null);\n",
        "300": "                if (k.isInstance(x)) return k.cast(x);\n",
        "301": "              }\n",
        "302": "              throw new NoSuchFieldError(\"the Unsafe\");\n",
        "303": "            }\n",
        "304": "          });\n",
        "305": "    } catch (java.security.PrivilegedActionException e) {\n",
        "306": "      throw new RuntimeException(\"Could not initialize intrinsics\", e.getCause());\n",
        "308": "  }\n"
    },
    "removed": {
        "18": " * A package-local class holding common representation and mechanics\n",
        "19": " * for classes supporting dynamic striping on 64bit values. The class\n",
        "20": " * extends Number so that concrete subclasses must publicly do so.\n",
        "24": "    /*\n",
        "25": "     * This class maintains a lazily-initialized table of atomically\n",
        "26": "     * updated variables, plus an extra \"base\" field. The table size\n",
        "27": "     * is a power of two. Indexing uses masked per-thread hash codes.\n",
        "28": "     * Nearly all declarations in this class are package-private,\n",
        "29": "     * accessed directly by subclasses.\n",
        "30": "     *\n",
        "31": "     * Table entries are of class Cell; a variant of AtomicLong padded\n",
        "32": "     * to reduce cache contention on most processors. Padding is\n",
        "33": "     * overkill for most Atomics because they are usually irregularly\n",
        "34": "     * scattered in memory and thus don't interfere much with each\n",
        "35": "     * other. But Atomic objects residing in arrays will tend to be\n",
        "36": "     * placed adjacent to each other, and so will most often share\n",
        "37": "     * cache lines (with a huge negative performance impact) without\n",
        "38": "     * this precaution.\n",
        "39": "     *\n",
        "40": "     * In part because Cells are relatively large, we avoid creating\n",
        "41": "     * them until they are needed.  When there is no contention, all\n",
        "42": "     * updates are made to the base field.  Upon first contention (a\n",
        "43": "     * failed CAS on base update), the table is initialized to size 2.\n",
        "44": "     * The table size is doubled upon further contention until\n",
        "45": "     * reaching the nearest power of two greater than or equal to the\n",
        "46": "     * number of CPUS. Table slots remain empty (null) until they are\n",
        "47": "     * needed.\n",
        "48": "     *\n",
        "49": "     * A single spinlock (\"busy\") is used for initializing and\n",
        "50": "     * resizing the table, as well as populating slots with new Cells.\n",
        "51": "     * There is no need for a blocking lock; when the lock is not\n",
        "52": "     * available, threads try other slots (or the base).  During these\n",
        "53": "     * retries, there is increased contention and reduced locality,\n",
        "54": "     * which is still better than alternatives.\n",
        "55": "     *\n",
        "56": "     * Per-thread hash codes are initialized to random values.\n",
        "57": "     * Contention and/or table collisions are indicated by failed\n",
        "58": "     * CASes when performing an update operation (see method\n",
        "59": "     * retryUpdate). Upon a collision, if the table size is less than\n",
        "60": "     * the capacity, it is doubled in size unless some other thread\n",
        "61": "     * holds the lock. If a hashed slot is empty, and lock is\n",
        "62": "     * available, a new Cell is created. Otherwise, if the slot\n",
        "63": "     * exists, a CAS is tried.  Retries proceed by \"double hashing\",\n",
        "64": "     * using a secondary hash (Marsaglia XorShift) to try to find a\n",
        "65": "     * free slot.\n",
        "66": "     *\n",
        "67": "     * The table size is capped because, when there are more threads\n",
        "68": "     * than CPUs, supposing that each thread were bound to a CPU,\n",
        "69": "     * there would exist a perfect hash function mapping threads to\n",
        "70": "     * slots that eliminates collisions. When we reach capacity, we\n",
        "71": "     * search for this mapping by randomly varying the hash codes of\n",
        "72": "     * colliding threads.  Because search is random, and collisions\n",
        "73": "     * only become known via CAS failures, convergence can be slow,\n",
        "74": "     * and because threads are typically not bound to CPUS forever,\n",
        "75": "     * may not occur at all. However, despite these limitations,\n",
        "76": "     * observed contention rates are typically low in these cases.\n",
        "77": "     *\n",
        "78": "     * It is possible for a Cell to become unused when threads that\n",
        "79": "     * once hashed to it terminate, as well as in the case where\n",
        "80": "     * doubling the table causes no thread to hash to it under\n",
        "81": "     * expanded mask.  We do not try to detect or remove such cells,\n",
        "82": "     * under the assumption that for long-running instances, observed\n",
        "83": "     * contention levels will recur, so the cells will eventually be\n",
        "84": "     * needed again; and for short-lived ones, it does not matter.\n",
        "85": "     */\n",
        "87": "    /**\n",
        "88": "     * Padded variant of AtomicLong supporting only raw accesses plus CAS.\n",
        "89": "     * The value field is placed between pads, hoping that the JVM doesn't\n",
        "90": "     * reorder them.\n",
        "91": "     *\n",
        "92": "     * JVM intrinsics note: It would be possible to use a release-only\n",
        "93": "     * form of CAS here, if it were provided.\n",
        "94": "     */\n",
        "95": "    static final class Cell {\n",
        "96": "        volatile long p0, p1, p2, p3, p4, p5, p6;\n",
        "97": "        volatile long value;\n",
        "98": "        volatile long q0, q1, q2, q3, q4, q5, q6;\n",
        "99": "        Cell(long x) { value = x; }\n",
        "101": "        final boolean cas(long cmp, long val) {\n",
        "102": "            return UNSAFE.compareAndSwapLong(this, valueOffset, cmp, val);\n",
        "103": "        }\n",
        "105": "        // Unsafe mechanics\n",
        "106": "        private static final sun.misc.Unsafe UNSAFE;\n",
        "107": "        private static final long valueOffset;\n",
        "108": "        static {\n",
        "109": "            try {\n",
        "110": "                UNSAFE = getUnsafe();\n",
        "111": "                Class<?> ak = Cell.class;\n",
        "112": "                valueOffset = UNSAFE.objectFieldOffset\n",
        "113": "                    (ak.getDeclaredField(\"value\"));\n",
        "114": "            } catch (Exception e) {\n",
        "115": "                throw new Error(e);\n",
        "116": "            }\n",
        "117": "        }\n",
        "128": "    /**\n",
        "129": "     * Generator of new random hash codes\n",
        "130": "     */\n",
        "131": "    static final Random rng = new Random();\n",
        "133": "    /** Number of CPUS, to place bound on table size */\n",
        "134": "    static final int NCPU = Runtime.getRuntime().availableProcessors();\n",
        "136": "    /**\n",
        "137": "     * Table of cells. When non-null, size is a power of 2.\n",
        "138": "     */\n",
        "139": "    transient volatile Cell[] cells;\n",
        "141": "    /**\n",
        "142": "     * Base value, used mainly when there is no contention, but also as\n",
        "143": "     * a fallback during table initialization races. Updated via CAS.\n",
        "144": "     */\n",
        "145": "    transient volatile long base;\n",
        "147": "    /**\n",
        "148": "     * Spinlock (locked via CAS) used when resizing and/or creating Cells.\n",
        "149": "     */\n",
        "150": "    transient volatile int busy;\n",
        "152": "    /**\n",
        "153": "     * Package-private default constructor\n",
        "154": "     */\n",
        "155": "    Striped64() {\n",
        "156": "    }\n",
        "158": "    /**\n",
        "159": "     * CASes the base field.\n",
        "160": "     */\n",
        "161": "    final boolean casBase(long cmp, long val) {\n",
        "162": "        return UNSAFE.compareAndSwapLong(this, baseOffset, cmp, val);\n",
        "163": "    }\n",
        "165": "    /**\n",
        "166": "     * CASes the busy field from 0 to 1 to acquire lock.\n",
        "167": "     */\n",
        "168": "    final boolean casBusy() {\n",
        "169": "        return UNSAFE.compareAndSwapInt(this, busyOffset, 0, 1);\n",
        "170": "    }\n",
        "172": "    /**\n",
        "173": "     * Computes the function of current and new value. Subclasses\n",
        "174": "     * should open-code this update function for most uses, but the\n",
        "175": "     * virtualized form is needed within retryUpdate.\n",
        "176": "     *\n",
        "177": "     * @param currentValue the current value (of either base or a cell)\n",
        "178": "     * @param newValue the argument from a user update call\n",
        "179": "     * @return result of the update function\n",
        "180": "     */\n",
        "181": "    abstract long fn(long currentValue, long newValue);\n",
        "183": "    /**\n",
        "184": "     * Handles cases of updates involving initialization, resizing,\n",
        "185": "     * creating new Cells, and/or contention. See above for\n",
        "186": "     * explanation. This method suffers the usual non-modularity\n",
        "187": "     * problems of optimistic retry code, relying on rechecked sets of\n",
        "188": "     * reads.\n",
        "189": "     *\n",
        "190": "     * @param x the value\n",
        "191": "     * @param hc the hash code holder\n",
        "192": "     * @param wasUncontended false if CAS failed before call\n",
        "193": "     */\n",
        "194": "    final void retryUpdate(long x, int[] hc, boolean wasUncontended) {\n",
        "195": "        int h;\n",
        "196": "        if (hc == null) {\n",
        "197": "            threadHashCode.set(hc = new int[1]); // Initialize randomly\n",
        "198": "            int r = rng.nextInt(); // Avoid zero to allow xorShift rehash\n",
        "199": "            h = hc[0] = (r == 0) ? 1 : r;\n",
        "200": "        }\n",
        "201": "        else\n",
        "202": "            h = hc[0];\n",
        "203": "        boolean collide = false;                // True if last slot nonempty\n",
        "204": "        for (;;) {\n",
        "205": "            Cell[] as; Cell a; int n; long v;\n",
        "206": "            if ((as = cells) != null && (n = as.length) > 0) {\n",
        "207": "                if ((a = as[(n - 1) & h]) == null) {\n",
        "208": "                    if (busy == 0) {            // Try to attach new Cell\n",
        "209": "                        Cell r = new Cell(x);   // Optimistically create\n",
        "210": "                        if (busy == 0 && casBusy()) {\n",
        "211": "                            boolean created = false;\n",
        "212": "                            try {               // Recheck under lock\n",
        "213": "                                Cell[] rs; int m, j;\n",
        "214": "                                if ((rs = cells) != null &&\n",
        "215": "                                    (m = rs.length) > 0 &&\n",
        "216": "                                    rs[j = (m - 1) & h] == null) {\n",
        "217": "                                    rs[j] = r;\n",
        "218": "                                    created = true;\n",
        "219": "                                }\n",
        "220": "                            } finally {\n",
        "221": "                                busy = 0;\n",
        "222": "                            }\n",
        "223": "                            if (created)\n",
        "224": "                                break;\n",
        "225": "                            continue;           // Slot is now non-empty\n",
        "226": "                        }\n",
        "227": "                    }\n",
        "228": "                    collide = false;\n",
        "229": "                }\n",
        "230": "                else if (!wasUncontended)       // CAS already known to fail\n",
        "231": "                    wasUncontended = true;      // Continue after rehash\n",
        "232": "                else if (a.cas(v = a.value, fn(v, x)))\n",
        "233": "                    break;\n",
        "234": "                else if (n >= NCPU || cells != as)\n",
        "235": "                    collide = false;            // At max size or stale\n",
        "236": "                else if (!collide)\n",
        "237": "                    collide = true;\n",
        "238": "                else if (busy == 0 && casBusy()) {\n",
        "239": "                    try {\n",
        "240": "                        if (cells == as) {      // Expand table unless stale\n",
        "241": "                            Cell[] rs = new Cell[n << 1];\n",
        "242": "                            for (int i = 0; i < n; ++i)\n",
        "243": "                                rs[i] = as[i];\n",
        "244": "                            cells = rs;\n",
        "245": "                        }\n",
        "246": "                    } finally {\n",
        "247": "                        busy = 0;\n",
        "248": "                    }\n",
        "249": "                    collide = false;\n",
        "250": "                    continue;                   // Retry with expanded table\n",
        "252": "                h ^= h << 13;                   // Rehash\n",
        "253": "                h ^= h >>> 17;\n",
        "254": "                h ^= h << 5;\n",
        "255": "                hc[0] = h;                      // Record index for next time\n",
        "257": "            else if (busy == 0 && cells == as && casBusy()) {\n",
        "258": "                boolean init = false;\n",
        "259": "                try {                           // Initialize table\n",
        "260": "                    if (cells == as) {\n",
        "261": "                        Cell[] rs = new Cell[2];\n",
        "262": "                        rs[h & 1] = new Cell(x);\n",
        "263": "                        cells = rs;\n",
        "264": "                        init = true;\n",
        "265": "                    }\n",
        "266": "                } finally {\n",
        "267": "                    busy = 0;\n",
        "268": "                }\n",
        "269": "                if (init)\n",
        "270": "                    break;\n",
        "272": "            else if (casBase(v = base, fn(v, x)))\n",
        "273": "                break;                          // Fall back on using base\n",
        "277": "    /**\n",
        "278": "     * Sets base and all cells to the given value.\n",
        "279": "     */\n",
        "280": "    final void internalReset(long initialValue) {\n",
        "281": "        Cell[] as = cells;\n",
        "282": "        base = initialValue;\n",
        "283": "        if (as != null) {\n",
        "284": "            int n = as.length;\n",
        "285": "            for (int i = 0; i < n; ++i) {\n",
        "286": "                Cell a = as[i];\n",
        "287": "                if (a != null)\n",
        "288": "                    a.value = initialValue;\n",
        "289": "            }\n",
        "290": "        }\n",
        "293": "    // Unsafe mechanics\n",
        "294": "    private static final sun.misc.Unsafe UNSAFE;\n",
        "295": "    private static final long baseOffset;\n",
        "296": "    private static final long busyOffset;\n",
        "297": "    static {\n",
        "298": "        try {\n",
        "299": "            UNSAFE = getUnsafe();\n",
        "300": "            Class<?> sk = Striped64.class;\n",
        "301": "            baseOffset = UNSAFE.objectFieldOffset\n",
        "302": "                (sk.getDeclaredField(\"base\"));\n",
        "303": "            busyOffset = UNSAFE.objectFieldOffset\n",
        "304": "                (sk.getDeclaredField(\"busy\"));\n",
        "305": "        } catch (Exception e) {\n",
        "306": "            throw new Error(e);\n",
        "307": "        }\n",
        "310": "    /**\n",
        "311": "     * Returns a sun.misc.Unsafe.  Suitable for use in a 3rd party package.\n",
        "312": "     * Replace with a simple call to Unsafe.getUnsafe when integrating\n",
        "313": "     * into a jdk.\n",
        "314": "     *\n",
        "315": "     * @return a sun.misc.Unsafe\n",
        "316": "     */\n",
        "317": "    private static sun.misc.Unsafe getUnsafe() {\n",
        "318": "        try {\n",
        "319": "            return sun.misc.Unsafe.getUnsafe();\n",
        "320": "        } catch (SecurityException tryReflectionInstead) {}\n",
        "321": "        try {\n",
        "322": "            return java.security.AccessController.doPrivileged\n",
        "323": "            (new java.security.PrivilegedExceptionAction<sun.misc.Unsafe>() {\n",
        "324": "                public sun.misc.Unsafe run() throws Exception {\n",
        "325": "                    Class<sun.misc.Unsafe> k = sun.misc.Unsafe.class;\n",
        "326": "                    for (java.lang.reflect.Field f : k.getDeclaredFields()) {\n",
        "327": "                        f.setAccessible(true);\n",
        "328": "                        Object x = f.get(null);\n",
        "329": "                        if (k.isInstance(x))\n",
        "330": "                            return k.cast(x);\n",
        "331": "                    }\n",
        "332": "                    throw new NoSuchFieldError(\"the Unsafe\");\n",
        "333": "                }});\n",
        "334": "        } catch (java.security.PrivilegedActionException e) {\n",
        "335": "            throw new RuntimeException(\"Could not initialize intrinsics\",\n",
        "336": "                                       e.getCause());\n",
        "337": "        }\n"
    }
}