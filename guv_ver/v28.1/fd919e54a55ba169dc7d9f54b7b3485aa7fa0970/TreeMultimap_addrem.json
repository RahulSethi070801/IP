{
    "addition": {
        "36": " * Implementation of {@code Multimap} whose keys and values are ordered by their natural ordering or\n",
        "37": " * by supplied comparators. In all cases, this implementation uses {@link Comparable#compareTo} or\n",
        "38": " * {@link Comparator#compare} instead of {@link Object#equals} to determine equivalence of\n",
        "39": " * instances.\n",
        "41": " * <p><b>Warning:</b> The comparators or comparables used must be <i>consistent with equals</i> as\n",
        "42": " * explained by the {@link Comparable} class specification. Otherwise, the resulting multiset will\n",
        "43": " * violate the general contract of {@link SetMultimap}, which it is specified in terms of {@link\n",
        "44": " * Object#equals}.\n",
        "46": " * <p>The collections returned by {@code keySet} and {@code asMap} iterate through the keys\n",
        "47": " * according to the key comparator ordering or the natural ordering of the keys. Similarly, {@code\n",
        "48": " * get}, {@code removeAll}, and {@code replaceValues} return collections that iterate through the\n",
        "49": " * values according to the value comparator ordering or the natural ordering of the values. The\n",
        "50": " * collections generated by {@code entries}, {@code keys}, and {@code values} iterate across the\n",
        "51": " * keys according to the above key ordering, and for each key they iterate across the values\n",
        "52": " * according to the value ordering.\n",
        "54": " * <p>The multimap does not store duplicate key-value pairs. Adding a new key-value pair equal to an\n",
        "55": " * existing key-value pair has no effect.\n",
        "57": " * <p>Null keys and values are permitted (provided, of course, that the respective comparators\n",
        "58": " * support them). All optional multimap methods are supported, and all returned views are\n",
        "59": " * modifiable.\n",
        "61": " * <p>This class is not threadsafe when any concurrent operations update the multimap. Concurrent\n",
        "62": " * read operations will work correctly. To allow concurrent update operations, wrap your multimap\n",
        "63": " * with a call to {@link Multimaps#synchronizedSortedSetMultimap}.\n",
        "66": " * \"https://github.com/google/guava/wiki/NewCollectionTypesExplained#multimap\"> {@code\n",
        "67": " * Multimap}</a>.\n",
        "79": "   * Creates an empty {@code TreeMultimap} ordered by the natural ordering of its keys and values.\n",
        "86": "   * Creates an empty {@code TreeMultimap} instance using explicit comparators. Neither comparator\n",
        "87": "   * may be null; use {@link Ordering#natural()} to specify natural order.\n",
        "98": "   * Constructs a {@code TreeMultimap}, ordered by the natural ordering of its keys and values, with\n",
        "99": "   * the same mappings as the specified multimap.\n",
        "127": "   * @return a new {@code TreeSet} containing a collection of values for one key\n",
        "157": "  /** @since 14.0 (present with return type {@code SortedSet} since 2.0) */\n",
        "167": "   * <p>Because a {@code TreeMultimap} has unique sorted keys, this method returns a {@link\n",
        "168": "   * NavigableSet}, instead of the {@link java.util.Set} specified in the {@link Multimap}\n",
        "169": "   * interface.\n",
        "181": "   * <p>Because a {@code TreeMultimap} has unique sorted keys, this method returns a {@link\n",
        "182": "   * NavigableMap}, instead of the {@link java.util.Map} specified in the {@link Multimap}\n",
        "183": "   * interface.\n",
        "193": "   * @serialData key comparator, value comparator, number of distinct keys, and then for each\n",
        "194": "   *     distinct key: the key, number of values for that key, and key values\n"
    },
    "removed": {
        "36": " * Implementation of {@code Multimap} whose keys and values are ordered by\n",
        "37": " * their natural ordering or by supplied comparators. In all cases, this\n",
        "38": " * implementation uses {@link Comparable#compareTo} or {@link\n",
        "39": " * Comparator#compare} instead of {@link Object#equals} to determine\n",
        "40": " * equivalence of instances.\n",
        "42": " * <p><b>Warning:</b> The comparators or comparables used must be <i>consistent\n",
        "43": " * with equals</i> as explained by the {@link Comparable} class specification.\n",
        "44": " * Otherwise, the resulting multiset will violate the general contract of {@link\n",
        "45": " * SetMultimap}, which it is specified in terms of {@link Object#equals}.\n",
        "47": " * <p>The collections returned by {@code keySet} and {@code asMap} iterate\n",
        "48": " * through the keys according to the key comparator ordering or the natural\n",
        "49": " * ordering of the keys. Similarly, {@code get}, {@code removeAll}, and {@code\n",
        "50": " * replaceValues} return collections that iterate through the values according\n",
        "51": " * to the value comparator ordering or the natural ordering of the values. The\n",
        "52": " * collections generated by {@code entries}, {@code keys}, and {@code values}\n",
        "53": " * iterate across the keys according to the above key ordering, and for each\n",
        "54": " * key they iterate across the values according to the value ordering.\n",
        "56": " * <p>The multimap does not store duplicate key-value pairs. Adding a new\n",
        "57": " * key-value pair equal to an existing key-value pair has no effect.\n",
        "59": " * <p>Null keys and values are permitted (provided, of course, that the\n",
        "60": " * respective comparators support them). All optional multimap methods are\n",
        "61": " * supported, and all returned views are modifiable.\n",
        "63": " * <p>This class is not threadsafe when any concurrent operations update the\n",
        "64": " * multimap. Concurrent read operations will work correctly. To allow concurrent\n",
        "65": " * update operations, wrap your multimap with a call to {@link\n",
        "66": " * Multimaps#synchronizedSortedSetMultimap}.\n",
        "69": " * \"https://github.com/google/guava/wiki/NewCollectionTypesExplained#multimap\">\n",
        "70": " * {@code Multimap}</a>.\n",
        "82": "   * Creates an empty {@code TreeMultimap} ordered by the natural ordering of\n",
        "83": "   * its keys and values.\n",
        "90": "   * Creates an empty {@code TreeMultimap} instance using explicit comparators.\n",
        "91": "   * Neither comparator may be null; use {@link Ordering#natural()} to specify\n",
        "92": "   * natural order.\n",
        "103": "   * Constructs a {@code TreeMultimap}, ordered by the natural ordering of its\n",
        "104": "   * keys and values, with the same mappings as the specified multimap.\n",
        "132": "   * @return a new {@code TreeSet} containing a collection of values for one\n",
        "133": "   *     key\n",
        "163": "  /**\n",
        "164": "   * @since 14.0 (present with return type {@code SortedSet} since 2.0)\n",
        "165": "   */\n",
        "175": "   * <p>Because a {@code TreeMultimap} has unique sorted keys, this method\n",
        "176": "   * returns a {@link NavigableSet}, instead of the {@link java.util.Set} specified\n",
        "177": "   * in the {@link Multimap} interface.\n",
        "189": "   * <p>Because a {@code TreeMultimap} has unique sorted keys, this method\n",
        "190": "   * returns a {@link NavigableMap}, instead of the {@link java.util.Map} specified\n",
        "191": "   * in the {@link Multimap} interface.\n",
        "201": "   * @serialData key comparator, value comparator, number of distinct keys, and\n",
        "202": "   *     then for each distinct key: the key, number of values for that key, and\n",
        "203": "   *     key values\n"
    }
}