{
    "addition": {
        "60": "   * SoftValueReference (and not a LoadingValueReference), and throws an IllegalStateException if\n",
        "61": "   * that assumption does not hold.\n",
        "63": "  @SuppressWarnings(\"unchecked\") // the instanceof check and the cast generate this warning\n",
        "82": "  @SuppressWarnings(\"unchecked\") // the instanceof check and the cast generate this warning\n",
        "101": "   * Forces the segment containing the given {@code key} to expand (see {@link Segment#expand()}.\n",
        "120": "    throw new IllegalArgumentException(\n",
        "121": "        \"Cache of type \" + cache.getClass() + \" doesn't have a LocalCache.\");\n",
        "125": "   * Determines whether the given cache can be converted to a LocalCache by {@link #toLocalCache}\n",
        "126": "   * without throwing an exception.\n",
        "183": "   * contains a non-null key and value, and the eviction and expiration queues are consistent (see\n",
        "184": "   * {@link #checkEviction}, {@link #checkExpiration}).\n",
        "213": "   * that the next/prev links in the expiration queue are correct, and that the queue is ordered by\n",
        "214": "   * expiration time.\n",
        "256": "            assertTrue(\n",
        "257": "                prev.getAccessTime() <= current.getAccessTime()\n",
        "258": "                    || prev.getAccessTime() - current.getAccessTime() < 1000);\n",
        "274": "   * Peeks into the cache's internals to verify that its eviction queue is consistent. Verifies that\n",
        "275": "   * the prev/next links are correct, and that all items in each segment are also in that segment's\n",
        "276": "   * eviction (recency) queue.\n",
        "376": "   * eviction queue. It will invoke the given {@code operation} on the first element in the eviction\n",
        "377": "   * queue, and then reverify that all items in the cache are in the eviction queue, and verify that\n",
        "378": "   * the head of the eviction queue has changed as a result of the operation.\n",
        "380": "  static void checkRecency(\n",
        "381": "      LoadingCache<Integer, Integer> cache,\n",
        "382": "      int maxSize,\n",
        "405": "  /** Warms the given cache by getting all values in {@code [start, end)}, in order. */\n",
        "418": "  static void expireEntries(LocalCache<?, ?> cchm, long expiringTime, FakeTicker ticker) {\n"
    },
    "removed": {
        "60": "   * SoftValueReference (and not a LoadingValueReference), and throws an IllegalStateException\n",
        "61": "   * if that assumption does not hold.\n",
        "63": "  @SuppressWarnings(\"unchecked\")  // the instanceof check and the cast generate this warning\n",
        "82": "  @SuppressWarnings(\"unchecked\")  // the instanceof check and the cast generate this warning\n",
        "101": "   * Forces the segment containing the given {@code key} to expand (see\n",
        "102": "   * {@link Segment#expand()}.\n",
        "121": "    throw new IllegalArgumentException(\"Cache of type \" + cache.getClass()\n",
        "122": "        + \" doesn't have a LocalCache.\");\n",
        "126": "   * Determines whether the given cache can be converted to a LocalCache by\n",
        "127": "   * {@link #toLocalCache} without throwing an exception.\n",
        "184": "   * contains a non-null key and value, and the eviction and expiration queues are consistent\n",
        "185": "   * (see {@link #checkEviction}, {@link #checkExpiration}).\n",
        "214": "   * that the next/prev links in the expiration queue are correct, and that the queue is ordered\n",
        "215": "   * by expiration time.\n",
        "257": "            assertTrue(prev.getAccessTime() <= current.getAccessTime()\n",
        "258": "                || prev.getAccessTime() - current.getAccessTime() < 1000);\n",
        "274": "   * Peeks into the cache's internals to verify that its eviction queue is consistent. Verifies\n",
        "275": "   * that the prev/next links are correct, and that all items in each segment are also in that\n",
        "276": "   * segment's eviction (recency) queue.\n",
        "376": "   * eviction queue. It will invoke the given {@code operation} on the first element in the\n",
        "377": "   * eviction queue, and then reverify that all items in the cache are in the eviction queue, and\n",
        "378": "   * verify that the head of the eviction queue has changed as a result of the operation.\n",
        "380": "  static void checkRecency(LoadingCache<Integer, Integer> cache, int maxSize,\n",
        "403": "  /**\n",
        "404": "   * Warms the given cache by getting all values in {@code [start, end)}, in order.\n",
        "405": "   */\n",
        "418": "  static void expireEntries(\n",
        "419": "      LocalCache<?, ?> cchm, long expiringTime, FakeTicker ticker) {\n"
    }
}