{
    "addition": {
        "74": " * Static utility methods pertaining to {@link Map} instances (including instances of {@link\n",
        "75": " * SortedMap}, {@link BiMap}, etc.). Also see this class's counterparts {@link Lists}, {@link Sets}\n",
        "76": " * and {@link Queues}.\n",
        "79": " * \"https://github.com/google/guava/wiki/CollectionUtilitiesExplained#maps\"> {@code Maps}</a>.\n",
        "127": "   * Returns an immutable map instance containing the given entries. Internally, the returned map\n",
        "128": "   * will be backed by an {@link EnumMap}.\n",
        "130": "   * <p>The iteration order of the returned map follows the enum's iteration order, not the order in\n",
        "131": "   * which the elements appear in the given map.\n",
        "207": "   * java.util.function.Function) Collectors.toMap(Function, Function)}, which throws an {@code\n",
        "208": "   * IllegalStateException}.)\n",
        "268": "   * <p><b>Note:</b> if mutability is not required, use {@link ImmutableMap#of()} instead.\n",
        "270": "   * <p><b>Note:</b> if {@code K} is an {@code enum} type, use {@link #newEnumMap} instead.\n",
        "272": "   * <p><b>Note for Java 7 and later:</b> this method is now unnecessary and should be treated as\n",
        "273": "   * deprecated. Instead, use the {@code HashMap} constructor directly, taking advantage of the new\n",
        "283": "   * Creates a {@code HashMap} instance, with a high enough \"initial capacity\" that it <i>should</i>\n",
        "284": "   * hold {@code expectedSize} elements without growth. This behavior cannot be broadly guaranteed,\n",
        "285": "   * but it is observed to be true for OpenJDK 1.7. It also can't be guaranteed that the method\n",
        "286": "   * isn't inadvertently <i>oversizing</i> the returned map.\n",
        "287": "   *\n",
        "288": "   * @param expectedSize the number of entries you expect to add to the returned map\n",
        "289": "   * @return a new, empty {@code HashMap} with enough capacity to hold {@code expectedSize} entries\n",
        "290": "   *     without resizing\n",
        "316": "   * Creates a <i>mutable</i> {@code HashMap} instance with the same mappings as the specified map.\n",
        "318": "   * <p><b>Note:</b> if mutability is not required, use {@link ImmutableMap#copyOf(Map)} instead.\n",
        "320": "   * <p><b>Note:</b> if {@code K} is an {@link Enum} type, use {@link #newEnumMap} instead.\n",
        "322": "   * <p><b>Note for Java 7 and later:</b> this method is now unnecessary and should be treated as\n",
        "323": "   * deprecated. Instead, use the {@code HashMap} constructor directly, taking advantage of the new\n",
        "327": "   * @return a new {@code HashMap} initialized with the mappings from {@code map}\n",
        "334": "   * Creates a <i>mutable</i>, empty, insertion-ordered {@code LinkedHashMap} instance.\n",
        "336": "   * <p><b>Note:</b> if mutability is not required, use {@link ImmutableMap#of()} instead.\n",
        "338": "   * <p><b>Note for Java 7 and later:</b> this method is now unnecessary and should be treated as\n",
        "339": "   * deprecated. Instead, use the {@code LinkedHashMap} constructor directly, taking advantage of\n",
        "340": "   * the new <a href=\"http://goo.gl/iz2Wi\">\"diamond\" syntax</a>.\n",
        "349": "   * Creates a {@code LinkedHashMap} instance, with a high enough \"initial capacity\" that it\n",
        "350": "   * <i>should</i> hold {@code expectedSize} elements without growth. This behavior cannot be\n",
        "351": "   * broadly guaranteed, but it is observed to be true for OpenJDK 1.7. It also can't be guaranteed\n",
        "354": "   * @param expectedSize the number of entries you expect to add to the returned map\n",
        "355": "   * @return a new, empty {@code LinkedHashMap} with enough capacity to hold {@code expectedSize}\n",
        "356": "   *     entries without resizing\n",
        "365": "   * Creates a <i>mutable</i>, insertion-ordered {@code LinkedHashMap} instance with the same\n",
        "366": "   * mappings as the specified map.\n",
        "368": "   * <p><b>Note:</b> if mutability is not required, use {@link ImmutableMap#copyOf(Map)} instead.\n",
        "370": "   * <p><b>Note for Java 7 and later:</b> this method is now unnecessary and should be treated as\n",
        "371": "   * deprecated. Instead, use the {@code LinkedHashMap} constructor directly, taking advantage of\n",
        "372": "   * the new <a href=\"http://goo.gl/iz2Wi\">\"diamond\" syntax</a>.\n",
        "375": "   * @return a new, {@code LinkedHashMap} initialized with the mappings from {@code map}\n",
        "391": "   * Creates a <i>mutable</i>, empty {@code TreeMap} instance using the natural ordering of its\n",
        "392": "   * elements.\n",
        "394": "   * <p><b>Note:</b> if mutability is not required, use {@link ImmutableSortedMap#of()} instead.\n",
        "396": "   * <p><b>Note for Java 7 and later:</b> this method is now unnecessary and should be treated as\n",
        "397": "   * deprecated. Instead, use the {@code TreeMap} constructor directly, taking advantage of the new\n",
        "407": "   * Creates a <i>mutable</i> {@code TreeMap} instance with the same mappings as the specified map\n",
        "408": "   * and using the same ordering as the specified map.\n",
        "413": "   * <p><b>Note for Java 7 and later:</b> this method is now unnecessary and should be treated as\n",
        "414": "   * deprecated. Instead, use the {@code TreeMap} constructor directly, taking advantage of the new\n",
        "417": "   * @param map the sorted map whose mappings are to be placed in the new map and whose comparator\n",
        "418": "   *     is to be used to sort the new map\n",
        "419": "   * @return a new {@code TreeMap} initialized with the mappings from {@code map} and using the\n",
        "420": "   *     comparator of {@code map}\n",
        "427": "   * Creates a <i>mutable</i>, empty {@code TreeMap} instance using the given comparator.\n",
        "432": "   * <p><b>Note for Java 7 and later:</b> this method is now unnecessary and should be treated as\n",
        "433": "   * deprecated. Instead, use the {@code TreeMap} constructor directly, taking advantage of the new\n",
        "461": "   * <p><b>Note for Java 7 and later:</b> this method is now unnecessary and should be treated as\n",
        "462": "   * deprecated. Instead, use the {@code EnumMap} constructor directly, taking advantage of the new\n",
        "466": "   * @return a new {@code EnumMap} initialized with the mappings from {@code map}\n",
        "467": "   * @throws IllegalArgumentException if {@code m} is not an {@code EnumMap} instance and contains\n",
        "468": "   *     no mappings\n",
        "477": "   * <p><b>Note for Java 7 and later:</b> this method is now unnecessary and should be treated as\n",
        "478": "   * deprecated. Instead, use the {@code IdentityHashMap} constructor directly, taking advantage of\n",
        "479": "   * the new <a href=\"http://goo.gl/iz2Wi\">\"diamond\" syntax</a>.\n",
        "488": "   * Computes the difference between two maps. This difference is an immutable snapshot of the state\n",
        "489": "   * of the maps at the time this method is called. It will never change, even if the maps change at\n",
        "490": "   * a later time.\n",
        "492": "   * <p>Since this method uses {@code HashMap} instances internally, the keys of the supplied maps\n",
        "493": "   * must be well-behaved with respect to {@link Object#equals} and {@link Object#hashCode}.\n",
        "495": "   * <p><b>Note:</b>If you only need to know whether two maps have the same mappings, call {@code\n",
        "496": "   * left.equals(right)} instead of this method.\n",
        "513": "   * Computes the difference between two maps. This difference is an immutable snapshot of the state\n",
        "514": "   * of the maps at the time this method is called. It will never change, even if the maps change at\n",
        "515": "   * a later time.\n",
        "517": "   * <p>Since this method uses {@code HashMap} instances internally, the keys of the supplied maps\n",
        "518": "   * must be well-behaved with respect to {@link Object#equals} and {@link Object#hashCode}.\n",
        "522": "   * @param valueEquivalence the equivalence relationship to use to compare values\n",
        "700": "   * Computes the difference between two sorted maps, using the comparator of the left map, or\n",
        "701": "   * {@code Ordering.natural()} if the left map uses the natural ordering of its elements. This\n",
        "702": "   * difference is an immutable snapshot of the state of the maps at the time this method is called.\n",
        "703": "   * It will never change, even if the maps change at a later time.\n",
        "705": "   * <p>Since this method uses {@code TreeMap} instances internally, the keys of the right map must\n",
        "706": "   * all compare as distinct according to the comparator of the left map.\n",
        "708": "   * <p><b>Note:</b>If you only need to know whether two sorted maps have the same mappings, call\n",
        "709": "   * {@code left.equals(right)} instead of this method.\n",
        "762": "   * Returns the specified comparator if not null; otherwise returns {@code Ordering.natural()}.\n",
        "763": "   * This method is an abomination of generics; the only purpose of this method is to contain the\n",
        "764": "   * ugly type-casting in one place.\n",
        "775": "   * Returns a live {@link Map} view whose keys are the contents of {@code set} and whose values are\n",
        "776": "   * computed on demand using {@code function}. To get an immutable <i>copy</i> instead, use {@link\n",
        "777": "   * #toMap(Iterable, Function)}.\n",
        "778": "   *\n",
        "779": "   * <p>Specifically, for each {@code k} in the backing set, the returned map has an entry mapping\n",
        "780": "   * {@code k} to {@code function.apply(k)}. The {@code keySet}, {@code values}, and {@code\n",
        "781": "   * entrySet} views of the returned map iterate in the same order as the backing set.\n",
        "782": "   *\n",
        "783": "   * <p>Modifications to the backing set are read through to the returned map. The returned map\n",
        "784": "   * supports removal operations if the backing set does. Removal operations write through to the\n",
        "785": "   * backing set. The returned map does not support put operations.\n",
        "786": "   *\n",
        "787": "   * <p><b>Warning:</b> If the function rejects {@code null}, caution is required to make sure the\n",
        "788": "   * set does not contain {@code null}, because the view cannot stop {@code null} from being added\n",
        "789": "   * to the set.\n",
        "790": "   *\n",
        "791": "   * <p><b>Warning:</b> This method assumes that for any instance {@code k} of key type {@code K},\n",
        "792": "   * {@code k.equals(k2)} implies that {@code k2} is also of type {@code K}. Using a key type for\n",
        "793": "   * which this may not hold, such as {@code ArrayList}, may risk a {@code ClassCastException} when\n",
        "794": "   * calling methods on the resulting map view.\n",
        "803": "   * Returns a view of the sorted set as a map, mapping keys from the set according to the specified\n",
        "804": "   * function.\n",
        "806": "   * <p>Specifically, for each {@code k} in the backing set, the returned map has an entry mapping\n",
        "807": "   * {@code k} to {@code function.apply(k)}. The {@code keySet}, {@code values}, and {@code\n",
        "808": "   * entrySet} views of the returned map iterate in the same order as the backing set.\n",
        "810": "   * <p>Modifications to the backing set are read through to the returned map. The returned map\n",
        "811": "   * supports removal operations if the backing set does. Removal operations write through to the\n",
        "812": "   * backing set. The returned map does not support put operations.\n",
        "814": "   * <p><b>Warning:</b> If the function rejects {@code null}, caution is required to make sure the\n",
        "815": "   * set does not contain {@code null}, because the view cannot stop {@code null} from being added\n",
        "816": "   * to the set.\n",
        "818": "   * <p><b>Warning:</b> This method assumes that for any instance {@code k} of key type {@code K},\n",
        "819": "   * {@code k.equals(k2)} implies that {@code k2} is also of type {@code K}. Using a key type for\n",
        "820": "   * which this may not hold, such as {@code ArrayList}, may risk a {@code ClassCastException} when\n",
        "821": "   * calling methods on the resulting map view.\n",
        "830": "   * Returns a view of the navigable set as a map, mapping keys from the set according to the\n",
        "831": "   * specified function.\n",
        "833": "   * <p>Specifically, for each {@code k} in the backing set, the returned map has an entry mapping\n",
        "834": "   * {@code k} to {@code function.apply(k)}. The {@code keySet}, {@code values}, and {@code\n",
        "835": "   * entrySet} views of the returned map iterate in the same order as the backing set.\n",
        "837": "   * <p>Modifications to the backing set are read through to the returned map. The returned map\n",
        "838": "   * supports removal operations if the backing set does. Removal operations write through to the\n",
        "839": "   * backing set. The returned map does not support put operations.\n",
        "841": "   * <p><b>Warning:</b> If the function rejects {@code null}, caution is required to make sure the\n",
        "842": "   * set does not contain {@code null}, because the view cannot stop {@code null} from being added\n",
        "843": "   * to the set.\n",
        "845": "   * <p><b>Warning:</b> This method assumes that for any instance {@code k} of key type {@code K},\n",
        "846": "   * {@code k.equals(k2)} implies that {@code k2} is also of type {@code K}. Using a key type for\n",
        "847": "   * which this may not hold, such as {@code ArrayList}, may risk a {@code ClassCastException} when\n",
        "848": "   * calling methods on the resulting map view.\n",
        "1212": "   * Returns an immutable map whose keys are the distinct elements of {@code keys} and whose value\n",
        "1213": "   * for each key was computed by {@code valueFunction}. The map's iteration order is the order of\n",
        "1214": "   * the first appearance of each key in {@code keys}.\n",
        "1215": "   *\n",
        "1216": "   * <p>When there are multiple instances of a key in {@code keys}, it is unspecified whether {@code\n",
        "1217": "   * valueFunction} will be applied to more than one instance of that key and, if it is, which\n",
        "1218": "   * result will be mapped to that key in the returned map.\n",
        "1219": "   *\n",
        "1220": "   * <p>If {@code keys} is a {@link Set}, a live view can be obtained instead of a copy using {@link\n",
        "1221": "   * Maps#asMap(Set, Function)}.\n",
        "1222": "   *\n",
        "1223": "   * @throws NullPointerException if any element of {@code keys} is {@code null}, or if {@code\n",
        "1224": "   *     valueFunction} produces {@code null} for any key\n",
        "1233": "   * Returns an immutable map whose keys are the distinct elements of {@code keys} and whose value\n",
        "1234": "   * for each key was computed by {@code valueFunction}. The map's iteration order is the order of\n",
        "1235": "   * the first appearance of each key in {@code keys}.\n",
        "1236": "   *\n",
        "1237": "   * <p>When there are multiple instances of a key in {@code keys}, it is unspecified whether {@code\n",
        "1238": "   * valueFunction} will be applied to more than one instance of that key and, if it is, which\n",
        "1239": "   * result will be mapped to that key in the returned map.\n",
        "1240": "   *\n",
        "1241": "   * @throws NullPointerException if any element of {@code keys} is {@code null}, or if {@code\n",
        "1242": "   *     valueFunction} produces {@code null} for any key\n",
        "1258": "   * Returns a map with the given {@code values}, indexed by keys derived from those values. In\n",
        "1259": "   * other words, each input value produces an entry in the map whose key is the result of applying\n",
        "1260": "   * {@code keyFunction} to that value. These entries appear in the same order as the input values.\n",
        "1261": "   * Example usage:\n",
        "1263": "   * <pre>{@code\n",
        "1264": "   * Color red = new Color(\"red\", 255, 0, 0);\n",
        "1265": "   * ...\n",
        "1266": "   * ImmutableSet<Color> allColors = ImmutableSet.of(red, green, blue);\n",
        "1268": "   * Map<String, Color> colorForName =\n",
        "1269": "   *     uniqueIndex(allColors, toStringFunction());\n",
        "1270": "   * assertThat(colorForName).containsEntry(\"red\", red);\n",
        "1271": "   * }</pre>\n",
        "1278": "   * @return a map mapping the result of evaluating the function {@code keyFunction} on each value\n",
        "1279": "   *     in the input collection to that value\n",
        "1280": "   * @throws IllegalArgumentException if {@code keyFunction} produces the same key for more than one\n",
        "1281": "   *     value in the input collection\n",
        "1282": "   * @throws NullPointerException if any element of {@code values} is {@code null}, or if {@code\n",
        "1283": "   *     keyFunction} produces {@code null} for any value\n",
        "1293": "   * Returns a map with the given {@code values}, indexed by keys derived from those values. In\n",
        "1294": "   * other words, each input value produces an entry in the map whose key is the result of applying\n",
        "1295": "   * {@code keyFunction} to that value. These entries appear in the same order as the input values.\n",
        "1296": "   * Example usage:\n",
        "1298": "   * <pre>{@code\n",
        "1299": "   * Color red = new Color(\"red\", 255, 0, 0);\n",
        "1300": "   * ...\n",
        "1301": "   * Iterator<Color> allColors = ImmutableSet.of(red, green, blue).iterator();\n",
        "1303": "   * Map<String, Color> colorForName =\n",
        "1304": "   *     uniqueIndex(allColors, toStringFunction());\n",
        "1305": "   * assertThat(colorForName).containsEntry(\"red\", red);\n",
        "1306": "   * }</pre>\n",
        "1313": "   * @return a map mapping the result of evaluating the function {@code keyFunction} on each value\n",
        "1314": "   *     in the input collection to that value\n",
        "1315": "   * @throws IllegalArgumentException if {@code keyFunction} produces the same key for more than one\n",
        "1316": "   *     value in the input collection\n",
        "1317": "   * @throws NullPointerException if any element of {@code values} is {@code null}, or if {@code\n",
        "1318": "   *     keyFunction} produces {@code null} for any value\n",
        "1340": "   * Creates an {@code ImmutableMap<String, String>} from a {@code Properties} instance. Properties\n",
        "1341": "   * normally derive from {@code Map<Object, Object>}, but they typically contain strings, which is\n",
        "1342": "   * awkward. This method lets you get a plain-old-{@code Map} out of a {@code Properties}.\n",
        "1346": "   * @throws ClassCastException if any key in {@code Properties} is not a {@code String}\n",
        "1347": "   * @throws NullPointerException if any key or value in {@code Properties} is null\n",
        "1362": "   * Returns an immutable map entry with the specified key and value. The {@link Entry#setValue}\n",
        "1363": "   * operation throws an {@link UnsupportedOperationException}.\n",
        "1376": "   * Returns an unmodifiable view of the specified set of entries. The {@link Entry#setValue}\n",
        "1377": "   * operation throws an {@link UnsupportedOperationException}, as do any operations that would\n",
        "1378": "   * modify the returned set.\n",
        "1388": "   * Returns an unmodifiable view of the specified map entry. The {@link Entry#setValue} operation\n",
        "1389": "   * throws an {@link UnsupportedOperationException}. This also has the side-effect of redefining\n",
        "1390": "   * {@code equals} to comply with the Entry contract, to avoid a possible nefarious implementation\n",
        "1391": "   * of equals.\n",
        "1478": "   * Returns a {@link Converter} that converts values using {@link BiMap#get bimap.get()}, and whose\n",
        "1479": "   * inverse view converts values using {@link BiMap#inverse bimap.inverse()}{@code .get()}.\n",
        "1481": "   * <p>To use a plain {@link Map} as a {@link Function}, see {@link\n",
        "1482": "   * com.google.common.base.Functions#forMap(Map)} or {@link\n",
        "1483": "   * com.google.common.base.Functions#forMap(Map, Object)}.\n",
        "1539": "   * Returns a synchronized (thread-safe) bimap backed by the specified bimap. In order to guarantee\n",
        "1540": "   * serial access, it is critical that <b>all</b> access to the backing bimap is accomplished\n",
        "1541": "   * through the returned bimap.\n",
        "1542": "   *\n",
        "1543": "   * <p>It is imperative that the user manually synchronize on the returned map when accessing any\n",
        "1544": "   * of its collection views:\n",
        "1545": "   *\n",
        "1546": "   * <pre>{@code\n",
        "1547": "   * BiMap<Long, String> map = Maps.synchronizedBiMap(\n",
        "1548": "   *     HashBiMap.<Long, String>create());\n",
        "1549": "   * ...\n",
        "1550": "   * Set<Long> set = map.keySet();  // Needn't be in synchronized block\n",
        "1551": "   * ...\n",
        "1552": "   * synchronized (map) {  // Synchronizing on map, not set!\n",
        "1553": "   *   Iterator<Long> it = set.iterator(); // Must be in synchronized block\n",
        "1554": "   *   while (it.hasNext()) {\n",
        "1555": "   *     foo(it.next());\n",
        "1556": "   *   }\n",
        "1557": "   * }\n",
        "1558": "   * }</pre>\n",
        "1562": "   * <p>The returned bimap will be serializable if the specified bimap is serializable.\n",
        "1572": "   * Returns an unmodifiable view of the specified bimap. This method allows modules to provide\n",
        "1573": "   * users with \"read-only\" access to internal bimaps. Query operations on the returned bimap \"read\n",
        "1574": "   * through\" to the specified bimap, and attempts to modify the returned map, whether direct or via\n",
        "1575": "   * its collection views, result in an {@code UnsupportedOperationException}.\n",
        "1577": "   * <p>The returned bimap will be serializable if the specified bimap is serializable.\n",
        "1591": "    @RetainedWith BiMap<V, K> inverse;\n",
        "1628": "   * Returns a view of a map where each value is transformed by a function. All other properties of\n",
        "1629": "   * the map, such as iteration order, are left intact. For example, the code:\n",
        "1630": "   *\n",
        "1631": "   * <pre>{@code\n",
        "1632": "   * Map<String, Integer> map = ImmutableMap.of(\"a\", 4, \"b\", 9);\n",
        "1633": "   * Function<Integer, Double> sqrt =\n",
        "1634": "   *     new Function<Integer, Double>() {\n",
        "1635": "   *       public Double apply(Integer in) {\n",
        "1636": "   *         return Math.sqrt((int) in);\n",
        "1637": "   *       }\n",
        "1638": "   *     };\n",
        "1639": "   * Map<String, Double> transformed = Maps.transformValues(map, sqrt);\n",
        "1640": "   * System.out.println(transformed);\n",
        "1641": "   * }</pre>\n",
        "1645": "   * <p>Changes in the underlying map are reflected in this view. Conversely, this view supports\n",
        "1646": "   * removal operations, and these are reflected in the underlying map.\n",
        "1648": "   * <p>It's acceptable for the underlying map to contain null keys, and even null values provided\n",
        "1649": "   * that the function is capable of accepting null input. The transformed map might contain null\n",
        "1650": "   * values, if the function sometimes gives a null result.\n",
        "1652": "   * <p>The returned map is not thread-safe or serializable, even if the underlying map is.\n",
        "1654": "   * <p>The function is applied lazily, invoked when needed. This is necessary for the returned map\n",
        "1655": "   * to be a view, but it means that the function will be applied many times for bulk operations\n",
        "1656": "   * like {@link Map#containsValue} and {@code Map.toString()}. For this to perform well, {@code\n",
        "1657": "   * function} should be fast. To avoid lazy evaluation when the returned map doesn't need to be a\n",
        "1658": "   * view, copy the returned map into a new map of your choosing.\n",
        "1666": "   * Returns a view of a sorted map where each value is transformed by a function. All other\n",
        "1667": "   * properties of the map, such as iteration order, are left intact. For example, the code:\n",
        "1668": "   *\n",
        "1669": "   * <pre>{@code\n",
        "1670": "   * SortedMap<String, Integer> map = ImmutableSortedMap.of(\"a\", 4, \"b\", 9);\n",
        "1671": "   * Function<Integer, Double> sqrt =\n",
        "1672": "   *     new Function<Integer, Double>() {\n",
        "1673": "   *       public Double apply(Integer in) {\n",
        "1674": "   *         return Math.sqrt((int) in);\n",
        "1675": "   *       }\n",
        "1676": "   *     };\n",
        "1677": "   * SortedMap<String, Double> transformed =\n",
        "1678": "   *      Maps.transformValues(map, sqrt);\n",
        "1679": "   * System.out.println(transformed);\n",
        "1680": "   * }</pre>\n",
        "1684": "   * <p>Changes in the underlying map are reflected in this view. Conversely, this view supports\n",
        "1685": "   * removal operations, and these are reflected in the underlying map.\n",
        "1687": "   * <p>It's acceptable for the underlying map to contain null keys, and even null values provided\n",
        "1688": "   * that the function is capable of accepting null input. The transformed map might contain null\n",
        "1689": "   * values, if the function sometimes gives a null result.\n",
        "1691": "   * <p>The returned map is not thread-safe or serializable, even if the underlying map is.\n",
        "1693": "   * <p>The function is applied lazily, invoked when needed. This is necessary for the returned map\n",
        "1694": "   * to be a view, but it means that the function will be applied many times for bulk operations\n",
        "1695": "   * like {@link Map#containsValue} and {@code Map.toString()}. For this to perform well, {@code\n",
        "1696": "   * function} should be fast. To avoid lazy evaluation when the returned map doesn't need to be a\n",
        "1697": "   * view, copy the returned map into a new map of your choosing.\n",
        "1707": "   * Returns a view of a navigable map where each value is transformed by a function. All other\n",
        "1708": "   * properties of the map, such as iteration order, are left intact. For example, the code:\n",
        "1709": "   *\n",
        "1710": "   * <pre>{@code\n",
        "1711": "   * NavigableMap<String, Integer> map = Maps.newTreeMap();\n",
        "1712": "   * map.put(\"a\", 4);\n",
        "1713": "   * map.put(\"b\", 9);\n",
        "1714": "   * Function<Integer, Double> sqrt =\n",
        "1715": "   *     new Function<Integer, Double>() {\n",
        "1716": "   *       public Double apply(Integer in) {\n",
        "1717": "   *         return Math.sqrt((int) in);\n",
        "1718": "   *       }\n",
        "1719": "   *     };\n",
        "1720": "   * NavigableMap<String, Double> transformed =\n",
        "1721": "   *      Maps.transformNavigableValues(map, sqrt);\n",
        "1722": "   * System.out.println(transformed);\n",
        "1723": "   * }</pre>\n",
        "1727": "   * <p>Changes in the underlying map are reflected in this view. Conversely, this view supports\n",
        "1728": "   * removal operations, and these are reflected in the underlying map.\n",
        "1730": "   * <p>It's acceptable for the underlying map to contain null keys, and even null values provided\n",
        "1731": "   * that the function is capable of accepting null input. The transformed map might contain null\n",
        "1732": "   * values, if the function sometimes gives a null result.\n",
        "1734": "   * <p>The returned map is not thread-safe or serializable, even if the underlying map is.\n",
        "1736": "   * <p>The function is applied lazily, invoked when needed. This is necessary for the returned map\n",
        "1737": "   * to be a view, but it means that the function will be applied many times for bulk operations\n",
        "1738": "   * like {@link Map#containsValue} and {@code Map.toString()}. For this to perform well, {@code\n",
        "1739": "   * function} should be fast. To avoid lazy evaluation when the returned map doesn't need to be a\n",
        "1740": "   * view, copy the returned map into a new map of your choosing.\n",
        "1751": "   * Returns a view of a map whose values are derived from the original map's entries. In contrast\n",
        "1752": "   * to {@link #transformValues}, this method's entry-transformation logic may depend on the key as\n",
        "1753": "   * well as the value.\n",
        "1754": "   *\n",
        "1755": "   * <p>All other properties of the transformed map, such as iteration order, are left intact. For\n",
        "1756": "   * example, the code:\n",
        "1757": "   *\n",
        "1758": "   * <pre>{@code\n",
        "1759": "   * Map<String, Boolean> options =\n",
        "1760": "   *     ImmutableMap.of(\"verbose\", true, \"sort\", false);\n",
        "1761": "   * EntryTransformer<String, Boolean, String> flagPrefixer =\n",
        "1762": "   *     new EntryTransformer<String, Boolean, String>() {\n",
        "1763": "   *       public String transformEntry(String key, Boolean value) {\n",
        "1764": "   *         return value ? key : \"no\" + key;\n",
        "1765": "   *       }\n",
        "1766": "   *     };\n",
        "1767": "   * Map<String, String> transformed =\n",
        "1768": "   *     Maps.transformEntries(options, flagPrefixer);\n",
        "1769": "   * System.out.println(transformed);\n",
        "1770": "   * }</pre>\n",
        "1774": "   * <p>Changes in the underlying map are reflected in this view. Conversely, this view supports\n",
        "1775": "   * removal operations, and these are reflected in the underlying map.\n",
        "1776": "   *\n",
        "1777": "   * <p>It's acceptable for the underlying map to contain null keys and null values provided that\n",
        "1778": "   * the transformer is capable of accepting null inputs. The transformed map might contain null\n",
        "1779": "   * values if the transformer sometimes gives a null result.\n",
        "1780": "   *\n",
        "1781": "   * <p>The returned map is not thread-safe or serializable, even if the underlying map is.\n",
        "1782": "   *\n",
        "1783": "   * <p>The transformer is applied lazily, invoked when needed. This is necessary for the returned\n",
        "1784": "   * map to be a view, but it means that the transformer will be applied many times for bulk\n",
        "1785": "   * operations like {@link Map#containsValue} and {@link Object#toString}. For this to perform\n",
        "1786": "   * well, {@code transformer} should be fast. To avoid lazy evaluation when the returned map\n",
        "1787": "   * doesn't need to be a view, copy the returned map into a new map of your choosing.\n",
        "1788": "   *\n",
        "1789": "   * <p><b>Warning:</b> This method assumes that for any instance {@code k} of {@code\n",
        "1790": "   * EntryTransformer} key type {@code K}, {@code k.equals(k2)} implies that {@code k2} is also of\n",
        "1791": "   * type {@code K}. Using an {@code EntryTransformer} key type for which this may not hold, such as\n",
        "1792": "   * {@code ArrayList}, may risk a {@code ClassCastException} when calling methods on the\n",
        "1793": "   * transformed map.\n",
        "1803": "   * Returns a view of a sorted map whose values are derived from the original sorted map's entries.\n",
        "1804": "   * In contrast to {@link #transformValues}, this method's entry-transformation logic may depend on\n",
        "1805": "   * the key as well as the value.\n",
        "1806": "   *\n",
        "1807": "   * <p>All other properties of the transformed map, such as iteration order, are left intact. For\n",
        "1808": "   * example, the code:\n",
        "1809": "   *\n",
        "1810": "   * <pre>{@code\n",
        "1811": "   * Map<String, Boolean> options =\n",
        "1812": "   *     ImmutableSortedMap.of(\"verbose\", true, \"sort\", false);\n",
        "1813": "   * EntryTransformer<String, Boolean, String> flagPrefixer =\n",
        "1814": "   *     new EntryTransformer<String, Boolean, String>() {\n",
        "1815": "   *       public String transformEntry(String key, Boolean value) {\n",
        "1816": "   *         return value ? key : \"yes\" + key;\n",
        "1817": "   *       }\n",
        "1818": "   *     };\n",
        "1819": "   * SortedMap<String, String> transformed =\n",
        "1820": "   *     Maps.transformEntries(options, flagPrefixer);\n",
        "1821": "   * System.out.println(transformed);\n",
        "1822": "   * }</pre>\n",
        "1826": "   * <p>Changes in the underlying map are reflected in this view. Conversely, this view supports\n",
        "1827": "   * removal operations, and these are reflected in the underlying map.\n",
        "1828": "   *\n",
        "1829": "   * <p>It's acceptable for the underlying map to contain null keys and null values provided that\n",
        "1830": "   * the transformer is capable of accepting null inputs. The transformed map might contain null\n",
        "1831": "   * values if the transformer sometimes gives a null result.\n",
        "1832": "   *\n",
        "1833": "   * <p>The returned map is not thread-safe or serializable, even if the underlying map is.\n",
        "1834": "   *\n",
        "1835": "   * <p>The transformer is applied lazily, invoked when needed. This is necessary for the returned\n",
        "1836": "   * map to be a view, but it means that the transformer will be applied many times for bulk\n",
        "1837": "   * operations like {@link Map#containsValue} and {@link Object#toString}. For this to perform\n",
        "1838": "   * well, {@code transformer} should be fast. To avoid lazy evaluation when the returned map\n",
        "1839": "   * doesn't need to be a view, copy the returned map into a new map of your choosing.\n",
        "1840": "   *\n",
        "1841": "   * <p><b>Warning:</b> This method assumes that for any instance {@code k} of {@code\n",
        "1842": "   * EntryTransformer} key type {@code K}, {@code k.equals(k2)} implies that {@code k2} is also of\n",
        "1843": "   * type {@code K}. Using an {@code EntryTransformer} key type for which this may not hold, such as\n",
        "1844": "   * {@code ArrayList}, may risk a {@code ClassCastException} when calling methods on the\n",
        "1845": "   * transformed map.\n",
        "1855": "   * Returns a view of a navigable map whose values are derived from the original navigable map's\n",
        "1856": "   * entries. In contrast to {@link #transformValues}, this method's entry-transformation logic may\n",
        "1859": "   * <p>All other properties of the transformed map, such as iteration order, are left intact. For\n",
        "1860": "   * example, the code:\n",
        "1861": "   *\n",
        "1862": "   * <pre>{@code\n",
        "1863": "   * NavigableMap<String, Boolean> options = Maps.newTreeMap();\n",
        "1864": "   * options.put(\"verbose\", false);\n",
        "1865": "   * options.put(\"sort\", true);\n",
        "1866": "   * EntryTransformer<String, Boolean, String> flagPrefixer =\n",
        "1867": "   *     new EntryTransformer<String, Boolean, String>() {\n",
        "1868": "   *       public String transformEntry(String key, Boolean value) {\n",
        "1869": "   *         return value ? key : (\"yes\" + key);\n",
        "1870": "   *       }\n",
        "1871": "   *     };\n",
        "1872": "   * NavigableMap<String, String> transformed =\n",
        "1873": "   *     LabsMaps.transformNavigableEntries(options, flagPrefixer);\n",
        "1874": "   * System.out.println(transformed);\n",
        "1875": "   * }</pre>\n",
        "1879": "   * <p>Changes in the underlying map are reflected in this view. Conversely, this view supports\n",
        "1880": "   * removal operations, and these are reflected in the underlying map.\n",
        "1881": "   *\n",
        "1882": "   * <p>It's acceptable for the underlying map to contain null keys and null values provided that\n",
        "1883": "   * the transformer is capable of accepting null inputs. The transformed map might contain null\n",
        "1884": "   * values if the transformer sometimes gives a null result.\n",
        "1885": "   *\n",
        "1886": "   * <p>The returned map is not thread-safe or serializable, even if the underlying map is.\n",
        "1887": "   *\n",
        "1888": "   * <p>The transformer is applied lazily, invoked when needed. This is necessary for the returned\n",
        "1889": "   * map to be a view, but it means that the transformer will be applied many times for bulk\n",
        "1890": "   * operations like {@link Map#containsValue} and {@link Object#toString}. For this to perform\n",
        "1891": "   * well, {@code transformer} should be fast. To avoid lazy evaluation when the returned map\n",
        "1892": "   * doesn't need to be a view, copy the returned map into a new map of your choosing.\n",
        "1893": "   *\n",
        "1894": "   * <p><b>Warning:</b> This method assumes that for any instance {@code k} of {@code\n",
        "1895": "   * EntryTransformer} key type {@code K}, {@code k.equals(k2)} implies that {@code k2} is also of\n",
        "1896": "   * type {@code K}. Using an {@code EntryTransformer} key type for which this may not hold, such as\n",
        "1897": "   * {@code ArrayList}, may risk a {@code ClassCastException} when calling methods on the\n",
        "1898": "   * transformed map.\n",
        "1909": "   * A transformation of the value of a key-value pair, using both key and value as inputs. To apply\n",
        "1910": "   * the transformation to a map, use {@link Maps#transformEntries(Map, EntryTransformer)}.\n",
        "1920": "     * Determines an output value based on a key-value pair. This method is <i>generally\n",
        "1921": "     * expected</i>, but not absolutely required, to have the following properties:\n",
        "1924": "     *   <li>Its execution does not cause any observable side effects.\n",
        "1925": "     *   <li>The computation is <i>consistent with equals</i>; that is, {@link Objects#equal\n",
        "1926": "     *       Objects.equal}{@code (k1, k2) &&} {@link Objects#equal}{@code (v1, v2)} implies that\n",
        "1927": "     *       {@code Objects.equal(transformer.transform(k1, v1), transformer.transform(k2, v2))}.\n",
        "1930": "     * @throws NullPointerException if the key or value is null and this transformer does not accept\n",
        "1931": "     *     null arguments\n",
        "1936": "  /** Views a function as an entry transformer that ignores the entry key. */\n",
        "1959": "  /** Views an entry transformer as a function from {@code Entry} to values. */\n",
        "1971": "  /** Returns a view of an entry transformed by the specified transformer. */\n",
        "1989": "  /** Views an entry transformer as a function from entries to entries. */\n",
        "2261": "   * Returns a map containing the mappings in {@code unfiltered} whose keys satisfy a predicate. The\n",
        "2262": "   * returned map is a live view of {@code unfiltered}; changes to one affect the other.\n",
        "2263": "   *\n",
        "2264": "   * <p>The resulting map's {@code keySet()}, {@code entrySet()}, and {@code values()} views have\n",
        "2265": "   * iterators that don't support {@code remove()}, but all other methods are supported by the map\n",
        "2266": "   * and its views. When given a key that doesn't satisfy the predicate, the map's {@code put()} and\n",
        "2267": "   * {@code putAll()} methods throw an {@link IllegalArgumentException}.\n",
        "2268": "   *\n",
        "2269": "   * <p>When methods such as {@code removeAll()} and {@code clear()} are called on the filtered map\n",
        "2270": "   * or its views, only mappings whose keys satisfy the filter will be removed from the underlying\n",
        "2271": "   * map.\n",
        "2272": "   *\n",
        "2273": "   * <p>The returned map isn't threadsafe or serializable, even if {@code unfiltered} is.\n",
        "2274": "   *\n",
        "2275": "   * <p>Many of the filtered map's methods, such as {@code size()}, iterate across every key/value\n",
        "2276": "   * mapping in the underlying map and determine which satisfy the filter. When a live view is\n",
        "2277": "   * <i>not</i> needed, it may be faster to copy the filtered map and use the copy.\n",
        "2278": "   *\n",
        "2279": "   * <p><b>Warning:</b> {@code keyPredicate} must be <i>consistent with equals</i>, as documented at\n",
        "2280": "   * {@link Predicate#apply}. Do not provide a predicate such as {@code\n",
        "2281": "   * Predicates.instanceOf(ArrayList.class)}, which is inconsistent with equals.\n",
        "2293": "   * Returns a sorted map containing the mappings in {@code unfiltered} whose keys satisfy a\n",
        "2294": "   * predicate. The returned map is a live view of {@code unfiltered}; changes to one affect the\n",
        "2295": "   * other.\n",
        "2297": "   * <p>The resulting map's {@code keySet()}, {@code entrySet()}, and {@code values()} views have\n",
        "2298": "   * iterators that don't support {@code remove()}, but all other methods are supported by the map\n",
        "2299": "   * and its views. When given a key that doesn't satisfy the predicate, the map's {@code put()} and\n",
        "2300": "   * {@code putAll()} methods throw an {@link IllegalArgumentException}.\n",
        "2302": "   * <p>When methods such as {@code removeAll()} and {@code clear()} are called on the filtered map\n",
        "2303": "   * or its views, only mappings whose keys satisfy the filter will be removed from the underlying\n",
        "2304": "   * map.\n",
        "2306": "   * <p>The returned map isn't threadsafe or serializable, even if {@code unfiltered} is.\n",
        "2308": "   * <p>Many of the filtered map's methods, such as {@code size()}, iterate across every key/value\n",
        "2309": "   * mapping in the underlying map and determine which satisfy the filter. When a live view is\n",
        "2310": "   * <i>not</i> needed, it may be faster to copy the filtered map and use the copy.\n",
        "2312": "   * <p><b>Warning:</b> {@code keyPredicate} must be <i>consistent with equals</i>, as documented at\n",
        "2313": "   * {@link Predicate#apply}. Do not provide a predicate such as {@code\n",
        "2314": "   * Predicates.instanceOf(ArrayList.class)}, which is inconsistent with equals.\n",
        "2326": "   * Returns a navigable map containing the mappings in {@code unfiltered} whose keys satisfy a\n",
        "2327": "   * predicate. The returned map is a live view of {@code unfiltered}; changes to one affect the\n",
        "2328": "   * other.\n",
        "2330": "   * <p>The resulting map's {@code keySet()}, {@code entrySet()}, and {@code values()} views have\n",
        "2331": "   * iterators that don't support {@code remove()}, but all other methods are supported by the map\n",
        "2332": "   * and its views. When given a key that doesn't satisfy the predicate, the map's {@code put()} and\n",
        "2333": "   * {@code putAll()} methods throw an {@link IllegalArgumentException}.\n",
        "2335": "   * <p>When methods such as {@code removeAll()} and {@code clear()} are called on the filtered map\n",
        "2336": "   * or its views, only mappings whose keys satisfy the filter will be removed from the underlying\n",
        "2337": "   * map.\n",
        "2339": "   * <p>The returned map isn't threadsafe or serializable, even if {@code unfiltered} is.\n",
        "2341": "   * <p>Many of the filtered map's methods, such as {@code size()}, iterate across every key/value\n",
        "2342": "   * mapping in the underlying map and determine which satisfy the filter. When a live view is\n",
        "2343": "   * <i>not</i> needed, it may be faster to copy the filtered map and use the copy.\n",
        "2345": "   * <p><b>Warning:</b> {@code keyPredicate} must be <i>consistent with equals</i>, as documented at\n",
        "2346": "   * {@link Predicate#apply}. Do not provide a predicate such as {@code\n",
        "2347": "   * Predicates.instanceOf(ArrayList.class)}, which is inconsistent with equals.\n",
        "2364": "   * iterators that don't support {@code remove()}, but all other methods are supported by the bimap\n",
        "2365": "   * and its views. When given a key that doesn't satisfy the predicate, the bimap's {@code put()},\n",
        "2366": "   * {@code forcePut()} and {@code putAll()} methods throw an {@link IllegalArgumentException}.\n",
        "2378": "   * <p><b>Warning:</b> {@code entryPredicate} must be <i>consistent with equals </i>, as documented\n",
        "2379": "   * at {@link Predicate#apply}.\n",
        "2390": "   * Returns a map containing the mappings in {@code unfiltered} whose values satisfy a predicate.\n",
        "2391": "   * The returned map is a live view of {@code unfiltered}; changes to one affect the other.\n",
        "2392": "   *\n",
        "2393": "   * <p>The resulting map's {@code keySet()}, {@code entrySet()}, and {@code values()} views have\n",
        "2394": "   * iterators that don't support {@code remove()}, but all other methods are supported by the map\n",
        "2395": "   * and its views. When given a value that doesn't satisfy the predicate, the map's {@code put()},\n",
        "2396": "   * {@code putAll()}, and {@link Entry#setValue} methods throw an {@link IllegalArgumentException}.\n",
        "2397": "   *\n",
        "2398": "   * <p>When methods such as {@code removeAll()} and {@code clear()} are called on the filtered map\n",
        "2399": "   * or its views, only mappings whose values satisfy the filter will be removed from the underlying\n",
        "2400": "   * map.\n",
        "2401": "   *\n",
        "2402": "   * <p>The returned map isn't threadsafe or serializable, even if {@code unfiltered} is.\n",
        "2403": "   *\n",
        "2404": "   * <p>Many of the filtered map's methods, such as {@code size()}, iterate across every key/value\n",
        "2405": "   * mapping in the underlying map and determine which satisfy the filter. When a live view is\n",
        "2406": "   * <i>not</i> needed, it may be faster to copy the filtered map and use the copy.\n",
        "2407": "   *\n",
        "2408": "   * <p><b>Warning:</b> {@code valuePredicate} must be <i>consistent with equals</i>, as documented\n",
        "2409": "   * at {@link Predicate#apply}. Do not provide a predicate such as {@code\n",
        "2410": "   * Predicates.instanceOf(ArrayList.class)}, which is inconsistent with equals.\n",
        "2418": "   * Returns a sorted map containing the mappings in {@code unfiltered} whose values satisfy a\n",
        "2419": "   * predicate. The returned map is a live view of {@code unfiltered}; changes to one affect the\n",
        "2420": "   * other.\n",
        "2421": "   *\n",
        "2422": "   * <p>The resulting map's {@code keySet()}, {@code entrySet()}, and {@code values()} views have\n",
        "2423": "   * iterators that don't support {@code remove()}, but all other methods are supported by the map\n",
        "2424": "   * and its views. When given a value that doesn't satisfy the predicate, the map's {@code put()},\n",
        "2425": "   * {@code putAll()}, and {@link Entry#setValue} methods throw an {@link IllegalArgumentException}.\n",
        "2426": "   *\n",
        "2427": "   * <p>When methods such as {@code removeAll()} and {@code clear()} are called on the filtered map\n",
        "2428": "   * or its views, only mappings whose values satisfy the filter will be removed from the underlying\n",
        "2429": "   * map.\n",
        "2430": "   *\n",
        "2431": "   * <p>The returned map isn't threadsafe or serializable, even if {@code unfiltered} is.\n",
        "2432": "   *\n",
        "2433": "   * <p>Many of the filtered map's methods, such as {@code size()}, iterate across every key/value\n",
        "2434": "   * mapping in the underlying map and determine which satisfy the filter. When a live view is\n",
        "2435": "   * <i>not</i> needed, it may be faster to copy the filtered map and use the copy.\n",
        "2436": "   *\n",
        "2437": "   * <p><b>Warning:</b> {@code valuePredicate} must be <i>consistent with equals</i>, as documented\n",
        "2438": "   * at {@link Predicate#apply}. Do not provide a predicate such as {@code\n",
        "2439": "   * Predicates.instanceOf(ArrayList.class)}, which is inconsistent with equals.\n",
        "2449": "   * Returns a navigable map containing the mappings in {@code unfiltered} whose values satisfy a\n",
        "2450": "   * predicate. The returned map is a live view of {@code unfiltered}; changes to one affect the\n",
        "2451": "   * other.\n",
        "2452": "   *\n",
        "2453": "   * <p>The resulting map's {@code keySet()}, {@code entrySet()}, and {@code values()} views have\n",
        "2454": "   * iterators that don't support {@code remove()}, but all other methods are supported by the map\n",
        "2455": "   * and its views. When given a value that doesn't satisfy the predicate, the map's {@code put()},\n",
        "2456": "   * {@code putAll()}, and {@link Entry#setValue} methods throw an {@link IllegalArgumentException}.\n",
        "2457": "   *\n",
        "2458": "   * <p>When methods such as {@code removeAll()} and {@code clear()} are called on the filtered map\n",
        "2459": "   * or its views, only mappings whose values satisfy the filter will be removed from the underlying\n",
        "2460": "   * map.\n",
        "2461": "   *\n",
        "2462": "   * <p>The returned map isn't threadsafe or serializable, even if {@code unfiltered} is.\n",
        "2463": "   *\n",
        "2464": "   * <p>Many of the filtered map's methods, such as {@code size()}, iterate across every key/value\n",
        "2465": "   * mapping in the underlying map and determine which satisfy the filter. When a live view is\n",
        "2466": "   * <i>not</i> needed, it may be faster to copy the filtered map and use the copy.\n",
        "2467": "   *\n",
        "2468": "   * <p><b>Warning:</b> {@code valuePredicate} must be <i>consistent with equals</i>, as documented\n",
        "2469": "   * at {@link Predicate#apply}. Do not provide a predicate such as {@code\n",
        "2470": "   * Predicates.instanceOf(ArrayList.class)}, which is inconsistent with equals.\n",
        "2481": "   * Returns a bimap containing the mappings in {@code unfiltered} whose values satisfy a predicate.\n",
        "2482": "   * The returned bimap is a live view of {@code unfiltered}; changes to one affect the other.\n",
        "2485": "   * iterators that don't support {@code remove()}, but all other methods are supported by the bimap\n",
        "2486": "   * and its views. When given a value that doesn't satisfy the predicate, the bimap's {@code\n",
        "2487": "   * put()}, {@code forcePut()} and {@code putAll()} methods throw an {@link\n",
        "2502": "   * <p><b>Warning:</b> {@code entryPredicate} must be <i>consistent with equals </i>, as documented\n",
        "2503": "   * at {@link Predicate#apply}.\n",
        "2513": "   * Returns a map containing the mappings in {@code unfiltered} that satisfy a predicate. The\n",
        "2514": "   * returned map is a live view of {@code unfiltered}; changes to one affect the other.\n",
        "2515": "   *\n",
        "2516": "   * <p>The resulting map's {@code keySet()}, {@code entrySet()}, and {@code values()} views have\n",
        "2517": "   * iterators that don't support {@code remove()}, but all other methods are supported by the map\n",
        "2518": "   * and its views. When given a key/value pair that doesn't satisfy the predicate, the map's {@code\n",
        "2519": "   * put()} and {@code putAll()} methods throw an {@link IllegalArgumentException}. Similarly, the\n",
        "2520": "   * map's entries have a {@link Entry#setValue} method that throws an {@link\n",
        "2521": "   * IllegalArgumentException} when the existing key and the provided value don't satisfy the\n",
        "2522": "   * predicate.\n",
        "2523": "   *\n",
        "2524": "   * <p>When methods such as {@code removeAll()} and {@code clear()} are called on the filtered map\n",
        "2525": "   * or its views, only mappings that satisfy the filter will be removed from the underlying map.\n",
        "2526": "   *\n",
        "2527": "   * <p>The returned map isn't threadsafe or serializable, even if {@code unfiltered} is.\n",
        "2528": "   *\n",
        "2529": "   * <p>Many of the filtered map's methods, such as {@code size()}, iterate across every key/value\n",
        "2530": "   * mapping in the underlying map and determine which satisfy the filter. When a live view is\n",
        "2531": "   * <i>not</i> needed, it may be faster to copy the filtered map and use the copy.\n",
        "2532": "   *\n",
        "2533": "   * <p><b>Warning:</b> {@code entryPredicate} must be <i>consistent with equals</i>, as documented\n",
        "2534": "   * at {@link Predicate#apply}.\n",
        "2545": "   * Returns a sorted map containing the mappings in {@code unfiltered} that satisfy a predicate.\n",
        "2546": "   * The returned map is a live view of {@code unfiltered}; changes to one affect the other.\n",
        "2547": "   *\n",
        "2548": "   * <p>The resulting map's {@code keySet()}, {@code entrySet()}, and {@code values()} views have\n",
        "2549": "   * iterators that don't support {@code remove()}, but all other methods are supported by the map\n",
        "2550": "   * and its views. When given a key/value pair that doesn't satisfy the predicate, the map's {@code\n",
        "2551": "   * put()} and {@code putAll()} methods throw an {@link IllegalArgumentException}. Similarly, the\n",
        "2552": "   * map's entries have a {@link Entry#setValue} method that throws an {@link\n",
        "2553": "   * IllegalArgumentException} when the existing key and the provided value don't satisfy the\n",
        "2554": "   * predicate.\n",
        "2555": "   *\n",
        "2556": "   * <p>When methods such as {@code removeAll()} and {@code clear()} are called on the filtered map\n",
        "2557": "   * or its views, only mappings that satisfy the filter will be removed from the underlying map.\n",
        "2558": "   *\n",
        "2559": "   * <p>The returned map isn't threadsafe or serializable, even if {@code unfiltered} is.\n",
        "2560": "   *\n",
        "2561": "   * <p>Many of the filtered map's methods, such as {@code size()}, iterate across every key/value\n",
        "2562": "   * mapping in the underlying map and determine which satisfy the filter. When a live view is\n",
        "2563": "   * <i>not</i> needed, it may be faster to copy the filtered map and use the copy.\n",
        "2564": "   *\n",
        "2565": "   * <p><b>Warning:</b> {@code entryPredicate} must be <i>consistent with equals</i>, as documented\n",
        "2566": "   * at {@link Predicate#apply}.\n",
        "2579": "   * Returns a sorted map containing the mappings in {@code unfiltered} that satisfy a predicate.\n",
        "2580": "   * The returned map is a live view of {@code unfiltered}; changes to one affect the other.\n",
        "2581": "   *\n",
        "2582": "   * <p>The resulting map's {@code keySet()}, {@code entrySet()}, and {@code values()} views have\n",
        "2583": "   * iterators that don't support {@code remove()}, but all other methods are supported by the map\n",
        "2584": "   * and its views. When given a key/value pair that doesn't satisfy the predicate, the map's {@code\n",
        "2585": "   * put()} and {@code putAll()} methods throw an {@link IllegalArgumentException}. Similarly, the\n",
        "2586": "   * map's entries have a {@link Entry#setValue} method that throws an {@link\n",
        "2587": "   * IllegalArgumentException} when the existing key and the provided value don't satisfy the\n",
        "2588": "   * predicate.\n",
        "2589": "   *\n",
        "2590": "   * <p>When methods such as {@code removeAll()} and {@code clear()} are called on the filtered map\n",
        "2591": "   * or its views, only mappings that satisfy the filter will be removed from the underlying map.\n",
        "2592": "   *\n",
        "2593": "   * <p>The returned map isn't threadsafe or serializable, even if {@code unfiltered} is.\n",
        "2594": "   *\n",
        "2595": "   * <p>Many of the filtered map's methods, such as {@code size()}, iterate across every key/value\n",
        "2596": "   * mapping in the underlying map and determine which satisfy the filter. When a live view is\n",
        "2597": "   * <i>not</i> needed, it may be faster to copy the filtered map and use the copy.\n",
        "2598": "   *\n",
        "2599": "   * <p><b>Warning:</b> {@code entryPredicate} must be <i>consistent with equals</i>, as documented\n",
        "2600": "   * at {@link Predicate#apply}.\n",
        "2620": "   * {@code put()}, {@code forcePut()} and {@code putAll()} methods throw an {@link\n",
        "2621": "   * IllegalArgumentException}. Similarly, the map's entries have an {@link Entry#setValue} method\n",
        "2622": "   * that throws an {@link IllegalArgumentException} when the existing key and the provided value\n",
        "2623": "   * don't satisfy the predicate.\n",
        "2631": "   * <p>Many of the filtered bimap's methods, such as {@code size()}, iterate across every key/value\n",
        "2632": "   * mapping in the underlying bimap and determine which satisfy the filter. When a live view is\n",
        "2633": "   * <i>not</i> needed, it may be faster to copy the filtered bimap and use the copy.\n",
        "2635": "   * <p><b>Warning:</b> {@code entryPredicate} must be <i>consistent with equals </i>, as documented\n",
        "2636": "   * at {@link Predicate#apply}.\n",
        "2650": "   * Support {@code clear()}, {@code removeAll()}, and {@code retainAll()} when filtering a filtered\n",
        "2651": "   * map.\n",
        "2813": "     * Entries in this set satisfy the predicate, but they don't validate the input to {@code\n",
        "2814": "     * Entry.setValue()}.\n",
        "2929": "   * Support {@code clear()}, {@code removeAll()}, and {@code retainAll()} when filtering a filtered\n",
        "2930": "   * sorted map.\n",
        "3034": "   * Support {@code clear()}, {@code removeAll()}, and {@code retainAll()} when filtering a filtered\n",
        "3035": "   * navigable map.\n",
        "3179": "   * Support {@code clear()}, {@code removeAll()}, and {@code retainAll()} when filtering a filtered\n",
        "3180": "   * map.\n",
        "3190": "    @RetainedWith private final BiMap<V, K> inverse;\n",
        "3420": "   * Returns a synchronized (thread-safe) navigable map backed by the specified navigable map. In\n",
        "3421": "   * order to guarantee serial access, it is critical that <b>all</b> access to the backing\n",
        "3422": "   * navigable map is accomplished through the returned navigable map (or its views).\n",
        "3424": "   * <p>It is imperative that the user manually synchronize on the returned navigable map when\n",
        "3425": "   * iterating over any of its collection views, or the collections views of any of its {@code\n",
        "3426": "   * descendingMap}, {@code subMap}, {@code headMap} or {@code tailMap} views.\n",
        "3428": "   * <pre>{@code\n",
        "3429": "   * NavigableMap<K, V> map = synchronizedNavigableMap(new TreeMap<K, V>());\n",
        "3431": "   * // Needn't be in synchronized block\n",
        "3432": "   * NavigableSet<K> set = map.navigableKeySet();\n",
        "3434": "   * synchronized (map) { // Synchronizing on map, not set!\n",
        "3435": "   *   Iterator<K> it = set.iterator(); // Must be in synchronized block\n",
        "3436": "   *   while (it.hasNext()) {\n",
        "3437": "   *     foo(it.next());\n",
        "3438": "   *   }\n",
        "3439": "   * }\n",
        "3440": "   * }</pre>\n",
        "3442": "   * <p>or:\n",
        "3444": "   * <pre>{@code\n",
        "3445": "   * NavigableMap<K, V> map = synchronizedNavigableMap(new TreeMap<K, V>());\n",
        "3446": "   * NavigableMap<K, V> map2 = map.subMap(foo, false, bar, true);\n",
        "3448": "   * // Needn't be in synchronized block\n",
        "3449": "   * NavigableSet<K> set2 = map2.descendingKeySet();\n",
        "3451": "   * synchronized (map) { // Synchronizing on map, not map2 or set2!\n",
        "3452": "   *   Iterator<K> it = set2.iterator(); // Must be in synchronized block\n",
        "3453": "   *   while (it.hasNext()) {\n",
        "3454": "   *     foo(it.next());\n",
        "3455": "   *   }\n",
        "3456": "   * }\n",
        "3457": "   * }</pre>\n",
        "3461": "   * <p>The returned navigable map will be serializable if the specified navigable map is\n",
        "3462": "   * serializable.\n",
        "3464": "   * @param navigableMap the navigable map to be \"wrapped\" in a synchronized navigable map.\n",
        "3475": "   * {@code AbstractMap} extension that makes it easy to cache customized keySet, values, and\n",
        "3476": "   * entrySet views.\n",
        "3481": "     * Creates the entry set to be returned by {@link #entrySet()}. This method is invoked at most\n",
        "3482": "     * once on a given map, at the time when {@code entrySet} is first called.\n",
        "3566": "   * Delegates to {@link Map#get}. Returns {@code null} on {@code ClassCastException} and {@code\n",
        "3567": "   * NullPointerException}.\n",
        "3579": "   * Delegates to {@link Map#containsKey}. Returns {@code false} on {@code ClassCastException} and\n",
        "3580": "   * {@code NullPointerException}.\n",
        "3592": "   * Delegates to {@link Map#remove}. Returns {@code null} on {@code ClassCastException} and {@code\n",
        "3593": "   * NullPointerException}.\n",
        "3604": "  /** An admittedly inefficient implementation of {@link Map#containsKey}. */\n",
        "3609": "  /** An implementation of {@link Map#containsValue}. */\n",
        "3615": "   * Implements {@code Collection.contains} safely for forwarding collections of map entries. If\n",
        "3616": "   * {@code o} is an instance of {@code Entry}, it is wrapped using {@link #unmodifiableEntry} to\n",
        "3617": "   * protect against a possible nefarious equals method.\n",
        "3619": "   * <p>Note that {@code c} is the backing (delegate) collection, rather than the forwarding\n",
        "3620": "   * collection.\n",
        "3634": "   * Implements {@code Collection.remove} safely for forwarding collections of map entries. If\n",
        "3635": "   * {@code o} is an instance of {@code Entry}, it is wrapped using {@link #unmodifiableEntry} to\n",
        "3636": "   * protect against a possible nefarious equals method.\n",
        "3638": "   * <p>Note that {@code c} is backing (delegate) collection, rather than the forwarding collection.\n",
        "3651": "  /** An implementation of {@link Map#equals}. */\n",
        "3662": "  /** An implementation of {@link Map#toString}. */\n",
        "3676": "  /** An implementation of {@link Map#putAll}. */\n",
        "4218": "  /** Returns a map from the ith element of list to i. */\n",
        "4231": "   * <p>This method delegates to the appropriate methods of {@link NavigableMap} (namely {@link\n",
        "4232": "   * NavigableMap#subMap(Object, boolean, Object, boolean) subMap()}, {@link\n",
        "4233": "   * NavigableMap#tailMap(Object, boolean) tailMap()}, and {@link NavigableMap#headMap(Object,\n",
        "4234": "   * boolean) headMap()}) to actually construct the view. Consult these methods for a full\n",
        "4235": "   * description of the returned view's behavior.\n",
        "4238": "   * ordering. {@code NavigableMap} on the other hand can specify a custom ordering via a {@link\n",
        "4239": "   * Comparator}, which can violate the natural ordering. Using this method (or in general using\n",
        "4240": "   * {@code Range}) with unnaturally-ordered maps can lead to unexpected and undefined behavior.\n"
    },
    "removed": {
        "74": " * Static utility methods pertaining to {@link Map} instances (including instances of\n",
        "75": " * {@link SortedMap}, {@link BiMap}, etc.). Also see this class's counterparts\n",
        "76": " * {@link Lists}, {@link Sets} and {@link Queues}.\n",
        "79": " * \"https://github.com/google/guava/wiki/CollectionUtilitiesExplained#maps\">\n",
        "80": " * {@code Maps}</a>.\n",
        "128": "   * Returns an immutable map instance containing the given entries.\n",
        "129": "   * Internally, the returned map will be backed by an {@link EnumMap}.\n",
        "131": "   * <p>The iteration order of the returned map follows the enum's iteration\n",
        "132": "   * order, not the order in which the elements appear in the given map.\n",
        "208": "   * java.util.function.Function) Collectors.toMap(Function, Function)}, which throws an\n",
        "209": "   * {@code IllegalStateException}.)\n",
        "269": "   * <p><b>Note:</b> if mutability is not required, use {@link\n",
        "270": "   * ImmutableMap#of()} instead.\n",
        "272": "   * <p><b>Note:</b> if {@code K} is an {@code enum} type, use {@link\n",
        "273": "   * #newEnumMap} instead.\n",
        "275": "   * <p><b>Note for Java 7 and later:</b> this method is now unnecessary and\n",
        "276": "   * should be treated as deprecated. Instead, use the {@code HashMap}\n",
        "277": "   * constructor directly, taking advantage of the new\n",
        "287": "   * Creates a {@code HashMap} instance, with a high enough \"initial capacity\"\n",
        "288": "   * that it <i>should</i> hold {@code expectedSize} elements without growth.\n",
        "289": "   * This behavior cannot be broadly guaranteed, but it is observed to be true\n",
        "290": "   * for OpenJDK 1.7. It also can't be guaranteed that the method isn't\n",
        "291": "   * inadvertently <i>oversizing</i> the returned map.\n",
        "292": "   *\n",
        "293": "   * @param expectedSize the number of entries you expect to add to the\n",
        "294": "   *        returned map\n",
        "295": "   * @return a new, empty {@code HashMap} with enough capacity to hold {@code\n",
        "296": "   *         expectedSize} entries without resizing\n",
        "322": "   * Creates a <i>mutable</i> {@code HashMap} instance with the same mappings as\n",
        "323": "   * the specified map.\n",
        "325": "   * <p><b>Note:</b> if mutability is not required, use {@link\n",
        "326": "   * ImmutableMap#copyOf(Map)} instead.\n",
        "328": "   * <p><b>Note:</b> if {@code K} is an {@link Enum} type, use {@link\n",
        "329": "   * #newEnumMap} instead.\n",
        "331": "   * <p><b>Note for Java 7 and later:</b> this method is now unnecessary and\n",
        "332": "   * should be treated as deprecated. Instead, use the {@code HashMap}\n",
        "333": "   * constructor directly, taking advantage of the new\n",
        "337": "   * @return a new {@code HashMap} initialized with the mappings from {@code\n",
        "338": "   *         map}\n",
        "345": "   * Creates a <i>mutable</i>, empty, insertion-ordered {@code LinkedHashMap}\n",
        "346": "   * instance.\n",
        "348": "   * <p><b>Note:</b> if mutability is not required, use {@link\n",
        "349": "   * ImmutableMap#of()} instead.\n",
        "351": "   * <p><b>Note for Java 7 and later:</b> this method is now unnecessary and\n",
        "352": "   * should be treated as deprecated. Instead, use the {@code LinkedHashMap}\n",
        "353": "   * constructor directly, taking advantage of the new\n",
        "354": "   * <a href=\"http://goo.gl/iz2Wi\">\"diamond\" syntax</a>.\n",
        "363": "   * Creates a {@code LinkedHashMap} instance, with a high enough\n",
        "364": "   * \"initial capacity\" that it <i>should</i> hold {@code expectedSize}\n",
        "365": "   * elements without growth. This behavior cannot be broadly guaranteed, but\n",
        "366": "   * it is observed to be true for OpenJDK 1.7. It also can't be guaranteed\n",
        "369": "   * @param expectedSize the number of entries you expect to add to the\n",
        "370": "   *        returned map\n",
        "371": "   * @return a new, empty {@code LinkedHashMap} with enough capacity to hold\n",
        "372": "   *         {@code expectedSize} entries without resizing\n",
        "381": "   * Creates a <i>mutable</i>, insertion-ordered {@code LinkedHashMap} instance\n",
        "382": "   * with the same mappings as the specified map.\n",
        "384": "   * <p><b>Note:</b> if mutability is not required, use {@link\n",
        "385": "   * ImmutableMap#copyOf(Map)} instead.\n",
        "387": "   * <p><b>Note for Java 7 and later:</b> this method is now unnecessary and\n",
        "388": "   * should be treated as deprecated. Instead, use the {@code LinkedHashMap}\n",
        "389": "   * constructor directly, taking advantage of the new\n",
        "390": "   * <a href=\"http://goo.gl/iz2Wi\">\"diamond\" syntax</a>.\n",
        "393": "   * @return a new, {@code LinkedHashMap} initialized with the mappings from\n",
        "394": "   *         {@code map}\n",
        "410": "   * Creates a <i>mutable</i>, empty {@code TreeMap} instance using the natural\n",
        "411": "   * ordering of its elements.\n",
        "413": "   * <p><b>Note:</b> if mutability is not required, use {@link\n",
        "414": "   * ImmutableSortedMap#of()} instead.\n",
        "416": "   * <p><b>Note for Java 7 and later:</b> this method is now unnecessary and\n",
        "417": "   * should be treated as deprecated. Instead, use the {@code TreeMap}\n",
        "418": "   * constructor directly, taking advantage of the new\n",
        "428": "   * Creates a <i>mutable</i> {@code TreeMap} instance with the same mappings as\n",
        "429": "   * the specified map and using the same ordering as the specified map.\n",
        "434": "   * <p><b>Note for Java 7 and later:</b> this method is now unnecessary and\n",
        "435": "   * should be treated as deprecated. Instead, use the {@code TreeMap}\n",
        "436": "   * constructor directly, taking advantage of the new\n",
        "439": "   * @param map the sorted map whose mappings are to be placed in the new map\n",
        "440": "   *        and whose comparator is to be used to sort the new map\n",
        "441": "   * @return a new {@code TreeMap} initialized with the mappings from {@code\n",
        "442": "   *         map} and using the comparator of {@code map}\n",
        "449": "   * Creates a <i>mutable</i>, empty {@code TreeMap} instance using the given\n",
        "450": "   * comparator.\n",
        "455": "   * <p><b>Note for Java 7 and later:</b> this method is now unnecessary and\n",
        "456": "   * should be treated as deprecated. Instead, use the {@code TreeMap}\n",
        "457": "   * constructor directly, taking advantage of the new\n",
        "485": "   * <p><b>Note for Java 7 and later:</b> this method is now unnecessary and\n",
        "486": "   * should be treated as deprecated. Instead, use the {@code EnumMap}\n",
        "487": "   * constructor directly, taking advantage of the new\n",
        "491": "   * @return a new {@code EnumMap} initialized with the mappings from {@code\n",
        "492": "   *         map}\n",
        "493": "   * @throws IllegalArgumentException if {@code m} is not an {@code EnumMap}\n",
        "494": "   *         instance and contains no mappings\n",
        "503": "   * <p><b>Note for Java 7 and later:</b> this method is now unnecessary and\n",
        "504": "   * should be treated as deprecated. Instead, use the {@code IdentityHashMap}\n",
        "505": "   * constructor directly, taking advantage of the new\n",
        "506": "   * <a href=\"http://goo.gl/iz2Wi\">\"diamond\" syntax</a>.\n",
        "515": "   * Computes the difference between two maps. This difference is an immutable\n",
        "516": "   * snapshot of the state of the maps at the time this method is called. It\n",
        "517": "   * will never change, even if the maps change at a later time.\n",
        "519": "   * <p>Since this method uses {@code HashMap} instances internally, the keys of\n",
        "520": "   * the supplied maps must be well-behaved with respect to\n",
        "521": "   * {@link Object#equals} and {@link Object#hashCode}.\n",
        "523": "   * <p><b>Note:</b>If you only need to know whether two maps have the same\n",
        "524": "   * mappings, call {@code left.equals(right)} instead of this method.\n",
        "541": "   * Computes the difference between two maps. This difference is an immutable\n",
        "542": "   * snapshot of the state of the maps at the time this method is called. It\n",
        "543": "   * will never change, even if the maps change at a later time.\n",
        "545": "   * <p>Since this method uses {@code HashMap} instances internally, the keys of\n",
        "546": "   * the supplied maps must be well-behaved with respect to\n",
        "547": "   * {@link Object#equals} and {@link Object#hashCode}.\n",
        "551": "   * @param valueEquivalence the equivalence relationship to use to compare\n",
        "552": "   *    values\n",
        "730": "   * Computes the difference between two sorted maps, using the comparator of\n",
        "731": "   * the left map, or {@code Ordering.natural()} if the left map uses the\n",
        "732": "   * natural ordering of its elements. This difference is an immutable snapshot\n",
        "733": "   * of the state of the maps at the time this method is called. It will never\n",
        "734": "   * change, even if the maps change at a later time.\n",
        "736": "   * <p>Since this method uses {@code TreeMap} instances internally, the keys of\n",
        "737": "   * the right map must all compare as distinct according to the comparator\n",
        "738": "   * of the left map.\n",
        "740": "   * <p><b>Note:</b>If you only need to know whether two sorted maps have the\n",
        "741": "   * same mappings, call {@code left.equals(right)} instead of this method.\n",
        "794": "   * Returns the specified comparator if not null; otherwise returns {@code\n",
        "795": "   * Ordering.natural()}. This method is an abomination of generics; the only\n",
        "796": "   * purpose of this method is to contain the ugly type-casting in one place.\n",
        "807": "   * Returns a live {@link Map} view whose keys are the contents of {@code set}\n",
        "808": "   * and whose values are computed on demand using {@code function}. To get an\n",
        "809": "   * immutable <i>copy</i> instead, use {@link #toMap(Iterable, Function)}.\n",
        "810": "   *\n",
        "811": "   * <p>Specifically, for each {@code k} in the backing set, the returned map\n",
        "812": "   * has an entry mapping {@code k} to {@code function.apply(k)}. The {@code\n",
        "813": "   * keySet}, {@code values}, and {@code entrySet} views of the returned map\n",
        "814": "   * iterate in the same order as the backing set.\n",
        "815": "   *\n",
        "816": "   * <p>Modifications to the backing set are read through to the returned map.\n",
        "817": "   * The returned map supports removal operations if the backing set does.\n",
        "818": "   * Removal operations write through to the backing set.  The returned map\n",
        "819": "   * does not support put operations.\n",
        "820": "   *\n",
        "821": "   * <p><b>Warning:</b> If the function rejects {@code null}, caution is\n",
        "822": "   * required to make sure the set does not contain {@code null}, because the\n",
        "823": "   * view cannot stop {@code null} from being added to the set.\n",
        "824": "   *\n",
        "825": "   * <p><b>Warning:</b> This method assumes that for any instance {@code k} of\n",
        "826": "   * key type {@code K}, {@code k.equals(k2)} implies that {@code k2} is also\n",
        "827": "   * of type {@code K}. Using a key type for which this may not hold, such as\n",
        "828": "   * {@code ArrayList}, may risk a {@code ClassCastException} when calling\n",
        "829": "   * methods on the resulting map view.\n",
        "838": "   * Returns a view of the sorted set as a map, mapping keys from the set\n",
        "839": "   * according to the specified function.\n",
        "841": "   * <p>Specifically, for each {@code k} in the backing set, the returned map\n",
        "842": "   * has an entry mapping {@code k} to {@code function.apply(k)}. The {@code\n",
        "843": "   * keySet}, {@code values}, and {@code entrySet} views of the returned map\n",
        "844": "   * iterate in the same order as the backing set.\n",
        "846": "   * <p>Modifications to the backing set are read through to the returned map.\n",
        "847": "   * The returned map supports removal operations if the backing set does.\n",
        "848": "   * Removal operations write through to the backing set.  The returned map does\n",
        "849": "   * not support put operations.\n",
        "851": "   * <p><b>Warning:</b> If the function rejects {@code null}, caution is\n",
        "852": "   * required to make sure the set does not contain {@code null}, because the\n",
        "853": "   * view cannot stop {@code null} from being added to the set.\n",
        "855": "   * <p><b>Warning:</b> This method assumes that for any instance {@code k} of\n",
        "856": "   * key type {@code K}, {@code k.equals(k2)} implies that {@code k2} is also of\n",
        "857": "   * type {@code K}. Using a key type for which this may not hold, such as\n",
        "858": "   * {@code ArrayList}, may risk a {@code ClassCastException} when calling\n",
        "859": "   * methods on the resulting map view.\n",
        "868": "   * Returns a view of the navigable set as a map, mapping keys from the set\n",
        "869": "   * according to the specified function.\n",
        "871": "   * <p>Specifically, for each {@code k} in the backing set, the returned map\n",
        "872": "   * has an entry mapping {@code k} to {@code function.apply(k)}. The {@code\n",
        "873": "   * keySet}, {@code values}, and {@code entrySet} views of the returned map\n",
        "874": "   * iterate in the same order as the backing set.\n",
        "876": "   * <p>Modifications to the backing set are read through to the returned map.\n",
        "877": "   * The returned map supports removal operations if the backing set does.\n",
        "878": "   * Removal operations write through to the backing set.  The returned map\n",
        "879": "   * does not support put operations.\n",
        "881": "   * <p><b>Warning:</b> If the function rejects {@code null}, caution is\n",
        "882": "   * required to make sure the set does not contain {@code null}, because the\n",
        "883": "   * view cannot stop {@code null} from being added to the set.\n",
        "885": "   * <p><b>Warning:</b> This method assumes that for any instance {@code k} of\n",
        "886": "   * key type {@code K}, {@code k.equals(k2)} implies that {@code k2} is also\n",
        "887": "   * of type {@code K}. Using a key type for which this may not hold, such as\n",
        "888": "   * {@code ArrayList}, may risk a {@code ClassCastException} when calling\n",
        "889": "   * methods on the resulting map view.\n",
        "1253": "   * Returns an immutable map whose keys are the distinct elements of {@code\n",
        "1254": "   * keys} and whose value for each key was computed by {@code valueFunction}.\n",
        "1255": "   * The map's iteration order is the order of the first appearance of each key\n",
        "1256": "   * in {@code keys}.\n",
        "1257": "   *\n",
        "1258": "   * <p>When there are multiple instances of a key in {@code keys}, it is\n",
        "1259": "   * unspecified whether {@code valueFunction} will be applied to more than one\n",
        "1260": "   * instance of that key and, if it is, which result will be mapped to that\n",
        "1261": "   * key in the returned map.\n",
        "1262": "   *\n",
        "1263": "   * <p>If {@code keys} is a {@link Set}, a live view can be obtained instead of\n",
        "1264": "   * a copy using {@link Maps#asMap(Set, Function)}.\n",
        "1265": "   *\n",
        "1266": "   * @throws NullPointerException if any element of {@code keys} is\n",
        "1267": "   *     {@code null}, or if {@code valueFunction} produces {@code null}\n",
        "1268": "   *     for any key\n",
        "1277": "   * Returns an immutable map whose keys are the distinct elements of {@code\n",
        "1278": "   * keys} and whose value for each key was computed by {@code valueFunction}.\n",
        "1279": "   * The map's iteration order is the order of the first appearance of each key\n",
        "1280": "   * in {@code keys}.\n",
        "1281": "   *\n",
        "1282": "   * <p>When there are multiple instances of a key in {@code keys}, it is\n",
        "1283": "   * unspecified whether {@code valueFunction} will be applied to more than one\n",
        "1284": "   * instance of that key and, if it is, which result will be mapped to that\n",
        "1285": "   * key in the returned map.\n",
        "1286": "   *\n",
        "1287": "   * @throws NullPointerException if any element of {@code keys} is\n",
        "1288": "   *     {@code null}, or if {@code valueFunction} produces {@code null}\n",
        "1289": "   *     for any key\n",
        "1305": "   * Returns a map with the given {@code values}, indexed by keys derived from\n",
        "1306": "   * those values. In other words, each input value produces an entry in the map\n",
        "1307": "   * whose key is the result of applying {@code keyFunction} to that value.\n",
        "1308": "   * These entries appear in the same order as the input values. Example usage:\n",
        "1309": "   * <pre>   {@code\n",
        "1311": "   *   Color red = new Color(\"red\", 255, 0, 0);\n",
        "1312": "   *   ...\n",
        "1313": "   *   ImmutableSet<Color> allColors = ImmutableSet.of(red, green, blue);\n",
        "1315": "   *   Map<String, Color> colorForName =\n",
        "1316": "   *       uniqueIndex(allColors, toStringFunction());\n",
        "1317": "   *   assertThat(colorForName).containsEntry(\"red\", red);}</pre>\n",
        "1324": "   * @return a map mapping the result of evaluating the function {@code\n",
        "1325": "   *         keyFunction} on each value in the input collection to that value\n",
        "1326": "   * @throws IllegalArgumentException if {@code keyFunction} produces the same\n",
        "1327": "   *         key for more than one value in the input collection\n",
        "1328": "   * @throws NullPointerException if any element of {@code values} is {@code\n",
        "1329": "   *         null}, or if {@code keyFunction} produces {@code null} for any value\n",
        "1339": "   * Returns a map with the given {@code values}, indexed by keys derived from\n",
        "1340": "   * those values. In other words, each input value produces an entry in the map\n",
        "1341": "   * whose key is the result of applying {@code keyFunction} to that value.\n",
        "1342": "   * These entries appear in the same order as the input values. Example usage:\n",
        "1343": "   * <pre>   {@code\n",
        "1345": "   *   Color red = new Color(\"red\", 255, 0, 0);\n",
        "1346": "   *   ...\n",
        "1347": "   *   Iterator<Color> allColors = ImmutableSet.of(red, green, blue).iterator();\n",
        "1349": "   *   Map<String, Color> colorForName =\n",
        "1350": "   *       uniqueIndex(allColors, toStringFunction());\n",
        "1351": "   *   assertThat(colorForName).containsEntry(\"red\", red);}</pre>\n",
        "1358": "   * @return a map mapping the result of evaluating the function {@code\n",
        "1359": "   *         keyFunction} on each value in the input collection to that value\n",
        "1360": "   * @throws IllegalArgumentException if {@code keyFunction} produces the same\n",
        "1361": "   *         key for more than one value in the input collection\n",
        "1362": "   * @throws NullPointerException if any element of {@code values} is {@code\n",
        "1363": "   *         null}, or if {@code keyFunction} produces {@code null} for any value\n",
        "1385": "   * Creates an {@code ImmutableMap<String, String>} from a {@code Properties}\n",
        "1386": "   * instance. Properties normally derive from {@code Map<Object, Object>}, but\n",
        "1387": "   * they typically contain strings, which is awkward. This method lets you get\n",
        "1388": "   * a plain-old-{@code Map} out of a {@code Properties}.\n",
        "1392": "   * @throws ClassCastException if any key in {@code Properties} is not a {@code\n",
        "1393": "   *         String}\n",
        "1394": "   * @throws NullPointerException if any key or value in {@code Properties} is\n",
        "1395": "   *         null\n",
        "1410": "   * Returns an immutable map entry with the specified key and value. The {@link\n",
        "1411": "   * Entry#setValue} operation throws an {@link UnsupportedOperationException}.\n",
        "1424": "   * Returns an unmodifiable view of the specified set of entries. The {@link\n",
        "1425": "   * Entry#setValue} operation throws an {@link UnsupportedOperationException},\n",
        "1426": "   * as do any operations that would modify the returned set.\n",
        "1436": "   * Returns an unmodifiable view of the specified map entry. The {@link\n",
        "1437": "   * Entry#setValue} operation throws an {@link UnsupportedOperationException}.\n",
        "1438": "   * This also has the side-effect of redefining {@code equals} to comply with\n",
        "1439": "   * the Entry contract, to avoid a possible nefarious implementation of equals.\n",
        "1526": "   * Returns a {@link Converter} that converts values using {@link BiMap#get bimap.get()},\n",
        "1527": "   * and whose inverse view converts values using\n",
        "1528": "   * {@link BiMap#inverse bimap.inverse()}{@code .get()}.\n",
        "1530": "   * <p>To use a plain {@link Map} as a {@link Function}, see\n",
        "1531": "   * {@link com.google.common.base.Functions#forMap(Map)} or\n",
        "1532": "   * {@link com.google.common.base.Functions#forMap(Map, Object)}.\n",
        "1588": "   * Returns a synchronized (thread-safe) bimap backed by the specified bimap.\n",
        "1589": "   * In order to guarantee serial access, it is critical that <b>all</b> access\n",
        "1590": "   * to the backing bimap is accomplished through the returned bimap.\n",
        "1591": "   *\n",
        "1592": "   * <p>It is imperative that the user manually synchronize on the returned map\n",
        "1593": "   * when accessing any of its collection views: <pre>   {@code\n",
        "1594": "   *\n",
        "1595": "   *   BiMap<Long, String> map = Maps.synchronizedBiMap(\n",
        "1596": "   *       HashBiMap.<Long, String>create());\n",
        "1597": "   *   ...\n",
        "1598": "   *   Set<Long> set = map.keySet();  // Needn't be in synchronized block\n",
        "1599": "   *   ...\n",
        "1600": "   *   synchronized (map) {  // Synchronizing on map, not set!\n",
        "1601": "   *     Iterator<Long> it = set.iterator(); // Must be in synchronized block\n",
        "1602": "   *     while (it.hasNext()) {\n",
        "1603": "   *       foo(it.next());\n",
        "1604": "   *     }\n",
        "1605": "   *   }}</pre>\n",
        "1609": "   * <p>The returned bimap will be serializable if the specified bimap is\n",
        "1610": "   * serializable.\n",
        "1620": "   * Returns an unmodifiable view of the specified bimap. This method allows\n",
        "1621": "   * modules to provide users with \"read-only\" access to internal bimaps. Query\n",
        "1622": "   * operations on the returned bimap \"read through\" to the specified bimap, and\n",
        "1623": "   * attempts to modify the returned map, whether direct or via its collection\n",
        "1624": "   * views, result in an {@code UnsupportedOperationException}.\n",
        "1626": "   * <p>The returned bimap will be serializable if the specified bimap is\n",
        "1627": "   * serializable.\n",
        "1641": "    @RetainedWith\n",
        "1642": "    BiMap<V, K> inverse;\n",
        "1679": "   * Returns a view of a map where each value is transformed by a function. All\n",
        "1680": "   * other properties of the map, such as iteration order, are left intact. For\n",
        "1681": "   * example, the code: <pre>   {@code\n",
        "1682": "   *\n",
        "1683": "   *   Map<String, Integer> map = ImmutableMap.of(\"a\", 4, \"b\", 9);\n",
        "1684": "   *   Function<Integer, Double> sqrt =\n",
        "1685": "   *       new Function<Integer, Double>() {\n",
        "1686": "   *         public Double apply(Integer in) {\n",
        "1687": "   *           return Math.sqrt((int) in);\n",
        "1688": "   *         }\n",
        "1689": "   *       };\n",
        "1690": "   *   Map<String, Double> transformed = Maps.transformValues(map, sqrt);\n",
        "1691": "   *   System.out.println(transformed);}</pre>\n",
        "1695": "   * <p>Changes in the underlying map are reflected in this view. Conversely,\n",
        "1696": "   * this view supports removal operations, and these are reflected in the\n",
        "1697": "   * underlying map.\n",
        "1699": "   * <p>It's acceptable for the underlying map to contain null keys, and even\n",
        "1700": "   * null values provided that the function is capable of accepting null input.\n",
        "1701": "   * The transformed map might contain null values, if the function sometimes\n",
        "1702": "   * gives a null result.\n",
        "1704": "   * <p>The returned map is not thread-safe or serializable, even if the\n",
        "1705": "   * underlying map is.\n",
        "1707": "   * <p>The function is applied lazily, invoked when needed. This is necessary\n",
        "1708": "   * for the returned map to be a view, but it means that the function will be\n",
        "1709": "   * applied many times for bulk operations like {@link Map#containsValue} and\n",
        "1710": "   * {@code Map.toString()}. For this to perform well, {@code function} should\n",
        "1711": "   * be fast. To avoid lazy evaluation when the returned map doesn't need to be\n",
        "1712": "   * a view, copy the returned map into a new map of your choosing.\n",
        "1720": "   * Returns a view of a sorted map where each value is transformed by a\n",
        "1721": "   * function. All other properties of the map, such as iteration order, are\n",
        "1722": "   * left intact. For example, the code: <pre>   {@code\n",
        "1723": "   *\n",
        "1724": "   *   SortedMap<String, Integer> map = ImmutableSortedMap.of(\"a\", 4, \"b\", 9);\n",
        "1725": "   *   Function<Integer, Double> sqrt =\n",
        "1726": "   *       new Function<Integer, Double>() {\n",
        "1727": "   *         public Double apply(Integer in) {\n",
        "1728": "   *           return Math.sqrt((int) in);\n",
        "1729": "   *         }\n",
        "1730": "   *       };\n",
        "1731": "   *   SortedMap<String, Double> transformed =\n",
        "1732": "   *        Maps.transformValues(map, sqrt);\n",
        "1733": "   *   System.out.println(transformed);}</pre>\n",
        "1737": "   * <p>Changes in the underlying map are reflected in this view. Conversely,\n",
        "1738": "   * this view supports removal operations, and these are reflected in the\n",
        "1739": "   * underlying map.\n",
        "1741": "   * <p>It's acceptable for the underlying map to contain null keys, and even\n",
        "1742": "   * null values provided that the function is capable of accepting null input.\n",
        "1743": "   * The transformed map might contain null values, if the function sometimes\n",
        "1744": "   * gives a null result.\n",
        "1746": "   * <p>The returned map is not thread-safe or serializable, even if the\n",
        "1747": "   * underlying map is.\n",
        "1749": "   * <p>The function is applied lazily, invoked when needed. This is necessary\n",
        "1750": "   * for the returned map to be a view, but it means that the function will be\n",
        "1751": "   * applied many times for bulk operations like {@link Map#containsValue} and\n",
        "1752": "   * {@code Map.toString()}. For this to perform well, {@code function} should\n",
        "1753": "   * be fast. To avoid lazy evaluation when the returned map doesn't need to be\n",
        "1754": "   * a view, copy the returned map into a new map of your choosing.\n",
        "1764": "   * Returns a view of a navigable map where each value is transformed by a\n",
        "1765": "   * function. All other properties of the map, such as iteration order, are\n",
        "1766": "   * left intact.  For example, the code: <pre>   {@code\n",
        "1767": "   *\n",
        "1768": "   *   NavigableMap<String, Integer> map = Maps.newTreeMap();\n",
        "1769": "   *   map.put(\"a\", 4);\n",
        "1770": "   *   map.put(\"b\", 9);\n",
        "1771": "   *   Function<Integer, Double> sqrt =\n",
        "1772": "   *       new Function<Integer, Double>() {\n",
        "1773": "   *         public Double apply(Integer in) {\n",
        "1774": "   *           return Math.sqrt((int) in);\n",
        "1775": "   *         }\n",
        "1776": "   *       };\n",
        "1777": "   *   NavigableMap<String, Double> transformed =\n",
        "1778": "   *        Maps.transformNavigableValues(map, sqrt);\n",
        "1779": "   *   System.out.println(transformed);}</pre>\n",
        "1783": "   * Changes in the underlying map are reflected in this view.\n",
        "1784": "   * Conversely, this view supports removal operations, and these are reflected\n",
        "1785": "   * in the underlying map.\n",
        "1787": "   * <p>It's acceptable for the underlying map to contain null keys, and even\n",
        "1788": "   * null values provided that the function is capable of accepting null input.\n",
        "1789": "   * The transformed map might contain null values, if the function sometimes\n",
        "1790": "   * gives a null result.\n",
        "1792": "   * <p>The returned map is not thread-safe or serializable, even if the\n",
        "1793": "   * underlying map is.\n",
        "1795": "   * <p>The function is applied lazily, invoked when needed. This is necessary\n",
        "1796": "   * for the returned map to be a view, but it means that the function will be\n",
        "1797": "   * applied many times for bulk operations like {@link Map#containsValue} and\n",
        "1798": "   * {@code Map.toString()}. For this to perform well, {@code function} should\n",
        "1799": "   * be fast. To avoid lazy evaluation when the returned map doesn't need to be\n",
        "1800": "   * a view, copy the returned map into a new map of your choosing.\n",
        "1811": "   * Returns a view of a map whose values are derived from the original map's\n",
        "1812": "   * entries. In contrast to {@link #transformValues}, this method's\n",
        "1813": "   * entry-transformation logic may depend on the key as well as the value.\n",
        "1814": "   *\n",
        "1815": "   * <p>All other properties of the transformed map, such as iteration order,\n",
        "1816": "   * are left intact. For example, the code: <pre>   {@code\n",
        "1817": "   *\n",
        "1818": "   *   Map<String, Boolean> options =\n",
        "1819": "   *       ImmutableMap.of(\"verbose\", true, \"sort\", false);\n",
        "1820": "   *   EntryTransformer<String, Boolean, String> flagPrefixer =\n",
        "1821": "   *       new EntryTransformer<String, Boolean, String>() {\n",
        "1822": "   *         public String transformEntry(String key, Boolean value) {\n",
        "1823": "   *           return value ? key : \"no\" + key;\n",
        "1824": "   *         }\n",
        "1825": "   *       };\n",
        "1826": "   *   Map<String, String> transformed =\n",
        "1827": "   *       Maps.transformEntries(options, flagPrefixer);\n",
        "1828": "   *   System.out.println(transformed);}</pre>\n",
        "1832": "   * <p>Changes in the underlying map are reflected in this view. Conversely,\n",
        "1833": "   * this view supports removal operations, and these are reflected in the\n",
        "1834": "   * underlying map.\n",
        "1835": "   *\n",
        "1836": "   * <p>It's acceptable for the underlying map to contain null keys and null\n",
        "1837": "   * values provided that the transformer is capable of accepting null inputs.\n",
        "1838": "   * The transformed map might contain null values if the transformer sometimes\n",
        "1839": "   * gives a null result.\n",
        "1840": "   *\n",
        "1841": "   * <p>The returned map is not thread-safe or serializable, even if the\n",
        "1842": "   * underlying map is.\n",
        "1843": "   *\n",
        "1844": "   * <p>The transformer is applied lazily, invoked when needed. This is\n",
        "1845": "   * necessary for the returned map to be a view, but it means that the\n",
        "1846": "   * transformer will be applied many times for bulk operations like {@link\n",
        "1847": "   * Map#containsValue} and {@link Object#toString}. For this to perform well,\n",
        "1848": "   * {@code transformer} should be fast. To avoid lazy evaluation when the\n",
        "1849": "   * returned map doesn't need to be a view, copy the returned map into a new\n",
        "1850": "   * map of your choosing.\n",
        "1851": "   *\n",
        "1852": "   * <p><b>Warning:</b> This method assumes that for any instance {@code k} of\n",
        "1853": "   * {@code EntryTransformer} key type {@code K}, {@code k.equals(k2)} implies\n",
        "1854": "   * that {@code k2} is also of type {@code K}. Using an {@code\n",
        "1855": "   * EntryTransformer} key type for which this may not hold, such as {@code\n",
        "1856": "   * ArrayList}, may risk a {@code ClassCastException} when calling methods on\n",
        "1857": "   * the transformed map.\n",
        "1867": "   * Returns a view of a sorted map whose values are derived from the original\n",
        "1868": "   * sorted map's entries. In contrast to {@link #transformValues}, this\n",
        "1869": "   * method's entry-transformation logic may depend on the key as well as the\n",
        "1870": "   * value.\n",
        "1871": "   *\n",
        "1872": "   * <p>All other properties of the transformed map, such as iteration order,\n",
        "1873": "   * are left intact. For example, the code: <pre>   {@code\n",
        "1874": "   *\n",
        "1875": "   *   Map<String, Boolean> options =\n",
        "1876": "   *       ImmutableSortedMap.of(\"verbose\", true, \"sort\", false);\n",
        "1877": "   *   EntryTransformer<String, Boolean, String> flagPrefixer =\n",
        "1878": "   *       new EntryTransformer<String, Boolean, String>() {\n",
        "1879": "   *         public String transformEntry(String key, Boolean value) {\n",
        "1880": "   *           return value ? key : \"yes\" + key;\n",
        "1881": "   *         }\n",
        "1882": "   *       };\n",
        "1883": "   *   SortedMap<String, String> transformed =\n",
        "1884": "   *       Maps.transformEntries(options, flagPrefixer);\n",
        "1885": "   *   System.out.println(transformed);}</pre>\n",
        "1889": "   * <p>Changes in the underlying map are reflected in this view. Conversely,\n",
        "1890": "   * this view supports removal operations, and these are reflected in the\n",
        "1891": "   * underlying map.\n",
        "1892": "   *\n",
        "1893": "   * <p>It's acceptable for the underlying map to contain null keys and null\n",
        "1894": "   * values provided that the transformer is capable of accepting null inputs.\n",
        "1895": "   * The transformed map might contain null values if the transformer sometimes\n",
        "1896": "   * gives a null result.\n",
        "1897": "   *\n",
        "1898": "   * <p>The returned map is not thread-safe or serializable, even if the\n",
        "1899": "   * underlying map is.\n",
        "1900": "   *\n",
        "1901": "   * <p>The transformer is applied lazily, invoked when needed. This is\n",
        "1902": "   * necessary for the returned map to be a view, but it means that the\n",
        "1903": "   * transformer will be applied many times for bulk operations like {@link\n",
        "1904": "   * Map#containsValue} and {@link Object#toString}. For this to perform well,\n",
        "1905": "   * {@code transformer} should be fast. To avoid lazy evaluation when the\n",
        "1906": "   * returned map doesn't need to be a view, copy the returned map into a new\n",
        "1907": "   * map of your choosing.\n",
        "1908": "   *\n",
        "1909": "   * <p><b>Warning:</b> This method assumes that for any instance {@code k} of\n",
        "1910": "   * {@code EntryTransformer} key type {@code K}, {@code k.equals(k2)} implies\n",
        "1911": "   * that {@code k2} is also of type {@code K}. Using an {@code\n",
        "1912": "   * EntryTransformer} key type for which this may not hold, such as {@code\n",
        "1913": "   * ArrayList}, may risk a {@code ClassCastException} when calling methods on\n",
        "1914": "   * the transformed map.\n",
        "1924": "   * Returns a view of a navigable map whose values are derived from the\n",
        "1925": "   * original navigable map's entries. In contrast to {@link\n",
        "1926": "   * #transformValues}, this method's entry-transformation logic may\n",
        "1929": "   * <p>All other properties of the transformed map, such as iteration order,\n",
        "1930": "   * are left intact. For example, the code: <pre>   {@code\n",
        "1931": "   *\n",
        "1932": "   *   NavigableMap<String, Boolean> options = Maps.newTreeMap();\n",
        "1933": "   *   options.put(\"verbose\", false);\n",
        "1934": "   *   options.put(\"sort\", true);\n",
        "1935": "   *   EntryTransformer<String, Boolean, String> flagPrefixer =\n",
        "1936": "   *       new EntryTransformer<String, Boolean, String>() {\n",
        "1937": "   *         public String transformEntry(String key, Boolean value) {\n",
        "1938": "   *           return value ? key : (\"yes\" + key);\n",
        "1939": "   *         }\n",
        "1940": "   *       };\n",
        "1941": "   *   NavigableMap<String, String> transformed =\n",
        "1942": "   *       LabsMaps.transformNavigableEntries(options, flagPrefixer);\n",
        "1943": "   *   System.out.println(transformed);}</pre>\n",
        "1947": "   * <p>Changes in the underlying map are reflected in this view.\n",
        "1948": "   * Conversely, this view supports removal operations, and these are reflected\n",
        "1949": "   * in the underlying map.\n",
        "1950": "   *\n",
        "1951": "   * <p>It's acceptable for the underlying map to contain null keys and null\n",
        "1952": "   * values provided that the transformer is capable of accepting null inputs.\n",
        "1953": "   * The transformed map might contain null values if the transformer sometimes\n",
        "1954": "   * gives a null result.\n",
        "1955": "   *\n",
        "1956": "   * <p>The returned map is not thread-safe or serializable, even if the\n",
        "1957": "   * underlying map is.\n",
        "1958": "   *\n",
        "1959": "   * <p>The transformer is applied lazily, invoked when needed. This is\n",
        "1960": "   * necessary for the returned map to be a view, but it means that the\n",
        "1961": "   * transformer will be applied many times for bulk operations like {@link\n",
        "1962": "   * Map#containsValue} and {@link Object#toString}. For this to perform well,\n",
        "1963": "   * {@code transformer} should be fast. To avoid lazy evaluation when the\n",
        "1964": "   * returned map doesn't need to be a view, copy the returned map into a new\n",
        "1965": "   * map of your choosing.\n",
        "1966": "   *\n",
        "1967": "   * <p><b>Warning:</b> This method assumes that for any instance {@code k} of\n",
        "1968": "   * {@code EntryTransformer} key type {@code K}, {@code k.equals(k2)} implies\n",
        "1969": "   * that {@code k2} is also of type {@code K}. Using an {@code\n",
        "1970": "   * EntryTransformer} key type for which this may not hold, such as {@code\n",
        "1971": "   * ArrayList}, may risk a {@code ClassCastException} when calling methods on\n",
        "1972": "   * the transformed map.\n",
        "1983": "   * A transformation of the value of a key-value pair, using both key and value\n",
        "1984": "   * as inputs. To apply the transformation to a map, use\n",
        "1985": "   * {@link Maps#transformEntries(Map, EntryTransformer)}.\n",
        "1995": "     * Determines an output value based on a key-value pair. This method is\n",
        "1996": "     * <i>generally expected</i>, but not absolutely required, to have the\n",
        "1997": "     * following properties:\n",
        "2000": "     * <li>Its execution does not cause any observable side effects.\n",
        "2001": "     * <li>The computation is <i>consistent with equals</i>; that is,\n",
        "2002": "     *     {@link Objects#equal Objects.equal}{@code (k1, k2) &&}\n",
        "2003": "     *     {@link Objects#equal}{@code (v1, v2)} implies that {@code\n",
        "2004": "     *     Objects.equal(transformer.transform(k1, v1),\n",
        "2005": "     *     transformer.transform(k2, v2))}.\n",
        "2008": "     * @throws NullPointerException if the key or value is null and this\n",
        "2009": "     *     transformer does not accept null arguments\n",
        "2014": "  /**\n",
        "2015": "   * Views a function as an entry transformer that ignores the entry key.\n",
        "2016": "   */\n",
        "2039": "  /**\n",
        "2040": "   * Views an entry transformer as a function from {@code Entry} to values.\n",
        "2041": "   */\n",
        "2053": "  /**\n",
        "2054": "   * Returns a view of an entry transformed by the specified transformer.\n",
        "2055": "   */\n",
        "2073": "  /**\n",
        "2074": "   * Views an entry transformer as a function from entries to entries.\n",
        "2075": "   */\n",
        "2347": "   * Returns a map containing the mappings in {@code unfiltered} whose keys\n",
        "2348": "   * satisfy a predicate. The returned map is a live view of {@code unfiltered};\n",
        "2349": "   * changes to one affect the other.\n",
        "2350": "   *\n",
        "2351": "   * <p>The resulting map's {@code keySet()}, {@code entrySet()}, and {@code\n",
        "2352": "   * values()} views have iterators that don't support {@code remove()}, but all\n",
        "2353": "   * other methods are supported by the map and its views. When given a key that\n",
        "2354": "   * doesn't satisfy the predicate, the map's {@code put()} and {@code putAll()}\n",
        "2355": "   * methods throw an {@link IllegalArgumentException}.\n",
        "2356": "   *\n",
        "2357": "   * <p>When methods such as {@code removeAll()} and {@code clear()} are called\n",
        "2358": "   * on the filtered map or its views, only mappings whose keys satisfy the\n",
        "2359": "   * filter will be removed from the underlying map.\n",
        "2360": "   *\n",
        "2361": "   * <p>The returned map isn't threadsafe or serializable, even if {@code\n",
        "2362": "   * unfiltered} is.\n",
        "2363": "   *\n",
        "2364": "   * <p>Many of the filtered map's methods, such as {@code size()},\n",
        "2365": "   * iterate across every key/value mapping in the underlying map and determine\n",
        "2366": "   * which satisfy the filter. When a live view is <i>not</i> needed, it may be\n",
        "2367": "   * faster to copy the filtered map and use the copy.\n",
        "2368": "   *\n",
        "2369": "   * <p><b>Warning:</b> {@code keyPredicate} must be <i>consistent with\n",
        "2370": "   * equals</i>, as documented at {@link Predicate#apply}. Do not provide a\n",
        "2371": "   * predicate such as {@code Predicates.instanceOf(ArrayList.class)}, which is\n",
        "2372": "   * inconsistent with equals.\n",
        "2384": "   * Returns a sorted map containing the mappings in {@code unfiltered} whose\n",
        "2385": "   * keys satisfy a predicate. The returned map is a live view of {@code\n",
        "2386": "   * unfiltered}; changes to one affect the other.\n",
        "2388": "   * <p>The resulting map's {@code keySet()}, {@code entrySet()}, and {@code\n",
        "2389": "   * values()} views have iterators that don't support {@code remove()}, but all\n",
        "2390": "   * other methods are supported by the map and its views. When given a key that\n",
        "2391": "   * doesn't satisfy the predicate, the map's {@code put()} and {@code putAll()}\n",
        "2392": "   * methods throw an {@link IllegalArgumentException}.\n",
        "2394": "   * <p>When methods such as {@code removeAll()} and {@code clear()} are called\n",
        "2395": "   * on the filtered map or its views, only mappings whose keys satisfy the\n",
        "2396": "   * filter will be removed from the underlying map.\n",
        "2398": "   * <p>The returned map isn't threadsafe or serializable, even if {@code\n",
        "2399": "   * unfiltered} is.\n",
        "2401": "   * <p>Many of the filtered map's methods, such as {@code size()},\n",
        "2402": "   * iterate across every key/value mapping in the underlying map and determine\n",
        "2403": "   * which satisfy the filter. When a live view is <i>not</i> needed, it may be\n",
        "2404": "   * faster to copy the filtered map and use the copy.\n",
        "2406": "   * <p><b>Warning:</b> {@code keyPredicate} must be <i>consistent with\n",
        "2407": "   * equals</i>, as documented at {@link Predicate#apply}. Do not provide a\n",
        "2408": "   * predicate such as {@code Predicates.instanceOf(ArrayList.class)}, which is\n",
        "2409": "   * inconsistent with equals.\n",
        "2421": "   * Returns a navigable map containing the mappings in {@code unfiltered} whose\n",
        "2422": "   * keys satisfy a predicate. The returned map is a live view of {@code\n",
        "2423": "   * unfiltered}; changes to one affect the other.\n",
        "2425": "   * <p>The resulting map's {@code keySet()}, {@code entrySet()}, and {@code\n",
        "2426": "   * values()} views have iterators that don't support {@code remove()}, but all\n",
        "2427": "   * other methods are supported by the map and its views. When given a key that\n",
        "2428": "   * doesn't satisfy the predicate, the map's {@code put()} and {@code putAll()}\n",
        "2429": "   * methods throw an {@link IllegalArgumentException}.\n",
        "2431": "   * <p>When methods such as {@code removeAll()} and {@code clear()} are called\n",
        "2432": "   * on the filtered map or its views, only mappings whose keys satisfy the\n",
        "2433": "   * filter will be removed from the underlying map.\n",
        "2435": "   * <p>The returned map isn't threadsafe or serializable, even if {@code\n",
        "2436": "   * unfiltered} is.\n",
        "2438": "   * <p>Many of the filtered map's methods, such as {@code size()},\n",
        "2439": "   * iterate across every key/value mapping in the underlying map and determine\n",
        "2440": "   * which satisfy the filter. When a live view is <i>not</i> needed, it may be\n",
        "2441": "   * faster to copy the filtered map and use the copy.\n",
        "2443": "   * <p><b>Warning:</b> {@code keyPredicate} must be <i>consistent with\n",
        "2444": "   * equals</i>, as documented at {@link Predicate#apply}. Do not provide a\n",
        "2445": "   * predicate such as {@code Predicates.instanceOf(ArrayList.class)}, which is\n",
        "2446": "   * inconsistent with equals.\n",
        "2463": "   * iterators that don't support {@code remove()}, but all other methods are supported by the\n",
        "2464": "   * bimap and its views. When given a key that doesn't satisfy the predicate, the bimap's {@code\n",
        "2465": "   * put()}, {@code forcePut()} and {@code putAll()} methods throw an {@link\n",
        "2466": "   * IllegalArgumentException}.\n",
        "2478": "   * <p><b>Warning:</b> {@code entryPredicate} must be <i>consistent with equals </i>, as\n",
        "2479": "   * documented at {@link Predicate#apply}.\n",
        "2490": "   * Returns a map containing the mappings in {@code unfiltered} whose values\n",
        "2491": "   * satisfy a predicate. The returned map is a live view of {@code unfiltered};\n",
        "2492": "   * changes to one affect the other.\n",
        "2493": "   *\n",
        "2494": "   * <p>The resulting map's {@code keySet()}, {@code entrySet()}, and {@code\n",
        "2495": "   * values()} views have iterators that don't support {@code remove()}, but all\n",
        "2496": "   * other methods are supported by the map and its views. When given a value\n",
        "2497": "   * that doesn't satisfy the predicate, the map's {@code put()}, {@code\n",
        "2498": "   * putAll()}, and {@link Entry#setValue} methods throw an {@link\n",
        "2499": "   * IllegalArgumentException}.\n",
        "2500": "   *\n",
        "2501": "   * <p>When methods such as {@code removeAll()} and {@code clear()} are called\n",
        "2502": "   * on the filtered map or its views, only mappings whose values satisfy the\n",
        "2503": "   * filter will be removed from the underlying map.\n",
        "2504": "   *\n",
        "2505": "   * <p>The returned map isn't threadsafe or serializable, even if {@code\n",
        "2506": "   * unfiltered} is.\n",
        "2507": "   *\n",
        "2508": "   * <p>Many of the filtered map's methods, such as {@code size()},\n",
        "2509": "   * iterate across every key/value mapping in the underlying map and determine\n",
        "2510": "   * which satisfy the filter. When a live view is <i>not</i> needed, it may be\n",
        "2511": "   * faster to copy the filtered map and use the copy.\n",
        "2512": "   *\n",
        "2513": "   * <p><b>Warning:</b> {@code valuePredicate} must be <i>consistent with\n",
        "2514": "   * equals</i>, as documented at {@link Predicate#apply}. Do not provide a\n",
        "2515": "   * predicate such as {@code Predicates.instanceOf(ArrayList.class)}, which is\n",
        "2516": "   * inconsistent with equals.\n",
        "2524": "   * Returns a sorted map containing the mappings in {@code unfiltered} whose\n",
        "2525": "   * values satisfy a predicate. The returned map is a live view of {@code\n",
        "2526": "   * unfiltered}; changes to one affect the other.\n",
        "2527": "   *\n",
        "2528": "   * <p>The resulting map's {@code keySet()}, {@code entrySet()}, and {@code\n",
        "2529": "   * values()} views have iterators that don't support {@code remove()}, but all\n",
        "2530": "   * other methods are supported by the map and its views. When given a value\n",
        "2531": "   * that doesn't satisfy the predicate, the map's {@code put()}, {@code\n",
        "2532": "   * putAll()}, and {@link Entry#setValue} methods throw an {@link\n",
        "2533": "   * IllegalArgumentException}.\n",
        "2534": "   *\n",
        "2535": "   * <p>When methods such as {@code removeAll()} and {@code clear()} are called\n",
        "2536": "   * on the filtered map or its views, only mappings whose values satisfy the\n",
        "2537": "   * filter will be removed from the underlying map.\n",
        "2538": "   *\n",
        "2539": "   * <p>The returned map isn't threadsafe or serializable, even if {@code\n",
        "2540": "   * unfiltered} is.\n",
        "2541": "   *\n",
        "2542": "   * <p>Many of the filtered map's methods, such as {@code size()},\n",
        "2543": "   * iterate across every key/value mapping in the underlying map and determine\n",
        "2544": "   * which satisfy the filter. When a live view is <i>not</i> needed, it may be\n",
        "2545": "   * faster to copy the filtered map and use the copy.\n",
        "2546": "   *\n",
        "2547": "   * <p><b>Warning:</b> {@code valuePredicate} must be <i>consistent with\n",
        "2548": "   * equals</i>, as documented at {@link Predicate#apply}. Do not provide a\n",
        "2549": "   * predicate such as {@code Predicates.instanceOf(ArrayList.class)}, which is\n",
        "2550": "   * inconsistent with equals.\n",
        "2560": "   * Returns a navigable map containing the mappings in {@code unfiltered} whose\n",
        "2561": "   * values satisfy a predicate. The returned map is a live view of {@code\n",
        "2562": "   * unfiltered}; changes to one affect the other.\n",
        "2563": "   *\n",
        "2564": "   * <p>The resulting map's {@code keySet()}, {@code entrySet()}, and {@code\n",
        "2565": "   * values()} views have iterators that don't support {@code remove()}, but all\n",
        "2566": "   * other methods are supported by the map and its views. When given a value\n",
        "2567": "   * that doesn't satisfy the predicate, the map's {@code put()}, {@code\n",
        "2568": "   * putAll()}, and {@link Entry#setValue} methods throw an {@link\n",
        "2569": "   * IllegalArgumentException}.\n",
        "2570": "   *\n",
        "2571": "   * <p>When methods such as {@code removeAll()} and {@code clear()} are called\n",
        "2572": "   * on the filtered map or its views, only mappings whose values satisfy the\n",
        "2573": "   * filter will be removed from the underlying map.\n",
        "2574": "   *\n",
        "2575": "   * <p>The returned map isn't threadsafe or serializable, even if {@code\n",
        "2576": "   * unfiltered} is.\n",
        "2577": "   *\n",
        "2578": "   * <p>Many of the filtered map's methods, such as {@code size()},\n",
        "2579": "   * iterate across every key/value mapping in the underlying map and determine\n",
        "2580": "   * which satisfy the filter. When a live view is <i>not</i> needed, it may be\n",
        "2581": "   * faster to copy the filtered map and use the copy.\n",
        "2582": "   *\n",
        "2583": "   * <p><b>Warning:</b> {@code valuePredicate} must be <i>consistent with\n",
        "2584": "   * equals</i>, as documented at {@link Predicate#apply}. Do not provide a\n",
        "2585": "   * predicate such as {@code Predicates.instanceOf(ArrayList.class)}, which is\n",
        "2586": "   * inconsistent with equals.\n",
        "2597": "   * Returns a bimap containing the mappings in {@code unfiltered} whose values satisfy a\n",
        "2598": "   * predicate. The returned bimap is a live view of {@code unfiltered}; changes to one affect the\n",
        "2599": "   * other.\n",
        "2602": "   * iterators that don't support {@code remove()}, but all other methods are supported by the\n",
        "2603": "   * bimap and its views. When given a value that doesn't satisfy the predicate, the bimap's\n",
        "2604": "   * {@code put()}, {@code forcePut()} and {@code putAll()} methods throw an {@link\n",
        "2619": "   * <p><b>Warning:</b> {@code entryPredicate} must be <i>consistent with equals </i>, as\n",
        "2620": "   * documented at {@link Predicate#apply}.\n",
        "2630": "   * Returns a map containing the mappings in {@code unfiltered} that satisfy a\n",
        "2631": "   * predicate. The returned map is a live view of {@code unfiltered}; changes\n",
        "2632": "   * to one affect the other.\n",
        "2633": "   *\n",
        "2634": "   * <p>The resulting map's {@code keySet()}, {@code entrySet()}, and {@code\n",
        "2635": "   * values()} views have iterators that don't support {@code remove()}, but all\n",
        "2636": "   * other methods are supported by the map and its views. When given a\n",
        "2637": "   * key/value pair that doesn't satisfy the predicate, the map's {@code put()}\n",
        "2638": "   * and {@code putAll()} methods throw an {@link IllegalArgumentException}.\n",
        "2639": "   * Similarly, the map's entries have a {@link Entry#setValue} method that\n",
        "2640": "   * throws an {@link IllegalArgumentException} when the existing key and the\n",
        "2641": "   * provided value don't satisfy the predicate.\n",
        "2642": "   *\n",
        "2643": "   * <p>When methods such as {@code removeAll()} and {@code clear()} are called\n",
        "2644": "   * on the filtered map or its views, only mappings that satisfy the filter\n",
        "2645": "   * will be removed from the underlying map.\n",
        "2646": "   *\n",
        "2647": "   * <p>The returned map isn't threadsafe or serializable, even if {@code\n",
        "2648": "   * unfiltered} is.\n",
        "2649": "   *\n",
        "2650": "   * <p>Many of the filtered map's methods, such as {@code size()},\n",
        "2651": "   * iterate across every key/value mapping in the underlying map and determine\n",
        "2652": "   * which satisfy the filter. When a live view is <i>not</i> needed, it may be\n",
        "2653": "   * faster to copy the filtered map and use the copy.\n",
        "2654": "   *\n",
        "2655": "   * <p><b>Warning:</b> {@code entryPredicate} must be <i>consistent with\n",
        "2656": "   * equals</i>, as documented at {@link Predicate#apply}.\n",
        "2667": "   * Returns a sorted map containing the mappings in {@code unfiltered} that\n",
        "2668": "   * satisfy a predicate. The returned map is a live view of {@code unfiltered};\n",
        "2669": "   * changes to one affect the other.\n",
        "2670": "   *\n",
        "2671": "   * <p>The resulting map's {@code keySet()}, {@code entrySet()}, and {@code\n",
        "2672": "   * values()} views have iterators that don't support {@code remove()}, but all\n",
        "2673": "   * other methods are supported by the map and its views. When given a\n",
        "2674": "   * key/value pair that doesn't satisfy the predicate, the map's {@code put()}\n",
        "2675": "   * and {@code putAll()} methods throw an {@link IllegalArgumentException}.\n",
        "2676": "   * Similarly, the map's entries have a {@link Entry#setValue} method that\n",
        "2677": "   * throws an {@link IllegalArgumentException} when the existing key and the\n",
        "2678": "   * provided value don't satisfy the predicate.\n",
        "2679": "   *\n",
        "2680": "   * <p>When methods such as {@code removeAll()} and {@code clear()} are called\n",
        "2681": "   * on the filtered map or its views, only mappings that satisfy the filter\n",
        "2682": "   * will be removed from the underlying map.\n",
        "2683": "   *\n",
        "2684": "   * <p>The returned map isn't threadsafe or serializable, even if {@code\n",
        "2685": "   * unfiltered} is.\n",
        "2686": "   *\n",
        "2687": "   * <p>Many of the filtered map's methods, such as {@code size()},\n",
        "2688": "   * iterate across every key/value mapping in the underlying map and determine\n",
        "2689": "   * which satisfy the filter. When a live view is <i>not</i> needed, it may be\n",
        "2690": "   * faster to copy the filtered map and use the copy.\n",
        "2691": "   *\n",
        "2692": "   * <p><b>Warning:</b> {@code entryPredicate} must be <i>consistent with\n",
        "2693": "   * equals</i>, as documented at {@link Predicate#apply}.\n",
        "2706": "   * Returns a sorted map containing the mappings in {@code unfiltered} that\n",
        "2707": "   * satisfy a predicate. The returned map is a live view of {@code unfiltered};\n",
        "2708": "   * changes to one affect the other.\n",
        "2709": "   *\n",
        "2710": "   * <p>The resulting map's {@code keySet()}, {@code entrySet()}, and {@code\n",
        "2711": "   * values()} views have iterators that don't support {@code remove()}, but all\n",
        "2712": "   * other methods are supported by the map and its views. When given a\n",
        "2713": "   * key/value pair that doesn't satisfy the predicate, the map's {@code put()}\n",
        "2714": "   * and {@code putAll()} methods throw an {@link IllegalArgumentException}.\n",
        "2715": "   * Similarly, the map's entries have a {@link Entry#setValue} method that\n",
        "2716": "   * throws an {@link IllegalArgumentException} when the existing key and the\n",
        "2717": "   * provided value don't satisfy the predicate.\n",
        "2718": "   *\n",
        "2719": "   * <p>When methods such as {@code removeAll()} and {@code clear()} are called\n",
        "2720": "   * on the filtered map or its views, only mappings that satisfy the filter\n",
        "2721": "   * will be removed from the underlying map.\n",
        "2722": "   *\n",
        "2723": "   * <p>The returned map isn't threadsafe or serializable, even if {@code\n",
        "2724": "   * unfiltered} is.\n",
        "2725": "   *\n",
        "2726": "   * <p>Many of the filtered map's methods, such as {@code size()},\n",
        "2727": "   * iterate across every key/value mapping in the underlying map and determine\n",
        "2728": "   * which satisfy the filter. When a live view is <i>not</i> needed, it may be\n",
        "2729": "   * faster to copy the filtered map and use the copy.\n",
        "2730": "   *\n",
        "2731": "   * <p><b>Warning:</b> {@code entryPredicate} must be <i>consistent with\n",
        "2732": "   * equals</i>, as documented at {@link Predicate#apply}.\n",
        "2752": "   * {@code put()}, {@code forcePut()} and {@code putAll()} methods throw an\n",
        "2753": "   * {@link IllegalArgumentException}. Similarly, the map's entries have an {@link Entry#setValue}\n",
        "2754": "   * method that throws an {@link IllegalArgumentException} when the existing key and the provided\n",
        "2755": "   * value don't satisfy the predicate.\n",
        "2763": "   * <p>Many of the filtered bimap's methods, such as {@code size()}, iterate across every\n",
        "2764": "   * key/value mapping in the underlying bimap and determine which satisfy the filter. When a live\n",
        "2765": "   * view is <i>not</i> needed, it may be faster to copy the filtered bimap and use the copy.\n",
        "2767": "   * <p><b>Warning:</b> {@code entryPredicate} must be <i>consistent with equals </i>, as\n",
        "2768": "   * documented at {@link Predicate#apply}.\n",
        "2782": "   * Support {@code clear()}, {@code removeAll()}, and {@code retainAll()} when\n",
        "2783": "   * filtering a filtered map.\n",
        "2945": "     * Entries in this set satisfy the predicate, but they don't validate the\n",
        "2946": "     * input to {@code Entry.setValue()}.\n",
        "3061": "   * Support {@code clear()}, {@code removeAll()}, and {@code retainAll()} when\n",
        "3062": "   * filtering a filtered sorted map.\n",
        "3166": "   * Support {@code clear()}, {@code removeAll()}, and {@code retainAll()} when\n",
        "3167": "   * filtering a filtered navigable map.\n",
        "3311": "   * Support {@code clear()}, {@code removeAll()}, and {@code retainAll()} when\n",
        "3312": "   * filtering a filtered map.\n",
        "3322": "    @RetainedWith\n",
        "3323": "    private final BiMap<V, K> inverse;\n",
        "3553": "   * Returns a synchronized (thread-safe) navigable map backed by the specified\n",
        "3554": "   * navigable map.  In order to guarantee serial access, it is critical that\n",
        "3555": "   * <b>all</b> access to the backing navigable map is accomplished\n",
        "3556": "   * through the returned navigable map (or its views).\n",
        "3558": "   * <p>It is imperative that the user manually synchronize on the returned\n",
        "3559": "   * navigable map when iterating over any of its collection views, or the\n",
        "3560": "   * collections views of any of its {@code descendingMap}, {@code subMap},\n",
        "3561": "   * {@code headMap} or {@code tailMap} views. <pre>   {@code\n",
        "3563": "   *   NavigableMap<K, V> map = synchronizedNavigableMap(new TreeMap<K, V>());\n",
        "3565": "   *   // Needn't be in synchronized block\n",
        "3566": "   *   NavigableSet<K> set = map.navigableKeySet();\n",
        "3568": "   *   synchronized (map) { // Synchronizing on map, not set!\n",
        "3569": "   *     Iterator<K> it = set.iterator(); // Must be in synchronized block\n",
        "3570": "   *     while (it.hasNext()) {\n",
        "3571": "   *       foo(it.next());\n",
        "3572": "   *     }\n",
        "3573": "   *   }}</pre>\n",
        "3575": "   * <p>or: <pre>   {@code\n",
        "3577": "   *   NavigableMap<K, V> map = synchronizedNavigableMap(new TreeMap<K, V>());\n",
        "3578": "   *   NavigableMap<K, V> map2 = map.subMap(foo, false, bar, true);\n",
        "3580": "   *   // Needn't be in synchronized block\n",
        "3581": "   *   NavigableSet<K> set2 = map2.descendingKeySet();\n",
        "3583": "   *   synchronized (map) { // Synchronizing on map, not map2 or set2!\n",
        "3584": "   *     Iterator<K> it = set2.iterator(); // Must be in synchronized block\n",
        "3585": "   *     while (it.hasNext()) {\n",
        "3586": "   *       foo(it.next());\n",
        "3587": "   *     }\n",
        "3588": "   *   }}</pre>\n",
        "3592": "   * <p>The returned navigable map will be serializable if the specified\n",
        "3593": "   * navigable map is serializable.\n",
        "3595": "   * @param navigableMap the navigable map to be \"wrapped\" in a synchronized\n",
        "3596": "   *    navigable map.\n",
        "3607": "   * {@code AbstractMap} extension that makes it easy to cache customized keySet, values,\n",
        "3608": "   * and entrySet views.\n",
        "3613": "     * Creates the entry set to be returned by {@link #entrySet()}. This method\n",
        "3614": "     * is invoked at most once on a given map, at the time when {@code entrySet}\n",
        "3615": "     * is first called.\n",
        "3699": "   * Delegates to {@link Map#get}. Returns {@code null} on {@code\n",
        "3700": "   * ClassCastException} and {@code NullPointerException}.\n",
        "3712": "   * Delegates to {@link Map#containsKey}. Returns {@code false} on {@code\n",
        "3713": "   * ClassCastException} and {@code NullPointerException}.\n",
        "3725": "   * Delegates to {@link Map#remove}. Returns {@code null} on {@code\n",
        "3726": "   * ClassCastException} and {@code NullPointerException}.\n",
        "3737": "  /**\n",
        "3738": "   * An admittedly inefficient implementation of {@link Map#containsKey}.\n",
        "3739": "   */\n",
        "3744": "  /**\n",
        "3745": "   * An implementation of {@link Map#containsValue}.\n",
        "3746": "   */\n",
        "3752": "   * Implements {@code Collection.contains} safely for forwarding collections of\n",
        "3753": "   * map entries. If {@code o} is an instance of {@code Entry}, it is\n",
        "3754": "   * wrapped using {@link #unmodifiableEntry} to protect against a possible\n",
        "3755": "   * nefarious equals method.\n",
        "3757": "   * <p>Note that {@code c} is the backing (delegate) collection, rather than\n",
        "3758": "   * the forwarding collection.\n",
        "3772": "   * Implements {@code Collection.remove} safely for forwarding collections of\n",
        "3773": "   * map entries. If {@code o} is an instance of {@code Entry}, it is\n",
        "3774": "   * wrapped using {@link #unmodifiableEntry} to protect against a possible\n",
        "3775": "   * nefarious equals method.\n",
        "3777": "   * <p>Note that {@code c} is backing (delegate) collection, rather than the\n",
        "3778": "   * forwarding collection.\n",
        "3791": "  /**\n",
        "3792": "   * An implementation of {@link Map#equals}.\n",
        "3793": "   */\n",
        "3804": "  /**\n",
        "3805": "   * An implementation of {@link Map#toString}.\n",
        "3806": "   */\n",
        "3820": "  /**\n",
        "3821": "   * An implementation of {@link Map#putAll}.\n",
        "3822": "   */\n",
        "4364": "  /**\n",
        "4365": "   * Returns a map from the ith element of list to i.\n",
        "4366": "   */\n",
        "4379": "   * <p>This method delegates to the appropriate methods of {@link NavigableMap} (namely\n",
        "4380": "   * {@link NavigableMap#subMap(Object, boolean, Object, boolean) subMap()},\n",
        "4381": "   * {@link NavigableMap#tailMap(Object, boolean) tailMap()}, and\n",
        "4382": "   * {@link NavigableMap#headMap(Object, boolean) headMap()}) to actually construct the view.\n",
        "4383": "   * Consult these methods for a full description of the returned view's behavior.\n",
        "4386": "   * ordering. {@code NavigableMap} on the other hand can specify a custom ordering via a\n",
        "4387": "   * {@link Comparator}, which can violate the natural ordering. Using this method (or in general\n",
        "4388": "   * using {@code Range}) with unnaturally-ordered maps can lead to unexpected and undefined\n",
        "4389": "   * behavior.\n"
    }
}