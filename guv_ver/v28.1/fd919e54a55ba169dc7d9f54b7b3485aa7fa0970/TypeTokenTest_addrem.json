{
    "addition": {
        "71": "    } catch (IllegalStateException expected) {\n",
        "72": "    }\n",
        "99": "    assertEquals(Types.newParameterizedType(Local.class, String.class), type.getType());\n",
        "110": "    assertEquals(Types.newParameterizedType(Local.class, String.class), type.getType());\n",
        "132": "    TypeToken<?> returnType =\n",
        "133": "        new TypeToken<List<String>>() {}.resolveType(getFromList.getGenericReturnType());\n",
        "138": "      void testResolveType_fromTypeVariable() {\n",
        "140": "    assertEquals(String.class, f.resolveType(Function.class.getTypeParameters()[0]).getType());\n",
        "141": "    assertEquals(Integer.class, f.resolveType(Function.class.getTypeParameters()[1]).getType());\n",
        "142": "    assertEquals(Long.class, f.resolveType(Iterable.class.getTypeParameters()[0]).getType());\n",
        "146": "      void testResolveType_fromTypeVariable_onlyDirectBoundsAreUsed() {\n",
        "148": "    assertEquals(Integer.class, e.resolveType(Iterable.class.getTypeParameters()[0]).getType());\n",
        "152": "    ParameterizedType withWildcardType =\n",
        "153": "        (ParameterizedType) new TypeCapture<Comparable<? extends Iterable<String>>>() {}.capture();\n",
        "155": "    assertEquals(\n",
        "156": "        String.class, wildcardType.resolveType(Iterable.class.getTypeParameters()[0]).getType());\n",
        "193": "    makeUnmodifiable(types)\n",
        "194": "        .containsExactly(\n",
        "195": "            new TypeToken<Class3<String>>() {},\n",
        "196": "            new TypeToken<Interface3<String>>() {},\n",
        "197": "            new TypeToken<Iterable<String>>() {},\n",
        "198": "            TypeToken.of(Class2.class),\n",
        "199": "            TypeToken.of(Interface12.class),\n",
        "200": "            TypeToken.of(Interface1.class),\n",
        "201": "            TypeToken.of(Interface2.class),\n",
        "202": "            TypeToken.of(Class1.class),\n",
        "203": "            TypeToken.of(Object.class));\n",
        "204": "    makeUnmodifiable(types.interfaces())\n",
        "205": "        .containsExactly(\n",
        "206": "            new TypeToken<Interface3<String>>() {},\n",
        "207": "            TypeToken.of(Interface12.class),\n",
        "208": "            TypeToken.of(Interface1.class),\n",
        "209": "            TypeToken.of(Interface2.class),\n",
        "210": "            new TypeToken<Iterable<String>>() {});\n",
        "211": "    makeUnmodifiable(types.classes())\n",
        "212": "        .containsExactly(\n",
        "213": "            new TypeToken<Class3<String>>() {},\n",
        "214": "            TypeToken.of(Class2.class),\n",
        "215": "            TypeToken.of(Class1.class),\n",
        "216": "            TypeToken.of(Object.class));\n",
        "224": "    makeUnmodifiable(types.rawTypes())\n",
        "225": "        .containsExactly(\n",
        "226": "            Class3.class,\n",
        "227": "            Interface3.class,\n",
        "228": "            Iterable.class,\n",
        "229": "            Class2.class,\n",
        "230": "            Interface12.class,\n",
        "231": "            Interface1.class,\n",
        "232": "            Interface2.class,\n",
        "233": "            Class1.class,\n",
        "234": "            Object.class);\n",
        "235": "    makeUnmodifiable(types.interfaces().rawTypes())\n",
        "236": "        .containsExactly(\n",
        "237": "            Interface3.class,\n",
        "238": "            Interface12.class,\n",
        "239": "            Interface1.class,\n",
        "240": "            Interface2.class,\n",
        "241": "            Iterable.class);\n",
        "242": "    makeUnmodifiable(types.classes().rawTypes())\n",
        "243": "        .containsExactly(Class3.class, Class2.class, Class1.class, Object.class);\n",
        "248": "      void testGetTypes_ignoresTypeVariablesByDefault() {\n",
        "250": "    makeUnmodifiable(types)\n",
        "251": "        .containsExactly(\n",
        "252": "            TypeToken.of(Interface1.class), TypeToken.of(Class1.class), TypeToken.of(Object.class));\n",
        "261": "      void testGetTypes_rawTypes_ignoresTypeVariablesByDefault() {\n",
        "271": "  public <A extends Interface1 & Interface2 & Interface3<String>> void testGetTypes_manyBounds() {\n",
        "359": "    assertSubtypeBeforeSupertype(ImmutableList.of(String.class, CharSequence.class));\n",
        "364": "      assertSubtypeBeforeSupertype(ImmutableList.of(CharSequence.class, String.class));\n",
        "373": "      assertSubtypeBeforeSupertype(ImmutableList.of(String.class, String.class));\n",
        "382": "    assertEquals(TypeToken.of(Object.class), new TypeToken<Object[]>() {}.getGenericSuperclass());\n",
        "384": "    assertEquals(\n",
        "385": "        TypeToken.of(Object.class), new TypeToken<List<String>[]>() {}.getGenericSuperclass());\n",
        "392": "    assertEquals(\n",
        "393": "        String.class, ((ParameterizedType) superToken.getType()).getActualTypeArguments()[0]);\n",
        "399": "    assertEquals(\n",
        "400": "        TypeToken.of(Object.class),\n",
        "406": "      void testGetGenericSuperclass_typeVariable_boundIsClass() {\n",
        "407": "    assertEquals(\n",
        "408": "        new TypeToken<ArrayList<String>>() {},\n",
        "414": "      void testGetGenericSuperclass_typeVariable_boundIsFBoundedClass() {\n",
        "415": "    assertEquals(\n",
        "416": "        new TypeToken<Enum<T>>() {},\n",
        "422": "      void testGetGenericSuperclass_typeVariable_boundIsInterface() {\n",
        "428": "      void testGetGenericSuperclass_typeVariable_boundIsTypeVariableAndClass() {\n",
        "429": "    assertEquals(\n",
        "430": "        TypeToken.of(new TypeCapture<T>() {}.capture()),\n",
        "436": "      void testGetGenericSuperclass_typeVariable_boundIsTypeVariableAndInterface() {\n",
        "442": "    assertEquals(\n",
        "443": "        TypeToken.of(Object.class),\n",
        "445": "    assertEquals(\n",
        "446": "        new TypeToken<Object>() {},\n",
        "448": "    assertEquals(\n",
        "449": "        new TypeToken<Object>() {},\n",
        "454": "    assertEquals(\n",
        "455": "        TypeToken.of(Object.class),\n",
        "457": "    assertEquals(\n",
        "458": "        new TypeToken<Object[]>() {},\n",
        "464": "    assertEquals(\n",
        "465": "        new TypeToken<CharSequence[]>() {},\n",
        "479": "  public <T extends NoInterface & Iterable<String>>\n",
        "480": "      void testGetGenericInterfaces_typeVariable_boundsAreClassWithInterface() {\n",
        "486": "  public <T extends CharSequence & Iterable<String>>\n",
        "487": "      void testGetGenericInterfaces_typeVariable_boundsAreInterfaces() {\n",
        "493": "  public <T extends CharSequence & Iterable<T>>\n",
        "494": "      void testGetGenericInterfaces_typeVariable_boundsAreFBoundedInterfaces() {\n",
        "500": "  public <T extends Base & Iterable<T>>\n",
        "501": "      void testGetGenericInterfaces_typeVariable_boundsAreClassWithFBoundedInterface() {\n",
        "508": "      void testGetGenericInterfaces_typeVariable_boundIsTypeVariableAndClass() {\n",
        "514": "      void testGetGenericInterfaces_typeVariable_boundIsTypeVariableAndInterface() {\n",
        "544": "    for (TypeToken<?> interfaceType :\n",
        "545": "        new TypeToken<Implementation<Integer, String>>() {}.getGenericInterfaces()) {\n",
        "548": "    assertEquals(\n",
        "549": "        ImmutableMap.of(\n",
        "567": "  private abstract static class Implementation<K, V> implements Iterable<V>, Map<K, V> {}\n",
        "594": "    assertTrue(\n",
        "595": "        TypeToken.of(Object.class).isSupertypeOf(TypeToken.of(new TypeCapture<T>() {}.capture())));\n",
        "596": "    assertFalse(\n",
        "597": "        TypeToken.of(int.class).isSupertypeOf(TypeToken.of(new TypeCapture<T>() {}.capture())));\n",
        "607": "    assertTrue(TypeToken.of(Object[].class.getSuperclass()).isSupertypeOf(new TypeToken<T[]>() {}));\n",
        "609": "      assertTrue(TypeToken.of(interfaceType).isSupertypeOf(new TypeToken<T[]>() {}));\n",
        "708": "    assertTrue(tokL.isSupertypeOf(StringList.class.getGenericInterfaces()[0]));\n",
        "738": "    assertTrue(tokS.isSupertypeOf(new TypeToken<Third<String, Integer>>() {}));\n",
        "764": "    assertTrue(tokenL.isSupertypeOf(StringList.class.getGenericInterfaces()[0]));\n",
        "765": "    assertFalse(tokenL.isSupertypeOf(IntegerList.class.getGenericInterfaces()[0]));\n",
        "768": "    assertTrue(tokenF.isSupertypeOf(ConcreteIS.class.getGenericSuperclass()));\n",
        "769": "    assertFalse(tokenF.isSupertypeOf(ConcreteSI.class.getGenericSuperclass()));\n",
        "774": "    TypeToken<ArrayList<String>[]> token = new TypeToken<ArrayList<String>[]>() {};\n",
        "787": "    assertTrue(tokenF.isSupertypeOf(new TypeToken<Third<String, Integer>>() {}));\n",
        "788": "    assertFalse(tokenF.isSupertypeOf(new TypeToken<Third<Integer, String>>() {}));\n",
        "789": "    assertTrue(tokenF.isSupertypeOf(new TypeToken<Fourth<Integer, String>>() {}));\n",
        "790": "    assertFalse(tokenF.isSupertypeOf(new TypeToken<Fourth<String, Integer>>() {}));\n",
        "802": "    List<TypeToken<?>> allTokens =\n",
        "803": "        ImmutableList.of(\n",
        "804": "            unboundedToken,\n",
        "805": "            upperBoundToken,\n",
        "806": "            lowerBoundToken,\n",
        "807": "            concreteToken,\n",
        "808": "            subtypeToken,\n",
        "809": "            supertypeToken);\n",
        "830": "      assertEquals(\n",
        "831": "          typeToken.toString(), typeToken == concreteToken, concreteToken.isSupertypeOf(typeToken));\n",
        "835": "      assertEquals(\n",
        "836": "          typeToken.toString(), typeToken == subtypeToken, subtypeToken.isSupertypeOf(typeToken));\n",
        "840": "      assertEquals(\n",
        "841": "          typeToken.toString(),\n",
        "842": "          typeToken == supertypeToken,\n",
        "843": "          supertypeToken.isSupertypeOf(typeToken));\n",
        "849": "    assertAssignable(\n",
        "850": "        TypeToken.of(new TypeCapture<N1>() {}.capture()),\n",
        "852": "    assertNotAssignable(new TypeToken<List<N11>>() {}, new TypeToken<List<N1>>() {});\n",
        "853": "    assertNotAssignable(\n",
        "854": "        new TypeToken<Number>() {}, TypeToken.of(new TypeCapture<N1>() {}.capture()));\n",
        "855": "    assertAssignable(\n",
        "856": "        TypeToken.of(new TypeCapture<N11>() {}.capture()),\n",
        "858": "    assertNotAssignable(\n",
        "859": "        TypeToken.of(new TypeCapture<N2>() {}.capture()),\n",
        "865": "    assertAssignable(\n",
        "866": "        new TypeToken<List<? extends N1>>() {}, new TypeToken<List<? extends N1>>() {});\n",
        "867": "    assertAssignable(new TypeToken<List<? super N1>>() {}, new TypeToken<List<? super N1>>() {});\n",
        "868": "    assertAssignable(\n",
        "869": "        new TypeToken<List<? extends Number>>() {}, new TypeToken<List<? extends Number>>() {});\n",
        "870": "    assertAssignable(\n",
        "871": "        new TypeToken<List<? super Number>>() {}, new TypeToken<List<? super Number>>() {});\n",
        "875": "    assertAssignable(new TypeToken<List<? super N>>() {}, new TypeToken<List<?>>() {});\n",
        "876": "    assertAssignable(new TypeToken<List<N>>() {}, new TypeToken<List<?>>() {});\n",
        "882": "    assertAssignable(new TypeToken<List<N11>>() {}, new TypeToken<List<? extends N1>>() {});\n",
        "883": "    assertNotAssignable(new TypeToken<List<N1>>() {}, new TypeToken<List<? extends N11>>() {});\n",
        "884": "    assertNotAssignable(new TypeToken<List<Number>>() {}, new TypeToken<List<? extends N11>>() {});\n",
        "887": "    assertAssignable(new TypeToken<List<N1>>() {}, new TypeToken<List<? extends Number>>() {});\n",
        "888": "    assertAssignable(new TypeToken<ArrayList<N1>>() {}, new TypeToken<List<? extends Number>>() {});\n",
        "889": "    assertAssignable(\n",
        "890": "        new TypeToken<List<? extends N11>>() {}, new TypeToken<List<? extends Number>>() {});\n",
        "896": "    assertAssignable(new TypeToken<List<N1>>() {}, new TypeToken<List<? super N11>>() {});\n",
        "897": "    assertAssignable(new TypeToken<ArrayList<Number>>() {}, new TypeToken<List<? super N1>>() {});\n",
        "898": "    assertNotAssignable(\n",
        "899": "        new TypeToken<ArrayList<? super N11>>() {}, new TypeToken<List<? super Number>>() {});\n",
        "900": "    assertAssignable(\n",
        "901": "        new TypeToken<ArrayList<? super N1>>() {}, new TypeToken<List<? super N11>>() {});\n",
        "902": "    assertAssignable(\n",
        "903": "        new TypeToken<ArrayList<? super Number>>() {}, new TypeToken<List<? super N11>>() {});\n",
        "906": "    assertNotAssignable(\n",
        "907": "        new TypeToken<ArrayList<N11>>() {}, new TypeToken<List<? super Number>>() {});\n",
        "908": "    assertAssignable(\n",
        "909": "        new TypeToken<ArrayList<Number>>() {}, new TypeToken<List<? super Number>>() {});\n",
        "910": "    assertAssignable(\n",
        "911": "        new TypeToken<ArrayList<Object>>() {}, new TypeToken<List<? super Number>>() {});\n",
        "916": "    assertAssignable(\n",
        "917": "        TypeToken.of(new TypeCapture<L>() {}.capture()),\n",
        "919": "    assertNotAssignable(\n",
        "920": "        TypeToken.of(new TypeCapture<R>() {}.capture()),\n",
        "922": "    assertAssignable(TypeToken.of(new TypeCapture<L>() {}.capture()), new TypeToken<List<R>>() {});\n",
        "933": "  public <From extends String & List<? extends String>> void testMultipleTypeBoundsAssignability() {\n",
        "940": "  private static <N1 extends Number, N11 extends N1> void assignabilityTestWithTypeVariables() {\n",
        "1005": "    assertEquals(\n",
        "1006": "        TypeToken.of(new TypeCapture<T>() {}.capture()),\n",
        "1012": "    assertEquals(\n",
        "1013": "        Types.subtypeOf(Object.class),\n",
        "1015": "    assertEquals(\n",
        "1016": "        Types.subtypeOf(Object[].class),\n",
        "1019": "    assertEquals(\n",
        "1020": "        int.class, TypeToken.of(Types.subtypeOf(int[].class)).getComponentType().getType());\n",
        "1029": "        new TypeToken<NumberList<? extends Number>>() {}, new TypeToken<NumberList<?>>() {});\n",
        "1031": "        new TypeToken<NumberList<? super Integer>>() {}, new TypeToken<NumberList<?>>() {});\n",
        "1035": "    assertAssignable(new TypeToken<List<T>>() {}, new TypeToken<List<? extends Readable>>() {});\n",
        "1036": "    assertAssignable(new TypeToken<List<T>>() {}, new TypeToken<List<? extends Appendable>>() {});\n",
        "1045": "    assertEquals(\n",
        "1046": "        Types.newParameterizedType(Iterable.class, Iterable.class.getTypeParameters()[0]),\n",
        "1077": "    ParameterizedType expectedType =\n",
        "1078": "        Types.newParameterizedType(\n",
        "1079": "            Iterable.class,\n",
        "1080": "            Types.newParameterizedType(List.class, ListIterable.class.getTypeParameters()[0]));\n",
        "1081": "    assertEquals(\n",
        "1082": "        expectedType, TypeToken.of(ListIterable.class).getSupertype(Iterable.class).getType());\n",
        "1085": "  public <A, T extends Number & Iterable<A>>\n",
        "1086": "      void testGetSupertype_typeVariableWithMultipleBounds() {\n",
        "1087": "    assertEquals(\n",
        "1088": "        Number.class, new TypeToken<T>(getClass()) {}.getSupertype(Number.class).getType());\n",
        "1089": "    assertEquals(\n",
        "1090": "        new TypeToken<Iterable<A>>() {},\n",
        "1095": "    ParameterizedType expectedType =\n",
        "1096": "        Types.newParameterizedType(\n",
        "1097": "            Iterable.class, Types.newParameterizedType(List.class, String.class));\n",
        "1098": "    assertEquals(\n",
        "1099": "        expectedType,\n",
        "1105": "    TypeToken<ListIterable<String>> listIterableType =\n",
        "1106": "        (TypeToken<ListIterable<String>>)\n",
        "1107": "            TypeToken.of(StringListIterable.class).getSupertype(ListIterable.class);\n",
        "1108": "    ParameterizedType expectedType =\n",
        "1109": "        Types.newParameterizedType(\n",
        "1110": "            Iterable.class, Types.newParameterizedType(List.class, String.class));\n",
        "1115": "    assertEquals(\n",
        "1116": "        new TypeToken<Iterable<List<String>>[]>() {},\n",
        "1121": "    assertEquals(\n",
        "1122": "        Object[].class, TypeToken.of(String[].class).getSupertype(Object[].class).getType());\n",
        "1128": "    TypeToken<? extends List<String>> type =\n",
        "1129": "        (TypeToken<? extends List<String>>)\n",
        "1130": "            TypeToken.of(Types.subtypeOf(new TypeToken<List<String>>() {}.getType()));\n",
        "1137": "    assertEquals(\n",
        "1138": "        new TypeToken<Iterable<String>>() {}, typeVariableToken.getSupertype(Iterable.class));\n",
        "1143": "    assertEquals(\n",
        "1144": "        Types.newParameterizedType(Iterable.class, List.class.getTypeParameters()[0]),\n",
        "1153": "    } catch (IllegalArgumentException expected) {\n",
        "1154": "    }\n",
        "1158": "    assertEquals(\n",
        "1159": "        new TypeToken<Iterable<String>[]>() {},\n",
        "1166": "    ParameterizedType expectedType =\n",
        "1167": "        Types.newParameterizedType(\n",
        "1168": "            Map.class,\n",
        "1169": "            ListMap.class.getTypeParameters()[0],\n",
        "1170": "            Types.newParameterizedType(List.class, ListMap.class.getTypeParameters()[1]));\n",
        "1171": "    assertEquals(expectedType, TypeToken.of(ListMap.class).getSupertype(Map.class).getType());\n",
        "1176": "    assertEquals(\n",
        "1177": "        expectedType,\n",
        "1185": "    assertEquals(\n",
        "1186": "        expectedType, new TypeToken<StringListMap<V>>() {}.getSupertype(Map.class).getType());\n",
        "1190": "    assertEquals(\n",
        "1191": "        new TypeToken<ListIterable<String>>() {},\n",
        "1193": "    assertEquals(\n",
        "1194": "        new TypeToken<ListArrayIterable<String>>() {},\n",
        "1196": "    assertEquals(\n",
        "1197": "        new TypeToken<ListArrayIterable<String>[]>() {},\n",
        "1202": "    assertEquals(\n",
        "1203": "        StringListIterable.class,\n",
        "1205": "    assertEquals(\n",
        "1206": "        StringListIterable[].class,\n",
        "1208": "    assertEquals(\n",
        "1209": "        TypeToken.of(StringListArrayIterable.class),\n",
        "1211": "    assertEquals(\n",
        "1212": "        TypeToken.of(StringListArrayIterable[].class),\n",
        "1217": "    assertEquals(\n",
        "1218": "        TypeToken.of(StringListIterable[].class),\n",
        "1220": "    assertEquals(\n",
        "1221": "        TypeToken.of(String[].class), TypeToken.of(Object[].class).getSubtype(String[].class));\n",
        "1222": "    assertEquals(TypeToken.of(int[].class), TypeToken.of(Object.class).getSubtype(int[].class));\n",
        "1227": "    TypeToken<? super Iterable<String>> type =\n",
        "1228": "        (TypeToken<? super Iterable<String>>)\n",
        "1229": "            TypeToken.of(Types.supertypeOf(new TypeToken<Iterable<String>>() {}.getType()));\n",
        "1235": "    TypeToken<? super Iterable<String>> type =\n",
        "1236": "        (TypeToken<? super Iterable<String>>)\n",
        "1237": "            TypeToken.of(Types.supertypeOf(new TypeToken<ImmutableList<String>>() {}.getType()));\n",
        "1241": "    } catch (IllegalArgumentException expected) {\n",
        "1242": "    }\n",
        "1247": "    TypeToken<? extends Iterable<String>> type =\n",
        "1248": "        (TypeToken<? extends Iterable<String>>)\n",
        "1249": "            TypeToken.of(Types.subtypeOf(new TypeToken<Iterable<String>>() {}.getType()));\n",
        "1253": "    } catch (IllegalArgumentException expected) {\n",
        "1254": "    }\n",
        "1261": "    } catch (IllegalArgumentException expected) {\n",
        "1262": "    }\n",
        "1271": "    assertEquals(\n",
        "1272": "        new TypeToken<List<String>[]>() {},\n",
        "1279": "    TypeToken<TwoTypeArgs<?, ?>> supertype = new TypeToken<TwoTypeArgs<?, ?>>() {};\n",
        "1283": "    assertEquals(\n",
        "1284": "        new TypeToken<StringForFirstTypeArg<?>>() {}, supertype.getSubtype(subtype.getRawType()));\n",
        "1301": "    ParameterizedType actualSubtype =\n",
        "1302": "        (ParameterizedType) supertype.getSubtype(subtype.getRawType()).getType();\n",
        "1315": "    assertEquals(new TypeToken<OuterTypeVar<?>>() {}, type.getSubtype(OuterTypeVar.class));\n",
        "1356": "    TypeToken<ArrayList<String>> subtype = new TypeToken<ArrayList<String>>() {};\n",
        "1369": "    TypeToken<MySpecialList<String, ?>> subtype = new TypeToken<MySpecialList<String, ?>>() {};\n",
        "1383": "    Class<?> actualSubtype = (Class<?>) supertype.getSubtype(subtype.getRawType()).getType();\n",
        "1396": "    ParameterizedType actualSubtype =\n",
        "1397": "        (ParameterizedType) supertype.getSubtype(subtype.getRawType()).getType();\n",
        "1410": "    assertEquals(\n",
        "1411": "        new TypeToken<ThreeTypeArgs<T, Integer, ?>>() {},\n",
        "1419": "\n",
        "1422": "    ParameterizedType subtype =\n",
        "1423": "        (ParameterizedType)\n",
        "1424": "            new TypeToken<BaseWithTypeVar<List<?>>>() {}.getSubtype(Outer.Sub.class).getType();\n",
        "1447": "    assertThat(barType.getSubtype(SubBar.class)).isEqualTo(new SubBar<Void>().fieldTypeAsSubBar());\n",
        "1454": "      type.where(\n",
        "1455": "          new TypeParameter<T>() {},\n",
        "1458": "    } catch (IllegalArgumentException expected) {\n",
        "1459": "    }\n",
        "1463": "    assertEquals(new TypeToken<Map<String, Integer>>() {}, mapOf(String.class, Integer.class));\n",
        "1477": "    TypeToken<?> parameterType =\n",
        "1478": "        type.resolveType(\n",
        "1479": "            Holder.class.getDeclaredMethod(\"setList\", List.class).getGenericParameterTypes()[0]);\n",
        "1481": "    assertFalse(\n",
        "1482": "        parameterType.getType().toString(),\n",
        "1488": "    TypeToken<?> matrixType =\n",
        "1489": "        type.resolveType(Holder.class.getDeclaredField(\"matrix\").getGenericType());\n",
        "1491": "    assertThat(matrixType.getType()).isNotEqualTo(new TypeToken<List<?>[]>() {}.getType());\n",
        "1496": "    TypeToken<?> parameterType =\n",
        "1497": "        type.resolveType(\n",
        "1498": "            Holder.class.getDeclaredMethod(\"setList\", List.class).getGenericParameterTypes()[0]);\n",
        "1508": "    TypeToken<?> parameterType =\n",
        "1509": "        type.resolveType(\n",
        "1510": "            Holder.class.getDeclaredMethod(\"setList\", List.class).getGenericParameterTypes()[0]);\n",
        "1526": "    TypeToken<?> fieldType =\n",
        "1527": "        type.resolveType(Counter.class.getDeclaredField(\"counts\").getGenericType());\n",
        "1539": "    TypeToken<?> fieldType =\n",
        "1540": "        type.resolveType(Counter.class.getDeclaredField(\"counts\").getGenericType());\n",
        "1553": "    TypeToken<?> fieldType =\n",
        "1554": "        type.resolveType(Counter.class.getDeclaredField(\"counts\").getGenericType());\n",
        "1559": "    assertThat(captured.getBounds())\n",
        "1560": "        .asList()\n",
        "1578": "    assertEquals(\n",
        "1579": "        TypeToken.of(List.class), TypeToken.of(List.class).method(sizeMethod).getOwnerType());\n",
        "1580": "    assertEquals(\n",
        "1581": "        new TypeToken<List<String>>() {},\n",
        "1590": "    } catch (IllegalArgumentException expected) {\n",
        "1591": "    }\n",
        "1603": "    Invokable<T, String> invokable =\n",
        "1604": "        new TypeToken<T>(getClass()) {}.method(getMethod).returning(String.class);\n",
        "1608": "  public <T extends List<String>> void testMethod_parameterTypes() throws NoSuchMethodException {\n",
        "1644": "    assertEquals(\n",
        "1645": "        TypeToken.of(ArrayList.class),\n",
        "1647": "    assertEquals(\n",
        "1648": "        new TypeToken<ArrayList<String>>() {},\n",
        "1657": "    } catch (IllegalArgumentException expected) {\n",
        "1658": "    }\n",
        "1666": "    } catch (IllegalArgumentException expected) {\n",
        "1667": "    }\n",
        "1722": "    assertNoTypeVariable(new TypeCapture<Iterable<? extends String>>() {}.capture());\n",
        "1723": "    assertNoTypeVariable(new TypeCapture<Iterable<? super String>>() {}.capture());\n",
        "1727": "    assertNoTypeVariable(new TypeCapture<Iterable<? extends String>[]>() {}.capture());\n",
        "1735": "    assertHasTypeVariable(new TypeCapture<Map<String, ? extends T>>() {}.capture());\n",
        "1736": "    assertHasTypeVariable(new TypeCapture<Map<String, ? super T[]>>() {}.capture());\n",
        "1772": "    } catch (IllegalArgumentException expected) {\n",
        "1773": "    }\n",
        "1782": "\n",
        "1784": "\n",
        "1786": "\n",
        "1788": "\n",
        "1790": "\n",
        "1791": "    abstract <T2 extends CharSequence & Iterable<T2>> void acceptT2(T2 t2);\n",
        "1795": "        assertEquals(\n",
        "1796": "            method.getReturnType(), TypeToken.of(method.getGenericReturnType()).getRawType());\n",
        "1798": "          assertEquals(\n",
        "1799": "              method.getParameterTypes()[i],\n",
        "1809": "    assertEquals(\n",
        "1810": "        CharSequence.class, TypeToken.of(Types.subtypeOf(CharSequence.class)).getRawType());\n",
        "1821": "    assertEquals(String.class, new IKnowMyType<String>() {}.type().getType());\n",
        "1822": "    assertEquals(\n",
        "1823": "        new TypeToken<Map<String, Integer>>() {},\n",
        "1842": "    } catch (RuntimeException expected) {\n",
        "1843": "    }\n",
        "1850": "    } catch (RuntimeException expected) {\n",
        "1851": "    }\n",
        "1863": "    new EqualsTester().addEqualityGroup(object, copy).testEquals();\n",
        "1870": "    TypeToken<Map<String, Integer>> reserialized =\n",
        "1871": "        reserialize(new TypeToken<Map<String, Integer>>() {});\n",
        "1923": "        .addEqualityGroup(new TypeToken<List<String>>() {}, new TypeToken<List<String>>() {})\n",
        "1924": "        .addEqualityGroup(new TypeToken<List<?>>() {}, new TypeToken<List<?>>() {})\n",
        "1925": "        .addEqualityGroup(new TypeToken<Map<A, ?>>() {}, new TypeToken<Map<A, ?>>() {})\n",
        "1926": "        .addEqualityGroup(new TypeToken<Map<B, ?>>() {})\n",
        "1942": "    return new TypeToken<Map<K, V>>() {}.where(new TypeParameter<K>() {}, keyType)\n",
        "1947": "    return new TypeToken<T[]>() {}.where(new TypeParameter<T>() {}, componentType);\n",
        "1951": "    new NullPointerTester().testAllPublicStaticMethods(TypeToken.class);\n",
        "1976": "        from.getType() + \" is expected to be a subtype of \" + to.getType(), from.isSubtypeOf(to));\n",
        "1981": "        from.getType() + \" shouldn't be assignable to \" + to.getType(), to.isSupertypeOf(from));\n",
        "1983": "        to.getType() + \" shouldn't be a supertype of \" + from.getType(), to.isSupertypeOf(from));\n",
        "1985": "        from.getType() + \" shouldn't be a subtype of \" + to.getType(), from.isSubtypeOf(to));\n",
        "2026": "\n",
        "2028": "\n",
        "2030": "\n",
        "2032": "    private interface Base {}\n"
    },
    "removed": {
        "71": "    } catch (IllegalStateException expected) {}\n",
        "98": "    assertEquals(Types.newParameterizedType(Local.class, String.class),\n",
        "99": "        type.getType());\n",
        "110": "    assertEquals(Types.newParameterizedType(Local.class, String.class),\n",
        "111": "        type.getType());\n",
        "133": "    TypeToken<?> returnType = new TypeToken<List<String>>() {}\n",
        "134": "        .resolveType(getFromList.getGenericReturnType());\n",
        "139": "  void testResolveType_fromTypeVariable() {\n",
        "141": "    assertEquals(String.class,\n",
        "142": "        f.resolveType(Function.class.getTypeParameters()[0]).getType());\n",
        "143": "    assertEquals(Integer.class,\n",
        "144": "        f.resolveType(Function.class.getTypeParameters()[1]).getType());\n",
        "145": "    assertEquals(Long.class,\n",
        "146": "        f.resolveType(Iterable.class.getTypeParameters()[0]).getType());\n",
        "150": "  void testResolveType_fromTypeVariable_onlyDirectBoundsAreUsed() {\n",
        "152": "    assertEquals(Integer.class,\n",
        "153": "        e.resolveType(Iterable.class.getTypeParameters()[0]).getType());\n",
        "157": "    ParameterizedType withWildcardType = (ParameterizedType)\n",
        "158": "        new TypeCapture<Comparable<? extends Iterable<String>>>() {}.capture();\n",
        "160": "    assertEquals(String.class,\n",
        "161": "        wildcardType.resolveType(Iterable.class.getTypeParameters()[0]).getType());\n",
        "198": "    makeUnmodifiable(types).containsExactly(\n",
        "199": "        new TypeToken<Class3<String>>() {},\n",
        "200": "        new TypeToken<Interface3<String>>() {},\n",
        "201": "        new TypeToken<Iterable<String>>() {},\n",
        "202": "        TypeToken.of(Class2.class),\n",
        "203": "        TypeToken.of(Interface12.class),\n",
        "204": "        TypeToken.of(Interface1.class),\n",
        "205": "        TypeToken.of(Interface2.class),\n",
        "206": "        TypeToken.of(Class1.class),\n",
        "207": "        TypeToken.of(Object.class));\n",
        "208": "    makeUnmodifiable(types.interfaces()).containsExactly(\n",
        "209": "        new TypeToken<Interface3<String>>() {},\n",
        "210": "        TypeToken.of(Interface12.class),\n",
        "211": "        TypeToken.of(Interface1.class),\n",
        "212": "        TypeToken.of(Interface2.class),\n",
        "213": "        new TypeToken<Iterable<String>>() {});\n",
        "214": "    makeUnmodifiable(types.classes()).containsExactly(\n",
        "215": "        new TypeToken<Class3<String>>() {},\n",
        "216": "        TypeToken.of(Class2.class),\n",
        "217": "        TypeToken.of(Class1.class),\n",
        "218": "        TypeToken.of(Object.class));\n",
        "226": "    makeUnmodifiable(types.rawTypes()).containsExactly(\n",
        "227": "        Class3.class, Interface3.class,\n",
        "228": "        Iterable.class,\n",
        "229": "        Class2.class,\n",
        "230": "        Interface12.class,\n",
        "231": "        Interface1.class,\n",
        "232": "        Interface2.class,\n",
        "233": "        Class1.class,\n",
        "234": "        Object.class);\n",
        "235": "    makeUnmodifiable(types.interfaces().rawTypes()).containsExactly(\n",
        "236": "        Interface3.class,\n",
        "237": "        Interface12.class,\n",
        "238": "        Interface1.class,\n",
        "239": "        Interface2.class,\n",
        "240": "        Iterable.class);\n",
        "241": "    makeUnmodifiable(types.classes().rawTypes()).containsExactly(\n",
        "242": "        Class3.class,\n",
        "243": "        Class2.class,\n",
        "244": "        Class1.class,\n",
        "245": "        Object.class);\n",
        "250": "  void testGetTypes_ignoresTypeVariablesByDefault() {\n",
        "252": "    makeUnmodifiable(types).containsExactly(\n",
        "253": "        TypeToken.of(Interface1.class), TypeToken.of(Class1.class),\n",
        "254": "        TypeToken.of(Object.class));\n",
        "263": "  void testGetTypes_rawTypes_ignoresTypeVariablesByDefault() {\n",
        "273": "  public <A extends Interface1 & Interface2 & Interface3<String>>\n",
        "274": "  void testGetTypes_manyBounds() {\n",
        "362": "    assertSubtypeBeforeSupertype(\n",
        "363": "        ImmutableList.of(String.class, CharSequence.class));\n",
        "368": "      assertSubtypeBeforeSupertype(\n",
        "369": "          ImmutableList.of(CharSequence.class, String.class));\n",
        "378": "      assertSubtypeBeforeSupertype(\n",
        "379": "          ImmutableList.of(String.class, String.class));\n",
        "388": "    assertEquals(TypeToken.of(Object.class),\n",
        "389": "        new TypeToken<Object[]>() {}.getGenericSuperclass());\n",
        "391": "    assertEquals(TypeToken.of(Object.class),\n",
        "392": "        new TypeToken<List<String>[]>() {}.getGenericSuperclass());\n",
        "399": "    assertEquals(String.class,\n",
        "400": "        ((ParameterizedType) superToken.getType()).getActualTypeArguments()[0]);\n",
        "406": "    assertEquals(TypeToken.of(Object.class),\n",
        "412": "  void testGetGenericSuperclass_typeVariable_boundIsClass() {\n",
        "413": "    assertEquals(new TypeToken<ArrayList<String>>() {},\n",
        "419": "  void testGetGenericSuperclass_typeVariable_boundIsFBoundedClass() {\n",
        "420": "    assertEquals(new TypeToken<Enum<T>>() {},\n",
        "426": "  void testGetGenericSuperclass_typeVariable_boundIsInterface() {\n",
        "432": "  void testGetGenericSuperclass_typeVariable_boundIsTypeVariableAndClass() {\n",
        "433": "    assertEquals(TypeToken.of(new TypeCapture<T>() {}.capture()),\n",
        "439": "  void testGetGenericSuperclass_typeVariable_boundIsTypeVariableAndInterface() {\n",
        "445": "    assertEquals(TypeToken.of(Object.class),\n",
        "447": "    assertEquals(new TypeToken<Object>() {},\n",
        "449": "    assertEquals(new TypeToken<Object>() {},\n",
        "454": "    assertEquals(TypeToken.of(Object.class),\n",
        "456": "    assertEquals(new TypeToken<Object[]>() {},\n",
        "462": "    assertEquals(new TypeToken<CharSequence[]>() {},\n",
        "476": "  public <T extends NoInterface&Iterable<String>>\n",
        "477": "  void testGetGenericInterfaces_typeVariable_boundsAreClassWithInterface() {\n",
        "483": "  public <T extends CharSequence&Iterable<String>>\n",
        "484": "  void testGetGenericInterfaces_typeVariable_boundsAreInterfaces() {\n",
        "490": "  public <T extends CharSequence&Iterable<T>>\n",
        "491": "  void testGetGenericInterfaces_typeVariable_boundsAreFBoundedInterfaces() {\n",
        "497": "  public <T extends Base&Iterable<T>>\n",
        "498": "  void testGetGenericInterfaces_typeVariable_boundsAreClassWithFBoundedInterface() {\n",
        "505": "  void testGetGenericInterfaces_typeVariable_boundIsTypeVariableAndClass() {\n",
        "511": "  void testGetGenericInterfaces_typeVariable_boundIsTypeVariableAndInterface() {\n",
        "541": "    for (TypeToken<?> interfaceType\n",
        "542": "        : new TypeToken<Implementation<Integer, String>>() {}.getGenericInterfaces()) {\n",
        "545": "    assertEquals(ImmutableMap.of(\n",
        "559": "  private abstract static class Implementation<K, V>\n",
        "560": "      implements Iterable<V>, Map<K, V> {}\n",
        "587": "    assertTrue(TypeToken.of(Object.class).isSupertypeOf(\n",
        "588": "        TypeToken.of(new TypeCapture<T>() {}.capture())));\n",
        "589": "    assertFalse(TypeToken.of(int.class).isSupertypeOf(\n",
        "590": "        TypeToken.of(new TypeCapture<T>() {}.capture())));\n",
        "600": "    assertTrue(TypeToken.of(Object[].class.getSuperclass())\n",
        "601": "        .isSupertypeOf(new TypeToken<T[]>() {}));\n",
        "603": "      assertTrue(TypeToken.of(interfaceType)\n",
        "604": "          .isSupertypeOf(new TypeToken<T[]>() {}));\n",
        "703": "    assertTrue(tokL.isSupertypeOf(\n",
        "704": "        StringList.class.getGenericInterfaces()[0]));\n",
        "734": "    assertTrue(tokS.isSupertypeOf(\n",
        "735": "        new TypeToken<Third<String, Integer>>() {}));\n",
        "761": "    assertTrue(tokenL.isSupertypeOf(\n",
        "762": "        StringList.class.getGenericInterfaces()[0]));\n",
        "763": "    assertFalse(tokenL.isSupertypeOf(\n",
        "764": "        IntegerList.class.getGenericInterfaces()[0]));\n",
        "767": "    assertTrue(tokenF.isSupertypeOf(\n",
        "768": "        ConcreteIS.class.getGenericSuperclass()));\n",
        "769": "    assertFalse(tokenF.isSupertypeOf(\n",
        "770": "        ConcreteSI.class.getGenericSuperclass()));\n",
        "775": "    TypeToken<ArrayList<String>[]> token =\n",
        "776": "        new TypeToken<ArrayList<String>[]>() {};\n",
        "789": "    assertTrue(tokenF.isSupertypeOf(\n",
        "790": "        new TypeToken<Third<String, Integer>>() {}));\n",
        "791": "    assertFalse(tokenF.isSupertypeOf(\n",
        "792": "        new TypeToken<Third<Integer, String>>() {}));\n",
        "793": "    assertTrue(tokenF.isSupertypeOf(\n",
        "794": "        new TypeToken<Fourth<Integer, String>>() {}));\n",
        "795": "    assertFalse(tokenF.isSupertypeOf(\n",
        "796": "        new TypeToken<Fourth<String, Integer>>() {}));\n",
        "808": "    List<TypeToken<?>> allTokens = ImmutableList.of(\n",
        "809": "        unboundedToken, upperBoundToken, lowerBoundToken,\n",
        "810": "        concreteToken, subtypeToken, supertypeToken);\n",
        "831": "      assertEquals(typeToken.toString(),\n",
        "832": "          typeToken == concreteToken, concreteToken.isSupertypeOf(typeToken));\n",
        "836": "      assertEquals(typeToken.toString(),\n",
        "837": "          typeToken == subtypeToken, subtypeToken.isSupertypeOf(typeToken));\n",
        "841": "      assertEquals(typeToken.toString(),\n",
        "842": "          typeToken == supertypeToken, supertypeToken.isSupertypeOf(typeToken));\n",
        "848": "    assertAssignable(TypeToken.of(new TypeCapture<N1>() {}.capture()),\n",
        "849": "        TypeToken.of(new TypeCapture<N1>() {}.capture()));\n",
        "850": "    assertNotAssignable(new TypeToken<List<N11>>() {},\n",
        "851": "        new TypeToken<List<N1>>() {});\n",
        "852": "    assertNotAssignable(new TypeToken<Number>() {},\n",
        "854": "    assertAssignable(TypeToken.of(new TypeCapture<N11>() {}.capture()),\n",
        "856": "    assertNotAssignable(TypeToken.of(new TypeCapture<N2>() {}.capture()),\n",
        "862": "    assertAssignable(new TypeToken<List<? extends N1>>() {},\n",
        "863": "        new TypeToken<List<? extends N1>>() {});\n",
        "864": "    assertAssignable(new TypeToken<List<? super N1>>() {},\n",
        "865": "        new TypeToken<List<? super N1>>() {});\n",
        "866": "    assertAssignable(new TypeToken<List<? extends Number>>() {},\n",
        "867": "        new TypeToken<List<? extends Number>>() {});\n",
        "868": "    assertAssignable(new TypeToken<List<? super Number>>() {},\n",
        "869": "        new TypeToken<List<? super Number>>() {});\n",
        "873": "    assertAssignable(new TypeToken<List<? super N>>() {},\n",
        "874": "        new TypeToken<List<?>>() {});\n",
        "875": "    assertAssignable(new TypeToken<List<N>>() {},\n",
        "876": "        new TypeToken<List<?>>() {});\n",
        "882": "    assertAssignable(new TypeToken<List<N11>>() {},\n",
        "883": "        new TypeToken<List<? extends N1>>() {});\n",
        "884": "    assertNotAssignable(new TypeToken<List<N1>>() {},\n",
        "885": "        new TypeToken<List<? extends N11>>() {});\n",
        "886": "    assertNotAssignable(new TypeToken<List<Number>>() {},\n",
        "887": "        new TypeToken<List<? extends N11>>() {});\n",
        "890": "    assertAssignable(new TypeToken<List<N1>>() {},\n",
        "891": "        new TypeToken<List<? extends Number>>() {});\n",
        "892": "    assertAssignable(new TypeToken<ArrayList<N1>>() {},\n",
        "893": "        new TypeToken<List<? extends Number>>() {});\n",
        "894": "    assertAssignable(new TypeToken<List<? extends N11>>() {},\n",
        "895": "        new TypeToken<List<? extends Number>>() {});\n",
        "901": "    assertAssignable(new TypeToken<List<N1>>() {},\n",
        "902": "        new TypeToken<List<? super N11>>() {});\n",
        "903": "    assertAssignable(new TypeToken<ArrayList<Number>>() {},\n",
        "904": "        new TypeToken<List<? super N1>>() {});\n",
        "905": "    assertNotAssignable(new TypeToken<ArrayList<? super N11>>() {},\n",
        "906": "        new TypeToken<List<? super Number>>() {});\n",
        "907": "    assertAssignable(new TypeToken<ArrayList<? super N1>>() {},\n",
        "908": "        new TypeToken<List<? super N11>>() {});\n",
        "909": "    assertAssignable(new TypeToken<ArrayList<? super Number>>() {},\n",
        "910": "        new TypeToken<List<? super N11>>() {});\n",
        "913": "    assertNotAssignable(new TypeToken<ArrayList<N11>>() {},\n",
        "914": "        new TypeToken<List<? super Number>>() {});\n",
        "915": "    assertAssignable(new TypeToken<ArrayList<Number>>() {},\n",
        "916": "        new TypeToken<List<? super Number>>() {});\n",
        "917": "    assertAssignable(new TypeToken<ArrayList<Object>>() {},\n",
        "918": "        new TypeToken<List<? super Number>>() {});\n",
        "923": "    assertAssignable(TypeToken.of(new TypeCapture<L>() {}.capture()),\n",
        "925": "    assertNotAssignable(TypeToken.of(new TypeCapture<R>() {}.capture()),\n",
        "927": "    assertAssignable(TypeToken.of(new TypeCapture<L>() {}.capture()),\n",
        "928": "        new TypeToken<List<R>>() {});\n",
        "939": "  public <From extends String&List<? extends String>>\n",
        "940": "  void testMultipleTypeBoundsAssignability() {\n",
        "947": "  private static <N1 extends Number, N11 extends N1>\n",
        "948": "      void assignabilityTestWithTypeVariables() {\n",
        "1013": "    assertEquals(TypeToken.of(new TypeCapture<T>() {}.capture()),\n",
        "1019": "    assertEquals(Types.subtypeOf(Object.class),\n",
        "1021": "    assertEquals(Types.subtypeOf(Object[].class),\n",
        "1024": "    assertEquals(int.class,\n",
        "1025": "        TypeToken.of(Types.subtypeOf(int[].class)).getComponentType().getType());\n",
        "1034": "        new TypeToken<NumberList<? extends Number>>() {},\n",
        "1035": "        new TypeToken<NumberList<?>>() {});\n",
        "1037": "        new TypeToken<NumberList<? super Integer>>() {},\n",
        "1038": "        new TypeToken<NumberList<?>>() {});\n",
        "1042": "    assertAssignable(new TypeToken<List<T>>() {},\n",
        "1043": "        new TypeToken<List<? extends Readable>>() {});\n",
        "1044": "    assertAssignable(new TypeToken<List<T>>() {},\n",
        "1045": "        new TypeToken<List<? extends Appendable>>() {});\n",
        "1054": "    assertEquals(Types.newParameterizedType(Iterable.class, Iterable.class.getTypeParameters()[0]),\n",
        "1082": "    ParameterizedType expectedType = Types.newParameterizedType(Iterable.class,\n",
        "1083": "        Types.newParameterizedType(List.class, ListIterable.class.getTypeParameters()[0]));\n",
        "1084": "    assertEquals(expectedType,\n",
        "1085": "        TypeToken.of(ListIterable.class).getSupertype(Iterable.class).getType());\n",
        "1088": "  public <A, T extends Number&Iterable<A>>\n",
        "1089": "  void testGetSupertype_typeVariableWithMultipleBounds() {\n",
        "1090": "    assertEquals(Number.class,\n",
        "1091": "        new TypeToken<T>(getClass()) {}.getSupertype(Number.class).getType());\n",
        "1092": "    assertEquals(new TypeToken<Iterable<A>>() {},\n",
        "1097": "    ParameterizedType expectedType = Types.newParameterizedType(Iterable.class,\n",
        "1098": "        Types.newParameterizedType(List.class, String.class));\n",
        "1099": "    assertEquals(expectedType,\n",
        "1105": "    TypeToken<ListIterable<String>> listIterableType = (TypeToken<ListIterable<String>>)\n",
        "1106": "        TypeToken.of(StringListIterable.class).getSupertype(ListIterable.class);\n",
        "1107": "    ParameterizedType expectedType = Types.newParameterizedType(Iterable.class,\n",
        "1108": "        Types.newParameterizedType(List.class, String.class));\n",
        "1113": "    assertEquals(new TypeToken<Iterable<List<String>>[]>() {},\n",
        "1118": "    assertEquals(Object[].class,\n",
        "1119": "        TypeToken.of(String[].class).getSupertype(Object[].class).getType());\n",
        "1125": "    TypeToken<? extends List<String>> type = (TypeToken<? extends List<String>>)\n",
        "1126": "        TypeToken.of(Types.subtypeOf(new TypeToken<List<String>>() {}.getType()));\n",
        "1133": "    assertEquals(new TypeToken<Iterable<String>>() {},\n",
        "1134": "        typeVariableToken.getSupertype(Iterable.class));\n",
        "1139": "    assertEquals(Types.newParameterizedType(Iterable.class, List.class.getTypeParameters()[0]),\n",
        "1148": "    } catch (IllegalArgumentException expected) {}\n",
        "1152": "    assertEquals(new TypeToken<Iterable<String>[]>() {},\n",
        "1159": "    ParameterizedType expectedType = Types.newParameterizedType(Map.class,\n",
        "1160": "        ListMap.class.getTypeParameters()[0],\n",
        "1161": "        Types.newParameterizedType(List.class, ListMap.class.getTypeParameters()[1]));\n",
        "1162": "    assertEquals(expectedType,\n",
        "1163": "        TypeToken.of(ListMap.class).getSupertype(Map.class).getType());\n",
        "1168": "    assertEquals(expectedType,\n",
        "1176": "    assertEquals(expectedType,\n",
        "1177": "        new TypeToken<StringListMap<V>>() {}.getSupertype(Map.class).getType());\n",
        "1181": "    assertEquals(new TypeToken<ListIterable<String>>() {},\n",
        "1183": "    assertEquals(new TypeToken<ListArrayIterable<String>>() {},\n",
        "1185": "    assertEquals(new TypeToken<ListArrayIterable<String>[]>() {},\n",
        "1190": "    assertEquals(StringListIterable.class,\n",
        "1192": "    assertEquals(StringListIterable[].class,\n",
        "1194": "    assertEquals(TypeToken.of(StringListArrayIterable.class),\n",
        "1196": "    assertEquals(TypeToken.of(StringListArrayIterable[].class),\n",
        "1201": "    assertEquals(TypeToken.of(StringListIterable[].class),\n",
        "1203": "    assertEquals(TypeToken.of(String[].class),\n",
        "1204": "        TypeToken.of(Object[].class).getSubtype(String[].class));\n",
        "1205": "    assertEquals(TypeToken.of(int[].class),\n",
        "1206": "        TypeToken.of(Object.class).getSubtype(int[].class));\n",
        "1211": "    TypeToken<? super Iterable<String>> type = (TypeToken<? super Iterable<String>>)\n",
        "1212": "        TypeToken.of(Types.supertypeOf(new TypeToken<Iterable<String>>() {}.getType()));\n",
        "1218": "    TypeToken<? super Iterable<String>> type = (TypeToken<? super Iterable<String>>)\n",
        "1219": "        TypeToken.of(Types.supertypeOf(new TypeToken<ImmutableList<String>>() {}.getType()));\n",
        "1223": "    } catch (IllegalArgumentException expected) {}\n",
        "1228": "    TypeToken<? extends Iterable<String>> type = (TypeToken<? extends Iterable<String>>)\n",
        "1229": "        TypeToken.of(Types.subtypeOf(new TypeToken<Iterable<String>>() {}.getType()));\n",
        "1233": "    } catch (IllegalArgumentException expected) {}\n",
        "1240": "    } catch (IllegalArgumentException expected) {}\n",
        "1249": "    assertEquals(new TypeToken<List<String>[]>() {},\n",
        "1256": "    TypeToken<TwoTypeArgs<?, ?>> supertype =\n",
        "1257": "        new TypeToken<TwoTypeArgs<?, ?>>() {};\n",
        "1261": "    assertEquals(new TypeToken<StringForFirstTypeArg<?>>() {},\n",
        "1262": "        supertype.getSubtype(subtype.getRawType()));\n",
        "1279": "    ParameterizedType actualSubtype = (ParameterizedType)\n",
        "1280": "        supertype.getSubtype(subtype.getRawType()).getType();\n",
        "1293": "    assertEquals(new TypeToken<OuterTypeVar<?>>() {},\n",
        "1294": "        type.getSubtype(OuterTypeVar.class));\n",
        "1335": "    TypeToken<ArrayList<String>> subtype =\n",
        "1336": "        new TypeToken<ArrayList<String>>() {};\n",
        "1349": "    TypeToken<MySpecialList<String, ?>> subtype =\n",
        "1350": "        new TypeToken<MySpecialList<String, ?>>() {};\n",
        "1364": "    Class<?> actualSubtype =\n",
        "1365": "        (Class<?>) supertype.getSubtype(subtype.getRawType()).getType();\n",
        "1378": "    ParameterizedType actualSubtype = (ParameterizedType)\n",
        "1379": "        supertype.getSubtype(subtype.getRawType()).getType();\n",
        "1392": "    assertEquals(new TypeToken<ThreeTypeArgs<T, Integer, ?>>() {},\n",
        "1402": "    ParameterizedType subtype = (ParameterizedType) new TypeToken<BaseWithTypeVar<List<?>>>() {}\n",
        "1403": "            .getSubtype(Outer.Sub.class)\n",
        "1404": "            .getType();\n",
        "1427": "    assertThat(barType.getSubtype(SubBar.class))\n",
        "1428": "        .isEqualTo(new SubBar<Void>().fieldTypeAsSubBar());\n",
        "1435": "      type.where(new TypeParameter<T>() {},\n",
        "1438": "    } catch (IllegalArgumentException expected) {}\n",
        "1442": "    assertEquals(\n",
        "1443": "        new TypeToken<Map<String, Integer>>() {},\n",
        "1444": "        mapOf(String.class, Integer.class));\n",
        "1457": "    TypeToken<?> parameterType = type.resolveType(\n",
        "1458": "        Holder.class.getDeclaredMethod(\"setList\", List.class).getGenericParameterTypes()[0]);\n",
        "1460": "    assertFalse(parameterType.getType().toString(),\n",
        "1466": "    TypeToken<?> matrixType = type.resolveType(\n",
        "1467": "        Holder.class.getDeclaredField(\"matrix\").getGenericType());\n",
        "1469": "    assertThat(matrixType.getType())\n",
        "1470": "        .isNotEqualTo(new TypeToken<List<?>[]>() {}.getType());\n",
        "1475": "    TypeToken<?> parameterType = type.resolveType(\n",
        "1476": "        Holder.class.getDeclaredMethod(\"setList\", List.class).getGenericParameterTypes()[0]);\n",
        "1486": "    TypeToken<?> parameterType = type.resolveType(\n",
        "1487": "        Holder.class.getDeclaredMethod(\"setList\", List.class).getGenericParameterTypes()[0]);\n",
        "1503": "    TypeToken<?> fieldType = type.resolveType(\n",
        "1504": "        Counter.class.getDeclaredField(\"counts\").getGenericType());\n",
        "1516": "    TypeToken<?> fieldType = type.resolveType(\n",
        "1517": "        Counter.class.getDeclaredField(\"counts\").getGenericType());\n",
        "1530": "    TypeToken<?> fieldType = type.resolveType(\n",
        "1531": "        Counter.class.getDeclaredField(\"counts\").getGenericType());\n",
        "1536": "    assertThat(captured.getBounds()).asList()\n",
        "1554": "    assertEquals(TypeToken.of(List.class),\n",
        "1555": "        TypeToken.of(List.class).method(sizeMethod).getOwnerType());\n",
        "1556": "    assertEquals(new TypeToken<List<String>>() {},\n",
        "1565": "    } catch (IllegalArgumentException expected) {}\n",
        "1577": "    Invokable<T, String> invokable = new TypeToken<T>(getClass()) {}\n",
        "1578": "        .method(getMethod)\n",
        "1579": "        .returning(String.class);\n",
        "1583": "  public <T extends List<String>> void testMethod_parameterTypes()\n",
        "1584": "      throws NoSuchMethodException {\n",
        "1620": "    assertEquals(TypeToken.of(ArrayList.class),\n",
        "1622": "    assertEquals(new TypeToken<ArrayList<String>>() {},\n",
        "1631": "    } catch (IllegalArgumentException expected) {}\n",
        "1639": "    } catch (IllegalArgumentException expected) {}\n",
        "1694": "    assertNoTypeVariable(\n",
        "1695": "        new TypeCapture<Iterable<? extends String>>() {}.capture());\n",
        "1696": "    assertNoTypeVariable(\n",
        "1697": "        new TypeCapture<Iterable<? super String>>() {}.capture());\n",
        "1701": "    assertNoTypeVariable(\n",
        "1702": "        new TypeCapture<Iterable<? extends String>[]>() {}.capture());\n",
        "1710": "    assertHasTypeVariable(\n",
        "1711": "        new TypeCapture<Map<String, ? extends T>>() {}.capture());\n",
        "1712": "    assertHasTypeVariable(\n",
        "1713": "        new TypeCapture<Map<String, ? super T[]>>() {}.capture());\n",
        "1749": "    } catch (IllegalArgumentException expected) {}\n",
        "1762": "    abstract <T2 extends CharSequence&Iterable<T2>> void acceptT2(T2 t2);\n",
        "1766": "        assertEquals(method.getReturnType(),\n",
        "1767": "            TypeToken.of(method.getGenericReturnType()).getRawType());\n",
        "1769": "          assertEquals(method.getParameterTypes()[i],\n",
        "1779": "    assertEquals(CharSequence.class,\n",
        "1780": "        TypeToken.of(Types.subtypeOf(CharSequence.class)).getRawType());\n",
        "1791": "    assertEquals(String.class,\n",
        "1792": "        new IKnowMyType<String>() {}.type().getType());\n",
        "1793": "    assertEquals(new TypeToken<Map<String, Integer>>() {},\n",
        "1812": "    } catch (RuntimeException expected) {}\n",
        "1819": "    } catch (RuntimeException expected) {}\n",
        "1831": "    new EqualsTester()\n",
        "1832": "        .addEqualityGroup(object, copy)\n",
        "1833": "        .testEquals();\n",
        "1840": "    TypeToken<Map<String, Integer>> reserialized = reserialize(\n",
        "1841": "        new TypeToken<Map<String, Integer>>() {});\n",
        "1891": "        .addEqualityGroup(\n",
        "1892": "            new TypeToken<List<String>>() {},\n",
        "1893": "            new TypeToken<List<String>>() {})\n",
        "1894": "        .addEqualityGroup(\n",
        "1895": "            new TypeToken<List<?>>() {},\n",
        "1896": "            new TypeToken<List<?>>() {})\n",
        "1897": "        .addEqualityGroup(\n",
        "1898": "            new TypeToken<Map<A, ?>>() {},\n",
        "1899": "            new TypeToken<Map<A, ?>>() {})\n",
        "1900": "        .addEqualityGroup(\n",
        "1901": "            new TypeToken<Map<B, ?>>() {})\n",
        "1917": "    return new TypeToken<Map<K, V>>() {}\n",
        "1918": "        .where(new TypeParameter<K>() {}, keyType)\n",
        "1923": "    return new TypeToken<T[]>() {}\n",
        "1924": "        .where(new TypeParameter<T>() {}, componentType);\n",
        "1928": "    new NullPointerTester()\n",
        "1929": "        .testAllPublicStaticMethods(TypeToken.class);\n",
        "1954": "        from.getType() + \" is expected to be a subtype of \" + to.getType(),\n",
        "1955": "        from.isSubtypeOf(to));\n",
        "1960": "        from.getType() + \" shouldn't be assignable to \" + to.getType(),\n",
        "1961": "        to.isSupertypeOf(from));\n",
        "1963": "        to.getType() + \" shouldn't be a supertype of \" + from.getType(),\n",
        "1964": "        to.isSupertypeOf(from));\n",
        "1966": "        from.getType() + \" shouldn't be a subtype of \" + to.getType(),\n",
        "1967": "        from.isSubtypeOf(to));\n",
        "2011": "    private static interface Base {}\n"
    }
}