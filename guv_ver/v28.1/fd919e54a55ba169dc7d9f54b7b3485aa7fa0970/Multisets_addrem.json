{
    "addition": {
        "44": " * Provides static utility methods for creating and working with {@link Multiset} instances.\n",
        "47": " * \"https://github.com/google/guava/wiki/CollectionUtilitiesExplained#multisets\"> {@code\n",
        "48": " * Multisets}</a>.\n",
        "60": "   * Returns an unmodifiable view of the specified multiset. Query operations on the returned\n",
        "61": "   * multiset \"read through\" to the specified multiset, and attempts to modify the returned multiset\n",
        "62": "   * result in an {@link UnsupportedOperationException}.\n",
        "64": "   * <p>The returned multiset will be serializable if the specified multiset is serializable.\n",
        "66": "   * @param multiset the multiset for which an unmodifiable view is to be generated\n",
        "187": "   * Returns an unmodifiable view of the specified sorted multiset. Query operations on the returned\n",
        "188": "   * multiset \"read through\" to the specified multiset, and attempts to modify the returned multiset\n",
        "189": "   * result in an {@link UnsupportedOperationException}.\n",
        "191": "   * <p>The returned multiset will be serializable if the specified multiset is serializable.\n",
        "193": "   * @param sortedMultiset the sorted multiset for which an unmodifiable view is to be generated\n",
        "204": "   * Returns an immutable multiset entry with the specified element and count. The entry will be\n",
        "205": "   * serializable if {@code e} is.\n",
        "247": "   * <p>The resulting multiset's iterators, and those of its {@code entrySet()} and {@code\n",
        "248": "   * elementSet()}, do not support {@code remove()}. However, all other multiset methods supported\n",
        "249": "   * by {@code unfiltered} are supported by the returned multiset. When given an element that\n",
        "250": "   * doesn't satisfy the predicate, the multiset's {@code add()} and {@code addAll()} methods throw\n",
        "251": "   * an {@link IllegalArgumentException}. When methods such as {@code removeAll()} and {@code\n",
        "252": "   * clear()} are called on the filtered multiset, only elements that satisfy the filter will be\n",
        "253": "   * removed from the underlying multiset.\n",
        "258": "   * element in the underlying multiset and determine which elements satisfy the filter. When a live\n",
        "259": "   * view is <i>not</i> needed, it may be faster to copy the returned multiset and use the copy.\n",
        "262": "   * {@link Predicate#apply}. Do not provide a predicate such as {@code\n",
        "263": "   * Predicates.instanceOf(ArrayList.class)}, which is inconsistent with equals. (See {@link\n",
        "264": "   * Iterables#filter(Iterable, Class)} for related functionality.)\n",
        "356": "   * Returns the expected number of distinct elements given the specified elements. The number of\n",
        "357": "   * distinct elements is only computed if {@code elements} is an instance of {@code Multiset};\n",
        "358": "   * otherwise the default value of 11 is returned.\n",
        "368": "   * Returns an unmodifiable view of the union of two multisets. In the returned multiset, the count\n",
        "369": "   * of each element is the <i>maximum</i> of its counts in the two backing multisets. The iteration\n",
        "370": "   * order of the returned multiset matches that of the element set of {@code multiset1} followed by\n",
        "371": "   * the members of the element set of {@code multiset2} that are not contained in {@code\n",
        "372": "   * multiset1}, with repeated occurrences of the same element appearing consecutively.\n",
        "374": "   * <p>Results are undefined if {@code multiset1} and {@code multiset2} are based on different\n",
        "375": "   * equivalence relations (as {@code HashMultiset} and {@code TreeMultiset} are).\n",
        "440": "   * Returns an unmodifiable view of the intersection of two multisets. In the returned multiset,\n",
        "441": "   * the count of each element is the <i>minimum</i> of its counts in the two backing multisets,\n",
        "442": "   * with elements that would have a count of 0 not included. The iteration order of the returned\n",
        "443": "   * multiset matches that of the element set of {@code multiset1}, with repeated occurrences of the\n",
        "444": "   * same element appearing consecutively.\n",
        "446": "   * <p>Results are undefined if {@code multiset1} and {@code multiset2} are based on different\n",
        "447": "   * equivalence relations (as {@code HashMultiset} and {@code TreeMultiset} are).\n",
        "496": "   * Returns an unmodifiable view of the sum of two multisets. In the returned multiset, the count\n",
        "497": "   * of each element is the <i>sum</i> of its counts in the two backing multisets. The iteration\n",
        "498": "   * order of the returned multiset matches that of the element set of {@code multiset1} followed by\n",
        "499": "   * the members of the element set of {@code multiset2} that are not contained in {@code\n",
        "500": "   * multiset1}, with repeated occurrences of the same element appearing consecutively.\n",
        "502": "   * <p>Results are undefined if {@code multiset1} and {@code multiset2} are based on different\n",
        "503": "   * equivalence relations (as {@code HashMultiset} and {@code TreeMultiset} are).\n",
        "573": "   * Returns an unmodifiable view of the difference of two multisets. In the returned multiset, the\n",
        "574": "   * count of each element is the result of the <i>zero-truncated subtraction</i> of its count in\n",
        "575": "   * the second multiset from its count in the first multiset, with elements that would have a count\n",
        "576": "   * of 0 not included. The iteration order of the returned multiset matches that of the element set\n",
        "577": "   * of {@code multiset1}, with repeated occurrences of the same element appearing consecutively.\n",
        "579": "   * <p>Results are undefined if {@code multiset1} and {@code multiset2} are based on different\n",
        "580": "   * equivalence relations (as {@code HashMultiset} and {@code TreeMultiset} are).\n",
        "625": "   * Returns {@code true} if {@code subMultiset.count(o) <= superMultiset.count(o)} for all {@code\n",
        "626": "   * o}.\n",
        "644": "   * Modifies {@code multisetToModify} so that its count for an element {@code e} is at most {@code\n",
        "645": "   * multisetToRetain.count(e)}.\n",
        "647": "   * <p>To be precise, {@code multisetToModify.count(e)} is set to {@code\n",
        "648": "   * Math.min(multisetToModify.count(e), multisetToRetain.count(e))}. This is similar to {@link\n",
        "649": "   * #intersection(Multiset, Multiset) intersection} {@code (multisetToModify, multisetToRetain)},\n",
        "650": "   * but mutates {@code multisetToModify} instead of returning a view.\n",
        "652": "   * <p>In contrast, {@code multisetToModify.retainAll(multisetToRetain)} keeps all occurrences of\n",
        "653": "   * elements that appear at all in {@code multisetToRetain}, and deletes all occurrences of all\n",
        "654": "   * other elements.\n",
        "656": "   * @return {@code true} if {@code multisetToModify} was changed as a result of this operation\n",
        "665": "  /** Delegate implementation which cares about the element type. */\n",
        "688": "   * For each occurrence of an element {@code e} in {@code occurrencesToRemove}, removes one\n",
        "689": "   * occurrence of {@code e} in {@code multisetToModify}.\n",
        "691": "   * <p>Equivalently, this method modifies {@code multisetToModify} so that {@code\n",
        "692": "   * multisetToModify.count(e)} is set to {@code Math.max(0, multisetToModify.count(e) -\n",
        "695": "   * <p>This is <i>not</i> the same as {@code multisetToModify.} {@link Multiset#removeAll\n",
        "696": "   * removeAll}{@code (occurrencesToRemove)}, which removes all occurrences of elements that appear\n",
        "697": "   * in {@code occurrencesToRemove}. However, this operation <i>is</i> equivalent to, albeit\n",
        "698": "   * sometimes more efficient than, the following:\n",
        "700": "   * <pre>{@code\n",
        "701": "   * for (E e : occurrencesToRemove) {\n",
        "702": "   *   multisetToModify.remove(e);\n",
        "703": "   * }\n",
        "704": "   * }</pre>\n",
        "706": "   * @return {@code true} if {@code multisetToModify} was changed as a result of this operation\n",
        "707": "   * @since 18.0 (present in 10.0 with a requirement that the second parameter be a {@code\n",
        "708": "   *     Multiset})\n",
        "727": "   * For each occurrence of an element {@code e} in {@code occurrencesToRemove}, removes one\n",
        "728": "   * occurrence of {@code e} in {@code multisetToModify}.\n",
        "730": "   * <p>Equivalently, this method modifies {@code multisetToModify} so that {@code\n",
        "731": "   * multisetToModify.count(e)} is set to {@code Math.max(0, multisetToModify.count(e) -\n",
        "734": "   * <p>This is <i>not</i> the same as {@code multisetToModify.} {@link Multiset#removeAll\n",
        "735": "   * removeAll}{@code (occurrencesToRemove)}, which removes all occurrences of elements that appear\n",
        "736": "   * in {@code occurrencesToRemove}. However, this operation <i>is</i> equivalent to, albeit\n",
        "737": "   * sometimes more efficient than, the following:\n",
        "739": "   * <pre>{@code\n",
        "740": "   * for (E e : occurrencesToRemove) {\n",
        "741": "   *   multisetToModify.remove(e);\n",
        "742": "   * }\n",
        "743": "   * }</pre>\n",
        "745": "   * @return {@code true} if {@code multisetToModify} was changed as a result of this operation\n",
        "771": "   * Implementation of the {@code equals}, {@code hashCode}, and {@code toString} methods of {@link\n",
        "772": "   * Multiset.Entry}.\n",
        "776": "     * Indicates whether an object equals this entry, following the behavior specified in {@link\n",
        "777": "     * Multiset.Entry#equals}.\n",
        "790": "     * Return this entry's hash code, following the behavior specified in {@link\n",
        "791": "     * Multiset.Entry#hashCode}.\n",
        "800": "     * Returns a string representation of this multiset entry. The string representation consists of\n",
        "801": "     * the associated element if the associated count is one, and otherwise the associated element\n",
        "802": "     * followed by the characters \" x \" (space, x and space) followed by the count. Elements and\n",
        "803": "     * counts are converted to strings as by {@code String.valueOf}.\n",
        "813": "  /** An implementation of {@link Multiset#equals}. */\n",
        "839": "  /** An implementation of {@link Multiset#addAll}. */\n",
        "855": "  /** An implementation of {@link Multiset#removeAll}. */\n",
        "865": "  /** An implementation of {@link Multiset#retainAll}. */\n",
        "876": "  /** An implementation of {@link Multiset#setCount(Object, int)}. */\n",
        "892": "  /** An implementation of {@link Multiset#setCount(Object, int, int)}. */\n",
        "993": "  /** An implementation of {@link Multiset#iterator}. */\n",
        "1048": "  /** An implementation of {@link Multiset#size}. */\n",
        "1057": "  /** Used to avoid http://bugs.sun.com/view_bug.do?bug_id=6558557 */\n",
        "1078": "    @Override\n",
        "1079": "    public int compare(Entry<?> entry1, Entry<?> entry2) {\n"
    },
    "removed": {
        "44": " * Provides static utility methods for creating and working with {@link\n",
        "45": " * Multiset} instances.\n",
        "48": " * \"https://github.com/google/guava/wiki/CollectionUtilitiesExplained#multisets\">\n",
        "49": " * {@code Multisets}</a>.\n",
        "61": "   * Returns an unmodifiable view of the specified multiset. Query operations on\n",
        "62": "   * the returned multiset \"read through\" to the specified multiset, and\n",
        "63": "   * attempts to modify the returned multiset result in an\n",
        "64": "   * {@link UnsupportedOperationException}.\n",
        "66": "   * <p>The returned multiset will be serializable if the specified multiset is\n",
        "67": "   * serializable.\n",
        "69": "   * @param multiset the multiset for which an unmodifiable view is to be\n",
        "70": "   *     generated\n",
        "191": "   * Returns an unmodifiable view of the specified sorted multiset. Query\n",
        "192": "   * operations on the returned multiset \"read through\" to the specified\n",
        "193": "   * multiset, and attempts to modify the returned multiset result in an {@link\n",
        "194": "   * UnsupportedOperationException}.\n",
        "196": "   * <p>The returned multiset will be serializable if the specified multiset is\n",
        "197": "   * serializable.\n",
        "199": "   * @param sortedMultiset the sorted multiset for which an unmodifiable view is\n",
        "200": "   *     to be generated\n",
        "211": "   * Returns an immutable multiset entry with the specified element and count.\n",
        "212": "   * The entry will be serializable if {@code e} is.\n",
        "254": "   * <p>The resulting multiset's iterators, and those of its {@code entrySet()} and\n",
        "255": "   * {@code elementSet()}, do not support {@code remove()}.  However, all other multiset methods\n",
        "256": "   * supported by {@code unfiltered} are supported by the returned multiset. When given an element\n",
        "257": "   * that doesn't satisfy the predicate, the multiset's {@code add()} and {@code addAll()} methods\n",
        "258": "   * throw an {@link IllegalArgumentException}. When methods such as {@code removeAll()} and\n",
        "259": "   * {@code clear()} are called on the filtered multiset, only elements that satisfy the filter\n",
        "260": "   * will be removed from the underlying multiset.\n",
        "265": "   * element in the underlying multiset and determine which elements satisfy the filter. When a\n",
        "266": "   * live view is <i>not</i> needed, it may be faster to copy the returned multiset and use the\n",
        "267": "   * copy.\n",
        "270": "   * {@link Predicate#apply}. Do not provide a predicate such as\n",
        "271": "   * {@code Predicates.instanceOf(ArrayList.class)}, which is inconsistent with equals. (See\n",
        "272": "   * {@link Iterables#filter(Iterable, Class)} for related functionality.)\n",
        "364": "   * Returns the expected number of distinct elements given the specified\n",
        "365": "   * elements. The number of distinct elements is only computed if {@code\n",
        "366": "   * elements} is an instance of {@code Multiset}; otherwise the default value\n",
        "367": "   * of 11 is returned.\n",
        "377": "   * Returns an unmodifiable view of the union of two multisets.\n",
        "378": "   * In the returned multiset, the count of each element is the <i>maximum</i>\n",
        "379": "   * of its counts in the two backing multisets. The iteration order of the\n",
        "380": "   * returned multiset matches that of the element set of {@code multiset1}\n",
        "381": "   * followed by the members of the element set of {@code multiset2} that are\n",
        "382": "   * not contained in {@code multiset1}, with repeated occurrences of the same\n",
        "383": "   * element appearing consecutively.\n",
        "385": "   * <p>Results are undefined if {@code multiset1} and {@code multiset2} are\n",
        "386": "   * based on different equivalence relations (as {@code HashMultiset} and\n",
        "387": "   * {@code TreeMultiset} are).\n",
        "452": "   * Returns an unmodifiable view of the intersection of two multisets.\n",
        "453": "   * In the returned multiset, the count of each element is the <i>minimum</i>\n",
        "454": "   * of its counts in the two backing multisets, with elements that would have\n",
        "455": "   * a count of 0 not included. The iteration order of the returned multiset\n",
        "456": "   * matches that of the element set of {@code multiset1}, with repeated\n",
        "457": "   * occurrences of the same element appearing consecutively.\n",
        "459": "   * <p>Results are undefined if {@code multiset1} and {@code multiset2} are\n",
        "460": "   * based on different equivalence relations (as {@code HashMultiset} and\n",
        "461": "   * {@code TreeMultiset} are).\n",
        "510": "   * Returns an unmodifiable view of the sum of two multisets.\n",
        "511": "   * In the returned multiset, the count of each element is the <i>sum</i> of\n",
        "512": "   * its counts in the two backing multisets. The iteration order of the\n",
        "513": "   * returned multiset matches that of the element set of {@code multiset1}\n",
        "514": "   * followed by the members of the element set of {@code multiset2} that\n",
        "515": "   * are not contained in {@code multiset1}, with repeated occurrences of the\n",
        "516": "   * same element appearing consecutively.\n",
        "518": "   * <p>Results are undefined if {@code multiset1} and {@code multiset2} are\n",
        "519": "   * based on different equivalence relations (as {@code HashMultiset} and\n",
        "520": "   * {@code TreeMultiset} are).\n",
        "590": "   * Returns an unmodifiable view of the difference of two multisets.\n",
        "591": "   * In the returned multiset, the count of each element is the result of the\n",
        "592": "   * <i>zero-truncated subtraction</i> of its count in the second multiset from\n",
        "593": "   * its count in the first multiset, with elements that would have a count of\n",
        "594": "   * 0 not included. The iteration order of the returned multiset matches that\n",
        "595": "   * of the element set of {@code multiset1}, with repeated occurrences of the\n",
        "596": "   * same element appearing consecutively.\n",
        "598": "   * <p>Results are undefined if {@code multiset1} and {@code multiset2} are\n",
        "599": "   * based on different equivalence relations (as {@code HashMultiset} and\n",
        "600": "   * {@code TreeMultiset} are).\n",
        "645": "   * Returns {@code true} if {@code subMultiset.count(o) <=\n",
        "646": "   * superMultiset.count(o)} for all {@code o}.\n",
        "664": "   * Modifies {@code multisetToModify} so that its count for an element\n",
        "665": "   * {@code e} is at most {@code multisetToRetain.count(e)}.\n",
        "667": "   * <p>To be precise, {@code multisetToModify.count(e)} is set to\n",
        "668": "   * {@code Math.min(multisetToModify.count(e),\n",
        "669": "   * multisetToRetain.count(e))}. This is similar to\n",
        "670": "   * {@link #intersection(Multiset, Multiset) intersection}\n",
        "671": "   * {@code (multisetToModify, multisetToRetain)}, but mutates\n",
        "672": "   * {@code multisetToModify} instead of returning a view.\n",
        "674": "   * <p>In contrast, {@code multisetToModify.retainAll(multisetToRetain)} keeps\n",
        "675": "   * all occurrences of elements that appear at all in {@code\n",
        "676": "   * multisetToRetain}, and deletes all occurrences of all other elements.\n",
        "678": "   * @return {@code true} if {@code multisetToModify} was changed as a result\n",
        "679": "   *         of this operation\n",
        "688": "  /**\n",
        "689": "   * Delegate implementation which cares about the element type.\n",
        "690": "   */\n",
        "713": "   * For each occurrence of an element {@code e} in {@code occurrencesToRemove},\n",
        "714": "   * removes one occurrence of {@code e} in {@code multisetToModify}.\n",
        "716": "   * <p>Equivalently, this method modifies {@code multisetToModify} so that\n",
        "717": "   * {@code multisetToModify.count(e)} is set to\n",
        "718": "   * {@code Math.max(0, multisetToModify.count(e) -\n",
        "721": "   * <p>This is <i>not</i> the same as {@code multisetToModify.}\n",
        "722": "   * {@link Multiset#removeAll removeAll}{@code (occurrencesToRemove)}, which\n",
        "723": "   * removes all occurrences of elements that appear in\n",
        "724": "   * {@code occurrencesToRemove}. However, this operation <i>is</i> equivalent\n",
        "725": "   * to, albeit sometimes more efficient than, the following: <pre>   {@code\n",
        "727": "   *   for (E e : occurrencesToRemove) {\n",
        "728": "   *     multisetToModify.remove(e);\n",
        "729": "   *   }}</pre>\n",
        "731": "   * @return {@code true} if {@code multisetToModify} was changed as a result of\n",
        "732": "   *         this operation\n",
        "733": "   * @since 18.0 (present in 10.0 with a requirement that the second parameter\n",
        "734": "   *     be a {@code Multiset})\n",
        "753": "   * For each occurrence of an element {@code e} in {@code occurrencesToRemove},\n",
        "754": "   * removes one occurrence of {@code e} in {@code multisetToModify}.\n",
        "756": "   * <p>Equivalently, this method modifies {@code multisetToModify} so that\n",
        "757": "   * {@code multisetToModify.count(e)} is set to\n",
        "758": "   * {@code Math.max(0, multisetToModify.count(e) -\n",
        "761": "   * <p>This is <i>not</i> the same as {@code multisetToModify.}\n",
        "762": "   * {@link Multiset#removeAll removeAll}{@code (occurrencesToRemove)}, which\n",
        "763": "   * removes all occurrences of elements that appear in\n",
        "764": "   * {@code occurrencesToRemove}. However, this operation <i>is</i> equivalent\n",
        "765": "   * to, albeit sometimes more efficient than, the following: <pre>   {@code\n",
        "767": "   *   for (E e : occurrencesToRemove) {\n",
        "768": "   *     multisetToModify.remove(e);\n",
        "769": "   *   }}</pre>\n",
        "771": "   * @return {@code true} if {@code multisetToModify} was changed as a result of\n",
        "772": "   *         this operation\n",
        "798": "   * Implementation of the {@code equals}, {@code hashCode}, and\n",
        "799": "   * {@code toString} methods of {@link Multiset.Entry}.\n",
        "803": "     * Indicates whether an object equals this entry, following the behavior\n",
        "804": "     * specified in {@link Multiset.Entry#equals}.\n",
        "817": "     * Return this entry's hash code, following the behavior specified in\n",
        "818": "     * {@link Multiset.Entry#hashCode}.\n",
        "827": "     * Returns a string representation of this multiset entry. The string\n",
        "828": "     * representation consists of the associated element if the associated count\n",
        "829": "     * is one, and otherwise the associated element followed by the characters\n",
        "830": "     * \" x \" (space, x and space) followed by the count. Elements and counts are\n",
        "831": "     * converted to strings as by {@code String.valueOf}.\n",
        "841": "  /**\n",
        "842": "   * An implementation of {@link Multiset#equals}.\n",
        "843": "   */\n",
        "869": "  /**\n",
        "870": "   * An implementation of {@link Multiset#addAll}.\n",
        "871": "   */\n",
        "887": "  /**\n",
        "888": "   * An implementation of {@link Multiset#removeAll}.\n",
        "889": "   */\n",
        "899": "  /**\n",
        "900": "   * An implementation of {@link Multiset#retainAll}.\n",
        "901": "   */\n",
        "912": "  /**\n",
        "913": "   * An implementation of {@link Multiset#setCount(Object, int)}.\n",
        "914": "   */\n",
        "930": "  /**\n",
        "931": "   * An implementation of {@link Multiset#setCount(Object, int, int)}.\n",
        "932": "   */\n",
        "1033": "  /**\n",
        "1034": "   * An implementation of {@link Multiset#iterator}.\n",
        "1035": "   */\n",
        "1090": "  /**\n",
        "1091": "   * An implementation of {@link Multiset#size}.\n",
        "1092": "   */\n",
        "1101": "  /**\n",
        "1102": "   * Used to avoid http://bugs.sun.com/view_bug.do?bug_id=6558557\n",
        "1103": "   */\n",
        "1124": "    @Override public int compare(Entry<?> entry1, Entry<?> entry2) {\n"
    }
}