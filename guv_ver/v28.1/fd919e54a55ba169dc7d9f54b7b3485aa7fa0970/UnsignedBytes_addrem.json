{
    "addition": {
        "32": " * <i>unsigned</i> (that is, any negative value {@code b} is treated as the positive value {@code\n",
        "33": " * 256 + b}). The corresponding methods that treat the values as signed are found in {@link\n",
        "34": " * SignedBytes}, and the methods for which signedness is not an issue are in {@link Bytes}.\n",
        "36": " * <p>See the Guava User Guide article on <a\n",
        "37": " * href=\"https://github.com/google/guava/wiki/PrimitivesExplained\">primitive utilities</a>.\n",
        "50": "   * The largest power of two that can be represented as an unsigned {@code byte}.\n",
        "92": "   * Returns the {@code byte} value that, when treated as unsigned, is nearest in value to {@code\n",
        "93": "   * value}.\n",
        "198": "   * @throws NullPointerException if {@code string} is null (in contrast to {@link\n",
        "199": "   *     Byte#parseByte(String)})\n",
        "214": "   *     the given radix, or if {@code radix} is not between {@link Character#MIN_RADIX} and {@link\n",
        "215": "   *     Character#MAX_RADIX}.\n",
        "216": "   * @throws NullPointerException if {@code string} is null (in contrast to {@link\n",
        "217": "   *     Byte#parseByte(String)})\n",
        "234": "   * For example, {@code join(\":\", (byte) 1, (byte) 2, (byte) 255)} returns the string {@code\n",
        "235": "   * \"1:2:255\"}.\n",
        "265": "   * support only identity equality), but it is consistent with {@link\n",
        "266": "   * java.util.Arrays#equals(byte[], byte[])}.\n",
        "324": "            && (BYTE_ARRAY_BASE_OFFSET % 8) == 0\n",
        "325": "            // sanity check - this should never fail\n",
        "326": "            && theUnsafe.arrayIndexScale(byte[].class) == 1)) {\n",
        "327": "          throw new Error(); // force fallback to PureJavaComparator\n"
    },
    "removed": {
        "32": " * <i>unsigned</i> (that is, any negative value {@code b} is treated as the positive value\n",
        "33": " * {@code 256 + b}). The corresponding methods that treat the values as signed are found in\n",
        "34": " * {@link SignedBytes}, and the methods for which signedness is not an issue are in {@link Bytes}.\n",
        "36": " * <p>See the Guava User Guide article on\n",
        "37": " * <a href=\"https://github.com/google/guava/wiki/PrimitivesExplained\">primitive utilities</a>.\n",
        "50": "   * The largest power of two that can be represented as an unsigned {@code\n",
        "51": "   * byte}.\n",
        "93": "   * Returns the {@code byte} value that, when treated as unsigned, is nearest in value to\n",
        "94": "   * {@code value}.\n",
        "199": "   * @throws NullPointerException if {@code string} is null (in contrast to\n",
        "200": "   *     {@link Byte#parseByte(String)})\n",
        "215": "   *     the given radix, or if {@code radix} is not between {@link Character#MIN_RADIX} and\n",
        "216": "   *     {@link Character#MAX_RADIX}.\n",
        "217": "   * @throws NullPointerException if {@code string} is null (in contrast to\n",
        "218": "   *     {@link Byte#parseByte(String)})\n",
        "235": "   * For example, {@code join(\":\", (byte) 1, (byte) 2,\n",
        "236": "   * (byte) 255)} returns the string {@code \"1:2:255\"}.\n",
        "266": "   * support only identity equality), but it is consistent with\n",
        "267": "   * {@link java.util.Arrays#equals(byte[], byte[])}.\n",
        "325": "              && (BYTE_ARRAY_BASE_OFFSET % 8) == 0\n",
        "326": "              // sanity check - this should never fail\n",
        "327": "              && theUnsafe.arrayIndexScale(byte[].class) == 1)) {\n",
        "328": "          throw new Error();  // force fallback to PureJavaComparator\n"
    }
}