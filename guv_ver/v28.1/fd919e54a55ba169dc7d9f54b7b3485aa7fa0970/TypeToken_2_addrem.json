{
    "addition": {
        "59": " *   <li>Wrap a {@code Type} obtained via reflection. For example: {@code\n",
        "60": " *       TypeToken.of(method.getGenericReturnType())}.\n",
        "61": " *   <li>Capture a generic type with a (usually anonymous) subclass. For example:\n",
        "62": " *       <pre>{@code\n",
        "63": " * new TypeToken<List<String>>() {}\n",
        "64": " * }</pre>\n",
        "65": " *       <p>Note that it's critical that the actual type argument is carried by a subclass. The\n",
        "66": " *       following code is wrong because it only captures the {@code <T>} type variable of the\n",
        "67": " *       {@code listType()} method signature; while {@code <String>} is lost in erasure:\n",
        "68": " *       <pre>{@code\n",
        "69": " * class Util {\n",
        "70": " *   static <T> TypeToken<List<T>> listType() {\n",
        "71": " *     return new TypeToken<List<T>>() {};\n",
        "73": " * }\n",
        "75": " * TypeToken<List<String>> stringListType = Util.<String>listType();\n",
        "76": " * }</pre>\n",
        "77": " *   <li>Capture a generic type with a (usually anonymous) subclass and resolve it against a context\n",
        "78": " *       class that knows what the type parameters are. For example:\n",
        "79": " *       <pre>{@code\n",
        "80": " * abstract class IKnowMyType<T> {\n",
        "81": " *   TypeToken<T> type = new TypeToken<T>(getClass()) {};\n",
        "82": " * }\n",
        "83": " * new IKnowMyType<String>() {}.type => String\n",
        "84": " * }</pre>\n",
        "112": "   * <p>For example:\n",
        "113": "   *\n",
        "114": "   * <pre>{@code\n",
        "115": "   * TypeToken<List<String>> t = new TypeToken<List<String>>() {};\n",
        "116": "   * }</pre>\n",
        "137": "   * <p>For example:\n",
        "138": "   *\n",
        "139": "   * <pre>{@code\n",
        "140": "   * abstract class IKnowMyType<T> {\n",
        "141": "   *   TypeToken<T> getMyType() {\n",
        "142": "   *     return new TypeToken<T>(getClass()) {};\n",
        "144": "   * }\n",
        "146": "   * new IKnowMyType<String>() {}.getMyType() => String\n",
        "147": "   * }</pre>\n",
        "173": "   * Returns the raw type of {@code T}. Formally speaking, if {@code T} is returned by {@link\n",
        "174": "   * java.lang.reflect.Method#getGenericReturnType}, the raw type is what's returned by {@link\n",
        "175": "   * java.lang.reflect.Method#getReturnType} of the same method object. Specifically:\n",
        "176": "   *\n",
        "178": "   *   <li>If {@code T} is a {@code Class} itself, {@code T} itself is returned.\n",
        "179": "   *   <li>If {@code T} is a {@link ParameterizedType}, the raw type of the parameterized type is\n",
        "180": "   *       returned.\n",
        "181": "   *   <li>If {@code T} is a {@link GenericArrayType}, the returned type is the corresponding array\n",
        "182": "   *       class. For example: {@code List<Integer>[] => List[]}.\n",
        "183": "   *   <li>If {@code T} is a type variable or a wildcard type, the raw type of the first upper bound\n",
        "184": "   *       is returned. For example: {@code <X extends Foo> => Foo}.\n",
        "201": "   * Returns a new {@code TypeToken} where type variables represented by {@code typeParam} are\n",
        "203": "   * any {@code K} and {@code V} type:\n",
        "204": "   *\n",
        "205": "   * <pre>{@code\n",
        "206": "   * static <K, V> TypeToken<Map<K, V>> mapOf(\n",
        "207": "   *     TypeToken<K> keyType, TypeToken<V> valueType) {\n",
        "208": "   *   return new TypeToken<Map<K, V>>() {}\n",
        "209": "   *       .where(new TypeParameter<K>() {}, keyType)\n",
        "210": "   *       .where(new TypeParameter<V>() {}, valueType);\n",
        "211": "   * }\n",
        "212": "   * }</pre>\n",
        "229": "   * Returns a new {@code TypeToken} where type variables represented by {@code typeParam} are\n",
        "231": "   * any {@code K} and {@code V} type:\n",
        "232": "   *\n",
        "233": "   * <pre>{@code\n",
        "234": "   * static <K, V> TypeToken<Map<K, V>> mapOf(\n",
        "235": "   *     Class<K> keyType, Class<V> valueType) {\n",
        "236": "   *   return new TypeToken<Map<K, V>>() {}\n",
        "237": "   *       .where(new TypeParameter<K>() {}, keyType)\n",
        "238": "   *       .where(new TypeParameter<V>() {}, valueType);\n",
        "239": "   * }\n",
        "240": "   * }</pre>\n",
        "251": "   * Resolves the given {@code type} against the type context represented by this type. For example:\n",
        "252": "   *\n",
        "253": "   * <pre>{@code\n",
        "254": "   * new TypeToken<List<String>>() {}.resolveType(\n",
        "255": "   *     List.class.getMethod(\"get\", int.class).getGenericReturnType())\n",
        "256": "   * => String.class\n",
        "257": "   * }</pre>\n",
        "283": "   * Returns the generic superclass of this type or {@code null} if the type represents {@link\n",
        "284": "   * Object} or an interface. This method is similar but different from {@link\n",
        "285": "   * Class#getGenericSuperclass}. For example, {@code new TypeToken<StringArrayList>()\n",
        "327": "   * TypeToken<List<String>>() {}.getGenericInterfaces()} will return a list that contains {@code\n",
        "328": "   * new TypeToken<Iterable<String>>() {}}; while {@code List.class.getGenericInterfaces()} will\n",
        "329": "   * return an array that contains {@code Iterable<T>}, where the {@code T} is the type variable\n",
        "330": "   * declared by interface {@code Iterable}.\n",
        "381": "   * Returns the generic form of {@code superclass}. For example, if this is {@code\n",
        "382": "   * ArrayList<String>}, {@code Iterable<String>} is returned given the input {@code\n",
        "383": "   * Iterable.class}.\n",
        "432": "   * according to <a\n",
        "433": "   * href=\"http://docs.oracle.com/javase/specs/jls/se8/html/jls-4.html#jls-4.5.1\">the rules for type\n",
        "434": "   * arguments</a> introduced with Java generics.\n",
        "444": "   * according to <a\n",
        "445": "   * href=\"http://docs.oracle.com/javase/specs/jls/se8/html/jls-4.html#jls-4.5.1\">the rules for type\n",
        "446": "   * arguments</a> introduced with Java generics.\n",
        "456": "   * according to <a\n",
        "457": "   * href=\"http://docs.oracle.com/javase/specs/jls/se8/html/jls-4.html#jls-4.5.1\">the rules for type\n",
        "458": "   * arguments</a> introduced with Java generics.\n",
        "468": "   * according to <a\n",
        "469": "   * href=\"http://docs.oracle.com/javase/specs/jls/se8/html/jls-4.html#jls-4.5.1\">the rules for type\n",
        "470": "   * arguments</a> introduced with Java generics.\n",
        "527": "   * Returns the corresponding wrapper type if this is a primitive type; otherwise returns {@code\n",
        "528": "   * this} itself. Idempotent.\n",
        "546": "   * Returns the corresponding primitive type if this is a wrapper type; otherwise returns {@code\n",
        "547": "   * this} itself. Idempotent.\n",
        "952": "   *   <li>'this' and {@code formalType} are equal\n",
        "953": "   *   <li>{@code formalType} is {@code <? extends Foo>} and 'this' is a subtype of {@code Foo}\n",
        "954": "   *   <li>{@code formalType} is {@code <? super Foo>} and 'this' is a supertype of {@code Foo}\n",
        "1057": "   * Returns the owner type of a {@link ParameterizedType} or enclosing class of a {@link Class}, or\n",
        "1058": "   * null otherwise.\n",
        "1060": "  @Nullable\n",
        "1061": "  private Type getOwnerTypeIfPresent() {\n",
        "1186": "   * Creates an array class if {@code componentType} is a class, or else, a {@link\n",
        "1187": "   * GenericArrayType}. This is what Java7 does for generic array type parameters.\n"
    },
    "removed": {
        "59": " *\n",
        "60": " * <li>Wrap a {@code Type} obtained via reflection. For example:\n",
        "61": " *     {@code TypeToken.of(method.getGenericReturnType())}.\n",
        "62": " *\n",
        "63": " * <li>Capture a generic type with a (usually anonymous) subclass. For example: <pre>   {@code\n",
        "64": " *   new TypeToken<List<String>>() {}}</pre>\n",
        "65": " *\n",
        "66": " *     <p>Note that it's critical that the actual type argument is carried by a subclass. The\n",
        "67": " *     following code is wrong because it only captures the {@code <T>} type variable of the {@code\n",
        "68": " *     listType()} method signature; while {@code <String>} is lost in erasure:\n",
        "69": " *\n",
        "70": " * <pre>   {@code\n",
        "71": " *   class Util {\n",
        "72": " *     static <T> TypeToken<List<T>> listType() {\n",
        "73": " *       return new TypeToken<List<T>>() {};\n",
        "74": " *     }\n",
        "75": " *   }\n",
        "76": " *\n",
        "77": " *   TypeToken<List<String>> stringListType = Util.<String>listType();}</pre>\n",
        "78": " *\n",
        "79": " * <li>Capture a generic type with a (usually anonymous) subclass and resolve it against a context\n",
        "80": " *     class that knows what the type parameters are. For example: <pre>   {@code\n",
        "81": " *   abstract class IKnowMyType<T> {\n",
        "82": " *     TypeToken<T> type = new TypeToken<T>(getClass()) {};\n",
        "84": " *   new IKnowMyType<String>() {}.type => String}</pre>\n",
        "113": "   * <p>For example: <pre>   {@code\n",
        "114": "   *   TypeToken<List<String>> t = new TypeToken<List<String>>() {};}</pre>\n",
        "135": "   * <p>For example: <pre>   {@code\n",
        "136": "   *   abstract class IKnowMyType<T> {\n",
        "137": "   *     TypeToken<T> getMyType() {\n",
        "138": "   *       return new TypeToken<T>(getClass()) {};\n",
        "139": "   *     }\n",
        "142": "   *   new IKnowMyType<String>() {}.getMyType() => String}</pre>\n",
        "168": "   * Returns the raw type of {@code T}. Formally speaking, if {@code T} is returned by\n",
        "169": "   * {@link java.lang.reflect.Method#getGenericReturnType}, the raw type is what's returned by\n",
        "170": "   * {@link java.lang.reflect.Method#getReturnType} of the same method object. Specifically:\n",
        "172": "   * <li>If {@code T} is a {@code Class} itself, {@code T} itself is returned.\n",
        "173": "   * <li>If {@code T} is a {@link ParameterizedType}, the raw type of the parameterized type is\n",
        "174": "   *     returned.\n",
        "175": "   * <li>If {@code T} is a {@link GenericArrayType}, the returned type is the corresponding array\n",
        "176": "   *     class. For example: {@code List<Integer>[] => List[]}.\n",
        "177": "   * <li>If {@code T} is a type variable or a wildcard type, the raw type of the first upper bound\n",
        "178": "   *     is returned. For example: {@code <X extends Foo> => Foo}.\n",
        "195": "   * <p>Returns a new {@code TypeToken} where type variables represented by {@code typeParam} are\n",
        "197": "   * any {@code K} and {@code V} type: <pre>   {@code\n",
        "198": "   *   static <K, V> TypeToken<Map<K, V>> mapOf(\n",
        "199": "   *       TypeToken<K> keyType, TypeToken<V> valueType) {\n",
        "200": "   *     return new TypeToken<Map<K, V>>() {}\n",
        "201": "   *         .where(new TypeParameter<K>() {}, keyType)\n",
        "202": "   *         .where(new TypeParameter<V>() {}, valueType);\n",
        "203": "   *   }}</pre>\n",
        "220": "   * <p>Returns a new {@code TypeToken} where type variables represented by {@code typeParam} are\n",
        "222": "   * any {@code K} and {@code V} type: <pre>   {@code\n",
        "223": "   *   static <K, V> TypeToken<Map<K, V>> mapOf(\n",
        "224": "   *       Class<K> keyType, Class<V> valueType) {\n",
        "225": "   *     return new TypeToken<Map<K, V>>() {}\n",
        "226": "   *         .where(new TypeParameter<K>() {}, keyType)\n",
        "227": "   *         .where(new TypeParameter<V>() {}, valueType);\n",
        "228": "   *   }}</pre>\n",
        "239": "   * <p>Resolves the given {@code type} against the type context represented by this type. For\n",
        "240": "   * example: <pre>   {@code\n",
        "241": "   *   new TypeToken<List<String>>() {}.resolveType(\n",
        "242": "   *       List.class.getMethod(\"get\", int.class).getGenericReturnType())\n",
        "243": "   *   => String.class}</pre>\n",
        "269": "   * Returns the generic superclass of this type or {@code null} if the type represents\n",
        "270": "   * {@link Object} or an interface. This method is similar but different from\n",
        "271": "   * {@link Class#getGenericSuperclass}. For example, {@code new TypeToken<StringArrayList>()\n",
        "313": "   * TypeToken<List<String>>() {}.getGenericInterfaces()} will return a list that contains\n",
        "314": "   * {@code new TypeToken<Iterable<String>>() {}}; while {@code List.class.getGenericInterfaces()}\n",
        "315": "   * will return an array that contains {@code Iterable<T>}, where the {@code T} is the type\n",
        "316": "   * variable declared by interface {@code Iterable}.\n",
        "367": "   * Returns the generic form of {@code superclass}. For example, if this is\n",
        "368": "   * {@code ArrayList<String>}, {@code Iterable<String>} is returned given the input\n",
        "369": "   * {@code Iterable.class}.\n",
        "418": "   * according to\n",
        "419": "   * <a href=\"http://docs.oracle.com/javase/specs/jls/se8/html/jls-4.html#jls-4.5.1\">the rules for\n",
        "420": "   * type arguments</a> introduced with Java generics.\n",
        "430": "   * according to\n",
        "431": "   * <a href=\"http://docs.oracle.com/javase/specs/jls/se8/html/jls-4.html#jls-4.5.1\">the rules for\n",
        "432": "   * type arguments</a> introduced with Java generics.\n",
        "442": "   * according to\n",
        "443": "   * <a href=\"http://docs.oracle.com/javase/specs/jls/se8/html/jls-4.html#jls-4.5.1\">the rules for\n",
        "444": "   * type arguments</a> introduced with Java generics.\n",
        "454": "   * according to\n",
        "455": "   * <a href=\"http://docs.oracle.com/javase/specs/jls/se8/html/jls-4.html#jls-4.5.1\">the rules for\n",
        "456": "   * type arguments</a> introduced with Java generics.\n",
        "513": "   * Returns the corresponding wrapper type if this is a primitive type; otherwise returns\n",
        "514": "   * {@code this} itself. Idempotent.\n",
        "532": "   * Returns the corresponding primitive type if this is a wrapper type; otherwise returns\n",
        "533": "   * {@code this} itself. Idempotent.\n",
        "938": "   * <li>'this' and {@code formalType} are equal\n",
        "939": "   * <li>{@code formalType} is {@code <? extends Foo>} and 'this' is a subtype of {@code Foo}\n",
        "940": "   * <li>{@code formalType} is {@code <? super Foo>} and 'this' is a supertype of {@code Foo}\n",
        "1043": "   * Returns the owner type of a {@link ParameterizedType} or enclosing class of a {@link Class},\n",
        "1044": "   * or null otherwise.\n",
        "1046": "  @Nullable private Type getOwnerTypeIfPresent() {\n",
        "1171": "   * Creates an array class if {@code componentType} is a class, or else, a\n",
        "1172": "   * {@link GenericArrayType}. This is what Java7 does for generic array type parameters.\n"
    }
}