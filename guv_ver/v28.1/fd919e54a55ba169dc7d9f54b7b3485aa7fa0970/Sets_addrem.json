{
    "addition": {
        "54": " * Static utility methods pertaining to {@link Set} instances. Also see this class's counterparts\n",
        "55": " * {@link Lists}, {@link Maps} and {@link Queues}.\n",
        "58": " * \"https://github.com/google/guava/wiki/CollectionUtilitiesExplained#sets\"> {@code Sets}</a>.\n",
        "70": "   * {@link AbstractSet} substitute without the potentially-quadratic {@code removeAll}\n",
        "71": "   * implementation.\n",
        "86": "   * Returns an immutable set instance containing the given enum elements. Internally, the returned\n",
        "87": "   * set will be backed by an {@link EnumSet}.\n",
        "89": "   * <p>The iteration order of the returned set follows the enum's iteration order, not the order in\n",
        "90": "   * which the elements are provided to the method.\n",
        "104": "   * Returns an immutable set instance containing the given enum elements. Internally, the returned\n",
        "105": "   * set will be backed by an {@link EnumSet}.\n",
        "107": "   * <p>The iteration order of the returned set follows the enum's iteration order, not the order in\n",
        "108": "   * which the elements appear in the given collection.\n",
        "110": "   * @param elements the elements, all of the same {@code enum} type, that the set should contain\n",
        "154": "   * <p><b>Note:</b> if mutability is not required, use {@link ImmutableSet#of()} instead. If {@code\n",
        "155": "   * E} is an {@link Enum} type, use {@link EnumSet#noneOf} instead. Otherwise, strongly consider\n",
        "156": "   * using a {@code LinkedHashSet} instead, at the cost of increased memory footprint, to get\n",
        "157": "   * deterministic iteration behavior.\n",
        "245": "   * Creates a thread-safe set backed by a hash map. The set is backed by a {@link\n",
        "246": "   * ConcurrentHashMap} instance, and thus carries the same concurrency guarantees.\n",
        "248": "   * <p>Unlike {@code HashSet}, this class does NOT allow {@code null} to be used as an element. The\n",
        "249": "   * set is serializable.\n",
        "259": "   * Creates a thread-safe set backed by a hash map and containing the given elements. The set is\n",
        "260": "   * backed by a {@link ConcurrentHashMap} instance, and thus carries the same concurrency\n",
        "261": "   * guarantees.\n",
        "263": "   * <p>Unlike {@code HashSet}, this class does NOT allow {@code null} to be used as an element. The\n",
        "264": "   * set is serializable.\n",
        "268": "   * @throws NullPointerException if {@code elements} or any of its contents is null\n",
        "302": "   *     elements without resizing\n",
        "400": "   * Creates an empty {@code Set} that uses identity to determine equality. It compares object\n",
        "401": "   * references, instead of calling {@code equals}, to determine whether a provided object matches\n",
        "402": "   * an element in the set. For example, {@code contains} returns {@code false} when passed an\n",
        "403": "   * object that equals a set member, but isn't the same instance. This behavior is similar to the\n",
        "404": "   * way {@code IdentityHashMap} handles key lookups.\n",
        "415": "   * <p><b>Note:</b> if you need an immutable empty {@link Set}, use {@link Collections#emptySet}\n",
        "416": "   * instead.\n",
        "445": "   * Creates an {@code EnumSet} consisting of all enum values that are not in the specified\n",
        "446": "   * collection. If the collection is an {@link EnumSet}, this method has the same behavior as\n",
        "447": "   * {@link EnumSet#complementOf}. Otherwise, the specified collection must contain at least one\n",
        "448": "   * element, in order to determine the element type. If the collection could be empty, use {@link\n",
        "449": "   * #complementOf(Collection, Class)} instead of this method.\n",
        "450": "   *\n",
        "451": "   * @param collection the collection whose complement should be stored in the enum set\n",
        "452": "   * @return a new, modifiable {@code EnumSet} containing all values of the enum that aren't present\n",
        "453": "   *     in the given collection\n",
        "454": "   * @throws IllegalArgumentException if {@code collection} is not an {@code EnumSet} instance and\n",
        "455": "   *     contains no elements\n",
        "468": "   * Creates an {@code EnumSet} consisting of all enum values that are not in the specified\n",
        "469": "   * collection. This is equivalent to {@link EnumSet#complementOf}, but can act on any input\n",
        "470": "   * collection, as long as the elements are of enum type.\n",
        "472": "   * @param collection the collection whose complement should be stored in the {@code EnumSet}\n",
        "474": "   * @return a new, modifiable {@code EnumSet} initially containing all the values of the enum not\n",
        "475": "   *     present in the given collection\n",
        "493": "   * Returns a set backed by the specified map. The resulting set displays the same ordering,\n",
        "494": "   * concurrency, and performance characteristics as the backing map. In essence, this factory\n",
        "495": "   * method provides a {@link Set} implementation corresponding to any {@link Map} implementation.\n",
        "496": "   * There is no need to use this method on a {@link Map} implementation that already has a\n",
        "497": "   * corresponding {@link Set} implementation (such as {@link java.util.HashMap} or {@link\n",
        "498": "   * java.util.TreeMap}).\n",
        "499": "   *\n",
        "500": "   * <p>Each method invocation on the set returned by this method results in exactly one method\n",
        "501": "   * invocation on the backing map or its {@code keySet} view, with one exception. The {@code\n",
        "502": "   * addAll} method is implemented as a sequence of {@code put} invocations on the backing map.\n",
        "503": "   *\n",
        "504": "   * <p>The specified map must be empty at the time this method is invoked, and should not be\n",
        "505": "   * accessed directly after this method returns. These conditions are ensured if the map is created\n",
        "506": "   * empty, passed directly to this method, and no reference to the map is retained, as illustrated\n",
        "507": "   * in the following code fragment:\n",
        "508": "   *\n",
        "509": "   * <pre>{@code\n",
        "510": "   * Set<Object> identityHashSet = Sets.newSetFromMap(\n",
        "511": "   *     new IdentityHashMap<Object, Boolean>());\n",
        "512": "   * }</pre>\n",
        "527": "   * An unmodifiable view of a set which may be backed by other sets; this view will change as the\n",
        "528": "   * backing sets do. Contains methods to copy the data into a new set which will then remain\n",
        "529": "   * stable. There is usually no reason to retain a reference of type {@code SetView}; typically,\n",
        "530": "   * you either use it as a plain {@link Set}, or immediately invoke {@link #immutableCopy} or\n",
        "539": "     * Returns an immutable copy of the current contents of this set view. Does not support null\n",
        "540": "     * elements.\n",
        "542": "     * <p><b>Warning:</b> this may have unexpected results if a backing set of this view uses a\n",
        "543": "     * nonstandard notion of equivalence, for example if it is a {@link TreeSet} using a comparator\n",
        "544": "     * that is inconsistent with {@link Object#equals(Object)}.\n",
        "551": "     * Copies the current contents of this set view into an existing set. This method has equivalent\n",
        "552": "     * behavior to {@code set.addAll(this)}, assuming that all the sets involved are based on the\n",
        "553": "     * same notion of equivalence.\n",
        "652": "   * Returns an unmodifiable <b>view</b> of the union of two sets. The returned set contains all\n",
        "653": "   * elements that are contained in either backing set. Iterating over the returned set iterates\n",
        "654": "   * first over all the elements of {@code set1}, then over each element of {@code set2}, in order,\n",
        "655": "   * that is not contained in {@code set1}.\n",
        "656": "   *\n",
        "657": "   * <p>Results are undefined if {@code set1} and {@code set2} are sets based on different\n",
        "658": "   * equivalence relations (as {@link HashSet}, {@link TreeSet}, and the {@link Map#keySet} of an\n",
        "659": "   * {@code IdentityHashMap} all are).\n",
        "724": "   * Returns an unmodifiable <b>view</b> of the intersection of two sets. The returned set contains\n",
        "725": "   * all elements that are contained by both backing sets. The iteration order of the returned set\n",
        "726": "   * matches that of {@code set1}.\n",
        "727": "   *\n",
        "728": "   * <p>Results are undefined if {@code set1} and {@code set2} are sets based on different\n",
        "729": "   * equivalence relations (as {@code HashSet}, {@code TreeSet}, and the keySet of an {@code\n",
        "730": "   * IdentityHashMap} all are).\n",
        "731": "   *\n",
        "732": "   * <p><b>Note:</b> The returned view performs slightly better when {@code set1} is the smaller of\n",
        "733": "   * the two sets. If you have reason to believe one of your sets will generally be smaller than the\n",
        "734": "   * other, pass it first. Unfortunately, since this method sets the generic type of the returned\n",
        "735": "   * set based on the type of the first set passed, this could in rare cases force you to make a\n",
        "736": "   * cast, for example:\n",
        "737": "   *\n",
        "738": "   * <pre>{@code\n",
        "739": "   * Set<Object> aFewBadObjects = ...\n",
        "740": "   * Set<String> manyBadStrings = ...\n",
        "741": "   *\n",
        "742": "   * // impossible for a non-String to be in the intersection\n",
        "743": "   * SuppressWarnings(\"unchecked\")\n",
        "744": "   * Set<String> badStrings = (Set) Sets.intersection(\n",
        "745": "   *     aFewBadObjects, manyBadStrings);\n",
        "746": "   * }</pre>\n",
        "802": "   * Returns an unmodifiable <b>view</b> of the difference of two sets. The returned set contains\n",
        "803": "   * all elements that are contained by {@code set1} and not contained by {@code set2}. {@code set2}\n",
        "804": "   * may also contain elements not present in {@code set1}; these are simply ignored. The iteration\n",
        "805": "   * order of the returned set matches that of {@code set1}.\n",
        "806": "   *\n",
        "807": "   * <p>Results are undefined if {@code set1} and {@code set2} are sets based on different\n",
        "808": "   * equivalence relations (as {@code HashSet}, {@code TreeSet}, and the keySet of an {@code\n",
        "809": "   * IdentityHashMap} all are).\n",
        "818": "        return new AbstractIterator<E>() {\n",
        "820": "\n",
        "858": "   * Returns an unmodifiable <b>view</b> of the symmetric difference of two sets. The returned set\n",
        "859": "   * contains all elements that are contained in either {@code set1} or {@code set2} but not in\n",
        "860": "   * both. The iteration order of the returned set is undefined.\n",
        "862": "   * <p>Results are undefined if {@code set1} and {@code set2} are sets based on different\n",
        "863": "   * equivalence relations (as {@code HashSet}, {@code TreeSet}, and the keySet of an {@code\n",
        "864": "   * IdentityHashMap} all are).\n",
        "927": "   * Returns the elements of {@code unfiltered} that satisfy a predicate. The returned set is a live\n",
        "928": "   * view of {@code unfiltered}; changes to one affect the other.\n",
        "929": "   *\n",
        "930": "   * <p>The resulting set's iterator does not support {@code remove()}, but all other set methods\n",
        "931": "   * are supported. When given an element that doesn't satisfy the predicate, the set's {@code\n",
        "932": "   * add()} and {@code addAll()} methods throw an {@link IllegalArgumentException}. When methods\n",
        "933": "   * such as {@code removeAll()} and {@code clear()} are called on the filtered set, only elements\n",
        "934": "   * that satisfy the filter will be removed from the underlying set.\n",
        "935": "   *\n",
        "936": "   * <p>The returned set isn't threadsafe or serializable, even if {@code unfiltered} is.\n",
        "937": "   *\n",
        "938": "   * <p>Many of the filtered set's methods, such as {@code size()}, iterate across every element in\n",
        "939": "   * the underlying set and determine which elements satisfy the filter. When a live view is\n",
        "940": "   * <i>not</i> needed, it may be faster to copy {@code Iterables.filter(unfiltered, predicate)} and\n",
        "941": "   * use the copy.\n",
        "942": "   *\n",
        "943": "   * <p><b>Warning:</b> {@code predicate} must be <i>consistent with equals</i>, as documented at\n",
        "944": "   * {@link Predicate#apply}. Do not provide a predicate such as {@code\n",
        "945": "   * Predicates.instanceOf(ArrayList.class)}, which is inconsistent with equals. (See {@link\n",
        "946": "   * Iterables#filter(Iterable, Class)} for related functionality.)\n",
        "947": "   *\n",
        "948": "   * <p><b>Java 8 users:</b> many use cases for this method are better addressed by {@link\n",
        "949": "   * java.util.stream.Stream#filter}. This method is not being deprecated, but we gently encourage\n",
        "950": "   * you to migrate to streams.\n",
        "985": "   * Returns the elements of a {@code SortedSet}, {@code unfiltered}, that satisfy a predicate. The\n",
        "986": "   * returned set is a live view of {@code unfiltered}; changes to one affect the other.\n",
        "987": "   *\n",
        "988": "   * <p>The resulting set's iterator does not support {@code remove()}, but all other set methods\n",
        "989": "   * are supported. When given an element that doesn't satisfy the predicate, the set's {@code\n",
        "990": "   * add()} and {@code addAll()} methods throw an {@link IllegalArgumentException}. When methods\n",
        "991": "   * such as {@code removeAll()} and {@code clear()} are called on the filtered set, only elements\n",
        "992": "   * that satisfy the filter will be removed from the underlying set.\n",
        "993": "   *\n",
        "994": "   * <p>The returned set isn't threadsafe or serializable, even if {@code unfiltered} is.\n",
        "995": "   *\n",
        "996": "   * <p>Many of the filtered set's methods, such as {@code size()}, iterate across every element in\n",
        "997": "   * the underlying set and determine which elements satisfy the filter. When a live view is\n",
        "998": "   * <i>not</i> needed, it may be faster to copy {@code Iterables.filter(unfiltered, predicate)} and\n",
        "999": "   * use the copy.\n",
        "1000": "   *\n",
        "1001": "   * <p><b>Warning:</b> {@code predicate} must be <i>consistent with equals</i>, as documented at\n",
        "1002": "   * {@link Predicate#apply}. Do not provide a predicate such as {@code\n",
        "1003": "   * Predicates.instanceOf(ArrayList.class)}, which is inconsistent with equals. (See {@link\n",
        "1004": "   * Iterables#filter(Iterable, Class)} for related functionality.)\n",
        "1066": "   * Returns the elements of a {@code NavigableSet}, {@code unfiltered}, that satisfy a predicate.\n",
        "1067": "   * The returned set is a live view of {@code unfiltered}; changes to one affect the other.\n",
        "1068": "   *\n",
        "1069": "   * <p>The resulting set's iterator does not support {@code remove()}, but all other set methods\n",
        "1070": "   * are supported. When given an element that doesn't satisfy the predicate, the set's {@code\n",
        "1071": "   * add()} and {@code addAll()} methods throw an {@link IllegalArgumentException}. When methods\n",
        "1072": "   * such as {@code removeAll()} and {@code clear()} are called on the filtered set, only elements\n",
        "1073": "   * that satisfy the filter will be removed from the underlying set.\n",
        "1074": "   *\n",
        "1075": "   * <p>The returned set isn't threadsafe or serializable, even if {@code unfiltered} is.\n",
        "1076": "   *\n",
        "1077": "   * <p>Many of the filtered set's methods, such as {@code size()}, iterate across every element in\n",
        "1078": "   * the underlying set and determine which elements satisfy the filter. When a live view is\n",
        "1079": "   * <i>not</i> needed, it may be faster to copy {@code Iterables.filter(unfiltered, predicate)} and\n",
        "1080": "   * use the copy.\n",
        "1081": "   *\n",
        "1082": "   * <p><b>Warning:</b> {@code predicate} must be <i>consistent with equals</i>, as documented at\n",
        "1083": "   * {@link Predicate#apply}. Do not provide a predicate such as {@code\n",
        "1084": "   * Predicates.instanceOf(ArrayList.class)}, which is inconsistent with equals. (See {@link\n",
        "1085": "   * Iterables#filter(Iterable, Class)} for related functionality.)\n",
        "1181": "   * Returns every possible list that can be formed by choosing one element from each of the given\n",
        "1182": "   * sets in order; the \"n-ary <a href=\"http://en.wikipedia.org/wiki/Cartesian_product\">Cartesian\n",
        "1183": "   * product</a>\" of the sets. For example:\n",
        "1185": "   * <pre>{@code\n",
        "1186": "   * Sets.cartesianProduct(ImmutableList.of(\n",
        "1187": "   *     ImmutableSet.of(1, 2),\n",
        "1188": "   *     ImmutableSet.of(\"A\", \"B\", \"C\")))\n",
        "1189": "   * }</pre>\n",
        "1194": "   *   <li>{@code ImmutableList.of(1, \"A\")}\n",
        "1195": "   *   <li>{@code ImmutableList.of(1, \"B\")}\n",
        "1196": "   *   <li>{@code ImmutableList.of(1, \"C\")}\n",
        "1197": "   *   <li>{@code ImmutableList.of(2, \"A\")}\n",
        "1198": "   *   <li>{@code ImmutableList.of(2, \"B\")}\n",
        "1199": "   *   <li>{@code ImmutableList.of(2, \"C\")}\n",
        "1202": "   * <p>The result is guaranteed to be in the \"traditional\", lexicographical order for Cartesian\n",
        "1203": "   * products that you would get from nesting for loops:\n",
        "1204": "   *\n",
        "1205": "   * <pre>{@code\n",
        "1206": "   * for (B b0 : sets.get(0)) {\n",
        "1207": "   *   for (B b1 : sets.get(1)) {\n",
        "1208": "   *     ...\n",
        "1209": "   *     ImmutableList<B> tuple = ImmutableList.of(b0, b1, ...);\n",
        "1210": "   *     // operate on tuple\n",
        "1211": "   *   }\n",
        "1212": "   * }\n",
        "1213": "   * }</pre>\n",
        "1214": "   *\n",
        "1215": "   * <p>Note that if any input set is empty, the Cartesian product will also be empty. If no sets at\n",
        "1216": "   * all are provided (an empty list), the resulting Cartesian product has one element, an empty\n",
        "1217": "   * list (counter-intuitive, but mathematically consistent).\n",
        "1218": "   *\n",
        "1219": "   * <p><i>Performance notes:</i> while the cartesian product of sets of size {@code m, n, p} is a\n",
        "1220": "   * set of size {@code m x n x p}, its actual memory consumption is much smaller. When the\n",
        "1221": "   * cartesian set is constructed, the input sets are merely copied. Only as the resulting set is\n",
        "1222": "   * iterated are the individual lists created, and these are not retained after iteration.\n",
        "1223": "   *\n",
        "1224": "   * @param sets the sets to choose elements from, in the order that the elements chosen from those\n",
        "1225": "   *     sets should appear in the resulting lists\n",
        "1226": "   * @param <B> any common base class shared by all axes (often just {@link Object})\n",
        "1227": "   * @return the Cartesian product, as an immutable set containing immutable lists\n",
        "1228": "   * @throws NullPointerException if {@code sets}, any one of the {@code sets}, or any element of a\n",
        "1229": "   *     provided set is null\n",
        "1237": "   * Returns every possible list that can be formed by choosing one element from each of the given\n",
        "1238": "   * sets in order; the \"n-ary <a href=\"http://en.wikipedia.org/wiki/Cartesian_product\">Cartesian\n",
        "1239": "   * product</a>\" of the sets. For example:\n",
        "1241": "   * <pre>{@code\n",
        "1242": "   * Sets.cartesianProduct(\n",
        "1243": "   *     ImmutableSet.of(1, 2),\n",
        "1244": "   *     ImmutableSet.of(\"A\", \"B\", \"C\"))\n",
        "1245": "   * }</pre>\n",
        "1250": "   *   <li>{@code ImmutableList.of(1, \"A\")}\n",
        "1251": "   *   <li>{@code ImmutableList.of(1, \"B\")}\n",
        "1252": "   *   <li>{@code ImmutableList.of(1, \"C\")}\n",
        "1253": "   *   <li>{@code ImmutableList.of(2, \"A\")}\n",
        "1254": "   *   <li>{@code ImmutableList.of(2, \"B\")}\n",
        "1255": "   *   <li>{@code ImmutableList.of(2, \"C\")}\n",
        "1258": "   * <p>The result is guaranteed to be in the \"traditional\", lexicographical order for Cartesian\n",
        "1259": "   * products that you would get from nesting for loops:\n",
        "1260": "   *\n",
        "1261": "   * <pre>{@code\n",
        "1262": "   * for (B b0 : sets.get(0)) {\n",
        "1263": "   *   for (B b1 : sets.get(1)) {\n",
        "1264": "   *     ...\n",
        "1265": "   *     ImmutableList<B> tuple = ImmutableList.of(b0, b1, ...);\n",
        "1266": "   *     // operate on tuple\n",
        "1267": "   *   }\n",
        "1268": "   * }\n",
        "1269": "   * }</pre>\n",
        "1270": "   *\n",
        "1271": "   * <p>Note that if any input set is empty, the Cartesian product will also be empty. If no sets at\n",
        "1272": "   * all are provided (an empty list), the resulting Cartesian product has one element, an empty\n",
        "1273": "   * list (counter-intuitive, but mathematically consistent).\n",
        "1274": "   *\n",
        "1275": "   * <p><i>Performance notes:</i> while the cartesian product of sets of size {@code m, n, p} is a\n",
        "1276": "   * set of size {@code m x n x p}, its actual memory consumption is much smaller. When the\n",
        "1277": "   * cartesian set is constructed, the input sets are merely copied. Only as the resulting set is\n",
        "1278": "   * iterated are the individual lists created, and these are not retained after iteration.\n",
        "1279": "   *\n",
        "1280": "   * @param sets the sets to choose elements from, in the order that the elements chosen from those\n",
        "1281": "   *     sets should appear in the resulting lists\n",
        "1282": "   * @param <B> any common base class shared by all axes (often just {@link Object})\n",
        "1283": "   * @return the Cartesian product, as an immutable set containing immutable lists\n",
        "1284": "   * @throws NullPointerException if {@code sets}, any one of the {@code sets}, or any element of a\n",
        "1285": "   *     provided set is null\n",
        "1372": "   * Returns the set of all possible subsets of {@code set}. For example, {@code\n",
        "1373": "   * powerSet(ImmutableSet.of(1, 2))} returns the set {@code {{}, {1}, {2}, {1, 2}}}.\n",
        "1375": "   * <p>Elements appear in these subsets in the same iteration order as they appeared in the input\n",
        "1376": "   * set. The order in which these subsets appear in the outer set is undefined. Note that the power\n",
        "1377": "   * set of the empty set is not the empty set, but a one-element set containing the empty set.\n",
        "1379": "   * <p>The returned set and its constituent sets use {@code equals} to decide whether two elements\n",
        "1380": "   * are identical, even if the input set uses a different concept of equivalence.\n",
        "1382": "   * <p><i>Performance notes:</i> while the power set of a set with size {@code n} is of size {@code\n",
        "1383": "   * 2^n}, its memory usage is only {@code O(n)}. When the power set is constructed, the input set\n",
        "1384": "   * is merely copied. Only as the power set is iterated are the individual subsets created, and\n",
        "1385": "   * these subsets themselves occupy only a small constant amount of memory.\n",
        "1389": "   * @throws IllegalArgumentException if {@code set} has more than 30 unique elements (causing the\n",
        "1390": "   *     power set size to exceed the {@code int} range)\n",
        "1392": "   * @see <a href=\"http://en.wikipedia.org/wiki/Power_set\">Power set article at Wikipedia</a>\n",
        "1629": "  /** An implementation for {@link Set#hashCode()}. */\n",
        "1641": "  /** An implementation for {@link Set#equals(Object)}. */\n",
        "1659": "   * Returns an unmodifiable view of the specified navigable set. This method allows modules to\n",
        "1660": "   * provide users with \"read-only\" access to internal navigable sets. Query operations on the\n",
        "1661": "   * returned set \"read through\" to the specified set, and attempts to modify the returned set,\n",
        "1662": "   * whether direct or via its collection views, result in an {@code UnsupportedOperationException}.\n",
        "1663": "   *\n",
        "1664": "   * <p>The returned navigable set will be serializable if the specified navigable set is\n",
        "1665": "   * serializable.\n",
        "1666": "   *\n",
        "1667": "   * @param set the navigable set for which an unmodifiable view is to be returned\n",
        "1761": "   * Returns a synchronized (thread-safe) navigable set backed by the specified navigable set. In\n",
        "1762": "   * order to guarantee serial access, it is critical that <b>all</b> access to the backing\n",
        "1763": "   * navigable set is accomplished through the returned navigable set (or its views).\n",
        "1764": "   *\n",
        "1765": "   * <p>It is imperative that the user manually synchronize on the returned sorted set when\n",
        "1766": "   * iterating over it or any of its {@code descendingSet}, {@code subSet}, {@code headSet}, or\n",
        "1767": "   * {@code tailSet} views.\n",
        "1768": "   *\n",
        "1769": "   * <pre>{@code\n",
        "1770": "   * NavigableSet<E> set = synchronizedNavigableSet(new TreeSet<E>());\n",
        "1771": "   *  ...\n",
        "1772": "   * synchronized (set) {\n",
        "1773": "   *   // Must be in the synchronized block\n",
        "1774": "   *   Iterator<E> it = set.iterator();\n",
        "1775": "   *   while (it.hasNext()) {\n",
        "1776": "   *     foo(it.next());\n",
        "1777": "   *   }\n",
        "1778": "   * }\n",
        "1779": "   * }</pre>\n",
        "1780": "   *\n",
        "1781": "   * <p>or:\n",
        "1782": "   *\n",
        "1783": "   * <pre>{@code\n",
        "1784": "   * NavigableSet<E> set = synchronizedNavigableSet(new TreeSet<E>());\n",
        "1785": "   * NavigableSet<E> set2 = set.descendingSet().headSet(foo);\n",
        "1786": "   *  ...\n",
        "1787": "   * synchronized (set) { // Note: set, not set2!!!\n",
        "1788": "   *   // Must be in the synchronized block\n",
        "1789": "   *   Iterator<E> it = set2.descendingIterator();\n",
        "1790": "   *   while (it.hasNext())\n",
        "1791": "   *     foo(it.next());\n",
        "1792": "   *   }\n",
        "1793": "   * }\n",
        "1794": "   * }</pre>\n",
        "1798": "   * <p>The returned navigable set will be serializable if the specified navigable set is\n",
        "1799": "   * serializable.\n",
        "1801": "   * @param navigableSet the navigable set to be \"wrapped\" in a synchronized navigable set.\n",
        "1810": "  /** Remove each element in an iterable from a set. */\n",
        "1972": "   * <p>This method delegates to the appropriate methods of {@link NavigableSet} (namely {@link\n",
        "1973": "   * NavigableSet#subSet(Object, boolean, Object, boolean) subSet()}, {@link\n",
        "1974": "   * NavigableSet#tailSet(Object, boolean) tailSet()}, and {@link NavigableSet#headSet(Object,\n",
        "1975": "   * boolean) headSet()}) to actually construct the view. Consult these methods for a full\n",
        "1976": "   * description of the returned view's behavior.\n",
        "1979": "   * ordering. {@code NavigableSet} on the other hand can specify a custom ordering via a {@link\n",
        "1980": "   * Comparator}, which can violate the natural ordering. Using this method (or in general using\n",
        "1981": "   * {@code Range}) with unnaturally-ordered sets can lead to unexpected and undefined behavior.\n"
    },
    "removed": {
        "54": " * Static utility methods pertaining to {@link Set} instances. Also see this\n",
        "55": " * class's counterparts {@link Lists}, {@link Maps} and {@link Queues}.\n",
        "58": " * \"https://github.com/google/guava/wiki/CollectionUtilitiesExplained#sets\">\n",
        "59": " * {@code Sets}</a>.\n",
        "71": "   * {@link AbstractSet} substitute without the potentially-quadratic\n",
        "72": "   * {@code removeAll} implementation.\n",
        "87": "   * Returns an immutable set instance containing the given enum elements.\n",
        "88": "   * Internally, the returned set will be backed by an {@link EnumSet}.\n",
        "90": "   * <p>The iteration order of the returned set follows the enum's iteration\n",
        "91": "   * order, not the order in which the elements are provided to the method.\n",
        "105": "   * Returns an immutable set instance containing the given enum elements.\n",
        "106": "   * Internally, the returned set will be backed by an {@link EnumSet}.\n",
        "108": "   * <p>The iteration order of the returned set follows the enum's iteration\n",
        "109": "   * order, not the order in which the elements appear in the given collection.\n",
        "111": "   * @param elements the elements, all of the same {@code enum} type, that the\n",
        "112": "   *     set should contain\n",
        "156": "   * <p><b>Note:</b> if mutability is not required, use {@link ImmutableSet#of()} instead. If\n",
        "157": "   * {@code E} is an {@link Enum} type, use {@link EnumSet#noneOf} instead. Otherwise, strongly\n",
        "158": "   * consider using a {@code LinkedHashSet} instead, at the cost of increased memory footprint, to\n",
        "159": "   * get deterministic iteration behavior.\n",
        "247": "   * Creates a thread-safe set backed by a hash map. The set is backed by a\n",
        "248": "   * {@link ConcurrentHashMap} instance, and thus carries the same concurrency\n",
        "249": "   * guarantees.\n",
        "251": "   * <p>Unlike {@code HashSet}, this class does NOT allow {@code null} to be\n",
        "252": "   * used as an element. The set is serializable.\n",
        "262": "   * Creates a thread-safe set backed by a hash map and containing the given\n",
        "263": "   * elements. The set is backed by a {@link ConcurrentHashMap} instance, and\n",
        "264": "   * thus carries the same concurrency guarantees.\n",
        "266": "   * <p>Unlike {@code HashSet}, this class does NOT allow {@code null} to be\n",
        "267": "   * used as an element. The set is serializable.\n",
        "271": "   * @throws NullPointerException if {@code elements} or any of its contents is\n",
        "272": "   *      null\n",
        "306": "   *         elements without resizing\n",
        "404": "   * Creates an empty {@code Set} that uses identity to determine equality. It\n",
        "405": "   * compares object references, instead of calling {@code equals}, to\n",
        "406": "   * determine whether a provided object matches an element in the set. For\n",
        "407": "   * example, {@code contains} returns {@code false} when passed an object that\n",
        "408": "   * equals a set member, but isn't the same instance. This behavior is similar\n",
        "409": "   * to the way {@code IdentityHashMap} handles key lookups.\n",
        "420": "   * <p><b>Note:</b> if you need an immutable empty {@link Set}, use\n",
        "421": "   * {@link Collections#emptySet} instead.\n",
        "450": "   * Creates an {@code EnumSet} consisting of all enum values that are not in\n",
        "451": "   * the specified collection. If the collection is an {@link EnumSet}, this\n",
        "452": "   * method has the same behavior as {@link EnumSet#complementOf}. Otherwise,\n",
        "453": "   * the specified collection must contain at least one element, in order to\n",
        "454": "   * determine the element type. If the collection could be empty, use\n",
        "455": "   * {@link #complementOf(Collection, Class)} instead of this method.\n",
        "456": "   *\n",
        "457": "   * @param collection the collection whose complement should be stored in the\n",
        "458": "   *     enum set\n",
        "459": "   * @return a new, modifiable {@code EnumSet} containing all values of the enum\n",
        "460": "   *     that aren't present in the given collection\n",
        "461": "   * @throws IllegalArgumentException if {@code collection} is not an\n",
        "462": "   *     {@code EnumSet} instance and contains no elements\n",
        "475": "   * Creates an {@code EnumSet} consisting of all enum values that are not in\n",
        "476": "   * the specified collection. This is equivalent to\n",
        "477": "   * {@link EnumSet#complementOf}, but can act on any input collection, as long\n",
        "478": "   * as the elements are of enum type.\n",
        "480": "   * @param collection the collection whose complement should be stored in the\n",
        "481": "   *     {@code EnumSet}\n",
        "483": "   * @return a new, modifiable {@code EnumSet} initially containing all the\n",
        "484": "   *     values of the enum not present in the given collection\n",
        "502": "   * Returns a set backed by the specified map. The resulting set displays\n",
        "503": "   * the same ordering, concurrency, and performance characteristics as the\n",
        "504": "   * backing map. In essence, this factory method provides a {@link Set}\n",
        "505": "   * implementation corresponding to any {@link Map} implementation. There is no\n",
        "506": "   * need to use this method on a {@link Map} implementation that already has a\n",
        "507": "   * corresponding {@link Set} implementation (such as {@link java.util.HashMap}\n",
        "508": "   * or {@link java.util.TreeMap}).\n",
        "509": "   *\n",
        "510": "   * <p>Each method invocation on the set returned by this method results in\n",
        "511": "   * exactly one method invocation on the backing map or its {@code keySet}\n",
        "512": "   * view, with one exception. The {@code addAll} method is implemented as a\n",
        "513": "   * sequence of {@code put} invocations on the backing map.\n",
        "514": "   *\n",
        "515": "   * <p>The specified map must be empty at the time this method is invoked,\n",
        "516": "   * and should not be accessed directly after this method returns. These\n",
        "517": "   * conditions are ensured if the map is created empty, passed directly\n",
        "518": "   * to this method, and no reference to the map is retained, as illustrated\n",
        "519": "   * in the following code fragment: <pre>  {@code\n",
        "520": "   *\n",
        "521": "   *   Set<Object> identityHashSet = Sets.newSetFromMap(\n",
        "522": "   *       new IdentityHashMap<Object, Boolean>());}</pre>\n",
        "537": "   * An unmodifiable view of a set which may be backed by other sets; this view\n",
        "538": "   * will change as the backing sets do. Contains methods to copy the data into\n",
        "539": "   * a new set which will then remain stable. There is usually no reason to\n",
        "540": "   * retain a reference of type {@code SetView}; typically, you either use it\n",
        "541": "   * as a plain {@link Set}, or immediately invoke {@link #immutableCopy} or\n",
        "550": "     * Returns an immutable copy of the current contents of this set view.\n",
        "551": "     * Does not support null elements.\n",
        "553": "     * <p><b>Warning:</b> this may have unexpected results if a backing set of\n",
        "554": "     * this view uses a nonstandard notion of equivalence, for example if it is\n",
        "555": "     * a {@link TreeSet} using a comparator that is inconsistent with {@link\n",
        "556": "     * Object#equals(Object)}.\n",
        "563": "     * Copies the current contents of this set view into an existing set. This\n",
        "564": "     * method has equivalent behavior to {@code set.addAll(this)}, assuming that\n",
        "565": "     * all the sets involved are based on the same notion of equivalence.\n",
        "664": "   * Returns an unmodifiable <b>view</b> of the union of two sets. The returned\n",
        "665": "   * set contains all elements that are contained in either backing set.\n",
        "666": "   * Iterating over the returned set iterates first over all the elements of\n",
        "667": "   * {@code set1}, then over each element of {@code set2}, in order, that is not\n",
        "668": "   * contained in {@code set1}.\n",
        "669": "   *\n",
        "670": "   * <p>Results are undefined if {@code set1} and {@code set2} are sets based on\n",
        "671": "   * different equivalence relations (as {@link HashSet}, {@link TreeSet}, and\n",
        "672": "   * the {@link Map#keySet} of an {@code IdentityHashMap} all are).\n",
        "737": "   * Returns an unmodifiable <b>view</b> of the intersection of two sets. The\n",
        "738": "   * returned set contains all elements that are contained by both backing sets.\n",
        "739": "   * The iteration order of the returned set matches that of {@code set1}.\n",
        "740": "   *\n",
        "741": "   * <p>Results are undefined if {@code set1} and {@code set2} are sets based\n",
        "742": "   * on different equivalence relations (as {@code HashSet}, {@code TreeSet},\n",
        "743": "   * and the keySet of an {@code IdentityHashMap} all are).\n",
        "744": "   *\n",
        "745": "   * <p><b>Note:</b> The returned view performs slightly better when {@code\n",
        "746": "   * set1} is the smaller of the two sets. If you have reason to believe one of\n",
        "747": "   * your sets will generally be smaller than the other, pass it first.\n",
        "748": "   * Unfortunately, since this method sets the generic type of the returned set\n",
        "749": "   * based on the type of the first set passed, this could in rare cases force\n",
        "750": "   * you to make a cast, for example: <pre>   {@code\n",
        "751": "   *\n",
        "752": "   *   Set<Object> aFewBadObjects = ...\n",
        "753": "   *   Set<String> manyBadStrings = ...\n",
        "754": "   *\n",
        "755": "   *   // impossible for a non-String to be in the intersection\n",
        "756": "   *   SuppressWarnings(\"unchecked\")\n",
        "757": "   *   Set<String> badStrings = (Set) Sets.intersection(\n",
        "758": "   *       aFewBadObjects, manyBadStrings);}</pre>\n",
        "814": "   * Returns an unmodifiable <b>view</b> of the difference of two sets. The\n",
        "815": "   * returned set contains all elements that are contained by {@code set1} and\n",
        "816": "   * not contained by {@code set2}. {@code set2} may also contain elements not\n",
        "817": "   * present in {@code set1}; these are simply ignored. The iteration order of\n",
        "818": "   * the returned set matches that of {@code set1}.\n",
        "819": "   *\n",
        "820": "   * <p>Results are undefined if {@code set1} and {@code set2} are sets based\n",
        "821": "   * on different equivalence relations (as {@code HashSet}, {@code TreeSet},\n",
        "822": "   * and the keySet of an {@code IdentityHashMap} all are).\n",
        "831": "        return new AbstractIterator<E>(){\n",
        "870": "   * Returns an unmodifiable <b>view</b> of the symmetric difference of two\n",
        "871": "   * sets. The returned set contains all elements that are contained in either\n",
        "872": "   * {@code set1} or {@code set2} but not in both. The iteration order of the\n",
        "873": "   * returned set is undefined.\n",
        "875": "   * <p>Results are undefined if {@code set1} and {@code set2} are sets based\n",
        "876": "   * on different equivalence relations (as {@code HashSet}, {@code TreeSet},\n",
        "877": "   * and the keySet of an {@code IdentityHashMap} all are).\n",
        "940": "   * Returns the elements of {@code unfiltered} that satisfy a predicate. The\n",
        "941": "   * returned set is a live view of {@code unfiltered}; changes to one affect\n",
        "942": "   * the other.\n",
        "943": "   *\n",
        "944": "   * <p>The resulting set's iterator does not support {@code remove()}, but all\n",
        "945": "   * other set methods are supported. When given an element that doesn't satisfy\n",
        "946": "   * the predicate, the set's {@code add()} and {@code addAll()} methods throw\n",
        "947": "   * an {@link IllegalArgumentException}. When methods such as {@code\n",
        "948": "   * removeAll()} and {@code clear()} are called on the filtered set, only\n",
        "949": "   * elements that satisfy the filter will be removed from the underlying set.\n",
        "950": "   *\n",
        "951": "   * <p>The returned set isn't threadsafe or serializable, even if\n",
        "952": "   * {@code unfiltered} is.\n",
        "953": "   *\n",
        "954": "   * <p>Many of the filtered set's methods, such as {@code size()}, iterate\n",
        "955": "   * across every element in the underlying set and determine which elements\n",
        "956": "   * satisfy the filter. When a live view is <i>not</i> needed, it may be faster\n",
        "957": "   * to copy {@code Iterables.filter(unfiltered, predicate)} and use the copy.\n",
        "958": "   *\n",
        "959": "   * <p><b>Warning:</b> {@code predicate} must be <i>consistent with equals</i>,\n",
        "960": "   * as documented at {@link Predicate#apply}. Do not provide a predicate such\n",
        "961": "   * as {@code Predicates.instanceOf(ArrayList.class)}, which is inconsistent\n",
        "962": "   * with equals. (See {@link Iterables#filter(Iterable, Class)} for related\n",
        "963": "   * functionality.)\n",
        "964": "   *\n",
        "965": "   * <p><b>Java 8 users:</b> many use cases for this method are better\n",
        "966": "   * addressed by {@link java.util.stream.Stream#filter}. This method is not\n",
        "967": "   * being deprecated, but we gently encourage you to migrate to streams.\n",
        "1002": "   * Returns the elements of a {@code SortedSet}, {@code unfiltered}, that\n",
        "1003": "   * satisfy a predicate. The returned set is a live view of {@code unfiltered};\n",
        "1004": "   * changes to one affect the other.\n",
        "1005": "   *\n",
        "1006": "   * <p>The resulting set's iterator does not support {@code remove()}, but all\n",
        "1007": "   * other set methods are supported. When given an element that doesn't satisfy\n",
        "1008": "   * the predicate, the set's {@code add()} and {@code addAll()} methods throw\n",
        "1009": "   * an {@link IllegalArgumentException}. When methods such as\n",
        "1010": "   * {@code removeAll()} and {@code clear()} are called on the filtered set,\n",
        "1011": "   * only elements that satisfy the filter will be removed from the underlying\n",
        "1012": "   * set.\n",
        "1013": "   *\n",
        "1014": "   * <p>The returned set isn't threadsafe or serializable, even if\n",
        "1015": "   * {@code unfiltered} is.\n",
        "1016": "   *\n",
        "1017": "   * <p>Many of the filtered set's methods, such as {@code size()}, iterate across\n",
        "1018": "   * every element in the underlying set and determine which elements satisfy\n",
        "1019": "   * the filter. When a live view is <i>not</i> needed, it may be faster to copy\n",
        "1020": "   * {@code Iterables.filter(unfiltered, predicate)} and use the copy.\n",
        "1021": "   *\n",
        "1022": "   * <p><b>Warning:</b> {@code predicate} must be <i>consistent with equals</i>,\n",
        "1023": "   * as documented at {@link Predicate#apply}. Do not provide a predicate such as\n",
        "1024": "   * {@code Predicates.instanceOf(ArrayList.class)}, which is inconsistent with\n",
        "1025": "   * equals. (See {@link Iterables#filter(Iterable, Class)} for related\n",
        "1026": "   * functionality.)\n",
        "1088": "   * Returns the elements of a {@code NavigableSet}, {@code unfiltered}, that\n",
        "1089": "   * satisfy a predicate. The returned set is a live view of {@code unfiltered};\n",
        "1090": "   * changes to one affect the other.\n",
        "1091": "   *\n",
        "1092": "   * <p>The resulting set's iterator does not support {@code remove()}, but all\n",
        "1093": "   * other set methods are supported. When given an element that doesn't satisfy\n",
        "1094": "   * the predicate, the set's {@code add()} and {@code addAll()} methods throw\n",
        "1095": "   * an {@link IllegalArgumentException}. When methods such as\n",
        "1096": "   * {@code removeAll()} and {@code clear()} are called on the filtered set,\n",
        "1097": "   * only elements that satisfy the filter will be removed from the underlying\n",
        "1098": "   * set.\n",
        "1099": "   *\n",
        "1100": "   * <p>The returned set isn't threadsafe or serializable, even if\n",
        "1101": "   * {@code unfiltered} is.\n",
        "1102": "   *\n",
        "1103": "   * <p>Many of the filtered set's methods, such as {@code size()}, iterate across\n",
        "1104": "   * every element in the underlying set and determine which elements satisfy\n",
        "1105": "   * the filter. When a live view is <i>not</i> needed, it may be faster to copy\n",
        "1106": "   * {@code Iterables.filter(unfiltered, predicate)} and use the copy.\n",
        "1107": "   *\n",
        "1108": "   * <p><b>Warning:</b> {@code predicate} must be <i>consistent with equals</i>,\n",
        "1109": "   * as documented at {@link Predicate#apply}. Do not provide a predicate such as\n",
        "1110": "   * {@code Predicates.instanceOf(ArrayList.class)}, which is inconsistent with\n",
        "1111": "   * equals. (See {@link Iterables#filter(Iterable, Class)} for related\n",
        "1112": "   * functionality.)\n",
        "1208": "   * Returns every possible list that can be formed by choosing one element\n",
        "1209": "   * from each of the given sets in order; the \"n-ary\n",
        "1210": "   * <a href=\"http://en.wikipedia.org/wiki/Cartesian_product\">Cartesian\n",
        "1211": "   * product</a>\" of the sets. For example: <pre>   {@code\n",
        "1213": "   *   Sets.cartesianProduct(ImmutableList.of(\n",
        "1214": "   *       ImmutableSet.of(1, 2),\n",
        "1215": "   *       ImmutableSet.of(\"A\", \"B\", \"C\")))}</pre>\n",
        "1220": "   * <li>{@code ImmutableList.of(1, \"A\")}\n",
        "1221": "   * <li>{@code ImmutableList.of(1, \"B\")}\n",
        "1222": "   * <li>{@code ImmutableList.of(1, \"C\")}\n",
        "1223": "   * <li>{@code ImmutableList.of(2, \"A\")}\n",
        "1224": "   * <li>{@code ImmutableList.of(2, \"B\")}\n",
        "1225": "   * <li>{@code ImmutableList.of(2, \"C\")}\n",
        "1228": "   * <p>The result is guaranteed to be in the \"traditional\", lexicographical\n",
        "1229": "   * order for Cartesian products that you would get from nesting for loops:\n",
        "1230": "   * <pre>   {@code\n",
        "1231": "   *\n",
        "1232": "   *   for (B b0 : sets.get(0)) {\n",
        "1233": "   *     for (B b1 : sets.get(1)) {\n",
        "1234": "   *       ...\n",
        "1235": "   *       ImmutableList<B> tuple = ImmutableList.of(b0, b1, ...);\n",
        "1236": "   *       // operate on tuple\n",
        "1237": "   *     }\n",
        "1238": "   *   }}</pre>\n",
        "1239": "   *\n",
        "1240": "   * <p>Note that if any input set is empty, the Cartesian product will also be\n",
        "1241": "   * empty. If no sets at all are provided (an empty list), the resulting\n",
        "1242": "   * Cartesian product has one element, an empty list (counter-intuitive, but\n",
        "1243": "   * mathematically consistent).\n",
        "1244": "   *\n",
        "1245": "   * <p><i>Performance notes:</i> while the cartesian product of sets of size\n",
        "1246": "   * {@code m, n, p} is a set of size {@code m x n x p}, its actual memory\n",
        "1247": "   * consumption is much smaller. When the cartesian set is constructed, the\n",
        "1248": "   * input sets are merely copied. Only as the resulting set is iterated are the\n",
        "1249": "   * individual lists created, and these are not retained after iteration.\n",
        "1250": "   *\n",
        "1251": "   * @param sets the sets to choose elements from, in the order that\n",
        "1252": "   *     the elements chosen from those sets should appear in the resulting\n",
        "1253": "   *     lists\n",
        "1254": "   * @param <B> any common base class shared by all axes (often just {@link\n",
        "1255": "   *     Object})\n",
        "1256": "   * @return the Cartesian product, as an immutable set containing immutable\n",
        "1257": "   *     lists\n",
        "1258": "   * @throws NullPointerException if {@code sets}, any one of the {@code sets},\n",
        "1259": "   *     or any element of a provided set is null\n",
        "1267": "   * Returns every possible list that can be formed by choosing one element\n",
        "1268": "   * from each of the given sets in order; the \"n-ary\n",
        "1269": "   * <a href=\"http://en.wikipedia.org/wiki/Cartesian_product\">Cartesian\n",
        "1270": "   * product</a>\" of the sets. For example: <pre>   {@code\n",
        "1272": "   *   Sets.cartesianProduct(\n",
        "1273": "   *       ImmutableSet.of(1, 2),\n",
        "1274": "   *       ImmutableSet.of(\"A\", \"B\", \"C\"))}</pre>\n",
        "1279": "   * <li>{@code ImmutableList.of(1, \"A\")}\n",
        "1280": "   * <li>{@code ImmutableList.of(1, \"B\")}\n",
        "1281": "   * <li>{@code ImmutableList.of(1, \"C\")}\n",
        "1282": "   * <li>{@code ImmutableList.of(2, \"A\")}\n",
        "1283": "   * <li>{@code ImmutableList.of(2, \"B\")}\n",
        "1284": "   * <li>{@code ImmutableList.of(2, \"C\")}\n",
        "1287": "   * <p>The result is guaranteed to be in the \"traditional\", lexicographical\n",
        "1288": "   * order for Cartesian products that you would get from nesting for loops:\n",
        "1289": "   * <pre>   {@code\n",
        "1290": "   *\n",
        "1291": "   *   for (B b0 : sets.get(0)) {\n",
        "1292": "   *     for (B b1 : sets.get(1)) {\n",
        "1293": "   *       ...\n",
        "1294": "   *       ImmutableList<B> tuple = ImmutableList.of(b0, b1, ...);\n",
        "1295": "   *       // operate on tuple\n",
        "1296": "   *     }\n",
        "1297": "   *   }}</pre>\n",
        "1298": "   *\n",
        "1299": "   * <p>Note that if any input set is empty, the Cartesian product will also be\n",
        "1300": "   * empty. If no sets at all are provided (an empty list), the resulting\n",
        "1301": "   * Cartesian product has one element, an empty list (counter-intuitive, but\n",
        "1302": "   * mathematically consistent).\n",
        "1303": "   *\n",
        "1304": "   * <p><i>Performance notes:</i> while the cartesian product of sets of size\n",
        "1305": "   * {@code m, n, p} is a set of size {@code m x n x p}, its actual memory\n",
        "1306": "   * consumption is much smaller. When the cartesian set is constructed, the\n",
        "1307": "   * input sets are merely copied. Only as the resulting set is iterated are the\n",
        "1308": "   * individual lists created, and these are not retained after iteration.\n",
        "1309": "   *\n",
        "1310": "   * @param sets the sets to choose elements from, in the order that\n",
        "1311": "   *     the elements chosen from those sets should appear in the resulting\n",
        "1312": "   *     lists\n",
        "1313": "   * @param <B> any common base class shared by all axes (often just {@link\n",
        "1314": "   *     Object})\n",
        "1315": "   * @return the Cartesian product, as an immutable set containing immutable\n",
        "1316": "   *     lists\n",
        "1317": "   * @throws NullPointerException if {@code sets}, any one of the {@code sets},\n",
        "1318": "   *     or any element of a provided set is null\n",
        "1405": "   * Returns the set of all possible subsets of {@code set}. For example,\n",
        "1406": "   * {@code powerSet(ImmutableSet.of(1, 2))} returns the set {@code {{},\n",
        "1407": "   * {1}, {2}, {1, 2}}}.\n",
        "1409": "   * <p>Elements appear in these subsets in the same iteration order as they\n",
        "1410": "   * appeared in the input set. The order in which these subsets appear in the\n",
        "1411": "   * outer set is undefined. Note that the power set of the empty set is not the\n",
        "1412": "   * empty set, but a one-element set containing the empty set.\n",
        "1414": "   * <p>The returned set and its constituent sets use {@code equals} to decide\n",
        "1415": "   * whether two elements are identical, even if the input set uses a different\n",
        "1416": "   * concept of equivalence.\n",
        "1418": "   * <p><i>Performance notes:</i> while the power set of a set with size {@code\n",
        "1419": "   * n} is of size {@code 2^n}, its memory usage is only {@code O(n)}. When the\n",
        "1420": "   * power set is constructed, the input set is merely copied. Only as the\n",
        "1421": "   * power set is iterated are the individual subsets created, and these subsets\n",
        "1422": "   * themselves occupy only a small constant amount of memory.\n",
        "1426": "   * @throws IllegalArgumentException if {@code set} has more than 30 unique\n",
        "1427": "   *     elements (causing the power set size to exceed the {@code int} range)\n",
        "1429": "   * @see <a href=\"http://en.wikipedia.org/wiki/Power_set\">Power set article at\n",
        "1430": "   *      Wikipedia</a>\n",
        "1667": "  /**\n",
        "1668": "   * An implementation for {@link Set#hashCode()}.\n",
        "1669": "   */\n",
        "1681": "  /**\n",
        "1682": "   * An implementation for {@link Set#equals(Object)}.\n",
        "1683": "   */\n",
        "1701": "   * Returns an unmodifiable view of the specified navigable set. This method\n",
        "1702": "   * allows modules to provide users with \"read-only\" access to internal\n",
        "1703": "   * navigable sets. Query operations on the returned set \"read through\" to the\n",
        "1704": "   * specified set, and attempts to modify the returned set, whether direct or\n",
        "1705": "   * via its collection views, result in an\n",
        "1706": "   * {@code UnsupportedOperationException}.\n",
        "1707": "   *\n",
        "1708": "   * <p>The returned navigable set will be serializable if the specified\n",
        "1709": "   * navigable set is serializable.\n",
        "1710": "   *\n",
        "1711": "   * @param set the navigable set for which an unmodifiable view is to be\n",
        "1712": "   *        returned\n",
        "1806": "   * Returns a synchronized (thread-safe) navigable set backed by the specified\n",
        "1807": "   * navigable set.  In order to guarantee serial access, it is critical that\n",
        "1808": "   * <b>all</b> access to the backing navigable set is accomplished\n",
        "1809": "   * through the returned navigable set (or its views).\n",
        "1810": "   *\n",
        "1811": "   * <p>It is imperative that the user manually synchronize on the returned\n",
        "1812": "   * sorted set when iterating over it or any of its {@code descendingSet},\n",
        "1813": "   * {@code subSet}, {@code headSet}, or {@code tailSet} views. <pre>   {@code\n",
        "1814": "   *\n",
        "1815": "   *   NavigableSet<E> set = synchronizedNavigableSet(new TreeSet<E>());\n",
        "1816": "   *    ...\n",
        "1817": "   *   synchronized (set) {\n",
        "1818": "   *     // Must be in the synchronized block\n",
        "1819": "   *     Iterator<E> it = set.iterator();\n",
        "1820": "   *     while (it.hasNext()) {\n",
        "1821": "   *       foo(it.next());\n",
        "1822": "   *     }\n",
        "1823": "   *   }}</pre>\n",
        "1824": "   *\n",
        "1825": "   * <p>or: <pre>   {@code\n",
        "1826": "   *\n",
        "1827": "   *   NavigableSet<E> set = synchronizedNavigableSet(new TreeSet<E>());\n",
        "1828": "   *   NavigableSet<E> set2 = set.descendingSet().headSet(foo);\n",
        "1829": "   *    ...\n",
        "1830": "   *   synchronized (set) { // Note: set, not set2!!!\n",
        "1831": "   *     // Must be in the synchronized block\n",
        "1832": "   *     Iterator<E> it = set2.descendingIterator();\n",
        "1833": "   *     while (it.hasNext())\n",
        "1834": "   *       foo(it.next());\n",
        "1835": "   *     }\n",
        "1836": "   *   }}</pre>\n",
        "1840": "   * <p>The returned navigable set will be serializable if the specified\n",
        "1841": "   * navigable set is serializable.\n",
        "1843": "   * @param navigableSet the navigable set to be \"wrapped\" in a synchronized\n",
        "1844": "   *    navigable set.\n",
        "1853": "  /**\n",
        "1854": "   * Remove each element in an iterable from a set.\n",
        "1855": "   */\n",
        "2017": "   * <p>This method delegates to the appropriate methods of {@link NavigableSet} (namely\n",
        "2018": "   * {@link NavigableSet#subSet(Object, boolean, Object, boolean) subSet()},\n",
        "2019": "   * {@link NavigableSet#tailSet(Object, boolean) tailSet()}, and\n",
        "2020": "   * {@link NavigableSet#headSet(Object, boolean) headSet()}) to actually construct the view.\n",
        "2021": "   * Consult these methods for a full description of the returned view's behavior.\n",
        "2024": "   * ordering. {@code NavigableSet} on the other hand can specify a custom ordering via a\n",
        "2025": "   * {@link Comparator}, which can violate the natural ordering. Using this method (or in general\n",
        "2026": "   * using {@code Range}) with unnaturally-ordered sets can lead to unexpected and undefined\n",
        "2027": "   * behavior.\n"
    }
}