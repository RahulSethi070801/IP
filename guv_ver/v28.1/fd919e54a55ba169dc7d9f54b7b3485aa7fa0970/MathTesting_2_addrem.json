{
    "addition": {
        "47": "  static final ImmutableSet<RoundingMode> ALL_ROUNDING_MODES =\n",
        "48": "      ImmutableSet.copyOf(RoundingMode.values());\n",
        "50": "  static final ImmutableList<RoundingMode> ALL_SAFE_ROUNDING_MODES =\n",
        "51": "      ImmutableList.of(DOWN, UP, FLOOR, CEILING, HALF_EVEN, HALF_UP, HALF_DOWN);\n",
        "54": "  static final ImmutableList<Integer> EXPONENTS =\n",
        "55": "      ImmutableList.of(0, 1, 2, 3, 4, 7, 10, 15, 20, 25, 40, 70);\n",
        "58": "  private static final Function<Integer, Long> TO_LONG =\n",
        "59": "      new Function<Integer, Long>() {\n",
        "60": "        @Override\n",
        "61": "        public Long apply(Integer n) {\n",
        "62": "          return Long.valueOf(n);\n",
        "63": "        }\n",
        "64": "      };\n",
        "75": "  private static final Function<Integer, Integer> NEGATE_INT =\n",
        "76": "      new Function<Integer, Integer>() {\n",
        "77": "        @Override\n",
        "78": "        public Integer apply(Integer x) {\n",
        "79": "          return -x;\n",
        "80": "        }\n",
        "81": "      };\n",
        "83": "  private static final Function<Long, Long> NEGATE_LONG =\n",
        "84": "      new Function<Long, Long>() {\n",
        "85": "        @Override\n",
        "86": "        public Long apply(Long x) {\n",
        "87": "          return -x;\n",
        "88": "        }\n",
        "89": "      };\n",
        "127": "    NEGATIVE_INTEGER_CANDIDATES =\n",
        "128": "        ImmutableList.copyOf(\n",
        "129": "            Iterables.concat(\n",
        "130": "                Iterables.transform(POSITIVE_INTEGER_CANDIDATES, NEGATE_INT),\n",
        "131": "                ImmutableList.of(Integer.MIN_VALUE)));\n",
        "132": "    NONZERO_INTEGER_CANDIDATES =\n",
        "133": "        ImmutableList.copyOf(\n",
        "134": "            Iterables.concat(POSITIVE_INTEGER_CANDIDATES, NEGATIVE_INTEGER_CANDIDATES));\n",
        "166": "        Iterables.concat(\n",
        "167": "            Iterables.transform(POSITIVE_LONG_CANDIDATES, NEGATE_LONG),\n",
        "193": "    for (int exponent :\n",
        "194": "        asList(\n",
        "195": "            64,\n",
        "196": "            65,\n",
        "197": "            71,\n",
        "198": "            72,\n",
        "199": "            73,\n",
        "200": "            79,\n",
        "201": "            80,\n",
        "202": "            81,\n",
        "203": "            255,\n",
        "204": "            256,\n",
        "205": "            257,\n",
        "206": "            511,\n",
        "207": "            512,\n",
        "208": "            513,\n",
        "209": "            Double.MAX_EXPONENT - 1,\n",
        "210": "            Double.MAX_EXPONENT,\n",
        "211": "            Double.MAX_EXPONENT + 1)) {\n",
        "216": "    // down\n",
        "229": "  static final Iterable<Double> INFINITIES =\n",
        "230": "      Doubles.asList(Double.POSITIVE_INFINITY, Double.NEGATIVE_INFINITY);\n",
        "248": "        double d = Double.longBitsToDouble(Double.doubleToLongBits(Math.scalb(1.0, i)) + direction);\n",
        "255": "    for (double d :\n",
        "256": "        Doubles.asList(\n",
        "257": "            0,\n",
        "258": "            1,\n",
        "259": "            2,\n",
        "260": "            7,\n",
        "261": "            51,\n",
        "262": "            102,\n",
        "263": "            Math.scalb(1.0, 53),\n",
        "264": "            Integer.MIN_VALUE,\n",
        "265": "            Integer.MAX_VALUE,\n",
        "266": "            Long.MIN_VALUE,\n",
        "267": "            Long.MAX_VALUE)) {\n",
        "291": "        Iterables.filter(\n",
        "292": "            FINITE_DOUBLE_CANDIDATES,\n",
        "293": "            new Predicate<Double>() {\n",
        "294": "              @Override\n",
        "295": "              public boolean apply(Double input) {\n",
        "296": "                return input.doubleValue() > 0.0;\n",
        "297": "              }\n",
        "298": "            });\n",
        "300": "    ALL_DOUBLE_CANDIDATES = Iterables.concat(DOUBLE_CANDIDATES_EXCEPT_NAN, asList(Double.NaN));\n"
    },
    "removed": {
        "47": "  static final ImmutableSet<RoundingMode> ALL_ROUNDING_MODES = ImmutableSet.copyOf(RoundingMode\n",
        "48": "      .values());\n",
        "50": "  static final ImmutableList<RoundingMode> ALL_SAFE_ROUNDING_MODES = ImmutableList.of(DOWN, UP,\n",
        "51": "      FLOOR, CEILING, HALF_EVEN, HALF_UP, HALF_DOWN);\n",
        "54": "  static final ImmutableList<Integer> EXPONENTS = ImmutableList.of(0, 1, 2, 3, 4, 7, 10, 15,\n",
        "55": "      20, 25, 40, 70);\n",
        "58": "  private static final Function<Integer, Long> TO_LONG = new Function<Integer, Long>() {\n",
        "59": "    @Override\n",
        "60": "    public Long apply(Integer n) {\n",
        "61": "      return Long.valueOf(n);\n",
        "62": "    }\n",
        "63": "  };\n",
        "74": "  private static final Function<Integer, Integer> NEGATE_INT = new Function<Integer, Integer>() {\n",
        "75": "    @Override\n",
        "76": "    public Integer apply(Integer x) {\n",
        "77": "      return -x;\n",
        "78": "    }\n",
        "79": "  };\n",
        "81": "  private static final Function<Long, Long> NEGATE_LONG = new Function<Long, Long>() {\n",
        "82": "    @Override\n",
        "83": "    public Long apply(Long x) {\n",
        "84": "      return -x;\n",
        "85": "    }\n",
        "86": "  };\n",
        "124": "    NEGATIVE_INTEGER_CANDIDATES = ImmutableList.copyOf(Iterables.concat(\n",
        "125": "        Iterables.transform(POSITIVE_INTEGER_CANDIDATES, NEGATE_INT),\n",
        "126": "        ImmutableList.of(Integer.MIN_VALUE)));\n",
        "127": "    NONZERO_INTEGER_CANDIDATES = ImmutableList.copyOf(\n",
        "128": "        Iterables.concat(POSITIVE_INTEGER_CANDIDATES, NEGATIVE_INTEGER_CANDIDATES));\n",
        "160": "        Iterables.concat(Iterables.transform(POSITIVE_LONG_CANDIDATES, NEGATE_LONG),\n",
        "186": "    for (int exponent : asList(64, 65, 71, 72, 73, 79, 80, 81, 255, 256, 257, 511, 512, 513,\n",
        "187": "        Double.MAX_EXPONENT - 1, Double.MAX_EXPONENT, Double.MAX_EXPONENT + 1)) {\n",
        "192": "                                                                  // down\n",
        "205": "  static final Iterable<Double> INFINITIES = Doubles.asList(\n",
        "206": "      Double.POSITIVE_INFINITY,\n",
        "207": "      Double.NEGATIVE_INFINITY);\n",
        "224": "        double d = \n",
        "225": "            Double.longBitsToDouble(Double.doubleToLongBits(Math.scalb(1.0, i)) + direction);\n",
        "232": "    for (double d : Doubles.asList(0, 1, 2, 7, 51, 102, Math.scalb(1.0, 53), Integer.MIN_VALUE,\n",
        "233": "        Integer.MAX_VALUE, Long.MIN_VALUE, Long.MAX_VALUE)) {\n",
        "257": "        Iterables.filter(FINITE_DOUBLE_CANDIDATES, new Predicate<Double>() {\n",
        "258": "          @Override\n",
        "259": "          public boolean apply(Double input) {\n",
        "260": "            return input.doubleValue() > 0.0;\n",
        "261": "          }\n",
        "262": "        });\n",
        "264": "    ALL_DOUBLE_CANDIDATES =\n",
        "265": "        Iterables.concat(DOUBLE_CANDIDATES_EXCEPT_NAN, asList(Double.NaN));\n"
    }
}