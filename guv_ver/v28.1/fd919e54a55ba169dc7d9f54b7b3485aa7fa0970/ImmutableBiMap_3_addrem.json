{
    "addition": {
        "43": "   * Returns a {@link Collector} that accumulates elements into an {@code ImmutableBiMap} whose keys\n",
        "44": "   * and values are the result of applying the provided mapping functions to the input elements.\n",
        "45": "   * Entries appear in the result {@code ImmutableBiMap} in encounter order.\n",
        "47": "   * <p>If the mapped keys or values contain duplicates (according to {@link Object#equals(Object)},\n",
        "48": "   * an {@code IllegalArgumentException} is thrown when the collection operation is performed. (This\n",
        "49": "   * differs from the {@code Collector} returned by {@link Collectors#toMap(Function, Function)},\n",
        "50": "   * which throws an {@code IllegalStateException}.)\n",
        "61": "  /** Returns the empty bimap. */\n",
        "68": "  /** Returns an immutable bimap containing a single entry. */\n",
        "115": "   * Returns a new builder. The generated builder is equivalent to the builder created by the {@link\n",
        "116": "   * Builder} constructor.\n",
        "141": "   * A builder for creating immutable bimap instances, especially {@code public static final} bimaps\n",
        "142": "   * (\"constant bimaps\"). Example:\n",
        "144": "   * <pre>{@code\n",
        "145": "   * static final ImmutableBiMap<String, Integer> WORD_TO_INT =\n",
        "146": "   *     new ImmutableBiMap.Builder<String, Integer>()\n",
        "147": "   *         .put(\"one\", 1)\n",
        "148": "   *         .put(\"two\", 2)\n",
        "149": "   *         .put(\"three\", 3)\n",
        "150": "   *         .build();\n",
        "151": "   * }</pre>\n",
        "153": "   * <p>For <i>small</i> immutable bimaps, the {@code ImmutableBiMap.of()} methods are even more\n",
        "154": "   * convenient.\n",
        "157": "   * they were inserted into the builder. For example, in the above example, {@code\n",
        "158": "   * WORD_TO_INT.entrySet()} is guaranteed to iterate over the entries in the order {@code \"one\"=1,\n",
        "159": "   * \"two\"=2, \"three\"=3}, and {@code keySet()} and {@code values()} respect the same order. If you\n",
        "160": "   * want a different order, consider using {@link #orderEntriesByValue(Comparator)}, which changes\n",
        "161": "   * this builder to sort entries by value.\n",
        "163": "   * <p>Builder instances can be reused - it is safe to call {@link #build} multiple times to build\n",
        "164": "   * multiple bimaps in series. Each bimap is a superset of the bimaps created before it.\n",
        "171": "     * Creates a new builder. The returned builder is equivalent to the builder generated by {@link\n",
        "172": "     * ImmutableBiMap#builder}.\n",
        "181": "     * Associates {@code key} with {@code value} in the built bimap. Duplicate keys or values are\n",
        "182": "     * not allowed, and will cause {@link #build} to fail.\n",
        "192": "     * Adds the given {@code entry} to the bimap. Duplicate keys or values are not allowed, and will\n",
        "193": "     * cause {@link #build} to fail.\n",
        "205": "     * Associates all of the given map's keys and values in the built bimap. Duplicate keys or\n",
        "206": "     * values are not allowed, and will cause {@link #build} to fail.\n",
        "218": "     * Adds all of the given entries to the built bimap. Duplicate keys or values are not allowed,\n",
        "219": "     * and will cause {@link #build} to fail.\n",
        "236": "     * <p>The sort order is stable, that is, if two entries have values that compare as equivalent,\n",
        "237": "     * the entry that was inserted first will be first in the built map's iteration order.\n",
        "258": "     * Returns a newly-created immutable bimap. The iteration order of the returned bimap is the\n",
        "259": "     * order in which entries were inserted into the builder, unless {@link #orderEntriesByValue}\n",
        "260": "     * was called, in which case entries are sorted by value.\n",
        "296": "   * Returns an immutable bimap containing the same entries as {@code map}. If {@code map} somehow\n",
        "297": "   * contains entries with duplicate keys (for example, if it is a {@code SortedMap} whose\n",
        "298": "   * comparator is not <i>consistent with equals</i>), the results of this method are undefined.\n",
        "300": "   * <p>The returned {@code BiMap} iterates over entries in the same order as the {@code entrySet}\n",
        "301": "   * of the original map.\n",
        "303": "   * <p>Despite the method name, this method attempts to avoid actually copying the data when it is\n",
        "304": "   * safe to do so. The exact circumstances under which a copy will or will not be performed are\n",
        "305": "   * undocumented and subject to change.\n",
        "325": "   * Returns an immutable bimap containing the given entries. The returned bimap iterates over\n",
        "328": "   * @throws IllegalArgumentException if two keys have the same value or two values have the same\n",
        "329": "   *     key\n",
        "358": "   * <p>The inverse of an {@code ImmutableBiMap} is another {@code ImmutableBiMap}.\n",
        "391": "   * Serialized type for all ImmutableBiMap instances. It captures the logical contents and they are\n",
        "392": "   * reconstructed using public factory methods. This ensures that the implementation types remain\n",
        "393": "   * as implementation details.\n",
        "395": "   * <p>Since the bimap is immutable, ImmutableBiMap doesn't require special logic for keeping the\n",
        "396": "   * bimap and its inverse in sync during serialization, the way AbstractBiMap does.\n"
    },
    "removed": {
        "43": "   * Returns a {@link Collector} that accumulates elements into an {@code ImmutableBiMap} whose\n",
        "44": "   * keys and values are the result of applying the provided mapping functions to the input\n",
        "45": "   * elements. Entries appear in the result {@code ImmutableBiMap} in encounter order.\n",
        "47": "   * <p>If the mapped keys or values contain duplicates\n",
        "48": "   * (according to {@link Object#equals(Object)}, an {@code IllegalArgumentException} is thrown\n",
        "49": "   * when the collection operation is performed. (This differs from the {@code Collector} returned\n",
        "50": "   * by {@link Collectors#toMap(Function, Function)}, which throws an\n",
        "51": "   * {@code IllegalStateException}.)\n",
        "62": "  /**\n",
        "63": "   * Returns the empty bimap.\n",
        "64": "   */\n",
        "71": "  /**\n",
        "72": "   * Returns an immutable bimap containing a single entry.\n",
        "73": "   */\n",
        "120": "   * Returns a new builder. The generated builder is equivalent to the builder\n",
        "121": "   * created by the {@link Builder} constructor.\n",
        "146": "   * A builder for creating immutable bimap instances, especially {@code public\n",
        "147": "   * static final} bimaps (\"constant bimaps\"). Example: <pre>   {@code\n",
        "149": "   *   static final ImmutableBiMap<String, Integer> WORD_TO_INT =\n",
        "150": "   *       new ImmutableBiMap.Builder<String, Integer>()\n",
        "151": "   *           .put(\"one\", 1)\n",
        "152": "   *           .put(\"two\", 2)\n",
        "153": "   *           .put(\"three\", 3)\n",
        "154": "   *           .build();}</pre>\n",
        "156": "   * <p>For <i>small</i> immutable bimaps, the {@code ImmutableBiMap.of()} methods\n",
        "157": "   * are even more convenient.\n",
        "160": "   * they were inserted into the builder.  For example, in the above example,\n",
        "161": "   * {@code WORD_TO_INT.entrySet()} is guaranteed to iterate over the entries in the order\n",
        "162": "   * {@code \"one\"=1, \"two\"=2, \"three\"=3}, and {@code keySet()} and {@code values()} respect the same\n",
        "163": "   * order. If you want a different order, consider using\n",
        "164": "   * {@link #orderEntriesByValue(Comparator)}, which changes this builder to sort\n",
        "165": "   * entries by value.\n",
        "167": "   * <p>Builder instances can be reused - it is safe to call {@link #build}\n",
        "168": "   * multiple times to build multiple bimaps in series. Each bimap is a superset\n",
        "169": "   * of the bimaps created before it.\n",
        "176": "     * Creates a new builder. The returned builder is equivalent to the builder\n",
        "177": "     * generated by {@link ImmutableBiMap#builder}.\n",
        "186": "     * Associates {@code key} with {@code value} in the built bimap. Duplicate\n",
        "187": "     * keys or values are not allowed, and will cause {@link #build} to fail.\n",
        "197": "     * Adds the given {@code entry} to the bimap.  Duplicate keys or values\n",
        "198": "     * are not allowed, and will cause {@link #build} to fail.\n",
        "210": "     * Associates all of the given map's keys and values in the built bimap.\n",
        "211": "     * Duplicate keys or values are not allowed, and will cause {@link #build}\n",
        "212": "     * to fail.\n",
        "224": "     * Adds all of the given entries to the built bimap.  Duplicate keys or\n",
        "225": "     * values are not allowed, and will cause {@link #build} to fail.\n",
        "242": "     * <p>The sort order is stable, that is, if two entries have values that compare\n",
        "243": "     * as equivalent, the entry that was inserted first will be first in the built map's\n",
        "244": "     * iteration order.\n",
        "265": "     * Returns a newly-created immutable bimap.  The iteration order of the returned bimap is\n",
        "266": "     * the order in which entries were inserted into the builder, unless\n",
        "267": "     * {@link #orderEntriesByValue} was called, in which case entries are sorted by value.\n",
        "303": "   * Returns an immutable bimap containing the same entries as {@code map}. If\n",
        "304": "   * {@code map} somehow contains entries with duplicate keys (for example, if\n",
        "305": "   * it is a {@code SortedMap} whose comparator is not <i>consistent with\n",
        "306": "   * equals</i>), the results of this method are undefined.\n",
        "308": "   * <p>The returned {@code BiMap} iterates over entries in the same order as the\n",
        "309": "   * {@code entrySet} of the original map.\n",
        "311": "   * <p>Despite the method name, this method attempts to avoid actually copying\n",
        "312": "   * the data when it is safe to do so. The exact circumstances under which a\n",
        "313": "   * copy will or will not be performed are undocumented and subject to change.\n",
        "333": "   * Returns an immutable bimap containing the given entries.  The returned bimap iterates over\n",
        "336": "   * @throws IllegalArgumentException if two keys have the same value or two\n",
        "337": "   *         values have the same key\n",
        "366": "   * <p>The inverse of an {@code ImmutableBiMap} is another\n",
        "367": "   * {@code ImmutableBiMap}.\n",
        "400": "   * Serialized type for all ImmutableBiMap instances. It captures the logical\n",
        "401": "   * contents and they are reconstructed using public factory methods. This\n",
        "402": "   * ensures that the implementation types remain as implementation details.\n",
        "404": "   * Since the bimap is immutable, ImmutableBiMap doesn't require special logic\n",
        "405": "   * for keeping the bimap and its inverse in sync during serialization, the way\n",
        "406": "   * AbstractBiMap does.\n"
    }
}