{
    "addition": {
        "72": "    this.cachingHashMap =\n",
        "73": "        new CapacityEnforcingLinkedHashMap<K, V>(\n",
        "74": "            builder.getInitialCapacity(),\n",
        "75": "            0.75f,\n",
        "76": "            (builder.maximumSize != UNSET_INT),\n",
        "77": "            builder.maximumSize,\n",
        "78": "            statsCounter,\n",
        "79": "            removalListener);\n",
        "295": "  private V getOrLoad(K key) throws ExecutionException {\n",
        "354": "    protected LocalManualCache(\n",
        "355": "        CacheBuilder<? super K, ? super V> builder, CacheLoader<? super K, V> loader) {\n",
        "416": "  public static class LocalLoadingCache<K, V> extends LocalManualCache<K, V>\n",
        "417": "      implements LoadingCache<K, V> {\n",
        "419": "    LocalLoadingCache(\n",
        "420": "        CacheBuilder<? super K, ? super V> builder, CacheLoader<? super K, V> loader) {\n",
        "461": "   * LinkedHashMap that enforces it's maximum size and logs events in a StatsCounter object and an\n",
        "462": "   * optional RemovalListener.\n",
        "490": "        removalListener.onRemoval(\n",
        "491": "            RemovalNotification.create(\n",
        "492": "                ignored.getKey(), ignored.getValue().getValue(), RemovalCause.SIZE));\n",
        "534": "   * Implementation for the EntryIterator, which is used to build Key and Value iterators.\n",
        "586": "  /** KeyIterator build on top of EntryIterator. */\n",
        "610": "  /** ValueIterator build on top of EntryIterator. */\n",
        "662": "   * Custom Entry class used by EntryIterator.next(), that relays setValue changes to the underlying\n",
        "663": "   * map.\n"
    },
    "removed": {
        "72": "    this.cachingHashMap = new CapacityEnforcingLinkedHashMap<K, V>(\n",
        "73": "        builder.getInitialCapacity(),\n",
        "74": "        0.75f,\n",
        "75": "        (builder.maximumSize != UNSET_INT),\n",
        "76": "        builder.maximumSize,\n",
        "77": "        statsCounter,\n",
        "78": "        removalListener);\n",
        "294": "  private V getOrLoad(K key) throws ExecutionException{\n",
        "353": "    protected LocalManualCache(CacheBuilder<? super K, ? super V> builder,\n",
        "354": "        CacheLoader<? super K, V> loader) {\n",
        "415": "  public static class LocalLoadingCache<K, V>\n",
        "416": "      extends LocalManualCache<K, V> implements LoadingCache<K, V> {\n",
        "418": "    LocalLoadingCache(CacheBuilder<? super K, ? super V> builder,\n",
        "419": "        CacheLoader<? super K, V> loader) {\n",
        "460": "   * LinkedHashMap that enforces it's maximum size and logs events in a StatsCounter object\n",
        "461": "   * and an optional RemovalListener.\n",
        "489": "        removalListener.onRemoval(RemovalNotification.create(\n",
        "490": "            ignored.getKey(),\n",
        "491": "            ignored.getValue().getValue(),\n",
        "492": "            RemovalCause.SIZE));\n",
        "534": "   * <p>Implementation for the EntryIterator, which is used to build Key and Value iterators.\n",
        "586": "  /**\n",
        "587": "   * KeyIterator build on top of EntryIterator.\n",
        "588": "   */\n",
        "612": "  /**\n",
        "613": "   * ValueIterator build on top of EntryIterator.\n",
        "614": "   */\n",
        "666": "   * Custom Entry class used by EntryIterator.next(), that relays setValue changes to the\n",
        "667": "   * underlying map.\n"
    }
}