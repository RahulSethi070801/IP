{
    "addition": {
        "53": " * NullPointerTester}, {@link EqualsTester} and {@link SerializableTester}. For example:\n",
        "54": " *\n",
        "55": " * <pre>\n",
        "60": " * factory method to construct instances can have their instance methods checked. For example:\n",
        "61": " *\n",
        "62": " * <pre>\n",
        "75": " *\n",
        "81": " * <p>For testing against the returned instances from a static factory class, such as\n",
        "82": " *\n",
        "83": " * <pre>\n",
        "93": " * <p>If not all classes on the classpath should be covered, {@link #ignoreClasses} can be used to\n",
        "94": " * exclude certain classes. As a special case, classes with an underscore in the name (like {@code\n",
        "95": " * AutoValue_Foo}) can be excluded using <code>ignoreClasses({@link #UNDERSCORE_IN_NAME})</code>.\n",
        "118": "  public static final Predicate<Class<?>> UNDERSCORE_IN_NAME =\n",
        "119": "      new Predicate<Class<?>>() {\n",
        "120": "        @Override\n",
        "121": "        public boolean apply(Class<?> c) {\n",
        "122": "          return c.getSimpleName().contains(\"_\");\n",
        "123": "        }\n",
        "124": "      };\n",
        "127": "  private static final ImmutableList<String> NULL_TEST_METHOD_NAMES =\n",
        "128": "      ImmutableList.of(\n",
        "129": "          \"testNulls\", \"testNull\",\n",
        "130": "          \"testNullPointers\", \"testNullPointer\",\n",
        "131": "          \"testNullPointerExceptions\", \"testNullPointerException\");\n",
        "134": "  private static final ImmutableList<String> SERIALIZABLE_TEST_METHOD_NAMES =\n",
        "135": "      ImmutableList.of(\n",
        "136": "          \"testSerializable\", \"testSerialization\",\n",
        "137": "          \"testEqualsAndSerializable\", \"testEqualsAndSerialization\");\n",
        "140": "  private static final ImmutableList<String> EQUALS_TEST_METHOD_NAMES =\n",
        "141": "      ImmutableList.of(\n",
        "142": "          \"testEquals\",\n",
        "143": "          \"testEqualsAndHashCode\",\n",
        "144": "          \"testEqualsAndSerializable\",\n",
        "145": "          \"testEqualsAndSerialization\",\n",
        "146": "          \"testEquality\");\n",
        "149": "      suffix(\"Test\").or(suffix(\"Tests\")).or(suffix(\"TestCase\")).or(suffix(\"TestSuite\"));\n",
        "154": "  private Predicate<Class<?>> classFilter =\n",
        "155": "      new Predicate<Class<?>>() {\n",
        "156": "        @Override\n",
        "157": "        public boolean apply(Class<?> cls) {\n",
        "158": "          return visibility.isVisible(cls.getModifiers());\n",
        "159": "        }\n",
        "160": "      };\n",
        "173": "   *\n",
        "175": "   *   <li>If {@code C} explicitly implements {@link Object#equals}, the deserialized instance will\n",
        "176": "   *       be checked to be equal to the instance before serialization.\n",
        "177": "   *   <li>If {@code C} doesn't explicitly implement {@code equals} but instead inherits it from a\n",
        "178": "   *       superclass, no equality check is done on the deserialized instance because it's not clear\n",
        "179": "   *       whether the author intended for the class to be a value type.\n",
        "180": "   *   <li>If a constructor or factory method takes a parameter whose type is interface, a dynamic\n",
        "181": "   *       proxy will be passed to the method. It's possible that the method body expects an\n",
        "182": "   *       instance method of the passed-in proxy to be of a certain value yet the proxy isn't aware\n",
        "183": "   *       of the assumption, in which case the equality check before and after serialization will\n",
        "184": "   *       fail.\n",
        "185": "   *   <li>If the constructor or factory method takes a parameter that {@link\n",
        "186": "   *       AbstractPackageSanityTests} doesn't know how to construct, the test will fail.\n",
        "187": "   *   <li>If there is no visible constructor or visible static factory method declared by {@code\n",
        "188": "   *       C}, {@code C} is skipped for serialization test, even if it implements {@link\n",
        "189": "   *       Serializable}.\n",
        "190": "   *   <li>Serialization test is not performed on method return values unless the method is a\n",
        "191": "   *       visible static factory method whose return type is {@code C} or {@code C}'s subtype.\n",
        "201": "    for (Class<?> classToTest :\n",
        "202": "        findClassesToTest(loadClassesInPackage(), SERIALIZABLE_TEST_METHOD_NAMES)) {\n",
        "223": "   *\n",
        "225": "   *   <li>All visible static methods are checked such that passing null for any parameter that's\n",
        "226": "   *       not annotated with {@link javax.annotation.Nullable} should throw {@link\n",
        "227": "   *       NullPointerException}.\n",
        "228": "   *   <li>If there is any visible constructor or visible static factory method declared by the\n",
        "229": "   *       class, all visible instance methods will be checked too using the instance created by\n",
        "230": "   *       invoking the constructor or static factory method.\n",
        "231": "   *   <li>If the constructor or factory method used to construct instance takes a parameter that\n",
        "232": "   *       {@link AbstractPackageSanityTests} doesn't know how to construct, the test will fail.\n",
        "233": "   *   <li>If there is no visible constructor or visible static factory method declared by {@code\n",
        "234": "   *       C}, instance methods are skipped for nulls test.\n",
        "235": "   *   <li>Nulls test is not performed on method return values unless the method is a visible static\n",
        "236": "   *       factory method whose return type is {@code C} or {@code C}'s subtype.\n",
        "245": "    for (Class<?> classToTest : findClassesToTest(loadClassesInPackage(), NULL_TEST_METHOD_NAMES)) {\n",
        "257": "   *\n",
        "259": "   *   <li>The visible constructor or visible static factory method with the most parameters is used\n",
        "260": "   *       to construct the sample instances. In case of tie, the candidate constructors or\n",
        "261": "   *       factories are tried one after another until one can be used to construct sample\n",
        "262": "   *       instances.\n",
        "263": "   *   <li>For the constructor or static factory method used to construct instances, it's checked\n",
        "264": "   *       that when equal parameters are passed, the result instance should also be equal; and vice\n",
        "265": "   *       versa.\n",
        "266": "   *   <li>Inequality check is not performed against state mutation methods such as {@link\n",
        "267": "   *       List#add}, or functional update methods such as {@link\n",
        "268": "   *       com.google.common.base.Joiner#skipNulls}.\n",
        "269": "   *   <li>If the constructor or factory method used to construct instance takes a parameter that\n",
        "270": "   *       {@link AbstractPackageSanityTests} doesn't know how to construct, the test will fail.\n",
        "271": "   *   <li>If there is no visible constructor or visible static factory method declared by {@code\n",
        "272": "   *       C}, {@code C} is skipped for equality test.\n",
        "273": "   *   <li>Equality test is not performed on method return values unless the method is a visible\n",
        "274": "   *       static factory method whose return type is {@code C} or {@code C}'s subtype.\n",
        "283": "    for (Class<?> classToTest :\n",
        "284": "        findClassesToTest(loadClassesInPackage(), EQUALS_TEST_METHOD_NAMES)) {\n",
        "322": "    String message =\n",
        "323": "        String.format(\n",
        "324": "            Locale.ROOT,\n",
        "325": "            \"Error in automated %s of %s\\n\"\n",
        "326": "                + \"If the class is better tested explicitly, you can add %s() to %sTest\",\n",
        "327": "            description,\n",
        "328": "            cls,\n",
        "329": "            explicitTestNames.get(0),\n",
        "330": "            cls.getName());\n",
        "337": "   * Finds the classes not ending with a test suffix and not covered by an explicit test whose name\n",
        "338": "   * is {@code explicitTestName}.\n",
        "340": "  @VisibleForTesting\n",
        "341": "  List<Class<?>> findClassesToTest(\n",
        "363": "    NEXT_CANDIDATE:\n",
        "364": "    for (Class<?> candidate : Iterables.filter(candidateClasses, classFilter)) {\n",
        "379": "    for (ClassPath.ClassInfo classInfo :\n",
        "380": "        ClassPath.from(getClass().getClassLoader()).getTopLevelClasses(packageName)) {\n",
        "421": "        @Override\n",
        "422": "        Optional<String> chop(String str) {\n",
        "432": "        @Override\n",
        "433": "        Optional<String> chop(String str) {\n"
    },
    "removed": {
        "53": " * NullPointerTester}, {@link EqualsTester} and {@link SerializableTester}. For example: <pre>\n",
        "58": " * factory method to construct instances can have their instance methods checked. For example: <pre>\n",
        "76": " * <p>For testing against the returned instances from a static factory class, such as <pre>\n",
        "86": " * <p>If not all classes on the classpath should be covered, {@link\n",
        "87": " * #ignoreClasses} can be used to exclude certain classes. As a special case, classes with an\n",
        "88": " * underscore in the name (like {@code AutoValue_Foo}) can be excluded using\n",
        "89": " * <code>ignoreClasses({@link #UNDERSCORE_IN_NAME})</code>.\n",
        "112": "  public static final Predicate<Class<?>> UNDERSCORE_IN_NAME = new Predicate<Class<?>>() {\n",
        "113": "    @Override public boolean apply(Class<?> c) {\n",
        "114": "      return c.getSimpleName().contains(\"_\");\n",
        "115": "    }\n",
        "116": "  };\n",
        "119": "  private static final ImmutableList<String> NULL_TEST_METHOD_NAMES = ImmutableList.of(\n",
        "120": "      \"testNulls\", \"testNull\",\n",
        "121": "      \"testNullPointers\", \"testNullPointer\",\n",
        "122": "      \"testNullPointerExceptions\", \"testNullPointerException\");\n",
        "125": "  private static final ImmutableList<String> SERIALIZABLE_TEST_METHOD_NAMES = ImmutableList.of(\n",
        "126": "      \"testSerializable\", \"testSerialization\",\n",
        "127": "      \"testEqualsAndSerializable\", \"testEqualsAndSerialization\");\n",
        "130": "  private static final ImmutableList<String> EQUALS_TEST_METHOD_NAMES = ImmutableList.of(\n",
        "131": "      \"testEquals\", \"testEqualsAndHashCode\",\n",
        "132": "      \"testEqualsAndSerializable\", \"testEqualsAndSerialization\",\n",
        "133": "      \"testEquality\");\n",
        "136": "      suffix(\"Test\")\n",
        "137": "          .or(suffix(\"Tests\"))\n",
        "138": "          .or(suffix(\"TestCase\"))\n",
        "139": "          .or(suffix(\"TestSuite\"));\n",
        "144": "  private Predicate<Class<?>> classFilter = new Predicate<Class<?>>() {\n",
        "145": "    @Override public boolean apply(Class<?> cls) {\n",
        "146": "      return visibility.isVisible(cls.getModifiers());\n",
        "147": "    }\n",
        "148": "  };\n",
        "162": "   * <li>If {@code C} explicitly implements {@link Object#equals}, the deserialized instance will be\n",
        "163": "   *     checked to be equal to the instance before serialization.\n",
        "164": "   * <li>If {@code C} doesn't explicitly implement {@code equals} but instead inherits it from a\n",
        "165": "   *     superclass, no equality check is done on the deserialized instance because it's not clear\n",
        "166": "   *     whether the author intended for the class to be a value type.\n",
        "167": "   * <li>If a constructor or factory method takes a parameter whose type is interface, a dynamic\n",
        "168": "   *     proxy will be passed to the method. It's possible that the method body expects an instance\n",
        "169": "   *     method of the passed-in proxy to be of a certain value yet the proxy isn't aware of the\n",
        "170": "   *     assumption, in which case the equality check before and after serialization will fail.\n",
        "171": "   * <li>If the constructor or factory method takes a parameter that {@link\n",
        "172": "   *     AbstractPackageSanityTests} doesn't know how to construct, the test will fail.\n",
        "173": "   * <li>If there is no visible constructor or visible static factory method declared by {@code C},\n",
        "174": "   *     {@code C} is skipped for serialization test, even if it implements {@link Serializable}.\n",
        "175": "   * <li>Serialization test is not performed on method return values unless the method is a visible\n",
        "176": "   *     static factory method whose return type is {@code C} or {@code C}'s subtype.\n",
        "186": "    for (Class<?> classToTest\n",
        "187": "        : findClassesToTest(loadClassesInPackage(), SERIALIZABLE_TEST_METHOD_NAMES)) {\n",
        "209": "   * <li>All visible static methods are checked such that passing null for any parameter that's not\n",
        "210": "   *     annotated with {@link javax.annotation.Nullable} should throw {@link NullPointerException}.\n",
        "211": "   * <li>If there is any visible constructor or visible static factory method declared by the class,\n",
        "212": "   *     all visible instance methods will be checked too using the instance created by invoking the\n",
        "213": "   *     constructor or static factory method.\n",
        "214": "   * <li>If the constructor or factory method used to construct instance takes a parameter that\n",
        "215": "   *     {@link AbstractPackageSanityTests} doesn't know how to construct, the test will fail.\n",
        "216": "   * <li>If there is no visible constructor or visible static factory method declared by {@code C},\n",
        "217": "   *     instance methods are skipped for nulls test.\n",
        "218": "   * <li>Nulls test is not performed on method return values unless the method is a visible static\n",
        "219": "   *     factory method whose return type is {@code C} or {@code C}'s subtype.\n",
        "228": "    for (Class<?> classToTest\n",
        "229": "        : findClassesToTest(loadClassesInPackage(), NULL_TEST_METHOD_NAMES)) {\n",
        "242": "   * <li>The visible constructor or visible static factory method with the most parameters is used\n",
        "243": "   *     to construct the sample instances. In case of tie, the candidate constructors or factories\n",
        "244": "   *     are tried one after another until one can be used to construct sample instances.\n",
        "245": "   * <li>For the constructor or static factory method used to construct instances, it's checked that\n",
        "246": "   *     when equal parameters are passed, the result instance should also be equal; and vice versa.\n",
        "247": "   * <li>Inequality check is not performed against state mutation methods such as {@link List#add},\n",
        "248": "   *     or functional update methods such as {@link com.google.common.base.Joiner#skipNulls}.\n",
        "249": "   * <li>If the constructor or factory method used to construct instance takes a parameter that\n",
        "250": "   *     {@link AbstractPackageSanityTests} doesn't know how to construct, the test will fail.\n",
        "251": "   * <li>If there is no visible constructor or visible static factory method declared by {@code C},\n",
        "252": "   *     {@code C} is skipped for equality test.\n",
        "253": "   * <li>Equality test is not performed on method return values unless the method is a visible\n",
        "254": "   *     static factory method whose return type is {@code C} or {@code C}'s subtype.\n",
        "263": "    for (Class<?> classToTest\n",
        "264": "        : findClassesToTest(loadClassesInPackage(), EQUALS_TEST_METHOD_NAMES)) {\n",
        "302": "    String message = String.format(Locale.ROOT,\n",
        "303": "        \"Error in automated %s of %s\\n\"\n",
        "304": "            + \"If the class is better tested explicitly, you can add %s() to %sTest\",\n",
        "305": "        description, cls, explicitTestNames.get(0), cls.getName());\n",
        "312": "   * Finds the classes not ending with a test suffix and not covered by an explicit test\n",
        "313": "   * whose name is {@code explicitTestName}.\n",
        "315": "  @VisibleForTesting List<Class<?>> findClassesToTest(\n",
        "337": "    NEXT_CANDIDATE: for (Class<?> candidate : Iterables.filter(candidateClasses, classFilter)) {\n",
        "352": "    for (ClassPath.ClassInfo classInfo\n",
        "353": "        : ClassPath.from(getClass().getClassLoader()).getTopLevelClasses(packageName)) {\n",
        "394": "        @Override Optional<String> chop(String str) {\n",
        "404": "        @Override Optional<String> chop(String str) {\n"
    }
}