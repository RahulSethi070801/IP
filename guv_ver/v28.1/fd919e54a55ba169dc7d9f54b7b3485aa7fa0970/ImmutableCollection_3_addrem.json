{
    "addition": {
        "56": " *   <li><b>Shallow immutability.</b> Elements can never be added, removed or replaced in this\n",
        "57": " *       collection. This is a stronger guarantee than that of {@link\n",
        "58": " *       Collections#unmodifiableCollection}, whose contents change whenever the wrapped collection\n",
        "59": " *       is modified.\n",
        "60": " *   <li><b>Null-hostility.</b> This collection will never contain a null element.\n",
        "61": " *   <li><b>Deterministic iteration.</b> The iteration order is always well-defined, depending on\n",
        "62": " *       how the collection was created. Typically this is insertion order unless an explicit\n",
        "63": " *       ordering is otherwise specified (e.g. {@link ImmutableSortedSet#naturalOrder}). See the\n",
        "64": " *       appropriate factory method for details. View collections such as {@link\n",
        "65": " *       ImmutableMultiset#elementSet} iterate in the same order as the parent, except as noted.\n",
        "66": " *   <li><b>Thread safety.</b> It is safe to access this collection concurrently from multiple\n",
        "67": " *       threads.\n",
        "68": " *   <li><b>Integrity.</b> This type cannot be subclassed outside this package (which would allow\n",
        "69": " *       these guarantees to be violated).\n",
        "90": " * powerful advantage. Although Java 9 offers certain immutable collection factory methods, like <a\n",
        "91": " * href=\"https://docs.oracle.com/javase/9/docs/api/java/util/Set.html#immutable\">{@code Set.of}</a>,\n",
        "101": " *   <li>Static methods named {@code of}, accepting an explicit list of elements or entries.\n",
        "102": " *   <li>Static methods named {@code copyOf} (or {@code copyOfSorted}), accepting an existing\n",
        "103": " *       collection whose contents should be copied.\n",
        "104": " *   <li>A static nested {@code Builder} class which can be used to populate a new immutable\n",
        "105": " *       instance.\n",
        "111": " *   <li><b>Warning:</b> as with any collection, it is almost always a bad idea to modify an element\n",
        "112": " *       (in a way that affects its {@link Object#equals} behavior) while it is contained in a\n",
        "113": " *       collection. Undefined behavior and bugs will result. It's generally best to avoid using\n",
        "114": " *       mutable objects as elements at all, as many users may expect your \"immutable\" object to be\n",
        "115": " *       <i>deeply</i> immutable.\n",
        "121": " *   <li>Implementations can be generally assumed to prioritize memory efficiency, then speed of\n",
        "122": " *       access, and lastly speed of creation.\n",
        "123": " *   <li>The {@code copyOf} methods will sometimes recognize that the actual copy operation is\n",
        "124": " *       unnecessary; for example, {@code copyOf(copyOf(anArrayList))} should copy the data only\n",
        "125": " *       once. This reduces the expense of habitually making defensive copies at API boundaries.\n",
        "126": " *       However, the precise conditions for skipping the copy operation are undefined.\n",
        "127": " *   <li><b>Warning:</b> a view collection such as {@link ImmutableMap#keySet} or {@link\n",
        "128": " *       ImmutableList#subList} may retain a reference to the entire data set, preventing it from\n",
        "129": " *       being garbage collected. If some of the data is no longer reachable through other means,\n",
        "130": " *       this constitutes a memory leak. Pass the view collection to the appropriate {@code copyOf}\n",
        "131": " *       method to obtain a correctly-sized copy.\n",
        "132": " *   <li>The performance of using the associated {@code Builder} class can be assumed to be no\n",
        "133": " *       worse, and possibly better, than creating a mutable collection and copying it.\n",
        "134": " *   <li>Implementations generally do not cache hash codes. If your element or key type has a slow\n",
        "135": " *       {@code hashCode} implementation, it should cache it itself.\n",
        "140": " * <pre>{@code\n",
        "141": " * class Foo {\n",
        "142": " *   private static final ImmutableSet<String> RESERVED_CODES =\n",
        "143": " *       ImmutableSet.of(\"AZ\", \"CQ\", \"ZX\");\n",
        "145": " *   private final ImmutableSet<String> codes;\n",
        "147": " *   public Foo(Iterable<String> codes) {\n",
        "148": " *     this.codes = ImmutableSet.copyOf(codes);\n",
        "149": " *     checkArgument(Collections.disjoint(this.codes, RESERVED_CODES));\n",
        "150": " *   }\n",
        "151": " * }\n",
        "152": " * }</pre>\n",
        "157": " * \"https://github.com/google/guava/wiki/ImmutableCollectionsExplained\"> immutable collections</a>.\n",
        "176": "  /** Returns an unmodifiable iterator across the elements in this collection. */\n",
        "335": "   * offset. Returns {@code offset + size()}.\n",
        "379": "     * <p>Note that each builder class covariantly returns its own type from this method.\n",
        "389": "     * Adds each element of {@code elements} to the {@code ImmutableCollection} being built.\n",
        "391": "     * <p>Note that each builder class overrides this method in order to covariantly return its own\n",
        "392": "     * type.\n",
        "396": "     * @throws NullPointerException if {@code elements} is null or contains a null element\n",
        "407": "     * Adds each element of {@code elements} to the {@code ImmutableCollection} being built.\n",
        "409": "     * <p>Note that each builder class overrides this method in order to covariantly return its own\n",
        "410": "     * type.\n",
        "414": "     * @throws NullPointerException if {@code elements} is null or contains a null element\n",
        "425": "     * Adds each element of {@code elements} to the {@code ImmutableCollection} being built.\n",
        "427": "     * <p>Note that each builder class overrides this method in order to covariantly return its own\n",
        "428": "     * type.\n",
        "432": "     * @throws NullPointerException if {@code elements} is null or contains a null element\n",
        "443": "     * Returns a newly-created {@code ImmutableCollection} of the appropriate type, containing the\n",
        "444": "     * elements provided to this builder.\n",
        "446": "     * <p>Note that each builder class covariantly returns the appropriate type of {@code\n",
        "447": "     * ImmutableCollection} from this method.\n",
        "471": "            Arrays.copyOf(this.contents, expandedCapacity(contents.length, minCapacity));\n"
    },
    "removed": {
        "27": "import java.util.ArrayList;\n",
        "57": " * <li><b>Shallow immutability.</b> Elements can never be added, removed or replaced in this\n",
        "58": " *     collection. This is a stronger guarantee than that of\n",
        "59": " *     {@link Collections#unmodifiableCollection}, whose contents change whenever the wrapped\n",
        "60": " *     collection is modified.\n",
        "61": " * <li><b>Null-hostility.</b> This collection will never contain a null element.\n",
        "62": " * <li><b>Deterministic iteration.</b> The iteration order is always well-defined, depending on how\n",
        "63": " *     the collection was created. Typically this is insertion order unless an explicit ordering is\n",
        "64": " *     otherwise specified (e.g. {@link ImmutableSortedSet#naturalOrder}).  See the appropriate\n",
        "65": " *     factory method for details. View collections such as {@link ImmutableMultiset#elementSet}\n",
        "66": " *     iterate in the same order as the parent, except as noted.\n",
        "67": " * <li><b>Thread safety.</b> It is safe to access this collection concurrently from multiple\n",
        "68": " *     threads.\n",
        "69": " * <li><b>Integrity.</b> This type cannot be subclassed outside this package (which would allow\n",
        "70": " *     these guarantees to be violated).\n",
        "91": " * powerful advantage. Although Java 9 offers certain immutable collection factory methods, like\n",
        "92": " * <a href=\"https://docs.oracle.com/javase/9/docs/api/java/util/Set.html#immutable\">{@code Set.of}</a>,\n",
        "102": " * <li>Static methods named {@code of}, accepting an explicit list of elements or entries.\n",
        "103": " * <li>Static methods named {@code copyOf} (or {@code copyOfSorted}), accepting an existing\n",
        "104": " *     collection whose contents should be copied.\n",
        "105": " * <li>A static nested {@code Builder} class which can be used to populate a new immutable instance.\n",
        "111": " * <li><b>Warning:</b> as with any collection, it is almost always a bad idea to modify an element\n",
        "112": " *     (in a way that affects its {@link Object#equals} behavior) while it is contained in a\n",
        "113": " *     collection. Undefined behavior and bugs will result. It's generally best to avoid using\n",
        "114": " *     mutable objects as elements at all, as many users may expect your \"immutable\" object to be\n",
        "115": " *     <i>deeply</i> immutable.\n",
        "121": " * <li>Implementations can be generally assumed to prioritize memory efficiency, then speed of\n",
        "122": " *     access, and lastly speed of creation.\n",
        "123": " * <li>The {@code copyOf} methods will sometimes recognize that the actual copy operation is\n",
        "124": " *     unnecessary; for example, {@code copyOf(copyOf(anArrayList))} should copy the data only once.\n",
        "125": " *     This reduces the expense of habitually making defensive copies at API boundaries. However,\n",
        "126": " *     the precise conditions for skipping the copy operation are undefined.\n",
        "127": " * <li><b>Warning:</b> a view collection such as {@link ImmutableMap#keySet} or {@link\n",
        "128": " *     ImmutableList#subList} may retain a reference to the entire data set, preventing it from\n",
        "129": " *     being garbage collected. If some of the data is no longer reachable through other means, this\n",
        "130": " *     constitutes a memory leak. Pass the view collection to the appropriate {@code copyOf} method\n",
        "131": " *     to obtain a correctly-sized copy.\n",
        "132": " * <li>The performance of using the associated {@code Builder} class can be assumed to be\n",
        "133": " *     no worse, and possibly better, than creating a mutable collection and copying it.\n",
        "134": " * <li>Implementations generally do not cache hash codes. If your element or key type has a slow\n",
        "135": " *     {@code hashCode} implementation, it should cache it itself.\n",
        "140": " * <pre>   {@code\n",
        "142": " *   class Foo {\n",
        "143": " *     private static final ImmutableSet<String> RESERVED_CODES =\n",
        "144": " *         ImmutableSet.of(\"AZ\", \"CQ\", \"ZX\");\n",
        "146": " *     private final ImmutableSet<String> codes;\n",
        "147": " *\n",
        "148": " *     public Foo(Iterable<String> codes) {\n",
        "149": " *       this.codes = ImmutableSet.copyOf(codes);\n",
        "150": " *       checkArgument(Collections.disjoint(this.codes, RESERVED_CODES));\n",
        "151": " *     }\n",
        "152": " *   }}</pre>\n",
        "157": " * \"https://github.com/google/guava/wiki/ImmutableCollectionsExplained\">\n",
        "158": " * immutable collections</a>.\n",
        "177": "  /**\n",
        "178": "   * Returns an unmodifiable iterator across the elements in this collection.\n",
        "179": "   */\n",
        "338": "   * offset.  Returns {@code offset + size()}.\n",
        "382": "     * <p>Note that each builder class covariantly returns its own type from\n",
        "383": "     * this method.\n",
        "393": "     * Adds each element of {@code elements} to the {@code ImmutableCollection}\n",
        "394": "     * being built.\n",
        "396": "     * <p>Note that each builder class overrides this method in order to\n",
        "397": "     * covariantly return its own type.\n",
        "401": "     * @throws NullPointerException if {@code elements} is null or contains a\n",
        "402": "     *     null element\n",
        "413": "     * Adds each element of {@code elements} to the {@code ImmutableCollection}\n",
        "414": "     * being built.\n",
        "416": "     * <p>Note that each builder class overrides this method in order to\n",
        "417": "     * covariantly return its own type.\n",
        "421": "     * @throws NullPointerException if {@code elements} is null or contains a\n",
        "422": "     *     null element\n",
        "433": "     * Adds each element of {@code elements} to the {@code ImmutableCollection}\n",
        "434": "     * being built.\n",
        "436": "     * <p>Note that each builder class overrides this method in order to\n",
        "437": "     * covariantly return its own type.\n",
        "441": "     * @throws NullPointerException if {@code elements} is null or contains a\n",
        "442": "     *     null element\n",
        "453": "     * Returns a newly-created {@code ImmutableCollection} of the appropriate\n",
        "454": "     * type, containing the elements provided to this builder.\n",
        "456": "     * <p>Note that each builder class covariantly returns the appropriate type\n",
        "457": "     * of {@code ImmutableCollection} from this method.\n",
        "481": "            Arrays.copyOf(\n",
        "482": "                this.contents, expandedCapacity(contents.length, minCapacity));\n"
    }
}