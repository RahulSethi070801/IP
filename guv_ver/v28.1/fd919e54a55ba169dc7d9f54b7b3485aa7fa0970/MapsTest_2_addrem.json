{
    "addition": {
        "76": "  private static final Comparator<Integer> SOME_COMPARATOR = Collections.reverseOrder();\n",
        "111": "   * Tests that nHMWES makes hash maps large enough that adding the expected number of elements\n",
        "112": "   * won't cause a rehash.\n",
        "114": "   * <p>As of jdk7u40, HashMap has an empty-map optimization. The argument to new HashMap(int) is\n",
        "115": "   * noted, but the initial table is a zero-length array.\n",
        "117": "   * <p>This test may fail miserably on non-OpenJDK environments...\n",
        "127": "      assertWontGrow(\n",
        "128": "          size, Maps.newHashMapWithExpectedSize(size), Maps.newHashMapWithExpectedSize(size));\n",
        "132": "  /** Same test as above but for newLinkedHashMapWithExpectedSize */\n",
        "139": "      assertWontGrow(\n",
        "140": "          size,\n",
        "182": "    int[] largeExpectedSizes =\n",
        "183": "        new int[] {\n",
        "184": "          Integer.MAX_VALUE / 2 - 1,\n",
        "185": "          Integer.MAX_VALUE / 2,\n",
        "186": "          Integer.MAX_VALUE / 2 + 1,\n",
        "187": "          Integer.MAX_VALUE - 1,\n",
        "188": "          Integer.MAX_VALUE\n",
        "189": "        };\n",
        "205": "    Map<String, String> map =\n",
        "206": "        new LinkedHashMap<String, String>() {\n",
        "207": "          {\n",
        "208": "            put(\"Hello\", \"World\");\n",
        "209": "            put(\"first\", \"second\");\n",
        "210": "            put(\"polygene\", \"lubricants\");\n",
        "211": "            put(\"alpha\", \"betical\");\n",
        "212": "          }\n",
        "213": "        };\n",
        "245": "    HashMap<Object, Object> map = Maps.<Object, Object>newLinkedHashMap(original);\n",
        "270": "    assertThat(map.keySet()).containsExactly(new Derived(\"bar\"), new Derived(\"foo\")).inOrder();\n",
        "280": "    assertThat(map.keySet())\n",
        "281": "        .containsExactly(new LegacyComparable(\"bar\"), new LegacyComparable(\"foo\"))\n",
        "282": "        .inOrder();\n",
        "303": "  public enum SomeEnum {\n",
        "304": "    SOME_INSTANCE\n",
        "305": "  }\n",
        "348": "    } catch (IllegalArgumentException expected) {\n",
        "349": "    }\n",
        "373": "  private static final Map<Integer, Integer> EMPTY = Collections.emptyMap();\n",
        "374": "  private static final Map<Integer, Integer> SINGLETON = Collections.singletonMap(1, 2);\n",
        "407": "    Map<Integer, String> left = ImmutableMap.of(1, \"a\", 2, \"b\", 3, \"c\", 4, \"d\", 5, \"e\");\n",
        "408": "    Map<Integer, String> right = ImmutableMap.of(1, \"a\", 3, \"f\", 5, \"g\", 6, \"z\");\n",
        "415": "    assertEquals(\n",
        "416": "        ImmutableMap.of(\n",
        "417": "            3, ValueDifferenceImpl.create(\"c\", \"f\"), 5, ValueDifferenceImpl.create(\"e\", \"g\")),\n",
        "419": "    assertEquals(\n",
        "420": "        \"not equal: only on left={2=b, 4=d}: only on right={6=z}: \"\n",
        "421": "            + \"value differences={3=(c, f), 5=(e, g)}\",\n",
        "422": "        diff1.toString());\n",
        "429": "    assertEquals(\n",
        "430": "        ImmutableMap.of(\n",
        "431": "            3, ValueDifferenceImpl.create(\"f\", \"c\"), 5, ValueDifferenceImpl.create(\"g\", \"e\")),\n",
        "433": "    assertEquals(\n",
        "434": "        \"not equal: only on left={6=z}: only on right={2=b, 4=d}: \"\n",
        "435": "            + \"value differences={3=(f, c), 5=(g, e)}\",\n",
        "436": "        diff2.toString());\n",
        "440": "    Map<Integer, String> left = ImmutableMap.of(1, \"a\", 2, \"b\", 3, \"c\", 4, \"d\", 5, \"e\");\n",
        "441": "    Map<Integer, String> right = ImmutableMap.of(1, \"a\", 3, \"f\", 5, \"g\", 6, \"z\");\n",
        "442": "    Map<Integer, String> right2 = ImmutableMap.of(1, \"a\", 3, \"h\", 5, \"g\", 6, \"z\");\n",
        "456": "    Map<Integer, String> left = ImmutableMap.of(1, \"a\", 2, \"b\", 3, \"c\", 4, \"d\", 5, \"e\");\n",
        "457": "    Map<Integer, String> right = ImmutableMap.of(1, \"A\", 3, \"F\", 5, \"G\", 6, \"Z\");\n",
        "461": "    Equivalence<String> caseInsensitiveEquivalence =\n",
        "462": "        Equivalence.equals()\n",
        "463": "            .onResultOf(\n",
        "464": "                new Function<String, String>() {\n",
        "465": "                  @Override\n",
        "466": "                  public String apply(String input) {\n",
        "467": "                    return input.toLowerCase();\n",
        "468": "                  }\n",
        "469": "                });\n",
        "470": "\n",
        "471": "    MapDifference<Integer, String> diff1 = Maps.difference(left, right, caseInsensitiveEquivalence);\n",
        "476": "    assertEquals(\n",
        "477": "        ImmutableMap.of(\n",
        "478": "            3, ValueDifferenceImpl.create(\"c\", \"F\"), 5, ValueDifferenceImpl.create(\"e\", \"G\")),\n",
        "480": "    assertEquals(\n",
        "481": "        \"not equal: only on left={2=b, 4=d}: only on right={6=Z}: \"\n",
        "482": "            + \"value differences={3=(c, F), 5=(e, G)}\",\n",
        "483": "        diff1.toString());\n",
        "485": "    MapDifference<Integer, String> diff2 = Maps.difference(right, left, caseInsensitiveEquivalence);\n",
        "490": "    assertEquals(\n",
        "491": "        ImmutableMap.of(\n",
        "492": "            3, ValueDifferenceImpl.create(\"F\", \"c\"), 5, ValueDifferenceImpl.create(\"G\", \"e\")),\n",
        "494": "    assertEquals(\n",
        "495": "        \"not equal: only on left={6=Z}: only on right={2=b, 4=d}: \"\n",
        "496": "            + \"value differences={3=(F, c), 5=(G, e)}\",\n",
        "497": "        diff2.toString());\n",
        "511": "    SortedMapDifference<Integer, Integer> diff = Maps.difference(SORTED_EMPTY, SORTED_EMPTY);\n",
        "521": "    SortedMapDifference<Integer, Integer> diff = Maps.difference(SORTED_EMPTY, SORTED_SINGLETON);\n",
        "531": "    SortedMapDifference<Integer, Integer> diff = Maps.difference(SORTED_SINGLETON, SORTED_EMPTY);\n",
        "543": "            .put(1, \"a\")\n",
        "544": "            .put(2, \"b\")\n",
        "545": "            .put(3, \"c\")\n",
        "546": "            .put(4, \"d\")\n",
        "547": "            .put(5, \"e\")\n",
        "548": "            .build();\n",
        "550": "    SortedMap<Integer, String> right = ImmutableSortedMap.of(1, \"a\", 3, \"f\", 5, \"g\", 6, \"z\");\n",
        "552": "    SortedMapDifference<Integer, String> diff1 = Maps.difference(left, right);\n",
        "554": "    assertThat(diff1.entriesOnlyOnLeft().entrySet())\n",
        "555": "        .containsExactly(Maps.immutableEntry(4, \"d\"), Maps.immutableEntry(2, \"b\"))\n",
        "556": "        .inOrder();\n",
        "557": "    assertThat(diff1.entriesOnlyOnRight().entrySet()).contains(Maps.immutableEntry(6, \"z\"));\n",
        "558": "    assertThat(diff1.entriesInCommon().entrySet()).contains(Maps.immutableEntry(1, \"a\"));\n",
        "559": "    assertThat(diff1.entriesDiffering().entrySet())\n",
        "560": "        .containsExactly(\n",
        "561": "            Maps.immutableEntry(5, ValueDifferenceImpl.create(\"e\", \"g\")),\n",
        "562": "            Maps.immutableEntry(3, ValueDifferenceImpl.create(\"c\", \"f\")))\n",
        "563": "        .inOrder();\n",
        "564": "    assertEquals(\n",
        "565": "        \"not equal: only on left={4=d, 2=b}: only on right={6=z}: \"\n",
        "566": "            + \"value differences={5=(e, g), 3=(c, f)}\",\n",
        "567": "        diff1.toString());\n",
        "568": "\n",
        "569": "    SortedMapDifference<Integer, String> diff2 = Maps.difference(right, left);\n",
        "571": "    assertThat(diff2.entriesOnlyOnLeft().entrySet()).contains(Maps.immutableEntry(6, \"z\"));\n",
        "572": "    assertThat(diff2.entriesOnlyOnRight().entrySet())\n",
        "573": "        .containsExactly(Maps.immutableEntry(2, \"b\"), Maps.immutableEntry(4, \"d\"))\n",
        "574": "        .inOrder();\n",
        "575": "    assertThat(diff1.entriesInCommon().entrySet()).contains(Maps.immutableEntry(1, \"a\"));\n",
        "576": "    assertEquals(\n",
        "577": "        ImmutableMap.of(\n",
        "581": "    assertEquals(\n",
        "582": "        \"not equal: only on left={6=z}: only on right={2=b, 4=d}: \"\n",
        "583": "            + \"value differences={3=(f, c), 5=(g, e)}\",\n",
        "584": "        diff2.toString());\n",
        "588": "    SortedMap<Integer, String> left =\n",
        "589": "        Maps.newTreeMap(ImmutableSortedMap.of(1, \"a\", 2, \"b\", 3, \"c\", 4, \"d\", 5, \"e\"));\n",
        "593": "    SortedMapDifference<Integer, String> diff1 = Maps.difference(left, right);\n",
        "596": "    assertThat(diff1.entriesOnlyOnLeft().entrySet())\n",
        "597": "        .containsExactly(Maps.immutableEntry(2, \"b\"), Maps.immutableEntry(4, \"d\"))\n",
        "598": "        .inOrder();\n",
        "599": "    assertThat(diff1.entriesOnlyOnRight().entrySet()).contains(Maps.immutableEntry(6, \"z\"));\n",
        "600": "    assertThat(diff1.entriesInCommon().entrySet()).contains(Maps.immutableEntry(1, \"a\"));\n",
        "601": "    assertThat(diff1.entriesDiffering().entrySet())\n",
        "602": "        .containsExactly(\n",
        "603": "            Maps.immutableEntry(3, ValueDifferenceImpl.create(\"c\", \"f\")),\n",
        "604": "            Maps.immutableEntry(5, ValueDifferenceImpl.create(\"e\", \"g\")))\n",
        "605": "        .inOrder();\n",
        "624": "    SortedMap<Integer, String> left = ImmutableSortedMap.of(1, \"a\", 2, \"b\", 3, \"c\", 4, \"d\", 5, \"e\");\n",
        "625": "    SortedMap<Integer, String> right = ImmutableSortedMap.of(1, \"a\", 3, \"f\", 5, \"g\", 6, \"z\");\n",
        "626": "    SortedMap<Integer, String> right2 = ImmutableSortedMap.of(1, \"a\", 3, \"h\", 5, \"g\", 6, \"z\");\n",
        "627": "    SortedMapDifference<Integer, String> original = Maps.difference(left, right);\n",
        "628": "    SortedMapDifference<Integer, String> same = Maps.difference(left, right);\n",
        "629": "    SortedMapDifference<Integer, String> reverse = Maps.difference(right, left);\n",
        "630": "    SortedMapDifference<Integer, String> diff2 = Maps.difference(left, right2);\n",
        "653": "    assertThat(map.entrySet())\n",
        "654": "        .containsExactly(mapEntry(\"one\", 3), mapEntry(\"two\", 3), mapEntry(\"three\", 5))\n",
        "655": "        .inOrder();\n",
        "686": "  private static class NonNavigableSortedSet extends ForwardingSortedSet<String> {\n",
        "702": "    assertThat(map.entrySet())\n",
        "703": "        .containsExactly(mapEntry(\"one\", 3), mapEntry(\"three\", 5), mapEntry(\"two\", 3))\n",
        "704": "        .inOrder();\n",
        "705": "    assertThat(map.tailMap(\"onea\").entrySet())\n",
        "706": "        .containsExactly(mapEntry(\"three\", 5), mapEntry(\"two\", 3))\n",
        "707": "        .inOrder();\n",
        "708": "    assertThat(map.subMap(\"one\", \"two\").entrySet())\n",
        "709": "        .containsExactly(mapEntry(\"one\", 3), mapEntry(\"three\", 5))\n",
        "710": "        .inOrder();\n",
        "721": "    assertEquals(ImmutableSortedMap.of(\"one\", 3, \"two\", 3, \"three\", 5, \"four\", 4), map);\n",
        "724": "    assertEquals(ImmutableSortedMap.of(\"four\", 4, \"one\", 3, \"three\", 5), headMap);\n",
        "727": "    assertEquals(ImmutableSortedMap.of(\"five\", 4, \"four\", 4, \"three\", 5), headMap);\n",
        "728": "    assertThat(map.entrySet())\n",
        "729": "        .containsExactly(\n",
        "730": "            mapEntry(\"five\", 4), mapEntry(\"four\", 4), mapEntry(\"three\", 5), mapEntry(\"two\", 3))\n",
        "731": "        .inOrder();\n",
        "744": "    SortedMap<String, Integer> map = Maps.asMap(new NonNavigableSortedSet(), LENGTH_FUNCTION);\n",
        "777": "    NavigableSet<String> strings = Sets.newTreeSet(asList(\"one\", \"two\", \"three\"));\n",
        "782": "    assertThat(map.entrySet())\n",
        "783": "        .containsExactly(mapEntry(\"one\", 3), mapEntry(\"three\", 5), mapEntry(\"two\", 3))\n",
        "784": "        .inOrder();\n",
        "785": "    assertThat(map.tailMap(\"onea\").entrySet())\n",
        "786": "        .containsExactly(mapEntry(\"three\", 5), mapEntry(\"two\", 3))\n",
        "787": "        .inOrder();\n",
        "788": "    assertThat(map.subMap(\"one\", \"two\").entrySet())\n",
        "789": "        .containsExactly(mapEntry(\"one\", 3), mapEntry(\"three\", 5))\n",
        "790": "        .inOrder();\n",
        "791": "\n",
        "792": "    assertEquals(ImmutableSortedMap.of(\"two\", 3, \"three\", 5), map.tailMap(\"three\", true));\n",
        "793": "    assertEquals(ImmutableSortedMap.of(\"one\", 3, \"three\", 5), map.headMap(\"two\", false));\n",
        "794": "    assertEquals(ImmutableSortedMap.of(\"three\", 5), map.subMap(\"one\", false, \"tr\", true));\n",
        "807": "    assertThat(map.descendingMap().entrySet())\n",
        "808": "        .containsExactly(mapEntry(\"two\", 3), mapEntry(\"three\", 5), mapEntry(\"one\", 3))\n",
        "809": "        .inOrder();\n",
        "810": "    assertEquals(map.headMap(\"three\", true), map.descendingMap().tailMap(\"three\", true));\n",
        "811": "    assertThat(map.tailMap(\"three\", false).entrySet()).contains(mapEntry(\"two\", 3));\n",
        "814": "    assertThat(map.headMap(\"two\", false).descendingMap().values()).containsExactly(5, 3).inOrder();\n",
        "815": "    assertThat(map.descendingKeySet()).containsExactly(\"two\", \"three\", \"one\").inOrder();\n",
        "831": "    assertEquals(ImmutableSortedMap.of(\"one\", 3, \"two\", 3, \"three\", 5, \"four\", 4), map);\n",
        "834": "    assertEquals(ImmutableSortedMap.of(\"four\", 4, \"one\", 3, \"three\", 5), headMap);\n",
        "837": "    assertEquals(ImmutableSortedMap.of(\"five\", 4, \"four\", 4, \"three\", 5), headMap);\n",
        "838": "    assertThat(map.entrySet())\n",
        "839": "        .containsExactly(\n",
        "840": "            mapEntry(\"five\", 4), mapEntry(\"four\", 4), mapEntry(\"three\", 5), mapEntry(\"two\", 3))\n",
        "841": "        .inOrder();\n",
        "848": "    assertThat(tailMap.entrySet())\n",
        "849": "        .containsExactly(mapEntry(\"six\", 3), mapEntry(\"three\", 5))\n",
        "850": "        .inOrder();\n",
        "851": "    assertThat(subMap.entrySet())\n",
        "852": "        .containsExactly(mapEntry(\"five\", 4), mapEntry(\"four\", 4), mapEntry(\"six\", 3))\n",
        "853": "        .inOrder();\n",
        "864": "    assertEquals(mapEntry(\"three\", 5), map.subMap(\"one\", false, \"zzz\", true).pollLastEntry());\n",
        "870": "    NavigableMap<String, Integer> map = Maps.asMap(Sets.<String>newTreeSet(), LENGTH_FUNCTION);\n",
        "911": "    assertThat(map.entrySet())\n",
        "912": "        .containsExactly(mapEntry(\"one\", 3), mapEntry(\"two\", 3), mapEntry(\"three\", 5))\n",
        "913": "        .inOrder();\n",
        "920": "    assertThat(map.entrySet())\n",
        "921": "        .containsExactly(mapEntry(\"one\", 3), mapEntry(\"two\", 3), mapEntry(\"three\", 5))\n",
        "922": "        .inOrder();\n",
        "929": "    assertThat(map.entrySet())\n",
        "930": "        .containsExactly(mapEntry(\"one\", 3), mapEntry(\"two\", 3), mapEntry(\"three\", 5))\n",
        "931": "        .inOrder();\n",
        "961": "        Maps.uniqueIndex(INT_TO_STRING_MAP.values(), Functions.forMap(INT_TO_STRING_MAP.inverse()));\n",
        "967": "        Maps.uniqueIndex(\n",
        "968": "            new Iterable<String>() {\n",
        "969": "              @Override\n",
        "970": "              public Iterator<String> iterator() {\n",
        "971": "                return INT_TO_STRING_MAP.values().iterator();\n",
        "972": "              }\n",
        "973": "            },\n",
        "974": "            Functions.forMap(INT_TO_STRING_MAP.inverse()));\n",
        "980": "        Maps.uniqueIndex(\n",
        "981": "            INT_TO_STRING_MAP.values().iterator(), Functions.forMap(INT_TO_STRING_MAP.inverse()));\n",
        "1062": "    assertNotSame(System.getProperty(\"java.version\"), result.get(\"java.version\"));\n",
        "1068": "    Properties properties =\n",
        "1069": "        new Properties() {\n",
        "1070": "          @Override\n",
        "1071": "          public Enumeration<?> propertyNames() {\n",
        "1072": "            return Iterators.asEnumeration(Arrays.asList(null, \"first\", \"second\").iterator());\n",
        "1073": "          }\n",
        "1074": "        };\n",
        "1081": "    } catch (NullPointerException expected) {\n",
        "1082": "    }\n",
        "1088": "    Properties properties =\n",
        "1089": "        new Properties() {\n",
        "1090": "          @Override\n",
        "1091": "          public Enumeration<?> propertyNames() {\n",
        "1092": "            return Iterators.asEnumeration(\n",
        "1093": "                Arrays.<Object>asList(Integer.valueOf(123), \"first\").iterator());\n",
        "1094": "          }\n",
        "1095": "        };\n",
        "1100": "    } catch (ClassCastException expected) {\n",
        "1101": "    }\n",
        "1105": "    ImmutableBiMap<String, Integer> biMap =\n",
        "1106": "        ImmutableBiMap.of(\n",
        "1107": "            \"one\", 1,\n",
        "1108": "            \"two\", 2);\n",
        "1116": "    ImmutableBiMap<String, Integer> biMap =\n",
        "1117": "        ImmutableBiMap.of(\n",
        "1118": "            \"one\", 1,\n",
        "1119": "            \"two\", 2);\n",
        "1127": "    ImmutableBiMap<String, Integer> biMap =\n",
        "1128": "        ImmutableBiMap.of(\n",
        "1129": "            \"one\", 1,\n",
        "1130": "            \"two\", 2);\n",
        "1140": "    ImmutableBiMap<String, Integer> biMap =\n",
        "1141": "        ImmutableBiMap.of(\n",
        "1142": "            \"one\", 1,\n",
        "1143": "            \"two\", 2);\n",
        "1183": "    ImmutableBiMap<String, Integer> biMap =\n",
        "1184": "        ImmutableBiMap.of(\n",
        "1185": "            \"one\", 1,\n",
        "1186": "            \"two\", 2);\n",
        "1192": "    ImmutableBiMap<String, Integer> biMap =\n",
        "1193": "        ImmutableBiMap.of(\n",
        "1194": "            \"one\", 1,\n",
        "1195": "            \"two\", 2);\n",
        "1221": "    } catch (UnsupportedOperationException expected) {\n",
        "1222": "    }\n",
        "1226": "    } catch (UnsupportedOperationException expected) {\n",
        "1227": "    }\n",
        "1231": "    } catch (UnsupportedOperationException expected) {\n",
        "1232": "    }\n",
        "1239": "    } catch (UnsupportedOperationException expected) {\n",
        "1240": "    }\n",
        "1244": "    } catch (UnsupportedOperationException expected) {\n",
        "1245": "    }\n",
        "1249": "    } catch (UnsupportedOperationException expected) {\n",
        "1250": "    }\n",
        "1255": "    } catch (UnsupportedOperationException expected) {\n",
        "1256": "    }\n",
        "1262": "    } catch (UnsupportedOperationException expected) {\n",
        "1263": "    }\n",
        "1265": "    Entry<Integer, String> entry2 = (Entry<Integer, String>) entries.toArray()[0];\n",
        "1269": "    } catch (UnsupportedOperationException expected) {\n",
        "1270": "    }\n",
        "1280": "    } catch (UnsupportedOperationException expected) {\n",
        "1281": "    }\n",
        "1287": "    Entry<String, Integer> e = Maps.immutableEntry((String) null, (Integer) null);\n",
        "1293": "    } catch (UnsupportedOperationException expected) {\n",
        "1294": "    }\n",
        "1310": "  private static final Predicate<String> NOT_LENGTH_3 =\n",
        "1311": "      new Predicate<String>() {\n",
        "1318": "  private static final Predicate<Integer> EVEN =\n",
        "1319": "      new Predicate<Integer>() {\n",
        "1326": "  private static final Predicate<Entry<String, Integer>> CORRECT_LENGTH =\n",
        "1327": "      new Predicate<Entry<String, Integer>>() {\n",
        "1334": "  private static final Function<Integer, Double> SQRT_FUNCTION =\n",
        "1335": "      new Function<Integer, Double>() {\n",
        "1336": "        @Override\n",
        "1337": "        public Double apply(Integer in) {\n",
        "1338": "          return Math.sqrt(in);\n",
        "1339": "        }\n",
        "1340": "      };\n",
        "1357": "      } catch (IllegalArgumentException expected) {\n",
        "1358": "      }\n",
        "1371": "      } catch (IllegalArgumentException expected) {\n",
        "1372": "      }\n",
        "1406": "      } catch (IllegalArgumentException expected) {\n",
        "1407": "      }\n",
        "1422": "      } catch (IllegalArgumentException expected) {\n",
        "1423": "      }\n",
        "1438": "      } catch (IllegalArgumentException expected) {\n",
        "1439": "      }\n",
        "1451": "      assertEquals(ImmutableMap.of(\"one\", 1, \"two\", 2, \"three\", 3, \"four\", 4), unfiltered);\n",
        "1464": "      Map<String, Integer> filtered = Maps.filterEntries(unfiltered, CORRECT_LENGTH);\n",
        "1473": "      } catch (IllegalArgumentException expected) {\n",
        "1474": "      }\n",
        "1483": "      Map<String, Integer> filtered = Maps.filterEntries(unfiltered, CORRECT_LENGTH);\n",
        "1492": "      } catch (IllegalArgumentException expected) {\n",
        "1493": "      }\n",
        "1503": "      Map<String, Integer> filtered = Maps.filterEntries(unfiltered, predicate);\n",
        "1512": "      Predicate<Entry<?, ?>> predicate =\n",
        "1513": "          new Predicate<Entry<?, ?>>() {\n",
        "1514": "            @Override\n",
        "1515": "            public boolean apply(Entry<?, ?> input) {\n",
        "1516": "              return \"cat\".equals(input.getKey()) || Integer.valueOf(2) == input.getValue();\n",
        "1517": "            }\n",
        "1518": "          };\n",
        "1519": "      Map<String, Integer> filtered = Maps.filterEntries(unfiltered, predicate);\n",
        "1648": "    Map<String, Boolean> options = ImmutableMap.of(\"verbose\", true, \"sort\", false);\n",
        "1661": "  private static <K, V> SortedMap<K, V> sortedNotNavigable(final SortedMap<K, V> map) {\n",
        "1663": "      @Override\n",
        "1664": "      protected SortedMap<K, V> delegate() {\n",
        "1671": "    SortedMap<String, Integer> map = sortedNotNavigable(ImmutableSortedMap.of(\"a\", 4, \"b\", 9));\n",
        "1672": "    SortedMap<String, Double> transformed = transformValues(map, SQRT_FUNCTION);\n",
        "1684": "    NavigableMap<String, Double> transformed = transformValues(map, SQRT_FUNCTION);\n",
        "1690": "    SortedMap<String, String> map = sortedNotNavigable(ImmutableSortedMap.of(\"a\", \"4\", \"b\", \"9\"));\n",
        "1709": "    NavigableMap<String, String> map = ImmutableSortedMap.of(\"a\", \"4\", \"b\", \"9\");\n",
        "1823": "    @SuppressWarnings(\"unchecked\")\n",
        "1824": "    Entry<Integer, String> entry2 = (Entry<Integer, String>) entries.toArray()[0];\n",
        "1897": "    assertEquals(\n",
        "1898": "        ImmutableSortedMap.of(4, 0, 6, 0, 8, 0, 10, 0), Maps.subMap(map, Range.atLeast(4)));\n",
        "1929": "            .put(2, 0)\n",
        "1930": "            .put(4, 0)\n",
        "1931": "            .put(6, 0)\n",
        "1932": "            .put(8, 0)\n",
        "1933": "            .put(10, 0)\n",
        "1934": "            .build();\n",
        "1946": "    assertEquals(\n",
        "1947": "        ImmutableSortedMap.of(2, 0, 4, 0, 6, 0, 8, 0, 10, 0),\n"
    },
    "removed": {
        "76": "  private static final Comparator<Integer> SOME_COMPARATOR =\n",
        "77": "      Collections.reverseOrder();\n",
        "112": "   * Tests that nHMWES makes hash maps large enough that adding the expected\n",
        "113": "   * number of elements won't cause a rehash.\n",
        "115": "   * As of jdk7u40, HashMap has an empty-map optimization.  The argument to\n",
        "116": "   * new HashMap(int) is noted, but the initial table is a zero-length array.\n",
        "118": "   * This test may fail miserably on non-OpenJDK environments...\n",
        "128": "      assertWontGrow(size,\n",
        "129": "          Maps.newHashMapWithExpectedSize(size),\n",
        "130": "          Maps.newHashMapWithExpectedSize(size));\n",
        "134": "  /**\n",
        "135": "   * Same test as above but for newLinkedHashMapWithExpectedSize\n",
        "136": "   */\n",
        "143": "      assertWontGrow(size,\n",
        "185": "    int[] largeExpectedSizes = new int[] {\n",
        "186": "      Integer.MAX_VALUE / 2 - 1,\n",
        "187": "      Integer.MAX_VALUE / 2,\n",
        "188": "      Integer.MAX_VALUE / 2 + 1,\n",
        "189": "      Integer.MAX_VALUE - 1,\n",
        "190": "      Integer.MAX_VALUE};\n",
        "206": "    Map<String, String> map = new LinkedHashMap<String, String>() {{\n",
        "207": "      put(\"Hello\", \"World\");\n",
        "208": "      put(\"first\", \"second\");\n",
        "209": "      put(\"polygene\", \"lubricants\");\n",
        "210": "      put(\"alpha\", \"betical\");\n",
        "211": "    }};\n",
        "243": "    HashMap<Object, Object> map\n",
        "244": "        = Maps.<Object, Object>newLinkedHashMap(original);\n",
        "269": "    assertThat(map.keySet()).containsExactly(\n",
        "270": "        new Derived(\"bar\"), new Derived(\"foo\")).inOrder();\n",
        "280": "    assertThat(map.keySet()).containsExactly(\n",
        "281": "        new LegacyComparable(\"bar\"), new LegacyComparable(\"foo\")).inOrder();\n",
        "302": "  public enum SomeEnum { SOME_INSTANCE }\n",
        "345": "    } catch (IllegalArgumentException expected) {}\n",
        "369": "  private static final Map<Integer, Integer> EMPTY\n",
        "370": "      = Collections.emptyMap();\n",
        "371": "  private static final Map<Integer, Integer> SINGLETON\n",
        "372": "      = Collections.singletonMap(1, 2);\n",
        "405": "    Map<Integer, String> left = ImmutableMap.of(\n",
        "406": "        1, \"a\", 2, \"b\", 3, \"c\", 4, \"d\", 5, \"e\");\n",
        "407": "    Map<Integer, String> right = ImmutableMap.of(\n",
        "408": "        1, \"a\", 3, \"f\", 5, \"g\", 6, \"z\");\n",
        "415": "    assertEquals(ImmutableMap.of(3,\n",
        "416": "        ValueDifferenceImpl.create(\"c\", \"f\"), 5,\n",
        "417": "        ValueDifferenceImpl.create(\"e\", \"g\")),\n",
        "419": "    assertEquals(\"not equal: only on left={2=b, 4=d}: only on right={6=z}: \"\n",
        "420": "        + \"value differences={3=(c, f), 5=(e, g)}\", diff1.toString());\n",
        "427": "    assertEquals(ImmutableMap.of(3,\n",
        "428": "        ValueDifferenceImpl.create(\"f\", \"c\"), 5,\n",
        "429": "        ValueDifferenceImpl.create(\"g\", \"e\")),\n",
        "431": "    assertEquals(\"not equal: only on left={6=z}: only on right={2=b, 4=d}: \"\n",
        "432": "        + \"value differences={3=(f, c), 5=(g, e)}\", diff2.toString());\n",
        "436": "    Map<Integer, String> left = ImmutableMap.of(\n",
        "437": "        1, \"a\", 2, \"b\", 3, \"c\", 4, \"d\", 5, \"e\");\n",
        "438": "    Map<Integer, String> right = ImmutableMap.of(\n",
        "439": "        1, \"a\", 3, \"f\", 5, \"g\", 6, \"z\");\n",
        "440": "    Map<Integer, String> right2 = ImmutableMap.of(\n",
        "441": "        1, \"a\", 3, \"h\", 5, \"g\", 6, \"z\");\n",
        "455": "    Map<Integer, String> left = ImmutableMap.of(\n",
        "456": "        1, \"a\", 2, \"b\", 3, \"c\", 4, \"d\", 5, \"e\");\n",
        "457": "    Map<Integer, String> right = ImmutableMap.of(\n",
        "458": "        1, \"A\", 3, \"F\", 5, \"G\", 6, \"Z\");\n",
        "462": "    Equivalence<String> caseInsensitiveEquivalence = Equivalence.equals().onResultOf(\n",
        "463": "        new Function<String, String>() {\n",
        "464": "          @Override public String apply(String input) {\n",
        "465": "            return input.toLowerCase();\n",
        "466": "          }\n",
        "467": "        });\n",
        "468": "\n",
        "469": "    MapDifference<Integer, String> diff1 = Maps.difference(left, right,\n",
        "470": "        caseInsensitiveEquivalence);\n",
        "475": "    assertEquals(ImmutableMap.of(3,\n",
        "476": "        ValueDifferenceImpl.create(\"c\", \"F\"), 5,\n",
        "477": "        ValueDifferenceImpl.create(\"e\", \"G\")),\n",
        "479": "    assertEquals(\"not equal: only on left={2=b, 4=d}: only on right={6=Z}: \"\n",
        "480": "        + \"value differences={3=(c, F), 5=(e, G)}\", diff1.toString());\n",
        "482": "    MapDifference<Integer, String> diff2 = Maps.difference(right, left,\n",
        "483": "        caseInsensitiveEquivalence);\n",
        "488": "    assertEquals(ImmutableMap.of(3,\n",
        "489": "        ValueDifferenceImpl.create(\"F\", \"c\"), 5,\n",
        "490": "        ValueDifferenceImpl.create(\"G\", \"e\")),\n",
        "492": "    assertEquals(\"not equal: only on left={6=Z}: only on right={2=b, 4=d}: \"\n",
        "493": "        + \"value differences={3=(F, c), 5=(G, e)}\", diff2.toString());\n",
        "507": "    SortedMapDifference<Integer, Integer> diff =\n",
        "508": "        Maps.difference(SORTED_EMPTY, SORTED_EMPTY);\n",
        "518": "    SortedMapDifference<Integer, Integer> diff =\n",
        "519": "        Maps.difference(SORTED_EMPTY, SORTED_SINGLETON);\n",
        "529": "    SortedMapDifference<Integer, Integer> diff =\n",
        "530": "        Maps.difference(SORTED_SINGLETON, SORTED_EMPTY);\n",
        "542": "        .put(1, \"a\").put(2, \"b\").put(3, \"c\").put(4, \"d\").put(5, \"e\")\n",
        "543": "        .build();\n",
        "545": "    SortedMap<Integer, String> right =\n",
        "546": "        ImmutableSortedMap.of(1, \"a\", 3, \"f\", 5, \"g\", 6, \"z\");\n",
        "548": "    SortedMapDifference<Integer, String> diff1 =\n",
        "549": "        Maps.difference(left, right);\n",
        "551": "    assertThat(diff1.entriesOnlyOnLeft().entrySet()).containsExactly(\n",
        "552": "        Maps.immutableEntry(4, \"d\"), Maps.immutableEntry(2, \"b\")).inOrder();\n",
        "553": "    assertThat(diff1.entriesOnlyOnRight().entrySet()).contains(\n",
        "554": "        Maps.immutableEntry(6, \"z\"));\n",
        "555": "    assertThat(diff1.entriesInCommon().entrySet()).contains(\n",
        "556": "        Maps.immutableEntry(1, \"a\"));\n",
        "557": "    assertThat(diff1.entriesDiffering().entrySet()).containsExactly(\n",
        "558": "        Maps.immutableEntry(5, ValueDifferenceImpl.create(\"e\", \"g\")),\n",
        "559": "        Maps.immutableEntry(3, ValueDifferenceImpl.create(\"c\", \"f\"))).inOrder();\n",
        "560": "    assertEquals(\"not equal: only on left={4=d, 2=b}: only on right={6=z}: \"\n",
        "561": "        + \"value differences={5=(e, g), 3=(c, f)}\", diff1.toString());\n",
        "562": "\n",
        "563": "    SortedMapDifference<Integer, String> diff2 =\n",
        "564": "        Maps.difference(right, left);\n",
        "566": "    assertThat(diff2.entriesOnlyOnLeft().entrySet()).contains(\n",
        "567": "        Maps.immutableEntry(6, \"z\"));\n",
        "568": "    assertThat(diff2.entriesOnlyOnRight().entrySet()).containsExactly(\n",
        "569": "        Maps.immutableEntry(2, \"b\"), Maps.immutableEntry(4, \"d\")).inOrder();\n",
        "570": "    assertThat(diff1.entriesInCommon().entrySet()).contains(\n",
        "571": "        Maps.immutableEntry(1, \"a\"));\n",
        "572": "    assertEquals(ImmutableMap.of(\n",
        "576": "    assertEquals(\"not equal: only on left={6=z}: only on right={2=b, 4=d}: \"\n",
        "577": "        + \"value differences={3=(f, c), 5=(g, e)}\", diff2.toString());\n",
        "581": "    SortedMap<Integer, String> left = Maps.newTreeMap(\n",
        "582": "        ImmutableSortedMap.of(1, \"a\", 2, \"b\", 3, \"c\", 4, \"d\", 5, \"e\"));\n",
        "586": "    SortedMapDifference<Integer, String> diff1 =\n",
        "587": "        Maps.difference(left, right);\n",
        "590": "    assertThat(diff1.entriesOnlyOnLeft().entrySet()).containsExactly(\n",
        "591": "        Maps.immutableEntry(2, \"b\"), Maps.immutableEntry(4, \"d\")).inOrder();\n",
        "592": "    assertThat(diff1.entriesOnlyOnRight().entrySet()).contains(\n",
        "593": "        Maps.immutableEntry(6, \"z\"));\n",
        "594": "    assertThat(diff1.entriesInCommon().entrySet()).contains(\n",
        "595": "        Maps.immutableEntry(1, \"a\"));\n",
        "596": "    assertThat(diff1.entriesDiffering().entrySet()).containsExactly(\n",
        "597": "        Maps.immutableEntry(3, ValueDifferenceImpl.create(\"c\", \"f\")),\n",
        "598": "        Maps.immutableEntry(5, ValueDifferenceImpl.create(\"e\", \"g\"))).inOrder();\n",
        "617": "    SortedMap<Integer, String> left =\n",
        "618": "        ImmutableSortedMap.of(1, \"a\", 2, \"b\", 3, \"c\", 4, \"d\", 5, \"e\");\n",
        "619": "    SortedMap<Integer, String> right =\n",
        "620": "        ImmutableSortedMap.of(1, \"a\", 3, \"f\", 5, \"g\", 6, \"z\");\n",
        "621": "    SortedMap<Integer, String> right2 =\n",
        "622": "        ImmutableSortedMap.of(1, \"a\", 3, \"h\", 5, \"g\", 6, \"z\");\n",
        "623": "    SortedMapDifference<Integer, String> original =\n",
        "624": "        Maps.difference(left, right);\n",
        "625": "    SortedMapDifference<Integer, String> same =\n",
        "626": "        Maps.difference(left, right);\n",
        "627": "    SortedMapDifference<Integer, String> reverse =\n",
        "628": "        Maps.difference(right, left);\n",
        "629": "    SortedMapDifference<Integer, String> diff2 =\n",
        "630": "        Maps.difference(left, right2);\n",
        "653": "    assertThat(map.entrySet()).containsExactly(\n",
        "654": "        mapEntry(\"one\", 3),\n",
        "655": "        mapEntry(\"two\", 3),\n",
        "656": "        mapEntry(\"three\", 5)).inOrder();\n",
        "687": "  private static class NonNavigableSortedSet\n",
        "688": "      extends ForwardingSortedSet<String> {\n",
        "704": "    assertThat(map.entrySet()).containsExactly(\n",
        "705": "        mapEntry(\"one\", 3),\n",
        "706": "        mapEntry(\"three\", 5),\n",
        "707": "        mapEntry(\"two\", 3)).inOrder();\n",
        "708": "    assertThat(map.tailMap(\"onea\").entrySet()).containsExactly(\n",
        "709": "        mapEntry(\"three\", 5),\n",
        "710": "        mapEntry(\"two\", 3)).inOrder();\n",
        "711": "    assertThat(map.subMap(\"one\", \"two\").entrySet()).containsExactly(\n",
        "712": "        mapEntry(\"one\", 3),\n",
        "713": "        mapEntry(\"three\", 5)).inOrder();\n",
        "724": "    assertEquals(\n",
        "725": "        ImmutableSortedMap.of(\"one\", 3, \"two\", 3, \"three\", 5, \"four\", 4),\n",
        "726": "        map);\n",
        "729": "    assertEquals(\n",
        "730": "        ImmutableSortedMap.of(\"four\", 4, \"one\", 3, \"three\", 5),\n",
        "731": "        headMap);\n",
        "734": "    assertEquals(\n",
        "735": "        ImmutableSortedMap.of(\"five\", 4, \"four\", 4, \"three\", 5),\n",
        "736": "        headMap);\n",
        "737": "    assertThat(map.entrySet()).containsExactly(\n",
        "738": "        mapEntry(\"five\", 4),\n",
        "739": "        mapEntry(\"four\", 4),\n",
        "740": "        mapEntry(\"three\", 5),\n",
        "741": "        mapEntry(\"two\", 3)).inOrder();\n",
        "754": "    SortedMap<String, Integer> map = Maps.asMap(\n",
        "755": "        new NonNavigableSortedSet(), LENGTH_FUNCTION);\n",
        "788": "    NavigableSet<String> strings =\n",
        "789": "        Sets.newTreeSet(asList(\"one\", \"two\", \"three\"));\n",
        "794": "    assertThat(map.entrySet()).containsExactly(\n",
        "795": "        mapEntry(\"one\", 3),\n",
        "796": "        mapEntry(\"three\", 5),\n",
        "797": "        mapEntry(\"two\", 3)).inOrder();\n",
        "798": "    assertThat(map.tailMap(\"onea\").entrySet()).containsExactly(\n",
        "799": "        mapEntry(\"three\", 5),\n",
        "800": "        mapEntry(\"two\", 3)).inOrder();\n",
        "801": "    assertThat(map.subMap(\"one\", \"two\").entrySet()).containsExactly(\n",
        "802": "        mapEntry(\"one\", 3),\n",
        "803": "        mapEntry(\"three\", 5)).inOrder();\n",
        "804": "\n",
        "805": "    assertEquals(ImmutableSortedMap.of(\"two\", 3, \"three\", 5),\n",
        "806": "        map.tailMap(\"three\", true));\n",
        "807": "    assertEquals(ImmutableSortedMap.of(\"one\", 3, \"three\", 5),\n",
        "808": "        map.headMap(\"two\", false));\n",
        "809": "    assertEquals(ImmutableSortedMap.of(\"three\", 5),\n",
        "810": "        map.subMap(\"one\", false, \"tr\", true));\n",
        "823": "    assertThat(map.descendingMap().entrySet()).containsExactly(\n",
        "824": "        mapEntry(\"two\", 3),\n",
        "825": "        mapEntry(\"three\", 5),\n",
        "826": "        mapEntry(\"one\", 3)).inOrder();\n",
        "827": "    assertEquals(map.headMap(\"three\", true),\n",
        "828": "        map.descendingMap().tailMap(\"three\", true));\n",
        "829": "    assertThat(map.tailMap(\"three\", false).entrySet()).contains(\n",
        "830": "        mapEntry(\"two\", 3));\n",
        "833": "    assertThat(map.headMap(\"two\", false).descendingMap().values())\n",
        "834": "        .containsExactly(5, 3).inOrder();\n",
        "835": "    assertThat(map.descendingKeySet()).containsExactly(\n",
        "836": "        \"two\", \"three\", \"one\").inOrder();\n",
        "852": "    assertEquals(\n",
        "853": "        ImmutableSortedMap.of(\"one\", 3, \"two\", 3, \"three\", 5, \"four\", 4),\n",
        "854": "        map);\n",
        "857": "    assertEquals(\n",
        "858": "        ImmutableSortedMap.of(\"four\", 4, \"one\", 3, \"three\", 5),\n",
        "859": "        headMap);\n",
        "862": "    assertEquals(\n",
        "863": "        ImmutableSortedMap.of(\"five\", 4, \"four\", 4, \"three\", 5),\n",
        "864": "        headMap);\n",
        "865": "    assertThat(map.entrySet()).containsExactly(\n",
        "866": "        mapEntry(\"five\", 4),\n",
        "867": "        mapEntry(\"four\", 4),\n",
        "868": "        mapEntry(\"three\", 5),\n",
        "869": "        mapEntry(\"two\", 3)).inOrder();\n",
        "876": "    assertThat(tailMap.entrySet()).containsExactly(\n",
        "877": "        mapEntry(\"six\", 3),\n",
        "878": "        mapEntry(\"three\", 5)).inOrder();\n",
        "879": "    assertThat(subMap.entrySet()).containsExactly(\n",
        "880": "        mapEntry(\"five\", 4),\n",
        "881": "        mapEntry(\"four\", 4),\n",
        "882": "        mapEntry(\"six\", 3)).inOrder();\n",
        "893": "    assertEquals(mapEntry(\"three\", 5),\n",
        "894": "        map.subMap(\"one\", false, \"zzz\", true).pollLastEntry());\n",
        "900": "    NavigableMap<String, Integer> map = Maps.asMap(\n",
        "901": "        Sets.<String>newTreeSet(), LENGTH_FUNCTION);\n",
        "942": "    assertThat(map.entrySet()).containsExactly(\n",
        "943": "        mapEntry(\"one\", 3),\n",
        "944": "        mapEntry(\"two\", 3),\n",
        "945": "        mapEntry(\"three\", 5)).inOrder();\n",
        "952": "    assertThat(map.entrySet()).containsExactly(\n",
        "953": "        mapEntry(\"one\", 3),\n",
        "954": "        mapEntry(\"two\", 3),\n",
        "955": "        mapEntry(\"three\", 5)).inOrder();\n",
        "962": "    assertThat(map.entrySet()).containsExactly(\n",
        "963": "        mapEntry(\"one\", 3),\n",
        "964": "        mapEntry(\"two\", 3),\n",
        "965": "        mapEntry(\"three\", 5)).inOrder();\n",
        "995": "        Maps.uniqueIndex(INT_TO_STRING_MAP.values(),\n",
        "996": "            Functions.forMap(INT_TO_STRING_MAP.inverse()));\n",
        "1002": "        Maps.uniqueIndex(new Iterable<String>() {\n",
        "1003": "          @Override\n",
        "1004": "          public Iterator<String> iterator() {\n",
        "1005": "            return INT_TO_STRING_MAP.values().iterator();\n",
        "1006": "          }\n",
        "1007": "        },\n",
        "1008": "        Functions.forMap(INT_TO_STRING_MAP.inverse()));\n",
        "1014": "        Maps.uniqueIndex(INT_TO_STRING_MAP.values().iterator(),\n",
        "1015": "            Functions.forMap(INT_TO_STRING_MAP.inverse()));\n",
        "1096": "    assertNotSame(System.getProperty(\"java.version\"),\n",
        "1097": "                  result.get(\"java.version\"));\n",
        "1103": "    Properties properties = new Properties() {\n",
        "1104": "      @Override public Enumeration<?> propertyNames() {\n",
        "1105": "        return Iterators.asEnumeration(\n",
        "1106": "            Arrays.asList(null, \"first\", \"second\").iterator());\n",
        "1107": "      }\n",
        "1108": "    };\n",
        "1115": "    } catch (NullPointerException expected) {}\n",
        "1121": "    Properties properties = new Properties() {\n",
        "1122": "      @Override public Enumeration<?> propertyNames() {\n",
        "1123": "        return Iterators.asEnumeration(\n",
        "1124": "            Arrays.<Object>asList(Integer.valueOf(123), \"first\").iterator());\n",
        "1125": "      }\n",
        "1126": "    };\n",
        "1131": "    } catch (ClassCastException expected) {}\n",
        "1135": "    ImmutableBiMap<String, Integer> biMap = ImmutableBiMap.of(\n",
        "1136": "        \"one\", 1,\n",
        "1137": "        \"two\", 2);\n",
        "1145": "    ImmutableBiMap<String, Integer> biMap = ImmutableBiMap.of(\n",
        "1146": "        \"one\", 1,\n",
        "1147": "        \"two\", 2);\n",
        "1155": "    ImmutableBiMap<String, Integer> biMap = ImmutableBiMap.of(\n",
        "1156": "        \"one\", 1,\n",
        "1157": "        \"two\", 2);\n",
        "1167": "    ImmutableBiMap<String, Integer> biMap = ImmutableBiMap.of(\n",
        "1168": "        \"one\", 1,\n",
        "1169": "        \"two\", 2);\n",
        "1209": "    ImmutableBiMap<String, Integer> biMap = ImmutableBiMap.of(\n",
        "1210": "        \"one\", 1,\n",
        "1211": "        \"two\", 2);\n",
        "1217": "    ImmutableBiMap<String, Integer> biMap = ImmutableBiMap.of(\n",
        "1218": "        \"one\", 1,\n",
        "1219": "        \"two\", 2);\n",
        "1245": "    } catch (UnsupportedOperationException expected) {}\n",
        "1249": "    } catch (UnsupportedOperationException expected) {}\n",
        "1253": "    } catch (UnsupportedOperationException expected) {}\n",
        "1260": "    } catch (UnsupportedOperationException expected) {}\n",
        "1264": "    } catch (UnsupportedOperationException expected) {}\n",
        "1268": "    } catch (UnsupportedOperationException expected) {}\n",
        "1273": "    } catch (UnsupportedOperationException expected) {}\n",
        "1279": "    } catch (UnsupportedOperationException expected) {}\n",
        "1281": "    Entry<Integer, String> entry2\n",
        "1282": "        = (Entry<Integer, String>) entries.toArray()[0];\n",
        "1286": "    } catch (UnsupportedOperationException expected) {}\n",
        "1296": "    } catch (UnsupportedOperationException expected) {}\n",
        "1302": "    Entry<String, Integer> e\n",
        "1303": "        = Maps.immutableEntry((String) null, (Integer) null);\n",
        "1309": "    } catch (UnsupportedOperationException expected) {}\n",
        "1325": "  private static final Predicate<String> NOT_LENGTH_3\n",
        "1326": "      = new Predicate<String>() {\n",
        "1333": "  private static final Predicate<Integer> EVEN\n",
        "1334": "      = new Predicate<Integer>() {\n",
        "1341": "  private static final Predicate<Entry<String, Integer>> CORRECT_LENGTH\n",
        "1342": "      = new Predicate<Entry<String, Integer>>() {\n",
        "1349": "  private static final Function<Integer, Double> SQRT_FUNCTION = new Function<Integer, Double>() {\n",
        "1350": "      @Override\n",
        "1351": "      public Double apply(Integer in) {\n",
        "1352": "        return Math.sqrt(in);\n",
        "1353": "      }\n",
        "1354": "    };\n",
        "1371": "      } catch (IllegalArgumentException expected) {}\n",
        "1384": "      } catch (IllegalArgumentException expected) {}\n",
        "1418": "      } catch (IllegalArgumentException expected) {}\n",
        "1433": "      } catch (IllegalArgumentException expected) {}\n",
        "1448": "      } catch (IllegalArgumentException expected) {}\n",
        "1460": "      assertEquals(ImmutableMap.of(\"one\", 1, \"two\", 2, \"three\", 3, \"four\", 4),\n",
        "1461": "          unfiltered);\n",
        "1474": "      Map<String, Integer> filtered\n",
        "1475": "          = Maps.filterEntries(unfiltered, CORRECT_LENGTH);\n",
        "1484": "      } catch (IllegalArgumentException expected) {}\n",
        "1493": "      Map<String, Integer> filtered\n",
        "1494": "          = Maps.filterEntries(unfiltered, CORRECT_LENGTH);\n",
        "1503": "      } catch (IllegalArgumentException expected) {}\n",
        "1513": "      Map<String, Integer> filtered\n",
        "1514": "          = Maps.filterEntries(unfiltered, predicate);\n",
        "1523": "      Predicate<Entry<?, ?>> predicate = new Predicate<Entry<?, ?>>() {\n",
        "1524": "        @Override\n",
        "1525": "        public boolean apply(Entry<?, ?> input) {\n",
        "1526": "          return \"cat\".equals(input.getKey())\n",
        "1527": "              || Integer.valueOf(2) == input.getValue();\n",
        "1528": "        }\n",
        "1529": "      };\n",
        "1530": "      Map<String, Integer> filtered\n",
        "1531": "          = Maps.filterEntries(unfiltered, predicate);\n",
        "1660": "    Map<String, Boolean> options =\n",
        "1661": "        ImmutableMap.of(\"verbose\", true, \"sort\", false);\n",
        "1674": "  private static <K, V> SortedMap<K, V> sortedNotNavigable(\n",
        "1675": "      final SortedMap<K, V> map) {\n",
        "1677": "      @Override protected SortedMap<K, V> delegate() {\n",
        "1684": "    SortedMap<String, Integer> map =\n",
        "1685": "        sortedNotNavigable(ImmutableSortedMap.of(\"a\", 4, \"b\", 9));\n",
        "1686": "    SortedMap<String, Double> transformed =\n",
        "1687": "        transformValues(map, SQRT_FUNCTION);\n",
        "1699": "    NavigableMap<String, Double> transformed =\n",
        "1700": "        transformValues(map, SQRT_FUNCTION);\n",
        "1706": "    SortedMap<String, String> map =\n",
        "1707": "        sortedNotNavigable(ImmutableSortedMap.of(\"a\", \"4\", \"b\", \"9\"));\n",
        "1726": "    NavigableMap<String, String> map =\n",
        "1727": "        ImmutableSortedMap.of(\"a\", \"4\", \"b\", \"9\");\n",
        "1841": "        @SuppressWarnings(\"unchecked\")\n",
        "1842": "    Entry<Integer, String> entry2 =\n",
        "1843": "        (Entry<Integer, String>) entries.toArray()[0];\n",
        "1916": "    assertEquals(ImmutableSortedMap.of(4, 0, 6, 0, 8, 0, 10, 0),\n",
        "1917": "        Maps.subMap(map, Range.atLeast(4)));\n",
        "1948": "            .put(2, 0).put(4, 0).put(6, 0).put(8, 0).put(10, 0).build();\n",
        "1960": "    assertEquals(ImmutableSortedMap.of(2, 0, 4, 0, 6, 0, 8, 0, 10, 0),\n"
    }
}