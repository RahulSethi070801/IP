{
    "addition": {
        "60": " * \"https://github.com/google/guava/wiki/CollectionUtilitiesExplained#multimaps\"> {@code\n",
        "61": " * Multimaps}</a>.\n",
        "255": "   * Creates a new {@code ListMultimap} that uses the provided map and factory. It can generate a\n",
        "256": "   * multimap based on arbitrary {@link Map} and {@link List} classes.\n",
        "257": "   *\n",
        "258": "   * <p>The {@code factory}-generated and {@code map} classes determine the multimap iteration\n",
        "259": "   * order. They also specify the behavior of the {@code equals}, {@code hashCode}, and {@code\n",
        "260": "   * toString} methods for the multimap and its returned views. The multimap's {@code get}, {@code\n",
        "261": "   * removeAll}, and {@code replaceValues} methods return {@code RandomAccess} lists if the factory\n",
        "262": "   * does. However, the multimap's {@code get} method returns instances of a different class than\n",
        "263": "   * does {@code factory.get()}.\n",
        "264": "   *\n",
        "265": "   * <p>The multimap is serializable if {@code map}, {@code factory}, the lists generated by {@code\n",
        "266": "   * factory}, and the multimap contents are all serializable.\n",
        "267": "   *\n",
        "268": "   * <p>The multimap is not threadsafe when any concurrent operations update the multimap, even if\n",
        "269": "   * {@code map} and the instances generated by {@code factory} are. Concurrent read operations will\n",
        "270": "   * work correctly. To allow concurrent update operations, wrap the multimap with a call to {@link\n",
        "271": "   * #synchronizedListMultimap}.\n",
        "272": "   *\n",
        "273": "   * <p>Call this method only when the simpler methods {@link ArrayListMultimap#create()} and {@link\n",
        "274": "   * LinkedListMultimap#create()} won't suffice.\n",
        "275": "   *\n",
        "276": "   * <p>Note: the multimap assumes complete ownership over of {@code map} and the lists returned by\n",
        "277": "   * {@code factory}. Those objects should not be manually updated, they should be empty when\n",
        "278": "   * provided, and they should not use soft, weak, or phantom references.\n",
        "280": "   * @param map place to store the mapping from each key to its corresponding values\n",
        "281": "   * @param factory supplier of new, empty lists that will each hold all values for a given key\n",
        "324": "   * Creates a new {@code SetMultimap} that uses the provided map and factory. It can generate a\n",
        "325": "   * multimap based on arbitrary {@link Map} and {@link Set} classes.\n",
        "326": "   *\n",
        "327": "   * <p>The {@code factory}-generated and {@code map} classes determine the multimap iteration\n",
        "328": "   * order. They also specify the behavior of the {@code equals}, {@code hashCode}, and {@code\n",
        "329": "   * toString} methods for the multimap and its returned views. However, the multimap's {@code get}\n",
        "330": "   * method returns instances of a different class than {@code factory.get()} does.\n",
        "331": "   *\n",
        "332": "   * <p>The multimap is serializable if {@code map}, {@code factory}, the sets generated by {@code\n",
        "333": "   * factory}, and the multimap contents are all serializable.\n",
        "334": "   *\n",
        "335": "   * <p>The multimap is not threadsafe when any concurrent operations update the multimap, even if\n",
        "336": "   * {@code map} and the instances generated by {@code factory} are. Concurrent read operations will\n",
        "337": "   * work correctly. To allow concurrent update operations, wrap the multimap with a call to {@link\n",
        "338": "   * #synchronizedSetMultimap}.\n",
        "339": "   *\n",
        "340": "   * <p>Call this method only when the simpler methods {@link HashMultimap#create()}, {@link\n",
        "341": "   * LinkedHashMultimap#create()}, {@link TreeMultimap#create()}, and {@link\n",
        "342": "   * TreeMultimap#create(Comparator, Comparator)} won't suffice.\n",
        "343": "   *\n",
        "344": "   * <p>Note: the multimap assumes complete ownership over of {@code map} and the sets returned by\n",
        "345": "   * {@code factory}. Those objects should not be manually updated and they should not use soft,\n",
        "346": "   * weak, or phantom references.\n",
        "347": "   *\n",
        "348": "   * @param map place to store the mapping from each key to its corresponding values\n",
        "349": "   * @param factory supplier of new, empty sets that will each hold all values for a given key\n",
        "392": "   * Creates a new {@code SortedSetMultimap} that uses the provided map and factory. It can generate\n",
        "393": "   * a multimap based on arbitrary {@link Map} and {@link SortedSet} classes.\n",
        "394": "   *\n",
        "395": "   * <p>The {@code factory}-generated and {@code map} classes determine the multimap iteration\n",
        "396": "   * order. They also specify the behavior of the {@code equals}, {@code hashCode}, and {@code\n",
        "397": "   * toString} methods for the multimap and its returned views. However, the multimap's {@code get}\n",
        "398": "   * method returns instances of a different class than {@code factory.get()} does.\n",
        "399": "   *\n",
        "400": "   * <p>The multimap is serializable if {@code map}, {@code factory}, the sets generated by {@code\n",
        "401": "   * factory}, and the multimap contents are all serializable.\n",
        "402": "   *\n",
        "403": "   * <p>The multimap is not threadsafe when any concurrent operations update the multimap, even if\n",
        "404": "   * {@code map} and the instances generated by {@code factory} are. Concurrent read operations will\n",
        "405": "   * work correctly. To allow concurrent update operations, wrap the multimap with a call to {@link\n",
        "406": "   * #synchronizedSortedSetMultimap}.\n",
        "407": "   *\n",
        "408": "   * <p>Call this method only when the simpler methods {@link TreeMultimap#create()} and {@link\n",
        "409": "   * TreeMultimap#create(Comparator, Comparator)} won't suffice.\n",
        "410": "   *\n",
        "411": "   * <p>Note: the multimap assumes complete ownership over of {@code map} and the sets returned by\n",
        "412": "   * {@code factory}. Those objects should not be manually updated and they should not use soft,\n",
        "413": "   * weak, or phantom references.\n",
        "414": "   *\n",
        "415": "   * @param map place to store the mapping from each key to its corresponding values\n",
        "416": "   * @param factory supplier of new, empty sorted sets that will each hold all values for a given\n",
        "417": "   *     key\n",
        "468": "   * Copies each key-value mapping in {@code source} into {@code dest}, with its key and value\n",
        "469": "   * reversed.\n",
        "471": "   * <p>If {@code source} is an {@link ImmutableMultimap}, consider using {@link\n",
        "472": "   * ImmutableMultimap#inverse} instead.\n",
        "489": "   * Returns a synchronized (thread-safe) multimap backed by the specified multimap. In order to\n",
        "490": "   * guarantee serial access, it is critical that <b>all</b> access to the backing multimap is\n",
        "491": "   * accomplished through the returned multimap.\n",
        "492": "   *\n",
        "493": "   * <p>It is imperative that the user manually synchronize on the returned multimap when accessing\n",
        "494": "   * any of its collection views:\n",
        "495": "   *\n",
        "496": "   * <pre>{@code\n",
        "497": "   * Multimap<K, V> multimap = Multimaps.synchronizedMultimap(\n",
        "498": "   *     HashMultimap.<K, V>create());\n",
        "499": "   * ...\n",
        "500": "   * Collection<V> values = multimap.get(key);  // Needn't be in synchronized block\n",
        "501": "   * ...\n",
        "502": "   * synchronized (multimap) {  // Synchronizing on multimap, not values!\n",
        "503": "   *   Iterator<V> i = values.iterator(); // Must be in synchronized block\n",
        "504": "   *   while (i.hasNext()) {\n",
        "505": "   *     foo(i.next());\n",
        "506": "   *   }\n",
        "507": "   * }\n",
        "508": "   * }</pre>\n",
        "512": "   * <p>Note that the generated multimap's {@link Multimap#removeAll} and {@link\n",
        "513": "   * Multimap#replaceValues} methods return collections that aren't synchronized.\n",
        "515": "   * <p>The returned multimap will be serializable if the specified multimap is serializable.\n",
        "525": "   * Returns an unmodifiable view of the specified multimap. Query operations on the returned\n",
        "526": "   * multimap \"read through\" to the specified multimap, and attempts to modify the returned\n",
        "527": "   * multimap, either directly or through the multimap's views, result in an {@code\n",
        "528": "   * UnsupportedOperationException}.\n",
        "530": "   * <p>Note that the generated multimap's {@link Multimap#removeAll} and {@link\n",
        "531": "   * Multimap#replaceValues} methods return collections that are modifiable.\n",
        "533": "   * <p>The returned multimap will be serializable if the specified multimap is serializable.\n",
        "535": "   * @param delegate the multimap for which an unmodifiable view is to be returned\n",
        "774": "   * Returns a synchronized (thread-safe) {@code SetMultimap} backed by the specified multimap.\n",
        "778": "   * <p>The returned multimap will be serializable if the specified multimap is serializable.\n",
        "788": "   * Returns an unmodifiable view of the specified {@code SetMultimap}. Query operations on the\n",
        "789": "   * returned multimap \"read through\" to the specified multimap, and attempts to modify the returned\n",
        "790": "   * multimap, either directly or through the multimap's views, result in an {@code\n",
        "791": "   * UnsupportedOperationException}.\n",
        "793": "   * <p>Note that the generated multimap's {@link Multimap#removeAll} and {@link\n",
        "794": "   * Multimap#replaceValues} methods return collections that are modifiable.\n",
        "796": "   * <p>The returned multimap will be serializable if the specified multimap is serializable.\n",
        "798": "   * @param delegate the multimap for which an unmodifiable view is to be returned\n",
        "821": "   * Returns a synchronized (thread-safe) {@code SortedSetMultimap} backed by the specified\n",
        "822": "   * multimap.\n",
        "826": "   * <p>The returned multimap will be serializable if the specified multimap is serializable.\n",
        "837": "   * Returns an unmodifiable view of the specified {@code SortedSetMultimap}. Query operations on\n",
        "838": "   * the returned multimap \"read through\" to the specified multimap, and attempts to modify the\n",
        "839": "   * returned multimap, either directly or through the multimap's views, result in an {@code\n",
        "840": "   * UnsupportedOperationException}.\n",
        "842": "   * <p>Note that the generated multimap's {@link Multimap#removeAll} and {@link\n",
        "843": "   * Multimap#replaceValues} methods return collections that are modifiable.\n",
        "845": "   * <p>The returned multimap will be serializable if the specified multimap is serializable.\n",
        "847": "   * @param delegate the multimap for which an unmodifiable view is to be returned\n",
        "859": "   * Returns a synchronized (thread-safe) {@code ListMultimap} backed by the specified multimap.\n",
        "871": "   * Returns an unmodifiable view of the specified {@code ListMultimap}. Query operations on the\n",
        "872": "   * returned multimap \"read through\" to the specified multimap, and attempts to modify the returned\n",
        "873": "   * multimap, either directly or through the multimap's views, result in an {@code\n",
        "874": "   * UnsupportedOperationException}.\n",
        "876": "   * <p>Note that the generated multimap's {@link Multimap#removeAll} and {@link\n",
        "877": "   * Multimap#replaceValues} methods return collections that are modifiable.\n",
        "879": "   * <p>The returned multimap will be serializable if the specified multimap is serializable.\n",
        "881": "   * @param delegate the multimap for which an unmodifiable view is to be returned\n",
        "904": "   * Returns an unmodifiable view of the specified collection, preserving the interface for\n",
        "905": "   * instances of {@code SortedSet}, {@code Set}, {@code List} and {@code Collection}, in that order\n",
        "906": "   * of preference.\n",
        "923": "   * Returns an unmodifiable view of the specified collection of entries. The {@link Entry#setValue}\n",
        "924": "   * operation throws an {@link UnsupportedOperationException}. If the specified collection is a\n",
        "925": "   * {@code Set}, the returned collection is also a {@code Set}.\n",
        "939": "   * Returns {@link ListMultimap#asMap multimap.asMap()}, with its type corrected from {@code Map<K,\n",
        "940": "   * Collection<V>>} to {@code Map<K, List<V>>}.\n",
        "952": "   * Returns {@link SetMultimap#asMap multimap.asMap()}, with its type corrected from {@code Map<K,\n",
        "953": "   * Collection<V>>} to {@code Map<K, Set<V>>}.\n",
        "965": "   * Returns {@link SortedSetMultimap#asMap multimap.asMap()}, with its type corrected from {@code\n",
        "966": "   * Map<K, Collection<V>>} to {@code Map<K, SortedSet<V>>}.\n",
        "978": "   * Returns {@link Multimap#asMap multimap.asMap()}. This is provided for parity with the other\n",
        "979": "   * more strongly-typed {@code asMap()} implementations.\n",
        "989": "   * Returns a multimap view of the specified map. The multimap is backed by the map, so changes to\n",
        "990": "   * the map are reflected in the multimap, and vice versa. If the map is modified while an\n",
        "991": "   * iteration over one of the multimap's collection views is in progress (except through the\n",
        "992": "   * iterator's own {@code remove} operation, or through the {@code setValue} operation on a map\n",
        "993": "   * entry returned by the iterator), the results of the iteration are undefined.\n",
        "995": "   * <p>The multimap supports mapping removal, which removes the corresponding mapping from the map.\n",
        "996": "   * It does not support any operations which might add mappings, such as {@code put}, {@code\n",
        "997": "   * putAll} or {@code replaceValues}.\n",
        "999": "   * <p>The returned multimap will be serializable if the specified map is serializable.\n",
        "1148": "   * Returns a view of a multimap where each value is transformed by a function. All other\n",
        "1149": "   * properties of the multimap, such as iteration order, are left intact. For example, the code:\n",
        "1151": "   * <pre>{@code\n",
        "1161": "   *   System.out.println(transformed);\n",
        "1162": "   * }</pre>\n",
        "1166": "   * <p>Changes in the underlying multimap are reflected in this view. Conversely, this view\n",
        "1167": "   * supports removal operations, and these are reflected in the underlying multimap.\n",
        "1168": "   *\n",
        "1169": "   * <p>It's acceptable for the underlying multimap to contain null keys, and even null values\n",
        "1170": "   * provided that the function is capable of accepting null input. The transformed multimap might\n",
        "1171": "   * contain null values, if the function sometimes gives a null result.\n",
        "1172": "   *\n",
        "1173": "   * <p>The returned multimap is not thread-safe or serializable, even if the underlying multimap\n",
        "1174": "   * is. The {@code equals} and {@code hashCode} methods of the returned multimap are meaningless,\n",
        "1175": "   * since there is not a definition of {@code equals} or {@code hashCode} for general collections,\n",
        "1176": "   * and {@code get()} will return a general {@code Collection} as opposed to a {@code List} or a\n",
        "1177": "   * {@code Set}.\n",
        "1178": "   *\n",
        "1179": "   * <p>The function is applied lazily, invoked when needed. This is necessary for the returned\n",
        "1180": "   * multimap to be a view, but it means that the function will be applied many times for bulk\n",
        "1181": "   * operations like {@link Multimap#containsValue} and {@code Multimap.toString()}. For this to\n",
        "1182": "   * perform well, {@code function} should be fast. To avoid lazy evaluation when the returned\n",
        "1183": "   * multimap doesn't need to be a view, copy the returned multimap into a new multimap of your\n",
        "1184": "   * choosing.\n",
        "1196": "   * Returns a view of a multimap whose values are derived from the original multimap's entries. In\n",
        "1197": "   * contrast to {@link #transformValues}, this method's entry-transformation logic may depend on\n",
        "1198": "   * the key as well as the value.\n",
        "1200": "   * <p>All other properties of the transformed multimap, such as iteration order, are left intact.\n",
        "1201": "   * For example, the code:\n",
        "1202": "   *\n",
        "1203": "   * <pre>{@code\n",
        "1204": "   * SetMultimap<String, Integer> multimap =\n",
        "1205": "   *     ImmutableSetMultimap.of(\"a\", 1, \"a\", 4, \"b\", -6);\n",
        "1206": "   * EntryTransformer<String, Integer, String> transformer =\n",
        "1207": "   *     new EntryTransformer<String, Integer, String>() {\n",
        "1208": "   *       public String transformEntry(String key, Integer value) {\n",
        "1209": "   *          return (value >= 0) ? key : \"no\" + key;\n",
        "1210": "   *       }\n",
        "1211": "   *     };\n",
        "1212": "   * Multimap<String, String> transformed =\n",
        "1213": "   *     Multimaps.transformEntries(multimap, transformer);\n",
        "1214": "   * System.out.println(transformed);\n",
        "1215": "   * }</pre>\n",
        "1219": "   * <p>Changes in the underlying multimap are reflected in this view. Conversely, this view\n",
        "1220": "   * supports removal operations, and these are reflected in the underlying multimap.\n",
        "1221": "   *\n",
        "1222": "   * <p>It's acceptable for the underlying multimap to contain null keys and null values provided\n",
        "1223": "   * that the transformer is capable of accepting null inputs. The transformed multimap might\n",
        "1224": "   * contain null values if the transformer sometimes gives a null result.\n",
        "1225": "   *\n",
        "1226": "   * <p>The returned multimap is not thread-safe or serializable, even if the underlying multimap\n",
        "1227": "   * is. The {@code equals} and {@code hashCode} methods of the returned multimap are meaningless,\n",
        "1228": "   * since there is not a definition of {@code equals} or {@code hashCode} for general collections,\n",
        "1229": "   * and {@code get()} will return a general {@code Collection} as opposed to a {@code List} or a\n",
        "1230": "   * {@code Set}.\n",
        "1231": "   *\n",
        "1232": "   * <p>The transformer is applied lazily, invoked when needed. This is necessary for the returned\n",
        "1233": "   * multimap to be a view, but it means that the transformer will be applied many times for bulk\n",
        "1234": "   * operations like {@link Multimap#containsValue} and {@link Object#toString}. For this to perform\n",
        "1235": "   * well, {@code transformer} should be fast. To avoid lazy evaluation when the returned multimap\n",
        "1236": "   * doesn't need to be a view, copy the returned multimap into a new multimap of your choosing.\n",
        "1237": "   *\n",
        "1238": "   * <p><b>Warning:</b> This method assumes that for any instance {@code k} of {@code\n",
        "1239": "   * EntryTransformer} key type {@code K}, {@code k.equals(k2)} implies that {@code k2} is also of\n",
        "1240": "   * type {@code K}. Using an {@code EntryTransformer} key type for which this may not hold, such as\n",
        "1241": "   * {@code ArrayList}, may risk a {@code ClassCastException} when calling methods on the\n",
        "1242": "   * transformed multimap.\n",
        "1364": "   * Returns a view of a {@code ListMultimap} where each value is transformed by a function. All\n",
        "1365": "   * other properties of the multimap, such as iteration order, are left intact. For example, the\n",
        "1366": "   * code:\n",
        "1367": "   *\n",
        "1368": "   * <pre>{@code\n",
        "1369": "   * ListMultimap<String, Integer> multimap\n",
        "1370": "   *      = ImmutableListMultimap.of(\"a\", 4, \"a\", 16, \"b\", 9);\n",
        "1371": "   * Function<Integer, Double> sqrt =\n",
        "1372": "   *     new Function<Integer, Double>() {\n",
        "1373": "   *       public Double apply(Integer in) {\n",
        "1374": "   *         return Math.sqrt((int) in);\n",
        "1375": "   *       }\n",
        "1376": "   *     };\n",
        "1377": "   * ListMultimap<String, Double> transformed = Multimaps.transformValues(map,\n",
        "1378": "   *     sqrt);\n",
        "1379": "   * System.out.println(transformed);\n",
        "1380": "   * }</pre>\n",
        "1384": "   * <p>Changes in the underlying multimap are reflected in this view. Conversely, this view\n",
        "1385": "   * supports removal operations, and these are reflected in the underlying multimap.\n",
        "1387": "   * <p>It's acceptable for the underlying multimap to contain null keys, and even null values\n",
        "1388": "   * provided that the function is capable of accepting null input. The transformed multimap might\n",
        "1389": "   * contain null values, if the function sometimes gives a null result.\n",
        "1391": "   * <p>The returned multimap is not thread-safe or serializable, even if the underlying multimap\n",
        "1392": "   * is.\n",
        "1394": "   * <p>The function is applied lazily, invoked when needed. This is necessary for the returned\n",
        "1395": "   * multimap to be a view, but it means that the function will be applied many times for bulk\n",
        "1396": "   * operations like {@link Multimap#containsValue} and {@code Multimap.toString()}. For this to\n",
        "1397": "   * perform well, {@code function} should be fast. To avoid lazy evaluation when the returned\n",
        "1398": "   * multimap doesn't need to be a view, copy the returned multimap into a new multimap of your\n",
        "1399": "   * choosing.\n",
        "1411": "   * Returns a view of a {@code ListMultimap} whose values are derived from the original multimap's\n",
        "1412": "   * entries. In contrast to {@link #transformValues(ListMultimap, Function)}, this method's\n",
        "1415": "   * <p>All other properties of the transformed multimap, such as iteration order, are left intact.\n",
        "1416": "   * For example, the code:\n",
        "1417": "   *\n",
        "1418": "   * <pre>{@code\n",
        "1419": "   * Multimap<String, Integer> multimap =\n",
        "1420": "   *     ImmutableMultimap.of(\"a\", 1, \"a\", 4, \"b\", 6);\n",
        "1421": "   * EntryTransformer<String, Integer, String> transformer =\n",
        "1422": "   *     new EntryTransformer<String, Integer, String>() {\n",
        "1423": "   *       public String transformEntry(String key, Integer value) {\n",
        "1424": "   *         return key + value;\n",
        "1425": "   *       }\n",
        "1426": "   *     };\n",
        "1427": "   * Multimap<String, String> transformed =\n",
        "1428": "   *     Multimaps.transformEntries(multimap, transformer);\n",
        "1429": "   * System.out.println(transformed);\n",
        "1430": "   * }</pre>\n",
        "1434": "   * <p>Changes in the underlying multimap are reflected in this view. Conversely, this view\n",
        "1435": "   * supports removal operations, and these are reflected in the underlying multimap.\n",
        "1436": "   *\n",
        "1437": "   * <p>It's acceptable for the underlying multimap to contain null keys and null values provided\n",
        "1438": "   * that the transformer is capable of accepting null inputs. The transformed multimap might\n",
        "1439": "   * contain null values if the transformer sometimes gives a null result.\n",
        "1440": "   *\n",
        "1441": "   * <p>The returned multimap is not thread-safe or serializable, even if the underlying multimap\n",
        "1442": "   * is.\n",
        "1443": "   *\n",
        "1444": "   * <p>The transformer is applied lazily, invoked when needed. This is necessary for the returned\n",
        "1445": "   * multimap to be a view, but it means that the transformer will be applied many times for bulk\n",
        "1446": "   * operations like {@link Multimap#containsValue} and {@link Object#toString}. For this to perform\n",
        "1447": "   * well, {@code transformer} should be fast. To avoid lazy evaluation when the returned multimap\n",
        "1448": "   * doesn't need to be a view, copy the returned multimap into a new multimap of your choosing.\n",
        "1449": "   *\n",
        "1450": "   * <p><b>Warning:</b> This method assumes that for any instance {@code k} of {@code\n",
        "1451": "   * EntryTransformer} key type {@code K}, {@code k.equals(k2)} implies that {@code k2} is also of\n",
        "1452": "   * type {@code K}. Using an {@code EntryTransformer} key type for which this may not hold, such as\n",
        "1453": "   * {@code ArrayList}, may risk a {@code ClassCastException} when calling methods on the\n",
        "1454": "   * transformed multimap.\n",
        "1494": "   * Creates an index {@code ImmutableListMultimap} that contains the results of applying a\n",
        "1495": "   * specified function to each item in an {@code Iterable} of values. Each value will be stored as\n",
        "1496": "   * a value in the resulting multimap, yielding a multimap with the same size as the input\n",
        "1497": "   * iterable. The key used to store that value in the multimap will be the result of calling the\n",
        "1498": "   * function on that value. The resulting multimap is created as an immutable snapshot. In the\n",
        "1499": "   * returned multimap, keys appear in the order they are first encountered, and the values\n",
        "1500": "   * corresponding to each key appear in the same order as they are encountered.\n",
        "1501": "   *\n",
        "1502": "   * <p>For example,\n",
        "1503": "   *\n",
        "1504": "   * <pre>{@code\n",
        "1505": "   * List<String> badGuys =\n",
        "1506": "   *     Arrays.asList(\"Inky\", \"Blinky\", \"Pinky\", \"Pinky\", \"Clyde\");\n",
        "1507": "   * Function<String, Integer> stringLengthFunction = ...;\n",
        "1508": "   * Multimap<Integer, String> index =\n",
        "1509": "   *     Multimaps.index(badGuys, stringLengthFunction);\n",
        "1510": "   * System.out.println(index);\n",
        "1511": "   * }</pre>\n",
        "1512": "   *\n",
        "1513": "   * <p>prints\n",
        "1514": "   *\n",
        "1515": "   * <pre>{@code\n",
        "1516": "   * {4=[Inky], 6=[Blinky], 5=[Pinky, Pinky, Clyde]}\n",
        "1517": "   * }</pre>\n",
        "1518": "   *\n",
        "1519": "   * <p>The returned multimap is serializable if its keys and values are all serializable.\n",
        "1520": "   *\n",
        "1521": "   * @param values the values to use when constructing the {@code ImmutableListMultimap}\n",
        "1523": "   * @return {@code ImmutableListMultimap} mapping the result of evaluating the function {@code\n",
        "1524": "   *     keyFunction} on each value in the input collection to that value\n",
        "1534": "   * Creates an index {@code ImmutableListMultimap} that contains the results of applying a\n",
        "1535": "   * specified function to each item in an {@code Iterator} of values. Each value will be stored as\n",
        "1536": "   * a value in the resulting multimap, yielding a multimap with the same size as the input\n",
        "1537": "   * iterator. The key used to store that value in the multimap will be the result of calling the\n",
        "1538": "   * function on that value. The resulting multimap is created as an immutable snapshot. In the\n",
        "1539": "   * returned multimap, keys appear in the order they are first encountered, and the values\n",
        "1540": "   * corresponding to each key appear in the same order as they are encountered.\n",
        "1541": "   *\n",
        "1542": "   * <p>For example,\n",
        "1543": "   *\n",
        "1544": "   * <pre>{@code\n",
        "1545": "   * List<String> badGuys =\n",
        "1546": "   *     Arrays.asList(\"Inky\", \"Blinky\", \"Pinky\", \"Pinky\", \"Clyde\");\n",
        "1547": "   * Function<String, Integer> stringLengthFunction = ...;\n",
        "1548": "   * Multimap<Integer, String> index =\n",
        "1549": "   *     Multimaps.index(badGuys.iterator(), stringLengthFunction);\n",
        "1550": "   * System.out.println(index);\n",
        "1551": "   * }</pre>\n",
        "1552": "   *\n",
        "1553": "   * <p>prints\n",
        "1554": "   *\n",
        "1555": "   * <pre>{@code\n",
        "1556": "   * {4=[Inky], 6=[Blinky], 5=[Pinky, Pinky, Clyde]}\n",
        "1557": "   * }</pre>\n",
        "1558": "   *\n",
        "1559": "   * <p>The returned multimap is serializable if its keys and values are all serializable.\n",
        "1560": "   *\n",
        "1561": "   * @param values the values to use when constructing the {@code ImmutableListMultimap}\n",
        "1563": "   * @return {@code ImmutableListMultimap} mapping the result of evaluating the function {@code\n",
        "1564": "   *     keyFunction} on each value in the input collection to that value\n",
        "1729": "  /** A skeleton implementation of {@link Multimap#entries()}. */\n",
        "1762": "  /** A skeleton implementation of {@link Multimap#asMap()}. */\n",
        "1847": "   * Returns a multimap containing the mappings in {@code unfiltered} whose keys satisfy a\n",
        "1848": "   * predicate. The returned multimap is a live view of {@code unfiltered}; changes to one affect\n",
        "1849": "   * the other.\n",
        "1851": "   * <p>The resulting multimap's views have iterators that don't support {@code remove()}, but all\n",
        "1852": "   * other methods are supported by the multimap and its views. When adding a key that doesn't\n",
        "1853": "   * satisfy the predicate, the multimap's {@code put()}, {@code putAll()}, and {@code\n",
        "1854": "   * replaceValues()} methods throw an {@link IllegalArgumentException}.\n",
        "1856": "   * <p>When methods such as {@code removeAll()} and {@code clear()} are called on the filtered\n",
        "1857": "   * multimap or its views, only mappings whose keys satisfy the filter will be removed from the\n",
        "1858": "   * underlying multimap.\n",
        "1860": "   * <p>The returned multimap isn't threadsafe or serializable, even if {@code unfiltered} is.\n",
        "1862": "   * <p>Many of the filtered multimap's methods, such as {@code size()}, iterate across every\n",
        "1863": "   * key/value mapping in the underlying multimap and determine which satisfy the filter. When a\n",
        "1864": "   * live view is <i>not</i> needed, it may be faster to copy the filtered multimap and use the\n",
        "1865": "   * copy.\n",
        "1867": "   * <p><b>Warning:</b> {@code keyPredicate} must be <i>consistent with equals</i>, as documented at\n",
        "1868": "   * {@link Predicate#apply}. Do not provide a predicate such as {@code\n",
        "1869": "   * Predicates.instanceOf(ArrayList.class)}, which is inconsistent with equals.\n",
        "1892": "   * Returns a multimap containing the mappings in {@code unfiltered} whose keys satisfy a\n",
        "1893": "   * predicate. The returned multimap is a live view of {@code unfiltered}; changes to one affect\n",
        "1894": "   * the other.\n",
        "1896": "   * <p>The resulting multimap's views have iterators that don't support {@code remove()}, but all\n",
        "1897": "   * other methods are supported by the multimap and its views. When adding a key that doesn't\n",
        "1898": "   * satisfy the predicate, the multimap's {@code put()}, {@code putAll()}, and {@code\n",
        "1899": "   * replaceValues()} methods throw an {@link IllegalArgumentException}.\n",
        "1901": "   * <p>When methods such as {@code removeAll()} and {@code clear()} are called on the filtered\n",
        "1902": "   * multimap or its views, only mappings whose keys satisfy the filter will be removed from the\n",
        "1903": "   * underlying multimap.\n",
        "1905": "   * <p>The returned multimap isn't threadsafe or serializable, even if {@code unfiltered} is.\n",
        "1907": "   * <p>Many of the filtered multimap's methods, such as {@code size()}, iterate across every\n",
        "1908": "   * key/value mapping in the underlying multimap and determine which satisfy the filter. When a\n",
        "1909": "   * live view is <i>not</i> needed, it may be faster to copy the filtered multimap and use the\n",
        "1910": "   * copy.\n",
        "1912": "   * <p><b>Warning:</b> {@code keyPredicate} must be <i>consistent with equals</i>, as documented at\n",
        "1913": "   * {@link Predicate#apply}. Do not provide a predicate such as {@code\n",
        "1914": "   * Predicates.instanceOf(ArrayList.class)}, which is inconsistent with equals.\n",
        "1933": "   * Returns a multimap containing the mappings in {@code unfiltered} whose keys satisfy a\n",
        "1934": "   * predicate. The returned multimap is a live view of {@code unfiltered}; changes to one affect\n",
        "1935": "   * the other.\n",
        "1937": "   * <p>The resulting multimap's views have iterators that don't support {@code remove()}, but all\n",
        "1938": "   * other methods are supported by the multimap and its views. When adding a key that doesn't\n",
        "1939": "   * satisfy the predicate, the multimap's {@code put()}, {@code putAll()}, and {@code\n",
        "1940": "   * replaceValues()} methods throw an {@link IllegalArgumentException}.\n",
        "1942": "   * <p>When methods such as {@code removeAll()} and {@code clear()} are called on the filtered\n",
        "1943": "   * multimap or its views, only mappings whose keys satisfy the filter will be removed from the\n",
        "1944": "   * underlying multimap.\n",
        "1946": "   * <p>The returned multimap isn't threadsafe or serializable, even if {@code unfiltered} is.\n",
        "1948": "   * <p>Many of the filtered multimap's methods, such as {@code size()}, iterate across every\n",
        "1949": "   * key/value mapping in the underlying multimap and determine which satisfy the filter. When a\n",
        "1950": "   * live view is <i>not</i> needed, it may be faster to copy the filtered multimap and use the\n",
        "1951": "   * copy.\n",
        "1953": "   * <p><b>Warning:</b> {@code keyPredicate} must be <i>consistent with equals</i>, as documented at\n",
        "1954": "   * {@link Predicate#apply}. Do not provide a predicate such as {@code\n",
        "1955": "   * Predicates.instanceOf(ArrayList.class)}, which is inconsistent with equals.\n",
        "1971": "   * Returns a multimap containing the mappings in {@code unfiltered} whose values satisfy a\n",
        "1972": "   * predicate. The returned multimap is a live view of {@code unfiltered}; changes to one affect\n",
        "1973": "   * the other.\n",
        "1975": "   * <p>The resulting multimap's views have iterators that don't support {@code remove()}, but all\n",
        "1976": "   * other methods are supported by the multimap and its views. When adding a value that doesn't\n",
        "1977": "   * satisfy the predicate, the multimap's {@code put()}, {@code putAll()}, and {@code\n",
        "1978": "   * replaceValues()} methods throw an {@link IllegalArgumentException}.\n",
        "1980": "   * <p>When methods such as {@code removeAll()} and {@code clear()} are called on the filtered\n",
        "1981": "   * multimap or its views, only mappings whose value satisfy the filter will be removed from the\n",
        "1982": "   * underlying multimap.\n",
        "1984": "   * <p>The returned multimap isn't threadsafe or serializable, even if {@code unfiltered} is.\n",
        "1986": "   * <p>Many of the filtered multimap's methods, such as {@code size()}, iterate across every\n",
        "1987": "   * key/value mapping in the underlying multimap and determine which satisfy the filter. When a\n",
        "1988": "   * live view is <i>not</i> needed, it may be faster to copy the filtered multimap and use the\n",
        "1989": "   * copy.\n",
        "1991": "   * <p><b>Warning:</b> {@code valuePredicate} must be <i>consistent with equals</i>, as documented\n",
        "1992": "   * at {@link Predicate#apply}. Do not provide a predicate such as {@code\n",
        "1993": "   * Predicates.instanceOf(ArrayList.class)}, which is inconsistent with equals.\n",
        "2003": "   * Returns a multimap containing the mappings in {@code unfiltered} whose values satisfy a\n",
        "2004": "   * predicate. The returned multimap is a live view of {@code unfiltered}; changes to one affect\n",
        "2005": "   * the other.\n",
        "2007": "   * <p>The resulting multimap's views have iterators that don't support {@code remove()}, but all\n",
        "2008": "   * other methods are supported by the multimap and its views. When adding a value that doesn't\n",
        "2009": "   * satisfy the predicate, the multimap's {@code put()}, {@code putAll()}, and {@code\n",
        "2010": "   * replaceValues()} methods throw an {@link IllegalArgumentException}.\n",
        "2012": "   * <p>When methods such as {@code removeAll()} and {@code clear()} are called on the filtered\n",
        "2013": "   * multimap or its views, only mappings whose value satisfy the filter will be removed from the\n",
        "2014": "   * underlying multimap.\n",
        "2016": "   * <p>The returned multimap isn't threadsafe or serializable, even if {@code unfiltered} is.\n",
        "2018": "   * <p>Many of the filtered multimap's methods, such as {@code size()}, iterate across every\n",
        "2019": "   * key/value mapping in the underlying multimap and determine which satisfy the filter. When a\n",
        "2020": "   * live view is <i>not</i> needed, it may be faster to copy the filtered multimap and use the\n",
        "2021": "   * copy.\n",
        "2023": "   * <p><b>Warning:</b> {@code valuePredicate} must be <i>consistent with equals</i>, as documented\n",
        "2024": "   * at {@link Predicate#apply}. Do not provide a predicate such as {@code\n",
        "2025": "   * Predicates.instanceOf(ArrayList.class)}, which is inconsistent with equals.\n",
        "2035": "   * Returns a multimap containing the mappings in {@code unfiltered} that satisfy a predicate. The\n",
        "2036": "   * returned multimap is a live view of {@code unfiltered}; changes to one affect the other.\n",
        "2038": "   * <p>The resulting multimap's views have iterators that don't support {@code remove()}, but all\n",
        "2039": "   * other methods are supported by the multimap and its views. When adding a key/value pair that\n",
        "2040": "   * doesn't satisfy the predicate, multimap's {@code put()}, {@code putAll()}, and {@code\n",
        "2041": "   * replaceValues()} methods throw an {@link IllegalArgumentException}.\n",
        "2043": "   * <p>When methods such as {@code removeAll()} and {@code clear()} are called on the filtered\n",
        "2044": "   * multimap or its views, only mappings whose keys satisfy the filter will be removed from the\n",
        "2045": "   * underlying multimap.\n",
        "2047": "   * <p>The returned multimap isn't threadsafe or serializable, even if {@code unfiltered} is.\n",
        "2049": "   * <p>Many of the filtered multimap's methods, such as {@code size()}, iterate across every\n",
        "2050": "   * key/value mapping in the underlying multimap and determine which satisfy the filter. When a\n",
        "2051": "   * live view is <i>not</i> needed, it may be faster to copy the filtered multimap and use the\n",
        "2052": "   * copy.\n",
        "2054": "   * <p><b>Warning:</b> {@code entryPredicate} must be <i>consistent with equals</i>, as documented\n",
        "2055": "   * at {@link Predicate#apply}.\n",
        "2071": "   * Returns a multimap containing the mappings in {@code unfiltered} that satisfy a predicate. The\n",
        "2072": "   * returned multimap is a live view of {@code unfiltered}; changes to one affect the other.\n",
        "2074": "   * <p>The resulting multimap's views have iterators that don't support {@code remove()}, but all\n",
        "2075": "   * other methods are supported by the multimap and its views. When adding a key/value pair that\n",
        "2076": "   * doesn't satisfy the predicate, multimap's {@code put()}, {@code putAll()}, and {@code\n",
        "2077": "   * replaceValues()} methods throw an {@link IllegalArgumentException}.\n",
        "2079": "   * <p>When methods such as {@code removeAll()} and {@code clear()} are called on the filtered\n",
        "2080": "   * multimap or its views, only mappings whose keys satisfy the filter will be removed from the\n",
        "2081": "   * underlying multimap.\n",
        "2083": "   * <p>The returned multimap isn't threadsafe or serializable, even if {@code unfiltered} is.\n",
        "2085": "   * <p>Many of the filtered multimap's methods, such as {@code size()}, iterate across every\n",
        "2086": "   * key/value mapping in the underlying multimap and determine which satisfy the filter. When a\n",
        "2087": "   * live view is <i>not</i> needed, it may be faster to copy the filtered multimap and use the\n",
        "2088": "   * copy.\n",
        "2090": "   * <p><b>Warning:</b> {@code entryPredicate} must be <i>consistent with equals</i>, as documented\n",
        "2091": "   * at {@link Predicate#apply}.\n",
        "2104": "   * Support removal operations when filtering a filtered multimap. Since a filtered multimap has\n",
        "2105": "   * iterators that don't support remove, passing one to the FilteredEntryMultimap constructor would\n",
        "2106": "   * lead to a multimap whose removal operations would fail. This method combines the predicates to\n",
        "2107": "   * avoid that problem.\n"
    },
    "removed": {
        "60": " * \"https://github.com/google/guava/wiki/CollectionUtilitiesExplained#multimaps\">\n",
        "61": " * {@code Multimaps}</a>.\n",
        "255": "   * Creates a new {@code ListMultimap} that uses the provided map and factory.\n",
        "256": "   * It can generate a multimap based on arbitrary {@link Map} and {@link List}\n",
        "257": "   * classes.\n",
        "258": "   *\n",
        "259": "   * <p>The {@code factory}-generated and {@code map} classes determine the\n",
        "260": "   * multimap iteration order. They also specify the behavior of the\n",
        "261": "   * {@code equals}, {@code hashCode}, and {@code toString} methods for the\n",
        "262": "   * multimap and its returned views. The multimap's {@code get}, {@code\n",
        "263": "   * removeAll}, and {@code replaceValues} methods return {@code RandomAccess}\n",
        "264": "   * lists if the factory does. However, the multimap's {@code get} method\n",
        "265": "   * returns instances of a different class than does {@code factory.get()}.\n",
        "266": "   *\n",
        "267": "   * <p>The multimap is serializable if {@code map}, {@code factory}, the\n",
        "268": "   * lists generated by {@code factory}, and the multimap contents are all\n",
        "269": "   * serializable.\n",
        "270": "   *\n",
        "271": "   * <p>The multimap is not threadsafe when any concurrent operations update the\n",
        "272": "   * multimap, even if {@code map} and the instances generated by\n",
        "273": "   * {@code factory} are. Concurrent read operations will work correctly. To\n",
        "274": "   * allow concurrent update operations, wrap the multimap with a call to\n",
        "275": "   * {@link #synchronizedListMultimap}.\n",
        "276": "   *\n",
        "277": "   * <p>Call this method only when the simpler methods\n",
        "278": "   * {@link ArrayListMultimap#create()} and {@link LinkedListMultimap#create()}\n",
        "279": "   * won't suffice.\n",
        "280": "   *\n",
        "281": "   * <p>Note: the multimap assumes complete ownership over of {@code map} and\n",
        "282": "   * the lists returned by {@code factory}. Those objects should not be manually\n",
        "283": "   * updated, they should be empty when provided, and they should not use soft,\n",
        "284": "   * weak, or phantom references.\n",
        "286": "   * @param map place to store the mapping from each key to its corresponding\n",
        "287": "   *     values\n",
        "288": "   * @param factory supplier of new, empty lists that will each hold all values\n",
        "289": "   *     for a given key\n",
        "332": "   * Creates a new {@code SetMultimap} that uses the provided map and factory.\n",
        "333": "   * It can generate a multimap based on arbitrary {@link Map} and {@link Set}\n",
        "334": "   * classes.\n",
        "335": "   *\n",
        "336": "   * <p>The {@code factory}-generated and {@code map} classes determine the\n",
        "337": "   * multimap iteration order. They also specify the behavior of the\n",
        "338": "   * {@code equals}, {@code hashCode}, and {@code toString} methods for the\n",
        "339": "   * multimap and its returned views. However, the multimap's {@code get}\n",
        "340": "   * method returns instances of a different class than {@code factory.get()}\n",
        "341": "   * does.\n",
        "342": "   *\n",
        "343": "   * <p>The multimap is serializable if {@code map}, {@code factory}, the\n",
        "344": "   * sets generated by {@code factory}, and the multimap contents are all\n",
        "345": "   * serializable.\n",
        "346": "   *\n",
        "347": "   * <p>The multimap is not threadsafe when any concurrent operations update the\n",
        "348": "   * multimap, even if {@code map} and the instances generated by\n",
        "349": "   * {@code factory} are. Concurrent read operations will work correctly. To\n",
        "350": "   * allow concurrent update operations, wrap the multimap with a call to\n",
        "351": "   * {@link #synchronizedSetMultimap}.\n",
        "352": "   *\n",
        "353": "   * <p>Call this method only when the simpler methods\n",
        "354": "   * {@link HashMultimap#create()}, {@link LinkedHashMultimap#create()},\n",
        "355": "   * {@link TreeMultimap#create()}, and\n",
        "356": "   * {@link TreeMultimap#create(Comparator, Comparator)} won't suffice.\n",
        "357": "   *\n",
        "358": "   * <p>Note: the multimap assumes complete ownership over of {@code map} and\n",
        "359": "   * the sets returned by {@code factory}. Those objects should not be manually\n",
        "360": "   * updated and they should not use soft, weak, or phantom references.\n",
        "361": "   *\n",
        "362": "   * @param map place to store the mapping from each key to its corresponding\n",
        "363": "   *     values\n",
        "364": "   * @param factory supplier of new, empty sets that will each hold all values\n",
        "365": "   *     for a given key\n",
        "408": "   * Creates a new {@code SortedSetMultimap} that uses the provided map and\n",
        "409": "   * factory. It can generate a multimap based on arbitrary {@link Map} and\n",
        "410": "   * {@link SortedSet} classes.\n",
        "411": "   *\n",
        "412": "   * <p>The {@code factory}-generated and {@code map} classes determine the\n",
        "413": "   * multimap iteration order. They also specify the behavior of the\n",
        "414": "   * {@code equals}, {@code hashCode}, and {@code toString} methods for the\n",
        "415": "   * multimap and its returned views. However, the multimap's {@code get}\n",
        "416": "   * method returns instances of a different class than {@code factory.get()}\n",
        "417": "   * does.\n",
        "418": "   *\n",
        "419": "   * <p>The multimap is serializable if {@code map}, {@code factory}, the\n",
        "420": "   * sets generated by {@code factory}, and the multimap contents are all\n",
        "421": "   * serializable.\n",
        "422": "   *\n",
        "423": "   * <p>The multimap is not threadsafe when any concurrent operations update the\n",
        "424": "   * multimap, even if {@code map} and the instances generated by\n",
        "425": "   * {@code factory} are. Concurrent read operations will work correctly. To\n",
        "426": "   * allow concurrent update operations, wrap the multimap with a call to\n",
        "427": "   * {@link #synchronizedSortedSetMultimap}.\n",
        "428": "   *\n",
        "429": "   * <p>Call this method only when the simpler methods\n",
        "430": "   * {@link TreeMultimap#create()} and\n",
        "431": "   * {@link TreeMultimap#create(Comparator, Comparator)} won't suffice.\n",
        "432": "   *\n",
        "433": "   * <p>Note: the multimap assumes complete ownership over of {@code map} and\n",
        "434": "   * the sets returned by {@code factory}. Those objects should not be manually\n",
        "435": "   * updated and they should not use soft, weak, or phantom references.\n",
        "436": "   *\n",
        "437": "   * @param map place to store the mapping from each key to its corresponding\n",
        "438": "   *     values\n",
        "439": "   * @param factory supplier of new, empty sorted sets that will each hold\n",
        "440": "   *     all values for a given key\n",
        "491": "   * Copies each key-value mapping in {@code source} into {@code dest}, with\n",
        "492": "   * its key and value reversed.\n",
        "494": "   * <p>If {@code source} is an {@link ImmutableMultimap}, consider using\n",
        "495": "   * {@link ImmutableMultimap#inverse} instead.\n",
        "512": "   * Returns a synchronized (thread-safe) multimap backed by the specified\n",
        "513": "   * multimap. In order to guarantee serial access, it is critical that\n",
        "514": "   * <b>all</b> access to the backing multimap is accomplished through the\n",
        "515": "   * returned multimap.\n",
        "516": "   *\n",
        "517": "   * <p>It is imperative that the user manually synchronize on the returned\n",
        "518": "   * multimap when accessing any of its collection views: <pre>   {@code\n",
        "519": "   *\n",
        "520": "   *   Multimap<K, V> multimap = Multimaps.synchronizedMultimap(\n",
        "521": "   *       HashMultimap.<K, V>create());\n",
        "522": "   *   ...\n",
        "523": "   *   Collection<V> values = multimap.get(key);  // Needn't be in synchronized block\n",
        "524": "   *   ...\n",
        "525": "   *   synchronized (multimap) {  // Synchronizing on multimap, not values!\n",
        "526": "   *     Iterator<V> i = values.iterator(); // Must be in synchronized block\n",
        "527": "   *     while (i.hasNext()) {\n",
        "528": "   *       foo(i.next());\n",
        "529": "   *     }\n",
        "530": "   *   }}</pre>\n",
        "534": "   * <p>Note that the generated multimap's {@link Multimap#removeAll} and\n",
        "535": "   * {@link Multimap#replaceValues} methods return collections that aren't\n",
        "536": "   * synchronized.\n",
        "538": "   * <p>The returned multimap will be serializable if the specified multimap is\n",
        "539": "   * serializable.\n",
        "549": "   * Returns an unmodifiable view of the specified multimap. Query operations on\n",
        "550": "   * the returned multimap \"read through\" to the specified multimap, and\n",
        "551": "   * attempts to modify the returned multimap, either directly or through the\n",
        "552": "   * multimap's views, result in an {@code UnsupportedOperationException}.\n",
        "554": "   * <p>Note that the generated multimap's {@link Multimap#removeAll} and\n",
        "555": "   * {@link Multimap#replaceValues} methods return collections that are\n",
        "556": "   * modifiable.\n",
        "558": "   * <p>The returned multimap will be serializable if the specified multimap is\n",
        "559": "   * serializable.\n",
        "561": "   * @param delegate the multimap for which an unmodifiable view is to be\n",
        "562": "   *     returned\n",
        "801": "   * Returns a synchronized (thread-safe) {@code SetMultimap} backed by the\n",
        "802": "   * specified multimap.\n",
        "806": "   * <p>The returned multimap will be serializable if the specified multimap is\n",
        "807": "   * serializable.\n",
        "817": "   * Returns an unmodifiable view of the specified {@code SetMultimap}. Query\n",
        "818": "   * operations on the returned multimap \"read through\" to the specified\n",
        "819": "   * multimap, and attempts to modify the returned multimap, either directly or\n",
        "820": "   * through the multimap's views, result in an\n",
        "821": "   * {@code UnsupportedOperationException}.\n",
        "823": "   * <p>Note that the generated multimap's {@link Multimap#removeAll} and\n",
        "824": "   * {@link Multimap#replaceValues} methods return collections that are\n",
        "825": "   * modifiable.\n",
        "827": "   * <p>The returned multimap will be serializable if the specified multimap is\n",
        "828": "   * serializable.\n",
        "830": "   * @param delegate the multimap for which an unmodifiable view is to be\n",
        "831": "   *     returned\n",
        "854": "   * Returns a synchronized (thread-safe) {@code SortedSetMultimap} backed by\n",
        "855": "   * the specified multimap.\n",
        "859": "   * <p>The returned multimap will be serializable if the specified multimap is\n",
        "860": "   * serializable.\n",
        "871": "   * Returns an unmodifiable view of the specified {@code SortedSetMultimap}.\n",
        "872": "   * Query operations on the returned multimap \"read through\" to the specified\n",
        "873": "   * multimap, and attempts to modify the returned multimap, either directly or\n",
        "874": "   * through the multimap's views, result in an\n",
        "875": "   * {@code UnsupportedOperationException}.\n",
        "877": "   * <p>Note that the generated multimap's {@link Multimap#removeAll} and\n",
        "878": "   * {@link Multimap#replaceValues} methods return collections that are\n",
        "879": "   * modifiable.\n",
        "881": "   * <p>The returned multimap will be serializable if the specified multimap is\n",
        "882": "   * serializable.\n",
        "884": "   * @param delegate the multimap for which an unmodifiable view is to be\n",
        "885": "   *     returned\n",
        "897": "   * Returns a synchronized (thread-safe) {@code ListMultimap} backed by the\n",
        "898": "   * specified multimap.\n",
        "910": "   * Returns an unmodifiable view of the specified {@code ListMultimap}. Query\n",
        "911": "   * operations on the returned multimap \"read through\" to the specified\n",
        "912": "   * multimap, and attempts to modify the returned multimap, either directly or\n",
        "913": "   * through the multimap's views, result in an\n",
        "914": "   * {@code UnsupportedOperationException}.\n",
        "916": "   * <p>Note that the generated multimap's {@link Multimap#removeAll} and\n",
        "917": "   * {@link Multimap#replaceValues} methods return collections that are\n",
        "918": "   * modifiable.\n",
        "920": "   * <p>The returned multimap will be serializable if the specified multimap is\n",
        "921": "   * serializable.\n",
        "923": "   * @param delegate the multimap for which an unmodifiable view is to be\n",
        "924": "   *     returned\n",
        "947": "   * Returns an unmodifiable view of the specified collection, preserving the\n",
        "948": "   * interface for instances of {@code SortedSet}, {@code Set}, {@code List} and\n",
        "949": "   * {@code Collection}, in that order of preference.\n",
        "966": "   * Returns an unmodifiable view of the specified collection of entries. The\n",
        "967": "   * {@link Entry#setValue} operation throws an {@link\n",
        "968": "   * UnsupportedOperationException}. If the specified collection is a {@code\n",
        "969": "   * Set}, the returned collection is also a {@code Set}.\n",
        "983": "   * Returns {@link ListMultimap#asMap multimap.asMap()}, with its type\n",
        "984": "   * corrected from {@code Map<K, Collection<V>>} to {@code Map<K, List<V>>}.\n",
        "996": "   * Returns {@link SetMultimap#asMap multimap.asMap()}, with its type corrected\n",
        "997": "   * from {@code Map<K, Collection<V>>} to {@code Map<K, Set<V>>}.\n",
        "1009": "   * Returns {@link SortedSetMultimap#asMap multimap.asMap()}, with its type\n",
        "1010": "   * corrected from {@code Map<K, Collection<V>>} to\n",
        "1011": "   * {@code Map<K, SortedSet<V>>}.\n",
        "1023": "   * Returns {@link Multimap#asMap multimap.asMap()}. This is provided for\n",
        "1024": "   * parity with the other more strongly-typed {@code asMap()} implementations.\n",
        "1034": "   * Returns a multimap view of the specified map. The multimap is backed by the\n",
        "1035": "   * map, so changes to the map are reflected in the multimap, and vice versa.\n",
        "1036": "   * If the map is modified while an iteration over one of the multimap's\n",
        "1037": "   * collection views is in progress (except through the iterator's own {@code\n",
        "1038": "   * remove} operation, or through the {@code setValue} operation on a map entry\n",
        "1039": "   * returned by the iterator), the results of the iteration are undefined.\n",
        "1041": "   * <p>The multimap supports mapping removal, which removes the corresponding\n",
        "1042": "   * mapping from the map. It does not support any operations which might add\n",
        "1043": "   * mappings, such as {@code put}, {@code putAll} or {@code replaceValues}.\n",
        "1045": "   * <p>The returned multimap will be serializable if the specified map is\n",
        "1046": "   * serializable.\n",
        "1195": "   * Returns a view of a multimap where each value is transformed by a function.\n",
        "1196": "   * All other properties of the multimap, such as iteration order, are left\n",
        "1197": "   * intact. For example, the code: <pre>   {@code\n",
        "1208": "   *   System.out.println(transformed);}</pre>\n",
        "1212": "   * <p>Changes in the underlying multimap are reflected in this view.\n",
        "1213": "   * Conversely, this view supports removal operations, and these are reflected\n",
        "1214": "   * in the underlying multimap.\n",
        "1215": "   *\n",
        "1216": "   * <p>It's acceptable for the underlying multimap to contain null keys, and\n",
        "1217": "   * even null values provided that the function is capable of accepting null\n",
        "1218": "   * input.  The transformed multimap might contain null values, if the function\n",
        "1219": "   * sometimes gives a null result.\n",
        "1220": "   *\n",
        "1221": "   * <p>The returned multimap is not thread-safe or serializable, even if the\n",
        "1222": "   * underlying multimap is.  The {@code equals} and {@code hashCode} methods\n",
        "1223": "   * of the returned multimap are meaningless, since there is not a definition\n",
        "1224": "   * of {@code equals} or {@code hashCode} for general collections, and\n",
        "1225": "   * {@code get()} will return a general {@code Collection} as opposed to a\n",
        "1226": "   * {@code List} or a {@code Set}.\n",
        "1227": "   *\n",
        "1228": "   * <p>The function is applied lazily, invoked when needed. This is necessary\n",
        "1229": "   * for the returned multimap to be a view, but it means that the function will\n",
        "1230": "   * be applied many times for bulk operations like\n",
        "1231": "   * {@link Multimap#containsValue} and {@code Multimap.toString()}. For this to\n",
        "1232": "   * perform well, {@code function} should be fast. To avoid lazy evaluation\n",
        "1233": "   * when the returned multimap doesn't need to be a view, copy the returned\n",
        "1234": "   * multimap into a new multimap of your choosing.\n",
        "1246": "   * Returns a view of a multimap whose values are derived from the original\n",
        "1247": "   * multimap's entries. In contrast to {@link #transformValues}, this method's\n",
        "1248": "   * entry-transformation logic may depend on the key as well as the value.\n",
        "1250": "   * <p>All other properties of the transformed multimap, such as iteration\n",
        "1251": "   * order, are left intact. For example, the code: <pre>   {@code\n",
        "1252": "   *\n",
        "1253": "   *   SetMultimap<String, Integer> multimap =\n",
        "1254": "   *       ImmutableSetMultimap.of(\"a\", 1, \"a\", 4, \"b\", -6);\n",
        "1255": "   *   EntryTransformer<String, Integer, String> transformer =\n",
        "1256": "   *       new EntryTransformer<String, Integer, String>() {\n",
        "1257": "   *         public String transformEntry(String key, Integer value) {\n",
        "1258": "   *            return (value >= 0) ? key : \"no\" + key;\n",
        "1259": "   *         }\n",
        "1260": "   *       };\n",
        "1261": "   *   Multimap<String, String> transformed =\n",
        "1262": "   *       Multimaps.transformEntries(multimap, transformer);\n",
        "1263": "   *   System.out.println(transformed);}</pre>\n",
        "1267": "   * <p>Changes in the underlying multimap are reflected in this view.\n",
        "1268": "   * Conversely, this view supports removal operations, and these are reflected\n",
        "1269": "   * in the underlying multimap.\n",
        "1270": "   *\n",
        "1271": "   * <p>It's acceptable for the underlying multimap to contain null keys and\n",
        "1272": "   * null values provided that the transformer is capable of accepting null\n",
        "1273": "   * inputs. The transformed multimap might contain null values if the\n",
        "1274": "   * transformer sometimes gives a null result.\n",
        "1275": "   *\n",
        "1276": "   * <p>The returned multimap is not thread-safe or serializable, even if the\n",
        "1277": "   * underlying multimap is.  The {@code equals} and {@code hashCode} methods\n",
        "1278": "   * of the returned multimap are meaningless, since there is not a definition\n",
        "1279": "   * of {@code equals} or {@code hashCode} for general collections, and\n",
        "1280": "   * {@code get()} will return a general {@code Collection} as opposed to a\n",
        "1281": "   * {@code List} or a {@code Set}.\n",
        "1282": "   *\n",
        "1283": "   * <p>The transformer is applied lazily, invoked when needed. This is\n",
        "1284": "   * necessary for the returned multimap to be a view, but it means that the\n",
        "1285": "   * transformer will be applied many times for bulk operations like {@link\n",
        "1286": "   * Multimap#containsValue} and {@link Object#toString}. For this to perform\n",
        "1287": "   * well, {@code transformer} should be fast. To avoid lazy evaluation when the\n",
        "1288": "   * returned multimap doesn't need to be a view, copy the returned multimap\n",
        "1289": "   * into a new multimap of your choosing.\n",
        "1290": "   *\n",
        "1291": "   * <p><b>Warning:</b> This method assumes that for any instance {@code k} of\n",
        "1292": "   * {@code EntryTransformer} key type {@code K}, {@code k.equals(k2)} implies\n",
        "1293": "   * that {@code k2} is also of type {@code K}. Using an {@code\n",
        "1294": "   * EntryTransformer} key type for which this may not hold, such as {@code\n",
        "1295": "   * ArrayList}, may risk a {@code ClassCastException} when calling methods on\n",
        "1296": "   * the transformed multimap.\n",
        "1418": "   * Returns a view of a {@code ListMultimap} where each value is transformed by\n",
        "1419": "   * a function. All other properties of the multimap, such as iteration order,\n",
        "1420": "   * are left intact. For example, the code: <pre>   {@code\n",
        "1421": "   *\n",
        "1422": "   *   ListMultimap<String, Integer> multimap\n",
        "1423": "   *        = ImmutableListMultimap.of(\"a\", 4, \"a\", 16, \"b\", 9);\n",
        "1424": "   *   Function<Integer, Double> sqrt =\n",
        "1425": "   *       new Function<Integer, Double>() {\n",
        "1426": "   *         public Double apply(Integer in) {\n",
        "1427": "   *           return Math.sqrt((int) in);\n",
        "1428": "   *         }\n",
        "1429": "   *       };\n",
        "1430": "   *   ListMultimap<String, Double> transformed = Multimaps.transformValues(map,\n",
        "1431": "   *       sqrt);\n",
        "1432": "   *   System.out.println(transformed);}</pre>\n",
        "1436": "   * <p>Changes in the underlying multimap are reflected in this view.\n",
        "1437": "   * Conversely, this view supports removal operations, and these are reflected\n",
        "1438": "   * in the underlying multimap.\n",
        "1440": "   * <p>It's acceptable for the underlying multimap to contain null keys, and\n",
        "1441": "   * even null values provided that the function is capable of accepting null\n",
        "1442": "   * input.  The transformed multimap might contain null values, if the function\n",
        "1443": "   * sometimes gives a null result.\n",
        "1445": "   * <p>The returned multimap is not thread-safe or serializable, even if the\n",
        "1446": "   * underlying multimap is.\n",
        "1448": "   * <p>The function is applied lazily, invoked when needed. This is necessary\n",
        "1449": "   * for the returned multimap to be a view, but it means that the function will\n",
        "1450": "   * be applied many times for bulk operations like\n",
        "1451": "   * {@link Multimap#containsValue} and {@code Multimap.toString()}. For this to\n",
        "1452": "   * perform well, {@code function} should be fast. To avoid lazy evaluation\n",
        "1453": "   * when the returned multimap doesn't need to be a view, copy the returned\n",
        "1454": "   * multimap into a new multimap of your choosing.\n",
        "1466": "   * Returns a view of a {@code ListMultimap} whose values are derived from the\n",
        "1467": "   * original multimap's entries. In contrast to\n",
        "1468": "   * {@link #transformValues(ListMultimap, Function)}, this method's\n",
        "1471": "   * <p>All other properties of the transformed multimap, such as iteration\n",
        "1472": "   * order, are left intact. For example, the code: <pre>   {@code\n",
        "1473": "   *\n",
        "1474": "   *   Multimap<String, Integer> multimap =\n",
        "1475": "   *       ImmutableMultimap.of(\"a\", 1, \"a\", 4, \"b\", 6);\n",
        "1476": "   *   EntryTransformer<String, Integer, String> transformer =\n",
        "1477": "   *       new EntryTransformer<String, Integer, String>() {\n",
        "1478": "   *         public String transformEntry(String key, Integer value) {\n",
        "1479": "   *           return key + value;\n",
        "1480": "   *         }\n",
        "1481": "   *       };\n",
        "1482": "   *   Multimap<String, String> transformed =\n",
        "1483": "   *       Multimaps.transformEntries(multimap, transformer);\n",
        "1484": "   *   System.out.println(transformed);}</pre>\n",
        "1488": "   * <p>Changes in the underlying multimap are reflected in this view.\n",
        "1489": "   * Conversely, this view supports removal operations, and these are reflected\n",
        "1490": "   * in the underlying multimap.\n",
        "1491": "   *\n",
        "1492": "   * <p>It's acceptable for the underlying multimap to contain null keys and\n",
        "1493": "   * null values provided that the transformer is capable of accepting null\n",
        "1494": "   * inputs. The transformed multimap might contain null values if the\n",
        "1495": "   * transformer sometimes gives a null result.\n",
        "1496": "   *\n",
        "1497": "   * <p>The returned multimap is not thread-safe or serializable, even if the\n",
        "1498": "   * underlying multimap is.\n",
        "1499": "   *\n",
        "1500": "   * <p>The transformer is applied lazily, invoked when needed. This is\n",
        "1501": "   * necessary for the returned multimap to be a view, but it means that the\n",
        "1502": "   * transformer will be applied many times for bulk operations like {@link\n",
        "1503": "   * Multimap#containsValue} and {@link Object#toString}. For this to perform\n",
        "1504": "   * well, {@code transformer} should be fast. To avoid lazy evaluation when the\n",
        "1505": "   * returned multimap doesn't need to be a view, copy the returned multimap\n",
        "1506": "   * into a new multimap of your choosing.\n",
        "1507": "   *\n",
        "1508": "   * <p><b>Warning:</b> This method assumes that for any instance {@code k} of\n",
        "1509": "   * {@code EntryTransformer} key type {@code K}, {@code k.equals(k2)} implies\n",
        "1510": "   * that {@code k2} is also of type {@code K}. Using an {@code\n",
        "1511": "   * EntryTransformer} key type for which this may not hold, such as {@code\n",
        "1512": "   * ArrayList}, may risk a {@code ClassCastException} when calling methods on\n",
        "1513": "   * the transformed multimap.\n",
        "1553": "   * Creates an index {@code ImmutableListMultimap} that contains the results of\n",
        "1554": "   * applying a specified function to each item in an {@code Iterable} of\n",
        "1555": "   * values. Each value will be stored as a value in the resulting multimap,\n",
        "1556": "   * yielding a multimap with the same size as the input iterable. The key used\n",
        "1557": "   * to store that value in the multimap will be the result of calling the\n",
        "1558": "   * function on that value. The resulting multimap is created as an immutable\n",
        "1559": "   * snapshot. In the returned multimap, keys appear in the order they are first\n",
        "1560": "   * encountered, and the values corresponding to each key appear in the same\n",
        "1561": "   * order as they are encountered.\n",
        "1562": "   *\n",
        "1563": "   * <p>For example, <pre>   {@code\n",
        "1564": "   *\n",
        "1565": "   *   List<String> badGuys =\n",
        "1566": "   *       Arrays.asList(\"Inky\", \"Blinky\", \"Pinky\", \"Pinky\", \"Clyde\");\n",
        "1567": "   *   Function<String, Integer> stringLengthFunction = ...;\n",
        "1568": "   *   Multimap<Integer, String> index =\n",
        "1569": "   *       Multimaps.index(badGuys, stringLengthFunction);\n",
        "1570": "   *   System.out.println(index);}</pre>\n",
        "1571": "   *\n",
        "1572": "   * <p>prints <pre>   {@code\n",
        "1573": "   *\n",
        "1574": "   *   {4=[Inky], 6=[Blinky], 5=[Pinky, Pinky, Clyde]}}</pre>\n",
        "1575": "   *\n",
        "1576": "   * <p>The returned multimap is serializable if its keys and values are all\n",
        "1577": "   * serializable.\n",
        "1578": "   *\n",
        "1579": "   * @param values the values to use when constructing the {@code\n",
        "1580": "   *     ImmutableListMultimap}\n",
        "1582": "   * @return {@code ImmutableListMultimap} mapping the result of evaluating the\n",
        "1583": "   *     function {@code keyFunction} on each value in the input collection to\n",
        "1584": "   *     that value\n",
        "1594": "   * Creates an index {@code ImmutableListMultimap} that contains the results of\n",
        "1595": "   * applying a specified function to each item in an {@code Iterator} of\n",
        "1596": "   * values. Each value will be stored as a value in the resulting multimap,\n",
        "1597": "   * yielding a multimap with the same size as the input iterator. The key used\n",
        "1598": "   * to store that value in the multimap will be the result of calling the\n",
        "1599": "   * function on that value. The resulting multimap is created as an immutable\n",
        "1600": "   * snapshot. In the returned multimap, keys appear in the order they are first\n",
        "1601": "   * encountered, and the values corresponding to each key appear in the same\n",
        "1602": "   * order as they are encountered.\n",
        "1603": "   *\n",
        "1604": "   * <p>For example, <pre>   {@code\n",
        "1605": "   *\n",
        "1606": "   *   List<String> badGuys =\n",
        "1607": "   *       Arrays.asList(\"Inky\", \"Blinky\", \"Pinky\", \"Pinky\", \"Clyde\");\n",
        "1608": "   *   Function<String, Integer> stringLengthFunction = ...;\n",
        "1609": "   *   Multimap<Integer, String> index =\n",
        "1610": "   *       Multimaps.index(badGuys.iterator(), stringLengthFunction);\n",
        "1611": "   *   System.out.println(index);}</pre>\n",
        "1612": "   *\n",
        "1613": "   * <p>prints <pre>   {@code\n",
        "1614": "   *\n",
        "1615": "   *   {4=[Inky], 6=[Blinky], 5=[Pinky, Pinky, Clyde]}}</pre>\n",
        "1616": "   *\n",
        "1617": "   * <p>The returned multimap is serializable if its keys and values are all\n",
        "1618": "   * serializable.\n",
        "1619": "   *\n",
        "1620": "   * @param values the values to use when constructing the {@code\n",
        "1621": "   *     ImmutableListMultimap}\n",
        "1623": "   * @return {@code ImmutableListMultimap} mapping the result of evaluating the\n",
        "1624": "   *     function {@code keyFunction} on each value in the input collection to\n",
        "1625": "   *     that value\n",
        "1790": "  /**\n",
        "1791": "   * A skeleton implementation of {@link Multimap#entries()}.\n",
        "1792": "   */\n",
        "1825": "  /**\n",
        "1826": "   * A skeleton implementation of {@link Multimap#asMap()}.\n",
        "1827": "   */\n",
        "1912": "   * Returns a multimap containing the mappings in {@code unfiltered} whose keys\n",
        "1913": "   * satisfy a predicate. The returned multimap is a live view of\n",
        "1914": "   * {@code unfiltered}; changes to one affect the other.\n",
        "1916": "   * <p>The resulting multimap's views have iterators that don't support\n",
        "1917": "   * {@code remove()}, but all other methods are supported by the multimap and\n",
        "1918": "   * its views. When adding a key that doesn't satisfy the predicate, the\n",
        "1919": "   * multimap's {@code put()}, {@code putAll()}, and {@code replaceValues()}\n",
        "1920": "   * methods throw an {@link IllegalArgumentException}.\n",
        "1922": "   * <p>When methods such as {@code removeAll()} and {@code clear()} are called on\n",
        "1923": "   * the filtered multimap or its views, only mappings whose keys satisfy the\n",
        "1924": "   * filter will be removed from the underlying multimap.\n",
        "1926": "   * <p>The returned multimap isn't threadsafe or serializable, even if\n",
        "1927": "   * {@code unfiltered} is.\n",
        "1929": "   * <p>Many of the filtered multimap's methods, such as {@code size()}, iterate\n",
        "1930": "   * across every key/value mapping in the underlying multimap and determine\n",
        "1931": "   * which satisfy the filter. When a live view is <i>not</i> needed, it may be\n",
        "1932": "   * faster to copy the filtered multimap and use the copy.\n",
        "1934": "   * <p><b>Warning:</b> {@code keyPredicate} must be <i>consistent with equals</i>,\n",
        "1935": "   * as documented at {@link Predicate#apply}. Do not provide a predicate such\n",
        "1936": "   * as {@code Predicates.instanceOf(ArrayList.class)}, which is inconsistent\n",
        "1937": "   * with equals.\n",
        "1960": "   * Returns a multimap containing the mappings in {@code unfiltered} whose keys\n",
        "1961": "   * satisfy a predicate. The returned multimap is a live view of\n",
        "1962": "   * {@code unfiltered}; changes to one affect the other.\n",
        "1964": "   * <p>The resulting multimap's views have iterators that don't support\n",
        "1965": "   * {@code remove()}, but all other methods are supported by the multimap and\n",
        "1966": "   * its views. When adding a key that doesn't satisfy the predicate, the\n",
        "1967": "   * multimap's {@code put()}, {@code putAll()}, and {@code replaceValues()}\n",
        "1968": "   * methods throw an {@link IllegalArgumentException}.\n",
        "1970": "   * <p>When methods such as {@code removeAll()} and {@code clear()} are called on\n",
        "1971": "   * the filtered multimap or its views, only mappings whose keys satisfy the\n",
        "1972": "   * filter will be removed from the underlying multimap.\n",
        "1974": "   * <p>The returned multimap isn't threadsafe or serializable, even if\n",
        "1975": "   * {@code unfiltered} is.\n",
        "1977": "   * <p>Many of the filtered multimap's methods, such as {@code size()}, iterate\n",
        "1978": "   * across every key/value mapping in the underlying multimap and determine\n",
        "1979": "   * which satisfy the filter. When a live view is <i>not</i> needed, it may be\n",
        "1980": "   * faster to copy the filtered multimap and use the copy.\n",
        "1982": "   * <p><b>Warning:</b> {@code keyPredicate} must be <i>consistent with equals</i>,\n",
        "1983": "   * as documented at {@link Predicate#apply}. Do not provide a predicate such\n",
        "1984": "   * as {@code Predicates.instanceOf(ArrayList.class)}, which is inconsistent\n",
        "1985": "   * with equals.\n",
        "2004": "   * Returns a multimap containing the mappings in {@code unfiltered} whose keys\n",
        "2005": "   * satisfy a predicate. The returned multimap is a live view of\n",
        "2006": "   * {@code unfiltered}; changes to one affect the other.\n",
        "2008": "   * <p>The resulting multimap's views have iterators that don't support\n",
        "2009": "   * {@code remove()}, but all other methods are supported by the multimap and\n",
        "2010": "   * its views. When adding a key that doesn't satisfy the predicate, the\n",
        "2011": "   * multimap's {@code put()}, {@code putAll()}, and {@code replaceValues()}\n",
        "2012": "   * methods throw an {@link IllegalArgumentException}.\n",
        "2014": "   * <p>When methods such as {@code removeAll()} and {@code clear()} are called on\n",
        "2015": "   * the filtered multimap or its views, only mappings whose keys satisfy the\n",
        "2016": "   * filter will be removed from the underlying multimap.\n",
        "2018": "   * <p>The returned multimap isn't threadsafe or serializable, even if\n",
        "2019": "   * {@code unfiltered} is.\n",
        "2021": "   * <p>Many of the filtered multimap's methods, such as {@code size()}, iterate\n",
        "2022": "   * across every key/value mapping in the underlying multimap and determine\n",
        "2023": "   * which satisfy the filter. When a live view is <i>not</i> needed, it may be\n",
        "2024": "   * faster to copy the filtered multimap and use the copy.\n",
        "2026": "   * <p><b>Warning:</b> {@code keyPredicate} must be <i>consistent with equals</i>,\n",
        "2027": "   * as documented at {@link Predicate#apply}. Do not provide a predicate such\n",
        "2028": "   * as {@code Predicates.instanceOf(ArrayList.class)}, which is inconsistent\n",
        "2029": "   * with equals.\n",
        "2045": "   * Returns a multimap containing the mappings in {@code unfiltered} whose values\n",
        "2046": "   * satisfy a predicate. The returned multimap is a live view of\n",
        "2047": "   * {@code unfiltered}; changes to one affect the other.\n",
        "2049": "   * <p>The resulting multimap's views have iterators that don't support\n",
        "2050": "   * {@code remove()}, but all other methods are supported by the multimap and\n",
        "2051": "   * its views. When adding a value that doesn't satisfy the predicate, the\n",
        "2052": "   * multimap's {@code put()}, {@code putAll()}, and {@code replaceValues()}\n",
        "2053": "   * methods throw an {@link IllegalArgumentException}.\n",
        "2055": "   * <p>When methods such as {@code removeAll()} and {@code clear()} are called on\n",
        "2056": "   * the filtered multimap or its views, only mappings whose value satisfy the\n",
        "2057": "   * filter will be removed from the underlying multimap.\n",
        "2059": "   * <p>The returned multimap isn't threadsafe or serializable, even if\n",
        "2060": "   * {@code unfiltered} is.\n",
        "2062": "   * <p>Many of the filtered multimap's methods, such as {@code size()}, iterate\n",
        "2063": "   * across every key/value mapping in the underlying multimap and determine\n",
        "2064": "   * which satisfy the filter. When a live view is <i>not</i> needed, it may be\n",
        "2065": "   * faster to copy the filtered multimap and use the copy.\n",
        "2067": "   * <p><b>Warning:</b> {@code valuePredicate} must be <i>consistent with\n",
        "2068": "   * equals</i>, as documented at {@link Predicate#apply}. Do not provide a\n",
        "2069": "   * predicate such as {@code Predicates.instanceOf(ArrayList.class)}, which is\n",
        "2070": "   * inconsistent with equals.\n",
        "2080": "   * Returns a multimap containing the mappings in {@code unfiltered} whose values\n",
        "2081": "   * satisfy a predicate. The returned multimap is a live view of\n",
        "2082": "   * {@code unfiltered}; changes to one affect the other.\n",
        "2084": "   * <p>The resulting multimap's views have iterators that don't support\n",
        "2085": "   * {@code remove()}, but all other methods are supported by the multimap and\n",
        "2086": "   * its views. When adding a value that doesn't satisfy the predicate, the\n",
        "2087": "   * multimap's {@code put()}, {@code putAll()}, and {@code replaceValues()}\n",
        "2088": "   * methods throw an {@link IllegalArgumentException}.\n",
        "2090": "   * <p>When methods such as {@code removeAll()} and {@code clear()} are called on\n",
        "2091": "   * the filtered multimap or its views, only mappings whose value satisfy the\n",
        "2092": "   * filter will be removed from the underlying multimap.\n",
        "2094": "   * <p>The returned multimap isn't threadsafe or serializable, even if\n",
        "2095": "   * {@code unfiltered} is.\n",
        "2097": "   * <p>Many of the filtered multimap's methods, such as {@code size()}, iterate\n",
        "2098": "   * across every key/value mapping in the underlying multimap and determine\n",
        "2099": "   * which satisfy the filter. When a live view is <i>not</i> needed, it may be\n",
        "2100": "   * faster to copy the filtered multimap and use the copy.\n",
        "2102": "   * <p><b>Warning:</b> {@code valuePredicate} must be <i>consistent with\n",
        "2103": "   * equals</i>, as documented at {@link Predicate#apply}. Do not provide a\n",
        "2104": "   * predicate such as {@code Predicates.instanceOf(ArrayList.class)}, which is\n",
        "2105": "   * inconsistent with equals.\n",
        "2115": "   * Returns a multimap containing the mappings in {@code unfiltered} that\n",
        "2116": "   * satisfy a predicate. The returned multimap is a live view of\n",
        "2117": "   * {@code unfiltered}; changes to one affect the other.\n",
        "2119": "   * <p>The resulting multimap's views have iterators that don't support\n",
        "2120": "   * {@code remove()}, but all other methods are supported by the multimap and\n",
        "2121": "   * its views. When adding a key/value pair that doesn't satisfy the predicate,\n",
        "2122": "   * multimap's {@code put()}, {@code putAll()}, and {@code replaceValues()}\n",
        "2123": "   * methods throw an {@link IllegalArgumentException}.\n",
        "2125": "   * <p>When methods such as {@code removeAll()} and {@code clear()} are called on\n",
        "2126": "   * the filtered multimap or its views, only mappings whose keys satisfy the\n",
        "2127": "   * filter will be removed from the underlying multimap.\n",
        "2129": "   * <p>The returned multimap isn't threadsafe or serializable, even if\n",
        "2130": "   * {@code unfiltered} is.\n",
        "2132": "   * <p>Many of the filtered multimap's methods, such as {@code size()}, iterate\n",
        "2133": "   * across every key/value mapping in the underlying multimap and determine\n",
        "2134": "   * which satisfy the filter. When a live view is <i>not</i> needed, it may be\n",
        "2135": "   * faster to copy the filtered multimap and use the copy.\n",
        "2137": "   * <p><b>Warning:</b> {@code entryPredicate} must be <i>consistent with\n",
        "2138": "   * equals</i>, as documented at {@link Predicate#apply}.\n",
        "2154": "   * Returns a multimap containing the mappings in {@code unfiltered} that\n",
        "2155": "   * satisfy a predicate. The returned multimap is a live view of\n",
        "2156": "   * {@code unfiltered}; changes to one affect the other.\n",
        "2158": "   * <p>The resulting multimap's views have iterators that don't support\n",
        "2159": "   * {@code remove()}, but all other methods are supported by the multimap and\n",
        "2160": "   * its views. When adding a key/value pair that doesn't satisfy the predicate,\n",
        "2161": "   * multimap's {@code put()}, {@code putAll()}, and {@code replaceValues()}\n",
        "2162": "   * methods throw an {@link IllegalArgumentException}.\n",
        "2164": "   * <p>When methods such as {@code removeAll()} and {@code clear()} are called on\n",
        "2165": "   * the filtered multimap or its views, only mappings whose keys satisfy the\n",
        "2166": "   * filter will be removed from the underlying multimap.\n",
        "2168": "   * <p>The returned multimap isn't threadsafe or serializable, even if\n",
        "2169": "   * {@code unfiltered} is.\n",
        "2171": "   * <p>Many of the filtered multimap's methods, such as {@code size()}, iterate\n",
        "2172": "   * across every key/value mapping in the underlying multimap and determine\n",
        "2173": "   * which satisfy the filter. When a live view is <i>not</i> needed, it may be\n",
        "2174": "   * faster to copy the filtered multimap and use the copy.\n",
        "2176": "   * <p><b>Warning:</b> {@code entryPredicate} must be <i>consistent with\n",
        "2177": "   * equals</i>, as documented at {@link Predicate#apply}.\n",
        "2190": "   * Support removal operations when filtering a filtered multimap. Since a\n",
        "2191": "   * filtered multimap has iterators that don't support remove, passing one to\n",
        "2192": "   * the FilteredEntryMultimap constructor would lead to a multimap whose removal\n",
        "2193": "   * operations would fail. This method combines the predicates to avoid that\n",
        "2194": "   * problem.\n"
    }
}