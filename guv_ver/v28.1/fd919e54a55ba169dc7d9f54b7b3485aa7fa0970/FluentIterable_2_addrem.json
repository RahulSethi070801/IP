{
    "addition": {
        "42": " *   <li>chaining methods which return a new {@code FluentIterable} based in some way on the\n",
        "43": " *       contents of the current one (for example {@link #transform})\n",
        "44": " *   <li>element extraction methods which facilitate the retrieval of certain elements (for example\n",
        "45": " *       {@link #last})\n",
        "46": " *   <li>query methods which answer questions about the {@code FluentIterable}'s contents (for\n",
        "47": " *       example {@link #anyMatch})\n",
        "48": " *   <li>conversion methods which copy the {@code FluentIterable}'s contents into a new collection\n",
        "49": " *       or array (for example {@link #toList})\n",
        "55": " * <p><a name=\"streams\"></a>\n",
        "56": " *\n",
        "63": " *   <li>A stream is <i>single-use</i>; it becomes invalid as soon as any \"terminal operation\" such\n",
        "64": " *       as {@code findFirst()} or {@code iterator()} is invoked. (Even though {@code Stream}\n",
        "65": " *       contains all the right method <i>signatures</i> to implement {@link Iterable}, it does not\n",
        "66": " *       actually do so, to avoid implying repeat-iterability.) {@code FluentIterable}, on the other\n",
        "67": " *       hand, is multiple-use, and does implement {@link Iterable}.\n",
        "68": " *   <li>Streams offer many features not found here, including {@code min/max}, {@code distinct},\n",
        "69": " *       {@code reduce}, {@code sorted}, the very powerful {@code collect}, and built-in support for\n",
        "70": " *       parallelizing stream operations.\n",
        "71": " *   <li>{@code FluentIterable} contains several features not available on {@code Stream}, which are\n",
        "72": " *       noted in the method descriptions below.\n",
        "73": " *   <li>Streams include primitive-specialized variants such as {@code IntStream}, the use of which\n",
        "74": " *       is strongly recommended.\n",
        "75": " *   <li>Streams are standard Java, not requiring a third-party dependency.\n",
        "135": "   * <p><b>{@code Stream} equivalent:</b> {@link Collection#stream} if {@code iterable} is a {@link\n",
        "136": "   * Collection}; {@link Streams#stream(Iterable)} otherwise.\n",
        "166": "   * but is intended to help call out cases where one migration from {@code Iterable} to {@code\n",
        "167": "   * FluentIterable} has obviated the need to explicitly convert to a {@code FluentIterable}.\n",
        "169": "   * @deprecated instances of {@code FluentIterable} don't need to be converted to {@code\n",
        "170": "   *     FluentIterable}\n",
        "350": "   * Returns {@code true} if this fluent iterable contains any object for which {@code\n",
        "351": "   * equals(target)} is true.\n",
        "363": "   * <p>That iterator supports {@code remove()} if {@code iterable.iterator()} does. After {@code\n",
        "364": "   * remove()} is called, subsequent cycles omit the removed element, which is no longer in this\n",
        "365": "   * fluent iterable. The iterator's {@code hasNext()} method returns {@code true} until this fluent\n",
        "366": "   * iterable is empty.\n",
        "518": "   * iterable is empty, {@code Optional.absent()} is returned. If the underlying {@code iterable} is\n",
        "519": "   * a {@link List} with {@link java.util.RandomAccess} support, then this operation is guaranteed\n",
        "520": "   * to be {@code O(1)}.\n",
        "524": "   * @throws NullPointerException if the last element is null; if this is a possibility, use {@link\n",
        "525": "   *     Iterables#getLast} instead.\n",
        "656": "   * <p><b>{@code Stream} equivalent:</b> pass {@link ImmutableSortedSet#toImmutableSortedSet} to\n",
        "657": "   * {@code stream.collect()}.\n",
        "671": "   * {@code stream.collect()}.\n",
        "689": "   * <p><b>{@code Stream} equivalent:</b> {@code stream.collect(ImmutableMap.toImmutableMap(k -> k,\n",
        "690": "   * valueFunction))}.\n",
        "759": "   * <p><b>{@code Stream} equivalent:</b> if an object array is acceptable, use {@code\n",
        "760": "   * stream.toArray()}; if {@code type} is a class literal such as {@code MyType.class}, use {@code\n",
        "761": "   * stream.toArray(MyType[]::new)}. Otherwise use {@code stream.toArray( len -> (E[])\n",
        "762": "   * Array.newInstance(type, len))}.\n",
        "777": "   * <p><b>{@code Stream} equivalent:</b> {@code stream.forEachOrdered(collection::add)} or {@code\n",
        "778": "   * stream.forEach(collection::add)}.\n",
        "803": "   * using any optional {@code Joiner} features, {@code\n",
        "804": "   * stream.collect(Collectors.joining(delimiter)}.\n",
        "844": "  /** Function that transforms {@code Iterable<E>} into a fluent iterable. */\n"
    },
    "removed": {
        "42": " * <li>chaining methods which return a new {@code FluentIterable} based in some way on the contents\n",
        "43": " *     of the current one (for example {@link #transform})\n",
        "44": " * <li>element extraction methods which facilitate the retrieval of certain elements (for example\n",
        "45": " *     {@link #last})\n",
        "46": " * <li>query methods which answer questions about the {@code FluentIterable}'s contents (for example\n",
        "47": " *     {@link #anyMatch})\n",
        "48": " * <li>conversion methods which copy the {@code FluentIterable}'s contents into a new collection or\n",
        "49": " *     array (for example {@link #toList})\n",
        "55": " * <a name=\"streams\"></a>\n",
        "62": " * <li>A stream is <i>single-use</i>; it becomes invalid as soon as any \"terminal operation\" such as\n",
        "63": " *     {@code findFirst()} or {@code iterator()} is invoked. (Even though {@code Stream} contains\n",
        "64": " *     all the right method <i>signatures</i> to implement {@link Iterable}, it does not actually do\n",
        "65": " *     so, to avoid implying repeat-iterability.) {@code FluentIterable}, on the other hand, is\n",
        "66": " *     multiple-use, and does implement {@link Iterable}.\n",
        "67": " * <li>Streams offer many features not found here, including {@code min/max}, {@code distinct},\n",
        "68": " *     {@code reduce}, {@code sorted}, the very powerful {@code collect}, and built-in support for\n",
        "69": " *     parallelizing stream operations.\n",
        "70": " * <li>{@code FluentIterable} contains several features not available on {@code Stream}, which are\n",
        "71": " *     noted in the method descriptions below.\n",
        "72": " * <li>Streams include primitive-specialized variants such as {@code IntStream}, the use of which is\n",
        "73": " *     strongly recommended.\n",
        "74": " * <li>Streams are standard Java, not requiring a third-party dependency.\n",
        "134": "   * <p><b>{@code Stream} equivalent:</b> {@link Collection#stream} if {@code iterable} is a\n",
        "135": "   * {@link Collection}; {@link Streams#stream(Iterable)} otherwise.\n",
        "165": "   * but is intended to help call out cases where one migration from {@code Iterable} to\n",
        "166": "   * {@code FluentIterable} has obviated the need to explicitly convert to a {@code FluentIterable}.\n",
        "168": "   * @deprecated instances of {@code FluentIterable} don't need to be converted to\n",
        "169": "   *     {@code FluentIterable}\n",
        "349": "   * Returns {@code true} if this fluent iterable contains any object for which\n",
        "350": "   * {@code equals(target)} is true.\n",
        "362": "   * <p>That iterator supports {@code remove()} if {@code iterable.iterator()} does. After\n",
        "363": "   * {@code remove()} is called, subsequent cycles omit the removed element, which is no longer in\n",
        "364": "   * this fluent iterable. The iterator's {@code hasNext()} method returns {@code true} until this\n",
        "365": "   * fluent iterable is empty.\n",
        "517": "   * iterable is empty, {@code Optional.absent()} is returned. If the underlying {@code iterable}\n",
        "518": "   * is a {@link List} with {@link java.util.RandomAccess} support, then this operation is\n",
        "519": "   * guaranteed to be {@code O(1)}.\n",
        "523": "   * @throws NullPointerException if the last element is null; if this is a possibility, use\n",
        "524": "   *     {@link Iterables#getLast} instead.\n",
        "655": "   * <p><b>{@code Stream} equivalent:</b> pass {@link\n",
        "656": "   * ImmutableSortedSet#toImmutableSortedSet} to {@code stream.collect()}.\n",
        "670": "   * {@code\n",
        "671": "   * stream.collect()}.\n",
        "689": "   * <p><b>{@code Stream} equivalent:</b> {@code\n",
        "690": "   * stream.collect(ImmutableMap.toImmutableMap(k -> k, valueFunction))}.\n",
        "759": "   * <p><b>{@code Stream} equivalent:</b> if an object array is acceptable, use\n",
        "760": "   * {@code stream.toArray()}; if {@code type} is a class literal such as {@code MyType.class}, use\n",
        "761": "   * {@code stream.toArray(MyType[]::new)}. Otherwise use {@code stream.toArray(\n",
        "762": "   * len -> (E[]) Array.newInstance(type, len))}.\n",
        "777": "   * <p><b>{@code Stream} equivalent:</b> {@code stream.forEachOrdered(collection::add)} or\n",
        "778": "   * {@code stream.forEach(collection::add)}.\n",
        "803": "   * using any optional {@code Joiner} features,\n",
        "804": "   * {@code stream.collect(Collectors.joining(delimiter)}.\n",
        "844": "  /**\n",
        "845": "   * Function that transforms {@code Iterable<E>} into a fluent iterable.\n",
        "846": "   */\n"
    }
}