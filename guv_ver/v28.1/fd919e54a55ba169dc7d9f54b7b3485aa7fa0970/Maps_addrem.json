{
    "addition": {
        "67": " * Static utility methods pertaining to {@link Map} instances (including instances of {@link\n",
        "68": " * SortedMap}, {@link BiMap}, etc.). Also see this class's counterparts {@link Lists}, {@link Sets}\n",
        "69": " * and {@link Queues}.\n",
        "72": " * \"https://github.com/google/guava/wiki/CollectionUtilitiesExplained#maps\"> {@code Maps}</a>.\n",
        "120": "   * Returns an immutable map instance containing the given entries. Internally, the returned map\n",
        "121": "   * will be backed by an {@link EnumMap}.\n",
        "123": "   * <p>The iteration order of the returned map follows the enum's iteration order, not the order in\n",
        "124": "   * which the elements appear in the given map.\n",
        "163": "   * <p><b>Note:</b> if mutability is not required, use {@link ImmutableMap#of()} instead.\n",
        "165": "   * <p><b>Note:</b> if {@code K} is an {@code enum} type, use {@link #newEnumMap} instead.\n",
        "167": "   * <p><b>Note for Java 7 and later:</b> this method is now unnecessary and should be treated as\n",
        "168": "   * deprecated. Instead, use the {@code HashMap} constructor directly, taking advantage of the new\n",
        "178": "   * Creates a {@code HashMap} instance, with a high enough \"initial capacity\" that it <i>should</i>\n",
        "179": "   * hold {@code expectedSize} elements without growth. This behavior cannot be broadly guaranteed,\n",
        "180": "   * but it is observed to be true for OpenJDK 1.7. It also can't be guaranteed that the method\n",
        "181": "   * isn't inadvertently <i>oversizing</i> the returned map.\n",
        "182": "   *\n",
        "183": "   * @param expectedSize the number of entries you expect to add to the returned map\n",
        "184": "   * @return a new, empty {@code HashMap} with enough capacity to hold {@code expectedSize} entries\n",
        "185": "   *     without resizing\n",
        "211": "   * Creates a <i>mutable</i> {@code HashMap} instance with the same mappings as the specified map.\n",
        "213": "   * <p><b>Note:</b> if mutability is not required, use {@link ImmutableMap#copyOf(Map)} instead.\n",
        "215": "   * <p><b>Note:</b> if {@code K} is an {@link Enum} type, use {@link #newEnumMap} instead.\n",
        "217": "   * <p><b>Note for Java 7 and later:</b> this method is now unnecessary and should be treated as\n",
        "218": "   * deprecated. Instead, use the {@code HashMap} constructor directly, taking advantage of the new\n",
        "222": "   * @return a new {@code HashMap} initialized with the mappings from {@code map}\n",
        "229": "   * Creates a <i>mutable</i>, empty, insertion-ordered {@code LinkedHashMap} instance.\n",
        "231": "   * <p><b>Note:</b> if mutability is not required, use {@link ImmutableMap#of()} instead.\n",
        "233": "   * <p><b>Note for Java 7 and later:</b> this method is now unnecessary and should be treated as\n",
        "234": "   * deprecated. Instead, use the {@code LinkedHashMap} constructor directly, taking advantage of\n",
        "235": "   * the new <a href=\"http://goo.gl/iz2Wi\">\"diamond\" syntax</a>.\n",
        "244": "   * Creates a {@code LinkedHashMap} instance, with a high enough \"initial capacity\" that it\n",
        "245": "   * <i>should</i> hold {@code expectedSize} elements without growth. This behavior cannot be\n",
        "246": "   * broadly guaranteed, but it is observed to be true for OpenJDK 1.7. It also can't be guaranteed\n",
        "249": "   * @param expectedSize the number of entries you expect to add to the returned map\n",
        "250": "   * @return a new, empty {@code LinkedHashMap} with enough capacity to hold {@code expectedSize}\n",
        "251": "   *     entries without resizing\n",
        "260": "   * Creates a <i>mutable</i>, insertion-ordered {@code LinkedHashMap} instance with the same\n",
        "261": "   * mappings as the specified map.\n",
        "263": "   * <p><b>Note:</b> if mutability is not required, use {@link ImmutableMap#copyOf(Map)} instead.\n",
        "265": "   * <p><b>Note for Java 7 and later:</b> this method is now unnecessary and should be treated as\n",
        "266": "   * deprecated. Instead, use the {@code LinkedHashMap} constructor directly, taking advantage of\n",
        "267": "   * the new <a href=\"http://goo.gl/iz2Wi\">\"diamond\" syntax</a>.\n",
        "270": "   * @return a new, {@code LinkedHashMap} initialized with the mappings from {@code map}\n",
        "286": "   * Creates a <i>mutable</i>, empty {@code TreeMap} instance using the natural ordering of its\n",
        "287": "   * elements.\n",
        "289": "   * <p><b>Note:</b> if mutability is not required, use {@link ImmutableSortedMap#of()} instead.\n",
        "291": "   * <p><b>Note for Java 7 and later:</b> this method is now unnecessary and should be treated as\n",
        "292": "   * deprecated. Instead, use the {@code TreeMap} constructor directly, taking advantage of the new\n",
        "302": "   * Creates a <i>mutable</i> {@code TreeMap} instance with the same mappings as the specified map\n",
        "303": "   * and using the same ordering as the specified map.\n",
        "308": "   * <p><b>Note for Java 7 and later:</b> this method is now unnecessary and should be treated as\n",
        "309": "   * deprecated. Instead, use the {@code TreeMap} constructor directly, taking advantage of the new\n",
        "312": "   * @param map the sorted map whose mappings are to be placed in the new map and whose comparator\n",
        "313": "   *     is to be used to sort the new map\n",
        "314": "   * @return a new {@code TreeMap} initialized with the mappings from {@code map} and using the\n",
        "315": "   *     comparator of {@code map}\n",
        "322": "   * Creates a <i>mutable</i>, empty {@code TreeMap} instance using the given comparator.\n",
        "327": "   * <p><b>Note for Java 7 and later:</b> this method is now unnecessary and should be treated as\n",
        "328": "   * deprecated. Instead, use the {@code TreeMap} constructor directly, taking advantage of the new\n",
        "356": "   * <p><b>Note for Java 7 and later:</b> this method is now unnecessary and should be treated as\n",
        "357": "   * deprecated. Instead, use the {@code EnumMap} constructor directly, taking advantage of the new\n",
        "361": "   * @return a new {@code EnumMap} initialized with the mappings from {@code map}\n",
        "362": "   * @throws IllegalArgumentException if {@code m} is not an {@code EnumMap} instance and contains\n",
        "363": "   *     no mappings\n",
        "372": "   * <p><b>Note for Java 7 and later:</b> this method is now unnecessary and should be treated as\n",
        "373": "   * deprecated. Instead, use the {@code IdentityHashMap} constructor directly, taking advantage of\n",
        "374": "   * the new <a href=\"http://goo.gl/iz2Wi\">\"diamond\" syntax</a>.\n",
        "383": "   * Computes the difference between two maps. This difference is an immutable snapshot of the state\n",
        "384": "   * of the maps at the time this method is called. It will never change, even if the maps change at\n",
        "385": "   * a later time.\n",
        "387": "   * <p>Since this method uses {@code HashMap} instances internally, the keys of the supplied maps\n",
        "388": "   * must be well-behaved with respect to {@link Object#equals} and {@link Object#hashCode}.\n",
        "390": "   * <p><b>Note:</b>If you only need to know whether two maps have the same mappings, call {@code\n",
        "391": "   * left.equals(right)} instead of this method.\n",
        "408": "   * Computes the difference between two maps. This difference is an immutable snapshot of the state\n",
        "409": "   * of the maps at the time this method is called. It will never change, even if the maps change at\n",
        "410": "   * a later time.\n",
        "412": "   * <p>Since this method uses {@code HashMap} instances internally, the keys of the supplied maps\n",
        "413": "   * must be well-behaved with respect to {@link Object#equals} and {@link Object#hashCode}.\n",
        "417": "   * @param valueEquivalence the equivalence relationship to use to compare values\n",
        "595": "   * Computes the difference between two sorted maps, using the comparator of the left map, or\n",
        "596": "   * {@code Ordering.natural()} if the left map uses the natural ordering of its elements. This\n",
        "597": "   * difference is an immutable snapshot of the state of the maps at the time this method is called.\n",
        "598": "   * It will never change, even if the maps change at a later time.\n",
        "600": "   * <p>Since this method uses {@code TreeMap} instances internally, the keys of the right map must\n",
        "601": "   * all compare as distinct according to the comparator of the left map.\n",
        "603": "   * <p><b>Note:</b>If you only need to know whether two sorted maps have the same mappings, call\n",
        "604": "   * {@code left.equals(right)} instead of this method.\n",
        "657": "   * Returns the specified comparator if not null; otherwise returns {@code Ordering.natural()}.\n",
        "658": "   * This method is an abomination of generics; the only purpose of this method is to contain the\n",
        "659": "   * ugly type-casting in one place.\n",
        "670": "   * Returns a live {@link Map} view whose keys are the contents of {@code set} and whose values are\n",
        "671": "   * computed on demand using {@code function}. To get an immutable <i>copy</i> instead, use {@link\n",
        "672": "   * #toMap(Iterable, Function)}.\n",
        "673": "   *\n",
        "674": "   * <p>Specifically, for each {@code k} in the backing set, the returned map has an entry mapping\n",
        "675": "   * {@code k} to {@code function.apply(k)}. The {@code keySet}, {@code values}, and {@code\n",
        "676": "   * entrySet} views of the returned map iterate in the same order as the backing set.\n",
        "677": "   *\n",
        "678": "   * <p>Modifications to the backing set are read through to the returned map. The returned map\n",
        "679": "   * supports removal operations if the backing set does. Removal operations write through to the\n",
        "680": "   * backing set. The returned map does not support put operations.\n",
        "681": "   *\n",
        "682": "   * <p><b>Warning:</b> If the function rejects {@code null}, caution is required to make sure the\n",
        "683": "   * set does not contain {@code null}, because the view cannot stop {@code null} from being added\n",
        "684": "   * to the set.\n",
        "685": "   *\n",
        "686": "   * <p><b>Warning:</b> This method assumes that for any instance {@code k} of key type {@code K},\n",
        "687": "   * {@code k.equals(k2)} implies that {@code k2} is also of type {@code K}. Using a key type for\n",
        "688": "   * which this may not hold, such as {@code ArrayList}, may risk a {@code ClassCastException} when\n",
        "689": "   * calling methods on the resulting map view.\n",
        "698": "   * Returns a view of the sorted set as a map, mapping keys from the set according to the specified\n",
        "699": "   * function.\n",
        "701": "   * <p>Specifically, for each {@code k} in the backing set, the returned map has an entry mapping\n",
        "702": "   * {@code k} to {@code function.apply(k)}. The {@code keySet}, {@code values}, and {@code\n",
        "703": "   * entrySet} views of the returned map iterate in the same order as the backing set.\n",
        "705": "   * <p>Modifications to the backing set are read through to the returned map. The returned map\n",
        "706": "   * supports removal operations if the backing set does. Removal operations write through to the\n",
        "707": "   * backing set. The returned map does not support put operations.\n",
        "709": "   * <p><b>Warning:</b> If the function rejects {@code null}, caution is required to make sure the\n",
        "710": "   * set does not contain {@code null}, because the view cannot stop {@code null} from being added\n",
        "711": "   * to the set.\n",
        "713": "   * <p><b>Warning:</b> This method assumes that for any instance {@code k} of key type {@code K},\n",
        "714": "   * {@code k.equals(k2)} implies that {@code k2} is also of type {@code K}. Using a key type for\n",
        "715": "   * which this may not hold, such as {@code ArrayList}, may risk a {@code ClassCastException} when\n",
        "716": "   * calling methods on the resulting map view.\n",
        "725": "   * Returns a view of the navigable set as a map, mapping keys from the set according to the\n",
        "726": "   * specified function.\n",
        "728": "   * <p>Specifically, for each {@code k} in the backing set, the returned map has an entry mapping\n",
        "729": "   * {@code k} to {@code function.apply(k)}. The {@code keySet}, {@code values}, and {@code\n",
        "730": "   * entrySet} views of the returned map iterate in the same order as the backing set.\n",
        "732": "   * <p>Modifications to the backing set are read through to the returned map. The returned map\n",
        "733": "   * supports removal operations if the backing set does. Removal operations write through to the\n",
        "734": "   * backing set. The returned map does not support put operations.\n",
        "736": "   * <p><b>Warning:</b> If the function rejects {@code null}, caution is required to make sure the\n",
        "737": "   * set does not contain {@code null}, because the view cannot stop {@code null} from being added\n",
        "738": "   * to the set.\n",
        "740": "   * <p><b>Warning:</b> This method assumes that for any instance {@code k} of key type {@code K},\n",
        "741": "   * {@code k.equals(k2)} implies that {@code k2} is also of type {@code K}. Using a key type for\n",
        "742": "   * which this may not hold, such as {@code ArrayList}, may risk a {@code ClassCastException} when\n",
        "743": "   * calling methods on the resulting map view.\n",
        "1079": "   * Returns an immutable map whose keys are the distinct elements of {@code keys} and whose value\n",
        "1080": "   * for each key was computed by {@code valueFunction}. The map's iteration order is the order of\n",
        "1081": "   * the first appearance of each key in {@code keys}.\n",
        "1082": "   *\n",
        "1083": "   * <p>When there are multiple instances of a key in {@code keys}, it is unspecified whether {@code\n",
        "1084": "   * valueFunction} will be applied to more than one instance of that key and, if it is, which\n",
        "1085": "   * result will be mapped to that key in the returned map.\n",
        "1086": "   *\n",
        "1087": "   * <p>If {@code keys} is a {@link Set}, a live view can be obtained instead of a copy using {@link\n",
        "1088": "   * Maps#asMap(Set, Function)}.\n",
        "1089": "   *\n",
        "1090": "   * @throws NullPointerException if any element of {@code keys} is {@code null}, or if {@code\n",
        "1091": "   *     valueFunction} produces {@code null} for any key\n",
        "1100": "   * Returns an immutable map whose keys are the distinct elements of {@code keys} and whose value\n",
        "1101": "   * for each key was computed by {@code valueFunction}. The map's iteration order is the order of\n",
        "1102": "   * the first appearance of each key in {@code keys}.\n",
        "1103": "   *\n",
        "1104": "   * <p>When there are multiple instances of a key in {@code keys}, it is unspecified whether {@code\n",
        "1105": "   * valueFunction} will be applied to more than one instance of that key and, if it is, which\n",
        "1106": "   * result will be mapped to that key in the returned map.\n",
        "1107": "   *\n",
        "1108": "   * @throws NullPointerException if any element of {@code keys} is {@code null}, or if {@code\n",
        "1109": "   *     valueFunction} produces {@code null} for any key\n",
        "1125": "   * Returns a map with the given {@code values}, indexed by keys derived from those values. In\n",
        "1126": "   * other words, each input value produces an entry in the map whose key is the result of applying\n",
        "1127": "   * {@code keyFunction} to that value. These entries appear in the same order as the input values.\n",
        "1128": "   * Example usage:\n",
        "1130": "   * <pre>{@code\n",
        "1131": "   * Color red = new Color(\"red\", 255, 0, 0);\n",
        "1132": "   * ...\n",
        "1133": "   * ImmutableSet<Color> allColors = ImmutableSet.of(red, green, blue);\n",
        "1135": "   * Map<String, Color> colorForName =\n",
        "1136": "   *     uniqueIndex(allColors, toStringFunction());\n",
        "1137": "   * assertThat(colorForName).containsEntry(\"red\", red);\n",
        "1138": "   * }</pre>\n",
        "1145": "   * @return a map mapping the result of evaluating the function {@code keyFunction} on each value\n",
        "1146": "   *     in the input collection to that value\n",
        "1147": "   * @throws IllegalArgumentException if {@code keyFunction} produces the same key for more than one\n",
        "1148": "   *     value in the input collection\n",
        "1149": "   * @throws NullPointerException if any element of {@code values} is {@code null}, or if {@code\n",
        "1150": "   *     keyFunction} produces {@code null} for any value\n",
        "1160": "   * Returns a map with the given {@code values}, indexed by keys derived from those values. In\n",
        "1161": "   * other words, each input value produces an entry in the map whose key is the result of applying\n",
        "1162": "   * {@code keyFunction} to that value. These entries appear in the same order as the input values.\n",
        "1163": "   * Example usage:\n",
        "1165": "   * <pre>{@code\n",
        "1166": "   * Color red = new Color(\"red\", 255, 0, 0);\n",
        "1167": "   * ...\n",
        "1168": "   * Iterator<Color> allColors = ImmutableSet.of(red, green, blue).iterator();\n",
        "1170": "   * Map<String, Color> colorForName =\n",
        "1171": "   *     uniqueIndex(allColors, toStringFunction());\n",
        "1172": "   * assertThat(colorForName).containsEntry(\"red\", red);\n",
        "1173": "   * }</pre>\n",
        "1180": "   * @return a map mapping the result of evaluating the function {@code keyFunction} on each value\n",
        "1181": "   *     in the input collection to that value\n",
        "1182": "   * @throws IllegalArgumentException if {@code keyFunction} produces the same key for more than one\n",
        "1183": "   *     value in the input collection\n",
        "1184": "   * @throws NullPointerException if any element of {@code values} is {@code null}, or if {@code\n",
        "1185": "   *     keyFunction} produces {@code null} for any value\n",
        "1207": "   * Creates an {@code ImmutableMap<String, String>} from a {@code Properties} instance. Properties\n",
        "1208": "   * normally derive from {@code Map<Object, Object>}, but they typically contain strings, which is\n",
        "1209": "   * awkward. This method lets you get a plain-old-{@code Map} out of a {@code Properties}.\n",
        "1213": "   * @throws ClassCastException if any key in {@code Properties} is not a {@code String}\n",
        "1214": "   * @throws NullPointerException if any key or value in {@code Properties} is null\n",
        "1229": "   * Returns an immutable map entry with the specified key and value. The {@link Entry#setValue}\n",
        "1230": "   * operation throws an {@link UnsupportedOperationException}.\n",
        "1243": "   * Returns an unmodifiable view of the specified set of entries. The {@link Entry#setValue}\n",
        "1244": "   * operation throws an {@link UnsupportedOperationException}, as do any operations that would\n",
        "1245": "   * modify the returned set.\n",
        "1255": "   * Returns an unmodifiable view of the specified map entry. The {@link Entry#setValue} operation\n",
        "1256": "   * throws an {@link UnsupportedOperationException}. This also has the side-effect of redefining\n",
        "1257": "   * {@code equals} to comply with the Entry contract, to avoid a possible nefarious implementation\n",
        "1258": "   * of equals.\n",
        "1345": "   * Returns a {@link Converter} that converts values using {@link BiMap#get bimap.get()}, and whose\n",
        "1346": "   * inverse view converts values using {@link BiMap#inverse bimap.inverse()}{@code .get()}.\n",
        "1348": "   * <p>To use a plain {@link Map} as a {@link Function}, see {@link\n",
        "1349": "   * com.google.common.base.Functions#forMap(Map)} or {@link\n",
        "1350": "   * com.google.common.base.Functions#forMap(Map, Object)}.\n",
        "1406": "   * Returns a synchronized (thread-safe) bimap backed by the specified bimap. In order to guarantee\n",
        "1407": "   * serial access, it is critical that <b>all</b> access to the backing bimap is accomplished\n",
        "1408": "   * through the returned bimap.\n",
        "1409": "   *\n",
        "1410": "   * <p>It is imperative that the user manually synchronize on the returned map when accessing any\n",
        "1411": "   * of its collection views:\n",
        "1412": "   *\n",
        "1413": "   * <pre>{@code\n",
        "1414": "   * BiMap<Long, String> map = Maps.synchronizedBiMap(\n",
        "1415": "   *     HashBiMap.<Long, String>create());\n",
        "1416": "   * ...\n",
        "1417": "   * Set<Long> set = map.keySet();  // Needn't be in synchronized block\n",
        "1418": "   * ...\n",
        "1419": "   * synchronized (map) {  // Synchronizing on map, not set!\n",
        "1420": "   *   Iterator<Long> it = set.iterator(); // Must be in synchronized block\n",
        "1421": "   *   while (it.hasNext()) {\n",
        "1422": "   *     foo(it.next());\n",
        "1423": "   *   }\n",
        "1424": "   * }\n",
        "1425": "   * }</pre>\n",
        "1429": "   * <p>The returned bimap will be serializable if the specified bimap is serializable.\n",
        "1439": "   * Returns an unmodifiable view of the specified bimap. This method allows modules to provide\n",
        "1440": "   * users with \"read-only\" access to internal bimaps. Query operations on the returned bimap \"read\n",
        "1441": "   * through\" to the specified bimap, and attempts to modify the returned map, whether direct or via\n",
        "1442": "   * its collection views, result in an {@code UnsupportedOperationException}.\n",
        "1444": "   * <p>The returned bimap will be serializable if the specified bimap is serializable.\n",
        "1458": "    @RetainedWith BiMap<V, K> inverse;\n",
        "1495": "   * Returns a view of a map where each value is transformed by a function. All other properties of\n",
        "1496": "   * the map, such as iteration order, are left intact. For example, the code:\n",
        "1497": "   *\n",
        "1498": "   * <pre>{@code\n",
        "1499": "   * Map<String, Integer> map = ImmutableMap.of(\"a\", 4, \"b\", 9);\n",
        "1500": "   * Function<Integer, Double> sqrt =\n",
        "1501": "   *     new Function<Integer, Double>() {\n",
        "1502": "   *       public Double apply(Integer in) {\n",
        "1503": "   *         return Math.sqrt((int) in);\n",
        "1504": "   *       }\n",
        "1505": "   *     };\n",
        "1506": "   * Map<String, Double> transformed = Maps.transformValues(map, sqrt);\n",
        "1507": "   * System.out.println(transformed);\n",
        "1508": "   * }</pre>\n",
        "1512": "   * <p>Changes in the underlying map are reflected in this view. Conversely, this view supports\n",
        "1513": "   * removal operations, and these are reflected in the underlying map.\n",
        "1515": "   * <p>It's acceptable for the underlying map to contain null keys, and even null values provided\n",
        "1516": "   * that the function is capable of accepting null input. The transformed map might contain null\n",
        "1517": "   * values, if the function sometimes gives a null result.\n",
        "1519": "   * <p>The returned map is not thread-safe or serializable, even if the underlying map is.\n",
        "1521": "   * <p>The function is applied lazily, invoked when needed. This is necessary for the returned map\n",
        "1522": "   * to be a view, but it means that the function will be applied many times for bulk operations\n",
        "1523": "   * like {@link Map#containsValue} and {@code Map.toString()}. For this to perform well, {@code\n",
        "1524": "   * function} should be fast. To avoid lazy evaluation when the returned map doesn't need to be a\n",
        "1525": "   * view, copy the returned map into a new map of your choosing.\n",
        "1533": "   * Returns a view of a sorted map where each value is transformed by a function. All other\n",
        "1534": "   * properties of the map, such as iteration order, are left intact. For example, the code:\n",
        "1535": "   *\n",
        "1536": "   * <pre>{@code\n",
        "1537": "   * SortedMap<String, Integer> map = ImmutableSortedMap.of(\"a\", 4, \"b\", 9);\n",
        "1538": "   * Function<Integer, Double> sqrt =\n",
        "1539": "   *     new Function<Integer, Double>() {\n",
        "1540": "   *       public Double apply(Integer in) {\n",
        "1541": "   *         return Math.sqrt((int) in);\n",
        "1542": "   *       }\n",
        "1543": "   *     };\n",
        "1544": "   * SortedMap<String, Double> transformed =\n",
        "1545": "   *      Maps.transformValues(map, sqrt);\n",
        "1546": "   * System.out.println(transformed);\n",
        "1547": "   * }</pre>\n",
        "1551": "   * <p>Changes in the underlying map are reflected in this view. Conversely, this view supports\n",
        "1552": "   * removal operations, and these are reflected in the underlying map.\n",
        "1554": "   * <p>It's acceptable for the underlying map to contain null keys, and even null values provided\n",
        "1555": "   * that the function is capable of accepting null input. The transformed map might contain null\n",
        "1556": "   * values, if the function sometimes gives a null result.\n",
        "1558": "   * <p>The returned map is not thread-safe or serializable, even if the underlying map is.\n",
        "1560": "   * <p>The function is applied lazily, invoked when needed. This is necessary for the returned map\n",
        "1561": "   * to be a view, but it means that the function will be applied many times for bulk operations\n",
        "1562": "   * like {@link Map#containsValue} and {@code Map.toString()}. For this to perform well, {@code\n",
        "1563": "   * function} should be fast. To avoid lazy evaluation when the returned map doesn't need to be a\n",
        "1564": "   * view, copy the returned map into a new map of your choosing.\n",
        "1574": "   * Returns a view of a navigable map where each value is transformed by a function. All other\n",
        "1575": "   * properties of the map, such as iteration order, are left intact. For example, the code:\n",
        "1576": "   *\n",
        "1577": "   * <pre>{@code\n",
        "1578": "   * NavigableMap<String, Integer> map = Maps.newTreeMap();\n",
        "1579": "   * map.put(\"a\", 4);\n",
        "1580": "   * map.put(\"b\", 9);\n",
        "1581": "   * Function<Integer, Double> sqrt =\n",
        "1582": "   *     new Function<Integer, Double>() {\n",
        "1583": "   *       public Double apply(Integer in) {\n",
        "1584": "   *         return Math.sqrt((int) in);\n",
        "1585": "   *       }\n",
        "1586": "   *     };\n",
        "1587": "   * NavigableMap<String, Double> transformed =\n",
        "1588": "   *      Maps.transformNavigableValues(map, sqrt);\n",
        "1589": "   * System.out.println(transformed);\n",
        "1590": "   * }</pre>\n",
        "1594": "   * <p>Changes in the underlying map are reflected in this view. Conversely, this view supports\n",
        "1595": "   * removal operations, and these are reflected in the underlying map.\n",
        "1597": "   * <p>It's acceptable for the underlying map to contain null keys, and even null values provided\n",
        "1598": "   * that the function is capable of accepting null input. The transformed map might contain null\n",
        "1599": "   * values, if the function sometimes gives a null result.\n",
        "1601": "   * <p>The returned map is not thread-safe or serializable, even if the underlying map is.\n",
        "1603": "   * <p>The function is applied lazily, invoked when needed. This is necessary for the returned map\n",
        "1604": "   * to be a view, but it means that the function will be applied many times for bulk operations\n",
        "1605": "   * like {@link Map#containsValue} and {@code Map.toString()}. For this to perform well, {@code\n",
        "1606": "   * function} should be fast. To avoid lazy evaluation when the returned map doesn't need to be a\n",
        "1607": "   * view, copy the returned map into a new map of your choosing.\n",
        "1618": "   * Returns a view of a map whose values are derived from the original map's entries. In contrast\n",
        "1619": "   * to {@link #transformValues}, this method's entry-transformation logic may depend on the key as\n",
        "1620": "   * well as the value.\n",
        "1621": "   *\n",
        "1622": "   * <p>All other properties of the transformed map, such as iteration order, are left intact. For\n",
        "1623": "   * example, the code:\n",
        "1624": "   *\n",
        "1625": "   * <pre>{@code\n",
        "1626": "   * Map<String, Boolean> options =\n",
        "1627": "   *     ImmutableMap.of(\"verbose\", true, \"sort\", false);\n",
        "1628": "   * EntryTransformer<String, Boolean, String> flagPrefixer =\n",
        "1629": "   *     new EntryTransformer<String, Boolean, String>() {\n",
        "1630": "   *       public String transformEntry(String key, Boolean value) {\n",
        "1631": "   *         return value ? key : \"no\" + key;\n",
        "1632": "   *       }\n",
        "1633": "   *     };\n",
        "1634": "   * Map<String, String> transformed =\n",
        "1635": "   *     Maps.transformEntries(options, flagPrefixer);\n",
        "1636": "   * System.out.println(transformed);\n",
        "1637": "   * }</pre>\n",
        "1641": "   * <p>Changes in the underlying map are reflected in this view. Conversely, this view supports\n",
        "1642": "   * removal operations, and these are reflected in the underlying map.\n",
        "1643": "   *\n",
        "1644": "   * <p>It's acceptable for the underlying map to contain null keys and null values provided that\n",
        "1645": "   * the transformer is capable of accepting null inputs. The transformed map might contain null\n",
        "1646": "   * values if the transformer sometimes gives a null result.\n",
        "1647": "   *\n",
        "1648": "   * <p>The returned map is not thread-safe or serializable, even if the underlying map is.\n",
        "1649": "   *\n",
        "1650": "   * <p>The transformer is applied lazily, invoked when needed. This is necessary for the returned\n",
        "1651": "   * map to be a view, but it means that the transformer will be applied many times for bulk\n",
        "1652": "   * operations like {@link Map#containsValue} and {@link Object#toString}. For this to perform\n",
        "1653": "   * well, {@code transformer} should be fast. To avoid lazy evaluation when the returned map\n",
        "1654": "   * doesn't need to be a view, copy the returned map into a new map of your choosing.\n",
        "1655": "   *\n",
        "1656": "   * <p><b>Warning:</b> This method assumes that for any instance {@code k} of {@code\n",
        "1657": "   * EntryTransformer} key type {@code K}, {@code k.equals(k2)} implies that {@code k2} is also of\n",
        "1658": "   * type {@code K}. Using an {@code EntryTransformer} key type for which this may not hold, such as\n",
        "1659": "   * {@code ArrayList}, may risk a {@code ClassCastException} when calling methods on the\n",
        "1660": "   * transformed map.\n",
        "1670": "   * Returns a view of a sorted map whose values are derived from the original sorted map's entries.\n",
        "1671": "   * In contrast to {@link #transformValues}, this method's entry-transformation logic may depend on\n",
        "1672": "   * the key as well as the value.\n",
        "1673": "   *\n",
        "1674": "   * <p>All other properties of the transformed map, such as iteration order, are left intact. For\n",
        "1675": "   * example, the code:\n",
        "1676": "   *\n",
        "1677": "   * <pre>{@code\n",
        "1678": "   * Map<String, Boolean> options =\n",
        "1679": "   *     ImmutableSortedMap.of(\"verbose\", true, \"sort\", false);\n",
        "1680": "   * EntryTransformer<String, Boolean, String> flagPrefixer =\n",
        "1681": "   *     new EntryTransformer<String, Boolean, String>() {\n",
        "1682": "   *       public String transformEntry(String key, Boolean value) {\n",
        "1683": "   *         return value ? key : \"yes\" + key;\n",
        "1684": "   *       }\n",
        "1685": "   *     };\n",
        "1686": "   * SortedMap<String, String> transformed =\n",
        "1687": "   *     Maps.transformEntries(options, flagPrefixer);\n",
        "1688": "   * System.out.println(transformed);\n",
        "1689": "   * }</pre>\n",
        "1693": "   * <p>Changes in the underlying map are reflected in this view. Conversely, this view supports\n",
        "1694": "   * removal operations, and these are reflected in the underlying map.\n",
        "1695": "   *\n",
        "1696": "   * <p>It's acceptable for the underlying map to contain null keys and null values provided that\n",
        "1697": "   * the transformer is capable of accepting null inputs. The transformed map might contain null\n",
        "1698": "   * values if the transformer sometimes gives a null result.\n",
        "1699": "   *\n",
        "1700": "   * <p>The returned map is not thread-safe or serializable, even if the underlying map is.\n",
        "1701": "   *\n",
        "1702": "   * <p>The transformer is applied lazily, invoked when needed. This is necessary for the returned\n",
        "1703": "   * map to be a view, but it means that the transformer will be applied many times for bulk\n",
        "1704": "   * operations like {@link Map#containsValue} and {@link Object#toString}. For this to perform\n",
        "1705": "   * well, {@code transformer} should be fast. To avoid lazy evaluation when the returned map\n",
        "1706": "   * doesn't need to be a view, copy the returned map into a new map of your choosing.\n",
        "1707": "   *\n",
        "1708": "   * <p><b>Warning:</b> This method assumes that for any instance {@code k} of {@code\n",
        "1709": "   * EntryTransformer} key type {@code K}, {@code k.equals(k2)} implies that {@code k2} is also of\n",
        "1710": "   * type {@code K}. Using an {@code EntryTransformer} key type for which this may not hold, such as\n",
        "1711": "   * {@code ArrayList}, may risk a {@code ClassCastException} when calling methods on the\n",
        "1712": "   * transformed map.\n",
        "1722": "   * Returns a view of a navigable map whose values are derived from the original navigable map's\n",
        "1723": "   * entries. In contrast to {@link #transformValues}, this method's entry-transformation logic may\n",
        "1726": "   * <p>All other properties of the transformed map, such as iteration order, are left intact. For\n",
        "1727": "   * example, the code:\n",
        "1728": "   *\n",
        "1729": "   * <pre>{@code\n",
        "1730": "   * NavigableMap<String, Boolean> options = Maps.newTreeMap();\n",
        "1731": "   * options.put(\"verbose\", false);\n",
        "1732": "   * options.put(\"sort\", true);\n",
        "1733": "   * EntryTransformer<String, Boolean, String> flagPrefixer =\n",
        "1734": "   *     new EntryTransformer<String, Boolean, String>() {\n",
        "1735": "   *       public String transformEntry(String key, Boolean value) {\n",
        "1736": "   *         return value ? key : (\"yes\" + key);\n",
        "1737": "   *       }\n",
        "1738": "   *     };\n",
        "1739": "   * NavigableMap<String, String> transformed =\n",
        "1740": "   *     LabsMaps.transformNavigableEntries(options, flagPrefixer);\n",
        "1741": "   * System.out.println(transformed);\n",
        "1742": "   * }</pre>\n",
        "1746": "   * <p>Changes in the underlying map are reflected in this view. Conversely, this view supports\n",
        "1747": "   * removal operations, and these are reflected in the underlying map.\n",
        "1748": "   *\n",
        "1749": "   * <p>It's acceptable for the underlying map to contain null keys and null values provided that\n",
        "1750": "   * the transformer is capable of accepting null inputs. The transformed map might contain null\n",
        "1751": "   * values if the transformer sometimes gives a null result.\n",
        "1752": "   *\n",
        "1753": "   * <p>The returned map is not thread-safe or serializable, even if the underlying map is.\n",
        "1754": "   *\n",
        "1755": "   * <p>The transformer is applied lazily, invoked when needed. This is necessary for the returned\n",
        "1756": "   * map to be a view, but it means that the transformer will be applied many times for bulk\n",
        "1757": "   * operations like {@link Map#containsValue} and {@link Object#toString}. For this to perform\n",
        "1758": "   * well, {@code transformer} should be fast. To avoid lazy evaluation when the returned map\n",
        "1759": "   * doesn't need to be a view, copy the returned map into a new map of your choosing.\n",
        "1760": "   *\n",
        "1761": "   * <p><b>Warning:</b> This method assumes that for any instance {@code k} of {@code\n",
        "1762": "   * EntryTransformer} key type {@code K}, {@code k.equals(k2)} implies that {@code k2} is also of\n",
        "1763": "   * type {@code K}. Using an {@code EntryTransformer} key type for which this may not hold, such as\n",
        "1764": "   * {@code ArrayList}, may risk a {@code ClassCastException} when calling methods on the\n",
        "1765": "   * transformed map.\n",
        "1776": "   * A transformation of the value of a key-value pair, using both key and value as inputs. To apply\n",
        "1777": "   * the transformation to a map, use {@link Maps#transformEntries(Map, EntryTransformer)}.\n",
        "1786": "     * Determines an output value based on a key-value pair. This method is <i>generally\n",
        "1787": "     * expected</i>, but not absolutely required, to have the following properties:\n",
        "1790": "     *   <li>Its execution does not cause any observable side effects.\n",
        "1791": "     *   <li>The computation is <i>consistent with equals</i>; that is, {@link Objects#equal\n",
        "1792": "     *       Objects.equal}{@code (k1, k2) &&} {@link Objects#equal}{@code (v1, v2)} implies that\n",
        "1793": "     *       {@code Objects.equal(transformer.transform(k1, v1), transformer.transform(k2, v2))}.\n",
        "1796": "     * @throws NullPointerException if the key or value is null and this transformer does not accept\n",
        "1797": "     *     null arguments\n",
        "1802": "  /** Views a function as an entry transformer that ignores the entry key. */\n",
        "1825": "  /** Views an entry transformer as a function from {@code Entry} to values. */\n",
        "1837": "  /** Returns a view of an entry transformed by the specified transformer. */\n",
        "1855": "  /** Views an entry transformer as a function from entries to entries. */\n",
        "2107": "   * Returns a map containing the mappings in {@code unfiltered} whose keys satisfy a predicate. The\n",
        "2108": "   * returned map is a live view of {@code unfiltered}; changes to one affect the other.\n",
        "2109": "   *\n",
        "2110": "   * <p>The resulting map's {@code keySet()}, {@code entrySet()}, and {@code values()} views have\n",
        "2111": "   * iterators that don't support {@code remove()}, but all other methods are supported by the map\n",
        "2112": "   * and its views. When given a key that doesn't satisfy the predicate, the map's {@code put()} and\n",
        "2113": "   * {@code putAll()} methods throw an {@link IllegalArgumentException}.\n",
        "2114": "   *\n",
        "2115": "   * <p>When methods such as {@code removeAll()} and {@code clear()} are called on the filtered map\n",
        "2116": "   * or its views, only mappings whose keys satisfy the filter will be removed from the underlying\n",
        "2117": "   * map.\n",
        "2118": "   *\n",
        "2119": "   * <p>The returned map isn't threadsafe or serializable, even if {@code unfiltered} is.\n",
        "2120": "   *\n",
        "2121": "   * <p>Many of the filtered map's methods, such as {@code size()}, iterate across every key/value\n",
        "2122": "   * mapping in the underlying map and determine which satisfy the filter. When a live view is\n",
        "2123": "   * <i>not</i> needed, it may be faster to copy the filtered map and use the copy.\n",
        "2124": "   *\n",
        "2125": "   * <p><b>Warning:</b> {@code keyPredicate} must be <i>consistent with equals</i>, as documented at\n",
        "2126": "   * {@link Predicate#apply}. Do not provide a predicate such as {@code\n",
        "2127": "   * Predicates.instanceOf(ArrayList.class)}, which is inconsistent with equals.\n",
        "2139": "   * Returns a sorted map containing the mappings in {@code unfiltered} whose keys satisfy a\n",
        "2140": "   * predicate. The returned map is a live view of {@code unfiltered}; changes to one affect the\n",
        "2141": "   * other.\n",
        "2143": "   * <p>The resulting map's {@code keySet()}, {@code entrySet()}, and {@code values()} views have\n",
        "2144": "   * iterators that don't support {@code remove()}, but all other methods are supported by the map\n",
        "2145": "   * and its views. When given a key that doesn't satisfy the predicate, the map's {@code put()} and\n",
        "2146": "   * {@code putAll()} methods throw an {@link IllegalArgumentException}.\n",
        "2148": "   * <p>When methods such as {@code removeAll()} and {@code clear()} are called on the filtered map\n",
        "2149": "   * or its views, only mappings whose keys satisfy the filter will be removed from the underlying\n",
        "2150": "   * map.\n",
        "2152": "   * <p>The returned map isn't threadsafe or serializable, even if {@code unfiltered} is.\n",
        "2154": "   * <p>Many of the filtered map's methods, such as {@code size()}, iterate across every key/value\n",
        "2155": "   * mapping in the underlying map and determine which satisfy the filter. When a live view is\n",
        "2156": "   * <i>not</i> needed, it may be faster to copy the filtered map and use the copy.\n",
        "2158": "   * <p><b>Warning:</b> {@code keyPredicate} must be <i>consistent with equals</i>, as documented at\n",
        "2159": "   * {@link Predicate#apply}. Do not provide a predicate such as {@code\n",
        "2160": "   * Predicates.instanceOf(ArrayList.class)}, which is inconsistent with equals.\n",
        "2172": "   * Returns a navigable map containing the mappings in {@code unfiltered} whose keys satisfy a\n",
        "2173": "   * predicate. The returned map is a live view of {@code unfiltered}; changes to one affect the\n",
        "2174": "   * other.\n",
        "2176": "   * <p>The resulting map's {@code keySet()}, {@code entrySet()}, and {@code values()} views have\n",
        "2177": "   * iterators that don't support {@code remove()}, but all other methods are supported by the map\n",
        "2178": "   * and its views. When given a key that doesn't satisfy the predicate, the map's {@code put()} and\n",
        "2179": "   * {@code putAll()} methods throw an {@link IllegalArgumentException}.\n",
        "2181": "   * <p>When methods such as {@code removeAll()} and {@code clear()} are called on the filtered map\n",
        "2182": "   * or its views, only mappings whose keys satisfy the filter will be removed from the underlying\n",
        "2183": "   * map.\n",
        "2185": "   * <p>The returned map isn't threadsafe or serializable, even if {@code unfiltered} is.\n",
        "2187": "   * <p>Many of the filtered map's methods, such as {@code size()}, iterate across every key/value\n",
        "2188": "   * mapping in the underlying map and determine which satisfy the filter. When a live view is\n",
        "2189": "   * <i>not</i> needed, it may be faster to copy the filtered map and use the copy.\n",
        "2191": "   * <p><b>Warning:</b> {@code keyPredicate} must be <i>consistent with equals</i>, as documented at\n",
        "2192": "   * {@link Predicate#apply}. Do not provide a predicate such as {@code\n",
        "2193": "   * Predicates.instanceOf(ArrayList.class)}, which is inconsistent with equals.\n",
        "2210": "   * iterators that don't support {@code remove()}, but all other methods are supported by the bimap\n",
        "2211": "   * and its views. When given a key that doesn't satisfy the predicate, the bimap's {@code put()},\n",
        "2212": "   * {@code forcePut()} and {@code putAll()} methods throw an {@link IllegalArgumentException}.\n",
        "2224": "   * <p><b>Warning:</b> {@code entryPredicate} must be <i>consistent with equals </i>, as documented\n",
        "2225": "   * at {@link Predicate#apply}.\n",
        "2236": "   * Returns a map containing the mappings in {@code unfiltered} whose values satisfy a predicate.\n",
        "2237": "   * The returned map is a live view of {@code unfiltered}; changes to one affect the other.\n",
        "2238": "   *\n",
        "2239": "   * <p>The resulting map's {@code keySet()}, {@code entrySet()}, and {@code values()} views have\n",
        "2240": "   * iterators that don't support {@code remove()}, but all other methods are supported by the map\n",
        "2241": "   * and its views. When given a value that doesn't satisfy the predicate, the map's {@code put()},\n",
        "2242": "   * {@code putAll()}, and {@link Entry#setValue} methods throw an {@link IllegalArgumentException}.\n",
        "2243": "   *\n",
        "2244": "   * <p>When methods such as {@code removeAll()} and {@code clear()} are called on the filtered map\n",
        "2245": "   * or its views, only mappings whose values satisfy the filter will be removed from the underlying\n",
        "2246": "   * map.\n",
        "2247": "   *\n",
        "2248": "   * <p>The returned map isn't threadsafe or serializable, even if {@code unfiltered} is.\n",
        "2249": "   *\n",
        "2250": "   * <p>Many of the filtered map's methods, such as {@code size()}, iterate across every key/value\n",
        "2251": "   * mapping in the underlying map and determine which satisfy the filter. When a live view is\n",
        "2252": "   * <i>not</i> needed, it may be faster to copy the filtered map and use the copy.\n",
        "2253": "   *\n",
        "2254": "   * <p><b>Warning:</b> {@code valuePredicate} must be <i>consistent with equals</i>, as documented\n",
        "2255": "   * at {@link Predicate#apply}. Do not provide a predicate such as {@code\n",
        "2256": "   * Predicates.instanceOf(ArrayList.class)}, which is inconsistent with equals.\n",
        "2264": "   * Returns a sorted map containing the mappings in {@code unfiltered} whose values satisfy a\n",
        "2265": "   * predicate. The returned map is a live view of {@code unfiltered}; changes to one affect the\n",
        "2266": "   * other.\n",
        "2267": "   *\n",
        "2268": "   * <p>The resulting map's {@code keySet()}, {@code entrySet()}, and {@code values()} views have\n",
        "2269": "   * iterators that don't support {@code remove()}, but all other methods are supported by the map\n",
        "2270": "   * and its views. When given a value that doesn't satisfy the predicate, the map's {@code put()},\n",
        "2271": "   * {@code putAll()}, and {@link Entry#setValue} methods throw an {@link IllegalArgumentException}.\n",
        "2272": "   *\n",
        "2273": "   * <p>When methods such as {@code removeAll()} and {@code clear()} are called on the filtered map\n",
        "2274": "   * or its views, only mappings whose values satisfy the filter will be removed from the underlying\n",
        "2275": "   * map.\n",
        "2276": "   *\n",
        "2277": "   * <p>The returned map isn't threadsafe or serializable, even if {@code unfiltered} is.\n",
        "2278": "   *\n",
        "2279": "   * <p>Many of the filtered map's methods, such as {@code size()}, iterate across every key/value\n",
        "2280": "   * mapping in the underlying map and determine which satisfy the filter. When a live view is\n",
        "2281": "   * <i>not</i> needed, it may be faster to copy the filtered map and use the copy.\n",
        "2282": "   *\n",
        "2283": "   * <p><b>Warning:</b> {@code valuePredicate} must be <i>consistent with equals</i>, as documented\n",
        "2284": "   * at {@link Predicate#apply}. Do not provide a predicate such as {@code\n",
        "2285": "   * Predicates.instanceOf(ArrayList.class)}, which is inconsistent with equals.\n",
        "2295": "   * Returns a navigable map containing the mappings in {@code unfiltered} whose values satisfy a\n",
        "2296": "   * predicate. The returned map is a live view of {@code unfiltered}; changes to one affect the\n",
        "2297": "   * other.\n",
        "2298": "   *\n",
        "2299": "   * <p>The resulting map's {@code keySet()}, {@code entrySet()}, and {@code values()} views have\n",
        "2300": "   * iterators that don't support {@code remove()}, but all other methods are supported by the map\n",
        "2301": "   * and its views. When given a value that doesn't satisfy the predicate, the map's {@code put()},\n",
        "2302": "   * {@code putAll()}, and {@link Entry#setValue} methods throw an {@link IllegalArgumentException}.\n",
        "2303": "   *\n",
        "2304": "   * <p>When methods such as {@code removeAll()} and {@code clear()} are called on the filtered map\n",
        "2305": "   * or its views, only mappings whose values satisfy the filter will be removed from the underlying\n",
        "2306": "   * map.\n",
        "2307": "   *\n",
        "2308": "   * <p>The returned map isn't threadsafe or serializable, even if {@code unfiltered} is.\n",
        "2309": "   *\n",
        "2310": "   * <p>Many of the filtered map's methods, such as {@code size()}, iterate across every key/value\n",
        "2311": "   * mapping in the underlying map and determine which satisfy the filter. When a live view is\n",
        "2312": "   * <i>not</i> needed, it may be faster to copy the filtered map and use the copy.\n",
        "2313": "   *\n",
        "2314": "   * <p><b>Warning:</b> {@code valuePredicate} must be <i>consistent with equals</i>, as documented\n",
        "2315": "   * at {@link Predicate#apply}. Do not provide a predicate such as {@code\n",
        "2316": "   * Predicates.instanceOf(ArrayList.class)}, which is inconsistent with equals.\n",
        "2327": "   * Returns a bimap containing the mappings in {@code unfiltered} whose values satisfy a predicate.\n",
        "2328": "   * The returned bimap is a live view of {@code unfiltered}; changes to one affect the other.\n",
        "2331": "   * iterators that don't support {@code remove()}, but all other methods are supported by the bimap\n",
        "2332": "   * and its views. When given a value that doesn't satisfy the predicate, the bimap's {@code\n",
        "2333": "   * put()}, {@code forcePut()} and {@code putAll()} methods throw an {@link\n",
        "2348": "   * <p><b>Warning:</b> {@code entryPredicate} must be <i>consistent with equals </i>, as documented\n",
        "2349": "   * at {@link Predicate#apply}.\n",
        "2359": "   * Returns a map containing the mappings in {@code unfiltered} that satisfy a predicate. The\n",
        "2360": "   * returned map is a live view of {@code unfiltered}; changes to one affect the other.\n",
        "2361": "   *\n",
        "2362": "   * <p>The resulting map's {@code keySet()}, {@code entrySet()}, and {@code values()} views have\n",
        "2363": "   * iterators that don't support {@code remove()}, but all other methods are supported by the map\n",
        "2364": "   * and its views. When given a key/value pair that doesn't satisfy the predicate, the map's {@code\n",
        "2365": "   * put()} and {@code putAll()} methods throw an {@link IllegalArgumentException}. Similarly, the\n",
        "2366": "   * map's entries have a {@link Entry#setValue} method that throws an {@link\n",
        "2367": "   * IllegalArgumentException} when the existing key and the provided value don't satisfy the\n",
        "2368": "   * predicate.\n",
        "2369": "   *\n",
        "2370": "   * <p>When methods such as {@code removeAll()} and {@code clear()} are called on the filtered map\n",
        "2371": "   * or its views, only mappings that satisfy the filter will be removed from the underlying map.\n",
        "2372": "   *\n",
        "2373": "   * <p>The returned map isn't threadsafe or serializable, even if {@code unfiltered} is.\n",
        "2374": "   *\n",
        "2375": "   * <p>Many of the filtered map's methods, such as {@code size()}, iterate across every key/value\n",
        "2376": "   * mapping in the underlying map and determine which satisfy the filter. When a live view is\n",
        "2377": "   * <i>not</i> needed, it may be faster to copy the filtered map and use the copy.\n",
        "2378": "   *\n",
        "2379": "   * <p><b>Warning:</b> {@code entryPredicate} must be <i>consistent with equals</i>, as documented\n",
        "2380": "   * at {@link Predicate#apply}.\n",
        "2391": "   * Returns a sorted map containing the mappings in {@code unfiltered} that satisfy a predicate.\n",
        "2392": "   * The returned map is a live view of {@code unfiltered}; changes to one affect the other.\n",
        "2393": "   *\n",
        "2394": "   * <p>The resulting map's {@code keySet()}, {@code entrySet()}, and {@code values()} views have\n",
        "2395": "   * iterators that don't support {@code remove()}, but all other methods are supported by the map\n",
        "2396": "   * and its views. When given a key/value pair that doesn't satisfy the predicate, the map's {@code\n",
        "2397": "   * put()} and {@code putAll()} methods throw an {@link IllegalArgumentException}. Similarly, the\n",
        "2398": "   * map's entries have a {@link Entry#setValue} method that throws an {@link\n",
        "2399": "   * IllegalArgumentException} when the existing key and the provided value don't satisfy the\n",
        "2400": "   * predicate.\n",
        "2401": "   *\n",
        "2402": "   * <p>When methods such as {@code removeAll()} and {@code clear()} are called on the filtered map\n",
        "2403": "   * or its views, only mappings that satisfy the filter will be removed from the underlying map.\n",
        "2404": "   *\n",
        "2405": "   * <p>The returned map isn't threadsafe or serializable, even if {@code unfiltered} is.\n",
        "2406": "   *\n",
        "2407": "   * <p>Many of the filtered map's methods, such as {@code size()}, iterate across every key/value\n",
        "2408": "   * mapping in the underlying map and determine which satisfy the filter. When a live view is\n",
        "2409": "   * <i>not</i> needed, it may be faster to copy the filtered map and use the copy.\n",
        "2410": "   *\n",
        "2411": "   * <p><b>Warning:</b> {@code entryPredicate} must be <i>consistent with equals</i>, as documented\n",
        "2412": "   * at {@link Predicate#apply}.\n",
        "2425": "   * Returns a sorted map containing the mappings in {@code unfiltered} that satisfy a predicate.\n",
        "2426": "   * The returned map is a live view of {@code unfiltered}; changes to one affect the other.\n",
        "2427": "   *\n",
        "2428": "   * <p>The resulting map's {@code keySet()}, {@code entrySet()}, and {@code values()} views have\n",
        "2429": "   * iterators that don't support {@code remove()}, but all other methods are supported by the map\n",
        "2430": "   * and its views. When given a key/value pair that doesn't satisfy the predicate, the map's {@code\n",
        "2431": "   * put()} and {@code putAll()} methods throw an {@link IllegalArgumentException}. Similarly, the\n",
        "2432": "   * map's entries have a {@link Entry#setValue} method that throws an {@link\n",
        "2433": "   * IllegalArgumentException} when the existing key and the provided value don't satisfy the\n",
        "2434": "   * predicate.\n",
        "2435": "   *\n",
        "2436": "   * <p>When methods such as {@code removeAll()} and {@code clear()} are called on the filtered map\n",
        "2437": "   * or its views, only mappings that satisfy the filter will be removed from the underlying map.\n",
        "2438": "   *\n",
        "2439": "   * <p>The returned map isn't threadsafe or serializable, even if {@code unfiltered} is.\n",
        "2440": "   *\n",
        "2441": "   * <p>Many of the filtered map's methods, such as {@code size()}, iterate across every key/value\n",
        "2442": "   * mapping in the underlying map and determine which satisfy the filter. When a live view is\n",
        "2443": "   * <i>not</i> needed, it may be faster to copy the filtered map and use the copy.\n",
        "2444": "   *\n",
        "2445": "   * <p><b>Warning:</b> {@code entryPredicate} must be <i>consistent with equals</i>, as documented\n",
        "2446": "   * at {@link Predicate#apply}.\n",
        "2466": "   * {@code put()}, {@code forcePut()} and {@code putAll()} methods throw an {@link\n",
        "2467": "   * IllegalArgumentException}. Similarly, the map's entries have an {@link Entry#setValue} method\n",
        "2468": "   * that throws an {@link IllegalArgumentException} when the existing key and the provided value\n",
        "2469": "   * don't satisfy the predicate.\n",
        "2477": "   * <p>Many of the filtered bimap's methods, such as {@code size()}, iterate across every key/value\n",
        "2478": "   * mapping in the underlying bimap and determine which satisfy the filter. When a live view is\n",
        "2479": "   * <i>not</i> needed, it may be faster to copy the filtered bimap and use the copy.\n",
        "2481": "   * <p><b>Warning:</b> {@code entryPredicate} must be <i>consistent with equals </i>, as documented\n",
        "2482": "   * at {@link Predicate#apply}.\n",
        "2496": "   * Support {@code clear()}, {@code removeAll()}, and {@code retainAll()} when filtering a filtered\n",
        "2497": "   * map.\n",
        "2659": "     * Entries in this set satisfy the predicate, but they don't validate the input to {@code\n",
        "2660": "     * Entry.setValue()}.\n",
        "2775": "   * Support {@code clear()}, {@code removeAll()}, and {@code retainAll()} when filtering a filtered\n",
        "2776": "   * sorted map.\n",
        "2880": "   * Support {@code clear()}, {@code removeAll()}, and {@code retainAll()} when filtering a filtered\n",
        "2881": "   * navigable map.\n",
        "3025": "   * Support {@code clear()}, {@code removeAll()}, and {@code retainAll()} when filtering a filtered\n",
        "3026": "   * map.\n",
        "3036": "    @RetainedWith private final BiMap<V, K> inverse;\n",
        "3256": "   * Returns a synchronized (thread-safe) navigable map backed by the specified navigable map. In\n",
        "3257": "   * order to guarantee serial access, it is critical that <b>all</b> access to the backing\n",
        "3258": "   * navigable map is accomplished through the returned navigable map (or its views).\n",
        "3260": "   * <p>It is imperative that the user manually synchronize on the returned navigable map when\n",
        "3261": "   * iterating over any of its collection views, or the collections views of any of its {@code\n",
        "3262": "   * descendingMap}, {@code subMap}, {@code headMap} or {@code tailMap} views.\n",
        "3264": "   * <pre>{@code\n",
        "3265": "   * NavigableMap<K, V> map = synchronizedNavigableMap(new TreeMap<K, V>());\n",
        "3267": "   * // Needn't be in synchronized block\n",
        "3268": "   * NavigableSet<K> set = map.navigableKeySet();\n",
        "3270": "   * synchronized (map) { // Synchronizing on map, not set!\n",
        "3271": "   *   Iterator<K> it = set.iterator(); // Must be in synchronized block\n",
        "3272": "   *   while (it.hasNext()) {\n",
        "3273": "   *     foo(it.next());\n",
        "3274": "   *   }\n",
        "3275": "   * }\n",
        "3276": "   * }</pre>\n",
        "3278": "   * <p>or:\n",
        "3280": "   * <pre>{@code\n",
        "3281": "   * NavigableMap<K, V> map = synchronizedNavigableMap(new TreeMap<K, V>());\n",
        "3282": "   * NavigableMap<K, V> map2 = map.subMap(foo, false, bar, true);\n",
        "3284": "   * // Needn't be in synchronized block\n",
        "3285": "   * NavigableSet<K> set2 = map2.descendingKeySet();\n",
        "3287": "   * synchronized (map) { // Synchronizing on map, not map2 or set2!\n",
        "3288": "   *   Iterator<K> it = set2.iterator(); // Must be in synchronized block\n",
        "3289": "   *   while (it.hasNext()) {\n",
        "3290": "   *     foo(it.next());\n",
        "3291": "   *   }\n",
        "3292": "   * }\n",
        "3293": "   * }</pre>\n",
        "3297": "   * <p>The returned navigable map will be serializable if the specified navigable map is\n",
        "3298": "   * serializable.\n",
        "3300": "   * @param navigableMap the navigable map to be \"wrapped\" in a synchronized navigable map.\n",
        "3311": "   * {@code AbstractMap} extension that makes it easy to cache customized keySet, values, and\n",
        "3312": "   * entrySet views.\n",
        "3317": "     * Creates the entry set to be returned by {@link #entrySet()}. This method is invoked at most\n",
        "3318": "     * once on a given map, at the time when {@code entrySet} is first called.\n",
        "3383": "   * Delegates to {@link Map#get}. Returns {@code null} on {@code ClassCastException} and {@code\n",
        "3384": "   * NullPointerException}.\n",
        "3396": "   * Delegates to {@link Map#containsKey}. Returns {@code false} on {@code ClassCastException} and\n",
        "3397": "   * {@code NullPointerException}.\n",
        "3409": "   * Delegates to {@link Map#remove}. Returns {@code null} on {@code ClassCastException} and {@code\n",
        "3410": "   * NullPointerException}.\n",
        "3421": "  /** An admittedly inefficient implementation of {@link Map#containsKey}. */\n",
        "3426": "  /** An implementation of {@link Map#containsValue}. */\n",
        "3432": "   * Implements {@code Collection.contains} safely for forwarding collections of map entries. If\n",
        "3433": "   * {@code o} is an instance of {@code Entry}, it is wrapped using {@link #unmodifiableEntry} to\n",
        "3434": "   * protect against a possible nefarious equals method.\n",
        "3436": "   * <p>Note that {@code c} is the backing (delegate) collection, rather than the forwarding\n",
        "3437": "   * collection.\n",
        "3451": "   * Implements {@code Collection.remove} safely for forwarding collections of map entries. If\n",
        "3452": "   * {@code o} is an instance of {@code Entry}, it is wrapped using {@link #unmodifiableEntry} to\n",
        "3453": "   * protect against a possible nefarious equals method.\n",
        "3455": "   * <p>Note that {@code c} is backing (delegate) collection, rather than the forwarding collection.\n",
        "3468": "  /** An implementation of {@link Map#equals}. */\n",
        "3479": "  /** An implementation of {@link Map#toString}. */\n",
        "3493": "  /** An implementation of {@link Map#putAll}. */\n",
        "4021": "  /** Returns a map from the ith element of list to i. */\n",
        "4034": "   * <p>This method delegates to the appropriate methods of {@link NavigableMap} (namely {@link\n",
        "4035": "   * NavigableMap#subMap(Object, boolean, Object, boolean) subMap()}, {@link\n",
        "4036": "   * NavigableMap#tailMap(Object, boolean) tailMap()}, and {@link NavigableMap#headMap(Object,\n",
        "4037": "   * boolean) headMap()}) to actually construct the view. Consult these methods for a full\n",
        "4038": "   * description of the returned view's behavior.\n",
        "4041": "   * ordering. {@code NavigableMap} on the other hand can specify a custom ordering via a {@link\n",
        "4042": "   * Comparator}, which can violate the natural ordering. Using this method (or in general using\n",
        "4043": "   * {@code Range}) with unnaturally-ordered maps can lead to unexpected and undefined behavior.\n"
    },
    "removed": {
        "67": " * Static utility methods pertaining to {@link Map} instances (including instances of\n",
        "68": " * {@link SortedMap}, {@link BiMap}, etc.). Also see this class's counterparts\n",
        "69": " * {@link Lists}, {@link Sets} and {@link Queues}.\n",
        "72": " * \"https://github.com/google/guava/wiki/CollectionUtilitiesExplained#maps\">\n",
        "73": " * {@code Maps}</a>.\n",
        "121": "   * Returns an immutable map instance containing the given entries.\n",
        "122": "   * Internally, the returned map will be backed by an {@link EnumMap}.\n",
        "124": "   * <p>The iteration order of the returned map follows the enum's iteration\n",
        "125": "   * order, not the order in which the elements appear in the given map.\n",
        "164": "   * <p><b>Note:</b> if mutability is not required, use {@link\n",
        "165": "   * ImmutableMap#of()} instead.\n",
        "167": "   * <p><b>Note:</b> if {@code K} is an {@code enum} type, use {@link\n",
        "168": "   * #newEnumMap} instead.\n",
        "170": "   * <p><b>Note for Java 7 and later:</b> this method is now unnecessary and\n",
        "171": "   * should be treated as deprecated. Instead, use the {@code HashMap}\n",
        "172": "   * constructor directly, taking advantage of the new\n",
        "182": "   * Creates a {@code HashMap} instance, with a high enough \"initial capacity\"\n",
        "183": "   * that it <i>should</i> hold {@code expectedSize} elements without growth.\n",
        "184": "   * This behavior cannot be broadly guaranteed, but it is observed to be true\n",
        "185": "   * for OpenJDK 1.7. It also can't be guaranteed that the method isn't\n",
        "186": "   * inadvertently <i>oversizing</i> the returned map.\n",
        "187": "   *\n",
        "188": "   * @param expectedSize the number of entries you expect to add to the\n",
        "189": "   *        returned map\n",
        "190": "   * @return a new, empty {@code HashMap} with enough capacity to hold {@code\n",
        "191": "   *         expectedSize} entries without resizing\n",
        "217": "   * Creates a <i>mutable</i> {@code HashMap} instance with the same mappings as\n",
        "218": "   * the specified map.\n",
        "220": "   * <p><b>Note:</b> if mutability is not required, use {@link\n",
        "221": "   * ImmutableMap#copyOf(Map)} instead.\n",
        "223": "   * <p><b>Note:</b> if {@code K} is an {@link Enum} type, use {@link\n",
        "224": "   * #newEnumMap} instead.\n",
        "226": "   * <p><b>Note for Java 7 and later:</b> this method is now unnecessary and\n",
        "227": "   * should be treated as deprecated. Instead, use the {@code HashMap}\n",
        "228": "   * constructor directly, taking advantage of the new\n",
        "232": "   * @return a new {@code HashMap} initialized with the mappings from {@code\n",
        "233": "   *         map}\n",
        "240": "   * Creates a <i>mutable</i>, empty, insertion-ordered {@code LinkedHashMap}\n",
        "241": "   * instance.\n",
        "243": "   * <p><b>Note:</b> if mutability is not required, use {@link\n",
        "244": "   * ImmutableMap#of()} instead.\n",
        "246": "   * <p><b>Note for Java 7 and later:</b> this method is now unnecessary and\n",
        "247": "   * should be treated as deprecated. Instead, use the {@code LinkedHashMap}\n",
        "248": "   * constructor directly, taking advantage of the new\n",
        "249": "   * <a href=\"http://goo.gl/iz2Wi\">\"diamond\" syntax</a>.\n",
        "258": "   * Creates a {@code LinkedHashMap} instance, with a high enough\n",
        "259": "   * \"initial capacity\" that it <i>should</i> hold {@code expectedSize}\n",
        "260": "   * elements without growth. This behavior cannot be broadly guaranteed, but\n",
        "261": "   * it is observed to be true for OpenJDK 1.7. It also can't be guaranteed\n",
        "264": "   * @param expectedSize the number of entries you expect to add to the\n",
        "265": "   *        returned map\n",
        "266": "   * @return a new, empty {@code LinkedHashMap} with enough capacity to hold\n",
        "267": "   *         {@code expectedSize} entries without resizing\n",
        "276": "   * Creates a <i>mutable</i>, insertion-ordered {@code LinkedHashMap} instance\n",
        "277": "   * with the same mappings as the specified map.\n",
        "279": "   * <p><b>Note:</b> if mutability is not required, use {@link\n",
        "280": "   * ImmutableMap#copyOf(Map)} instead.\n",
        "282": "   * <p><b>Note for Java 7 and later:</b> this method is now unnecessary and\n",
        "283": "   * should be treated as deprecated. Instead, use the {@code LinkedHashMap}\n",
        "284": "   * constructor directly, taking advantage of the new\n",
        "285": "   * <a href=\"http://goo.gl/iz2Wi\">\"diamond\" syntax</a>.\n",
        "288": "   * @return a new, {@code LinkedHashMap} initialized with the mappings from\n",
        "289": "   *         {@code map}\n",
        "305": "   * Creates a <i>mutable</i>, empty {@code TreeMap} instance using the natural\n",
        "306": "   * ordering of its elements.\n",
        "308": "   * <p><b>Note:</b> if mutability is not required, use {@link\n",
        "309": "   * ImmutableSortedMap#of()} instead.\n",
        "311": "   * <p><b>Note for Java 7 and later:</b> this method is now unnecessary and\n",
        "312": "   * should be treated as deprecated. Instead, use the {@code TreeMap}\n",
        "313": "   * constructor directly, taking advantage of the new\n",
        "323": "   * Creates a <i>mutable</i> {@code TreeMap} instance with the same mappings as\n",
        "324": "   * the specified map and using the same ordering as the specified map.\n",
        "329": "   * <p><b>Note for Java 7 and later:</b> this method is now unnecessary and\n",
        "330": "   * should be treated as deprecated. Instead, use the {@code TreeMap}\n",
        "331": "   * constructor directly, taking advantage of the new\n",
        "334": "   * @param map the sorted map whose mappings are to be placed in the new map\n",
        "335": "   *        and whose comparator is to be used to sort the new map\n",
        "336": "   * @return a new {@code TreeMap} initialized with the mappings from {@code\n",
        "337": "   *         map} and using the comparator of {@code map}\n",
        "344": "   * Creates a <i>mutable</i>, empty {@code TreeMap} instance using the given\n",
        "345": "   * comparator.\n",
        "350": "   * <p><b>Note for Java 7 and later:</b> this method is now unnecessary and\n",
        "351": "   * should be treated as deprecated. Instead, use the {@code TreeMap}\n",
        "352": "   * constructor directly, taking advantage of the new\n",
        "380": "   * <p><b>Note for Java 7 and later:</b> this method is now unnecessary and\n",
        "381": "   * should be treated as deprecated. Instead, use the {@code EnumMap}\n",
        "382": "   * constructor directly, taking advantage of the new\n",
        "386": "   * @return a new {@code EnumMap} initialized with the mappings from {@code\n",
        "387": "   *         map}\n",
        "388": "   * @throws IllegalArgumentException if {@code m} is not an {@code EnumMap}\n",
        "389": "   *         instance and contains no mappings\n",
        "398": "   * <p><b>Note for Java 7 and later:</b> this method is now unnecessary and\n",
        "399": "   * should be treated as deprecated. Instead, use the {@code IdentityHashMap}\n",
        "400": "   * constructor directly, taking advantage of the new\n",
        "401": "   * <a href=\"http://goo.gl/iz2Wi\">\"diamond\" syntax</a>.\n",
        "410": "   * Computes the difference between two maps. This difference is an immutable\n",
        "411": "   * snapshot of the state of the maps at the time this method is called. It\n",
        "412": "   * will never change, even if the maps change at a later time.\n",
        "414": "   * <p>Since this method uses {@code HashMap} instances internally, the keys of\n",
        "415": "   * the supplied maps must be well-behaved with respect to\n",
        "416": "   * {@link Object#equals} and {@link Object#hashCode}.\n",
        "418": "   * <p><b>Note:</b>If you only need to know whether two maps have the same\n",
        "419": "   * mappings, call {@code left.equals(right)} instead of this method.\n",
        "436": "   * Computes the difference between two maps. This difference is an immutable\n",
        "437": "   * snapshot of the state of the maps at the time this method is called. It\n",
        "438": "   * will never change, even if the maps change at a later time.\n",
        "440": "   * <p>Since this method uses {@code HashMap} instances internally, the keys of\n",
        "441": "   * the supplied maps must be well-behaved with respect to\n",
        "442": "   * {@link Object#equals} and {@link Object#hashCode}.\n",
        "446": "   * @param valueEquivalence the equivalence relationship to use to compare\n",
        "447": "   *    values\n",
        "625": "   * Computes the difference between two sorted maps, using the comparator of\n",
        "626": "   * the left map, or {@code Ordering.natural()} if the left map uses the\n",
        "627": "   * natural ordering of its elements. This difference is an immutable snapshot\n",
        "628": "   * of the state of the maps at the time this method is called. It will never\n",
        "629": "   * change, even if the maps change at a later time.\n",
        "631": "   * <p>Since this method uses {@code TreeMap} instances internally, the keys of\n",
        "632": "   * the right map must all compare as distinct according to the comparator\n",
        "633": "   * of the left map.\n",
        "635": "   * <p><b>Note:</b>If you only need to know whether two sorted maps have the\n",
        "636": "   * same mappings, call {@code left.equals(right)} instead of this method.\n",
        "689": "   * Returns the specified comparator if not null; otherwise returns {@code\n",
        "690": "   * Ordering.natural()}. This method is an abomination of generics; the only\n",
        "691": "   * purpose of this method is to contain the ugly type-casting in one place.\n",
        "702": "   * Returns a live {@link Map} view whose keys are the contents of {@code set}\n",
        "703": "   * and whose values are computed on demand using {@code function}. To get an\n",
        "704": "   * immutable <i>copy</i> instead, use {@link #toMap(Iterable, Function)}.\n",
        "705": "   *\n",
        "706": "   * <p>Specifically, for each {@code k} in the backing set, the returned map\n",
        "707": "   * has an entry mapping {@code k} to {@code function.apply(k)}. The {@code\n",
        "708": "   * keySet}, {@code values}, and {@code entrySet} views of the returned map\n",
        "709": "   * iterate in the same order as the backing set.\n",
        "710": "   *\n",
        "711": "   * <p>Modifications to the backing set are read through to the returned map.\n",
        "712": "   * The returned map supports removal operations if the backing set does.\n",
        "713": "   * Removal operations write through to the backing set.  The returned map\n",
        "714": "   * does not support put operations.\n",
        "715": "   *\n",
        "716": "   * <p><b>Warning:</b> If the function rejects {@code null}, caution is\n",
        "717": "   * required to make sure the set does not contain {@code null}, because the\n",
        "718": "   * view cannot stop {@code null} from being added to the set.\n",
        "719": "   *\n",
        "720": "   * <p><b>Warning:</b> This method assumes that for any instance {@code k} of\n",
        "721": "   * key type {@code K}, {@code k.equals(k2)} implies that {@code k2} is also\n",
        "722": "   * of type {@code K}. Using a key type for which this may not hold, such as\n",
        "723": "   * {@code ArrayList}, may risk a {@code ClassCastException} when calling\n",
        "724": "   * methods on the resulting map view.\n",
        "733": "   * Returns a view of the sorted set as a map, mapping keys from the set\n",
        "734": "   * according to the specified function.\n",
        "736": "   * <p>Specifically, for each {@code k} in the backing set, the returned map\n",
        "737": "   * has an entry mapping {@code k} to {@code function.apply(k)}. The {@code\n",
        "738": "   * keySet}, {@code values}, and {@code entrySet} views of the returned map\n",
        "739": "   * iterate in the same order as the backing set.\n",
        "741": "   * <p>Modifications to the backing set are read through to the returned map.\n",
        "742": "   * The returned map supports removal operations if the backing set does.\n",
        "743": "   * Removal operations write through to the backing set.  The returned map does\n",
        "744": "   * not support put operations.\n",
        "746": "   * <p><b>Warning:</b> If the function rejects {@code null}, caution is\n",
        "747": "   * required to make sure the set does not contain {@code null}, because the\n",
        "748": "   * view cannot stop {@code null} from being added to the set.\n",
        "750": "   * <p><b>Warning:</b> This method assumes that for any instance {@code k} of\n",
        "751": "   * key type {@code K}, {@code k.equals(k2)} implies that {@code k2} is also of\n",
        "752": "   * type {@code K}. Using a key type for which this may not hold, such as\n",
        "753": "   * {@code ArrayList}, may risk a {@code ClassCastException} when calling\n",
        "754": "   * methods on the resulting map view.\n",
        "763": "   * Returns a view of the navigable set as a map, mapping keys from the set\n",
        "764": "   * according to the specified function.\n",
        "766": "   * <p>Specifically, for each {@code k} in the backing set, the returned map\n",
        "767": "   * has an entry mapping {@code k} to {@code function.apply(k)}. The {@code\n",
        "768": "   * keySet}, {@code values}, and {@code entrySet} views of the returned map\n",
        "769": "   * iterate in the same order as the backing set.\n",
        "771": "   * <p>Modifications to the backing set are read through to the returned map.\n",
        "772": "   * The returned map supports removal operations if the backing set does.\n",
        "773": "   * Removal operations write through to the backing set.  The returned map\n",
        "774": "   * does not support put operations.\n",
        "776": "   * <p><b>Warning:</b> If the function rejects {@code null}, caution is\n",
        "777": "   * required to make sure the set does not contain {@code null}, because the\n",
        "778": "   * view cannot stop {@code null} from being added to the set.\n",
        "780": "   * <p><b>Warning:</b> This method assumes that for any instance {@code k} of\n",
        "781": "   * key type {@code K}, {@code k.equals(k2)} implies that {@code k2} is also\n",
        "782": "   * of type {@code K}. Using a key type for which this may not hold, such as\n",
        "783": "   * {@code ArrayList}, may risk a {@code ClassCastException} when calling\n",
        "784": "   * methods on the resulting map view.\n",
        "1120": "   * Returns an immutable map whose keys are the distinct elements of {@code\n",
        "1121": "   * keys} and whose value for each key was computed by {@code valueFunction}.\n",
        "1122": "   * The map's iteration order is the order of the first appearance of each key\n",
        "1123": "   * in {@code keys}.\n",
        "1124": "   *\n",
        "1125": "   * <p>When there are multiple instances of a key in {@code keys}, it is\n",
        "1126": "   * unspecified whether {@code valueFunction} will be applied to more than one\n",
        "1127": "   * instance of that key and, if it is, which result will be mapped to that\n",
        "1128": "   * key in the returned map.\n",
        "1129": "   *\n",
        "1130": "   * <p>If {@code keys} is a {@link Set}, a live view can be obtained instead of\n",
        "1131": "   * a copy using {@link Maps#asMap(Set, Function)}.\n",
        "1132": "   *\n",
        "1133": "   * @throws NullPointerException if any element of {@code keys} is\n",
        "1134": "   *     {@code null}, or if {@code valueFunction} produces {@code null}\n",
        "1135": "   *     for any key\n",
        "1144": "   * Returns an immutable map whose keys are the distinct elements of {@code\n",
        "1145": "   * keys} and whose value for each key was computed by {@code valueFunction}.\n",
        "1146": "   * The map's iteration order is the order of the first appearance of each key\n",
        "1147": "   * in {@code keys}.\n",
        "1148": "   *\n",
        "1149": "   * <p>When there are multiple instances of a key in {@code keys}, it is\n",
        "1150": "   * unspecified whether {@code valueFunction} will be applied to more than one\n",
        "1151": "   * instance of that key and, if it is, which result will be mapped to that\n",
        "1152": "   * key in the returned map.\n",
        "1153": "   *\n",
        "1154": "   * @throws NullPointerException if any element of {@code keys} is\n",
        "1155": "   *     {@code null}, or if {@code valueFunction} produces {@code null}\n",
        "1156": "   *     for any key\n",
        "1172": "   * Returns a map with the given {@code values}, indexed by keys derived from\n",
        "1173": "   * those values. In other words, each input value produces an entry in the map\n",
        "1174": "   * whose key is the result of applying {@code keyFunction} to that value.\n",
        "1175": "   * These entries appear in the same order as the input values. Example usage:\n",
        "1176": "   * <pre>   {@code\n",
        "1178": "   *   Color red = new Color(\"red\", 255, 0, 0);\n",
        "1179": "   *   ...\n",
        "1180": "   *   ImmutableSet<Color> allColors = ImmutableSet.of(red, green, blue);\n",
        "1182": "   *   Map<String, Color> colorForName =\n",
        "1183": "   *       uniqueIndex(allColors, toStringFunction());\n",
        "1184": "   *   assertThat(colorForName).containsEntry(\"red\", red);}</pre>\n",
        "1191": "   * @return a map mapping the result of evaluating the function {@code\n",
        "1192": "   *         keyFunction} on each value in the input collection to that value\n",
        "1193": "   * @throws IllegalArgumentException if {@code keyFunction} produces the same\n",
        "1194": "   *         key for more than one value in the input collection\n",
        "1195": "   * @throws NullPointerException if any element of {@code values} is {@code\n",
        "1196": "   *         null}, or if {@code keyFunction} produces {@code null} for any value\n",
        "1206": "   * Returns a map with the given {@code values}, indexed by keys derived from\n",
        "1207": "   * those values. In other words, each input value produces an entry in the map\n",
        "1208": "   * whose key is the result of applying {@code keyFunction} to that value.\n",
        "1209": "   * These entries appear in the same order as the input values. Example usage:\n",
        "1210": "   * <pre>   {@code\n",
        "1212": "   *   Color red = new Color(\"red\", 255, 0, 0);\n",
        "1213": "   *   ...\n",
        "1214": "   *   Iterator<Color> allColors = ImmutableSet.of(red, green, blue).iterator();\n",
        "1216": "   *   Map<String, Color> colorForName =\n",
        "1217": "   *       uniqueIndex(allColors, toStringFunction());\n",
        "1218": "   *   assertThat(colorForName).containsEntry(\"red\", red);}</pre>\n",
        "1225": "   * @return a map mapping the result of evaluating the function {@code\n",
        "1226": "   *         keyFunction} on each value in the input collection to that value\n",
        "1227": "   * @throws IllegalArgumentException if {@code keyFunction} produces the same\n",
        "1228": "   *         key for more than one value in the input collection\n",
        "1229": "   * @throws NullPointerException if any element of {@code values} is {@code\n",
        "1230": "   *         null}, or if {@code keyFunction} produces {@code null} for any value\n",
        "1252": "   * Creates an {@code ImmutableMap<String, String>} from a {@code Properties}\n",
        "1253": "   * instance. Properties normally derive from {@code Map<Object, Object>}, but\n",
        "1254": "   * they typically contain strings, which is awkward. This method lets you get\n",
        "1255": "   * a plain-old-{@code Map} out of a {@code Properties}.\n",
        "1259": "   * @throws ClassCastException if any key in {@code Properties} is not a {@code\n",
        "1260": "   *         String}\n",
        "1261": "   * @throws NullPointerException if any key or value in {@code Properties} is\n",
        "1262": "   *         null\n",
        "1277": "   * Returns an immutable map entry with the specified key and value. The {@link\n",
        "1278": "   * Entry#setValue} operation throws an {@link UnsupportedOperationException}.\n",
        "1291": "   * Returns an unmodifiable view of the specified set of entries. The {@link\n",
        "1292": "   * Entry#setValue} operation throws an {@link UnsupportedOperationException},\n",
        "1293": "   * as do any operations that would modify the returned set.\n",
        "1303": "   * Returns an unmodifiable view of the specified map entry. The {@link\n",
        "1304": "   * Entry#setValue} operation throws an {@link UnsupportedOperationException}.\n",
        "1305": "   * This also has the side-effect of redefining {@code equals} to comply with\n",
        "1306": "   * the Entry contract, to avoid a possible nefarious implementation of equals.\n",
        "1393": "   * Returns a {@link Converter} that converts values using {@link BiMap#get bimap.get()},\n",
        "1394": "   * and whose inverse view converts values using\n",
        "1395": "   * {@link BiMap#inverse bimap.inverse()}{@code .get()}.\n",
        "1397": "   * <p>To use a plain {@link Map} as a {@link Function}, see\n",
        "1398": "   * {@link com.google.common.base.Functions#forMap(Map)} or\n",
        "1399": "   * {@link com.google.common.base.Functions#forMap(Map, Object)}.\n",
        "1455": "   * Returns a synchronized (thread-safe) bimap backed by the specified bimap.\n",
        "1456": "   * In order to guarantee serial access, it is critical that <b>all</b> access\n",
        "1457": "   * to the backing bimap is accomplished through the returned bimap.\n",
        "1458": "   *\n",
        "1459": "   * <p>It is imperative that the user manually synchronize on the returned map\n",
        "1460": "   * when accessing any of its collection views: <pre>   {@code\n",
        "1461": "   *\n",
        "1462": "   *   BiMap<Long, String> map = Maps.synchronizedBiMap(\n",
        "1463": "   *       HashBiMap.<Long, String>create());\n",
        "1464": "   *   ...\n",
        "1465": "   *   Set<Long> set = map.keySet();  // Needn't be in synchronized block\n",
        "1466": "   *   ...\n",
        "1467": "   *   synchronized (map) {  // Synchronizing on map, not set!\n",
        "1468": "   *     Iterator<Long> it = set.iterator(); // Must be in synchronized block\n",
        "1469": "   *     while (it.hasNext()) {\n",
        "1470": "   *       foo(it.next());\n",
        "1471": "   *     }\n",
        "1472": "   *   }}</pre>\n",
        "1476": "   * <p>The returned bimap will be serializable if the specified bimap is\n",
        "1477": "   * serializable.\n",
        "1487": "   * Returns an unmodifiable view of the specified bimap. This method allows\n",
        "1488": "   * modules to provide users with \"read-only\" access to internal bimaps. Query\n",
        "1489": "   * operations on the returned bimap \"read through\" to the specified bimap, and\n",
        "1490": "   * attempts to modify the returned map, whether direct or via its collection\n",
        "1491": "   * views, result in an {@code UnsupportedOperationException}.\n",
        "1493": "   * <p>The returned bimap will be serializable if the specified bimap is\n",
        "1494": "   * serializable.\n",
        "1508": "    @RetainedWith\n",
        "1509": "    BiMap<V, K> inverse;\n",
        "1546": "   * Returns a view of a map where each value is transformed by a function. All\n",
        "1547": "   * other properties of the map, such as iteration order, are left intact. For\n",
        "1548": "   * example, the code: <pre>   {@code\n",
        "1549": "   *\n",
        "1550": "   *   Map<String, Integer> map = ImmutableMap.of(\"a\", 4, \"b\", 9);\n",
        "1551": "   *   Function<Integer, Double> sqrt =\n",
        "1552": "   *       new Function<Integer, Double>() {\n",
        "1553": "   *         public Double apply(Integer in) {\n",
        "1554": "   *           return Math.sqrt((int) in);\n",
        "1555": "   *         }\n",
        "1556": "   *       };\n",
        "1557": "   *   Map<String, Double> transformed = Maps.transformValues(map, sqrt);\n",
        "1558": "   *   System.out.println(transformed);}</pre>\n",
        "1562": "   * <p>Changes in the underlying map are reflected in this view. Conversely,\n",
        "1563": "   * this view supports removal operations, and these are reflected in the\n",
        "1564": "   * underlying map.\n",
        "1566": "   * <p>It's acceptable for the underlying map to contain null keys, and even\n",
        "1567": "   * null values provided that the function is capable of accepting null input.\n",
        "1568": "   * The transformed map might contain null values, if the function sometimes\n",
        "1569": "   * gives a null result.\n",
        "1571": "   * <p>The returned map is not thread-safe or serializable, even if the\n",
        "1572": "   * underlying map is.\n",
        "1574": "   * <p>The function is applied lazily, invoked when needed. This is necessary\n",
        "1575": "   * for the returned map to be a view, but it means that the function will be\n",
        "1576": "   * applied many times for bulk operations like {@link Map#containsValue} and\n",
        "1577": "   * {@code Map.toString()}. For this to perform well, {@code function} should\n",
        "1578": "   * be fast. To avoid lazy evaluation when the returned map doesn't need to be\n",
        "1579": "   * a view, copy the returned map into a new map of your choosing.\n",
        "1587": "   * Returns a view of a sorted map where each value is transformed by a\n",
        "1588": "   * function. All other properties of the map, such as iteration order, are\n",
        "1589": "   * left intact. For example, the code: <pre>   {@code\n",
        "1590": "   *\n",
        "1591": "   *   SortedMap<String, Integer> map = ImmutableSortedMap.of(\"a\", 4, \"b\", 9);\n",
        "1592": "   *   Function<Integer, Double> sqrt =\n",
        "1593": "   *       new Function<Integer, Double>() {\n",
        "1594": "   *         public Double apply(Integer in) {\n",
        "1595": "   *           return Math.sqrt((int) in);\n",
        "1596": "   *         }\n",
        "1597": "   *       };\n",
        "1598": "   *   SortedMap<String, Double> transformed =\n",
        "1599": "   *        Maps.transformValues(map, sqrt);\n",
        "1600": "   *   System.out.println(transformed);}</pre>\n",
        "1604": "   * <p>Changes in the underlying map are reflected in this view. Conversely,\n",
        "1605": "   * this view supports removal operations, and these are reflected in the\n",
        "1606": "   * underlying map.\n",
        "1608": "   * <p>It's acceptable for the underlying map to contain null keys, and even\n",
        "1609": "   * null values provided that the function is capable of accepting null input.\n",
        "1610": "   * The transformed map might contain null values, if the function sometimes\n",
        "1611": "   * gives a null result.\n",
        "1613": "   * <p>The returned map is not thread-safe or serializable, even if the\n",
        "1614": "   * underlying map is.\n",
        "1616": "   * <p>The function is applied lazily, invoked when needed. This is necessary\n",
        "1617": "   * for the returned map to be a view, but it means that the function will be\n",
        "1618": "   * applied many times for bulk operations like {@link Map#containsValue} and\n",
        "1619": "   * {@code Map.toString()}. For this to perform well, {@code function} should\n",
        "1620": "   * be fast. To avoid lazy evaluation when the returned map doesn't need to be\n",
        "1621": "   * a view, copy the returned map into a new map of your choosing.\n",
        "1631": "   * Returns a view of a navigable map where each value is transformed by a\n",
        "1632": "   * function. All other properties of the map, such as iteration order, are\n",
        "1633": "   * left intact.  For example, the code: <pre>   {@code\n",
        "1634": "   *\n",
        "1635": "   *   NavigableMap<String, Integer> map = Maps.newTreeMap();\n",
        "1636": "   *   map.put(\"a\", 4);\n",
        "1637": "   *   map.put(\"b\", 9);\n",
        "1638": "   *   Function<Integer, Double> sqrt =\n",
        "1639": "   *       new Function<Integer, Double>() {\n",
        "1640": "   *         public Double apply(Integer in) {\n",
        "1641": "   *           return Math.sqrt((int) in);\n",
        "1642": "   *         }\n",
        "1643": "   *       };\n",
        "1644": "   *   NavigableMap<String, Double> transformed =\n",
        "1645": "   *        Maps.transformNavigableValues(map, sqrt);\n",
        "1646": "   *   System.out.println(transformed);}</pre>\n",
        "1650": "   * Changes in the underlying map are reflected in this view.\n",
        "1651": "   * Conversely, this view supports removal operations, and these are reflected\n",
        "1652": "   * in the underlying map.\n",
        "1654": "   * <p>It's acceptable for the underlying map to contain null keys, and even\n",
        "1655": "   * null values provided that the function is capable of accepting null input.\n",
        "1656": "   * The transformed map might contain null values, if the function sometimes\n",
        "1657": "   * gives a null result.\n",
        "1659": "   * <p>The returned map is not thread-safe or serializable, even if the\n",
        "1660": "   * underlying map is.\n",
        "1662": "   * <p>The function is applied lazily, invoked when needed. This is necessary\n",
        "1663": "   * for the returned map to be a view, but it means that the function will be\n",
        "1664": "   * applied many times for bulk operations like {@link Map#containsValue} and\n",
        "1665": "   * {@code Map.toString()}. For this to perform well, {@code function} should\n",
        "1666": "   * be fast. To avoid lazy evaluation when the returned map doesn't need to be\n",
        "1667": "   * a view, copy the returned map into a new map of your choosing.\n",
        "1678": "   * Returns a view of a map whose values are derived from the original map's\n",
        "1679": "   * entries. In contrast to {@link #transformValues}, this method's\n",
        "1680": "   * entry-transformation logic may depend on the key as well as the value.\n",
        "1681": "   *\n",
        "1682": "   * <p>All other properties of the transformed map, such as iteration order,\n",
        "1683": "   * are left intact. For example, the code: <pre>   {@code\n",
        "1684": "   *\n",
        "1685": "   *   Map<String, Boolean> options =\n",
        "1686": "   *       ImmutableMap.of(\"verbose\", true, \"sort\", false);\n",
        "1687": "   *   EntryTransformer<String, Boolean, String> flagPrefixer =\n",
        "1688": "   *       new EntryTransformer<String, Boolean, String>() {\n",
        "1689": "   *         public String transformEntry(String key, Boolean value) {\n",
        "1690": "   *           return value ? key : \"no\" + key;\n",
        "1691": "   *         }\n",
        "1692": "   *       };\n",
        "1693": "   *   Map<String, String> transformed =\n",
        "1694": "   *       Maps.transformEntries(options, flagPrefixer);\n",
        "1695": "   *   System.out.println(transformed);}</pre>\n",
        "1699": "   * <p>Changes in the underlying map are reflected in this view. Conversely,\n",
        "1700": "   * this view supports removal operations, and these are reflected in the\n",
        "1701": "   * underlying map.\n",
        "1702": "   *\n",
        "1703": "   * <p>It's acceptable for the underlying map to contain null keys and null\n",
        "1704": "   * values provided that the transformer is capable of accepting null inputs.\n",
        "1705": "   * The transformed map might contain null values if the transformer sometimes\n",
        "1706": "   * gives a null result.\n",
        "1707": "   *\n",
        "1708": "   * <p>The returned map is not thread-safe or serializable, even if the\n",
        "1709": "   * underlying map is.\n",
        "1710": "   *\n",
        "1711": "   * <p>The transformer is applied lazily, invoked when needed. This is\n",
        "1712": "   * necessary for the returned map to be a view, but it means that the\n",
        "1713": "   * transformer will be applied many times for bulk operations like {@link\n",
        "1714": "   * Map#containsValue} and {@link Object#toString}. For this to perform well,\n",
        "1715": "   * {@code transformer} should be fast. To avoid lazy evaluation when the\n",
        "1716": "   * returned map doesn't need to be a view, copy the returned map into a new\n",
        "1717": "   * map of your choosing.\n",
        "1718": "   *\n",
        "1719": "   * <p><b>Warning:</b> This method assumes that for any instance {@code k} of\n",
        "1720": "   * {@code EntryTransformer} key type {@code K}, {@code k.equals(k2)} implies\n",
        "1721": "   * that {@code k2} is also of type {@code K}. Using an {@code\n",
        "1722": "   * EntryTransformer} key type for which this may not hold, such as {@code\n",
        "1723": "   * ArrayList}, may risk a {@code ClassCastException} when calling methods on\n",
        "1724": "   * the transformed map.\n",
        "1734": "   * Returns a view of a sorted map whose values are derived from the original\n",
        "1735": "   * sorted map's entries. In contrast to {@link #transformValues}, this\n",
        "1736": "   * method's entry-transformation logic may depend on the key as well as the\n",
        "1737": "   * value.\n",
        "1738": "   *\n",
        "1739": "   * <p>All other properties of the transformed map, such as iteration order,\n",
        "1740": "   * are left intact. For example, the code: <pre>   {@code\n",
        "1741": "   *\n",
        "1742": "   *   Map<String, Boolean> options =\n",
        "1743": "   *       ImmutableSortedMap.of(\"verbose\", true, \"sort\", false);\n",
        "1744": "   *   EntryTransformer<String, Boolean, String> flagPrefixer =\n",
        "1745": "   *       new EntryTransformer<String, Boolean, String>() {\n",
        "1746": "   *         public String transformEntry(String key, Boolean value) {\n",
        "1747": "   *           return value ? key : \"yes\" + key;\n",
        "1748": "   *         }\n",
        "1749": "   *       };\n",
        "1750": "   *   SortedMap<String, String> transformed =\n",
        "1751": "   *       Maps.transformEntries(options, flagPrefixer);\n",
        "1752": "   *   System.out.println(transformed);}</pre>\n",
        "1756": "   * <p>Changes in the underlying map are reflected in this view. Conversely,\n",
        "1757": "   * this view supports removal operations, and these are reflected in the\n",
        "1758": "   * underlying map.\n",
        "1759": "   *\n",
        "1760": "   * <p>It's acceptable for the underlying map to contain null keys and null\n",
        "1761": "   * values provided that the transformer is capable of accepting null inputs.\n",
        "1762": "   * The transformed map might contain null values if the transformer sometimes\n",
        "1763": "   * gives a null result.\n",
        "1764": "   *\n",
        "1765": "   * <p>The returned map is not thread-safe or serializable, even if the\n",
        "1766": "   * underlying map is.\n",
        "1767": "   *\n",
        "1768": "   * <p>The transformer is applied lazily, invoked when needed. This is\n",
        "1769": "   * necessary for the returned map to be a view, but it means that the\n",
        "1770": "   * transformer will be applied many times for bulk operations like {@link\n",
        "1771": "   * Map#containsValue} and {@link Object#toString}. For this to perform well,\n",
        "1772": "   * {@code transformer} should be fast. To avoid lazy evaluation when the\n",
        "1773": "   * returned map doesn't need to be a view, copy the returned map into a new\n",
        "1774": "   * map of your choosing.\n",
        "1775": "   *\n",
        "1776": "   * <p><b>Warning:</b> This method assumes that for any instance {@code k} of\n",
        "1777": "   * {@code EntryTransformer} key type {@code K}, {@code k.equals(k2)} implies\n",
        "1778": "   * that {@code k2} is also of type {@code K}. Using an {@code\n",
        "1779": "   * EntryTransformer} key type for which this may not hold, such as {@code\n",
        "1780": "   * ArrayList}, may risk a {@code ClassCastException} when calling methods on\n",
        "1781": "   * the transformed map.\n",
        "1791": "   * Returns a view of a navigable map whose values are derived from the\n",
        "1792": "   * original navigable map's entries. In contrast to {@link\n",
        "1793": "   * #transformValues}, this method's entry-transformation logic may\n",
        "1796": "   * <p>All other properties of the transformed map, such as iteration order,\n",
        "1797": "   * are left intact. For example, the code: <pre>   {@code\n",
        "1798": "   *\n",
        "1799": "   *   NavigableMap<String, Boolean> options = Maps.newTreeMap();\n",
        "1800": "   *   options.put(\"verbose\", false);\n",
        "1801": "   *   options.put(\"sort\", true);\n",
        "1802": "   *   EntryTransformer<String, Boolean, String> flagPrefixer =\n",
        "1803": "   *       new EntryTransformer<String, Boolean, String>() {\n",
        "1804": "   *         public String transformEntry(String key, Boolean value) {\n",
        "1805": "   *           return value ? key : (\"yes\" + key);\n",
        "1806": "   *         }\n",
        "1807": "   *       };\n",
        "1808": "   *   NavigableMap<String, String> transformed =\n",
        "1809": "   *       LabsMaps.transformNavigableEntries(options, flagPrefixer);\n",
        "1810": "   *   System.out.println(transformed);}</pre>\n",
        "1814": "   * <p>Changes in the underlying map are reflected in this view.\n",
        "1815": "   * Conversely, this view supports removal operations, and these are reflected\n",
        "1816": "   * in the underlying map.\n",
        "1817": "   *\n",
        "1818": "   * <p>It's acceptable for the underlying map to contain null keys and null\n",
        "1819": "   * values provided that the transformer is capable of accepting null inputs.\n",
        "1820": "   * The transformed map might contain null values if the transformer sometimes\n",
        "1821": "   * gives a null result.\n",
        "1822": "   *\n",
        "1823": "   * <p>The returned map is not thread-safe or serializable, even if the\n",
        "1824": "   * underlying map is.\n",
        "1825": "   *\n",
        "1826": "   * <p>The transformer is applied lazily, invoked when needed. This is\n",
        "1827": "   * necessary for the returned map to be a view, but it means that the\n",
        "1828": "   * transformer will be applied many times for bulk operations like {@link\n",
        "1829": "   * Map#containsValue} and {@link Object#toString}. For this to perform well,\n",
        "1830": "   * {@code transformer} should be fast. To avoid lazy evaluation when the\n",
        "1831": "   * returned map doesn't need to be a view, copy the returned map into a new\n",
        "1832": "   * map of your choosing.\n",
        "1833": "   *\n",
        "1834": "   * <p><b>Warning:</b> This method assumes that for any instance {@code k} of\n",
        "1835": "   * {@code EntryTransformer} key type {@code K}, {@code k.equals(k2)} implies\n",
        "1836": "   * that {@code k2} is also of type {@code K}. Using an {@code\n",
        "1837": "   * EntryTransformer} key type for which this may not hold, such as {@code\n",
        "1838": "   * ArrayList}, may risk a {@code ClassCastException} when calling methods on\n",
        "1839": "   * the transformed map.\n",
        "1850": "   * A transformation of the value of a key-value pair, using both key and value\n",
        "1851": "   * as inputs. To apply the transformation to a map, use\n",
        "1852": "   * {@link Maps#transformEntries(Map, EntryTransformer)}.\n",
        "1861": "     * Determines an output value based on a key-value pair. This method is\n",
        "1862": "     * <i>generally expected</i>, but not absolutely required, to have the\n",
        "1863": "     * following properties:\n",
        "1866": "     * <li>Its execution does not cause any observable side effects.\n",
        "1867": "     * <li>The computation is <i>consistent with equals</i>; that is,\n",
        "1868": "     *     {@link Objects#equal Objects.equal}{@code (k1, k2) &&}\n",
        "1869": "     *     {@link Objects#equal}{@code (v1, v2)} implies that {@code\n",
        "1870": "     *     Objects.equal(transformer.transform(k1, v1),\n",
        "1871": "     *     transformer.transform(k2, v2))}.\n",
        "1874": "     * @throws NullPointerException if the key or value is null and this\n",
        "1875": "     *     transformer does not accept null arguments\n",
        "1880": "  /**\n",
        "1881": "   * Views a function as an entry transformer that ignores the entry key.\n",
        "1882": "   */\n",
        "1905": "  /**\n",
        "1906": "   * Views an entry transformer as a function from {@code Entry} to values.\n",
        "1907": "   */\n",
        "1919": "  /**\n",
        "1920": "   * Returns a view of an entry transformed by the specified transformer.\n",
        "1921": "   */\n",
        "1939": "  /**\n",
        "1940": "   * Views an entry transformer as a function from entries to entries.\n",
        "1941": "   */\n",
        "2193": "   * Returns a map containing the mappings in {@code unfiltered} whose keys\n",
        "2194": "   * satisfy a predicate. The returned map is a live view of {@code unfiltered};\n",
        "2195": "   * changes to one affect the other.\n",
        "2196": "   *\n",
        "2197": "   * <p>The resulting map's {@code keySet()}, {@code entrySet()}, and {@code\n",
        "2198": "   * values()} views have iterators that don't support {@code remove()}, but all\n",
        "2199": "   * other methods are supported by the map and its views. When given a key that\n",
        "2200": "   * doesn't satisfy the predicate, the map's {@code put()} and {@code putAll()}\n",
        "2201": "   * methods throw an {@link IllegalArgumentException}.\n",
        "2202": "   *\n",
        "2203": "   * <p>When methods such as {@code removeAll()} and {@code clear()} are called\n",
        "2204": "   * on the filtered map or its views, only mappings whose keys satisfy the\n",
        "2205": "   * filter will be removed from the underlying map.\n",
        "2206": "   *\n",
        "2207": "   * <p>The returned map isn't threadsafe or serializable, even if {@code\n",
        "2208": "   * unfiltered} is.\n",
        "2209": "   *\n",
        "2210": "   * <p>Many of the filtered map's methods, such as {@code size()},\n",
        "2211": "   * iterate across every key/value mapping in the underlying map and determine\n",
        "2212": "   * which satisfy the filter. When a live view is <i>not</i> needed, it may be\n",
        "2213": "   * faster to copy the filtered map and use the copy.\n",
        "2214": "   *\n",
        "2215": "   * <p><b>Warning:</b> {@code keyPredicate} must be <i>consistent with\n",
        "2216": "   * equals</i>, as documented at {@link Predicate#apply}. Do not provide a\n",
        "2217": "   * predicate such as {@code Predicates.instanceOf(ArrayList.class)}, which is\n",
        "2218": "   * inconsistent with equals.\n",
        "2230": "   * Returns a sorted map containing the mappings in {@code unfiltered} whose\n",
        "2231": "   * keys satisfy a predicate. The returned map is a live view of {@code\n",
        "2232": "   * unfiltered}; changes to one affect the other.\n",
        "2234": "   * <p>The resulting map's {@code keySet()}, {@code entrySet()}, and {@code\n",
        "2235": "   * values()} views have iterators that don't support {@code remove()}, but all\n",
        "2236": "   * other methods are supported by the map and its views. When given a key that\n",
        "2237": "   * doesn't satisfy the predicate, the map's {@code put()} and {@code putAll()}\n",
        "2238": "   * methods throw an {@link IllegalArgumentException}.\n",
        "2240": "   * <p>When methods such as {@code removeAll()} and {@code clear()} are called\n",
        "2241": "   * on the filtered map or its views, only mappings whose keys satisfy the\n",
        "2242": "   * filter will be removed from the underlying map.\n",
        "2244": "   * <p>The returned map isn't threadsafe or serializable, even if {@code\n",
        "2245": "   * unfiltered} is.\n",
        "2247": "   * <p>Many of the filtered map's methods, such as {@code size()},\n",
        "2248": "   * iterate across every key/value mapping in the underlying map and determine\n",
        "2249": "   * which satisfy the filter. When a live view is <i>not</i> needed, it may be\n",
        "2250": "   * faster to copy the filtered map and use the copy.\n",
        "2252": "   * <p><b>Warning:</b> {@code keyPredicate} must be <i>consistent with\n",
        "2253": "   * equals</i>, as documented at {@link Predicate#apply}. Do not provide a\n",
        "2254": "   * predicate such as {@code Predicates.instanceOf(ArrayList.class)}, which is\n",
        "2255": "   * inconsistent with equals.\n",
        "2267": "   * Returns a navigable map containing the mappings in {@code unfiltered} whose\n",
        "2268": "   * keys satisfy a predicate. The returned map is a live view of {@code\n",
        "2269": "   * unfiltered}; changes to one affect the other.\n",
        "2271": "   * <p>The resulting map's {@code keySet()}, {@code entrySet()}, and {@code\n",
        "2272": "   * values()} views have iterators that don't support {@code remove()}, but all\n",
        "2273": "   * other methods are supported by the map and its views. When given a key that\n",
        "2274": "   * doesn't satisfy the predicate, the map's {@code put()} and {@code putAll()}\n",
        "2275": "   * methods throw an {@link IllegalArgumentException}.\n",
        "2277": "   * <p>When methods such as {@code removeAll()} and {@code clear()} are called\n",
        "2278": "   * on the filtered map or its views, only mappings whose keys satisfy the\n",
        "2279": "   * filter will be removed from the underlying map.\n",
        "2281": "   * <p>The returned map isn't threadsafe or serializable, even if {@code\n",
        "2282": "   * unfiltered} is.\n",
        "2284": "   * <p>Many of the filtered map's methods, such as {@code size()},\n",
        "2285": "   * iterate across every key/value mapping in the underlying map and determine\n",
        "2286": "   * which satisfy the filter. When a live view is <i>not</i> needed, it may be\n",
        "2287": "   * faster to copy the filtered map and use the copy.\n",
        "2289": "   * <p><b>Warning:</b> {@code keyPredicate} must be <i>consistent with\n",
        "2290": "   * equals</i>, as documented at {@link Predicate#apply}. Do not provide a\n",
        "2291": "   * predicate such as {@code Predicates.instanceOf(ArrayList.class)}, which is\n",
        "2292": "   * inconsistent with equals.\n",
        "2309": "   * iterators that don't support {@code remove()}, but all other methods are supported by the\n",
        "2310": "   * bimap and its views. When given a key that doesn't satisfy the predicate, the bimap's {@code\n",
        "2311": "   * put()}, {@code forcePut()} and {@code putAll()} methods throw an {@link\n",
        "2312": "   * IllegalArgumentException}.\n",
        "2324": "   * <p><b>Warning:</b> {@code entryPredicate} must be <i>consistent with equals </i>, as\n",
        "2325": "   * documented at {@link Predicate#apply}.\n",
        "2336": "   * Returns a map containing the mappings in {@code unfiltered} whose values\n",
        "2337": "   * satisfy a predicate. The returned map is a live view of {@code unfiltered};\n",
        "2338": "   * changes to one affect the other.\n",
        "2339": "   *\n",
        "2340": "   * <p>The resulting map's {@code keySet()}, {@code entrySet()}, and {@code\n",
        "2341": "   * values()} views have iterators that don't support {@code remove()}, but all\n",
        "2342": "   * other methods are supported by the map and its views. When given a value\n",
        "2343": "   * that doesn't satisfy the predicate, the map's {@code put()}, {@code\n",
        "2344": "   * putAll()}, and {@link Entry#setValue} methods throw an {@link\n",
        "2345": "   * IllegalArgumentException}.\n",
        "2346": "   *\n",
        "2347": "   * <p>When methods such as {@code removeAll()} and {@code clear()} are called\n",
        "2348": "   * on the filtered map or its views, only mappings whose values satisfy the\n",
        "2349": "   * filter will be removed from the underlying map.\n",
        "2350": "   *\n",
        "2351": "   * <p>The returned map isn't threadsafe or serializable, even if {@code\n",
        "2352": "   * unfiltered} is.\n",
        "2353": "   *\n",
        "2354": "   * <p>Many of the filtered map's methods, such as {@code size()},\n",
        "2355": "   * iterate across every key/value mapping in the underlying map and determine\n",
        "2356": "   * which satisfy the filter. When a live view is <i>not</i> needed, it may be\n",
        "2357": "   * faster to copy the filtered map and use the copy.\n",
        "2358": "   *\n",
        "2359": "   * <p><b>Warning:</b> {@code valuePredicate} must be <i>consistent with\n",
        "2360": "   * equals</i>, as documented at {@link Predicate#apply}. Do not provide a\n",
        "2361": "   * predicate such as {@code Predicates.instanceOf(ArrayList.class)}, which is\n",
        "2362": "   * inconsistent with equals.\n",
        "2370": "   * Returns a sorted map containing the mappings in {@code unfiltered} whose\n",
        "2371": "   * values satisfy a predicate. The returned map is a live view of {@code\n",
        "2372": "   * unfiltered}; changes to one affect the other.\n",
        "2373": "   *\n",
        "2374": "   * <p>The resulting map's {@code keySet()}, {@code entrySet()}, and {@code\n",
        "2375": "   * values()} views have iterators that don't support {@code remove()}, but all\n",
        "2376": "   * other methods are supported by the map and its views. When given a value\n",
        "2377": "   * that doesn't satisfy the predicate, the map's {@code put()}, {@code\n",
        "2378": "   * putAll()}, and {@link Entry#setValue} methods throw an {@link\n",
        "2379": "   * IllegalArgumentException}.\n",
        "2380": "   *\n",
        "2381": "   * <p>When methods such as {@code removeAll()} and {@code clear()} are called\n",
        "2382": "   * on the filtered map or its views, only mappings whose values satisfy the\n",
        "2383": "   * filter will be removed from the underlying map.\n",
        "2384": "   *\n",
        "2385": "   * <p>The returned map isn't threadsafe or serializable, even if {@code\n",
        "2386": "   * unfiltered} is.\n",
        "2387": "   *\n",
        "2388": "   * <p>Many of the filtered map's methods, such as {@code size()},\n",
        "2389": "   * iterate across every key/value mapping in the underlying map and determine\n",
        "2390": "   * which satisfy the filter. When a live view is <i>not</i> needed, it may be\n",
        "2391": "   * faster to copy the filtered map and use the copy.\n",
        "2392": "   *\n",
        "2393": "   * <p><b>Warning:</b> {@code valuePredicate} must be <i>consistent with\n",
        "2394": "   * equals</i>, as documented at {@link Predicate#apply}. Do not provide a\n",
        "2395": "   * predicate such as {@code Predicates.instanceOf(ArrayList.class)}, which is\n",
        "2396": "   * inconsistent with equals.\n",
        "2406": "   * Returns a navigable map containing the mappings in {@code unfiltered} whose\n",
        "2407": "   * values satisfy a predicate. The returned map is a live view of {@code\n",
        "2408": "   * unfiltered}; changes to one affect the other.\n",
        "2409": "   *\n",
        "2410": "   * <p>The resulting map's {@code keySet()}, {@code entrySet()}, and {@code\n",
        "2411": "   * values()} views have iterators that don't support {@code remove()}, but all\n",
        "2412": "   * other methods are supported by the map and its views. When given a value\n",
        "2413": "   * that doesn't satisfy the predicate, the map's {@code put()}, {@code\n",
        "2414": "   * putAll()}, and {@link Entry#setValue} methods throw an {@link\n",
        "2415": "   * IllegalArgumentException}.\n",
        "2416": "   *\n",
        "2417": "   * <p>When methods such as {@code removeAll()} and {@code clear()} are called\n",
        "2418": "   * on the filtered map or its views, only mappings whose values satisfy the\n",
        "2419": "   * filter will be removed from the underlying map.\n",
        "2420": "   *\n",
        "2421": "   * <p>The returned map isn't threadsafe or serializable, even if {@code\n",
        "2422": "   * unfiltered} is.\n",
        "2423": "   *\n",
        "2424": "   * <p>Many of the filtered map's methods, such as {@code size()},\n",
        "2425": "   * iterate across every key/value mapping in the underlying map and determine\n",
        "2426": "   * which satisfy the filter. When a live view is <i>not</i> needed, it may be\n",
        "2427": "   * faster to copy the filtered map and use the copy.\n",
        "2428": "   *\n",
        "2429": "   * <p><b>Warning:</b> {@code valuePredicate} must be <i>consistent with\n",
        "2430": "   * equals</i>, as documented at {@link Predicate#apply}. Do not provide a\n",
        "2431": "   * predicate such as {@code Predicates.instanceOf(ArrayList.class)}, which is\n",
        "2432": "   * inconsistent with equals.\n",
        "2443": "   * Returns a bimap containing the mappings in {@code unfiltered} whose values satisfy a\n",
        "2444": "   * predicate. The returned bimap is a live view of {@code unfiltered}; changes to one affect the\n",
        "2445": "   * other.\n",
        "2448": "   * iterators that don't support {@code remove()}, but all other methods are supported by the\n",
        "2449": "   * bimap and its views. When given a value that doesn't satisfy the predicate, the bimap's\n",
        "2450": "   * {@code put()}, {@code forcePut()} and {@code putAll()} methods throw an {@link\n",
        "2465": "   * <p><b>Warning:</b> {@code entryPredicate} must be <i>consistent with equals </i>, as\n",
        "2466": "   * documented at {@link Predicate#apply}.\n",
        "2476": "   * Returns a map containing the mappings in {@code unfiltered} that satisfy a\n",
        "2477": "   * predicate. The returned map is a live view of {@code unfiltered}; changes\n",
        "2478": "   * to one affect the other.\n",
        "2479": "   *\n",
        "2480": "   * <p>The resulting map's {@code keySet()}, {@code entrySet()}, and {@code\n",
        "2481": "   * values()} views have iterators that don't support {@code remove()}, but all\n",
        "2482": "   * other methods are supported by the map and its views. When given a\n",
        "2483": "   * key/value pair that doesn't satisfy the predicate, the map's {@code put()}\n",
        "2484": "   * and {@code putAll()} methods throw an {@link IllegalArgumentException}.\n",
        "2485": "   * Similarly, the map's entries have a {@link Entry#setValue} method that\n",
        "2486": "   * throws an {@link IllegalArgumentException} when the existing key and the\n",
        "2487": "   * provided value don't satisfy the predicate.\n",
        "2488": "   *\n",
        "2489": "   * <p>When methods such as {@code removeAll()} and {@code clear()} are called\n",
        "2490": "   * on the filtered map or its views, only mappings that satisfy the filter\n",
        "2491": "   * will be removed from the underlying map.\n",
        "2492": "   *\n",
        "2493": "   * <p>The returned map isn't threadsafe or serializable, even if {@code\n",
        "2494": "   * unfiltered} is.\n",
        "2495": "   *\n",
        "2496": "   * <p>Many of the filtered map's methods, such as {@code size()},\n",
        "2497": "   * iterate across every key/value mapping in the underlying map and determine\n",
        "2498": "   * which satisfy the filter. When a live view is <i>not</i> needed, it may be\n",
        "2499": "   * faster to copy the filtered map and use the copy.\n",
        "2500": "   *\n",
        "2501": "   * <p><b>Warning:</b> {@code entryPredicate} must be <i>consistent with\n",
        "2502": "   * equals</i>, as documented at {@link Predicate#apply}.\n",
        "2513": "   * Returns a sorted map containing the mappings in {@code unfiltered} that\n",
        "2514": "   * satisfy a predicate. The returned map is a live view of {@code unfiltered};\n",
        "2515": "   * changes to one affect the other.\n",
        "2516": "   *\n",
        "2517": "   * <p>The resulting map's {@code keySet()}, {@code entrySet()}, and {@code\n",
        "2518": "   * values()} views have iterators that don't support {@code remove()}, but all\n",
        "2519": "   * other methods are supported by the map and its views. When given a\n",
        "2520": "   * key/value pair that doesn't satisfy the predicate, the map's {@code put()}\n",
        "2521": "   * and {@code putAll()} methods throw an {@link IllegalArgumentException}.\n",
        "2522": "   * Similarly, the map's entries have a {@link Entry#setValue} method that\n",
        "2523": "   * throws an {@link IllegalArgumentException} when the existing key and the\n",
        "2524": "   * provided value don't satisfy the predicate.\n",
        "2525": "   *\n",
        "2526": "   * <p>When methods such as {@code removeAll()} and {@code clear()} are called\n",
        "2527": "   * on the filtered map or its views, only mappings that satisfy the filter\n",
        "2528": "   * will be removed from the underlying map.\n",
        "2529": "   *\n",
        "2530": "   * <p>The returned map isn't threadsafe or serializable, even if {@code\n",
        "2531": "   * unfiltered} is.\n",
        "2532": "   *\n",
        "2533": "   * <p>Many of the filtered map's methods, such as {@code size()},\n",
        "2534": "   * iterate across every key/value mapping in the underlying map and determine\n",
        "2535": "   * which satisfy the filter. When a live view is <i>not</i> needed, it may be\n",
        "2536": "   * faster to copy the filtered map and use the copy.\n",
        "2537": "   *\n",
        "2538": "   * <p><b>Warning:</b> {@code entryPredicate} must be <i>consistent with\n",
        "2539": "   * equals</i>, as documented at {@link Predicate#apply}.\n",
        "2552": "   * Returns a sorted map containing the mappings in {@code unfiltered} that\n",
        "2553": "   * satisfy a predicate. The returned map is a live view of {@code unfiltered};\n",
        "2554": "   * changes to one affect the other.\n",
        "2555": "   *\n",
        "2556": "   * <p>The resulting map's {@code keySet()}, {@code entrySet()}, and {@code\n",
        "2557": "   * values()} views have iterators that don't support {@code remove()}, but all\n",
        "2558": "   * other methods are supported by the map and its views. When given a\n",
        "2559": "   * key/value pair that doesn't satisfy the predicate, the map's {@code put()}\n",
        "2560": "   * and {@code putAll()} methods throw an {@link IllegalArgumentException}.\n",
        "2561": "   * Similarly, the map's entries have a {@link Entry#setValue} method that\n",
        "2562": "   * throws an {@link IllegalArgumentException} when the existing key and the\n",
        "2563": "   * provided value don't satisfy the predicate.\n",
        "2564": "   *\n",
        "2565": "   * <p>When methods such as {@code removeAll()} and {@code clear()} are called\n",
        "2566": "   * on the filtered map or its views, only mappings that satisfy the filter\n",
        "2567": "   * will be removed from the underlying map.\n",
        "2568": "   *\n",
        "2569": "   * <p>The returned map isn't threadsafe or serializable, even if {@code\n",
        "2570": "   * unfiltered} is.\n",
        "2571": "   *\n",
        "2572": "   * <p>Many of the filtered map's methods, such as {@code size()},\n",
        "2573": "   * iterate across every key/value mapping in the underlying map and determine\n",
        "2574": "   * which satisfy the filter. When a live view is <i>not</i> needed, it may be\n",
        "2575": "   * faster to copy the filtered map and use the copy.\n",
        "2576": "   *\n",
        "2577": "   * <p><b>Warning:</b> {@code entryPredicate} must be <i>consistent with\n",
        "2578": "   * equals</i>, as documented at {@link Predicate#apply}.\n",
        "2598": "   * {@code put()}, {@code forcePut()} and {@code putAll()} methods throw an\n",
        "2599": "   * {@link IllegalArgumentException}. Similarly, the map's entries have an {@link Entry#setValue}\n",
        "2600": "   * method that throws an {@link IllegalArgumentException} when the existing key and the provided\n",
        "2601": "   * value don't satisfy the predicate.\n",
        "2609": "   * <p>Many of the filtered bimap's methods, such as {@code size()}, iterate across every\n",
        "2610": "   * key/value mapping in the underlying bimap and determine which satisfy the filter. When a live\n",
        "2611": "   * view is <i>not</i> needed, it may be faster to copy the filtered bimap and use the copy.\n",
        "2613": "   * <p><b>Warning:</b> {@code entryPredicate} must be <i>consistent with equals </i>, as\n",
        "2614": "   * documented at {@link Predicate#apply}.\n",
        "2628": "   * Support {@code clear()}, {@code removeAll()}, and {@code retainAll()} when\n",
        "2629": "   * filtering a filtered map.\n",
        "2791": "     * Entries in this set satisfy the predicate, but they don't validate the\n",
        "2792": "     * input to {@code Entry.setValue()}.\n",
        "2907": "   * Support {@code clear()}, {@code removeAll()}, and {@code retainAll()} when\n",
        "2908": "   * filtering a filtered sorted map.\n",
        "3012": "   * Support {@code clear()}, {@code removeAll()}, and {@code retainAll()} when\n",
        "3013": "   * filtering a filtered navigable map.\n",
        "3157": "   * Support {@code clear()}, {@code removeAll()}, and {@code retainAll()} when\n",
        "3158": "   * filtering a filtered map.\n",
        "3168": "    @RetainedWith\n",
        "3169": "    private final BiMap<V, K> inverse;\n",
        "3389": "   * Returns a synchronized (thread-safe) navigable map backed by the specified\n",
        "3390": "   * navigable map.  In order to guarantee serial access, it is critical that\n",
        "3391": "   * <b>all</b> access to the backing navigable map is accomplished\n",
        "3392": "   * through the returned navigable map (or its views).\n",
        "3394": "   * <p>It is imperative that the user manually synchronize on the returned\n",
        "3395": "   * navigable map when iterating over any of its collection views, or the\n",
        "3396": "   * collections views of any of its {@code descendingMap}, {@code subMap},\n",
        "3397": "   * {@code headMap} or {@code tailMap} views. <pre>   {@code\n",
        "3399": "   *   NavigableMap<K, V> map = synchronizedNavigableMap(new TreeMap<K, V>());\n",
        "3401": "   *   // Needn't be in synchronized block\n",
        "3402": "   *   NavigableSet<K> set = map.navigableKeySet();\n",
        "3404": "   *   synchronized (map) { // Synchronizing on map, not set!\n",
        "3405": "   *     Iterator<K> it = set.iterator(); // Must be in synchronized block\n",
        "3406": "   *     while (it.hasNext()) {\n",
        "3407": "   *       foo(it.next());\n",
        "3408": "   *     }\n",
        "3409": "   *   }}</pre>\n",
        "3411": "   * <p>or: <pre>   {@code\n",
        "3413": "   *   NavigableMap<K, V> map = synchronizedNavigableMap(new TreeMap<K, V>());\n",
        "3414": "   *   NavigableMap<K, V> map2 = map.subMap(foo, false, bar, true);\n",
        "3416": "   *   // Needn't be in synchronized block\n",
        "3417": "   *   NavigableSet<K> set2 = map2.descendingKeySet();\n",
        "3419": "   *   synchronized (map) { // Synchronizing on map, not map2 or set2!\n",
        "3420": "   *     Iterator<K> it = set2.iterator(); // Must be in synchronized block\n",
        "3421": "   *     while (it.hasNext()) {\n",
        "3422": "   *       foo(it.next());\n",
        "3423": "   *     }\n",
        "3424": "   *   }}</pre>\n",
        "3428": "   * <p>The returned navigable map will be serializable if the specified\n",
        "3429": "   * navigable map is serializable.\n",
        "3431": "   * @param navigableMap the navigable map to be \"wrapped\" in a synchronized\n",
        "3432": "   *    navigable map.\n",
        "3443": "   * {@code AbstractMap} extension that makes it easy to cache customized keySet, values,\n",
        "3444": "   * and entrySet views.\n",
        "3449": "     * Creates the entry set to be returned by {@link #entrySet()}. This method\n",
        "3450": "     * is invoked at most once on a given map, at the time when {@code entrySet}\n",
        "3451": "     * is first called.\n",
        "3516": "   * Delegates to {@link Map#get}. Returns {@code null} on {@code\n",
        "3517": "   * ClassCastException} and {@code NullPointerException}.\n",
        "3529": "   * Delegates to {@link Map#containsKey}. Returns {@code false} on {@code\n",
        "3530": "   * ClassCastException} and {@code NullPointerException}.\n",
        "3542": "   * Delegates to {@link Map#remove}. Returns {@code null} on {@code\n",
        "3543": "   * ClassCastException} and {@code NullPointerException}.\n",
        "3554": "  /**\n",
        "3555": "   * An admittedly inefficient implementation of {@link Map#containsKey}.\n",
        "3556": "   */\n",
        "3561": "  /**\n",
        "3562": "   * An implementation of {@link Map#containsValue}.\n",
        "3563": "   */\n",
        "3569": "   * Implements {@code Collection.contains} safely for forwarding collections of\n",
        "3570": "   * map entries. If {@code o} is an instance of {@code Entry}, it is\n",
        "3571": "   * wrapped using {@link #unmodifiableEntry} to protect against a possible\n",
        "3572": "   * nefarious equals method.\n",
        "3574": "   * <p>Note that {@code c} is the backing (delegate) collection, rather than\n",
        "3575": "   * the forwarding collection.\n",
        "3589": "   * Implements {@code Collection.remove} safely for forwarding collections of\n",
        "3590": "   * map entries. If {@code o} is an instance of {@code Entry}, it is\n",
        "3591": "   * wrapped using {@link #unmodifiableEntry} to protect against a possible\n",
        "3592": "   * nefarious equals method.\n",
        "3594": "   * <p>Note that {@code c} is backing (delegate) collection, rather than the\n",
        "3595": "   * forwarding collection.\n",
        "3608": "  /**\n",
        "3609": "   * An implementation of {@link Map#equals}.\n",
        "3610": "   */\n",
        "3621": "  /**\n",
        "3622": "   * An implementation of {@link Map#toString}.\n",
        "3623": "   */\n",
        "3637": "  /**\n",
        "3638": "   * An implementation of {@link Map#putAll}.\n",
        "3639": "   */\n",
        "4167": "  /**\n",
        "4168": "   * Returns a map from the ith element of list to i.\n",
        "4169": "   */\n",
        "4182": "   * <p>This method delegates to the appropriate methods of {@link NavigableMap} (namely\n",
        "4183": "   * {@link NavigableMap#subMap(Object, boolean, Object, boolean) subMap()},\n",
        "4184": "   * {@link NavigableMap#tailMap(Object, boolean) tailMap()}, and\n",
        "4185": "   * {@link NavigableMap#headMap(Object, boolean) headMap()}) to actually construct the view.\n",
        "4186": "   * Consult these methods for a full description of the returned view's behavior.\n",
        "4189": "   * ordering. {@code NavigableMap} on the other hand can specify a custom ordering via a\n",
        "4190": "   * {@link Comparator}, which can violate the natural ordering. Using this method (or in general\n",
        "4191": "   * using {@code Range}) with unnaturally-ordered maps can lead to unexpected and undefined\n",
        "4192": "   * behavior.\n"
    }
}