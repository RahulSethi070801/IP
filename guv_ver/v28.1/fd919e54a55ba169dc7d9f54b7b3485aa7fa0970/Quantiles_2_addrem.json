{
    "addition": {
        "34": " * Provides a fluent API for calculating <a\n",
        "35": " * href=\"http://en.wikipedia.org/wiki/Quantile\">quantiles</a>.\n",
        "41": " * <pre>{@code\n",
        "42": " * double myMedian = median().compute(myDataset);\n",
        "43": " * }</pre>\n",
        "49": " * <pre>{@code\n",
        "50": " * double myPercentile99 = percentiles().index(99).compute(myDataset);\n",
        "51": " * }</pre>\n",
        "57": " * <pre>{@code\n",
        "58": " * Map<Integer, Double> myPercentiles =\n",
        "59": " *     percentiles().indexes(50, 90, 99).compute(myDataset);\n",
        "60": " * }</pre>\n",
        "69": " * it being arbitrarily reordered, and you want to avoid that copy, you can use {@code\n",
        "70": " * computeInPlace} instead of {@code compute}.\n",
        "79": " * definition in <a\n",
        "80": " * href=\"http://stat.ethz.ch/R-manual/R-devel/library/stats/html/quantile.html\">R</a>, and it is\n",
        "81": " * described by <a\n",
        "82": " * href=\"http://en.wikipedia.org/wiki/Quantile#Estimating_the_quantiles_of_a_population\">\n",
        "88": " * <p>If any values in the input are {@link Double#NaN NaN} then all values returned are {@link\n",
        "89": " * Double#NaN NaN}. (This is the one occasion when the behaviour is not the same as you'd get from\n",
        "90": " * sorting with {@link java.util.Arrays#sort(double[]) Arrays.sort(double[])} or {@link\n",
        "91": " * java.util.Collections#sort(java.util.List) Collections.sort(List&lt;Double&gt;)} and selecting\n",
        "92": " * the required value(s). Those methods would sort {@link Double#NaN NaN} as if it is greater than\n",
        "93": " * any other value and place them at the end of the dataset, even after {@link\n",
        "94": " * Double#POSITIVE_INFINITY POSITIVE_INFINITY}.)\n",
        "96": " * <p>Otherwise, {@link Double#NEGATIVE_INFINITY NEGATIVE_INFINITY} and {@link\n",
        "97": " * Double#POSITIVE_INFINITY POSITIVE_INFINITY} sort to the beginning and the end of the dataset, as\n",
        "98": " * you would expect.\n",
        "121": " * independent of N (but depends on the quantiles being computed). When calling {@link\n",
        "122": " * ScaleAndIndex#computeInPlace computeInPlace} (in {@linkplain ScaleAndIndexes#computeInPlace\n",
        "123": " * either form}), only the overhead is required. The number of object allocations is independent of\n",
        "124": " * N in both cases.\n",
        "133": "  /** Specifies the computation of a median (i.e. the 1st 2-quantile). */\n",
        "138": "  /** Specifies the computation of quartiles (i.e. 4-quantiles). */\n",
        "143": "  /** Specifies the computation of percentiles (i.e. 100-quantiles). */\n",
        "440": "  /** Returns whether any of the values in {@code dataset} are {@code NaN}. */\n",
        "499": "   *\n",
        "501": "   *   <li>{@code required}, {@code from}, and {@code to} should all be indexes into {@code array};\n",
        "502": "   *   <li>{@code required} should be in the range [{@code from}, {@code to}];\n",
        "503": "   *   <li>all the values with indexes in the range [0, {@code from}) should be less than or equal\n",
        "504": "   *       to all the values with indexes in the range [{@code from}, {@code to}];\n",
        "505": "   *   <li>all the values with indexes in the range ({@code to}, {@code array.length - 1}] should be\n",
        "506": "   *       greater than or equal to all the values with indexes in the range [{@code from}, {@code\n",
        "507": "   *       to}].\n",
        "509": "   *\n",
        "547": "   * Performs a partition operation on the slice of {@code array} with elements in the range [{@code\n",
        "548": "   * from}, {@code to}]. Uses the median of {@code from}, {@code to}, and the midpoint between them\n",
        "549": "   * as a pivot. Returns the index which the slice is partitioned around, i.e. if it returns {@code\n",
        "550": "   * ret} then we know that the values with indexes in [{@code from}, {@code ret}) are less than or\n",
        "551": "   * equal to the value at {@code ret} and the values with indexes in ({@code ret}, {@code to}] are\n",
        "552": "   * greater than or equal to that.\n",
        "602": "   * Performs an in-place selection, like {@link #selectInPlace}, to select all the indexes {@code\n",
        "603": "   * allRequired[i]} for {@code i} in the range [{@code requiredFrom}, {@code requiredTo}]. These\n",
        "604": "   * indexes must be sorted in the array and must all be in the range [{@code from}, {@code to}].\n",
        "679": "  /** Swaps the values at {@code i} and {@code j} in {@code array}. */\n"
    },
    "removed": {
        "34": " * Provides a fluent API for calculating\n",
        "35": " * <a href=\"http://en.wikipedia.org/wiki/Quantile\">quantiles</a>.\n",
        "40": " * <pre>   {@code\n",
        "42": " *   double myMedian = median().compute(myDataset);}</pre>\n",
        "47": " * <pre>   {@code\n",
        "49": " *   double myPercentile99 = percentiles().index(99).compute(myDataset);}</pre>\n",
        "54": " * <pre>   {@code\n",
        "56": " *   Map<Integer, Double> myPercentiles =\n",
        "57": " *       percentiles().indexes(50, 90, 99).compute(myDataset);}</pre>\n",
        "66": " * it being arbitrarily reordered, and you want to avoid that copy, you can use\n",
        "67": " * {@code computeInPlace} instead of {@code compute}.\n",
        "76": " * definition in\n",
        "77": " * <a href=\"http://stat.ethz.ch/R-manual/R-devel/library/stats/html/quantile.html\">R</a>, and it is\n",
        "78": " * described by\n",
        "79": " * <a href=\"http://en.wikipedia.org/wiki/Quantile#Estimating_the_quantiles_of_a_population\">\n",
        "85": " * <p>If any values in the input are {@link Double#NaN NaN} then all values returned are\n",
        "86": " * {@link Double#NaN NaN}. (This is the one occasion when the behaviour is not the same as you'd get\n",
        "87": " * from sorting with {@link java.util.Arrays#sort(double[]) Arrays.sort(double[])} or\n",
        "88": " * {@link java.util.Collections#sort(java.util.List) Collections.sort(List&lt;Double&gt;)} and\n",
        "89": " * selecting the required value(s). Those methods would sort {@link Double#NaN NaN} as if it is\n",
        "90": " * greater than any other value and place them at the end of the dataset, even after\n",
        "91": " * {@link Double#POSITIVE_INFINITY POSITIVE_INFINITY}.)\n",
        "93": " * <p>Otherwise, {@link Double#NEGATIVE_INFINITY NEGATIVE_INFINITY} and\n",
        "94": " * {@link Double#POSITIVE_INFINITY POSITIVE_INFINITY} sort to the beginning and the end of the\n",
        "95": " * dataset, as you would expect.\n",
        "118": " * independent of N (but depends on the quantiles being computed). When calling\n",
        "119": " * {@link ScaleAndIndex#computeInPlace computeInPlace} (in\n",
        "120": " * {@linkplain ScaleAndIndexes#computeInPlace either form}), only the overhead is required. The\n",
        "121": " * number of object allocations is independent of N in both cases.\n",
        "130": "  /**\n",
        "131": "   * Specifies the computation of a median (i.e. the 1st 2-quantile).\n",
        "132": "   */\n",
        "137": "  /**\n",
        "138": "   * Specifies the computation of quartiles (i.e. 4-quantiles).\n",
        "139": "   */\n",
        "144": "  /**\n",
        "145": "   * Specifies the computation of percentiles (i.e. 100-quantiles).\n",
        "146": "   */\n",
        "443": "  /**\n",
        "444": "   * Returns whether any of the values in {@code dataset} are {@code NaN}.\n",
        "445": "   */\n",
        "505": "   * <li>{@code required}, {@code from}, and {@code to} should all be indexes into {@code array};\n",
        "506": "   * <li>{@code required} should be in the range [{@code from}, {@code to}];\n",
        "507": "   * <li>all the values with indexes in the range [0, {@code from}) should be less than or equal to\n",
        "508": "   * all the values with indexes in the range [{@code from}, {@code to}];\n",
        "509": "   * <li>all the values with indexes in the range ({@code to}, {@code array.length - 1}] should be\n",
        "510": "   * greater than or equal to all the values with indexes in the range [{@code from}, {@code to}].\n",
        "549": "   * Performs a partition operation on the slice of {@code array} with elements in the range\n",
        "550": "   * [{@code from}, {@code to}]. Uses the median of {@code from}, {@code to}, and the midpoint\n",
        "551": "   * between them as a pivot. Returns the index which the slice is partitioned around, i.e. if it\n",
        "552": "   * returns {@code ret} then we know that the values with indexes in [{@code from}, {@code ret})\n",
        "553": "   * are less than or equal to the value at {@code ret} and the values with indexes in ({@code ret},\n",
        "554": "   * {@code to}] are greater than or equal to that.\n",
        "604": "   * Performs an in-place selection, like {@link #selectInPlace}, to select all the indexes\n",
        "605": "   * {@code allRequired[i]} for {@code i} in the range [{@code requiredFrom}, {@code requiredTo}].\n",
        "606": "   * These indexes must be sorted in the array and must all be in the range [{@code from},\n",
        "607": "   * {@code to}].\n",
        "682": "  /**\n",
        "683": "   * Swaps the values at {@code i} and {@code j} in {@code array}.\n",
        "684": "   */\n"
    }
}