{
    "addition": {
        "52": " * Base class for JSR166 Junit TCK tests. Defines some constants, utility methods and classes, as\n",
        "53": " * well as a simple framework for helping to make sure that assertions failing in generated threads\n",
        "54": " * cause the associated test that generated them to itself fail (which JUnit does not otherwise\n",
        "55": " * arrange). The rules for creating such tests are:\n",
        "58": " *   <li>All assertions in code running in generated threads must use the forms {@link #threadFail},\n",
        "59": " *       {@link #threadAssertTrue}, {@link #threadAssertEquals}, or {@link #threadAssertNull}, (not\n",
        "60": " *       {@code fail}, {@code assertTrue}, etc.) It is OK (but not particularly recommended) for\n",
        "61": " *       other code to use these forms too. Only the most typically used JUnit assertion methods are\n",
        "62": " *       defined this way, but enough to live with.\n",
        "63": " *   <li>If you override {@link #setUp} or {@link #tearDown}, make sure to invoke {@code\n",
        "64": " *       super.setUp} and {@code super.tearDown} within them. These methods are used to clear and\n",
        "65": " *       check for thread assertion failures.\n",
        "66": " *   <li>All delays and timeouts must use one of the constants {@code SHORT_DELAY_MS}, {@code\n",
        "67": " *       SMALL_DELAY_MS}, {@code MEDIUM_DELAY_MS}, {@code LONG_DELAY_MS}. The idea here is that a\n",
        "68": " *       SHORT is always discriminable from zero time, and always allows enough time for the small\n",
        "69": " *       amounts of computation (creating a thread, calling a few methods, etc) needed to reach a\n",
        "70": " *       timeout point. Similarly, a SMALL is always discriminable as larger than SHORT and smaller\n",
        "71": " *       than MEDIUM. And so on. These constants are set to conservative values, but even so, if\n",
        "72": " *       there is ever any doubt, they can all be increased in one spot to rerun tests on slower\n",
        "73": " *       platforms.\n",
        "74": " *   <li>All threads generated must be joined inside each test case method (or {@code fail} to do\n",
        "75": " *       so) before returning from the method. The {@code joinPool} method can be used to do this\n",
        "76": " *       when using Executors.\n",
        "79": " * <p><b>Other notes</b>\n",
        "81": " * <ul>\n",
        "82": " *   <li>Usually, there is one testcase method per JSR166 method covering \"normal\" operation, and\n",
        "83": " *       then as many exception-testing methods as there are exceptions the method can throw.\n",
        "84": " *       Sometimes there are multiple tests per JSR166 method when the different \"normal\" behaviors\n",
        "85": " *       differ significantly. And sometimes testcases cover multiple methods when they cannot be\n",
        "86": " *       tested in isolation.\n",
        "87": " *   <li>The documentation style for testcases is to provide as javadoc a simple sentence or two\n",
        "88": " *       describing the property that the testcase method purports to test. The javadocs do not say\n",
        "89": " *       anything about how the property is tested. To find out, read the code.\n",
        "90": " *   <li>These tests are \"conformance tests\", and do not attempt to test throughput, latency,\n",
        "91": " *       scalability or other performance factors (see the separate \"jtreg\" tests for a set intended\n",
        "92": " *       to check these for the most central aspects of functionality.) So, most tests use the\n",
        "93": " *       smallest sensible numbers of threads, collection sizes, etc needed to check basic\n",
        "94": " *       conformance.\n",
        "95": " *   <li>The test classes currently do not declare inclusion in any particular package to simplify\n",
        "96": " *       things for people integrating them in TCK test suites.\n",
        "97": " *   <li>As a convenience, the {@code main} of this class (JSR166TestCase) runs all JSR166 unit\n",
        "98": " *       tests.\n",
        "102": "  private static final boolean useSecurityManager = Boolean.getBoolean(\"jsr166.useSecurityManager\");\n",
        "103": "\n",
        "104": "  protected static final boolean expensiveTests = Boolean.getBoolean(\"jsr166.expensiveTests\");\n",
        "105": "\n",
        "106": "  /**\n",
        "107": "   * If true, report on stdout all \"slow\" tests, that is, ones that take more than profileThreshold\n",
        "108": "   * milliseconds to execute.\n",
        "109": "   */\n",
        "110": "  private static final boolean profileTests = Boolean.getBoolean(\"jsr166.profileTests\");\n",
        "111": "\n",
        "112": "  /**\n",
        "113": "   * The number of milliseconds that tests are permitted for execution without being reported, when\n",
        "114": "   * profileTests is set.\n",
        "115": "   */\n",
        "116": "  private static final long profileThreshold = Long.getLong(\"jsr166.profileThreshold\", 100);\n",
        "117": "\n",
        "118": "  protected void runTest() throws Throwable {\n",
        "119": "    if (profileTests) runTestProfiled();\n",
        "120": "    else super.runTest();\n",
        "121": "  }\n",
        "122": "\n",
        "123": "  protected void runTestProfiled() throws Throwable {\n",
        "124": "    long t0 = System.nanoTime();\n",
        "125": "    try {\n",
        "126": "      super.runTest();\n",
        "127": "    } finally {\n",
        "128": "      long elapsedMillis = (System.nanoTime() - t0) / (1000L * 1000L);\n",
        "129": "      if (elapsedMillis >= profileThreshold)\n",
        "130": "        System.out.printf(\"%n%s: %d%n\", toString(), elapsedMillis);\n",
        "131": "    }\n",
        "132": "  }\n",
        "133": "\n",
        "134": "  //     /**\n",
        "135": "  //      * Runs all JSR166 unit tests using junit.textui.TestRunner\n",
        "136": "  //      */\n",
        "137": "  //     public static void main(String[] args) {\n",
        "138": "  //         if (useSecurityManager) {\n",
        "139": "  //             System.err.println(\"Setting a permissive security manager\");\n",
        "140": "  //             Policy.setPolicy(permissivePolicy());\n",
        "141": "  //             System.setSecurityManager(new SecurityManager());\n",
        "142": "  //         }\n",
        "143": "  //         int iters = (args.length == 0) ? 1 : Integer.parseInt(args[0]);\n",
        "144": "\n",
        "145": "  //         Test s = suite();\n",
        "146": "  //         for (int i = 0; i < iters; ++i) {\n",
        "147": "  //             junit.textui.TestRunner.run(s);\n",
        "148": "  //             System.gc();\n",
        "149": "  //             System.runFinalization();\n",
        "150": "  //         }\n",
        "151": "  //         System.exit(0);\n",
        "152": "  //     }\n",
        "153": "\n",
        "154": "  //     public static TestSuite newTestSuite(Object... suiteOrClasses) {\n",
        "155": "  //         TestSuite suite = new TestSuite();\n",
        "156": "  //         for (Object suiteOrClass : suiteOrClasses) {\n",
        "157": "  //             if (suiteOrClass instanceof TestSuite)\n",
        "158": "  //                 suite.addTest((TestSuite) suiteOrClass);\n",
        "159": "  //             else if (suiteOrClass instanceof Class)\n",
        "160": "  //                 suite.addTest(new TestSuite((Class<?>) suiteOrClass));\n",
        "161": "  //             else\n",
        "162": "  //                 throw new ClassCastException(\"not a test suite or class\");\n",
        "163": "  //         }\n",
        "164": "  //         return suite;\n",
        "165": "  //     }\n",
        "166": "\n",
        "167": "  //     /**\n",
        "168": "  //      * Collects all JSR166 unit tests as one suite.\n",
        "169": "  //      */\n",
        "170": "  //     public static Test suite() {\n",
        "171": "  //         return newTestSuite(\n",
        "172": "  //             ForkJoinPoolTest.suite(),\n",
        "173": "  //             ForkJoinTaskTest.suite(),\n",
        "174": "  //             RecursiveActionTest.suite(),\n",
        "175": "  //             RecursiveTaskTest.suite(),\n",
        "176": "  //             LinkedTransferQueueTest.suite(),\n",
        "177": "  //             PhaserTest.suite(),\n",
        "178": "  //             ThreadLocalRandomTest.suite(),\n",
        "179": "  //             AbstractExecutorServiceTest.suite(),\n",
        "180": "  //             AbstractQueueTest.suite(),\n",
        "181": "  //             AbstractQueuedSynchronizerTest.suite(),\n",
        "182": "  //             AbstractQueuedLongSynchronizerTest.suite(),\n",
        "183": "  //             ArrayBlockingQueueTest.suite(),\n",
        "184": "  //             ArrayDequeTest.suite(),\n",
        "185": "  //             AtomicBooleanTest.suite(),\n",
        "186": "  //             AtomicIntegerArrayTest.suite(),\n",
        "187": "  //             AtomicIntegerFieldUpdaterTest.suite(),\n",
        "188": "  //             AtomicIntegerTest.suite(),\n",
        "189": "  //             AtomicLongArrayTest.suite(),\n",
        "190": "  //             AtomicLongFieldUpdaterTest.suite(),\n",
        "191": "  //             AtomicLongTest.suite(),\n",
        "192": "  //             AtomicMarkableReferenceTest.suite(),\n",
        "193": "  //             AtomicReferenceArrayTest.suite(),\n",
        "194": "  //             AtomicReferenceFieldUpdaterTest.suite(),\n",
        "195": "  //             AtomicReferenceTest.suite(),\n",
        "196": "  //             AtomicStampedReferenceTest.suite(),\n",
        "197": "  //             ConcurrentHashMapTest.suite(),\n",
        "198": "  //             ConcurrentLinkedDequeTest.suite(),\n",
        "199": "  //             ConcurrentLinkedQueueTest.suite(),\n",
        "200": "  //             ConcurrentSkipListMapTest.suite(),\n",
        "201": "  //             ConcurrentSkipListSubMapTest.suite(),\n",
        "202": "  //             ConcurrentSkipListSetTest.suite(),\n",
        "203": "  //             ConcurrentSkipListSubSetTest.suite(),\n",
        "204": "  //             CopyOnWriteArrayListTest.suite(),\n",
        "205": "  //             CopyOnWriteArraySetTest.suite(),\n",
        "206": "  //             CountDownLatchTest.suite(),\n",
        "207": "  //             CyclicBarrierTest.suite(),\n",
        "208": "  //             DelayQueueTest.suite(),\n",
        "209": "  //             EntryTest.suite(),\n",
        "210": "  //             ExchangerTest.suite(),\n",
        "211": "  //             ExecutorsTest.suite(),\n",
        "212": "  //             ExecutorCompletionServiceTest.suite(),\n",
        "213": "  //             FutureTaskTest.suite(),\n",
        "214": "  //             LinkedBlockingDequeTest.suite(),\n",
        "215": "  //             LinkedBlockingQueueTest.suite(),\n",
        "216": "  //             LinkedListTest.suite(),\n",
        "217": "  //             LockSupportTest.suite(),\n",
        "218": "  //             PriorityBlockingQueueTest.suite(),\n",
        "219": "  //             PriorityQueueTest.suite(),\n",
        "220": "  //             ReentrantLockTest.suite(),\n",
        "221": "  //             ReentrantReadWriteLockTest.suite(),\n",
        "222": "  //             ScheduledExecutorTest.suite(),\n",
        "223": "  //             ScheduledExecutorSubclassTest.suite(),\n",
        "224": "  //             SemaphoreTest.suite(),\n",
        "225": "  //             SynchronousQueueTest.suite(),\n",
        "226": "  //             SystemTest.suite(),\n",
        "227": "  //             ThreadLocalTest.suite(),\n",
        "228": "  //             ThreadPoolExecutorTest.suite(),\n",
        "229": "  //             ThreadPoolExecutorSubclassTest.suite(),\n",
        "230": "  //             ThreadTest.suite(),\n",
        "231": "  //             TimeUnitTest.suite(),\n",
        "232": "  //             TreeMapTest.suite(),\n",
        "233": "  //             TreeSetTest.suite(),\n",
        "234": "  //             TreeSubMapTest.suite(),\n",
        "235": "  //             TreeSubSetTest.suite());\n",
        "236": "  //     }\n",
        "237": "\n",
        "238": "  public static long SHORT_DELAY_MS;\n",
        "239": "  public static long SMALL_DELAY_MS;\n",
        "240": "  public static long MEDIUM_DELAY_MS;\n",
        "241": "  public static long LONG_DELAY_MS;\n",
        "242": "\n",
        "243": "  /**\n",
        "244": "   * Returns the shortest timed delay. This could be reimplemented to use for example a Property.\n",
        "245": "   */\n",
        "246": "  protected long getShortDelay() {\n",
        "247": "    return 50;\n",
        "248": "  }\n",
        "249": "\n",
        "250": "  /** Sets delays as multiples of SHORT_DELAY. */\n",
        "251": "  protected void setDelays() {\n",
        "252": "    SHORT_DELAY_MS = getShortDelay();\n",
        "253": "    SMALL_DELAY_MS = SHORT_DELAY_MS * 5;\n",
        "254": "    MEDIUM_DELAY_MS = SHORT_DELAY_MS * 10;\n",
        "255": "    LONG_DELAY_MS = SHORT_DELAY_MS * 200;\n",
        "256": "  }\n",
        "257": "\n",
        "258": "  /**\n",
        "259": "   * Returns a timeout in milliseconds to be used in tests that verify that operations block or time\n",
        "260": "   * out.\n",
        "261": "   */\n",
        "262": "  long timeoutMillis() {\n",
        "263": "    return SHORT_DELAY_MS / 4;\n",
        "264": "  }\n",
        "265": "\n",
        "266": "  /** Returns a new Date instance representing a time delayMillis milliseconds in the future. */\n",
        "267": "  Date delayedDate(long delayMillis) {\n",
        "268": "    return new Date(System.currentTimeMillis() + delayMillis);\n",
        "269": "  }\n",
        "274": "  /**\n",
        "275": "   * Records an exception so that it can be rethrown later in the test harness thread, triggering a\n",
        "276": "   * test case failure. Only the first failure is recorded; subsequent calls to this method from\n",
        "277": "   * within the same test have no effect.\n",
        "278": "   */\n",
        "279": "  public void threadRecordFailure(Throwable t) {\n",
        "280": "    threadFailure.compareAndSet(null, t);\n",
        "281": "  }\n",
        "282": "\n",
        "283": "  public void setUp() {\n",
        "284": "    setDelays();\n",
        "285": "  }\n",
        "286": "\n",
        "287": "  /**\n",
        "288": "   * Extra checks that get done for all test cases.\n",
        "289": "   *\n",
        "290": "   * <p>Triggers test case failure if any thread assertions have failed, by rethrowing, in the test\n",
        "291": "   * harness thread, any exception recorded earlier by threadRecordFailure.\n",
        "292": "   *\n",
        "293": "   * <p>Triggers test case failure if interrupt status is set in the main thread.\n",
        "294": "   */\n",
        "295": "  public void tearDown() throws Exception {\n",
        "296": "    Throwable t = threadFailure.getAndSet(null);\n",
        "297": "    if (t != null) {\n",
        "298": "      if (t instanceof Error) throw (Error) t;\n",
        "299": "      else if (t instanceof RuntimeException) throw (RuntimeException) t;\n",
        "300": "      else if (t instanceof Exception) throw (Exception) t;\n",
        "301": "      else {\n",
        "302": "        AssertionFailedError afe = new AssertionFailedError(t.toString());\n",
        "303": "        afe.initCause(t);\n",
        "304": "        throw afe;\n",
        "305": "      }\n",
        "306": "    }\n",
        "307": "\n",
        "308": "    if (Thread.interrupted()) throw new AssertionFailedError(\"interrupt status set in main thread\");\n",
        "309": "  }\n",
        "310": "\n",
        "311": "  /**\n",
        "312": "   * Just like fail(reason), but additionally recording (using threadRecordFailure) any\n",
        "313": "   * AssertionFailedError thrown, so that the current testcase will fail.\n",
        "314": "   */\n",
        "315": "  public void threadFail(String reason) {\n",
        "316": "    try {\n",
        "317": "      fail(reason);\n",
        "318": "    } catch (AssertionFailedError t) {\n",
        "319": "      threadRecordFailure(t);\n",
        "320": "      fail(reason);\n",
        "321": "    }\n",
        "322": "  }\n",
        "323": "\n",
        "324": "  /**\n",
        "325": "   * Just like assertTrue(b), but additionally recording (using threadRecordFailure) any\n",
        "326": "   * AssertionFailedError thrown, so that the current testcase will fail.\n",
        "327": "   */\n",
        "328": "  public void threadAssertTrue(boolean b) {\n",
        "329": "    try {\n",
        "330": "      assertTrue(b);\n",
        "331": "    } catch (AssertionFailedError t) {\n",
        "332": "      threadRecordFailure(t);\n",
        "333": "      throw t;\n",
        "334": "    }\n",
        "335": "  }\n",
        "336": "\n",
        "337": "  /**\n",
        "338": "   * Just like assertFalse(b), but additionally recording (using threadRecordFailure) any\n",
        "339": "   * AssertionFailedError thrown, so that the current testcase will fail.\n",
        "340": "   */\n",
        "341": "  public void threadAssertFalse(boolean b) {\n",
        "342": "    try {\n",
        "343": "      assertFalse(b);\n",
        "344": "    } catch (AssertionFailedError t) {\n",
        "345": "      threadRecordFailure(t);\n",
        "346": "      throw t;\n",
        "347": "    }\n",
        "348": "  }\n",
        "349": "\n",
        "350": "  /**\n",
        "351": "   * Just like assertNull(x), but additionally recording (using threadRecordFailure) any\n",
        "352": "   * AssertionFailedError thrown, so that the current testcase will fail.\n",
        "353": "   */\n",
        "354": "  public void threadAssertNull(Object x) {\n",
        "355": "    try {\n",
        "356": "      assertNull(x);\n",
        "357": "    } catch (AssertionFailedError t) {\n",
        "358": "      threadRecordFailure(t);\n",
        "359": "      throw t;\n",
        "360": "    }\n",
        "361": "  }\n",
        "362": "\n",
        "363": "  /**\n",
        "364": "   * Just like assertEquals(x, y), but additionally recording (using threadRecordFailure) any\n",
        "365": "   * AssertionFailedError thrown, so that the current testcase will fail.\n",
        "366": "   */\n",
        "367": "  public void threadAssertEquals(long x, long y) {\n",
        "368": "    try {\n",
        "369": "      assertEquals(x, y);\n",
        "370": "    } catch (AssertionFailedError t) {\n",
        "371": "      threadRecordFailure(t);\n",
        "372": "      throw t;\n",
        "373": "    }\n",
        "374": "  }\n",
        "375": "\n",
        "376": "  /**\n",
        "377": "   * Just like assertEquals(x, y), but additionally recording (using threadRecordFailure) any\n",
        "378": "   * AssertionFailedError thrown, so that the current testcase will fail.\n",
        "379": "   */\n",
        "380": "  public void threadAssertEquals(Object x, Object y) {\n",
        "381": "    try {\n",
        "382": "      assertEquals(x, y);\n",
        "383": "    } catch (AssertionFailedError t) {\n",
        "384": "      threadRecordFailure(t);\n",
        "385": "      throw t;\n",
        "386": "    } catch (Throwable t) {\n",
        "387": "      threadUnexpectedException(t);\n",
        "388": "    }\n",
        "389": "  }\n",
        "390": "\n",
        "391": "  /**\n",
        "392": "   * Just like assertSame(x, y), but additionally recording (using threadRecordFailure) any\n",
        "393": "   * AssertionFailedError thrown, so that the current testcase will fail.\n",
        "394": "   */\n",
        "395": "  public void threadAssertSame(Object x, Object y) {\n",
        "396": "    try {\n",
        "397": "      assertSame(x, y);\n",
        "398": "    } catch (AssertionFailedError t) {\n",
        "399": "      threadRecordFailure(t);\n",
        "400": "      throw t;\n",
        "401": "    }\n",
        "402": "  }\n",
        "403": "\n",
        "404": "  /** Calls threadFail with message \"should throw exception\". */\n",
        "405": "  public void threadShouldThrow() {\n",
        "406": "    threadFail(\"should throw exception\");\n",
        "407": "  }\n",
        "408": "\n",
        "409": "  /** Calls threadFail with message \"should throw\" + exceptionName. */\n",
        "410": "  public void threadShouldThrow(String exceptionName) {\n",
        "411": "    threadFail(\"should throw \" + exceptionName);\n",
        "412": "  }\n",
        "413": "\n",
        "414": "  /**\n",
        "415": "   * Records the given exception using {@link #threadRecordFailure}, then rethrows the exception,\n",
        "416": "   * wrapping it in an AssertionFailedError if necessary.\n",
        "417": "   */\n",
        "418": "  public void threadUnexpectedException(Throwable t) {\n",
        "419": "    threadRecordFailure(t);\n",
        "420": "    t.printStackTrace();\n",
        "421": "    if (t instanceof RuntimeException) throw (RuntimeException) t;\n",
        "422": "    else if (t instanceof Error) throw (Error) t;\n",
        "423": "    else {\n",
        "424": "      AssertionFailedError afe = new AssertionFailedError(\"unexpected exception: \" + t);\n",
        "425": "      afe.initCause(t);\n",
        "426": "      throw afe;\n",
        "427": "    }\n",
        "428": "  }\n",
        "429": "\n",
        "430": "  /**\n",
        "431": "   * Delays, via Thread.sleep, for the given millisecond delay, but if the sleep is shorter than\n",
        "432": "   * specified, may re-sleep or yield until time elapses.\n",
        "433": "   */\n",
        "434": "  static void delay(long millis) throws InterruptedException {\n",
        "435": "    long startTime = System.nanoTime();\n",
        "436": "    long ns = millis * 1000 * 1000;\n",
        "437": "    for (; ; ) {\n",
        "438": "      if (millis > 0L) Thread.sleep(millis);\n",
        "439": "      else // too short to sleep\n",
        "440": "      Thread.yield();\n",
        "441": "      long d = ns - (System.nanoTime() - startTime);\n",
        "442": "      if (d > 0L) millis = d / (1000 * 1000);\n",
        "443": "      else break;\n",
        "444": "    }\n",
        "445": "  }\n",
        "446": "\n",
        "447": "  /** Waits out termination of a thread pool or fails doing so. */\n",
        "448": "  void joinPool(ExecutorService exec) {\n",
        "449": "    try {\n",
        "450": "      exec.shutdown();\n",
        "451": "      assertTrue(\n",
        "452": "          \"ExecutorService did not terminate in a timely manner\",\n",
        "453": "          exec.awaitTermination(2 * LONG_DELAY_MS, MILLISECONDS));\n",
        "454": "    } catch (SecurityException ok) {\n",
        "455": "      // Allowed in case test doesn't have privs\n",
        "456": "    } catch (InterruptedException ie) {\n",
        "457": "      fail(\"Unexpected InterruptedException\");\n",
        "458": "    }\n",
        "459": "  }\n",
        "460": "\n",
        "461": "  /**\n",
        "462": "   * Checks that thread does not terminate within the default millisecond delay of {@code\n",
        "463": "   * timeoutMillis()}.\n",
        "464": "   */\n",
        "465": "  void assertThreadStaysAlive(Thread thread) {\n",
        "466": "    assertThreadStaysAlive(thread, timeoutMillis());\n",
        "467": "  }\n",
        "468": "\n",
        "469": "  /** Checks that thread does not terminate within the given millisecond delay. */\n",
        "470": "  void assertThreadStaysAlive(Thread thread, long millis) {\n",
        "471": "    try {\n",
        "472": "      // No need to optimize the failing case via Thread.join.\n",
        "473": "      delay(millis);\n",
        "474": "      assertTrue(thread.isAlive());\n",
        "475": "    } catch (InterruptedException ie) {\n",
        "476": "      fail(\"Unexpected InterruptedException\");\n",
        "477": "    }\n",
        "478": "  }\n",
        "479": "\n",
        "480": "  /**\n",
        "481": "   * Checks that the threads do not terminate within the default millisecond delay of {@code\n",
        "482": "   * timeoutMillis()}.\n",
        "483": "   */\n",
        "484": "  void assertThreadsStayAlive(Thread... threads) {\n",
        "485": "    assertThreadsStayAlive(timeoutMillis(), threads);\n",
        "486": "  }\n",
        "487": "\n",
        "488": "  /** Checks that the threads do not terminate within the given millisecond delay. */\n",
        "489": "  void assertThreadsStayAlive(long millis, Thread... threads) {\n",
        "490": "    try {\n",
        "491": "      // No need to optimize the failing case via Thread.join.\n",
        "492": "      delay(millis);\n",
        "493": "      for (Thread thread : threads) assertTrue(thread.isAlive());\n",
        "494": "    } catch (InterruptedException ie) {\n",
        "495": "      fail(\"Unexpected InterruptedException\");\n",
        "496": "    }\n",
        "497": "  }\n",
        "498": "\n",
        "499": "  /** Checks that future.get times out, with the default timeout of {@code timeoutMillis()}. */\n",
        "500": "  void assertFutureTimesOut(Future future) {\n",
        "501": "    assertFutureTimesOut(future, timeoutMillis());\n",
        "502": "  }\n",
        "503": "\n",
        "504": "  /** Checks that future.get times out, with the given millisecond timeout. */\n",
        "505": "  void assertFutureTimesOut(Future future, long timeoutMillis) {\n",
        "506": "    long startTime = System.nanoTime();\n",
        "507": "    try {\n",
        "508": "      future.get(timeoutMillis, MILLISECONDS);\n",
        "509": "      shouldThrow();\n",
        "510": "    } catch (TimeoutException success) {\n",
        "511": "    } catch (Exception e) {\n",
        "512": "      threadUnexpectedException(e);\n",
        "513": "    } finally {\n",
        "514": "      future.cancel(true);\n",
        "515": "    }\n",
        "516": "    assertTrue(millisElapsedSince(startTime) >= timeoutMillis);\n",
        "517": "  }\n",
        "518": "\n",
        "519": "  /** Fails with message \"should throw exception\". */\n",
        "520": "  public void shouldThrow() {\n",
        "521": "    fail(\"Should throw exception\");\n",
        "522": "  }\n",
        "523": "\n",
        "524": "  /** Fails with message \"should throw \" + exceptionName. */\n",
        "525": "  public void shouldThrow(String exceptionName) {\n",
        "526": "    fail(\"Should throw \" + exceptionName);\n",
        "527": "  }\n",
        "528": "\n",
        "529": "  /** The number of elements to place in collections, arrays, etc. */\n",
        "530": "  public static final int SIZE = 20;\n",
        "531": "\n",
        "532": "  // Some convenient Integer constants\n",
        "533": "\n",
        "534": "  public static final Integer zero = new Integer(0);\n",
        "535": "  public static final Integer one = new Integer(1);\n",
        "536": "  public static final Integer two = new Integer(2);\n",
        "537": "  public static final Integer three = new Integer(3);\n",
        "538": "  public static final Integer four = new Integer(4);\n",
        "539": "  public static final Integer five = new Integer(5);\n",
        "540": "  public static final Integer six = new Integer(6);\n",
        "541": "  public static final Integer seven = new Integer(7);\n",
        "542": "  public static final Integer eight = new Integer(8);\n",
        "543": "  public static final Integer nine = new Integer(9);\n",
        "544": "  public static final Integer m1 = new Integer(-1);\n",
        "545": "  public static final Integer m2 = new Integer(-2);\n",
        "546": "  public static final Integer m3 = new Integer(-3);\n",
        "547": "  public static final Integer m4 = new Integer(-4);\n",
        "548": "  public static final Integer m5 = new Integer(-5);\n",
        "549": "  public static final Integer m6 = new Integer(-6);\n",
        "550": "  public static final Integer m10 = new Integer(-10);\n",
        "551": "\n",
        "552": "  /**\n",
        "553": "   * Runs Runnable r with a security policy that permits precisely the specified permissions. If\n",
        "554": "   * there is no current security manager, the runnable is run twice, both with and without a\n",
        "555": "   * security manager. We require that any security manager permit getPolicy/setPolicy.\n",
        "556": "   */\n",
        "557": "  public void runWithPermissions(Runnable r, Permission... permissions) {\n",
        "558": "    SecurityManager sm = System.getSecurityManager();\n",
        "559": "    if (sm == null) {\n",
        "560": "      r.run();\n",
        "561": "      Policy savedPolicy = Policy.getPolicy();\n",
        "562": "      try {\n",
        "563": "        Policy.setPolicy(permissivePolicy());\n",
        "564": "        System.setSecurityManager(new SecurityManager());\n",
        "565": "        runWithPermissions(r, permissions);\n",
        "566": "      } finally {\n",
        "567": "        System.setSecurityManager(null);\n",
        "568": "        Policy.setPolicy(savedPolicy);\n",
        "569": "      }\n",
        "570": "    } else {\n",
        "571": "      Policy savedPolicy = Policy.getPolicy();\n",
        "572": "      AdjustablePolicy policy = new AdjustablePolicy(permissions);\n",
        "573": "      Policy.setPolicy(policy);\n",
        "574": "\n",
        "575": "      try {\n",
        "576": "        r.run();\n",
        "577": "      } finally {\n",
        "578": "        policy.addPermission(new SecurityPermission(\"setPolicy\"));\n",
        "579": "        Policy.setPolicy(savedPolicy);\n",
        "580": "      }\n",
        "581": "    }\n",
        "582": "  }\n",
        "583": "\n",
        "584": "  /** Runs a runnable without any permissions. */\n",
        "585": "  public void runWithoutPermissions(Runnable r) {\n",
        "586": "    runWithPermissions(r);\n",
        "587": "  }\n",
        "588": "\n",
        "589": "  /** A security policy where new permissions can be dynamically added or all cleared. */\n",
        "590": "  public static class AdjustablePolicy extends java.security.Policy {\n",
        "591": "    Permissions perms = new Permissions();\n",
        "592": "\n",
        "593": "    AdjustablePolicy(Permission... permissions) {\n",
        "594": "      for (Permission permission : permissions) perms.add(permission);\n",
        "595": "    }\n",
        "596": "\n",
        "597": "    void addPermission(Permission perm) {\n",
        "598": "      perms.add(perm);\n",
        "599": "    }\n",
        "600": "\n",
        "601": "    void clearPermissions() {\n",
        "602": "      perms = new Permissions();\n",
        "603": "    }\n",
        "604": "\n",
        "605": "    public PermissionCollection getPermissions(CodeSource cs) {\n",
        "606": "      return perms;\n",
        "607": "    }\n",
        "608": "\n",
        "609": "    public PermissionCollection getPermissions(ProtectionDomain pd) {\n",
        "610": "      return perms;\n",
        "611": "    }\n",
        "612": "\n",
        "613": "    public boolean implies(ProtectionDomain pd, Permission p) {\n",
        "614": "      return perms.implies(p);\n",
        "615": "    }\n",
        "616": "\n",
        "617": "    public void refresh() {}\n",
        "618": "  }\n",
        "619": "\n",
        "620": "  /** Returns a policy containing all the permissions we ever need. */\n",
        "621": "  public static Policy permissivePolicy() {\n",
        "622": "    return new AdjustablePolicy\n",
        "623": "    // Permissions j.u.c. needs directly\n",
        "624": "    (\n",
        "625": "        new RuntimePermission(\"modifyThread\"),\n",
        "626": "        new RuntimePermission(\"getClassLoader\"),\n",
        "627": "        new RuntimePermission(\"setContextClassLoader\"),\n",
        "628": "        // Permissions needed to change permissions!\n",
        "629": "        new SecurityPermission(\"getPolicy\"),\n",
        "630": "        new SecurityPermission(\"setPolicy\"),\n",
        "631": "        new RuntimePermission(\"setSecurityManager\"),\n",
        "632": "        // Permissions needed by the junit test harness\n",
        "633": "        new RuntimePermission(\"accessDeclaredMembers\"),\n",
        "634": "        new PropertyPermission(\"*\", \"read\"),\n",
        "635": "        new java.io.FilePermission(\"<<ALL FILES>>\", \"read\"));\n",
        "636": "  }\n",
        "637": "\n",
        "638": "  /** Sleeps until the given time has elapsed. Throws AssertionFailedError if interrupted. */\n",
        "639": "  void sleep(long millis) {\n",
        "640": "    try {\n",
        "641": "      delay(millis);\n",
        "642": "    } catch (InterruptedException ie) {\n",
        "643": "      AssertionFailedError afe = new AssertionFailedError(\"Unexpected InterruptedException\");\n",
        "644": "      afe.initCause(ie);\n",
        "645": "      throw afe;\n",
        "646": "    }\n",
        "647": "  }\n",
        "648": "\n",
        "649": "  /**\n",
        "650": "   * Spin-waits up to the specified number of milliseconds for the given thread to enter a wait\n",
        "651": "   * state: BLOCKED, WAITING, or TIMED_WAITING.\n",
        "652": "   */\n",
        "653": "  void waitForThreadToEnterWaitState(Thread thread, long timeoutMillis) {\n",
        "654": "    long startTime = System.nanoTime();\n",
        "655": "    for (; ; ) {\n",
        "656": "      Thread.State s = thread.getState();\n",
        "657": "      if (s == Thread.State.BLOCKED || s == Thread.State.WAITING || s == Thread.State.TIMED_WAITING)\n",
        "658": "        return;\n",
        "659": "      else if (s == Thread.State.TERMINATED) fail(\"Unexpected thread termination\");\n",
        "660": "      else if (millisElapsedSince(startTime) > timeoutMillis) {\n",
        "661": "        threadAssertTrue(thread.isAlive());\n",
        "662": "        return;\n",
        "663": "      }\n",
        "664": "      Thread.yield();\n",
        "665": "    }\n",
        "666": "  }\n",
        "667": "\n",
        "668": "  /**\n",
        "669": "   * Waits up to LONG_DELAY_MS for the given thread to enter a wait state: BLOCKED, WAITING, or\n",
        "670": "   * TIMED_WAITING.\n",
        "671": "   */\n",
        "672": "  void waitForThreadToEnterWaitState(Thread thread) {\n",
        "673": "    waitForThreadToEnterWaitState(thread, LONG_DELAY_MS);\n",
        "674": "  }\n",
        "675": "\n",
        "676": "  /**\n",
        "677": "   * Returns the number of milliseconds since time given by startNanoTime, which must have been\n",
        "678": "   * previously returned from a call to {@link System.nanoTime()}.\n",
        "679": "   */\n",
        "680": "  long millisElapsedSince(long startNanoTime) {\n",
        "681": "    return NANOSECONDS.toMillis(System.nanoTime() - startNanoTime);\n",
        "682": "  }\n",
        "683": "\n",
        "684": "  /** Returns a new started daemon Thread running the given runnable. */\n",
        "685": "  Thread newStartedThread(Runnable runnable) {\n",
        "686": "    Thread t = new Thread(runnable);\n",
        "687": "    t.setDaemon(true);\n",
        "688": "    t.start();\n",
        "689": "    return t;\n",
        "690": "  }\n",
        "691": "\n",
        "692": "  /**\n",
        "693": "   * Waits for the specified time (in milliseconds) for the thread to terminate (using {@link\n",
        "694": "   * Thread#join(long)}), else interrupts the thread (in the hope that it may terminate later) and\n",
        "695": "   * fails.\n",
        "696": "   */\n",
        "697": "  void awaitTermination(Thread t, long timeoutMillis) {\n",
        "698": "    try {\n",
        "699": "      t.join(timeoutMillis);\n",
        "700": "    } catch (InterruptedException ie) {\n",
        "701": "      threadUnexpectedException(ie);\n",
        "702": "    } finally {\n",
        "703": "      if (t.getState() != Thread.State.TERMINATED) {\n",
        "704": "        t.interrupt();\n",
        "705": "        fail(\"Test timed out\");\n",
        "706": "      }\n",
        "707": "    }\n",
        "708": "  }\n",
        "709": "\n",
        "710": "  /**\n",
        "711": "   * Waits for LONG_DELAY_MS milliseconds for the thread to terminate (using {@link\n",
        "712": "   * Thread#join(long)}), else interrupts the thread (in the hope that it may terminate later) and\n",
        "713": "   * fails.\n",
        "714": "   */\n",
        "715": "  void awaitTermination(Thread t) {\n",
        "716": "    awaitTermination(t, LONG_DELAY_MS);\n",
        "717": "  }\n",
        "718": "\n",
        "719": "  // Some convenient Runnable classes\n",
        "720": "\n",
        "721": "  public abstract class CheckedRunnable implements Runnable {\n",
        "722": "    protected abstract void realRun() throws Throwable;\n",
        "723": "\n",
        "724": "    public final void run() {\n",
        "725": "      try {\n",
        "726": "        realRun();\n",
        "727": "      } catch (Throwable t) {\n",
        "728": "        threadUnexpectedException(t);\n",
        "729": "      }\n",
        "730": "    }\n",
        "731": "  }\n",
        "732": "\n",
        "733": "  public abstract class RunnableShouldThrow implements Runnable {\n",
        "734": "    protected abstract void realRun() throws Throwable;\n",
        "735": "\n",
        "736": "    final Class<?> exceptionClass;\n",
        "737": "\n",
        "738": "    <T extends Throwable> RunnableShouldThrow(Class<T> exceptionClass) {\n",
        "739": "      this.exceptionClass = exceptionClass;\n",
        "740": "    }\n",
        "741": "\n",
        "742": "    public final void run() {\n",
        "743": "      try {\n",
        "744": "        realRun();\n",
        "745": "        threadShouldThrow(exceptionClass.getSimpleName());\n",
        "746": "      } catch (Throwable t) {\n",
        "747": "        if (!exceptionClass.isInstance(t)) threadUnexpectedException(t);\n",
        "748": "      }\n",
        "749": "    }\n",
        "750": "  }\n",
        "751": "\n",
        "752": "  public abstract class ThreadShouldThrow extends Thread {\n",
        "753": "    protected abstract void realRun() throws Throwable;\n",
        "754": "\n",
        "755": "    final Class<?> exceptionClass;\n",
        "756": "\n",
        "757": "    <T extends Throwable> ThreadShouldThrow(Class<T> exceptionClass) {\n",
        "758": "      this.exceptionClass = exceptionClass;\n",
        "759": "    }\n",
        "760": "\n",
        "761": "    public final void run() {\n",
        "762": "      try {\n",
        "763": "        realRun();\n",
        "764": "        threadShouldThrow(exceptionClass.getSimpleName());\n",
        "765": "      } catch (Throwable t) {\n",
        "766": "        if (!exceptionClass.isInstance(t)) threadUnexpectedException(t);\n",
        "767": "      }\n",
        "768": "    }\n",
        "769": "  }\n",
        "770": "\n",
        "771": "  public abstract class CheckedInterruptedRunnable implements Runnable {\n",
        "772": "    protected abstract void realRun() throws Throwable;\n",
        "773": "\n",
        "774": "    public final void run() {\n",
        "775": "      try {\n",
        "776": "        realRun();\n",
        "777": "        threadShouldThrow(\"InterruptedException\");\n",
        "778": "      } catch (InterruptedException success) {\n",
        "779": "        threadAssertFalse(Thread.interrupted());\n",
        "780": "      } catch (Throwable t) {\n",
        "781": "        threadUnexpectedException(t);\n",
        "782": "      }\n",
        "783": "    }\n",
        "784": "  }\n",
        "785": "\n",
        "786": "  public abstract class CheckedCallable<T> implements Callable<T> {\n",
        "787": "    protected abstract T realCall() throws Throwable;\n",
        "788": "\n",
        "789": "    public final T call() {\n",
        "790": "      try {\n",
        "791": "        return realCall();\n",
        "792": "      } catch (Throwable t) {\n",
        "793": "        threadUnexpectedException(t);\n",
        "794": "        return null;\n",
        "795": "      }\n",
        "796": "    }\n",
        "797": "  }\n",
        "799": "  public abstract class CheckedInterruptedCallable<T> implements Callable<T> {\n",
        "800": "    protected abstract T realCall() throws Throwable;\n",
        "802": "    public final T call() {\n",
        "803": "      try {\n",
        "804": "        T result = realCall();\n",
        "805": "        threadShouldThrow(\"InterruptedException\");\n",
        "806": "        return result;\n",
        "807": "      } catch (InterruptedException success) {\n",
        "808": "        threadAssertFalse(Thread.interrupted());\n",
        "809": "      } catch (Throwable t) {\n",
        "810": "        threadUnexpectedException(t);\n",
        "811": "      }\n",
        "812": "      return null;\n",
        "814": "  }\n",
        "816": "  public static class NoOpRunnable implements Runnable {\n",
        "817": "    public void run() {}\n",
        "818": "  }\n",
        "820": "  public static class NoOpCallable implements Callable {\n",
        "821": "    public Object call() {\n",
        "822": "      return Boolean.TRUE;\n",
        "824": "  }\n",
        "826": "  public static final String TEST_STRING = \"a test string\";\n",
        "828": "  public static class StringTask implements Callable<String> {\n",
        "829": "    public String call() {\n",
        "830": "      return TEST_STRING;\n",
        "832": "  }\n",
        "834": "  public Callable<String> latchAwaitingStringTask(final CountDownLatch latch) {\n",
        "835": "    return new CheckedCallable<String>() {\n",
        "836": "      protected String realCall() {\n",
        "838": "          latch.await();\n",
        "839": "        } catch (InterruptedException quittingTime) {\n",
        "841": "        return TEST_STRING;\n",
        "842": "      }\n",
        "843": "    };\n",
        "844": "  }\n",
        "845": "\n",
        "846": "  public Runnable awaiter(final CountDownLatch latch) {\n",
        "847": "    return new CheckedRunnable() {\n",
        "848": "      public void realRun() throws InterruptedException {\n",
        "849": "        await(latch);\n",
        "850": "      }\n",
        "851": "    };\n",
        "852": "  }\n",
        "853": "\n",
        "854": "  public void await(CountDownLatch latch) {\n",
        "855": "    try {\n",
        "856": "      assertTrue(latch.await(LONG_DELAY_MS, MILLISECONDS));\n",
        "857": "    } catch (Throwable t) {\n",
        "858": "      threadUnexpectedException(t);\n",
        "859": "    }\n",
        "860": "  }\n",
        "861": "\n",
        "862": "  public void await(Semaphore semaphore) {\n",
        "863": "    try {\n",
        "864": "      assertTrue(semaphore.tryAcquire(LONG_DELAY_MS, MILLISECONDS));\n",
        "865": "    } catch (Throwable t) {\n",
        "866": "      threadUnexpectedException(t);\n",
        "867": "    }\n",
        "868": "  }\n",
        "869": "\n",
        "870": "  //     /**\n",
        "871": "  //      * Spin-waits up to LONG_DELAY_MS until flag becomes true.\n",
        "872": "  //      */\n",
        "873": "  //     public void await(AtomicBoolean flag) {\n",
        "874": "  //         await(flag, LONG_DELAY_MS);\n",
        "875": "  //     }\n",
        "876": "\n",
        "877": "  //     /**\n",
        "878": "  //      * Spin-waits up to the specified timeout until flag becomes true.\n",
        "879": "  //      */\n",
        "880": "  //     public void await(AtomicBoolean flag, long timeoutMillis) {\n",
        "881": "  //         long startTime = System.nanoTime();\n",
        "882": "  //         while (!flag.get()) {\n",
        "883": "  //             if (millisElapsedSince(startTime) > timeoutMillis)\n",
        "884": "  //                 throw new AssertionFailedError(\"timed out\");\n",
        "885": "  //             Thread.yield();\n",
        "886": "  //         }\n",
        "887": "  //     }\n",
        "888": "\n",
        "889": "  public static class NPETask implements Callable<String> {\n",
        "890": "    public String call() {\n",
        "891": "      throw new NullPointerException();\n",
        "892": "    }\n",
        "893": "  }\n",
        "894": "\n",
        "895": "  public static class CallableOne implements Callable<Integer> {\n",
        "896": "    public Integer call() {\n",
        "897": "      return one;\n",
        "898": "    }\n",
        "899": "  }\n",
        "900": "\n",
        "901": "  public class ShortRunnable extends CheckedRunnable {\n",
        "902": "    protected void realRun() throws Throwable {\n",
        "903": "      delay(SHORT_DELAY_MS);\n",
        "904": "    }\n",
        "905": "  }\n",
        "906": "\n",
        "907": "  public class ShortInterruptedRunnable extends CheckedInterruptedRunnable {\n",
        "908": "    protected void realRun() throws InterruptedException {\n",
        "909": "      delay(SHORT_DELAY_MS);\n",
        "910": "    }\n",
        "911": "  }\n",
        "912": "\n",
        "913": "  public class SmallRunnable extends CheckedRunnable {\n",
        "914": "    protected void realRun() throws Throwable {\n",
        "915": "      delay(SMALL_DELAY_MS);\n",
        "916": "    }\n",
        "917": "  }\n",
        "918": "\n",
        "919": "  public class SmallPossiblyInterruptedRunnable extends CheckedRunnable {\n",
        "920": "    protected void realRun() {\n",
        "921": "      try {\n",
        "922": "        delay(SMALL_DELAY_MS);\n",
        "923": "      } catch (InterruptedException ok) {\n",
        "924": "      }\n",
        "925": "    }\n",
        "926": "  }\n",
        "927": "\n",
        "928": "  public class SmallCallable extends CheckedCallable {\n",
        "929": "    protected Object realCall() throws InterruptedException {\n",
        "930": "      delay(SMALL_DELAY_MS);\n",
        "931": "      return Boolean.TRUE;\n",
        "932": "    }\n",
        "933": "  }\n",
        "934": "\n",
        "935": "  public class MediumRunnable extends CheckedRunnable {\n",
        "936": "    protected void realRun() throws Throwable {\n",
        "937": "      delay(MEDIUM_DELAY_MS);\n",
        "938": "    }\n",
        "939": "  }\n",
        "940": "\n",
        "941": "  public class MediumInterruptedRunnable extends CheckedInterruptedRunnable {\n",
        "942": "    protected void realRun() throws InterruptedException {\n",
        "943": "      delay(MEDIUM_DELAY_MS);\n",
        "945": "  }\n",
        "946": "\n",
        "947": "  public Runnable possiblyInterruptedRunnable(final long timeoutMillis) {\n",
        "948": "    return new CheckedRunnable() {\n",
        "949": "      protected void realRun() {\n",
        "951": "          delay(timeoutMillis);\n",
        "952": "        } catch (InterruptedException ok) {\n",
        "954": "      }\n",
        "955": "    };\n",
        "956": "  }\n",
        "958": "  public class MediumPossiblyInterruptedRunnable extends CheckedRunnable {\n",
        "959": "    protected void realRun() {\n",
        "960": "      try {\n",
        "961": "        delay(MEDIUM_DELAY_MS);\n",
        "962": "      } catch (InterruptedException ok) {\n",
        "963": "      }\n",
        "965": "  }\n",
        "967": "  public class LongPossiblyInterruptedRunnable extends CheckedRunnable {\n",
        "968": "    protected void realRun() {\n",
        "969": "      try {\n",
        "970": "        delay(LONG_DELAY_MS);\n",
        "971": "      } catch (InterruptedException ok) {\n",
        "972": "      }\n",
        "974": "  }\n",
        "976": "  /** For use as ThreadFactory in constructors */\n",
        "977": "  public static class SimpleThreadFactory implements ThreadFactory {\n",
        "978": "    public Thread newThread(Runnable r) {\n",
        "979": "      return new Thread(r);\n",
        "981": "  }\n",
        "983": "  public interface TrackedRunnable extends Runnable {\n",
        "984": "    boolean isDone();\n",
        "985": "  }\n",
        "987": "  public static TrackedRunnable trackedRunnable(final long timeoutMillis) {\n",
        "988": "    return new TrackedRunnable() {\n",
        "989": "      private volatile boolean done = false;\n",
        "991": "      public boolean isDone() {\n",
        "992": "        return done;\n",
        "993": "      }\n",
        "995": "      public void run() {\n",
        "997": "          delay(timeoutMillis);\n",
        "998": "          done = true;\n",
        "999": "        } catch (InterruptedException ok) {\n",
        "1001": "      }\n",
        "1002": "    };\n",
        "1003": "  }\n",
        "1004": "\n",
        "1005": "  public static class TrackedShortRunnable implements Runnable {\n",
        "1006": "    public volatile boolean done = false;\n",
        "1007": "\n",
        "1008": "    public void run() {\n",
        "1009": "      try {\n",
        "1010": "        delay(SHORT_DELAY_MS);\n",
        "1011": "        done = true;\n",
        "1012": "      } catch (InterruptedException ok) {\n",
        "1013": "      }\n",
        "1014": "    }\n",
        "1015": "  }\n",
        "1016": "\n",
        "1017": "  public static class TrackedSmallRunnable implements Runnable {\n",
        "1018": "    public volatile boolean done = false;\n",
        "1019": "\n",
        "1020": "    public void run() {\n",
        "1021": "      try {\n",
        "1022": "        delay(SMALL_DELAY_MS);\n",
        "1023": "        done = true;\n",
        "1024": "      } catch (InterruptedException ok) {\n",
        "1025": "      }\n",
        "1026": "    }\n",
        "1027": "  }\n",
        "1028": "\n",
        "1029": "  public static class TrackedMediumRunnable implements Runnable {\n",
        "1030": "    public volatile boolean done = false;\n",
        "1031": "\n",
        "1032": "    public void run() {\n",
        "1033": "      try {\n",
        "1034": "        delay(MEDIUM_DELAY_MS);\n",
        "1035": "        done = true;\n",
        "1036": "      } catch (InterruptedException ok) {\n",
        "1037": "      }\n",
        "1038": "    }\n",
        "1039": "  }\n",
        "1040": "\n",
        "1041": "  public static class TrackedLongRunnable implements Runnable {\n",
        "1042": "    public volatile boolean done = false;\n",
        "1043": "\n",
        "1044": "    public void run() {\n",
        "1045": "      try {\n",
        "1046": "        delay(LONG_DELAY_MS);\n",
        "1047": "        done = true;\n",
        "1048": "      } catch (InterruptedException ok) {\n",
        "1049": "      }\n",
        "1050": "    }\n",
        "1051": "  }\n",
        "1052": "\n",
        "1053": "  public static class TrackedNoOpRunnable implements Runnable {\n",
        "1054": "    public volatile boolean done = false;\n",
        "1055": "\n",
        "1056": "    public void run() {\n",
        "1057": "      done = true;\n",
        "1058": "    }\n",
        "1059": "  }\n",
        "1060": "\n",
        "1061": "  public static class TrackedCallable implements Callable {\n",
        "1062": "    public volatile boolean done = false;\n",
        "1063": "\n",
        "1064": "    public Object call() {\n",
        "1065": "      try {\n",
        "1066": "        delay(SMALL_DELAY_MS);\n",
        "1067": "        done = true;\n",
        "1068": "      } catch (InterruptedException ok) {\n",
        "1069": "      }\n",
        "1070": "      return Boolean.TRUE;\n",
        "1071": "    }\n",
        "1072": "  }\n",
        "1073": "\n",
        "1074": "  //     /**\n",
        "1075": "  //      * Analog of CheckedRunnable for RecursiveAction\n",
        "1076": "  //      */\n",
        "1077": "  //     public abstract class CheckedRecursiveAction extends RecursiveAction {\n",
        "1078": "  //         protected abstract void realCompute() throws Throwable;\n",
        "1079": "\n",
        "1080": "  //         public final void compute() {\n",
        "1081": "  //             try {\n",
        "1082": "  //                 realCompute();\n",
        "1083": "  //             } catch (Throwable t) {\n",
        "1084": "  //                 threadUnexpectedException(t);\n",
        "1085": "  //             }\n",
        "1086": "  //         }\n",
        "1087": "  //     }\n",
        "1088": "\n",
        "1089": "  //     /**\n",
        "1090": "  //      * Analog of CheckedCallable for RecursiveTask\n",
        "1091": "  //      */\n",
        "1092": "  //     public abstract class CheckedRecursiveTask<T> extends RecursiveTask<T> {\n",
        "1093": "  //         protected abstract T realCompute() throws Throwable;\n",
        "1094": "\n",
        "1095": "  //         public final T compute() {\n",
        "1096": "  //             try {\n",
        "1097": "  //                 return realCompute();\n",
        "1098": "  //             } catch (Throwable t) {\n",
        "1099": "  //                 threadUnexpectedException(t);\n",
        "1100": "  //                 return null;\n",
        "1101": "  //             }\n",
        "1102": "  //         }\n",
        "1103": "  //     }\n",
        "1104": "\n",
        "1105": "  /** For use as RejectedExecutionHandler in constructors */\n",
        "1106": "  public static class NoOpREHandler implements RejectedExecutionHandler {\n",
        "1107": "    public void rejectedExecution(Runnable r, ThreadPoolExecutor executor) {}\n",
        "1108": "  }\n",
        "1109": "\n",
        "1110": "  /**\n",
        "1111": "   * A CyclicBarrier that uses timed await and fails with AssertionFailedErrors instead of throwing\n",
        "1112": "   * checked exceptions.\n",
        "1113": "   */\n",
        "1114": "  public class CheckedBarrier extends CyclicBarrier {\n",
        "1115": "    public CheckedBarrier(int parties) {\n",
        "1116": "      super(parties);\n",
        "1117": "    }\n",
        "1118": "\n",
        "1119": "    public int await() {\n",
        "1120": "      try {\n",
        "1121": "        return super.await(2 * LONG_DELAY_MS, MILLISECONDS);\n",
        "1122": "      } catch (TimeoutException e) {\n",
        "1123": "        throw new AssertionFailedError(\"timed out\");\n",
        "1124": "      } catch (Exception e) {\n",
        "1125": "        AssertionFailedError afe = new AssertionFailedError(\"Unexpected exception: \" + e);\n",
        "1126": "        afe.initCause(e);\n",
        "1127": "        throw afe;\n",
        "1128": "      }\n",
        "1129": "    }\n",
        "1130": "  }\n",
        "1131": "\n",
        "1132": "  void checkEmpty(BlockingQueue q) {\n",
        "1133": "    try {\n",
        "1134": "      assertTrue(q.isEmpty());\n",
        "1135": "      assertEquals(0, q.size());\n",
        "1136": "      assertNull(q.peek());\n",
        "1137": "      assertNull(q.poll());\n",
        "1138": "      assertNull(q.poll(0, MILLISECONDS));\n",
        "1140": "      assertTrue(Arrays.equals(q.toArray(), new Object[0]));\n",
        "1141": "      assertFalse(q.iterator().hasNext());\n",
        "1142": "      try {\n",
        "1143": "        q.element();\n",
        "1144": "        shouldThrow();\n",
        "1145": "      } catch (NoSuchElementException success) {\n",
        "1146": "      }\n",
        "1147": "      try {\n",
        "1148": "        q.iterator().next();\n",
        "1149": "        shouldThrow();\n",
        "1150": "      } catch (NoSuchElementException success) {\n",
        "1151": "      }\n",
        "1152": "      try {\n",
        "1153": "        q.remove();\n",
        "1154": "        shouldThrow();\n",
        "1155": "      } catch (NoSuchElementException success) {\n",
        "1156": "      }\n",
        "1157": "    } catch (InterruptedException ie) {\n",
        "1158": "      threadUnexpectedException(ie);\n",
        "1159": "    }\n",
        "1160": "  }\n",
        "1161": "\n",
        "1162": "  @SuppressWarnings(\"unchecked\")\n",
        "1163": "  <T> T serialClone(T o) {\n",
        "1164": "    try {\n",
        "1165": "      ByteArrayOutputStream bos = new ByteArrayOutputStream();\n",
        "1166": "      ObjectOutputStream oos = new ObjectOutputStream(bos);\n",
        "1167": "      oos.writeObject(o);\n",
        "1168": "      oos.flush();\n",
        "1169": "      oos.close();\n",
        "1170": "      ObjectInputStream ois = new ObjectInputStream(new ByteArrayInputStream(bos.toByteArray()));\n",
        "1171": "      T clone = (T) ois.readObject();\n",
        "1172": "      assertSame(o.getClass(), clone.getClass());\n",
        "1173": "      return clone;\n",
        "1174": "    } catch (Throwable t) {\n",
        "1175": "      threadUnexpectedException(t);\n",
        "1176": "      return null;\n",
        "1177": "    }\n",
        "1178": "  }\n"
    },
    "removed": {
        "52": " * Base class for JSR166 Junit TCK tests.  Defines some constants,\n",
        "53": " * utility methods and classes, as well as a simple framework for\n",
        "54": " * helping to make sure that assertions failing in generated threads\n",
        "55": " * cause the associated test that generated them to itself fail (which\n",
        "56": " * JUnit does not otherwise arrange).  The rules for creating such\n",
        "57": " * tests are:\n",
        "60": " *\n",
        "61": " * <li> All assertions in code running in generated threads must use\n",
        "62": " * the forms {@link #threadFail}, {@link #threadAssertTrue}, {@link\n",
        "63": " * #threadAssertEquals}, or {@link #threadAssertNull}, (not\n",
        "64": " * {@code fail}, {@code assertTrue}, etc.) It is OK (but not\n",
        "65": " * particularly recommended) for other code to use these forms too.\n",
        "66": " * Only the most typically used JUnit assertion methods are defined\n",
        "67": " * this way, but enough to live with.</li>\n",
        "68": " *\n",
        "69": " * <li> If you override {@link #setUp} or {@link #tearDown}, make sure\n",
        "70": " * to invoke {@code super.setUp} and {@code super.tearDown} within\n",
        "71": " * them. These methods are used to clear and check for thread\n",
        "72": " * assertion failures.</li>\n",
        "73": " *\n",
        "74": " * <li>All delays and timeouts must use one of the constants {@code\n",
        "75": " * SHORT_DELAY_MS}, {@code SMALL_DELAY_MS}, {@code MEDIUM_DELAY_MS},\n",
        "76": " * {@code LONG_DELAY_MS}. The idea here is that a SHORT is always\n",
        "77": " * discriminable from zero time, and always allows enough time for the\n",
        "78": " * small amounts of computation (creating a thread, calling a few\n",
        "79": " * methods, etc) needed to reach a timeout point. Similarly, a SMALL\n",
        "80": " * is always discriminable as larger than SHORT and smaller than\n",
        "81": " * MEDIUM.  And so on. These constants are set to conservative values,\n",
        "82": " * but even so, if there is ever any doubt, they can all be increased\n",
        "83": " * in one spot to rerun tests on slower platforms.</li>\n",
        "84": " *\n",
        "85": " * <li> All threads generated must be joined inside each test case\n",
        "86": " * method (or {@code fail} to do so) before returning from the\n",
        "87": " * method. The {@code joinPool} method can be used to do this when\n",
        "88": " * using Executors.</li>\n",
        "89": " *\n",
        "92": " * <p> <b>Other notes</b>\n",
        "93": " * <ul>\n",
        "94": " *\n",
        "95": " * <li> Usually, there is one testcase method per JSR166 method\n",
        "96": " * covering \"normal\" operation, and then as many exception-testing\n",
        "97": " * methods as there are exceptions the method can throw. Sometimes\n",
        "98": " * there are multiple tests per JSR166 method when the different\n",
        "99": " * \"normal\" behaviors differ significantly. And sometimes testcases\n",
        "100": " * cover multiple methods when they cannot be tested in\n",
        "101": " * isolation.</li>\n",
        "102": " *\n",
        "103": " * <li> The documentation style for testcases is to provide as javadoc\n",
        "104": " * a simple sentence or two describing the property that the testcase\n",
        "105": " * method purports to test. The javadocs do not say anything about how\n",
        "106": " * the property is tested. To find out, read the code.</li>\n",
        "107": " *\n",
        "108": " * <li> These tests are \"conformance tests\", and do not attempt to\n",
        "109": " * test throughput, latency, scalability or other performance factors\n",
        "110": " * (see the separate \"jtreg\" tests for a set intended to check these\n",
        "111": " * for the most central aspects of functionality.) So, most tests use\n",
        "112": " * the smallest sensible numbers of threads, collection sizes, etc\n",
        "113": " * needed to check basic conformance.</li>\n",
        "114": " *\n",
        "115": " * <li>The test classes currently do not declare inclusion in\n",
        "116": " * any particular package to simplify things for people integrating\n",
        "117": " * them in TCK test suites.</li>\n",
        "118": " *\n",
        "119": " * <li> As a convenience, the {@code main} of this class (JSR166TestCase)\n",
        "120": " * runs all JSR166 unit tests.</li>\n",
        "125": "    private static final boolean useSecurityManager =\n",
        "126": "        Boolean.getBoolean(\"jsr166.useSecurityManager\");\n",
        "127": "\n",
        "128": "    protected static final boolean expensiveTests =\n",
        "129": "        Boolean.getBoolean(\"jsr166.expensiveTests\");\n",
        "130": "\n",
        "131": "    /**\n",
        "132": "     * If true, report on stdout all \"slow\" tests, that is, ones that\n",
        "133": "     * take more than profileThreshold milliseconds to execute.\n",
        "134": "     */\n",
        "135": "    private static final boolean profileTests =\n",
        "136": "        Boolean.getBoolean(\"jsr166.profileTests\");\n",
        "137": "\n",
        "138": "    /**\n",
        "139": "     * The number of milliseconds that tests are permitted for\n",
        "140": "     * execution without being reported, when profileTests is set.\n",
        "141": "     */\n",
        "142": "    private static final long profileThreshold =\n",
        "143": "        Long.getLong(\"jsr166.profileThreshold\", 100);\n",
        "144": "\n",
        "145": "    protected void runTest() throws Throwable {\n",
        "146": "        if (profileTests)\n",
        "147": "            runTestProfiled();\n",
        "148": "        else\n",
        "149": "            super.runTest();\n",
        "150": "    }\n",
        "151": "\n",
        "152": "    protected void runTestProfiled() throws Throwable {\n",
        "153": "        long t0 = System.nanoTime();\n",
        "154": "        try {\n",
        "155": "            super.runTest();\n",
        "156": "        } finally {\n",
        "157": "            long elapsedMillis =\n",
        "158": "                (System.nanoTime() - t0) / (1000L * 1000L);\n",
        "159": "            if (elapsedMillis >= profileThreshold)\n",
        "160": "                System.out.printf(\"%n%s: %d%n\", toString(), elapsedMillis);\n",
        "161": "        }\n",
        "162": "    }\n",
        "163": "\n",
        "164": "//     /**\n",
        "165": "//      * Runs all JSR166 unit tests using junit.textui.TestRunner\n",
        "166": "//      */\n",
        "167": "//     public static void main(String[] args) {\n",
        "168": "//         if (useSecurityManager) {\n",
        "169": "//             System.err.println(\"Setting a permissive security manager\");\n",
        "170": "//             Policy.setPolicy(permissivePolicy());\n",
        "171": "//             System.setSecurityManager(new SecurityManager());\n",
        "172": "//         }\n",
        "173": "//         int iters = (args.length == 0) ? 1 : Integer.parseInt(args[0]);\n",
        "174": "\n",
        "175": "//         Test s = suite();\n",
        "176": "//         for (int i = 0; i < iters; ++i) {\n",
        "177": "//             junit.textui.TestRunner.run(s);\n",
        "178": "//             System.gc();\n",
        "179": "//             System.runFinalization();\n",
        "180": "//         }\n",
        "181": "//         System.exit(0);\n",
        "182": "//     }\n",
        "183": "\n",
        "184": "//     public static TestSuite newTestSuite(Object... suiteOrClasses) {\n",
        "185": "//         TestSuite suite = new TestSuite();\n",
        "186": "//         for (Object suiteOrClass : suiteOrClasses) {\n",
        "187": "//             if (suiteOrClass instanceof TestSuite)\n",
        "188": "//                 suite.addTest((TestSuite) suiteOrClass);\n",
        "189": "//             else if (suiteOrClass instanceof Class)\n",
        "190": "//                 suite.addTest(new TestSuite((Class<?>) suiteOrClass));\n",
        "191": "//             else\n",
        "192": "//                 throw new ClassCastException(\"not a test suite or class\");\n",
        "193": "//         }\n",
        "194": "//         return suite;\n",
        "195": "//     }\n",
        "196": "\n",
        "197": "//     /**\n",
        "198": "//      * Collects all JSR166 unit tests as one suite.\n",
        "199": "//      */\n",
        "200": "//     public static Test suite() {\n",
        "201": "//         return newTestSuite(\n",
        "202": "//             ForkJoinPoolTest.suite(),\n",
        "203": "//             ForkJoinTaskTest.suite(),\n",
        "204": "//             RecursiveActionTest.suite(),\n",
        "205": "//             RecursiveTaskTest.suite(),\n",
        "206": "//             LinkedTransferQueueTest.suite(),\n",
        "207": "//             PhaserTest.suite(),\n",
        "208": "//             ThreadLocalRandomTest.suite(),\n",
        "209": "//             AbstractExecutorServiceTest.suite(),\n",
        "210": "//             AbstractQueueTest.suite(),\n",
        "211": "//             AbstractQueuedSynchronizerTest.suite(),\n",
        "212": "//             AbstractQueuedLongSynchronizerTest.suite(),\n",
        "213": "//             ArrayBlockingQueueTest.suite(),\n",
        "214": "//             ArrayDequeTest.suite(),\n",
        "215": "//             AtomicBooleanTest.suite(),\n",
        "216": "//             AtomicIntegerArrayTest.suite(),\n",
        "217": "//             AtomicIntegerFieldUpdaterTest.suite(),\n",
        "218": "//             AtomicIntegerTest.suite(),\n",
        "219": "//             AtomicLongArrayTest.suite(),\n",
        "220": "//             AtomicLongFieldUpdaterTest.suite(),\n",
        "221": "//             AtomicLongTest.suite(),\n",
        "222": "//             AtomicMarkableReferenceTest.suite(),\n",
        "223": "//             AtomicReferenceArrayTest.suite(),\n",
        "224": "//             AtomicReferenceFieldUpdaterTest.suite(),\n",
        "225": "//             AtomicReferenceTest.suite(),\n",
        "226": "//             AtomicStampedReferenceTest.suite(),\n",
        "227": "//             ConcurrentHashMapTest.suite(),\n",
        "228": "//             ConcurrentLinkedDequeTest.suite(),\n",
        "229": "//             ConcurrentLinkedQueueTest.suite(),\n",
        "230": "//             ConcurrentSkipListMapTest.suite(),\n",
        "231": "//             ConcurrentSkipListSubMapTest.suite(),\n",
        "232": "//             ConcurrentSkipListSetTest.suite(),\n",
        "233": "//             ConcurrentSkipListSubSetTest.suite(),\n",
        "234": "//             CopyOnWriteArrayListTest.suite(),\n",
        "235": "//             CopyOnWriteArraySetTest.suite(),\n",
        "236": "//             CountDownLatchTest.suite(),\n",
        "237": "//             CyclicBarrierTest.suite(),\n",
        "238": "//             DelayQueueTest.suite(),\n",
        "239": "//             EntryTest.suite(),\n",
        "240": "//             ExchangerTest.suite(),\n",
        "241": "//             ExecutorsTest.suite(),\n",
        "242": "//             ExecutorCompletionServiceTest.suite(),\n",
        "243": "//             FutureTaskTest.suite(),\n",
        "244": "//             LinkedBlockingDequeTest.suite(),\n",
        "245": "//             LinkedBlockingQueueTest.suite(),\n",
        "246": "//             LinkedListTest.suite(),\n",
        "247": "//             LockSupportTest.suite(),\n",
        "248": "//             PriorityBlockingQueueTest.suite(),\n",
        "249": "//             PriorityQueueTest.suite(),\n",
        "250": "//             ReentrantLockTest.suite(),\n",
        "251": "//             ReentrantReadWriteLockTest.suite(),\n",
        "252": "//             ScheduledExecutorTest.suite(),\n",
        "253": "//             ScheduledExecutorSubclassTest.suite(),\n",
        "254": "//             SemaphoreTest.suite(),\n",
        "255": "//             SynchronousQueueTest.suite(),\n",
        "256": "//             SystemTest.suite(),\n",
        "257": "//             ThreadLocalTest.suite(),\n",
        "258": "//             ThreadPoolExecutorTest.suite(),\n",
        "259": "//             ThreadPoolExecutorSubclassTest.suite(),\n",
        "260": "//             ThreadTest.suite(),\n",
        "261": "//             TimeUnitTest.suite(),\n",
        "262": "//             TreeMapTest.suite(),\n",
        "263": "//             TreeSetTest.suite(),\n",
        "264": "//             TreeSubMapTest.suite(),\n",
        "265": "//             TreeSubSetTest.suite());\n",
        "266": "//     }\n",
        "267": "\n",
        "268": "    public static long SHORT_DELAY_MS;\n",
        "269": "    public static long SMALL_DELAY_MS;\n",
        "270": "    public static long MEDIUM_DELAY_MS;\n",
        "271": "    public static long LONG_DELAY_MS;\n",
        "272": "\n",
        "273": "    /**\n",
        "274": "     * Returns the shortest timed delay. This could\n",
        "275": "     * be reimplemented to use for example a Property.\n",
        "276": "     */\n",
        "277": "    protected long getShortDelay() {\n",
        "278": "        return 50;\n",
        "279": "    }\n",
        "280": "\n",
        "281": "    /**\n",
        "282": "     * Sets delays as multiples of SHORT_DELAY.\n",
        "283": "     */\n",
        "284": "    protected void setDelays() {\n",
        "285": "        SHORT_DELAY_MS = getShortDelay();\n",
        "286": "        SMALL_DELAY_MS  = SHORT_DELAY_MS * 5;\n",
        "287": "        MEDIUM_DELAY_MS = SHORT_DELAY_MS * 10;\n",
        "288": "        LONG_DELAY_MS   = SHORT_DELAY_MS * 200;\n",
        "289": "    }\n",
        "290": "\n",
        "291": "    /**\n",
        "292": "     * Returns a timeout in milliseconds to be used in tests that\n",
        "293": "     * verify that operations block or time out.\n",
        "294": "     */\n",
        "295": "    long timeoutMillis() {\n",
        "296": "        return SHORT_DELAY_MS / 4;\n",
        "297": "    }\n",
        "298": "\n",
        "299": "    /**\n",
        "300": "     * Returns a new Date instance representing a time delayMillis\n",
        "301": "     * milliseconds in the future.\n",
        "302": "     */\n",
        "303": "    Date delayedDate(long delayMillis) {\n",
        "304": "        return new Date(System.currentTimeMillis() + delayMillis);\n",
        "305": "    }\n",
        "310": "    /**\n",
        "311": "     * Records an exception so that it can be rethrown later in the test\n",
        "312": "     * harness thread, triggering a test case failure.  Only the first\n",
        "313": "     * failure is recorded; subsequent calls to this method from within\n",
        "314": "     * the same test have no effect.\n",
        "315": "     */\n",
        "316": "    public void threadRecordFailure(Throwable t) {\n",
        "317": "        threadFailure.compareAndSet(null, t);\n",
        "318": "    }\n",
        "319": "\n",
        "320": "    public void setUp() {\n",
        "321": "        setDelays();\n",
        "322": "    }\n",
        "323": "\n",
        "324": "    /**\n",
        "325": "     * Extra checks that get done for all test cases.\n",
        "326": "     *\n",
        "327": "     * Triggers test case failure if any thread assertions have failed,\n",
        "328": "     * by rethrowing, in the test harness thread, any exception recorded\n",
        "329": "     * earlier by threadRecordFailure.\n",
        "330": "     *\n",
        "331": "     * Triggers test case failure if interrupt status is set in the main thread.\n",
        "332": "     */\n",
        "333": "    public void tearDown() throws Exception {\n",
        "334": "        Throwable t = threadFailure.getAndSet(null);\n",
        "335": "        if (t != null) {\n",
        "336": "            if (t instanceof Error)\n",
        "337": "                throw (Error) t;\n",
        "338": "            else if (t instanceof RuntimeException)\n",
        "339": "                throw (RuntimeException) t;\n",
        "340": "            else if (t instanceof Exception)\n",
        "341": "                throw (Exception) t;\n",
        "342": "            else {\n",
        "343": "                AssertionFailedError afe =\n",
        "344": "                    new AssertionFailedError(t.toString());\n",
        "345": "                afe.initCause(t);\n",
        "346": "                throw afe;\n",
        "347": "            }\n",
        "348": "        }\n",
        "349": "\n",
        "350": "        if (Thread.interrupted())\n",
        "351": "            throw new AssertionFailedError(\"interrupt status set in main thread\");\n",
        "352": "    }\n",
        "353": "\n",
        "354": "    /**\n",
        "355": "     * Just like fail(reason), but additionally recording (using\n",
        "356": "     * threadRecordFailure) any AssertionFailedError thrown, so that\n",
        "357": "     * the current testcase will fail.\n",
        "358": "     */\n",
        "359": "    public void threadFail(String reason) {\n",
        "360": "        try {\n",
        "361": "            fail(reason);\n",
        "362": "        } catch (AssertionFailedError t) {\n",
        "363": "            threadRecordFailure(t);\n",
        "364": "            fail(reason);\n",
        "365": "        }\n",
        "366": "    }\n",
        "367": "\n",
        "368": "    /**\n",
        "369": "     * Just like assertTrue(b), but additionally recording (using\n",
        "370": "     * threadRecordFailure) any AssertionFailedError thrown, so that\n",
        "371": "     * the current testcase will fail.\n",
        "372": "     */\n",
        "373": "    public void threadAssertTrue(boolean b) {\n",
        "374": "        try {\n",
        "375": "            assertTrue(b);\n",
        "376": "        } catch (AssertionFailedError t) {\n",
        "377": "            threadRecordFailure(t);\n",
        "378": "            throw t;\n",
        "379": "        }\n",
        "380": "    }\n",
        "381": "\n",
        "382": "    /**\n",
        "383": "     * Just like assertFalse(b), but additionally recording (using\n",
        "384": "     * threadRecordFailure) any AssertionFailedError thrown, so that\n",
        "385": "     * the current testcase will fail.\n",
        "386": "     */\n",
        "387": "    public void threadAssertFalse(boolean b) {\n",
        "388": "        try {\n",
        "389": "            assertFalse(b);\n",
        "390": "        } catch (AssertionFailedError t) {\n",
        "391": "            threadRecordFailure(t);\n",
        "392": "            throw t;\n",
        "393": "        }\n",
        "394": "    }\n",
        "395": "\n",
        "396": "    /**\n",
        "397": "     * Just like assertNull(x), but additionally recording (using\n",
        "398": "     * threadRecordFailure) any AssertionFailedError thrown, so that\n",
        "399": "     * the current testcase will fail.\n",
        "400": "     */\n",
        "401": "    public void threadAssertNull(Object x) {\n",
        "402": "        try {\n",
        "403": "            assertNull(x);\n",
        "404": "        } catch (AssertionFailedError t) {\n",
        "405": "            threadRecordFailure(t);\n",
        "406": "            throw t;\n",
        "407": "        }\n",
        "408": "    }\n",
        "409": "\n",
        "410": "    /**\n",
        "411": "     * Just like assertEquals(x, y), but additionally recording (using\n",
        "412": "     * threadRecordFailure) any AssertionFailedError thrown, so that\n",
        "413": "     * the current testcase will fail.\n",
        "414": "     */\n",
        "415": "    public void threadAssertEquals(long x, long y) {\n",
        "416": "        try {\n",
        "417": "            assertEquals(x, y);\n",
        "418": "        } catch (AssertionFailedError t) {\n",
        "419": "            threadRecordFailure(t);\n",
        "420": "            throw t;\n",
        "421": "        }\n",
        "422": "    }\n",
        "423": "\n",
        "424": "    /**\n",
        "425": "     * Just like assertEquals(x, y), but additionally recording (using\n",
        "426": "     * threadRecordFailure) any AssertionFailedError thrown, so that\n",
        "427": "     * the current testcase will fail.\n",
        "428": "     */\n",
        "429": "    public void threadAssertEquals(Object x, Object y) {\n",
        "430": "        try {\n",
        "431": "            assertEquals(x, y);\n",
        "432": "        } catch (AssertionFailedError t) {\n",
        "433": "            threadRecordFailure(t);\n",
        "434": "            throw t;\n",
        "435": "        } catch (Throwable t) {\n",
        "436": "            threadUnexpectedException(t);\n",
        "437": "        }\n",
        "438": "    }\n",
        "439": "\n",
        "440": "    /**\n",
        "441": "     * Just like assertSame(x, y), but additionally recording (using\n",
        "442": "     * threadRecordFailure) any AssertionFailedError thrown, so that\n",
        "443": "     * the current testcase will fail.\n",
        "444": "     */\n",
        "445": "    public void threadAssertSame(Object x, Object y) {\n",
        "446": "        try {\n",
        "447": "            assertSame(x, y);\n",
        "448": "        } catch (AssertionFailedError t) {\n",
        "449": "            threadRecordFailure(t);\n",
        "450": "            throw t;\n",
        "451": "        }\n",
        "452": "    }\n",
        "454": "    /**\n",
        "455": "     * Calls threadFail with message \"should throw exception\".\n",
        "456": "     */\n",
        "457": "    public void threadShouldThrow() {\n",
        "458": "        threadFail(\"should throw exception\");\n",
        "459": "    }\n",
        "461": "    /**\n",
        "462": "     * Calls threadFail with message \"should throw\" + exceptionName.\n",
        "463": "     */\n",
        "464": "    public void threadShouldThrow(String exceptionName) {\n",
        "465": "        threadFail(\"should throw \" + exceptionName);\n",
        "468": "    /**\n",
        "469": "     * Records the given exception using {@link #threadRecordFailure},\n",
        "470": "     * then rethrows the exception, wrapping it in an\n",
        "471": "     * AssertionFailedError if necessary.\n",
        "472": "     */\n",
        "473": "    public void threadUnexpectedException(Throwable t) {\n",
        "474": "        threadRecordFailure(t);\n",
        "475": "        t.printStackTrace();\n",
        "476": "        if (t instanceof RuntimeException)\n",
        "477": "            throw (RuntimeException) t;\n",
        "478": "        else if (t instanceof Error)\n",
        "479": "            throw (Error) t;\n",
        "480": "        else {\n",
        "481": "            AssertionFailedError afe =\n",
        "482": "                new AssertionFailedError(\"unexpected exception: \" + t);\n",
        "483": "            afe.initCause(t);\n",
        "484": "            throw afe;\n",
        "485": "        }\n",
        "486": "    }\n",
        "488": "    /**\n",
        "489": "     * Delays, via Thread.sleep, for the given millisecond delay, but\n",
        "490": "     * if the sleep is shorter than specified, may re-sleep or yield\n",
        "491": "     * until time elapses.\n",
        "492": "     */\n",
        "493": "    static void delay(long millis) throws InterruptedException {\n",
        "494": "        long startTime = System.nanoTime();\n",
        "495": "        long ns = millis * 1000 * 1000;\n",
        "496": "        for (;;) {\n",
        "497": "            if (millis > 0L)\n",
        "498": "                Thread.sleep(millis);\n",
        "499": "            else // too short to sleep\n",
        "500": "                Thread.yield();\n",
        "501": "            long d = ns - (System.nanoTime() - startTime);\n",
        "502": "            if (d > 0L)\n",
        "503": "                millis = d / (1000 * 1000);\n",
        "504": "            else\n",
        "505": "                break;\n",
        "506": "        }\n",
        "509": "    /**\n",
        "510": "     * Waits out termination of a thread pool or fails doing so.\n",
        "511": "     */\n",
        "512": "    void joinPool(ExecutorService exec) {\n",
        "513": "        try {\n",
        "514": "            exec.shutdown();\n",
        "515": "            assertTrue(\"ExecutorService did not terminate in a timely manner\",\n",
        "516": "                       exec.awaitTermination(2 * LONG_DELAY_MS, MILLISECONDS));\n",
        "517": "        } catch (SecurityException ok) {\n",
        "518": "            // Allowed in case test doesn't have privs\n",
        "519": "        } catch (InterruptedException ie) {\n",
        "520": "            fail(\"Unexpected InterruptedException\");\n",
        "521": "        }\n",
        "522": "    }\n",
        "524": "    /**\n",
        "525": "     * Checks that thread does not terminate within the default\n",
        "526": "     * millisecond delay of {@code timeoutMillis()}.\n",
        "527": "     */\n",
        "528": "    void assertThreadStaysAlive(Thread thread) {\n",
        "529": "        assertThreadStaysAlive(thread, timeoutMillis());\n",
        "532": "    /**\n",
        "533": "     * Checks that thread does not terminate within the given millisecond delay.\n",
        "534": "     */\n",
        "535": "    void assertThreadStaysAlive(Thread thread, long millis) {\n",
        "537": "            // No need to optimize the failing case via Thread.join.\n",
        "538": "            delay(millis);\n",
        "539": "            assertTrue(thread.isAlive());\n",
        "540": "        } catch (InterruptedException ie) {\n",
        "541": "            fail(\"Unexpected InterruptedException\");\n",
        "544": "\n",
        "545": "    /**\n",
        "546": "     * Checks that the threads do not terminate within the default\n",
        "547": "     * millisecond delay of {@code timeoutMillis()}.\n",
        "548": "     */\n",
        "549": "    void assertThreadsStayAlive(Thread... threads) {\n",
        "550": "        assertThreadsStayAlive(timeoutMillis(), threads);\n",
        "551": "    }\n",
        "552": "\n",
        "553": "    /**\n",
        "554": "     * Checks that the threads do not terminate within the given millisecond delay.\n",
        "555": "     */\n",
        "556": "    void assertThreadsStayAlive(long millis, Thread... threads) {\n",
        "558": "            // No need to optimize the failing case via Thread.join.\n",
        "559": "            delay(millis);\n",
        "560": "            for (Thread thread : threads)\n",
        "561": "                assertTrue(thread.isAlive());\n",
        "562": "        } catch (InterruptedException ie) {\n",
        "563": "            fail(\"Unexpected InterruptedException\");\n",
        "565": "    }\n",
        "567": "    /**\n",
        "568": "     * Checks that future.get times out, with the default timeout of\n",
        "569": "     * {@code timeoutMillis()}.\n",
        "570": "     */\n",
        "571": "    void assertFutureTimesOut(Future future) {\n",
        "572": "        assertFutureTimesOut(future, timeoutMillis());\n",
        "575": "    /**\n",
        "576": "     * Checks that future.get times out, with the given millisecond timeout.\n",
        "577": "     */\n",
        "578": "    void assertFutureTimesOut(Future future, long timeoutMillis) {\n",
        "579": "        long startTime = System.nanoTime();\n",
        "580": "        try {\n",
        "581": "            future.get(timeoutMillis, MILLISECONDS);\n",
        "582": "            shouldThrow();\n",
        "583": "        } catch (TimeoutException success) {\n",
        "584": "        } catch (Exception e) {\n",
        "585": "            threadUnexpectedException(e);\n",
        "586": "        } finally { future.cancel(true); }\n",
        "587": "        assertTrue(millisElapsedSince(startTime) >= timeoutMillis);\n",
        "590": "    /**\n",
        "591": "     * Fails with message \"should throw exception\".\n",
        "592": "     */\n",
        "593": "    public void shouldThrow() {\n",
        "594": "        fail(\"Should throw exception\");\n",
        "597": "    /**\n",
        "598": "     * Fails with message \"should throw \" + exceptionName.\n",
        "599": "     */\n",
        "600": "    public void shouldThrow(String exceptionName) {\n",
        "601": "        fail(\"Should throw \" + exceptionName);\n",
        "602": "    }\n",
        "603": "\n",
        "604": "    /**\n",
        "605": "     * The number of elements to place in collections, arrays, etc.\n",
        "606": "     */\n",
        "607": "    public static final int SIZE = 20;\n",
        "608": "\n",
        "609": "    // Some convenient Integer constants\n",
        "610": "\n",
        "611": "    public static final Integer zero  = new Integer(0);\n",
        "612": "    public static final Integer one   = new Integer(1);\n",
        "613": "    public static final Integer two   = new Integer(2);\n",
        "614": "    public static final Integer three = new Integer(3);\n",
        "615": "    public static final Integer four  = new Integer(4);\n",
        "616": "    public static final Integer five  = new Integer(5);\n",
        "617": "    public static final Integer six   = new Integer(6);\n",
        "618": "    public static final Integer seven = new Integer(7);\n",
        "619": "    public static final Integer eight = new Integer(8);\n",
        "620": "    public static final Integer nine  = new Integer(9);\n",
        "621": "    public static final Integer m1  = new Integer(-1);\n",
        "622": "    public static final Integer m2  = new Integer(-2);\n",
        "623": "    public static final Integer m3  = new Integer(-3);\n",
        "624": "    public static final Integer m4  = new Integer(-4);\n",
        "625": "    public static final Integer m5  = new Integer(-5);\n",
        "626": "    public static final Integer m6  = new Integer(-6);\n",
        "627": "    public static final Integer m10 = new Integer(-10);\n",
        "628": "\n",
        "629": "    /**\n",
        "630": "     * Runs Runnable r with a security policy that permits precisely\n",
        "631": "     * the specified permissions.  If there is no current security\n",
        "632": "     * manager, the runnable is run twice, both with and without a\n",
        "633": "     * security manager.  We require that any security manager permit\n",
        "634": "     * getPolicy/setPolicy.\n",
        "635": "     */\n",
        "636": "    public void runWithPermissions(Runnable r, Permission... permissions) {\n",
        "637": "        SecurityManager sm = System.getSecurityManager();\n",
        "638": "        if (sm == null) {\n",
        "639": "            r.run();\n",
        "640": "            Policy savedPolicy = Policy.getPolicy();\n",
        "641": "            try {\n",
        "642": "                Policy.setPolicy(permissivePolicy());\n",
        "643": "                System.setSecurityManager(new SecurityManager());\n",
        "644": "                runWithPermissions(r, permissions);\n",
        "645": "            } finally {\n",
        "646": "                System.setSecurityManager(null);\n",
        "647": "                Policy.setPolicy(savedPolicy);\n",
        "648": "            }\n",
        "649": "        } else {\n",
        "650": "            Policy savedPolicy = Policy.getPolicy();\n",
        "651": "            AdjustablePolicy policy = new AdjustablePolicy(permissions);\n",
        "652": "            Policy.setPolicy(policy);\n",
        "653": "\n",
        "654": "            try {\n",
        "655": "                r.run();\n",
        "656": "            } finally {\n",
        "657": "                policy.addPermission(new SecurityPermission(\"setPolicy\"));\n",
        "658": "                Policy.setPolicy(savedPolicy);\n",
        "659": "            }\n",
        "660": "        }\n",
        "661": "    }\n",
        "663": "    /**\n",
        "664": "     * Runs a runnable without any permissions.\n",
        "665": "     */\n",
        "666": "    public void runWithoutPermissions(Runnable r) {\n",
        "667": "        runWithPermissions(r);\n",
        "668": "    }\n",
        "670": "    /**\n",
        "671": "     * A security policy where new permissions can be dynamically added\n",
        "672": "     * or all cleared.\n",
        "673": "     */\n",
        "674": "    public static class AdjustablePolicy extends java.security.Policy {\n",
        "675": "        Permissions perms = new Permissions();\n",
        "676": "        AdjustablePolicy(Permission... permissions) {\n",
        "677": "            for (Permission permission : permissions)\n",
        "678": "                perms.add(permission);\n",
        "679": "        }\n",
        "680": "        void addPermission(Permission perm) { perms.add(perm); }\n",
        "681": "        void clearPermissions() { perms = new Permissions(); }\n",
        "682": "        public PermissionCollection getPermissions(CodeSource cs) {\n",
        "683": "            return perms;\n",
        "684": "        }\n",
        "685": "        public PermissionCollection getPermissions(ProtectionDomain pd) {\n",
        "686": "            return perms;\n",
        "687": "        }\n",
        "688": "        public boolean implies(ProtectionDomain pd, Permission p) {\n",
        "689": "            return perms.implies(p);\n",
        "690": "        }\n",
        "691": "        public void refresh() {}\n",
        "692": "    }\n",
        "694": "    /**\n",
        "695": "     * Returns a policy containing all the permissions we ever need.\n",
        "696": "     */\n",
        "697": "    public static Policy permissivePolicy() {\n",
        "698": "        return new AdjustablePolicy\n",
        "699": "            // Permissions j.u.c. needs directly\n",
        "700": "            (new RuntimePermission(\"modifyThread\"),\n",
        "701": "             new RuntimePermission(\"getClassLoader\"),\n",
        "702": "             new RuntimePermission(\"setContextClassLoader\"),\n",
        "703": "             // Permissions needed to change permissions!\n",
        "704": "             new SecurityPermission(\"getPolicy\"),\n",
        "705": "             new SecurityPermission(\"setPolicy\"),\n",
        "706": "             new RuntimePermission(\"setSecurityManager\"),\n",
        "707": "             // Permissions needed by the junit test harness\n",
        "708": "             new RuntimePermission(\"accessDeclaredMembers\"),\n",
        "709": "             new PropertyPermission(\"*\", \"read\"),\n",
        "710": "             new java.io.FilePermission(\"<<ALL FILES>>\", \"read\"));\n",
        "711": "    }\n",
        "712": "\n",
        "713": "    /**\n",
        "714": "     * Sleeps until the given time has elapsed.\n",
        "715": "     * Throws AssertionFailedError if interrupted.\n",
        "716": "     */\n",
        "717": "    void sleep(long millis) {\n",
        "718": "        try {\n",
        "719": "            delay(millis);\n",
        "720": "        } catch (InterruptedException ie) {\n",
        "721": "            AssertionFailedError afe =\n",
        "722": "                new AssertionFailedError(\"Unexpected InterruptedException\");\n",
        "723": "            afe.initCause(ie);\n",
        "724": "            throw afe;\n",
        "725": "        }\n",
        "726": "    }\n",
        "727": "\n",
        "728": "    /**\n",
        "729": "     * Spin-waits up to the specified number of milliseconds for the given\n",
        "730": "     * thread to enter a wait state: BLOCKED, WAITING, or TIMED_WAITING.\n",
        "731": "     */\n",
        "732": "    void waitForThreadToEnterWaitState(Thread thread, long timeoutMillis) {\n",
        "733": "        long startTime = System.nanoTime();\n",
        "734": "        for (;;) {\n",
        "735": "            Thread.State s = thread.getState();\n",
        "736": "            if (s == Thread.State.BLOCKED ||\n",
        "737": "                s == Thread.State.WAITING ||\n",
        "738": "                s == Thread.State.TIMED_WAITING)\n",
        "739": "                return;\n",
        "740": "            else if (s == Thread.State.TERMINATED)\n",
        "741": "                fail(\"Unexpected thread termination\");\n",
        "742": "            else if (millisElapsedSince(startTime) > timeoutMillis) {\n",
        "743": "                threadAssertTrue(thread.isAlive());\n",
        "744": "                return;\n",
        "745": "            }\n",
        "746": "            Thread.yield();\n",
        "747": "        }\n",
        "748": "    }\n",
        "749": "\n",
        "750": "    /**\n",
        "751": "     * Waits up to LONG_DELAY_MS for the given thread to enter a wait\n",
        "752": "     * state: BLOCKED, WAITING, or TIMED_WAITING.\n",
        "753": "     */\n",
        "754": "    void waitForThreadToEnterWaitState(Thread thread) {\n",
        "755": "        waitForThreadToEnterWaitState(thread, LONG_DELAY_MS);\n",
        "756": "    }\n",
        "757": "\n",
        "758": "    /**\n",
        "759": "     * Returns the number of milliseconds since time given by\n",
        "760": "     * startNanoTime, which must have been previously returned from a\n",
        "761": "     * call to {@link System.nanoTime()}.\n",
        "762": "     */\n",
        "763": "    long millisElapsedSince(long startNanoTime) {\n",
        "764": "        return NANOSECONDS.toMillis(System.nanoTime() - startNanoTime);\n",
        "765": "    }\n",
        "766": "\n",
        "767": "    /**\n",
        "768": "     * Returns a new started daemon Thread running the given runnable.\n",
        "769": "     */\n",
        "770": "    Thread newStartedThread(Runnable runnable) {\n",
        "771": "        Thread t = new Thread(runnable);\n",
        "772": "        t.setDaemon(true);\n",
        "773": "        t.start();\n",
        "774": "        return t;\n",
        "775": "    }\n",
        "776": "\n",
        "777": "    /**\n",
        "778": "     * Waits for the specified time (in milliseconds) for the thread\n",
        "779": "     * to terminate (using {@link Thread#join(long)}), else interrupts\n",
        "780": "     * the thread (in the hope that it may terminate later) and fails.\n",
        "781": "     */\n",
        "782": "    void awaitTermination(Thread t, long timeoutMillis) {\n",
        "784": "            t.join(timeoutMillis);\n",
        "785": "        } catch (InterruptedException ie) {\n",
        "786": "            threadUnexpectedException(ie);\n",
        "787": "        } finally {\n",
        "788": "            if (t.getState() != Thread.State.TERMINATED) {\n",
        "789": "                t.interrupt();\n",
        "790": "                fail(\"Test timed out\");\n",
        "791": "            }\n",
        "793": "    }\n",
        "794": "\n",
        "795": "    /**\n",
        "796": "     * Waits for LONG_DELAY_MS milliseconds for the thread to\n",
        "797": "     * terminate (using {@link Thread#join(long)}), else interrupts\n",
        "798": "     * the thread (in the hope that it may terminate later) and fails.\n",
        "799": "     */\n",
        "800": "    void awaitTermination(Thread t) {\n",
        "801": "        awaitTermination(t, LONG_DELAY_MS);\n",
        "802": "    }\n",
        "803": "\n",
        "804": "    // Some convenient Runnable classes\n",
        "805": "\n",
        "806": "    public abstract class CheckedRunnable implements Runnable {\n",
        "807": "        protected abstract void realRun() throws Throwable;\n",
        "808": "\n",
        "809": "        public final void run() {\n",
        "810": "            try {\n",
        "811": "                realRun();\n",
        "812": "            } catch (Throwable t) {\n",
        "813": "                threadUnexpectedException(t);\n",
        "814": "            }\n",
        "815": "        }\n",
        "816": "    }\n",
        "817": "\n",
        "818": "    public abstract class RunnableShouldThrow implements Runnable {\n",
        "819": "        protected abstract void realRun() throws Throwable;\n",
        "820": "\n",
        "821": "        final Class<?> exceptionClass;\n",
        "822": "\n",
        "823": "        <T extends Throwable> RunnableShouldThrow(Class<T> exceptionClass) {\n",
        "824": "            this.exceptionClass = exceptionClass;\n",
        "825": "        }\n",
        "826": "\n",
        "827": "        public final void run() {\n",
        "828": "            try {\n",
        "829": "                realRun();\n",
        "830": "                threadShouldThrow(exceptionClass.getSimpleName());\n",
        "831": "            } catch (Throwable t) {\n",
        "832": "                if (! exceptionClass.isInstance(t))\n",
        "833": "                    threadUnexpectedException(t);\n",
        "834": "            }\n",
        "835": "        }\n",
        "836": "    }\n",
        "837": "\n",
        "838": "    public abstract class ThreadShouldThrow extends Thread {\n",
        "839": "        protected abstract void realRun() throws Throwable;\n",
        "840": "\n",
        "841": "        final Class<?> exceptionClass;\n",
        "842": "\n",
        "843": "        <T extends Throwable> ThreadShouldThrow(Class<T> exceptionClass) {\n",
        "844": "            this.exceptionClass = exceptionClass;\n",
        "845": "        }\n",
        "846": "\n",
        "847": "        public final void run() {\n",
        "848": "            try {\n",
        "849": "                realRun();\n",
        "850": "                threadShouldThrow(exceptionClass.getSimpleName());\n",
        "851": "            } catch (Throwable t) {\n",
        "852": "                if (! exceptionClass.isInstance(t))\n",
        "853": "                    threadUnexpectedException(t);\n",
        "854": "            }\n",
        "855": "        }\n",
        "856": "    }\n",
        "857": "\n",
        "858": "    public abstract class CheckedInterruptedRunnable implements Runnable {\n",
        "859": "        protected abstract void realRun() throws Throwable;\n",
        "860": "\n",
        "861": "        public final void run() {\n",
        "862": "            try {\n",
        "863": "                realRun();\n",
        "864": "                threadShouldThrow(\"InterruptedException\");\n",
        "865": "            } catch (InterruptedException success) {\n",
        "866": "                threadAssertFalse(Thread.interrupted());\n",
        "867": "            } catch (Throwable t) {\n",
        "868": "                threadUnexpectedException(t);\n",
        "869": "            }\n",
        "870": "        }\n",
        "871": "    }\n",
        "872": "\n",
        "873": "    public abstract class CheckedCallable<T> implements Callable<T> {\n",
        "874": "        protected abstract T realCall() throws Throwable;\n",
        "875": "\n",
        "876": "        public final T call() {\n",
        "877": "            try {\n",
        "878": "                return realCall();\n",
        "879": "            } catch (Throwable t) {\n",
        "880": "                threadUnexpectedException(t);\n",
        "881": "                return null;\n",
        "882": "            }\n",
        "883": "        }\n",
        "884": "    }\n",
        "885": "\n",
        "886": "    public abstract class CheckedInterruptedCallable<T>\n",
        "887": "        implements Callable<T> {\n",
        "888": "        protected abstract T realCall() throws Throwable;\n",
        "889": "\n",
        "890": "        public final T call() {\n",
        "891": "            try {\n",
        "892": "                T result = realCall();\n",
        "893": "                threadShouldThrow(\"InterruptedException\");\n",
        "894": "                return result;\n",
        "895": "            } catch (InterruptedException success) {\n",
        "896": "                threadAssertFalse(Thread.interrupted());\n",
        "897": "            } catch (Throwable t) {\n",
        "898": "                threadUnexpectedException(t);\n",
        "899": "            }\n",
        "900": "            return null;\n",
        "901": "        }\n",
        "902": "    }\n",
        "903": "\n",
        "904": "    public static class NoOpRunnable implements Runnable {\n",
        "905": "        public void run() {}\n",
        "906": "    }\n",
        "907": "\n",
        "908": "    public static class NoOpCallable implements Callable {\n",
        "909": "        public Object call() { return Boolean.TRUE; }\n",
        "910": "    }\n",
        "911": "\n",
        "912": "    public static final String TEST_STRING = \"a test string\";\n",
        "913": "\n",
        "914": "    public static class StringTask implements Callable<String> {\n",
        "915": "        public String call() { return TEST_STRING; }\n",
        "916": "    }\n",
        "917": "\n",
        "918": "    public Callable<String> latchAwaitingStringTask(final CountDownLatch latch) {\n",
        "919": "        return new CheckedCallable<String>() {\n",
        "920": "            protected String realCall() {\n",
        "921": "                try {\n",
        "922": "                    latch.await();\n",
        "923": "                } catch (InterruptedException quittingTime) {}\n",
        "924": "                return TEST_STRING;\n",
        "925": "            }};\n",
        "926": "    }\n",
        "927": "\n",
        "928": "    public Runnable awaiter(final CountDownLatch latch) {\n",
        "929": "        return new CheckedRunnable() {\n",
        "930": "            public void realRun() throws InterruptedException {\n",
        "931": "                await(latch);\n",
        "932": "            }};\n",
        "933": "    }\n",
        "934": "\n",
        "935": "    public void await(CountDownLatch latch) {\n",
        "936": "        try {\n",
        "937": "            assertTrue(latch.await(LONG_DELAY_MS, MILLISECONDS));\n",
        "938": "        } catch (Throwable t) {\n",
        "939": "            threadUnexpectedException(t);\n",
        "940": "        }\n",
        "941": "    }\n",
        "942": "\n",
        "943": "    public void await(Semaphore semaphore) {\n",
        "944": "        try {\n",
        "945": "            assertTrue(semaphore.tryAcquire(LONG_DELAY_MS, MILLISECONDS));\n",
        "946": "        } catch (Throwable t) {\n",
        "947": "            threadUnexpectedException(t);\n",
        "948": "        }\n",
        "949": "    }\n",
        "950": "\n",
        "951": "//     /**\n",
        "952": "//      * Spin-waits up to LONG_DELAY_MS until flag becomes true.\n",
        "953": "//      */\n",
        "954": "//     public void await(AtomicBoolean flag) {\n",
        "955": "//         await(flag, LONG_DELAY_MS);\n",
        "956": "//     }\n",
        "957": "\n",
        "958": "//     /**\n",
        "959": "//      * Spin-waits up to the specified timeout until flag becomes true.\n",
        "960": "//      */\n",
        "961": "//     public void await(AtomicBoolean flag, long timeoutMillis) {\n",
        "962": "//         long startTime = System.nanoTime();\n",
        "963": "//         while (!flag.get()) {\n",
        "964": "//             if (millisElapsedSince(startTime) > timeoutMillis)\n",
        "965": "//                 throw new AssertionFailedError(\"timed out\");\n",
        "966": "//             Thread.yield();\n",
        "967": "//         }\n",
        "968": "//     }\n",
        "969": "\n",
        "970": "    public static class NPETask implements Callable<String> {\n",
        "971": "        public String call() { throw new NullPointerException(); }\n",
        "972": "    }\n",
        "973": "\n",
        "974": "    public static class CallableOne implements Callable<Integer> {\n",
        "975": "        public Integer call() { return one; }\n",
        "976": "    }\n",
        "977": "\n",
        "978": "    public class ShortRunnable extends CheckedRunnable {\n",
        "979": "        protected void realRun() throws Throwable {\n",
        "980": "            delay(SHORT_DELAY_MS);\n",
        "981": "        }\n",
        "982": "    }\n",
        "983": "\n",
        "984": "    public class ShortInterruptedRunnable extends CheckedInterruptedRunnable {\n",
        "985": "        protected void realRun() throws InterruptedException {\n",
        "986": "            delay(SHORT_DELAY_MS);\n",
        "987": "        }\n",
        "988": "    }\n",
        "989": "\n",
        "990": "    public class SmallRunnable extends CheckedRunnable {\n",
        "991": "        protected void realRun() throws Throwable {\n",
        "992": "            delay(SMALL_DELAY_MS);\n",
        "993": "        }\n",
        "994": "    }\n",
        "995": "\n",
        "996": "    public class SmallPossiblyInterruptedRunnable extends CheckedRunnable {\n",
        "997": "        protected void realRun() {\n",
        "998": "            try {\n",
        "999": "                delay(SMALL_DELAY_MS);\n",
        "1000": "            } catch (InterruptedException ok) {}\n",
        "1001": "        }\n",
        "1002": "    }\n",
        "1003": "\n",
        "1004": "    public class SmallCallable extends CheckedCallable {\n",
        "1005": "        protected Object realCall() throws InterruptedException {\n",
        "1006": "            delay(SMALL_DELAY_MS);\n",
        "1007": "            return Boolean.TRUE;\n",
        "1008": "        }\n",
        "1009": "    }\n",
        "1010": "\n",
        "1011": "    public class MediumRunnable extends CheckedRunnable {\n",
        "1012": "        protected void realRun() throws Throwable {\n",
        "1013": "            delay(MEDIUM_DELAY_MS);\n",
        "1014": "        }\n",
        "1015": "    }\n",
        "1016": "\n",
        "1017": "    public class MediumInterruptedRunnable extends CheckedInterruptedRunnable {\n",
        "1018": "        protected void realRun() throws InterruptedException {\n",
        "1019": "            delay(MEDIUM_DELAY_MS);\n",
        "1020": "        }\n",
        "1021": "    }\n",
        "1022": "\n",
        "1023": "    public Runnable possiblyInterruptedRunnable(final long timeoutMillis) {\n",
        "1024": "        return new CheckedRunnable() {\n",
        "1025": "            protected void realRun() {\n",
        "1026": "                try {\n",
        "1027": "                    delay(timeoutMillis);\n",
        "1028": "                } catch (InterruptedException ok) {}\n",
        "1029": "            }};\n",
        "1030": "    }\n",
        "1031": "\n",
        "1032": "    public class MediumPossiblyInterruptedRunnable extends CheckedRunnable {\n",
        "1033": "        protected void realRun() {\n",
        "1034": "            try {\n",
        "1035": "                delay(MEDIUM_DELAY_MS);\n",
        "1036": "            } catch (InterruptedException ok) {}\n",
        "1037": "        }\n",
        "1038": "    }\n",
        "1039": "\n",
        "1040": "    public class LongPossiblyInterruptedRunnable extends CheckedRunnable {\n",
        "1041": "        protected void realRun() {\n",
        "1042": "            try {\n",
        "1043": "                delay(LONG_DELAY_MS);\n",
        "1044": "            } catch (InterruptedException ok) {}\n",
        "1045": "        }\n",
        "1046": "    }\n",
        "1047": "\n",
        "1048": "    /**\n",
        "1049": "     * For use as ThreadFactory in constructors\n",
        "1050": "     */\n",
        "1051": "    public static class SimpleThreadFactory implements ThreadFactory {\n",
        "1052": "        public Thread newThread(Runnable r) {\n",
        "1053": "            return new Thread(r);\n",
        "1054": "        }\n",
        "1055": "    }\n",
        "1056": "\n",
        "1057": "    public interface TrackedRunnable extends Runnable {\n",
        "1058": "        boolean isDone();\n",
        "1059": "    }\n",
        "1060": "\n",
        "1061": "    public static TrackedRunnable trackedRunnable(final long timeoutMillis) {\n",
        "1062": "        return new TrackedRunnable() {\n",
        "1063": "                private volatile boolean done = false;\n",
        "1064": "                public boolean isDone() { return done; }\n",
        "1065": "                public void run() {\n",
        "1066": "                    try {\n",
        "1067": "                        delay(timeoutMillis);\n",
        "1068": "                        done = true;\n",
        "1069": "                    } catch (InterruptedException ok) {}\n",
        "1070": "                }\n",
        "1071": "            };\n",
        "1072": "    }\n",
        "1073": "\n",
        "1074": "    public static class TrackedShortRunnable implements Runnable {\n",
        "1075": "        public volatile boolean done = false;\n",
        "1076": "        public void run() {\n",
        "1077": "            try {\n",
        "1078": "                delay(SHORT_DELAY_MS);\n",
        "1079": "                done = true;\n",
        "1080": "            } catch (InterruptedException ok) {}\n",
        "1081": "        }\n",
        "1082": "    }\n",
        "1083": "\n",
        "1084": "    public static class TrackedSmallRunnable implements Runnable {\n",
        "1085": "        public volatile boolean done = false;\n",
        "1086": "        public void run() {\n",
        "1087": "            try {\n",
        "1088": "                delay(SMALL_DELAY_MS);\n",
        "1089": "                done = true;\n",
        "1090": "            } catch (InterruptedException ok) {}\n",
        "1091": "        }\n",
        "1092": "    }\n",
        "1093": "\n",
        "1094": "    public static class TrackedMediumRunnable implements Runnable {\n",
        "1095": "        public volatile boolean done = false;\n",
        "1096": "        public void run() {\n",
        "1097": "            try {\n",
        "1098": "                delay(MEDIUM_DELAY_MS);\n",
        "1099": "                done = true;\n",
        "1100": "            } catch (InterruptedException ok) {}\n",
        "1101": "        }\n",
        "1102": "    }\n",
        "1103": "\n",
        "1104": "    public static class TrackedLongRunnable implements Runnable {\n",
        "1105": "        public volatile boolean done = false;\n",
        "1106": "        public void run() {\n",
        "1107": "            try {\n",
        "1108": "                delay(LONG_DELAY_MS);\n",
        "1109": "                done = true;\n",
        "1110": "            } catch (InterruptedException ok) {}\n",
        "1111": "        }\n",
        "1112": "    }\n",
        "1113": "\n",
        "1114": "    public static class TrackedNoOpRunnable implements Runnable {\n",
        "1115": "        public volatile boolean done = false;\n",
        "1116": "        public void run() {\n",
        "1117": "            done = true;\n",
        "1118": "        }\n",
        "1119": "    }\n",
        "1120": "\n",
        "1121": "    public static class TrackedCallable implements Callable {\n",
        "1122": "        public volatile boolean done = false;\n",
        "1123": "        public Object call() {\n",
        "1124": "            try {\n",
        "1125": "                delay(SMALL_DELAY_MS);\n",
        "1126": "                done = true;\n",
        "1127": "            } catch (InterruptedException ok) {}\n",
        "1128": "            return Boolean.TRUE;\n",
        "1129": "        }\n",
        "1130": "    }\n",
        "1131": "\n",
        "1132": "//     /**\n",
        "1133": "//      * Analog of CheckedRunnable for RecursiveAction\n",
        "1134": "//      */\n",
        "1135": "//     public abstract class CheckedRecursiveAction extends RecursiveAction {\n",
        "1136": "//         protected abstract void realCompute() throws Throwable;\n",
        "1137": "\n",
        "1138": "//         public final void compute() {\n",
        "1139": "//             try {\n",
        "1140": "//                 realCompute();\n",
        "1141": "//             } catch (Throwable t) {\n",
        "1142": "//                 threadUnexpectedException(t);\n",
        "1143": "//             }\n",
        "1144": "//         }\n",
        "1145": "//     }\n",
        "1146": "\n",
        "1147": "//     /**\n",
        "1148": "//      * Analog of CheckedCallable for RecursiveTask\n",
        "1149": "//      */\n",
        "1150": "//     public abstract class CheckedRecursiveTask<T> extends RecursiveTask<T> {\n",
        "1151": "//         protected abstract T realCompute() throws Throwable;\n",
        "1152": "\n",
        "1153": "//         public final T compute() {\n",
        "1154": "//             try {\n",
        "1155": "//                 return realCompute();\n",
        "1156": "//             } catch (Throwable t) {\n",
        "1157": "//                 threadUnexpectedException(t);\n",
        "1158": "//                 return null;\n",
        "1159": "//             }\n",
        "1160": "//         }\n",
        "1161": "//     }\n",
        "1162": "\n",
        "1163": "    /**\n",
        "1164": "     * For use as RejectedExecutionHandler in constructors\n",
        "1165": "     */\n",
        "1166": "    public static class NoOpREHandler implements RejectedExecutionHandler {\n",
        "1167": "        public void rejectedExecution(Runnable r,\n",
        "1168": "                                      ThreadPoolExecutor executor) {}\n",
        "1169": "    }\n",
        "1170": "\n",
        "1171": "    /**\n",
        "1172": "     * A CyclicBarrier that uses timed await and fails with\n",
        "1173": "     * AssertionFailedErrors instead of throwing checked exceptions.\n",
        "1174": "     */\n",
        "1175": "    public class CheckedBarrier extends CyclicBarrier {\n",
        "1176": "        public CheckedBarrier(int parties) { super(parties); }\n",
        "1177": "\n",
        "1178": "        public int await() {\n",
        "1179": "            try {\n",
        "1180": "                return super.await(2 * LONG_DELAY_MS, MILLISECONDS);\n",
        "1181": "            } catch (TimeoutException e) {\n",
        "1182": "                throw new AssertionFailedError(\"timed out\");\n",
        "1183": "            } catch (Exception e) {\n",
        "1184": "                AssertionFailedError afe =\n",
        "1185": "                    new AssertionFailedError(\"Unexpected exception: \" + e);\n",
        "1186": "                afe.initCause(e);\n",
        "1187": "                throw afe;\n",
        "1188": "            }\n",
        "1189": "        }\n",
        "1190": "    }\n",
        "1191": "\n",
        "1192": "    void checkEmpty(BlockingQueue q) {\n",
        "1193": "        try {\n",
        "1194": "            assertTrue(q.isEmpty());\n",
        "1195": "            assertEquals(0, q.size());\n",
        "1196": "            assertNull(q.peek());\n",
        "1197": "            assertNull(q.poll());\n",
        "1198": "            assertNull(q.poll(0, MILLISECONDS));\n",
        "1200": "            assertTrue(Arrays.equals(q.toArray(), new Object[0]));\n",
        "1201": "            assertFalse(q.iterator().hasNext());\n",
        "1202": "            try {\n",
        "1203": "                q.element();\n",
        "1204": "                shouldThrow();\n",
        "1205": "            } catch (NoSuchElementException success) {}\n",
        "1206": "            try {\n",
        "1207": "                q.iterator().next();\n",
        "1208": "                shouldThrow();\n",
        "1209": "            } catch (NoSuchElementException success) {}\n",
        "1210": "            try {\n",
        "1211": "                q.remove();\n",
        "1212": "                shouldThrow();\n",
        "1213": "            } catch (NoSuchElementException success) {}\n",
        "1214": "        } catch (InterruptedException ie) {\n",
        "1215": "            threadUnexpectedException(ie);\n",
        "1216": "        }\n",
        "1217": "    }\n",
        "1218": "\n",
        "1219": "    @SuppressWarnings(\"unchecked\")\n",
        "1220": "    <T> T serialClone(T o) {\n",
        "1221": "        try {\n",
        "1222": "            ByteArrayOutputStream bos = new ByteArrayOutputStream();\n",
        "1223": "            ObjectOutputStream oos = new ObjectOutputStream(bos);\n",
        "1224": "            oos.writeObject(o);\n",
        "1225": "            oos.flush();\n",
        "1226": "            oos.close();\n",
        "1227": "            ObjectInputStream ois = new ObjectInputStream\n",
        "1228": "                (new ByteArrayInputStream(bos.toByteArray()));\n",
        "1229": "            T clone = (T) ois.readObject();\n",
        "1230": "            assertSame(o.getClass(), clone.getClass());\n",
        "1231": "            return clone;\n",
        "1232": "        } catch (Throwable t) {\n",
        "1233": "            threadUnexpectedException(t);\n",
        "1234": "            return null;\n",
        "1235": "        }\n",
        "1236": "    }\n"
    }
}