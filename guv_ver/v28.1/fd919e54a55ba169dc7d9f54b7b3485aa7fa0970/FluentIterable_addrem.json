{
    "addition": {
        "43": " *   <li>chaining methods which return a new {@code FluentIterable} based in some way on the\n",
        "44": " *       contents of the current one (for example {@link #transform})\n",
        "45": " *   <li>element extraction methods which facilitate the retrieval of certain elements (for example\n",
        "46": " *       {@link #last})\n",
        "47": " *   <li>query methods which answer questions about the {@code FluentIterable}'s contents (for\n",
        "48": " *       example {@link #anyMatch})\n",
        "49": " *   <li>conversion methods which copy the {@code FluentIterable}'s contents into a new collection\n",
        "50": " *       or array (for example {@link #toList})\n",
        "56": " * <p><a name=\"streams\"></a>\n",
        "57": " *\n",
        "65": " *   <li>A stream is <i>single-use</i>; it becomes invalid as soon as any \"terminal operation\" such\n",
        "66": " *       as {@code findFirst()} or {@code iterator()} is invoked. (Even though {@code Stream}\n",
        "67": " *       contains all the right method <i>signatures</i> to implement {@link Iterable}, it does not\n",
        "68": " *       actually do so, to avoid implying repeat-iterability.) {@code FluentIterable}, on the other\n",
        "69": " *       hand, is multiple-use, and does implement {@link Iterable}.\n",
        "70": " *   <li>Streams offer many features not found here, including {@code min/max}, {@code distinct},\n",
        "71": " *       {@code reduce}, {@code sorted}, the very powerful {@code collect}, and built-in support for\n",
        "72": " *       parallelizing stream operations.\n",
        "73": " *   <li>{@code FluentIterable} contains several features not available on {@code Stream}, which are\n",
        "74": " *       noted in the method descriptions below.\n",
        "75": " *   <li>Streams include primitive-specialized variants such as {@code IntStream}, the use of which\n",
        "76": " *       is strongly recommended.\n",
        "77": " *   <li>Streams are standard Java, not requiring a third-party dependency (but do render your code\n",
        "78": " *       incompatible with Java 7 and earlier).\n",
        "138": "   * <p><b>{@code Stream} equivalent:</b> {@code iterable.stream()} if {@code iterable} is a {@link\n",
        "139": "   * Collection}; {@code StreamSupport.stream(iterable.spliterator(), false)} otherwise.\n",
        "169": "   * but is intended to help call out cases where one migration from {@code Iterable} to {@code\n",
        "170": "   * FluentIterable} has obviated the need to explicitly convert to a {@code FluentIterable}.\n",
        "172": "   * @deprecated instances of {@code FluentIterable} don't need to be converted to {@code\n",
        "173": "   *     FluentIterable}\n",
        "353": "   * Returns {@code true} if this fluent iterable contains any object for which {@code\n",
        "354": "   * equals(target)} is true.\n",
        "366": "   * <p>That iterator supports {@code remove()} if {@code iterable.iterator()} does. After {@code\n",
        "367": "   * remove()} is called, subsequent cycles omit the removed element, which is no longer in this\n",
        "368": "   * fluent iterable. The iterator's {@code hasNext()} method returns {@code true} until this fluent\n",
        "369": "   * iterable is empty.\n",
        "521": "   * iterable is empty, {@code Optional.absent()} is returned. If the underlying {@code iterable} is\n",
        "522": "   * a {@link List} with {@link java.util.RandomAccess} support, then this operation is guaranteed\n",
        "523": "   * to be {@code O(1)}.\n",
        "527": "   * @throws NullPointerException if the last element is null; if this is a possibility, use {@link\n",
        "528": "   *     Iterables#getLast} instead.\n",
        "772": "   * <p><b>{@code Stream} equivalent:</b> if an object array is acceptable, use {@code\n",
        "773": "   * stream.toArray()}; if {@code type} is a class literal such as {@code MyType.class}, use {@code\n",
        "774": "   * stream.toArray(MyType[]::new)}. Otherwise use {@code stream.toArray( len -> (E[])\n",
        "775": "   * Array.newInstance(type, len))}.\n",
        "790": "   * <p><b>{@code Stream} equivalent:</b> {@code stream.forEachOrdered(collection::add)} or {@code\n",
        "791": "   * stream.forEach(collection::add)}.\n",
        "816": "   * using any optional {@code Joiner} features, {@code\n",
        "817": "   * stream.collect(Collectors.joining(delimiter)}.\n",
        "843": "  /** Function that transforms {@code Iterable<E>} into a fluent iterable. */\n"
    },
    "removed": {
        "43": " * <li>chaining methods which return a new {@code FluentIterable} based in some way on the contents\n",
        "44": " *     of the current one (for example {@link #transform})\n",
        "45": " * <li>element extraction methods which facilitate the retrieval of certain elements (for example\n",
        "46": " *     {@link #last})\n",
        "47": " * <li>query methods which answer questions about the {@code FluentIterable}'s contents (for example\n",
        "48": " *     {@link #anyMatch})\n",
        "49": " * <li>conversion methods which copy the {@code FluentIterable}'s contents into a new collection or\n",
        "50": " *     array (for example {@link #toList})\n",
        "56": " * <a name=\"streams\"></a>\n",
        "64": " * <li>A stream is <i>single-use</i>; it becomes invalid as soon as any \"terminal operation\" such as\n",
        "65": " *     {@code findFirst()} or {@code iterator()} is invoked. (Even though {@code Stream} contains\n",
        "66": " *     all the right method <i>signatures</i> to implement {@link Iterable}, it does not actually do\n",
        "67": " *     so, to avoid implying repeat-iterability.) {@code FluentIterable}, on the other hand, is\n",
        "68": " *     multiple-use, and does implement {@link Iterable}.\n",
        "69": " * <li>Streams offer many features not found here, including {@code min/max}, {@code distinct},\n",
        "70": " *     {@code reduce}, {@code sorted}, the very powerful {@code collect}, and built-in support for\n",
        "71": " *     parallelizing stream operations.\n",
        "72": " * <li>{@code FluentIterable} contains several features not available on {@code Stream}, which are\n",
        "73": " *     noted in the method descriptions below.\n",
        "74": " * <li>Streams include primitive-specialized variants such as {@code IntStream}, the use of which is\n",
        "75": " *     strongly recommended.\n",
        "76": " * <li>Streams are standard Java, not requiring a third-party dependency (but do render your code\n",
        "77": " *     incompatible with Java 7 and earlier).\n",
        "137": "   * <p><b>{@code Stream} equivalent:</b> {@code iterable.stream()} if {@code iterable} is a\n",
        "138": "   * {@link Collection}; {@code StreamSupport.stream(iterable.spliterator(), false)} otherwise.\n",
        "168": "   * but is intended to help call out cases where one migration from {@code Iterable} to\n",
        "169": "   * {@code FluentIterable} has obviated the need to explicitly convert to a {@code FluentIterable}.\n",
        "171": "   * @deprecated instances of {@code FluentIterable} don't need to be converted to\n",
        "172": "   *     {@code FluentIterable}\n",
        "352": "   * Returns {@code true} if this fluent iterable contains any object for which\n",
        "353": "   * {@code equals(target)} is true.\n",
        "365": "   * <p>That iterator supports {@code remove()} if {@code iterable.iterator()} does. After\n",
        "366": "   * {@code remove()} is called, subsequent cycles omit the removed element, which is no longer in\n",
        "367": "   * this fluent iterable. The iterator's {@code hasNext()} method returns {@code true} until this\n",
        "368": "   * fluent iterable is empty.\n",
        "520": "   * iterable is empty, {@code Optional.absent()} is returned. If the underlying {@code iterable}\n",
        "521": "   * is a {@link List} with {@link java.util.RandomAccess} support, then this operation is\n",
        "522": "   * guaranteed to be {@code O(1)}.\n",
        "526": "   * @throws NullPointerException if the last element is null; if this is a possibility, use\n",
        "527": "   *     {@link Iterables#getLast} instead.\n",
        "771": "   * <p><b>{@code Stream} equivalent:</b> if an object array is acceptable, use\n",
        "772": "   * {@code stream.toArray()}; if {@code type} is a class literal such as {@code MyType.class}, use\n",
        "773": "   * {@code stream.toArray(MyType[]::new)}. Otherwise use {@code stream.toArray(\n",
        "774": "   * len -> (E[]) Array.newInstance(type, len))}.\n",
        "789": "   * <p><b>{@code Stream} equivalent:</b> {@code stream.forEachOrdered(collection::add)} or\n",
        "790": "   * {@code stream.forEach(collection::add)}.\n",
        "815": "   * using any optional {@code Joiner} features,\n",
        "816": "   * {@code stream.collect(Collectors.joining(delimiter)}.\n",
        "842": "  /**\n",
        "843": "   * Function that transforms {@code Iterable<E>} into a fluent iterable.\n",
        "844": "   */\n"
    }
}