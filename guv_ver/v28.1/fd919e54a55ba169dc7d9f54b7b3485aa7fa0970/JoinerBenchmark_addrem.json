{
    "addition": {
        "26": " * Benchmarks {@link Joiner} against some common implementations of delimiter-based string joining.\n",
        "38": "  @Param({\"3\", \"30\", \"300\"})\n",
        "39": "  int count;\n",
        "40": "\n",
        "41": "  @Param({\"0\", \"1\", \"16\", \"32\", \"100\"})\n",
        "42": "  int componentLength;\n",
        "54": "  /** {@link Joiner} with a string delimiter. */\n",
        "55": "  @Benchmark\n",
        "56": "  int joinerWithStringDelimiter(int reps) {\n",
        "64": "  /** {@link Joiner} with a character delimiter. */\n",
        "65": "  @Benchmark\n",
        "66": "  int joinerWithCharacterDelimiter(int reps) {\n",
        "75": "   * Mimics what the {@link Joiner} class does internally when no extra options like ignoring {@code\n",
        "76": "   * null} values are used.\n",
        "78": "  @Benchmark\n",
        "79": "  int joinerInlined(int reps) {\n",
        "97": "   * Only appends delimiter if the accumulated string is non-empty. Note: this isn't a candidate\n",
        "98": "   * implementation for Joiner since it fails on leading empty components.\n",
        "100": "  @Benchmark\n",
        "101": "  int stringBuilderIsEmpty(int reps) {\n",
        "117": "   * Similar to the above, but keeps a boolean flag rather than checking for the string accumulated\n",
        "118": "   * so far being empty. As a result, it does not have the above-mentioned bug.\n",
        "120": "  @Benchmark\n",
        "121": "  int booleanIfFirst(int reps) {\n",
        "139": "   * Starts with an empty delimiter and changes to the desired value at the end of the iteration.\n",
        "141": "  @Benchmark\n",
        "142": "  int assignDelimiter(int reps) {\n",
        "158": "   * Always append the delimiter after the component, and in the very end shortens the buffer to get\n",
        "159": "   * rid of the extra trailing delimiter.\n",
        "161": "  @Benchmark\n",
        "162": "  int alwaysAppendThenBackUp(int reps) {\n"
    },
    "removed": {
        "26": " * Benchmarks {@link Joiner} against some common implementations of delimiter-based\n",
        "27": " * string joining.\n",
        "39": "  @Param({\"3\", \"30\", \"300\"}) int count;\n",
        "40": "  @Param({\"0\", \"1\", \"16\", \"32\", \"100\"}) int componentLength;\n",
        "52": "  /**\n",
        "53": "   * {@link Joiner} with a string delimiter.\n",
        "54": "   */\n",
        "55": "  @Benchmark int joinerWithStringDelimiter(int reps) {\n",
        "63": "  /**\n",
        "64": "   * {@link Joiner} with a character delimiter.\n",
        "65": "   */\n",
        "66": "  @Benchmark int joinerWithCharacterDelimiter(int reps) {\n",
        "75": "   * Mimics what the {@link Joiner} class does internally when no extra options like\n",
        "76": "   * ignoring {@code null} values are used.\n",
        "78": "  @Benchmark int joinerInlined(int reps) {\n",
        "96": "   * Only appends delimiter if the accumulated string is non-empty.\n",
        "97": "   * Note: this isn't a candidate implementation for Joiner since it fails on leading\n",
        "98": "   * empty components.\n",
        "100": "  @Benchmark int stringBuilderIsEmpty(int reps) {\n",
        "116": "   * Similar to the above, but keeps a boolean flag rather than checking for the string\n",
        "117": "   * accumulated so far being empty. As a result, it does not have the above-mentioned bug.\n",
        "119": "  @Benchmark int booleanIfFirst(int reps) {\n",
        "137": "   * Starts with an empty delimiter and changes to the desired value at the end of the\n",
        "138": "   * iteration.\n",
        "140": "  @Benchmark int assignDelimiter(int reps) {\n",
        "156": "   * Always append the delimiter after the component, and in the very end shortens the buffer\n",
        "157": "   * to get rid of the extra trailing delimiter.\n",
        "159": "  @Benchmark int alwaysAppendThenBackUp(int reps) {\n"
    }
}