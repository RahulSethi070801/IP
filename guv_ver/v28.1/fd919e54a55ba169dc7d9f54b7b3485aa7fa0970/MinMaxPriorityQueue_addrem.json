{
    "addition": {
        "46": " * A double-ended priority queue, which provides constant-time access to both its least element and\n",
        "47": " * its greatest element, as determined by the queue's specified comparator. If no comparator is\n",
        "48": " * given at creation time, the natural order of elements is used. If no maximum size is given at\n",
        "49": " * creation time, the queue is unbounded.\n",
        "51": " * <p>Usage example:\n",
        "53": " * <pre>{@code\n",
        "54": " * MinMaxPriorityQueue<User> users = MinMaxPriorityQueue.orderedBy(userComparator)\n",
        "55": " *     .maximumSize(1000)\n",
        "56": " *     .create();\n",
        "57": " * }</pre>\n",
        "59": " * <p>As a {@link Queue} it functions exactly as a {@link PriorityQueue}: its head element -- the\n",
        "60": " * implicit target of the methods {@link #peek()}, {@link #poll()} and {@link #remove()} -- is\n",
        "61": " * defined as the <i>least</i> element in the queue according to the queue's comparator. But unlike\n",
        "62": " * a regular priority queue, the methods {@link #peekLast}, {@link #pollLast} and {@link\n",
        "63": " * #removeLast} are also provided, to act on the <i>greatest</i> element in the queue instead.\n",
        "65": " * <p>A min-max priority queue can be configured with a maximum size. If so, each time the size of\n",
        "66": " * the queue exceeds that value, the queue automatically removes its greatest element according to\n",
        "67": " * its comparator (which might be the element that was just added). This is different from\n",
        "68": " * conventional bounded queues, which either block or reject new elements when full.\n",
        "70": " * <p>This implementation is based on the <a\n",
        "71": " * href=\"http://portal.acm.org/citation.cfm?id=6621\">min-max heap</a> developed by Atkinson, et al.\n",
        "72": " * Unlike many other double-ended priority queues, it stores elements in a single array, as compact\n",
        "73": " * as the traditional heap data structure used in {@link PriorityQueue}.\n",
        "80": " *   <li>If you only access one end of the queue, and do use a maximum size, this class will perform\n",
        "81": " *       significantly worse than a {@code PriorityQueue} with manual eviction above the maximum\n",
        "82": " *       size. In many cases {@link Ordering#leastOf} may work for your use case with significantly\n",
        "83": " *       improved (and asymptotically superior) performance.\n",
        "84": " *   <li>The retrieval operations {@link #peek}, {@link #peekFirst}, {@link #peekLast}, {@link\n",
        "85": " *       #element}, and {@link #size} are constant-time.\n",
        "86": " *   <li>The enqueuing and dequeuing operations ({@link #offer}, {@link #add}, and all the forms of\n",
        "87": " *       {@link #poll} and {@link #remove()}) run in {@code O(log n) time}.\n",
        "88": " *   <li>The {@link #remove(Object)} and {@link #contains} operations require linear ({@code O(n)})\n",
        "89": " *       time.\n",
        "90": " *   <li>If you only access one end of the queue, and don't use a maximum size, this class is\n",
        "91": " *       functionally equivalent to {@link PriorityQueue}, but significantly slower.\n",
        "103": "   * Creates a new min-max priority queue with default settings: natural order, no maximum size, no\n",
        "104": "   * initial contents, and an initial expected size of 11.\n",
        "111": "   * Creates a new min-max priority queue using natural order, no maximum size, and initially\n",
        "112": "   * containing the given elements.\n",
        "120": "   * Creates and returns a new builder, configured to build {@code MinMaxPriorityQueue} instances\n",
        "121": "   * that use {@code comparator} to determine the least and greatest elements.\n",
        "128": "   * Creates and returns a new builder, configured to build {@code MinMaxPriorityQueue} instances\n",
        "129": "   * sized appropriately to hold {@code expectedSize} elements.\n",
        "136": "   * Creates and returns a new builder, configured to build {@code MinMaxPriorityQueue} instances\n",
        "137": "   * that are limited to {@code maximumSize} elements. Each time a queue grows beyond this bound, it\n",
        "138": "   * immediately removes its greatest element (according to its comparator), which might be the\n",
        "139": "   * element that was just added.\n",
        "146": "   * The builder class used in creation of min-max priority queues. Instead of constructing one\n",
        "147": "   * directly, use {@link MinMaxPriorityQueue#orderedBy(Comparator)}, {@link\n",
        "148": "   * MinMaxPriorityQueue#expectedSize(int)} or {@link MinMaxPriorityQueue#maximumSize(int)}.\n",
        "150": "   * @param <B> the upper bound on the eventual type that can be produced by this builder (for\n",
        "151": "   *     example, a {@code Builder<Number>} can produce a {@code Queue<Number>} or {@code\n",
        "152": "   *     Queue<Integer>} but not a {@code Queue<Object>}).\n",
        "172": "     * Configures this builder to build min-max priority queues with an initial expected size of\n",
        "173": "     * {@code expectedSize}.\n",
        "183": "     * Configures this builder to build {@code MinMaxPriorityQueue} instances that are limited to\n",
        "184": "     * {@code maximumSize} elements. Each time a queue grows beyond this bound, it immediately\n",
        "185": "     * removes its greatest element (according to its comparator), which might be the element that\n",
        "186": "     * was just added.\n",
        "196": "     * Builds a new min-max priority queue using the previously specified options, and having no\n",
        "197": "     * initial contents.\n",
        "204": "     * Builds a new min-max priority queue using the previously specified options, and having the\n",
        "205": "     * given initial elements.\n",
        "248": "   * Adds the given element to this queue. If this queue has a maximum size, after adding {@code\n",
        "249": "   * element} the queue will automatically evict its greatest element (according to its comparator),\n",
        "250": "   * which may be {@code element} itself.\n",
        "273": "   * Adds the given element to this queue. If this queue has a maximum size, after adding {@code\n",
        "274": "   * element} the queue will automatically evict its greatest element (according to its comparator),\n",
        "275": "   * which may be {@code element} itself.\n",
        "308": "  /** Returns the index of the max element. */\n",
        "323": "   * Removes and returns the least element of this queue, or returns {@code null} if the queue is\n",
        "324": "   * empty.\n",
        "342": "   * Retrieves, but does not remove, the least element of this queue, or returns {@code null} if the\n",
        "343": "   * queue is empty.\n",
        "350": "   * Removes and returns the greatest element of this queue, or returns {@code null} if the queue is\n",
        "351": "   * empty.\n",
        "372": "   * Retrieves, but does not remove, the greatest element of this queue, or returns {@code null} if\n",
        "373": "   * the queue is empty.\n",
        "382": "   * <p>Normally this method leaves the elements at up to {@code index - 1}, inclusive, untouched.\n",
        "383": "   * Under these circumstances, it returns {@code null}.\n",
        "385": "   * <p>Occasionally, in order to maintain the heap invariant, it must swap a later element of the\n",
        "386": "   * list with one before {@code index}. Under these circumstances it returns a pair of elements as\n",
        "387": "   * a {@link MoveDesc}. The first one is the element that was previously at the end of the heap and\n",
        "388": "   * is now at some position before {@code index}. The second element is the one that was swapped\n",
        "389": "   * down to replace the element at {@code index}. This fact is used by iterator.remove so as to\n",
        "390": "   * visit elements during a traversal once and only once.\n",
        "462": "  /** Removes and returns the value at {@code index}. */\n",
        "484": "   * Returns {@code true} if the MinMax heap structure holds. This is only used in testing.\n",
        "486": "   * <p>TODO(kevinb): move to the test class?\n",
        "499": "   * Each instance of MinMaxPriortyQueue encapsulates two instances of Heap: a min-heap and a\n",
        "500": "   * max-heap. Conceptually, these might each have their own array for storage, but for efficiency's\n",
        "501": "   * sake they are stored interleaved on alternate heap levels in the same array (MMPQ.queue).\n",
        "517": "     * Tries to move {@code toTrickle} from a min to a max level and bubble up there. If it moved\n",
        "518": "     * before {@code removeIndex} this method returns a pair as described in {@link #removeAt}.\n",
        "546": "    /** Bubbles a value from {@code index} up the appropriate heap if required. */\n",
        "561": "     * Bubbles a value from {@code index} up the levels of this heap, and returns the index the\n",
        "562": "     * element ended up at.\n",
        "580": "     * Returns the index of minimum value between {@code index} and {@code index + len}, or {@code\n",
        "581": "     * -1} if {@code index} is greater than {@code size}.\n",
        "598": "    /** Returns the minimum child or {@code -1} if no child exists. */\n",
        "603": "    /** Returns the minimum grand child or -1 if no grand child exists. */\n",
        "613": "     * Moves an element one level up from a min level to a max level (or vice versa). Returns the\n",
        "614": "     * new position of the element.\n",
        "651": "     * <p>Since the last element of the array is actually in the middle of the sorted structure, a\n",
        "652": "     * childless uncle node could be smaller, which would corrupt the invariant if this element\n",
        "653": "     * becomes the new parent of the uncle. In that case, we first switch the last element with its\n",
        "654": "     * uncle, before returning.\n",
        "674": "     * Crosses an element over to the opposite heap by moving it one level down (or up if there are\n",
        "675": "     * no elements below it).\n",
        "677": "     * <p>Returns the new position of the element.\n",
        "692": "     * Fills the hole at {@code index} by moving in the least of its grandchildren to this position,\n",
        "693": "     * then recursively filling the new hole created.\n",
        "695": "     * @return the position of the new hole (where the lowest grandchild moved from, that had no\n",
        "696": "     *     grandchild to replace it)\n",
        "745": "   * <p>If the underlying queue is modified during iteration an exception will be thrown.\n",
        "762": "      return (nextCursor < size()) || ((forgetMeNot != null) && !forgetMeNot.isEmpty());\n",
        "814": "      for (Iterator<E> it = elements.iterator(); it.hasNext(); ) {\n",
        "842": "     * Advances nextCursor to the index of the first element after {@code c} that is not in {@code\n",
        "843": "     * skipMe} and returns {@code size()} if there is no such element.\n",
        "858": "   * Returns an iterator over the elements contained in this collection, <i>in no particular\n",
        "859": "   * order</i>.\n",
        "861": "   * <p>The iterator is <i>fail-fast</i>: If the MinMaxPriorityQueue is modified at any time after\n",
        "862": "   * the iterator is created, in any way except through the iterator's own remove method, the\n",
        "863": "   * iterator will generally throw a {@link ConcurrentModificationException}. Thus, in the face of\n",
        "864": "   * concurrent modification, the iterator fails quickly and cleanly, rather than risking arbitrary,\n",
        "865": "   * non-deterministic behavior at an undetermined time in the future.\n",
        "867": "   * <p>Note that the fail-fast behavior of an iterator cannot be guaranteed as it is, generally\n",
        "868": "   * speaking, impossible to make any hard guarantees in the presence of unsynchronized concurrent\n",
        "869": "   * modification. Fail-fast iterators throw {@code ConcurrentModificationException} on a\n",
        "870": "   * best-effort basis. Therefore, it would be wrong to write a program that depended on this\n",
        "871": "   * exception for its correctness: <i>the fail-fast behavior of iterators should be used only to\n",
        "872": "   * detect bugs.</i>\n",
        "897": "   * Returns the comparator used to order the elements in this queue. Obeys the general contract of\n",
        "898": "   * {@link PriorityQueue#comparator}, but returns {@link Ordering#natural} instead of {@code null}\n",
        "899": "   * to indicate natural ordering.\n",
        "946": "        (oldCapacity < 64) ? (oldCapacity + 1) * 2 : IntMath.checkedMultiply(oldCapacity / 2, 3);\n"
    },
    "removed": {
        "46": " * A double-ended priority queue, which provides constant-time access to both\n",
        "47": " * its least element and its greatest element, as determined by the queue's\n",
        "48": " * specified comparator. If no comparator is given at creation time, the\n",
        "49": " * natural order of elements is used. If no maximum size is given at creation time,\n",
        "50": " * the queue is unbounded.\n",
        "52": " * <p>Usage example: <pre>   {@code\n",
        "54": " *   MinMaxPriorityQueue<User> users = MinMaxPriorityQueue.orderedBy(userComparator)\n",
        "55": " *       .maximumSize(1000)\n",
        "56": " *       .create();}</pre>\n",
        "58": " * <p>As a {@link Queue} it functions exactly as a {@link PriorityQueue}: its\n",
        "59": " * head element -- the implicit target of the methods {@link #peek()}, {@link\n",
        "60": " * #poll()} and {@link #remove()} -- is defined as the <i>least</i> element in\n",
        "61": " * the queue according to the queue's comparator. But unlike a regular priority\n",
        "62": " * queue, the methods {@link #peekLast}, {@link #pollLast} and\n",
        "63": " * {@link #removeLast} are also provided, to act on the <i>greatest</i> element\n",
        "64": " * in the queue instead.\n",
        "66": " * <p>A min-max priority queue can be configured with a maximum size. If so,\n",
        "67": " * each time the size of the queue exceeds that value, the queue automatically\n",
        "68": " * removes its greatest element according to its comparator (which might be the\n",
        "69": " * element that was just added). This is different from conventional bounded\n",
        "70": " * queues, which either block or reject new elements when full.\n",
        "72": " * <p>This implementation is based on the\n",
        "73": " * <a href=\"http://portal.acm.org/citation.cfm?id=6621\">min-max heap</a>\n",
        "74": " * developed by Atkinson, et al. Unlike many other double-ended priority queues,\n",
        "75": " * it stores elements in a single array, as compact as the traditional heap data\n",
        "76": " * structure used in {@link PriorityQueue}.\n",
        "83": " * <li>If you only access one end of the queue, and do use a maximum size,\n",
        "84": " *     this class will perform significantly worse than a {@code PriorityQueue}\n",
        "85": " *     with manual eviction above the maximum size.  In many cases\n",
        "86": " *     {@link Ordering#leastOf} may work for your use case with significantly\n",
        "87": " *     improved (and asymptotically superior) performance.\n",
        "88": " * <li>The retrieval operations {@link #peek}, {@link #peekFirst}, {@link\n",
        "89": " *     #peekLast}, {@link #element}, and {@link #size} are constant-time.\n",
        "90": " * <li>The enqueuing and dequeuing operations ({@link #offer}, {@link #add}, and\n",
        "91": " *     all the forms of {@link #poll} and {@link #remove()}) run in {@code\n",
        "92": " *     O(log n) time}.\n",
        "93": " * <li>The {@link #remove(Object)} and {@link #contains} operations require\n",
        "94": " *     linear ({@code O(n)}) time.\n",
        "95": " * <li>If you only access one end of the queue, and don't use a maximum size,\n",
        "96": " *     this class is functionally equivalent to {@link PriorityQueue}, but\n",
        "97": " *     significantly slower.\n",
        "109": "   * Creates a new min-max priority queue with default settings: natural order,\n",
        "110": "   * no maximum size, no initial contents, and an initial expected size of 11.\n",
        "117": "   * Creates a new min-max priority queue using natural order, no maximum size,\n",
        "118": "   * and initially containing the given elements.\n",
        "126": "   * Creates and returns a new builder, configured to build {@code\n",
        "127": "   * MinMaxPriorityQueue} instances that use {@code comparator} to determine the\n",
        "128": "   * least and greatest elements.\n",
        "135": "   * Creates and returns a new builder, configured to build {@code\n",
        "136": "   * MinMaxPriorityQueue} instances sized appropriately to hold {@code\n",
        "137": "   * expectedSize} elements.\n",
        "144": "   * Creates and returns a new builder, configured to build {@code\n",
        "145": "   * MinMaxPriorityQueue} instances that are limited to {@code maximumSize}\n",
        "146": "   * elements. Each time a queue grows beyond this bound, it immediately\n",
        "147": "   * removes its greatest element (according to its comparator), which might be\n",
        "148": "   * the element that was just added.\n",
        "155": "   * The builder class used in creation of min-max priority queues. Instead of\n",
        "156": "   * constructing one directly, use {@link\n",
        "157": "   * MinMaxPriorityQueue#orderedBy(Comparator)}, {@link\n",
        "158": "   * MinMaxPriorityQueue#expectedSize(int)} or {@link\n",
        "159": "   * MinMaxPriorityQueue#maximumSize(int)}.\n",
        "161": "   * @param <B> the upper bound on the eventual type that can be produced by\n",
        "162": "   *     this builder (for example, a {@code Builder<Number>} can produce a\n",
        "163": "   *     {@code Queue<Number>} or {@code Queue<Integer>} but not a {@code\n",
        "164": "   *     Queue<Object>}).\n",
        "184": "     * Configures this builder to build min-max priority queues with an initial\n",
        "185": "     * expected size of {@code expectedSize}.\n",
        "195": "     * Configures this builder to build {@code MinMaxPriorityQueue} instances\n",
        "196": "     * that are limited to {@code maximumSize} elements. Each time a queue grows\n",
        "197": "     * beyond this bound, it immediately removes its greatest element (according\n",
        "198": "     * to its comparator), which might be the element that was just added.\n",
        "208": "     * Builds a new min-max priority queue using the previously specified\n",
        "209": "     * options, and having no initial contents.\n",
        "216": "     * Builds a new min-max priority queue using the previously specified\n",
        "217": "     * options, and having the given initial elements.\n",
        "260": "   * Adds the given element to this queue. If this queue has a maximum size,\n",
        "261": "   * after adding {@code element} the queue will automatically evict its\n",
        "262": "   * greatest element (according to its comparator), which may be {@code\n",
        "263": "   * element} itself.\n",
        "286": "   * Adds the given element to this queue. If this queue has a maximum size,\n",
        "287": "   * after adding {@code element} the queue will automatically evict its\n",
        "288": "   * greatest element (according to its comparator), which may be {@code\n",
        "289": "   * element} itself.\n",
        "322": "  /**\n",
        "323": "   * Returns the index of the max element.\n",
        "324": "   */\n",
        "339": "   * Removes and returns the least element of this queue, or returns {@code\n",
        "340": "   * null} if the queue is empty.\n",
        "358": "   * Retrieves, but does not remove, the least element of this queue, or returns\n",
        "359": "   * {@code null} if the queue is empty.\n",
        "366": "   * Removes and returns the greatest element of this queue, or returns {@code\n",
        "367": "   * null} if the queue is empty.\n",
        "388": "   * Retrieves, but does not remove, the greatest element of this queue, or\n",
        "389": "   * returns {@code null} if the queue is empty.\n",
        "398": "   * <p>Normally this method leaves the elements at up to {@code index - 1},\n",
        "399": "   * inclusive, untouched.  Under these circumstances, it returns {@code null}.\n",
        "401": "   * <p>Occasionally, in order to maintain the heap invariant, it must swap a\n",
        "402": "   * later element of the list with one before {@code index}. Under these\n",
        "403": "   * circumstances it returns a pair of elements as a {@link MoveDesc}. The\n",
        "404": "   * first one is the element that was previously at the end of the heap and is\n",
        "405": "   * now at some position before {@code index}. The second element is the one\n",
        "406": "   * that was swapped down to replace the element at {@code index}. This fact is\n",
        "407": "   * used by iterator.remove so as to visit elements during a traversal once and\n",
        "408": "   * only once.\n",
        "480": "  /**\n",
        "481": "   * Removes and returns the value at {@code index}.\n",
        "482": "   */\n",
        "504": "   * Returns {@code true} if the MinMax heap structure holds. This is only used\n",
        "505": "   * in testing.\n",
        "507": "   * TODO(kevinb): move to the test class?\n",
        "520": "   * Each instance of MinMaxPriortyQueue encapsulates two instances of Heap:\n",
        "521": "   * a min-heap and a max-heap. Conceptually, these might each have their own\n",
        "522": "   * array for storage, but for efficiency's sake they are stored interleaved on\n",
        "523": "   * alternate heap levels in the same array (MMPQ.queue).\n",
        "539": "     * Tries to move {@code toTrickle} from a min to a max level and\n",
        "540": "     * bubble up there. If it moved before {@code removeIndex} this method\n",
        "541": "     * returns a pair as described in {@link #removeAt}.\n",
        "569": "    /**\n",
        "570": "     * Bubbles a value from {@code index} up the appropriate heap if required.\n",
        "571": "     */\n",
        "586": "     * Bubbles a value from {@code index} up the levels of this heap, and\n",
        "587": "     * returns the index the element ended up at.\n",
        "605": "     * Returns the index of minimum value between {@code index} and\n",
        "606": "     * {@code index + len}, or {@code -1} if {@code index} is greater than\n",
        "607": "     * {@code size}.\n",
        "624": "    /**\n",
        "625": "     * Returns the minimum child or {@code -1} if no child exists.\n",
        "626": "     */\n",
        "631": "    /**\n",
        "632": "     * Returns the minimum grand child or -1 if no grand child exists.\n",
        "633": "     */\n",
        "643": "     * Moves an element one level up from a min level to a max level\n",
        "644": "     * (or vice versa).\n",
        "645": "     * Returns the new position of the element.\n",
        "682": "     * <p>Since the last element of the array is actually in the\n",
        "683": "     * middle of the sorted structure, a childless uncle node could be\n",
        "684": "     * smaller, which would corrupt the invariant if this element\n",
        "685": "     * becomes the new parent of the uncle. In that case, we first\n",
        "686": "     * switch the last element with its uncle, before returning.\n",
        "706": "     * Crosses an element over to the opposite heap by moving it one level down\n",
        "707": "     * (or up if there are no elements below it).\n",
        "709": "     * Returns the new position of the element.\n",
        "724": "     * Fills the hole at {@code index} by moving in the least of its\n",
        "725": "     * grandchildren to this position, then recursively filling the new hole\n",
        "726": "     * created.\n",
        "728": "     * @return the position of the new hole (where the lowest grandchild moved\n",
        "729": "     *     from, that had no grandchild to replace it)\n",
        "778": "   * If the underlying queue is modified during iteration an exception will be\n",
        "779": "   * thrown.\n",
        "796": "      return (nextCursor < size())\n",
        "797": "          || ((forgetMeNot != null) && !forgetMeNot.isEmpty());\n",
        "849": "      for (Iterator<E> it = elements.iterator(); it.hasNext();) {\n",
        "877": "     * Advances nextCursor to the index of the first element after {@code c} that is not in\n",
        "878": "     * {@code skipMe} and returns {@code size()} if there is no such element.\n",
        "893": "   * Returns an iterator over the elements contained in this collection,\n",
        "894": "   * <i>in no particular order</i>.\n",
        "896": "   * <p>The iterator is <i>fail-fast</i>: If the MinMaxPriorityQueue is modified\n",
        "897": "   * at any time after the iterator is created, in any way except through the\n",
        "898": "   * iterator's own remove method, the iterator will generally throw a\n",
        "899": "   * {@link ConcurrentModificationException}. Thus, in the face of concurrent\n",
        "900": "   * modification, the iterator fails quickly and cleanly, rather than risking\n",
        "901": "   * arbitrary, non-deterministic behavior at an undetermined time in the\n",
        "902": "   * future.\n",
        "904": "   * <p>Note that the fail-fast behavior of an iterator cannot be guaranteed\n",
        "905": "   * as it is, generally speaking, impossible to make any hard guarantees in the\n",
        "906": "   * presence of unsynchronized concurrent modification.  Fail-fast iterators\n",
        "907": "   * throw {@code ConcurrentModificationException} on a best-effort basis.\n",
        "908": "   * Therefore, it would be wrong to write a program that depended on this\n",
        "909": "   * exception for its correctness: <i>the fail-fast behavior of iterators\n",
        "910": "   * should be used only to detect bugs.</i>\n",
        "935": "   * Returns the comparator used to order the elements in this queue. Obeys the\n",
        "936": "   * general contract of {@link PriorityQueue#comparator}, but returns {@link\n",
        "937": "   * Ordering#natural} instead of {@code null} to indicate natural ordering.\n",
        "984": "        (oldCapacity < 64)\n",
        "985": "            ? (oldCapacity + 1) * 2\n",
        "986": "            : IntMath.checkedMultiply(oldCapacity / 2, 3);\n"
    }
}