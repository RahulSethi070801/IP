{
    "addition": {
        "53": " * more than 2 per second:\n",
        "54": " *\n",
        "55": " * <pre>{@code\n",
        "56": " * final RateLimiter rateLimiter = RateLimiter.create(2.0); // rate is \"2 permits per second\"\n",
        "57": " * void submitTasks(List<Runnable> tasks, Executor executor) {\n",
        "58": " *   for (Runnable task : tasks) {\n",
        "59": " *     rateLimiter.acquire(); // may wait\n",
        "60": " *     executor.execute(task);\n",
        "61": " *   }\n",
        "62": " * }\n",
        "63": " * }</pre>\n",
        "67": " * permits per second:\n",
        "68": " *\n",
        "69": " * <pre>{@code\n",
        "70": " * final RateLimiter rateLimiter = RateLimiter.create(5000.0); // rate = 5000 permits per second\n",
        "71": " * void submitPacket(byte[] packet) {\n",
        "72": " *   rateLimiter.acquire(packet.length);\n",
        "73": " *   networkService.send(packet);\n",
        "74": " * }\n",
        "75": " * }</pre>\n",
        "78": " * throttling of the request itself (an invocation to {@code acquire(1)} and an invocation to {@code\n",
        "79": " * acquire(1000)} will result in exactly the same throttling, if any), but it affects the throttling\n",
        "80": " * of the <i>next</i> request. I.e., if an expensive task arrives at an idle RateLimiter, it will be\n",
        "81": " * granted immediately, but it is the <i>next</i> request that will experience extra throttling,\n",
        "82": " * thus paying for the cost of the expensive task.\n",
        "95": "   * Creates a {@code RateLimiter} with the specified stable throughput, given as \"permits per\n",
        "96": "   * second\" (commonly referred to as <i>QPS</i>, queries per second).\n",
        "101": "   * rate limiter will release one permit every {@code (1.0 / permitsPerSecond)} seconds. When the\n",
        "102": "   * rate limiter is unused, bursts of up to {@code permitsPerSecond} permits will be allowed, with\n",
        "103": "   * subsequent requests being smoothly limited at the stable rate of {@code permitsPerSecond}.\n",
        "136": "   * Creates a {@code RateLimiter} with the specified stable throughput, given as \"permits per\n",
        "137": "   * second\" (commonly referred to as <i>QPS</i>, queries per second), and a <i>warmup period</i>,\n",
        "138": "   * during which the {@code RateLimiter} smoothly ramps up its rate, until it reaches its maximum\n",
        "139": "   * rate at the end of the period (as long as there are enough requests to saturate it). Similarly,\n",
        "140": "   * if the {@code RateLimiter} is left <i>unused</i> for a duration of {@code warmupPeriod}, it\n",
        "141": "   * will gradually return to its \"cold\" state, i.e. it will go through the same warming up process\n",
        "142": "   * as when it was first created.\n",
        "156": "   * @throws IllegalArgumentException if {@code permitsPerSecond} is negative or zero or {@code\n",
        "157": "   *     warmupPeriod} is negative\n",
        "210": "   * <i>previous</i> request, this means that the very next request after an invocation to {@code\n",
        "211": "   * setRate} will not be affected by the new rate; it will pay the cost of the previous request,\n",
        "212": "   * which is in terms of the previous rate.\n",
        "214": "   * <p>The behavior of the {@code RateLimiter} is not modified in any other way, e.g. if the {@code\n",
        "215": "   * RateLimiter} was configured with a warmup period of 20 seconds, it still has a warmup period of\n",
        "216": "   * 20 seconds after this method invocation.\n"
    },
    "removed": {
        "53": " * more than 2 per second: <pre>   {@code\n",
        "54": " *  final RateLimiter rateLimiter = RateLimiter.create(2.0); // rate is \"2 permits per second\"\n",
        "55": " *  void submitTasks(List<Runnable> tasks, Executor executor) {\n",
        "56": " *    for (Runnable task : tasks) {\n",
        "57": " *      rateLimiter.acquire(); // may wait\n",
        "58": " *      executor.execute(task);\n",
        "59": " *    }\n",
        "60": " *  }}</pre>\n",
        "64": " * permits per second: <pre>   {@code\n",
        "65": " *  final RateLimiter rateLimiter = RateLimiter.create(5000.0); // rate = 5000 permits per second\n",
        "66": " *  void submitPacket(byte[] packet) {\n",
        "67": " *    rateLimiter.acquire(packet.length);\n",
        "68": " *    networkService.send(packet);\n",
        "69": " *  }}</pre>\n",
        "72": " * throttling of the request itself (an invocation to {@code acquire(1)} and an invocation to\n",
        "73": " * {@code acquire(1000)} will result in exactly the same throttling, if any), but it affects the\n",
        "74": " * throttling of the <i>next</i> request. I.e., if an expensive task arrives at an idle RateLimiter,\n",
        "75": " * it will be granted immediately, but it is the <i>next</i> request that will experience extra\n",
        "76": " * throttling, thus paying for the cost of the expensive task.\n",
        "89": "   * Creates a {@code RateLimiter} with the specified stable throughput, given as\n",
        "90": "   * \"permits per second\" (commonly referred to as <i>QPS</i>, queries per second).\n",
        "95": "   * rate limiter will release one permit every {@code\n",
        "96": "   * (1.0 / permitsPerSecond)} seconds. When the rate limiter is unused, bursts of up to\n",
        "97": "   * {@code permitsPerSecond} permits will be allowed, with subsequent requests being smoothly\n",
        "98": "   * limited at the stable rate of {@code permitsPerSecond}.\n",
        "131": "   * Creates a {@code RateLimiter} with the specified stable throughput, given as\n",
        "132": "   * \"permits per second\" (commonly referred to as <i>QPS</i>, queries per second), and a <i>warmup\n",
        "133": "   * period</i>, during which the {@code RateLimiter} smoothly ramps up its rate, until it reaches\n",
        "134": "   * its maximum rate at the end of the period (as long as there are enough requests to saturate\n",
        "135": "   * it). Similarly, if the {@code RateLimiter} is left <i>unused</i> for a duration of\n",
        "136": "   * {@code warmupPeriod}, it will gradually return to its \"cold\" state, i.e. it will go through the\n",
        "137": "   * same warming up process as when it was first created.\n",
        "151": "   * @throws IllegalArgumentException if {@code permitsPerSecond} is negative or zero or\n",
        "152": "   *     {@code warmupPeriod} is negative\n",
        "205": "   * <i>previous</i> request, this means that the very next request after an invocation to\n",
        "206": "   * {@code setRate} will not be affected by the new rate; it will pay the cost of the previous\n",
        "207": "   * request, which is in terms of the previous rate.\n",
        "209": "   * <p>The behavior of the {@code RateLimiter} is not modified in any other way, e.g. if the\n",
        "210": "   * {@code RateLimiter} was configured with a warmup period of 20 seconds, it still has a warmup\n",
        "211": "   * period of 20 seconds after this method invocation.\n"
    }
}