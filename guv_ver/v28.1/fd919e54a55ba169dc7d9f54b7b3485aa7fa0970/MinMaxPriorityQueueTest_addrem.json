{
    "addition": {
        "65": "    suite.addTest(\n",
        "66": "        QueueTestSuiteBuilder.using(\n",
        "67": "                new TestStringQueueGenerator() {\n",
        "68": "                  @Override\n",
        "69": "                  protected Queue<String> create(String[] elements) {\n",
        "70": "                    return MinMaxPriorityQueue.create(Arrays.asList(elements));\n",
        "71": "                  }\n",
        "72": "                })\n",
        "73": "            .named(\"MinMaxPriorityQueue\")\n",
        "74": "            .withFeatures(CollectionSize.ANY, CollectionFeature.GENERAL_PURPOSE)\n",
        "75": "            .createTestSuite());\n",
        "82": "    MinMaxPriorityQueue<Integer> queue = MinMaxPriorityQueue.create();\n",
        "89": "    MinMaxPriorityQueue<Integer> queue = MinMaxPriorityQueue.orderedBy(SOME_COMPARATOR).create();\n",
        "96": "    MinMaxPriorityQueue<Integer> queue = MinMaxPriorityQueue.expectedSize(8).create();\n",
        "103": "    MinMaxPriorityQueue<Integer> queue =\n",
        "104": "        MinMaxPriorityQueue.orderedBy(SOME_COMPARATOR).expectedSize(8).create();\n",
        "111": "    MinMaxPriorityQueue<Integer> queue = MinMaxPriorityQueue.maximumSize(42).create();\n",
        "118": "    MinMaxPriorityQueue<Integer> queue =\n",
        "119": "        MinMaxPriorityQueue.orderedBy(SOME_COMPARATOR).maximumSize(42).create();\n",
        "126": "    MinMaxPriorityQueue<Integer> queue =\n",
        "127": "        MinMaxPriorityQueue.expectedSize(8).maximumSize(42).create();\n",
        "136": "    MinMaxPriorityQueue<Integer> queue = MinMaxPriorityQueue.create(NUMBERS);\n",
        "144": "    MinMaxPriorityQueue<Integer> queue =\n",
        "145": "        MinMaxPriorityQueue.orderedBy(SOME_COMPARATOR).create(NUMBERS);\n",
        "153": "    MinMaxPriorityQueue<Integer> queue = MinMaxPriorityQueue.expectedSize(8).create(NUMBERS);\n",
        "161": "    MinMaxPriorityQueue<Integer> queue = MinMaxPriorityQueue.maximumSize(42).create(NUMBERS);\n",
        "171": "    MinMaxPriorityQueue<Integer> queue =\n",
        "172": "        MinMaxPriorityQueue.orderedBy(SOME_COMPARATOR)\n",
        "173": "            .expectedSize(8)\n",
        "174": "            .maximumSize(42)\n",
        "175": "            .create(NUMBERS);\n",
        "197": "    MinMaxPriorityQueue<Integer> mmHeap = MinMaxPriorityQueue.expectedSize(heapSize).create();\n",
        "340": "  /** Tests a failure caused by fix to childless uncle issue. */\n",
        "342": "    final ArrayList<Integer> initial = Lists.newArrayList(1, 15, 13, 8, 9, 10, 11, 14);\n",
        "351": "    for (Iterator<Integer> iter = q.iterator(); iter.hasNext(); ) {\n",
        "363": "   * This tests a special case of the removeAt() call. Moving an element sideways on the heap could\n",
        "364": "   * break the invariants. Sometimes we need to bubble an element up instead of trickling down. See\n",
        "365": "   * implementation.\n",
        "369": "    mmHeap.addAll(\n",
        "370": "        Lists.newArrayList(1, 20, 1000, 2, 3, 30, 40, 10, 11, 12, 13, 300, 400, 500, 600));\n",
        "378": "  /** This tests a more obscure special case, but otherwise similar to above. */\n",
        "381": "    List<Integer> values =\n",
        "382": "        Lists.newArrayList(\n",
        "383": "            1, 20, 1000, 2, 3, 30, 40, 10, 11, 12, 13, 300, 400, 500, 600, 4, 5, 6, 7, 8, 9, 4, 5,\n",
        "384": "            200, 250);\n",
        "399": "    mmHeap.addAll(Lists.newArrayList(1, 20, 100, 2, 3, 30, 40));\n",
        "432": "   * This tests a special case where removeAt has to trickle an element first down one level from a\n",
        "433": "   * min to a max level, then up one level above the index of the removed element. It also tests\n",
        "434": "   * that skipMe in the iterator plays nicely with forgetMeNot.\n",
        "438": "    mmHeap.addAll(\n",
        "439": "        Lists.newArrayList(1, 20, 1000, 2, 3, 30, 40, 10, 11, 12, 13, 200, 300, 500, 400));\n",
        "469": "    MinMaxPriorityQueue<String> mmHeap = MinMaxPriorityQueue.expectedSize(5).create();\n",
        "470": "    Collections.addAll(mmHeap, \"foo\", \"bar\", \"foobar\", \"barfoo\", \"larry\", \"sergey\", \"eric\");\n",
        "477": "    assertFalse(\"heap contains larry which has been removed\", mmHeap.contains(\"larry\"));\n",
        "478": "    assertTrue(\"heap does not contain sergey\", mmHeap.contains(\"sergey\"));\n",
        "479": "    assertTrue(\"Could not remove larry\", mmHeap.removeAll(Lists.newArrayList(\"sergey\", \"eric\")));\n",
        "480": "    assertFalse(\"Could remove nikesh which is not in the heap\", mmHeap.remove(\"nikesh\"));\n",
        "487": "    Collections.addAll(mmHeap, \"foo\", \"bar\", \"foobar\", \"barfoo\", \"larry\", \"sergey\", \"eric\");\n",
        "494": "    MinMaxPriorityQueue<Integer> mmHeap =\n",
        "495": "        MinMaxPriorityQueue.orderedBy(Ordering.natural().reverse()).expectedSize(5).create();\n",
        "502": "  private <T extends Comparable<T>> void runIterator(final List<T> values, int steps)\n",
        "503": "      throws Exception {\n",
        "545": "    MinMaxPriorityQueue<Integer> mmHeap = MinMaxPriorityQueue.expectedSize(heapSize).create();\n",
        "569": "  /** Regression test for bug found. */\n",
        "571": "    MinMaxPriorityQueue<Integer> q = MinMaxPriorityQueue.create(ImmutableList.of(3, 5, 1, 4, 7));\n",
        "624": "  /** Regression test for bug found in random testing. */\n",
        "700": "  /** Regression test for b/4124577 */\n",
        "731": "  /** Regression test for https://github.com/google/guava/issues/2658 */\n",
        "785": "    ONE,\n",
        "786": "    TWO,\n",
        "787": "    THREE,\n",
        "788": "    FOUR,\n",
        "789": "    FIVE;\n",
        "820": "  /** Returns the seed used for the randomization. */\n",
        "821": "  private long insertRandomly(ArrayList<Integer> elements, MinMaxPriorityQueue<Integer> q) {\n",
        "897": "  private static void insertIntoReplica(Map<Integer, AtomicInteger> replica, int newValue) {\n",
        "906": "      SortedMap<Integer, AtomicInteger> replica, int minValue) {\n",
        "913": "      SortedMap<Integer, AtomicInteger> replica, int maxValue) {\n",
        "919": "  private static void removeFromReplica(Map<Integer, AtomicInteger> replica, int value) {\n"
    },
    "removed": {
        "65": "    suite.addTest(QueueTestSuiteBuilder\n",
        "66": "        .using(new TestStringQueueGenerator() {\n",
        "67": "          @Override protected Queue<String> create(String[] elements) {\n",
        "68": "            return MinMaxPriorityQueue.create(Arrays.asList(elements));\n",
        "69": "          }\n",
        "70": "        })\n",
        "71": "        .named(\"MinMaxPriorityQueue\")\n",
        "72": "        .withFeatures(CollectionSize.ANY, CollectionFeature.GENERAL_PURPOSE)\n",
        "73": "        .createTestSuite());\n",
        "80": "    MinMaxPriorityQueue<Integer> queue = MinMaxPriorityQueue\n",
        "81": "        .create();\n",
        "88": "    MinMaxPriorityQueue<Integer> queue = MinMaxPriorityQueue\n",
        "89": "        .orderedBy(SOME_COMPARATOR)\n",
        "90": "        .create();\n",
        "97": "    MinMaxPriorityQueue<Integer> queue = MinMaxPriorityQueue\n",
        "98": "        .expectedSize(8)\n",
        "99": "        .create();\n",
        "106": "    MinMaxPriorityQueue<Integer> queue = MinMaxPriorityQueue\n",
        "107": "        .orderedBy(SOME_COMPARATOR)\n",
        "108": "        .expectedSize(8)\n",
        "109": "        .create();\n",
        "116": "    MinMaxPriorityQueue<Integer> queue = MinMaxPriorityQueue\n",
        "117": "        .maximumSize(42)\n",
        "118": "        .create();\n",
        "125": "    MinMaxPriorityQueue<Integer> queue = MinMaxPriorityQueue\n",
        "126": "        .orderedBy(SOME_COMPARATOR)\n",
        "127": "        .maximumSize(42)\n",
        "128": "        .create();\n",
        "135": "    MinMaxPriorityQueue<Integer> queue = MinMaxPriorityQueue\n",
        "136": "        .expectedSize(8)\n",
        "137": "        .maximumSize(42)\n",
        "138": "        .create();\n",
        "147": "    MinMaxPriorityQueue<Integer> queue = MinMaxPriorityQueue\n",
        "148": "        .create(NUMBERS);\n",
        "156": "    MinMaxPriorityQueue<Integer> queue = MinMaxPriorityQueue\n",
        "157": "        .orderedBy(SOME_COMPARATOR)\n",
        "158": "        .create(NUMBERS);\n",
        "166": "    MinMaxPriorityQueue<Integer> queue = MinMaxPriorityQueue\n",
        "167": "        .expectedSize(8)\n",
        "168": "        .create(NUMBERS);\n",
        "176": "    MinMaxPriorityQueue<Integer> queue = MinMaxPriorityQueue\n",
        "177": "        .maximumSize(42)\n",
        "178": "        .create(NUMBERS);\n",
        "188": "    MinMaxPriorityQueue<Integer> queue = MinMaxPriorityQueue\n",
        "189": "        .orderedBy(SOME_COMPARATOR)\n",
        "190": "        .expectedSize(8)\n",
        "191": "        .maximumSize(42)\n",
        "192": "        .create(NUMBERS);\n",
        "214": "    MinMaxPriorityQueue<Integer> mmHeap =\n",
        "215": "        MinMaxPriorityQueue.expectedSize(heapSize).create();\n",
        "358": "  /**\n",
        "359": "   * Tests a failure caused by fix to childless uncle issue.\n",
        "360": "   */\n",
        "362": "    final ArrayList<Integer> initial = Lists.newArrayList(\n",
        "363": "        1, 15, 13, 8, 9, 10, 11, 14);\n",
        "372": "    for (Iterator<Integer> iter = q.iterator(); iter.hasNext();) {\n",
        "384": "   * This tests a special case of the removeAt() call. Moving an element\n",
        "385": "   * sideways on the heap could break the invariants. Sometimes we need to\n",
        "386": "   * bubble an element up instead of trickling down. See implementation.\n",
        "390": "    mmHeap.addAll(Lists.newArrayList(\n",
        "391": "            1, 20, 1000, 2, 3, 30, 40, 10, 11, 12, 13, 300, 400, 500, 600));\n",
        "399": "  /**\n",
        "400": "   * This tests a more obscure special case, but otherwise similar to above.\n",
        "401": "   */\n",
        "404": "    List<Integer> values = Lists.newArrayList(\n",
        "405": "        1, 20, 1000, 2, 3, 30, 40, 10, 11, 12, 13, 300, 400, 500, 600, 4, 5,\n",
        "406": "        6, 7, 8, 9, 4, 5, 200, 250);\n",
        "421": "    mmHeap.addAll(Lists.newArrayList(\n",
        "422": "            1, 20, 100, 2, 3, 30, 40));\n",
        "455": "   * This tests a special case where removeAt has to trickle an element\n",
        "456": "   * first down one level from a min to a max level, then up one level above\n",
        "457": "   * the index of the removed element.\n",
        "458": "   * It also tests that skipMe in the iterator plays nicely with\n",
        "459": "   * forgetMeNot.\n",
        "463": "    mmHeap.addAll(Lists.newArrayList(\n",
        "464": "        1, 20, 1000, 2, 3, 30, 40, 10, 11, 12, 13, 200, 300, 500, 400));\n",
        "494": "    MinMaxPriorityQueue<String> mmHeap =\n",
        "495": "        MinMaxPriorityQueue.expectedSize(5).create();\n",
        "496": "    Collections.addAll(mmHeap,\n",
        "497": "        \"foo\", \"bar\", \"foobar\", \"barfoo\", \"larry\", \"sergey\", \"eric\");\n",
        "504": "    assertFalse(\"heap contains larry which has been removed\",\n",
        "505": "        mmHeap.contains(\"larry\"));\n",
        "506": "    assertTrue(\"heap does not contain sergey\",\n",
        "507": "        mmHeap.contains(\"sergey\"));\n",
        "508": "    assertTrue(\"Could not remove larry\", mmHeap.removeAll(\n",
        "509": "        Lists.newArrayList(\"sergey\", \"eric\")));\n",
        "510": "    assertFalse(\"Could remove nikesh which is not in the heap\",\n",
        "511": "        mmHeap.remove(\"nikesh\"));\n",
        "518": "    Collections.addAll(mmHeap,\n",
        "519": "        \"foo\", \"bar\", \"foobar\", \"barfoo\", \"larry\", \"sergey\", \"eric\");\n",
        "526": "    MinMaxPriorityQueue<Integer> mmHeap = MinMaxPriorityQueue.orderedBy(\n",
        "527": "        Ordering.natural().reverse()).expectedSize(5).create();\n",
        "534": "  private <T extends Comparable<T>> void runIterator(\n",
        "535": "      final List<T> values, int steps) throws Exception {\n",
        "577": "    MinMaxPriorityQueue<Integer> mmHeap =\n",
        "578": "        MinMaxPriorityQueue.expectedSize(heapSize).create();\n",
        "602": "  /**\n",
        "603": "   * Regression test for bug found.\n",
        "604": "   */\n",
        "606": "    MinMaxPriorityQueue<Integer> q = MinMaxPriorityQueue\n",
        "607": "        .create(ImmutableList.of(3, 5, 1, 4, 7));\n",
        "660": "  /**\n",
        "661": "   * Regression test for bug found in random testing.\n",
        "662": "   */\n",
        "738": "  /**\n",
        "739": "   * Regression test for b/4124577\n",
        "740": "   */\n",
        "771": "  /**\n",
        "772": "   * Regression test for https://github.com/google/guava/issues/2658\n",
        "773": "   */\n",
        "827": "    ONE, TWO, THREE, FOUR, FIVE;\n",
        "858": "  /**\n",
        "859": "   * Returns the seed used for the randomization.\n",
        "860": "   */\n",
        "861": "  private long insertRandomly(ArrayList<Integer> elements,\n",
        "862": "      MinMaxPriorityQueue<Integer> q) {\n",
        "938": "  private static void insertIntoReplica(\n",
        "939": "      Map<Integer, AtomicInteger> replica,\n",
        "940": "      int newValue) {\n",
        "949": "      SortedMap<Integer, AtomicInteger> replica,\n",
        "950": "      int minValue) {\n",
        "957": "      SortedMap<Integer, AtomicInteger> replica,\n",
        "958": "      int maxValue) {\n",
        "964": "  private static void removeFromReplica(\n",
        "965": "      Map<Integer, AtomicInteger> replica, int value) {\n"
    }
}