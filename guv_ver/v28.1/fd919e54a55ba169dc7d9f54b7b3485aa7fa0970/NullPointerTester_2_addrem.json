{
    "addition": {
        "52": " * NullPointerException} or {@link UnsupportedOperationException} whenever null is passed to a\n",
        "53": " * parameter that isn't annotated with {@link Nullable}.\n",
        "55": " * <p>The tested methods and constructors are invoked -- each time with one parameter being null and\n",
        "56": " * the rest not null -- and the test fails if no expected exception is thrown. {@code\n",
        "57": " * NullPointerTester} uses best effort to pick non-null default values for many common JDK and Guava\n",
        "58": " * types, and also for interfaces and public classes that have public parameter-less constructors.\n",
        "59": " * When the non-null default value for a particular parameter type cannot be provided by {@code\n",
        "60": " * NullPointerTester}, the caller can provide a custom non-null default value for the parameter type\n",
        "61": " * via {@link #setDefault}.\n",
        "70": "  private final ClassToInstanceMap<Object> defaults = MutableClassToInstanceMap.create();\n",
        "76": "   * Sets a default value that can be used for any parameter of type {@code type}. Returns this\n",
        "77": "   * object.\n",
        "105": "   * Runs {@link #testConstructor} on every constructor in class {@code c} that has at least {@code\n",
        "106": "   * minimalVisibility}.\n",
        "116": "  /** Runs {@link #testConstructor} on every public constructor in class {@code c}. */\n",
        "122": "   * Runs {@link #testMethod} on every static method of class {@code c} that has at least {@code\n",
        "123": "   * minimalVisibility}, including those \"inherited\" from superclasses of the same package.\n",
        "134": "   * Runs {@link #testMethod} on every public static method of class {@code c}, including those\n",
        "135": "   * \"inherited\" from superclasses of the same package.\n",
        "142": "   * Runs {@link #testMethod} on every instance method of the class of {@code instance} with at\n",
        "143": "   * least {@code minimalVisibility}, including those inherited from superclasses of the same\n",
        "144": "   * package.\n",
        "163": "   * Runs {@link #testMethod} on every public instance method of the class of {@code instance},\n",
        "164": "   * including those inherited from superclasses of the same package.\n",
        "171": "   * Verifies that {@code method} produces a {@link NullPointerException} or {@link\n",
        "172": "   * UnsupportedOperationException} whenever <i>any</i> of its non-{@link Nullable} parameters are\n",
        "173": "   * null.\n",
        "175": "   * @param instance the instance to invoke {@code method} on, or null if {@code method} is static\n",
        "185": "   * Verifies that {@code ctor} produces a {@link NullPointerException} or {@link\n",
        "186": "   * UnsupportedOperationException} whenever <i>any</i> of its non-{@link Nullable} parameters are\n",
        "187": "   * null.\n",
        "191": "    checkArgument(\n",
        "192": "        Modifier.isStatic(declaringClass.getModifiers())\n",
        "193": "            || declaringClass.getEnclosingClass() == null,\n",
        "194": "        \"Cannot test constructor of non-static inner class: %s\",\n",
        "195": "        declaringClass.getName());\n",
        "203": "   * Verifies that {@code method} produces a {@link NullPointerException} or {@link\n",
        "204": "   * UnsupportedOperationException} when the parameter in position {@code paramIndex} is null. If\n",
        "205": "   * this parameter is marked {@link Nullable}, this method does nothing.\n",
        "207": "   * @param instance the instance to invoke {@code method} on, or null if {@code method} is static\n",
        "216": "   * Verifies that {@code ctor} produces a {@link NullPointerException} or {@link\n",
        "217": "   * UnsupportedOperationException} when the parameter in position {@code paramIndex} is null. If\n",
        "218": "   * this parameter is marked {@link Nullable}, this method does nothing.\n",
        "228": "      @Override\n",
        "229": "      boolean isVisible(int modifiers) {\n",
        "235": "      @Override\n",
        "236": "      boolean isVisible(int modifiers) {\n",
        "242": "      @Override\n",
        "243": "      boolean isVisible(int modifiers) {\n",
        "250": "    /** Returns {@code true} if {@code member} is visible under {@code this} visibility. */\n",
        "307": "    @Override\n",
        "308": "    public boolean equals(Object obj) {\n",
        "311": "        return name.equals(that.name) && parameterTypes.equals(that.parameterTypes);\n",
        "316": "    @Override\n",
        "317": "    public int hashCode() {\n",
        "323": "   * Verifies that {@code invokable} produces a {@link NullPointerException} or {@link\n",
        "324": "   * UnsupportedOperationException} when the parameter in position {@code paramIndex} is null. If\n",
        "325": "   * this parameter is marked {@link Nullable}, this method does nothing.\n",
        "327": "   * @param instance the instance to invoke {@code invokable} on, or null if {@code invokable} is\n",
        "328": "   *     static\n",
        "330": "  private void testParameter(\n",
        "331": "      Object instance, Invokable<?, ?> invokable, int paramIndex, Class<?> testedClass) {\n",
        "340": "      Assert.fail(\n",
        "341": "          \"No exception thrown for parameter at index \"\n",
        "342": "              + paramIndex\n",
        "343": "              + \" from \"\n",
        "344": "              + invokable\n",
        "345": "              + Arrays.toString(params)\n",
        "346": "              + \" for \"\n",
        "347": "              + testedClass);\n",
        "415": "      TypeToken<?> convertFromType = type.resolveType(Converter.class.getTypeParameters()[0]);\n",
        "416": "      TypeToken<?> convertToType = type.resolveType(Converter.class.getTypeParameters()[1]);\n",
        "430": "      @Override\n",
        "431": "      protected T doForward(F a) {\n",
        "434": "\n",
        "435": "      @Override\n",
        "436": "      protected F doBackward(T b) {\n",
        "448": "      return TypeToken.of(((ParameterizedType) type).getActualTypeArguments()[0]);\n",
        "456": "      @Override\n",
        "457": "      <R> R dummyReturnValue(TypeToken<R> returnType) {\n",
        "514": "  /** Strategy for exception type matching used by {@link NullPointerTester}. */\n",
        "518": "     * Exceptions should be {@link NullPointerException} or {@link UnsupportedOperationException}.\n",
        "529": "     * Exceptions should be {@link NullPointerException}, {@link IllegalArgumentException}, or\n"
    },
    "removed": {
        "52": " * NullPointerException} or {@link UnsupportedOperationException} whenever null\n",
        "53": " * is passed to a parameter that isn't annotated with {@link Nullable}.\n",
        "55": " * <p>The tested methods and constructors are invoked -- each time with one\n",
        "56": " * parameter being null and the rest not null -- and the test fails if no\n",
        "57": " * expected exception is thrown. {@code NullPointerTester} uses best effort to\n",
        "58": " * pick non-null default values for many common JDK and Guava types, and also\n",
        "59": " * for interfaces and public classes that have public parameter-less\n",
        "60": " * constructors. When the non-null default value for a particular parameter type\n",
        "61": " * cannot be provided by {@code NullPointerTester}, the caller can provide a\n",
        "62": " * custom non-null default value for the parameter type via {@link #setDefault}.\n",
        "71": "  private final ClassToInstanceMap<Object> defaults =\n",
        "72": "      MutableClassToInstanceMap.create();\n",
        "78": "   * Sets a default value that can be used for any parameter of type\n",
        "79": "   * {@code type}. Returns this object.\n",
        "107": "   * Runs {@link #testConstructor} on every constructor in class {@code c} that\n",
        "108": "   * has at least {@code minimalVisibility}.\n",
        "118": "  /**\n",
        "119": "   * Runs {@link #testConstructor} on every public constructor in class {@code\n",
        "120": "   * c}.\n",
        "121": "   */\n",
        "127": "   * Runs {@link #testMethod} on every static method of class {@code c} that has\n",
        "128": "   * at least {@code minimalVisibility}, including those \"inherited\" from\n",
        "129": "   * superclasses of the same package.\n",
        "140": "   * Runs {@link #testMethod} on every public static method of class {@code c},\n",
        "141": "   * including those \"inherited\" from superclasses of the same package.\n",
        "148": "   * Runs {@link #testMethod} on every instance method of the class of\n",
        "149": "   * {@code instance} with at least {@code minimalVisibility}, including those\n",
        "150": "   * inherited from superclasses of the same package.\n",
        "169": "   * Runs {@link #testMethod} on every public instance method of the class of\n",
        "170": "   * {@code instance}, including those inherited from superclasses of the same\n",
        "171": "   * package.\n",
        "178": "   * Verifies that {@code method} produces a {@link NullPointerException}\n",
        "179": "   * or {@link UnsupportedOperationException} whenever <i>any</i> of its\n",
        "180": "   * non-{@link Nullable} parameters are null.\n",
        "182": "   * @param instance the instance to invoke {@code method} on, or null if\n",
        "183": "   *     {@code method} is static\n",
        "193": "   * Verifies that {@code ctor} produces a {@link NullPointerException} or\n",
        "194": "   * {@link UnsupportedOperationException} whenever <i>any</i> of its\n",
        "195": "   * non-{@link Nullable} parameters are null.\n",
        "199": "    checkArgument(Modifier.isStatic(declaringClass.getModifiers())\n",
        "200": "        || declaringClass.getEnclosingClass() == null,\n",
        "201": "        \"Cannot test constructor of non-static inner class: %s\", declaringClass.getName());\n",
        "209": "   * Verifies that {@code method} produces a {@link NullPointerException} or\n",
        "210": "   * {@link UnsupportedOperationException} when the parameter in position {@code\n",
        "211": "   * paramIndex} is null.  If this parameter is marked {@link Nullable}, this\n",
        "212": "   * method does nothing.\n",
        "214": "   * @param instance the instance to invoke {@code method} on, or null if\n",
        "215": "   *     {@code method} is static\n",
        "224": "   * Verifies that {@code ctor} produces a {@link NullPointerException} or\n",
        "225": "   * {@link UnsupportedOperationException} when the parameter in position {@code\n",
        "226": "   * paramIndex} is null.  If this parameter is marked {@link Nullable}, this\n",
        "227": "   * method does nothing.\n",
        "236": "\n",
        "238": "      @Override boolean isVisible(int modifiers) {\n",
        "244": "      @Override boolean isVisible(int modifiers) {\n",
        "250": "      @Override boolean isVisible(int modifiers) {\n",
        "257": "    /**\n",
        "258": "     * Returns {@code true} if {@code member} is visible under {@code this}\n",
        "259": "     * visibility.\n",
        "260": "     */\n",
        "317": "    @Override public boolean equals(Object obj) {\n",
        "320": "        return name.equals(that.name)\n",
        "321": "            && parameterTypes.equals(that.parameterTypes);\n",
        "326": "    @Override public int hashCode() {\n",
        "332": "   * Verifies that {@code invokable} produces a {@link NullPointerException} or\n",
        "333": "   * {@link UnsupportedOperationException} when the parameter in position {@code\n",
        "334": "   * paramIndex} is null.  If this parameter is marked {@link Nullable}, this\n",
        "335": "   * method does nothing.\n",
        "337": "   * @param instance the instance to invoke {@code invokable} on, or null if\n",
        "338": "   *     {@code invokable} is static\n",
        "340": "  private void testParameter(Object instance, Invokable<?, ?> invokable,\n",
        "341": "      int paramIndex, Class<?> testedClass) {\n",
        "350": "      Assert.fail(\"No exception thrown for parameter at index \" + paramIndex\n",
        "351": "          + \" from \" + invokable + Arrays.toString(params) + \" for \" + testedClass);\n",
        "419": "      TypeToken<?> convertFromType = type.resolveType(\n",
        "420": "          Converter.class.getTypeParameters()[0]);\n",
        "421": "      TypeToken<?> convertToType = type.resolveType(\n",
        "422": "          Converter.class.getTypeParameters()[1]);\n",
        "436": "      @Override protected T doForward(F a) {\n",
        "439": "      @Override protected F doBackward(T b) {\n",
        "451": "      return TypeToken.of(\n",
        "452": "          ((ParameterizedType) type).getActualTypeArguments()[0]);\n",
        "460": "      @Override <R> R dummyReturnValue(TypeToken<R> returnType) {\n",
        "517": "  /**\n",
        "518": "   * Strategy for exception type matching used by {@link NullPointerTester}.\n",
        "519": "   */\n",
        "523": "     * Exceptions should be {@link NullPointerException} or\n",
        "524": "     * {@link UnsupportedOperationException}.\n",
        "535": "     * Exceptions should be {@link NullPointerException},\n",
        "536": "     * {@link IllegalArgumentException}, or\n"
    }
}