{
    "addition": {
        "57": " * Static utility methods pertaining to {@link Set} instances. Also see this class's counterparts\n",
        "58": " * {@link Lists}, {@link Maps} and {@link Queues}.\n",
        "61": " * \"https://github.com/google/guava/wiki/CollectionUtilitiesExplained#sets\"> {@code Sets}</a>.\n",
        "73": "   * {@link AbstractSet} substitute without the potentially-quadratic {@code removeAll}\n",
        "74": "   * implementation.\n",
        "89": "   * Returns an immutable set instance containing the given enum elements. Internally, the returned\n",
        "90": "   * set will be backed by an {@link EnumSet}.\n",
        "92": "   * <p>The iteration order of the returned set follows the enum's iteration order, not the order in\n",
        "93": "   * which the elements are provided to the method.\n",
        "107": "   * Returns an immutable set instance containing the given enum elements. Internally, the returned\n",
        "108": "   * set will be backed by an {@link EnumSet}.\n",
        "110": "   * <p>The iteration order of the returned set follows the enum's iteration order, not the order in\n",
        "111": "   * which the elements appear in the given collection.\n",
        "113": "   * @param elements the elements, all of the same {@code enum} type, that the set should contain\n",
        "141": "    static final Collector<Enum<?>, ?, ImmutableSet<? extends Enum<?>>> TO_IMMUTABLE_ENUM_SET =\n",
        "142": "        (Collector)\n",
        "143": "            Collector.<Enum, Accumulator, ImmutableSet<?>>of(\n",
        "144": "                Accumulator::new,\n",
        "145": "                Accumulator::add,\n",
        "146": "                Accumulator::combine,\n",
        "147": "                Accumulator::toImmutableSet,\n",
        "148": "                Collector.Characteristics.UNORDERED);\n",
        "205": "   * <p><b>Note:</b> if mutability is not required, use {@link ImmutableSet#of()} instead. If {@code\n",
        "206": "   * E} is an {@link Enum} type, use {@link EnumSet#noneOf} instead. Otherwise, strongly consider\n",
        "207": "   * using a {@code LinkedHashSet} instead, at the cost of increased memory footprint, to get\n",
        "208": "   * deterministic iteration behavior.\n",
        "296": "   * Creates a thread-safe set backed by a hash map. The set is backed by a {@link\n",
        "297": "   * ConcurrentHashMap} instance, and thus carries the same concurrency guarantees.\n",
        "299": "   * <p>Unlike {@code HashSet}, this class does NOT allow {@code null} to be used as an element. The\n",
        "300": "   * set is serializable.\n",
        "310": "   * Creates a thread-safe set backed by a hash map and containing the given elements. The set is\n",
        "311": "   * backed by a {@link ConcurrentHashMap} instance, and thus carries the same concurrency\n",
        "312": "   * guarantees.\n",
        "314": "   * <p>Unlike {@code HashSet}, this class does NOT allow {@code null} to be used as an element. The\n",
        "315": "   * set is serializable.\n",
        "319": "   * @throws NullPointerException if {@code elements} or any of its contents is null\n",
        "353": "   *     elements without resizing\n",
        "451": "   * Creates an empty {@code Set} that uses identity to determine equality. It compares object\n",
        "452": "   * references, instead of calling {@code equals}, to determine whether a provided object matches\n",
        "453": "   * an element in the set. For example, {@code contains} returns {@code false} when passed an\n",
        "454": "   * object that equals a set member, but isn't the same instance. This behavior is similar to the\n",
        "455": "   * way {@code IdentityHashMap} handles key lookups.\n",
        "466": "   * <p><b>Note:</b> if you need an immutable empty {@link Set}, use {@link Collections#emptySet}\n",
        "467": "   * instead.\n",
        "496": "   * Creates an {@code EnumSet} consisting of all enum values that are not in the specified\n",
        "497": "   * collection. If the collection is an {@link EnumSet}, this method has the same behavior as\n",
        "498": "   * {@link EnumSet#complementOf}. Otherwise, the specified collection must contain at least one\n",
        "499": "   * element, in order to determine the element type. If the collection could be empty, use {@link\n",
        "500": "   * #complementOf(Collection, Class)} instead of this method.\n",
        "501": "   *\n",
        "502": "   * @param collection the collection whose complement should be stored in the enum set\n",
        "503": "   * @return a new, modifiable {@code EnumSet} containing all values of the enum that aren't present\n",
        "504": "   *     in the given collection\n",
        "505": "   * @throws IllegalArgumentException if {@code collection} is not an {@code EnumSet} instance and\n",
        "506": "   *     contains no elements\n",
        "519": "   * Creates an {@code EnumSet} consisting of all enum values that are not in the specified\n",
        "520": "   * collection. This is equivalent to {@link EnumSet#complementOf}, but can act on any input\n",
        "521": "   * collection, as long as the elements are of enum type.\n",
        "523": "   * @param collection the collection whose complement should be stored in the {@code EnumSet}\n",
        "525": "   * @return a new, modifiable {@code EnumSet} initially containing all the values of the enum not\n",
        "526": "   *     present in the given collection\n",
        "544": "   * Returns a set backed by the specified map. The resulting set displays the same ordering,\n",
        "545": "   * concurrency, and performance characteristics as the backing map. In essence, this factory\n",
        "546": "   * method provides a {@link Set} implementation corresponding to any {@link Map} implementation.\n",
        "547": "   * There is no need to use this method on a {@link Map} implementation that already has a\n",
        "548": "   * corresponding {@link Set} implementation (such as {@link java.util.HashMap} or {@link\n",
        "549": "   * java.util.TreeMap}).\n",
        "550": "   *\n",
        "551": "   * <p>Each method invocation on the set returned by this method results in exactly one method\n",
        "552": "   * invocation on the backing map or its {@code keySet} view, with one exception. The {@code\n",
        "553": "   * addAll} method is implemented as a sequence of {@code put} invocations on the backing map.\n",
        "554": "   *\n",
        "555": "   * <p>The specified map must be empty at the time this method is invoked, and should not be\n",
        "556": "   * accessed directly after this method returns. These conditions are ensured if the map is created\n",
        "557": "   * empty, passed directly to this method, and no reference to the map is retained, as illustrated\n",
        "558": "   * in the following code fragment:\n",
        "559": "   *\n",
        "560": "   * <pre>{@code\n",
        "561": "   * Set<Object> identityHashSet = Sets.newSetFromMap(\n",
        "562": "   *     new IdentityHashMap<Object, Boolean>());\n",
        "563": "   * }</pre>\n",
        "578": "   * An unmodifiable view of a set which may be backed by other sets; this view will change as the\n",
        "579": "   * backing sets do. Contains methods to copy the data into a new set which will then remain\n",
        "580": "   * stable. There is usually no reason to retain a reference of type {@code SetView}; typically,\n",
        "581": "   * you either use it as a plain {@link Set}, or immediately invoke {@link #immutableCopy} or\n",
        "590": "     * Returns an immutable copy of the current contents of this set view. Does not support null\n",
        "591": "     * elements.\n",
        "593": "     * <p><b>Warning:</b> this may have unexpected results if a backing set of this view uses a\n",
        "594": "     * nonstandard notion of equivalence, for example if it is a {@link TreeSet} using a comparator\n",
        "595": "     * that is inconsistent with {@link Object#equals(Object)}.\n",
        "602": "     * Copies the current contents of this set view into an existing set. This method has equivalent\n",
        "603": "     * behavior to {@code set.addAll(this)}, assuming that all the sets involved are based on the\n",
        "604": "     * same notion of equivalence.\n",
        "716": "   * Returns an unmodifiable <b>view</b> of the union of two sets. The returned set contains all\n",
        "717": "   * elements that are contained in either backing set. Iterating over the returned set iterates\n",
        "718": "   * first over all the elements of {@code set1}, then over each element of {@code set2}, in order,\n",
        "719": "   * that is not contained in {@code set1}.\n",
        "720": "   *\n",
        "721": "   * <p>Results are undefined if {@code set1} and {@code set2} are sets based on different\n",
        "722": "   * equivalence relations (as {@link HashSet}, {@link TreeSet}, and the {@link Map#keySet} of an\n",
        "723": "   * {@code IdentityHashMap} all are).\n",
        "798": "   * Returns an unmodifiable <b>view</b> of the intersection of two sets. The returned set contains\n",
        "799": "   * all elements that are contained by both backing sets. The iteration order of the returned set\n",
        "800": "   * matches that of {@code set1}.\n",
        "801": "   *\n",
        "802": "   * <p>Results are undefined if {@code set1} and {@code set2} are sets based on different\n",
        "803": "   * equivalence relations (as {@code HashSet}, {@code TreeSet}, and the keySet of an {@code\n",
        "804": "   * IdentityHashMap} all are).\n",
        "805": "   *\n",
        "806": "   * <p><b>Note:</b> The returned view performs slightly better when {@code set1} is the smaller of\n",
        "807": "   * the two sets. If you have reason to believe one of your sets will generally be smaller than the\n",
        "808": "   * other, pass it first. Unfortunately, since this method sets the generic type of the returned\n",
        "809": "   * set based on the type of the first set passed, this could in rare cases force you to make a\n",
        "810": "   * cast, for example:\n",
        "811": "   *\n",
        "812": "   * <pre>{@code\n",
        "813": "   * Set<Object> aFewBadObjects = ...\n",
        "814": "   * Set<String> manyBadStrings = ...\n",
        "815": "   *\n",
        "816": "   * // impossible for a non-String to be in the intersection\n",
        "817": "   * SuppressWarnings(\"unchecked\")\n",
        "818": "   * Set<String> badStrings = (Set) Sets.intersection(\n",
        "819": "   *     aFewBadObjects, manyBadStrings);\n",
        "820": "   * }</pre>\n",
        "886": "   * Returns an unmodifiable <b>view</b> of the difference of two sets. The returned set contains\n",
        "887": "   * all elements that are contained by {@code set1} and not contained by {@code set2}. {@code set2}\n",
        "888": "   * may also contain elements not present in {@code set1}; these are simply ignored. The iteration\n",
        "889": "   * order of the returned set matches that of {@code set1}.\n",
        "890": "   *\n",
        "891": "   * <p>Results are undefined if {@code set1} and {@code set2} are sets based on different\n",
        "892": "   * equivalence relations (as {@code HashSet}, {@code TreeSet}, and the keySet of an {@code\n",
        "893": "   * IdentityHashMap} all are).\n",
        "902": "        return new AbstractIterator<E>() {\n",
        "904": "\n",
        "952": "   * Returns an unmodifiable <b>view</b> of the symmetric difference of two sets. The returned set\n",
        "953": "   * contains all elements that are contained in either {@code set1} or {@code set2} but not in\n",
        "954": "   * both. The iteration order of the returned set is undefined.\n",
        "956": "   * <p>Results are undefined if {@code set1} and {@code set2} are sets based on different\n",
        "957": "   * equivalence relations (as {@code HashSet}, {@code TreeSet}, and the keySet of an {@code\n",
        "958": "   * IdentityHashMap} all are).\n",
        "1021": "   * Returns the elements of {@code unfiltered} that satisfy a predicate. The returned set is a live\n",
        "1022": "   * view of {@code unfiltered}; changes to one affect the other.\n",
        "1023": "   *\n",
        "1024": "   * <p>The resulting set's iterator does not support {@code remove()}, but all other set methods\n",
        "1025": "   * are supported. When given an element that doesn't satisfy the predicate, the set's {@code\n",
        "1026": "   * add()} and {@code addAll()} methods throw an {@link IllegalArgumentException}. When methods\n",
        "1027": "   * such as {@code removeAll()} and {@code clear()} are called on the filtered set, only elements\n",
        "1028": "   * that satisfy the filter will be removed from the underlying set.\n",
        "1029": "   *\n",
        "1030": "   * <p>The returned set isn't threadsafe or serializable, even if {@code unfiltered} is.\n",
        "1031": "   *\n",
        "1032": "   * <p>Many of the filtered set's methods, such as {@code size()}, iterate across every element in\n",
        "1033": "   * the underlying set and determine which elements satisfy the filter. When a live view is\n",
        "1034": "   * <i>not</i> needed, it may be faster to copy {@code Iterables.filter(unfiltered, predicate)} and\n",
        "1035": "   * use the copy.\n",
        "1036": "   *\n",
        "1037": "   * <p><b>Warning:</b> {@code predicate} must be <i>consistent with equals</i>, as documented at\n",
        "1038": "   * {@link Predicate#apply}. Do not provide a predicate such as {@code\n",
        "1039": "   * Predicates.instanceOf(ArrayList.class)}, which is inconsistent with equals. (See {@link\n",
        "1040": "   * Iterables#filter(Iterable, Class)} for related functionality.)\n",
        "1041": "   *\n",
        "1042": "   * <p><b>Java 8 users:</b> many use cases for this method are better addressed by {@link\n",
        "1043": "   * java.util.stream.Stream#filter}. This method is not being deprecated, but we gently encourage\n",
        "1044": "   * you to migrate to streams.\n",
        "1079": "   * Returns the elements of a {@code SortedSet}, {@code unfiltered}, that satisfy a predicate. The\n",
        "1080": "   * returned set is a live view of {@code unfiltered}; changes to one affect the other.\n",
        "1081": "   *\n",
        "1082": "   * <p>The resulting set's iterator does not support {@code remove()}, but all other set methods\n",
        "1083": "   * are supported. When given an element that doesn't satisfy the predicate, the set's {@code\n",
        "1084": "   * add()} and {@code addAll()} methods throw an {@link IllegalArgumentException}. When methods\n",
        "1085": "   * such as {@code removeAll()} and {@code clear()} are called on the filtered set, only elements\n",
        "1086": "   * that satisfy the filter will be removed from the underlying set.\n",
        "1087": "   *\n",
        "1088": "   * <p>The returned set isn't threadsafe or serializable, even if {@code unfiltered} is.\n",
        "1089": "   *\n",
        "1090": "   * <p>Many of the filtered set's methods, such as {@code size()}, iterate across every element in\n",
        "1091": "   * the underlying set and determine which elements satisfy the filter. When a live view is\n",
        "1092": "   * <i>not</i> needed, it may be faster to copy {@code Iterables.filter(unfiltered, predicate)} and\n",
        "1093": "   * use the copy.\n",
        "1094": "   *\n",
        "1095": "   * <p><b>Warning:</b> {@code predicate} must be <i>consistent with equals</i>, as documented at\n",
        "1096": "   * {@link Predicate#apply}. Do not provide a predicate such as {@code\n",
        "1097": "   * Predicates.instanceOf(ArrayList.class)}, which is inconsistent with equals. (See {@link\n",
        "1098": "   * Iterables#filter(Iterable, Class)} for related functionality.)\n",
        "1160": "   * Returns the elements of a {@code NavigableSet}, {@code unfiltered}, that satisfy a predicate.\n",
        "1161": "   * The returned set is a live view of {@code unfiltered}; changes to one affect the other.\n",
        "1162": "   *\n",
        "1163": "   * <p>The resulting set's iterator does not support {@code remove()}, but all other set methods\n",
        "1164": "   * are supported. When given an element that doesn't satisfy the predicate, the set's {@code\n",
        "1165": "   * add()} and {@code addAll()} methods throw an {@link IllegalArgumentException}. When methods\n",
        "1166": "   * such as {@code removeAll()} and {@code clear()} are called on the filtered set, only elements\n",
        "1167": "   * that satisfy the filter will be removed from the underlying set.\n",
        "1168": "   *\n",
        "1169": "   * <p>The returned set isn't threadsafe or serializable, even if {@code unfiltered} is.\n",
        "1170": "   *\n",
        "1171": "   * <p>Many of the filtered set's methods, such as {@code size()}, iterate across every element in\n",
        "1172": "   * the underlying set and determine which elements satisfy the filter. When a live view is\n",
        "1173": "   * <i>not</i> needed, it may be faster to copy {@code Iterables.filter(unfiltered, predicate)} and\n",
        "1174": "   * use the copy.\n",
        "1175": "   *\n",
        "1176": "   * <p><b>Warning:</b> {@code predicate} must be <i>consistent with equals</i>, as documented at\n",
        "1177": "   * {@link Predicate#apply}. Do not provide a predicate such as {@code\n",
        "1178": "   * Predicates.instanceOf(ArrayList.class)}, which is inconsistent with equals. (See {@link\n",
        "1179": "   * Iterables#filter(Iterable, Class)} for related functionality.)\n",
        "1275": "   * Returns every possible list that can be formed by choosing one element from each of the given\n",
        "1276": "   * sets in order; the \"n-ary <a href=\"http://en.wikipedia.org/wiki/Cartesian_product\">Cartesian\n",
        "1277": "   * product</a>\" of the sets. For example:\n",
        "1279": "   * <pre>{@code\n",
        "1280": "   * Sets.cartesianProduct(ImmutableList.of(\n",
        "1281": "   *     ImmutableSet.of(1, 2),\n",
        "1282": "   *     ImmutableSet.of(\"A\", \"B\", \"C\")))\n",
        "1283": "   * }</pre>\n",
        "1288": "   *   <li>{@code ImmutableList.of(1, \"A\")}\n",
        "1289": "   *   <li>{@code ImmutableList.of(1, \"B\")}\n",
        "1290": "   *   <li>{@code ImmutableList.of(1, \"C\")}\n",
        "1291": "   *   <li>{@code ImmutableList.of(2, \"A\")}\n",
        "1292": "   *   <li>{@code ImmutableList.of(2, \"B\")}\n",
        "1293": "   *   <li>{@code ImmutableList.of(2, \"C\")}\n",
        "1296": "   * <p>The result is guaranteed to be in the \"traditional\", lexicographical order for Cartesian\n",
        "1297": "   * products that you would get from nesting for loops:\n",
        "1298": "   *\n",
        "1299": "   * <pre>{@code\n",
        "1300": "   * for (B b0 : sets.get(0)) {\n",
        "1301": "   *   for (B b1 : sets.get(1)) {\n",
        "1302": "   *     ...\n",
        "1303": "   *     ImmutableList<B> tuple = ImmutableList.of(b0, b1, ...);\n",
        "1304": "   *     // operate on tuple\n",
        "1305": "   *   }\n",
        "1306": "   * }\n",
        "1307": "   * }</pre>\n",
        "1308": "   *\n",
        "1309": "   * <p>Note that if any input set is empty, the Cartesian product will also be empty. If no sets at\n",
        "1310": "   * all are provided (an empty list), the resulting Cartesian product has one element, an empty\n",
        "1311": "   * list (counter-intuitive, but mathematically consistent).\n",
        "1312": "   *\n",
        "1313": "   * <p><i>Performance notes:</i> while the cartesian product of sets of size {@code m, n, p} is a\n",
        "1314": "   * set of size {@code m x n x p}, its actual memory consumption is much smaller. When the\n",
        "1315": "   * cartesian set is constructed, the input sets are merely copied. Only as the resulting set is\n",
        "1316": "   * iterated are the individual lists created, and these are not retained after iteration.\n",
        "1317": "   *\n",
        "1318": "   * @param sets the sets to choose elements from, in the order that the elements chosen from those\n",
        "1319": "   *     sets should appear in the resulting lists\n",
        "1320": "   * @param <B> any common base class shared by all axes (often just {@link Object})\n",
        "1321": "   * @return the Cartesian product, as an immutable set containing immutable lists\n",
        "1322": "   * @throws NullPointerException if {@code sets}, any one of the {@code sets}, or any element of a\n",
        "1323": "   *     provided set is null\n",
        "1331": "   * Returns every possible list that can be formed by choosing one element from each of the given\n",
        "1332": "   * sets in order; the \"n-ary <a href=\"http://en.wikipedia.org/wiki/Cartesian_product\">Cartesian\n",
        "1333": "   * product</a>\" of the sets. For example:\n",
        "1335": "   * <pre>{@code\n",
        "1336": "   * Sets.cartesianProduct(\n",
        "1337": "   *     ImmutableSet.of(1, 2),\n",
        "1338": "   *     ImmutableSet.of(\"A\", \"B\", \"C\"))\n",
        "1339": "   * }</pre>\n",
        "1344": "   *   <li>{@code ImmutableList.of(1, \"A\")}\n",
        "1345": "   *   <li>{@code ImmutableList.of(1, \"B\")}\n",
        "1346": "   *   <li>{@code ImmutableList.of(1, \"C\")}\n",
        "1347": "   *   <li>{@code ImmutableList.of(2, \"A\")}\n",
        "1348": "   *   <li>{@code ImmutableList.of(2, \"B\")}\n",
        "1349": "   *   <li>{@code ImmutableList.of(2, \"C\")}\n",
        "1352": "   * <p>The result is guaranteed to be in the \"traditional\", lexicographical order for Cartesian\n",
        "1353": "   * products that you would get from nesting for loops:\n",
        "1354": "   *\n",
        "1355": "   * <pre>{@code\n",
        "1356": "   * for (B b0 : sets.get(0)) {\n",
        "1357": "   *   for (B b1 : sets.get(1)) {\n",
        "1358": "   *     ...\n",
        "1359": "   *     ImmutableList<B> tuple = ImmutableList.of(b0, b1, ...);\n",
        "1360": "   *     // operate on tuple\n",
        "1361": "   *   }\n",
        "1362": "   * }\n",
        "1363": "   * }</pre>\n",
        "1364": "   *\n",
        "1365": "   * <p>Note that if any input set is empty, the Cartesian product will also be empty. If no sets at\n",
        "1366": "   * all are provided (an empty list), the resulting Cartesian product has one element, an empty\n",
        "1367": "   * list (counter-intuitive, but mathematically consistent).\n",
        "1368": "   *\n",
        "1369": "   * <p><i>Performance notes:</i> while the cartesian product of sets of size {@code m, n, p} is a\n",
        "1370": "   * set of size {@code m x n x p}, its actual memory consumption is much smaller. When the\n",
        "1371": "   * cartesian set is constructed, the input sets are merely copied. Only as the resulting set is\n",
        "1372": "   * iterated are the individual lists created, and these are not retained after iteration.\n",
        "1373": "   *\n",
        "1374": "   * @param sets the sets to choose elements from, in the order that the elements chosen from those\n",
        "1375": "   *     sets should appear in the resulting lists\n",
        "1376": "   * @param <B> any common base class shared by all axes (often just {@link Object})\n",
        "1377": "   * @return the Cartesian product, as an immutable set containing immutable lists\n",
        "1378": "   * @throws NullPointerException if {@code sets}, any one of the {@code sets}, or any element of a\n",
        "1379": "   *     provided set is null\n",
        "1466": "   * Returns the set of all possible subsets of {@code set}. For example, {@code\n",
        "1467": "   * powerSet(ImmutableSet.of(1, 2))} returns the set {@code {{}, {1}, {2}, {1, 2}}}.\n",
        "1469": "   * <p>Elements appear in these subsets in the same iteration order as they appeared in the input\n",
        "1470": "   * set. The order in which these subsets appear in the outer set is undefined. Note that the power\n",
        "1471": "   * set of the empty set is not the empty set, but a one-element set containing the empty set.\n",
        "1473": "   * <p>The returned set and its constituent sets use {@code equals} to decide whether two elements\n",
        "1474": "   * are identical, even if the input set uses a different concept of equivalence.\n",
        "1476": "   * <p><i>Performance notes:</i> while the power set of a set with size {@code n} is of size {@code\n",
        "1477": "   * 2^n}, its memory usage is only {@code O(n)}. When the power set is constructed, the input set\n",
        "1478": "   * is merely copied. Only as the power set is iterated are the individual subsets created, and\n",
        "1479": "   * these subsets themselves occupy only a small constant amount of memory.\n",
        "1483": "   * @throws IllegalArgumentException if {@code set} has more than 30 unique elements (causing the\n",
        "1484": "   *     power set size to exceed the {@code int} range)\n",
        "1486": "   * @see <a href=\"http://en.wikipedia.org/wiki/Power_set\">Power set article at Wikipedia</a>\n",
        "1724": "  /** An implementation for {@link Set#hashCode()}. */\n",
        "1736": "  /** An implementation for {@link Set#equals(Object)}. */\n",
        "1754": "   * Returns an unmodifiable view of the specified navigable set. This method allows modules to\n",
        "1755": "   * provide users with \"read-only\" access to internal navigable sets. Query operations on the\n",
        "1756": "   * returned set \"read through\" to the specified set, and attempts to modify the returned set,\n",
        "1757": "   * whether direct or via its collection views, result in an {@code UnsupportedOperationException}.\n",
        "1758": "   *\n",
        "1759": "   * <p>The returned navigable set will be serializable if the specified navigable set is\n",
        "1760": "   * serializable.\n",
        "1761": "   *\n",
        "1762": "   * @param set the navigable set for which an unmodifiable view is to be returned\n",
        "1878": "   * Returns a synchronized (thread-safe) navigable set backed by the specified navigable set. In\n",
        "1879": "   * order to guarantee serial access, it is critical that <b>all</b> access to the backing\n",
        "1880": "   * navigable set is accomplished through the returned navigable set (or its views).\n",
        "1881": "   *\n",
        "1882": "   * <p>It is imperative that the user manually synchronize on the returned sorted set when\n",
        "1883": "   * iterating over it or any of its {@code descendingSet}, {@code subSet}, {@code headSet}, or\n",
        "1884": "   * {@code tailSet} views.\n",
        "1885": "   *\n",
        "1886": "   * <pre>{@code\n",
        "1887": "   * NavigableSet<E> set = synchronizedNavigableSet(new TreeSet<E>());\n",
        "1888": "   *  ...\n",
        "1889": "   * synchronized (set) {\n",
        "1890": "   *   // Must be in the synchronized block\n",
        "1891": "   *   Iterator<E> it = set.iterator();\n",
        "1892": "   *   while (it.hasNext()) {\n",
        "1893": "   *     foo(it.next());\n",
        "1894": "   *   }\n",
        "1895": "   * }\n",
        "1896": "   * }</pre>\n",
        "1897": "   *\n",
        "1898": "   * <p>or:\n",
        "1899": "   *\n",
        "1900": "   * <pre>{@code\n",
        "1901": "   * NavigableSet<E> set = synchronizedNavigableSet(new TreeSet<E>());\n",
        "1902": "   * NavigableSet<E> set2 = set.descendingSet().headSet(foo);\n",
        "1903": "   *  ...\n",
        "1904": "   * synchronized (set) { // Note: set, not set2!!!\n",
        "1905": "   *   // Must be in the synchronized block\n",
        "1906": "   *   Iterator<E> it = set2.descendingIterator();\n",
        "1907": "   *   while (it.hasNext())\n",
        "1908": "   *     foo(it.next());\n",
        "1909": "   *   }\n",
        "1910": "   * }\n",
        "1911": "   * }</pre>\n",
        "1915": "   * <p>The returned navigable set will be serializable if the specified navigable set is\n",
        "1916": "   * serializable.\n",
        "1918": "   * @param navigableSet the navigable set to be \"wrapped\" in a synchronized navigable set.\n",
        "1927": "  /** Remove each element in an iterable from a set. */\n",
        "2089": "   * <p>This method delegates to the appropriate methods of {@link NavigableSet} (namely {@link\n",
        "2090": "   * NavigableSet#subSet(Object, boolean, Object, boolean) subSet()}, {@link\n",
        "2091": "   * NavigableSet#tailSet(Object, boolean) tailSet()}, and {@link NavigableSet#headSet(Object,\n",
        "2092": "   * boolean) headSet()}) to actually construct the view. Consult these methods for a full\n",
        "2093": "   * description of the returned view's behavior.\n",
        "2096": "   * ordering. {@code NavigableSet} on the other hand can specify a custom ordering via a {@link\n",
        "2097": "   * Comparator}, which can violate the natural ordering. Using this method (or in general using\n",
        "2098": "   * {@code Range}) with unnaturally-ordered sets can lead to unexpected and undefined behavior.\n"
    },
    "removed": {
        "57": " * Static utility methods pertaining to {@link Set} instances. Also see this\n",
        "58": " * class's counterparts {@link Lists}, {@link Maps} and {@link Queues}.\n",
        "61": " * \"https://github.com/google/guava/wiki/CollectionUtilitiesExplained#sets\">\n",
        "62": " * {@code Sets}</a>.\n",
        "74": "   * {@link AbstractSet} substitute without the potentially-quadratic\n",
        "75": "   * {@code removeAll} implementation.\n",
        "90": "   * Returns an immutable set instance containing the given enum elements.\n",
        "91": "   * Internally, the returned set will be backed by an {@link EnumSet}.\n",
        "93": "   * <p>The iteration order of the returned set follows the enum's iteration\n",
        "94": "   * order, not the order in which the elements are provided to the method.\n",
        "108": "   * Returns an immutable set instance containing the given enum elements.\n",
        "109": "   * Internally, the returned set will be backed by an {@link EnumSet}.\n",
        "111": "   * <p>The iteration order of the returned set follows the enum's iteration\n",
        "112": "   * order, not the order in which the elements appear in the given collection.\n",
        "114": "   * @param elements the elements, all of the same {@code enum} type, that the\n",
        "115": "   *     set should contain\n",
        "143": "    static final Collector<Enum<?>, ?, ImmutableSet<? extends Enum<?>>>\n",
        "144": "      TO_IMMUTABLE_ENUM_SET =\n",
        "145": "          (Collector)\n",
        "146": "              Collector.<Enum, Accumulator, ImmutableSet<?>>of(\n",
        "147": "                  Accumulator::new,\n",
        "148": "                  Accumulator::add,\n",
        "149": "                  Accumulator::combine,\n",
        "150": "                  Accumulator::toImmutableSet,\n",
        "151": "                  Collector.Characteristics.UNORDERED);\n",
        "208": "   * <p><b>Note:</b> if mutability is not required, use {@link ImmutableSet#of()} instead. If\n",
        "209": "   * {@code E} is an {@link Enum} type, use {@link EnumSet#noneOf} instead. Otherwise, strongly\n",
        "210": "   * consider using a {@code LinkedHashSet} instead, at the cost of increased memory footprint, to\n",
        "211": "   * get deterministic iteration behavior.\n",
        "299": "   * Creates a thread-safe set backed by a hash map. The set is backed by a\n",
        "300": "   * {@link ConcurrentHashMap} instance, and thus carries the same concurrency\n",
        "301": "   * guarantees.\n",
        "303": "   * <p>Unlike {@code HashSet}, this class does NOT allow {@code null} to be\n",
        "304": "   * used as an element. The set is serializable.\n",
        "314": "   * Creates a thread-safe set backed by a hash map and containing the given\n",
        "315": "   * elements. The set is backed by a {@link ConcurrentHashMap} instance, and\n",
        "316": "   * thus carries the same concurrency guarantees.\n",
        "318": "   * <p>Unlike {@code HashSet}, this class does NOT allow {@code null} to be\n",
        "319": "   * used as an element. The set is serializable.\n",
        "323": "   * @throws NullPointerException if {@code elements} or any of its contents is\n",
        "324": "   *      null\n",
        "358": "   *         elements without resizing\n",
        "456": "   * Creates an empty {@code Set} that uses identity to determine equality. It\n",
        "457": "   * compares object references, instead of calling {@code equals}, to\n",
        "458": "   * determine whether a provided object matches an element in the set. For\n",
        "459": "   * example, {@code contains} returns {@code false} when passed an object that\n",
        "460": "   * equals a set member, but isn't the same instance. This behavior is similar\n",
        "461": "   * to the way {@code IdentityHashMap} handles key lookups.\n",
        "472": "   * <p><b>Note:</b> if you need an immutable empty {@link Set}, use\n",
        "473": "   * {@link Collections#emptySet} instead.\n",
        "502": "   * Creates an {@code EnumSet} consisting of all enum values that are not in\n",
        "503": "   * the specified collection. If the collection is an {@link EnumSet}, this\n",
        "504": "   * method has the same behavior as {@link EnumSet#complementOf}. Otherwise,\n",
        "505": "   * the specified collection must contain at least one element, in order to\n",
        "506": "   * determine the element type. If the collection could be empty, use\n",
        "507": "   * {@link #complementOf(Collection, Class)} instead of this method.\n",
        "508": "   *\n",
        "509": "   * @param collection the collection whose complement should be stored in the\n",
        "510": "   *     enum set\n",
        "511": "   * @return a new, modifiable {@code EnumSet} containing all values of the enum\n",
        "512": "   *     that aren't present in the given collection\n",
        "513": "   * @throws IllegalArgumentException if {@code collection} is not an\n",
        "514": "   *     {@code EnumSet} instance and contains no elements\n",
        "527": "   * Creates an {@code EnumSet} consisting of all enum values that are not in\n",
        "528": "   * the specified collection. This is equivalent to\n",
        "529": "   * {@link EnumSet#complementOf}, but can act on any input collection, as long\n",
        "530": "   * as the elements are of enum type.\n",
        "532": "   * @param collection the collection whose complement should be stored in the\n",
        "533": "   *     {@code EnumSet}\n",
        "535": "   * @return a new, modifiable {@code EnumSet} initially containing all the\n",
        "536": "   *     values of the enum not present in the given collection\n",
        "554": "   * Returns a set backed by the specified map. The resulting set displays\n",
        "555": "   * the same ordering, concurrency, and performance characteristics as the\n",
        "556": "   * backing map. In essence, this factory method provides a {@link Set}\n",
        "557": "   * implementation corresponding to any {@link Map} implementation. There is no\n",
        "558": "   * need to use this method on a {@link Map} implementation that already has a\n",
        "559": "   * corresponding {@link Set} implementation (such as {@link java.util.HashMap}\n",
        "560": "   * or {@link java.util.TreeMap}).\n",
        "561": "   *\n",
        "562": "   * <p>Each method invocation on the set returned by this method results in\n",
        "563": "   * exactly one method invocation on the backing map or its {@code keySet}\n",
        "564": "   * view, with one exception. The {@code addAll} method is implemented as a\n",
        "565": "   * sequence of {@code put} invocations on the backing map.\n",
        "566": "   *\n",
        "567": "   * <p>The specified map must be empty at the time this method is invoked,\n",
        "568": "   * and should not be accessed directly after this method returns. These\n",
        "569": "   * conditions are ensured if the map is created empty, passed directly\n",
        "570": "   * to this method, and no reference to the map is retained, as illustrated\n",
        "571": "   * in the following code fragment: <pre>  {@code\n",
        "572": "   *\n",
        "573": "   *   Set<Object> identityHashSet = Sets.newSetFromMap(\n",
        "574": "   *       new IdentityHashMap<Object, Boolean>());}</pre>\n",
        "589": "   * An unmodifiable view of a set which may be backed by other sets; this view\n",
        "590": "   * will change as the backing sets do. Contains methods to copy the data into\n",
        "591": "   * a new set which will then remain stable. There is usually no reason to\n",
        "592": "   * retain a reference of type {@code SetView}; typically, you either use it\n",
        "593": "   * as a plain {@link Set}, or immediately invoke {@link #immutableCopy} or\n",
        "602": "     * Returns an immutable copy of the current contents of this set view.\n",
        "603": "     * Does not support null elements.\n",
        "605": "     * <p><b>Warning:</b> this may have unexpected results if a backing set of\n",
        "606": "     * this view uses a nonstandard notion of equivalence, for example if it is\n",
        "607": "     * a {@link TreeSet} using a comparator that is inconsistent with {@link\n",
        "608": "     * Object#equals(Object)}.\n",
        "615": "     * Copies the current contents of this set view into an existing set. This\n",
        "616": "     * method has equivalent behavior to {@code set.addAll(this)}, assuming that\n",
        "617": "     * all the sets involved are based on the same notion of equivalence.\n",
        "729": "   * Returns an unmodifiable <b>view</b> of the union of two sets. The returned\n",
        "730": "   * set contains all elements that are contained in either backing set.\n",
        "731": "   * Iterating over the returned set iterates first over all the elements of\n",
        "732": "   * {@code set1}, then over each element of {@code set2}, in order, that is not\n",
        "733": "   * contained in {@code set1}.\n",
        "734": "   *\n",
        "735": "   * <p>Results are undefined if {@code set1} and {@code set2} are sets based on\n",
        "736": "   * different equivalence relations (as {@link HashSet}, {@link TreeSet}, and\n",
        "737": "   * the {@link Map#keySet} of an {@code IdentityHashMap} all are).\n",
        "812": "   * Returns an unmodifiable <b>view</b> of the intersection of two sets. The\n",
        "813": "   * returned set contains all elements that are contained by both backing sets.\n",
        "814": "   * The iteration order of the returned set matches that of {@code set1}.\n",
        "815": "   *\n",
        "816": "   * <p>Results are undefined if {@code set1} and {@code set2} are sets based\n",
        "817": "   * on different equivalence relations (as {@code HashSet}, {@code TreeSet},\n",
        "818": "   * and the keySet of an {@code IdentityHashMap} all are).\n",
        "819": "   *\n",
        "820": "   * <p><b>Note:</b> The returned view performs slightly better when {@code\n",
        "821": "   * set1} is the smaller of the two sets. If you have reason to believe one of\n",
        "822": "   * your sets will generally be smaller than the other, pass it first.\n",
        "823": "   * Unfortunately, since this method sets the generic type of the returned set\n",
        "824": "   * based on the type of the first set passed, this could in rare cases force\n",
        "825": "   * you to make a cast, for example: <pre>   {@code\n",
        "826": "   *\n",
        "827": "   *   Set<Object> aFewBadObjects = ...\n",
        "828": "   *   Set<String> manyBadStrings = ...\n",
        "829": "   *\n",
        "830": "   *   // impossible for a non-String to be in the intersection\n",
        "831": "   *   SuppressWarnings(\"unchecked\")\n",
        "832": "   *   Set<String> badStrings = (Set) Sets.intersection(\n",
        "833": "   *       aFewBadObjects, manyBadStrings);}</pre>\n",
        "899": "   * Returns an unmodifiable <b>view</b> of the difference of two sets. The\n",
        "900": "   * returned set contains all elements that are contained by {@code set1} and\n",
        "901": "   * not contained by {@code set2}. {@code set2} may also contain elements not\n",
        "902": "   * present in {@code set1}; these are simply ignored. The iteration order of\n",
        "903": "   * the returned set matches that of {@code set1}.\n",
        "904": "   *\n",
        "905": "   * <p>Results are undefined if {@code set1} and {@code set2} are sets based\n",
        "906": "   * on different equivalence relations (as {@code HashSet}, {@code TreeSet},\n",
        "907": "   * and the keySet of an {@code IdentityHashMap} all are).\n",
        "916": "        return new AbstractIterator<E>(){\n",
        "965": "   * Returns an unmodifiable <b>view</b> of the symmetric difference of two\n",
        "966": "   * sets. The returned set contains all elements that are contained in either\n",
        "967": "   * {@code set1} or {@code set2} but not in both. The iteration order of the\n",
        "968": "   * returned set is undefined.\n",
        "970": "   * <p>Results are undefined if {@code set1} and {@code set2} are sets based\n",
        "971": "   * on different equivalence relations (as {@code HashSet}, {@code TreeSet},\n",
        "972": "   * and the keySet of an {@code IdentityHashMap} all are).\n",
        "1035": "   * Returns the elements of {@code unfiltered} that satisfy a predicate. The\n",
        "1036": "   * returned set is a live view of {@code unfiltered}; changes to one affect\n",
        "1037": "   * the other.\n",
        "1038": "   *\n",
        "1039": "   * <p>The resulting set's iterator does not support {@code remove()}, but all\n",
        "1040": "   * other set methods are supported. When given an element that doesn't satisfy\n",
        "1041": "   * the predicate, the set's {@code add()} and {@code addAll()} methods throw\n",
        "1042": "   * an {@link IllegalArgumentException}. When methods such as {@code\n",
        "1043": "   * removeAll()} and {@code clear()} are called on the filtered set, only\n",
        "1044": "   * elements that satisfy the filter will be removed from the underlying set.\n",
        "1045": "   *\n",
        "1046": "   * <p>The returned set isn't threadsafe or serializable, even if\n",
        "1047": "   * {@code unfiltered} is.\n",
        "1048": "   *\n",
        "1049": "   * <p>Many of the filtered set's methods, such as {@code size()}, iterate\n",
        "1050": "   * across every element in the underlying set and determine which elements\n",
        "1051": "   * satisfy the filter. When a live view is <i>not</i> needed, it may be faster\n",
        "1052": "   * to copy {@code Iterables.filter(unfiltered, predicate)} and use the copy.\n",
        "1053": "   *\n",
        "1054": "   * <p><b>Warning:</b> {@code predicate} must be <i>consistent with equals</i>,\n",
        "1055": "   * as documented at {@link Predicate#apply}. Do not provide a predicate such\n",
        "1056": "   * as {@code Predicates.instanceOf(ArrayList.class)}, which is inconsistent\n",
        "1057": "   * with equals. (See {@link Iterables#filter(Iterable, Class)} for related\n",
        "1058": "   * functionality.)\n",
        "1059": "   *\n",
        "1060": "   * <p><b>Java 8 users:</b> many use cases for this method are better\n",
        "1061": "   * addressed by {@link java.util.stream.Stream#filter}. This method is not\n",
        "1062": "   * being deprecated, but we gently encourage you to migrate to streams.\n",
        "1097": "   * Returns the elements of a {@code SortedSet}, {@code unfiltered}, that\n",
        "1098": "   * satisfy a predicate. The returned set is a live view of {@code unfiltered};\n",
        "1099": "   * changes to one affect the other.\n",
        "1100": "   *\n",
        "1101": "   * <p>The resulting set's iterator does not support {@code remove()}, but all\n",
        "1102": "   * other set methods are supported. When given an element that doesn't satisfy\n",
        "1103": "   * the predicate, the set's {@code add()} and {@code addAll()} methods throw\n",
        "1104": "   * an {@link IllegalArgumentException}. When methods such as\n",
        "1105": "   * {@code removeAll()} and {@code clear()} are called on the filtered set,\n",
        "1106": "   * only elements that satisfy the filter will be removed from the underlying\n",
        "1107": "   * set.\n",
        "1108": "   *\n",
        "1109": "   * <p>The returned set isn't threadsafe or serializable, even if\n",
        "1110": "   * {@code unfiltered} is.\n",
        "1111": "   *\n",
        "1112": "   * <p>Many of the filtered set's methods, such as {@code size()}, iterate across\n",
        "1113": "   * every element in the underlying set and determine which elements satisfy\n",
        "1114": "   * the filter. When a live view is <i>not</i> needed, it may be faster to copy\n",
        "1115": "   * {@code Iterables.filter(unfiltered, predicate)} and use the copy.\n",
        "1116": "   *\n",
        "1117": "   * <p><b>Warning:</b> {@code predicate} must be <i>consistent with equals</i>,\n",
        "1118": "   * as documented at {@link Predicate#apply}. Do not provide a predicate such as\n",
        "1119": "   * {@code Predicates.instanceOf(ArrayList.class)}, which is inconsistent with\n",
        "1120": "   * equals. (See {@link Iterables#filter(Iterable, Class)} for related\n",
        "1121": "   * functionality.)\n",
        "1183": "   * Returns the elements of a {@code NavigableSet}, {@code unfiltered}, that\n",
        "1184": "   * satisfy a predicate. The returned set is a live view of {@code unfiltered};\n",
        "1185": "   * changes to one affect the other.\n",
        "1186": "   *\n",
        "1187": "   * <p>The resulting set's iterator does not support {@code remove()}, but all\n",
        "1188": "   * other set methods are supported. When given an element that doesn't satisfy\n",
        "1189": "   * the predicate, the set's {@code add()} and {@code addAll()} methods throw\n",
        "1190": "   * an {@link IllegalArgumentException}. When methods such as\n",
        "1191": "   * {@code removeAll()} and {@code clear()} are called on the filtered set,\n",
        "1192": "   * only elements that satisfy the filter will be removed from the underlying\n",
        "1193": "   * set.\n",
        "1194": "   *\n",
        "1195": "   * <p>The returned set isn't threadsafe or serializable, even if\n",
        "1196": "   * {@code unfiltered} is.\n",
        "1197": "   *\n",
        "1198": "   * <p>Many of the filtered set's methods, such as {@code size()}, iterate across\n",
        "1199": "   * every element in the underlying set and determine which elements satisfy\n",
        "1200": "   * the filter. When a live view is <i>not</i> needed, it may be faster to copy\n",
        "1201": "   * {@code Iterables.filter(unfiltered, predicate)} and use the copy.\n",
        "1202": "   *\n",
        "1203": "   * <p><b>Warning:</b> {@code predicate} must be <i>consistent with equals</i>,\n",
        "1204": "   * as documented at {@link Predicate#apply}. Do not provide a predicate such as\n",
        "1205": "   * {@code Predicates.instanceOf(ArrayList.class)}, which is inconsistent with\n",
        "1206": "   * equals. (See {@link Iterables#filter(Iterable, Class)} for related\n",
        "1207": "   * functionality.)\n",
        "1303": "   * Returns every possible list that can be formed by choosing one element\n",
        "1304": "   * from each of the given sets in order; the \"n-ary\n",
        "1305": "   * <a href=\"http://en.wikipedia.org/wiki/Cartesian_product\">Cartesian\n",
        "1306": "   * product</a>\" of the sets. For example: <pre>   {@code\n",
        "1308": "   *   Sets.cartesianProduct(ImmutableList.of(\n",
        "1309": "   *       ImmutableSet.of(1, 2),\n",
        "1310": "   *       ImmutableSet.of(\"A\", \"B\", \"C\")))}</pre>\n",
        "1315": "   * <li>{@code ImmutableList.of(1, \"A\")}\n",
        "1316": "   * <li>{@code ImmutableList.of(1, \"B\")}\n",
        "1317": "   * <li>{@code ImmutableList.of(1, \"C\")}\n",
        "1318": "   * <li>{@code ImmutableList.of(2, \"A\")}\n",
        "1319": "   * <li>{@code ImmutableList.of(2, \"B\")}\n",
        "1320": "   * <li>{@code ImmutableList.of(2, \"C\")}\n",
        "1323": "   * <p>The result is guaranteed to be in the \"traditional\", lexicographical\n",
        "1324": "   * order for Cartesian products that you would get from nesting for loops:\n",
        "1325": "   * <pre>   {@code\n",
        "1326": "   *\n",
        "1327": "   *   for (B b0 : sets.get(0)) {\n",
        "1328": "   *     for (B b1 : sets.get(1)) {\n",
        "1329": "   *       ...\n",
        "1330": "   *       ImmutableList<B> tuple = ImmutableList.of(b0, b1, ...);\n",
        "1331": "   *       // operate on tuple\n",
        "1332": "   *     }\n",
        "1333": "   *   }}</pre>\n",
        "1334": "   *\n",
        "1335": "   * <p>Note that if any input set is empty, the Cartesian product will also be\n",
        "1336": "   * empty. If no sets at all are provided (an empty list), the resulting\n",
        "1337": "   * Cartesian product has one element, an empty list (counter-intuitive, but\n",
        "1338": "   * mathematically consistent).\n",
        "1339": "   *\n",
        "1340": "   * <p><i>Performance notes:</i> while the cartesian product of sets of size\n",
        "1341": "   * {@code m, n, p} is a set of size {@code m x n x p}, its actual memory\n",
        "1342": "   * consumption is much smaller. When the cartesian set is constructed, the\n",
        "1343": "   * input sets are merely copied. Only as the resulting set is iterated are the\n",
        "1344": "   * individual lists created, and these are not retained after iteration.\n",
        "1345": "   *\n",
        "1346": "   * @param sets the sets to choose elements from, in the order that\n",
        "1347": "   *     the elements chosen from those sets should appear in the resulting\n",
        "1348": "   *     lists\n",
        "1349": "   * @param <B> any common base class shared by all axes (often just {@link\n",
        "1350": "   *     Object})\n",
        "1351": "   * @return the Cartesian product, as an immutable set containing immutable\n",
        "1352": "   *     lists\n",
        "1353": "   * @throws NullPointerException if {@code sets}, any one of the {@code sets},\n",
        "1354": "   *     or any element of a provided set is null\n",
        "1362": "   * Returns every possible list that can be formed by choosing one element\n",
        "1363": "   * from each of the given sets in order; the \"n-ary\n",
        "1364": "   * <a href=\"http://en.wikipedia.org/wiki/Cartesian_product\">Cartesian\n",
        "1365": "   * product</a>\" of the sets. For example: <pre>   {@code\n",
        "1367": "   *   Sets.cartesianProduct(\n",
        "1368": "   *       ImmutableSet.of(1, 2),\n",
        "1369": "   *       ImmutableSet.of(\"A\", \"B\", \"C\"))}</pre>\n",
        "1374": "   * <li>{@code ImmutableList.of(1, \"A\")}\n",
        "1375": "   * <li>{@code ImmutableList.of(1, \"B\")}\n",
        "1376": "   * <li>{@code ImmutableList.of(1, \"C\")}\n",
        "1377": "   * <li>{@code ImmutableList.of(2, \"A\")}\n",
        "1378": "   * <li>{@code ImmutableList.of(2, \"B\")}\n",
        "1379": "   * <li>{@code ImmutableList.of(2, \"C\")}\n",
        "1382": "   * <p>The result is guaranteed to be in the \"traditional\", lexicographical\n",
        "1383": "   * order for Cartesian products that you would get from nesting for loops:\n",
        "1384": "   * <pre>   {@code\n",
        "1385": "   *\n",
        "1386": "   *   for (B b0 : sets.get(0)) {\n",
        "1387": "   *     for (B b1 : sets.get(1)) {\n",
        "1388": "   *       ...\n",
        "1389": "   *       ImmutableList<B> tuple = ImmutableList.of(b0, b1, ...);\n",
        "1390": "   *       // operate on tuple\n",
        "1391": "   *     }\n",
        "1392": "   *   }}</pre>\n",
        "1393": "   *\n",
        "1394": "   * <p>Note that if any input set is empty, the Cartesian product will also be\n",
        "1395": "   * empty. If no sets at all are provided (an empty list), the resulting\n",
        "1396": "   * Cartesian product has one element, an empty list (counter-intuitive, but\n",
        "1397": "   * mathematically consistent).\n",
        "1398": "   *\n",
        "1399": "   * <p><i>Performance notes:</i> while the cartesian product of sets of size\n",
        "1400": "   * {@code m, n, p} is a set of size {@code m x n x p}, its actual memory\n",
        "1401": "   * consumption is much smaller. When the cartesian set is constructed, the\n",
        "1402": "   * input sets are merely copied. Only as the resulting set is iterated are the\n",
        "1403": "   * individual lists created, and these are not retained after iteration.\n",
        "1404": "   *\n",
        "1405": "   * @param sets the sets to choose elements from, in the order that\n",
        "1406": "   *     the elements chosen from those sets should appear in the resulting\n",
        "1407": "   *     lists\n",
        "1408": "   * @param <B> any common base class shared by all axes (often just {@link\n",
        "1409": "   *     Object})\n",
        "1410": "   * @return the Cartesian product, as an immutable set containing immutable\n",
        "1411": "   *     lists\n",
        "1412": "   * @throws NullPointerException if {@code sets}, any one of the {@code sets},\n",
        "1413": "   *     or any element of a provided set is null\n",
        "1500": "   * Returns the set of all possible subsets of {@code set}. For example,\n",
        "1501": "   * {@code powerSet(ImmutableSet.of(1, 2))} returns the set {@code {{},\n",
        "1502": "   * {1}, {2}, {1, 2}}}.\n",
        "1504": "   * <p>Elements appear in these subsets in the same iteration order as they\n",
        "1505": "   * appeared in the input set. The order in which these subsets appear in the\n",
        "1506": "   * outer set is undefined. Note that the power set of the empty set is not the\n",
        "1507": "   * empty set, but a one-element set containing the empty set.\n",
        "1509": "   * <p>The returned set and its constituent sets use {@code equals} to decide\n",
        "1510": "   * whether two elements are identical, even if the input set uses a different\n",
        "1511": "   * concept of equivalence.\n",
        "1513": "   * <p><i>Performance notes:</i> while the power set of a set with size {@code\n",
        "1514": "   * n} is of size {@code 2^n}, its memory usage is only {@code O(n)}. When the\n",
        "1515": "   * power set is constructed, the input set is merely copied. Only as the\n",
        "1516": "   * power set is iterated are the individual subsets created, and these subsets\n",
        "1517": "   * themselves occupy only a small constant amount of memory.\n",
        "1521": "   * @throws IllegalArgumentException if {@code set} has more than 30 unique\n",
        "1522": "   *     elements (causing the power set size to exceed the {@code int} range)\n",
        "1524": "   * @see <a href=\"http://en.wikipedia.org/wiki/Power_set\">Power set article at\n",
        "1525": "   *      Wikipedia</a>\n",
        "1763": "  /**\n",
        "1764": "   * An implementation for {@link Set#hashCode()}.\n",
        "1765": "   */\n",
        "1777": "  /**\n",
        "1778": "   * An implementation for {@link Set#equals(Object)}.\n",
        "1779": "   */\n",
        "1797": "   * Returns an unmodifiable view of the specified navigable set. This method\n",
        "1798": "   * allows modules to provide users with \"read-only\" access to internal\n",
        "1799": "   * navigable sets. Query operations on the returned set \"read through\" to the\n",
        "1800": "   * specified set, and attempts to modify the returned set, whether direct or\n",
        "1801": "   * via its collection views, result in an\n",
        "1802": "   * {@code UnsupportedOperationException}.\n",
        "1803": "   *\n",
        "1804": "   * <p>The returned navigable set will be serializable if the specified\n",
        "1805": "   * navigable set is serializable.\n",
        "1806": "   *\n",
        "1807": "   * @param set the navigable set for which an unmodifiable view is to be\n",
        "1808": "   *        returned\n",
        "1924": "   * Returns a synchronized (thread-safe) navigable set backed by the specified\n",
        "1925": "   * navigable set.  In order to guarantee serial access, it is critical that\n",
        "1926": "   * <b>all</b> access to the backing navigable set is accomplished\n",
        "1927": "   * through the returned navigable set (or its views).\n",
        "1928": "   *\n",
        "1929": "   * <p>It is imperative that the user manually synchronize on the returned\n",
        "1930": "   * sorted set when iterating over it or any of its {@code descendingSet},\n",
        "1931": "   * {@code subSet}, {@code headSet}, or {@code tailSet} views. <pre>   {@code\n",
        "1932": "   *\n",
        "1933": "   *   NavigableSet<E> set = synchronizedNavigableSet(new TreeSet<E>());\n",
        "1934": "   *    ...\n",
        "1935": "   *   synchronized (set) {\n",
        "1936": "   *     // Must be in the synchronized block\n",
        "1937": "   *     Iterator<E> it = set.iterator();\n",
        "1938": "   *     while (it.hasNext()) {\n",
        "1939": "   *       foo(it.next());\n",
        "1940": "   *     }\n",
        "1941": "   *   }}</pre>\n",
        "1942": "   *\n",
        "1943": "   * <p>or: <pre>   {@code\n",
        "1944": "   *\n",
        "1945": "   *   NavigableSet<E> set = synchronizedNavigableSet(new TreeSet<E>());\n",
        "1946": "   *   NavigableSet<E> set2 = set.descendingSet().headSet(foo);\n",
        "1947": "   *    ...\n",
        "1948": "   *   synchronized (set) { // Note: set, not set2!!!\n",
        "1949": "   *     // Must be in the synchronized block\n",
        "1950": "   *     Iterator<E> it = set2.descendingIterator();\n",
        "1951": "   *     while (it.hasNext())\n",
        "1952": "   *       foo(it.next());\n",
        "1953": "   *     }\n",
        "1954": "   *   }}</pre>\n",
        "1958": "   * <p>The returned navigable set will be serializable if the specified\n",
        "1959": "   * navigable set is serializable.\n",
        "1961": "   * @param navigableSet the navigable set to be \"wrapped\" in a synchronized\n",
        "1962": "   *    navigable set.\n",
        "1971": "  /**\n",
        "1972": "   * Remove each element in an iterable from a set.\n",
        "1973": "   */\n",
        "2135": "   * <p>This method delegates to the appropriate methods of {@link NavigableSet} (namely\n",
        "2136": "   * {@link NavigableSet#subSet(Object, boolean, Object, boolean) subSet()},\n",
        "2137": "   * {@link NavigableSet#tailSet(Object, boolean) tailSet()}, and\n",
        "2138": "   * {@link NavigableSet#headSet(Object, boolean) headSet()}) to actually construct the view.\n",
        "2139": "   * Consult these methods for a full description of the returned view's behavior.\n",
        "2142": "   * ordering. {@code NavigableSet} on the other hand can specify a custom ordering via a\n",
        "2143": "   * {@link Comparator}, which can violate the natural ordering. Using this method (or in general\n",
        "2144": "   * using {@code Range}) with unnaturally-ordered sets can lead to unexpected and undefined\n",
        "2145": "   * behavior.\n"
    }
}