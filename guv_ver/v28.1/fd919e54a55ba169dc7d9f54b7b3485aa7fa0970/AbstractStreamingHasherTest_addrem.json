{
    "addition": {
        "41": "    byte[] expected = {1, 2, 3, 4, 5, 6, 7, 8};\n",
        "43": "    sink.putBytes(new byte[] {2, 3, 4, 5, 6});\n",
        "46": "    sink.putBytes(new byte[] {8});\n",
        "57": "    sink.assertBytes(new byte[] {1, 2, 0, 0}); // padded with zeros\n",
        "65": "    sink.assertBytes(new byte[] {1, 2, 3, 4});\n",
        "73": "    sink.assertBytes(new byte[] {1, 2, 3, 4, 5, 6, 7, 8});\n",
        "81": "    sink.assertBytes(new byte[] {1, 2, 0, 0}); // padded with zeros\n",
        "94": "          new Sink(4).putUnencodedChars(s).hash(), new Sink(4).putString(s, UTF_16LE).hash());\n",
        "103": "    sink.assertBytes(new byte[] {1, 2, 3, 4});\n",
        "111": "    sink.assertBytes(new byte[] {1, 2, 3, 4, 5, 6, 7, 8});\n",
        "119": "    } catch (IndexOutOfBoundsException ok) {\n",
        "120": "    }\n",
        "124": "    } catch (IndexOutOfBoundsException ok) {\n",
        "125": "    }\n",
        "129": "    } catch (IndexOutOfBoundsException ok) {\n",
        "130": "    }\n",
        "134": "   * This test creates a long random sequence of inputs, then a lot of differently configured sinks\n",
        "135": "   * process it; all should produce the same answer, the only difference should be the number of\n",
        "136": "   * process()/processRemaining() invocations, due to alignment.\n",
        "200": "    @Override\n",
        "201": "    protected HashCode makeHash() {\n",
        "205": "    @Override\n",
        "206": "    protected void process(ByteBuffer bb) {\n",
        "215": "    @Override\n",
        "216": "    protected void processRemaining(ByteBuffer bb) {\n"
    },
    "removed": {
        "41": "    byte[] expected = { 1, 2, 3, 4, 5, 6, 7, 8 };\n",
        "43": "    sink.putBytes(new byte[] { 2, 3, 4, 5, 6 });\n",
        "46": "    sink.putBytes(new byte[] { 8 });\n",
        "57": "    sink.assertBytes(new byte[] { 1, 2, 0, 0 }); // padded with zeros\n",
        "65": "    sink.assertBytes(new byte[] { 1, 2, 3, 4 });\n",
        "73": "    sink.assertBytes(new byte[] { 1, 2, 3, 4, 5, 6, 7, 8 });\n",
        "81": "    sink.assertBytes(new byte[] { 1, 2, 0, 0  }); // padded with zeros\n",
        "94": "          new Sink(4).putUnencodedChars(s).hash(),\n",
        "95": "          new Sink(4).putString(s, UTF_16LE).hash());\n",
        "104": "    sink.assertBytes(new byte[] { 1, 2, 3, 4 });\n",
        "112": "    sink.assertBytes(new byte[] { 1, 2, 3, 4, 5, 6, 7, 8 });\n",
        "120": "    } catch (IndexOutOfBoundsException ok) {}\n",
        "124": "    } catch (IndexOutOfBoundsException ok) {}\n",
        "128": "    } catch (IndexOutOfBoundsException ok) {}\n",
        "132": "   * This test creates a long random sequence of inputs, then a lot of differently configured\n",
        "133": "   * sinks process it; all should produce the same answer, the only difference should be the\n",
        "134": "   * number of process()/processRemaining() invocations, due to alignment.\n",
        "198": "    @Override protected HashCode makeHash() {\n",
        "202": "    @Override protected void process(ByteBuffer bb) {\n",
        "211": "    @Override protected void processRemaining(ByteBuffer bb) {\n"
    }
}