{
    "addition": {
        "46": " * {@link Table} implementation backed by a map that associates row keys with column key / value\n",
        "47": " * secondary maps. This class provides rapid access to records by the row key alone or by both keys,\n",
        "48": " * but not by just the column key.\n",
        "50": " * <p>The views returned by {@link #column}, {@link #columnKeySet()}, and {@link #columnMap()} have\n",
        "51": " * iterators that don't support {@code remove()}. Otherwise, all optional operations are supported.\n",
        "52": " * Null row keys, columns keys, and values are not supported.\n",
        "54": " * <p>Lookups by row key are often faster than lookups by column key, because the data is stored in\n",
        "55": " * a {@code Map<R, Map<C, V>>}. A method call like {@code column(columnKey).get(rowKey)} still runs\n",
        "56": " * quickly, since the row key is provided. However, {@code column(columnKey).size()} takes longer,\n",
        "57": " * since an iteration across all row keys occurs.\n",
        "59": " * <p>Note that this implementation is not synchronized. If multiple threads access this table\n",
        "60": " * concurrently and one of the threads modifies the table, it must be synchronized externally.\n",
        "198": "   * Abstract set whose {@code isEmpty()} returns whether the table is empty and whose {@code\n",
        "199": "   * clear()} clears all table mappings.\n",
        "217": "   * <p>The set's iterator traverses the mappings for the first row, the mappings for the second\n",
        "218": "   * row, and so on.\n",
        "220": "   * <p>Each cell is an immutable snapshot of a row key / column key / value mapping, taken at the\n",
        "221": "   * time the cell is returned by a method call to the set or its iterator.\n",
        "392": "   * <p>The returned map's views have iterators that don't support {@code remove()}.\n",
        "426": "    /** Removes all {@code Column} mappings whose row key and value satisfy the given predicate. */\n",
        "602": "   * <p>The set's iterator traverses the columns of the first row, the columns of the second row,\n",
        "603": "   * etc., skipping any columns that have appeared previously.\n",
        "684": "  /** Creates an iterator that returns each column value with duplicates omitted. */\n",
        "717": "   * <p>The collection's iterator traverses the values for the first row, the values for the second\n",
        "718": "   * row, and so on.\n"
    },
    "removed": {
        "47": " * {@link Table} implementation backed by a map that associates row keys with\n",
        "48": " * column key / value secondary maps. This class provides rapid access to\n",
        "49": " * records by the row key alone or by both keys, but not by just the column key.\n",
        "51": " * <p>The views returned by {@link #column}, {@link #columnKeySet()}, and {@link\n",
        "52": " * #columnMap()} have iterators that don't support {@code remove()}. Otherwise,\n",
        "53": " * all optional operations are supported. Null row keys, columns keys, and\n",
        "54": " * values are not supported.\n",
        "56": " * <p>Lookups by row key are often faster than lookups by column key, because\n",
        "57": " * the data is stored in a {@code Map<R, Map<C, V>>}. A method call like {@code\n",
        "58": " * column(columnKey).get(rowKey)} still runs quickly, since the row key is\n",
        "59": " * provided. However, {@code column(columnKey).size()} takes longer, since an\n",
        "60": " * iteration across all row keys occurs.\n",
        "62": " * <p>Note that this implementation is not synchronized. If multiple threads\n",
        "63": " * access this table concurrently and one of the threads modifies the table, it\n",
        "64": " * must be synchronized externally.\n",
        "202": "   * Abstract set whose {@code isEmpty()} returns whether the table is empty and\n",
        "203": "   * whose {@code clear()} clears all table mappings.\n",
        "221": "   * <p>The set's iterator traverses the mappings for the first row, the\n",
        "222": "   * mappings for the second row, and so on.\n",
        "224": "   * <p>Each cell is an immutable snapshot of a row key / column key / value\n",
        "225": "   * mapping, taken at the time the cell is returned by a method call to the\n",
        "226": "   * set or its iterator.\n",
        "397": "   * <p>The returned map's views have iterators that don't support\n",
        "398": "   * {@code remove()}.\n",
        "432": "    /**\n",
        "433": "     * Removes all {@code Column} mappings whose row key and value satisfy the\n",
        "434": "     * given predicate.\n",
        "435": "     */\n",
        "611": "   * <p>The set's iterator traverses the columns of the first row, the\n",
        "612": "   * columns of the second row, etc., skipping any columns that have\n",
        "613": "   * appeared previously.\n",
        "694": "  /**\n",
        "695": "   * Creates an iterator that returns each column value with duplicates\n",
        "696": "   * omitted.\n",
        "697": "   */\n",
        "730": "   * <p>The collection's iterator traverses the values for the first row,\n",
        "731": "   * the values for the second row, and so on.\n"
    }
}