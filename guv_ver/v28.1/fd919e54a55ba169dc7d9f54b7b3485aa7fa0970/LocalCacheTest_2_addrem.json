{
    "addition": {
        "80": "/** @author Charles Fry */\n",
        "103": "    suite.addTest(\n",
        "104": "        MapTestSuiteBuilder.using(new TestStringCacheGenerator(createCacheBuilder()))\n",
        "105": "            .named(\"LocalCache with defaults\")\n",
        "106": "            .withFeatures(\n",
        "107": "                CollectionSize.ANY,\n",
        "108": "                MapFeature.GENERAL_PURPOSE,\n",
        "109": "                CollectionFeature.SUPPORTS_ITERATOR_REMOVE)\n",
        "110": "            .createTestSuite());\n",
        "111": "    suite.addTest(\n",
        "112": "        MapTestSuiteBuilder.using(\n",
        "113": "                new TestStringCacheGenerator(createCacheBuilder().concurrencyLevel(1)))\n",
        "114": "            .named(\"LocalCache with concurrencyLevel[1]\")\n",
        "115": "            .withFeatures(\n",
        "116": "                CollectionSize.ANY,\n",
        "117": "                MapFeature.GENERAL_PURPOSE,\n",
        "118": "                CollectionFeature.SUPPORTS_ITERATOR_REMOVE)\n",
        "119": "            .createTestSuite());\n",
        "120": "    suite.addTest(\n",
        "121": "        MapTestSuiteBuilder.using(\n",
        "122": "                new TestStringCacheGenerator(createCacheBuilder().maximumSize(Integer.MAX_VALUE)))\n",
        "123": "            .named(\"LocalCache with maximumSize\")\n",
        "124": "            .withFeatures(\n",
        "125": "                CollectionSize.ANY,\n",
        "126": "                MapFeature.GENERAL_PURPOSE,\n",
        "127": "                CollectionFeature.SUPPORTS_ITERATOR_REMOVE)\n",
        "128": "            .createTestSuite());\n",
        "129": "    suite.addTest(\n",
        "130": "        MapTestSuiteBuilder.using(\n",
        "131": "                new TestStringCacheGenerator(\n",
        "132": "                    createCacheBuilder()\n",
        "133": "                        .maximumWeight(Integer.MAX_VALUE)\n",
        "134": "                        .weigher(new SerializableWeigher<String, String>())))\n",
        "135": "            .named(\"LocalCache with maximumWeight\")\n",
        "136": "            .withFeatures(\n",
        "137": "                CollectionSize.ANY,\n",
        "138": "                MapFeature.GENERAL_PURPOSE,\n",
        "139": "                CollectionFeature.SUPPORTS_ITERATOR_REMOVE)\n",
        "140": "            .createTestSuite());\n",
        "141": "    suite.addTest(\n",
        "142": "        MapTestSuiteBuilder.using(new TestStringCacheGenerator(createCacheBuilder().weakKeys()))\n",
        "143": "            .named(\"LocalCache with weakKeys\") // keys are string literals and won't be GC'd\n",
        "144": "            .withFeatures(\n",
        "145": "                CollectionSize.ANY,\n",
        "146": "                MapFeature.GENERAL_PURPOSE,\n",
        "147": "                CollectionFeature.SUPPORTS_ITERATOR_REMOVE)\n",
        "148": "            .createTestSuite());\n",
        "149": "    suite.addTest(\n",
        "150": "        MapTestSuiteBuilder.using(new TestStringCacheGenerator(createCacheBuilder().weakValues()))\n",
        "151": "            .named(\"LocalCache with weakValues\") // values are string literals and won't be GC'd\n",
        "152": "            .withFeatures(\n",
        "153": "                CollectionSize.ANY,\n",
        "154": "                MapFeature.GENERAL_PURPOSE,\n",
        "155": "                CollectionFeature.SUPPORTS_ITERATOR_REMOVE)\n",
        "156": "            .createTestSuite());\n",
        "157": "    suite.addTest(\n",
        "158": "        MapTestSuiteBuilder.using(new TestStringCacheGenerator(createCacheBuilder().softValues()))\n",
        "159": "            .named(\"LocalCache with softValues\") // values are string literals and won't be GC'd\n",
        "160": "            .withFeatures(\n",
        "161": "                CollectionSize.ANY,\n",
        "162": "                MapFeature.GENERAL_PURPOSE,\n",
        "163": "                CollectionFeature.SUPPORTS_ITERATOR_REMOVE)\n",
        "164": "            .createTestSuite());\n",
        "165": "    suite.addTest(\n",
        "166": "        MapTestSuiteBuilder.using(\n",
        "167": "                new TestStringCacheGenerator(\n",
        "168": "                    createCacheBuilder()\n",
        "169": "                        .expireAfterAccess(1, SECONDS)\n",
        "170": "                        .ticker(new SerializableTicker())))\n",
        "171": "            .named(\"LocalCache with expireAfterAccess\") // SerializableTicker never advances\n",
        "172": "            .withFeatures(\n",
        "173": "                CollectionSize.ANY,\n",
        "174": "                MapFeature.GENERAL_PURPOSE,\n",
        "175": "                CollectionFeature.SUPPORTS_ITERATOR_REMOVE)\n",
        "176": "            .createTestSuite());\n",
        "177": "    suite.addTest(\n",
        "178": "        MapTestSuiteBuilder.using(\n",
        "179": "                new TestStringCacheGenerator(\n",
        "180": "                    createCacheBuilder()\n",
        "181": "                        .expireAfterWrite(1, SECONDS)\n",
        "182": "                        .ticker(new SerializableTicker())))\n",
        "183": "            .named(\"LocalCache with expireAfterWrite\") // SerializableTicker never advances\n",
        "184": "            .withFeatures(\n",
        "185": "                CollectionSize.ANY,\n",
        "186": "                MapFeature.GENERAL_PURPOSE,\n",
        "187": "                CollectionFeature.SUPPORTS_ITERATOR_REMOVE)\n",
        "188": "            .createTestSuite());\n",
        "189": "    suite.addTest(\n",
        "190": "        MapTestSuiteBuilder.using(\n",
        "191": "                new TestStringCacheGenerator(\n",
        "192": "                    createCacheBuilder()\n",
        "193": "                        .removalListener(new SerializableRemovalListener<String, String>())))\n",
        "194": "            .named(\"LocalCache with removalListener\")\n",
        "195": "            .withFeatures(\n",
        "196": "                CollectionSize.ANY,\n",
        "197": "                MapFeature.GENERAL_PURPOSE,\n",
        "198": "                CollectionFeature.SUPPORTS_ITERATOR_REMOVE)\n",
        "199": "            .createTestSuite());\n",
        "200": "    suite.addTest(\n",
        "201": "        MapTestSuiteBuilder.using(new TestStringCacheGenerator(createCacheBuilder().recordStats()))\n",
        "202": "            .named(\"LocalCache with recordStats\")\n",
        "203": "            .withFeatures(\n",
        "204": "                CollectionSize.ANY,\n",
        "205": "                MapFeature.GENERAL_PURPOSE,\n",
        "206": "                CollectionFeature.SUPPORTS_ITERATOR_REMOVE)\n",
        "207": "            .createTestSuite());\n",
        "288": "    Equivalence<Object> testEquivalence =\n",
        "289": "        new Equivalence<Object>() {\n",
        "290": "          @Override\n",
        "291": "          protected boolean doEquivalent(Object a, Object b) {\n",
        "292": "            return false;\n",
        "293": "          }\n",
        "295": "          @Override\n",
        "296": "          protected int doHash(Object t) {\n",
        "297": "            return 0;\n",
        "298": "          }\n",
        "299": "        };\n",
        "308": "    Equivalence<Object> testEquivalence =\n",
        "309": "        new Equivalence<Object>() {\n",
        "310": "          @Override\n",
        "311": "          protected boolean doEquivalent(Object a, Object b) {\n",
        "312": "            return false;\n",
        "313": "          }\n",
        "315": "          @Override\n",
        "316": "          protected int doHash(Object t) {\n",
        "317": "            return 0;\n",
        "318": "          }\n",
        "319": "        };\n",
        "382": "    LocalCache<Object, Object> map =\n",
        "383": "        makeLocalCache(\n",
        "384": "            createCacheBuilder()\n",
        "385": "                .concurrencyLevel(concurrencyLevel)\n",
        "386": "                .initialCapacity(initialCapacity));\n",
        "418": "    LocalCache<Object, Object> map =\n",
        "419": "        makeLocalCache(\n",
        "420": "            createCacheBuilder()\n",
        "421": "                .concurrencyLevel(concurrencyLevel)\n",
        "422": "                .initialCapacity(initialCapacity)\n",
        "423": "                .maximumSize(maxSize));\n",
        "425": "    assertTrue(\n",
        "426": "        \"segments=\" + map.segments.length + \", maxSize=\" + maxSize,\n",
        "433": "    map =\n",
        "434": "        makeLocalCache(\n",
        "435": "            createCacheBuilder()\n",
        "436": "                .concurrencyLevel(concurrencyLevel)\n",
        "437": "                .initialCapacity(initialCapacity)\n",
        "438": "                .maximumWeight(maxSize)\n",
        "439": "                .weigher(constantWeigher(1)));\n",
        "440": "    assertTrue(\n",
        "441": "        \"segments=\" + map.segments.length + \", maxSize=\" + maxSize,\n",
        "451": "    Weigher<Object, Object> testWeigher =\n",
        "452": "        new Weigher<Object, Object>() {\n",
        "453": "          @Override\n",
        "454": "          public int weigh(Object key, Object value) {\n",
        "455": "            return 42;\n",
        "456": "          }\n",
        "457": "        };\n",
        "521": "    Ticker testTicker =\n",
        "522": "        new Ticker() {\n",
        "523": "          @Override\n",
        "524": "          public long read() {\n",
        "525": "            return 0;\n",
        "526": "          }\n",
        "527": "        };\n",
        "533": "    assertSame(EntryFactory.STRONG, EntryFactory.getFactory(Strength.STRONG, false, false));\n",
        "534": "    assertSame(EntryFactory.STRONG_ACCESS, EntryFactory.getFactory(Strength.STRONG, true, false));\n",
        "535": "    assertSame(EntryFactory.STRONG_WRITE, EntryFactory.getFactory(Strength.STRONG, false, true));\n",
        "536": "    assertSame(\n",
        "537": "        EntryFactory.STRONG_ACCESS_WRITE, EntryFactory.getFactory(Strength.STRONG, true, true));\n",
        "538": "    assertSame(EntryFactory.WEAK, EntryFactory.getFactory(Strength.WEAK, false, false));\n",
        "539": "    assertSame(EntryFactory.WEAK_ACCESS, EntryFactory.getFactory(Strength.WEAK, true, false));\n",
        "540": "    assertSame(EntryFactory.WEAK_WRITE, EntryFactory.getFactory(Strength.WEAK, false, true));\n",
        "541": "    assertSame(EntryFactory.WEAK_ACCESS_WRITE, EntryFactory.getFactory(Strength.WEAK, true, true));\n",
        "561": "      LocalCache<Object, Object> map = makeLocalCache(builder.concurrencyLevel(1));\n",
        "674": "    CacheBuilder<Object, Object> builder =\n",
        "675": "        createCacheBuilder().expireAfterWrite(1, TimeUnit.NANOSECONDS);\n",
        "705": "    final CacheLoader<Object, Object> loader =\n",
        "706": "        new CacheLoader<Object, Object>() {\n",
        "707": "          @Override\n",
        "708": "          public Object load(Object key) throws Exception {\n",
        "709": "            computingSignal.countDown();\n",
        "710": "            startSignal.await();\n",
        "711": "            return computedObject;\n",
        "712": "          }\n",
        "713": "        };\n",
        "716": "    CacheBuilder<Object, Object> builder =\n",
        "717": "        createCacheBuilder().concurrencyLevel(1).removalListener(listener);\n",
        "782": "    RemovalListener<Object, Object> listener =\n",
        "783": "        new RemovalListener<Object, Object>() {\n",
        "784": "          @Override\n",
        "785": "          public void onRemoval(RemovalNotification<Object, Object> notification) {\n",
        "786": "            throw e;\n",
        "787": "          }\n",
        "788": "        };\n",
        "806": "    final CacheLoader<Object, Object> loader =\n",
        "807": "        new CacheLoader<Object, Object>() {\n",
        "808": "          @Override\n",
        "809": "          public Object load(Object key) throws Exception {\n",
        "810": "            computingSignal.countDown();\n",
        "811": "            startSignal.await();\n",
        "812": "            return computedObject;\n",
        "813": "          }\n",
        "814": "        };\n",
        "858": "    LocalCache<Object, Object> map = makeLocalCache(createCacheBuilder().concurrencyLevel(1));\n",
        "879": "    LocalCache<Object, Object> map = makeLocalCache(createCacheBuilder().removalListener(listener));\n",
        "920": "    LocalCache<Object, Object> map = makeLocalCache(createCacheBuilder().removalListener(listener));\n",
        "947": "    LocalCache<Object, Object> map =\n",
        "948": "        makeLocalCache(\n",
        "949": "            createCacheBuilder().concurrencyLevel(1).softValues().removalListener(listener));\n",
        "972": "    LocalCache<Object, Object> map =\n",
        "973": "        makeLocalCache(\n",
        "974": "            createCacheBuilder()\n",
        "975": "                .concurrencyLevel(1)\n",
        "976": "                .expireAfterWrite(3, TimeUnit.NANOSECONDS)\n",
        "977": "                .ticker(ticker)\n",
        "978": "                .removalListener(listener));\n",
        "1002": "    LocalCache<Object, Object> map =\n",
        "1003": "        makeLocalCache(\n",
        "1004": "            createCacheBuilder().concurrencyLevel(1).maximumSize(2).removalListener(listener));\n",
        "1114": "    LocalCache<Object, Object> map =\n",
        "1115": "        makeLocalCache(\n",
        "1116": "            createCacheBuilder()\n",
        "1117": "                .concurrencyLevel(1)\n",
        "1118": "                .ticker(ticker)\n",
        "1119": "                .expireAfterAccess(1, TimeUnit.NANOSECONDS));\n",
        "1379": "    LocalCache<Object, Object> map =\n",
        "1380": "        makeLocalCache(createCacheBuilder().concurrencyLevel(1).removalListener(listener));\n",
        "1584": "        segment.get(\n",
        "1585": "            key,\n",
        "1586": "            key.hashCode(),\n",
        "1587": "            new CacheLoader<Object, Object>() {\n",
        "1588": "              @Override\n",
        "1589": "              public Object load(Object key) {\n",
        "1590": "                return value;\n",
        "1591": "              }\n",
        "1592": "            });\n",
        "1630": "    LocalCache<Object, Object> map =\n",
        "1631": "        makeLocalCache(\n",
        "1632": "            createCacheBuilder()\n",
        "1633": "                .concurrencyLevel(1)\n",
        "1634": "                .initialCapacity(1)\n",
        "1635": "                .maximumSize(SMALL_MAX_SIZE)\n",
        "1636": "                .expireAfterWrite(99999, SECONDS)\n",
        "1637": "                .removalListener(listener));\n",
        "1655": "        createDummyEntry(keyThree, hashThree, valueThree, entryTwo);\n",
        "1699": "        createDummyEntry(keyThree, hashThree, valueThree, entryTwo);\n",
        "1822": "    LocalCache<Object, Object> map =\n",
        "1823": "        makeLocalCache(\n",
        "1824": "            createCacheBuilder()\n",
        "1825": "                .concurrencyLevel(1)\n",
        "1826": "                .initialCapacity(1)\n",
        "1827": "                .maximumSize(SMALL_MAX_SIZE)\n",
        "1828": "                .expireAfterWrite(99999, SECONDS));\n",
        "1858": "    LocalCache<Object, Object> map =\n",
        "1859": "        makeLocalCache(\n",
        "1860": "            createCacheBuilder()\n",
        "1861": "                .concurrencyLevel(1)\n",
        "1862": "                .initialCapacity(1)\n",
        "1863": "                .maximumSize(SMALL_MAX_SIZE)\n",
        "1864": "                .expireAfterWrite(99999, SECONDS)\n",
        "1865": "                .removalListener(listener));\n",
        "1895": "    LocalCache<Object, Object> map =\n",
        "1896": "        makeLocalCache(\n",
        "1897": "            createCacheBuilder()\n",
        "1898": "                .concurrencyLevel(1)\n",
        "1899": "                .initialCapacity(1)\n",
        "1900": "                .maximumSize(SMALL_MAX_SIZE)\n",
        "1901": "                .expireAfterWrite(99999, SECONDS)\n",
        "1902": "                .removalListener(countingRemovalListener()));\n",
        "1929": "    CountingRemovalListener<Object, Object> listener = countingRemovalListener();\n",
        "1930": "    LocalCache<Object, Object> map =\n",
        "1931": "        makeLocalCache(\n",
        "1932": "            createCacheBuilder()\n",
        "1933": "                .concurrencyLevel(1)\n",
        "1934": "                .initialCapacity(1)\n",
        "1935": "                .maximumSize(SMALL_MAX_SIZE)\n",
        "1936": "                .expireAfterWrite(99999, SECONDS)\n",
        "1937": "                .removalListener(listener));\n",
        "1979": "    LocalCache<Object, Object> map =\n",
        "1980": "        makeLocalCache(\n",
        "1981": "            createCacheBuilder()\n",
        "1982": "                .concurrencyLevel(1)\n",
        "1983": "                .initialCapacity(1)\n",
        "1984": "                .maximumSize(SMALL_MAX_SIZE)\n",
        "1985": "                .expireAfterWrite(99999, SECONDS)\n",
        "1986": "                .removalListener(countingRemovalListener()));\n",
        "2229": "  static <K, V> void checkAndDrainRecencyQueue(\n",
        "2230": "      LocalCache<K, V> map, Segment<K, V> segment, List<ReferenceEntry<K, V>> reads) {\n",
        "2237": "  static <K, V> void checkEvictionQueues(\n",
        "2238": "      LocalCache<K, V> map,\n",
        "2239": "      Segment<K, V> segment,\n",
        "2240": "      List<ReferenceEntry<K, V>> readOrder,\n",
        "2250": "  private static <K, V> void assertSameEntries(\n",
        "2251": "      List<ReferenceEntry<K, V>> expectedEntries, List<ReferenceEntry<K, V>> actualEntries) {\n",
        "2296": "    LocalCache<Object, Object> map =\n",
        "2297": "        makeLocalCache(\n",
        "2298": "            createCacheBuilder()\n",
        "2299": "                .concurrencyLevel(1)\n",
        "2300": "                .ticker(ticker)\n",
        "2301": "                .expireAfterWrite(2, TimeUnit.NANOSECONDS));\n",
        "2337": "    LocalCache<Object, Object> map =\n",
        "2338": "        makeLocalCache(\n",
        "2339": "            createCacheBuilder()\n",
        "2340": "                .concurrencyLevel(1)\n",
        "2341": "                .ticker(ticker)\n",
        "2342": "                .expireAfterAccess(2, TimeUnit.NANOSECONDS));\n",
        "2434": "      LocalCache<Object, Object> map = makeLocalCache(builder.concurrencyLevel(1));\n",
        "2463": "      LocalCache<Object, Object> map = makeLocalCache(builder.concurrencyLevel(1));\n",
        "2493": "      LocalCache<Object, Object> map = makeLocalCache(builder.concurrencyLevel(1));\n",
        "2523": "      LocalCache<Object, Object> map = makeLocalCache(builder.concurrencyLevel(1));\n",
        "2565": "    LocalLoadingCache<Object, Object> one =\n",
        "2566": "        (LocalLoadingCache)\n",
        "2567": "            CacheBuilder.newBuilder()\n",
        "2568": "                .weakKeys()\n",
        "2569": "                .softValues()\n",
        "2570": "                .expireAfterAccess(123, SECONDS)\n",
        "2571": "                .expireAfterWrite(456, MINUTES)\n",
        "2572": "                .maximumWeight(789)\n",
        "2573": "                .weigher(weigher)\n",
        "2574": "                .concurrencyLevel(12)\n",
        "2575": "                .removalListener(listener)\n",
        "2576": "                .ticker(ticker)\n",
        "2577": "                .build(loader);\n",
        "2623": "    LocalManualCache<Object, Object> one =\n",
        "2624": "        (LocalManualCache)\n",
        "2625": "            CacheBuilder.newBuilder()\n",
        "2626": "                .weakKeys()\n",
        "2627": "                .softValues()\n",
        "2628": "                .expireAfterAccess(123, NANOSECONDS)\n",
        "2629": "                .maximumWeight(789)\n",
        "2630": "                .weigher(weigher)\n",
        "2631": "                .concurrencyLevel(12)\n",
        "2632": "                .removalListener(listener)\n",
        "2633": "                .ticker(ticker)\n",
        "2634": "                .build();\n",
        "2681": "    List<CacheBuilder<Object, Object>> result = newArrayList(allKeyValueStrengthMakers());\n",
        "2700": "  /** Returns an iterable containing all combinations of maximumSize and expireAfterAccess/Write. */\n",
        "2703": "    return ImmutableList.of(\n",
        "2704": "        createCacheBuilder().maximumSize(SMALL_MAX_SIZE),\n",
        "2715": "  /** Returns an iterable containing all combinations weakKeys and weak/softValues. */\n",
        "2718": "    return ImmutableList.of(\n",
        "2719": "        createCacheBuilder(),\n",
        "2924": "  private static class SerializableCacheLoader extends CacheLoader<Object, Object>\n",
        "2925": "      implements Serializable {\n"
    },
    "removed": {
        "80": "/**\n",
        "81": " * @author Charles Fry\n",
        "82": " */\n",
        "105": "    suite.addTest(MapTestSuiteBuilder\n",
        "106": "        .using(new TestStringCacheGenerator(createCacheBuilder()))\n",
        "107": "        .named(\"LocalCache with defaults\")\n",
        "108": "        .withFeatures(CollectionSize.ANY, MapFeature.GENERAL_PURPOSE,\n",
        "109": "            CollectionFeature.SUPPORTS_ITERATOR_REMOVE)\n",
        "110": "        .createTestSuite());\n",
        "111": "    suite.addTest(MapTestSuiteBuilder\n",
        "112": "        .using(new TestStringCacheGenerator(\n",
        "113": "            createCacheBuilder().concurrencyLevel(1)))\n",
        "114": "        .named(\"LocalCache with concurrencyLevel[1]\")\n",
        "115": "        .withFeatures(CollectionSize.ANY, MapFeature.GENERAL_PURPOSE,\n",
        "116": "            CollectionFeature.SUPPORTS_ITERATOR_REMOVE)\n",
        "117": "        .createTestSuite());\n",
        "118": "    suite.addTest(MapTestSuiteBuilder\n",
        "119": "        .using(new TestStringCacheGenerator(\n",
        "120": "            createCacheBuilder().maximumSize(Integer.MAX_VALUE)))\n",
        "121": "        .named(\"LocalCache with maximumSize\")\n",
        "122": "        .withFeatures(CollectionSize.ANY, MapFeature.GENERAL_PURPOSE,\n",
        "123": "            CollectionFeature.SUPPORTS_ITERATOR_REMOVE)\n",
        "124": "        .createTestSuite());\n",
        "125": "    suite.addTest(MapTestSuiteBuilder\n",
        "126": "        .using(new TestStringCacheGenerator(\n",
        "127": "            createCacheBuilder()\n",
        "128": "                .maximumWeight(Integer.MAX_VALUE)\n",
        "129": "                .weigher(new SerializableWeigher<String, String>())))\n",
        "130": "        .named(\"LocalCache with maximumWeight\")\n",
        "131": "        .withFeatures(CollectionSize.ANY, MapFeature.GENERAL_PURPOSE,\n",
        "132": "            CollectionFeature.SUPPORTS_ITERATOR_REMOVE)\n",
        "133": "        .createTestSuite());\n",
        "134": "    suite.addTest(MapTestSuiteBuilder\n",
        "135": "        .using(new TestStringCacheGenerator(\n",
        "136": "            createCacheBuilder().weakKeys()))\n",
        "137": "        .named(\"LocalCache with weakKeys\") // keys are string literals and won't be GC'd\n",
        "138": "        .withFeatures(CollectionSize.ANY, MapFeature.GENERAL_PURPOSE,\n",
        "139": "            CollectionFeature.SUPPORTS_ITERATOR_REMOVE)\n",
        "140": "        .createTestSuite());\n",
        "141": "    suite.addTest(MapTestSuiteBuilder\n",
        "142": "        .using(new TestStringCacheGenerator(\n",
        "143": "            createCacheBuilder().weakValues()))\n",
        "144": "        .named(\"LocalCache with weakValues\") // values are string literals and won't be GC'd\n",
        "145": "        .withFeatures(CollectionSize.ANY, MapFeature.GENERAL_PURPOSE,\n",
        "146": "            CollectionFeature.SUPPORTS_ITERATOR_REMOVE)\n",
        "147": "        .createTestSuite());\n",
        "148": "    suite.addTest(MapTestSuiteBuilder\n",
        "149": "        .using(new TestStringCacheGenerator(\n",
        "150": "            createCacheBuilder().softValues()))\n",
        "151": "        .named(\"LocalCache with softValues\") // values are string literals and won't be GC'd\n",
        "152": "        .withFeatures(CollectionSize.ANY, MapFeature.GENERAL_PURPOSE,\n",
        "153": "            CollectionFeature.SUPPORTS_ITERATOR_REMOVE)\n",
        "154": "        .createTestSuite());\n",
        "155": "    suite.addTest(MapTestSuiteBuilder\n",
        "156": "        .using(new TestStringCacheGenerator(\n",
        "157": "            createCacheBuilder().expireAfterAccess(1, SECONDS).ticker(new SerializableTicker())))\n",
        "158": "        .named(\"LocalCache with expireAfterAccess\") // SerializableTicker never advances\n",
        "159": "        .withFeatures(CollectionSize.ANY, MapFeature.GENERAL_PURPOSE,\n",
        "160": "            CollectionFeature.SUPPORTS_ITERATOR_REMOVE)\n",
        "161": "        .createTestSuite());\n",
        "162": "    suite.addTest(MapTestSuiteBuilder\n",
        "163": "        .using(new TestStringCacheGenerator(\n",
        "164": "            createCacheBuilder().expireAfterWrite(1, SECONDS).ticker(new SerializableTicker())))\n",
        "165": "        .named(\"LocalCache with expireAfterWrite\") // SerializableTicker never advances\n",
        "166": "        .withFeatures(CollectionSize.ANY, MapFeature.GENERAL_PURPOSE,\n",
        "167": "            CollectionFeature.SUPPORTS_ITERATOR_REMOVE)\n",
        "168": "        .createTestSuite());\n",
        "169": "    suite.addTest(MapTestSuiteBuilder\n",
        "170": "        .using(new TestStringCacheGenerator(\n",
        "171": "            createCacheBuilder()\n",
        "172": "                .removalListener(new SerializableRemovalListener<String, String>())))\n",
        "173": "        .named(\"LocalCache with removalListener\")\n",
        "174": "        .withFeatures(CollectionSize.ANY, MapFeature.GENERAL_PURPOSE,\n",
        "175": "            CollectionFeature.SUPPORTS_ITERATOR_REMOVE)\n",
        "176": "        .createTestSuite());\n",
        "177": "    suite.addTest(MapTestSuiteBuilder\n",
        "178": "        .using(new TestStringCacheGenerator(createCacheBuilder().recordStats()))\n",
        "179": "        .named(\"LocalCache with recordStats\")\n",
        "180": "        .withFeatures(CollectionSize.ANY, MapFeature.GENERAL_PURPOSE,\n",
        "181": "            CollectionFeature.SUPPORTS_ITERATOR_REMOVE)\n",
        "182": "        .createTestSuite());\n",
        "263": "    Equivalence<Object> testEquivalence = new Equivalence<Object>() {\n",
        "264": "      @Override\n",
        "265": "      protected boolean doEquivalent(Object a, Object b) {\n",
        "266": "        return false;\n",
        "267": "      }\n",
        "269": "      @Override\n",
        "270": "      protected int doHash(Object t) {\n",
        "271": "        return 0;\n",
        "272": "      }\n",
        "273": "    };\n",
        "282": "    Equivalence<Object> testEquivalence = new Equivalence<Object>() {\n",
        "283": "      @Override\n",
        "284": "      protected boolean doEquivalent(Object a, Object b) {\n",
        "285": "        return false;\n",
        "286": "      }\n",
        "288": "      @Override\n",
        "289": "      protected int doHash(Object t) {\n",
        "290": "        return 0;\n",
        "291": "      }\n",
        "292": "    };\n",
        "355": "    LocalCache<Object, Object> map = makeLocalCache(\n",
        "356": "        createCacheBuilder().concurrencyLevel(concurrencyLevel).initialCapacity(initialCapacity));\n",
        "388": "    LocalCache<Object, Object> map = makeLocalCache(createCacheBuilder()\n",
        "389": "        .concurrencyLevel(concurrencyLevel)\n",
        "390": "        .initialCapacity(initialCapacity)\n",
        "391": "        .maximumSize(maxSize));\n",
        "393": "    assertTrue(\"segments=\" + map.segments.length + \", maxSize=\" + maxSize,\n",
        "400": "    map = makeLocalCache(createCacheBuilder()\n",
        "401": "        .concurrencyLevel(concurrencyLevel)\n",
        "402": "        .initialCapacity(initialCapacity)\n",
        "403": "        .maximumWeight(maxSize)\n",
        "404": "        .weigher(constantWeigher(1)));\n",
        "405": "    assertTrue(\"segments=\" + map.segments.length + \", maxSize=\" + maxSize,\n",
        "415": "    Weigher<Object, Object> testWeigher = new Weigher<Object, Object>() {\n",
        "416": "      @Override\n",
        "417": "      public int weigh(Object key, Object value) {\n",
        "418": "        return 42;\n",
        "419": "      }\n",
        "420": "    };\n",
        "484": "    Ticker testTicker = new Ticker() {\n",
        "485": "      @Override\n",
        "486": "      public long read() {\n",
        "487": "        return 0;\n",
        "488": "      }\n",
        "489": "    };\n",
        "495": "    assertSame(EntryFactory.STRONG,\n",
        "496": "        EntryFactory.getFactory(Strength.STRONG, false, false));\n",
        "497": "    assertSame(EntryFactory.STRONG_ACCESS,\n",
        "498": "        EntryFactory.getFactory(Strength.STRONG, true, false));\n",
        "499": "    assertSame(EntryFactory.STRONG_WRITE,\n",
        "500": "        EntryFactory.getFactory(Strength.STRONG, false, true));\n",
        "501": "    assertSame(EntryFactory.STRONG_ACCESS_WRITE,\n",
        "502": "        EntryFactory.getFactory(Strength.STRONG, true, true));\n",
        "503": "    assertSame(EntryFactory.WEAK,\n",
        "504": "        EntryFactory.getFactory(Strength.WEAK, false, false));\n",
        "505": "    assertSame(EntryFactory.WEAK_ACCESS,\n",
        "506": "        EntryFactory.getFactory(Strength.WEAK, true, false));\n",
        "507": "    assertSame(EntryFactory.WEAK_WRITE,\n",
        "508": "        EntryFactory.getFactory(Strength.WEAK, false, true));\n",
        "509": "    assertSame(EntryFactory.WEAK_ACCESS_WRITE,\n",
        "510": "        EntryFactory.getFactory(Strength.WEAK, true, true));\n",
        "530": "      LocalCache<Object, Object> map =\n",
        "531": "          makeLocalCache(builder.concurrencyLevel(1));\n",
        "644": "    CacheBuilder<Object, Object> builder = createCacheBuilder()\n",
        "645": "        .expireAfterWrite(1, TimeUnit.NANOSECONDS);\n",
        "675": "    final CacheLoader<Object, Object> loader = new CacheLoader<Object, Object>() {\n",
        "676": "      @Override\n",
        "677": "      public Object load(Object key) throws Exception {\n",
        "678": "        computingSignal.countDown();\n",
        "679": "        startSignal.await();\n",
        "680": "        return computedObject;\n",
        "681": "      }\n",
        "682": "    };\n",
        "685": "    CacheBuilder<Object, Object> builder = createCacheBuilder()\n",
        "686": "        .concurrencyLevel(1)\n",
        "687": "        .removalListener(listener);\n",
        "752": "    RemovalListener<Object, Object> listener = new RemovalListener<Object, Object>() {\n",
        "753": "      @Override\n",
        "754": "      public void onRemoval(RemovalNotification<Object, Object> notification) {\n",
        "755": "        throw e;\n",
        "756": "      }\n",
        "757": "    };\n",
        "775": "    final CacheLoader<Object, Object> loader = new CacheLoader<Object, Object>() {\n",
        "776": "      @Override\n",
        "777": "      public Object load(Object key) throws Exception {\n",
        "778": "        computingSignal.countDown();\n",
        "779": "        startSignal.await();\n",
        "780": "        return computedObject;\n",
        "781": "      }\n",
        "782": "    };\n",
        "826": "    LocalCache<Object, Object> map = makeLocalCache(createCacheBuilder()\n",
        "827": "        .concurrencyLevel(1));\n",
        "848": "    LocalCache<Object, Object> map = makeLocalCache(createCacheBuilder()\n",
        "849": "        .removalListener(listener));\n",
        "890": "    LocalCache<Object, Object> map = makeLocalCache(createCacheBuilder()\n",
        "891": "        .removalListener(listener));\n",
        "918": "    LocalCache<Object, Object> map = makeLocalCache(createCacheBuilder()\n",
        "919": "        .concurrencyLevel(1)\n",
        "920": "        .softValues()\n",
        "921": "        .removalListener(listener));\n",
        "944": "    LocalCache<Object, Object> map = makeLocalCache(createCacheBuilder()\n",
        "945": "        .concurrencyLevel(1)\n",
        "946": "        .expireAfterWrite(3, TimeUnit.NANOSECONDS)\n",
        "947": "        .ticker(ticker)\n",
        "948": "        .removalListener(listener));\n",
        "972": "    LocalCache<Object, Object> map = makeLocalCache(createCacheBuilder()\n",
        "973": "        .concurrencyLevel(1)\n",
        "974": "        .maximumSize(2)\n",
        "975": "        .removalListener(listener));\n",
        "1085": "    LocalCache<Object, Object> map = makeLocalCache(createCacheBuilder()\n",
        "1086": "        .concurrencyLevel(1)\n",
        "1087": "        .ticker(ticker)\n",
        "1088": "        .expireAfterAccess(1, TimeUnit.NANOSECONDS));\n",
        "1348": "    LocalCache<Object, Object> map = makeLocalCache(createCacheBuilder()\n",
        "1349": "        .concurrencyLevel(1)\n",
        "1350": "        .removalListener(listener));\n",
        "1554": "        segment.get(key, key.hashCode(), new CacheLoader<Object, Object>() {\n",
        "1555": "          @Override\n",
        "1556": "          public Object load(Object key) {\n",
        "1557": "            return value;\n",
        "1558": "          }\n",
        "1559": "        });\n",
        "1597": "    LocalCache<Object, Object> map = makeLocalCache(createCacheBuilder()\n",
        "1598": "        .concurrencyLevel(1)\n",
        "1599": "        .initialCapacity(1)\n",
        "1600": "        .maximumSize(SMALL_MAX_SIZE)\n",
        "1601": "        .expireAfterWrite(99999, SECONDS)\n",
        "1602": "        .removalListener(listener));\n",
        "1620": "      createDummyEntry(keyThree, hashThree, valueThree, entryTwo);\n",
        "1664": "      createDummyEntry(keyThree, hashThree, valueThree, entryTwo);\n",
        "1787": "    LocalCache<Object, Object> map = makeLocalCache(createCacheBuilder()\n",
        "1788": "        .concurrencyLevel(1)\n",
        "1789": "        .initialCapacity(1)\n",
        "1790": "        .maximumSize(SMALL_MAX_SIZE)\n",
        "1791": "        .expireAfterWrite(99999, SECONDS));\n",
        "1821": "    LocalCache<Object, Object> map = makeLocalCache(createCacheBuilder()\n",
        "1822": "        .concurrencyLevel(1)\n",
        "1823": "        .initialCapacity(1)\n",
        "1824": "        .maximumSize(SMALL_MAX_SIZE)\n",
        "1825": "        .expireAfterWrite(99999, SECONDS)\n",
        "1826": "        .removalListener(listener));\n",
        "1856": "    LocalCache<Object, Object> map = makeLocalCache(createCacheBuilder()\n",
        "1857": "        .concurrencyLevel(1)\n",
        "1858": "        .initialCapacity(1)\n",
        "1859": "        .maximumSize(SMALL_MAX_SIZE)\n",
        "1860": "        .expireAfterWrite(99999, SECONDS)\n",
        "1861": "        .removalListener(countingRemovalListener()));\n",
        "1888": "    CountingRemovalListener<Object, Object> listener =\n",
        "1889": "        countingRemovalListener();\n",
        "1890": "    LocalCache<Object, Object> map = makeLocalCache(createCacheBuilder()\n",
        "1891": "        .concurrencyLevel(1)\n",
        "1892": "        .initialCapacity(1)\n",
        "1893": "        .maximumSize(SMALL_MAX_SIZE)\n",
        "1894": "        .expireAfterWrite(99999, SECONDS)\n",
        "1895": "        .removalListener(listener));\n",
        "1937": "    LocalCache<Object, Object> map = makeLocalCache(createCacheBuilder()\n",
        "1938": "        .concurrencyLevel(1)\n",
        "1939": "        .initialCapacity(1)\n",
        "1940": "        .maximumSize(SMALL_MAX_SIZE)\n",
        "1941": "        .expireAfterWrite(99999, SECONDS)\n",
        "1942": "        .removalListener(countingRemovalListener()));\n",
        "2185": "  static <K, V> void checkAndDrainRecencyQueue(LocalCache<K, V> map,\n",
        "2186": "      Segment<K, V> segment, List<ReferenceEntry<K, V>> reads) {\n",
        "2193": "  static <K, V> void checkEvictionQueues(LocalCache<K, V> map,\n",
        "2194": "      Segment<K, V> segment, List<ReferenceEntry<K, V>> readOrder,\n",
        "2204": "  private static <K, V> void assertSameEntries(List<ReferenceEntry<K, V>> expectedEntries,\n",
        "2205": "      List<ReferenceEntry<K, V>> actualEntries) {\n",
        "2250": "    LocalCache<Object, Object> map = makeLocalCache(createCacheBuilder()\n",
        "2251": "        .concurrencyLevel(1)\n",
        "2252": "        .ticker(ticker)\n",
        "2253": "        .expireAfterWrite(2, TimeUnit.NANOSECONDS));\n",
        "2289": "    LocalCache<Object, Object> map = makeLocalCache(createCacheBuilder()\n",
        "2290": "        .concurrencyLevel(1)\n",
        "2291": "        .ticker(ticker)\n",
        "2292": "        .expireAfterAccess(2, TimeUnit.NANOSECONDS));\n",
        "2384": "      LocalCache<Object, Object> map =\n",
        "2385": "          makeLocalCache(builder.concurrencyLevel(1));\n",
        "2414": "      LocalCache<Object, Object> map =\n",
        "2415": "          makeLocalCache(builder.concurrencyLevel(1));\n",
        "2445": "      LocalCache<Object, Object> map =\n",
        "2446": "          makeLocalCache(builder.concurrencyLevel(1));\n",
        "2476": "      LocalCache<Object, Object> map =\n",
        "2477": "          makeLocalCache(builder.concurrencyLevel(1));\n",
        "2519": "    LocalLoadingCache<Object, Object> one = (LocalLoadingCache) CacheBuilder.newBuilder()\n",
        "2520": "        .weakKeys()\n",
        "2521": "        .softValues()\n",
        "2522": "        .expireAfterAccess(123, SECONDS)\n",
        "2523": "        .expireAfterWrite(456, MINUTES)\n",
        "2524": "        .maximumWeight(789)\n",
        "2525": "        .weigher(weigher)\n",
        "2526": "        .concurrencyLevel(12)\n",
        "2527": "        .removalListener(listener)\n",
        "2528": "        .ticker(ticker)\n",
        "2529": "        .build(loader);\n",
        "2575": "    LocalManualCache<Object, Object> one = (LocalManualCache) CacheBuilder.newBuilder()\n",
        "2576": "        .weakKeys()\n",
        "2577": "        .softValues()\n",
        "2578": "        .expireAfterAccess(123, NANOSECONDS)\n",
        "2579": "        .maximumWeight(789)\n",
        "2580": "        .weigher(weigher)\n",
        "2581": "        .concurrencyLevel(12)\n",
        "2582": "        .removalListener(listener)\n",
        "2583": "        .ticker(ticker)\n",
        "2584": "        .build();\n",
        "2631": "    List<CacheBuilder<Object, Object>> result =\n",
        "2632": "        newArrayList(allKeyValueStrengthMakers());\n",
        "2651": "  /**\n",
        "2652": "   * Returns an iterable containing all combinations of maximumSize and expireAfterAccess/Write.\n",
        "2653": "   */\n",
        "2656": "    return ImmutableList.of(createCacheBuilder().maximumSize(SMALL_MAX_SIZE),\n",
        "2667": "  /**\n",
        "2668": "   * Returns an iterable containing all combinations weakKeys and weak/softValues.\n",
        "2669": "   */\n",
        "2672": "    return ImmutableList.of(createCacheBuilder(),\n",
        "2877": "  private static class SerializableCacheLoader\n",
        "2878": "      extends CacheLoader<Object, Object> implements Serializable {\n"
    }
}