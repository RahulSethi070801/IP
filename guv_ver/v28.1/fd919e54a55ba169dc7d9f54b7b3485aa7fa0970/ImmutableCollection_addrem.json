{
    "addition": {
        "53": " *   <li><b>Shallow immutability.</b> Elements can never be added, removed or replaced in this\n",
        "54": " *       collection. This is a stronger guarantee than that of {@link\n",
        "55": " *       Collections#unmodifiableCollection}, whose contents change whenever the wrapped collection\n",
        "56": " *       is modified.\n",
        "57": " *   <li><b>Null-hostility.</b> This collection will never contain a null element.\n",
        "58": " *   <li><b>Deterministic iteration.</b> The iteration order is always well-defined, depending on\n",
        "59": " *       how the collection was created. Typically this is insertion order unless an explicit\n",
        "60": " *       ordering is otherwise specified (e.g. {@link ImmutableSortedSet#naturalOrder}). See the\n",
        "61": " *       appropriate factory method for details. View collections such as {@link\n",
        "62": " *       ImmutableMultiset#elementSet} iterate in the same order as the parent, except as noted.\n",
        "63": " *   <li><b>Thread safety.</b> It is safe to access this collection concurrently from multiple\n",
        "64": " *       threads.\n",
        "65": " *   <li><b>Integrity.</b> This type cannot be subclassed outside this package (which would allow\n",
        "66": " *       these guarantees to be violated).\n",
        "87": " * powerful advantage. Although Java 9 offers certain immutable collection factory methods, like <a\n",
        "88": " * href=\"https://docs.oracle.com/javase/9/docs/api/java/util/Set.html#immutable\">{@code Set.of}</a>,\n",
        "98": " *   <li>Static methods named {@code of}, accepting an explicit list of elements or entries.\n",
        "99": " *   <li>Static methods named {@code copyOf} (or {@code copyOfSorted}), accepting an existing\n",
        "100": " *       collection whose contents should be copied.\n",
        "101": " *   <li>A static nested {@code Builder} class which can be used to populate a new immutable\n",
        "102": " *       instance.\n",
        "108": " *   <li><b>Warning:</b> as with any collection, it is almost always a bad idea to modify an element\n",
        "109": " *       (in a way that affects its {@link Object#equals} behavior) while it is contained in a\n",
        "110": " *       collection. Undefined behavior and bugs will result. It's generally best to avoid using\n",
        "111": " *       mutable objects as elements at all, as many users may expect your \"immutable\" object to be\n",
        "112": " *       <i>deeply</i> immutable.\n",
        "118": " *   <li>Implementations can be generally assumed to prioritize memory efficiency, then speed of\n",
        "119": " *       access, and lastly speed of creation.\n",
        "120": " *   <li>The {@code copyOf} methods will sometimes recognize that the actual copy operation is\n",
        "121": " *       unnecessary; for example, {@code copyOf(copyOf(anArrayList))} should copy the data only\n",
        "122": " *       once. This reduces the expense of habitually making defensive copies at API boundaries.\n",
        "123": " *       However, the precise conditions for skipping the copy operation are undefined.\n",
        "124": " *   <li><b>Warning:</b> a view collection such as {@link ImmutableMap#keySet} or {@link\n",
        "125": " *       ImmutableList#subList} may retain a reference to the entire data set, preventing it from\n",
        "126": " *       being garbage collected. If some of the data is no longer reachable through other means,\n",
        "127": " *       this constitutes a memory leak. Pass the view collection to the appropriate {@code copyOf}\n",
        "128": " *       method to obtain a correctly-sized copy.\n",
        "129": " *   <li>The performance of using the associated {@code Builder} class can be assumed to be no\n",
        "130": " *       worse, and possibly better, than creating a mutable collection and copying it.\n",
        "131": " *   <li>Implementations generally do not cache hash codes. If your element or key type has a slow\n",
        "132": " *       {@code hashCode} implementation, it should cache it itself.\n",
        "137": " * <pre>{@code\n",
        "138": " * class Foo {\n",
        "139": " *   private static final ImmutableSet<String> RESERVED_CODES =\n",
        "140": " *       ImmutableSet.of(\"AZ\", \"CQ\", \"ZX\");\n",
        "142": " *   private final ImmutableSet<String> codes;\n",
        "144": " *   public Foo(Iterable<String> codes) {\n",
        "145": " *     this.codes = ImmutableSet.copyOf(codes);\n",
        "146": " *     checkArgument(Collections.disjoint(this.codes, RESERVED_CODES));\n",
        "147": " *   }\n",
        "148": " * }\n",
        "149": " * }</pre>\n",
        "154": " * \"https://github.com/google/guava/wiki/ImmutableCollectionsExplained\"> immutable collections</a>.\n",
        "166": "  /** Returns an unmodifiable iterator across the elements in this collection. */\n",
        "301": "   * offset. Returns {@code offset + size()}.\n",
        "345": "     * <p>Note that each builder class covariantly returns its own type from this method.\n",
        "355": "     * Adds each element of {@code elements} to the {@code ImmutableCollection} being built.\n",
        "357": "     * <p>Note that each builder class overrides this method in order to covariantly return its own\n",
        "358": "     * type.\n",
        "362": "     * @throws NullPointerException if {@code elements} is null or contains a null element\n",
        "373": "     * Adds each element of {@code elements} to the {@code ImmutableCollection} being built.\n",
        "375": "     * <p>Note that each builder class overrides this method in order to covariantly return its own\n",
        "376": "     * type.\n",
        "380": "     * @throws NullPointerException if {@code elements} is null or contains a null element\n",
        "391": "     * Adds each element of {@code elements} to the {@code ImmutableCollection} being built.\n",
        "393": "     * <p>Note that each builder class overrides this method in order to covariantly return its own\n",
        "394": "     * type.\n",
        "398": "     * @throws NullPointerException if {@code elements} is null or contains a null element\n",
        "409": "     * Returns a newly-created {@code ImmutableCollection} of the appropriate type, containing the\n",
        "410": "     * elements provided to this builder.\n",
        "412": "     * <p>Note that each builder class covariantly returns the appropriate type of {@code\n",
        "413": "     * ImmutableCollection} from this method.\n",
        "437": "            Arrays.copyOf(this.contents, expandedCapacity(contents.length, minCapacity));\n"
    },
    "removed": {
        "27": "import java.util.ArrayList;\n",
        "54": " * <li><b>Shallow immutability.</b> Elements can never be added, removed or replaced in this\n",
        "55": " *     collection. This is a stronger guarantee than that of\n",
        "56": " *     {@link Collections#unmodifiableCollection}, whose contents change whenever the wrapped\n",
        "57": " *     collection is modified.\n",
        "58": " * <li><b>Null-hostility.</b> This collection will never contain a null element.\n",
        "59": " * <li><b>Deterministic iteration.</b> The iteration order is always well-defined, depending on how\n",
        "60": " *     the collection was created. Typically this is insertion order unless an explicit ordering is\n",
        "61": " *     otherwise specified (e.g. {@link ImmutableSortedSet#naturalOrder}).  See the appropriate\n",
        "62": " *     factory method for details. View collections such as {@link ImmutableMultiset#elementSet}\n",
        "63": " *     iterate in the same order as the parent, except as noted.\n",
        "64": " * <li><b>Thread safety.</b> It is safe to access this collection concurrently from multiple\n",
        "65": " *     threads.\n",
        "66": " * <li><b>Integrity.</b> This type cannot be subclassed outside this package (which would allow\n",
        "67": " *     these guarantees to be violated).\n",
        "88": " * powerful advantage. Although Java 9 offers certain immutable collection factory methods, like\n",
        "89": " * <a href=\"https://docs.oracle.com/javase/9/docs/api/java/util/Set.html#immutable\">{@code Set.of}</a>,\n",
        "99": " * <li>Static methods named {@code of}, accepting an explicit list of elements or entries.\n",
        "100": " * <li>Static methods named {@code copyOf} (or {@code copyOfSorted}), accepting an existing\n",
        "101": " *     collection whose contents should be copied.\n",
        "102": " * <li>A static nested {@code Builder} class which can be used to populate a new immutable instance.\n",
        "108": " * <li><b>Warning:</b> as with any collection, it is almost always a bad idea to modify an element\n",
        "109": " *     (in a way that affects its {@link Object#equals} behavior) while it is contained in a\n",
        "110": " *     collection. Undefined behavior and bugs will result. It's generally best to avoid using\n",
        "111": " *     mutable objects as elements at all, as many users may expect your \"immutable\" object to be\n",
        "112": " *     <i>deeply</i> immutable.\n",
        "118": " * <li>Implementations can be generally assumed to prioritize memory efficiency, then speed of\n",
        "119": " *     access, and lastly speed of creation.\n",
        "120": " * <li>The {@code copyOf} methods will sometimes recognize that the actual copy operation is\n",
        "121": " *     unnecessary; for example, {@code copyOf(copyOf(anArrayList))} should copy the data only once.\n",
        "122": " *     This reduces the expense of habitually making defensive copies at API boundaries. However,\n",
        "123": " *     the precise conditions for skipping the copy operation are undefined.\n",
        "124": " * <li><b>Warning:</b> a view collection such as {@link ImmutableMap#keySet} or {@link\n",
        "125": " *     ImmutableList#subList} may retain a reference to the entire data set, preventing it from\n",
        "126": " *     being garbage collected. If some of the data is no longer reachable through other means, this\n",
        "127": " *     constitutes a memory leak. Pass the view collection to the appropriate {@code copyOf} method\n",
        "128": " *     to obtain a correctly-sized copy.\n",
        "129": " * <li>The performance of using the associated {@code Builder} class can be assumed to be\n",
        "130": " *     no worse, and possibly better, than creating a mutable collection and copying it.\n",
        "131": " * <li>Implementations generally do not cache hash codes. If your element or key type has a slow\n",
        "132": " *     {@code hashCode} implementation, it should cache it itself.\n",
        "137": " * <pre>   {@code\n",
        "139": " *   class Foo {\n",
        "140": " *     private static final ImmutableSet<String> RESERVED_CODES =\n",
        "141": " *         ImmutableSet.of(\"AZ\", \"CQ\", \"ZX\");\n",
        "143": " *     private final ImmutableSet<String> codes;\n",
        "144": " *\n",
        "145": " *     public Foo(Iterable<String> codes) {\n",
        "146": " *       this.codes = ImmutableSet.copyOf(codes);\n",
        "147": " *       checkArgument(Collections.disjoint(this.codes, RESERVED_CODES));\n",
        "148": " *     }\n",
        "149": " *   }}</pre>\n",
        "154": " * \"https://github.com/google/guava/wiki/ImmutableCollectionsExplained\">\n",
        "155": " * immutable collections</a>.\n",
        "167": "  /**\n",
        "168": "   * Returns an unmodifiable iterator across the elements in this collection.\n",
        "169": "   */\n",
        "304": "   * offset.  Returns {@code offset + size()}.\n",
        "348": "     * <p>Note that each builder class covariantly returns its own type from\n",
        "349": "     * this method.\n",
        "359": "     * Adds each element of {@code elements} to the {@code ImmutableCollection}\n",
        "360": "     * being built.\n",
        "362": "     * <p>Note that each builder class overrides this method in order to\n",
        "363": "     * covariantly return its own type.\n",
        "367": "     * @throws NullPointerException if {@code elements} is null or contains a\n",
        "368": "     *     null element\n",
        "379": "     * Adds each element of {@code elements} to the {@code ImmutableCollection}\n",
        "380": "     * being built.\n",
        "382": "     * <p>Note that each builder class overrides this method in order to\n",
        "383": "     * covariantly return its own type.\n",
        "387": "     * @throws NullPointerException if {@code elements} is null or contains a\n",
        "388": "     *     null element\n",
        "399": "     * Adds each element of {@code elements} to the {@code ImmutableCollection}\n",
        "400": "     * being built.\n",
        "402": "     * <p>Note that each builder class overrides this method in order to\n",
        "403": "     * covariantly return its own type.\n",
        "407": "     * @throws NullPointerException if {@code elements} is null or contains a\n",
        "408": "     *     null element\n",
        "419": "     * Returns a newly-created {@code ImmutableCollection} of the appropriate\n",
        "420": "     * type, containing the elements provided to this builder.\n",
        "422": "     * <p>Note that each builder class covariantly returns the appropriate type\n",
        "423": "     * of {@code ImmutableCollection} from this method.\n",
        "447": "            Arrays.copyOf(\n",
        "448": "                this.contents, expandedCapacity(contents.length, minCapacity));\n"
    }
}