{
    "addition": {
        "37": " * Static utility methods pertaining to {@link Queue} and {@link Deque} instances. Also see this\n",
        "38": " * class's counterparts {@link Lists}, {@link Sets}, and {@link Maps}.\n",
        "50": "   * Creates an empty {@code ArrayBlockingQueue} with the given (fixed) capacity and nonfair access\n",
        "51": "   * policy.\n",
        "70": "   * Creates an {@code ArrayDeque} containing the elements of the specified iterable, in the order\n",
        "71": "   * they are returned by the iterable's iterator.\n",
        "86": "  /** Creates an empty {@code ConcurrentLinkedQueue}. */\n",
        "93": "   * Creates a {@code ConcurrentLinkedQueue} containing the elements of the specified iterable, in\n",
        "94": "   * the order they are returned by the iterable's iterator.\n",
        "131": "   * Creates a {@code LinkedBlockingDeque} with a capacity of {@link Integer#MAX_VALUE}, containing\n",
        "132": "   * the elements of the specified iterable, in the order they are returned by the iterable's\n",
        "133": "   * iterator.\n",
        "149": "  /** Creates an empty {@code LinkedBlockingQueue} with a capacity of {@link Integer#MAX_VALUE}. */\n",
        "166": "   * Creates a {@code LinkedBlockingQueue} with a capacity of {@link Integer#MAX_VALUE}, containing\n",
        "167": "   * the elements of the specified iterable, in the order they are returned by the iterable's\n",
        "168": "   * iterator.\n",
        "188": "   * Creates an empty {@code PriorityBlockingQueue} with the ordering given by its elements' natural\n",
        "189": "   * ordering.\n",
        "201": "   * <p><b>Note:</b> If the specified iterable is a {@code SortedSet} or a {@code PriorityQueue},\n",
        "220": "   * Creates an empty {@code PriorityQueue} with the ordering given by its elements' natural\n",
        "221": "   * ordering.\n",
        "232": "   * <p><b>Note:</b> If the specified iterable is a {@code SortedSet} or a {@code PriorityQueue},\n",
        "249": "  /** Creates an empty {@code SynchronousQueue} with nonfair access policy. */\n",
        "256": "   * Drains the queue as {@link BlockingQueue#drainTo(Collection, int)}, but if the requested {@code\n",
        "257": "   * numElements} elements are not available, it will wait for them up to the specified timeout.\n",
        "302": "   * Drains the queue as {@linkplain #drain(BlockingQueue, Collection, int, long, TimeUnit)}, but\n",
        "303": "   * with a different behavior in case it is interrupted while waiting. In that case, the operation\n",
        "304": "   * will continue as usual, and in the end the thread's interruption status will be set (no {@code\n",
        "305": "   * InterruptedException} is thrown).\n",
        "358": "   * Returns a synchronized (thread-safe) queue backed by the specified queue. In order to guarantee\n",
        "359": "   * serial access, it is critical that <b>all</b> access to the backing queue is accomplished\n",
        "360": "   * through the returned queue.\n",
        "362": "   * <p>It is imperative that the user manually synchronize on the returned queue when accessing the\n",
        "363": "   * queue's iterator:\n",
        "365": "   * <pre>{@code\n",
        "366": "   * Queue<E> queue = Queues.synchronizedQueue(MinMaxPriorityQueue.<E>create());\n",
        "367": "   * ...\n",
        "368": "   * queue.add(element);  // Needn't be in synchronized block\n",
        "369": "   * ...\n",
        "370": "   * synchronized (queue) {  // Must synchronize on queue!\n",
        "371": "   *   Iterator<E> i = queue.iterator(); // Must be in synchronized block\n",
        "372": "   *   while (i.hasNext()) {\n",
        "373": "   *     foo(i.next());\n",
        "374": "   *   }\n",
        "375": "   * }\n",
        "376": "   * }</pre>\n",
        "391": "   * Returns a synchronized (thread-safe) deque backed by the specified deque. In order to guarantee\n",
        "392": "   * serial access, it is critical that <b>all</b> access to the backing deque is accomplished\n",
        "393": "   * through the returned deque.\n",
        "395": "   * <p>It is imperative that the user manually synchronize on the returned deque when accessing any\n",
        "396": "   * of the deque's iterators:\n",
        "398": "   * <pre>{@code\n",
        "399": "   * Deque<E> deque = Queues.synchronizedDeque(Queues.<E>newArrayDeque());\n",
        "400": "   * ...\n",
        "401": "   * deque.add(element);  // Needn't be in synchronized block\n",
        "402": "   * ...\n",
        "403": "   * synchronized (deque) {  // Must synchronize on deque!\n",
        "404": "   *   Iterator<E> i = deque.iterator(); // Must be in synchronized block\n",
        "405": "   *   while (i.hasNext()) {\n",
        "406": "   *     foo(i.next());\n",
        "407": "   *   }\n",
        "408": "   * }\n",
        "409": "   * }</pre>\n"
    },
    "removed": {
        "37": " * Static utility methods pertaining to {@link Queue} and {@link Deque} instances.\n",
        "38": " * Also see this class's counterparts {@link Lists}, {@link Sets}, and {@link Maps}.\n",
        "50": "   * Creates an empty {@code ArrayBlockingQueue} with the given (fixed) capacity\n",
        "51": "   * and nonfair access policy.\n",
        "70": "   * Creates an {@code ArrayDeque} containing the elements of the specified iterable,\n",
        "71": "   * in the order they are returned by the iterable's iterator.\n",
        "86": "  /**\n",
        "87": "   * Creates an empty {@code ConcurrentLinkedQueue}.\n",
        "88": "   */\n",
        "95": "   * Creates a {@code ConcurrentLinkedQueue} containing the elements of the specified iterable,\n",
        "96": "   * in the order they are returned by the iterable's iterator.\n",
        "133": "   * Creates a {@code LinkedBlockingDeque} with a capacity of {@link Integer#MAX_VALUE},\n",
        "134": "   * containing the elements of the specified iterable,\n",
        "135": "   * in the order they are returned by the iterable's iterator.\n",
        "151": "  /**\n",
        "152": "   * Creates an empty {@code LinkedBlockingQueue} with a capacity of {@link Integer#MAX_VALUE}.\n",
        "153": "   */\n",
        "170": "   * Creates a {@code LinkedBlockingQueue} with a capacity of {@link Integer#MAX_VALUE},\n",
        "171": "   * containing the elements of the specified iterable,\n",
        "172": "   * in the order they are returned by the iterable's iterator.\n",
        "192": "   * Creates an empty {@code PriorityBlockingQueue} with the ordering given by its\n",
        "193": "   * elements' natural ordering.\n",
        "205": "   * <b>Note:</b> If the specified iterable is a {@code SortedSet} or a {@code PriorityQueue},\n",
        "224": "   * Creates an empty {@code PriorityQueue} with the ordering given by its\n",
        "225": "   * elements' natural ordering.\n",
        "236": "   * <b>Note:</b> If the specified iterable is a {@code SortedSet} or a {@code PriorityQueue},\n",
        "253": "  /**\n",
        "254": "   * Creates an empty {@code SynchronousQueue} with nonfair access policy.\n",
        "255": "   */\n",
        "262": "   * Drains the queue as {@link BlockingQueue#drainTo(Collection, int)}, but if the requested\n",
        "263": "   * {@code numElements} elements are not available, it will wait for them up to the specified\n",
        "264": "   * timeout.\n",
        "309": "   * Drains the queue as {@linkplain #drain(BlockingQueue, Collection, int, long, TimeUnit)},\n",
        "310": "   * but with a different behavior in case it is interrupted while waiting. In that case, the\n",
        "311": "   * operation will continue as usual, and in the end the thread's interruption status will be set\n",
        "312": "   * (no {@code InterruptedException} is thrown).\n",
        "365": "   * Returns a synchronized (thread-safe) queue backed by the specified queue. In order to\n",
        "366": "   * guarantee serial access, it is critical that <b>all</b> access to the backing queue is\n",
        "367": "   * accomplished through the returned queue.\n",
        "369": "   * <p>It is imperative that the user manually synchronize on the returned queue when accessing\n",
        "370": "   * the queue's iterator: <pre>   {@code\n",
        "372": "   *   Queue<E> queue = Queues.synchronizedQueue(MinMaxPriorityQueue.<E>create());\n",
        "373": "   *   ...\n",
        "374": "   *   queue.add(element);  // Needn't be in synchronized block\n",
        "375": "   *   ...\n",
        "376": "   *   synchronized (queue) {  // Must synchronize on queue!\n",
        "377": "   *     Iterator<E> i = queue.iterator(); // Must be in synchronized block\n",
        "378": "   *     while (i.hasNext()) {\n",
        "379": "   *       foo(i.next());\n",
        "380": "   *     }\n",
        "381": "   *   }}</pre>\n",
        "396": "   * Returns a synchronized (thread-safe) deque backed by the specified deque. In order to\n",
        "397": "   * guarantee serial access, it is critical that <b>all</b> access to the backing deque is\n",
        "398": "   * accomplished through the returned deque.\n",
        "400": "   * <p>It is imperative that the user manually synchronize on the returned deque when accessing\n",
        "401": "   * any of the deque's iterators: <pre>   {@code\n",
        "403": "   *   Deque<E> deque = Queues.synchronizedDeque(Queues.<E>newArrayDeque());\n",
        "404": "   *   ...\n",
        "405": "   *   deque.add(element);  // Needn't be in synchronized block\n",
        "406": "   *   ...\n",
        "407": "   *   synchronized (deque) {  // Must synchronize on deque!\n",
        "408": "   *     Iterator<E> i = deque.iterator(); // Must be in synchronized block\n",
        "409": "   *     while (i.hasNext()) {\n",
        "410": "   *       foo(i.next());\n",
        "411": "   *     }\n",
        "412": "   *   }}</pre>\n"
    }
}