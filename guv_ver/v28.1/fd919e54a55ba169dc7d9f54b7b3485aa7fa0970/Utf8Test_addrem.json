{
    "addition": {
        "50": "      MAX_LOW_SURROGATE, MAX_HIGH_SURROGATE, MIN_LOW_SURROGATE, MIN_HIGH_SURROGATE,\n",
        "66": "    assertEquals(\n",
        "67": "        461,\n",
        "68": "        Utf8.encodedLength(\n",
        "69": "            \"\u5a01\u5ec9\u00b7\u838e\u58eb\u6bd4\u4e9e\uff08William Shakespeare\uff0c\"\n",
        "70": "                + \"1564\u5e744\u670826\u865f\u20141616\u5e744\u670823\u865f[1]\uff09\u4fc2\u96bb\u82f1\u570b\u55f0\u6f14\u54e1\u3001\u5287\u4f5c\u5bb6\u540c\u8a69\u4eba\uff0c\"\n",
        "71": "                + \"\u6709\u6642\u9593\u4f62\u7c21\u7a31\u838e\u7fc1\uff1b\u4e2d\u570b\u6e05\u672b\u6c11\u521d\u54c8\u62d5\u7ffb\u8b6f\u505a\u820c\u514b\u65af\u6bd5\u3001\u6c99\u65af\u76ae\u8033\u3001\u7b5b\u65af\u6bd4\u8033\u3001\"\n",
        "72": "                + \"\u838e\u57fa\u65af\u5e87\u5c14\u3001\u7d22\u58eb\u6bd4\u5c14\u3001\u590f\u514b\u601d\u8298\u5c14\u3001\u5e0c\u54c0\u82e6\u76ae\u963f\u3001\u53f6\u65af\u58c1\u3001\u6c99\u514b\u76ae\u5c14\u3001\"\n",
        "73": "                + \"\u72f9\u65af\u4e15\u723e\u3002[2]\u838e\u58eb\u6bd4\u4e9e\u7de8\u5beb\u904e\u597d\u591a\u4f5c\u54c1\uff0c\u4f62\u55f0\u5287\u4f5c\u97ff\u897f\u6d0b\u6587\u5b78\u597d\u6709\u5f71\u97ff\uff0c\"\n",
        "74": "                + \"\u54c8\u90fd\u62d5\u4eba\u7ffb\u8b6f\u505a\u597d\u591a\u8a71\u3002\"));\n",
        "90": "    Integer[] codePoints = utf8Lengths.keySet().toArray(new Integer[] {});\n",
        "129": "  private static final long ONE_BYTE_ROUNDTRIPPABLE_CHARACTERS = 0x007f - 0x0000 + 1;\n",
        "136": "  private static final long TWO_BYTE_ROUNDTRIPPABLE_CHARACTERS = 0x07FF - 0x0080 + 1;\n",
        "141": "      (long) Math.pow(EXPECTED_ONE_BYTE_ROUNDTRIPPABLE_COUNT, 2)\n",
        "142": "          +\n",
        "143": "          // The possible number of two byte characters\n",
        "144": "          TWO_BYTE_ROUNDTRIPPABLE_CHARACTERS;\n",
        "156": "      (long) Math.pow(EXPECTED_ONE_BYTE_ROUNDTRIPPABLE_COUNT, 3)\n",
        "157": "          +\n",
        "158": "          // One two byte character and a one byte character\n",
        "159": "          2 * TWO_BYTE_ROUNDTRIPPABLE_CHARACTERS * ONE_BYTE_ROUNDTRIPPABLE_CHARACTERS\n",
        "160": "          +\n",
        "161": "          // Three byte characters\n",
        "162": "          THREE_BYTE_ROUNDTRIPPABLE_CHARACTERS;\n",
        "165": "  private static final long FOUR_BYTE_ROUNDTRIPPABLE_CHARACTERS = 0x10FFFF - 0x10000L + 1;\n",
        "170": "      (long) Math.pow(EXPECTED_ONE_BYTE_ROUNDTRIPPABLE_COUNT, 4)\n",
        "171": "          +\n",
        "172": "          // One and three byte characters\n",
        "173": "          2 * THREE_BYTE_ROUNDTRIPPABLE_CHARACTERS * ONE_BYTE_ROUNDTRIPPABLE_CHARACTERS\n",
        "174": "          +\n",
        "175": "          // Two two byte characters\n",
        "176": "          TWO_BYTE_ROUNDTRIPPABLE_CHARACTERS * TWO_BYTE_ROUNDTRIPPABLE_CHARACTERS\n",
        "177": "          +\n",
        "178": "          // Permutations of one and two byte characters\n",
        "179": "          3\n",
        "180": "              * TWO_BYTE_ROUNDTRIPPABLE_CHARACTERS\n",
        "181": "              * ONE_BYTE_ROUNDTRIPPABLE_CHARACTERS\n",
        "182": "              * ONE_BYTE_ROUNDTRIPPABLE_CHARACTERS\n",
        "183": "          +\n",
        "184": "          // Four byte characters\n",
        "185": "          FOUR_BYTE_ROUNDTRIPPABLE_CHARACTERS;\n",
        "207": "   * Tests that round tripping of a sample of four byte permutations work. All permutations are\n",
        "208": "   * prohibitively expensive to test for automated runs. This method tests specific four-byte cases.\n",
        "236": "    assertWellFormed(\n",
        "237": "        0x61, 0xc8, 0x8a, 0x63, 0xc2, 0xa2, 0x62, 0x5c, 0x75, 0x30, 0x32, 0x34, 0x42, 0x36, 0x32,\n",
        "238": "        0x75, 0x30, 0x32, 0x30, 0x61, 0x63, 0x63, 0xc2, 0xa2, 0x64, 0x65, 0xc9, 0x8b, 0x36, 0x32);\n",
        "280": "      expected[i] = 2342912;\n",
        "298": "   * Helper to run the loop to test all the permutations for the number of bytes specified.\n",
        "309": "   * Helper to run the loop to test all the permutations for the number of bytes specified. This\n",
        "310": "   * overload is useful for debugging to get the loop to start at a certain character.\n",
        "315": "   * @param lim the limit of bytes to process encoded as a long as big-endian, or -1 to mean the max\n",
        "316": "   *     limit for numBytes\n"
    },
    "removed": {
        "49": "      MAX_LOW_SURROGATE,\n",
        "50": "      MAX_HIGH_SURROGATE,\n",
        "51": "      MIN_LOW_SURROGATE,\n",
        "52": "      MIN_HIGH_SURROGATE,\n",
        "68": "    assertEquals(461, Utf8.encodedLength(\"\u5a01\u5ec9\u00b7\u838e\u58eb\u6bd4\u4e9e\uff08William Shakespeare\uff0c\"\n",
        "69": "        + \"1564\u5e744\u670826\u865f\u20141616\u5e744\u670823\u865f[1]\uff09\u4fc2\u96bb\u82f1\u570b\u55f0\u6f14\u54e1\u3001\u5287\u4f5c\u5bb6\u540c\u8a69\u4eba\uff0c\"\n",
        "70": "        + \"\u6709\u6642\u9593\u4f62\u7c21\u7a31\u838e\u7fc1\uff1b\u4e2d\u570b\u6e05\u672b\u6c11\u521d\u54c8\u62d5\u7ffb\u8b6f\u505a\u820c\u514b\u65af\u6bd5\u3001\u6c99\u65af\u76ae\u8033\u3001\u7b5b\u65af\u6bd4\u8033\u3001\"\n",
        "71": "        + \"\u838e\u57fa\u65af\u5e87\u5c14\u3001\u7d22\u58eb\u6bd4\u5c14\u3001\u590f\u514b\u601d\u8298\u5c14\u3001\u5e0c\u54c0\u82e6\u76ae\u963f\u3001\u53f6\u65af\u58c1\u3001\u6c99\u514b\u76ae\u5c14\u3001\"\n",
        "72": "        + \"\u72f9\u65af\u4e15\u723e\u3002[2]\u838e\u58eb\u6bd4\u4e9e\u7de8\u5beb\u904e\u597d\u591a\u4f5c\u54c1\uff0c\u4f62\u55f0\u5287\u4f5c\u97ff\u897f\u6d0b\u6587\u5b78\u597d\u6709\u5f71\u97ff\uff0c\"\n",
        "73": "        + \"\u54c8\u90fd\u62d5\u4eba\u7ffb\u8b6f\u505a\u597d\u591a\u8a71\u3002\"));\n",
        "89": "    Integer[] codePoints = utf8Lengths.keySet().toArray(new Integer[]{});\n",
        "128": "  private static final long ONE_BYTE_ROUNDTRIPPABLE_CHARACTERS =\n",
        "129": "      0x007f - 0x0000 + 1;\n",
        "136": "  private static final long TWO_BYTE_ROUNDTRIPPABLE_CHARACTERS =\n",
        "137": "      0x07FF - 0x0080 + 1;\n",
        "142": "      (long) Math.pow(EXPECTED_ONE_BYTE_ROUNDTRIPPABLE_COUNT, 2) +\n",
        "143": "      // The possible number of two byte characters\n",
        "144": "      TWO_BYTE_ROUNDTRIPPABLE_CHARACTERS;\n",
        "156": "      (long) Math.pow(EXPECTED_ONE_BYTE_ROUNDTRIPPABLE_COUNT, 3) +\n",
        "157": "      // One two byte character and a one byte character\n",
        "158": "      2 * TWO_BYTE_ROUNDTRIPPABLE_CHARACTERS *\n",
        "159": "          ONE_BYTE_ROUNDTRIPPABLE_CHARACTERS +\n",
        "160": "       // Three byte characters\n",
        "161": "      THREE_BYTE_ROUNDTRIPPABLE_CHARACTERS;\n",
        "164": "  private static final long FOUR_BYTE_ROUNDTRIPPABLE_CHARACTERS =\n",
        "165": "      0x10FFFF - 0x10000L + 1;\n",
        "170": "      (long) Math.pow(EXPECTED_ONE_BYTE_ROUNDTRIPPABLE_COUNT, 4) +\n",
        "171": "      // One and three byte characters\n",
        "172": "      2 * THREE_BYTE_ROUNDTRIPPABLE_CHARACTERS *\n",
        "173": "          ONE_BYTE_ROUNDTRIPPABLE_CHARACTERS +\n",
        "174": "      // Two two byte characters\n",
        "175": "      TWO_BYTE_ROUNDTRIPPABLE_CHARACTERS * TWO_BYTE_ROUNDTRIPPABLE_CHARACTERS +\n",
        "176": "      // Permutations of one and two byte characters\n",
        "177": "      3 * TWO_BYTE_ROUNDTRIPPABLE_CHARACTERS *\n",
        "178": "          ONE_BYTE_ROUNDTRIPPABLE_CHARACTERS *\n",
        "179": "          ONE_BYTE_ROUNDTRIPPABLE_CHARACTERS +\n",
        "180": "      // Four byte characters\n",
        "181": "      FOUR_BYTE_ROUNDTRIPPABLE_CHARACTERS;\n",
        "203": "   * Tests that round tripping of a sample of four byte permutations work.\n",
        "204": "   * All permutations are prohibitively expensive to test for automated runs.\n",
        "205": "   * This method tests specific four-byte cases.\n",
        "233": "    assertWellFormed(0x61, 0xc8, 0x8a, 0x63, 0xc2, 0xa2, 0x62, 0x5c, 0x75, 0x30,\n",
        "234": "        0x32, 0x34, 0x42, 0x36, 0x32, 0x75, 0x30, 0x32, 0x30, 0x61, 0x63, 0x63,\n",
        "235": "        0xc2, 0xa2, 0x64, 0x65, 0xc9, 0x8b, 0x36, 0x32);\n",
        "277": "     expected[i] = 2342912;\n",
        "295": "   * Helper to run the loop to test all the permutations for the number of bytes\n",
        "296": "   * specified.\n",
        "307": "   * Helper to run the loop to test all the permutations for the number of bytes\n",
        "308": "   * specified. This overload is useful for debugging to get the loop to start\n",
        "309": "   * at a certain character.\n",
        "314": "   * @param lim the limit of bytes to process encoded as a long as big-endian,\n",
        "315": "   *     or -1 to mean the max limit for numBytes\n"
    }
}