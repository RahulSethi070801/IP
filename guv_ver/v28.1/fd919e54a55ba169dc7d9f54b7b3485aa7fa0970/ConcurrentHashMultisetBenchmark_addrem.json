{
    "addition": {
        "48": "  @Param({\"1\", \"2\", \"4\", \"8\"})\n",
        "49": "  int threads;\n",
        "50": "\n",
        "51": "  @Param({\"3\", \"30\", \"300\"})\n",
        "52": "  int size;\n",
        "53": "\n",
        "60": "  @BeforeExperiment\n",
        "61": "  void setUp() throws Exception {\n",
        "72": "  @Benchmark\n",
        "73": "  long add(final int reps) throws ExecutionException, InterruptedException {\n",
        "76": "          @Override\n",
        "77": "          public Long call() {\n",
        "83": "  @Benchmark\n",
        "84": "  long addRemove(final int reps) throws ExecutionException, InterruptedException {\n",
        "87": "          @Override\n",
        "88": "          public Long call() {\n",
        "142": "      @Override\n",
        "143": "      Multiset<Integer> get() {\n",
        "148": "      @Override\n",
        "149": "      Multiset<Integer> get() {\n",
        "154": "      @Override\n",
        "155": "      Multiset<Integer> get() {\n",
        "173": "     * Creates a new, empty {@code OldConcurrentHashMultiset} using the default initial capacity,\n",
        "174": "     * load factor, and concurrency settings.\n",
        "180": "    @VisibleForTesting\n",
        "181": "    OldConcurrentHashMultiset(ConcurrentMap<E, Integer> countMap) {\n",
        "194": "    @Override\n",
        "195": "    public int count(@Nullable Object element) {\n",
        "206": "     * <p>If the data in the multiset is modified by any other threads during this method, it is\n",
        "207": "     * undefined which (if any) of these modifications will be reflected in the result.\n",
        "209": "    @Override\n",
        "210": "    public int size() {\n",
        "219": "     * Note: the superclass toArray() methods assume that size() gives a correct\n",
        "220": "     * answer, which ours does not.\n",
        "221": "     */\n",
        "223": "    @Override\n",
        "224": "    public Object[] toArray() {\n",
        "228": "    @Override\n",
        "229": "    public <T> T[] toArray(T[] array) {\n",
        "234": "     * We'd love to use 'new ArrayList(this)' or 'list.addAll(this)', but\n",
        "235": "     * either of these would recurse back to us again!\n",
        "236": "     */\n",
        "255": "     * @return the previous count of the element before the operation; possibly zero\n",
        "256": "     * @throws IllegalArgumentException if {@code occurrences} is negative, or if the resulting\n",
        "257": "     *     amount would exceed {@link Integer#MAX_VALUE}\n",
        "259": "    @Override\n",
        "260": "    public int add(E element, int occurrences) {\n",
        "273": "          checkArgument(\n",
        "274": "              occurrences <= Integer.MAX_VALUE - current,\n",
        "276": "              occurrences,\n",
        "277": "              current);\n",
        "288": "     * Removes a number of occurrences of the specified element from this multiset. If the multiset\n",
        "289": "     * contains fewer than this number of occurrences to begin with, all occurrences will be\n",
        "290": "     * removed.\n",
        "297": "    @Override\n",
        "298": "    public int remove(@Nullable Object element, int occurrences) {\n",
        "327": "     * Removes <b>all</b> occurrences of the specified element from this multiset. This method\n",
        "328": "     * complements {@link Multiset#remove(Object)}, which removes only one occurrence at a time.\n",
        "342": "     * Removes exactly the specified number of occurrences of {@code element}, or makes no change if\n",
        "343": "     * this is not possible.\n",
        "345": "     * <p>This method, in contrast to {@link #remove(Object, int)}, has no effect when the element\n",
        "346": "     * count is smaller than {@code occurrences}.\n",
        "350": "     * @return {@code true} if the removal was possible (including if {@code occurrences} is zero)\n",
        "369": "          E casted = (E) element;\n",
        "379": "     * Adds or removes occurrences of {@code element} such that the {@link #count} of the element\n",
        "380": "     * becomes {@code count}.\n",
        "385": "    @Override\n",
        "386": "    public int setCount(E element, int count) {\n",
        "388": "      return (count == 0) ? removeAllOccurrences(element) : unbox(countMap.put(element, count));\n",
        "392": "     * Sets the number of occurrences of {@code element} to {@code newCount}, but only if the count\n",
        "393": "     * is currently {@code oldCount}. If {@code element} does not appear in the multiset exactly\n",
        "394": "     * {@code oldCount} times, no changes will be made.\n",
        "396": "     * @return {@code true} if the change was successful. This usually indicates that the multiset\n",
        "397": "     *     has been modified, but not always: in the case that {@code oldCount == newCount}, the\n",
        "398": "     *     method will return {@code true} if the condition was met.\n",
        "399": "     * @throws IllegalArgumentException if {@code oldCount} or {@code newCount} is negative\n",
        "401": "    @Override\n",
        "402": "    public boolean setCount(E element, int oldCount, int newCount) {\n",
        "421": "    @Override\n",
        "422": "    Set<E> createElementSet() {\n",
        "443": "    @Override\n",
        "444": "    public Set<Multiset.Entry<E>> entrySet() {\n",
        "452": "    @Override\n",
        "453": "    int distinctElements() {\n",
        "457": "    @Override\n",
        "458": "    public boolean isEmpty() {\n",
        "462": "    @Override\n",
        "463": "    Iterator<Entry<E>> entryIterator() {\n",
        "464": "      final Iterator<Map.Entry<E, Integer>> backingIterator = countMap.entrySet().iterator();\n",
        "466": "        @Override\n",
        "467": "        public boolean hasNext() {\n",
        "471": "        @Override\n",
        "472": "        public Multiset.Entry<E> next() {\n",
        "474": "          return Multisets.immutableEntry(backingEntry.getKey(), backingEntry.getValue());\n",
        "477": "        @Override\n",
        "478": "        public void remove() {\n",
        "484": "    @Override\n",
        "485": "    public void clear() {\n",
        "490": "      @Override\n",
        "491": "      Multiset<E> multiset() {\n",
        "496": "       * Note: the superclass toArray() methods assume that size() gives a correct\n",
        "497": "       * answer, which ours does not.\n",
        "498": "       */\n",
        "500": "      @Override\n",
        "501": "      public Object[] toArray() {\n",
        "505": "      @Override\n",
        "506": "      public <T> T[] toArray(T[] array) {\n",
        "517": "      @Override\n",
        "518": "      public boolean remove(Object object) {\n",
        "528": "      /** The hash code is the same as countMap's, though the objects aren't equal. */\n",
        "529": "      @Override\n",
        "530": "      public int hashCode() {\n",
        "535": "    /** We use a special form of unboxing that treats null as zero. */\n"
    },
    "removed": {
        "48": "  @Param({\"1\", \"2\", \"4\", \"8\"}) int threads;\n",
        "49": "  @Param({\"3\", \"30\", \"300\"}) int size;\n",
        "56": "  @BeforeExperiment void setUp() throws Exception {\n",
        "67": "  @Benchmark long add(final int reps) throws ExecutionException, InterruptedException {\n",
        "70": "          @Override public Long call() {\n",
        "76": "  @Benchmark long addRemove(final int reps) throws ExecutionException, InterruptedException {\n",
        "79": "          @Override public Long call() {\n",
        "133": "      @Override Multiset<Integer> get() {\n",
        "138": "      @Override Multiset<Integer> get() {\n",
        "143": "      @Override Multiset<Integer> get() {\n",
        "161": "     * Creates a new, empty {@code OldConcurrentHashMultiset} using the default\n",
        "162": "     * initial capacity, load factor, and concurrency settings.\n",
        "168": "    @VisibleForTesting OldConcurrentHashMultiset(ConcurrentMap<E, Integer> countMap) {\n",
        "181": "    @Override public int count(@Nullable Object element) {\n",
        "192": "     * <p>If the data in the multiset is modified by any other threads during this\n",
        "193": "     * method, it is undefined which (if any) of these modifications will be\n",
        "194": "     * reflected in the result.\n",
        "196": "    @Override public int size() {\n",
        "205": "    * Note: the superclass toArray() methods assume that size() gives a correct\n",
        "206": "    * answer, which ours does not.\n",
        "207": "    */\n",
        "209": "    @Override public Object[] toArray() {\n",
        "213": "    @Override public <T> T[] toArray(T[] array) {\n",
        "218": "    * We'd love to use 'new ArrayList(this)' or 'list.addAll(this)', but\n",
        "219": "    * either of these would recurse back to us again!\n",
        "220": "    */\n",
        "239": "     * @return the previous count of the element before the operation; possibly\n",
        "240": "     *     zero\n",
        "241": "     * @throws IllegalArgumentException if {@code occurrences} is negative, or if\n",
        "242": "     *     the resulting amount would exceed {@link Integer#MAX_VALUE}\n",
        "244": "    @Override public int add(E element, int occurrences) {\n",
        "257": "          checkArgument(occurrences <= Integer.MAX_VALUE - current,\n",
        "259": "              occurrences, current);\n",
        "270": "     * Removes a number of occurrences of the specified element from this\n",
        "271": "     * multiset. If the multiset contains fewer than this number of occurrences to\n",
        "272": "     * begin with, all occurrences will be removed.\n",
        "279": "    @Override public int remove(@Nullable Object element, int occurrences) {\n",
        "308": "     * Removes <b>all</b> occurrences of the specified element from this multiset.\n",
        "309": "     * This method complements {@link Multiset#remove(Object)}, which removes only\n",
        "310": "     * one occurrence at a time.\n",
        "324": "     * Removes exactly the specified number of occurrences of {@code element}, or\n",
        "325": "     * makes no change if this is not possible.\n",
        "327": "     * <p>This method, in contrast to {@link #remove(Object, int)}, has no effect\n",
        "328": "     * when the element count is smaller than {@code occurrences}.\n",
        "332": "     * @return {@code true} if the removal was possible (including if {@code\n",
        "333": "     *     occurrences} is zero)\n",
        "352": "              E casted = (E) element;\n",
        "362": "     * Adds or removes occurrences of {@code element} such that the {@link #count}\n",
        "363": "     * of the element becomes {@code count}.\n",
        "368": "    @Override public int setCount(E element, int count) {\n",
        "370": "      return (count == 0)\n",
        "371": "          ? removeAllOccurrences(element)\n",
        "372": "          : unbox(countMap.put(element, count));\n",
        "376": "     * Sets the number of occurrences of {@code element} to {@code newCount}, but\n",
        "377": "     * only if the count is currently {@code oldCount}. If {@code element} does\n",
        "378": "     * not appear in the multiset exactly {@code oldCount} times, no changes will\n",
        "379": "     * be made.\n",
        "381": "     * @return {@code true} if the change was successful. This usually indicates\n",
        "382": "     *     that the multiset has been modified, but not always: in the case that\n",
        "383": "     *     {@code oldCount == newCount}, the method will return {@code true} if\n",
        "384": "     *     the condition was met.\n",
        "385": "     * @throws IllegalArgumentException if {@code oldCount} or {@code newCount} is\n",
        "386": "     *     negative\n",
        "388": "    @Override public boolean setCount(E element, int oldCount, int newCount) {\n",
        "407": "    @Override Set<E> createElementSet() {\n",
        "428": "    @Override public Set<Multiset.Entry<E>> entrySet() {\n",
        "436": "    @Override int distinctElements() {\n",
        "440": "    @Override public boolean isEmpty() {\n",
        "444": "    @Override Iterator<Entry<E>> entryIterator() {\n",
        "445": "      final Iterator<Map.Entry<E, Integer>> backingIterator =\n",
        "446": "          countMap.entrySet().iterator();\n",
        "448": "        @Override public boolean hasNext() {\n",
        "452": "        @Override public Multiset.Entry<E> next() {\n",
        "454": "          return Multisets.immutableEntry(backingEntry.getKey(),\n",
        "455": "              backingEntry.getValue());\n",
        "458": "        @Override public void remove() {\n",
        "464": "    @Override public void clear() {\n",
        "469": "      @Override Multiset<E> multiset() {\n",
        "474": "      * Note: the superclass toArray() methods assume that size() gives a correct\n",
        "475": "      * answer, which ours does not.\n",
        "476": "      */\n",
        "478": "      @Override public Object[] toArray() {\n",
        "482": "      @Override public <T> T[] toArray(T[] array) {\n",
        "493": "      @Override public boolean remove(Object object) {\n",
        "503": "      /**\n",
        "504": "       * The hash code is the same as countMap's, though the objects aren't equal.\n",
        "505": "       */\n",
        "506": "      @Override public int hashCode() {\n",
        "511": "    /**\n",
        "512": "     * We use a special form of unboxing that treats null as zero.\n",
        "513": "     */\n"
    }
}