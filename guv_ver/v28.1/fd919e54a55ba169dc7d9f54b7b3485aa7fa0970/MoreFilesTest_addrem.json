{
    "addition": {
        "60": "    suite.addTest(\n",
        "61": "        ByteSourceTester.tests(\n",
        "62": "            \"MoreFiles.asByteSource[Path]\", SourceSinkFactories.pathByteSourceFactory(), true));\n",
        "63": "    suite.addTest(\n",
        "64": "        ByteSinkTester.tests(\n",
        "65": "            \"MoreFiles.asByteSink[Path]\", SourceSinkFactories.pathByteSinkFactory()));\n",
        "66": "    suite.addTest(\n",
        "67": "        ByteSinkTester.tests(\n",
        "68": "            \"MoreFiles.asByteSink[Path, APPEND]\",\n",
        "69": "            SourceSinkFactories.appendingPathByteSinkFactory()));\n",
        "70": "    suite.addTest(\n",
        "71": "        CharSourceTester.tests(\n",
        "72": "            \"MoreFiles.asCharSource[Path, Charset]\",\n",
        "73": "            SourceSinkFactories.pathCharSourceFactory(),\n",
        "74": "            false));\n",
        "75": "    suite.addTest(\n",
        "76": "        CharSinkTester.tests(\n",
        "77": "            \"MoreFiles.asCharSink[Path, Charset]\", SourceSinkFactories.pathCharSinkFactory()));\n",
        "78": "    suite.addTest(\n",
        "79": "        CharSinkTester.tests(\n",
        "80": "            \"MoreFiles.asCharSink[Path, Charset, APPEND]\",\n",
        "81": "            SourceSinkFactories.appendingPathCharSinkFactory()));\n",
        "103": "      Files.walkFileTree(\n",
        "104": "          tempDir,\n",
        "105": "          new SimpleFileVisitor<Path>() {\n",
        "106": "            @Override\n",
        "107": "            public FileVisitResult visitFile(Path file, BasicFileAttributes attrs)\n",
        "108": "                throws IOException {\n",
        "109": "              Files.deleteIfExists(file);\n",
        "110": "              return FileVisitResult.CONTINUE;\n",
        "111": "            }\n",
        "113": "            @Override\n",
        "114": "            public FileVisitResult postVisitDirectory(Path dir, IOException exc)\n",
        "115": "                throws IOException {\n",
        "116": "              if (exc != null) {\n",
        "117": "                return FileVisitResult.TERMINATE;\n",
        "118": "              }\n",
        "119": "              Files.deleteIfExists(dir);\n",
        "120": "              return FileVisitResult.CONTINUE;\n",
        "121": "            }\n",
        "122": "          });\n",
        "425": "    FileSystem fs =\n",
        "426": "        Jimfs.newFileSystem(\n",
        "427": "            Configuration.unix()\n",
        "428": "                .toBuilder()\n",
        "429": "                .setSupportedFeatures(ObjectArrays.concat(SYMBOLIC_LINKS, supportedFeatures))\n",
        "430": "                .build());\n",
        "457": "        assertEquals(\n",
        "458": "            \"contents of /dontdelete deleted by delete method \" + method,\n",
        "459": "            3,\n",
        "460": "            MoreFiles.listFiles(fs.getPath(\"/dontdelete\")).size());\n",
        "535": "        assertEquals(\n",
        "536": "            \"contents of /dontdelete deleted by delete method \" + method,\n",
        "537": "            3,\n",
        "538": "            MoreFiles.listFiles(fs.getPath(\"/dontdelete\")).size());\n",
        "573": "   * This test attempts to create a situation in which one thread is constantly changing a file from\n",
        "574": "   * being a real directory to being a symlink to another directory. It then calls\n",
        "576": "   * that's switching between directory and symlink to try to ensure that under no circumstance does\n",
        "577": "   * deleteDirectoryContents follow the symlink to the other directory and delete that directory's\n",
        "578": "   * contents.\n",
        "647": "   * between being a directory and being a symlink, while the given {@code target} is the target the\n",
        "648": "   * symlink should have.\n",
        "680": "  /** Enum defining the two MoreFiles methods that delete directory contents. */\n",
        "690": "        assertEquals(\n",
        "691": "            \"contents of directory \" + path + \" not deleted with delete method \" + this,\n",
        "692": "            0,\n",
        "693": "            MoreFiles.listFiles(path).size());\n",
        "704": "        assertFalse(\"file \" + path + \" not deleted with delete method \" + this, Files.exists(path));\n"
    },
    "removed": {
        "60": "    suite.addTest(ByteSourceTester.tests(\"MoreFiles.asByteSource[Path]\",\n",
        "61": "        SourceSinkFactories.pathByteSourceFactory(), true));\n",
        "62": "    suite.addTest(ByteSinkTester.tests(\"MoreFiles.asByteSink[Path]\",\n",
        "63": "        SourceSinkFactories.pathByteSinkFactory()));\n",
        "64": "    suite.addTest(ByteSinkTester.tests(\"MoreFiles.asByteSink[Path, APPEND]\",\n",
        "65": "        SourceSinkFactories.appendingPathByteSinkFactory()));\n",
        "66": "    suite.addTest(CharSourceTester.tests(\"MoreFiles.asCharSource[Path, Charset]\",\n",
        "67": "        SourceSinkFactories.pathCharSourceFactory(), false));\n",
        "68": "    suite.addTest(CharSinkTester.tests(\"MoreFiles.asCharSink[Path, Charset]\",\n",
        "69": "        SourceSinkFactories.pathCharSinkFactory()));\n",
        "70": "    suite.addTest(CharSinkTester.tests(\"MoreFiles.asCharSink[Path, Charset, APPEND]\",\n",
        "71": "        SourceSinkFactories.appendingPathCharSinkFactory()));\n",
        "93": "      Files.walkFileTree(tempDir, new SimpleFileVisitor<Path>() {\n",
        "94": "        @Override\n",
        "95": "        public FileVisitResult visitFile(Path file, BasicFileAttributes attrs) throws IOException {\n",
        "96": "          Files.deleteIfExists(file);\n",
        "97": "          return FileVisitResult.CONTINUE;\n",
        "98": "        }\n",
        "100": "        @Override\n",
        "101": "        public FileVisitResult postVisitDirectory(Path dir, IOException exc) throws IOException {\n",
        "102": "          if (exc != null) {\n",
        "103": "            return FileVisitResult.TERMINATE;\n",
        "104": "          }\n",
        "105": "          Files.deleteIfExists(dir);\n",
        "106": "          return FileVisitResult.CONTINUE;\n",
        "107": "        }\n",
        "108": "      });\n",
        "411": "    FileSystem fs = Jimfs.newFileSystem(Configuration.unix().toBuilder()\n",
        "412": "        .setSupportedFeatures(ObjectArrays.concat(SYMBOLIC_LINKS, supportedFeatures))\n",
        "413": "        .build());\n",
        "440": "        assertEquals(\"contents of /dontdelete deleted by delete method \" + method,\n",
        "441": "            3, MoreFiles.listFiles(fs.getPath(\"/dontdelete\")).size());\n",
        "516": "        assertEquals(\"contents of /dontdelete deleted by delete method \" + method,\n",
        "517": "            3, MoreFiles.listFiles(fs.getPath(\"/dontdelete\")).size());\n",
        "552": "   * This test attempts to create a situation in which one thread is constantly changing a file\n",
        "553": "   * from being a real directory to being a symlink to another directory. It then calls\n",
        "555": "   * that's switching between directory and symlink to try to ensure that under no circumstance\n",
        "556": "   * does deleteDirectoryContents follow the symlink to the other directory and delete that\n",
        "557": "   * directory's contents.\n",
        "626": "   * between being a directory and being a symlink, while the given {@code target} is the target\n",
        "627": "   * the symlink should have.\n",
        "659": "  /**\n",
        "660": "   * Enum defining the two MoreFiles methods that delete directory contents.\n",
        "661": "   */\n",
        "671": "        assertEquals(\"contents of directory \" + path + \" not deleted with delete method \" + this,\n",
        "672": "            0, MoreFiles.listFiles(path).size());\n",
        "683": "        assertFalse(\"file \" + path + \" not deleted with delete method \" + this,\n",
        "684": "            Files.exists(path));\n"
    }
}