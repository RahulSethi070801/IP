{
    "addition": {
        "33": " * A collection that maps keys to values, similar to {@link Map}, but in which each key may be\n",
        "34": " * associated with <i>multiple</i> values. You can visualize the contents of a multimap either as a\n",
        "35": " * map from keys to <i>nonempty</i> collections of values:\n",
        "38": " *   <li>a \u2192 1, 2\n",
        "39": " *   <li>b \u2192 3\n",
        "45": " *   <li>a \u2192 1\n",
        "46": " *   <li>a \u2192 2\n",
        "47": " *   <li>b \u2192 3\n",
        "50": " * <p><b>Important:</b> although the first interpretation resembles how most multimaps are\n",
        "51": " * <i>implemented</i>, the design of the {@code Multimap} API is based on the <i>second</i> form.\n",
        "52": " * So, using the multimap shown above as an example, the {@link #size} is {@code 3}, not {@code 2},\n",
        "53": " * and the {@link #values} collection is {@code [1, 2, 3]}, not {@code [[1, 2], [3]]}. For those\n",
        "54": " * times when the first style is more useful, use the multimap's {@link #asMap} view (or create a\n",
        "55": " * {@code Map<K, Collection<V>>} in the first place).\n",
        "59": " * <p>The following code:\n",
        "61": " * <pre>{@code\n",
        "62": " * ListMultimap<String, String> multimap = ArrayListMultimap.create();\n",
        "63": " * for (President pres : US_PRESIDENTS_IN_ORDER) {\n",
        "64": " *   multimap.put(pres.firstName(), pres.lastName());\n",
        "65": " * }\n",
        "66": " * for (String firstName : multimap.keySet()) {\n",
        "67": " *   List<String> lastNames = multimap.get(firstName);\n",
        "68": " *   out.println(firstName + \": \" + lastNames);\n",
        "69": " * }\n",
        "70": " * }</pre>\n",
        "72": " * ... produces output such as:\n",
        "74": " * <pre>{@code\n",
        "75": " * Zachary: [Taylor]\n",
        "76": " * John: [Adams, Adams, Tyler, Kennedy]  // Remember, Quincy!\n",
        "77": " * George: [Washington, Bush, Bush]\n",
        "78": " * Grover: [Cleveland, Cleveland]        // Two, non-consecutive terms, rep'ing NJ!\n",
        "79": " * ...\n",
        "80": " * }</pre>\n",
        "84": " * <p>Much of the power of the multimap API comes from the <i>view collections</i> it provides.\n",
        "85": " * These always reflect the latest state of the multimap itself. When they support modification, the\n",
        "86": " * changes are <i>write-through</i> (they automatically update the backing multimap). These view\n",
        "87": " * collections are:\n",
        "90": " *   <li>{@link #asMap}, mentioned above\n",
        "91": " *   <li>{@link #keys}, {@link #keySet}, {@link #values}, {@link #entries}, which are similar to the\n",
        "92": " *       corresponding view collections of {@link Map}\n",
        "93": " *   <li>and, notably, even the collection returned by {@link #get get(key)} is an active view of\n",
        "94": " *       the values corresponding to {@code key}\n",
        "97": " * <p>The collections returned by the {@link #replaceValues replaceValues} and {@link #removeAll\n",
        "98": " * removeAll} methods, which contain values that have just been removed from the multimap, are\n",
        "99": " * naturally <i>not</i> views.\n",
        "103": " * <p>Instead of using the {@code Multimap} interface directly, prefer the subinterfaces {@link\n",
        "104": " * ListMultimap} and {@link SetMultimap}. These take their names from the fact that the collections\n",
        "105": " * they return from {@code get} behave like (and, of course, implement) {@link List} and {@link\n",
        "106": " * Set}, respectively.\n",
        "108": " * <p>For example, the \"presidents\" code snippet above used a {@code ListMultimap}; if it had used a\n",
        "109": " * {@code SetMultimap} instead, two presidents would have vanished, and last names might or might\n",
        "110": " * not appear in chronological order.\n",
        "112": " * <p><b>Warning:</b> instances of type {@code Multimap} may not implement {@link Object#equals} in\n",
        "113": " * the way you expect. Multimaps containing the same key-value pairs, even in the same order, may or\n",
        "114": " * may not be equal and may or may not have the same {@code hashCode}. The recommended subinterfaces\n",
        "119": " * <p>Multimaps are commonly used in places where a {@code Map<K, Collection<V>>} would otherwise\n",
        "120": " * have appeared. The differences include:\n",
        "123": " *   <li>There is no need to populate an empty collection before adding an entry with {@link #put\n",
        "124": " *       put}.\n",
        "125": " *   <li>{@code get} never returns {@code null}, only an empty collection.\n",
        "126": " *   <li>A key is contained in the multimap if and only if it maps to at least one value. Any\n",
        "127": " *       operation that causes a key to have zero associated values has the effect of\n",
        "128": " *       <i>removing</i> that key from the multimap.\n",
        "129": " *   <li>The total entry count is available as {@link #size}.\n",
        "130": " *   <li>Many complex operations become easier; for example, {@code\n",
        "131": " *       Collections.min(multimap.values())} finds the smallest value across all keys.\n",
        "136": " * <p>As always, prefer the immutable implementations, {@link ImmutableListMultimap} and {@link\n",
        "137": " * ImmutableSetMultimap}. General-purpose mutable implementations are listed above under \"All Known\n",
        "138": " * Implementing Classes\". You can also create a <i>custom</i> multimap, backed by any {@code Map}\n",
        "139": " * and {@link Collection} types, using the {@link Multimaps#newMultimap Multimaps.newMultimap}\n",
        "140": " * family of methods. Finally, another popular way to obtain a multimap is using {@link\n",
        "141": " * Multimaps#index Multimaps.index}. See the {@link Multimaps} class for these and other static\n",
        "142": " * utilities related to multimaps.\n",
        "146": " * <p>As with {@code Map}, the behavior of a {@code Multimap} is not specified if key objects\n",
        "147": " * already present in the multimap change in a manner that affects {@code equals} comparisons. Use\n",
        "148": " * caution if mutable objects are used as keys in a {@code Multimap}.\n",
        "150": " * <p>All methods that modify the multimap are optional. The view collections returned by the\n",
        "151": " * multimap may or may not be modifiable. Any modification method that is not supported will throw\n",
        "152": " * {@link UnsupportedOperationException}.\n",
        "155": " * \"https://github.com/google/guava/wiki/NewCollectionTypesExplained#multimap\"> {@code\n",
        "156": " * Multimap}</a>.\n",
        "168": "   * <p><b>Note:</b> this method does not return the number of <i>distinct keys</i> in the multimap,\n",
        "169": "   * which is given by {@code keySet().size()} or {@code asMap().size()}. See the opening section of\n",
        "170": "   * the {@link Multimap} class documentation for clarification.\n",
        "175": "   * Returns {@code true} if this multimap contains no key-value pairs. Equivalent to {@code size()\n",
        "176": "   * == 0}, but can in some cases be more efficient.\n",
        "181": "   * Returns {@code true} if this multimap contains at least one key-value pair with the key {@code\n",
        "182": "   * key}.\n",
        "187": "   * Returns {@code true} if this multimap contains at least one key-value pair with the value\n",
        "188": "   * {@code value}.\n",
        "193": "   * Returns {@code true} if this multimap contains at least one key-value pair with the key {@code\n",
        "194": "   * key} and the value {@code value}.\n",
        "197": "      @CompatibleWith(\"K\") @Nullable Object key, @CompatibleWith(\"V\") @Nullable Object value);\n",
        "204": "   * <p>Some multimap implementations allow duplicate key-value pairs, in which case {@code put}\n",
        "205": "   * always adds a new key-value pair and increases the multimap size by 1. Other implementations\n",
        "206": "   * prohibit duplicates, and storing a key-value pair that's already in the multimap has no effect.\n",
        "208": "   * @return {@code true} if the method increased the size of the multimap, or {@code false} if the\n",
        "209": "   *     multimap already contained the key-value pair and doesn't allow duplicates\n",
        "215": "   * Removes a single key-value pair with the key {@code key} and the value {@code value} from this\n",
        "216": "   * multimap, if such exists. If multiple key-value pairs in the multimap fit this description,\n",
        "217": "   * which one is removed is unspecified.\n",
        "223": "      @CompatibleWith(\"K\") @Nullable Object key, @CompatibleWith(\"V\") @Nullable Object value);\n",
        "228": "   * Stores a key-value pair in this multimap for each of {@code values}, all using the same key,\n",
        "229": "   * {@code key}. Equivalent to (but expected to be more efficient than):\n",
        "231": "   * <pre>{@code\n",
        "232": "   * for (V value : values) {\n",
        "233": "   *   put(key, value);\n",
        "234": "   * }\n",
        "235": "   * }</pre>\n",
        "245": "   * Stores all key-value pairs of {@code multimap} in this multimap, in the order returned by\n",
        "246": "   * {@code multimap.entries()}.\n",
        "254": "   * Stores a collection of values with the same key, replacing any existing values for that key.\n",
        "256": "   * <p>If {@code values} is empty, this is equivalent to {@link #removeAll(Object) removeAll(key)}.\n",
        "258": "   * @return the collection of replaced values, or an empty collection if no values were previously\n",
        "259": "   *     associated with the key. The collection <i>may</i> be modifiable, but updating it will have\n",
        "260": "   *     no effect on the multimap.\n",
        "268": "   * <p>Once this method returns, {@code key} will not be mapped to any values, so it will not\n",
        "269": "   * appear in {@link #keySet()}, {@link #asMap()}, or any other views.\n",
        "271": "   * @return the values that were removed (possibly empty). The returned collection <i>may</i> be\n",
        "272": "   *     modifiable, but updating it will have no effect on the multimap.\n",
        "277": "  /** Removes all key-value pairs from the multimap, leaving it {@linkplain #isEmpty empty}. */\n",
        "283": "   * Returns a view collection of the values associated with {@code key} in this multimap, if any.\n",
        "284": "   * Note that when {@code containsKey(key)} is false, this returns an empty collection, not {@code\n",
        "285": "   * null}.\n",
        "287": "   * <p>Changes to the returned collection will update the underlying multimap, and vice versa.\n",
        "292": "   * Returns a view collection of all <i>distinct</i> keys contained in this multimap. Note that the\n",
        "293": "   * key set contains a key if and only if this multimap maps that key to at least one value.\n",
        "295": "   * <p>Changes to the returned set will update the underlying multimap, and vice versa. However,\n",
        "296": "   * <i>adding</i> to the returned set is not possible.\n",
        "301": "   * Returns a view collection containing the key from each key-value pair in this multimap,\n",
        "302": "   * <i>without</i> collapsing duplicates. This collection has the same size as this multimap, and\n",
        "303": "   * {@code keys().count(k) == get(k).size()} for all {@code k}.\n",
        "305": "   * <p>Changes to the returned multiset will update the underlying multimap, and vice versa.\n",
        "306": "   * However, <i>adding</i> to the returned collection is not possible.\n",
        "311": "   * Returns a view collection containing the <i>value</i> from each key-value pair contained in\n",
        "312": "   * this multimap, without collapsing duplicates (so {@code values().size() == size()}).\n",
        "314": "   * <p>Changes to the returned collection will update the underlying multimap, and vice versa.\n",
        "315": "   * However, <i>adding</i> to the returned collection is not possible.\n",
        "320": "   * Returns a view collection of all key-value pairs contained in this multimap, as {@link Entry}\n",
        "321": "   * instances.\n",
        "323": "   * <p>Changes to the returned collection or the entries it contains will update the underlying\n",
        "324": "   * multimap, and vice versa. However, <i>adding</i> to the returned collection is not possible.\n",
        "333": "   * <p>To loop over all keys and their associated value collections, write {@code\n",
        "334": "   * Multimaps.asMap(multimap).forEach((key, valueCollection) -> action())}.\n",
        "344": "   * Returns a view of this multimap as a {@code Map} from each distinct key to the nonempty\n",
        "345": "   * collection of that key's associated values. Note that {@code this.asMap().get(k)} is equivalent\n",
        "346": "   * to {@code this.get(k)} only when {@code k} is a key contained in the multimap; otherwise it\n",
        "347": "   * returns {@code null} as opposed to an empty collection.\n",
        "349": "   * <p>Changes to the returned map or the collections that serve as its values will update the\n",
        "350": "   * underlying multimap, and vice versa. The map does not support {@code put} or {@code putAll},\n",
        "351": "   * nor do its entries support {@link Entry#setValue setValue}.\n",
        "358": "   * Compares the specified object with this multimap for equality. Two multimaps are equal when\n",
        "359": "   * their map views, as returned by {@link #asMap}, are also equal.\n",
        "361": "   * <p>In general, two multimaps with identical key-value mappings may or may not be equal,\n",
        "362": "   * depending on the implementation. For example, two {@link SetMultimap} instances with the same\n",
        "363": "   * key-value mappings are equal, but equality of two {@link ListMultimap} instances depends on the\n",
        "364": "   * ordering of the values for each key.\n",
        "366": "   * <p>A non-empty {@link SetMultimap} cannot be equal to a non-empty {@link ListMultimap}, since\n",
        "367": "   * their {@link #asMap} views contain unequal collections as values. However, any two empty\n",
        "368": "   * multimaps are equal, because they both have empty {@link #asMap} views.\n",
        "376": "   * <p>The hash code of a multimap is defined as the hash code of the map view, as returned by\n",
        "377": "   * {@link Multimap#asMap}.\n",
        "379": "   * <p>In general, two multimaps with identical key-value mappings may or may not have the same\n",
        "380": "   * hash codes, depending on the implementation. For example, two {@link SetMultimap} instances\n",
        "381": "   * with the same key-value mappings will have the same {@code hashCode}, but the {@code hashCode}\n",
        "382": "   * of {@link ListMultimap} instances depends on the ordering of the values for each key.\n"
    },
    "removed": {
        "33": " * A collection that maps keys to values, similar to {@link Map}, but in which\n",
        "34": " * each key may be associated with <i>multiple</i> values. You can visualize the\n",
        "35": " * contents of a multimap either as a map from keys to <i>nonempty</i>\n",
        "36": " * collections of values:\n",
        "39": " * <li>a \u2192 1, 2\n",
        "40": " * <li>b \u2192 3\n",
        "46": " * <li>a \u2192 1\n",
        "47": " * <li>a \u2192 2\n",
        "48": " * <li>b \u2192 3\n",
        "51": " * <p><b>Important:</b> although the first interpretation resembles how most\n",
        "52": " * multimaps are <i>implemented</i>, the design of the {@code Multimap} API is\n",
        "53": " * based on the <i>second</i> form. So, using the multimap shown above as an\n",
        "54": " * example, the {@link #size} is {@code 3}, not {@code 2}, and the {@link\n",
        "55": " * #values} collection is {@code [1, 2, 3]}, not {@code [[1, 2], [3]]}. For\n",
        "56": " * those times when the first style is more useful, use the multimap's {@link\n",
        "57": " * #asMap} view (or create a {@code Map<K, Collection<V>>} in the first place).\n",
        "61": " * <p>The following code: <pre>   {@code\n",
        "63": " *   ListMultimap<String, String> multimap = ArrayListMultimap.create();\n",
        "64": " *   for (President pres : US_PRESIDENTS_IN_ORDER) {\n",
        "65": " *     multimap.put(pres.firstName(), pres.lastName());\n",
        "66": " *   }\n",
        "67": " *   for (String firstName : multimap.keySet()) {\n",
        "68": " *     List<String> lastNames = multimap.get(firstName);\n",
        "69": " *     out.println(firstName + \": \" + lastNames);\n",
        "70": " *   }}</pre>\n",
        "72": " * ... produces output such as: <pre>   {@code\n",
        "74": " *   Zachary: [Taylor]\n",
        "75": " *   John: [Adams, Adams, Tyler, Kennedy]  // Remember, Quincy!\n",
        "76": " *   George: [Washington, Bush, Bush]\n",
        "77": " *   Grover: [Cleveland, Cleveland]        // Two, non-consecutive terms, rep'ing NJ!\n",
        "78": " *   ...}</pre>\n",
        "82": " * <p>Much of the power of the multimap API comes from the <i>view\n",
        "83": " * collections</i> it provides. These always reflect the latest state of the\n",
        "84": " * multimap itself. When they support modification, the changes are\n",
        "85": " * <i>write-through</i> (they automatically update the backing multimap). These\n",
        "86": " * view collections are:\n",
        "89": " * <li>{@link #asMap}, mentioned above</li>\n",
        "90": " * <li>{@link #keys}, {@link #keySet}, {@link #values}, {@link #entries}, which\n",
        "91": " *     are similar to the corresponding view collections of {@link Map}\n",
        "92": " * <li>and, notably, even the collection returned by {@link #get get(key)} is an\n",
        "93": " *     active view of the values corresponding to {@code key}\n",
        "96": " * <p>The collections returned by the {@link #replaceValues replaceValues} and\n",
        "97": " * {@link #removeAll removeAll} methods, which contain values that have just\n",
        "98": " * been removed from the multimap, are naturally <i>not</i> views.\n",
        "102": " * <p>Instead of using the {@code Multimap} interface directly, prefer the\n",
        "103": " * subinterfaces {@link ListMultimap} and {@link SetMultimap}. These take their\n",
        "104": " * names from the fact that the collections they return from {@code get} behave\n",
        "105": " * like (and, of course, implement) {@link List} and {@link Set}, respectively.\n",
        "107": " * <p>For example, the \"presidents\" code snippet above used a {@code\n",
        "108": " * ListMultimap}; if it had used a {@code SetMultimap} instead, two presidents\n",
        "109": " * would have vanished, and last names might or might not appear in\n",
        "110": " * chronological order.\n",
        "112": " * <p><b>Warning:</b> instances of type {@code Multimap} may not implement\n",
        "113": " * {@link Object#equals} in the way you expect.  Multimaps containing the same\n",
        "114": " * key-value pairs, even in the same order, may or may not be equal and may or\n",
        "115": " * may not have the same {@code hashCode}. The recommended subinterfaces\n",
        "120": " * <p>Multimaps are commonly used in places where a {@code Map<K,\n",
        "121": " * Collection<V>>} would otherwise have appeared. The differences include:\n",
        "124": " * <li>There is no need to populate an empty collection before adding an entry\n",
        "125": " *     with {@link #put put}.\n",
        "126": " * <li>{@code get} never returns {@code null}, only an empty collection.\n",
        "127": " * <li>A key is contained in the multimap if and only if it maps to at least\n",
        "128": " *     one value. Any operation that causes a key to have zero associated\n",
        "129": " *     values has the effect of <i>removing</i> that key from the multimap.\n",
        "130": " * <li>The total entry count is available as {@link #size}.\n",
        "131": " * <li>Many complex operations become easier; for example, {@code\n",
        "132": " *     Collections.min(multimap.values())} finds the smallest value across all\n",
        "133": " *     keys.\n",
        "138": " * <p>As always, prefer the immutable implementations, {@link\n",
        "139": " * ImmutableListMultimap} and {@link ImmutableSetMultimap}. General-purpose\n",
        "140": " * mutable implementations are listed above under \"All Known Implementing\n",
        "141": " * Classes\". You can also create a <i>custom</i> multimap, backed by any {@code\n",
        "142": " * Map} and {@link Collection} types, using the {@link Multimaps#newMultimap\n",
        "143": " * Multimaps.newMultimap} family of methods. Finally, another popular way to\n",
        "144": " * obtain a multimap is using {@link Multimaps#index Multimaps.index}. See\n",
        "145": " * the {@link Multimaps} class for these and other static utilities related\n",
        "146": " * to multimaps.\n",
        "150": " * <p>As with {@code Map}, the behavior of a {@code Multimap} is not specified\n",
        "151": " * if key objects already present in the multimap change in a manner that\n",
        "152": " * affects {@code equals} comparisons.  Use caution if mutable objects are used\n",
        "153": " * as keys in a {@code Multimap}.\n",
        "155": " * <p>All methods that modify the multimap are optional. The view collections\n",
        "156": " * returned by the multimap may or may not be modifiable. Any modification\n",
        "157": " * method that is not supported will throw {@link\n",
        "158": " * UnsupportedOperationException}.\n",
        "161": " * \"https://github.com/google/guava/wiki/NewCollectionTypesExplained#multimap\">\n",
        "162": " * {@code Multimap}</a>.\n",
        "174": "   * <p><b>Note:</b> this method does not return the number of <i>distinct\n",
        "175": "   * keys</i> in the multimap, which is given by {@code keySet().size()} or\n",
        "176": "   * {@code asMap().size()}. See the opening section of the {@link Multimap}\n",
        "177": "   * class documentation for clarification.\n",
        "182": "   * Returns {@code true} if this multimap contains no key-value pairs.\n",
        "183": "   * Equivalent to {@code size() == 0}, but can in some cases be more efficient.\n",
        "188": "   * Returns {@code true} if this multimap contains at least one key-value pair\n",
        "189": "   * with the key {@code key}.\n",
        "194": "   * Returns {@code true} if this multimap contains at least one key-value pair\n",
        "195": "   * with the value {@code value}.\n",
        "200": "   * Returns {@code true} if this multimap contains at least one key-value pair\n",
        "201": "   * with the key {@code key} and the value {@code value}.\n",
        "204": "      @CompatibleWith(\"K\") @Nullable Object key,\n",
        "205": "      @CompatibleWith(\"V\") @Nullable Object value);\n",
        "212": "   * <p>Some multimap implementations allow duplicate key-value pairs, in which\n",
        "213": "   * case {@code put} always adds a new key-value pair and increases the\n",
        "214": "   * multimap size by 1. Other implementations prohibit duplicates, and storing\n",
        "215": "   * a key-value pair that's already in the multimap has no effect.\n",
        "217": "   * @return {@code true} if the method increased the size of the multimap, or\n",
        "218": "   *     {@code false} if the multimap already contained the key-value pair and\n",
        "219": "   *     doesn't allow duplicates\n",
        "225": "   * Removes a single key-value pair with the key {@code key} and the value\n",
        "226": "   * {@code value} from this multimap, if such exists. If multiple key-value\n",
        "227": "   * pairs in the multimap fit this description, which one is removed is\n",
        "228": "   * unspecified.\n",
        "234": "      @CompatibleWith(\"K\") @Nullable Object key,\n",
        "235": "      @CompatibleWith(\"V\") @Nullable Object value);\n",
        "240": "   * Stores a key-value pair in this multimap for each of {@code values}, all\n",
        "241": "   * using the same key, {@code key}. Equivalent to (but expected to be more\n",
        "242": "   * efficient than): <pre>   {@code\n",
        "244": "   *   for (V value : values) {\n",
        "245": "   *     put(key, value);\n",
        "246": "   *   }}</pre>\n",
        "256": "   * Stores all key-value pairs of {@code multimap} in this multimap, in the\n",
        "257": "   * order returned by {@code multimap.entries()}.\n",
        "265": "   * Stores a collection of values with the same key, replacing any existing\n",
        "266": "   * values for that key.\n",
        "268": "   * <p>If {@code values} is empty, this is equivalent to\n",
        "269": "   * {@link #removeAll(Object) removeAll(key)}.\n",
        "271": "   * @return the collection of replaced values, or an empty collection if no\n",
        "272": "   *     values were previously associated with the key. The collection\n",
        "273": "   *     <i>may</i> be modifiable, but updating it will have no effect on the\n",
        "274": "   *     multimap.\n",
        "282": "   * <p>Once this method returns, {@code key} will not be mapped to any values,\n",
        "283": "   * so it will not appear in {@link #keySet()}, {@link #asMap()}, or any other\n",
        "284": "   * views.\n",
        "286": "   * @return the values that were removed (possibly empty). The returned\n",
        "287": "   *     collection <i>may</i> be modifiable, but updating it will have no\n",
        "288": "   *     effect on the multimap.\n",
        "293": "  /**\n",
        "294": "   * Removes all key-value pairs from the multimap, leaving it {@linkplain\n",
        "295": "   * #isEmpty empty}.\n",
        "296": "   */\n",
        "302": "   * Returns a view collection of the values associated with {@code key} in this\n",
        "303": "   * multimap, if any. Note that when {@code containsKey(key)} is false, this\n",
        "304": "   * returns an empty collection, not {@code null}.\n",
        "306": "   * <p>Changes to the returned collection will update the underlying multimap,\n",
        "307": "   * and vice versa.\n",
        "312": "   * Returns a view collection of all <i>distinct</i> keys contained in this\n",
        "313": "   * multimap. Note that the key set contains a key if and only if this multimap\n",
        "314": "   * maps that key to at least one value.\n",
        "316": "   * <p>Changes to the returned set will update the underlying multimap, and\n",
        "317": "   * vice versa. However, <i>adding</i> to the returned set is not possible.\n",
        "322": "   * Returns a view collection containing the key from each key-value pair in\n",
        "323": "   * this multimap, <i>without</i> collapsing duplicates. This collection has\n",
        "324": "   * the same size as this multimap, and {@code keys().count(k) ==\n",
        "325": "   * get(k).size()} for all {@code k}.\n",
        "327": "   * <p>Changes to the returned multiset will update the underlying multimap,\n",
        "328": "   * and vice versa. However, <i>adding</i> to the returned collection is not\n",
        "329": "   * possible.\n",
        "334": "   * Returns a view collection containing the <i>value</i> from each key-value\n",
        "335": "   * pair contained in this multimap, without collapsing duplicates (so {@code\n",
        "336": "   * values().size() == size()}).\n",
        "338": "   * <p>Changes to the returned collection will update the underlying multimap,\n",
        "339": "   * and vice versa. However, <i>adding</i> to the returned collection is not\n",
        "340": "   * possible.\n",
        "345": "   * Returns a view collection of all key-value pairs contained in this\n",
        "346": "   * multimap, as {@link Entry} instances.\n",
        "348": "   * <p>Changes to the returned collection or the entries it contains will\n",
        "349": "   * update the underlying multimap, and vice versa. However, <i>adding</i> to\n",
        "350": "   * the returned collection is not possible.\n",
        "359": "   * <p>To loop over all keys and their associated value collections, write\n",
        "360": "   * {@code Multimaps.asMap(multimap).forEach((key, valueCollection) -> action())}.\n",
        "370": "   * Returns a view of this multimap as a {@code Map} from each distinct key\n",
        "371": "   * to the nonempty collection of that key's associated values. Note that\n",
        "372": "   * {@code this.asMap().get(k)} is equivalent to {@code this.get(k)} only when\n",
        "373": "   * {@code k} is a key contained in the multimap; otherwise it returns {@code\n",
        "374": "   * null} as opposed to an empty collection.\n",
        "376": "   * <p>Changes to the returned map or the collections that serve as its values\n",
        "377": "   * will update the underlying multimap, and vice versa. The map does not\n",
        "378": "   * support {@code put} or {@code putAll}, nor do its entries support {@link\n",
        "379": "   * Entry#setValue setValue}.\n",
        "386": "   * Compares the specified object with this multimap for equality. Two\n",
        "387": "   * multimaps are equal when their map views, as returned by {@link #asMap},\n",
        "388": "   * are also equal.\n",
        "390": "   * <p>In general, two multimaps with identical key-value mappings may or may\n",
        "391": "   * not be equal, depending on the implementation. For example, two\n",
        "392": "   * {@link SetMultimap} instances with the same key-value mappings are equal,\n",
        "393": "   * but equality of two {@link ListMultimap} instances depends on the ordering\n",
        "394": "   * of the values for each key.\n",
        "396": "   * <p>A non-empty {@link SetMultimap} cannot be equal to a non-empty\n",
        "397": "   * {@link ListMultimap}, since their {@link #asMap} views contain unequal\n",
        "398": "   * collections as values. However, any two empty multimaps are equal, because\n",
        "399": "   * they both have empty {@link #asMap} views.\n",
        "407": "   * <p>The hash code of a multimap is defined as the hash code of the map view,\n",
        "408": "   * as returned by {@link Multimap#asMap}.\n",
        "410": "   * <p>In general, two multimaps with identical key-value mappings may or may\n",
        "411": "   * not have the same hash codes, depending on the implementation. For\n",
        "412": "   * example, two {@link SetMultimap} instances with the same key-value\n",
        "413": "   * mappings will have the same {@code hashCode}, but the {@code hashCode}\n",
        "414": "   * of {@link ListMultimap} instances depends on the ordering of the values\n",
        "415": "   * for each key.\n"
    }
}