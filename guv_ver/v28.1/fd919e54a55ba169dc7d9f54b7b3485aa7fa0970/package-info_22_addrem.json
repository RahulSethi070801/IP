{
    "addition": {
        "22": " * <p>See the Guava User Guide article on <a\n",
        "23": " * href=\"https://github.com/google/guava/wiki/EventBusExplained\">{@code EventBus}</a>.\n",
        "32": " *\n",
        "34": " *   <li><strong>...in traditional Java events:</strong> implement an interface defined with the\n",
        "35": " *       event &mdash; such as CustomerChangeEventListener.\n",
        "36": " *   <li><strong>...with EventBus:</strong> create a method that accepts CustomerChangeEvent as its\n",
        "37": " *       sole argument, and mark it with the {@link com.google.common.eventbus.Subscribe}\n",
        "38": " *       annotation.\n",
        "42": " *\n",
        "44": " *   <li><strong>...in traditional Java events:</strong> pass your object to each producer's {@code\n",
        "45": " *       registerCustomerChangeEventListener} method. These methods are rarely defined in common\n",
        "46": " *       interfaces, so in addition to knowing every possible producer, you must also know its type.\n",
        "47": " *   <li><strong>...with EventBus:</strong> pass your object to the {@link\n",
        "48": " *       com.google.common.eventbus.EventBus#register(Object)} method on an EventBus. You'll need to\n",
        "49": " *       make sure that your object shares an EventBus instance with the event producers.\n",
        "53": " *\n",
        "55": " *   <li><strong>...in traditional Java events:</strong> not easy.\n",
        "56": " *   <li><strong>...with EventBus:</strong> events are automatically dispatched to listeners of any\n",
        "57": " *       supertype, allowing listeners for interface types or \"wildcard listeners\" for Object.\n",
        "61": " *\n",
        "63": " *   <li><strong>...in traditional Java events:</strong> add code to each event-dispatching method\n",
        "64": " *       (perhaps using AOP).\n",
        "65": " *   <li><strong>...with EventBus:</strong> subscribe to {@link\n",
        "66": " *       com.google.common.eventbus.DeadEvent}. The EventBus will notify you of any events that were\n",
        "67": " *       posted but not delivered. (Handy for debugging.)\n",
        "73": " *\n",
        "75": " *   <li><strong>...in traditional Java events:</strong> write code to manage a list of listeners to\n",
        "76": " *       your object, including synchronization, or use a utility class like EventListenerList.\n",
        "77": " *   <li><strong>...with EventBus:</strong> EventBus does this for you.\n",
        "81": " *\n",
        "83": " *   <li><strong>...in traditional Java events:</strong> write a method to dispatch events to each\n",
        "84": " *       event listener, including error isolation and (if desired) asynchronicity.\n",
        "85": " *   <li><strong>...with EventBus:</strong> pass the event object to an EventBus's {@link\n",
        "86": " *       com.google.common.eventbus.EventBus#post(Object)} method.\n",
        "93": " * <dl>\n",
        "94": " *   <dt>Event\n",
        "95": " *   <dd>Any object that may be <em>posted</em> to a bus.\n",
        "96": " *   <dt>Subscribing\n",
        "97": " *   <dd>The act of registering a <em>listener</em> with an EventBus, so that its <em>subscriber\n",
        "98": " *       methods</em> will receive events.\n",
        "99": " *   <dt>Listener\n",
        "100": " *   <dd>An object that wishes to receive events, by exposing <em>subscriber methods</em>.\n",
        "101": " *   <dt>Subscriber method\n",
        "102": " *   <dd>A public method that the EventBus should use to deliver <em>posted</em> events. Subscriber\n",
        "103": " *       methods are marked by the {@link com.google.common.eventbus.Subscribe} annotation.\n",
        "104": " *   <dt>Posting an event\n",
        "105": " *   <dd>Making the event available to any <em>listeners</em> through the EventBus.\n",
        "109": " *\n",
        "133": " *\n",
        "135": " *   <li>Any one class can only implement a single response to a given event.\n",
        "136": " *   <li>Listener interface methods may conflict.\n",
        "137": " *   <li>The method must be named after the event (e.g. {@code handleChangeEvent}), rather than its\n",
        "138": " *       purpose (e.g. {@code recordChangeInJournal}).\n",
        "139": " *   <li>Each event usually has its own interface, without a common parent interface for a family of\n",
        "140": " *       events (e.g. all UI events).\n",
        "146": " * <p>Compare these two cases:\n",
        "147": " *\n",
        "148": " * <pre>{@code\n",
        "149": " * class ChangeRecorder {\n",
        "150": " *   void setCustomer(Customer cust) {\n",
        "151": " *     cust.addChangeListener(new ChangeListener() {\n",
        "152": " *       void customerChanged(ChangeEvent e) {\n",
        "153": " *         recordChange(e.getChange());\n",
        "154": " *       }\n",
        "155": " *     };\n",
        "157": " * }\n",
        "159": " * // Class is typically registered by the container.\n",
        "160": " * class EventBusChangeRecorder {\n",
        "161": " *  }{@code @Subscribe void recordCustomerChange(ChangeEvent e) {\n",
        "162": " *     recordChange(e.getChange());\n",
        "163": " *   }\n",
        "164": " * }\n",
        "165": " * }</pre>\n",
        "175": " * <p>Let's say the interface looked something like the following:\n",
        "176": " *\n",
        "177": " * <pre>{@code\n",
        "178": " * interface Subscriber<T> {\n",
        "179": " *   void handleEvent(T event);\n",
        "180": " * }\n",
        "181": " * }</pre>\n",
        "244": " * EventBus receives an event with no registered subscribers, it will turn it into a {@code\n",
        "245": " * DeadEvent} and pass it your way -- allowing you to log it or otherwise recover.\n"
    },
    "removed": {
        "22": " * <p>See the Guava User Guide article on\n",
        "23": " * <a href=\"https://github.com/google/guava/wiki/EventBusExplained\">{@code EventBus}</a>.\n",
        "33": " * <li><strong>...in traditional Java events:</strong> implement an interface defined with the event\n",
        "34": " *     &mdash; such as CustomerChangeEventListener.\n",
        "35": " * <li><strong>...with EventBus:</strong> create a method that accepts CustomerChangeEvent as its\n",
        "36": " *     sole argument, and mark it with the {@link com.google.common.eventbus.Subscribe}\n",
        "37": " *     annotation.\n",
        "42": " * <li><strong>...in traditional Java events:</strong> pass your object to each producer's\n",
        "43": " *     {@code registerCustomerChangeEventListener} method. These methods are rarely defined in\n",
        "44": " *     common interfaces, so in addition to knowing every possible producer, you must also know its\n",
        "45": " *     type.\n",
        "46": " * <li><strong>...with EventBus:</strong> pass your object to the\n",
        "47": " *     {@link com.google.common.eventbus.EventBus#register(Object)} method on an EventBus. You'll\n",
        "48": " *     need to make sure that your object shares an EventBus instance with the event producers.\n",
        "53": " * <li><strong>...in traditional Java events:</strong> not easy.\n",
        "54": " * <li><strong>...with EventBus:</strong> events are automatically dispatched to listeners of any\n",
        "55": " *     supertype, allowing listeners for interface types or \"wildcard listeners\" for Object.\n",
        "60": " * <li><strong>...in traditional Java events:</strong> add code to each event-dispatching method\n",
        "61": " *     (perhaps using AOP).\n",
        "62": " * <li><strong>...with EventBus:</strong> subscribe to {@link com.google.common.eventbus.DeadEvent}.\n",
        "63": " *     The EventBus will notify you of any events that were posted but not delivered. (Handy for\n",
        "64": " *     debugging.)\n",
        "71": " * <li><strong>...in traditional Java events:</strong> write code to manage a list of listeners to\n",
        "72": " *     your object, including synchronization, or use a utility class like EventListenerList.\n",
        "73": " * <li><strong>...with EventBus:</strong> EventBus does this for you.\n",
        "78": " * <li><strong>...in traditional Java events:</strong> write a method to dispatch events to each\n",
        "79": " *     event listener, including error isolation and (if desired) asynchronicity.\n",
        "80": " * <li><strong>...with EventBus:</strong> pass the event object to an EventBus's\n",
        "81": " *     {@link com.google.common.eventbus.EventBus#post(Object)} method.\n",
        "87": " * <dl>\n",
        "88": " *\n",
        "89": " * <dt>Event\n",
        "90": " * <dd>Any object that may be <em>posted</em> to a bus.\n",
        "91": " *\n",
        "92": " * <dt>Subscribing\n",
        "93": " * <dd>The act of registering a <em>listener</em> with an EventBus, so that its\n",
        "94": " *     <em>subscriber methods</em> will receive events.\n",
        "95": " *\n",
        "96": " * <dt>Listener\n",
        "97": " * <dd>An object that wishes to receive events, by exposing <em>subscriber methods</em>.\n",
        "98": " *\n",
        "99": " * <dt>Subscriber method\n",
        "100": " * <dd>A public method that the EventBus should use to deliver <em>posted</em> events. Subscriber\n",
        "101": " *     methods are marked by the {@link com.google.common.eventbus.Subscribe} annotation.\n",
        "102": " *\n",
        "103": " * <dt>Posting an event\n",
        "104": " * <dd>Making the event available to any <em>listeners</em> through the EventBus.\n",
        "133": " * <li>Any one class can only implement a single response to a given event.\n",
        "134": " * <li>Listener interface methods may conflict.\n",
        "135": " * <li>The method must be named after the event (e.g. {@code handleChangeEvent}), rather than its\n",
        "136": " *     purpose (e.g. {@code recordChangeInJournal}).\n",
        "137": " * <li>Each event usually has its own interface, without a common parent interface for a family of\n",
        "138": " *     events (e.g. all UI events).\n",
        "144": " * <p>Compare these two cases: <pre>   {@code\n",
        "145": " *   class ChangeRecorder {\n",
        "146": " *     void setCustomer(Customer cust) {\n",
        "147": " *       cust.addChangeListener(new ChangeListener() {\n",
        "148": " *         void customerChanged(ChangeEvent e) {\n",
        "149": " *           recordChange(e.getChange());\n",
        "150": " *         }\n",
        "151": " *       };\n",
        "152": " *     }\n",
        "155": " *   // Class is typically registered by the container.\n",
        "156": " *   class EventBusChangeRecorder {\n",
        "157": " *    }{@code @Subscribe void recordCustomerChange(ChangeEvent e) {\n",
        "158": " *       recordChange(e.getChange());\n",
        "159": " *     }\n",
        "160": " *   }}</pre>\n",
        "170": " * <p>Let's say the interface looked something like the following: <pre>   {@code\n",
        "171": " *   interface Subscriber<T> {\n",
        "172": " *     void handleEvent(T event);\n",
        "173": " *   }}</pre>\n",
        "236": " * EventBus receives an event with no registered subscribers, it will turn it into a\n",
        "237": " * {@code DeadEvent} and pass it your way -- allowing you to log it or otherwise recover.\n"
    }
}