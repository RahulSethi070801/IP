{
    "addition": {
        "54": "      suite.addTest(\n",
        "55": "          ByteSourceTester.tests(\n",
        "56": "              \"ByteSource.wrap[byte[]]\",\n",
        "57": "              SourceSinkFactories.byteArraySourceFactory(),\n",
        "58": "              asCharSource));\n",
        "59": "      suite.addTest(\n",
        "60": "          ByteSourceTester.tests(\n",
        "61": "              \"ByteSource.empty[]\", SourceSinkFactories.emptyByteSourceFactory(), asCharSource));\n",
        "129": "    ByteProcessor<byte[]> processor =\n",
        "130": "        new ByteProcessor<byte[]>() {\n",
        "131": "          int pos;\n",
        "132": "\n",
        "133": "          @Override\n",
        "134": "          public boolean processBytes(byte[] buf, int off, int len) throws IOException {\n",
        "135": "            System.arraycopy(buf, off, processedBytes, pos, len);\n",
        "136": "            pos += len;\n",
        "137": "            return true;\n",
        "138": "          }\n",
        "140": "          @Override\n",
        "141": "          public byte[] getResult() {\n",
        "142": "            return processedBytes;\n",
        "143": "          }\n",
        "144": "        };\n",
        "153": "    ByteProcessor<Void> processor =\n",
        "154": "        new ByteProcessor<Void>() {\n",
        "155": "          boolean firstCall = true;\n",
        "156": "\n",
        "157": "          @Override\n",
        "158": "          public boolean processBytes(byte[] buf, int off, int len) throws IOException {\n",
        "159": "            assertTrue(\"consume() called twice\", firstCall);\n",
        "160": "            firstCall = false;\n",
        "161": "            return false;\n",
        "162": "          }\n",
        "164": "          @Override\n",
        "165": "          public Void getResult() {\n",
        "166": "            return null;\n",
        "167": "          }\n",
        "168": "        };\n",
        "276": "        return read(b) == -1 ? -1 : UnsignedBytes.toInt(b[0]);\n",
        "294": "   * @param input the size of the input source\n",
        "295": "   * @param offset the first argument to {@link ByteSource#slice}\n",
        "296": "   * @param length the second argument to {@link ByteSource#slice}\n",
        "299": "  private static void assertCorrectSlice(int input, int offset, long length, int expectRead)\n",
        "300": "      throws IOException {\n",
        "328": "      assertTrue(\n",
        "329": "          \"stream not closed when copying to sink with option: \" + option,\n",
        "362": "    assertArrayEquals(expected, ByteSource.concat(ImmutableList.of(b1, b2, b3)).read());\n",
        "363": "    assertArrayEquals(expected, ByteSource.concat(b1, b2, b3).read());\n",
        "364": "    assertArrayEquals(expected, ByteSource.concat(ImmutableList.of(b1, b2, b3).iterator()).read());\n",
        "382": "  private static final ByteSource BROKEN_CLOSE_SOURCE =\n",
        "383": "      new TestByteSource(new byte[10], CLOSE_THROWS);\n",
        "384": "  private static final ByteSource BROKEN_OPEN_SOURCE =\n",
        "385": "      new TestByteSource(new byte[10], OPEN_THROWS);\n",
        "386": "  private static final ByteSource BROKEN_READ_SOURCE =\n",
        "387": "      new TestByteSource(new byte[10], READ_THROWS);\n",
        "388": "  private static final ByteSink BROKEN_CLOSE_SINK = new TestByteSink(CLOSE_THROWS);\n",
        "389": "  private static final ByteSink BROKEN_OPEN_SINK = new TestByteSink(OPEN_THROWS);\n",
        "390": "  private static final ByteSink BROKEN_WRITE_SINK = new TestByteSink(WRITE_THROWS);\n",
        "391": "\n",
        "392": "  private static final ImmutableSet<ByteSource> BROKEN_SOURCES =\n",
        "393": "      ImmutableSet.of(BROKEN_CLOSE_SOURCE, BROKEN_OPEN_SOURCE, BROKEN_READ_SOURCE);\n",
        "394": "  private static final ImmutableSet<ByteSink> BROKEN_SINKS =\n",
        "395": "      ImmutableSet.of(BROKEN_CLOSE_SINK, BROKEN_OPEN_SINK, BROKEN_WRITE_SINK);\n",
        "471": "  /** @return the number of exceptions that were suppressed on the expected thrown exception */\n",
        "488": "      @Override\n",
        "489": "      public OutputStream openStream() {\n"
    },
    "removed": {
        "54": "      suite.addTest(ByteSourceTester.tests(\"ByteSource.wrap[byte[]]\",\n",
        "55": "          SourceSinkFactories.byteArraySourceFactory(), asCharSource));\n",
        "56": "      suite.addTest(ByteSourceTester.tests(\"ByteSource.empty[]\",\n",
        "57": "          SourceSinkFactories.emptyByteSourceFactory(), asCharSource));\n",
        "125": "    ByteProcessor<byte[]> processor = new ByteProcessor<byte[]>() {\n",
        "126": "      int pos;\n",
        "127": "\n",
        "128": "      @Override\n",
        "129": "      public boolean processBytes(byte[] buf, int off, int len) throws IOException {\n",
        "130": "        System.arraycopy(buf, off, processedBytes, pos, len);\n",
        "131": "        pos += len;\n",
        "132": "        return true;\n",
        "133": "      }\n",
        "135": "      @Override\n",
        "136": "      public byte[] getResult() {\n",
        "137": "        return processedBytes;\n",
        "138": "      }\n",
        "139": "    };\n",
        "148": "    ByteProcessor<Void> processor = new ByteProcessor<Void>() {\n",
        "149": "      boolean firstCall = true;\n",
        "150": "\n",
        "151": "      @Override\n",
        "152": "      public boolean processBytes(byte[] buf, int off, int len) throws IOException {\n",
        "153": "        assertTrue(\"consume() called twice\", firstCall);\n",
        "154": "        firstCall = false;\n",
        "155": "        return false;\n",
        "156": "      }\n",
        "158": "      @Override\n",
        "159": "      public Void getResult() {\n",
        "160": "        return null;\n",
        "161": "      }\n",
        "162": "    };\n",
        "270": "        return read(b) == -1\n",
        "271": "            ? -1\n",
        "272": "            : UnsignedBytes.toInt(b[0]);\n",
        "290": "   * @param input      the size of the input source\n",
        "291": "   * @param offset     the first argument to {@link ByteSource#slice}\n",
        "292": "   * @param length     the second argument to {@link ByteSource#slice}\n",
        "295": "  private static void assertCorrectSlice(\n",
        "296": "      int input, int offset, long length, int expectRead) throws IOException {\n",
        "324": "      assertTrue(\"stream not closed when copying to sink with option: \" + option,\n",
        "357": "    assertArrayEquals(expected,\n",
        "358": "        ByteSource.concat(ImmutableList.of(b1, b2, b3)).read());\n",
        "359": "    assertArrayEquals(expected,\n",
        "360": "        ByteSource.concat(b1, b2, b3).read());\n",
        "361": "    assertArrayEquals(expected,\n",
        "362": "        ByteSource.concat(ImmutableList.of(b1, b2, b3).iterator()).read());\n",
        "380": "  private static final ByteSource BROKEN_CLOSE_SOURCE\n",
        "381": "      = new TestByteSource(new byte[10], CLOSE_THROWS);\n",
        "382": "  private static final ByteSource BROKEN_OPEN_SOURCE\n",
        "383": "      = new TestByteSource(new byte[10], OPEN_THROWS);\n",
        "384": "  private static final ByteSource BROKEN_READ_SOURCE\n",
        "385": "      = new TestByteSource(new byte[10], READ_THROWS);\n",
        "386": "  private static final ByteSink BROKEN_CLOSE_SINK\n",
        "387": "      = new TestByteSink(CLOSE_THROWS);\n",
        "388": "  private static final ByteSink BROKEN_OPEN_SINK\n",
        "389": "      = new TestByteSink(OPEN_THROWS);\n",
        "390": "  private static final ByteSink BROKEN_WRITE_SINK\n",
        "391": "      = new TestByteSink(WRITE_THROWS);\n",
        "392": "\n",
        "393": "  private static final ImmutableSet<ByteSource> BROKEN_SOURCES\n",
        "394": "      = ImmutableSet.of(BROKEN_CLOSE_SOURCE, BROKEN_OPEN_SOURCE, BROKEN_READ_SOURCE);\n",
        "395": "  private static final ImmutableSet<ByteSink> BROKEN_SINKS\n",
        "396": "      = ImmutableSet.of(BROKEN_CLOSE_SINK, BROKEN_OPEN_SINK, BROKEN_WRITE_SINK);\n",
        "472": "  /**\n",
        "473": "   * @return the number of exceptions that were suppressed on the expected thrown exception\n",
        "474": "   */\n",
        "491": "      @Override public OutputStream openStream() {\n"
    }
}