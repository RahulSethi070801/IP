{
    "addition": {
        "24": " * A set comprising zero or more {@linkplain Range#isEmpty nonempty}, {@linkplain\n",
        "25": " * Range#isConnected(Range) disconnected} ranges of type {@code C}.\n",
        "28": " * ignore empty ranges and coalesce connected ranges. For example:\n",
        "30": " * <pre>{@code\n",
        "31": " * RangeSet<Integer> rangeSet = TreeRangeSet.create();\n",
        "32": " * rangeSet.add(Range.closed(1, 10)); // {[1, 10]}\n",
        "33": " * rangeSet.add(Range.closedOpen(11, 15)); // disconnected range; {[1, 10], [11, 15)}\n",
        "34": " * rangeSet.add(Range.closedOpen(15, 20)); // connected range; {[1, 10], [11, 20)}\n",
        "35": " * rangeSet.add(Range.openClosed(0, 0)); // empty range; {[1, 10], [11, 20)}\n",
        "36": " * rangeSet.remove(Range.open(5, 10)); // splits [1, 10]; {[1, 5], [10, 10], [11, 20)}\n",
        "37": " * }</pre>\n",
        "39": " * <p>Note that the behavior of {@link Range#isEmpty()} and {@link Range#isConnected(Range)} may not\n",
        "40": " * be as expected on discrete ranges. See the Javadoc of those methods for details.\n",
        "45": " * \"https://github.com/google/guava/wiki/NewCollectionTypesExplained#rangeset\"> RangeSets</a>.\n",
        "61": "   * Returns the unique range from this range set that {@linkplain Range#contains contains} {@code\n",
        "62": "   * value}, or {@code null} if this range set does not contain {@code value}.\n",
        "68": "   * range set and the specified range. This is equivalent to calling {@code\n",
        "69": "   * subRangeSet(otherRange)} and testing whether the resulting range set is non-empty.\n",
        "76": "   * Returns {@code true} if there exists a member range in this range set which {@linkplain\n",
        "77": "   * Range#encloses encloses} the specified range.\n",
        "83": "   * this range set which {@linkplain Range#encloses encloses} it. It follows that {@code\n",
        "84": "   * this.contains(value)} whenever {@code other.contains(value)}. Returns {@code true} if {@code\n",
        "85": "   * other} is empty.\n",
        "104": "  /** Returns {@code true} if this range set contains no ranges. */\n",
        "108": "   * Returns the minimal range which {@linkplain Range#encloses(Range) encloses} all ranges in this\n",
        "109": "   * range set.\n",
        "119": "   * range set. The returned set may be empty. The iterators returned by its {@link\n",
        "120": "   * Iterable#iterator} method return the ranges in increasing order of lower bound (equivalently,\n",
        "121": "   * of upper bound).\n",
        "126": "   * Returns a descending view of the {@linkplain Range#isConnected disconnected} ranges that make\n",
        "127": "   * up this range set. The returned set may be empty. The iterators returned by its {@link\n",
        "128": "   * Iterable#iterator} method return the ranges in decreasing order of lower bound (equivalently,\n",
        "129": "   * of upper bound).\n",
        "147": "   * the caveat that an {@link IllegalArgumentException} is thrown on an attempt to {@linkplain\n",
        "148": "   * #add(Range) add} any range not {@linkplain Range#encloses(Range) enclosed} by {@code view}.\n",
        "160": "   * the range set that are {@linkplain Range#isConnected(Range) connected} with it. Moreover, if\n",
        "161": "   * {@code range} is empty, this is a no-op.\n",
        "164": "   *     operation\n",
        "175": "   *     operation\n",
        "180": "   * Removes all ranges from this {@code RangeSet} (optional operation). After this operation,\n",
        "186": "   *     operation\n",
        "192": "   * After this operation, this range set is the minimal range set that {@linkplain\n",
        "193": "   * #enclosesAll(RangeSet) encloses} both the original range set and {@code other}.\n",
        "198": "   *     operation\n",
        "224": "   *     operation\n",
        "249": "  /** Returns {@code asRanges().hashCode()}. */\n",
        "254": "   * Returns a readable string representation of this range set. For example, if this {@code\n",
        "255": "   * RangeSet} consisted of {@code Range.closed(1, 3)} and {@code Range.greaterThan(4)}, this might\n",
        "256": "   * return {@code \" [1..3](4..+\u221e)}\"}.\n"
    },
    "removed": {
        "24": " * A set comprising zero or more {@linkplain Range#isEmpty nonempty},\n",
        "25": " * {@linkplain Range#isConnected(Range) disconnected} ranges of type {@code C}.\n",
        "28": " * ignore empty ranges and coalesce connected ranges.  For example:  <pre>   {@code\n",
        "30": " *   RangeSet<Integer> rangeSet = TreeRangeSet.create();\n",
        "31": " *   rangeSet.add(Range.closed(1, 10)); // {[1, 10]}\n",
        "32": " *   rangeSet.add(Range.closedOpen(11, 15)); // disconnected range; {[1, 10], [11, 15)}\n",
        "33": " *   rangeSet.add(Range.closedOpen(15, 20)); // connected range; {[1, 10], [11, 20)}\n",
        "34": " *   rangeSet.add(Range.openClosed(0, 0)); // empty range; {[1, 10], [11, 20)}\n",
        "35": " *   rangeSet.remove(Range.open(5, 10)); // splits [1, 10]; {[1, 5], [10, 10], [11, 20)}}</pre>\n",
        "37": " * <p>Note that the behavior of {@link Range#isEmpty()} and {@link Range#isConnected(Range)} may\n",
        "38": " * not be as expected on discrete ranges.  See the Javadoc of those methods for details.\n",
        "43": " * \"https://github.com/google/guava/wiki/NewCollectionTypesExplained#rangeset\">\n",
        "44": " * RangeSets</a>.\n",
        "60": "   * Returns the unique range from this range set that {@linkplain Range#contains contains}\n",
        "61": "   * {@code value}, or {@code null} if this range set does not contain {@code value}.\n",
        "67": "   * range set and the specified range. This is equivalent to calling\n",
        "68": "   * {@code subRangeSet(otherRange)} and testing whether the resulting range set is non-empty.\n",
        "75": "   * Returns {@code true} if there exists a member range in this range set which\n",
        "76": "   * {@linkplain Range#encloses encloses} the specified range.\n",
        "82": "   * this range set which {@linkplain Range#encloses encloses} it. It follows that\n",
        "83": "   * {@code this.contains(value)} whenever {@code other.contains(value)}. Returns {@code true} if\n",
        "84": "   * {@code other} is empty.\n",
        "103": "  /**\n",
        "104": "   * Returns {@code true} if this range set contains no ranges.\n",
        "105": "   */\n",
        "109": "   * Returns the minimal range which {@linkplain Range#encloses(Range) encloses} all ranges\n",
        "110": "   * in this range set.\n",
        "120": "   * range set.  The returned set may be empty. The iterators returned by its\n",
        "121": "   * {@link Iterable#iterator} method return the ranges in increasing order of lower bound\n",
        "122": "   * (equivalently, of upper bound).\n",
        "127": "   * Returns a descending view of the {@linkplain Range#isConnected disconnected} ranges that\n",
        "128": "   * make up this range set. The returned set may be empty. The iterators returned by its\n",
        "129": "   * {@link Iterable#iterator} method return the ranges in decreasing order of lower bound\n",
        "130": "   * (equivalently, of upper bound).\n",
        "148": "   * the caveat that an {@link IllegalArgumentException} is thrown on an attempt to\n",
        "149": "   * {@linkplain #add(Range) add} any range not {@linkplain Range#encloses(Range) enclosed} by\n",
        "150": "   * {@code view}.\n",
        "162": "   * the range set that are {@linkplain Range#isConnected(Range) connected} with it.  Moreover,\n",
        "163": "   * if {@code range} is empty, this is a no-op.\n",
        "166": "   *         operation\n",
        "177": "   *         operation\n",
        "182": "   * Removes all ranges from this {@code RangeSet} (optional operation).  After this operation,\n",
        "188": "   *         operation\n",
        "194": "   * After this operation, this range set is the minimal range set that\n",
        "195": "   * {@linkplain #enclosesAll(RangeSet) encloses} both the original range set and {@code other}.\n",
        "200": "   *         operation\n",
        "226": "   *         operation\n",
        "251": "  /**\n",
        "252": "   * Returns {@code asRanges().hashCode()}.\n",
        "253": "   */\n",
        "258": "   * Returns a readable string representation of this range set. For example, if this\n",
        "259": "   * {@code RangeSet} consisted of {@code Range.closed(1, 3)} and {@code Range.greaterThan(4)},\n",
        "260": "   * this might return {@code \" [1..3](4..+\u221e)}\"}.\n"
    }
}