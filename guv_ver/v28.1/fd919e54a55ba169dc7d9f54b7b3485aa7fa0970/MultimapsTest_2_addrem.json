{
    "addition": {
        "167": "    checkUnmodifiableMultimap(ArrayListMultimap.<String, Integer>create(), true);\n",
        "181": "    ListMultimap<String, Integer> multimap = Multimaps.unmodifiableListMultimap(delegate);\n",
        "209": "    checkUnmodifiableMultimap(TreeMultimap.<String, Integer>create(), false, \"null\", 42);\n",
        "221": "    checkUnmodifiableMultimap(\n",
        "222": "        Multimaps.synchronizedListMultimap(ArrayListMultimap.<String, Integer>create()), true);\n",
        "228": "        prepareUnmodifiableTests(\n",
        "229": "            Multimaps.synchronizedListMultimap(ArrayListMultimap.<String, Integer>create()),\n",
        "230": "            true,\n",
        "231": "            null,\n",
        "232": "            null);\n",
        "238": "    checkUnmodifiableMultimap(\n",
        "239": "        Multimaps.synchronizedSetMultimap(HashMultimap.<String, Integer>create()), false);\n",
        "245": "        prepareUnmodifiableTests(\n",
        "246": "            Multimaps.synchronizedSetMultimap(HashMultimap.<String, Integer>create()),\n",
        "247": "            false,\n",
        "248": "            null,\n",
        "249": "            null);\n",
        "255": "    TreeMultimap<String, Integer> delegate =\n",
        "256": "        TreeMultimap.create(Ordering.<String>natural(), INT_COMPARATOR);\n",
        "257": "    SortedSetMultimap<String, Integer> multimap = Multimaps.synchronizedSortedSetMultimap(delegate);\n",
        "266": "    SortedSetMultimap<String, Integer> multimap = Multimaps.synchronizedSortedSetMultimap(delegate);\n",
        "267": "    Multimap<String, Integer> unmodifiable = prepareUnmodifiableTests(multimap, false, \"null\", 42);\n",
        "290": "    } catch (UnsupportedOperationException expected) {\n",
        "291": "    }\n",
        "296": "    } catch (UnsupportedOperationException expected) {\n",
        "297": "    }\n",
        "298": "    Entry<String, Integer>[] array = (Entry<String, Integer>[]) new Entry<?, ?>[2];\n",
        "303": "    } catch (UnsupportedOperationException expected) {\n",
        "304": "    }\n",
        "310": "   * The supplied multimap will be mutated and an unmodifiable instance used in its stead. The\n",
        "311": "   * multimap must support null keys and values.\n",
        "319": "   * The supplied multimap will be mutated and an unmodifiable instance used in its stead. If the\n",
        "320": "   * multimap does not support null keys or values, alternatives may be specified for tests\n",
        "321": "   * involving nulls.\n",
        "324": "      Multimap<String, Integer> multimap,\n",
        "325": "      boolean permitsDuplicates,\n",
        "326": "      @Nullable String nullKey,\n",
        "327": "      @Nullable Integer nullValue) {\n",
        "331": "    UnmodifiableCollectionTests.assertMultimapIsUnmodifiable(unmodifiable, \"test\", 123);\n",
        "333": "    assertUnmodifiableIterableInTandem(unmodifiable.keys(), multimap.keys());\n",
        "335": "    assertUnmodifiableIterableInTandem(unmodifiable.keySet(), multimap.keySet());\n",
        "337": "    assertUnmodifiableIterableInTandem(unmodifiable.entries(), multimap.entries());\n",
        "352": "  /** Prepares the multimap for unmodifiable tests, returning an unmodifiable view of the map. */\n",
        "354": "      Multimap<String, Integer> multimap,\n",
        "355": "      boolean permitsDuplicates,\n",
        "356": "      @Nullable String nullKey,\n",
        "357": "      @Nullable Integer nullValue) {\n",
        "377": "      unmodifiable =\n",
        "378": "          Multimaps.unmodifiableSortedSetMultimap((SortedSetMultimap<String, Integer>) multimap);\n",
        "380": "      unmodifiable = Multimaps.unmodifiableSetMultimap((SetMultimap<String, Integer>) multimap);\n",
        "382": "      unmodifiable = Multimaps.unmodifiableListMultimap((ListMultimap<String, Integer>) multimap);\n",
        "391": "    UnmodifiableCollectionTests.assertIteratorIsUnmodifiable(unmodifiable.iterator());\n",
        "400": "    Multimap<String, Integer> multimap =\n",
        "401": "        Multimaps.invertFrom(empty, ArrayListMultimap.<String, Integer>create());\n",
        "404": "    ImmutableMultimap<Integer, String> single =\n",
        "405": "        new ImmutableMultimap.Builder<Integer, String>().put(1, \"one\").put(2, \"two\").build();\n",
        "410": "    ImmutableMultimap<String, Integer> expected =\n",
        "411": "        new ImmutableMultimap.Builder<String, Integer>().put(\"one\", 1).put(\"two\", 2).build();\n",
        "417": "    Multimap<String, Integer> multimap =\n",
        "418": "        Multimaps.newMultimap(new HashMap<String, Collection<Integer>>(), new QueueSupplier());\n",
        "436": "    SortedSetMultimap<String, Integer> sortedSetMultimap = TreeMultimap.create();\n",
        "449": "    new EqualsTester().addEqualityGroup(multimap, multimapView).addEqualityGroup(map).testEquals();\n",
        "455": "    ListMultimap<String, Integer> listMultimap =\n",
        "456": "        new ImmutableListMultimap.Builder<String, Integer>().put(\"foo\", 1).put(\"bar\", 2).build();\n",
        "457": "    assertFalse(\"SetMultimap equals ListMultimap\", multimapView.equals(listMultimap));\n",
        "469": "    } catch (UnsupportedOperationException expected) {\n",
        "470": "    }\n",
        "474": "    } catch (UnsupportedOperationException expected) {\n",
        "475": "    }\n",
        "479": "    } catch (UnsupportedOperationException expected) {\n",
        "480": "    }\n",
        "484": "    } catch (UnsupportedOperationException expected) {\n",
        "485": "    }\n",
        "545": "    assertFalse(entries.contains(Maps.immutableEntry(\"foo\", Collections.singletonList(1))));\n",
        "546": "    assertFalse(entries.remove(Maps.immutableEntry(\"foo\", Collections.singletonList(1))));\n",
        "547": "    assertFalse(entries.contains(Maps.immutableEntry(\"foo\", Sets.newLinkedHashSet(asList(1, 2)))));\n",
        "548": "    assertFalse(entries.remove(Maps.immutableEntry(\"foo\", Sets.newLinkedHashSet(asList(1, 2)))));\n",
        "549": "    assertFalse(entries.contains(Maps.immutableEntry(\"foo\", Collections.singleton(2))));\n",
        "550": "    assertFalse(entries.remove(Maps.immutableEntry(\"foo\", Collections.singleton(2))));\n",
        "552": "    assertTrue(entries.contains(Maps.immutableEntry(\"foo\", Collections.singleton(1))));\n",
        "553": "    assertTrue(entries.remove(Maps.immutableEntry(\"foo\", Collections.singleton(1))));\n",
        "559": "        new IteratorTester<Integer>(\n",
        "560": "            4, MODIFIABLE, newHashSet(1), IteratorTester.KnownOrder.KNOWN_ORDER) {\n",
        "563": "          @Override\n",
        "564": "          protected Iterator<Integer> newTargetIterator() {\n",
        "572": "          @Override\n",
        "573": "          protected void verify(List<Integer> elements) {\n",
        "581": "  private enum Color {\n",
        "582": "    BLUE,\n",
        "583": "    RED,\n",
        "584": "    YELLOW,\n",
        "585": "    GREEN\n",
        "586": "  }\n",
        "588": "  private abstract static class CountingSupplier<E> implements Supplier<E>, Serializable {\n",
        "601": "    @Override\n",
        "602": "    public Queue<Integer> getImpl() {\n",
        "605": "\n",
        "610": "    CountingSupplier<Set<Integer>> factory =\n",
        "611": "        new SetSupplier() {\n",
        "613": "          public Set<Integer> getImpl() {\n",
        "614": "            final Set<Integer> backing = super.getImpl();\n",
        "615": "            return new ForwardingSet<Integer>() {\n",
        "616": "              @Override\n",
        "617": "              protected Set<Integer> delegate() {\n",
        "618": "                return backing;\n",
        "619": "              }\n",
        "620": "\n",
        "621": "              @Override\n",
        "622": "              public boolean add(Integer element) {\n",
        "623": "                checkArgument(element >= 0);\n",
        "624": "                return super.add(element);\n",
        "625": "              }\n",
        "626": "\n",
        "627": "              @Override\n",
        "628": "              public boolean addAll(Collection<? extends Integer> collection) {\n",
        "629": "                return standardAddAll(collection);\n",
        "630": "              }\n",
        "631": "            };\n",
        "649": "    assertThat(multimap.entries())\n",
        "650": "        .containsExactly(Maps.immutableEntry(Color.RED, 1), Maps.immutableEntry(Color.BLUE, 2));\n",
        "666": "    Multimap<Color, Integer> ummodifiable = Multimaps.unmodifiableMultimap(multimap);\n",
        "686": "  private static class ListSupplier extends CountingSupplier<LinkedList<Integer>> {\n",
        "687": "    @Override\n",
        "688": "    public LinkedList<Integer> getImpl() {\n",
        "691": "\n",
        "698": "    ListMultimap<Color, Integer> multimap = Multimaps.newListMultimap(map, factory);\n",
        "722": "    @Override\n",
        "723": "    public Set<Integer> getImpl() {\n",
        "726": "\n",
        "733": "    SetMultimap<Color, Integer> multimap = Multimaps.newSetMultimap(map, factory);\n",
        "752": "  private static class SortedSetSupplier extends CountingSupplier<TreeSet<Integer>> {\n",
        "753": "    @Override\n",
        "754": "    public TreeSet<Integer> getImpl() {\n",
        "757": "\n",
        "764": "    SortedSetMultimap<Color, Integer> multimap = Multimaps.newSortedSetMultimap(map, factory);\n",
        "797": "        Multimaps.index(stringToObject.values(), Functions.toStringFunction());\n",
        "812": "        Multimaps.index(stringToObject.values().iterator(), Functions.toStringFunction());\n",
        "826": "    final List<String> badGuys = Arrays.asList(\"Inky\", \"Blinky\", \"Pinky\", \"Pinky\", \"Clyde\");\n",
        "835": "    Multimap<Integer, String> index = Multimaps.index(badGuys, stringLengthFunction);\n",
        "862": "    Function<Integer, Integer> square =\n",
        "863": "        new Function<Integer, Integer>() {\n",
        "864": "          @Override\n",
        "865": "          public Integer apply(Integer in) {\n",
        "866": "            return in * in;\n",
        "867": "          }\n",
        "868": "        };\n",
        "870": "    assertThat(transformed.entries())\n",
        "871": "        .containsExactly(\n",
        "872": "            immutableEntry(\"a\", 4),\n",
        "873": "            immutableEntry(\"a\", 16),\n",
        "874": "            immutableEntry(\"b\", 9),\n",
        "875": "            immutableEntry(\"b\", 9),\n",
        "876": "            immutableEntry(\"c\", 36))\n",
        "877": "        .inOrder();\n",
        "885": "        Multimaps.transformValues(\n",
        "886": "            multimap,\n",
        "887": "            new Function<String, Integer>() {\n",
        "888": "\n",
        "889": "              @Override\n",
        "890": "              public Integer apply(String str) {\n",
        "891": "                return str.length();\n",
        "892": "              }\n",
        "893": "            });\n",
        "903": "    Function<Integer, Integer> square =\n",
        "904": "        new Function<Integer, Integer>() {\n",
        "905": "          @Override\n",
        "906": "          public Integer apply(Integer in) {\n",
        "907": "            return in * in;\n",
        "908": "          }\n",
        "909": "        };\n",
        "910": "    ListMultimap<String, Integer> transformed = Multimaps.transformValues(multimap, square);\n",
        "911": "    assertThat(transformed.entries())\n",
        "912": "        .containsExactly(\n",
        "913": "            immutableEntry(\"a\", 4),\n",
        "914": "            immutableEntry(\"a\", 16),\n",
        "915": "            immutableEntry(\"b\", 9),\n",
        "916": "            immutableEntry(\"b\", 9),\n",
        "917": "            immutableEntry(\"c\", 36))\n",
        "918": "        .inOrder();\n",
        "923": "    SetMultimap<String, Integer> multimap = ImmutableSetMultimap.of(\"a\", 1, \"a\", 4, \"b\", -6);\n",
        "931": "    Multimap<String, String> transformed = Multimaps.transformEntries(multimap, transformer);\n",
        "932": "    assertThat(transformed.entries())\n",
        "933": "        .containsExactly(\n",
        "934": "            immutableEntry(\"a\", \"a\"), immutableEntry(\"a\", \"a\"), immutableEntry(\"b\", \"nob\"))\n",
        "935": "        .inOrder();\n",
        "949": "    ListMultimap<String, String> transformed = Multimaps.transformEntries(multimap, transformer);\n",
        "950": "    assertEquals(ImmutableListMultimap.of(\"a\", \"a1\", \"a\", \"a4\", \"a\", \"a4\", \"b\", \"b6\"), transformed);\n",
        "957": "    Multimap<K, V> multimap = Multimaps.synchronizedMultimap(HashMultimap.<K, V>create());\n",
        "958": "    Collection<V> values = multimap.get(key); // Needn't be in synchronized block\n",
        "959": "    synchronized (multimap) { // Synchronizing on multimap, not values!\n",
        "976": "    SetMultimap<String, Integer> filtered =\n",
        "977": "        Multimaps.filterKeys(multimap, Predicates.in(ImmutableSet.of(\"foo\", \"bar\")));\n",
        "979": "    assertEquals(ImmutableSet.of(), filtered.replaceValues(\"baz\", ImmutableSet.<Integer>of()));\n",
        "995": "    SetMultimap<String, Integer> filtered =\n",
        "996": "        Multimaps.filterKeys(multimap, Predicates.in(ImmutableSet.of(\"foo\", \"bar\")));\n",
        "1018": "    ListMultimap<String, Integer> filtered =\n",
        "1019": "        Multimaps.filterKeys(multimap, Predicates.in(ImmutableSet.of(\"foo\", \"bar\")));\n"
    },
    "removed": {
        "167": "    checkUnmodifiableMultimap(\n",
        "168": "        ArrayListMultimap.<String, Integer>create(), true);\n",
        "182": "    ListMultimap<String, Integer> multimap\n",
        "183": "        = Multimaps.unmodifiableListMultimap(delegate);\n",
        "211": "    checkUnmodifiableMultimap(\n",
        "212": "        TreeMultimap.<String, Integer>create(), false, \"null\", 42);\n",
        "224": "    checkUnmodifiableMultimap(Multimaps.synchronizedListMultimap(\n",
        "225": "        ArrayListMultimap.<String, Integer>create()), true);\n",
        "231": "        prepareUnmodifiableTests(Multimaps.synchronizedListMultimap(\n",
        "232": "          ArrayListMultimap.<String, Integer>create()), true, null, null);\n",
        "238": "    checkUnmodifiableMultimap(Multimaps.synchronizedSetMultimap(\n",
        "239": "        HashMultimap.<String, Integer>create()), false);\n",
        "245": "        prepareUnmodifiableTests(Multimaps.synchronizedSetMultimap(\n",
        "246": "        HashMultimap.<String, Integer>create()), false, null, null);\n",
        "252": "    TreeMultimap<String, Integer> delegate\n",
        "253": "        = TreeMultimap.create(Ordering.<String>natural(), INT_COMPARATOR);\n",
        "254": "    SortedSetMultimap<String, Integer> multimap\n",
        "255": "        = Multimaps.synchronizedSortedSetMultimap(delegate);\n",
        "264": "    SortedSetMultimap<String, Integer> multimap =\n",
        "265": "        Multimaps.synchronizedSortedSetMultimap(delegate);\n",
        "266": "    Multimap<String, Integer> unmodifiable =\n",
        "267": "        prepareUnmodifiableTests(multimap, false, \"null\", 42);\n",
        "290": "    } catch (UnsupportedOperationException expected) {}\n",
        "295": "    } catch (UnsupportedOperationException expected) {}\n",
        "296": "    Entry<String, Integer>[] array\n",
        "297": "        = (Entry<String, Integer>[]) new Entry<?, ?>[2];\n",
        "302": "    } catch (UnsupportedOperationException expected) {}\n",
        "308": "   * The supplied multimap will be mutated and an unmodifiable instance used\n",
        "309": "   * in its stead. The multimap must support null keys and values.\n",
        "317": "   * The supplied multimap will be mutated and an unmodifiable instance used\n",
        "318": "   * in its stead. If the multimap does not support null keys or values,\n",
        "319": "   * alternatives may be specified for tests involving nulls.\n",
        "322": "      Multimap<String, Integer> multimap, boolean permitsDuplicates,\n",
        "323": "      @Nullable String nullKey, @Nullable Integer nullValue) {\n",
        "327": "    UnmodifiableCollectionTests.assertMultimapIsUnmodifiable(\n",
        "328": "        unmodifiable, \"test\", 123);\n",
        "330": "    assertUnmodifiableIterableInTandem(\n",
        "331": "        unmodifiable.keys(), multimap.keys());\n",
        "333": "    assertUnmodifiableIterableInTandem(\n",
        "334": "        unmodifiable.keySet(), multimap.keySet());\n",
        "336": "    assertUnmodifiableIterableInTandem(\n",
        "337": "        unmodifiable.entries(), multimap.entries());\n",
        "352": "  /**\n",
        "353": "   * Prepares the multimap for unmodifiable tests, returning an unmodifiable view\n",
        "354": "   * of the map.\n",
        "355": "   */\n",
        "357": "      Multimap<String, Integer> multimap, boolean permitsDuplicates,\n",
        "358": "      @Nullable String nullKey, @Nullable Integer nullValue) {\n",
        "378": "      unmodifiable = Multimaps.unmodifiableSortedSetMultimap(\n",
        "379": "          (SortedSetMultimap<String, Integer>) multimap);\n",
        "381": "      unmodifiable = Multimaps.unmodifiableSetMultimap(\n",
        "382": "          (SetMultimap<String, Integer>) multimap);\n",
        "384": "      unmodifiable = Multimaps.unmodifiableListMultimap(\n",
        "385": "          (ListMultimap<String, Integer>) multimap);\n",
        "394": "    UnmodifiableCollectionTests.assertIteratorIsUnmodifiable(\n",
        "395": "        unmodifiable.iterator());\n",
        "404": "    Multimap<String, Integer> multimap = Multimaps.invertFrom(empty,\n",
        "405": "        ArrayListMultimap.<String, Integer>create());\n",
        "408": "    ImmutableMultimap<Integer, String> single\n",
        "409": "        = new ImmutableMultimap.Builder<Integer, String>()\n",
        "410": "            .put(1, \"one\")\n",
        "411": "            .put(2, \"two\")\n",
        "412": "            .build();\n",
        "417": "    ImmutableMultimap<String, Integer> expected\n",
        "418": "        = new ImmutableMultimap.Builder<String, Integer>()\n",
        "419": "        .put(\"one\", 1)\n",
        "420": "        .put(\"two\", 2)\n",
        "421": "        .build();\n",
        "427": "    Multimap<String, Integer> multimap = Multimaps.newMultimap(\n",
        "428": "        new HashMap<String, Collection<Integer>>(), new QueueSupplier());\n",
        "446": "    SortedSetMultimap<String, Integer> sortedSetMultimap =\n",
        "447": "        TreeMultimap.create();\n",
        "460": "    new EqualsTester()\n",
        "461": "        .addEqualityGroup(multimap, multimapView)\n",
        "462": "        .addEqualityGroup(map)\n",
        "463": "        .testEquals();\n",
        "469": "    ListMultimap<String, Integer> listMultimap\n",
        "470": "        = new ImmutableListMultimap.Builder<String, Integer>()\n",
        "471": "            .put(\"foo\", 1).put(\"bar\", 2).build();\n",
        "472": "    assertFalse(\"SetMultimap equals ListMultimap\",\n",
        "473": "        multimapView.equals(listMultimap));\n",
        "485": "    } catch (UnsupportedOperationException expected) {}\n",
        "489": "    } catch (UnsupportedOperationException expected) {}\n",
        "493": "    } catch (UnsupportedOperationException expected) {}\n",
        "497": "    } catch (UnsupportedOperationException expected) {}\n",
        "557": "    assertFalse(entries.contains(Maps.immutableEntry(\"foo\",\n",
        "558": "        Collections.singletonList(1))));\n",
        "559": "    assertFalse(entries.remove(Maps.immutableEntry(\"foo\",\n",
        "560": "        Collections.singletonList(1))));\n",
        "561": "    assertFalse(entries.contains(Maps.immutableEntry(\"foo\",\n",
        "562": "        Sets.newLinkedHashSet(asList(1, 2)))));\n",
        "563": "    assertFalse(entries.remove(Maps.immutableEntry(\"foo\",\n",
        "564": "        Sets.newLinkedHashSet(asList(1, 2)))));\n",
        "565": "    assertFalse(entries.contains(Maps.immutableEntry(\"foo\",\n",
        "566": "        Collections.singleton(2))));\n",
        "567": "    assertFalse(entries.remove(Maps.immutableEntry(\"foo\",\n",
        "568": "        Collections.singleton(2))));\n",
        "570": "    assertTrue(entries.contains(Maps.immutableEntry(\"foo\",\n",
        "571": "        Collections.singleton(1))));\n",
        "572": "    assertTrue(entries.remove(Maps.immutableEntry(\"foo\",\n",
        "573": "        Collections.singleton(1))));\n",
        "579": "        new IteratorTester<Integer>(4, MODIFIABLE, newHashSet(1),\n",
        "580": "            IteratorTester.KnownOrder.KNOWN_ORDER) {\n",
        "583": "          @Override protected Iterator<Integer> newTargetIterator() {\n",
        "591": "          @Override protected void verify(List<Integer> elements) {\n",
        "599": "  private enum Color {BLUE, RED, YELLOW, GREEN}\n",
        "601": "  private abstract static class CountingSupplier<E>\n",
        "602": "      implements Supplier<E>, Serializable {\n",
        "615": "    @Override public Queue<Integer> getImpl() {\n",
        "622": "    CountingSupplier<Set<Integer>> factory = new SetSupplier() {\n",
        "623": "      @Override\n",
        "624": "      public Set<Integer> getImpl() {\n",
        "625": "        final Set<Integer> backing = super.getImpl();\n",
        "626": "        return new ForwardingSet<Integer>() {\n",
        "628": "          protected Set<Integer> delegate() {\n",
        "629": "            return backing;\n",
        "630": "          }\n",
        "631": "\n",
        "632": "          @Override\n",
        "633": "          public boolean add(Integer element) {\n",
        "634": "            checkArgument(element >= 0);\n",
        "635": "            return super.add(element);\n",
        "636": "          }\n",
        "637": "\n",
        "638": "          @Override\n",
        "639": "          public boolean addAll(Collection<? extends Integer> collection) {\n",
        "640": "            return standardAddAll(collection);\n",
        "643": "      }\n",
        "644": "    };\n",
        "660": "    assertThat(multimap.entries()).containsExactly(\n",
        "661": "        Maps.immutableEntry(Color.RED, 1),\n",
        "662": "        Maps.immutableEntry(Color.BLUE, 2));\n",
        "678": "    Multimap<Color, Integer> ummodifiable =\n",
        "679": "        Multimaps.unmodifiableMultimap(multimap);\n",
        "699": "  private static class ListSupplier extends\n",
        "700": "      CountingSupplier<LinkedList<Integer>> {\n",
        "701": "    @Override public LinkedList<Integer> getImpl() {\n",
        "710": "    ListMultimap<Color, Integer> multimap =\n",
        "711": "        Multimaps.newListMultimap(map, factory);\n",
        "735": "    @Override public Set<Integer> getImpl() {\n",
        "744": "    SetMultimap<Color, Integer> multimap =\n",
        "745": "        Multimaps.newSetMultimap(map, factory);\n",
        "764": "  private static class SortedSetSupplier extends\n",
        "765": "      CountingSupplier<TreeSet<Integer>> {\n",
        "766": "    @Override public TreeSet<Integer> getImpl() {\n",
        "775": "    SortedSetMultimap<Color, Integer> multimap =\n",
        "776": "        Multimaps.newSortedSetMultimap(map, factory);\n",
        "809": "        Multimaps.index(stringToObject.values(),\n",
        "810": "            Functions.toStringFunction());\n",
        "825": "        Multimaps.index(stringToObject.values().iterator(),\n",
        "826": "            Functions.toStringFunction());\n",
        "840": "    final List<String> badGuys =\n",
        "841": "        Arrays.asList(\"Inky\", \"Blinky\", \"Pinky\", \"Pinky\", \"Clyde\");\n",
        "850": "    Multimap<Integer, String> index =\n",
        "851": "        Multimaps.index(badGuys, stringLengthFunction);\n",
        "878": "    Function<Integer, Integer> square = new Function<Integer, Integer>() {\n",
        "879": "      @Override\n",
        "880": "      public Integer apply(Integer in) {\n",
        "881": "        return in * in;\n",
        "882": "      }\n",
        "883": "    };\n",
        "885": "    assertThat(transformed.entries()).containsExactly(immutableEntry(\"a\", 4),\n",
        "886": "        immutableEntry(\"a\", 16), immutableEntry(\"b\", 9), immutableEntry(\"b\", 9),\n",
        "887": "        immutableEntry(\"c\", 36)).inOrder();\n",
        "895": "        Multimaps.transformValues(multimap, new Function<String, Integer>() {\n",
        "896": "\n",
        "897": "          @Override public Integer apply(String str) {\n",
        "898": "            return str.length();\n",
        "899": "          }\n",
        "900": "        });\n",
        "910": "    Function<Integer, Integer> square = new Function<Integer, Integer>() {\n",
        "911": "      @Override\n",
        "912": "      public Integer apply(Integer in) {\n",
        "913": "        return in * in;\n",
        "914": "      }\n",
        "915": "    };\n",
        "916": "    ListMultimap<String, Integer> transformed =\n",
        "917": "        Multimaps.transformValues(multimap, square);\n",
        "918": "    assertThat(transformed.entries()).containsExactly(immutableEntry(\"a\", 4),\n",
        "919": "        immutableEntry(\"a\", 16), immutableEntry(\"b\", 9), immutableEntry(\"b\", 9),\n",
        "920": "        immutableEntry(\"c\", 36)).inOrder();\n",
        "925": "    SetMultimap<String, Integer> multimap =\n",
        "926": "        ImmutableSetMultimap.of(\"a\", 1, \"a\", 4, \"b\", -6);\n",
        "934": "    Multimap<String, String> transformed =\n",
        "935": "        Multimaps.transformEntries(multimap, transformer);\n",
        "936": "    assertThat(transformed.entries()).containsExactly(immutableEntry(\"a\", \"a\"),\n",
        "937": "        immutableEntry(\"a\", \"a\"), immutableEntry(\"b\", \"nob\")).inOrder();\n",
        "951": "    ListMultimap<String, String> transformed =\n",
        "952": "        Multimaps.transformEntries(multimap, transformer);\n",
        "953": "    assertEquals(\n",
        "954": "        ImmutableListMultimap.of(\"a\", \"a1\", \"a\", \"a4\", \"a\", \"a4\", \"b\", \"b6\"),\n",
        "955": "        transformed);\n",
        "962": "    Multimap<K, V> multimap = Multimaps.synchronizedMultimap(\n",
        "963": "        HashMultimap.<K, V>create());\n",
        "964": "    Collection<V> values = multimap.get(key);  // Needn't be in synchronized block\n",
        "965": "    synchronized (multimap) {  // Synchronizing on multimap, not values!\n",
        "982": "    SetMultimap<String, Integer> filtered = Multimaps.filterKeys(\n",
        "983": "        multimap, Predicates.in(ImmutableSet.of(\"foo\", \"bar\")));\n",
        "985": "    assertEquals(\n",
        "986": "        ImmutableSet.of(),\n",
        "987": "        filtered.replaceValues(\"baz\", ImmutableSet.<Integer>of()));\n",
        "1003": "    SetMultimap<String, Integer> filtered = Multimaps.filterKeys(\n",
        "1004": "        multimap, Predicates.in(ImmutableSet.of(\"foo\", \"bar\")));\n",
        "1026": "    ListMultimap<String, Integer> filtered = Multimaps.filterKeys(\n",
        "1027": "        multimap, Predicates.in(ImmutableSet.of(\"foo\", \"bar\")));\n"
    }
}