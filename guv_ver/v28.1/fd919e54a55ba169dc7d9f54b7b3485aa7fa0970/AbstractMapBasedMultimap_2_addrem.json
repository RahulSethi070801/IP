{
    "addition": {
        "48": " * Basic implementation of the {@link Multimap} interface. This class represents a multimap as a map\n",
        "49": " * that associates each key with a collection of values. All methods of {@link Multimap} are\n",
        "50": " * supported, including those specified as optional in the interface.\n",
        "52": " * <p>To implement a multimap, a subclass must define the method {@link #createCollection()}, which\n",
        "53": " * creates an empty collection of values for a key.\n",
        "55": " * <p>The multimap constructor takes a map that has a single entry for each distinct key. When you\n",
        "56": " * insert a key-value pair with a key that isn't already in the multimap, {@code\n",
        "57": " * AbstractMapBasedMultimap} calls {@link #createCollection()} to create the collection of values\n",
        "58": " * for that key. The subclass should not call {@link #createCollection()} directly, and a new\n",
        "59": " * instance should be created every time the method is called.\n",
        "61": " * <p>For example, the subclass could pass a {@link java.util.TreeMap} during construction, and\n",
        "62": " * {@link #createCollection()} could return a {@link java.util.TreeSet}, in which case the\n",
        "63": " * multimap's iterators would propagate through the keys and values in sorted order.\n",
        "65": " * <p>Keys and values may be null, as long as the underlying collection classes support null\n",
        "66": " * elements.\n",
        "68": " * <p>The collections created by {@link #createCollection()} may or may not allow duplicates. If the\n",
        "69": " * collection, such as a {@link Set}, does not support duplicates, an added key-value pair will\n",
        "70": " * replace an existing pair with the same key and value, if such a pair is present. With collections\n",
        "71": " * like {@link List} that allow duplicates, the collection will keep the existing key-value pairs\n",
        "72": " * while adding a new pair.\n",
        "74": " * <p>This class is not threadsafe when any concurrent operations update the multimap, even if the\n",
        "75": " * underlying map and {@link #createCollection()} method return threadsafe classes. Concurrent read\n",
        "76": " * operations will work correctly. To allow concurrent update operations, wrap your multimap with a\n",
        "77": " * call to {@link Multimaps#synchronizedMultimap}.\n",
        "79": " * <p>For serialization to work, the subclass must specify explicit {@code readObject} and {@code\n",
        "80": " * writeObject} methods.\n",
        "113": "   * @param map place to store the mapping from each key to its corresponding values\n",
        "143": "   * <p>Collections with weak, soft, or phantom references are not supported. Each call to {@code\n",
        "144": "   * createCollection} should create a new instance.\n",
        "146": "   * <p>The returned collection class determines whether duplicate key-value pairs are allowed.\n",
        "153": "   * Creates the collection of values for an explicitly provided key. By default, it simply calls\n",
        "154": "   * {@link #createCollection()}, which is the correct behavior for most implementations. The {@link\n",
        "155": "   * LinkedHashMultimap} class overrides it.\n",
        "304": "   * Generates a decorated collection that remains consistent with the values in the multimap for\n",
        "305": "   * the provided key. Changes to the multimap may alter the returned collection, and vice versa.\n",
        "328": "   * Collection decorator that stays in sync with the multimap values for a key. There are two kinds\n",
        "329": "   * of wrapped collections: full and subcollections. Both have a delegate pointing to the\n",
        "330": "   * underlying collection class.\n",
        "332": "   * <p>Full collections, identified by a null ancestor field, contain all multimap values for a\n",
        "333": "   * given key. Its delegate is a value in {@link AbstractMapBasedMultimap#map} whenever the\n",
        "334": "   * delegate is non-empty. The {@code refreshIfEmpty}, {@code removeIfEmpty}, and {@code addToMap}\n",
        "335": "   * methods ensure that the {@code WrappedCollection} and map remain consistent.\n",
        "337": "   * <p>A subcollection, such as a sublist, contains some of the values for a given key. Its\n",
        "338": "   * ancestor field points to the full wrapped collection with all values for the key. The\n",
        "339": "   * subcollection {@code refreshIfEmpty}, {@code removeIfEmpty}, and {@code addToMap} methods call\n",
        "340": "   * the corresponding methods of the full wrapped collection.\n",
        "358": "     * If the delegate collection is empty, but the multimap has values for the key, replace the\n",
        "359": "     * delegate with the new collection for the key.\n",
        "361": "     * <p>For a subcollection, refresh its ancestor and validate that the ancestor delegate hasn't\n",
        "362": "     * changed.\n",
        "379": "     * If collection is empty, remove it from {@code AbstractMapBasedMultimap.this.map}. For\n",
        "380": "     * subcollections, check whether the ancestor collection is empty.\n",
        "395": "     * Add the delegate to the map. Other {@code WrappedCollection} methods should call this method\n",
        "396": "     * after adding elements to a previously empty collection.\n",
        "465": "       * If the delegate changed since the iterator was created, the iterator is no longer valid.\n",
        "632": "  /** SortedSet decorator that stays in sync with the multimap values for a key. */\n",
        "905": "   * List decorator that stays in sync with the multimap values for a key and supports rapid random\n",
        "906": "   * access.\n",
        "1126": "  /** Removes all values for the provided key. */\n",
        "1181": "   * <p>The iterator generated by the returned collection traverses the values for one key, followed\n",
        "1182": "   * by the values of a second key, and so on.\n",
        "1214": "   * <p>The iterator generated by the returned collection traverses the values for one key, followed\n",
        "1215": "   * by the values of a second key, and so on.\n",
        "1217": "   * <p>Each entry is an immutable snapshot of a key-value mapping in the multimap, taken at the\n",
        "1218": "   * time the entry is returned by a method call to the collection or its iterator.\n",
        "1226": "   * Returns an iterator across all key-value map entries, used by {@code entries().iterator()} and\n",
        "1227": "   * {@code values().iterator()}. The default behavior, which traverses the values for one key, the\n",
        "1228": "   * values for a second key, and so on, suffices for most {@code AbstractMapBasedMultimap}\n",
        "1229": "   * implementations.\n",
        "1278": "     * Usually the same as map, but smaller for the headMap(), tailMap(), or subMap() of a\n",
        "1279": "     * SortedAsMap.\n"
    },
    "removed": {
        "48": " * Basic implementation of the {@link Multimap} interface. This class represents\n",
        "49": " * a multimap as a map that associates each key with a collection of values. All\n",
        "50": " * methods of {@link Multimap} are supported, including those specified as\n",
        "51": " * optional in the interface.\n",
        "53": " * <p>To implement a multimap, a subclass must define the method {@link\n",
        "54": " * #createCollection()}, which creates an empty collection of values for a key.\n",
        "56": " * <p>The multimap constructor takes a map that has a single entry for each\n",
        "57": " * distinct key. When you insert a key-value pair with a key that isn't already\n",
        "58": " * in the multimap, {@code AbstractMapBasedMultimap} calls {@link #createCollection()}\n",
        "59": " * to create the collection of values for that key. The subclass should not call\n",
        "60": " * {@link #createCollection()} directly, and a new instance should be created\n",
        "61": " * every time the method is called.\n",
        "63": " * <p>For example, the subclass could pass a {@link java.util.TreeMap} during\n",
        "64": " * construction, and {@link #createCollection()} could return a {@link\n",
        "65": " * java.util.TreeSet}, in which case the multimap's iterators would propagate\n",
        "66": " * through the keys and values in sorted order.\n",
        "68": " * <p>Keys and values may be null, as long as the underlying collection classes\n",
        "69": " * support null elements.\n",
        "71": " * <p>The collections created by {@link #createCollection()} may or may not\n",
        "72": " * allow duplicates. If the collection, such as a {@link Set}, does not support\n",
        "73": " * duplicates, an added key-value pair will replace an existing pair with the\n",
        "74": " * same key and value, if such a pair is present. With collections like {@link\n",
        "75": " * List} that allow duplicates, the collection will keep the existing key-value\n",
        "76": " * pairs while adding a new pair.\n",
        "78": " * <p>This class is not threadsafe when any concurrent operations update the\n",
        "79": " * multimap, even if the underlying map and {@link #createCollection()} method\n",
        "80": " * return threadsafe classes. Concurrent read operations will work correctly. To\n",
        "81": " * allow concurrent update operations, wrap your multimap with a call to {@link\n",
        "82": " * Multimaps#synchronizedMultimap}.\n",
        "84": " * <p>For serialization to work, the subclass must specify explicit\n",
        "85": " * {@code readObject} and {@code writeObject} methods.\n",
        "118": "   * @param map place to store the mapping from each key to its corresponding\n",
        "119": "   *     values\n",
        "149": "   * <p>Collections with weak, soft, or phantom references are not supported.\n",
        "150": "   * Each call to {@code createCollection} should create a new instance.\n",
        "152": "   * <p>The returned collection class determines whether duplicate key-value\n",
        "153": "   * pairs are allowed.\n",
        "160": "   * Creates the collection of values for an explicitly provided key. By\n",
        "161": "   * default, it simply calls {@link #createCollection()}, which is the correct\n",
        "162": "   * behavior for most implementations. The {@link LinkedHashMultimap} class\n",
        "163": "   * overrides it.\n",
        "312": "   * Generates a decorated collection that remains consistent with the values in\n",
        "313": "   * the multimap for the provided key. Changes to the multimap may alter the\n",
        "314": "   * returned collection, and vice versa.\n",
        "337": "   * Collection decorator that stays in sync with the multimap values for a key.\n",
        "338": "   * There are two kinds of wrapped collections: full and subcollections. Both\n",
        "339": "   * have a delegate pointing to the underlying collection class.\n",
        "341": "   * <p>Full collections, identified by a null ancestor field, contain all\n",
        "342": "   * multimap values for a given key. Its delegate is a value in {@link\n",
        "343": "   * AbstractMapBasedMultimap#map} whenever the delegate is non-empty. The {@code\n",
        "344": "   * refreshIfEmpty}, {@code removeIfEmpty}, and {@code addToMap} methods ensure\n",
        "345": "   * that the {@code WrappedCollection} and map remain consistent.\n",
        "347": "   * <p>A subcollection, such as a sublist, contains some of the values for a\n",
        "348": "   * given key. Its ancestor field points to the full wrapped collection with\n",
        "349": "   * all values for the key. The subcollection {@code refreshIfEmpty}, {@code\n",
        "350": "   * removeIfEmpty}, and {@code addToMap} methods call the corresponding methods\n",
        "351": "   * of the full wrapped collection.\n",
        "369": "     * If the delegate collection is empty, but the multimap has values for the\n",
        "370": "     * key, replace the delegate with the new collection for the key.\n",
        "372": "     * <p>For a subcollection, refresh its ancestor and validate that the\n",
        "373": "     * ancestor delegate hasn't changed.\n",
        "390": "     * If collection is empty, remove it from {@code AbstractMapBasedMultimap.this.map}.\n",
        "391": "     * For subcollections, check whether the ancestor collection is empty.\n",
        "406": "     * Add the delegate to the map. Other {@code WrappedCollection} methods\n",
        "407": "     * should call this method after adding elements to a previously empty\n",
        "408": "     * collection.\n",
        "477": "       * If the delegate changed since the iterator was created, the iterator is\n",
        "478": "       * no longer valid.\n",
        "645": "  /**\n",
        "646": "   * SortedSet decorator that stays in sync with the multimap values for a key.\n",
        "647": "   */\n",
        "920": "   * List decorator that stays in sync with the multimap values for a key and\n",
        "921": "   * supports rapid random access.\n",
        "1141": "  /**\n",
        "1142": "   * Removes all values for the provided key.\n",
        "1143": "   */\n",
        "1198": "   * <p>The iterator generated by the returned collection traverses the values\n",
        "1199": "   * for one key, followed by the values of a second key, and so on.\n",
        "1231": "   * <p>The iterator generated by the returned collection traverses the values\n",
        "1232": "   * for one key, followed by the values of a second key, and so on.\n",
        "1234": "   * <p>Each entry is an immutable snapshot of a key-value mapping in the\n",
        "1235": "   * multimap, taken at the time the entry is returned by a method call to the\n",
        "1236": "   * collection or its iterator.\n",
        "1244": "   * Returns an iterator across all key-value map entries, used by {@code\n",
        "1245": "   * entries().iterator()} and {@code values().iterator()}. The default\n",
        "1246": "   * behavior, which traverses the values for one key, the values for a second\n",
        "1247": "   * key, and so on, suffices for most {@code AbstractMapBasedMultimap} implementations.\n",
        "1296": "     * Usually the same as map, but smaller for the headMap(), tailMap(), or\n",
        "1297": "     * subMap() of a SortedAsMap.\n"
    }
}