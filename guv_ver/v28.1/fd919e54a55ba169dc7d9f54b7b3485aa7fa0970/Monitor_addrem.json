{
    "addition": {
        "35": " * href=\"http://en.wikipedia.org/wiki/Monitor_(synchronization)#Implicit_signaling\">implicit</a>. By\n",
        "36": " * eliminating explicit signaling, this class can guarantee that only one thread is awakened when a\n",
        "37": " * condition becomes true (no \"signaling storms\" due to use of {@link\n",
        "50": " * monitor cleanly:\n",
        "52": " * <pre>{@code\n",
        "53": " * monitor.enter();\n",
        "54": " * try {\n",
        "55": " *   // do things while occupying the monitor\n",
        "56": " * } finally {\n",
        "57": " *   monitor.leave();\n",
        "58": " * }\n",
        "59": " * }</pre>\n",
        "63": " * the current thread leaves the monitor cleanly:\n",
        "65": " * <pre>{@code\n",
        "66": " * if (monitor.tryEnter()) {\n",
        "67": " *   try {\n",
        "68": " *     // do things while occupying the monitor\n",
        "69": " *   } finally {\n",
        "70": " *     monitor.leave();\n",
        "71": " *   }\n",
        "72": " * } else {\n",
        "73": " *   // do other things since the monitor was not available\n",
        "74": " * }\n",
        "75": " * }</pre>\n",
        "88": " * logical conditions being awaited.\n",
        "90": " * <pre>{@code\n",
        "91": " * public class SafeBox<V> {\n",
        "92": " *   private V value;\n",
        "94": " *   public synchronized V get() throws InterruptedException {\n",
        "95": " *     while (value == null) {\n",
        "96": " *       wait();\n",
        "98": " *     V result = value;\n",
        "99": " *     value = null;\n",
        "100": " *     notifyAll();\n",
        "101": " *     return result;\n",
        "102": " *   }\n",
        "104": " *   public synchronized void set(V newValue) throws InterruptedException {\n",
        "105": " *     while (value != null) {\n",
        "106": " *       wait();\n",
        "108": " *     value = newValue;\n",
        "109": " *     notifyAll();\n",
        "110": " *   }\n",
        "111": " * }\n",
        "112": " * }</pre>\n",
        "117": " * from the need for the programmer to remember to use {@code while} instead of {@code if}. However,\n",
        "118": " * one advantage is that we can introduce two separate {@code Condition} objects, which allows us to\n",
        "119": " * use {@code signal()} instead of {@code signalAll()}, which may be a performance benefit.\n",
        "121": " * <pre>{@code\n",
        "122": " * public class SafeBox<V> {\n",
        "123": " *   private final ReentrantLock lock = new ReentrantLock();\n",
        "124": " *   private final Condition valuePresent = lock.newCondition();\n",
        "125": " *   private final Condition valueAbsent = lock.newCondition();\n",
        "126": " *   private V value;\n",
        "128": " *   public V get() throws InterruptedException {\n",
        "129": " *     lock.lock();\n",
        "130": " *     try {\n",
        "131": " *       while (value == null) {\n",
        "132": " *         valuePresent.await();\n",
        "134": " *       V result = value;\n",
        "135": " *       value = null;\n",
        "136": " *       valueAbsent.signal();\n",
        "137": " *       return result;\n",
        "138": " *     } finally {\n",
        "139": " *       lock.unlock();\n",
        "141": " *   }\n",
        "143": " *   public void set(V newValue) throws InterruptedException {\n",
        "144": " *     lock.lock();\n",
        "145": " *     try {\n",
        "146": " *       while (value != null) {\n",
        "147": " *         valueAbsent.await();\n",
        "149": " *       value = newValue;\n",
        "150": " *       valuePresent.signal();\n",
        "151": " *     } finally {\n",
        "152": " *       lock.unlock();\n",
        "154": " *   }\n",
        "155": " * }\n",
        "156": " * }</pre>\n",
        "164": " * remember to use {@code while} instead of {@code if}.\n",
        "166": " * <pre>{@code\n",
        "167": " * public class SafeBox<V> {\n",
        "168": " *   private final Monitor monitor = new Monitor();\n",
        "169": " *   private final Monitor.Guard valuePresent = new Monitor.Guard(monitor) {\n",
        "170": " *     public boolean isSatisfied() {\n",
        "171": " *       return value != null;\n",
        "172": " *     }\n",
        "173": " *   };\n",
        "174": " *   private final Monitor.Guard valueAbsent = new Monitor.Guard(monitor) {\n",
        "175": " *     public boolean isSatisfied() {\n",
        "176": " *       return value == null;\n",
        "177": " *     }\n",
        "178": " *   };\n",
        "179": " *   private V value;\n",
        "181": " *   public V get() throws InterruptedException {\n",
        "182": " *     monitor.enterWhen(valuePresent);\n",
        "183": " *     try {\n",
        "184": " *       V result = value;\n",
        "185": " *       value = null;\n",
        "186": " *       return result;\n",
        "187": " *     } finally {\n",
        "188": " *       monitor.leave();\n",
        "190": " *   }\n",
        "192": " *   public void set(V newValue) throws InterruptedException {\n",
        "193": " *     monitor.enterWhen(valueAbsent);\n",
        "194": " *     try {\n",
        "195": " *       value = newValue;\n",
        "196": " *     } finally {\n",
        "197": " *       monitor.leave();\n",
        "199": " *   }\n",
        "200": " * }\n",
        "201": " * }</pre>\n",
        "336": "  /** Whether this monitor is fair. */\n",
        "339": "  /** The lock underlying this monitor. */\n",
        "368": "  /** Enters this monitor. Blocks indefinitely. */\n",
        "458": "  /** Enters this monitor when the guard is satisfied. Blocks indefinitely. */\n",
        "815": "  /** Leaves this monitor. May be called only by a thread currently occupying this monitor. */\n",
        "828": "  /** Returns whether this monitor is using a fair ordering policy. */\n",
        "958": "   * <p>We manage calls to this method carefully, to signal only when necessary, but never losing a\n",
        "963": "   * <p>In addition, any thread that has been signalled when its guard was satisfied acquires the\n",
        "969": "   * <p>On the other hand, if a signalled thread wakes up to discover that its guard is still not\n",
        "976": "   * <p>This method must not be called from within a beginWaitingFor/endWaitingFor block, or else\n",
        "977": "   * the current thread's guard might be mistakenly signalled, leading to a lost signal.\n",
        "994": "   * <p>We decided against using this method, since in practice, isSatisfied() is likely to be very\n",
        "997": "  //   @GuardedBy(\"lock\")\n",
        "998": "  //   private void signalNextWaiterSkipping(Guard guardToSkip) {\n",
        "999": "  //     for (Guard guard = activeGuards; guard != null; guard = guard.next) {\n",
        "1000": "  //       if (guard != guardToSkip && isSatisfied(guard)) {\n",
        "1001": "  //         guard.condition.signal();\n",
        "1002": "  //         break;\n",
        "1003": "  //       }\n",
        "1004": "  //     }\n",
        "1005": "  //   }\n",
        "1021": "  /** Signals all threads waiting on guards. */\n",
        "1029": "  /** Records that the current thread is about to wait on the specified guard. */\n",
        "1040": "  /** Records that the current thread is no longer waiting on the specified guard. */\n",
        "1096": "  /** Caller should check before calling that guard is not satisfied. */\n"
    },
    "removed": {
        "35": " * href=\"http://en.wikipedia.org/wiki/Monitor_(synchronization)#Implicit_signaling\">implicit</a>.\n",
        "36": " * By eliminating explicit signaling, this class can guarantee that only one thread is awakened when\n",
        "37": " * a condition becomes true (no \"signaling storms\" due to use of {@link\n",
        "50": " * monitor cleanly: <pre>   {@code\n",
        "52": " *   monitor.enter();\n",
        "53": " *   try {\n",
        "54": " *     // do things while occupying the monitor\n",
        "55": " *   } finally {\n",
        "56": " *     monitor.leave();\n",
        "57": " *   }}</pre>\n",
        "61": " * the current thread leaves the monitor cleanly: <pre>   {@code\n",
        "63": " *   if (monitor.tryEnter()) {\n",
        "64": " *     try {\n",
        "65": " *       // do things while occupying the monitor\n",
        "66": " *     } finally {\n",
        "67": " *       monitor.leave();\n",
        "68": " *     }\n",
        "69": " *   } else {\n",
        "70": " *     // do other things since the monitor was not available\n",
        "71": " *   }}</pre>\n",
        "84": " * logical conditions being awaited. <pre>   {@code\n",
        "86": " *   public class SafeBox<V> {\n",
        "87": " *     private V value;\n",
        "89": " *     public synchronized V get() throws InterruptedException {\n",
        "90": " *       while (value == null) {\n",
        "91": " *         wait();\n",
        "92": " *       }\n",
        "93": " *       V result = value;\n",
        "94": " *       value = null;\n",
        "95": " *       notifyAll();\n",
        "96": " *       return result;\n",
        "99": " *     public synchronized void set(V newValue) throws InterruptedException {\n",
        "100": " *       while (value != null) {\n",
        "101": " *         wait();\n",
        "102": " *       }\n",
        "103": " *       value = newValue;\n",
        "104": " *       notifyAll();\n",
        "106": " *   }}</pre>\n",
        "111": " * from the need for the programmer to remember to use {@code while} instead of {@code if}.\n",
        "112": " * However, one advantage is that we can introduce two separate {@code Condition} objects, which\n",
        "113": " * allows us to use {@code signal()} instead of {@code signalAll()}, which may be a performance\n",
        "114": " * benefit. <pre>   {@code\n",
        "116": " *   public class SafeBox<V> {\n",
        "117": " *     private final ReentrantLock lock = new ReentrantLock();\n",
        "118": " *     private final Condition valuePresent = lock.newCondition();\n",
        "119": " *     private final Condition valueAbsent = lock.newCondition();\n",
        "120": " *     private V value;\n",
        "122": " *     public V get() throws InterruptedException {\n",
        "123": " *       lock.lock();\n",
        "124": " *       try {\n",
        "125": " *         while (value == null) {\n",
        "126": " *           valuePresent.await();\n",
        "127": " *         }\n",
        "128": " *         V result = value;\n",
        "129": " *         value = null;\n",
        "130": " *         valueAbsent.signal();\n",
        "131": " *         return result;\n",
        "132": " *       } finally {\n",
        "133": " *         lock.unlock();\n",
        "137": " *     public void set(V newValue) throws InterruptedException {\n",
        "138": " *       lock.lock();\n",
        "139": " *       try {\n",
        "140": " *         while (value != null) {\n",
        "141": " *           valueAbsent.await();\n",
        "142": " *         }\n",
        "143": " *         value = newValue;\n",
        "144": " *         valuePresent.signal();\n",
        "145": " *       } finally {\n",
        "146": " *         lock.unlock();\n",
        "149": " *   }}</pre>\n",
        "157": " * remember to use {@code while} instead of {@code if}. <pre>   {@code\n",
        "159": " *   public class SafeBox<V> {\n",
        "160": " *     private final Monitor monitor = new Monitor();\n",
        "161": " *     private final Monitor.Guard valuePresent = new Monitor.Guard(monitor) {\n",
        "162": " *       public boolean isSatisfied() {\n",
        "163": " *         return value != null;\n",
        "164": " *       }\n",
        "165": " *     };\n",
        "166": " *     private final Monitor.Guard valueAbsent = new Monitor.Guard(monitor) {\n",
        "167": " *       public boolean isSatisfied() {\n",
        "168": " *         return value == null;\n",
        "169": " *       }\n",
        "170": " *     };\n",
        "171": " *     private V value;\n",
        "173": " *     public V get() throws InterruptedException {\n",
        "174": " *       monitor.enterWhen(valuePresent);\n",
        "175": " *       try {\n",
        "176": " *         V result = value;\n",
        "177": " *         value = null;\n",
        "178": " *         return result;\n",
        "179": " *       } finally {\n",
        "180": " *         monitor.leave();\n",
        "181": " *       }\n",
        "184": " *     public void set(V newValue) throws InterruptedException {\n",
        "185": " *       monitor.enterWhen(valueAbsent);\n",
        "186": " *       try {\n",
        "187": " *         value = newValue;\n",
        "188": " *       } finally {\n",
        "189": " *         monitor.leave();\n",
        "190": " *       }\n",
        "192": " *   }}</pre>\n",
        "327": "  /**\n",
        "328": "   * Whether this monitor is fair.\n",
        "329": "   */\n",
        "332": "  /**\n",
        "333": "   * The lock underlying this monitor.\n",
        "334": "   */\n",
        "363": "  /**\n",
        "364": "   * Enters this monitor. Blocks indefinitely.\n",
        "365": "   */\n",
        "455": "  /**\n",
        "456": "   * Enters this monitor when the guard is satisfied. Blocks indefinitely.\n",
        "457": "   */\n",
        "814": "  /**\n",
        "815": "   * Leaves this monitor. May be called only by a thread currently occupying this monitor.\n",
        "816": "   */\n",
        "829": "  /**\n",
        "830": "   * Returns whether this monitor is using a fair ordering policy.\n",
        "831": "   */\n",
        "961": "   * We manage calls to this method carefully, to signal only when necessary, but never losing a\n",
        "966": "   * In addition, any thread that has been signalled when its guard was satisfied acquires the\n",
        "972": "   * On the other hand, if a signalled thread wakes up to discover that its guard is still not\n",
        "979": "   * This method must not be called from within a beginWaitingFor/endWaitingFor block, or else the\n",
        "980": "   * current thread's guard might be mistakenly signalled, leading to a lost signal.\n",
        "997": "   * We decided against using this method, since in practice, isSatisfied() is likely to be very\n",
        "1000": "//   @GuardedBy(\"lock\")\n",
        "1001": "//   private void signalNextWaiterSkipping(Guard guardToSkip) {\n",
        "1002": "//     for (Guard guard = activeGuards; guard != null; guard = guard.next) {\n",
        "1003": "//       if (guard != guardToSkip && isSatisfied(guard)) {\n",
        "1004": "//         guard.condition.signal();\n",
        "1005": "//         break;\n",
        "1006": "//       }\n",
        "1007": "//     }\n",
        "1008": "//   }\n",
        "1024": "  /**\n",
        "1025": "   * Signals all threads waiting on guards.\n",
        "1026": "   */\n",
        "1034": "  /**\n",
        "1035": "   * Records that the current thread is about to wait on the specified guard.\n",
        "1036": "   */\n",
        "1047": "  /**\n",
        "1048": "   * Records that the current thread is no longer waiting on the specified guard.\n",
        "1049": "   */\n",
        "1105": "  /**\n",
        "1106": "   * Caller should check before calling that guard is not satisfied.\n",
        "1107": "   */\n"
    }
}