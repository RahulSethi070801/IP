{
    "addition": {
        "21": " * One or more variables that together maintain an initially zero {@code long} sum. When updates\n",
        "22": " * (method {@link #add}) are contended across threads, the set of variables may grow dynamically to\n",
        "23": " * reduce contention. Method {@link #sum} (or, equivalently, {@link #longValue}) returns the current\n",
        "24": " * total combined across the variables maintaining the sum.\n",
        "26": " * <p>This class is usually preferable to {@link AtomicLong} when multiple threads update a common\n",
        "27": " * sum that is used for purposes such as collecting statistics, not for fine-grained synchronization\n",
        "28": " * control. Under low update contention, the two classes have similar characteristics. But under\n",
        "29": " * high contention, expected throughput of this class is significantly higher, at the expense of\n",
        "30": " * higher space consumption.\n",
        "32": " * <p>This class extends {@link Number}, but does <em>not</em> define methods such as {@code\n",
        "33": " * equals}, {@code hashCode} and {@code compareTo} because instances are expected to be mutated, and\n",
        "34": " * so are not useful as collection keys.\n",
        "36": " * <p><em>jsr166e note: This class is targeted to be placed in java.util.concurrent.atomic.</em>\n",
        "42": "  private static final long serialVersionUID = 7249069246863182397L;\n",
        "43": "\n",
        "44": "  /** Version of plus for use in retryUpdate */\n",
        "45": "  final long fn(long v, long x) {\n",
        "46": "    return v + x;\n",
        "47": "  }\n",
        "48": "\n",
        "49": "  /** Creates a new adder with initial sum of zero. */\n",
        "50": "  public LongAdder() {}\n",
        "51": "\n",
        "52": "  /**\n",
        "53": "   * Adds the given value.\n",
        "54": "   *\n",
        "55": "   * @param x the value to add\n",
        "56": "   */\n",
        "57": "  public void add(long x) {\n",
        "58": "    Cell[] as;\n",
        "59": "    long b, v;\n",
        "60": "    int[] hc;\n",
        "61": "    Cell a;\n",
        "62": "    int n;\n",
        "63": "    if ((as = cells) != null || !casBase(b = base, b + x)) {\n",
        "64": "      boolean uncontended = true;\n",
        "65": "      if ((hc = threadHashCode.get()) == null\n",
        "66": "          || as == null\n",
        "67": "          || (n = as.length) < 1\n",
        "68": "          || (a = as[(n - 1) & hc[0]]) == null\n",
        "69": "          || !(uncontended = a.cas(v = a.value, v + x))) retryUpdate(x, hc, uncontended);\n",
        "71": "  }\n",
        "72": "\n",
        "73": "  /** Equivalent to {@code add(1)}. */\n",
        "74": "  public void increment() {\n",
        "75": "    add(1L);\n",
        "76": "  }\n",
        "77": "\n",
        "78": "  /** Equivalent to {@code add(-1)}. */\n",
        "79": "  public void decrement() {\n",
        "80": "    add(-1L);\n",
        "81": "  }\n",
        "82": "\n",
        "83": "  /**\n",
        "84": "   * Returns the current sum. The returned value is <em>NOT</em> an atomic snapshot; invocation in\n",
        "85": "   * the absence of concurrent updates returns an accurate result, but concurrent updates that occur\n",
        "86": "   * while the sum is being calculated might not be incorporated.\n",
        "87": "   *\n",
        "88": "   * @return the sum\n",
        "89": "   */\n",
        "90": "  public long sum() {\n",
        "91": "    long sum = base;\n",
        "92": "    Cell[] as = cells;\n",
        "93": "    if (as != null) {\n",
        "94": "      int n = as.length;\n",
        "95": "      for (int i = 0; i < n; ++i) {\n",
        "96": "        Cell a = as[i];\n",
        "97": "        if (a != null) sum += a.value;\n",
        "98": "      }\n",
        "100": "    return sum;\n",
        "101": "  }\n",
        "102": "\n",
        "103": "  /**\n",
        "104": "   * Resets variables maintaining the sum to zero. This method may be a useful alternative to\n",
        "105": "   * creating a new adder, but is only effective if there are no concurrent updates. Because this\n",
        "106": "   * method is intrinsically racy, it should only be used when it is known that no threads are\n",
        "107": "   * concurrently updating.\n",
        "108": "   */\n",
        "109": "  public void reset() {\n",
        "110": "    internalReset(0L);\n",
        "111": "  }\n",
        "112": "\n",
        "113": "  /**\n",
        "114": "   * Equivalent in effect to {@link #sum} followed by {@link #reset}. This method may apply for\n",
        "115": "   * example during quiescent points between multithreaded computations. If there are updates\n",
        "116": "   * concurrent with this method, the returned value is <em>not</em> guaranteed to be the final\n",
        "117": "   * value occurring before the reset.\n",
        "118": "   *\n",
        "119": "   * @return the sum\n",
        "120": "   */\n",
        "121": "  public long sumThenReset() {\n",
        "122": "    long sum = base;\n",
        "123": "    Cell[] as = cells;\n",
        "124": "    base = 0L;\n",
        "125": "    if (as != null) {\n",
        "126": "      int n = as.length;\n",
        "127": "      for (int i = 0; i < n; ++i) {\n",
        "128": "        Cell a = as[i];\n",
        "129": "        if (a != null) {\n",
        "130": "          sum += a.value;\n",
        "131": "          a.value = 0L;\n",
        "133": "      }\n",
        "135": "    return sum;\n",
        "136": "  }\n",
        "137": "\n",
        "138": "  /**\n",
        "139": "   * Returns the String representation of the {@link #sum}.\n",
        "140": "   *\n",
        "141": "   * @return the String representation of the {@link #sum}\n",
        "142": "   */\n",
        "143": "  public String toString() {\n",
        "144": "    return Long.toString(sum());\n",
        "145": "  }\n",
        "146": "\n",
        "147": "  /**\n",
        "148": "   * Equivalent to {@link #sum}.\n",
        "149": "   *\n",
        "150": "   * @return the sum\n",
        "151": "   */\n",
        "152": "  public long longValue() {\n",
        "153": "    return sum();\n",
        "154": "  }\n",
        "155": "\n",
        "156": "  /** Returns the {@link #sum} as an {@code int} after a narrowing primitive conversion. */\n",
        "157": "  public int intValue() {\n",
        "158": "    return (int) sum();\n",
        "159": "  }\n",
        "160": "\n",
        "161": "  /** Returns the {@link #sum} as a {@code float} after a widening primitive conversion. */\n",
        "162": "  public float floatValue() {\n",
        "163": "    return (float) sum();\n",
        "164": "  }\n",
        "165": "\n",
        "166": "  /** Returns the {@link #sum} as a {@code double} after a widening primitive conversion. */\n",
        "167": "  public double doubleValue() {\n",
        "168": "    return (double) sum();\n",
        "169": "  }\n",
        "170": "\n",
        "171": "  private void writeObject(ObjectOutputStream s) throws IOException {\n",
        "172": "    s.defaultWriteObject();\n",
        "173": "    s.writeLong(sum());\n",
        "174": "  }\n",
        "175": "\n",
        "176": "  private void readObject(ObjectInputStream s) throws IOException, ClassNotFoundException {\n",
        "177": "    s.defaultReadObject();\n",
        "178": "    busy = 0;\n",
        "179": "    cells = null;\n",
        "180": "    base = s.readLong();\n",
        "181": "  }\n"
    },
    "removed": {
        "21": " * One or more variables that together maintain an initially zero\n",
        "22": " * {@code long} sum.  When updates (method {@link #add}) are contended\n",
        "23": " * across threads, the set of variables may grow dynamically to reduce\n",
        "24": " * contention. Method {@link #sum} (or, equivalently, {@link\n",
        "25": " * #longValue}) returns the current total combined across the\n",
        "26": " * variables maintaining the sum.\n",
        "28": " * <p>This class is usually preferable to {@link AtomicLong} when\n",
        "29": " * multiple threads update a common sum that is used for purposes such\n",
        "30": " * as collecting statistics, not for fine-grained synchronization\n",
        "31": " * control.  Under low update contention, the two classes have similar\n",
        "32": " * characteristics. But under high contention, expected throughput of\n",
        "33": " * this class is significantly higher, at the expense of higher space\n",
        "34": " * consumption.\n",
        "36": " * <p>This class extends {@link Number}, but does <em>not</em> define\n",
        "37": " * methods such as {@code equals}, {@code hashCode} and {@code\n",
        "38": " * compareTo} because instances are expected to be mutated, and so are\n",
        "39": " * not useful as collection keys.\n",
        "41": " * <p><em>jsr166e note: This class is targeted to be placed in\n",
        "42": " * java.util.concurrent.atomic.</em>\n",
        "48": "    private static final long serialVersionUID = 7249069246863182397L;\n",
        "49": "\n",
        "50": "    /**\n",
        "51": "     * Version of plus for use in retryUpdate\n",
        "52": "     */\n",
        "53": "    final long fn(long v, long x) { return v + x; }\n",
        "54": "\n",
        "55": "    /**\n",
        "56": "     * Creates a new adder with initial sum of zero.\n",
        "57": "     */\n",
        "58": "    public LongAdder() {\n",
        "59": "    }\n",
        "60": "\n",
        "61": "    /**\n",
        "62": "     * Adds the given value.\n",
        "63": "     *\n",
        "64": "     * @param x the value to add\n",
        "65": "     */\n",
        "66": "    public void add(long x) {\n",
        "67": "        Cell[] as; long b, v; int[] hc; Cell a; int n;\n",
        "68": "        if ((as = cells) != null || !casBase(b = base, b + x)) {\n",
        "69": "            boolean uncontended = true;\n",
        "70": "            if ((hc = threadHashCode.get()) == null ||\n",
        "71": "                as == null || (n = as.length) < 1 ||\n",
        "72": "                (a = as[(n - 1) & hc[0]]) == null ||\n",
        "73": "                !(uncontended = a.cas(v = a.value, v + x)))\n",
        "74": "                retryUpdate(x, hc, uncontended);\n",
        "75": "        }\n",
        "76": "    }\n",
        "77": "\n",
        "78": "    /**\n",
        "79": "     * Equivalent to {@code add(1)}.\n",
        "80": "     */\n",
        "81": "    public void increment() {\n",
        "82": "        add(1L);\n",
        "84": "\n",
        "85": "    /**\n",
        "86": "     * Equivalent to {@code add(-1)}.\n",
        "87": "     */\n",
        "88": "    public void decrement() {\n",
        "89": "        add(-1L);\n",
        "91": "\n",
        "92": "    /**\n",
        "93": "     * Returns the current sum.  The returned value is <em>NOT</em> an\n",
        "94": "     * atomic snapshot; invocation in the absence of concurrent\n",
        "95": "     * updates returns an accurate result, but concurrent updates that\n",
        "96": "     * occur while the sum is being calculated might not be\n",
        "97": "     * incorporated.\n",
        "98": "     *\n",
        "99": "     * @return the sum\n",
        "100": "     */\n",
        "101": "    public long sum() {\n",
        "102": "        long sum = base;\n",
        "103": "        Cell[] as = cells;\n",
        "104": "        if (as != null) {\n",
        "105": "            int n = as.length;\n",
        "106": "            for (int i = 0; i < n; ++i) {\n",
        "107": "                Cell a = as[i];\n",
        "108": "                if (a != null)\n",
        "109": "                    sum += a.value;\n",
        "110": "            }\n",
        "112": "        return sum;\n",
        "113": "    }\n",
        "114": "\n",
        "115": "    /**\n",
        "116": "     * Resets variables maintaining the sum to zero.  This method may\n",
        "117": "     * be a useful alternative to creating a new adder, but is only\n",
        "118": "     * effective if there are no concurrent updates.  Because this\n",
        "119": "     * method is intrinsically racy, it should only be used when it is\n",
        "120": "     * known that no threads are concurrently updating.\n",
        "121": "     */\n",
        "122": "    public void reset() {\n",
        "123": "        internalReset(0L);\n",
        "125": "\n",
        "126": "    /**\n",
        "127": "     * Equivalent in effect to {@link #sum} followed by {@link\n",
        "128": "     * #reset}. This method may apply for example during quiescent\n",
        "129": "     * points between multithreaded computations.  If there are\n",
        "130": "     * updates concurrent with this method, the returned value is\n",
        "131": "     * <em>not</em> guaranteed to be the final value occurring before\n",
        "132": "     * the reset.\n",
        "133": "     *\n",
        "134": "     * @return the sum\n",
        "135": "     */\n",
        "136": "    public long sumThenReset() {\n",
        "137": "        long sum = base;\n",
        "138": "        Cell[] as = cells;\n",
        "139": "        base = 0L;\n",
        "140": "        if (as != null) {\n",
        "141": "            int n = as.length;\n",
        "142": "            for (int i = 0; i < n; ++i) {\n",
        "143": "                Cell a = as[i];\n",
        "144": "                if (a != null) {\n",
        "145": "                    sum += a.value;\n",
        "146": "                    a.value = 0L;\n",
        "147": "                }\n",
        "148": "            }\n",
        "149": "        }\n",
        "150": "        return sum;\n",
        "151": "    }\n",
        "152": "\n",
        "153": "    /**\n",
        "154": "     * Returns the String representation of the {@link #sum}.\n",
        "155": "     * @return the String representation of the {@link #sum}\n",
        "156": "     */\n",
        "157": "    public String toString() {\n",
        "158": "        return Long.toString(sum());\n",
        "159": "    }\n",
        "160": "\n",
        "161": "    /**\n",
        "162": "     * Equivalent to {@link #sum}.\n",
        "163": "     *\n",
        "164": "     * @return the sum\n",
        "165": "     */\n",
        "166": "    public long longValue() {\n",
        "167": "        return sum();\n",
        "168": "    }\n",
        "169": "\n",
        "170": "    /**\n",
        "171": "     * Returns the {@link #sum} as an {@code int} after a narrowing\n",
        "172": "     * primitive conversion.\n",
        "173": "     */\n",
        "174": "    public int intValue() {\n",
        "175": "        return (int)sum();\n",
        "176": "    }\n",
        "177": "\n",
        "178": "    /**\n",
        "179": "     * Returns the {@link #sum} as a {@code float}\n",
        "180": "     * after a widening primitive conversion.\n",
        "181": "     */\n",
        "182": "    public float floatValue() {\n",
        "183": "        return (float)sum();\n",
        "184": "    }\n",
        "185": "\n",
        "186": "    /**\n",
        "187": "     * Returns the {@link #sum} as a {@code double} after a widening\n",
        "188": "     * primitive conversion.\n",
        "189": "     */\n",
        "190": "    public double doubleValue() {\n",
        "191": "        return (double)sum();\n",
        "192": "    }\n",
        "193": "\n",
        "194": "    private void writeObject(ObjectOutputStream s) throws IOException {\n",
        "195": "        s.defaultWriteObject();\n",
        "196": "        s.writeLong(sum());\n",
        "197": "    }\n",
        "198": "\n",
        "199": "    private void readObject(ObjectInputStream s)\n",
        "200": "            throws IOException, ClassNotFoundException {\n",
        "201": "        s.defaultReadObject();\n",
        "202": "        busy = 0;\n",
        "203": "        cells = null;\n",
        "204": "        base = s.readLong();\n",
        "205": "    }\n",
        "206": "\n"
    }
}