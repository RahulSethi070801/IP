{
    "addition": {
        "36": "  private static final ImmutableList<ExpectedHashCode> expectedHashCodes =\n",
        "37": "      ImmutableList.of(\n",
        "38": "          new ExpectedHashCode(\n",
        "39": "              new byte[] {\n",
        "40": "                (byte) 0xef, (byte) 0xcd, (byte) 0xab, (byte) 0x89,\n",
        "41": "                (byte) 0x67, (byte) 0x45, (byte) 0x23, (byte) 0x01\n",
        "42": "              },\n",
        "43": "              0x89abcdef,\n",
        "44": "              0x0123456789abcdefL,\n",
        "45": "              \"efcdab8967452301\"),\n",
        "46": "          new ExpectedHashCode(\n",
        "47": "              new byte[] {\n",
        "48": "                (byte) 0xef, (byte) 0xcd, (byte) 0xab, (byte) 0x89,\n",
        "49": "                (byte) 0x67, (byte) 0x45, (byte) 0x23,\n",
        "50": "                    (byte) 0x01, // up to here, same bytes as above\n",
        "51": "                (byte) 0x01, (byte) 0x02, (byte) 0x03, (byte) 0x04,\n",
        "52": "                (byte) 0x05, (byte) 0x06, (byte) 0x07, (byte) 0x08\n",
        "53": "              },\n",
        "54": "              0x89abcdef,\n",
        "55": "              0x0123456789abcdefL, // asInt/asLong as above, due to equal eight first bytes\n",
        "56": "              \"efcdab89674523010102030405060708\"),\n",
        "57": "          new ExpectedHashCode(\n",
        "58": "              new byte[] {(byte) 0xdf, (byte) 0x9b, (byte) 0x57, (byte) 0x13},\n",
        "59": "              0x13579bdf,\n",
        "60": "              null,\n",
        "61": "              \"df9b5713\"),\n",
        "62": "          new ExpectedHashCode(\n",
        "63": "              new byte[] {(byte) 0xcd, (byte) 0xab, (byte) 0x00, (byte) 0x00},\n",
        "64": "              0x0000abcd,\n",
        "65": "              null,\n",
        "66": "              \"cdab0000\"),\n",
        "67": "          new ExpectedHashCode(\n",
        "68": "              new byte[] {\n",
        "69": "                (byte) 0xef, (byte) 0xcd, (byte) 0xab, (byte) 0x00,\n",
        "70": "                (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00\n",
        "71": "              },\n",
        "72": "              0x00abcdef,\n",
        "73": "              0x0000000000abcdefL,\n",
        "74": "              \"efcdab0000000000\"));\n",
        "104": "    byte[] bytes = new byte[] {(byte) 0xcd, (byte) 0xab, (byte) 0x00, (byte) 0x00};\n",
        "119": "    byte[] bytes = new byte[] {(byte) 0xcd, (byte) 0xab, (byte) 0x00, (byte) 0x00};\n",
        "132": "    byte[] bytes = new byte[] {(byte) 0xcd, (byte) 0xab, (byte) 0x00, (byte) 0x00};\n",
        "170": "    byte[] data = new byte[] {127, -128, 5, -1, 14};\n",
        "185": "    HashCode hash2 = HashCode.fromBytes(BaseEncoding.base16().lowerCase().decode(hash1.toString()));\n",
        "227": "          HashCode.fromBytes(BaseEncoding.base16().lowerCase().decode(string)).toString());\n",
        "273": "    assertTrue(Arrays.equals(HashCode.fromInt(42).asBytes(), dest));\n",
        "279": "    assertTrue(Arrays.equals(HashCode.fromLong(42).asBytes(), dest));\n",
        "283": "      HashCode.fromBytes(new byte[] {(byte) 0xaa, (byte) 0xbb, (byte) 0xcc, (byte) 0xdd});\n",
        "288": "    assertTrue(\n",
        "289": "        Arrays.equals(new byte[] {(byte) 0xaa, (byte) 0xbb, (byte) 0xcc, (byte) 0xdd}, dest));\n",
        "295": "    assertTrue(\n",
        "296": "        Arrays.equals(\n",
        "297": "            new byte[] {(byte) 0xaa, (byte) 0xbb, (byte) 0xcc, (byte) 0xdd, (byte) 0x00}, dest));\n",
        "303": "    assertTrue(\n",
        "304": "        Arrays.equals(\n",
        "305": "            new byte[] {(byte) 0xaa, (byte) 0xbb, (byte) 0xcc, (byte) 0xdd, (byte) 0x00}, dest));\n",
        "311": "    assertTrue(\n",
        "312": "        Arrays.equals(\n",
        "313": "            new byte[] {(byte) 0xaa, (byte) 0xbb, (byte) 0xcc, (byte) 0x00, (byte) 0x00}, dest));\n",
        "337": "    assertTrue(Arrays.equals(new byte[] {(byte) 0xaa, (byte) 0xbb, (byte) 0x00}, dest));\n",
        "358": "      } catch (IllegalStateException expected) {\n",
        "359": "      }\n"
    },
    "removed": {
        "36": "  private static final ImmutableList<ExpectedHashCode> expectedHashCodes = ImmutableList.of(\n",
        "37": "      new ExpectedHashCode(new byte[] {\n",
        "38": "        (byte) 0xef, (byte) 0xcd, (byte) 0xab, (byte) 0x89,\n",
        "39": "        (byte) 0x67, (byte) 0x45, (byte) 0x23, (byte) 0x01},\n",
        "40": "        0x89abcdef, 0x0123456789abcdefL, \"efcdab8967452301\"),\n",
        "41": "\n",
        "42": "      new ExpectedHashCode(new byte[] {\n",
        "43": "        (byte) 0xef, (byte) 0xcd, (byte) 0xab, (byte) 0x89,\n",
        "44": "        (byte) 0x67, (byte) 0x45, (byte) 0x23, (byte) 0x01, // up to here, same bytes as above\n",
        "45": "        (byte) 0x01, (byte) 0x02, (byte) 0x03, (byte) 0x04,\n",
        "46": "        (byte) 0x05, (byte) 0x06, (byte) 0x07, (byte) 0x08},\n",
        "47": "        0x89abcdef, 0x0123456789abcdefL, // asInt/asLong as above, due to equal eight first bytes\n",
        "48": "        \"efcdab89674523010102030405060708\"),\n",
        "49": "\n",
        "50": "      new ExpectedHashCode(new byte[] { (byte) 0xdf, (byte) 0x9b, (byte) 0x57, (byte) 0x13 },\n",
        "51": "        0x13579bdf, null, \"df9b5713\"),\n",
        "52": "\n",
        "53": "      new ExpectedHashCode(new byte[] {\n",
        "54": "          (byte) 0xcd, (byte) 0xab, (byte) 0x00, (byte) 0x00},\n",
        "55": "          0x0000abcd, null, \"cdab0000\"),\n",
        "56": "\n",
        "57": "      new ExpectedHashCode(new byte[] {\n",
        "58": "          (byte) 0xef, (byte) 0xcd, (byte) 0xab, (byte) 0x00,\n",
        "59": "          (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00},\n",
        "60": "          0x00abcdef, 0x0000000000abcdefL, \"efcdab0000000000\")\n",
        "61": "    );\n",
        "91": "    byte[] bytes = new byte[] { (byte) 0xcd, (byte) 0xab, (byte) 0x00, (byte) 0x00 };\n",
        "106": "    byte[] bytes = new byte[] { (byte) 0xcd, (byte) 0xab, (byte) 0x00, (byte) 0x00 };\n",
        "119": "    byte[] bytes = new byte[] { (byte) 0xcd, (byte) 0xab, (byte) 0x00, (byte) 0x00 };\n",
        "157": "    byte[] data = new byte[] { 127, -128, 5, -1, 14 };\n",
        "172": "    HashCode hash2 =\n",
        "173": "        HashCode.fromBytes(BaseEncoding.base16().lowerCase().decode(hash1.toString()));\n",
        "215": "          HashCode.fromBytes(\n",
        "216": "              BaseEncoding.base16().lowerCase().decode(string)).toString());\n",
        "262": "    assertTrue(Arrays.equals(\n",
        "263": "        HashCode.fromInt(42).asBytes(),\n",
        "264": "        dest));\n",
        "270": "    assertTrue(Arrays.equals(\n",
        "271": "        HashCode.fromLong(42).asBytes(),\n",
        "272": "        dest));\n",
        "276": "      HashCode.fromBytes(new byte[] { (byte) 0xaa, (byte) 0xbb, (byte) 0xcc, (byte) 0xdd });\n",
        "281": "    assertTrue(Arrays.equals(\n",
        "282": "        new byte[] { (byte) 0xaa, (byte) 0xbb, (byte) 0xcc, (byte) 0xdd },\n",
        "283": "        dest));\n",
        "289": "    assertTrue(Arrays.equals(\n",
        "290": "        new byte[] { (byte) 0xaa, (byte) 0xbb, (byte) 0xcc, (byte) 0xdd, (byte) 0x00 },\n",
        "291": "        dest));\n",
        "297": "    assertTrue(Arrays.equals(\n",
        "298": "        new byte[] { (byte) 0xaa, (byte) 0xbb, (byte) 0xcc, (byte) 0xdd, (byte) 0x00 },\n",
        "299": "        dest));\n",
        "305": "    assertTrue(Arrays.equals(\n",
        "306": "        new byte[] { (byte) 0xaa, (byte) 0xbb, (byte) 0xcc, (byte) 0x00, (byte) 0x00 },\n",
        "307": "        dest));\n",
        "331": "    assertTrue(Arrays.equals(\n",
        "332": "        new byte[] { (byte) 0xaa, (byte) 0xbb, (byte) 0x00 },\n",
        "333": "        dest));\n",
        "354": "      } catch (IllegalStateException expected) {}\n"
    }
}