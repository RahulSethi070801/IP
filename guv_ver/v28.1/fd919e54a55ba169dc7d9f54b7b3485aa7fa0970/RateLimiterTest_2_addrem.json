{
    "addition": {
        "82": "    } catch (IllegalArgumentException expected) {\n",
        "83": "    }\n",
        "87": "    } catch (IllegalArgumentException expected) {\n",
        "88": "    }\n",
        "127": "    limiter.acquire(); // R0.00\n",
        "128": "    stopwatch.sleepMillis(200); // U0.20, we are ready for the next request...\n",
        "129": "    limiter.acquire(); // R0.00, ...which is granted immediately\n",
        "130": "    limiter.acquire(); // R0.20\n",
        "136": "    assertEquals(0.0, limiter.acquire(), EPSILON); // R0.00\n",
        "137": "    stopwatch.sleepMillis(200); // U0.20, we are ready for the next request...\n",
        "138": "    assertEquals(0.0, limiter.acquire(), EPSILON); // R0.00, ...which is granted immediately\n",
        "139": "    assertEquals(0.2, limiter.acquire(), EPSILON); // R0.20\n",
        "163": "    assertEvents(\n",
        "164": "        \"U1.00\", \"U1.00\", \"R0.00\", \"R0.00\", \"R0.00\", \"R0.00\", // first request and burst\n",
        "391": "        \"R0.00\", \"R0.00\", // Now comes the free request.\n",
        "412": "        \"R0.00\", \"R0.00\", // Now comes the free request.\n",
        "448": "   * Make sure that bursts can never go above 1-second-worth-of-work for the current rate, even when\n",
        "449": "   * we change the rate.\n",
        "453": "    int[] rates = {1000, 1, 10, 1000000, 10, 1};\n",
        "468": "   * This neat test shows that no matter what weights we use in our requests, if we push X amount of\n",
        "469": "   * permits in a cool state, where X = rate * timeToCoolDown, and we have specified a\n",
        "470": "   * timeToWarmUp() period, it will cost as the prescribed amount of time. E.g., calling\n",
        "471": "   * [acquire(5), acquire(1)] takes exactly the same time as [acquire(2), acquire(3), acquire(1)].\n",
        "476": "    double[] coldFactorsToTest = {2.0, 3.0, 10.0};\n",
        "477": "    double[] qpsToTest = {4.0, 2.0, 1.0, 0.5, 0.1};\n",
        "493": "    NullPointerTester tester =\n",
        "494": "        new NullPointerTester()\n",
        "495": "            .setDefault(SleepingStopwatch.class, stopwatch)\n",
        "496": "            .setDefault(int.class, 1)\n",
        "497": "            .setDefault(double.class, 1.0d);\n",
        "527": "   * The stopwatch gathers events and presents them as strings. R0.6 means a delay of 0.6 seconds\n",
        "528": "   * caused by the (R)ateLimiter U1.0 means the (U)ser caused the stopwatch to sleep for a second.\n"
    },
    "removed": {
        "82": "    } catch (IllegalArgumentException expected) {}\n",
        "86": "    } catch (IllegalArgumentException expected) {}\n",
        "125": "    limiter.acquire();          // R0.00\n",
        "126": "    stopwatch.sleepMillis(200);    // U0.20, we are ready for the next request...\n",
        "127": "    limiter.acquire();          // R0.00, ...which is granted immediately\n",
        "128": "    limiter.acquire();          // R0.20\n",
        "134": "    assertEquals(0.0, limiter.acquire(), EPSILON);  // R0.00\n",
        "135": "    stopwatch.sleepMillis(200);                     // U0.20, we are ready for the next request...\n",
        "136": "    assertEquals(0.0, limiter.acquire(), EPSILON);  // R0.00, ...which is granted immediately\n",
        "137": "    assertEquals(0.2, limiter.acquire(), EPSILON);  // R0.20\n",
        "161": "    assertEvents(\"U1.00\", \"U1.00\",\n",
        "162": "        \"R0.00\", \"R0.00\", \"R0.00\", \"R0.00\", // first request and burst\n",
        "389": "        \"R0.00\",\n",
        "390": "        \"R0.00\", // Now comes the free request.\n",
        "411": "        \"R0.00\",\n",
        "412": "        \"R0.00\", // Now comes the free request.\n",
        "448": "   * Make sure that bursts can never go above 1-second-worth-of-work for the current\n",
        "449": "   * rate, even when we change the rate.\n",
        "453": "    int[] rates = { 1000, 1, 10, 1000000, 10, 1};\n",
        "468": "   * This neat test shows that no matter what weights we use in our requests, if we push X\n",
        "469": "   * amount of permits in a cool state, where X = rate * timeToCoolDown, and we have\n",
        "470": "   * specified a timeToWarmUp() period, it will cost as the prescribed amount of time. E.g.,\n",
        "471": "   * calling [acquire(5), acquire(1)] takes exactly the same time as\n",
        "472": "   * [acquire(2), acquire(3), acquire(1)].\n",
        "477": "    double[] coldFactorsToTest = { 2.0, 3.0, 10.0 };\n",
        "478": "    double[] qpsToTest = { 4.0, 2.0, 1.0, 0.5, 0.1 };\n",
        "494": "    NullPointerTester tester = new NullPointerTester()\n",
        "495": "        .setDefault(SleepingStopwatch.class, stopwatch)\n",
        "496": "        .setDefault(int.class, 1)\n",
        "497": "        .setDefault(double.class, 1.0d);\n",
        "527": "   * The stopwatch gathers events and presents them as strings.\n",
        "528": "   * R0.6 means a delay of 0.6 seconds caused by the (R)ateLimiter\n",
        "529": "   * U1.0 means the (U)ser caused the stopwatch to sleep for a second.\n"
    }
}