{
    "addition": {
        "233": "  private static class MyException extends Exception {}\n",
        "237": "    CheckedFuture<String, MyException> future = immediateCheckedFuture(DATA1);\n",
        "238": "    assertThat(future.toString()).endsWith(\"[status=SUCCESS, result=[\" + DATA1 + \"]]\");\n",
        "247": "    CheckedFuture<String, MyException> future1 = immediateCheckedFuture(DATA1);\n",
        "248": "    CheckedFuture<String, MyException> future2 = immediateCheckedFuture(DATA2);\n",
        "260": "    CheckedFuture<String, MyException> future = immediateFailedCheckedFuture(exception);\n",
        "261": "    assertThat(future.toString()).endsWith(\"[status=FAILURE, cause=[\" + exception + \"]]\");\n",
        "279": "  private static class Foo {}\n",
        "281": "  private static class FooChild extends Foo {}\n",
        "283": "  private static class Bar {}\n",
        "285": "  private static class BarChild extends Bar {}\n",
        "296": "    Function<Foo, BarChild> function =\n",
        "297": "        new Function<Foo, BarChild>() {\n",
        "298": "          @Override\n",
        "299": "          public BarChild apply(Foo unused) {\n",
        "300": "            return barChild;\n",
        "301": "          }\n",
        "302": "        };\n",
        "422": "    AsyncFunction<Foo, Bar> function =\n",
        "423": "        new AsyncFunction<Foo, Bar>() {\n",
        "424": "          @Override\n",
        "425": "          public ListenableFuture<Bar> apply(Foo unused) {\n",
        "426": "            throw new AssertionFailedError(\"Unexpeted call to apply.\");\n",
        "427": "          }\n",
        "428": "        };\n",
        "436": "    AsyncFunction<Foo, Bar> function =\n",
        "437": "        new AsyncFunction<Foo, Bar>() {\n",
        "438": "          @Override\n",
        "439": "          public ListenableFuture<Bar> apply(Foo unused) {\n",
        "440": "            throw new AssertionFailedError(\"Unexpeted call to apply.\");\n",
        "441": "          }\n",
        "442": "        };\n",
        "455": "    AsyncFunction<String, String> function =\n",
        "456": "        new AsyncFunction<String, String>() {\n",
        "457": "          @Override\n",
        "458": "          public ListenableFuture<String> apply(String s) throws Exception {\n",
        "459": "            inFunction.countDown();\n",
        "460": "            try {\n",
        "461": "              shouldCompleteFunction.await();\n",
        "462": "            } catch (InterruptedException expected) {\n",
        "463": "              gotException.countDown();\n",
        "464": "              throw expected;\n",
        "465": "            }\n",
        "466": "            return immediateFuture(\"a\");\n",
        "467": "          }\n",
        "468": "        };\n",
        "480": "    } catch (CancellationException expected) {\n",
        "481": "    }\n",
        "491": "    AsyncFunction<Foo, Bar> function =\n",
        "492": "        new AsyncFunction<Foo, Bar>() {\n",
        "493": "          @Override\n",
        "494": "          public ListenableFuture<Bar> apply(Foo unused) {\n",
        "495": "            return secondary;\n",
        "496": "          }\n",
        "497": "        };\n",
        "503": "  public void testTransformAsync_interruptPropagatesToAsyncOutput() throws Exception {\n",
        "506": "    AsyncFunction<Foo, Bar> function =\n",
        "507": "        new AsyncFunction<Foo, Bar>() {\n",
        "508": "          @Override\n",
        "509": "          public ListenableFuture<Bar> apply(Foo unused) {\n",
        "510": "            return secondary;\n",
        "511": "          }\n",
        "512": "        };\n",
        "651": "  public void testTransform_rejectionPropagatesToOutput() throws Exception {\n",
        "667": "    ListenableFuture<Foo> transformed = transformAsync(input, asyncIdentity, REJECTING_EXECUTOR);\n",
        "677": "  /** Tests that the function is invoked only once, even if it throws an exception. */\n",
        "686": "    Function<Integer, Integer> adder =\n",
        "687": "        new Function<Integer, Integer>() {\n",
        "688": "          @Override\n",
        "689": "          public Integer apply(Integer from) {\n",
        "690": "            return from + holder.value;\n",
        "691": "          }\n",
        "692": "        };\n",
        "726": "  static class MyError extends Error {}\n",
        "728": "  static class MyRuntimeException extends RuntimeException {}\n",
        "835": "    ListenableFuture<Object> future = transform(immediateFuture(value), identity(), spy);\n",
        "856": "    Function<Integer, String> function =\n",
        "857": "        new Function<Integer, String>() {\n",
        "858": "          @Override\n",
        "859": "          public String apply(Integer input) {\n",
        "860": "            throw exception;\n",
        "861": "          }\n",
        "862": "        };\n",
        "961": "    AsyncFunctionSpy<Throwable, Integer> fallback =\n",
        "962": "        spy(\n",
        "963": "            new AsyncFunction<Throwable, Integer>() {\n",
        "964": "              @Override\n",
        "965": "              public ListenableFuture<Integer> apply(Throwable t) throws Exception {\n",
        "966": "                assertThat(t).isSameAs(raisedException);\n",
        "967": "                return immediateFuture(20);\n",
        "968": "              }\n",
        "969": "            });\n",
        "983": "    Exception expectedException = new Exception() {};\n",
        "989": "    AsyncFunction<Throwable, Integer> fallback =\n",
        "990": "        new AsyncFunction<Throwable, Integer>() {\n",
        "991": "          @Override\n",
        "992": "          public ListenableFuture<Integer> apply(Throwable t) throws Exception {\n",
        "993": "            throw error;\n",
        "994": "          }\n",
        "995": "        };\n",
        "1011": "    Exception expectedException = new Exception() {};\n",
        "1017": "    AsyncFunctionSpy<Throwable, Integer> fallback =\n",
        "1018": "        spy(\n",
        "1019": "            new AsyncFunction<Throwable, Integer>() {\n",
        "1020": "              @Override\n",
        "1021": "              public ListenableFuture<Integer> apply(Throwable t) throws Exception {\n",
        "1022": "                if (!wrapInFuture) {\n",
        "1023": "                  throw expectedException;\n",
        "1024": "                } else {\n",
        "1025": "                  return immediateFailedFuture(expectedException);\n",
        "1026": "                }\n",
        "1027": "              }\n",
        "1028": "            });\n",
        "1046": "    AsyncFunction<Throwable, Integer> fallback =\n",
        "1047": "        new AsyncFunction<Throwable, Integer>() {\n",
        "1048": "          @Override\n",
        "1049": "          public ListenableFuture<Integer> apply(Throwable t) {\n",
        "1050": "            return secondary;\n",
        "1051": "          }\n",
        "1052": "        };\n",
        "1085": "    AsyncFunctionSpy<Throwable, Integer> fallback =\n",
        "1086": "        spy(\n",
        "1087": "            new AsyncFunction<Throwable, Integer>() {\n",
        "1088": "              @Override\n",
        "1089": "              public ListenableFuture<Integer> apply(Throwable t) throws Exception {\n",
        "1090": "                assertThat(t).isSameAs(raisedException);\n",
        "1091": "                return secondary;\n",
        "1092": "              }\n",
        "1093": "            });\n",
        "1124": "      assertThat(cause)\n",
        "1125": "          .hasMessage(\n",
        "1126": "              \"AsyncFunction.apply returned null instead of a Future. \"\n",
        "1127": "                  + \"Did you mean to return immediateFuture(null)?\");\n",
        "1138": "    AsyncFunction<Throwable, String> function =\n",
        "1139": "        new AsyncFunction<Throwable, String>() {\n",
        "1140": "          @Override\n",
        "1141": "          public ListenableFuture<String> apply(Throwable t) throws Exception {\n",
        "1142": "            inFunction.countDown();\n",
        "1143": "            try {\n",
        "1144": "              shouldCompleteFunction.await();\n",
        "1145": "            } catch (InterruptedException expected) {\n",
        "1146": "              gotException.countDown();\n",
        "1147": "              throw expected;\n",
        "1148": "            }\n",
        "1149": "            return immediateFuture(\"a\");\n",
        "1150": "          }\n",
        "1151": "        };\n",
        "1163": "    } catch (CancellationException expected) {\n",
        "1164": "    }\n",
        "1183": "    FunctionSpy<Throwable, Integer> fallback =\n",
        "1184": "        spy(\n",
        "1185": "            new Function<Throwable, Integer>() {\n",
        "1186": "              @Override\n",
        "1187": "              public Integer apply(Throwable t) {\n",
        "1188": "                assertThat(t).isSameAs(raisedException);\n",
        "1189": "                return 20;\n",
        "1190": "              }\n",
        "1191": "            });\n",
        "1211": "    Function<Throwable, Integer> fallback =\n",
        "1212": "        new Function<Throwable, Integer>() {\n",
        "1213": "          @Override\n",
        "1214": "          public Integer apply(Throwable t) {\n",
        "1215": "            throw error;\n",
        "1216": "          }\n",
        "1217": "        };\n",
        "1234": "    FunctionSpy<Throwable, Integer> fallback =\n",
        "1235": "        spy(\n",
        "1236": "            new Function<Throwable, Integer>() {\n",
        "1237": "              @Override\n",
        "1238": "              public Integer apply(Throwable t) {\n",
        "1239": "                throw expectedException;\n",
        "1240": "              }\n",
        "1241": "            });\n",
        "1628": "            AbstractFuture<BarChild> future = new AbstractFuture<BarChild>() {};\n",
        "1652": "    AsyncFunction<String, Integer> function =\n",
        "1653": "        new AsyncFunction<String, Integer>() {\n",
        "1654": "          @Override\n",
        "1655": "          public ListenableFuture<Integer> apply(String input) {\n",
        "1656": "            throw error;\n",
        "1657": "          }\n",
        "1658": "        };\n",
        "1680": "      assertThat(cause)\n",
        "1681": "          .hasMessage(\n",
        "1682": "              \"AsyncFunction.apply returned null instead of a Future. \"\n",
        "1683": "                  + \"Did you mean to return immediateFuture(null)?\");\n",
        "1694": "    AsyncFunction<String, Integer> function =\n",
        "1695": "        new AsyncFunction<String, Integer>() {\n",
        "1696": "          @Override\n",
        "1697": "          public ListenableFuture<Integer> apply(String input) throws Exception {\n",
        "1698": "            inFunction.countDown();\n",
        "1699": "            functionDone.await();\n",
        "1700": "            return resultFuture;\n",
        "1701": "          }\n",
        "1702": "        };\n",
        "1704": "    ListenableFuture<Integer> future =\n",
        "1705": "        transformAsync(inputFuture, function, newSingleThreadExecutor());\n",
        "1727": "    AsyncFunction<String, Integer> function =\n",
        "1728": "        new AsyncFunction<String, Integer>() {\n",
        "1729": "          @Override\n",
        "1730": "          public ListenableFuture<Integer> apply(String input) throws Exception {\n",
        "1731": "            functionCalled.set(true);\n",
        "1732": "            return immediateFuture(1);\n",
        "1733": "          }\n",
        "1734": "        };\n",
        "1737": "    ListenableFuture<Integer> future = transformAsync(inputFuture, function, executor);\n",
        "2041": "  /** Runnable which can be called a single time, and only after {@link #expectCall} is called. */\n",
        "2071": "    ListenableFuture<List<String>> compound = allAsList(future1, future2, future3);\n",
        "2105": "    ListenableFuture<List<String>> compound = allAsList();\n",
        "2116": "    ListenableFuture<List<String>> compound = allAsList(future1, future2);\n",
        "2181": "    ListenableFuture<List<String>> compound = allAsList(future1, future2);\n",
        "2201": "    ListenableFuture<List<String>> compound = allAsList(future1, future2);\n",
        "2211": "  public void testAllAsList_resultCancelledInterrupted_withSecondaryListFuture() throws Exception {\n",
        "2214": "    ListenableFuture<List<String>> compound = allAsList(future1, future2);\n",
        "2217": "    ListenableFuture<List<String>> otherCompound = allAsList(future1, future2);\n",
        "2227": "  public void testAllAsList_resultCancelled_withSecondaryListFuture() throws Exception {\n",
        "2230": "    ListenableFuture<List<String>> compound = allAsList(future1, future2);\n",
        "2245": "    ListenableFuture<List<String>> compound = allAsList(future1, future2);\n",
        "2256": "   * Test the case where the futures are fulfilled prior to constructing the ListFuture. There was a\n",
        "2257": "   * bug where the loop that connects a Listener to each of the futures would die on the last\n",
        "2273": "    ListenableFuture<List<String>> compound = allAsList(future1, future2, future3);\n",
        "2286": "  /** A single non-error failure is not logged because it is reported via the output future. */\n",
        "2299": "  /** Ensure that errors are always logged. */\n",
        "2313": "  /** All as list will log extra exceptions that have already occurred. */\n",
        "2317": "      getDone(\n",
        "2318": "          allAsList(\n",
        "2319": "              immediateFailedFuture(new MyException()), immediateFailedFuture(new MyException())));\n",
        "2329": "  /** All as list will log extra exceptions that occur later. */\n",
        "2352": "  /** The same exception happening on multiple futures should not be logged. */\n",
        "2357": "      getDone(allAsList(immediateFailedFuture(sameInstance), immediateFailedFuture(sameInstance)));\n",
        "2372": "    bulkFuture.addListener(\n",
        "2373": "        new Runnable() {\n",
        "2374": "          @Override\n",
        "2375": "          public void run() {\n",
        "2376": "            /*\n",
        "2377": "             * firstFuture just completed, but AggregateFuture hasn't yet had time to record the\n",
        "2378": "             * exception in seenExceptions. When we complete secondFuture with the same exception,\n",
        "2379": "             * we want for AggregateFuture to still detect that it's been previously seen.\n",
        "2380": "             */\n",
        "2381": "            secondFuture.setException(sameInstance);\n",
        "2382": "          }\n",
        "2383": "        },\n",
        "2384": "        directExecutor());\n",
        "2402": "    bulkFuture.addListener(\n",
        "2403": "        new Runnable() {\n",
        "2404": "          @Override\n",
        "2405": "          public void run() {\n",
        "2406": "            /*\n",
        "2407": "             * This is similar to the above test, but this time we're making sure that we recognize\n",
        "2408": "             * that the output Future is done early not because of an exception but because of a\n",
        "2409": "             * cancellation.\n",
        "2410": "             */\n",
        "2411": "            secondFuture.setException(subsequentFailure);\n",
        "2412": "          }\n",
        "2413": "        },\n",
        "2414": "        directExecutor());\n",
        "2440": "      getDone(allAsList(immediateFailedFuture(exception1), immediateFailedFuture(exception3)));\n",
        "2476": "    Callable<String> combiner =\n",
        "2477": "        new Callable<String>() {\n",
        "2478": "          @Override\n",
        "2479": "          public String call() throws Exception {\n",
        "2480": "            return \"hi\";\n",
        "2481": "          }\n",
        "2482": "        };\n",
        "2500": "    AsyncCallable<String> combiner =\n",
        "2501": "        new AsyncCallable<String>() {\n",
        "2502": "          @Override\n",
        "2503": "          public ListenableFuture<String> call() throws Exception {\n",
        "2504": "            return immediateFuture(\n",
        "2505": "                createCombinedResult(getDone(futureInteger), getDone(futureBoolean)));\n",
        "2506": "          }\n",
        "2507": "        };\n",
        "2515": "    assertEquals(createCombinedResult(integerPartial, booleanPartial), getDone(futureResult));\n",
        "2523": "    AsyncCallable<String> combiner =\n",
        "2524": "        new AsyncCallable<String>() {\n",
        "2525": "          @Override\n",
        "2526": "          public ListenableFuture<String> call() throws Exception {\n",
        "2527": "            assertTrue(futureInteger.isDone());\n",
        "2528": "            assertTrue(futureBoolean.isDone());\n",
        "2529": "            return immediateFailedFuture(thrown);\n",
        "2530": "          }\n",
        "2531": "        };\n",
        "2556": "    AsyncCallable<String> combiner =\n",
        "2557": "        new AsyncCallable<String>() {\n",
        "2558": "          @Override\n",
        "2559": "          public ListenableFuture<String> call() throws Exception {\n",
        "2560": "            inFunction.countDown();\n",
        "2561": "            shouldCompleteFunction.await();\n",
        "2562": "            return resultFuture;\n",
        "2563": "          }\n",
        "2564": "        };\n",
        "2566": "    ListenableFuture<String> futureResult =\n",
        "2567": "        whenAllComplete(stringFuture, booleanFuture).callAsync(combiner, newSingleThreadExecutor());\n",
        "2577": "    } catch (CancellationException expected) {\n",
        "2578": "    }\n",
        "2583": "    } catch (CancellationException expected) {\n",
        "2584": "    }\n",
        "2609": "    ListenableFuture<String> futureResult =\n",
        "2610": "        whenAllComplete(stringFuture, booleanFuture).callAsync(combiner, newSingleThreadExecutor());\n",
        "2619": "    } catch (CancellationException expected) {\n",
        "2620": "    }\n",
        "2759": "  public void testWhenAllSucceed() throws Exception {\n",
        "2760": "    class PartialResultException extends Exception {}\n",
        "2764": "    AsyncCallable<String> combiner =\n",
        "2765": "        new AsyncCallable<String>() {\n",
        "2766": "          @Override\n",
        "2767": "          public ListenableFuture<String> call() throws Exception {\n",
        "2768": "            throw new AssertionFailedError(\"AsyncCallable should not have been called.\");\n",
        "2769": "          }\n",
        "2770": "        };\n",
        "2774": "    PartialResultException partialResultException = new PartialResultException();\n",
        "2803": "    TestFuture(ListenableFuture<String> future, String name, Runnable finisher) {\n",
        "2822": "    final ListenableFuture<String> doneFailed = immediateFailedFuture(new Exception());\n",
        "2831": "          final ListenableFuture<String> delegate = immediateFuture(\"Should never be seen\");\n",
        "2853": "    final SettableFuture<String> delegateForDelayedRuntimeException = SettableFuture.create();\n",
        "2868": "          public String get(long timeout, TimeUnit unit)\n",
        "2869": "              throws ExecutionException, InterruptedException, TimeoutException {\n",
        "2875": "    final Runnable doNothing =\n",
        "2876": "        new Runnable() {\n",
        "2877": "          @Override\n",
        "2878": "          public void run() {}\n",
        "2879": "        };\n",
        "2880": "    final Runnable finishSuccess =\n",
        "2881": "        new Runnable() {\n",
        "2882": "          @Override\n",
        "2883": "          public void run() {\n",
        "2884": "            delayedSuccess.set(\"b\");\n",
        "2885": "          }\n",
        "2886": "        };\n",
        "2887": "    final Runnable finishFailure =\n",
        "2888": "        new Runnable() {\n",
        "2889": "          @Override\n",
        "2890": "          public void run() {\n",
        "2891": "            delayedFailed.setException(new Exception());\n",
        "2892": "          }\n",
        "2893": "        };\n",
        "2894": "    final Runnable finishCancelled =\n",
        "2895": "        new Runnable() {\n",
        "2896": "          @Override\n",
        "2897": "          public void run() {\n",
        "2898": "            delayedCancelled.cancel(true);\n",
        "2899": "          }\n",
        "2900": "        };\n",
        "2901": "    final Runnable finishRuntimeException =\n",
        "2902": "        new Runnable() {\n",
        "2903": "          @Override\n",
        "2904": "          public void run() {\n",
        "2905": "            delegateForDelayedRuntimeException.set(\"Should never be seen\");\n",
        "2906": "          }\n",
        "2907": "        };\n",
        "2909": "    /** All the futures, together with human-readable names for use by {@link #smartToString}. */\n",
        "2911": "        ImmutableList.of(\n",
        "2912": "            new TestFuture(doneSuccess, \"doneSuccess\", doNothing),\n",
        "2915": "            new TestFuture(doneRuntimeException, \"doneRuntimeException\", doNothing),\n",
        "2918": "            new TestFuture(delayedCancelled, \"delayedCancelled\", finishCancelled),\n",
        "2920": "                delayedRuntimeException, \"delayedRuntimeException\", finishRuntimeException));\n",
        "2948": "    void smartAssertTrue(\n",
        "2949": "        ImmutableSet<ListenableFuture<String>> inputs, Exception cause, boolean expression) {\n",
        "2957": "      return intersect(\n",
        "2958": "          inputs,\n",
        "2959": "          ImmutableSet.of(\n",
        "2960": "              delayedSuccess, delayedFailed, delayedCancelled, delayedRuntimeException));\n",
        "2963": "    void assertHasDelayed(ListenableFuture<String> a, ListenableFuture<String> b, Exception e) {\n",
        "2968": "    void assertHasFailure(ListenableFuture<String> a, ListenableFuture<String> b, Exception e) {\n",
        "2970": "      smartAssertTrue(\n",
        "2971": "          inputs,\n",
        "2972": "          e,\n",
        "2973": "          intersect(\n",
        "2974": "              inputs,\n",
        "2975": "              ImmutableSet.of(\n",
        "2976": "                  doneFailed, doneRuntimeException, delayedFailed, delayedRuntimeException)));\n",
        "2979": "    void assertHasCancel(ListenableFuture<String> a, ListenableFuture<String> b, Exception e) {\n",
        "2981": "      smartAssertTrue(\n",
        "2982": "          inputs, e, intersect(inputs, ImmutableSet.of(doneCancelled, delayedCancelled)));\n",
        "2988": "      smartAssertTrue(\n",
        "2989": "          inputs, e, intersect(inputs, ImmutableSet.of(doneFailed, doneRuntimeException)));\n",
        "2995": "      smartAssertTrue(inputs, e, intersect(inputs, ImmutableSet.of(doneCancelled)));\n",
        "3006": "    ListenableFuture<List<String>> merged(ListenableFuture<String> a, ListenableFuture<String> b);\n",
        "3008": "    Merger allMerger =\n",
        "3009": "        new Merger() {\n",
        "3010": "          @Override\n",
        "3011": "          public ListenableFuture<List<String>> merged(\n",
        "3012": "              ListenableFuture<String> a, ListenableFuture<String> b) {\n",
        "3013": "            return allAsList(ImmutableSet.of(a, b));\n",
        "3014": "          }\n",
        "3015": "        };\n",
        "3016": "    Merger successMerger =\n",
        "3017": "        new Merger() {\n",
        "3018": "          @Override\n",
        "3019": "          public ListenableFuture<List<String>> merged(\n",
        "3020": "              ListenableFuture<String> a, ListenableFuture<String> b) {\n",
        "3021": "            return successfulAsList(ImmutableSet.of(a, b));\n",
        "3022": "          }\n",
        "3023": "        };\n",
        "3038": "    Future<V> waiter =\n",
        "3039": "        executor.submit(\n",
        "3040": "            new Callable<V>() {\n",
        "3041": "              @Override\n",
        "3042": "              public V call() throws Exception {\n",
        "3043": "                return input.get();\n",
        "3044": "              }\n",
        "3045": "            });\n",
        "3071": "        for (boolean iBeforeJ : new boolean[] {true, false}) {\n",
        "3075": "          ListenableFuture<List<String>> future = merger.merged(iFuture, jFuture);\n",
        "3080": "            assertTrue(\"Got \" + result, asList(\"a\", null).containsAll(result));\n",
        "3093": "            List<String> result =\n",
        "3094": "                conditionalPseudoTimedGetUninterruptibly(\n",
        "3095": "                    inputs, iFuture, jFuture, future, 20, MILLISECONDS);\n",
        "3096": "            assertTrue(\"Got \" + result, asList(\"a\", null).containsAll(result));\n",
        "3114": "            assertTrue(\"Got \" + result, asList(\"a\", \"b\", null).containsAll(result));\n",
        "3139": "   * <p>[*] To avoid hangs, I've disabled the in-thread calls. This makes the test take (very\n",
        "3140": "   * roughly) 2.5s longer. (2.5s is also the maximum length of time we will wait for a timed get\n",
        "3141": "   * that is expected to succeed; the fact that the numbers match is only a coincidence.) See the\n",
        "3142": "   * comment below for how to restore the fast but hang-y version.\n",
        "3179": "    ListenableFuture<List<String>> compound = successfulAsList(future1, future2, future3);\n",
        "3213": "    ListenableFuture<List<String>> compound = successfulAsList();\n",
        "3224": "    ListenableFuture<List<String>> compound = successfulAsList(future1, future2);\n",
        "3243": "    ListenableFuture<List<String>> compound = successfulAsList(future1, future2);\n",
        "3262": "    ListenableFuture<List<String>> compound = successfulAsList(future1, future2);\n",
        "3280": "    ListenableFuture<List<String>> compound = successfulAsList(future1, future2);\n",
        "3298": "          .that(listenerLoggerHandler.getStoredLogRecords())\n",
        "3299": "          .isEmpty();\n",
        "3307": "    successfulAsList(ImmutableList.of(SettableFuture.create())).cancel(true);\n",
        "3317": "    ListenableFuture<List<String>> compound = successfulAsList(future1, future2);\n",
        "3319": "    future1.addListener(\n",
        "3320": "        new Runnable() {\n",
        "3321": "          @Override\n",
        "3322": "          public void run() {\n",
        "3323": "            assertTrue(future1.isCancelled());\n",
        "3324": "            /*\n",
        "3325": "             * This test relies on behavior that's unspecified but currently\n",
        "3326": "             * guaranteed by the implementation: Cancellation of inputs is\n",
        "3327": "             * performed in the order they were provided to the constructor. Verify\n",
        "3328": "             * that as a sanity check:\n",
        "3329": "             */\n",
        "3330": "            assertFalse(future2.isCancelled());\n",
        "3331": "            // Now attempt to trigger the exception:\n",
        "3332": "            future2.set(DATA2);\n",
        "3333": "          }\n",
        "3334": "        },\n",
        "3335": "        directExecutor());\n",
        "3352": "    ListenableFuture<List<String>> compound = successfulAsList(future1, future2);\n",
        "3368": "    ListenableFuture<List<String>> compound = successfulAsList(future1, future2, future3);\n",
        "3385": "  /** Non-Error exceptions are never logged. */\n",
        "3388": "    assertEquals(\n",
        "3389": "        newArrayList((Object) null),\n",
        "3390": "        getDone(successfulAsList(immediateFailedFuture(new MyException()))));\n",
        "3392": "        .that(aggregateFutureLogHandler.getStoredLogRecords())\n",
        "3393": "        .isEmpty();\n",
        "3396": "    assertEquals(\n",
        "3397": "        newArrayList(null, null, null),\n",
        "3398": "        getDone(\n",
        "3399": "            successfulAsList(\n",
        "3400": "                immediateFailedFuture(new MyException()),\n",
        "3401": "                immediateFailedFuture(new MyException()),\n",
        "3402": "                immediateFailedFuture(new MyException()))));\n",
        "3404": "        .that(aggregateFutureLogHandler.getStoredLogRecords())\n",
        "3405": "        .isEmpty();\n",
        "3408": "  /** Ensure that errors are always logged. */\n",
        "3411": "    assertEquals(\n",
        "3412": "        newArrayList((Object) null),\n",
        "3413": "        getDone(successfulAsList(immediateFailedFuture(new MyError()))));\n",
        "3493": "    CheckedFuture<String, TestException> checked = makeChecked(future, mapper);\n",
        "3533": "    CheckedFuture<String, TestException> checked = makeChecked(future, mapper);\n",
        "3574": "    CheckedFuture<String, TestException> checked = makeChecked(future, mapper);\n",
        "3609": "    CheckedFuture<String, TestException> checked =\n",
        "3610": "        makeChecked(\n",
        "3611": "            future,\n",
        "3612": "            new Function<Exception, TestException>() {\n",
        "3613": "              @Override\n",
        "3614": "              public TestException apply(Exception from) {\n",
        "3615": "                throw new NullPointerException();\n",
        "3616": "              }\n",
        "3617": "            });\n",
        "3639": "    CheckedFuture<String, TestException> checked =\n",
        "3640": "        makeChecked(\n",
        "3641": "            future,\n",
        "3642": "            new Function<Exception, TestException>() {\n",
        "3643": "              @Override\n",
        "3644": "              public TestException apply(Exception from) {\n",
        "3645": "                throw new NullPointerException();\n",
        "3646": "              }\n",
        "3647": "            });\n",
        "3661": "    CheckedFuture<String, TestException> checked =\n",
        "3662": "        makeChecked(\n",
        "3663": "            future,\n",
        "3664": "            new Function<Exception, TestException>() {\n",
        "3665": "              @Override\n",
        "3666": "              public TestException apply(Exception from) {\n",
        "3667": "                throw new NullPointerException();\n",
        "3668": "              }\n",
        "3669": "            });\n",
        "3683": "    CheckedFuture<String, TestException> checked =\n",
        "3684": "        makeChecked(\n",
        "3685": "            future,\n",
        "3686": "            new Function<Exception, TestException>() {\n",
        "3687": "              @Override\n",
        "3688": "              public TestException apply(Exception from) {\n",
        "3689": "                throw new NullPointerException();\n",
        "3690": "              }\n",
        "3691": "            });\n",
        "3710": "    ImmutableList<ListenableFuture<Long>> futures =\n",
        "3711": "        inCompletionOrder(\n",
        "3712": "            ImmutableList.<ListenableFuture<Long>>of(future1, future2, future3, future4, future5));\n",
        "3733": "    ImmutableList<ListenableFuture<Long>> futures =\n",
        "3734": "        inCompletionOrder(\n",
        "3735": "            ImmutableList.<ListenableFuture<Long>>of(future1, future2, future3, future4, future5));\n",
        "3765": "    ImmutableList<ListenableFuture<Long>> futures =\n",
        "3766": "        inCompletionOrder(\n",
        "3767": "            ImmutableList.<ListenableFuture<Long>>of(future1, future2, future3, future4, future5));\n",
        "3794": "    ImmutableList<ListenableFuture<Long>> futures =\n",
        "3795": "        inCompletionOrder(ImmutableList.<ListenableFuture<Long>>of(future1, future2, future3));\n",
        "3812": "    ImmutableList<ListenableFuture<Long>> delegates =\n",
        "3813": "        inCompletionOrder(ImmutableList.<ListenableFuture<Long>>of(future1, future2, future3));\n",
        "3856": "    ImmutableList<ListenableFuture<Long>> delegates =\n",
        "3857": "        inCompletionOrder(ImmutableList.<ListenableFuture<Long>>of(future1, future2));\n"
    },
    "removed": {
        "233": "  private static class MyException extends Exception {\n",
        "234": "  }\n",
        "238": "    CheckedFuture<String, MyException> future = immediateCheckedFuture(\n",
        "239": "        DATA1);\n",
        "240": "    assertThat(future.toString())\n",
        "241": "        .endsWith(\"[status=SUCCESS, result=[\" + DATA1 + \"]]\");\n",
        "250": "    CheckedFuture<String, MyException> future1 = immediateCheckedFuture(\n",
        "251": "        DATA1);\n",
        "252": "    CheckedFuture<String, MyException> future2 = immediateCheckedFuture(\n",
        "253": "        DATA2);\n",
        "265": "    CheckedFuture<String, MyException> future =\n",
        "266": "        immediateFailedCheckedFuture(exception);\n",
        "267": "    assertThat(future.toString())\n",
        "268": "        .endsWith(\"[status=FAILURE, cause=[\" + exception + \"]]\");\n",
        "286": "  private static class Foo {\n",
        "287": "\n",
        "288": "  }\n",
        "289": "\n",
        "290": "  private static class FooChild extends Foo {\n",
        "291": "\n",
        "292": "  }\n",
        "293": "\n",
        "294": "  private static class Bar {\n",
        "296": "  }\n",
        "298": "  private static class BarChild extends Bar {\n",
        "300": "  }\n",
        "311": "    Function<Foo, BarChild> function = new Function<Foo, BarChild>() {\n",
        "312": "      @Override\n",
        "313": "      public BarChild apply(Foo unused) {\n",
        "314": "        return barChild;\n",
        "315": "      }\n",
        "316": "    };\n",
        "436": "    AsyncFunction<Foo, Bar> function = new AsyncFunction<Foo, Bar>() {\n",
        "437": "      @Override\n",
        "438": "      public ListenableFuture<Bar> apply(Foo unused) {\n",
        "439": "        throw new AssertionFailedError(\"Unexpeted call to apply.\");\n",
        "440": "      }\n",
        "441": "    };\n",
        "449": "    AsyncFunction<Foo, Bar> function = new AsyncFunction<Foo, Bar>() {\n",
        "450": "      @Override\n",
        "451": "      public ListenableFuture<Bar> apply(Foo unused) {\n",
        "452": "        throw new AssertionFailedError(\"Unexpeted call to apply.\");\n",
        "453": "      }\n",
        "454": "    };\n",
        "467": "    AsyncFunction<String, String> function = new AsyncFunction<String, String>() {\n",
        "468": "      @Override\n",
        "469": "      public ListenableFuture<String> apply(String s) throws Exception {\n",
        "470": "        inFunction.countDown();\n",
        "471": "        try {\n",
        "472": "          shouldCompleteFunction.await();\n",
        "473": "        } catch (InterruptedException expected) {\n",
        "474": "          gotException.countDown();\n",
        "475": "          throw expected;\n",
        "476": "        }\n",
        "477": "        return immediateFuture(\"a\");\n",
        "478": "      }\n",
        "479": "    };\n",
        "491": "    } catch (CancellationException expected) {}\n",
        "501": "    AsyncFunction<Foo, Bar> function = new AsyncFunction<Foo, Bar>() {\n",
        "502": "      @Override\n",
        "503": "      public ListenableFuture<Bar> apply(Foo unused) {\n",
        "504": "        return secondary;\n",
        "505": "      }\n",
        "506": "    };\n",
        "512": "  public void testTransformAsync_interruptPropagatesToAsyncOutput()\n",
        "513": "      throws Exception {\n",
        "516": "    AsyncFunction<Foo, Bar> function = new AsyncFunction<Foo, Bar>() {\n",
        "517": "      @Override\n",
        "518": "      public ListenableFuture<Bar> apply(Foo unused) {\n",
        "519": "        return secondary;\n",
        "520": "      }\n",
        "521": "    };\n",
        "660": "  public void testTransform_rejectionPropagatesToOutput()\n",
        "661": "      throws Exception {\n",
        "677": "    ListenableFuture<Foo> transformed =\n",
        "678": "        transformAsync(input, asyncIdentity, REJECTING_EXECUTOR);\n",
        "688": "  /**\n",
        "689": "   * Tests that the function is invoked only once, even if it throws an exception.\n",
        "690": "   */\n",
        "699": "    Function<Integer, Integer> adder = new Function<Integer, Integer>() {\n",
        "700": "      @Override\n",
        "701": "      public Integer apply(Integer from) {\n",
        "702": "        return from + holder.value;\n",
        "703": "      }\n",
        "704": "    };\n",
        "738": "  static class MyError extends Error {\n",
        "739": "\n",
        "740": "  }\n",
        "741": "\n",
        "742": "  static class MyRuntimeException extends RuntimeException {\n",
        "744": "  }\n",
        "851": "    ListenableFuture<Object> future = transform(\n",
        "852": "        immediateFuture(value),\n",
        "853": "        identity(), spy);\n",
        "874": "    Function<Integer, String> function = new Function<Integer, String>() {\n",
        "875": "      @Override\n",
        "876": "      public String apply(Integer input) {\n",
        "877": "        throw exception;\n",
        "878": "      }\n",
        "879": "    };\n",
        "978": "    AsyncFunctionSpy<Throwable, Integer> fallback = spy(new AsyncFunction<Throwable, Integer>() {\n",
        "979": "      @Override\n",
        "980": "      public ListenableFuture<Integer> apply(Throwable t) throws Exception {\n",
        "981": "        assertThat(t).isSameAs(raisedException);\n",
        "982": "        return immediateFuture(20);\n",
        "983": "      }\n",
        "984": "    });\n",
        "998": "    Exception expectedException = new Exception() {\n",
        "999": "    };\n",
        "1005": "    AsyncFunction<Throwable, Integer> fallback = new AsyncFunction<Throwable, Integer>() {\n",
        "1006": "      @Override\n",
        "1007": "      public ListenableFuture<Integer> apply(Throwable t) throws Exception {\n",
        "1008": "        throw error;\n",
        "1009": "      }\n",
        "1010": "    };\n",
        "1026": "    Exception expectedException = new Exception() {\n",
        "1027": "    };\n",
        "1033": "    AsyncFunctionSpy<Throwable, Integer> fallback = spy(new AsyncFunction<Throwable, Integer>() {\n",
        "1034": "      @Override\n",
        "1035": "      public ListenableFuture<Integer> apply(Throwable t) throws Exception {\n",
        "1036": "        if (!wrapInFuture) {\n",
        "1037": "          throw expectedException;\n",
        "1038": "        } else {\n",
        "1039": "          return immediateFailedFuture(expectedException);\n",
        "1040": "        }\n",
        "1041": "      }\n",
        "1042": "    });\n",
        "1060": "    AsyncFunction<Throwable, Integer> fallback = new AsyncFunction<Throwable, Integer>() {\n",
        "1061": "      @Override\n",
        "1062": "      public ListenableFuture<Integer> apply(Throwable t) {\n",
        "1063": "        return secondary;\n",
        "1064": "      }\n",
        "1065": "    };\n",
        "1098": "    AsyncFunctionSpy<Throwable, Integer> fallback = spy(new AsyncFunction<Throwable, Integer>() {\n",
        "1099": "      @Override\n",
        "1100": "      public ListenableFuture<Integer> apply(Throwable t) throws Exception {\n",
        "1101": "        assertThat(t).isSameAs(raisedException);\n",
        "1102": "        return secondary;\n",
        "1103": "      }\n",
        "1104": "    });\n",
        "1135": "      assertThat(cause).hasMessage(\"AsyncFunction.apply returned null instead of a Future. \"\n",
        "1136": "          + \"Did you mean to return immediateFuture(null)?\");\n",
        "1147": "    AsyncFunction<Throwable, String> function = new AsyncFunction<Throwable, String>() {\n",
        "1148": "      @Override\n",
        "1149": "      public ListenableFuture<String> apply(Throwable t) throws Exception {\n",
        "1150": "        inFunction.countDown();\n",
        "1151": "        try {\n",
        "1152": "          shouldCompleteFunction.await();\n",
        "1153": "        } catch (InterruptedException expected) {\n",
        "1154": "          gotException.countDown();\n",
        "1155": "          throw expected;\n",
        "1156": "        }\n",
        "1157": "        return immediateFuture(\"a\");\n",
        "1158": "      }\n",
        "1159": "    };\n",
        "1171": "    } catch (CancellationException expected) {}\n",
        "1190": "    FunctionSpy<Throwable, Integer> fallback = spy(new Function<Throwable, Integer>() {\n",
        "1191": "      @Override\n",
        "1192": "      public Integer apply(Throwable t) {\n",
        "1193": "        assertThat(t).isSameAs(raisedException);\n",
        "1194": "        return 20;\n",
        "1195": "      }\n",
        "1196": "    });\n",
        "1216": "    Function<Throwable, Integer> fallback = new Function<Throwable, Integer>() {\n",
        "1217": "      @Override\n",
        "1218": "      public Integer apply(Throwable t) {\n",
        "1219": "        throw error;\n",
        "1220": "      }\n",
        "1221": "    };\n",
        "1238": "    FunctionSpy<Throwable, Integer> fallback = spy(new Function<Throwable, Integer>() {\n",
        "1239": "      @Override\n",
        "1240": "      public Integer apply(Throwable t) {\n",
        "1241": "        throw expectedException;\n",
        "1242": "      }\n",
        "1243": "    });\n",
        "1630": "            AbstractFuture<BarChild> future = new AbstractFuture<BarChild>() {\n",
        "1631": "            };\n",
        "1655": "    AsyncFunction<String, Integer> function = new AsyncFunction<String, Integer>() {\n",
        "1656": "      @Override\n",
        "1657": "      public ListenableFuture<Integer> apply(String input) {\n",
        "1658": "        throw error;\n",
        "1659": "      }\n",
        "1660": "    };\n",
        "1682": "      assertThat(cause).hasMessage(\"AsyncFunction.apply returned null instead of a Future. \"\n",
        "1683": "          + \"Did you mean to return immediateFuture(null)?\");\n",
        "1694": "    AsyncFunction<String, Integer> function = new AsyncFunction<String, Integer>() {\n",
        "1695": "      @Override\n",
        "1696": "      public ListenableFuture<Integer> apply(String input) throws Exception {\n",
        "1697": "        inFunction.countDown();\n",
        "1698": "        functionDone.await();\n",
        "1699": "        return resultFuture;\n",
        "1700": "      }\n",
        "1701": "    };\n",
        "1703": "    ListenableFuture<Integer> future = transformAsync(\n",
        "1704": "        inputFuture, function, newSingleThreadExecutor());\n",
        "1726": "    AsyncFunction<String, Integer> function = new AsyncFunction<String, Integer>() {\n",
        "1727": "      @Override\n",
        "1728": "      public ListenableFuture<Integer> apply(String input) throws Exception {\n",
        "1729": "        functionCalled.set(true);\n",
        "1730": "        return immediateFuture(1);\n",
        "1731": "      }\n",
        "1732": "    };\n",
        "1735": "    ListenableFuture<Integer> future = transformAsync(\n",
        "1736": "        inputFuture, function, executor);\n",
        "2040": "  /**\n",
        "2041": "   * Runnable which can be called a single time, and only after {@link #expectCall} is called.\n",
        "2042": "   */\n",
        "2072": "        ListenableFuture<List<String>> compound =\n",
        "2073": "        allAsList(future1, future2, future3);\n",
        "2107": "        ListenableFuture<List<String>> compound = allAsList();\n",
        "2118": "        ListenableFuture<List<String>> compound =\n",
        "2119": "        allAsList(future1, future2);\n",
        "2184": "        ListenableFuture<List<String>> compound =\n",
        "2185": "        allAsList(future1, future2);\n",
        "2205": "        ListenableFuture<List<String>> compound =\n",
        "2206": "        allAsList(future1, future2);\n",
        "2216": "  public void testAllAsList_resultCancelledInterrupted_withSecondaryListFuture()\n",
        "2217": "      throws Exception {\n",
        "2220": "    ListenableFuture<List<String>> compound =\n",
        "2221": "        allAsList(future1, future2);\n",
        "2224": "    ListenableFuture<List<String>> otherCompound =\n",
        "2225": "        allAsList(future1, future2);\n",
        "2235": "  public void testAllAsList_resultCancelled_withSecondaryListFuture()\n",
        "2236": "      throws Exception {\n",
        "2239": "    ListenableFuture<List<String>> compound =\n",
        "2240": "        allAsList(future1, future2);\n",
        "2255": "        ListenableFuture<List<String>> compound =\n",
        "2256": "        allAsList(future1, future2);\n",
        "2267": "   * Test the case where the futures are fulfilled prior to constructing the ListFuture.  There was\n",
        "2268": "   * a bug where the loop that connects a Listener to each of the futures would die on the last\n",
        "2284": "        ListenableFuture<List<String>> compound =\n",
        "2285": "        allAsList(future1, future2, future3);\n",
        "2298": "  /**\n",
        "2299": "   * A single non-error failure is not logged because it is reported via the output future.\n",
        "2300": "   */\n",
        "2313": "  /**\n",
        "2314": "   * Ensure that errors are always logged.\n",
        "2315": "   */\n",
        "2329": "  /**\n",
        "2330": "   * All as list will log extra exceptions that have already occurred.\n",
        "2331": "   */\n",
        "2335": "      getDone(allAsList(immediateFailedFuture(new MyException()),\n",
        "2336": "          immediateFailedFuture(new MyException())));\n",
        "2346": "  /**\n",
        "2347": "   * All as list will log extra exceptions that occur later.\n",
        "2348": "   */\n",
        "2371": "  /**\n",
        "2372": "   * The same exception happening on multiple futures should not be logged.\n",
        "2373": "   */\n",
        "2378": "      getDone(allAsList(immediateFailedFuture(sameInstance),\n",
        "2379": "          immediateFailedFuture(sameInstance)));\n",
        "2394": "    bulkFuture.addListener(new Runnable() {\n",
        "2395": "      @Override\n",
        "2396": "      public void run() {\n",
        "2397": "        /*\n",
        "2398": "         * firstFuture just completed, but AggregateFuture hasn't yet had time to record the\n",
        "2399": "         * exception in seenExceptions. When we complete secondFuture with the same exception,\n",
        "2400": "         * we want for AggregateFuture to still detect that it's been previously seen.\n",
        "2401": "         */\n",
        "2402": "        secondFuture.setException(sameInstance);\n",
        "2403": "      }\n",
        "2404": "    }, directExecutor());\n",
        "2422": "    bulkFuture.addListener(new Runnable() {\n",
        "2423": "      @Override\n",
        "2424": "      public void run() {\n",
        "2425": "        /*\n",
        "2426": "         * This is similar to the above test, but this time we're making sure that we recognize that\n",
        "2427": "         * the output Future is done early not because of an exception but because of a\n",
        "2428": "         * cancellation.\n",
        "2429": "         */\n",
        "2430": "        secondFuture.setException(subsequentFailure);\n",
        "2431": "      }\n",
        "2432": "    }, directExecutor());\n",
        "2458": "      getDone(allAsList(immediateFailedFuture(exception1),\n",
        "2459": "          immediateFailedFuture(exception3)));\n",
        "2495": "    Callable<String> combiner = new Callable<String>() {\n",
        "2496": "      @Override\n",
        "2497": "      public String call() throws Exception {\n",
        "2498": "        return \"hi\";\n",
        "2499": "      }\n",
        "2500": "    };\n",
        "2518": "    AsyncCallable<String> combiner = new AsyncCallable<String>() {\n",
        "2519": "      @Override\n",
        "2520": "      public ListenableFuture<String> call() throws Exception {\n",
        "2521": "        return immediateFuture(\n",
        "2522": "            createCombinedResult(getDone(futureInteger), getDone(futureBoolean)));\n",
        "2523": "      }\n",
        "2524": "    };\n",
        "2532": "    assertEquals(createCombinedResult(integerPartial, booleanPartial),\n",
        "2533": "        getDone(futureResult));\n",
        "2541": "    AsyncCallable<String> combiner = new AsyncCallable<String>() {\n",
        "2542": "      @Override\n",
        "2543": "      public ListenableFuture<String> call() throws Exception {\n",
        "2544": "        assertTrue(futureInteger.isDone());\n",
        "2545": "        assertTrue(futureBoolean.isDone());\n",
        "2546": "        return immediateFailedFuture(thrown);\n",
        "2547": "      }\n",
        "2548": "    };\n",
        "2573": "    AsyncCallable<String> combiner = new AsyncCallable<String>() {\n",
        "2574": "      @Override\n",
        "2575": "      public ListenableFuture<String> call() throws Exception {\n",
        "2576": "        inFunction.countDown();\n",
        "2577": "        shouldCompleteFunction.await();\n",
        "2578": "        return resultFuture;\n",
        "2579": "      }\n",
        "2580": "    };\n",
        "2582": "    ListenableFuture<String> futureResult = whenAllComplete(stringFuture, booleanFuture)\n",
        "2583": "        .callAsync(combiner, newSingleThreadExecutor());\n",
        "2593": "    } catch (CancellationException expected) {}\n",
        "2598": "    } catch (CancellationException expected) {}\n",
        "2623": "    ListenableFuture<String> futureResult = whenAllComplete(stringFuture, booleanFuture)\n",
        "2624": "        .callAsync(combiner, newSingleThreadExecutor());\n",
        "2633": "    } catch (CancellationException expected) {}\n",
        "2772": "  public void testWhenAllSucceed()  throws Exception {\n",
        "2773": "    class PartialResultException extends Exception {\n",
        "2775": "    }\n",
        "2778": "    AsyncCallable<String> combiner = new AsyncCallable<String>() {\n",
        "2779": "      @Override\n",
        "2780": "      public ListenableFuture<String> call() throws Exception {\n",
        "2781": "        throw new AssertionFailedError(\n",
        "2782": "            \"AsyncCallable should not have been called.\");\n",
        "2783": "      }\n",
        "2784": "    };\n",
        "2788": "    PartialResultException partialResultException =\n",
        "2789": "        new PartialResultException();\n",
        "2818": "    TestFuture(\n",
        "2819": "        ListenableFuture<String> future, String name, Runnable finisher) {\n",
        "2838": "    final ListenableFuture<String> doneFailed =\n",
        "2839": "        immediateFailedFuture(new Exception());\n",
        "2848": "          final ListenableFuture<String> delegate =\n",
        "2849": "              immediateFuture(\"Should never be seen\");\n",
        "2871": "    final SettableFuture<String> delegateForDelayedRuntimeException =\n",
        "2872": "        SettableFuture.create();\n",
        "2887": "          public String get(long timeout, TimeUnit unit) throws\n",
        "2888": "              ExecutionException, InterruptedException, TimeoutException {\n",
        "2894": "    final Runnable doNothing = new Runnable() {\n",
        "2895": "      @Override\n",
        "2896": "      public void run() {\n",
        "2897": "      }\n",
        "2898": "    };\n",
        "2899": "    final Runnable finishSuccess = new Runnable() {\n",
        "2900": "      @Override\n",
        "2901": "      public void run() {\n",
        "2902": "        delayedSuccess.set(\"b\");\n",
        "2903": "      }\n",
        "2904": "    };\n",
        "2905": "    final Runnable finishFailure = new Runnable() {\n",
        "2906": "      @Override\n",
        "2907": "      public void run() {\n",
        "2908": "        delayedFailed.setException(new Exception());\n",
        "2909": "      }\n",
        "2910": "    };\n",
        "2911": "    final Runnable finishCancelled = new Runnable() {\n",
        "2912": "      @Override\n",
        "2913": "      public void run() {\n",
        "2914": "        delayedCancelled.cancel(true);\n",
        "2915": "      }\n",
        "2916": "    };\n",
        "2917": "    final Runnable finishRuntimeException = new Runnable() {\n",
        "2918": "      @Override\n",
        "2919": "      public void run() {\n",
        "2920": "        delegateForDelayedRuntimeException.set(\"Should never be seen\");\n",
        "2921": "      }\n",
        "2922": "    };\n",
        "2924": "    /**\n",
        "2925": "     * All the futures, together with human-readable names for use by {@link #smartToString}.\n",
        "2926": "     */\n",
        "2928": "        ImmutableList.of(new TestFuture(doneSuccess, \"doneSuccess\", doNothing),\n",
        "2931": "            new TestFuture(\n",
        "2932": "                doneRuntimeException, \"doneRuntimeException\", doNothing),\n",
        "2936": "                delayedCancelled, \"delayedCancelled\", finishCancelled),\n",
        "2937": "            new TestFuture(delayedRuntimeException, \"delayedRuntimeException\",\n",
        "2938": "                finishRuntimeException));\n",
        "2966": "    void smartAssertTrue(ImmutableSet<ListenableFuture<String>> inputs,\n",
        "2967": "        Exception cause, boolean expression) {\n",
        "2975": "      return intersect(inputs, ImmutableSet.of(\n",
        "2976": "          delayedSuccess, delayedFailed, delayedCancelled,\n",
        "2977": "          delayedRuntimeException));\n",
        "2980": "    void assertHasDelayed(\n",
        "2981": "        ListenableFuture<String> a, ListenableFuture<String> b, Exception e) {\n",
        "2986": "    void assertHasFailure(\n",
        "2987": "        ListenableFuture<String> a, ListenableFuture<String> b, Exception e) {\n",
        "2989": "      smartAssertTrue(inputs, e, intersect(inputs, ImmutableSet.of(doneFailed,\n",
        "2990": "          doneRuntimeException, delayedFailed, delayedRuntimeException)));\n",
        "2993": "    void assertHasCancel(\n",
        "2994": "        ListenableFuture<String> a, ListenableFuture<String> b, Exception e) {\n",
        "2996": "      smartAssertTrue(inputs, e,\n",
        "2997": "          intersect(inputs, ImmutableSet.of(doneCancelled, delayedCancelled)));\n",
        "3003": "      smartAssertTrue(inputs, e, intersect(\n",
        "3004": "          inputs, ImmutableSet.of(doneFailed, doneRuntimeException)));\n",
        "3010": "      smartAssertTrue(inputs, e,\n",
        "3011": "          intersect(inputs, ImmutableSet.of(doneCancelled)));\n",
        "3022": "    ListenableFuture<List<String>> merged(\n",
        "3023": "        ListenableFuture<String> a, ListenableFuture<String> b);\n",
        "3025": "    Merger allMerger = new Merger() {\n",
        "3026": "      @Override\n",
        "3027": "      public ListenableFuture<List<String>> merged(\n",
        "3028": "          ListenableFuture<String> a, ListenableFuture<String> b) {\n",
        "3029": "        return allAsList(ImmutableSet.of(a, b));\n",
        "3030": "      }\n",
        "3031": "    };\n",
        "3032": "    Merger successMerger = new Merger() {\n",
        "3033": "      @Override\n",
        "3034": "      public ListenableFuture<List<String>> merged(\n",
        "3035": "          ListenableFuture<String> a, ListenableFuture<String> b) {\n",
        "3036": "        return successfulAsList(ImmutableSet.of(a, b));\n",
        "3037": "      }\n",
        "3038": "    };\n",
        "3053": "    Future<V> waiter = executor.submit(new Callable<V>() {\n",
        "3054": "      @Override\n",
        "3055": "      public V call() throws Exception {\n",
        "3056": "        return input.get();\n",
        "3057": "      }\n",
        "3058": "    });\n",
        "3084": "        for (boolean iBeforeJ : new boolean[]{true, false}) {\n",
        "3088": "          ListenableFuture<List<String>> future =\n",
        "3089": "              merger.merged(iFuture, jFuture);\n",
        "3094": "            assertTrue(\"Got \" + result,\n",
        "3095": "                asList(\"a\", null).containsAll(result));\n",
        "3108": "            List<String> result = conditionalPseudoTimedGetUninterruptibly(\n",
        "3109": "                inputs, iFuture, jFuture, future, 20, MILLISECONDS);\n",
        "3110": "            assertTrue(\"Got \" + result,\n",
        "3111": "                asList(\"a\", null).containsAll(result));\n",
        "3129": "            assertTrue(\"Got \" + result,\n",
        "3130": "                asList(\"a\", \"b\", null).containsAll(result));\n",
        "3155": "   * [*] To avoid hangs, I've disabled the in-thread calls. This makes the test take (very roughly)\n",
        "3156": "   * 2.5s longer. (2.5s is also the maximum length of time we will wait for a timed get that is\n",
        "3157": "   * expected to succeed; the fact that the numbers match is only a coincidence.) See the comment\n",
        "3158": "   * below for how to restore the fast but hang-y version.\n",
        "3195": "        ListenableFuture<List<String>> compound =\n",
        "3196": "        successfulAsList(future1, future2, future3);\n",
        "3230": "        ListenableFuture<List<String>> compound = successfulAsList();\n",
        "3241": "        ListenableFuture<List<String>> compound =\n",
        "3242": "        successfulAsList(future1, future2);\n",
        "3261": "        ListenableFuture<List<String>> compound =\n",
        "3262": "        successfulAsList(future1, future2);\n",
        "3281": "        ListenableFuture<List<String>> compound =\n",
        "3282": "        successfulAsList(future1, future2);\n",
        "3300": "        ListenableFuture<List<String>> compound =\n",
        "3301": "        successfulAsList(future1, future2);\n",
        "3319": "          .that(listenerLoggerHandler.getStoredLogRecords()).isEmpty();\n",
        "3327": "    successfulAsList(ImmutableList.of(SettableFuture.create()))\n",
        "3328": "        .cancel(true);\n",
        "3338": "        ListenableFuture<List<String>> compound =\n",
        "3339": "        successfulAsList(future1, future2);\n",
        "3341": "    future1.addListener(new Runnable() {\n",
        "3342": "      @Override\n",
        "3343": "      public void run() {\n",
        "3344": "        assertTrue(future1.isCancelled());\n",
        "3345": "        /*\n",
        "3346": "         * This test relies on behavior that's unspecified but currently\n",
        "3347": "         * guaranteed by the implementation: Cancellation of inputs is\n",
        "3348": "         * performed in the order they were provided to the constructor. Verify\n",
        "3349": "         * that as a sanity check:\n",
        "3350": "         */\n",
        "3351": "        assertFalse(future2.isCancelled());\n",
        "3352": "        // Now attempt to trigger the exception:\n",
        "3353": "        future2.set(DATA2);\n",
        "3354": "      }\n",
        "3355": "    }, directExecutor());\n",
        "3372": "        ListenableFuture<List<String>> compound =\n",
        "3373": "        successfulAsList(future1, future2);\n",
        "3389": "        ListenableFuture<List<String>> compound =\n",
        "3390": "        successfulAsList(future1, future2, future3);\n",
        "3407": "  /**\n",
        "3408": "   * Non-Error exceptions are never logged.\n",
        "3409": "   */\n",
        "3412": "    assertEquals(newArrayList((Object) null),\n",
        "3413": "        getDone(successfulAsList(\n",
        "3414": "            immediateFailedFuture(new MyException()))));\n",
        "3416": "        .that(aggregateFutureLogHandler.getStoredLogRecords()).isEmpty();\n",
        "3419": "    assertEquals(newArrayList(null, null, null),\n",
        "3420": "        getDone(successfulAsList(\n",
        "3421": "            immediateFailedFuture(new MyException()),\n",
        "3422": "            immediateFailedFuture(new MyException()),\n",
        "3423": "            immediateFailedFuture(new MyException()))));\n",
        "3425": "        .that(aggregateFutureLogHandler.getStoredLogRecords()).isEmpty();\n",
        "3428": "  /**\n",
        "3429": "   * Ensure that errors are always logged.\n",
        "3430": "   */\n",
        "3433": "    assertEquals(newArrayList((Object) null),\n",
        "3434": "        getDone(successfulAsList(\n",
        "3435": "            immediateFailedFuture(new MyError()))));\n",
        "3515": "    CheckedFuture<String, TestException> checked = makeChecked(\n",
        "3516": "        future, mapper);\n",
        "3556": "    CheckedFuture<String, TestException> checked = makeChecked(\n",
        "3557": "        future, mapper);\n",
        "3598": "    CheckedFuture<String, TestException> checked = makeChecked(\n",
        "3599": "        future, mapper);\n",
        "3634": "    CheckedFuture<String, TestException> checked = makeChecked(\n",
        "3635": "        future, new Function<Exception, TestException>() {\n",
        "3636": "          @Override\n",
        "3637": "          public TestException apply(Exception from) {\n",
        "3638": "            throw new NullPointerException();\n",
        "3639": "          }\n",
        "3640": "        });\n",
        "3662": "    CheckedFuture<String, TestException> checked = makeChecked(\n",
        "3663": "        future, new Function<Exception, TestException>() {\n",
        "3664": "          @Override\n",
        "3665": "          public TestException apply(Exception from) {\n",
        "3666": "            throw new NullPointerException();\n",
        "3667": "          }\n",
        "3668": "        });\n",
        "3682": "    CheckedFuture<String, TestException> checked = makeChecked(\n",
        "3683": "        future, new Function<Exception, TestException>() {\n",
        "3684": "          @Override\n",
        "3685": "          public TestException apply(Exception from) {\n",
        "3686": "            throw new NullPointerException();\n",
        "3687": "          }\n",
        "3688": "        });\n",
        "3702": "    CheckedFuture<String, TestException> checked = makeChecked(\n",
        "3703": "        future, new Function<Exception, TestException>() {\n",
        "3704": "          @Override\n",
        "3705": "          public TestException apply(Exception from) {\n",
        "3706": "            throw new NullPointerException();\n",
        "3707": "          }\n",
        "3708": "        });\n",
        "3727": "    ImmutableList<ListenableFuture<Long>> futures = inCompletionOrder(\n",
        "3728": "        ImmutableList.<ListenableFuture<Long>>of(future1, future2, future3, future4, future5));\n",
        "3749": "    ImmutableList<ListenableFuture<Long>> futures = inCompletionOrder(\n",
        "3750": "        ImmutableList.<ListenableFuture<Long>>of(future1, future2, future3, future4, future5));\n",
        "3780": "    ImmutableList<ListenableFuture<Long>> futures = inCompletionOrder(\n",
        "3781": "        ImmutableList.<ListenableFuture<Long>>of(future1, future2, future3, future4, future5));\n",
        "3808": "    ImmutableList<ListenableFuture<Long>> futures = inCompletionOrder(\n",
        "3809": "        ImmutableList.<ListenableFuture<Long>>of(future1, future2, future3));\n",
        "3826": "    ImmutableList<ListenableFuture<Long>> delegates = inCompletionOrder(\n",
        "3827": "        ImmutableList.<ListenableFuture<Long>>of(future1, future2, future3));\n",
        "3870": "    ImmutableList<ListenableFuture<Long>> delegates = inCompletionOrder(\n",
        "3871": "        ImmutableList.<ListenableFuture<Long>>of(future1, future2));\n"
    }
}