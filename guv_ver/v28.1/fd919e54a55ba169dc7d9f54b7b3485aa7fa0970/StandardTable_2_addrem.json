{
    "addition": {
        "48": " * {@link Table} implementation backed by a map that associates row keys with column key / value\n",
        "49": " * secondary maps. This class provides rapid access to records by the row key alone or by both keys,\n",
        "50": " * but not by just the column key.\n",
        "52": " * <p>The views returned by {@link #column}, {@link #columnKeySet()}, and {@link #columnMap()} have\n",
        "53": " * iterators that don't support {@code remove()}. Otherwise, all optional operations are supported.\n",
        "54": " * Null row keys, columns keys, and values are not supported.\n",
        "56": " * <p>Lookups by row key are often faster than lookups by column key, because the data is stored in\n",
        "57": " * a {@code Map<R, Map<C, V>>}. A method call like {@code column(columnKey).get(rowKey)} still runs\n",
        "58": " * quickly, since the row key is provided. However, {@code column(columnKey).size()} takes longer,\n",
        "59": " * since an iteration across all row keys occurs.\n",
        "61": " * <p>Note that this implementation is not synchronized. If multiple threads access this table\n",
        "62": " * concurrently and one of the threads modifies the table, it must be synchronized externally.\n",
        "200": "   * Abstract set whose {@code isEmpty()} returns whether the table is empty and whose {@code\n",
        "201": "   * clear()} clears all table mappings.\n",
        "219": "   * <p>The set's iterator traverses the mappings for the first row, the mappings for the second\n",
        "220": "   * row, and so on.\n",
        "222": "   * <p>Each cell is an immutable snapshot of a row key / column key / value mapping, taken at the\n",
        "223": "   * time the cell is returned by a method call to the set or its iterator.\n",
        "417": "   * <p>The returned map's views have iterators that don't support {@code remove()}.\n",
        "451": "    /** Removes all {@code Column} mappings whose row key and value satisfy the given predicate. */\n",
        "627": "   * <p>The set's iterator traverses the columns of the first row, the columns of the second row,\n",
        "628": "   * etc., skipping any columns that have appeared previously.\n",
        "709": "  /** Creates an iterator that returns each column value with duplicates omitted. */\n",
        "742": "   * <p>The collection's iterator traverses the values for the first row, the values for the second\n",
        "743": "   * row, and so on.\n"
    },
    "removed": {
        "48": " * {@link Table} implementation backed by a map that associates row keys with\n",
        "49": " * column key / value secondary maps. This class provides rapid access to\n",
        "50": " * records by the row key alone or by both keys, but not by just the column key.\n",
        "52": " * <p>The views returned by {@link #column}, {@link #columnKeySet()}, and {@link\n",
        "53": " * #columnMap()} have iterators that don't support {@code remove()}. Otherwise,\n",
        "54": " * all optional operations are supported. Null row keys, columns keys, and\n",
        "55": " * values are not supported.\n",
        "57": " * <p>Lookups by row key are often faster than lookups by column key, because\n",
        "58": " * the data is stored in a {@code Map<R, Map<C, V>>}. A method call like {@code\n",
        "59": " * column(columnKey).get(rowKey)} still runs quickly, since the row key is\n",
        "60": " * provided. However, {@code column(columnKey).size()} takes longer, since an\n",
        "61": " * iteration across all row keys occurs.\n",
        "63": " * <p>Note that this implementation is not synchronized. If multiple threads\n",
        "64": " * access this table concurrently and one of the threads modifies the table, it\n",
        "65": " * must be synchronized externally.\n",
        "203": "   * Abstract set whose {@code isEmpty()} returns whether the table is empty and\n",
        "204": "   * whose {@code clear()} clears all table mappings.\n",
        "222": "   * <p>The set's iterator traverses the mappings for the first row, the\n",
        "223": "   * mappings for the second row, and so on.\n",
        "225": "   * <p>Each cell is an immutable snapshot of a row key / column key / value\n",
        "226": "   * mapping, taken at the time the cell is returned by a method call to the\n",
        "227": "   * set or its iterator.\n",
        "421": "   * <p>The returned map's views have iterators that don't support\n",
        "422": "   * {@code remove()}.\n",
        "456": "    /**\n",
        "457": "     * Removes all {@code Column} mappings whose row key and value satisfy the\n",
        "458": "     * given predicate.\n",
        "459": "     */\n",
        "635": "   * <p>The set's iterator traverses the columns of the first row, the\n",
        "636": "   * columns of the second row, etc., skipping any columns that have\n",
        "637": "   * appeared previously.\n",
        "718": "  /**\n",
        "719": "   * Creates an iterator that returns each column value with duplicates\n",
        "720": "   * omitted.\n",
        "721": "   */\n",
        "754": "   * <p>The collection's iterator traverses the values for the first row,\n",
        "755": "   * the values for the second row, and so on.\n"
    }
}