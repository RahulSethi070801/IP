{
    "addition": {
        "51": "      suite.addTest(\n",
        "52": "          CharSourceTester.tests(\n",
        "53": "              \"CharSource.wrap[CharSequence]\",\n",
        "54": "              SourceSinkFactories.stringCharSourceFactory(),\n",
        "55": "              asByteSource));\n",
        "56": "      suite.addTest(\n",
        "57": "          CharSourceTester.tests(\n",
        "58": "              \"CharSource.empty[]\", SourceSinkFactories.emptyCharSourceFactory(), asByteSource));\n",
        "149": "    List<String> list =\n",
        "150": "        lines.readLines(\n",
        "151": "            new LineProcessor<List<String>>() {\n",
        "152": "              List<String> list = Lists.newArrayList();\n",
        "153": "\n",
        "154": "              @Override\n",
        "155": "              public boolean processLine(String line) throws IOException {\n",
        "156": "                list.add(line);\n",
        "157": "                return true;\n",
        "158": "              }\n",
        "159": "\n",
        "160": "              @Override\n",
        "161": "              public List<String> getResult() {\n",
        "162": "                return list;\n",
        "163": "              }\n",
        "164": "            });\n",
        "171": "    List<String> list =\n",
        "172": "        lines.readLines(\n",
        "173": "            new LineProcessor<List<String>>() {\n",
        "174": "              List<String> list = Lists.newArrayList();\n",
        "175": "\n",
        "176": "              @Override\n",
        "177": "              public boolean processLine(String line) throws IOException {\n",
        "178": "                list.add(line);\n",
        "179": "                return false;\n",
        "180": "              }\n",
        "181": "\n",
        "182": "              @Override\n",
        "183": "              public List<String> getResult() {\n",
        "184": "                return list;\n",
        "185": "              }\n",
        "186": "            });\n",
        "219": "      assertTrue(\n",
        "220": "          \"stream not closed when copying to sink with option: \" + option,\n",
        "252": "    assertEquals(expected, CharSource.concat(ImmutableList.of(c1, c2, c3)).read());\n",
        "253": "    assertEquals(expected, CharSource.concat(c1, c2, c3).read());\n",
        "254": "    assertEquals(expected, CharSource.concat(ImmutableList.of(c1, c2, c3).iterator()).read());\n",
        "285": "  private static final ImmutableSet<CharSource> BROKEN_SOURCES =\n",
        "286": "      ImmutableSet.of(BROKEN_CLOSE_SOURCE, BROKEN_OPEN_SOURCE, BROKEN_READ_SOURCE);\n",
        "287": "  private static final ImmutableSet<CharSink> BROKEN_SINKS =\n",
        "288": "      ImmutableSet.of(BROKEN_CLOSE_SINK, BROKEN_OPEN_SINK, BROKEN_WRITE_SINK);\n",
        "364": "  /** @return the number of exceptions that were suppressed on the expected thrown exception */\n",
        "381": "      @Override\n",
        "382": "      public Writer openStream() {\n"
    },
    "removed": {
        "51": "      suite.addTest(CharSourceTester.tests(\"CharSource.wrap[CharSequence]\",\n",
        "52": "          SourceSinkFactories.stringCharSourceFactory(), asByteSource));\n",
        "53": "      suite.addTest(CharSourceTester.tests(\"CharSource.empty[]\",\n",
        "54": "          SourceSinkFactories.emptyCharSourceFactory(), asByteSource));\n",
        "145": "    List<String> list = lines.readLines(new LineProcessor<List<String>>() {\n",
        "146": "      List<String> list = Lists.newArrayList();\n",
        "147": "\n",
        "148": "      @Override\n",
        "149": "      public boolean processLine(String line) throws IOException {\n",
        "150": "        list.add(line);\n",
        "151": "        return true;\n",
        "152": "      }\n",
        "153": "\n",
        "154": "      @Override\n",
        "155": "      public List<String> getResult() {\n",
        "156": "        return list;\n",
        "157": "      }\n",
        "158": "    });\n",
        "165": "    List<String> list = lines.readLines(new LineProcessor<List<String>>() {\n",
        "166": "      List<String> list = Lists.newArrayList();\n",
        "167": "\n",
        "168": "      @Override\n",
        "169": "      public boolean processLine(String line) throws IOException {\n",
        "170": "        list.add(line);\n",
        "171": "        return false;\n",
        "172": "      }\n",
        "173": "\n",
        "174": "      @Override\n",
        "175": "      public List<String> getResult() {\n",
        "176": "        return list;\n",
        "177": "      }\n",
        "178": "    });\n",
        "211": "      assertTrue(\"stream not closed when copying to sink with option: \" + option,\n",
        "243": "    assertEquals(expected,\n",
        "244": "        CharSource.concat(ImmutableList.of(c1, c2, c3)).read());\n",
        "245": "    assertEquals(expected,\n",
        "246": "        CharSource.concat(c1, c2, c3).read());\n",
        "247": "    assertEquals(expected,\n",
        "248": "        CharSource.concat(ImmutableList.of(c1, c2, c3).iterator()).read());\n",
        "279": "  private static final ImmutableSet<CharSource> BROKEN_SOURCES\n",
        "280": "      = ImmutableSet.of(BROKEN_CLOSE_SOURCE, BROKEN_OPEN_SOURCE, BROKEN_READ_SOURCE);\n",
        "281": "  private static final ImmutableSet<CharSink> BROKEN_SINKS\n",
        "282": "      = ImmutableSet.of(BROKEN_CLOSE_SINK, BROKEN_OPEN_SINK, BROKEN_WRITE_SINK);\n",
        "358": "  /**\n",
        "359": "   * @return the number of exceptions that were suppressed on the expected thrown exception\n",
        "360": "   */\n",
        "377": "      @Override public Writer openStream() {\n"
    }
}