{
    "addition": {
        "30": "/** Utilities for the AbstractFutureBenchmarks */\n",
        "56": "  private static class OldAbstractFutureFacade<T> extends OldAbstractFuture<T>\n",
        "57": "      implements Facade<T> {\n",
        "73": "      @Override\n",
        "74": "      <T> Facade<T> newFacade() {\n",
        "79": "      @Override\n",
        "80": "      <T> Facade<T> newFacade() {\n",
        "112": "    /** Constructor for use by subclasses. */\n",
        "122": "     * <p>The default {@link AbstractFuture} implementation throws {@code InterruptedException} if\n",
        "123": "     * the current thread is interrupted before or during the call, even if the value is already\n",
        "124": "     * available.\n",
        "126": "     * @throws InterruptedException if the current thread was interrupted before or during the call\n",
        "127": "     *     (optional but recommended).\n",
        "144": "     * <p>The default {@link AbstractFuture} implementation throws {@code InterruptedException} if\n",
        "145": "     * the current thread is interrupted before or during the call, even if the value is already\n",
        "146": "     * available.\n",
        "148": "     * @throws InterruptedException if the current thread was interrupted before or during the call\n",
        "149": "     *     (optional but recommended).\n",
        "182": "     * Subclasses can override this method to implement interruption of the future's computation.\n",
        "183": "     * The method is invoked automatically by a successful call to {@link #cancel(boolean)\n",
        "184": "     * cancel(true)}.\n",
        "190": "    protected void interruptTask() {}\n",
        "193": "     * Returns true if this future was cancelled with {@code mayInterruptIfRunning} set to {@code\n",
        "194": "     * true}.\n",
        "213": "     * Subclasses should invoke this method to set the result of the computation to {@code value}.\n",
        "214": "     * This will set the state of the future to {@link OldAbstractFuture.Sync#COMPLETED} and invoke\n",
        "215": "     * the listeners if the state was successfully changed.\n",
        "230": "     * Subclasses should invoke this method to set the result of the computation to an error, {@code\n",
        "231": "     * throwable}. This will set the state of the future to {@link OldAbstractFuture.Sync#COMPLETED}\n",
        "232": "     * and invoke the listeners if the state was successfully changed.\n",
        "247": "     * Following the contract of {@link AbstractQueuedSynchronizer} we create a private subclass to\n",
        "248": "     * hold the synchronizer. This synchronizer is used to implement the blocking and waiting calls\n",
        "249": "     * as well as to handle state changes in a thread-safe manner. The current state of the future\n",
        "250": "     * is held in the Sync state, and the lock is released whenever the state changes to {@link\n",
        "251": "     * #COMPLETED}, {@link #CANCELLED}, or {@link #INTERRUPTED}\n",
        "253": "     * <p>To avoid races between threads doing release and acquire, we transition to the final state\n",
        "254": "     * in two steps. One thread will successfully CAS from RUNNING to COMPLETING, that thread will\n",
        "255": "     * then set the result of the computation, and only then transition to COMPLETED, CANCELLED, or\n",
        "258": "     * <p>We don't use the integer argument passed between acquire methods so we pass around a -1\n",
        "259": "     * everywhere.\n",
        "297": "       * Blocks until the task is complete or the timeout expires. Throws a {@link TimeoutException}\n",
        "298": "       * if the timer expires, otherwise behaves like {@link #get()}.\n",
        "300": "      V get(long nanos)\n",
        "301": "          throws TimeoutException, CancellationException, ExecutionException, InterruptedException {\n",
        "312": "       * Blocks until {@link #complete(Object, Throwable, int)} has been successfully called. Throws\n",
        "313": "       * a {@link CancellationException} if the task was cancelled, or a {@link ExecutionException}\n",
        "314": "       * if the task completed with an error.\n",
        "316": "      V get() throws CancellationException, ExecutionException, InterruptedException {\n",
        "324": "       * Implementation of the actual value retrieval. Will return the value on success, an\n",
        "325": "       * exception on failure, a cancellation on cancellation, or an illegal state if the\n",
        "326": "       * synchronizer is in an invalid state.\n",
        "340": "            throw cancellationExceptionWithCause(\"Task was cancelled.\", exception);\n",
        "343": "            throw new IllegalStateException(\"Error, synchronizer in invalid state: \" + state);\n",
        "347": "      /** Checks if the state is {@link #COMPLETED}, {@link #CANCELLED}, or {@link #INTERRUPTED}. */\n",
        "352": "      /** Checks if the state is {@link #CANCELLED} or {@link #INTERRUPTED}. */\n",
        "357": "      /** Checks if the state is {@link #INTERRUPTED}. */\n",
        "362": "      /** Transition to the COMPLETED state and set the value. */\n",
        "367": "      /** Transition to the COMPLETED state and set the exception. */\n",
        "372": "      /** Transition to the CANCELLED or INTERRUPTED state. */\n",
        "378": "       * Implementation of completing a task. Either {@code v} or {@code t} will be set but not\n",
        "379": "       * both. The {@code finalState} is the state to change to from {@link #RUNNING}. If the state\n",
        "380": "       * is not in the RUNNING state we return {@code false} after waiting for the state to be set\n",
        "381": "       * to a valid final state ({@link #COMPLETED}, {@link #CANCELLED}, or {@link #INTERRUPTED}).\n",
        "387": "      private boolean complete(@Nullable V v, @Nullable Throwable t, int finalState) {\n",
        "394": "          this.exception =\n",
        "395": "              ((finalState & (CANCELLED | INTERRUPTED)) != 0)\n",
        "396": "                  ? new CancellationException(\"Future.cancel() was called.\")\n",
        "397": "                  : t;\n"
    },
    "removed": {
        "30": "/**\n",
        "31": " * Utilities for the AbstractFutureBenchmarks\n",
        "32": " */\n",
        "58": "  private static class OldAbstractFutureFacade<T>\n",
        "59": "      extends OldAbstractFuture<T> implements Facade<T> {\n",
        "75": "      @Override <T> Facade<T> newFacade() {\n",
        "80": "      @Override <T> Facade<T> newFacade() {\n",
        "112": "    /**\n",
        "113": "     * Constructor for use by subclasses.\n",
        "114": "     */\n",
        "124": "     * <p>The default {@link AbstractFuture} implementation throws {@code\n",
        "125": "     * InterruptedException} if the current thread is interrupted before or during\n",
        "126": "     * the call, even if the value is already available.\n",
        "128": "     * @throws InterruptedException if the current thread was interrupted before\n",
        "129": "     *     or during the call (optional but recommended).\n",
        "146": "     * <p>The default {@link AbstractFuture} implementation throws {@code\n",
        "147": "     * InterruptedException} if the current thread is interrupted before or during\n",
        "148": "     * the call, even if the value is already available.\n",
        "150": "     * @throws InterruptedException if the current thread was interrupted before\n",
        "151": "     *     or during the call (optional but recommended).\n",
        "184": "     * Subclasses can override this method to implement interruption of the\n",
        "185": "     * future's computation. The method is invoked automatically by a successful\n",
        "186": "     * call to {@link #cancel(boolean) cancel(true)}.\n",
        "192": "    protected void interruptTask() {\n",
        "193": "    }\n",
        "196": "     * Returns true if this future was cancelled with {@code\n",
        "197": "     * mayInterruptIfRunning} set to {@code true}.\n",
        "216": "     * Subclasses should invoke this method to set the result of the computation\n",
        "217": "     * to {@code value}.  This will set the state of the future to\n",
        "218": "     * {@link OldAbstractFuture.Sync#COMPLETED} and invoke the listeners if the\n",
        "219": "     * state was successfully changed.\n",
        "234": "     * Subclasses should invoke this method to set the result of the computation\n",
        "235": "     * to an error, {@code throwable}.  This will set the state of the future to\n",
        "236": "     * {@link OldAbstractFuture.Sync#COMPLETED} and invoke the listeners if the\n",
        "237": "     * state was successfully changed.\n",
        "252": "     * <p>Following the contract of {@link AbstractQueuedSynchronizer} we create a\n",
        "253": "     * private subclass to hold the synchronizer.  This synchronizer is used to\n",
        "254": "     * implement the blocking and waiting calls as well as to handle state changes\n",
        "255": "     * in a thread-safe manner.  The current state of the future is held in the\n",
        "256": "     * Sync state, and the lock is released whenever the state changes to\n",
        "257": "     * {@link #COMPLETED}, {@link #CANCELLED}, or {@link #INTERRUPTED}\n",
        "259": "     * <p>To avoid races between threads doing release and acquire, we transition\n",
        "260": "     * to the final state in two steps.  One thread will successfully CAS from\n",
        "261": "     * RUNNING to COMPLETING, that thread will then set the result of the\n",
        "262": "     * computation, and only then transition to COMPLETED, CANCELLED, or\n",
        "265": "     * <p>We don't use the integer argument passed between acquire methods so we\n",
        "266": "     * pass around a -1 everywhere.\n",
        "304": "       * Blocks until the task is complete or the timeout expires.  Throws a\n",
        "305": "       * {@link TimeoutException} if the timer expires, otherwise behaves like\n",
        "306": "       * {@link #get()}.\n",
        "308": "      V get(long nanos) throws TimeoutException, CancellationException,\n",
        "309": "          ExecutionException, InterruptedException {\n",
        "320": "       * Blocks until {@link #complete(Object, Throwable, int)} has been\n",
        "321": "       * successfully called.  Throws a {@link CancellationException} if the task\n",
        "322": "       * was cancelled, or a {@link ExecutionException} if the task completed with\n",
        "323": "       * an error.\n",
        "325": "      V get() throws CancellationException, ExecutionException,\n",
        "326": "          InterruptedException {\n",
        "334": "       * Implementation of the actual value retrieval.  Will return the value\n",
        "335": "       * on success, an exception on failure, a cancellation on cancellation, or\n",
        "336": "       * an illegal state if the synchronizer is in an invalid state.\n",
        "350": "            throw cancellationExceptionWithCause(\n",
        "351": "                \"Task was cancelled.\", exception);\n",
        "354": "            throw new IllegalStateException(\n",
        "355": "                \"Error, synchronizer in invalid state: \" + state);\n",
        "359": "      /**\n",
        "360": "       * Checks if the state is {@link #COMPLETED}, {@link #CANCELLED}, or {@link #INTERRUPTED}.\n",
        "361": "       */\n",
        "366": "      /**\n",
        "367": "       * Checks if the state is {@link #CANCELLED} or {@link #INTERRUPTED}.\n",
        "368": "       */\n",
        "373": "      /**\n",
        "374": "       * Checks if the state is {@link #INTERRUPTED}.\n",
        "375": "       */\n",
        "380": "      /**\n",
        "381": "       * Transition to the COMPLETED state and set the value.\n",
        "382": "       */\n",
        "387": "      /**\n",
        "388": "       * Transition to the COMPLETED state and set the exception.\n",
        "389": "       */\n",
        "394": "      /**\n",
        "395": "       * Transition to the CANCELLED or INTERRUPTED state.\n",
        "396": "       */\n",
        "402": "       * Implementation of completing a task.  Either {@code v} or {@code t} will\n",
        "403": "       * be set but not both.  The {@code finalState} is the state to change to\n",
        "404": "       * from {@link #RUNNING}.  If the state is not in the RUNNING state we\n",
        "405": "       * return {@code false} after waiting for the state to be set to a valid\n",
        "406": "       * final state ({@link #COMPLETED}, {@link #CANCELLED}, or {@link\n",
        "407": "       * #INTERRUPTED}).\n",
        "413": "      private boolean complete(@Nullable V v, @Nullable Throwable t,\n",
        "414": "          int finalState) {\n",
        "421": "          this.exception = ((finalState & (CANCELLED | INTERRUPTED)) != 0)\n",
        "422": "              ? new CancellationException(\"Future.cancel() was called.\") : t;\n"
    }
}