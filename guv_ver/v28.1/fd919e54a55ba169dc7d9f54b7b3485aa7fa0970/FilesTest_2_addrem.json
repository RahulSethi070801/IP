{
    "addition": {
        "58": "    suite.addTest(\n",
        "59": "        ByteSourceTester.tests(\n",
        "60": "            \"Files.asByteSource[File]\", SourceSinkFactories.fileByteSourceFactory(), true));\n",
        "61": "    suite.addTest(\n",
        "62": "        ByteSinkTester.tests(\"Files.asByteSink[File]\", SourceSinkFactories.fileByteSinkFactory()));\n",
        "63": "    suite.addTest(\n",
        "64": "        ByteSinkTester.tests(\n",
        "65": "            \"Files.asByteSink[File, APPEND]\", SourceSinkFactories.appendingFileByteSinkFactory()));\n",
        "66": "    suite.addTest(\n",
        "67": "        CharSourceTester.tests(\n",
        "68": "            \"Files.asCharSource[File, Charset]\",\n",
        "69": "            SourceSinkFactories.fileCharSourceFactory(),\n",
        "70": "            false));\n",
        "71": "    suite.addTest(\n",
        "72": "        CharSinkTester.tests(\n",
        "73": "            \"Files.asCharSink[File, Charset]\", SourceSinkFactories.fileCharSinkFactory()));\n",
        "74": "    suite.addTest(\n",
        "75": "        CharSinkTester.tests(\n",
        "76": "            \"Files.asCharSink[File, Charset, APPEND]\",\n",
        "77": "            SourceSinkFactories.appendingFileCharSinkFactory()));\n",
        "85": "    assertSame(byteSource, byteSource.asCharSource(Charsets.UTF_8).asByteSource(Charsets.UTF_8));\n",
        "91": "    assertTrue(Arrays.equals(ASCII.getBytes(Charsets.US_ASCII), Files.toByteArray(asciiFile)));\n",
        "92": "    assertTrue(Arrays.equals(I18N.getBytes(Charsets.UTF_8), Files.toByteArray(i18nFile)));\n",
        "93": "    assertTrue(Arrays.equals(I18N.getBytes(Charsets.UTF_8), Files.asByteSource(i18nFile).read()));\n",
        "156": "  /** A {@link File} that provides a specialized value for {@link File#length()}. */\n",
        "179": "    assertThat(Files.toString(i18nFile, Charsets.US_ASCII)).isNotEqualTo(I18N);\n",
        "285": "    assertTrue(Files.asByteSource(asciiFile).contentEquals(Files.asByteSource(asciiFile)));\n",
        "349": "      Files.touch(\n",
        "350": "          new File(temp.getPath()) {\n",
        "351": "            @Override\n",
        "352": "            public boolean setLastModified(long t) {\n",
        "353": "              return false;\n",
        "354": "            }\n",
        "355": "\n",
        "356": "            private static final long serialVersionUID = 0;\n",
        "357": "          });\n",
        "457": "    moveHelper(\n",
        "458": "        false, new UnmovableFile(temp1, false, false), new UnmovableFile(temp2, true, false));\n",
        "468": "  private void moveHelper(boolean success, File from, File to) throws IOException {\n",
        "521": "    assertEquals(\n",
        "522": "        ImmutableList.of(\"hello\", \"\", \" world  \", \"\"), Files.readLines(temp, Charsets.UTF_8));\n",
        "553": "    assertThat(collect.getResult()).containsExactly(\"hello\", \"\", \" world  \", \"\").inOrder();\n",
        "573": "    assertThat(collectNonEmptyLines.getResult()).containsExactly(\"hello\", \" world  \").inOrder();\n",
        "716": "    ByteProcessor<byte[]> processor =\n",
        "717": "        new ByteProcessor<byte[]>() {\n",
        "718": "          private final ByteArrayOutputStream out = new ByteArrayOutputStream();\n",
        "720": "          @Override\n",
        "721": "          public boolean processBytes(byte[] buffer, int offset, int length) throws IOException {\n",
        "722": "            if (length >= 0) {\n",
        "723": "              out.write(buffer, offset, length);\n",
        "724": "            }\n",
        "725": "            return true;\n",
        "726": "          }\n",
        "727": "\n",
        "728": "          @Override\n",
        "729": "          public byte[] getResult() {\n",
        "730": "            return out.toByteArray();\n",
        "731": "          }\n",
        "732": "        };\n",
        "740": "    ByteProcessor<byte[]> processor =\n",
        "741": "        new ByteProcessor<byte[]>() {\n",
        "742": "          private final ByteArrayOutputStream out = new ByteArrayOutputStream();\n",
        "744": "          @Override\n",
        "745": "          public boolean processBytes(byte[] buffer, int offset, int length) throws IOException {\n",
        "746": "            if (length > 0) {\n",
        "747": "              out.write(buffer, offset, 1);\n",
        "748": "              return false;\n",
        "749": "            } else {\n",
        "750": "              return true;\n",
        "751": "            }\n",
        "752": "          }\n",
        "753": "\n",
        "754": "          @Override\n",
        "755": "          public byte[] getResult() {\n",
        "756": "            return out.toByteArray();\n",
        "757": "          }\n",
        "758": "        };\n",
        "775": "  /** Returns a root path for the file system. */\n",
        "780": "  /** Returns a {@code File} object for the given path parts. */\n",
        "785": "  /** Returns a {@code File} object for the given path parts. */\n"
    },
    "removed": {
        "58": "    suite.addTest(ByteSourceTester.tests(\"Files.asByteSource[File]\",\n",
        "59": "        SourceSinkFactories.fileByteSourceFactory(), true));\n",
        "60": "    suite.addTest(ByteSinkTester.tests(\"Files.asByteSink[File]\",\n",
        "61": "        SourceSinkFactories.fileByteSinkFactory()));\n",
        "62": "    suite.addTest(ByteSinkTester.tests(\"Files.asByteSink[File, APPEND]\",\n",
        "63": "        SourceSinkFactories.appendingFileByteSinkFactory()));\n",
        "64": "    suite.addTest(CharSourceTester.tests(\"Files.asCharSource[File, Charset]\",\n",
        "65": "        SourceSinkFactories.fileCharSourceFactory(), false));\n",
        "66": "    suite.addTest(CharSinkTester.tests(\"Files.asCharSink[File, Charset]\",\n",
        "67": "        SourceSinkFactories.fileCharSinkFactory()));\n",
        "68": "    suite.addTest(CharSinkTester.tests(\"Files.asCharSink[File, Charset, APPEND]\",\n",
        "69": "        SourceSinkFactories.appendingFileCharSinkFactory()));\n",
        "77": "    assertSame(byteSource,\n",
        "78": "        byteSource.asCharSource(Charsets.UTF_8).asByteSource(Charsets.UTF_8));\n",
        "84": "    assertTrue(Arrays.equals(ASCII.getBytes(Charsets.US_ASCII),\n",
        "85": "        Files.toByteArray(asciiFile)));\n",
        "86": "    assertTrue(Arrays.equals(I18N.getBytes(Charsets.UTF_8),\n",
        "87": "        Files.toByteArray(i18nFile)));\n",
        "88": "    assertTrue(Arrays.equals(I18N.getBytes(Charsets.UTF_8),\n",
        "89": "        Files.asByteSource(i18nFile).read()));\n",
        "152": "  /**\n",
        "153": "   * A {@link File} that provides a specialized value for {@link File#length()}.\n",
        "154": "   */\n",
        "177": "    assertThat(Files.toString(i18nFile, Charsets.US_ASCII))\n",
        "178": "        .isNotEqualTo(I18N);\n",
        "284": "    assertTrue(Files.asByteSource(asciiFile)\n",
        "285": "        .contentEquals(Files.asByteSource(asciiFile)));\n",
        "349": "      Files.touch(new File(temp.getPath()) {\n",
        "350": "        @Override\n",
        "351": "        public boolean setLastModified(long t) {\n",
        "352": "          return false;\n",
        "353": "        }\n",
        "354": "\n",
        "355": "        private static final long serialVersionUID = 0;\n",
        "356": "      });\n",
        "456": "    moveHelper(false, new UnmovableFile(temp1, false, false),\n",
        "457": "        new UnmovableFile(temp2, true, false));\n",
        "467": "  private void moveHelper(boolean success, File from, File to)\n",
        "468": "      throws IOException {\n",
        "521": "    assertEquals(ImmutableList.of(\"hello\", \"\", \" world  \", \"\"),\n",
        "522": "        Files.readLines(temp, Charsets.UTF_8));\n",
        "553": "    assertThat(collect.getResult())\n",
        "554": "        .containsExactly(\"hello\", \"\", \" world  \", \"\").inOrder();\n",
        "574": "    assertThat(collectNonEmptyLines.getResult()).containsExactly(\n",
        "575": "        \"hello\", \" world  \").inOrder();\n",
        "718": "    ByteProcessor<byte[]> processor = new ByteProcessor<byte[]>() {\n",
        "719": "      private final ByteArrayOutputStream out = new ByteArrayOutputStream();\n",
        "720": "\n",
        "721": "      @Override\n",
        "722": "      public boolean processBytes(byte[] buffer, int offset, int length) throws IOException {\n",
        "723": "        if (length >= 0) {\n",
        "724": "          out.write(buffer, offset, length);\n",
        "725": "        }\n",
        "726": "        return true;\n",
        "727": "      }\n",
        "729": "      @Override\n",
        "730": "      public byte[] getResult() {\n",
        "731": "        return out.toByteArray();\n",
        "732": "      }\n",
        "733": "    };\n",
        "741": "    ByteProcessor<byte[]> processor = new ByteProcessor<byte[]>() {\n",
        "742": "      private final ByteArrayOutputStream out = new ByteArrayOutputStream();\n",
        "743": "\n",
        "744": "      @Override\n",
        "745": "      public boolean processBytes(byte[] buffer, int offset, int length) throws IOException {\n",
        "746": "        if (length > 0) {\n",
        "747": "          out.write(buffer, offset, 1);\n",
        "748": "          return false;\n",
        "749": "        } else {\n",
        "750": "          return true;\n",
        "751": "        }\n",
        "752": "      }\n",
        "754": "      @Override\n",
        "755": "      public byte[] getResult() {\n",
        "756": "        return out.toByteArray();\n",
        "757": "      }\n",
        "758": "    };\n",
        "775": "  /**\n",
        "776": "   * Returns a root path for the file system.\n",
        "777": "   */\n",
        "782": "  /**\n",
        "783": "   * Returns a {@code File} object for the given path parts.\n",
        "784": "   */\n",
        "789": "  /**\n",
        "790": "   * Returns a {@code File} object for the given path parts.\n",
        "791": "   */\n"
    }
}