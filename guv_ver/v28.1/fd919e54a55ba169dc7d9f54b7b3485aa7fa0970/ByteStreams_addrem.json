{
    "addition": {
        "52": "  /** Creates a new byte array for buffering reads or writes. */\n",
        "58": "   * There are three methods to implement {@link FileChannel#transferTo(long, long,\n",
        "59": "   * WritableByteChannel)}:\n",
        "62": "   *   <li>Use sendfile(2) or equivalent. Requires that both the input channel and the output\n",
        "63": "   *       channel have their own file descriptors. Generally this only happens when both channels\n",
        "64": "   *       are files or sockets. This performs zero copies - the bytes never enter userspace.\n",
        "65": "   *   <li>Use mmap(2) or equivalent. Requires that either the input channel or the output channel\n",
        "66": "   *       have file descriptors. Bytes are copied from the file into a kernel buffer, then directly\n",
        "67": "   *       into the other buffer (userspace). Note that if the file is very large, a naive\n",
        "68": "   *       implementation will effectively put the whole file in memory. On many systems with paging\n",
        "69": "   *       and virtual memory, this is not a problem - because it is mapped read-only, the kernel\n",
        "70": "   *       can always page it to disk \"for free\". However, on systems where killing processes\n",
        "71": "   *       happens all the time in normal conditions (i.e., android) the OS must make a tradeoff\n",
        "72": "   *       between paging memory and killing other processes - so allocating a gigantic buffer and\n",
        "73": "   *       then sequentially accessing it could result in other processes dying. This is solvable\n",
        "74": "   *       via madvise(2), but that obviously doesn't exist in java.\n",
        "75": "   *   <li>Ordinary copy. Kernel copies bytes into a kernel buffer, from a kernel buffer into a\n",
        "76": "   *       userspace buffer (byte[] or ByteBuffer), then copies them from that buffer into the\n",
        "77": "   *       destination channel.\n",
        "205": "  /** BAOS that provides limited access to its internal byte array. */\n",
        "254": "   * Returns a new {@link ByteArrayDataInput} instance to read from the given {@code\n",
        "255": "   * ByteArrayInputStream}. The given input stream is not reset before being read from by the\n",
        "409": "  /** Returns a new {@link ByteArrayDataOutput} instance with a default size. */\n",
        "430": "   * Returns a new {@link ByteArrayDataOutput} instance which writes to the given {@code\n",
        "431": "   * ByteArrayOutputStream}. The given output stream is not reset before being written to by the\n",
        "432": "   * returned {@code ByteArrayDataOutput} and new data will be appended to any existing content.\n",
        "434": "   * <p>Note that if the given output stream was not empty or is modified after the {@code\n",
        "435": "   * ByteArrayDataOutput} is created, the contract for {@link ByteArrayDataOutput#toByteArray} will\n",
        "436": "   * not be honored (the bytes returned in the byte array may not be exactly what was written via\n",
        "437": "   * calls to {@code ByteArrayDataOutput}).\n",
        "720": "   * Attempts to read {@code len} bytes from the stream into the given array starting at {@code\n",
        "721": "   * off}, with the same behavior as {@link DataInput#readFully(byte[], int, int)}. Does not close\n",
        "722": "   * the stream.\n",
        "786": "   * Attempts to skip up to {@code n} bytes from the given input stream, but not more than {@code\n",
        "787": "   * in.available()} bytes. This prevents {@code FileInputStream} from skipping more bytes than\n",
        "788": "   * actually remain in the file, something that it {@linkplain java.io.FileInputStream#skip(long)\n",
        "789": "   * specifies} it can do in its Javadoc despite the fact that it is violating the contract of\n",
        "790": "   * {@code InputStream.skip()}.\n",
        "829": "   * or {@code len} is negative, or {@code off+len} is greater than the length of the array {@code\n",
        "830": "   * b}, then an {@code IndexOutOfBoundsException} is thrown. If {@code len} is zero, then no bytes\n",
        "831": "   * are read. Otherwise, the first byte read is stored into element {@code b[off]}, the next one\n",
        "832": "   * into {@code b[off+1]}, and so on. The number of bytes read is, at most, equal to {@code len}.\n"
    },
    "removed": {
        "52": "  /**\n",
        "53": "   * Creates a new byte array for buffering reads or writes.\n",
        "54": "   */\n",
        "60": "   * There are three methods to implement\n",
        "61": "   * {@link FileChannel#transferTo(long, long, WritableByteChannel)}:\n",
        "64": "   * <li>Use sendfile(2) or equivalent. Requires that both the input channel and the output channel\n",
        "65": "   *     have their own file descriptors. Generally this only happens when both channels are files\n",
        "66": "   *     or sockets. This performs zero copies - the bytes never enter userspace.\n",
        "67": "   * <li>Use mmap(2) or equivalent. Requires that either the input channel or the output channel\n",
        "68": "   *     have file descriptors. Bytes are copied from the file into a kernel buffer, then directly\n",
        "69": "   *     into the other buffer (userspace). Note that if the file is very large, a naive\n",
        "70": "   *     implementation will effectively put the whole file in memory. On many systems with paging\n",
        "71": "   *     and virtual memory, this is not a problem - because it is mapped read-only, the kernel can\n",
        "72": "   *     always page it to disk \"for free\". However, on systems where killing processes happens all\n",
        "73": "   *     the time in normal conditions (i.e., android) the OS must make a tradeoff between paging\n",
        "74": "   *     memory and killing other processes - so allocating a gigantic buffer and then sequentially\n",
        "75": "   *     accessing it could result in other processes dying. This is solvable via madvise(2), but\n",
        "76": "   *     that obviously doesn't exist in java.\n",
        "77": "   * <li>Ordinary copy. Kernel copies bytes into a kernel buffer, from a kernel buffer into a\n",
        "78": "   *     userspace buffer (byte[] or ByteBuffer), then copies them from that buffer into the\n",
        "79": "   *     destination channel.\n",
        "207": "  /**\n",
        "208": "   * BAOS that provides limited access to its internal byte array.\n",
        "209": "   */\n",
        "258": "   * Returns a new {@link ByteArrayDataInput} instance to read from the given\n",
        "259": "   * {@code ByteArrayInputStream}. The given input stream is not reset before being read from by the\n",
        "413": "  /**\n",
        "414": "   * Returns a new {@link ByteArrayDataOutput} instance with a default size.\n",
        "415": "   */\n",
        "436": "   * Returns a new {@link ByteArrayDataOutput} instance which writes to the given\n",
        "437": "   * {@code ByteArrayOutputStream}. The given output stream is not reset before being written to by\n",
        "438": "   * the returned {@code ByteArrayDataOutput} and new data will be appended to any existing content.\n",
        "440": "   * <p>Note that if the given output stream was not empty or is modified after the\n",
        "441": "   * {@code ByteArrayDataOutput} is created, the contract for\n",
        "442": "   * {@link ByteArrayDataOutput#toByteArray} will not be honored (the bytes returned in the byte\n",
        "443": "   * array may not be exactly what was written via calls to {@code ByteArrayDataOutput}).\n",
        "726": "   * Attempts to read {@code len} bytes from the stream into the given array starting at\n",
        "727": "   * {@code off}, with the same behavior as {@link DataInput#readFully(byte[], int, int)}. Does not\n",
        "728": "   * close the stream.\n",
        "792": "   * Attempts to skip up to {@code n} bytes from the given input stream, but not more than\n",
        "793": "   * {@code in.available()} bytes. This prevents {@code FileInputStream} from skipping more bytes\n",
        "794": "   * than actually remain in the file, something that it {@linkplain\n",
        "795": "   * java.io.FileInputStream#skip(long) specifies} it can do in its Javadoc despite the fact that\n",
        "796": "   * it is violating the contract of {@code InputStream.skip()}.\n",
        "835": "   * or {@code len} is negative, or {@code off+len} is greater than the length of the array\n",
        "836": "   * {@code b}, then an {@code IndexOutOfBoundsException} is thrown. If {@code len} is zero, then no\n",
        "837": "   * bytes are read. Otherwise, the first byte read is stored into element {@code b[off]}, the next\n",
        "838": "   * one into {@code b[off+1]}, and so on. The number of bytes read is, at most, equal to\n",
        "839": "   * {@code len}.\n"
    }
}