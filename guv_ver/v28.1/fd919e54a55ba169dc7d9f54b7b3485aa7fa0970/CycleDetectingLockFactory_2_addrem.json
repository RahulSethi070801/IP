{
    "addition": {
        "48": " * The {@code CycleDetectingLockFactory} creates {@link ReentrantLock} instances and {@link\n",
        "49": " * ReentrantReadWriteLock} instances that detect potential deadlock by checking for cycles in lock\n",
        "50": " * acquisition order.\n",
        "55": " *\n",
        "57": " *   <li>DISABLED\n",
        "58": " *   <li>WARN\n",
        "59": " *   <li>THROW\n",
        "95": " *\n",
        "97": " *   <li>Each lock adds (and removes) itself to/from a ThreadLocal Set of acquired locks when the\n",
        "98": " *       Thread acquires its first hold (and releases its last remaining hold).\n",
        "99": " *   <li>Before the lock is acquired, the lock is checked against the current set of acquired\n",
        "100": " *       locks---to each of the acquired locks, an edge from the soon-to-be-acquired lock is either\n",
        "101": " *       verified or created.\n",
        "102": " *   <li>If a new edge needs to be created, the outgoing edges of the acquired locks are traversed\n",
        "103": " *       to check for a cycle that reaches the lock to be acquired. If no cycle is detected, a new\n",
        "104": " *       \"safe\" edge is created.\n",
        "105": " *   <li>If a cycle is detected, an \"unsafe\" (cyclic) edge is created to represent a potential\n",
        "106": " *       deadlock situation, and the appropriate Policy is executed.\n",
        "143": " *   <li>for an unnested {@code lock()} and {@code unlock()}, a cycle detecting lock takes 38ns as\n",
        "144": " *       opposed to the 24ns taken by a plain lock.\n",
        "145": " *   <li>for nested locking, the cost increases with the depth of the nesting:\n",
        "146": " *       <ul>\n",
        "147": " *         <li>2 levels: average of 64ns per lock()/unlock()\n",
        "148": " *         <li>3 levels: average of 77ns per lock()/unlock()\n",
        "149": " *         <li>4 levels: average of 99ns per lock()/unlock()\n",
        "150": " *         <li>5 levels: average of 103ns per lock()/unlock()\n",
        "151": " *         <li>10 levels: average of 184ns per lock()/unlock()\n",
        "152": " *         <li>20 levels: average of 393ns per lock()/unlock()\n",
        "153": " *       </ul>\n",
        "178": "     * Called when a potential deadlock is encountered. Implementations can throw the given {@code\n",
        "179": "     * exception} and/or execute other desired logic.\n",
        "197": "     * When potential deadlock is detected, this policy results in the throwing of the {@code\n",
        "198": "     * PotentialDeadlockException} indicating the potential deadlock, which includes stack traces\n",
        "199": "     * illustrating the cycle in lock acquisition order.\n",
        "209": "     * When potential deadlock is detected, this policy results in the logging of a {@link\n",
        "210": "     * Level#SEVERE} message indicating the potential deadlock, which includes stack traces\n",
        "234": "  /** Creates a new factory with the specified policy. */\n",
        "239": "  /** Equivalent to {@code newReentrantLock(lockName, false)}. */\n",
        "254": "  /** Equivalent to {@code newReentrantReadWriteLock(lockName, false)}. */\n",
        "274": "  /** Creates a {@code CycleDetectingLockFactory.WithExplicitOrdering<E>}. */\n",
        "298": "   * corresponding LockGraphNode, with the {@code allowedPriorLocks} and {@code\n",
        "299": "   * disallowedPriorLocks} prepopulated with nodes according to the natural ordering of the\n",
        "334": "   * A {@code CycleDetectingLockFactory.WithExplicitOrdering} provides the additional enforcement of\n",
        "335": "   * an application-specified ordering of lock acquisitions. The application defines the allowed\n",
        "341": "   * <pre>{@code\n",
        "355": "   * lock2.lock();  // will throw an IllegalStateException\n",
        "356": "   * }</pre>\n",
        "368": "   * <pre>{@code\n",
        "383": "   * lockA.lock();  // reentrant acquisition is okay\n",
        "384": "   * }</pre>\n",
        "404": "    /** Equivalent to {@code newReentrantLock(rank, false)}. */\n",
        "423": "    /** Equivalent to {@code newReentrantReadWriteLock(rank, false)}. */\n",
        "454": "   * Tracks the currently acquired locks for each Thread, kept up to date by calls to {@link\n",
        "455": "   * #aboutToAcquire(CycleDetectingLock)} and {@link #lockStateChanged(CycleDetectingLock)}.\n",
        "544": "     * Appends the chain of messages from the {@code conflictingStackTrace} to the original {@code\n",
        "545": "     * message}.\n",
        "611": "     * <p>When this method returns, the {@code acquiredLock} should be in either the {@code\n",
        "612": "     * preAcquireLocks} map, for the case in which it is safe to acquire {@code this} after the\n",
        "613": "     * {@code acquiredLock}, or in the {@code disallowedPriorLocks} map, in which case it is not\n",
        "671": "     * Performs a depth-first traversal of the graph edges defined by each node's {@code\n",
        "672": "     * allowedPriorLocks} to find a path between {@code this} and the specified {@code lock}.\n"
    },
    "removed": {
        "48": " * The {@code CycleDetectingLockFactory} creates {@link ReentrantLock} instances and\n",
        "49": " * {@link ReentrantReadWriteLock} instances that detect potential deadlock by checking for cycles in\n",
        "50": " * lock acquisition order.\n",
        "56": " * <li>DISABLED\n",
        "57": " * <li>WARN\n",
        "58": " * <li>THROW\n",
        "95": " * <li>Each lock adds (and removes) itself to/from a ThreadLocal Set of acquired locks when the\n",
        "96": " *     Thread acquires its first hold (and releases its last remaining hold).\n",
        "97": " * <li>Before the lock is acquired, the lock is checked against the current set of acquired\n",
        "98": " *     locks---to each of the acquired locks, an edge from the soon-to-be-acquired lock is either\n",
        "99": " *     verified or created.\n",
        "100": " * <li>If a new edge needs to be created, the outgoing edges of the acquired locks are traversed to\n",
        "101": " *     check for a cycle that reaches the lock to be acquired. If no cycle is detected, a new \"safe\"\n",
        "102": " *     edge is created.\n",
        "103": " * <li>If a cycle is detected, an \"unsafe\" (cyclic) edge is created to represent a potential\n",
        "104": " *     deadlock situation, and the appropriate Policy is executed.\n",
        "141": " * <li>for an unnested {@code lock()} and {@code unlock()}, a cycle detecting lock takes 38ns as\n",
        "142": " *     opposed to the 24ns taken by a plain lock.\n",
        "143": " * <li>for nested locking, the cost increases with the depth of the nesting:\n",
        "144": " *     <ul>\n",
        "145": " *     <li>2 levels: average of 64ns per lock()/unlock()\n",
        "146": " *     <li>3 levels: average of 77ns per lock()/unlock()\n",
        "147": " *     <li>4 levels: average of 99ns per lock()/unlock()\n",
        "148": " *     <li>5 levels: average of 103ns per lock()/unlock()\n",
        "149": " *     <li>10 levels: average of 184ns per lock()/unlock()\n",
        "150": " *     <li>20 levels: average of 393ns per lock()/unlock()\n",
        "151": " *     </ul>\n",
        "176": "     * Called when a potential deadlock is encountered. Implementations can throw the given\n",
        "177": "     * {@code exception} and/or execute other desired logic.\n",
        "195": "     * When potential deadlock is detected, this policy results in the throwing of the\n",
        "196": "     * {@code PotentialDeadlockException} indicating the potential deadlock, which includes stack\n",
        "197": "     * traces illustrating the cycle in lock acquisition order.\n",
        "207": "     * When potential deadlock is detected, this policy results in the logging of a\n",
        "208": "     * {@link Level#SEVERE} message indicating the potential deadlock, which includes stack traces\n",
        "232": "  /**\n",
        "233": "   * Creates a new factory with the specified policy.\n",
        "234": "   */\n",
        "239": "  /**\n",
        "240": "   * Equivalent to {@code newReentrantLock(lockName, false)}.\n",
        "241": "   */\n",
        "256": "  /**\n",
        "257": "   * Equivalent to {@code newReentrantReadWriteLock(lockName, false)}.\n",
        "258": "   */\n",
        "278": "  /**\n",
        "279": "   * Creates a {@code CycleDetectingLockFactory.WithExplicitOrdering<E>}.\n",
        "280": "   */\n",
        "304": "   * corresponding LockGraphNode, with the {@code allowedPriorLocks} and\n",
        "305": "   * {@code disallowedPriorLocks} prepopulated with nodes according to the natural ordering of the\n",
        "340": "   * <p>A {@code CycleDetectingLockFactory.WithExplicitOrdering} provides the additional enforcement\n",
        "341": "   * of an application-specified ordering of lock acquisitions. The application defines the allowed\n",
        "347": "   * <pre>   {@code\n",
        "361": "   * lock2.lock();  // will throw an IllegalStateException}</pre>\n",
        "373": "   * <pre>   {@code\n",
        "388": "   * lockA.lock();  // reentrant acquisition is okay}</pre>\n",
        "408": "    /**\n",
        "409": "     * Equivalent to {@code newReentrantLock(rank, false)}.\n",
        "410": "     */\n",
        "429": "    /**\n",
        "430": "     * Equivalent to {@code newReentrantReadWriteLock(rank, false)}.\n",
        "431": "     */\n",
        "462": "   * Tracks the currently acquired locks for each Thread, kept up to date by calls to\n",
        "463": "   * {@link #aboutToAcquire(CycleDetectingLock)} and {@link #lockStateChanged(CycleDetectingLock)}.\n",
        "552": "     * Appends the chain of messages from the {@code conflictingStackTrace} to the original\n",
        "553": "     * {@code message}.\n",
        "619": "     * <p>When this method returns, the {@code acquiredLock} should be in either the\n",
        "620": "     * {@code preAcquireLocks} map, for the case in which it is safe to acquire {@code this} after\n",
        "621": "     * the {@code acquiredLock}, or in the {@code disallowedPriorLocks} map, in which case it is not\n",
        "679": "     * Performs a depth-first traversal of the graph edges defined by each node's\n",
        "680": "     * {@code allowedPriorLocks} to find a path between {@code this} and the specified {@code lock}.\n"
    }
}