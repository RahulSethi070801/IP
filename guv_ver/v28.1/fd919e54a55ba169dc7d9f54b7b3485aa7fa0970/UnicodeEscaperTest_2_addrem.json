{
    "addition": {
        "36": "      \"\\0abyz\\u0080\\u0100\\u0800\\u1000ABYZ\\uffff\" + SMALLEST_SURROGATE + \"0189\" + LARGEST_SURROGATE;\n",
        "39": "  private static final UnicodeEscaper NOP_ESCAPER =\n",
        "40": "      new UnicodeEscaper() {\n",
        "41": "        @Override\n",
        "42": "        protected char[] escape(int c) {\n",
        "43": "          return null;\n",
        "44": "        }\n",
        "45": "      };\n",
        "48": "  private static final UnicodeEscaper SIMPLE_ESCAPER =\n",
        "49": "      new UnicodeEscaper() {\n",
        "50": "        @Override\n",
        "51": "        protected char[] escape(int cp) {\n",
        "52": "          return ('a' <= cp && cp <= 'z') || ('A' <= cp && cp <= 'Z') || ('0' <= cp && cp <= '9')\n",
        "53": "              ? null\n",
        "54": "              : (\"[\" + String.valueOf(cp) + \"]\").toCharArray();\n",
        "55": "        }\n",
        "56": "      };\n",
        "66": "        \"[0]abyz[128][256][2048][4096]ABYZ[65535]\"\n",
        "67": "            + \"[\"\n",
        "68": "            + Character.MIN_SUPPLEMENTARY_CODE_POINT\n",
        "69": "            + \"]\"\n",
        "70": "            + \"0189[\"\n",
        "71": "            + Character.MAX_CODE_POINT\n",
        "72": "            + \"]\";\n",
        "109": "    String expected = \"x[\" + min + \"][\" + s1 + \"][\" + s2 + \"][\" + s3 + \"][\" + max + \"]x\";\n",
        "142": "      String.valueOf(Character.MIN_LOW_SURROGATE),\n",
        "143": "      Character.MIN_LOW_SURROGATE + \"xyz\",\n",
        "144": "      \"abc\" + Character.MIN_LOW_SURROGATE,\n",
        "145": "      \"abc\" + Character.MIN_LOW_SURROGATE + \"xyz\",\n",
        "146": "      String.valueOf(Character.MAX_LOW_SURROGATE),\n",
        "147": "      Character.MAX_LOW_SURROGATE + \"xyz\",\n",
        "148": "      \"abc\" + Character.MAX_LOW_SURROGATE,\n",
        "149": "      \"abc\" + Character.MAX_LOW_SURROGATE + \"xyz\",\n",
        "162": "    UnicodeEscaper e =\n",
        "163": "        new UnicodeEscaper() {\n",
        "164": "          // Canonical escaper method that only escapes lower case ASCII letters.\n",
        "165": "          @Override\n",
        "166": "          protected char[] escape(int cp) {\n",
        "167": "            return ('a' <= cp && cp <= 'z') ? new char[] {Character.toUpperCase((char) cp)} : null;\n",
        "168": "          }\n",
        "169": "          // Inefficient implementation that defines all letters as escapable.\n",
        "170": "          @Override\n",
        "171": "          protected int nextEscapeIndex(CharSequence csq, int index, int end) {\n",
        "172": "            while (index < end && !Character.isLetter(csq.charAt(index))) {\n",
        "173": "              index++;\n",
        "174": "            }\n",
        "175": "            return index;\n",
        "176": "          }\n",
        "177": "        };\n",
        "178": "    assertEquals(\"\\0HELLO \\uD800\\uDC00 WORLD!\\n\", e.escape(\"\\0HeLLo \\uD800\\uDC00 WorlD!\\n\"));\n"
    },
    "removed": {
        "36": "      \"\\0abyz\\u0080\\u0100\\u0800\\u1000ABYZ\\uffff\" +\n",
        "37": "      SMALLEST_SURROGATE + \"0189\" +  LARGEST_SURROGATE;\n",
        "40": "  private static final UnicodeEscaper NOP_ESCAPER = new UnicodeEscaper() {\n",
        "41": "    @Override\n",
        "42": "    protected char[] escape(int c) {\n",
        "43": "      return null;\n",
        "44": "    }\n",
        "45": "  };\n",
        "48": "  private static final UnicodeEscaper SIMPLE_ESCAPER = new UnicodeEscaper() {\n",
        "49": "    @Override\n",
        "50": "    protected char[] escape(int cp) {\n",
        "51": "      return ('a' <= cp && cp <= 'z') ||\n",
        "52": "             ('A' <= cp && cp <= 'Z') ||\n",
        "53": "             ('0' <= cp && cp <= '9') ? null :\n",
        "54": "          (\"[\" + String.valueOf(cp) + \"]\").toCharArray();\n",
        "55": "    }\n",
        "56": "  };\n",
        "66": "        \"[0]abyz[128][256][2048][4096]ABYZ[65535]\" +\n",
        "67": "        \"[\" + Character.MIN_SUPPLEMENTARY_CODE_POINT + \"]\" +\n",
        "68": "        \"0189[\" + Character.MAX_CODE_POINT + \"]\";\n",
        "105": "    String expected =\n",
        "106": "        \"x[\" + min + \"][\" + s1 + \"][\" + s2 + \"][\" + s3 + \"][\" + max + \"]x\";\n",
        "139": "        String.valueOf(Character.MIN_LOW_SURROGATE),\n",
        "140": "        Character.MIN_LOW_SURROGATE + \"xyz\",\n",
        "141": "        \"abc\" + Character.MIN_LOW_SURROGATE,\n",
        "142": "        \"abc\" + Character.MIN_LOW_SURROGATE + \"xyz\",\n",
        "143": "        String.valueOf(Character.MAX_LOW_SURROGATE),\n",
        "144": "        Character.MAX_LOW_SURROGATE + \"xyz\",\n",
        "145": "        \"abc\" + Character.MAX_LOW_SURROGATE,\n",
        "146": "        \"abc\" + Character.MAX_LOW_SURROGATE + \"xyz\",\n",
        "159": "    UnicodeEscaper e = new UnicodeEscaper() {\n",
        "160": "      // Canonical escaper method that only escapes lower case ASCII letters.\n",
        "161": "      @Override\n",
        "162": "      protected char[] escape(int cp) {\n",
        "163": "        return ('a' <= cp && cp <= 'z') ?\n",
        "164": "            new char[] { Character.toUpperCase((char) cp) } : null;\n",
        "165": "      }\n",
        "166": "      // Inefficient implementation that defines all letters as escapable.\n",
        "167": "      @Override\n",
        "168": "      protected int nextEscapeIndex(CharSequence csq, int index, int end) {\n",
        "169": "        while (index < end && !Character.isLetter(csq.charAt(index))) {\n",
        "170": "          index++;\n",
        "171": "        }\n",
        "172": "        return index;\n",
        "173": "      }\n",
        "174": "    };\n",
        "175": "    assertEquals(\"\\0HELLO \\uD800\\uDC00 WORLD!\\n\",\n",
        "176": "        e.escape(\"\\0HeLLo \\uD800\\uDC00 WorlD!\\n\"));\n"
    }
}