{
    "addition": {
        "110": "    checkUnmodifiableMultimap(ArrayListMultimap.<String, Integer>create(), true);\n",
        "124": "    ListMultimap<String, Integer> multimap = Multimaps.unmodifiableListMultimap(delegate);\n",
        "152": "    checkUnmodifiableMultimap(TreeMultimap.<String, Integer>create(), false, \"null\", 42);\n",
        "164": "    checkUnmodifiableMultimap(\n",
        "165": "        Multimaps.synchronizedListMultimap(ArrayListMultimap.<String, Integer>create()), true);\n",
        "171": "        prepareUnmodifiableTests(\n",
        "172": "            Multimaps.synchronizedListMultimap(ArrayListMultimap.<String, Integer>create()),\n",
        "173": "            true,\n",
        "174": "            null,\n",
        "175": "            null);\n",
        "181": "    checkUnmodifiableMultimap(\n",
        "182": "        Multimaps.synchronizedSetMultimap(HashMultimap.<String, Integer>create()), false);\n",
        "188": "        prepareUnmodifiableTests(\n",
        "189": "            Multimaps.synchronizedSetMultimap(HashMultimap.<String, Integer>create()),\n",
        "190": "            false,\n",
        "191": "            null,\n",
        "192": "            null);\n",
        "198": "    TreeMultimap<String, Integer> delegate =\n",
        "199": "        TreeMultimap.create(Ordering.<String>natural(), INT_COMPARATOR);\n",
        "200": "    SortedSetMultimap<String, Integer> multimap = Multimaps.synchronizedSortedSetMultimap(delegate);\n",
        "209": "    SortedSetMultimap<String, Integer> multimap = Multimaps.synchronizedSortedSetMultimap(delegate);\n",
        "210": "    Multimap<String, Integer> unmodifiable = prepareUnmodifiableTests(multimap, false, \"null\", 42);\n",
        "233": "    } catch (UnsupportedOperationException expected) {\n",
        "234": "    }\n",
        "239": "    } catch (UnsupportedOperationException expected) {\n",
        "240": "    }\n",
        "241": "    Entry<String, Integer>[] array = (Entry<String, Integer>[]) new Entry<?, ?>[2];\n",
        "246": "    } catch (UnsupportedOperationException expected) {\n",
        "247": "    }\n",
        "253": "   * The supplied multimap will be mutated and an unmodifiable instance used in its stead. The\n",
        "254": "   * multimap must support null keys and values.\n",
        "262": "   * The supplied multimap will be mutated and an unmodifiable instance used in its stead. If the\n",
        "263": "   * multimap does not support null keys or values, alternatives may be specified for tests\n",
        "264": "   * involving nulls.\n",
        "267": "      Multimap<String, Integer> multimap,\n",
        "268": "      boolean permitsDuplicates,\n",
        "269": "      @Nullable String nullKey,\n",
        "270": "      @Nullable Integer nullValue) {\n",
        "274": "    UnmodifiableCollectionTests.assertMultimapIsUnmodifiable(unmodifiable, \"test\", 123);\n",
        "276": "    assertUnmodifiableIterableInTandem(unmodifiable.keys(), multimap.keys());\n",
        "278": "    assertUnmodifiableIterableInTandem(unmodifiable.keySet(), multimap.keySet());\n",
        "280": "    assertUnmodifiableIterableInTandem(unmodifiable.entries(), multimap.entries());\n",
        "295": "  /** Prepares the multimap for unmodifiable tests, returning an unmodifiable view of the map. */\n",
        "297": "      Multimap<String, Integer> multimap,\n",
        "298": "      boolean permitsDuplicates,\n",
        "299": "      @Nullable String nullKey,\n",
        "300": "      @Nullable Integer nullValue) {\n",
        "320": "      unmodifiable =\n",
        "321": "          Multimaps.unmodifiableSortedSetMultimap((SortedSetMultimap<String, Integer>) multimap);\n",
        "323": "      unmodifiable = Multimaps.unmodifiableSetMultimap((SetMultimap<String, Integer>) multimap);\n",
        "325": "      unmodifiable = Multimaps.unmodifiableListMultimap((ListMultimap<String, Integer>) multimap);\n",
        "334": "    UnmodifiableCollectionTests.assertIteratorIsUnmodifiable(unmodifiable.iterator());\n",
        "343": "    Multimap<String, Integer> multimap =\n",
        "344": "        Multimaps.invertFrom(empty, ArrayListMultimap.<String, Integer>create());\n",
        "347": "    ImmutableMultimap<Integer, String> single =\n",
        "348": "        new ImmutableMultimap.Builder<Integer, String>().put(1, \"one\").put(2, \"two\").build();\n",
        "353": "    ImmutableMultimap<String, Integer> expected =\n",
        "354": "        new ImmutableMultimap.Builder<String, Integer>().put(\"one\", 1).put(\"two\", 2).build();\n",
        "360": "    Multimap<String, Integer> multimap =\n",
        "361": "        Multimaps.newMultimap(new HashMap<String, Collection<Integer>>(), new QueueSupplier());\n",
        "379": "    SortedSetMultimap<String, Integer> sortedSetMultimap = TreeMultimap.create();\n",
        "392": "    new EqualsTester().addEqualityGroup(multimap, multimapView).addEqualityGroup(map).testEquals();\n",
        "398": "    ListMultimap<String, Integer> listMultimap =\n",
        "399": "        new ImmutableListMultimap.Builder<String, Integer>().put(\"foo\", 1).put(\"bar\", 2).build();\n",
        "400": "    assertFalse(\"SetMultimap equals ListMultimap\", multimapView.equals(listMultimap));\n",
        "412": "    } catch (UnsupportedOperationException expected) {\n",
        "413": "    }\n",
        "417": "    } catch (UnsupportedOperationException expected) {\n",
        "418": "    }\n",
        "422": "    } catch (UnsupportedOperationException expected) {\n",
        "423": "    }\n",
        "427": "    } catch (UnsupportedOperationException expected) {\n",
        "428": "    }\n",
        "488": "    assertFalse(entries.contains(Maps.immutableEntry(\"foo\", Collections.singletonList(1))));\n",
        "489": "    assertFalse(entries.remove(Maps.immutableEntry(\"foo\", Collections.singletonList(1))));\n",
        "490": "    assertFalse(entries.contains(Maps.immutableEntry(\"foo\", Sets.newLinkedHashSet(asList(1, 2)))));\n",
        "491": "    assertFalse(entries.remove(Maps.immutableEntry(\"foo\", Sets.newLinkedHashSet(asList(1, 2)))));\n",
        "492": "    assertFalse(entries.contains(Maps.immutableEntry(\"foo\", Collections.singleton(2))));\n",
        "493": "    assertFalse(entries.remove(Maps.immutableEntry(\"foo\", Collections.singleton(2))));\n",
        "495": "    assertTrue(entries.contains(Maps.immutableEntry(\"foo\", Collections.singleton(1))));\n",
        "496": "    assertTrue(entries.remove(Maps.immutableEntry(\"foo\", Collections.singleton(1))));\n",
        "502": "        new IteratorTester<Integer>(\n",
        "503": "            4, MODIFIABLE, newHashSet(1), IteratorTester.KnownOrder.KNOWN_ORDER) {\n",
        "506": "          @Override\n",
        "507": "          protected Iterator<Integer> newTargetIterator() {\n",
        "515": "          @Override\n",
        "516": "          protected void verify(List<Integer> elements) {\n",
        "524": "  private enum Color {\n",
        "525": "    BLUE,\n",
        "526": "    RED,\n",
        "527": "    YELLOW,\n",
        "528": "    GREEN\n",
        "529": "  }\n",
        "531": "  private abstract static class CountingSupplier<E> implements Supplier<E>, Serializable {\n",
        "544": "    @Override\n",
        "545": "    public Queue<Integer> getImpl() {\n",
        "548": "\n",
        "553": "    CountingSupplier<Set<Integer>> factory =\n",
        "554": "        new SetSupplier() {\n",
        "556": "          public Set<Integer> getImpl() {\n",
        "557": "            final Set<Integer> backing = super.getImpl();\n",
        "558": "            return new ForwardingSet<Integer>() {\n",
        "559": "              @Override\n",
        "560": "              protected Set<Integer> delegate() {\n",
        "561": "                return backing;\n",
        "562": "              }\n",
        "563": "\n",
        "564": "              @Override\n",
        "565": "              public boolean add(Integer element) {\n",
        "566": "                checkArgument(element >= 0);\n",
        "567": "                return super.add(element);\n",
        "568": "              }\n",
        "569": "\n",
        "570": "              @Override\n",
        "571": "              public boolean addAll(Collection<? extends Integer> collection) {\n",
        "572": "                return standardAddAll(collection);\n",
        "573": "              }\n",
        "574": "            };\n",
        "592": "    assertThat(multimap.entries())\n",
        "593": "        .containsExactly(Maps.immutableEntry(Color.RED, 1), Maps.immutableEntry(Color.BLUE, 2));\n",
        "609": "    Multimap<Color, Integer> ummodifiable = Multimaps.unmodifiableMultimap(multimap);\n",
        "629": "  private static class ListSupplier extends CountingSupplier<LinkedList<Integer>> {\n",
        "630": "    @Override\n",
        "631": "    public LinkedList<Integer> getImpl() {\n",
        "634": "\n",
        "641": "    ListMultimap<Color, Integer> multimap = Multimaps.newListMultimap(map, factory);\n",
        "665": "    @Override\n",
        "666": "    public Set<Integer> getImpl() {\n",
        "669": "\n",
        "676": "    SetMultimap<Color, Integer> multimap = Multimaps.newSetMultimap(map, factory);\n",
        "695": "  private static class SortedSetSupplier extends CountingSupplier<TreeSet<Integer>> {\n",
        "696": "    @Override\n",
        "697": "    public TreeSet<Integer> getImpl() {\n",
        "700": "\n",
        "707": "    SortedSetMultimap<Color, Integer> multimap = Multimaps.newSortedSetMultimap(map, factory);\n",
        "740": "        Multimaps.index(stringToObject.values(), Functions.toStringFunction());\n",
        "755": "        Multimaps.index(stringToObject.values().iterator(), Functions.toStringFunction());\n",
        "769": "    final List<String> badGuys = Arrays.asList(\"Inky\", \"Blinky\", \"Pinky\", \"Pinky\", \"Clyde\");\n",
        "778": "    Multimap<Integer, String> index = Multimaps.index(badGuys, stringLengthFunction);\n",
        "805": "    Function<Integer, Integer> square =\n",
        "806": "        new Function<Integer, Integer>() {\n",
        "807": "          @Override\n",
        "808": "          public Integer apply(Integer in) {\n",
        "809": "            return in * in;\n",
        "810": "          }\n",
        "811": "        };\n",
        "813": "    assertThat(transformed.entries())\n",
        "814": "        .containsExactly(\n",
        "815": "            immutableEntry(\"a\", 4),\n",
        "816": "            immutableEntry(\"a\", 16),\n",
        "817": "            immutableEntry(\"b\", 9),\n",
        "818": "            immutableEntry(\"b\", 9),\n",
        "819": "            immutableEntry(\"c\", 36))\n",
        "820": "        .inOrder();\n",
        "828": "        Multimaps.transformValues(\n",
        "829": "            multimap,\n",
        "830": "            new Function<String, Integer>() {\n",
        "831": "\n",
        "832": "              @Override\n",
        "833": "              public Integer apply(String str) {\n",
        "834": "                return str.length();\n",
        "835": "              }\n",
        "836": "            });\n",
        "846": "    Function<Integer, Integer> square =\n",
        "847": "        new Function<Integer, Integer>() {\n",
        "848": "          @Override\n",
        "849": "          public Integer apply(Integer in) {\n",
        "850": "            return in * in;\n",
        "851": "          }\n",
        "852": "        };\n",
        "853": "    ListMultimap<String, Integer> transformed = Multimaps.transformValues(multimap, square);\n",
        "854": "    assertThat(transformed.entries())\n",
        "855": "        .containsExactly(\n",
        "856": "            immutableEntry(\"a\", 4),\n",
        "857": "            immutableEntry(\"a\", 16),\n",
        "858": "            immutableEntry(\"b\", 9),\n",
        "859": "            immutableEntry(\"b\", 9),\n",
        "860": "            immutableEntry(\"c\", 36))\n",
        "861": "        .inOrder();\n",
        "866": "    SetMultimap<String, Integer> multimap = ImmutableSetMultimap.of(\"a\", 1, \"a\", 4, \"b\", -6);\n",
        "874": "    Multimap<String, String> transformed = Multimaps.transformEntries(multimap, transformer);\n",
        "875": "    assertThat(transformed.entries())\n",
        "876": "        .containsExactly(\n",
        "877": "            immutableEntry(\"a\", \"a\"), immutableEntry(\"a\", \"a\"), immutableEntry(\"b\", \"nob\"))\n",
        "878": "        .inOrder();\n",
        "892": "    ListMultimap<String, String> transformed = Multimaps.transformEntries(multimap, transformer);\n",
        "893": "    assertEquals(ImmutableListMultimap.of(\"a\", \"a1\", \"a\", \"a4\", \"a\", \"a4\", \"b\", \"b6\"), transformed);\n",
        "900": "    Multimap<K, V> multimap = Multimaps.synchronizedMultimap(HashMultimap.<K, V>create());\n",
        "901": "    Collection<V> values = multimap.get(key); // Needn't be in synchronized block\n",
        "902": "    synchronized (multimap) { // Synchronizing on multimap, not values!\n",
        "919": "    SetMultimap<String, Integer> filtered =\n",
        "920": "        Multimaps.filterKeys(multimap, Predicates.in(ImmutableSet.of(\"foo\", \"bar\")));\n",
        "922": "    assertEquals(ImmutableSet.of(), filtered.replaceValues(\"baz\", ImmutableSet.<Integer>of()));\n",
        "938": "    SetMultimap<String, Integer> filtered =\n",
        "939": "        Multimaps.filterKeys(multimap, Predicates.in(ImmutableSet.of(\"foo\", \"bar\")));\n",
        "961": "    ListMultimap<String, Integer> filtered =\n",
        "962": "        Multimaps.filterKeys(multimap, Predicates.in(ImmutableSet.of(\"foo\", \"bar\")));\n"
    },
    "removed": {
        "110": "    checkUnmodifiableMultimap(\n",
        "111": "        ArrayListMultimap.<String, Integer>create(), true);\n",
        "125": "    ListMultimap<String, Integer> multimap\n",
        "126": "        = Multimaps.unmodifiableListMultimap(delegate);\n",
        "154": "    checkUnmodifiableMultimap(\n",
        "155": "        TreeMultimap.<String, Integer>create(), false, \"null\", 42);\n",
        "167": "    checkUnmodifiableMultimap(Multimaps.synchronizedListMultimap(\n",
        "168": "        ArrayListMultimap.<String, Integer>create()), true);\n",
        "174": "        prepareUnmodifiableTests(Multimaps.synchronizedListMultimap(\n",
        "175": "          ArrayListMultimap.<String, Integer>create()), true, null, null);\n",
        "181": "    checkUnmodifiableMultimap(Multimaps.synchronizedSetMultimap(\n",
        "182": "        HashMultimap.<String, Integer>create()), false);\n",
        "188": "        prepareUnmodifiableTests(Multimaps.synchronizedSetMultimap(\n",
        "189": "        HashMultimap.<String, Integer>create()), false, null, null);\n",
        "195": "    TreeMultimap<String, Integer> delegate\n",
        "196": "        = TreeMultimap.create(Ordering.<String>natural(), INT_COMPARATOR);\n",
        "197": "    SortedSetMultimap<String, Integer> multimap\n",
        "198": "        = Multimaps.synchronizedSortedSetMultimap(delegate);\n",
        "207": "    SortedSetMultimap<String, Integer> multimap =\n",
        "208": "        Multimaps.synchronizedSortedSetMultimap(delegate);\n",
        "209": "    Multimap<String, Integer> unmodifiable =\n",
        "210": "        prepareUnmodifiableTests(multimap, false, \"null\", 42);\n",
        "233": "    } catch (UnsupportedOperationException expected) {}\n",
        "238": "    } catch (UnsupportedOperationException expected) {}\n",
        "239": "    Entry<String, Integer>[] array\n",
        "240": "        = (Entry<String, Integer>[]) new Entry<?, ?>[2];\n",
        "245": "    } catch (UnsupportedOperationException expected) {}\n",
        "251": "   * The supplied multimap will be mutated and an unmodifiable instance used\n",
        "252": "   * in its stead. The multimap must support null keys and values.\n",
        "260": "   * The supplied multimap will be mutated and an unmodifiable instance used\n",
        "261": "   * in its stead. If the multimap does not support null keys or values,\n",
        "262": "   * alternatives may be specified for tests involving nulls.\n",
        "265": "      Multimap<String, Integer> multimap, boolean permitsDuplicates,\n",
        "266": "      @Nullable String nullKey, @Nullable Integer nullValue) {\n",
        "270": "    UnmodifiableCollectionTests.assertMultimapIsUnmodifiable(\n",
        "271": "        unmodifiable, \"test\", 123);\n",
        "273": "    assertUnmodifiableIterableInTandem(\n",
        "274": "        unmodifiable.keys(), multimap.keys());\n",
        "276": "    assertUnmodifiableIterableInTandem(\n",
        "277": "        unmodifiable.keySet(), multimap.keySet());\n",
        "279": "    assertUnmodifiableIterableInTandem(\n",
        "280": "        unmodifiable.entries(), multimap.entries());\n",
        "295": "  /**\n",
        "296": "   * Prepares the multimap for unmodifiable tests, returning an unmodifiable view\n",
        "297": "   * of the map.\n",
        "298": "   */\n",
        "300": "      Multimap<String, Integer> multimap, boolean permitsDuplicates,\n",
        "301": "      @Nullable String nullKey, @Nullable Integer nullValue) {\n",
        "321": "      unmodifiable = Multimaps.unmodifiableSortedSetMultimap(\n",
        "322": "          (SortedSetMultimap<String, Integer>) multimap);\n",
        "324": "      unmodifiable = Multimaps.unmodifiableSetMultimap(\n",
        "325": "          (SetMultimap<String, Integer>) multimap);\n",
        "327": "      unmodifiable = Multimaps.unmodifiableListMultimap(\n",
        "328": "          (ListMultimap<String, Integer>) multimap);\n",
        "337": "    UnmodifiableCollectionTests.assertIteratorIsUnmodifiable(\n",
        "338": "        unmodifiable.iterator());\n",
        "347": "    Multimap<String, Integer> multimap = Multimaps.invertFrom(empty,\n",
        "348": "        ArrayListMultimap.<String, Integer>create());\n",
        "351": "    ImmutableMultimap<Integer, String> single\n",
        "352": "        = new ImmutableMultimap.Builder<Integer, String>()\n",
        "353": "            .put(1, \"one\")\n",
        "354": "            .put(2, \"two\")\n",
        "355": "            .build();\n",
        "360": "    ImmutableMultimap<String, Integer> expected\n",
        "361": "        = new ImmutableMultimap.Builder<String, Integer>()\n",
        "362": "        .put(\"one\", 1)\n",
        "363": "        .put(\"two\", 2)\n",
        "364": "        .build();\n",
        "370": "    Multimap<String, Integer> multimap = Multimaps.newMultimap(\n",
        "371": "        new HashMap<String, Collection<Integer>>(), new QueueSupplier());\n",
        "389": "    SortedSetMultimap<String, Integer> sortedSetMultimap =\n",
        "390": "        TreeMultimap.create();\n",
        "403": "    new EqualsTester()\n",
        "404": "        .addEqualityGroup(multimap, multimapView)\n",
        "405": "        .addEqualityGroup(map)\n",
        "406": "        .testEquals();\n",
        "412": "    ListMultimap<String, Integer> listMultimap\n",
        "413": "        = new ImmutableListMultimap.Builder<String, Integer>()\n",
        "414": "            .put(\"foo\", 1).put(\"bar\", 2).build();\n",
        "415": "    assertFalse(\"SetMultimap equals ListMultimap\",\n",
        "416": "        multimapView.equals(listMultimap));\n",
        "428": "    } catch (UnsupportedOperationException expected) {}\n",
        "432": "    } catch (UnsupportedOperationException expected) {}\n",
        "436": "    } catch (UnsupportedOperationException expected) {}\n",
        "440": "    } catch (UnsupportedOperationException expected) {}\n",
        "500": "    assertFalse(entries.contains(Maps.immutableEntry(\"foo\",\n",
        "501": "        Collections.singletonList(1))));\n",
        "502": "    assertFalse(entries.remove(Maps.immutableEntry(\"foo\",\n",
        "503": "        Collections.singletonList(1))));\n",
        "504": "    assertFalse(entries.contains(Maps.immutableEntry(\"foo\",\n",
        "505": "        Sets.newLinkedHashSet(asList(1, 2)))));\n",
        "506": "    assertFalse(entries.remove(Maps.immutableEntry(\"foo\",\n",
        "507": "        Sets.newLinkedHashSet(asList(1, 2)))));\n",
        "508": "    assertFalse(entries.contains(Maps.immutableEntry(\"foo\",\n",
        "509": "        Collections.singleton(2))));\n",
        "510": "    assertFalse(entries.remove(Maps.immutableEntry(\"foo\",\n",
        "511": "        Collections.singleton(2))));\n",
        "513": "    assertTrue(entries.contains(Maps.immutableEntry(\"foo\",\n",
        "514": "        Collections.singleton(1))));\n",
        "515": "    assertTrue(entries.remove(Maps.immutableEntry(\"foo\",\n",
        "516": "        Collections.singleton(1))));\n",
        "522": "        new IteratorTester<Integer>(4, MODIFIABLE, newHashSet(1),\n",
        "523": "            IteratorTester.KnownOrder.KNOWN_ORDER) {\n",
        "526": "          @Override protected Iterator<Integer> newTargetIterator() {\n",
        "534": "          @Override protected void verify(List<Integer> elements) {\n",
        "542": "  private enum Color {BLUE, RED, YELLOW, GREEN}\n",
        "544": "  private abstract static class CountingSupplier<E>\n",
        "545": "      implements Supplier<E>, Serializable {\n",
        "558": "    @Override public Queue<Integer> getImpl() {\n",
        "565": "    CountingSupplier<Set<Integer>> factory = new SetSupplier() {\n",
        "566": "      @Override\n",
        "567": "      public Set<Integer> getImpl() {\n",
        "568": "        final Set<Integer> backing = super.getImpl();\n",
        "569": "        return new ForwardingSet<Integer>() {\n",
        "571": "          protected Set<Integer> delegate() {\n",
        "572": "            return backing;\n",
        "573": "          }\n",
        "574": "\n",
        "575": "          @Override\n",
        "576": "          public boolean add(Integer element) {\n",
        "577": "            checkArgument(element >= 0);\n",
        "578": "            return super.add(element);\n",
        "579": "          }\n",
        "580": "\n",
        "581": "          @Override\n",
        "582": "          public boolean addAll(Collection<? extends Integer> collection) {\n",
        "583": "            return standardAddAll(collection);\n",
        "586": "      }\n",
        "587": "    };\n",
        "603": "    assertThat(multimap.entries()).containsExactly(\n",
        "604": "        Maps.immutableEntry(Color.RED, 1),\n",
        "605": "        Maps.immutableEntry(Color.BLUE, 2));\n",
        "621": "    Multimap<Color, Integer> ummodifiable =\n",
        "622": "        Multimaps.unmodifiableMultimap(multimap);\n",
        "642": "  private static class ListSupplier extends\n",
        "643": "      CountingSupplier<LinkedList<Integer>> {\n",
        "644": "    @Override public LinkedList<Integer> getImpl() {\n",
        "653": "    ListMultimap<Color, Integer> multimap =\n",
        "654": "        Multimaps.newListMultimap(map, factory);\n",
        "678": "    @Override public Set<Integer> getImpl() {\n",
        "687": "    SetMultimap<Color, Integer> multimap =\n",
        "688": "        Multimaps.newSetMultimap(map, factory);\n",
        "707": "  private static class SortedSetSupplier extends\n",
        "708": "      CountingSupplier<TreeSet<Integer>> {\n",
        "709": "    @Override public TreeSet<Integer> getImpl() {\n",
        "718": "    SortedSetMultimap<Color, Integer> multimap =\n",
        "719": "        Multimaps.newSortedSetMultimap(map, factory);\n",
        "752": "        Multimaps.index(stringToObject.values(),\n",
        "753": "            Functions.toStringFunction());\n",
        "768": "        Multimaps.index(stringToObject.values().iterator(),\n",
        "769": "            Functions.toStringFunction());\n",
        "783": "    final List<String> badGuys =\n",
        "784": "        Arrays.asList(\"Inky\", \"Blinky\", \"Pinky\", \"Pinky\", \"Clyde\");\n",
        "793": "    Multimap<Integer, String> index =\n",
        "794": "        Multimaps.index(badGuys, stringLengthFunction);\n",
        "821": "    Function<Integer, Integer> square = new Function<Integer, Integer>() {\n",
        "822": "      @Override\n",
        "823": "      public Integer apply(Integer in) {\n",
        "824": "        return in * in;\n",
        "825": "      }\n",
        "826": "    };\n",
        "828": "    assertThat(transformed.entries()).containsExactly(immutableEntry(\"a\", 4),\n",
        "829": "        immutableEntry(\"a\", 16), immutableEntry(\"b\", 9), immutableEntry(\"b\", 9),\n",
        "830": "        immutableEntry(\"c\", 36)).inOrder();\n",
        "838": "        Multimaps.transformValues(multimap, new Function<String, Integer>() {\n",
        "839": "\n",
        "840": "          @Override public Integer apply(String str) {\n",
        "841": "            return str.length();\n",
        "842": "          }\n",
        "843": "        });\n",
        "853": "    Function<Integer, Integer> square = new Function<Integer, Integer>() {\n",
        "854": "      @Override\n",
        "855": "      public Integer apply(Integer in) {\n",
        "856": "        return in * in;\n",
        "857": "      }\n",
        "858": "    };\n",
        "859": "    ListMultimap<String, Integer> transformed =\n",
        "860": "        Multimaps.transformValues(multimap, square);\n",
        "861": "    assertThat(transformed.entries()).containsExactly(immutableEntry(\"a\", 4),\n",
        "862": "        immutableEntry(\"a\", 16), immutableEntry(\"b\", 9), immutableEntry(\"b\", 9),\n",
        "863": "        immutableEntry(\"c\", 36)).inOrder();\n",
        "868": "    SetMultimap<String, Integer> multimap =\n",
        "869": "        ImmutableSetMultimap.of(\"a\", 1, \"a\", 4, \"b\", -6);\n",
        "877": "    Multimap<String, String> transformed =\n",
        "878": "        Multimaps.transformEntries(multimap, transformer);\n",
        "879": "    assertThat(transformed.entries()).containsExactly(immutableEntry(\"a\", \"a\"),\n",
        "880": "        immutableEntry(\"a\", \"a\"), immutableEntry(\"b\", \"nob\")).inOrder();\n",
        "894": "    ListMultimap<String, String> transformed =\n",
        "895": "        Multimaps.transformEntries(multimap, transformer);\n",
        "896": "    assertEquals(\n",
        "897": "        ImmutableListMultimap.of(\"a\", \"a1\", \"a\", \"a4\", \"a\", \"a4\", \"b\", \"b6\"),\n",
        "898": "        transformed);\n",
        "905": "    Multimap<K, V> multimap = Multimaps.synchronizedMultimap(\n",
        "906": "        HashMultimap.<K, V>create());\n",
        "907": "    Collection<V> values = multimap.get(key);  // Needn't be in synchronized block\n",
        "908": "    synchronized (multimap) {  // Synchronizing on multimap, not values!\n",
        "925": "    SetMultimap<String, Integer> filtered = Multimaps.filterKeys(\n",
        "926": "        multimap, Predicates.in(ImmutableSet.of(\"foo\", \"bar\")));\n",
        "928": "    assertEquals(\n",
        "929": "        ImmutableSet.of(),\n",
        "930": "        filtered.replaceValues(\"baz\", ImmutableSet.<Integer>of()));\n",
        "946": "    SetMultimap<String, Integer> filtered = Multimaps.filterKeys(\n",
        "947": "        multimap, Predicates.in(ImmutableSet.of(\"foo\", \"bar\")));\n",
        "969": "    ListMultimap<String, Integer> filtered = Multimaps.filterKeys(\n",
        "970": "        multimap, Predicates.in(ImmutableSet.of(\"foo\", \"bar\")));\n"
    }
}