{
    "addition": {
        "33": " * Abstract test case parent for anything implementing {@link ListenableFuture}. Tests the two get\n",
        "34": " * methods and the addListener method.\n",
        "61": "  /** Constructs a listenable future with a value available after the latch has counted down. */\n",
        "65": "  /** Tests that the {@link Future#get()} method blocks until a value is available. */\n",
        "75": "    new Thread(\n",
        "76": "            new Runnable() {\n",
        "77": "              @Override\n",
        "78": "              public void run() {\n",
        "79": "                try {\n",
        "80": "                  assertSame(Boolean.TRUE, future.get());\n",
        "81": "                  successLatch.countDown();\n",
        "82": "                } catch (Throwable t) {\n",
        "83": "                  t.printStackTrace();\n",
        "84": "                  badness[0] = t;\n",
        "85": "                }\n",
        "86": "              }\n",
        "87": "            })\n",
        "88": "        .start();\n",
        "103": "  /** Tests that the {@link Future#get(long, TimeUnit)} method times out correctly. */\n",
        "104": "  public void testTimeoutOnGetWorksCorrectly() throws InterruptedException, ExecutionException {\n",
        "119": "   * <p>This method checks the cancel, isCancelled, and isDone methods.\n",
        "129": "    new Thread(\n",
        "130": "            new Runnable() {\n",
        "131": "              @Override\n",
        "132": "              public void run() {\n",
        "133": "                try {\n",
        "134": "                  future.get();\n",
        "135": "                } catch (CancellationException expected) {\n",
        "136": "                  successLatch.countDown();\n",
        "137": "                } catch (Exception ignored) {\n",
        "138": "                  // All other errors are ignored, we expect a cancellation.\n",
        "139": "                }\n",
        "140": "              }\n",
        "141": "            })\n",
        "142": "        .start();\n",
        "163": "    future.addListener(\n",
        "164": "        new Runnable() {\n",
        "165": "          @Override\n",
        "166": "          public void run() {\n",
        "167": "            listenerLatch.countDown();\n",
        "168": "          }\n",
        "169": "        },\n",
        "170": "        exec);\n",
        "171": "\n",
        "172": "    new Thread(\n",
        "173": "            new Runnable() {\n",
        "174": "              @Override\n",
        "175": "              public void run() {\n",
        "176": "                try {\n",
        "177": "                  future.get();\n",
        "178": "                } catch (CancellationException expected) {\n",
        "179": "                  successLatch.countDown();\n",
        "180": "                } catch (Exception ignored) {\n",
        "181": "                  // No success latch count down.\n",
        "182": "                }\n",
        "183": "              }\n",
        "184": "            })\n",
        "185": "        .start();\n",
        "202": "   * Tests that all listeners complete, even if they were added before or after the future was\n",
        "203": "   * finishing. Also acts as a concurrency test to make sure the locking is done correctly when a\n",
        "204": "   * future is finishing so that no listeners can be lost.\n",
        "220": "        new Thread(\n",
        "221": "                new Runnable() {\n",
        "222": "                  @Override\n",
        "223": "                  public void run() {\n",
        "224": "                    latch.countDown();\n",
        "225": "                  }\n",
        "226": "                })\n",
        "227": "            .start();\n",
        "230": "      future.addListener(\n",
        "231": "          new Runnable() {\n",
        "232": "            @Override\n",
        "233": "            public void run() {\n",
        "234": "              listenerLatch.countDown();\n",
        "235": "            }\n",
        "236": "          },\n",
        "237": "          exec);\n"
    },
    "removed": {
        "33": " * Abstract test case parent for anything implementing {@link ListenableFuture}.\n",
        "34": " * Tests the two get methods and the addListener method.\n",
        "61": "  /**\n",
        "62": "   * Constructs a listenable future with a value available after the latch\n",
        "63": "   * has counted down.\n",
        "64": "   */\n",
        "68": "  /**\n",
        "69": "   * Tests that the {@link Future#get()} method blocks until a value is\n",
        "70": "   * available.\n",
        "71": "   */\n",
        "81": "    new Thread(new Runnable() {\n",
        "82": "      @Override\n",
        "83": "      public void run() {\n",
        "84": "        try {\n",
        "85": "          assertSame(Boolean.TRUE, future.get());\n",
        "86": "          successLatch.countDown();\n",
        "87": "        } catch (Throwable t) {\n",
        "88": "          t.printStackTrace();\n",
        "89": "          badness[0] = t;\n",
        "90": "        }\n",
        "91": "      }}).start();\n",
        "106": "  /**\n",
        "107": "   * Tests that the {@link Future#get(long, TimeUnit)} method times out\n",
        "108": "   * correctly.\n",
        "109": "   */\n",
        "110": "  public void testTimeoutOnGetWorksCorrectly() throws InterruptedException,\n",
        "111": "      ExecutionException {\n",
        "126": "   * This method checks the cancel, isCancelled, and isDone methods.\n",
        "136": "    new Thread(new Runnable() {\n",
        "137": "      @Override\n",
        "138": "      public void run() {\n",
        "139": "        try {\n",
        "140": "          future.get();\n",
        "141": "        } catch (CancellationException expected) {\n",
        "142": "          successLatch.countDown();\n",
        "143": "        } catch (Exception ignored) {\n",
        "144": "          // All other errors are ignored, we expect a cancellation.\n",
        "145": "        }\n",
        "146": "      }\n",
        "147": "    }).start();\n",
        "168": "    future.addListener(new Runnable() {\n",
        "169": "      @Override\n",
        "170": "      public void run() {\n",
        "171": "        listenerLatch.countDown();\n",
        "172": "      }\n",
        "173": "    }, exec);\n",
        "174": "\n",
        "175": "    new Thread(new Runnable() {\n",
        "176": "      @Override\n",
        "177": "      public void run() {\n",
        "178": "        try {\n",
        "179": "          future.get();\n",
        "180": "        } catch (CancellationException expected) {\n",
        "181": "          successLatch.countDown();\n",
        "182": "        } catch (Exception ignored) {\n",
        "183": "          // No success latch count down.\n",
        "184": "        }\n",
        "185": "      }\n",
        "186": "    }).start();\n",
        "203": "   * Tests that all listeners complete, even if they were added before or after\n",
        "204": "   * the future was finishing.  Also acts as a concurrency test to make sure the\n",
        "205": "   * locking is done correctly when a future is finishing so that no listeners\n",
        "206": "   * can be lost.\n",
        "222": "        new Thread(new Runnable() {\n",
        "223": "          @Override\n",
        "224": "          public void run() {\n",
        "225": "            latch.countDown();\n",
        "226": "          }\n",
        "227": "        }).start();\n",
        "230": "      future.addListener(new Runnable() {\n",
        "231": "        @Override\n",
        "232": "        public void run() {\n",
        "233": "          listenerLatch.countDown();\n",
        "234": "        }\n",
        "235": "      }, exec);\n"
    }
}