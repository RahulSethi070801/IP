{
    "addition": {
        "36": " * href=\"http://en.wikipedia.org/wiki/Monitor_(synchronization)#Implicit_signaling\">implicit</a>. By\n",
        "37": " * eliminating explicit signaling, this class can guarantee that only one thread is awakened when a\n",
        "38": " * condition becomes true (no \"signaling storms\" due to use of {@link\n",
        "51": " * monitor cleanly:\n",
        "53": " * <pre>{@code\n",
        "54": " * monitor.enter();\n",
        "55": " * try {\n",
        "56": " *   // do things while occupying the monitor\n",
        "57": " * } finally {\n",
        "58": " *   monitor.leave();\n",
        "59": " * }\n",
        "60": " * }</pre>\n",
        "64": " * the current thread leaves the monitor cleanly:\n",
        "66": " * <pre>{@code\n",
        "67": " * if (monitor.tryEnter()) {\n",
        "68": " *   try {\n",
        "69": " *     // do things while occupying the monitor\n",
        "70": " *   } finally {\n",
        "71": " *     monitor.leave();\n",
        "72": " *   }\n",
        "73": " * } else {\n",
        "74": " *   // do other things since the monitor was not available\n",
        "75": " * }\n",
        "76": " * }</pre>\n",
        "89": " * logical conditions being awaited.\n",
        "91": " * <pre>{@code\n",
        "92": " * public class SafeBox<V> {\n",
        "93": " *   private V value;\n",
        "95": " *   public synchronized V get() throws InterruptedException {\n",
        "96": " *     while (value == null) {\n",
        "97": " *       wait();\n",
        "99": " *     V result = value;\n",
        "100": " *     value = null;\n",
        "101": " *     notifyAll();\n",
        "102": " *     return result;\n",
        "103": " *   }\n",
        "105": " *   public synchronized void set(V newValue) throws InterruptedException {\n",
        "106": " *     while (value != null) {\n",
        "107": " *       wait();\n",
        "109": " *     value = newValue;\n",
        "110": " *     notifyAll();\n",
        "111": " *   }\n",
        "112": " * }\n",
        "113": " * }</pre>\n",
        "118": " * from the need for the programmer to remember to use {@code while} instead of {@code if}. However,\n",
        "119": " * one advantage is that we can introduce two separate {@code Condition} objects, which allows us to\n",
        "120": " * use {@code signal()} instead of {@code signalAll()}, which may be a performance benefit.\n",
        "122": " * <pre>{@code\n",
        "123": " * public class SafeBox<V> {\n",
        "124": " *   private final ReentrantLock lock = new ReentrantLock();\n",
        "125": " *   private final Condition valuePresent = lock.newCondition();\n",
        "126": " *   private final Condition valueAbsent = lock.newCondition();\n",
        "127": " *   private V value;\n",
        "129": " *   public V get() throws InterruptedException {\n",
        "130": " *     lock.lock();\n",
        "131": " *     try {\n",
        "132": " *       while (value == null) {\n",
        "133": " *         valuePresent.await();\n",
        "135": " *       V result = value;\n",
        "136": " *       value = null;\n",
        "137": " *       valueAbsent.signal();\n",
        "138": " *       return result;\n",
        "139": " *     } finally {\n",
        "140": " *       lock.unlock();\n",
        "142": " *   }\n",
        "144": " *   public void set(V newValue) throws InterruptedException {\n",
        "145": " *     lock.lock();\n",
        "146": " *     try {\n",
        "147": " *       while (value != null) {\n",
        "148": " *         valueAbsent.await();\n",
        "150": " *       value = newValue;\n",
        "151": " *       valuePresent.signal();\n",
        "152": " *     } finally {\n",
        "153": " *       lock.unlock();\n",
        "155": " *   }\n",
        "156": " * }\n",
        "157": " * }</pre>\n",
        "165": " * remember to use {@code while} instead of {@code if}.\n",
        "167": " * <pre>{@code\n",
        "168": " * public class SafeBox<V> {\n",
        "169": " *   private final Monitor monitor = new Monitor();\n",
        "170": " *   private final Monitor.Guard valuePresent = new Monitor.Guard(monitor) {\n",
        "171": " *     public boolean isSatisfied() {\n",
        "172": " *       return value != null;\n",
        "173": " *     }\n",
        "174": " *   };\n",
        "175": " *   private final Monitor.Guard valueAbsent = new Monitor.Guard(monitor) {\n",
        "176": " *     public boolean isSatisfied() {\n",
        "177": " *       return value == null;\n",
        "178": " *     }\n",
        "179": " *   };\n",
        "180": " *   private V value;\n",
        "182": " *   public V get() throws InterruptedException {\n",
        "183": " *     monitor.enterWhen(valuePresent);\n",
        "184": " *     try {\n",
        "185": " *       V result = value;\n",
        "186": " *       value = null;\n",
        "187": " *       return result;\n",
        "188": " *     } finally {\n",
        "189": " *       monitor.leave();\n",
        "191": " *   }\n",
        "193": " *   public void set(V newValue) throws InterruptedException {\n",
        "194": " *     monitor.enterWhen(valueAbsent);\n",
        "195": " *     try {\n",
        "196": " *       value = newValue;\n",
        "197": " *     } finally {\n",
        "198": " *       monitor.leave();\n",
        "200": " *   }\n",
        "201": " * }\n",
        "202": " * }</pre>\n",
        "337": "  /** Whether this monitor is fair. */\n",
        "340": "  /** The lock underlying this monitor. */\n",
        "370": "   * Creates a new {@link Guard} for {@code this} monitor. @Param isSatisfied The guards boolean\n",
        "371": "   * condition. See {@link Guard#isSatisfied}.\n",
        "383": "  /** Enters this monitor. Blocks indefinitely. */\n",
        "473": "  /** Enters this monitor when the guard is satisfied. Blocks indefinitely. */\n",
        "830": "  /** Leaves this monitor. May be called only by a thread currently occupying this monitor. */\n",
        "843": "  /** Returns whether this monitor is using a fair ordering policy. */\n",
        "973": "   * <p>We manage calls to this method carefully, to signal only when necessary, but never losing a\n",
        "978": "   * <p>In addition, any thread that has been signalled when its guard was satisfied acquires the\n",
        "984": "   * <p>On the other hand, if a signalled thread wakes up to discover that its guard is still not\n",
        "991": "   * <p>This method must not be called from within a beginWaitingFor/endWaitingFor block, or else\n",
        "992": "   * the current thread's guard might be mistakenly signalled, leading to a lost signal.\n",
        "1009": "   * <p>We decided against using this method, since in practice, isSatisfied() is likely to be very\n",
        "1012": "  //   @GuardedBy(\"lock\")\n",
        "1013": "  //   private void signalNextWaiterSkipping(Guard guardToSkip) {\n",
        "1014": "  //     for (Guard guard = activeGuards; guard != null; guard = guard.next) {\n",
        "1015": "  //       if (guard != guardToSkip && isSatisfied(guard)) {\n",
        "1016": "  //         guard.condition.signal();\n",
        "1017": "  //         break;\n",
        "1018": "  //       }\n",
        "1019": "  //     }\n",
        "1020": "  //   }\n",
        "1036": "  /** Signals all threads waiting on guards. */\n",
        "1044": "  /** Records that the current thread is about to wait on the specified guard. */\n",
        "1055": "  /** Records that the current thread is no longer waiting on the specified guard. */\n",
        "1111": "  /** Caller should check before calling that guard is not satisfied. */\n"
    },
    "removed": {
        "36": " * href=\"http://en.wikipedia.org/wiki/Monitor_(synchronization)#Implicit_signaling\">implicit</a>.\n",
        "37": " * By eliminating explicit signaling, this class can guarantee that only one thread is awakened when\n",
        "38": " * a condition becomes true (no \"signaling storms\" due to use of {@link\n",
        "51": " * monitor cleanly: <pre>   {@code\n",
        "53": " *   monitor.enter();\n",
        "54": " *   try {\n",
        "55": " *     // do things while occupying the monitor\n",
        "56": " *   } finally {\n",
        "57": " *     monitor.leave();\n",
        "58": " *   }}</pre>\n",
        "62": " * the current thread leaves the monitor cleanly: <pre>   {@code\n",
        "64": " *   if (monitor.tryEnter()) {\n",
        "65": " *     try {\n",
        "66": " *       // do things while occupying the monitor\n",
        "67": " *     } finally {\n",
        "68": " *       monitor.leave();\n",
        "69": " *     }\n",
        "70": " *   } else {\n",
        "71": " *     // do other things since the monitor was not available\n",
        "72": " *   }}</pre>\n",
        "85": " * logical conditions being awaited. <pre>   {@code\n",
        "87": " *   public class SafeBox<V> {\n",
        "88": " *     private V value;\n",
        "90": " *     public synchronized V get() throws InterruptedException {\n",
        "91": " *       while (value == null) {\n",
        "92": " *         wait();\n",
        "93": " *       }\n",
        "94": " *       V result = value;\n",
        "95": " *       value = null;\n",
        "96": " *       notifyAll();\n",
        "97": " *       return result;\n",
        "100": " *     public synchronized void set(V newValue) throws InterruptedException {\n",
        "101": " *       while (value != null) {\n",
        "102": " *         wait();\n",
        "103": " *       }\n",
        "104": " *       value = newValue;\n",
        "105": " *       notifyAll();\n",
        "107": " *   }}</pre>\n",
        "112": " * from the need for the programmer to remember to use {@code while} instead of {@code if}.\n",
        "113": " * However, one advantage is that we can introduce two separate {@code Condition} objects, which\n",
        "114": " * allows us to use {@code signal()} instead of {@code signalAll()}, which may be a performance\n",
        "115": " * benefit. <pre>   {@code\n",
        "117": " *   public class SafeBox<V> {\n",
        "118": " *     private final ReentrantLock lock = new ReentrantLock();\n",
        "119": " *     private final Condition valuePresent = lock.newCondition();\n",
        "120": " *     private final Condition valueAbsent = lock.newCondition();\n",
        "121": " *     private V value;\n",
        "123": " *     public V get() throws InterruptedException {\n",
        "124": " *       lock.lock();\n",
        "125": " *       try {\n",
        "126": " *         while (value == null) {\n",
        "127": " *           valuePresent.await();\n",
        "128": " *         }\n",
        "129": " *         V result = value;\n",
        "130": " *         value = null;\n",
        "131": " *         valueAbsent.signal();\n",
        "132": " *         return result;\n",
        "133": " *       } finally {\n",
        "134": " *         lock.unlock();\n",
        "138": " *     public void set(V newValue) throws InterruptedException {\n",
        "139": " *       lock.lock();\n",
        "140": " *       try {\n",
        "141": " *         while (value != null) {\n",
        "142": " *           valueAbsent.await();\n",
        "143": " *         }\n",
        "144": " *         value = newValue;\n",
        "145": " *         valuePresent.signal();\n",
        "146": " *       } finally {\n",
        "147": " *         lock.unlock();\n",
        "150": " *   }}</pre>\n",
        "158": " * remember to use {@code while} instead of {@code if}. <pre>   {@code\n",
        "160": " *   public class SafeBox<V> {\n",
        "161": " *     private final Monitor monitor = new Monitor();\n",
        "162": " *     private final Monitor.Guard valuePresent = new Monitor.Guard(monitor) {\n",
        "163": " *       public boolean isSatisfied() {\n",
        "164": " *         return value != null;\n",
        "165": " *       }\n",
        "166": " *     };\n",
        "167": " *     private final Monitor.Guard valueAbsent = new Monitor.Guard(monitor) {\n",
        "168": " *       public boolean isSatisfied() {\n",
        "169": " *         return value == null;\n",
        "170": " *       }\n",
        "171": " *     };\n",
        "172": " *     private V value;\n",
        "174": " *     public V get() throws InterruptedException {\n",
        "175": " *       monitor.enterWhen(valuePresent);\n",
        "176": " *       try {\n",
        "177": " *         V result = value;\n",
        "178": " *         value = null;\n",
        "179": " *         return result;\n",
        "180": " *       } finally {\n",
        "181": " *         monitor.leave();\n",
        "182": " *       }\n",
        "185": " *     public void set(V newValue) throws InterruptedException {\n",
        "186": " *       monitor.enterWhen(valueAbsent);\n",
        "187": " *       try {\n",
        "188": " *         value = newValue;\n",
        "189": " *       } finally {\n",
        "190": " *         monitor.leave();\n",
        "191": " *       }\n",
        "193": " *   }}</pre>\n",
        "328": "  /**\n",
        "329": "   * Whether this monitor is fair.\n",
        "330": "   */\n",
        "333": "  /**\n",
        "334": "   * The lock underlying this monitor.\n",
        "335": "   */\n",
        "365": "   * Creates a new {@link Guard} for {@code this} monitor.\n",
        "366": "   *\n",
        "367": "   * @Param isSatisfied The guards boolean condition.  See {@link Guard#isSatisfied}.\n",
        "379": "  /**\n",
        "380": "   * Enters this monitor. Blocks indefinitely.\n",
        "381": "   */\n",
        "471": "  /**\n",
        "472": "   * Enters this monitor when the guard is satisfied. Blocks indefinitely.\n",
        "473": "   */\n",
        "830": "  /**\n",
        "831": "   * Leaves this monitor. May be called only by a thread currently occupying this monitor.\n",
        "832": "   */\n",
        "845": "  /**\n",
        "846": "   * Returns whether this monitor is using a fair ordering policy.\n",
        "847": "   */\n",
        "977": "   * We manage calls to this method carefully, to signal only when necessary, but never losing a\n",
        "982": "   * In addition, any thread that has been signalled when its guard was satisfied acquires the\n",
        "988": "   * On the other hand, if a signalled thread wakes up to discover that its guard is still not\n",
        "995": "   * This method must not be called from within a beginWaitingFor/endWaitingFor block, or else the\n",
        "996": "   * current thread's guard might be mistakenly signalled, leading to a lost signal.\n",
        "1013": "   * We decided against using this method, since in practice, isSatisfied() is likely to be very\n",
        "1016": "//   @GuardedBy(\"lock\")\n",
        "1017": "//   private void signalNextWaiterSkipping(Guard guardToSkip) {\n",
        "1018": "//     for (Guard guard = activeGuards; guard != null; guard = guard.next) {\n",
        "1019": "//       if (guard != guardToSkip && isSatisfied(guard)) {\n",
        "1020": "//         guard.condition.signal();\n",
        "1021": "//         break;\n",
        "1022": "//       }\n",
        "1023": "//     }\n",
        "1024": "//   }\n",
        "1040": "  /**\n",
        "1041": "   * Signals all threads waiting on guards.\n",
        "1042": "   */\n",
        "1050": "  /**\n",
        "1051": "   * Records that the current thread is about to wait on the specified guard.\n",
        "1052": "   */\n",
        "1063": "  /**\n",
        "1064": "   * Records that the current thread is no longer waiting on the specified guard.\n",
        "1065": "   */\n",
        "1121": "  /**\n",
        "1122": "   * Caller should check before calling that guard is not satisfied.\n",
        "1123": "   */\n"
    }
}