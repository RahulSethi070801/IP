{
    "addition": {
        "81": " *\n",
        "82": " * <pre>{@code\n",
        "113": " * }\n",
        "114": " * }</pre>\n",
        "153": "   * that need to listen to more fine-grained events (such as when each particular {@linkplain\n",
        "154": "   * Service service} starts, or terminates), should attach {@linkplain Service.Listener service\n",
        "155": "   * listeners} to each individual service.\n",
        "165": "     * <p>This will be called at most once after all the services have entered the {@linkplain\n",
        "166": "     * State#RUNNING running} state. If any services fail during start up or {@linkplain\n",
        "167": "     * State#FAILED fail}/{@linkplain State#TERMINATED terminate} before all other services have\n",
        "168": "     * started {@linkplain State#RUNNING running} then this method will not be called.\n",
        "189": "   * be made {@code static} and its instances can be safely constructed and added in the {@link\n",
        "190": "   * ServiceManager} constructor without having to close over the partially constructed {@link\n",
        "191": "   * ServiceManager} instance (i.e. avoid leaking a pointer to {@code this}).\n",
        "194": "\n",
        "348": "   * services will either be {@linkplain Service.State#TERMINATED terminated} or {@linkplain\n",
        "349": "   * Service.State#FAILED failed}.\n",
        "472": "    /** Controls how long to wait for all services to reach a terminal state. */\n",
        "503": "     * Attempts to start the timer immediately prior to the service being started via {@link\n",
        "504": "     * Service#startAsync()}.\n",
        "641": "     *\n",
        "643": "     *   <li>Update the {@link #servicesByState()}\n",
        "644": "     *   <li>Update the {@link #startupTimers}\n",
        "645": "     *   <li>Based on the new state queue listeners to run\n",
        "646": "     *   <li>Run the listeners (outside of the lock)\n"
    },
    "removed": {
        "80": " * <pre>   {@code\n",
        "111": " * }}</pre>\n",
        "150": "   * that need to listen to more fine-grained events (such as when each particular\n",
        "151": "   * {@linkplain Service service} starts, or terminates), should attach {@linkplain Service.Listener\n",
        "152": "   * service listeners} to each individual service.\n",
        "162": "     * <p>This will be called at most once after all the services have entered the\n",
        "163": "     * {@linkplain State#RUNNING running} state. If any services fail during start up or\n",
        "164": "     * {@linkplain State#FAILED fail}/{@linkplain State#TERMINATED terminate} before all other\n",
        "165": "     * services have started {@linkplain State#RUNNING running} then this method will not be called.\n",
        "186": "   * be made {@code static} and its instances can be safely constructed and added in the\n",
        "187": "   * {@link ServiceManager} constructor without having to close over the partially constructed\n",
        "188": "   * {@link ServiceManager} instance (i.e. avoid leaking a pointer to {@code this}).\n",
        "197": "   *\n",
        "345": "   * services will either be {@linkplain Service.State#TERMINATED terminated} or\n",
        "346": "   * {@linkplain Service.State#FAILED failed}.\n",
        "469": "    /**\n",
        "470": "     * Controls how long to wait for all services to reach a terminal state.\n",
        "471": "     */\n",
        "502": "     * Attempts to start the timer immediately prior to the service being started via\n",
        "503": "     * {@link Service#startAsync()}.\n",
        "641": "     * <li>Update the {@link #servicesByState()}\n",
        "642": "     * <li>Update the {@link #startupTimers}\n",
        "643": "     * <li>Based on the new state queue listeners to run\n",
        "644": "     * <li>Run the listeners (outside of the lock)\n"
    }
}