{
    "addition": {
        "58": "    CycleDetectingLockFactory factory = CycleDetectingLockFactory.newInstance(Policies.THROW);\n",
        "62": "    ReentrantReadWriteLock readWriteLockA = factory.newReentrantReadWriteLock(\"ReadWriteA\");\n",
        "63": "    ReentrantReadWriteLock readWriteLockB = factory.newReentrantReadWriteLock(\"ReadWriteB\");\n",
        "64": "    ReentrantReadWriteLock readWriteLockC = factory.newReentrantReadWriteLock(\"ReadWriteC\");\n",
        "88": "  private <E extends Enum<E>>\n",
        "89": "      CycleDetectingLockFactory.WithExplicitOrdering<E> newInstanceWithExplicitOrdering(\n",
        "90": "          Class<E> enumClass, Policy policy) {\n",
        "146": "      checkMessage(expected, \"LockC -> LockA\", \"LockB -> LockC\", \"LockA -> LockB\");\n",
        "153": "    lockA.lock(); // Should not assert on lockB -> reentrant(lockA)\n",
        "192": "    lock3.lock(); // MyOrder, ordinal() == 3\n",
        "193": "    lock01.lock(); // OtherOrder, ordinal() == 1\n",
        "197": "    lock3.lock(); // MyOrder, ordinal() == 3\n",
        "198": "    lock01.lock(); // OtherOrder, ordinal() == 1\n",
        "206": "          expected, \"OtherOrder.FIRST -> MyOrder.THIRD\", \"MyOrder.THIRD -> OtherOrder.FIRST\");\n",
        "219": "          expected, \"LockB -> OtherOrder.FIRST\", \"LockA -> LockB\", \"OtherOrder.FIRST -> LockA\");\n",
        "224": "    Lock myLock = CycleDetectingLockFactory.newInstance(Policies.THROW).newReentrantLock(\"MyLock\");\n",
        "275": "    readLockA.lock(); // Establish an ordering from readLockA -> lockB.\n",
        "290": "    readLockA.lock(); // Establish an ordering from readLockA -> lockB.\n",
        "308": "          expected, \"ReadWriteC -> ReadWriteA\", \"LockB -> ReadWriteC\", \"ReadWriteA -> LockB\");\n",
        "338": "    writeLockA.lock(); // writeLockA downgrades to readLockA\n",
        "342": "    lockB.lock(); // readLockA -> lockB\n",
        "350": "      checkMessage(expected, \"LockB -> ReadWriteA\", \"ReadWriteA -> LockB\");\n",
        "355": "    writeLockA.lock(); // Establish an ordering from writeLockA -> lockB\n",
        "366": "      checkMessage(expected, \"LockB -> ReadWriteA\", \"ReadWriteA -> LockB\");\n",
        "371": "    readLockA.lock(); // Establish an ordering from readLockA -> lockB\n",
        "388": "      checkMessage(expected, \"LockC -> ReadWriteA\", \"LockB -> LockC\", \"ReadWriteA -> LockB\");\n",
        "393": "    readLockA.lock(); // readLockA -> writeLockB\n",
        "404": "      checkMessage(expected, \"ReadWriteB -> ReadWriteA\", \"ReadWriteA -> ReadWriteB\");\n",
        "409": "    CycleDetectingLockFactory otherFactory = CycleDetectingLockFactory.newInstance(Policies.WARN);\n",
        "429": "    CycleDetectingLockFactory otherFactory = CycleDetectingLockFactory.newInstance(Policies.WARN);\n",
        "517": "        \"Unexpected number of public methods in ReentrantReadWriteLock. \"\n",
        "518": "            + \"The correctness of CycleDetectingReentrantReadWriteLock depends on \"\n",
        "519": "            + \"the fact that the shadowed ReadLock and WriteLock are never used or \"\n",
        "520": "            + \"exposed by the superclass implementation. If the implementation has \"\n",
        "521": "            + \"changed, the code must be re-inspected to ensure that the \"\n",
        "522": "            + \"assumption is still valid.\",\n",
        "523": "        24,\n",
        "524": "        ReentrantReadWriteLock.class.getMethods().length);\n",
        "528": "    FIRST,\n",
        "529": "    SECOND,\n",
        "530": "    THIRD;\n",
        "534": "    FIRST,\n",
        "535": "    SECOND,\n",
        "536": "    THIRD;\n",
        "543": "  private void checkMessage(IllegalStateException exception, String... expectedLockCycle) {\n",
        "554": "      fail(\"expected to contain regex:<\" + expectedRegex + \"> but was:\" + actualDesc);\n"
    },
    "removed": {
        "58": "    CycleDetectingLockFactory factory =\n",
        "59": "        CycleDetectingLockFactory.newInstance(Policies.THROW);\n",
        "63": "    ReentrantReadWriteLock readWriteLockA =\n",
        "64": "        factory.newReentrantReadWriteLock(\"ReadWriteA\");\n",
        "65": "    ReentrantReadWriteLock readWriteLockB =\n",
        "66": "        factory.newReentrantReadWriteLock(\"ReadWriteB\");\n",
        "67": "    ReentrantReadWriteLock readWriteLockC =\n",
        "68": "        factory.newReentrantReadWriteLock(\"ReadWriteC\");\n",
        "92": "  private <E extends Enum<E>> CycleDetectingLockFactory.WithExplicitOrdering<E>\n",
        "93": "      newInstanceWithExplicitOrdering(Class<E> enumClass, Policy policy) {\n",
        "149": "      checkMessage(\n",
        "150": "          expected, \"LockC -> LockA\", \"LockB -> LockC\", \"LockA -> LockB\");\n",
        "157": "    lockA.lock();  // Should not assert on lockB -> reentrant(lockA)\n",
        "196": "    lock3.lock();   // MyOrder, ordinal() == 3\n",
        "197": "    lock01.lock();  // OtherOrder, ordinal() == 1\n",
        "201": "    lock3.lock();   // MyOrder, ordinal() == 3\n",
        "202": "    lock01.lock();  // OtherOrder, ordinal() == 1\n",
        "210": "          expected,\n",
        "211": "          \"OtherOrder.FIRST -> MyOrder.THIRD\",\n",
        "212": "          \"MyOrder.THIRD -> OtherOrder.FIRST\");\n",
        "225": "          expected,\n",
        "226": "          \"LockB -> OtherOrder.FIRST\",\n",
        "227": "          \"LockA -> LockB\",\n",
        "228": "          \"OtherOrder.FIRST -> LockA\");\n",
        "233": "    Lock myLock = CycleDetectingLockFactory.newInstance(Policies.THROW)\n",
        "234": "        .newReentrantLock(\"MyLock\");\n",
        "285": "    readLockA.lock();  // Establish an ordering from readLockA -> lockB.\n",
        "300": "    readLockA.lock();  // Establish an ordering from readLockA -> lockB.\n",
        "318": "          expected,\n",
        "319": "          \"ReadWriteC -> ReadWriteA\",\n",
        "320": "          \"LockB -> ReadWriteC\",\n",
        "321": "          \"ReadWriteA -> LockB\");\n",
        "351": "    writeLockA.lock();  // writeLockA downgrades to readLockA\n",
        "355": "    lockB.lock();  // readLockA -> lockB\n",
        "363": "      checkMessage(\n",
        "364": "          expected, \"LockB -> ReadWriteA\", \"ReadWriteA -> LockB\");\n",
        "369": "    writeLockA.lock();  // Establish an ordering from writeLockA -> lockB\n",
        "380": "      checkMessage(\n",
        "381": "          expected, \"LockB -> ReadWriteA\", \"ReadWriteA -> LockB\");\n",
        "386": "    readLockA.lock();  // Establish an ordering from readLockA -> lockB\n",
        "403": "      checkMessage(\n",
        "404": "          expected,\n",
        "405": "          \"LockC -> ReadWriteA\",\n",
        "406": "          \"LockB -> LockC\",\n",
        "407": "          \"ReadWriteA -> LockB\");\n",
        "412": "    readLockA.lock();  // readLockA -> writeLockB\n",
        "423": "      checkMessage(\n",
        "424": "          expected, \"ReadWriteB -> ReadWriteA\", \"ReadWriteA -> ReadWriteB\");\n",
        "429": "    CycleDetectingLockFactory otherFactory =\n",
        "430": "        CycleDetectingLockFactory.newInstance(Policies.WARN);\n",
        "450": "    CycleDetectingLockFactory otherFactory =\n",
        "451": "        CycleDetectingLockFactory.newInstance(Policies.WARN);\n",
        "539": "        \"Unexpected number of public methods in ReentrantReadWriteLock. \" +\n",
        "540": "        \"The correctness of CycleDetectingReentrantReadWriteLock depends on \" +\n",
        "541": "        \"the fact that the shadowed ReadLock and WriteLock are never used or \" +\n",
        "542": "        \"exposed by the superclass implementation. If the implementation has \" +\n",
        "543": "        \"changed, the code must be re-inspected to ensure that the \" +\n",
        "544": "        \"assumption is still valid.\",\n",
        "545": "        24, ReentrantReadWriteLock.class.getMethods().length);\n",
        "549": "    FIRST, SECOND, THIRD;\n",
        "553": "    FIRST, SECOND, THIRD;\n",
        "560": "  private void checkMessage(\n",
        "561": "      IllegalStateException exception, String... expectedLockCycle) {\n",
        "572": "      fail(\"expected to contain regex:<\" + expectedRegex + \"> but was:\"\n",
        "573": "          + actualDesc);\n"
    }
}