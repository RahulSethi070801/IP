{
    "addition": {
        "55": " * Static utility methods pertaining to {@link List} instances. Also see this class's counterparts\n",
        "56": " * {@link Sets}, {@link Maps} and {@link Queues}.\n",
        "59": " * \"https://github.com/google/guava/wiki/CollectionUtilitiesExplained#lists\"> {@code Lists}</a>.\n",
        "73": "   * Creates a <i>mutable</i>, empty {@code ArrayList} instance (for Java 6 and earlier).\n",
        "75": "   * <p><b>Note:</b> if mutability is not required, use {@link ImmutableList#of()} instead.\n",
        "77": "   * <p><b>Note for Java 7 and later:</b> this method is now unnecessary and should be treated as\n",
        "78": "   * deprecated. Instead, use the {@code ArrayList} {@linkplain ArrayList#ArrayList() constructor}\n",
        "79": "   * directly, taking advantage of the new <a href=\"http://goo.gl/iz2Wi\">\"diamond\" syntax</a>.\n",
        "87": "   * Creates a <i>mutable</i> {@code ArrayList} instance containing the given elements.\n",
        "89": "   * <p><b>Note:</b> essentially the only reason to use this method is when you will need to add or\n",
        "90": "   * remove elements later. Otherwise, for non-null elements use {@link ImmutableList#of()} (for\n",
        "91": "   * varargs) or {@link ImmutableList#copyOf(Object[])} (for an array) instead. If any elements\n",
        "92": "   * might be null, or you need support for {@link List#set(int, Object)}, use {@link\n",
        "93": "   * Arrays#asList}.\n",
        "95": "   * <p>Note that even when you do need the ability to add or remove, this method provides only a\n",
        "96": "   * tiny bit of syntactic sugar for {@code newArrayList(}{@link Arrays#asList asList}{@code\n",
        "97": "   * (...))}, or for creating an empty list then calling {@link Collections#addAll}. This method is\n",
        "98": "   * not actually very useful and will likely be deprecated in the future.\n",
        "121": "   * Creates a <i>mutable</i> {@code ArrayList} instance containing the given elements; a very thin\n",
        "122": "   * shortcut for creating an empty list then calling {@link Iterables#addAll}.\n",
        "124": "   * <p><b>Note:</b> if mutability is not required and the elements are non-null, use {@link\n",
        "125": "   * ImmutableList#copyOf(Iterable)} instead. (Or, change {@code elements} to be a {@link\n",
        "126": "   * FluentIterable} and call {@code elements.toList()}.)\n",
        "128": "   * <p><b>Note for Java 7 and later:</b> if {@code elements} is a {@link Collection}, you don't\n",
        "129": "   * need this method. Use the {@code ArrayList} {@linkplain ArrayList#ArrayList(Collection)\n",
        "130": "   * constructor} directly, taking advantage of the new <a href=\"http://goo.gl/iz2Wi\">\"diamond\"\n",
        "131": "   * syntax</a>.\n",
        "144": "   * Creates a <i>mutable</i> {@code ArrayList} instance containing the given elements; a very thin\n",
        "145": "   * shortcut for creating an empty list and then calling {@link Iterators#addAll}.\n",
        "147": "   * <p><b>Note:</b> if mutability is not required and the elements are non-null, use {@link\n",
        "148": "   * ImmutableList#copyOf(Iterator)} instead.\n",
        "159": "   * Creates an {@code ArrayList} instance backed by an array with the specified initial size;\n",
        "160": "   * simply delegates to {@link ArrayList#ArrayList(int)}.\n",
        "162": "   * <p><b>Note for Java 7 and later:</b> this method is now unnecessary and should be treated as\n",
        "163": "   * deprecated. Instead, use {@code new }{@link ArrayList#ArrayList(int) ArrayList}{@code <>(int)}\n",
        "164": "   * directly, taking advantage of the new <a href=\"http://goo.gl/iz2Wi\">\"diamond\" syntax</a>.\n",
        "165": "   * (Unlike here, there is no risk of overload ambiguity, since the {@code ArrayList} constructors\n",
        "166": "   * very wisely did not accept varargs.)\n",
        "168": "   * @param initialArraySize the exact size of the initial backing array for the returned array list\n",
        "169": "   *     ({@code ArrayList} documentation calls this value the \"capacity\")\n",
        "170": "   * @return a new, empty {@code ArrayList} which is guaranteed not to resize itself unless its size\n",
        "171": "   *     reaches {@code initialArraySize + 1}\n",
        "181": "   * Creates an {@code ArrayList} instance to hold {@code estimatedSize} elements, <i>plus</i> an\n",
        "182": "   * unspecified amount of padding; you almost certainly mean to call {@link\n",
        "183": "   * #newArrayListWithCapacity} (see that method for further advice on usage).\n",
        "185": "   * <p><b>Note:</b> This method will soon be deprecated. Even in the rare case that you do want\n",
        "186": "   * some amount of padding, it's best if you choose your desired amount explicitly.\n",
        "188": "   * @param estimatedSize an estimate of the eventual {@link List#size()} of the new list\n",
        "189": "   * @return a new, empty {@code ArrayList}, sized appropriately to hold the estimated number of\n",
        "190": "   *     elements\n",
        "201": "   * Creates a <i>mutable</i>, empty {@code LinkedList} instance (for Java 6 and earlier).\n",
        "203": "   * <p><b>Note:</b> if you won't be adding any elements to the list, use {@link ImmutableList#of()}\n",
        "204": "   * instead.\n",
        "206": "   * <p><b>Performance note:</b> {@link ArrayList} and {@link java.util.ArrayDeque} consistently\n",
        "207": "   * outperform {@code LinkedList} except in certain rare and specific situations. Unless you have\n",
        "208": "   * spent a lot of time benchmarking your specific needs, use one of those instead.\n",
        "210": "   * <p><b>Note for Java 7 and later:</b> this method is now unnecessary and should be treated as\n",
        "211": "   * deprecated. Instead, use the {@code LinkedList} {@linkplain LinkedList#LinkedList()\n",
        "212": "   * constructor} directly, taking advantage of the new <a href=\"http://goo.gl/iz2Wi\">\"diamond\"\n",
        "213": "   * syntax</a>.\n",
        "221": "   * Creates a <i>mutable</i> {@code LinkedList} instance containing the given elements; a very thin\n",
        "222": "   * shortcut for creating an empty list then calling {@link Iterables#addAll}.\n",
        "224": "   * <p><b>Note:</b> if mutability is not required and the elements are non-null, use {@link\n",
        "225": "   * ImmutableList#copyOf(Iterable)} instead. (Or, change {@code elements} to be a {@link\n",
        "226": "   * FluentIterable} and call {@code elements.toList()}.)\n",
        "228": "   * <p><b>Performance note:</b> {@link ArrayList} and {@link java.util.ArrayDeque} consistently\n",
        "229": "   * outperform {@code LinkedList} except in certain rare and specific situations. Unless you have\n",
        "230": "   * spent a lot of time benchmarking your specific needs, use one of those instead.\n",
        "232": "   * <p><b>Note for Java 7 and later:</b> if {@code elements} is a {@link Collection}, you don't\n",
        "233": "   * need this method. Use the {@code LinkedList} {@linkplain LinkedList#LinkedList(Collection)\n",
        "234": "   * constructor} directly, taking advantage of the new <a href=\"http://goo.gl/iz2Wi\">\"diamond\"\n",
        "235": "   * syntax</a>.\n",
        "247": "   * <p><b>Note:</b> if you need an immutable empty {@link List}, use {@link Collections#emptyList}\n",
        "248": "   * instead.\n",
        "276": "   * Returns an unmodifiable list containing the specified first element and backed by the specified\n",
        "277": "   * array of additional elements. Changes to the {@code rest} array will be reflected in the\n",
        "278": "   * returned list. Unlike {@link Arrays#asList}, the returned list is unmodifiable.\n",
        "280": "   * <p>This is useful when a varargs method needs to use a signature such as {@code (Foo firstFoo,\n",
        "281": "   * Foo... moreFoos)}, in order to avoid overload ambiguity or to enforce a minimum argument count.\n",
        "320": "   * Returns an unmodifiable list containing the specified first and second element, and backed by\n",
        "321": "   * the specified array of additional elements. Changes to the {@code rest} array will be reflected\n",
        "322": "   * in the returned list. Unlike {@link Arrays#asList}, the returned list is unmodifiable.\n",
        "324": "   * <p>This is useful when a varargs method needs to use a signature such as {@code (Foo firstFoo,\n",
        "325": "   * Foo secondFoo, Foo... moreFoos)}, in order to avoid overload ambiguity or to enforce a minimum\n",
        "326": "   * argument count.\n",
        "375": "   * Returns every possible list that can be formed by choosing one element from each of the given\n",
        "376": "   * lists in order; the \"n-ary <a href=\"http://en.wikipedia.org/wiki/Cartesian_product\">Cartesian\n",
        "377": "   * product</a>\" of the lists. For example:\n",
        "379": "   * <pre>{@code\n",
        "380": "   * Lists.cartesianProduct(ImmutableList.of(\n",
        "381": "   *     ImmutableList.of(1, 2),\n",
        "382": "   *     ImmutableList.of(\"A\", \"B\", \"C\")))\n",
        "383": "   * }</pre>\n",
        "388": "   *   <li>{@code ImmutableList.of(1, \"A\")}\n",
        "389": "   *   <li>{@code ImmutableList.of(1, \"B\")}\n",
        "390": "   *   <li>{@code ImmutableList.of(1, \"C\")}\n",
        "391": "   *   <li>{@code ImmutableList.of(2, \"A\")}\n",
        "392": "   *   <li>{@code ImmutableList.of(2, \"B\")}\n",
        "393": "   *   <li>{@code ImmutableList.of(2, \"C\")}\n",
        "396": "   * <p>The result is guaranteed to be in the \"traditional\", lexicographical order for Cartesian\n",
        "397": "   * products that you would get from nesting for loops:\n",
        "399": "   * <pre>{@code\n",
        "400": "   * for (B b0 : lists.get(0)) {\n",
        "401": "   *   for (B b1 : lists.get(1)) {\n",
        "402": "   *     ...\n",
        "403": "   *     ImmutableList<B> tuple = ImmutableList.of(b0, b1, ...);\n",
        "404": "   *     // operate on tuple\n",
        "405": "   *   }\n",
        "406": "   * }\n",
        "407": "   * }</pre>\n",
        "409": "   * <p>Note that if any input list is empty, the Cartesian product will also be empty. If no lists\n",
        "410": "   * at all are provided (an empty list), the resulting Cartesian product has one element, an empty\n",
        "411": "   * list (counter-intuitive, but mathematically consistent).\n",
        "413": "   * <p><i>Performance notes:</i> while the cartesian product of lists of size {@code m, n, p} is a\n",
        "414": "   * list of size {@code m x n x p}, its actual memory consumption is much smaller. When the\n",
        "415": "   * cartesian product is constructed, the input lists are merely copied. Only as the resulting list\n",
        "416": "   * is iterated are the individual lists created, and these are not retained after iteration.\n",
        "418": "   * @param lists the lists to choose elements from, in the order that the elements chosen from\n",
        "419": "   *     those lists should appear in the resulting lists\n",
        "420": "   * @param <B> any common base class shared by all axes (often just {@link Object})\n",
        "421": "   * @return the Cartesian product, as an immutable list containing immutable lists\n",
        "422": "   * @throws IllegalArgumentException if the size of the cartesian product would be greater than\n",
        "423": "   *     {@link Integer#MAX_VALUE}\n",
        "424": "   * @throws NullPointerException if {@code lists}, any one of the {@code lists}, or any element of\n",
        "425": "   *     a provided list is null\n",
        "433": "   * Returns every possible list that can be formed by choosing one element from each of the given\n",
        "434": "   * lists in order; the \"n-ary <a href=\"http://en.wikipedia.org/wiki/Cartesian_product\">Cartesian\n",
        "435": "   * product</a>\" of the lists. For example:\n",
        "437": "   * <pre>{@code\n",
        "438": "   * Lists.cartesianProduct(ImmutableList.of(\n",
        "439": "   *     ImmutableList.of(1, 2),\n",
        "440": "   *     ImmutableList.of(\"A\", \"B\", \"C\")))\n",
        "441": "   * }</pre>\n",
        "446": "   *   <li>{@code ImmutableList.of(1, \"A\")}\n",
        "447": "   *   <li>{@code ImmutableList.of(1, \"B\")}\n",
        "448": "   *   <li>{@code ImmutableList.of(1, \"C\")}\n",
        "449": "   *   <li>{@code ImmutableList.of(2, \"A\")}\n",
        "450": "   *   <li>{@code ImmutableList.of(2, \"B\")}\n",
        "451": "   *   <li>{@code ImmutableList.of(2, \"C\")}\n",
        "454": "   * <p>The result is guaranteed to be in the \"traditional\", lexicographical order for Cartesian\n",
        "455": "   * products that you would get from nesting for loops:\n",
        "457": "   * <pre>{@code\n",
        "458": "   * for (B b0 : lists.get(0)) {\n",
        "459": "   *   for (B b1 : lists.get(1)) {\n",
        "460": "   *     ...\n",
        "461": "   *     ImmutableList<B> tuple = ImmutableList.of(b0, b1, ...);\n",
        "462": "   *     // operate on tuple\n",
        "463": "   *   }\n",
        "464": "   * }\n",
        "465": "   * }</pre>\n",
        "467": "   * <p>Note that if any input list is empty, the Cartesian product will also be empty. If no lists\n",
        "468": "   * at all are provided (an empty list), the resulting Cartesian product has one element, an empty\n",
        "469": "   * list (counter-intuitive, but mathematically consistent).\n",
        "471": "   * <p><i>Performance notes:</i> while the cartesian product of lists of size {@code m, n, p} is a\n",
        "472": "   * list of size {@code m x n x p}, its actual memory consumption is much smaller. When the\n",
        "473": "   * cartesian product is constructed, the input lists are merely copied. Only as the resulting list\n",
        "474": "   * is iterated are the individual lists created, and these are not retained after iteration.\n",
        "476": "   * @param lists the lists to choose elements from, in the order that the elements chosen from\n",
        "477": "   *     those lists should appear in the resulting lists\n",
        "478": "   * @param <B> any common base class shared by all axes (often just {@link Object})\n",
        "479": "   * @return the Cartesian product, as an immutable list containing immutable lists\n",
        "480": "   * @throws IllegalArgumentException if the size of the cartesian product would be greater than\n",
        "481": "   *     {@link Integer#MAX_VALUE}\n",
        "482": "   * @throws NullPointerException if {@code lists}, any one of the {@code lists}, or any element of\n",
        "483": "   *     a provided list is null\n",
        "492": "   * Returns a list that applies {@code function} to each element of {@code fromList}. The returned\n",
        "493": "   * list is a transformed view of {@code fromList}; changes to {@code fromList} will be reflected\n",
        "494": "   * in the returned list and vice versa.\n",
        "496": "   * <p>Since functions are not reversible, the transform is one-way and new items cannot be stored\n",
        "497": "   * in the returned list. The {@code add}, {@code addAll} and {@code set} methods are unsupported\n",
        "498": "   * in the returned list.\n",
        "500": "   * <p>The function is applied lazily, invoked when needed. This is necessary for the returned list\n",
        "501": "   * to be a view, but it means that the function will be applied many times for bulk operations\n",
        "502": "   * like {@link List#contains} and {@link List#hashCode}. For this to perform well, {@code\n",
        "503": "   * function} should be fast. To avoid lazy evaluation when the returned list doesn't need to be a\n",
        "506": "   * <p>If {@code fromList} implements {@link RandomAccess}, so will the returned list. The returned\n",
        "507": "   * list is threadsafe if the supplied list and function are.\n",
        "509": "   * <p>If only a {@code Collection} or {@code Iterable} input is available, use {@link\n",
        "510": "   * Collections2#transform} or {@link Iterables#transform}.\n",
        "512": "   * <p><b>Note:</b> serializing the returned list is implemented by serializing {@code fromList},\n",
        "513": "   * its contents, and {@code function} -- <i>not</i> by serializing the transformed values. This\n",
        "514": "   * can lead to surprising behavior, so serializing the returned list is <b>not recommended</b>.\n",
        "515": "   * Instead, copy the list using {@link ImmutableList#copyOf(Collection)} (for example), then\n",
        "516": "   * serialize the copy. Other methods similar to this do not implement serialization at all for\n",
        "517": "   * this reason.\n",
        "519": "   * <p><b>Java 8 users:</b> many use cases for this method are better addressed by {@link\n",
        "520": "   * java.util.stream.Stream#map}. This method is not being deprecated, but we gently encourage you\n",
        "521": "   * to migrate to streams.\n",
        "544": "\n",
        "546": "     * The default implementation inherited is based on iteration and removal of each element which\n",
        "547": "     * can be overkill. That's why we forward this call directly to the backing list.\n",
        "573": "   * Implementation of a transforming random access list. We try to make as many of these methods\n",
        "574": "   * pass-through to the source list as possible so that the performance characteristics of the\n",
        "575": "   * source list and transformed list are similar.\n",
        "633": "   * Returns consecutive {@linkplain List#subList(int, int) sublists} of a list, each of the same\n",
        "634": "   * size (the final list may be smaller). For example, partitioning a list containing {@code [a, b,\n",
        "635": "   * c, d, e]} with a partition size of 3 yields {@code [[a, b, c], [d, e]]} -- an outer list\n",
        "636": "   * containing two inner lists of three and two elements, all in the original order.\n",
        "638": "   * <p>The outer list is unmodifiable, but reflects the latest state of the source list. The inner\n",
        "639": "   * lists are sublist views of the original list, produced on demand using {@link List#subList(int,\n",
        "640": "   * int)}, and are subject to all the usual caveats about modification as explained in that API.\n",
        "643": "   * @param size the desired size of each sublist (the last may be smaller)\n",
        "690": "   * Returns a view of the specified string as an immutable list of {@code Character} values.\n",
        "741": "   * Returns a view of the specified {@code CharSequence} as a {@code List<Character>}, viewing\n",
        "742": "   * {@code sequence} as a sequence of Unicode code units. The view does not support any\n",
        "743": "   * modification operations, but reflects any changes to the underlying character sequence.\n",
        "745": "   * @param sequence the character sequence to view as a {@code List} of characters\n",
        "775": "   * Lists.reverse(Arrays.asList(1, 2, 3))} returns a list containing {@code 3, 2, 1}. The returned\n",
        "776": "   * list is backed by this list, so changes in the returned list are reflected in this list, and\n",
        "777": "   * vice-versa. The returned list supports all of the optional list operations supported by this\n",
        "778": "   * list.\n",
        "780": "   * <p>The returned list is random-access if the specified list is random access.\n",
        "940": "  /** An implementation of {@link List#hashCode()}. */\n",
        "953": "  /** An implementation of {@link List#equals(Object)}. */\n",
        "979": "  /** An implementation of {@link List#addAll(int, Collection)}. */\n",
        "990": "  /** An implementation of {@link List#indexOf(Object)}. */\n",
        "1023": "  /** An implementation of {@link List#lastIndexOf(Object)}. */\n",
        "1055": "  /** Returns an implementation of {@link List#listIterator(int)}. */\n",
        "1060": "  /** An implementation of {@link List#subList(int, int)}. */\n",
        "1137": "  /** Used to avoid http://bugs.sun.com/view_bug.do?bug_id=6558557 */\n"
    },
    "removed": {
        "55": " * Static utility methods pertaining to {@link List} instances. Also see this\n",
        "56": " * class's counterparts {@link Sets}, {@link Maps} and {@link Queues}.\n",
        "59": " * \"https://github.com/google/guava/wiki/CollectionUtilitiesExplained#lists\">\n",
        "60": " * {@code Lists}</a>.\n",
        "74": "   * Creates a <i>mutable</i>, empty {@code ArrayList} instance (for Java 6 and\n",
        "75": "   * earlier).\n",
        "77": "   * <p><b>Note:</b> if mutability is not required, use {@link\n",
        "78": "   * ImmutableList#of()} instead.\n",
        "80": "   * <p><b>Note for Java 7 and later:</b> this method is now unnecessary and\n",
        "81": "   * should be treated as deprecated. Instead, use the {@code ArrayList}\n",
        "82": "   * {@linkplain ArrayList#ArrayList() constructor} directly, taking advantage\n",
        "83": "   * of the new <a href=\"http://goo.gl/iz2Wi\">\"diamond\" syntax</a>.\n",
        "91": "   * Creates a <i>mutable</i> {@code ArrayList} instance containing the given\n",
        "92": "   * elements.\n",
        "94": "   * <p><b>Note:</b> essentially the only reason to use this method is when you\n",
        "95": "   * will need to add or remove elements later. Otherwise, for non-null elements\n",
        "96": "   * use {@link ImmutableList#of()} (for varargs) or {@link\n",
        "97": "   * ImmutableList#copyOf(Object[])} (for an array) instead. If any elements\n",
        "98": "   * might be null, or you need support for {@link List#set(int, Object)}, use\n",
        "99": "   * {@link Arrays#asList}.\n",
        "101": "   * <p>Note that even when you do need the ability to add or remove, this method\n",
        "102": "   * provides only a tiny bit of syntactic sugar for {@code newArrayList(}{@link\n",
        "103": "   * Arrays#asList asList}{@code (...))}, or for creating an empty list then\n",
        "104": "   * calling {@link Collections#addAll}. This method is not actually very useful\n",
        "105": "   * and will likely be deprecated in the future.\n",
        "128": "   * Creates a <i>mutable</i> {@code ArrayList} instance containing the given\n",
        "129": "   * elements; a very thin shortcut for creating an empty list then calling\n",
        "130": "   * {@link Iterables#addAll}.\n",
        "132": "   * <p><b>Note:</b> if mutability is not required and the elements are\n",
        "133": "   * non-null, use {@link ImmutableList#copyOf(Iterable)} instead. (Or, change\n",
        "134": "   * {@code elements} to be a {@link FluentIterable} and call\n",
        "135": "   * {@code elements.toList()}.)\n",
        "137": "   * <p><b>Note for Java 7 and later:</b> if {@code elements} is a {@link\n",
        "138": "   * Collection}, you don't need this method. Use the {@code ArrayList}\n",
        "139": "   * {@linkplain ArrayList#ArrayList(Collection) constructor} directly, taking\n",
        "140": "   * advantage of the new <a href=\"http://goo.gl/iz2Wi\">\"diamond\" syntax</a>.\n",
        "153": "   * Creates a <i>mutable</i> {@code ArrayList} instance containing the given\n",
        "154": "   * elements; a very thin shortcut for creating an empty list and then calling\n",
        "155": "   * {@link Iterators#addAll}.\n",
        "157": "   * <p><b>Note:</b> if mutability is not required and the elements are\n",
        "158": "   * non-null, use {@link ImmutableList#copyOf(Iterator)} instead.\n",
        "169": "   * Creates an {@code ArrayList} instance backed by an array with the specified\n",
        "170": "   * initial size; simply delegates to {@link ArrayList#ArrayList(int)}.\n",
        "172": "   * <p><b>Note for Java 7 and later:</b> this method is now unnecessary and\n",
        "173": "   * should be treated as deprecated. Instead, use {@code new }{@link\n",
        "174": "   * ArrayList#ArrayList(int) ArrayList}{@code <>(int)} directly, taking\n",
        "175": "   * advantage of the new <a href=\"http://goo.gl/iz2Wi\">\"diamond\" syntax</a>.\n",
        "176": "   * (Unlike here, there is no risk of overload ambiguity, since the {@code\n",
        "177": "   * ArrayList} constructors very wisely did not accept varargs.)\n",
        "179": "   * @param initialArraySize the exact size of the initial backing array for\n",
        "180": "   *     the returned array list ({@code ArrayList} documentation calls this\n",
        "181": "   *     value the \"capacity\")\n",
        "182": "   * @return a new, empty {@code ArrayList} which is guaranteed not to resize\n",
        "183": "   *     itself unless its size reaches {@code initialArraySize + 1}\n",
        "193": "   * Creates an {@code ArrayList} instance to hold {@code estimatedSize}\n",
        "194": "   * elements, <i>plus</i> an unspecified amount of padding; you almost\n",
        "195": "   * certainly mean to call {@link #newArrayListWithCapacity} (see that method\n",
        "196": "   * for further advice on usage).\n",
        "198": "   * <p><b>Note:</b> This method will soon be deprecated. Even in the rare case\n",
        "199": "   * that you do want some amount of padding, it's best if you choose your\n",
        "200": "   * desired amount explicitly.\n",
        "202": "   * @param estimatedSize an estimate of the eventual {@link List#size()} of\n",
        "203": "   *     the new list\n",
        "204": "   * @return a new, empty {@code ArrayList}, sized appropriately to hold the\n",
        "205": "   *     estimated number of elements\n",
        "216": "   * Creates a <i>mutable</i>, empty {@code LinkedList} instance (for Java 6 and\n",
        "217": "   * earlier).\n",
        "219": "   * <p><b>Note:</b> if you won't be adding any elements to the list, use {@link\n",
        "220": "   * ImmutableList#of()} instead.\n",
        "222": "   * <p><b>Performance note:</b> {@link ArrayList} and {@link\n",
        "223": "   * java.util.ArrayDeque} consistently outperform {@code LinkedList} except in\n",
        "224": "   * certain rare and specific situations. Unless you have spent a lot of time\n",
        "225": "   * benchmarking your specific needs, use one of those instead.\n",
        "227": "   * <p><b>Note for Java 7 and later:</b> this method is now unnecessary and\n",
        "228": "   * should be treated as deprecated. Instead, use the {@code LinkedList}\n",
        "229": "   * {@linkplain LinkedList#LinkedList() constructor} directly, taking advantage\n",
        "230": "   * of the new <a href=\"http://goo.gl/iz2Wi\">\"diamond\" syntax</a>.\n",
        "238": "   * Creates a <i>mutable</i> {@code LinkedList} instance containing the given\n",
        "239": "   * elements; a very thin shortcut for creating an empty list then calling\n",
        "240": "   * {@link Iterables#addAll}.\n",
        "242": "   * <p><b>Note:</b> if mutability is not required and the elements are\n",
        "243": "   * non-null, use {@link ImmutableList#copyOf(Iterable)} instead. (Or, change\n",
        "244": "   * {@code elements} to be a {@link FluentIterable} and call\n",
        "245": "   * {@code elements.toList()}.)\n",
        "247": "   * <p><b>Performance note:</b> {@link ArrayList} and {@link\n",
        "248": "   * java.util.ArrayDeque} consistently outperform {@code LinkedList} except in\n",
        "249": "   * certain rare and specific situations. Unless you have spent a lot of time\n",
        "250": "   * benchmarking your specific needs, use one of those instead.\n",
        "252": "   * <p><b>Note for Java 7 and later:</b> if {@code elements} is a {@link\n",
        "253": "   * Collection}, you don't need this method. Use the {@code LinkedList}\n",
        "254": "   * {@linkplain LinkedList#LinkedList(Collection) constructor} directly, taking\n",
        "255": "   * advantage of the new <a href=\"http://goo.gl/iz2Wi\">\"diamond\" syntax</a>.\n",
        "267": "   * <p><b>Note:</b> if you need an immutable empty {@link List}, use\n",
        "268": "   * {@link Collections#emptyList} instead.\n",
        "296": "   * Returns an unmodifiable list containing the specified first element and\n",
        "297": "   * backed by the specified array of additional elements. Changes to the {@code\n",
        "298": "   * rest} array will be reflected in the returned list. Unlike {@link\n",
        "299": "   * Arrays#asList}, the returned list is unmodifiable.\n",
        "301": "   * <p>This is useful when a varargs method needs to use a signature such as\n",
        "302": "   * {@code (Foo firstFoo, Foo... moreFoos)}, in order to avoid overload\n",
        "303": "   * ambiguity or to enforce a minimum argument count.\n",
        "342": "   * Returns an unmodifiable list containing the specified first and second\n",
        "343": "   * element, and backed by the specified array of additional elements. Changes\n",
        "344": "   * to the {@code rest} array will be reflected in the returned list. Unlike\n",
        "345": "   * {@link Arrays#asList}, the returned list is unmodifiable.\n",
        "347": "   * <p>This is useful when a varargs method needs to use a signature such as\n",
        "348": "   * {@code (Foo firstFoo, Foo secondFoo, Foo... moreFoos)}, in order to avoid\n",
        "349": "   * overload ambiguity or to enforce a minimum argument count.\n",
        "398": "   * Returns every possible list that can be formed by choosing one element\n",
        "399": "   * from each of the given lists in order; the \"n-ary\n",
        "400": "   * <a href=\"http://en.wikipedia.org/wiki/Cartesian_product\">Cartesian\n",
        "401": "   * product</a>\" of the lists. For example: <pre>   {@code\n",
        "403": "   *   Lists.cartesianProduct(ImmutableList.of(\n",
        "404": "   *       ImmutableList.of(1, 2),\n",
        "405": "   *       ImmutableList.of(\"A\", \"B\", \"C\")))}</pre>\n",
        "410": "   * <li>{@code ImmutableList.of(1, \"A\")}\n",
        "411": "   * <li>{@code ImmutableList.of(1, \"B\")}\n",
        "412": "   * <li>{@code ImmutableList.of(1, \"C\")}\n",
        "413": "   * <li>{@code ImmutableList.of(2, \"A\")}\n",
        "414": "   * <li>{@code ImmutableList.of(2, \"B\")}\n",
        "415": "   * <li>{@code ImmutableList.of(2, \"C\")}\n",
        "418": "   * <p>The result is guaranteed to be in the \"traditional\", lexicographical\n",
        "419": "   * order for Cartesian products that you would get from nesting for loops:\n",
        "420": "   * <pre>   {@code\n",
        "422": "   *   for (B b0 : lists.get(0)) {\n",
        "423": "   *     for (B b1 : lists.get(1)) {\n",
        "424": "   *       ...\n",
        "425": "   *       ImmutableList<B> tuple = ImmutableList.of(b0, b1, ...);\n",
        "426": "   *       // operate on tuple\n",
        "427": "   *     }\n",
        "428": "   *   }}</pre>\n",
        "430": "   * <p>Note that if any input list is empty, the Cartesian product will also be\n",
        "431": "   * empty. If no lists at all are provided (an empty list), the resulting\n",
        "432": "   * Cartesian product has one element, an empty list (counter-intuitive, but\n",
        "433": "   * mathematically consistent).\n",
        "435": "   * <p><i>Performance notes:</i> while the cartesian product of lists of size\n",
        "436": "   * {@code m, n, p} is a list of size {@code m x n x p}, its actual memory\n",
        "437": "   * consumption is much smaller. When the cartesian product is constructed, the\n",
        "438": "   * input lists are merely copied. Only as the resulting list is iterated are\n",
        "439": "   * the individual lists created, and these are not retained after iteration.\n",
        "441": "   * @param lists the lists to choose elements from, in the order that\n",
        "442": "   *     the elements chosen from those lists should appear in the resulting\n",
        "443": "   *     lists\n",
        "444": "   * @param <B> any common base class shared by all axes (often just {@link\n",
        "445": "   *     Object})\n",
        "446": "   * @return the Cartesian product, as an immutable list containing immutable\n",
        "447": "   *     lists\n",
        "448": "   * @throws IllegalArgumentException if the size of the cartesian product would\n",
        "449": "   *     be greater than {@link Integer#MAX_VALUE}\n",
        "450": "   * @throws NullPointerException if {@code lists}, any one of the {@code lists},\n",
        "451": "   *     or any element of a provided list is null\n",
        "459": "   * Returns every possible list that can be formed by choosing one element\n",
        "460": "   * from each of the given lists in order; the \"n-ary\n",
        "461": "   * <a href=\"http://en.wikipedia.org/wiki/Cartesian_product\">Cartesian\n",
        "462": "   * product</a>\" of the lists. For example: <pre>   {@code\n",
        "464": "   *   Lists.cartesianProduct(ImmutableList.of(\n",
        "465": "   *       ImmutableList.of(1, 2),\n",
        "466": "   *       ImmutableList.of(\"A\", \"B\", \"C\")))}</pre>\n",
        "471": "   * <li>{@code ImmutableList.of(1, \"A\")}\n",
        "472": "   * <li>{@code ImmutableList.of(1, \"B\")}\n",
        "473": "   * <li>{@code ImmutableList.of(1, \"C\")}\n",
        "474": "   * <li>{@code ImmutableList.of(2, \"A\")}\n",
        "475": "   * <li>{@code ImmutableList.of(2, \"B\")}\n",
        "476": "   * <li>{@code ImmutableList.of(2, \"C\")}\n",
        "479": "   * <p>The result is guaranteed to be in the \"traditional\", lexicographical\n",
        "480": "   * order for Cartesian products that you would get from nesting for loops:\n",
        "481": "   * <pre>   {@code\n",
        "483": "   *   for (B b0 : lists.get(0)) {\n",
        "484": "   *     for (B b1 : lists.get(1)) {\n",
        "485": "   *       ...\n",
        "486": "   *       ImmutableList<B> tuple = ImmutableList.of(b0, b1, ...);\n",
        "487": "   *       // operate on tuple\n",
        "488": "   *     }\n",
        "489": "   *   }}</pre>\n",
        "491": "   * <p>Note that if any input list is empty, the Cartesian product will also be\n",
        "492": "   * empty. If no lists at all are provided (an empty list), the resulting\n",
        "493": "   * Cartesian product has one element, an empty list (counter-intuitive, but\n",
        "494": "   * mathematically consistent).\n",
        "496": "   * <p><i>Performance notes:</i> while the cartesian product of lists of size\n",
        "497": "   * {@code m, n, p} is a list of size {@code m x n x p}, its actual memory\n",
        "498": "   * consumption is much smaller. When the cartesian product is constructed, the\n",
        "499": "   * input lists are merely copied. Only as the resulting list is iterated are\n",
        "500": "   * the individual lists created, and these are not retained after iteration.\n",
        "502": "   * @param lists the lists to choose elements from, in the order that\n",
        "503": "   *     the elements chosen from those lists should appear in the resulting\n",
        "504": "   *     lists\n",
        "505": "   * @param <B> any common base class shared by all axes (often just {@link\n",
        "506": "   *     Object})\n",
        "507": "   * @return the Cartesian product, as an immutable list containing immutable\n",
        "508": "   *     lists\n",
        "509": "   * @throws IllegalArgumentException if the size of the cartesian product would\n",
        "510": "   *     be greater than {@link Integer#MAX_VALUE}\n",
        "511": "   * @throws NullPointerException if {@code lists}, any one of the\n",
        "512": "   *     {@code lists}, or any element of a provided list is null\n",
        "521": "   * Returns a list that applies {@code function} to each element of {@code\n",
        "522": "   * fromList}. The returned list is a transformed view of {@code fromList};\n",
        "523": "   * changes to {@code fromList} will be reflected in the returned list and vice\n",
        "524": "   * versa.\n",
        "526": "   * <p>Since functions are not reversible, the transform is one-way and new\n",
        "527": "   * items cannot be stored in the returned list. The {@code add},\n",
        "528": "   * {@code addAll} and {@code set} methods are unsupported in the returned\n",
        "529": "   * list.\n",
        "531": "   * <p>The function is applied lazily, invoked when needed. This is necessary\n",
        "532": "   * for the returned list to be a view, but it means that the function will be\n",
        "533": "   * applied many times for bulk operations like {@link List#contains} and\n",
        "534": "   * {@link List#hashCode}. For this to perform well, {@code function} should be\n",
        "535": "   * fast. To avoid lazy evaluation when the returned list doesn't need to be a\n",
        "538": "   * <p>If {@code fromList} implements {@link RandomAccess}, so will the\n",
        "539": "   * returned list. The returned list is threadsafe if the supplied list and\n",
        "540": "   * function are.\n",
        "542": "   * <p>If only a {@code Collection} or {@code Iterable} input is available, use\n",
        "543": "   * {@link Collections2#transform} or {@link Iterables#transform}.\n",
        "545": "   * <p><b>Note:</b> serializing the returned list is implemented by serializing\n",
        "546": "   * {@code fromList}, its contents, and {@code function} -- <i>not</i> by\n",
        "547": "   * serializing the transformed values. This can lead to surprising behavior,\n",
        "548": "   * so serializing the returned list is <b>not recommended</b>. Instead,\n",
        "549": "   * copy the list using {@link ImmutableList#copyOf(Collection)} (for example),\n",
        "550": "   * then serialize the copy. Other methods similar to this do not implement\n",
        "551": "   * serialization at all for this reason.\n",
        "553": "   * <p><b>Java 8 users:</b> many use cases for this method are better addressed\n",
        "554": "   *  by {@link java.util.stream.Stream#map}. This method is not being\n",
        "555": "   * deprecated, but we gently encourage you to migrate to streams.\n",
        "579": "     * The default implementation inherited is based on iteration and removal of\n",
        "580": "     * each element which can be overkill. That's why we forward this call\n",
        "581": "     * directly to the backing list.\n",
        "607": "   * Implementation of a transforming random access list. We try to make as many\n",
        "608": "   * of these methods pass-through to the source list as possible so that the\n",
        "609": "   * performance characteristics of the source list and transformed list are\n",
        "610": "   * similar.\n",
        "668": "   * Returns consecutive {@linkplain List#subList(int, int) sublists} of a list,\n",
        "669": "   * each of the same size (the final list may be smaller). For example,\n",
        "670": "   * partitioning a list containing {@code [a, b, c, d, e]} with a partition\n",
        "671": "   * size of 3 yields {@code [[a, b, c], [d, e]]} -- an outer list containing\n",
        "672": "   * two inner lists of three and two elements, all in the original order.\n",
        "674": "   * <p>The outer list is unmodifiable, but reflects the latest state of the\n",
        "675": "   * source list. The inner lists are sublist views of the original list,\n",
        "676": "   * produced on demand using {@link List#subList(int, int)}, and are subject\n",
        "677": "   * to all the usual caveats about modification as explained in that API.\n",
        "680": "   * @param size the desired size of each sublist (the last may be\n",
        "681": "   *     smaller)\n",
        "728": "   * Returns a view of the specified string as an immutable list of {@code\n",
        "729": "   * Character} values.\n",
        "780": "   * Returns a view of the specified {@code CharSequence} as a {@code\n",
        "781": "   * List<Character>}, viewing {@code sequence} as a sequence of Unicode code\n",
        "782": "   * units. The view does not support any modification operations, but reflects\n",
        "783": "   * any changes to the underlying character sequence.\n",
        "785": "   * @param sequence the character sequence to view as a {@code List} of\n",
        "786": "   *        characters\n",
        "816": "   * Lists.reverse(Arrays.asList(1, 2, 3))} returns a list containing {@code 3,\n",
        "817": "   * 2, 1}. The returned list is backed by this list, so changes in the returned\n",
        "818": "   * list are reflected in this list, and vice-versa. The returned list supports\n",
        "819": "   * all of the optional list operations supported by this list.\n",
        "821": "   * <p>The returned list is random-access if the specified list is random\n",
        "822": "   * access.\n",
        "982": "  /**\n",
        "983": "   * An implementation of {@link List#hashCode()}.\n",
        "984": "   */\n",
        "997": "  /**\n",
        "998": "   * An implementation of {@link List#equals(Object)}.\n",
        "999": "   */\n",
        "1025": "  /**\n",
        "1026": "   * An implementation of {@link List#addAll(int, Collection)}.\n",
        "1027": "   */\n",
        "1038": "  /**\n",
        "1039": "   * An implementation of {@link List#indexOf(Object)}.\n",
        "1040": "   */\n",
        "1073": "  /**\n",
        "1074": "   * An implementation of {@link List#lastIndexOf(Object)}.\n",
        "1075": "   */\n",
        "1107": "  /**\n",
        "1108": "   * Returns an implementation of {@link List#listIterator(int)}.\n",
        "1109": "   */\n",
        "1114": "  /**\n",
        "1115": "   * An implementation of {@link List#subList(int, int)}.\n",
        "1116": "   */\n",
        "1193": "  /**\n",
        "1194": "   * Used to avoid http://bugs.sun.com/view_bug.do?bug_id=6558557\n",
        "1195": "   */\n"
    }
}