{
    "addition": {
        "38": "  /** Constructor for use by subclasses. */\n",
        "48": "   *   <li>{@code equivalent(x, x)} is true (<i>reflexive</i> property)\n",
        "49": "   *   <li>{@code equivalent(x, y)} and {@code equivalent(y, x)} each return the same result\n",
        "50": "   *       (<i>symmetric</i> property)\n",
        "51": "   *   <li>If {@code equivalent(x, y)} and {@code equivalent(y, z)} are both true, then {@code\n",
        "52": "   *       equivalent(x, z)} is also true (<i>transitive</i> property)\n",
        "69": "   * @deprecated Provided only to satisfy the {@link BiPredicate} interface; use {@link #equivalent}\n",
        "70": "   *     instead.\n",
        "80": "   * Implemented by the user to determine whether {@code a} and {@code b} are considered equivalent,\n",
        "81": "   * subject to the requirements specified in {@link #equivalent}.\n",
        "95": "   *\n",
        "97": "   *   <li>It is <i>consistent</i>: for any reference {@code x}, multiple invocations of {@code\n",
        "98": "   *       hash(x}} consistently return the same value provided {@code x} remains unchanged\n",
        "99": "   *       according to the definition of the equivalence. The hash need not remain consistent from\n",
        "100": "   *       one execution of an application to another execution of the same application.\n",
        "101": "   *   <li>It is <i>distributable across equivalence</i>: for any references {@code x} and {@code\n",
        "102": "   *       y}, if {@code equivalent(x, y)}, then {@code hash(x) == hash(y)}. It is <i>not</i>\n",
        "103": "   *       necessary that the hash be distributable across <i>inequivalence</i>. If {@code\n",
        "104": "   *       equivalence(x, y)} is false, {@code hash(x) == hash(y)} may still be true.\n",
        "105": "   *   <li>{@code hash(null)} is {@code 0}.\n",
        "130": "   * non-null objects {@code x} and {@code y}, {@code equivalence.onResultOf(function).equivalent(a,\n",
        "131": "   * b)} is true if and only if {@code equivalence.equivalent(function.apply(a), function.apply(b))}\n",
        "132": "   * is true.\n",
        "136": "   * <pre>{@code\n",
        "137": "   * Equivalence<Person> SAME_AGE = Equivalence.equals().onResultOf(GET_PERSON_AGE);\n",
        "138": "   * }</pre>\n",
        "144": "   * equivalent results. For example, {@code\n",
        "145": "   * Equivalence.identity().onResultOf(Functions.toStringFunction())} is broken because it's not\n",
        "146": "   * guaranteed that {@link Object#toString}) always returns the same string instance.\n",
        "156": "   * Object.equals()} such that {@code wrap(a).equals(wrap(b))} if and only if {@code equivalent(a,\n",
        "157": "   * b)}.\n",
        "166": "   * Wraps an object so that {@link #equals(Object)} and {@link #hashCode()} delegate to an {@link\n",
        "167": "   * Equivalence}.\n",
        "172": "   * <pre>{@code\n",
        "173": "   * equiv.wrap(\"a\").equals(equiv.wrap(\"b\")) // true\n",
        "174": "   * equiv.wrap(\"a\").equals(equiv.wrap(\"hello\")) // false\n",
        "175": "   * }</pre>\n",
        "179": "   * <pre>{@code\n",
        "180": "   * equiv.wrap(obj).equals(obj) // always false\n",
        "181": "   * }</pre>\n",
        "226": "    /** Returns the result of {@link Equivalence#hash(Object)} applied to the wrapped reference. */\n",
        "250": "   * <p>Note that this method performs a similar function for equivalences as {@link\n",
        "251": "   * com.google.common.collect.Ordering#lexicographical} does for orderings.\n",
        "327": "   * Returns an equivalence that uses {@code ==} to compare values and {@link\n",
        "328": "   * System#identityHashCode(Object)} to compute the hash code. {@link Equivalence#equivalent}\n",
        "329": "   * returns {@code true} if {@code a == b}, including in the case that a and b are both null.\n"
    },
    "removed": {
        "38": "  /**\n",
        "39": "   * Constructor for use by subclasses.\n",
        "40": "   */\n",
        "50": "   * <li>{@code equivalent(x, x)} is true (<i>reflexive</i> property)\n",
        "51": "   * <li>{@code equivalent(x, y)} and {@code equivalent(y, x)} each return the same result\n",
        "52": "   *     (<i>symmetric</i> property)\n",
        "53": "   * <li>If {@code equivalent(x, y)} and {@code equivalent(y, z)} are both true, then\n",
        "54": "   *     {@code equivalent(x, z)} is also true (<i>transitive</i> property)\n",
        "71": "   * @deprecated Provided only to satisfy the {@link BiPredicate} interface; use\n",
        "72": "   *     {@link #equivalent} instead.\n",
        "82": "   * Implemented by the user to determine whether {@code a} and {@code b} are considered\n",
        "83": "   * equivalent, subject to the requirements specified in {@link #equivalent}.\n",
        "98": "   * <li>It is <i>consistent</i>: for any reference {@code x}, multiple invocations of\n",
        "99": "   *     {@code hash(x}} consistently return the same value provided {@code x} remains unchanged\n",
        "100": "   *     according to the definition of the equivalence. The hash need not remain consistent from\n",
        "101": "   *     one execution of an application to another execution of the same application.\n",
        "102": "   * <li>It is <i>distributable across equivalence</i>: for any references {@code x} and {@code y},\n",
        "103": "   *     if {@code equivalent(x, y)}, then {@code hash(x) == hash(y)}. It is <i>not</i> necessary\n",
        "104": "   *     that the hash be distributable across <i>inequivalence</i>. If {@code equivalence(x, y)} is\n",
        "105": "   *     false, {@code hash(x) == hash(y)} may still be true.\n",
        "106": "   * <li>{@code hash(null)} is {@code 0}.\n",
        "131": "   * non-null objects {@code x} and {@code y}, {@code\n",
        "132": "   * equivalence.onResultOf(function).equivalent(a, b)} is true if and only if {@code\n",
        "133": "   * equivalence.equivalent(function.apply(a), function.apply(b))} is true.\n",
        "137": "   * <pre>   {@code\n",
        "138": "   *    Equivalence<Person> SAME_AGE = Equivalence.equals().onResultOf(GET_PERSON_AGE);}</pre>\n",
        "144": "   * equivalent results. For example,\n",
        "145": "   * {@code Equivalence.identity().onResultOf(Functions.toStringFunction())} is broken because it's\n",
        "146": "   * not guaranteed that {@link Object#toString}) always returns the same string instance.\n",
        "156": "   * Object.equals()} such that {@code wrap(a).equals(wrap(b))} if and only if\n",
        "157": "   * {@code equivalent(a, b)}.\n",
        "166": "   * Wraps an object so that {@link #equals(Object)} and {@link #hashCode()} delegate to an\n",
        "167": "   * {@link Equivalence}.\n",
        "172": "   * <pre>   {@code\n",
        "173": "   *   equiv.wrap(\"a\").equals(equiv.wrap(\"b\")) // true\n",
        "174": "   *   equiv.wrap(\"a\").equals(equiv.wrap(\"hello\")) // false}</pre>\n",
        "178": "   * <pre>   {@code\n",
        "179": "   *   equiv.wrap(obj).equals(obj) // always false}</pre>\n",
        "224": "    /**\n",
        "225": "     * Returns the result of {@link Equivalence#hash(Object)} applied to the wrapped reference.\n",
        "226": "     */\n",
        "250": "   * <p>Note that this method performs a similar function for equivalences as\n",
        "251": "   * {@link com.google.common.collect.Ordering#lexicographical} does for orderings.\n",
        "327": "   * Returns an equivalence that uses {@code ==} to compare values and\n",
        "328": "   * {@link System#identityHashCode(Object)} to compute the hash code.\n",
        "329": "   * {@link Equivalence#equivalent} returns {@code true} if {@code a == b}, including in the case\n",
        "330": "   * that a and b are both null.\n"
    }
}