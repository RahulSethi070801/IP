{
    "addition": {
        "40": " * Tester to ensure forwarding wrapper works by delegating calls to the corresponding method with\n",
        "41": " * the same parameters forwarded and return value forwarded back or exception propagated as is.\n",
        "43": " * <p>For example:\n",
        "44": " *\n",
        "45": " * <pre>{@code\n",
        "46": " * new ForwardingWrapperTester().testForwarding(Foo.class, new Function<Foo, Foo>() {\n",
        "47": " *   public Foo apply(Foo foo) {\n",
        "48": " *     return new ForwardingFoo(foo);\n",
        "49": " *   }\n",
        "50": " * });\n",
        "51": " * }</pre>\n",
        "63": "   * Asks for {@link Object#equals} and {@link Object#hashCode} to be tested. That is, forwarding\n",
        "64": "   * wrappers of equal instances should be equal.\n",
        "72": "   * Tests that the forwarding wrapper returned by {@code wrapperFunction} properly forwards method\n",
        "73": "   * calls with parameters passed as is, return value returned as is, and exceptions propagated as\n",
        "74": "   * is.\n",
        "96": "      if (method.getName().equals(\"hashCode\") && method.getParameterTypes().length == 0) {\n",
        "99": "      if (method.getName().equals(\"toString\") && method.getParameterTypes().length == 0) {\n",
        "126": "      Class<T> interfaceType, Method method, Function<? super T, ? extends T> wrapperFunction) {\n",
        "133": "    T proxy =\n",
        "134": "        Reflection.newProxy(\n",
        "135": "            interfaceType,\n",
        "136": "            new AbstractInvocationHandler() {\n",
        "137": "              @Override\n",
        "138": "              protected Object handleInvocation(Object p, Method m, Object[] args)\n",
        "139": "                  throws Throwable {\n",
        "140": "                throw exception;\n",
        "141": "              }\n",
        "142": "            });\n",
        "170": "    assertEquals(\n",
        "171": "        \"toString() isn't properly forwarded\",\n",
        "172": "        proxy.toString(),\n",
        "173": "        wrapperFunction.apply(proxy).toString());\n",
        "201": "    @Override\n",
        "202": "    protected Object handleInvocation(Object p, Method calledMethod, Object[] args)\n",
        "207": "        assertEquals(\n",
        "208": "            \"Parameter #\" + i + \" of \" + method + \" not forwarded\", passedArgs[i], args[i]);\n",
        "223": "          assertEquals(\n",
        "224": "              \"Return value of \" + method + \" not forwarded\", returnValue, actualReturnValue);\n",
        "234": "    @Override\n",
        "235": "    public String toString() {\n"
    },
    "removed": {
        "40": " * Tester to ensure forwarding wrapper works by delegating calls to the corresponding method\n",
        "41": " * with the same parameters forwarded and return value forwarded back or exception propagated as is.\n",
        "43": " * <p>For example: <pre>   {@code\n",
        "44": " *   new ForwardingWrapperTester().testForwarding(Foo.class, new Function<Foo, Foo>() {\n",
        "45": " *     public Foo apply(Foo foo) {\n",
        "46": " *       return new ForwardingFoo(foo);\n",
        "47": " *     }\n",
        "48": " *   });}</pre>\n",
        "60": "   * Asks for {@link Object#equals} and {@link Object#hashCode} to be tested.\n",
        "61": "   * That is, forwarding wrappers of equal instances should be equal.\n",
        "69": "   * Tests that the forwarding wrapper returned by {@code wrapperFunction} properly forwards\n",
        "70": "   * method calls with parameters passed as is, return value returned as is, and exceptions\n",
        "71": "   * propagated as is.\n",
        "93": "      if (method.getName().equals(\"hashCode\")\n",
        "94": "          && method.getParameterTypes().length == 0) {\n",
        "97": "      if (method.getName().equals(\"toString\")\n",
        "98": "          && method.getParameterTypes().length == 0) {\n",
        "125": "      Class<T> interfaceType,  Method method, Function<? super T, ? extends T> wrapperFunction) {\n",
        "132": "    T proxy = Reflection.newProxy(interfaceType, new AbstractInvocationHandler() {\n",
        "133": "      @Override protected Object handleInvocation(Object p, Method m, Object[] args)\n",
        "134": "          throws Throwable {\n",
        "135": "        throw exception;\n",
        "136": "      }\n",
        "137": "    });\n",
        "165": "    assertEquals(\"toString() isn't properly forwarded\",\n",
        "166": "        proxy.toString(), wrapperFunction.apply(proxy).toString());\n",
        "194": "    @Override protected Object handleInvocation(Object p, Method calledMethod, Object[] args)\n",
        "199": "        assertEquals(\"Parameter #\" + i + \" of \" + method + \" not forwarded\",\n",
        "200": "            passedArgs[i], args[i]);\n",
        "215": "          assertEquals(\"Return value of \" + method + \" not forwarded\", returnValue,\n",
        "216": "              actualReturnValue);\n",
        "226": "    @Override public String toString() {\n"
    }
}