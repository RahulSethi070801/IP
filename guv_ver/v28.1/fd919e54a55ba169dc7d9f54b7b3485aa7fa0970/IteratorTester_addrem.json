{
    "addition": {
        "24": " * A utility for testing an Iterator implementation by comparing its behavior to that of a \"known\n",
        "25": " * good\" reference implementation. In order to accomplish this, it's important to test a great\n",
        "26": " * variety of sequences of the {@link Iterator#next}, {@link Iterator#hasNext} and {@link\n",
        "27": " * Iterator#remove} operations. This utility takes the brute-force approach of trying <i>all</i>\n",
        "28": " * possible sequences of these operations, up to a given number of steps. So, if the caller\n",
        "29": " * specifies to use <i>n</i> steps, a total of <i>3^n</i> tests are actually performed.\n",
        "31": " * <p>For instance, if <i>steps</i> is 5, one example sequence that will be tested is:\n",
        "34": " *   <li>remove();\n",
        "35": " *   <li>hasNext()\n",
        "36": " *   <li>hasNext();\n",
        "37": " *   <li>remove();\n",
        "38": " *   <li>next();\n",
        "41": " * <p>This particular order of operations may be unrealistic, and testing all 3^5 of them may be\n",
        "42": " * thought of as overkill; however, it's difficult to determine which proper subset of this massive\n",
        "43": " * set would be sufficient to expose any possible bug. Brute force is simpler.\n",
        "45": " * <p>To use this class the concrete subclass must implement the {@link\n",
        "46": " * IteratorTester#newTargetIterator()} method. This is because it's impossible to test an Iterator\n",
        "47": " * without changing its state, so the tester needs a steady supply of fresh Iterators.\n",
        "49": " * <p>If your iterator supports modification through {@code remove()}, you may wish to override the\n",
        "50": " * verify() method, which is called <em>after</em> each sequence and is guaranteed to be called\n",
        "51": " * using the latest values obtained from {@link IteratorTester#newTargetIterator()}.\n"
    },
    "removed": {
        "24": " * A utility for testing an Iterator implementation by comparing its behavior to\n",
        "25": " * that of a \"known good\" reference implementation. In order to accomplish this,\n",
        "26": " * it's important to test a great variety of sequences of the\n",
        "27": " * {@link Iterator#next}, {@link Iterator#hasNext} and {@link Iterator#remove}\n",
        "28": " * operations. This utility takes the brute-force approach of trying <i>all</i>\n",
        "29": " * possible sequences of these operations, up to a given number of steps. So, if\n",
        "30": " * the caller specifies to use <i>n</i> steps, a total of <i>3^n</i> tests are\n",
        "31": " * actually performed.\n",
        "33": " * <p>For instance, if <i>steps</i> is 5, one example sequence that will be\n",
        "34": " * tested is:\n",
        "37": " * <li>remove();\n",
        "38": " * <li>hasNext()\n",
        "39": " * <li>hasNext();\n",
        "40": " * <li>remove();\n",
        "41": " * <li>next();\n",
        "44": " * <p>This particular order of operations may be unrealistic, and testing all 3^5\n",
        "45": " * of them may be thought of as overkill; however, it's difficult to determine\n",
        "46": " * which proper subset of this massive set would be sufficient to expose any\n",
        "47": " * possible bug. Brute force is simpler.\n",
        "49": " * <p>To use this class the concrete subclass must implement the\n",
        "50": " * {@link IteratorTester#newTargetIterator()} method. This is because it's\n",
        "51": " * impossible to test an Iterator without changing its state, so the tester\n",
        "52": " * needs a steady supply of fresh Iterators.\n",
        "54": " * <p>If your iterator supports modification through {@code remove()}, you may\n",
        "55": " * wish to override the verify() method, which is called <em>after</em>\n",
        "56": " * each sequence and is guaranteed to be called using the latest values\n",
        "57": " * obtained from {@link IteratorTester#newTargetIterator()}.\n"
    }
}