{
    "addition": {
        "38": " * <p>For example, this expression:\n",
        "40": " * <pre>{@code\n",
        "41": " * Splitter.on(',').split(\"foo,bar,qux\")\n",
        "42": " * }</pre>\n",
        "48": " * expression:\n",
        "50": " * <pre>{@code\n",
        "51": " * Splitter.on(',').split(\" foo,,,  bar ,\")\n",
        "52": " * }</pre>\n",
        "54": " * ... yields the substrings {@code [\" foo\", \"\", \"\", \" bar \", \"\"]}. If this is not the desired\n",
        "56": " * behavior:\n",
        "58": " * <pre>{@code\n",
        "59": " * private static final Splitter MY_SPLITTER = Splitter.on(',')\n",
        "60": " *     .trimResults()\n",
        "61": " *     .omitEmptyStrings();\n",
        "62": " * }</pre>\n",
        "64": " * <p>Now {@code MY_SPLITTER.split(\"foo,,, bar ,\")} returns just {@code [\"foo\", \"bar\"]}. Note that\n",
        "65": " * the order in which these configuration methods are called is never significant.\n",
        "69": " * instead.\n",
        "71": " * <pre>{@code\n",
        "72": " * // Do NOT do this\n",
        "73": " * Splitter splitter = Splitter.on('/');\n",
        "74": " * splitter.trimResults(); // does nothing!\n",
        "75": " * return splitter.split(\"wrong / wrong / wrong\");\n",
        "76": " * }</pre>\n",
        "79": " * containing {@code n} occurrences of the separator naturally yields an iterable of size {@code n +\n",
        "80": " * 1}. So if the separator does not occur anywhere in the input, a single substring is returned\n",
        "81": " * containing the entire input. Consequently, all splitters split the empty string to {@code [\"\"]}\n",
        "82": " * (note: even fixed-length splitters).\n",
        "84": " * <p>Splitter instances are thread-safe immutable, and are therefore safe to store as {@code static\n",
        "85": " * final} constants.\n",
        "90": " * <p>See the Guava User Guide article on <a\n",
        "91": " * href=\"https://github.com/google/guava/wiki/StringsExplained#splitter\">{@code Splitter}</a>.\n",
        "118": "   * Returns a splitter that uses the given single-character separator. For example, {@code\n",
        "119": "   * Splitter.on(',').split(\"foo,,bar\")} returns an iterable containing {@code [\"foo\", \"\", \"bar\"]}.\n",
        "161": "   * Returns a splitter that uses the given fixed string as a separator. For example, {@code\n",
        "162": "   * Splitter.on(\", \").split(\"foo, bar,baz\")} returns an iterable containing {@code [\"foo\",\n",
        "163": "   * \"bar,baz\"]}.\n",
        "262": "   * Returns a splitter that divides strings into pieces of the given length. For example, {@code\n",
        "263": "   * Splitter.fixedLength(2).split(\"abcde\")} returns an iterable containing {@code [\"ab\", \"cd\",\n",
        "264": "   * \"e\"]}. The last piece can be smaller than {@code length} but will never be empty.\n",
        "266": "   * <p><b>Exception:</b> for consistency with separator-based splitters, {@code split(\"\")} does not\n",
        "267": "   * yield an empty iterable, but an iterable containing {@code \"\"}. This is the only case in which\n",
        "268": "   * {@code Iterables.size(split(input))} does not equal {@code IntMath.divide(input.length(),\n",
        "269": "   * length, CEILING)}. To avoid this behavior, use {@code omitEmptyStrings}.\n",
        "327": "   * trimmed, including the last. Hence {@code Splitter.on(',').limit(3).trimResults().split(\" a , b\n",
        "328": "   * , c , d \")} results in {@code [\"a\", \"b\", \"c , d\"]}.\n",
        "343": "   * Splitter.on(',').trimResults().split(\" a, b ,c \")} returns an iterable containing {@code [\"a\",\n",
        "344": "   * \"b\", \"c\"]}.\n",
        "354": "   * or trailing characters matching the given {@code CharMatcher} from each returned substring. For\n",
        "355": "   * example, {@code Splitter.on(',').trimResults(CharMatcher.is('_')).split(\"_a ,_b_ ,c__\")}\n",
        "356": "   * returns an iterable containing {@code [\"a \", \"b_ \", \"c\"]}.\n",
        "369": "   * Splits {@code sequence} into string components and makes them available through an {@link\n",
        "370": "   * Iterator}, which may be lazily evaluated. If you want an eagerly computed {@link List}, use\n",
        "371": "   * {@link #splitToList(CharSequence)}.\n",
        "475": "     * unmodifiable map with each of the entries. For example, {@code\n",
        "476": "     * Splitter.on(';').trimResults().withKeyValueSeparator(\"=>\").split(\"a=>b ; c=>b\")} will return\n",
        "477": "     * a mapping from {@code \"a\"} to {@code \"b\"} and {@code \"c\"} to {@code \"b\"}.\n",
        "519": "     * Returns the first index in {@code toSplit} after {@code separatorPosition} that does not\n",
        "520": "     * contain a separator. This method is only invoked after a call to {@code separatorStart}.\n"
    },
    "removed": {
        "38": " * <p>For example, this expression: <pre>   {@code\n",
        "40": " *   Splitter.on(',').split(\"foo,bar,qux\")}</pre>\n",
        "46": " * expression: <pre>   {@code\n",
        "48": " *   Splitter.on(',').split(\" foo,,,  bar ,\")}</pre>\n",
        "50": " * ... yields the substrings {@code [\" foo\", \"\", \"\", \"  bar \", \"\"]}. If this is not the desired\n",
        "52": " * behavior: <pre>   {@code\n",
        "54": " *   private static final Splitter MY_SPLITTER = Splitter.on(',')\n",
        "55": " *       .trimResults()\n",
        "56": " *       .omitEmptyStrings();}</pre>\n",
        "58": " * <p>Now {@code MY_SPLITTER.split(\"foo,,,  bar ,\")} returns just {@code [\"foo\",\n",
        "59": " * \"bar\"]}. Note that the order in which these configuration methods are called is never\n",
        "60": " * significant.\n",
        "64": " * instead. <pre>   {@code\n",
        "66": " *   // Do NOT do this\n",
        "67": " *   Splitter splitter = Splitter.on('/');\n",
        "68": " *   splitter.trimResults(); // does nothing!\n",
        "69": " *   return splitter.split(\"wrong / wrong / wrong\");}</pre>\n",
        "72": " * containing {@code n} occurrences of the separator naturally yields an iterable of size\n",
        "73": " * {@code n + 1}. So if the separator does not occur anywhere in the input, a single substring is\n",
        "74": " * returned containing the entire input. Consequently, all splitters split the empty string to\n",
        "75": " * {@code [\"\"]} (note: even fixed-length splitters).\n",
        "77": " * <p>Splitter instances are thread-safe immutable, and are therefore safe to store as\n",
        "78": " * {@code static final} constants.\n",
        "83": " * <p>See the Guava User Guide article on\n",
        "84": " * <a href=\"https://github.com/google/guava/wiki/StringsExplained#splitter\">{@code Splitter}</a>.\n",
        "111": "   * Returns a splitter that uses the given single-character separator. For example,\n",
        "112": "   * {@code Splitter.on(',').split(\"foo,,bar\")} returns an iterable containing\n",
        "113": "   * {@code [\"foo\", \"\", \"bar\"]}.\n",
        "155": "   * Returns a splitter that uses the given fixed string as a separator. For example,\n",
        "156": "   * {@code Splitter.on(\", \").split(\"foo, bar,baz\")} returns an iterable containing\n",
        "157": "   * {@code [\"foo\", \"bar,baz\"]}.\n",
        "256": "   * Returns a splitter that divides strings into pieces of the given length. For example,\n",
        "257": "   * {@code Splitter.fixedLength(2).split(\"abcde\")} returns an iterable containing\n",
        "258": "   * {@code [\"ab\", \"cd\", \"e\"]}. The last piece can be smaller than {@code length} but will never be\n",
        "259": "   * empty.\n",
        "261": "   * <p><b>Exception:</b> for consistency with separator-based splitters, {@code\n",
        "262": "   * split(\"\")} does not yield an empty iterable, but an iterable containing {@code \"\"}. This is the\n",
        "263": "   * only case in which {@code\n",
        "264": "   * Iterables.size(split(input))} does not equal {@code\n",
        "265": "   * IntMath.divide(input.length(), length, CEILING)}. To avoid this behavior, use\n",
        "266": "   * {@code omitEmptyStrings}.\n",
        "324": "   * trimmed, including the last. Hence\n",
        "325": "   * {@code Splitter.on(',').limit(3).trimResults().split(\" a , b , c , d \")} results in\n",
        "326": "   * {@code [\"a\", \"b\", \"c , d\"]}.\n",
        "341": "   * Splitter.on(',').trimResults().split(\" a, b ,c \")} returns an iterable containing\n",
        "342": "   * {@code [\"a\", \"b\", \"c\"]}.\n",
        "352": "   * or trailing characters matching the given {@code\n",
        "353": "   * CharMatcher} from each returned substring. For example, {@code\n",
        "354": "   * Splitter.on(',').trimResults(CharMatcher.is('_')).split(\"_a ,_b_ ,c__\")} returns an iterable\n",
        "355": "   * containing {@code [\"a \", \"b_ \", \"c\"]}.\n",
        "368": "   * Splits {@code sequence} into string components and makes them available through an\n",
        "369": "   * {@link Iterator}, which may be lazily evaluated. If you want an eagerly computed {@link List},\n",
        "370": "   * use {@link #splitToList(CharSequence)}.\n",
        "474": "     * unmodifiable map with each of the entries. For example,\n",
        "475": "     * {@code Splitter.on(';').trimResults().withKeyValueSeparator(\"=>\").split(\"a=>b ; c=>b\")} will\n",
        "476": "     * return a mapping from {@code \"a\"} to {@code \"b\"} and {@code \"c\"} to {@code \"b\"}.\n",
        "518": "     * Returns the first index in {@code toSplit} after {@code\n",
        "519": "     * separatorPosition} that does not contain a separator. This method is only invoked after a\n",
        "520": "     * call to {@code separatorStart}.\n"
    }
}