{
    "addition": {
        "31": " *   <li><b>block of data:</b> the input for a hash function is always, in concept, an ordered byte\n",
        "32": " *       array. This hashing API accepts an arbitrary sequence of byte and multibyte values (via\n",
        "33": " *       {@link Hasher}), but this is merely a convenience; these are always translated into raw\n",
        "34": " *       byte sequences under the covers.\n",
        "35": " *   <li><b>hash code:</b> each hash function always yields hash codes of the same fixed bit length\n",
        "36": " *       (given by {@link #bits}). For example, {@link Hashing#sha1} produces a 160-bit number,\n",
        "37": " *       while {@link Hashing#murmur3_32()} yields only 32 bits. Because a {@code long} value is\n",
        "38": " *       clearly insufficient to hold all hash code values, this API represents a hash code as an\n",
        "39": " *       instance of {@link HashCode}.\n",
        "40": " *   <li><b>pure function:</b> the value produced must depend only on the input bytes, in the order\n",
        "41": " *       they appear. Input data is never modified. {@link HashFunction} instances should always be\n",
        "42": " *       stateless, and therefore thread-safe.\n",
        "43": " *   <li><b>collision-averse:</b> while it can't be helped that a hash function will sometimes\n",
        "44": " *       produce the same hash code for distinct inputs (a \"collision\"), every hash function strives\n",
        "45": " *       to <i>some</i> degree to make this unlikely. (Without this condition, a function that\n",
        "46": " *       always returns zero could be called a hash function. It is not.)\n",
        "57": " *   <li><b>collision-resistant:</b> while the definition above requires making at least <i>some</i>\n",
        "58": " *       token attempt, one measure of the quality of a hash function is <i>how well</i> it succeeds\n",
        "59": " *       at this goal. Important note: it may be easy to achieve the theoretical minimum collision\n",
        "60": " *       rate when using completely <i>random</i> sample input. The true test of a hash function is\n",
        "61": " *       how it performs on representative real-world data, which tends to contain many hidden\n",
        "62": " *       patterns and clumps. The goal of a good hash function is to stamp these patterns out as\n",
        "63": " *       thoroughly as possible.\n",
        "64": " *   <li><b>bit-dispersing:</b> masking out any <i>single bit</i> from a hash code should yield only\n",
        "65": " *       the expected <i>twofold</i> increase to all collision rates. Informally, the \"information\"\n",
        "66": " *       in the hash code should be as evenly \"spread out\" through the hash code's bits as possible.\n",
        "67": " *       The result is that, for example, when choosing a bucket in a hash table of size 2^8,\n",
        "68": " *       <i>any</i> eight bits could be consistently used.\n",
        "69": " *   <li><b>cryptographic:</b> certain hash functions such as {@link Hashing#sha512} are designed to\n",
        "70": " *       make it as infeasible as possible to reverse-engineer the input that produced a given hash\n",
        "71": " *       code, or even to discover <i>any</i> two distinct inputs that yield the same result. These\n",
        "72": " *       are called <i>cryptographic hash functions</i>. But, whenever it is learned that either of\n",
        "73": " *       these feats has become computationally feasible, the function is deemed \"broken\" and should\n",
        "74": " *       no longer be used for secure purposes. (This is the likely eventual fate of <i>all</i>\n",
        "75": " *       cryptographic hashes.)\n",
        "76": " *   <li><b>fast:</b> perhaps self-explanatory, but often the most important consideration. We have\n",
        "77": " *       published <a href=\"#noWeHaventYet\">microbenchmark results</a> for many common hash\n",
        "78": " *       functions.\n",
        "83": " * <p>The primary way to provide the data that your hash function should act on is via a {@link\n",
        "84": " * Hasher}. Obtain a new hasher from the hash function using {@link #newHasher}, \"push\" the relevant\n",
        "85": " * data into it using methods like {@link Hasher#putBytes(byte[])}, and finally ask for the {@code\n",
        "86": " * HashCode} when finished using {@link Hasher#hash}. (See an {@linkplain #newHasher example} of\n",
        "87": " * this.)\n",
        "92": " * <p>Hasher accepts primitive data types, but can also accept any Object of type {@code T} provided\n",
        "93": " * that you implement a {@link Funnel}{@code <T>} to specify how to \"feed\" data from that object\n",
        "94": " * into the function. (See {@linkplain Hasher#putObject an example} of this.)\n",
        "122": "   * Begins a new hash code computation by returning an initialized, stateful {@code Hasher}\n",
        "123": "   * instance that is ready to receive data. Example:\n",
        "125": "   * <pre>{@code\n",
        "126": "   * HashFunction hf = Hashing.md5();\n",
        "127": "   * HashCode hc = hf.newHasher()\n",
        "128": "   *     .putLong(id)\n",
        "129": "   *     .putBoolean(isActive)\n",
        "130": "   *     .hash();\n",
        "131": "   * }</pre>\n"
    },
    "removed": {
        "31": " * <li><b>block of data:</b> the input for a hash function is always, in concept, an ordered byte\n",
        "32": " *     array. This hashing API accepts an arbitrary sequence of byte and multibyte values (via\n",
        "33": " *     {@link Hasher}), but this is merely a convenience; these are always translated into raw byte\n",
        "34": " *     sequences under the covers.\n",
        "35": " *\n",
        "36": " * <li><b>hash code:</b> each hash function always yields hash codes of the same fixed bit length\n",
        "37": " *     (given by {@link #bits}). For example, {@link Hashing#sha1} produces a 160-bit number, while\n",
        "38": " *     {@link Hashing#murmur3_32()} yields only 32 bits. Because a {@code long} value is clearly\n",
        "39": " *     insufficient to hold all hash code values, this API represents a hash code as an instance of\n",
        "40": " *     {@link HashCode}.\n",
        "41": " *\n",
        "42": " * <li><b>pure function:</b> the value produced must depend only on the input bytes, in the order\n",
        "43": " *     they appear. Input data is never modified. {@link HashFunction} instances should always be\n",
        "44": " *     stateless, and therefore thread-safe.\n",
        "45": " *\n",
        "46": " * <li><b>collision-averse:</b> while it can't be helped that a hash function will sometimes produce\n",
        "47": " *     the same hash code for distinct inputs (a \"collision\"), every hash function strives to\n",
        "48": " *     <i>some</i> degree to make this unlikely. (Without this condition, a function that always\n",
        "49": " *     returns zero could be called a hash function. It is not.)\n",
        "60": " * <li><b>collision-resistant:</b> while the definition above requires making at least <i>some</i>\n",
        "61": " *     token attempt, one measure of the quality of a hash function is <i>how well</i> it succeeds\n",
        "62": " *     at this goal. Important note: it may be easy to achieve the theoretical minimum collision\n",
        "63": " *     rate when using completely <i>random</i> sample input. The true test of a hash function is\n",
        "64": " *     how it performs on representative real-world data, which tends to contain many hidden\n",
        "65": " *     patterns and clumps. The goal of a good hash function is to stamp these patterns out as\n",
        "66": " *     thoroughly as possible.\n",
        "67": " *\n",
        "68": " * <li><b>bit-dispersing:</b> masking out any <i>single bit</i> from a hash code should yield only\n",
        "69": " *     the expected <i>twofold</i> increase to all collision rates. Informally, the \"information\" in\n",
        "70": " *     the hash code should be as evenly \"spread out\" through the hash code's bits as possible. The\n",
        "71": " *     result is that, for example, when choosing a bucket in a hash table of size 2^8, <i>any</i>\n",
        "72": " *     eight bits could be consistently used.\n",
        "73": " *\n",
        "74": " * <li><b>cryptographic:</b> certain hash functions such as {@link Hashing#sha512} are designed to\n",
        "75": " *     make it as infeasible as possible to reverse-engineer the input that produced a given hash\n",
        "76": " *     code, or even to discover <i>any</i> two distinct inputs that yield the same result. These\n",
        "77": " *     are called <i>cryptographic hash functions</i>. But, whenever it is learned that either of\n",
        "78": " *     these feats has become computationally feasible, the function is deemed \"broken\" and should\n",
        "79": " *     no longer be used for secure purposes. (This is the likely eventual fate of <i>all</i>\n",
        "80": " *     cryptographic hashes.)\n",
        "81": " *\n",
        "82": " * <li><b>fast:</b> perhaps self-explanatory, but often the most important consideration. We have\n",
        "83": " *     published <a href=\"#noWeHaventYet\">microbenchmark results</a> for many common hash functions.\n",
        "88": " * <p>The primary way to provide the data that your hash function should act on is via a\n",
        "89": " * {@link Hasher}. Obtain a new hasher from the hash function using {@link #newHasher}, \"push\" the\n",
        "90": " * relevant data into it using methods like {@link Hasher#putBytes(byte[])}, and finally ask for the\n",
        "91": " * {@code HashCode} when finished using {@link Hasher#hash}. (See an {@linkplain #newHasher example}\n",
        "92": " * of this.)\n",
        "97": " * <p>Hasher accepts primitive data types, but can also accept any Object of type {@code\n",
        "98": " * T} provided that you implement a {@link Funnel}{@code <T>} to specify how to \"feed\" data from\n",
        "99": " * that object into the function. (See {@linkplain Hasher#putObject an example} of this.)\n",
        "127": "   * Begins a new hash code computation by returning an initialized, stateful {@code\n",
        "128": "   * Hasher} instance that is ready to receive data. Example: <pre>   {@code\n",
        "130": "   *   HashFunction hf = Hashing.md5();\n",
        "131": "   *   HashCode hc = hf.newHasher()\n",
        "132": "   *       .putLong(id)\n",
        "133": "   *       .putBoolean(isActive)\n",
        "134": "   *       .hash();}</pre>\n"
    }
}