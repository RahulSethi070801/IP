{
    "addition": {
        "44": " * A builder of {@link LoadingCache} and {@link Cache} instances having any combination of the\n",
        "48": " *   <li>automatic loading of entries into the cache\n",
        "49": " *   <li>least-recently-used eviction when a maximum size is exceeded\n",
        "50": " *   <li>time-based expiration of entries, measured since last access or last write\n",
        "51": " *   <li>keys automatically wrapped in {@linkplain WeakReference weak} references\n",
        "52": " *   <li>values automatically wrapped in {@linkplain WeakReference weak} or {@linkplain\n",
        "53": " *       SoftReference soft} references\n",
        "54": " *   <li>notification of evicted (or otherwise removed) entries\n",
        "55": " *   <li>accumulation of cache access statistics\n",
        "62": " * <p>Usage example:\n",
        "64": " * <pre>{@code\n",
        "65": " * LoadingCache<Key, Graph> graphs = CacheBuilder.newBuilder()\n",
        "66": " *     .maximumSize(10000)\n",
        "67": " *     .expireAfterWrite(10, TimeUnit.MINUTES)\n",
        "68": " *     .removalListener(MY_LISTENER)\n",
        "69": " *     .build(\n",
        "70": " *         new CacheLoader<Key, Graph>() {\n",
        "71": " *           public Graph load(Key key) throws AnyException {\n",
        "72": " *             return createExpensiveGraph(key);\n",
        "73": " *           }\n",
        "74": " *         });\n",
        "75": " * }</pre>\n",
        "77": " * <p>Or equivalently,\n",
        "79": " * <pre>{@code\n",
        "80": " * // In real life this would come from a command-line flag or config file\n",
        "81": " * String spec = \"maximumSize=10000,expireAfterWrite=10m\";\n",
        "83": " * LoadingCache<Key, Graph> graphs = CacheBuilder.from(spec)\n",
        "84": " *     .removalListener(MY_LISTENER)\n",
        "85": " *     .build(\n",
        "86": " *         new CacheLoader<Key, Graph>() {\n",
        "87": " *           public Graph load(Key key) throws AnyException {\n",
        "88": " *             return createExpensiveGraph(key);\n",
        "89": " *           }\n",
        "90": " *         });\n",
        "91": " * }</pre>\n",
        "98": " * are reflected in that iterator. These iterators never throw {@link\n",
        "99": " * ConcurrentModificationException}.\n",
        "101": " * <p><b>Note:</b> by default, the returned cache uses equality comparisons (the {@link\n",
        "102": " * Object#equals equals} method) to determine equality for keys or values. However, if {@link\n",
        "103": " * #weakKeys} was specified, the cache uses identity ({@code ==}) comparisons instead for keys.\n",
        "104": " * Likewise, if {@link #weakValues} or {@link #softValues} was specified, the cache uses identity\n",
        "105": " * comparisons for values.\n",
        "118": " * cache accesses, or on calls to {@link Cache#cleanUp}. Expired entries may be counted by {@link\n",
        "119": " * Cache#size}, but will never be visible to read or write operations.\n",
        "121": " * <p>If {@linkplain #weakKeys weakKeys}, {@linkplain #weakValues weakValues}, or {@linkplain\n",
        "122": " * #softValues softValues} are requested, it is possible for a key or value present in the cache to\n",
        "123": " * be reclaimed by the garbage collector. Entries with reclaimed keys or values may be removed from\n",
        "124": " * the cache on each cache modification, on occasional cache accesses, or on calls to {@link\n",
        "125": " * Cache#cleanUp}; such entries may be counted in {@link Cache#size}, but will never be visible to\n",
        "126": " * read or write operations.\n",
        "133": " * {@linkplain #expireAfterAccess expireAfterAccess}, {@linkplain #weakKeys weakKeys}, {@linkplain\n",
        "134": " * #weakValues weakValues}, or {@linkplain #softValues softValues} perform periodic maintenance.\n",
        "140": " * <p>See the Guava User Guide article on <a\n",
        "141": " * href=\"https://github.com/google/guava/wiki/CachesExplained\">caching</a> for a higher-level\n",
        "560": "   * Specifies that each value (not key) stored in the cache should be wrapped in a {@link\n",
        "561": "   * WeakReference} (by default, strong references are used).\n",
        "582": "   * Specifies that each value (not key) stored in the cache should be wrapped in a {@link\n",
        "583": "   * SoftReference} (by default, strong references are used). Softly-referenced objects will be\n",
        "584": "   * garbage-collected in a <i>globally</i> least-recently-used manner, in response to memory\n",
        "587": "   * <p><b>Warning:</b> in most circumstances it is better to set a per-cache {@linkplain\n",
        "588": "   * #maximumSize(long) maximum size} instead of using soft references. You should only use this\n",
        "589": "   * method if you are well familiar with the practical consequences of soft references.\n",
        "652": "   * access. Access time is reset by all cache read and write operations (including {@code\n",
        "653": "   * Cache.asMap().get(Object)} and {@code Cache.asMap().put(K, V)}), but not by operations on the\n",
        "654": "   * collection-views of {@link Cache#asMap}.\n",
        "690": "   * of refreshes are specified in {@link LoadingCache#refresh}, and are performed by calling {@link\n",
        "691": "   * CacheLoader#reload}.\n",
        "727": "   * Specifies a nanosecond-precision time source for this cache. By default, {@link\n",
        "728": "   * System#nanoTime} is used.\n",
        "832": "   * <p>Consider {@link #build(CacheLoader)} instead, if it is feasible to implement a {@code\n",
        "833": "   * CacheLoader}.\n"
    },
    "removed": {
        "44": " * <p>A builder of {@link LoadingCache} and {@link Cache} instances having any combination of the\n",
        "48": " * <li>automatic loading of entries into the cache\n",
        "49": " * <li>least-recently-used eviction when a maximum size is exceeded\n",
        "50": " * <li>time-based expiration of entries, measured since last access or last write\n",
        "51": " * <li>keys automatically wrapped in {@linkplain WeakReference weak} references\n",
        "52": " * <li>values automatically wrapped in {@linkplain WeakReference weak} or {@linkplain SoftReference\n",
        "53": " *     soft} references\n",
        "54": " * <li>notification of evicted (or otherwise removed) entries\n",
        "55": " * <li>accumulation of cache access statistics\n",
        "62": " * <p>Usage example: <pre>   {@code\n",
        "64": " *   LoadingCache<Key, Graph> graphs = CacheBuilder.newBuilder()\n",
        "65": " *       .maximumSize(10000)\n",
        "66": " *       .expireAfterWrite(10, TimeUnit.MINUTES)\n",
        "67": " *       .removalListener(MY_LISTENER)\n",
        "68": " *       .build(\n",
        "69": " *           new CacheLoader<Key, Graph>() {\n",
        "70": " *             public Graph load(Key key) throws AnyException {\n",
        "71": " *               return createExpensiveGraph(key);\n",
        "72": " *             }\n",
        "73": " *           });}</pre>\n",
        "75": " * <p>Or equivalently, <pre>   {@code\n",
        "77": " *   // In real life this would come from a command-line flag or config file\n",
        "78": " *   String spec = \"maximumSize=10000,expireAfterWrite=10m\";\n",
        "80": " *   LoadingCache<Key, Graph> graphs = CacheBuilder.from(spec)\n",
        "81": " *       .removalListener(MY_LISTENER)\n",
        "82": " *       .build(\n",
        "83": " *           new CacheLoader<Key, Graph>() {\n",
        "84": " *             public Graph load(Key key) throws AnyException {\n",
        "85": " *               return createExpensiveGraph(key);\n",
        "86": " *             }\n",
        "87": " *           });}</pre>\n",
        "94": " * are reflected in that iterator. These iterators never throw\n",
        "95": " * {@link ConcurrentModificationException}.\n",
        "97": " * <p><b>Note:</b> by default, the returned cache uses equality comparisons (the\n",
        "98": " * {@link Object#equals equals} method) to determine equality for keys or values. However, if\n",
        "99": " * {@link #weakKeys} was specified, the cache uses identity ({@code ==}) comparisons instead for\n",
        "100": " * keys. Likewise, if {@link #weakValues} or {@link #softValues} was specified, the cache uses\n",
        "101": " * identity comparisons for values.\n",
        "114": " * cache accesses, or on calls to {@link Cache#cleanUp}. Expired entries may be counted by\n",
        "115": " * {@link Cache#size}, but will never be visible to read or write operations.\n",
        "117": " * <p>If {@linkplain #weakKeys weakKeys}, {@linkplain #weakValues weakValues}, or\n",
        "118": " * {@linkplain #softValues softValues} are requested, it is possible for a key or value present in\n",
        "119": " * the cache to be reclaimed by the garbage collector. Entries with reclaimed keys or values may be\n",
        "120": " * removed from the cache on each cache modification, on occasional cache accesses, or on calls to\n",
        "121": " * {@link Cache#cleanUp}; such entries may be counted in {@link Cache#size}, but will never be\n",
        "122": " * visible to read or write operations.\n",
        "129": " * {@linkplain #expireAfterAccess expireAfterAccess}, {@linkplain #weakKeys weakKeys},\n",
        "130": " * {@linkplain #weakValues weakValues}, or {@linkplain #softValues softValues} perform periodic\n",
        "131": " * maintenance.\n",
        "137": " * <p>See the Guava User Guide article on\n",
        "138": " * <a href=\"https://github.com/google/guava/wiki/CachesExplained\">caching</a> for a higher-level\n",
        "557": "   * Specifies that each value (not key) stored in the cache should be wrapped in a\n",
        "558": "   * {@link WeakReference} (by default, strong references are used).\n",
        "579": "   * Specifies that each value (not key) stored in the cache should be wrapped in a\n",
        "580": "   * {@link SoftReference} (by default, strong references are used). Softly-referenced objects will\n",
        "581": "   * be garbage-collected in a <i>globally</i> least-recently-used manner, in response to memory\n",
        "584": "   * <p><b>Warning:</b> in most circumstances it is better to set a per-cache\n",
        "585": "   * {@linkplain #maximumSize(long) maximum size} instead of using soft references. You should only\n",
        "586": "   * use this method if you are well familiar with the practical consequences of soft references.\n",
        "649": "   * access. Access time is reset by all cache read and write operations (including\n",
        "650": "   * {@code Cache.asMap().get(Object)} and {@code Cache.asMap().put(K, V)}), but not by operations\n",
        "651": "   * on the collection-views of {@link Cache#asMap}.\n",
        "687": "   * of refreshes are specified in {@link LoadingCache#refresh}, and are performed by calling\n",
        "688": "   * {@link CacheLoader#reload}.\n",
        "724": "   * Specifies a nanosecond-precision time source for this cache. By default,\n",
        "725": "   * {@link System#nanoTime} is used.\n",
        "829": "   * <p>Consider {@link #build(CacheLoader)} instead, if it is feasible to implement a\n",
        "830": "   * {@code CacheLoader}.\n"
    }
}