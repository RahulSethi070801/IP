{
    "addition": {
        "31": " * A bounded {@linkplain BlockingQueue blocking queue} backed by an array. This queue orders\n",
        "32": " * elements FIFO (first-in-first-out). The <em>head</em> of the queue is that element that has been\n",
        "33": " * on the queue the longest time. The <em>tail</em> of the queue is that element that has been on\n",
        "34": " * the queue the shortest time. New elements are inserted at the tail of the queue, and the queue\n",
        "35": " * retrieval operations obtain elements at the head of the queue.\n",
        "37": " * <p>This is a classic &quot;bounded buffer&quot;, in which a fixed-sized array holds elements\n",
        "38": " * inserted by producers and extracted by consumers. Once created, the capacity cannot be increased.\n",
        "39": " * Attempts to <tt>put</tt> an element into a full queue will result in the operation blocking;\n",
        "40": " * attempts to <tt>take</tt> an element from an empty queue will similarly block.\n",
        "42": " * <p>This class supports an optional fairness policy for ordering waiting producer and consumer\n",
        "43": " * threads. By default, this ordering is not guaranteed. However, a queue constructed with fairness\n",
        "44": " * set to <tt>true</tt> grants threads access in FIFO order. Fairness generally decreases throughput\n",
        "45": " * but reduces variability and avoids starvation.\n",
        "47": " * <p>This class and its iterator implement all of the <em>optional</em> methods of the {@link\n",
        "48": " * Collection} and {@link Iterator} interfaces.\n",
        "58": "  // Based on revision 1.58 of ArrayBlockingQueue by Doug Lea, from\n",
        "59": "  // http://gee.cs.oswego.edu/cgi-bin/viewcvs.cgi/jsr166/src/main/java/util/concurrent/\n",
        "60": "\n",
        "61": "  /** The queued items */\n",
        "62": "  final E[] items;\n",
        "63": "  /** items index for next take, poll or remove */\n",
        "64": "  int takeIndex;\n",
        "65": "  /** items index for next put, offer, or add. */\n",
        "66": "  int putIndex;\n",
        "67": "  /** Number of items in the queue */\n",
        "68": "  private int count;\n",
        "69": "\n",
        "70": "  /*\n",
        "71": "   * Concurrency control uses the classic two-condition algorithm\n",
        "72": "   * found in any textbook.\n",
        "73": "   */\n",
        "74": "\n",
        "75": "  /** Monitor guarding all access */\n",
        "76": "  final Monitor monitor;\n",
        "77": "\n",
        "78": "  /** Guard for waiting takes */\n",
        "79": "  private final Monitor.Guard notEmpty;\n",
        "80": "\n",
        "81": "  /** Guard for waiting puts */\n",
        "82": "  private final Monitor.Guard notFull;\n",
        "83": "\n",
        "84": "  // Internal helper methods\n",
        "85": "\n",
        "86": "  /** Circularly increment i. */\n",
        "87": "  final int inc(int i) {\n",
        "88": "    return (++i == items.length) ? 0 : i;\n",
        "89": "  }\n",
        "90": "\n",
        "91": "  /**\n",
        "92": "   * Inserts element at current put position, advances, and signals. Call only when occupying\n",
        "93": "   * monitor.\n",
        "94": "   */\n",
        "95": "  private void insert(E x) {\n",
        "96": "    items[putIndex] = x;\n",
        "97": "    putIndex = inc(putIndex);\n",
        "98": "    ++count;\n",
        "99": "  }\n",
        "100": "\n",
        "101": "  /**\n",
        "102": "   * Extracts element at current take position, advances, and signals. Call only when occupying\n",
        "103": "   * monitor.\n",
        "104": "   */\n",
        "105": "  private E extract() {\n",
        "106": "    final E[] items = this.items;\n",
        "107": "    E x = items[takeIndex];\n",
        "108": "    items[takeIndex] = null;\n",
        "109": "    takeIndex = inc(takeIndex);\n",
        "110": "    --count;\n",
        "111": "    return x;\n",
        "112": "  }\n",
        "113": "\n",
        "114": "  /**\n",
        "115": "   * Utility for remove and iterator.remove: Delete item at position i. Call only when occupying\n",
        "116": "   * monitor.\n",
        "117": "   */\n",
        "118": "  void removeAt(int i) {\n",
        "119": "    final E[] items = this.items;\n",
        "120": "    // if removing front item, just advance\n",
        "121": "    if (i == takeIndex) {\n",
        "122": "      items[takeIndex] = null;\n",
        "123": "      takeIndex = inc(takeIndex);\n",
        "124": "    } else {\n",
        "125": "      // slide over all others up through putIndex.\n",
        "126": "      for (; ; ) {\n",
        "127": "        int nexti = inc(i);\n",
        "128": "        if (nexti != putIndex) {\n",
        "129": "          items[i] = items[nexti];\n",
        "130": "          i = nexti;\n",
        "132": "          items[i] = null;\n",
        "133": "          putIndex = i;\n",
        "134": "          break;\n",
        "136": "      }\n",
        "138": "    --count;\n",
        "139": "  }\n",
        "140": "\n",
        "141": "  /**\n",
        "142": "   * Creates an <tt>MonitorBasedArrayBlockingQueue</tt> with the given (fixed) capacity and default\n",
        "143": "   * access policy.\n",
        "144": "   *\n",
        "145": "   * @param capacity the capacity of this queue\n",
        "146": "   * @throws IllegalArgumentException if <tt>capacity</tt> is less than 1\n",
        "147": "   */\n",
        "148": "  public MonitorBasedArrayBlockingQueue(int capacity) {\n",
        "149": "    this(capacity, false);\n",
        "150": "  }\n",
        "151": "\n",
        "152": "  /**\n",
        "153": "   * Creates an <tt>MonitorBasedArrayBlockingQueue</tt> with the given (fixed) capacity and the\n",
        "154": "   * specified access policy.\n",
        "155": "   *\n",
        "156": "   * @param capacity the capacity of this queue\n",
        "157": "   * @param fair if <tt>true</tt> then queue accesses for threads blocked on insertion or removal,\n",
        "158": "   *     are processed in FIFO order; if <tt>false</tt> the access order is unspecified.\n",
        "159": "   * @throws IllegalArgumentException if <tt>capacity</tt> is less than 1\n",
        "160": "   */\n",
        "161": "  public MonitorBasedArrayBlockingQueue(int capacity, boolean fair) {\n",
        "162": "    if (capacity <= 0) throw new IllegalArgumentException();\n",
        "163": "    this.items = newEArray(capacity);\n",
        "164": "    monitor = new Monitor(fair);\n",
        "165": "    notEmpty =\n",
        "166": "        new Monitor.Guard(monitor) {\n",
        "167": "          @Override\n",
        "168": "          public boolean isSatisfied() {\n",
        "169": "            return count > 0;\n",
        "170": "          }\n",
        "172": "    notFull =\n",
        "173": "        new Monitor.Guard(monitor) {\n",
        "174": "          @Override\n",
        "175": "          public boolean isSatisfied() {\n",
        "176": "            return count < items.length;\n",
        "177": "          }\n",
        "179": "  }\n",
        "180": "\n",
        "181": "  @SuppressWarnings(\"unchecked\") // please don't try this home, kids\n",
        "182": "  private static <E> E[] newEArray(int capacity) {\n",
        "183": "    return (E[]) new Object[capacity];\n",
        "184": "  }\n",
        "185": "\n",
        "186": "  /**\n",
        "187": "   * Creates an <tt>MonitorBasedArrayBlockingQueue</tt> with the given (fixed) capacity, the\n",
        "188": "   * specified access policy and initially containing the elements of the given collection, added in\n",
        "189": "   * traversal order of the collection's iterator.\n",
        "190": "   *\n",
        "191": "   * @param capacity the capacity of this queue\n",
        "192": "   * @param fair if <tt>true</tt> then queue accesses for threads blocked on insertion or removal,\n",
        "193": "   *     are processed in FIFO order; if <tt>false</tt> the access order is unspecified.\n",
        "194": "   * @param c the collection of elements to initially contain\n",
        "195": "   * @throws IllegalArgumentException if <tt>capacity</tt> is less than <tt>c.size()</tt>, or less\n",
        "196": "   *     than 1.\n",
        "197": "   * @throws NullPointerException if the specified collection or any of its elements are null\n",
        "198": "   */\n",
        "199": "  public MonitorBasedArrayBlockingQueue(int capacity, boolean fair, Collection<? extends E> c) {\n",
        "200": "    this(capacity, fair);\n",
        "201": "    if (capacity < c.size()) throw new IllegalArgumentException();\n",
        "202": "\n",
        "203": "    for (E e : c) add(e);\n",
        "204": "  }\n",
        "205": "\n",
        "206": "  /**\n",
        "207": "   * Inserts the specified element at the tail of this queue if it is possible to do so immediately\n",
        "208": "   * without exceeding the queue's capacity, returning <tt>true</tt> upon success and throwing an\n",
        "209": "   * <tt>IllegalStateException</tt> if this queue is full.\n",
        "210": "   *\n",
        "211": "   * @param e the element to add\n",
        "212": "   * @return <tt>true</tt> (as specified by {@link Collection#add})\n",
        "213": "   * @throws IllegalStateException if this queue is full\n",
        "214": "   * @throws NullPointerException if the specified element is null\n",
        "215": "   */\n",
        "216": "  @Override\n",
        "217": "  public boolean add(E e) {\n",
        "218": "    return super.add(e);\n",
        "219": "  }\n",
        "220": "\n",
        "221": "  /**\n",
        "222": "   * Inserts the specified element at the tail of this queue if it is possible to do so immediately\n",
        "223": "   * without exceeding the queue's capacity, returning <tt>true</tt> upon success and <tt>false</tt>\n",
        "224": "   * if this queue is full. This method is generally preferable to method {@link #add}, which can\n",
        "225": "   * fail to insert an element only by throwing an exception.\n",
        "226": "   *\n",
        "227": "   * @throws NullPointerException if the specified element is null\n",
        "228": "   */\n",
        "229": "  @Override\n",
        "230": "  public boolean offer(E e) {\n",
        "231": "    if (e == null) throw new NullPointerException();\n",
        "232": "    final Monitor monitor = this.monitor;\n",
        "233": "    if (monitor.enterIf(notFull)) {\n",
        "234": "      try {\n",
        "235": "        insert(e);\n",
        "236": "        return true;\n",
        "237": "      } finally {\n",
        "238": "        monitor.leave();\n",
        "239": "      }\n",
        "240": "    } else {\n",
        "241": "      return false;\n",
        "243": "  }\n",
        "244": "\n",
        "245": "  /**\n",
        "246": "   * Inserts the specified element at the tail of this queue, waiting for space to become available\n",
        "247": "   * if the queue is full.\n",
        "248": "   *\n",
        "249": "   * @throws InterruptedException {@inheritDoc}\n",
        "250": "   * @throws NullPointerException {@inheritDoc}\n",
        "251": "   */\n",
        "252": "  @Override\n",
        "253": "  public void put(E e) throws InterruptedException {\n",
        "254": "    if (e == null) throw new NullPointerException();\n",
        "255": "    final Monitor monitor = this.monitor;\n",
        "256": "    monitor.enterWhen(notFull);\n",
        "257": "    try {\n",
        "258": "      insert(e);\n",
        "259": "    } finally {\n",
        "260": "      monitor.leave();\n",
        "262": "  }\n",
        "263": "\n",
        "264": "  /**\n",
        "265": "   * Inserts the specified element at the tail of this queue, waiting up to the specified wait time\n",
        "266": "   * for space to become available if the queue is full.\n",
        "267": "   *\n",
        "268": "   * @throws InterruptedException {@inheritDoc}\n",
        "269": "   * @throws NullPointerException {@inheritDoc}\n",
        "270": "   */\n",
        "271": "  @Override\n",
        "272": "  public boolean offer(E e, long timeout, TimeUnit unit) throws InterruptedException {\n",
        "273": "\n",
        "274": "    if (e == null) throw new NullPointerException();\n",
        "275": "    final Monitor monitor = this.monitor;\n",
        "276": "    if (monitor.enterWhen(notFull, timeout, unit)) {\n",
        "277": "      try {\n",
        "278": "        insert(e);\n",
        "279": "        return true;\n",
        "280": "      } finally {\n",
        "281": "        monitor.leave();\n",
        "282": "      }\n",
        "283": "    } else {\n",
        "284": "      return false;\n",
        "286": "  }\n",
        "287": "\n",
        "288": "  @Override\n",
        "289": "  public E poll() {\n",
        "290": "    final Monitor monitor = this.monitor;\n",
        "291": "    if (monitor.enterIf(notEmpty)) {\n",
        "292": "      try {\n",
        "293": "        return extract();\n",
        "294": "      } finally {\n",
        "295": "        monitor.leave();\n",
        "296": "      }\n",
        "297": "    } else {\n",
        "298": "      return null;\n",
        "300": "  }\n",
        "301": "\n",
        "302": "  @Override\n",
        "303": "  public E take() throws InterruptedException {\n",
        "304": "    final Monitor monitor = this.monitor;\n",
        "305": "    monitor.enterWhen(notEmpty);\n",
        "306": "    try {\n",
        "307": "      return extract();\n",
        "308": "    } finally {\n",
        "309": "      monitor.leave();\n",
        "311": "  }\n",
        "312": "\n",
        "313": "  @Override\n",
        "314": "  public E poll(long timeout, TimeUnit unit) throws InterruptedException {\n",
        "315": "    final Monitor monitor = this.monitor;\n",
        "316": "    if (monitor.enterWhen(notEmpty, timeout, unit)) {\n",
        "317": "      try {\n",
        "318": "        return extract();\n",
        "319": "      } finally {\n",
        "320": "        monitor.leave();\n",
        "321": "      }\n",
        "322": "    } else {\n",
        "323": "      return null;\n",
        "325": "  }\n",
        "326": "\n",
        "327": "  @Override\n",
        "328": "  public E peek() {\n",
        "329": "    final Monitor monitor = this.monitor;\n",
        "330": "    if (monitor.enterIf(notEmpty)) {\n",
        "331": "      try {\n",
        "332": "        return items[takeIndex];\n",
        "333": "      } finally {\n",
        "334": "        monitor.leave();\n",
        "335": "      }\n",
        "336": "    } else {\n",
        "337": "      return null;\n",
        "339": "  }\n",
        "340": "\n",
        "341": "  // this doc comment is overridden to remove the reference to collections\n",
        "342": "  // greater in size than Integer.MAX_VALUE\n",
        "343": "  /**\n",
        "344": "   * Returns the number of elements in this queue.\n",
        "345": "   *\n",
        "346": "   * @return the number of elements in this queue\n",
        "347": "   */\n",
        "348": "  @Override\n",
        "349": "  public int size() {\n",
        "350": "    final Monitor monitor = this.monitor;\n",
        "351": "    monitor.enter();\n",
        "352": "    try {\n",
        "353": "      return count;\n",
        "354": "    } finally {\n",
        "355": "      monitor.leave();\n",
        "357": "  }\n",
        "358": "\n",
        "359": "  // this doc comment is a modified copy of the inherited doc comment,\n",
        "360": "  // without the reference to unlimited queues.\n",
        "361": "  /**\n",
        "362": "   * Returns the number of additional elements that this queue can ideally (in the absence of memory\n",
        "363": "   * or resource constraints) accept without blocking. This is always equal to the initial capacity\n",
        "364": "   * of this queue less the current <tt>size</tt> of this queue.\n",
        "365": "   *\n",
        "366": "   * <p>Note that you <em>cannot</em> always tell if an attempt to insert an element will succeed by\n",
        "367": "   * inspecting <tt>remainingCapacity</tt> because it may be the case that another thread is about\n",
        "368": "   * to insert or remove an element.\n",
        "369": "   */\n",
        "370": "  @Override\n",
        "371": "  public int remainingCapacity() {\n",
        "372": "    final Monitor monitor = this.monitor;\n",
        "373": "    monitor.enter();\n",
        "374": "    try {\n",
        "375": "      return items.length - count;\n",
        "376": "    } finally {\n",
        "377": "      monitor.leave();\n",
        "379": "  }\n",
        "380": "\n",
        "381": "  /**\n",
        "382": "   * Removes a single instance of the specified element from this queue, if it is present. More\n",
        "383": "   * formally, removes an element <tt>e</tt> such that <tt>o.equals(e)</tt>, if this queue contains\n",
        "384": "   * one or more such elements. Returns <tt>true</tt> if this queue contained the specified element\n",
        "385": "   * (or equivalently, if this queue changed as a result of the call).\n",
        "386": "   *\n",
        "387": "   * @param o element to be removed from this queue, if present\n",
        "388": "   * @return <tt>true</tt> if this queue changed as a result of the call\n",
        "389": "   */\n",
        "390": "  @Override\n",
        "391": "  public boolean remove(@Nullable Object o) {\n",
        "392": "    if (o == null) return false;\n",
        "393": "    final E[] items = this.items;\n",
        "394": "    final Monitor monitor = this.monitor;\n",
        "395": "    monitor.enter();\n",
        "396": "    try {\n",
        "397": "      int i = takeIndex;\n",
        "398": "      int k = 0;\n",
        "399": "      for (; ; ) {\n",
        "400": "        if (k++ >= count) return false;\n",
        "401": "        if (o.equals(items[i])) {\n",
        "402": "          removeAt(i);\n",
        "403": "          return true;\n",
        "405": "        i = inc(i);\n",
        "406": "      }\n",
        "407": "    } finally {\n",
        "408": "      monitor.leave();\n",
        "410": "  }\n",
        "411": "\n",
        "412": "  /**\n",
        "413": "   * Returns <tt>true</tt> if this queue contains the specified element. More formally, returns\n",
        "414": "   * <tt>true</tt> if and only if this queue contains at least one element <tt>e</tt> such that\n",
        "415": "   * <tt>o.equals(e)</tt>.\n",
        "416": "   *\n",
        "417": "   * @param o object to be checked for containment in this queue\n",
        "418": "   * @return <tt>true</tt> if this queue contains the specified element\n",
        "419": "   */\n",
        "420": "  @Override\n",
        "421": "  public boolean contains(@Nullable Object o) {\n",
        "422": "    if (o == null) return false;\n",
        "423": "    final E[] items = this.items;\n",
        "424": "    final Monitor monitor = this.monitor;\n",
        "425": "    monitor.enter();\n",
        "426": "    try {\n",
        "427": "      int i = takeIndex;\n",
        "428": "      int k = 0;\n",
        "429": "      while (k++ < count) {\n",
        "430": "        if (o.equals(items[i])) return true;\n",
        "431": "        i = inc(i);\n",
        "432": "      }\n",
        "433": "      return false;\n",
        "434": "    } finally {\n",
        "435": "      monitor.leave();\n",
        "437": "  }\n",
        "438": "\n",
        "439": "  /**\n",
        "440": "   * Returns an array containing all of the elements in this queue, in proper sequence.\n",
        "441": "   *\n",
        "442": "   * <p>The returned array will be \"safe\" in that no references to it are maintained by this queue.\n",
        "443": "   * (In other words, this method must allocate a new array). The caller is thus free to modify the\n",
        "444": "   * returned array.\n",
        "445": "   *\n",
        "446": "   * <p>This method acts as bridge between array-based and collection-based APIs.\n",
        "447": "   *\n",
        "448": "   * @return an array containing all of the elements in this queue\n",
        "449": "   */\n",
        "450": "  @Override\n",
        "451": "  public Object[] toArray() {\n",
        "452": "    final E[] items = this.items;\n",
        "453": "    final Monitor monitor = this.monitor;\n",
        "454": "    monitor.enter();\n",
        "455": "    try {\n",
        "456": "      Object[] a = new Object[count];\n",
        "457": "      int k = 0;\n",
        "458": "      int i = takeIndex;\n",
        "459": "      while (k < count) {\n",
        "460": "        a[k++] = items[i];\n",
        "461": "        i = inc(i);\n",
        "462": "      }\n",
        "463": "      return a;\n",
        "464": "    } finally {\n",
        "465": "      monitor.leave();\n",
        "467": "  }\n",
        "468": "\n",
        "469": "  /**\n",
        "470": "   * Returns an array containing all of the elements in this queue, in proper sequence; the runtime\n",
        "471": "   * type of the returned array is that of the specified array. If the queue fits in the specified\n",
        "472": "   * array, it is returned therein. Otherwise, a new array is allocated with the runtime type of the\n",
        "473": "   * specified array and the size of this queue.\n",
        "474": "   *\n",
        "475": "   * <p>If this queue fits in the specified array with room to spare (i.e., the array has more\n",
        "476": "   * elements than this queue), the element in the array immediately following the end of the queue\n",
        "477": "   * is set to <tt>null</tt>.\n",
        "478": "   *\n",
        "479": "   * <p>Like the {@link #toArray()} method, this method acts as bridge between array-based and\n",
        "480": "   * collection-based APIs. Further, this method allows precise control over the runtime type of the\n",
        "481": "   * output array, and may, under certain circumstances, be used to save allocation costs.\n",
        "482": "   *\n",
        "483": "   * <p>Suppose <tt>x</tt> is a queue known to contain only strings. The following code can be used\n",
        "484": "   * to dump the queue into a newly allocated array of <tt>String</tt>:\n",
        "485": "   *\n",
        "486": "   * <pre>\n",
        "487": "   *     String[] y = x.toArray(new String[0]);</pre>\n",
        "488": "   *\n",
        "489": "   * <p>Note that <tt>toArray(new Object[0])</tt> is identical in function to <tt>toArray()</tt>.\n",
        "490": "   *\n",
        "491": "   * @param a the array into which the elements of the queue are to be stored, if it is big enough;\n",
        "492": "   *     otherwise, a new array of the same runtime type is allocated for this purpose\n",
        "493": "   * @return an array containing all of the elements in this queue\n",
        "494": "   * @throws ArrayStoreException if the runtime type of the specified array is not a supertype of\n",
        "495": "   *     the runtime type of every element in this queue\n",
        "496": "   * @throws NullPointerException if the specified array is null\n",
        "497": "   */\n",
        "498": "  @Override\n",
        "499": "  public <T> T[] toArray(T[] a) {\n",
        "500": "    final E[] items = this.items;\n",
        "501": "    final Monitor monitor = this.monitor;\n",
        "502": "    monitor.enter();\n",
        "503": "    try {\n",
        "504": "      if (a.length < count) a = ObjectArrays.newArray(a, count);\n",
        "505": "\n",
        "506": "      int k = 0;\n",
        "507": "      int i = takeIndex;\n",
        "508": "      while (k < count) {\n",
        "509": "        // This cast is not itself safe, but the following statement\n",
        "510": "        // will fail if the runtime type of items[i] is not assignable\n",
        "511": "        // to the runtime type of a[k++], which is all that the method\n",
        "512": "        // contract requires (see @throws ArrayStoreException above).\n",
        "513": "        @SuppressWarnings(\"unchecked\")\n",
        "514": "        T t = (T) items[i];\n",
        "515": "        a[k++] = t;\n",
        "516": "        i = inc(i);\n",
        "517": "      }\n",
        "518": "      if (a.length > count) a[count] = null;\n",
        "519": "      return a;\n",
        "520": "    } finally {\n",
        "521": "      monitor.leave();\n",
        "523": "  }\n",
        "524": "\n",
        "525": "  @Override\n",
        "526": "  public String toString() {\n",
        "527": "    final Monitor monitor = this.monitor;\n",
        "528": "    monitor.enter();\n",
        "529": "    try {\n",
        "530": "      return super.toString();\n",
        "531": "    } finally {\n",
        "532": "      monitor.leave();\n",
        "534": "  }\n",
        "535": "\n",
        "536": "  /**\n",
        "537": "   * Atomically removes all of the elements from this queue. The queue will be empty after this call\n",
        "538": "   * returns.\n",
        "539": "   */\n",
        "540": "  @Override\n",
        "541": "  public void clear() {\n",
        "542": "    final E[] items = this.items;\n",
        "543": "    final Monitor monitor = this.monitor;\n",
        "544": "    monitor.enter();\n",
        "545": "    try {\n",
        "546": "      int i = takeIndex;\n",
        "547": "      int k = count;\n",
        "548": "      while (k-- > 0) {\n",
        "549": "        items[i] = null;\n",
        "550": "        i = inc(i);\n",
        "551": "      }\n",
        "552": "      count = 0;\n",
        "553": "      putIndex = 0;\n",
        "554": "      takeIndex = 0;\n",
        "555": "    } finally {\n",
        "556": "      monitor.leave();\n",
        "558": "  }\n",
        "559": "\n",
        "560": "  /**\n",
        "561": "   * @throws UnsupportedOperationException {@inheritDoc}\n",
        "562": "   * @throws ClassCastException {@inheritDoc}\n",
        "563": "   * @throws NullPointerException {@inheritDoc}\n",
        "564": "   * @throws IllegalArgumentException {@inheritDoc}\n",
        "565": "   */\n",
        "566": "  @Override\n",
        "567": "  public int drainTo(Collection<? super E> c) {\n",
        "568": "    if (c == null) throw new NullPointerException();\n",
        "569": "    if (c == this) throw new IllegalArgumentException();\n",
        "570": "    final E[] items = this.items;\n",
        "571": "    final Monitor monitor = this.monitor;\n",
        "572": "    monitor.enter();\n",
        "573": "    try {\n",
        "574": "      int i = takeIndex;\n",
        "575": "      int n = 0;\n",
        "576": "      int max = count;\n",
        "577": "      while (n < max) {\n",
        "578": "        c.add(items[i]);\n",
        "579": "        items[i] = null;\n",
        "580": "        i = inc(i);\n",
        "581": "        ++n;\n",
        "582": "      }\n",
        "583": "      if (n > 0) {\n",
        "584": "        count = 0;\n",
        "585": "        putIndex = 0;\n",
        "586": "        takeIndex = 0;\n",
        "587": "      }\n",
        "588": "      return n;\n",
        "589": "    } finally {\n",
        "590": "      monitor.leave();\n",
        "592": "  }\n",
        "593": "\n",
        "594": "  /**\n",
        "595": "   * @throws UnsupportedOperationException {@inheritDoc}\n",
        "596": "   * @throws ClassCastException {@inheritDoc}\n",
        "597": "   * @throws NullPointerException {@inheritDoc}\n",
        "598": "   * @throws IllegalArgumentException {@inheritDoc}\n",
        "599": "   */\n",
        "600": "  @Override\n",
        "601": "  public int drainTo(Collection<? super E> c, int maxElements) {\n",
        "602": "    if (c == null) throw new NullPointerException();\n",
        "603": "    if (c == this) throw new IllegalArgumentException();\n",
        "604": "    if (maxElements <= 0) return 0;\n",
        "605": "    final E[] items = this.items;\n",
        "606": "    final Monitor monitor = this.monitor;\n",
        "607": "    monitor.enter();\n",
        "608": "    try {\n",
        "609": "      int i = takeIndex;\n",
        "610": "      int n = 0;\n",
        "611": "      int max = (maxElements < count) ? maxElements : count;\n",
        "612": "      while (n < max) {\n",
        "613": "        c.add(items[i]);\n",
        "614": "        items[i] = null;\n",
        "615": "        i = inc(i);\n",
        "616": "        ++n;\n",
        "617": "      }\n",
        "618": "      if (n > 0) {\n",
        "619": "        count -= n;\n",
        "620": "        takeIndex = i;\n",
        "621": "      }\n",
        "622": "      return n;\n",
        "623": "    } finally {\n",
        "624": "      monitor.leave();\n",
        "626": "  }\n",
        "627": "\n",
        "628": "  /**\n",
        "629": "   * Returns an iterator over the elements in this queue in proper sequence. The returned\n",
        "630": "   * <tt>Iterator</tt> is a \"weakly consistent\" iterator that will never throw {@link\n",
        "631": "   * ConcurrentModificationException}, and guarantees to traverse elements as they existed upon\n",
        "632": "   * construction of the iterator, and may (but is not guaranteed to) reflect any modifications\n",
        "633": "   * subsequent to construction.\n",
        "634": "   *\n",
        "635": "   * @return an iterator over the elements in this queue in proper sequence\n",
        "636": "   */\n",
        "637": "  @Override\n",
        "638": "  public Iterator<E> iterator() {\n",
        "639": "    final Monitor monitor = this.monitor;\n",
        "640": "    monitor.enter();\n",
        "641": "    try {\n",
        "642": "      return new Itr();\n",
        "643": "    } finally {\n",
        "644": "      monitor.leave();\n",
        "646": "  }\n",
        "647": "\n",
        "648": "  /** Iterator for MonitorBasedArrayBlockingQueue */\n",
        "649": "  private class Itr implements Iterator<E> {\n",
        "650": "    /** Index of element to be returned by next, or a negative number if no such. */\n",
        "651": "    private int nextIndex;\n",
        "654": "     * nextItem holds on to item fields because once we claim that an element exists in hasNext(),\n",
        "655": "     * we must return it in the following next() call even if it was in the process of being removed\n",
        "656": "     * when hasNext() was called.\n",
        "658": "    private E nextItem;\n",
        "661": "     * Index of element returned by most recent call to next. Reset to -1 if this element is deleted\n",
        "662": "     * by a call to remove.\n",
        "664": "    private int lastRet;\n",
        "665": "\n",
        "666": "    Itr() {\n",
        "667": "      lastRet = -1;\n",
        "668": "      if (count == 0) nextIndex = -1;\n",
        "669": "      else {\n",
        "670": "        nextIndex = takeIndex;\n",
        "671": "        nextItem = items[takeIndex];\n",
        "672": "      }\n",
        "676": "    public boolean hasNext() {\n",
        "677": "      /*\n",
        "678": "       * No sync. We can return true by mistake here\n",
        "679": "       * only if this iterator passed across threads,\n",
        "680": "       * which we don't support anyway.\n",
        "681": "       */\n",
        "682": "      return nextIndex >= 0;\n",
        "686": "     * Checks whether nextIndex is valid; if so setting nextItem. Stops iterator when either hits\n",
        "687": "     * putIndex or sees null item.\n",
        "689": "    private void checkNext() {\n",
        "690": "      if (nextIndex == putIndex) {\n",
        "691": "        nextIndex = -1;\n",
        "692": "        nextItem = null;\n",
        "693": "      } else {\n",
        "694": "        nextItem = items[nextIndex];\n",
        "695": "        if (nextItem == null) nextIndex = -1;\n",
        "696": "      }\n",
        "699": "    @Override\n",
        "700": "    public E next() {\n",
        "701": "      final Monitor monitor = MonitorBasedArrayBlockingQueue.this.monitor;\n",
        "702": "      monitor.enter();\n",
        "703": "      try {\n",
        "704": "        if (nextIndex < 0) throw new NoSuchElementException();\n",
        "705": "        lastRet = nextIndex;\n",
        "706": "        E x = nextItem;\n",
        "707": "        nextIndex = inc(nextIndex);\n",
        "708": "        checkNext();\n",
        "709": "        return x;\n",
        "710": "      } finally {\n",
        "711": "        monitor.leave();\n",
        "712": "      }\n",
        "713": "    }\n",
        "715": "    @Override\n",
        "716": "    public void remove() {\n",
        "717": "      final Monitor monitor = MonitorBasedArrayBlockingQueue.this.monitor;\n",
        "718": "      monitor.enter();\n",
        "719": "      try {\n",
        "720": "        int i = lastRet;\n",
        "721": "        if (i == -1) throw new IllegalStateException();\n",
        "722": "        lastRet = -1;\n",
        "723": "\n",
        "724": "        int ti = takeIndex;\n",
        "725": "        removeAt(i);\n",
        "726": "        // back up cursor (reset to front if was first element)\n",
        "727": "        nextIndex = (i == ti) ? takeIndex : i;\n",
        "728": "        checkNext();\n",
        "729": "      } finally {\n",
        "730": "        monitor.leave();\n",
        "731": "      }\n",
        "733": "  }\n"
    },
    "removed": {
        "31": " * A bounded {@linkplain BlockingQueue blocking queue} backed by an\n",
        "32": " * array.  This queue orders elements FIFO (first-in-first-out).  The\n",
        "33": " * <em>head</em> of the queue is that element that has been on the\n",
        "34": " * queue the longest time.  The <em>tail</em> of the queue is that\n",
        "35": " * element that has been on the queue the shortest time. New elements\n",
        "36": " * are inserted at the tail of the queue, and the queue retrieval\n",
        "37": " * operations obtain elements at the head of the queue.\n",
        "39": " * <p>This is a classic &quot;bounded buffer&quot;, in which a\n",
        "40": " * fixed-sized array holds elements inserted by producers and\n",
        "41": " * extracted by consumers.  Once created, the capacity cannot be\n",
        "42": " * increased.  Attempts to <tt>put</tt> an element into a full queue\n",
        "43": " * will result in the operation blocking; attempts to <tt>take</tt> an\n",
        "44": " * element from an empty queue will similarly block.\n",
        "46": " * <p> This class supports an optional fairness policy for ordering\n",
        "47": " * waiting producer and consumer threads.  By default, this ordering\n",
        "48": " * is not guaranteed. However, a queue constructed with fairness set\n",
        "49": " * to <tt>true</tt> grants threads access in FIFO order. Fairness\n",
        "50": " * generally decreases throughput but reduces variability and avoids\n",
        "51": " * starvation.\n",
        "53": " * <p>This class and its iterator implement all of the\n",
        "54": " * <em>optional</em> methods of the {@link Collection} and {@link\n",
        "55": " * Iterator} interfaces.\n",
        "65": "    // Based on revision 1.58 of ArrayBlockingQueue by Doug Lea, from\n",
        "66": "    // http://gee.cs.oswego.edu/cgi-bin/viewcvs.cgi/jsr166/src/main/java/util/concurrent/\n",
        "67": "\n",
        "68": "    /** The queued items  */\n",
        "69": "    final E[] items;\n",
        "70": "    /** items index for next take, poll or remove */\n",
        "71": "    int takeIndex;\n",
        "72": "    /** items index for next put, offer, or add. */\n",
        "73": "    int putIndex;\n",
        "74": "    /** Number of items in the queue */\n",
        "75": "    private int count;\n",
        "76": "\n",
        "77": "    /*\n",
        "78": "     * Concurrency control uses the classic two-condition algorithm\n",
        "79": "     * found in any textbook.\n",
        "80": "     */\n",
        "81": "\n",
        "82": "    /** Monitor guarding all access */\n",
        "83": "    final Monitor monitor;\n",
        "84": "\n",
        "85": "    /** Guard for waiting takes */\n",
        "86": "    private final Monitor.Guard notEmpty;\n",
        "87": "\n",
        "88": "    /** Guard for waiting puts */\n",
        "89": "    private final Monitor.Guard notFull;\n",
        "90": "\n",
        "91": "    // Internal helper methods\n",
        "92": "\n",
        "93": "    /**\n",
        "94": "     * Circularly increment i.\n",
        "95": "     */\n",
        "96": "    final int inc(int i) {\n",
        "97": "        return (++i == items.length) ? 0 : i;\n",
        "98": "    }\n",
        "99": "\n",
        "100": "    /**\n",
        "101": "     * Inserts element at current put position, advances, and signals.\n",
        "102": "     * Call only when occupying monitor.\n",
        "103": "     */\n",
        "104": "    private void insert(E x) {\n",
        "105": "        items[putIndex] = x;\n",
        "106": "        putIndex = inc(putIndex);\n",
        "107": "        ++count;\n",
        "108": "    }\n",
        "109": "\n",
        "110": "    /**\n",
        "111": "     * Extracts element at current take position, advances, and signals.\n",
        "112": "     * Call only when occupying monitor.\n",
        "113": "     */\n",
        "114": "    private E extract() {\n",
        "115": "        final E[] items = this.items;\n",
        "116": "        E x = items[takeIndex];\n",
        "117": "        items[takeIndex] = null;\n",
        "118": "        takeIndex = inc(takeIndex);\n",
        "119": "        --count;\n",
        "120": "        return x;\n",
        "121": "    }\n",
        "122": "\n",
        "123": "    /**\n",
        "124": "     * Utility for remove and iterator.remove: Delete item at position i.\n",
        "125": "     * Call only when occupying monitor.\n",
        "126": "     */\n",
        "127": "    void removeAt(int i) {\n",
        "128": "        final E[] items = this.items;\n",
        "129": "        // if removing front item, just advance\n",
        "130": "        if (i == takeIndex) {\n",
        "131": "            items[takeIndex] = null;\n",
        "132": "            takeIndex = inc(takeIndex);\n",
        "134": "            // slide over all others up through putIndex.\n",
        "135": "            for (;;) {\n",
        "136": "                int nexti = inc(i);\n",
        "137": "                if (nexti != putIndex) {\n",
        "138": "                    items[i] = items[nexti];\n",
        "139": "                    i = nexti;\n",
        "140": "                } else {\n",
        "141": "                    items[i] = null;\n",
        "142": "                    putIndex = i;\n",
        "143": "                    break;\n",
        "144": "                }\n",
        "145": "            }\n",
        "147": "        --count;\n",
        "148": "    }\n",
        "149": "\n",
        "150": "    /**\n",
        "151": "     * Creates an <tt>MonitorBasedArrayBlockingQueue</tt> with the given (fixed)\n",
        "152": "     * capacity and default access policy.\n",
        "153": "     *\n",
        "154": "     * @param capacity the capacity of this queue\n",
        "155": "     * @throws IllegalArgumentException if <tt>capacity</tt> is less than 1\n",
        "156": "     */\n",
        "157": "    public MonitorBasedArrayBlockingQueue(int capacity) {\n",
        "158": "        this(capacity, false);\n",
        "160": "\n",
        "161": "    /**\n",
        "162": "     * Creates an <tt>MonitorBasedArrayBlockingQueue</tt> with the given (fixed)\n",
        "163": "     * capacity and the specified access policy.\n",
        "164": "     *\n",
        "165": "     * @param capacity the capacity of this queue\n",
        "166": "     * @param fair if <tt>true</tt> then queue accesses for threads blocked\n",
        "167": "     *        on insertion or removal, are processed in FIFO order;\n",
        "168": "     *        if <tt>false</tt> the access order is unspecified.\n",
        "169": "     * @throws IllegalArgumentException if <tt>capacity</tt> is less than 1\n",
        "170": "     */\n",
        "171": "    public MonitorBasedArrayBlockingQueue(int capacity, boolean fair) {\n",
        "172": "        if (capacity <= 0)\n",
        "173": "            throw new IllegalArgumentException();\n",
        "174": "        this.items = newEArray(capacity);\n",
        "175": "        monitor = new Monitor(fair);\n",
        "176": "        notEmpty = new Monitor.Guard(monitor) {\n",
        "177": "            @Override public boolean isSatisfied() {\n",
        "178": "                return count > 0;\n",
        "179": "            }\n",
        "181": "        notFull = new Monitor.Guard(monitor) {\n",
        "182": "            @Override public boolean isSatisfied() {\n",
        "183": "                return count < items.length;\n",
        "184": "            }\n",
        "187": "\n",
        "188": "    @SuppressWarnings(\"unchecked\") // please don't try this home, kids\n",
        "189": "    private static <E> E[] newEArray(int capacity) {\n",
        "190": "        return (E[]) new Object[capacity];\n",
        "192": "\n",
        "193": "    /**\n",
        "194": "     * Creates an <tt>MonitorBasedArrayBlockingQueue</tt> with the given (fixed)\n",
        "195": "     * capacity, the specified access policy and initially containing the\n",
        "196": "     * elements of the given collection,\n",
        "197": "     * added in traversal order of the collection's iterator.\n",
        "198": "     *\n",
        "199": "     * @param capacity the capacity of this queue\n",
        "200": "     * @param fair if <tt>true</tt> then queue accesses for threads blocked\n",
        "201": "     *        on insertion or removal, are processed in FIFO order;\n",
        "202": "     *        if <tt>false</tt> the access order is unspecified.\n",
        "203": "     * @param c the collection of elements to initially contain\n",
        "204": "     * @throws IllegalArgumentException if <tt>capacity</tt> is less than\n",
        "205": "     *         <tt>c.size()</tt>, or less than 1.\n",
        "206": "     * @throws NullPointerException if the specified collection or any\n",
        "207": "     *         of its elements are null\n",
        "208": "     */\n",
        "209": "    public MonitorBasedArrayBlockingQueue(int capacity, boolean fair,\n",
        "210": "                              Collection<? extends E> c) {\n",
        "211": "        this(capacity, fair);\n",
        "212": "        if (capacity < c.size())\n",
        "213": "            throw new IllegalArgumentException();\n",
        "214": "\n",
        "215": "        for (E e : c)\n",
        "216": "            add(e);\n",
        "218": "\n",
        "219": "    /**\n",
        "220": "     * Inserts the specified element at the tail of this queue if it is\n",
        "221": "     * possible to do so immediately without exceeding the queue's capacity,\n",
        "222": "     * returning <tt>true</tt> upon success and throwing an\n",
        "223": "     * <tt>IllegalStateException</tt> if this queue is full.\n",
        "224": "     *\n",
        "225": "     * @param e the element to add\n",
        "226": "     * @return <tt>true</tt> (as specified by {@link Collection#add})\n",
        "227": "     * @throws IllegalStateException if this queue is full\n",
        "228": "     * @throws NullPointerException if the specified element is null\n",
        "229": "     */\n",
        "230": "    @Override public boolean add(E e) {\n",
        "231": "        return super.add(e);\n",
        "233": "\n",
        "234": "    /**\n",
        "235": "     * Inserts the specified element at the tail of this queue if it is\n",
        "236": "     * possible to do so immediately without exceeding the queue's capacity,\n",
        "237": "     * returning <tt>true</tt> upon success and <tt>false</tt> if this queue\n",
        "238": "     * is full.  This method is generally preferable to method {@link #add},\n",
        "239": "     * which can fail to insert an element only by throwing an exception.\n",
        "240": "     *\n",
        "241": "     * @throws NullPointerException if the specified element is null\n",
        "242": "     */\n",
        "243": "    @Override\n",
        "244": "    public boolean offer(E e) {\n",
        "245": "        if (e == null) throw new NullPointerException();\n",
        "246": "        final Monitor monitor = this.monitor;\n",
        "247": "        if (monitor.enterIf(notFull)) {\n",
        "248": "            try {\n",
        "249": "                insert(e);\n",
        "250": "                return true;\n",
        "251": "            } finally {\n",
        "252": "                monitor.leave();\n",
        "253": "            }\n",
        "254": "        } else {\n",
        "255": "          return false;\n",
        "256": "        }\n",
        "258": "\n",
        "259": "    /**\n",
        "260": "     * Inserts the specified element at the tail of this queue, waiting\n",
        "261": "     * for space to become available if the queue is full.\n",
        "262": "     *\n",
        "263": "     * @throws InterruptedException {@inheritDoc}\n",
        "264": "     * @throws NullPointerException {@inheritDoc}\n",
        "265": "     */\n",
        "266": "    @Override\n",
        "267": "    public void put(E e) throws InterruptedException {\n",
        "268": "        if (e == null) throw new NullPointerException();\n",
        "269": "        final Monitor monitor = this.monitor;\n",
        "270": "        monitor.enterWhen(notFull);\n",
        "271": "        try {\n",
        "272": "            insert(e);\n",
        "273": "        } finally {\n",
        "274": "            monitor.leave();\n",
        "275": "        }\n",
        "277": "\n",
        "278": "    /**\n",
        "279": "     * Inserts the specified element at the tail of this queue, waiting\n",
        "280": "     * up to the specified wait time for space to become available if\n",
        "281": "     * the queue is full.\n",
        "282": "     *\n",
        "283": "     * @throws InterruptedException {@inheritDoc}\n",
        "284": "     * @throws NullPointerException {@inheritDoc}\n",
        "285": "     */\n",
        "286": "    @Override\n",
        "287": "    public boolean offer(E e, long timeout, TimeUnit unit)\n",
        "288": "        throws InterruptedException {\n",
        "289": "\n",
        "290": "        if (e == null) throw new NullPointerException();\n",
        "291": "        final Monitor monitor = this.monitor;\n",
        "292": "        if (monitor.enterWhen(notFull, timeout, unit)) {\n",
        "293": "            try {\n",
        "294": "                insert(e);\n",
        "295": "                return true;\n",
        "296": "            } finally {\n",
        "297": "                monitor.leave();\n",
        "298": "            }\n",
        "299": "        } else {\n",
        "300": "          return false;\n",
        "301": "        }\n",
        "303": "\n",
        "304": "    @Override\n",
        "305": "    public E poll() {\n",
        "306": "        final Monitor monitor = this.monitor;\n",
        "307": "        if (monitor.enterIf(notEmpty)) {\n",
        "308": "            try {\n",
        "309": "                return extract();\n",
        "310": "            } finally {\n",
        "311": "                monitor.leave();\n",
        "312": "            }\n",
        "313": "        } else {\n",
        "314": "          return null;\n",
        "315": "        }\n",
        "317": "\n",
        "318": "    @Override\n",
        "319": "    public E take() throws InterruptedException {\n",
        "320": "        final Monitor monitor = this.monitor;\n",
        "321": "        monitor.enterWhen(notEmpty);\n",
        "322": "        try {\n",
        "323": "            return extract();\n",
        "324": "        } finally {\n",
        "325": "            monitor.leave();\n",
        "326": "        }\n",
        "328": "\n",
        "329": "    @Override\n",
        "330": "    public E poll(long timeout, TimeUnit unit) throws InterruptedException {\n",
        "331": "        final Monitor monitor = this.monitor;\n",
        "332": "        if (monitor.enterWhen(notEmpty, timeout, unit)) {\n",
        "333": "            try {\n",
        "334": "                return extract();\n",
        "335": "            } finally {\n",
        "336": "                monitor.leave();\n",
        "337": "            }\n",
        "338": "        } else {\n",
        "339": "          return null;\n",
        "342": "\n",
        "343": "    @Override\n",
        "344": "    public E peek() {\n",
        "345": "        final Monitor monitor = this.monitor;\n",
        "346": "        if (monitor.enterIf(notEmpty)) {\n",
        "347": "            try {\n",
        "348": "                return items[takeIndex];\n",
        "349": "            } finally {\n",
        "350": "                monitor.leave();\n",
        "351": "            }\n",
        "352": "        } else {\n",
        "353": "            return null;\n",
        "354": "        }\n",
        "356": "\n",
        "357": "    // this doc comment is overridden to remove the reference to collections\n",
        "358": "    // greater in size than Integer.MAX_VALUE\n",
        "359": "    /**\n",
        "360": "     * Returns the number of elements in this queue.\n",
        "361": "     *\n",
        "362": "     * @return the number of elements in this queue\n",
        "363": "     */\n",
        "364": "    @Override public int size() {\n",
        "365": "        final Monitor monitor = this.monitor;\n",
        "366": "        monitor.enter();\n",
        "367": "        try {\n",
        "368": "            return count;\n",
        "369": "        } finally {\n",
        "370": "            monitor.leave();\n",
        "371": "        }\n",
        "373": "\n",
        "374": "    // this doc comment is a modified copy of the inherited doc comment,\n",
        "375": "    // without the reference to unlimited queues.\n",
        "376": "    /**\n",
        "377": "     * Returns the number of additional elements that this queue can ideally\n",
        "378": "     * (in the absence of memory or resource constraints) accept without\n",
        "379": "     * blocking. This is always equal to the initial capacity of this queue\n",
        "380": "     * less the current <tt>size</tt> of this queue.\n",
        "381": "     *\n",
        "382": "     * <p>Note that you <em>cannot</em> always tell if an attempt to insert\n",
        "383": "     * an element will succeed by inspecting <tt>remainingCapacity</tt>\n",
        "384": "     * because it may be the case that another thread is about to\n",
        "385": "     * insert or remove an element.\n",
        "386": "     */\n",
        "387": "    @Override\n",
        "388": "    public int remainingCapacity() {\n",
        "389": "        final Monitor monitor = this.monitor;\n",
        "390": "        monitor.enter();\n",
        "391": "        try {\n",
        "392": "            return items.length - count;\n",
        "393": "        } finally {\n",
        "394": "            monitor.leave();\n",
        "395": "        }\n",
        "397": "\n",
        "398": "    /**\n",
        "399": "     * Removes a single instance of the specified element from this queue,\n",
        "400": "     * if it is present.  More formally, removes an element <tt>e</tt> such\n",
        "401": "     * that <tt>o.equals(e)</tt>, if this queue contains one or more such\n",
        "402": "     * elements.\n",
        "403": "     * Returns <tt>true</tt> if this queue contained the specified element\n",
        "404": "     * (or equivalently, if this queue changed as a result of the call).\n",
        "405": "     *\n",
        "406": "     * @param o element to be removed from this queue, if present\n",
        "407": "     * @return <tt>true</tt> if this queue changed as a result of the call\n",
        "408": "     */\n",
        "409": "    @Override public boolean remove(@Nullable Object o) {\n",
        "410": "        if (o == null) return false;\n",
        "411": "        final E[] items = this.items;\n",
        "412": "        final Monitor monitor = this.monitor;\n",
        "413": "        monitor.enter();\n",
        "414": "        try {\n",
        "415": "            int i = takeIndex;\n",
        "416": "            int k = 0;\n",
        "417": "            for (;;) {\n",
        "418": "                if (k++ >= count)\n",
        "419": "                    return false;\n",
        "420": "                if (o.equals(items[i])) {\n",
        "421": "                    removeAt(i);\n",
        "422": "                    return true;\n",
        "423": "                }\n",
        "424": "                i = inc(i);\n",
        "425": "            }\n",
        "426": "        } finally {\n",
        "427": "            monitor.leave();\n",
        "428": "        }\n",
        "430": "\n",
        "431": "    /**\n",
        "432": "     * Returns <tt>true</tt> if this queue contains the specified element.\n",
        "433": "     * More formally, returns <tt>true</tt> if and only if this queue contains\n",
        "434": "     * at least one element <tt>e</tt> such that <tt>o.equals(e)</tt>.\n",
        "435": "     *\n",
        "436": "     * @param o object to be checked for containment in this queue\n",
        "437": "     * @return <tt>true</tt> if this queue contains the specified element\n",
        "438": "     */\n",
        "439": "    @Override public boolean contains(@Nullable Object o) {\n",
        "440": "        if (o == null) return false;\n",
        "441": "        final E[] items = this.items;\n",
        "442": "        final Monitor monitor = this.monitor;\n",
        "443": "        monitor.enter();\n",
        "444": "        try {\n",
        "445": "            int i = takeIndex;\n",
        "446": "            int k = 0;\n",
        "447": "            while (k++ < count) {\n",
        "448": "                if (o.equals(items[i]))\n",
        "449": "                    return true;\n",
        "450": "                i = inc(i);\n",
        "451": "            }\n",
        "452": "            return false;\n",
        "453": "        } finally {\n",
        "454": "            monitor.leave();\n",
        "455": "        }\n",
        "457": "\n",
        "458": "    /**\n",
        "459": "     * Returns an array containing all of the elements in this queue, in\n",
        "460": "     * proper sequence.\n",
        "461": "     *\n",
        "462": "     * <p>The returned array will be \"safe\" in that no references to it are\n",
        "463": "     * maintained by this queue.  (In other words, this method must allocate\n",
        "464": "     * a new array).  The caller is thus free to modify the returned array.\n",
        "465": "     *\n",
        "466": "     * <p>This method acts as bridge between array-based and collection-based\n",
        "467": "     * APIs.\n",
        "468": "     *\n",
        "469": "     * @return an array containing all of the elements in this queue\n",
        "470": "     */\n",
        "471": "    @Override public Object[] toArray() {\n",
        "472": "        final E[] items = this.items;\n",
        "473": "        final Monitor monitor = this.monitor;\n",
        "474": "        monitor.enter();\n",
        "475": "        try {\n",
        "476": "            Object[] a = new Object[count];\n",
        "477": "            int k = 0;\n",
        "478": "            int i = takeIndex;\n",
        "479": "            while (k < count) {\n",
        "480": "                a[k++] = items[i];\n",
        "481": "                i = inc(i);\n",
        "482": "            }\n",
        "483": "            return a;\n",
        "484": "        } finally {\n",
        "485": "            monitor.leave();\n",
        "486": "        }\n",
        "488": "\n",
        "489": "    /**\n",
        "490": "     * Returns an array containing all of the elements in this queue, in\n",
        "491": "     * proper sequence; the runtime type of the returned array is that of\n",
        "492": "     * the specified array.  If the queue fits in the specified array, it\n",
        "493": "     * is returned therein.  Otherwise, a new array is allocated with the\n",
        "494": "     * runtime type of the specified array and the size of this queue.\n",
        "495": "     *\n",
        "496": "     * <p>If this queue fits in the specified array with room to spare\n",
        "497": "     * (i.e., the array has more elements than this queue), the element in\n",
        "498": "     * the array immediately following the end of the queue is set to\n",
        "499": "     * <tt>null</tt>.\n",
        "500": "     *\n",
        "501": "     * <p>Like the {@link #toArray()} method, this method acts as bridge between\n",
        "502": "     * array-based and collection-based APIs.  Further, this method allows\n",
        "503": "     * precise control over the runtime type of the output array, and may,\n",
        "504": "     * under certain circumstances, be used to save allocation costs.\n",
        "505": "     *\n",
        "506": "     * <p>Suppose <tt>x</tt> is a queue known to contain only strings.\n",
        "507": "     * The following code can be used to dump the queue into a newly\n",
        "508": "     * allocated array of <tt>String</tt>:\n",
        "509": "     *\n",
        "510": "     * <pre>\n",
        "511": "     *     String[] y = x.toArray(new String[0]);</pre>\n",
        "512": "     *\n",
        "513": "     * <p>Note that <tt>toArray(new Object[0])</tt> is identical in function to\n",
        "514": "     * <tt>toArray()</tt>.\n",
        "515": "     *\n",
        "516": "     * @param a the array into which the elements of the queue are to\n",
        "517": "     *          be stored, if it is big enough; otherwise, a new array of the\n",
        "518": "     *          same runtime type is allocated for this purpose\n",
        "519": "     * @return an array containing all of the elements in this queue\n",
        "520": "     * @throws ArrayStoreException if the runtime type of the specified array\n",
        "521": "     *         is not a supertype of the runtime type of every element in\n",
        "522": "     *         this queue\n",
        "523": "     * @throws NullPointerException if the specified array is null\n",
        "524": "     */\n",
        "525": "    @Override public <T> T[] toArray(T[] a) {\n",
        "526": "        final E[] items = this.items;\n",
        "527": "        final Monitor monitor = this.monitor;\n",
        "528": "        monitor.enter();\n",
        "529": "        try {\n",
        "530": "            if (a.length < count)\n",
        "531": "                a = ObjectArrays.newArray(a, count);\n",
        "532": "\n",
        "533": "            int k = 0;\n",
        "534": "            int i = takeIndex;\n",
        "535": "            while (k < count) {\n",
        "536": "                // This cast is not itself safe, but the following statement\n",
        "537": "                // will fail if the runtime type of items[i] is not assignable\n",
        "538": "                // to the runtime type of a[k++], which is all that the method\n",
        "539": "                // contract requires (see @throws ArrayStoreException above).\n",
        "540": "                @SuppressWarnings(\"unchecked\")\n",
        "541": "                T t = (T) items[i];\n",
        "542": "                a[k++] = t;\n",
        "543": "                i = inc(i);\n",
        "544": "            }\n",
        "545": "            if (a.length > count)\n",
        "546": "                a[count] = null;\n",
        "547": "            return a;\n",
        "548": "        } finally {\n",
        "549": "            monitor.leave();\n",
        "550": "        }\n",
        "552": "\n",
        "553": "    @Override public String toString() {\n",
        "554": "        final Monitor monitor = this.monitor;\n",
        "555": "        monitor.enter();\n",
        "556": "        try {\n",
        "557": "            return super.toString();\n",
        "558": "        } finally {\n",
        "559": "            monitor.leave();\n",
        "560": "        }\n",
        "564": "     * Atomically removes all of the elements from this queue.\n",
        "565": "     * The queue will be empty after this call returns.\n",
        "567": "    @Override public void clear() {\n",
        "568": "        final E[] items = this.items;\n",
        "569": "        final Monitor monitor = this.monitor;\n",
        "570": "        monitor.enter();\n",
        "571": "        try {\n",
        "572": "            int i = takeIndex;\n",
        "573": "            int k = count;\n",
        "574": "            while (k-- > 0) {\n",
        "575": "                items[i] = null;\n",
        "576": "                i = inc(i);\n",
        "577": "            }\n",
        "578": "            count = 0;\n",
        "579": "            putIndex = 0;\n",
        "580": "            takeIndex = 0;\n",
        "581": "        } finally {\n",
        "582": "            monitor.leave();\n",
        "583": "        }\n",
        "584": "    }\n",
        "587": "     * @throws UnsupportedOperationException {@inheritDoc}\n",
        "588": "     * @throws ClassCastException            {@inheritDoc}\n",
        "589": "     * @throws NullPointerException          {@inheritDoc}\n",
        "590": "     * @throws IllegalArgumentException      {@inheritDoc}\n",
        "592": "    @Override\n",
        "593": "    public int drainTo(Collection<? super E> c) {\n",
        "594": "        if (c == null)\n",
        "595": "            throw new NullPointerException();\n",
        "596": "        if (c == this)\n",
        "597": "            throw new IllegalArgumentException();\n",
        "598": "        final E[] items = this.items;\n",
        "599": "        final Monitor monitor = this.monitor;\n",
        "600": "        monitor.enter();\n",
        "601": "        try {\n",
        "602": "            int i = takeIndex;\n",
        "603": "            int n = 0;\n",
        "604": "            int max = count;\n",
        "605": "            while (n < max) {\n",
        "606": "                c.add(items[i]);\n",
        "607": "                items[i] = null;\n",
        "608": "                i = inc(i);\n",
        "609": "                ++n;\n",
        "610": "            }\n",
        "611": "            if (n > 0) {\n",
        "612": "                count = 0;\n",
        "613": "                putIndex = 0;\n",
        "614": "                takeIndex = 0;\n",
        "615": "            }\n",
        "616": "            return n;\n",
        "617": "        } finally {\n",
        "618": "            monitor.leave();\n",
        "619": "        }\n",
        "622": "    /**\n",
        "623": "     * @throws UnsupportedOperationException {@inheritDoc}\n",
        "624": "     * @throws ClassCastException            {@inheritDoc}\n",
        "625": "     * @throws NullPointerException          {@inheritDoc}\n",
        "626": "     * @throws IllegalArgumentException      {@inheritDoc}\n",
        "627": "     */\n",
        "629": "    public int drainTo(Collection<? super E> c, int maxElements) {\n",
        "630": "        if (c == null)\n",
        "631": "            throw new NullPointerException();\n",
        "632": "        if (c == this)\n",
        "633": "            throw new IllegalArgumentException();\n",
        "634": "        if (maxElements <= 0)\n",
        "635": "            return 0;\n",
        "636": "        final E[] items = this.items;\n",
        "637": "        final Monitor monitor = this.monitor;\n",
        "638": "        monitor.enter();\n",
        "639": "        try {\n",
        "640": "            int i = takeIndex;\n",
        "641": "            int n = 0;\n",
        "642": "            int max = (maxElements < count) ? maxElements : count;\n",
        "643": "            while (n < max) {\n",
        "644": "                c.add(items[i]);\n",
        "645": "                items[i] = null;\n",
        "646": "                i = inc(i);\n",
        "647": "                ++n;\n",
        "648": "            }\n",
        "649": "            if (n > 0) {\n",
        "650": "                count -= n;\n",
        "651": "                takeIndex = i;\n",
        "652": "            }\n",
        "653": "            return n;\n",
        "654": "        } finally {\n",
        "655": "            monitor.leave();\n",
        "656": "        }\n",
        "660": "     * Returns an iterator over the elements in this queue in proper sequence.\n",
        "661": "     * The returned <tt>Iterator</tt> is a \"weakly consistent\" iterator that\n",
        "662": "     * will never throw {@link ConcurrentModificationException},\n",
        "663": "     * and guarantees to traverse elements as they existed upon\n",
        "664": "     * construction of the iterator, and may (but is not guaranteed to)\n",
        "665": "     * reflect any modifications subsequent to construction.\n",
        "666": "     *\n",
        "667": "     * @return an iterator over the elements in this queue in proper sequence\n",
        "669": "    @Override public Iterator<E> iterator() {\n",
        "670": "        final Monitor monitor = this.monitor;\n",
        "671": "        monitor.enter();\n",
        "672": "        try {\n",
        "673": "            return new Itr();\n",
        "674": "        } finally {\n",
        "675": "            monitor.leave();\n",
        "676": "        }\n",
        "679": "    /**\n",
        "680": "     * Iterator for MonitorBasedArrayBlockingQueue\n",
        "681": "     */\n",
        "682": "    private class Itr implements Iterator<E> {\n",
        "683": "        /**\n",
        "684": "         * Index of element to be returned by next,\n",
        "685": "         * or a negative number if no such.\n",
        "686": "         */\n",
        "687": "        private int nextIndex;\n",
        "688": "\n",
        "689": "        /**\n",
        "690": "         * nextItem holds on to item fields because once we claim\n",
        "691": "         * that an element exists in hasNext(), we must return it in\n",
        "692": "         * the following next() call even if it was in the process of\n",
        "693": "         * being removed when hasNext() was called.\n",
        "694": "         */\n",
        "695": "        private E nextItem;\n",
        "696": "\n",
        "697": "        /**\n",
        "698": "         * Index of element returned by most recent call to next.\n",
        "699": "         * Reset to -1 if this element is deleted by a call to remove.\n",
        "700": "         */\n",
        "701": "        private int lastRet;\n",
        "702": "\n",
        "703": "        Itr() {\n",
        "704": "            lastRet = -1;\n",
        "705": "            if (count == 0)\n",
        "706": "                nextIndex = -1;\n",
        "707": "            else {\n",
        "708": "                nextIndex = takeIndex;\n",
        "709": "                nextItem = items[takeIndex];\n",
        "710": "            }\n",
        "711": "        }\n",
        "712": "\n",
        "713": "        @Override\n",
        "714": "        public boolean hasNext() {\n",
        "715": "            /*\n",
        "716": "             * No sync. We can return true by mistake here\n",
        "717": "             * only if this iterator passed across threads,\n",
        "718": "             * which we don't support anyway.\n",
        "719": "             */\n",
        "720": "            return nextIndex >= 0;\n",
        "721": "        }\n",
        "722": "\n",
        "723": "        /**\n",
        "724": "         * Checks whether nextIndex is valid; if so setting nextItem.\n",
        "725": "         * Stops iterator when either hits putIndex or sees null item.\n",
        "726": "         */\n",
        "727": "        private void checkNext() {\n",
        "728": "            if (nextIndex == putIndex) {\n",
        "729": "                nextIndex = -1;\n",
        "730": "                nextItem = null;\n",
        "731": "            } else {\n",
        "732": "                nextItem = items[nextIndex];\n",
        "733": "                if (nextItem == null)\n",
        "734": "                    nextIndex = -1;\n",
        "735": "            }\n",
        "736": "        }\n",
        "737": "\n",
        "738": "        @Override\n",
        "739": "        public E next() {\n",
        "740": "            final Monitor monitor = MonitorBasedArrayBlockingQueue.this.monitor;\n",
        "741": "            monitor.enter();\n",
        "742": "            try {\n",
        "743": "                if (nextIndex < 0)\n",
        "744": "                    throw new NoSuchElementException();\n",
        "745": "                lastRet = nextIndex;\n",
        "746": "                E x = nextItem;\n",
        "747": "                nextIndex = inc(nextIndex);\n",
        "748": "                checkNext();\n",
        "749": "                return x;\n",
        "750": "            } finally {\n",
        "751": "                monitor.leave();\n",
        "752": "            }\n",
        "753": "        }\n",
        "755": "        @Override\n",
        "756": "        public void remove() {\n",
        "757": "            final Monitor monitor = MonitorBasedArrayBlockingQueue.this.monitor;\n",
        "758": "            monitor.enter();\n",
        "759": "            try {\n",
        "760": "                int i = lastRet;\n",
        "761": "                if (i == -1)\n",
        "762": "                    throw new IllegalStateException();\n",
        "763": "                lastRet = -1;\n",
        "764": "\n",
        "765": "                int ti = takeIndex;\n",
        "766": "                removeAt(i);\n",
        "767": "                // back up cursor (reset to front if was first element)\n",
        "768": "                nextIndex = (i == ti) ? takeIndex : i;\n",
        "769": "                checkNext();\n",
        "770": "            } finally {\n",
        "771": "                monitor.leave();\n",
        "772": "            }\n",
        "773": "        }\n"
    }
}