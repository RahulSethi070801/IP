{
    "addition": {
        "221": "   * any values at all. Because of this optimization, {@code build.getValueStrength()} must be\n",
        "222": "   * {@link Strength#STRONG}.\n",
        "322": "    /** Gets the entry's hash. */\n",
        "325": "    /** Gets the key for this entry. */\n",
        "1048": "   * tables, that otherwise encounter collisions for hash codes that do not differ in lower or upper\n",
        "1049": "   * bits.\n",
        "1185": "     * computing size or checking containsValue, then we might have an inconsistent view of state so\n",
        "1186": "     * (usually) must retry.\n",
        "1199": "    /** The maximum size of this map. MapMaker.UNSET_INT if there is no maximum. */\n",
        "1340": "    /** Cleanup collected entries when the lock is available. */\n",
        "1534": "    /** Expands the table if possible. */\n",
        "1975": "     * Performs routine cleanup prior to executing a write. This should be called every time a write\n",
        "1976": "     * thread acquires the segment lock, immediately after acquiring the lock.\n",
        "2549": "    /** Finds the next entry in the current chain. Returns {@code true} if an entry was found. */\n",
        "2561": "    /** Finds the next entry in the current table. Returns {@code true} if an entry was found. */\n",
        "2632": "   * Custom Entry class used by EntryIterator.next(), that relays setValue changes to the underlying\n",
        "2633": "   * map.\n",
        "2931": "          keyStrength, valueStrength, keyEquivalence, valueEquivalence, concurrencyLevel, delegate);\n"
    },
    "removed": {
        "221": "   * any values at all. Because of this optimization, {@code build.getValueStrength()} must\n",
        "222": "   * be {@link Strength#STRONG}.\n",
        "322": "    /**\n",
        "323": "     * Gets the entry's hash.\n",
        "324": "     */\n",
        "327": "    /**\n",
        "328": "     * Gets the key for this entry.\n",
        "329": "     */\n",
        "1052": "   * tables, that otherwise encounter collisions for hash codes that do not differ in lower or\n",
        "1053": "   * upper bits.\n",
        "1189": "     * computing size or checking containsValue, then we might have an inconsistent view of state\n",
        "1190": "     * so (usually) must retry.\n",
        "1203": "    /**\n",
        "1204": "     * The maximum size of this map. MapMaker.UNSET_INT if there is no maximum.\n",
        "1205": "     */\n",
        "1346": "    /**\n",
        "1347": "     * Cleanup collected entries when the lock is available.\n",
        "1348": "     */\n",
        "1542": "    /**\n",
        "1543": "     * Expands the table if possible.\n",
        "1544": "     */\n",
        "1985": "     * Performs routine cleanup prior to executing a write. This should be called every time a\n",
        "1986": "     * write thread acquires the segment lock, immediately after acquiring the lock.\n",
        "2559": "    /**\n",
        "2560": "     * Finds the next entry in the current chain. Returns {@code true} if an entry was found.\n",
        "2561": "     */\n",
        "2573": "    /**\n",
        "2574": "     * Finds the next entry in the current table. Returns {@code true} if an entry was found.\n",
        "2575": "     */\n",
        "2646": "   * Custom Entry class used by EntryIterator.next(), that relays setValue changes to the\n",
        "2647": "   * underlying map.\n",
        "2945": "          keyStrength,\n",
        "2946": "          valueStrength,\n",
        "2947": "          keyEquivalence,\n",
        "2948": "          valueEquivalence,\n",
        "2949": "          concurrencyLevel,\n",
        "2950": "          delegate);\n"
    }
}