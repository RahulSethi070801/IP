{
    "addition": {
        "46": " * Provides static utility methods for creating and working with {@link Multiset} instances.\n",
        "49": " * \"https://github.com/google/guava/wiki/CollectionUtilitiesExplained#multisets\"> {@code\n",
        "50": " * Multisets}</a>.\n",
        "92": "   * Returns an unmodifiable view of the specified multiset. Query operations on the returned\n",
        "93": "   * multiset \"read through\" to the specified multiset, and attempts to modify the returned multiset\n",
        "94": "   * result in an {@link UnsupportedOperationException}.\n",
        "96": "   * <p>The returned multiset will be serializable if the specified multiset is serializable.\n",
        "98": "   * @param multiset the multiset for which an unmodifiable view is to be generated\n",
        "219": "   * Returns an unmodifiable view of the specified sorted multiset. Query operations on the returned\n",
        "220": "   * multiset \"read through\" to the specified multiset, and attempts to modify the returned multiset\n",
        "221": "   * result in an {@link UnsupportedOperationException}.\n",
        "223": "   * <p>The returned multiset will be serializable if the specified multiset is serializable.\n",
        "225": "   * @param sortedMultiset the sorted multiset for which an unmodifiable view is to be generated\n",
        "236": "   * Returns an immutable multiset entry with the specified element and count. The entry will be\n",
        "237": "   * serializable if {@code e} is.\n",
        "279": "   * <p>The resulting multiset's iterators, and those of its {@code entrySet()} and {@code\n",
        "280": "   * elementSet()}, do not support {@code remove()}. However, all other multiset methods supported\n",
        "281": "   * by {@code unfiltered} are supported by the returned multiset. When given an element that\n",
        "282": "   * doesn't satisfy the predicate, the multiset's {@code add()} and {@code addAll()} methods throw\n",
        "283": "   * an {@link IllegalArgumentException}. When methods such as {@code removeAll()} and {@code\n",
        "284": "   * clear()} are called on the filtered multiset, only elements that satisfy the filter will be\n",
        "285": "   * removed from the underlying multiset.\n",
        "290": "   * element in the underlying multiset and determine which elements satisfy the filter. When a live\n",
        "291": "   * view is <i>not</i> needed, it may be faster to copy the returned multiset and use the copy.\n",
        "294": "   * {@link Predicate#apply}. Do not provide a predicate such as {@code\n",
        "295": "   * Predicates.instanceOf(ArrayList.class)}, which is inconsistent with equals. (See {@link\n",
        "296": "   * Iterables#filter(Iterable, Class)} for related functionality.)\n",
        "388": "   * Returns the expected number of distinct elements given the specified elements. The number of\n",
        "389": "   * distinct elements is only computed if {@code elements} is an instance of {@code Multiset};\n",
        "390": "   * otherwise the default value of 11 is returned.\n",
        "400": "   * Returns an unmodifiable view of the union of two multisets. In the returned multiset, the count\n",
        "401": "   * of each element is the <i>maximum</i> of its counts in the two backing multisets. The iteration\n",
        "402": "   * order of the returned multiset matches that of the element set of {@code multiset1} followed by\n",
        "403": "   * the members of the element set of {@code multiset2} that are not contained in {@code\n",
        "404": "   * multiset1}, with repeated occurrences of the same element appearing consecutively.\n",
        "406": "   * <p>Results are undefined if {@code multiset1} and {@code multiset2} are based on different\n",
        "407": "   * equivalence relations (as {@code HashMultiset} and {@code TreeMultiset} are).\n",
        "472": "   * Returns an unmodifiable view of the intersection of two multisets. In the returned multiset,\n",
        "473": "   * the count of each element is the <i>minimum</i> of its counts in the two backing multisets,\n",
        "474": "   * with elements that would have a count of 0 not included. The iteration order of the returned\n",
        "475": "   * multiset matches that of the element set of {@code multiset1}, with repeated occurrences of the\n",
        "476": "   * same element appearing consecutively.\n",
        "478": "   * <p>Results are undefined if {@code multiset1} and {@code multiset2} are based on different\n",
        "479": "   * equivalence relations (as {@code HashMultiset} and {@code TreeMultiset} are).\n",
        "528": "   * Returns an unmodifiable view of the sum of two multisets. In the returned multiset, the count\n",
        "529": "   * of each element is the <i>sum</i> of its counts in the two backing multisets. The iteration\n",
        "530": "   * order of the returned multiset matches that of the element set of {@code multiset1} followed by\n",
        "531": "   * the members of the element set of {@code multiset2} that are not contained in {@code\n",
        "532": "   * multiset1}, with repeated occurrences of the same element appearing consecutively.\n",
        "534": "   * <p>Results are undefined if {@code multiset1} and {@code multiset2} are based on different\n",
        "535": "   * equivalence relations (as {@code HashMultiset} and {@code TreeMultiset} are).\n",
        "605": "   * Returns an unmodifiable view of the difference of two multisets. In the returned multiset, the\n",
        "606": "   * count of each element is the result of the <i>zero-truncated subtraction</i> of its count in\n",
        "607": "   * the second multiset from its count in the first multiset, with elements that would have a count\n",
        "608": "   * of 0 not included. The iteration order of the returned multiset matches that of the element set\n",
        "609": "   * of {@code multiset1}, with repeated occurrences of the same element appearing consecutively.\n",
        "611": "   * <p>Results are undefined if {@code multiset1} and {@code multiset2} are based on different\n",
        "612": "   * equivalence relations (as {@code HashMultiset} and {@code TreeMultiset} are).\n",
        "657": "   * Returns {@code true} if {@code subMultiset.count(o) <= superMultiset.count(o)} for all {@code\n",
        "658": "   * o}.\n",
        "676": "   * Modifies {@code multisetToModify} so that its count for an element {@code e} is at most {@code\n",
        "677": "   * multisetToRetain.count(e)}.\n",
        "679": "   * <p>To be precise, {@code multisetToModify.count(e)} is set to {@code\n",
        "680": "   * Math.min(multisetToModify.count(e), multisetToRetain.count(e))}. This is similar to {@link\n",
        "681": "   * #intersection(Multiset, Multiset) intersection} {@code (multisetToModify, multisetToRetain)},\n",
        "682": "   * but mutates {@code multisetToModify} instead of returning a view.\n",
        "684": "   * <p>In contrast, {@code multisetToModify.retainAll(multisetToRetain)} keeps all occurrences of\n",
        "685": "   * elements that appear at all in {@code multisetToRetain}, and deletes all occurrences of all\n",
        "686": "   * other elements.\n",
        "688": "   * @return {@code true} if {@code multisetToModify} was changed as a result of this operation\n",
        "697": "  /** Delegate implementation which cares about the element type. */\n",
        "720": "   * For each occurrence of an element {@code e} in {@code occurrencesToRemove}, removes one\n",
        "721": "   * occurrence of {@code e} in {@code multisetToModify}.\n",
        "723": "   * <p>Equivalently, this method modifies {@code multisetToModify} so that {@code\n",
        "724": "   * multisetToModify.count(e)} is set to {@code Math.max(0, multisetToModify.count(e) -\n",
        "727": "   * <p>This is <i>not</i> the same as {@code multisetToModify.} {@link Multiset#removeAll\n",
        "728": "   * removeAll}{@code (occurrencesToRemove)}, which removes all occurrences of elements that appear\n",
        "729": "   * in {@code occurrencesToRemove}. However, this operation <i>is</i> equivalent to, albeit\n",
        "730": "   * sometimes more efficient than, the following:\n",
        "732": "   * <pre>{@code\n",
        "733": "   * for (E e : occurrencesToRemove) {\n",
        "734": "   *   multisetToModify.remove(e);\n",
        "735": "   * }\n",
        "736": "   * }</pre>\n",
        "738": "   * @return {@code true} if {@code multisetToModify} was changed as a result of this operation\n",
        "739": "   * @since 18.0 (present in 10.0 with a requirement that the second parameter be a {@code\n",
        "740": "   *     Multiset})\n",
        "759": "   * For each occurrence of an element {@code e} in {@code occurrencesToRemove}, removes one\n",
        "760": "   * occurrence of {@code e} in {@code multisetToModify}.\n",
        "762": "   * <p>Equivalently, this method modifies {@code multisetToModify} so that {@code\n",
        "763": "   * multisetToModify.count(e)} is set to {@code Math.max(0, multisetToModify.count(e) -\n",
        "766": "   * <p>This is <i>not</i> the same as {@code multisetToModify.} {@link Multiset#removeAll\n",
        "767": "   * removeAll}{@code (occurrencesToRemove)}, which removes all occurrences of elements that appear\n",
        "768": "   * in {@code occurrencesToRemove}. However, this operation <i>is</i> equivalent to, albeit\n",
        "769": "   * sometimes more efficient than, the following:\n",
        "771": "   * <pre>{@code\n",
        "772": "   * for (E e : occurrencesToRemove) {\n",
        "773": "   *   multisetToModify.remove(e);\n",
        "774": "   * }\n",
        "775": "   * }</pre>\n",
        "777": "   * @return {@code true} if {@code multisetToModify} was changed as a result of this operation\n",
        "803": "   * Implementation of the {@code equals}, {@code hashCode}, and {@code toString} methods of {@link\n",
        "804": "   * Multiset.Entry}.\n",
        "808": "     * Indicates whether an object equals this entry, following the behavior specified in {@link\n",
        "809": "     * Multiset.Entry#equals}.\n",
        "822": "     * Return this entry's hash code, following the behavior specified in {@link\n",
        "823": "     * Multiset.Entry#hashCode}.\n",
        "832": "     * Returns a string representation of this multiset entry. The string representation consists of\n",
        "833": "     * the associated element if the associated count is one, and otherwise the associated element\n",
        "834": "     * followed by the characters \" x \" (space, x and space) followed by the count. Elements and\n",
        "835": "     * counts are converted to strings as by {@code String.valueOf}.\n",
        "845": "  /** An implementation of {@link Multiset#equals}. */\n",
        "871": "  /** An implementation of {@link Multiset#addAll}. */\n",
        "887": "  /** An implementation of {@link Multiset#removeAll}. */\n",
        "897": "  /** An implementation of {@link Multiset#retainAll}. */\n",
        "908": "  /** An implementation of {@link Multiset#setCount(Object, int)}. */\n",
        "924": "  /** An implementation of {@link Multiset#setCount(Object, int, int)}. */\n",
        "1025": "  /** An implementation of {@link Multiset#iterator}. */\n",
        "1091": "  /** An implementation of {@link Multiset#size}. */\n",
        "1100": "  /** Used to avoid http://bugs.sun.com/view_bug.do?bug_id=6558557 */\n",
        "1121": "    @Override\n",
        "1122": "    public int compare(Entry<?> entry1, Entry<?> entry2) {\n"
    },
    "removed": {
        "46": " * Provides static utility methods for creating and working with {@link\n",
        "47": " * Multiset} instances.\n",
        "50": " * \"https://github.com/google/guava/wiki/CollectionUtilitiesExplained#multisets\">\n",
        "51": " * {@code Multisets}</a>.\n",
        "93": "   * Returns an unmodifiable view of the specified multiset. Query operations on\n",
        "94": "   * the returned multiset \"read through\" to the specified multiset, and\n",
        "95": "   * attempts to modify the returned multiset result in an\n",
        "96": "   * {@link UnsupportedOperationException}.\n",
        "98": "   * <p>The returned multiset will be serializable if the specified multiset is\n",
        "99": "   * serializable.\n",
        "101": "   * @param multiset the multiset for which an unmodifiable view is to be\n",
        "102": "   *     generated\n",
        "223": "   * Returns an unmodifiable view of the specified sorted multiset. Query\n",
        "224": "   * operations on the returned multiset \"read through\" to the specified\n",
        "225": "   * multiset, and attempts to modify the returned multiset result in an {@link\n",
        "226": "   * UnsupportedOperationException}.\n",
        "228": "   * <p>The returned multiset will be serializable if the specified multiset is\n",
        "229": "   * serializable.\n",
        "231": "   * @param sortedMultiset the sorted multiset for which an unmodifiable view is\n",
        "232": "   *     to be generated\n",
        "243": "   * Returns an immutable multiset entry with the specified element and count.\n",
        "244": "   * The entry will be serializable if {@code e} is.\n",
        "286": "   * <p>The resulting multiset's iterators, and those of its {@code entrySet()} and\n",
        "287": "   * {@code elementSet()}, do not support {@code remove()}.  However, all other multiset methods\n",
        "288": "   * supported by {@code unfiltered} are supported by the returned multiset. When given an element\n",
        "289": "   * that doesn't satisfy the predicate, the multiset's {@code add()} and {@code addAll()} methods\n",
        "290": "   * throw an {@link IllegalArgumentException}. When methods such as {@code removeAll()} and\n",
        "291": "   * {@code clear()} are called on the filtered multiset, only elements that satisfy the filter\n",
        "292": "   * will be removed from the underlying multiset.\n",
        "297": "   * element in the underlying multiset and determine which elements satisfy the filter. When a\n",
        "298": "   * live view is <i>not</i> needed, it may be faster to copy the returned multiset and use the\n",
        "299": "   * copy.\n",
        "302": "   * {@link Predicate#apply}. Do not provide a predicate such as\n",
        "303": "   * {@code Predicates.instanceOf(ArrayList.class)}, which is inconsistent with equals. (See\n",
        "304": "   * {@link Iterables#filter(Iterable, Class)} for related functionality.)\n",
        "396": "   * Returns the expected number of distinct elements given the specified\n",
        "397": "   * elements. The number of distinct elements is only computed if {@code\n",
        "398": "   * elements} is an instance of {@code Multiset}; otherwise the default value\n",
        "399": "   * of 11 is returned.\n",
        "409": "   * Returns an unmodifiable view of the union of two multisets.\n",
        "410": "   * In the returned multiset, the count of each element is the <i>maximum</i>\n",
        "411": "   * of its counts in the two backing multisets. The iteration order of the\n",
        "412": "   * returned multiset matches that of the element set of {@code multiset1}\n",
        "413": "   * followed by the members of the element set of {@code multiset2} that are\n",
        "414": "   * not contained in {@code multiset1}, with repeated occurrences of the same\n",
        "415": "   * element appearing consecutively.\n",
        "417": "   * <p>Results are undefined if {@code multiset1} and {@code multiset2} are\n",
        "418": "   * based on different equivalence relations (as {@code HashMultiset} and\n",
        "419": "   * {@code TreeMultiset} are).\n",
        "484": "   * Returns an unmodifiable view of the intersection of two multisets.\n",
        "485": "   * In the returned multiset, the count of each element is the <i>minimum</i>\n",
        "486": "   * of its counts in the two backing multisets, with elements that would have\n",
        "487": "   * a count of 0 not included. The iteration order of the returned multiset\n",
        "488": "   * matches that of the element set of {@code multiset1}, with repeated\n",
        "489": "   * occurrences of the same element appearing consecutively.\n",
        "491": "   * <p>Results are undefined if {@code multiset1} and {@code multiset2} are\n",
        "492": "   * based on different equivalence relations (as {@code HashMultiset} and\n",
        "493": "   * {@code TreeMultiset} are).\n",
        "542": "   * Returns an unmodifiable view of the sum of two multisets.\n",
        "543": "   * In the returned multiset, the count of each element is the <i>sum</i> of\n",
        "544": "   * its counts in the two backing multisets. The iteration order of the\n",
        "545": "   * returned multiset matches that of the element set of {@code multiset1}\n",
        "546": "   * followed by the members of the element set of {@code multiset2} that\n",
        "547": "   * are not contained in {@code multiset1}, with repeated occurrences of the\n",
        "548": "   * same element appearing consecutively.\n",
        "550": "   * <p>Results are undefined if {@code multiset1} and {@code multiset2} are\n",
        "551": "   * based on different equivalence relations (as {@code HashMultiset} and\n",
        "552": "   * {@code TreeMultiset} are).\n",
        "622": "   * Returns an unmodifiable view of the difference of two multisets.\n",
        "623": "   * In the returned multiset, the count of each element is the result of the\n",
        "624": "   * <i>zero-truncated subtraction</i> of its count in the second multiset from\n",
        "625": "   * its count in the first multiset, with elements that would have a count of\n",
        "626": "   * 0 not included. The iteration order of the returned multiset matches that\n",
        "627": "   * of the element set of {@code multiset1}, with repeated occurrences of the\n",
        "628": "   * same element appearing consecutively.\n",
        "630": "   * <p>Results are undefined if {@code multiset1} and {@code multiset2} are\n",
        "631": "   * based on different equivalence relations (as {@code HashMultiset} and\n",
        "632": "   * {@code TreeMultiset} are).\n",
        "677": "   * Returns {@code true} if {@code subMultiset.count(o) <=\n",
        "678": "   * superMultiset.count(o)} for all {@code o}.\n",
        "696": "   * Modifies {@code multisetToModify} so that its count for an element\n",
        "697": "   * {@code e} is at most {@code multisetToRetain.count(e)}.\n",
        "699": "   * <p>To be precise, {@code multisetToModify.count(e)} is set to\n",
        "700": "   * {@code Math.min(multisetToModify.count(e),\n",
        "701": "   * multisetToRetain.count(e))}. This is similar to\n",
        "702": "   * {@link #intersection(Multiset, Multiset) intersection}\n",
        "703": "   * {@code (multisetToModify, multisetToRetain)}, but mutates\n",
        "704": "   * {@code multisetToModify} instead of returning a view.\n",
        "706": "   * <p>In contrast, {@code multisetToModify.retainAll(multisetToRetain)} keeps\n",
        "707": "   * all occurrences of elements that appear at all in {@code\n",
        "708": "   * multisetToRetain}, and deletes all occurrences of all other elements.\n",
        "710": "   * @return {@code true} if {@code multisetToModify} was changed as a result\n",
        "711": "   *         of this operation\n",
        "720": "  /**\n",
        "721": "   * Delegate implementation which cares about the element type.\n",
        "722": "   */\n",
        "745": "   * For each occurrence of an element {@code e} in {@code occurrencesToRemove},\n",
        "746": "   * removes one occurrence of {@code e} in {@code multisetToModify}.\n",
        "748": "   * <p>Equivalently, this method modifies {@code multisetToModify} so that\n",
        "749": "   * {@code multisetToModify.count(e)} is set to\n",
        "750": "   * {@code Math.max(0, multisetToModify.count(e) -\n",
        "753": "   * <p>This is <i>not</i> the same as {@code multisetToModify.}\n",
        "754": "   * {@link Multiset#removeAll removeAll}{@code (occurrencesToRemove)}, which\n",
        "755": "   * removes all occurrences of elements that appear in\n",
        "756": "   * {@code occurrencesToRemove}. However, this operation <i>is</i> equivalent\n",
        "757": "   * to, albeit sometimes more efficient than, the following: <pre>   {@code\n",
        "759": "   *   for (E e : occurrencesToRemove) {\n",
        "760": "   *     multisetToModify.remove(e);\n",
        "761": "   *   }}</pre>\n",
        "763": "   * @return {@code true} if {@code multisetToModify} was changed as a result of\n",
        "764": "   *         this operation\n",
        "765": "   * @since 18.0 (present in 10.0 with a requirement that the second parameter\n",
        "766": "   *     be a {@code Multiset})\n",
        "785": "   * For each occurrence of an element {@code e} in {@code occurrencesToRemove},\n",
        "786": "   * removes one occurrence of {@code e} in {@code multisetToModify}.\n",
        "788": "   * <p>Equivalently, this method modifies {@code multisetToModify} so that\n",
        "789": "   * {@code multisetToModify.count(e)} is set to\n",
        "790": "   * {@code Math.max(0, multisetToModify.count(e) -\n",
        "793": "   * <p>This is <i>not</i> the same as {@code multisetToModify.}\n",
        "794": "   * {@link Multiset#removeAll removeAll}{@code (occurrencesToRemove)}, which\n",
        "795": "   * removes all occurrences of elements that appear in\n",
        "796": "   * {@code occurrencesToRemove}. However, this operation <i>is</i> equivalent\n",
        "797": "   * to, albeit sometimes more efficient than, the following: <pre>   {@code\n",
        "799": "   *   for (E e : occurrencesToRemove) {\n",
        "800": "   *     multisetToModify.remove(e);\n",
        "801": "   *   }}</pre>\n",
        "803": "   * @return {@code true} if {@code multisetToModify} was changed as a result of\n",
        "804": "   *         this operation\n",
        "830": "   * Implementation of the {@code equals}, {@code hashCode}, and\n",
        "831": "   * {@code toString} methods of {@link Multiset.Entry}.\n",
        "835": "     * Indicates whether an object equals this entry, following the behavior\n",
        "836": "     * specified in {@link Multiset.Entry#equals}.\n",
        "849": "     * Return this entry's hash code, following the behavior specified in\n",
        "850": "     * {@link Multiset.Entry#hashCode}.\n",
        "859": "     * Returns a string representation of this multiset entry. The string\n",
        "860": "     * representation consists of the associated element if the associated count\n",
        "861": "     * is one, and otherwise the associated element followed by the characters\n",
        "862": "     * \" x \" (space, x and space) followed by the count. Elements and counts are\n",
        "863": "     * converted to strings as by {@code String.valueOf}.\n",
        "873": "  /**\n",
        "874": "   * An implementation of {@link Multiset#equals}.\n",
        "875": "   */\n",
        "901": "  /**\n",
        "902": "   * An implementation of {@link Multiset#addAll}.\n",
        "903": "   */\n",
        "919": "  /**\n",
        "920": "   * An implementation of {@link Multiset#removeAll}.\n",
        "921": "   */\n",
        "931": "  /**\n",
        "932": "   * An implementation of {@link Multiset#retainAll}.\n",
        "933": "   */\n",
        "944": "  /**\n",
        "945": "   * An implementation of {@link Multiset#setCount(Object, int)}.\n",
        "946": "   */\n",
        "962": "  /**\n",
        "963": "   * An implementation of {@link Multiset#setCount(Object, int, int)}.\n",
        "964": "   */\n",
        "1065": "  /**\n",
        "1066": "   * An implementation of {@link Multiset#iterator}.\n",
        "1067": "   */\n",
        "1133": "  /**\n",
        "1134": "   * An implementation of {@link Multiset#size}.\n",
        "1135": "   */\n",
        "1144": "  /**\n",
        "1145": "   * Used to avoid http://bugs.sun.com/view_bug.do?bug_id=6558557\n",
        "1146": "   */\n",
        "1167": "    @Override public int compare(Entry<?> entry1, Entry<?> entry2) {\n"
    }
}