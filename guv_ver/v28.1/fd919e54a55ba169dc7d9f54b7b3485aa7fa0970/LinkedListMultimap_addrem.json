{
    "addition": {
        "46": " * An implementation of {@code ListMultimap} that supports deterministic iteration order for both\n",
        "47": " * keys and values. The iteration order is preserved across non-distinct key values. For example,\n",
        "48": " * for the following multimap definition:\n",
        "50": " * <pre>{@code\n",
        "51": " * Multimap<K, V> multimap = LinkedListMultimap.create();\n",
        "52": " * multimap.put(key1, foo);\n",
        "53": " * multimap.put(key2, bar);\n",
        "54": " * multimap.put(key1, baz);\n",
        "55": " * }</pre>\n",
        "57": " * ... the iteration order for {@link #keys()} is {@code [key1, key2, key1]}, and similarly for\n",
        "58": " * {@link #entries()}. Unlike {@link LinkedHashMultimap}, the iteration order is kept consistent\n",
        "59": " * between keys, entries and values. For example, calling:\n",
        "61": " * <pre>{@code\n",
        "62": " * map.remove(key1, foo);\n",
        "63": " * }</pre>\n",
        "65": " * <p>changes the entries iteration order to {@code [key2=bar, key1=baz]} and the key iteration\n",
        "66": " * order to {@code [key2, key1]}. The {@link #entries()} iterator returns mutable map entries, and\n",
        "67": " * {@link #replaceValues} attempts to preserve iteration order as much as possible.\n",
        "69": " * <p>The collections returned by {@link #keySet()} and {@link #asMap} iterate through the keys in\n",
        "70": " * the order they were first added to the multimap. Similarly, {@link #get}, {@link #removeAll}, and\n",
        "71": " * {@link #replaceValues} return collections that iterate through the values in the order they were\n",
        "72": " * added. The collections generated by {@link #entries()}, {@link #keys()}, and {@link #values}\n",
        "73": " * iterate across the key-value mappings in the order they were added to the multimap.\n",
        "75": " * <p>The {@link #values()} and {@link #entries()} methods both return a {@code List}, instead of\n",
        "76": " * the {@code Collection} specified by the {@link ListMultimap} interface.\n",
        "78": " * <p>The methods {@link #get}, {@link #keySet()}, {@link #keys()}, {@link #values}, {@link\n",
        "79": " * #entries()}, and {@link #asMap} return collections that are views of the multimap. If the\n",
        "80": " * multimap is modified while an iteration over any of those collections is in progress, except\n",
        "81": " * through the iterator's methods, the results of the iteration are undefined.\n",
        "83": " * <p>Keys and values may be null. All optional multimap methods are supported, and all returned\n",
        "84": " * views are modifiable.\n",
        "86": " * <p>This class is not threadsafe when any concurrent operations update the multimap. Concurrent\n",
        "87": " * read operations will work correctly. To allow concurrent update operations, wrap your multimap\n",
        "88": " * with a call to {@link Multimaps#synchronizedListMultimap}.\n",
        "91": " * \"https://github.com/google/guava/wiki/NewCollectionTypesExplained#multimap\"> {@code\n",
        "92": " * Multimap}</a>.\n",
        "164": "  /** Creates a new, empty {@code LinkedListMultimap} with the default initial capacity. */\n",
        "170": "   * Constructs an empty {@code LinkedListMultimap} with enough capacity to hold the specified\n",
        "171": "   * number of keys without rehashing.\n",
        "181": "   * Constructs a {@code LinkedListMultimap} with the same mappings as the specified {@code\n",
        "182": "   * Multimap}. The new multimap has the same {@link Multimap#entries()} iteration order as the\n",
        "183": "   * input multimap.\n",
        "206": "   * Adds a new node for the specified key-value pair before the specified {@code nextSibling}\n",
        "207": "   * element, or at the end of the list if {@code nextSibling} is null. Note: if {@code nextSibling}\n",
        "208": "   * is specified, it MUST be for an node for the same {@code key}!\n",
        "257": "   * Removes the specified node from the linked list. This method is only intended to be used from\n",
        "258": "   * the {@code Iterator} classes. See also {@link LinkedListMultimap#removeAllNodes(Object)}.\n",
        "470": "     * Constructs a new iterator over all values for the specified key starting at the specified\n",
        "471": "     * index. This constructor is optimized so that it starts at either the head or the tail,\n",
        "472": "     * depending on which is closer to the specified index. This allows adds to the tail to be done\n",
        "473": "     * in constant time.\n",
        "608": "   * <p>If any entries for the specified {@code key} already exist in the multimap, their values are\n",
        "609": "   * changed in-place without affecting the iteration order.\n",
        "611": "   * <p>The returned list is immutable and implements {@link java.util.RandomAccess}.\n",
        "647": "   * <p>The returned list is immutable and implements {@link java.util.RandomAccess}.\n",
        "671": "   * <p>If the multimap is modified while an iteration over the list is in progress (except through\n",
        "672": "   * the iterator's own {@code add}, {@code set} or {@code remove} operations) the results of the\n",
        "673": "   * iteration are undefined.\n",
        "723": "   * <p>The iterator generated by the returned collection traverses the values in the order they\n",
        "724": "   * were added to the multimap. Because the values may have duplicates and follow the insertion\n",
        "725": "   * ordering, this method returns a {@link List}, instead of the {@link Collection} specified in\n",
        "726": "   * the {@link ListMultimap} interface.\n",
        "764": "   * <p>The iterator generated by the returned collection traverses the entries in the order they\n",
        "765": "   * were added to the multimap. Because the entries may have duplicates and follow the insertion\n",
        "766": "   * ordering, this method returns a {@link List}, instead of the {@link Collection} specified in\n",
        "767": "   * the {@link ListMultimap} interface.\n",
        "769": "   * <p>An entry's {@link Entry#getKey} method always returns the same key, regardless of what\n",
        "770": "   * happens subsequently. As long as the corresponding key-value mapping is not removed from the\n",
        "771": "   * multimap, {@link Entry#getValue} returns the value from the multimap, which may change over\n",
        "772": "   * time, and {@link Entry#setValue} modifies that value. Removing the mapping from the multimap\n",
        "773": "   * does not alter the value returned by {@code getValue()}, though a subsequent {@code setValue()}\n",
        "774": "   * call won't update the multimap but will lead to a revised value being returned by {@code\n",
        "775": "   * getValue()}.\n",
        "810": "   * @serialData the number of distinct keys, and then for each distinct key: the first key, the\n",
        "811": "   *     number of values for that key, and the key's values, followed by successive keys and values\n",
        "812": "   *     from the entries() ordering\n"
    },
    "removed": {
        "46": " * An implementation of {@code ListMultimap} that supports deterministic\n",
        "47": " * iteration order for both keys and values. The iteration order is preserved\n",
        "48": " * across non-distinct key values. For example, for the following multimap\n",
        "49": " * definition: <pre>   {@code\n",
        "51": " *   Multimap<K, V> multimap = LinkedListMultimap.create();\n",
        "52": " *   multimap.put(key1, foo);\n",
        "53": " *   multimap.put(key2, bar);\n",
        "54": " *   multimap.put(key1, baz);}</pre>\n",
        "56": " * ... the iteration order for {@link #keys()} is {@code [key1, key2, key1]},\n",
        "57": " * and similarly for {@link #entries()}. Unlike {@link LinkedHashMultimap}, the\n",
        "58": " * iteration order is kept consistent between keys, entries and values. For\n",
        "59": " * example, calling: <pre>   {@code\n",
        "61": " *   map.remove(key1, foo);}</pre>\n",
        "63": " * <p>changes the entries iteration order to {@code [key2=bar, key1=baz]} and the\n",
        "64": " * key iteration order to {@code [key2, key1]}. The {@link #entries()} iterator\n",
        "65": " * returns mutable map entries, and {@link #replaceValues} attempts to preserve\n",
        "66": " * iteration order as much as possible.\n",
        "68": " * <p>The collections returned by {@link #keySet()} and {@link #asMap} iterate\n",
        "69": " * through the keys in the order they were first added to the multimap.\n",
        "70": " * Similarly, {@link #get}, {@link #removeAll}, and {@link #replaceValues}\n",
        "71": " * return collections that iterate through the values in the order they were\n",
        "72": " * added. The collections generated by {@link #entries()}, {@link #keys()}, and\n",
        "73": " * {@link #values} iterate across the key-value mappings in the order they were\n",
        "74": " * added to the multimap.\n",
        "76": " * <p>The {@link #values()} and {@link #entries()} methods both return a\n",
        "77": " * {@code List}, instead of the {@code Collection} specified by the {@link\n",
        "78": " * ListMultimap} interface.\n",
        "80": " * <p>The methods {@link #get}, {@link #keySet()}, {@link #keys()},\n",
        "81": " * {@link #values}, {@link #entries()}, and {@link #asMap} return collections\n",
        "82": " * that are views of the multimap. If the multimap is modified while an\n",
        "83": " * iteration over any of those collections is in progress, except through the\n",
        "84": " * iterator's methods, the results of the iteration are undefined.\n",
        "86": " * <p>Keys and values may be null. All optional multimap methods are supported,\n",
        "87": " * and all returned views are modifiable.\n",
        "89": " * <p>This class is not threadsafe when any concurrent operations update the\n",
        "90": " * multimap. Concurrent read operations will work correctly. To allow concurrent\n",
        "91": " * update operations, wrap your multimap with a call to {@link\n",
        "92": " * Multimaps#synchronizedListMultimap}.\n",
        "95": " * \"https://github.com/google/guava/wiki/NewCollectionTypesExplained#multimap\">\n",
        "96": " * {@code Multimap}</a>.\n",
        "168": "  /**\n",
        "169": "   * Creates a new, empty {@code LinkedListMultimap} with the default initial\n",
        "170": "   * capacity.\n",
        "171": "   */\n",
        "177": "   * Constructs an empty {@code LinkedListMultimap} with enough capacity to hold\n",
        "178": "   * the specified number of keys without rehashing.\n",
        "188": "   * Constructs a {@code LinkedListMultimap} with the same mappings as the\n",
        "189": "   * specified {@code Multimap}. The new multimap has the same\n",
        "190": "   * {@link Multimap#entries()} iteration order as the input multimap.\n",
        "213": "   * Adds a new node for the specified key-value pair before the specified\n",
        "214": "   * {@code nextSibling} element, or at the end of the list if {@code\n",
        "215": "   * nextSibling} is null. Note: if {@code nextSibling} is specified, it MUST be\n",
        "216": "   * for an node for the same {@code key}!\n",
        "265": "   * Removes the specified node from the linked list. This method is only\n",
        "266": "   * intended to be used from the {@code Iterator} classes. See also {@link\n",
        "267": "   * LinkedListMultimap#removeAllNodes(Object)}.\n",
        "479": "     * Constructs a new iterator over all values for the specified key starting\n",
        "480": "     * at the specified index. This constructor is optimized so that it starts\n",
        "481": "     * at either the head or the tail, depending on which is closer to the\n",
        "482": "     * specified index. This allows adds to the tail to be done in constant\n",
        "483": "     * time.\n",
        "618": "   * <p>If any entries for the specified {@code key} already exist in the\n",
        "619": "   * multimap, their values are changed in-place without affecting the iteration\n",
        "620": "   * order.\n",
        "622": "   * <p>The returned list is immutable and implements\n",
        "623": "   * {@link java.util.RandomAccess}.\n",
        "659": "   * <p>The returned list is immutable and implements\n",
        "660": "   * {@link java.util.RandomAccess}.\n",
        "684": "   * <p>If the multimap is modified while an iteration over the list is in\n",
        "685": "   * progress (except through the iterator's own {@code add}, {@code set} or\n",
        "686": "   * {@code remove} operations) the results of the iteration are undefined.\n",
        "736": "   * <p>The iterator generated by the returned collection traverses the values\n",
        "737": "   * in the order they were added to the multimap. Because the values may have\n",
        "738": "   * duplicates and follow the insertion ordering, this method returns a {@link\n",
        "739": "   * List}, instead of the {@link Collection} specified in the {@link\n",
        "740": "   * ListMultimap} interface.\n",
        "778": "   * <p>The iterator generated by the returned collection traverses the entries\n",
        "779": "   * in the order they were added to the multimap. Because the entries may have\n",
        "780": "   * duplicates and follow the insertion ordering, this method returns a {@link\n",
        "781": "   * List}, instead of the {@link Collection} specified in the {@link\n",
        "782": "   * ListMultimap} interface.\n",
        "784": "   * <p>An entry's {@link Entry#getKey} method always returns the same key,\n",
        "785": "   * regardless of what happens subsequently. As long as the corresponding\n",
        "786": "   * key-value mapping is not removed from the multimap, {@link Entry#getValue}\n",
        "787": "   * returns the value from the multimap, which may change over time, and {@link\n",
        "788": "   * Entry#setValue} modifies that value. Removing the mapping from the\n",
        "789": "   * multimap does not alter the value returned by {@code getValue()}, though a\n",
        "790": "   * subsequent {@code setValue()} call won't update the multimap but will lead\n",
        "791": "   * to a revised value being returned by {@code getValue()}.\n",
        "826": "   * @serialData the number of distinct keys, and then for each distinct key:\n",
        "827": "   *     the first key, the number of values for that key, and the key's values,\n",
        "828": "   *     followed by successive keys and values from the entries() ordering\n"
    }
}