{
    "addition": {
        "35": " * <p>Use this class to test code triggered by <em>finalization</em>, that is, one of the following\n",
        "36": " * actions taken by the java garbage collection system:\n",
        "39": " *   <li>invoking the {@code finalize} methods of unreachable objects\n",
        "40": " *   <li>clearing weak references to unreachable referents\n",
        "41": " *   <li>enqueuing weak references to unreachable referents in their reference queue\n",
        "45": " * finalization to happen. However, a call to {@code System.gc()} is specified to be no more than a\n",
        "46": " * hint, so this technique may fail at the whim of the JDK implementation, for example if a user\n",
        "47": " * specified the JVM flag {@code -XX:+DisableExplicitGC}. But in practice, it works very well for\n",
        "48": " * ordinary tests.\n",
        "56": " * <pre>{@code\n",
        "57": " * final CountDownLatch latch = new CountDownLatch(1);\n",
        "58": " * Object x = new MyClass() {\n",
        "59": " *   ...\n",
        "60": " *   protected void finalize() { latch.countDown(); ... }\n",
        "61": " * };\n",
        "62": " * x = null;  // Hint to the JIT that x is stack-unreachable\n",
        "63": " * GcFinalization.await(latch);\n",
        "64": " * }</pre>\n",
        "68": " * <pre>{@code\n",
        "69": " * final WeakHashMap<Object, Object> map = new WeakHashMap<Object, Object>();\n",
        "70": " * map.put(new Object(), Boolean.TRUE);\n",
        "71": " * GcFinalization.awaitDone(new FinalizationPredicate() {\n",
        "72": " *   public boolean isDone() {\n",
        "73": " *     return map.isEmpty();\n",
        "74": " *   }\n",
        "75": " * });\n",
        "76": " * }</pre>\n",
        "78": " * <p>Even if your non-test code does not use finalization, you can use this class to test for\n",
        "79": " * leaks, by ensuring that objects are no longer strongly referenced:\n",
        "81": " * <pre>{@code\n",
        "92": " * }\n",
        "93": " * }</pre>\n",
        "98": " * <p>This class only provides testing utilities. It is not designed for direct use in production or\n",
        "99": " * for benchmarking.\n",
        "112": "   * 10 seconds ought to be long enough for any object to be GC'ed and finalized. Unless we have a\n",
        "131": "   * Waits until the given future {@linkplain Future#isDone is done}, invoking the garbage collector\n",
        "132": "   * as necessary to try to ensure that this will happen.\n",
        "193": "   * Creates a garbage object that counts down the latch in its finalizer. Sequestered into a\n",
        "197": "    new Object() {\n",
        "198": "      @Override\n",
        "199": "      protected void finalize() {\n",
        "200": "        latch.countDown();\n",
        "201": "      }\n",
        "202": "    };\n",
        "211": "   *   <li>invoking the {@code finalize} methods of unreachable objects\n",
        "212": "   *   <li>clearing weak references to unreachable referents\n",
        "213": "   *   <li>enqueuing weak references to unreachable referents in their reference queue\n",
        "249": "   * Waits until the given weak reference is cleared, invoking the garbage collector as necessary to\n",
        "250": "   * try to ensure that this will happen.\n",
        "253": "   *\n",
        "254": "   * <pre>{@code\n",
        "255": "   * awaitDone(new FinalizationPredicate() {\n",
        "256": "   *   public boolean isDone() {\n",
        "257": "   *     return ref.get() == null;\n",
        "258": "   *   }\n",
        "259": "   * });\n",
        "260": "   * }</pre>\n",
        "265": "    awaitDone(\n",
        "266": "        new FinalizationPredicate() {\n",
        "267": "          public boolean isDone() {\n",
        "268": "            return ref.get() == null;\n",
        "269": "          }\n",
        "270": "        });\n",
        "274": "   * Tries to perform a \"full\" garbage collection cycle (including processing of weak references and\n",
        "275": "   * invocation of finalize methods) and waits for it to complete. Ensures that at least one weak\n",
        "276": "   * reference has been cleared and one {@code finalize} method has been run before this method\n",
        "277": "   * returns. This method may be useful when testing the garbage collection mechanism itself, or\n",
        "278": "   * inhibiting a spontaneous GC initiation in subsequent code.\n",
        "285": "   * from GC, as with {@link #awaitClear}. Because there are no guarantees for the order of GC\n"
    },
    "removed": {
        "35": " * <p>Use this class to test code triggered by <em>finalization</em>, that is, one of the\n",
        "36": " * following actions taken by the java garbage collection system:\n",
        "39": " * <li>invoking the {@code finalize} methods of unreachable objects\n",
        "40": " * <li>clearing weak references to unreachable referents\n",
        "41": " * <li>enqueuing weak references to unreachable referents in their reference queue\n",
        "45": " * finalization to happen.  However, a call to {@code System.gc()} is specified to be no more\n",
        "46": " * than a hint, so this technique may fail at the whim of the JDK implementation, for example if\n",
        "47": " * a user specified the JVM flag {@code -XX:+DisableExplicitGC}.  But in practice, it works very\n",
        "48": " * well for ordinary tests.\n",
        "56": " * <pre>   {@code\n",
        "57": " *   final CountDownLatch latch = new CountDownLatch(1);\n",
        "58": " *   Object x = new MyClass() {\n",
        "59": " *     ...\n",
        "60": " *     protected void finalize() { latch.countDown(); ... }\n",
        "61": " *   };\n",
        "62": " *   x = null;  // Hint to the JIT that x is stack-unreachable\n",
        "63": " *   GcFinalization.await(latch);}</pre>\n",
        "67": " * <pre>   {@code\n",
        "68": " *   final WeakHashMap<Object, Object> map = new WeakHashMap<Object, Object>();\n",
        "69": " *   map.put(new Object(), Boolean.TRUE);\n",
        "70": " *   GcFinalization.awaitDone(new FinalizationPredicate() {\n",
        "71": " *     public boolean isDone() {\n",
        "72": " *       return map.isEmpty();\n",
        "73": " *     }\n",
        "74": " *   });}</pre>\n",
        "76": " * <p>Even if your non-test code does not use finalization, you can\n",
        "77": " * use this class to test for leaks, by ensuring that objects are no\n",
        "78": " * longer strongly referenced:\n",
        "80": " * <pre> {@code\n",
        "91": " * }}</pre>\n",
        "96": " * <p>This class only provides testing utilities.  It is not designed for direct use in production\n",
        "97": " * or for benchmarking.\n",
        "110": "   * 10 seconds ought to be long enough for any object to be GC'ed and finalized.  Unless we have a\n",
        "129": "   * Waits until the given future {@linkplain Future#isDone is done}, invoking the garbage\n",
        "130": "   * collector as necessary to try to ensure that this will happen.\n",
        "191": "   * Creates a garbage object that counts down the latch in its finalizer.  Sequestered into a\n",
        "195": "    new Object() { @Override protected void finalize() { latch.countDown(); }};\n",
        "204": "   * <li>invoking the {@code finalize} methods of unreachable objects\n",
        "205": "   * <li>clearing weak references to unreachable referents\n",
        "206": "   * <li>enqueuing weak references to unreachable referents in their reference queue\n",
        "242": "   * Waits until the given weak reference is cleared, invoking the garbage collector as necessary\n",
        "243": "   * to try to ensure that this will happen.\n",
        "246": "   * <pre>   {@code\n",
        "247": "   *   awaitDone(new FinalizationPredicate() {\n",
        "248": "   *     public boolean isDone() {\n",
        "249": "   *       return ref.get() == null;\n",
        "250": "   *     }\n",
        "251": "   *   });}</pre>\n",
        "256": "    awaitDone(new FinalizationPredicate() {\n",
        "257": "      public boolean isDone() {\n",
        "258": "        return ref.get() == null;\n",
        "259": "      }\n",
        "260": "    });\n",
        "264": "   * Tries to perform a \"full\" garbage collection cycle (including processing of weak references\n",
        "265": "   * and invocation of finalize methods) and waits for it to complete.  Ensures that at least one\n",
        "266": "   * weak reference has been cleared and one {@code finalize} method has been run before this\n",
        "267": "   * method returns.  This method may be useful when testing the garbage collection mechanism\n",
        "268": "   * itself, or inhibiting a spontaneous GC initiation in subsequent code.\n",
        "275": "   * from GC, as with {@link #awaitClear}.  Because there are no guarantees for the order of GC\n"
    }
}