{
    "addition": {
        "48": " * Implementation of {@code Multimap} that does not allow duplicate key-value entries and that\n",
        "49": " * returns collections whose iterators follow the ordering in which the data was added to the\n",
        "50": " * multimap.\n",
        "52": " * <p>The collections returned by {@code keySet}, {@code keys}, and {@code asMap} iterate through\n",
        "53": " * the keys in the order they were first added to the multimap. Similarly, {@code get}, {@code\n",
        "54": " * removeAll}, and {@code replaceValues} return collections that iterate through the values in the\n",
        "55": " * order they were added. The collections generated by {@code entries} and {@code values} iterate\n",
        "56": " * across the key-value mappings in the order they were added to the multimap.\n",
        "58": " * <p>The iteration ordering of the collections generated by {@code keySet}, {@code keys}, and\n",
        "59": " * {@code asMap} has a few subtleties. As long as the set of keys remains unchanged, adding or\n",
        "60": " * removing mappings does not affect the key iteration order. However, if you remove all values\n",
        "61": " * associated with a key and then add the key back to the multimap, that key will come last in the\n",
        "62": " * key iteration order.\n",
        "64": " * <p>The multimap does not store duplicate key-value pairs. Adding a new key-value pair equal to an\n",
        "65": " * existing key-value pair has no effect.\n",
        "67": " * <p>Keys and values may be null. All optional multimap methods are supported, and all returned\n",
        "68": " * views are modifiable.\n",
        "70": " * <p>This class is not threadsafe when any concurrent operations update the multimap. Concurrent\n",
        "71": " * read operations will work correctly. To allow concurrent update operations, wrap your multimap\n",
        "72": " * with a call to {@link Multimaps#synchronizedSetMultimap}.\n",
        "75": " * \"https://github.com/google/guava/wiki/NewCollectionTypesExplained#multimap\"> {@code\n",
        "76": " * Multimap}</a>.\n",
        "86": "  /** Creates a new, empty {@code LinkedHashMultimap} with the default initial capacities. */\n",
        "92": "   * Constructs an empty {@code LinkedHashMultimap} with enough capacity to hold the specified\n",
        "93": "   * numbers of keys and values without rehashing.\n",
        "97": "   * @throws IllegalArgumentException if {@code expectedKeys} or {@code expectedValuesPerKey} is\n",
        "98": "   *     negative\n",
        "106": "   * Constructs a {@code LinkedHashMultimap} with the same mappings as the specified multimap. If a\n",
        "107": "   * key-value mapping appears multiple times in the input multimap, it only appears once in the\n",
        "108": "   * constructed multimap. The new multimap has the same {@link Multimap#entries()} iteration order\n",
        "109": "   * as the input multimap, except for excluding duplicate mappings.\n",
        "236": "   * <p>Creates an empty {@code LinkedHashSet} for a collection of values for one key.\n",
        "238": "   * @return a new {@code LinkedHashSet} containing a collection of values for one key\n",
        "248": "   * <p>Creates a decorated insertion-ordered set that also keeps track of the order in which\n",
        "249": "   * key-value pairs are added to the multimap.\n",
        "262": "   * <p>If {@code values} is not empty and the multimap already contains a mapping for {@code key},\n",
        "263": "   * the {@code keySet()} ordering is unchanged. However, the provided values always come last in\n",
        "264": "   * the {@link #entries()} and {@link #values()} iteration orderings.\n",
        "273": "   * Returns a set of all key-value pairs. Changes to the returned set will update the underlying\n",
        "274": "   * multimap, and vice versa. The entries set does not support the {@code add} or {@code addAll}\n",
        "275": "   * operations.\n",
        "277": "   * <p>The iterator generated by the returned set traverses the entries in the order they were\n",
        "278": "   * added to the multimap.\n",
        "280": "   * <p>Each entry is an immutable snapshot of a key-value mapping in the multimap, taken at the\n",
        "281": "   * time the entry is returned by a method call to the collection or its iterator.\n",
        "289": "   * Returns a view collection of all <i>distinct</i> keys contained in this multimap. Note that the\n",
        "290": "   * key set contains a key if and only if this multimap maps that key to at least one value.\n",
        "292": "   * <p>The iterator generated by the returned set traverses the keys in the order they were first\n",
        "293": "   * added to the multimap.\n",
        "295": "   * <p>Changes to the returned set will update the underlying multimap, and vice versa. However,\n",
        "296": "   * <i>adding</i> to the returned set is not possible.\n",
        "304": "   * Returns a collection of all values in the multimap. Changes to the returned collection will\n",
        "305": "   * update the underlying multimap, and vice versa.\n",
        "307": "   * <p>The iterator generated by the returned collection traverses the values in the order they\n",
        "308": "   * were added to the multimap.\n",
        "573": "   * @serialData the expected values per key, the number of distinct keys, the number of entries,\n",
        "574": "   *     and the entries in order\n"
    },
    "removed": {
        "48": " * Implementation of {@code Multimap} that does not allow duplicate key-value\n",
        "49": " * entries and that returns collections whose iterators follow the ordering in\n",
        "50": " * which the data was added to the multimap.\n",
        "52": " * <p>The collections returned by {@code keySet}, {@code keys}, and {@code\n",
        "53": " * asMap} iterate through the keys in the order they were first added to the\n",
        "54": " * multimap. Similarly, {@code get}, {@code removeAll}, and {@code\n",
        "55": " * replaceValues} return collections that iterate through the values in the\n",
        "56": " * order they were added. The collections generated by {@code entries} and\n",
        "57": " * {@code values} iterate across the key-value mappings in the order they were\n",
        "58": " * added to the multimap.\n",
        "60": " * <p>The iteration ordering of the collections generated by {@code keySet},\n",
        "61": " * {@code keys}, and {@code asMap} has a few subtleties. As long as the set of\n",
        "62": " * keys remains unchanged, adding or removing mappings does not affect the key\n",
        "63": " * iteration order. However, if you remove all values associated with a key and\n",
        "64": " * then add the key back to the multimap, that key will come last in the key\n",
        "65": " * iteration order.\n",
        "67": " * <p>The multimap does not store duplicate key-value pairs. Adding a new\n",
        "68": " * key-value pair equal to an existing key-value pair has no effect.\n",
        "70": " * <p>Keys and values may be null. All optional multimap methods are supported,\n",
        "71": " * and all returned views are modifiable.\n",
        "73": " * <p>This class is not threadsafe when any concurrent operations update the\n",
        "74": " * multimap. Concurrent read operations will work correctly. To allow concurrent\n",
        "75": " * update operations, wrap your multimap with a call to {@link\n",
        "76": " * Multimaps#synchronizedSetMultimap}.\n",
        "79": " * \"https://github.com/google/guava/wiki/NewCollectionTypesExplained#multimap\">\n",
        "80": " * {@code Multimap}</a>.\n",
        "90": "  /**\n",
        "91": "   * Creates a new, empty {@code LinkedHashMultimap} with the default initial\n",
        "92": "   * capacities.\n",
        "93": "   */\n",
        "99": "   * Constructs an empty {@code LinkedHashMultimap} with enough capacity to hold\n",
        "100": "   * the specified numbers of keys and values without rehashing.\n",
        "104": "   * @throws IllegalArgumentException if {@code expectedKeys} or {@code\n",
        "105": "   *      expectedValuesPerKey} is negative\n",
        "113": "   * Constructs a {@code LinkedHashMultimap} with the same mappings as the\n",
        "114": "   * specified multimap. If a key-value mapping appears multiple times in the\n",
        "115": "   * input multimap, it only appears once in the constructed multimap. The new\n",
        "116": "   * multimap has the same {@link Multimap#entries()} iteration order as the\n",
        "117": "   * input multimap, except for excluding duplicate mappings.\n",
        "244": "   * <p>Creates an empty {@code LinkedHashSet} for a collection of values for\n",
        "245": "   * one key.\n",
        "247": "   * @return a new {@code LinkedHashSet} containing a collection of values for\n",
        "248": "   *     one key\n",
        "258": "   * <p>Creates a decorated insertion-ordered set that also keeps track of the\n",
        "259": "   * order in which key-value pairs are added to the multimap.\n",
        "272": "   * <p>If {@code values} is not empty and the multimap already contains a\n",
        "273": "   * mapping for {@code key}, the {@code keySet()} ordering is unchanged.\n",
        "274": "   * However, the provided values always come last in the {@link #entries()} and\n",
        "275": "   * {@link #values()} iteration orderings.\n",
        "284": "   * Returns a set of all key-value pairs. Changes to the returned set will\n",
        "285": "   * update the underlying multimap, and vice versa. The entries set does not\n",
        "286": "   * support the {@code add} or {@code addAll} operations.\n",
        "288": "   * <p>The iterator generated by the returned set traverses the entries in the\n",
        "289": "   * order they were added to the multimap.\n",
        "291": "   * <p>Each entry is an immutable snapshot of a key-value mapping in the\n",
        "292": "   * multimap, taken at the time the entry is returned by a method call to the\n",
        "293": "   * collection or its iterator.\n",
        "301": "   * Returns a view collection of all <i>distinct</i> keys contained in this\n",
        "302": "   * multimap. Note that the key set contains a key if and only if this multimap\n",
        "303": "   * maps that key to at least one value.\n",
        "305": "   * <p>The iterator generated by the returned set traverses the keys in the\n",
        "306": "   * order they were first added to the multimap.\n",
        "308": "   * <p>Changes to the returned set will update the underlying multimap, and\n",
        "309": "   * vice versa. However, <i>adding</i> to the returned set is not possible.\n",
        "317": "   * Returns a collection of all values in the multimap. Changes to the returned\n",
        "318": "   * collection will update the underlying multimap, and vice versa.\n",
        "320": "   * <p>The iterator generated by the returned collection traverses the values\n",
        "321": "   * in the order they were added to the multimap.\n",
        "586": "   * @serialData the expected values per key, the number of distinct keys,\n",
        "587": "   * the number of entries, and the entries in order\n"
    }
}