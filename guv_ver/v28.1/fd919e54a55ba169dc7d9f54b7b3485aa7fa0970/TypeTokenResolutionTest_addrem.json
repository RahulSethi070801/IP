{
    "addition": {
        "99": "  private abstract static class Bar<T> {}\n",
        "104": "        @Override\n",
        "105": "        public Type[] getActualTypeArguments() {\n",
        "106": "          return new Type[] {new TypeCapture<P>() {}.capture()};\n",
        "108": "\n",
        "109": "        @Override\n",
        "110": "        public Type getOwnerType() {\n",
        "113": "\n",
        "114": "        @Override\n",
        "115": "        public Type getRawType() {\n",
        "127": "    ParameterizedType resolved =\n",
        "128": "        (ParameterizedType) typeResolver.resolveType(parameterized.parameterizedType());\n",
        "140": "  private interface IntegerStringFunction\n",
        "141": "      extends IntegerSupplier, Predicate<List<String>>, StringListPredicate {}\n",
        "146": "    assertEquals(\n",
        "147": "        Integer.class, TypeToken.of(IntegerStringFunction.class).resolveType(fType).getRawType());\n",
        "151": "    assertEquals(\n",
        "152": "        new TypeToken<List<String>>() {}.getType(),\n",
        "153": "        TypeToken.of(IntegerStringFunction.class).resolveType(predicateParameterType).getType());\n",
        "156": "  private abstract static class StringIntegerFoo extends Foo<String, Integer> {}\n",
        "164": "    private abstract static class Nested<X> {\n",
        "182": "    assertEquals(String.class, new Owner<Integer>().new Inner<String>() {}.getTypeArgument());\n",
        "186": "    assertEquals(Integer.class, new Owner<Integer>().new Inner<String>() {}.getOwnerType());\n",
        "230": "    Type fieldType = ParameterizedOuter.class.getField(\"field\").getGenericType();\n",
        "231": "    assertEquals(\n",
        "232": "        fieldType, TypeToken.of(ParameterizedOuter.class).resolveType(fieldType).getType());\n",
        "239": "    assertEquals(\n",
        "240": "        String.class,\n",
        "242": "            .resolveType(Iterable.class.getTypeParameters()[0])\n",
        "243": "            .getType());\n",
        "244": "    assertEquals(\n",
        "245": "        String.class,\n",
        "247": "            .resolveType(Iterable.class.getTypeParameters()[0])\n",
        "248": "            .getType());\n",
        "252": "    } catch (NullPointerException expected) {\n",
        "253": "    }\n",
        "263": "    Type context = Context.class.getDeclaredMethod(\"returningMap\").getGenericReturnType();\n",
        "269": "    assertEquals(Integer.class, TypeToken.of(context).resolveType(valueType).getType());\n",
        "284": "    assertEquals(Types.newArrayType(genericArray.t), genericArray.array);\n",
        "337": "    Red<String>.Yellow<Integer> yellowInteger = redString.new Yellow<Integer>(redInteger) {};\n",
        "347": "    Red<String>.Yellow<Integer> yellowInteger = redString.new Yellow<Integer>(redInteger) {};\n",
        "387": "    assertNotNull(\n",
        "388": "        new Object() {\n",
        "389": "          Type getType() {\n",
        "390": "            return new TypeToken<Object>() {}.getType();\n",
        "391": "          }\n",
        "392": "        }.getType());\n",
        "406": "    assertEquals(new TypeToken<int[]>() {}.getType(), new Holder<int[]>() {}.getContentType());\n",
        "407": "    assertEquals(new TypeToken<int[][]>() {}.getType(), new Holder<int[][]>() {}.getContentType());\n",
        "411": "    GenericArrayType arrayType =\n",
        "412": "        (GenericArrayType) new Holder<List<int[][]>[]>() {}.getContentType();\n",
        "413": "    ParameterizedType listType = (ParameterizedType) arrayType.getGenericComponentType();\n",
        "415": "    assertEquals(Types.newArrayType(int[].class), listType.getActualTypeArguments()[0]);\n",
        "437": "      ParameterizedType parameterType =\n",
        "438": "          (ParameterizedType)\n",
        "439": "              WithGenericBound.class.getDeclaredMethod(methodName, List.class)\n",
        "440": "                  .getGenericParameterTypes()[0];\n",
        "441": "      parameterType =\n",
        "442": "          (ParameterizedType) TypeToken.of(this.getClass()).resolveType(parameterType).getType();\n",
        "448": "    TypeVariable<?> typeVariable =\n",
        "449": "        (TypeVariable<?>) new WithGenericBound<String>() {}.getTargetType(\"withTypeVariable\");\n",
        "454": "    TypeVariable<?> typeVariable =\n",
        "455": "        (TypeVariable<?>) new WithGenericBound<String>() {}.getTargetType(\"withRecursiveBound\");\n",
        "456": "    assertEquals(Types.newParameterizedType(Enum.class, typeVariable), typeVariable.getBounds()[0]);\n",
        "460": "    ParameterizedType paramType =\n",
        "461": "        (ParameterizedType)\n",
        "462": "            new WithGenericBound<String>() {}.getTargetType(\"withMutualRecursiveBound\");\n",
        "470": "    WildcardType wildcardType =\n",
        "471": "        (WildcardType) new WithGenericBound<String>() {}.getTargetType(\"withWildcardLowerBound\");\n",
        "476": "    WildcardType wildcardType =\n",
        "477": "        (WildcardType) new WithGenericBound<String>() {}.getTargetType(\"withWildcardUpperBound\");\n",
        "482": "    assertEquals(\n",
        "483": "        String.class,\n",
        "485": "            .resolveType(List.class.getTypeParameters()[0])\n",
        "486": "            .getType());\n",
        "508": "    Type returnType =\n",
        "509": "        genericReturnType(WithFalseRecursiveType.class, \"keyShouldNotResolveToStringList\");\n",
        "510": "    TypeToken<?> keyType =\n",
        "511": "        TypeToken.of(returnType).resolveType(WithFalseRecursiveType.class.getTypeParameters()[0]);\n",
        "516": "    Type returnType = genericReturnType(WithFalseRecursiveType.class, \"shouldNotCauseInfiniteLoop\");\n",
        "517": "    TypeToken<?> keyType =\n",
        "518": "        TypeToken.of(returnType).resolveType(WithFalseRecursiveType.class.getTypeParameters()[0]);\n",
        "523": "    Type returnType = genericReturnType(WithFalseRecursiveType.class, \"evenSubtypeWorks\");\n",
        "524": "    TypeToken<?> keyType =\n",
        "525": "        TypeToken.of(returnType).resolveType(WithFalseRecursiveType.class.getTypeParameters()[0]);\n",
        "530": "    Type returnType =\n",
        "531": "        genericReturnType(SubtypeOfWithFalseRecursiveType.class, \"revertKeyAndValueTypes\");\n",
        "532": "    TypeToken<?> keyType =\n",
        "533": "        TypeToken.of(returnType).resolveType(WithFalseRecursiveType.class.getTypeParameters()[0]);\n",
        "549": "        Type type =\n",
        "550": "            new TypeToken<B>(getClass()) {}\n",
        "553": "            .where(new TypeParameter<B>() {}, (Class) Integer.class).getType();\n"
    },
    "removed": {
        "99": "  private static abstract class Bar<T> {}\n",
        "104": "        @Override public Type[] getActualTypeArguments() {\n",
        "105": "          return new Type[]{new TypeCapture<P>() {}.capture()};\n",
        "107": "        @Override public Type getOwnerType() {\n",
        "110": "        @Override public Type getRawType() {\n",
        "122": "    ParameterizedType resolved = (ParameterizedType) typeResolver.resolveType(\n",
        "123": "        parameterized.parameterizedType());\n",
        "134": "  private interface IntegerStringFunction extends IntegerSupplier,\n",
        "135": "      Predicate<List<String>>, StringListPredicate {}\n",
        "140": "    assertEquals(Integer.class,\n",
        "141": "        TypeToken.of(IntegerStringFunction.class).resolveType(fType)\n",
        "142": "            .getRawType());\n",
        "146": "    assertEquals(new TypeToken<List<String>>() {}.getType(),\n",
        "147": "        TypeToken.of(IntegerStringFunction.class).resolveType(predicateParameterType)\n",
        "148": "            .getType());\n",
        "151": "  private static abstract class StringIntegerFoo extends Foo<String, Integer> {}\n",
        "159": "    private static abstract class Nested<X> {\n",
        "177": "    assertEquals(String.class,\n",
        "178": "        new Owner<Integer>().new Inner<String>() {}.getTypeArgument());\n",
        "182": "    assertEquals(Integer.class,\n",
        "183": "        new Owner<Integer>().new Inner<String>() {}.getOwnerType());\n",
        "227": "    Type fieldType = ParameterizedOuter.class.getField(\"field\")\n",
        "228": "        .getGenericType();\n",
        "229": "    assertEquals(fieldType,\n",
        "230": "        TypeToken.of(ParameterizedOuter.class).resolveType(fieldType).getType());\n",
        "237": "    assertEquals(String.class,\n",
        "239": "            .resolveType(Iterable.class.getTypeParameters()[0]).getType());\n",
        "240": "    assertEquals(String.class,\n",
        "242": "            .resolveType(Iterable.class.getTypeParameters()[0]).getType());\n",
        "246": "    } catch (NullPointerException expected) {}\n",
        "256": "    Type context = Context.class.getDeclaredMethod(\"returningMap\")\n",
        "257": "        .getGenericReturnType();\n",
        "263": "    assertEquals(Integer.class,\n",
        "264": "        TypeToken.of(context).resolveType(valueType).getType());\n",
        "279": "    assertEquals(Types.newArrayType(genericArray.t),\n",
        "280": "        genericArray.array);\n",
        "333": "    Red<String>.Yellow<Integer> yellowInteger =\n",
        "334": "        redString.new Yellow<Integer>(redInteger) {};\n",
        "344": "    Red<String>.Yellow<Integer> yellowInteger =\n",
        "345": "        redString.new Yellow<Integer>(redInteger) {};\n",
        "385": "    assertNotNull(new Object() {\n",
        "386": "      Type getType() {\n",
        "387": "        return new TypeToken<Object>() {}.getType();\n",
        "388": "      }\n",
        "389": "    }.getType());\n",
        "403": "    assertEquals(new TypeToken<int[]>() {}.getType(),\n",
        "404": "        new Holder<int[]>() {}.getContentType());\n",
        "405": "    assertEquals(new TypeToken<int[][]> () {}.getType(),\n",
        "406": "        new Holder<int[][]>() {}.getContentType());\n",
        "410": "    GenericArrayType arrayType = (GenericArrayType)\n",
        "411": "        new Holder<List<int[][]>[]>() {}.getContentType();\n",
        "412": "    ParameterizedType listType = (ParameterizedType)\n",
        "413": "        arrayType.getGenericComponentType();\n",
        "415": "    assertEquals(Types.newArrayType(int[].class),\n",
        "416": "        listType.getActualTypeArguments()[0]);\n",
        "438": "      ParameterizedType parameterType = (ParameterizedType)\n",
        "439": "          WithGenericBound.class.getDeclaredMethod(methodName, List.class)\n",
        "440": "              .getGenericParameterTypes()[0];\n",
        "441": "      parameterType = (ParameterizedType)\n",
        "442": "          TypeToken.of(this.getClass()).resolveType(parameterType).getType();\n",
        "448": "    TypeVariable<?> typeVariable = (TypeVariable<?>)\n",
        "449": "        new WithGenericBound<String>() {}.getTargetType(\"withTypeVariable\");\n",
        "454": "    TypeVariable<?> typeVariable = (TypeVariable<?>)\n",
        "455": "        new WithGenericBound<String>() {}.getTargetType(\"withRecursiveBound\");\n",
        "456": "    assertEquals(Types.newParameterizedType(Enum.class, typeVariable),\n",
        "457": "        typeVariable.getBounds()[0]);\n",
        "461": "    ParameterizedType paramType = (ParameterizedType)\n",
        "462": "        new WithGenericBound<String>() {}\n",
        "463": "            .getTargetType(\"withMutualRecursiveBound\");\n",
        "471": "    WildcardType wildcardType = (WildcardType)\n",
        "472": "        new WithGenericBound<String>() {}\n",
        "473": "            .getTargetType(\"withWildcardLowerBound\");\n",
        "478": "    WildcardType wildcardType = (WildcardType)\n",
        "479": "        new WithGenericBound<String>() {}\n",
        "480": "            .getTargetType(\"withWildcardUpperBound\");\n",
        "485": "    assertEquals(String.class,\n",
        "487": "            .resolveType(List.class.getTypeParameters()[0]).getType());\n",
        "507": "    Type returnType = genericReturnType(\n",
        "508": "        WithFalseRecursiveType.class, \"keyShouldNotResolveToStringList\");\n",
        "509": "    TypeToken<?> keyType = TypeToken.of(returnType)\n",
        "510": "        .resolveType(WithFalseRecursiveType.class.getTypeParameters()[0]);\n",
        "515": "    Type returnType = genericReturnType(\n",
        "516": "        WithFalseRecursiveType.class, \"shouldNotCauseInfiniteLoop\");\n",
        "517": "    TypeToken<?> keyType = TypeToken.of(returnType)\n",
        "518": "        .resolveType(WithFalseRecursiveType.class.getTypeParameters()[0]);\n",
        "523": "    Type returnType = genericReturnType(\n",
        "524": "        WithFalseRecursiveType.class, \"evenSubtypeWorks\");\n",
        "525": "    TypeToken<?> keyType = TypeToken.of(returnType)\n",
        "526": "        .resolveType(WithFalseRecursiveType.class.getTypeParameters()[0]);\n",
        "531": "    Type returnType = genericReturnType(\n",
        "532": "        SubtypeOfWithFalseRecursiveType.class, \"revertKeyAndValueTypes\");\n",
        "533": "    TypeToken<?> keyType = TypeToken.of(returnType)\n",
        "534": "        .resolveType(WithFalseRecursiveType.class.getTypeParameters()[0]);\n",
        "550": "        Type type = new TypeToken<B>(getClass()) {}\n",
        "553": "            .where(new TypeParameter<B>() {}, (Class) Integer.class)\n",
        "554": "            .getType();\n"
    }
}