{
    "addition": {
        "56": " * \"https://github.com/google/guava/wiki/CollectionUtilitiesExplained#multimaps\"> {@code\n",
        "57": " * Multimaps}</a>.\n",
        "70": "   * Creates a new {@code Multimap} backed by {@code map}, whose internal value collections are\n",
        "71": "   * generated by {@code factory}.\n",
        "72": "   *\n",
        "73": "   * <p><b>Warning: do not use</b> this method when the collections returned by {@code factory}\n",
        "74": "   * implement either {@link List} or {@code Set}! Use the more specific method {@link\n",
        "75": "   * #newListMultimap}, {@link #newSetMultimap} or {@link #newSortedSetMultimap} instead, to avoid\n",
        "76": "   * very surprising behavior from {@link Multimap#equals}.\n",
        "77": "   *\n",
        "78": "   * <p>The {@code factory}-generated and {@code map} classes determine the multimap iteration\n",
        "79": "   * order. They also specify the behavior of the {@code equals}, {@code hashCode}, and {@code\n",
        "80": "   * toString} methods for the multimap and its returned views. However, the multimap's {@code get}\n",
        "81": "   * method returns instances of a different class than {@code factory.get()} does.\n",
        "82": "   *\n",
        "83": "   * <p>The multimap is serializable if {@code map}, {@code factory}, the collections generated by\n",
        "84": "   * {@code factory}, and the multimap contents are all serializable.\n",
        "85": "   *\n",
        "86": "   * <p>The multimap is not threadsafe when any concurrent operations update the multimap, even if\n",
        "87": "   * {@code map} and the instances generated by {@code factory} are. Concurrent read operations will\n",
        "88": "   * work correctly. To allow concurrent update operations, wrap the multimap with a call to {@link\n",
        "89": "   * #synchronizedMultimap}.\n",
        "90": "   *\n",
        "91": "   * <p>Call this method only when the simpler methods {@link ArrayListMultimap#create()}, {@link\n",
        "92": "   * HashMultimap#create()}, {@link LinkedHashMultimap#create()}, {@link\n",
        "93": "   * LinkedListMultimap#create()}, {@link TreeMultimap#create()}, and {@link\n",
        "94": "   * TreeMultimap#create(Comparator, Comparator)} won't suffice.\n",
        "95": "   *\n",
        "96": "   * <p>Note: the multimap assumes complete ownership over of {@code map} and the collections\n",
        "97": "   * returned by {@code factory}. Those objects should not be manually updated and they should not\n",
        "98": "   * use soft, weak, or phantom references.\n",
        "99": "   *\n",
        "100": "   * @param map place to store the mapping from each key to its corresponding values\n",
        "101": "   * @param factory supplier of new, empty collections that will each hold all values for a given\n",
        "102": "   *     key\n",
        "148": "   * Creates a new {@code ListMultimap} that uses the provided map and factory. It can generate a\n",
        "149": "   * multimap based on arbitrary {@link Map} and {@link List} classes.\n",
        "150": "   *\n",
        "151": "   * <p>The {@code factory}-generated and {@code map} classes determine the multimap iteration\n",
        "152": "   * order. They also specify the behavior of the {@code equals}, {@code hashCode}, and {@code\n",
        "153": "   * toString} methods for the multimap and its returned views. The multimap's {@code get}, {@code\n",
        "154": "   * removeAll}, and {@code replaceValues} methods return {@code RandomAccess} lists if the factory\n",
        "155": "   * does. However, the multimap's {@code get} method returns instances of a different class than\n",
        "156": "   * does {@code factory.get()}.\n",
        "157": "   *\n",
        "158": "   * <p>The multimap is serializable if {@code map}, {@code factory}, the lists generated by {@code\n",
        "159": "   * factory}, and the multimap contents are all serializable.\n",
        "160": "   *\n",
        "161": "   * <p>The multimap is not threadsafe when any concurrent operations update the multimap, even if\n",
        "162": "   * {@code map} and the instances generated by {@code factory} are. Concurrent read operations will\n",
        "163": "   * work correctly. To allow concurrent update operations, wrap the multimap with a call to {@link\n",
        "164": "   * #synchronizedListMultimap}.\n",
        "165": "   *\n",
        "166": "   * <p>Call this method only when the simpler methods {@link ArrayListMultimap#create()} and {@link\n",
        "167": "   * LinkedListMultimap#create()} won't suffice.\n",
        "168": "   *\n",
        "169": "   * <p>Note: the multimap assumes complete ownership over of {@code map} and the lists returned by\n",
        "170": "   * {@code factory}. Those objects should not be manually updated, they should be empty when\n",
        "171": "   * provided, and they should not use soft, weak, or phantom references.\n",
        "173": "   * @param map place to store the mapping from each key to its corresponding values\n",
        "174": "   * @param factory supplier of new, empty lists that will each hold all values for a given key\n",
        "217": "   * Creates a new {@code SetMultimap} that uses the provided map and factory. It can generate a\n",
        "218": "   * multimap based on arbitrary {@link Map} and {@link Set} classes.\n",
        "219": "   *\n",
        "220": "   * <p>The {@code factory}-generated and {@code map} classes determine the multimap iteration\n",
        "221": "   * order. They also specify the behavior of the {@code equals}, {@code hashCode}, and {@code\n",
        "222": "   * toString} methods for the multimap and its returned views. However, the multimap's {@code get}\n",
        "223": "   * method returns instances of a different class than {@code factory.get()} does.\n",
        "224": "   *\n",
        "225": "   * <p>The multimap is serializable if {@code map}, {@code factory}, the sets generated by {@code\n",
        "226": "   * factory}, and the multimap contents are all serializable.\n",
        "227": "   *\n",
        "228": "   * <p>The multimap is not threadsafe when any concurrent operations update the multimap, even if\n",
        "229": "   * {@code map} and the instances generated by {@code factory} are. Concurrent read operations will\n",
        "230": "   * work correctly. To allow concurrent update operations, wrap the multimap with a call to {@link\n",
        "231": "   * #synchronizedSetMultimap}.\n",
        "232": "   *\n",
        "233": "   * <p>Call this method only when the simpler methods {@link HashMultimap#create()}, {@link\n",
        "234": "   * LinkedHashMultimap#create()}, {@link TreeMultimap#create()}, and {@link\n",
        "235": "   * TreeMultimap#create(Comparator, Comparator)} won't suffice.\n",
        "236": "   *\n",
        "237": "   * <p>Note: the multimap assumes complete ownership over of {@code map} and the sets returned by\n",
        "238": "   * {@code factory}. Those objects should not be manually updated and they should not use soft,\n",
        "239": "   * weak, or phantom references.\n",
        "240": "   *\n",
        "241": "   * @param map place to store the mapping from each key to its corresponding values\n",
        "242": "   * @param factory supplier of new, empty sets that will each hold all values for a given key\n",
        "285": "   * Creates a new {@code SortedSetMultimap} that uses the provided map and factory. It can generate\n",
        "286": "   * a multimap based on arbitrary {@link Map} and {@link SortedSet} classes.\n",
        "287": "   *\n",
        "288": "   * <p>The {@code factory}-generated and {@code map} classes determine the multimap iteration\n",
        "289": "   * order. They also specify the behavior of the {@code equals}, {@code hashCode}, and {@code\n",
        "290": "   * toString} methods for the multimap and its returned views. However, the multimap's {@code get}\n",
        "291": "   * method returns instances of a different class than {@code factory.get()} does.\n",
        "292": "   *\n",
        "293": "   * <p>The multimap is serializable if {@code map}, {@code factory}, the sets generated by {@code\n",
        "294": "   * factory}, and the multimap contents are all serializable.\n",
        "295": "   *\n",
        "296": "   * <p>The multimap is not threadsafe when any concurrent operations update the multimap, even if\n",
        "297": "   * {@code map} and the instances generated by {@code factory} are. Concurrent read operations will\n",
        "298": "   * work correctly. To allow concurrent update operations, wrap the multimap with a call to {@link\n",
        "299": "   * #synchronizedSortedSetMultimap}.\n",
        "300": "   *\n",
        "301": "   * <p>Call this method only when the simpler methods {@link TreeMultimap#create()} and {@link\n",
        "302": "   * TreeMultimap#create(Comparator, Comparator)} won't suffice.\n",
        "303": "   *\n",
        "304": "   * <p>Note: the multimap assumes complete ownership over of {@code map} and the sets returned by\n",
        "305": "   * {@code factory}. Those objects should not be manually updated and they should not use soft,\n",
        "306": "   * weak, or phantom references.\n",
        "307": "   *\n",
        "308": "   * @param map place to store the mapping from each key to its corresponding values\n",
        "309": "   * @param factory supplier of new, empty sorted sets that will each hold all values for a given\n",
        "310": "   *     key\n",
        "361": "   * Copies each key-value mapping in {@code source} into {@code dest}, with its key and value\n",
        "362": "   * reversed.\n",
        "364": "   * <p>If {@code source} is an {@link ImmutableMultimap}, consider using {@link\n",
        "365": "   * ImmutableMultimap#inverse} instead.\n",
        "382": "   * Returns a synchronized (thread-safe) multimap backed by the specified multimap. In order to\n",
        "383": "   * guarantee serial access, it is critical that <b>all</b> access to the backing multimap is\n",
        "384": "   * accomplished through the returned multimap.\n",
        "385": "   *\n",
        "386": "   * <p>It is imperative that the user manually synchronize on the returned multimap when accessing\n",
        "387": "   * any of its collection views:\n",
        "388": "   *\n",
        "389": "   * <pre>{@code\n",
        "390": "   * Multimap<K, V> multimap = Multimaps.synchronizedMultimap(\n",
        "391": "   *     HashMultimap.<K, V>create());\n",
        "392": "   * ...\n",
        "393": "   * Collection<V> values = multimap.get(key);  // Needn't be in synchronized block\n",
        "394": "   * ...\n",
        "395": "   * synchronized (multimap) {  // Synchronizing on multimap, not values!\n",
        "396": "   *   Iterator<V> i = values.iterator(); // Must be in synchronized block\n",
        "397": "   *   while (i.hasNext()) {\n",
        "398": "   *     foo(i.next());\n",
        "399": "   *   }\n",
        "400": "   * }\n",
        "401": "   * }</pre>\n",
        "405": "   * <p>Note that the generated multimap's {@link Multimap#removeAll} and {@link\n",
        "406": "   * Multimap#replaceValues} methods return collections that aren't synchronized.\n",
        "408": "   * <p>The returned multimap will be serializable if the specified multimap is serializable.\n",
        "418": "   * Returns an unmodifiable view of the specified multimap. Query operations on the returned\n",
        "419": "   * multimap \"read through\" to the specified multimap, and attempts to modify the returned\n",
        "420": "   * multimap, either directly or through the multimap's views, result in an {@code\n",
        "421": "   * UnsupportedOperationException}.\n",
        "423": "   * <p>Note that the generated multimap's {@link Multimap#removeAll} and {@link\n",
        "424": "   * Multimap#replaceValues} methods return collections that are modifiable.\n",
        "426": "   * <p>The returned multimap will be serializable if the specified multimap is serializable.\n",
        "428": "   * @param delegate the multimap for which an unmodifiable view is to be returned\n",
        "667": "   * Returns a synchronized (thread-safe) {@code SetMultimap} backed by the specified multimap.\n",
        "671": "   * <p>The returned multimap will be serializable if the specified multimap is serializable.\n",
        "681": "   * Returns an unmodifiable view of the specified {@code SetMultimap}. Query operations on the\n",
        "682": "   * returned multimap \"read through\" to the specified multimap, and attempts to modify the returned\n",
        "683": "   * multimap, either directly or through the multimap's views, result in an {@code\n",
        "684": "   * UnsupportedOperationException}.\n",
        "686": "   * <p>Note that the generated multimap's {@link Multimap#removeAll} and {@link\n",
        "687": "   * Multimap#replaceValues} methods return collections that are modifiable.\n",
        "689": "   * <p>The returned multimap will be serializable if the specified multimap is serializable.\n",
        "691": "   * @param delegate the multimap for which an unmodifiable view is to be returned\n",
        "714": "   * Returns a synchronized (thread-safe) {@code SortedSetMultimap} backed by the specified\n",
        "715": "   * multimap.\n",
        "719": "   * <p>The returned multimap will be serializable if the specified multimap is serializable.\n",
        "730": "   * Returns an unmodifiable view of the specified {@code SortedSetMultimap}. Query operations on\n",
        "731": "   * the returned multimap \"read through\" to the specified multimap, and attempts to modify the\n",
        "732": "   * returned multimap, either directly or through the multimap's views, result in an {@code\n",
        "733": "   * UnsupportedOperationException}.\n",
        "735": "   * <p>Note that the generated multimap's {@link Multimap#removeAll} and {@link\n",
        "736": "   * Multimap#replaceValues} methods return collections that are modifiable.\n",
        "738": "   * <p>The returned multimap will be serializable if the specified multimap is serializable.\n",
        "740": "   * @param delegate the multimap for which an unmodifiable view is to be returned\n",
        "752": "   * Returns a synchronized (thread-safe) {@code ListMultimap} backed by the specified multimap.\n",
        "764": "   * Returns an unmodifiable view of the specified {@code ListMultimap}. Query operations on the\n",
        "765": "   * returned multimap \"read through\" to the specified multimap, and attempts to modify the returned\n",
        "766": "   * multimap, either directly or through the multimap's views, result in an {@code\n",
        "767": "   * UnsupportedOperationException}.\n",
        "769": "   * <p>Note that the generated multimap's {@link Multimap#removeAll} and {@link\n",
        "770": "   * Multimap#replaceValues} methods return collections that are modifiable.\n",
        "772": "   * <p>The returned multimap will be serializable if the specified multimap is serializable.\n",
        "774": "   * @param delegate the multimap for which an unmodifiable view is to be returned\n",
        "797": "   * Returns an unmodifiable view of the specified collection, preserving the interface for\n",
        "798": "   * instances of {@code SortedSet}, {@code Set}, {@code List} and {@code Collection}, in that order\n",
        "799": "   * of preference.\n",
        "816": "   * Returns an unmodifiable view of the specified collection of entries. The {@link Entry#setValue}\n",
        "817": "   * operation throws an {@link UnsupportedOperationException}. If the specified collection is a\n",
        "818": "   * {@code Set}, the returned collection is also a {@code Set}.\n",
        "832": "   * Returns {@link ListMultimap#asMap multimap.asMap()}, with its type corrected from {@code Map<K,\n",
        "833": "   * Collection<V>>} to {@code Map<K, List<V>>}.\n",
        "845": "   * Returns {@link SetMultimap#asMap multimap.asMap()}, with its type corrected from {@code Map<K,\n",
        "846": "   * Collection<V>>} to {@code Map<K, Set<V>>}.\n",
        "858": "   * Returns {@link SortedSetMultimap#asMap multimap.asMap()}, with its type corrected from {@code\n",
        "859": "   * Map<K, Collection<V>>} to {@code Map<K, SortedSet<V>>}.\n",
        "871": "   * Returns {@link Multimap#asMap multimap.asMap()}. This is provided for parity with the other\n",
        "872": "   * more strongly-typed {@code asMap()} implementations.\n",
        "882": "   * Returns a multimap view of the specified map. The multimap is backed by the map, so changes to\n",
        "883": "   * the map are reflected in the multimap, and vice versa. If the map is modified while an\n",
        "884": "   * iteration over one of the multimap's collection views is in progress (except through the\n",
        "885": "   * iterator's own {@code remove} operation, or through the {@code setValue} operation on a map\n",
        "886": "   * entry returned by the iterator), the results of the iteration are undefined.\n",
        "888": "   * <p>The multimap supports mapping removal, which removes the corresponding mapping from the map.\n",
        "889": "   * It does not support any operations which might add mappings, such as {@code put}, {@code\n",
        "890": "   * putAll} or {@code replaceValues}.\n",
        "892": "   * <p>The returned multimap will be serializable if the specified map is serializable.\n",
        "1041": "   * Returns a view of a multimap where each value is transformed by a function. All other\n",
        "1042": "   * properties of the multimap, such as iteration order, are left intact. For example, the code:\n",
        "1044": "   * <pre>{@code\n",
        "1054": "   *   System.out.println(transformed);\n",
        "1055": "   * }</pre>\n",
        "1059": "   * <p>Changes in the underlying multimap are reflected in this view. Conversely, this view\n",
        "1060": "   * supports removal operations, and these are reflected in the underlying multimap.\n",
        "1061": "   *\n",
        "1062": "   * <p>It's acceptable for the underlying multimap to contain null keys, and even null values\n",
        "1063": "   * provided that the function is capable of accepting null input. The transformed multimap might\n",
        "1064": "   * contain null values, if the function sometimes gives a null result.\n",
        "1065": "   *\n",
        "1066": "   * <p>The returned multimap is not thread-safe or serializable, even if the underlying multimap\n",
        "1067": "   * is. The {@code equals} and {@code hashCode} methods of the returned multimap are meaningless,\n",
        "1068": "   * since there is not a definition of {@code equals} or {@code hashCode} for general collections,\n",
        "1069": "   * and {@code get()} will return a general {@code Collection} as opposed to a {@code List} or a\n",
        "1070": "   * {@code Set}.\n",
        "1071": "   *\n",
        "1072": "   * <p>The function is applied lazily, invoked when needed. This is necessary for the returned\n",
        "1073": "   * multimap to be a view, but it means that the function will be applied many times for bulk\n",
        "1074": "   * operations like {@link Multimap#containsValue} and {@code Multimap.toString()}. For this to\n",
        "1075": "   * perform well, {@code function} should be fast. To avoid lazy evaluation when the returned\n",
        "1076": "   * multimap doesn't need to be a view, copy the returned multimap into a new multimap of your\n",
        "1077": "   * choosing.\n",
        "1089": "   * Returns a view of a multimap whose values are derived from the original multimap's entries. In\n",
        "1090": "   * contrast to {@link #transformValues}, this method's entry-transformation logic may depend on\n",
        "1091": "   * the key as well as the value.\n",
        "1092": "   *\n",
        "1093": "   * <p>All other properties of the transformed multimap, such as iteration order, are left intact.\n",
        "1094": "   * For example, the code:\n",
        "1095": "   *\n",
        "1096": "   * <pre>{@code\n",
        "1097": "   * SetMultimap<String, Integer> multimap =\n",
        "1098": "   *     ImmutableSetMultimap.of(\"a\", 1, \"a\", 4, \"b\", -6);\n",
        "1099": "   * EntryTransformer<String, Integer, String> transformer =\n",
        "1100": "   *     new EntryTransformer<String, Integer, String>() {\n",
        "1101": "   *       public String transformEntry(String key, Integer value) {\n",
        "1102": "   *          return (value >= 0) ? key : \"no\" + key;\n",
        "1103": "   *       }\n",
        "1104": "   *     };\n",
        "1105": "   * Multimap<String, String> transformed =\n",
        "1106": "   *     Multimaps.transformEntries(multimap, transformer);\n",
        "1107": "   * System.out.println(transformed);\n",
        "1108": "   * }</pre>\n",
        "1112": "   * <p>Changes in the underlying multimap are reflected in this view. Conversely, this view\n",
        "1113": "   * supports removal operations, and these are reflected in the underlying multimap.\n",
        "1114": "   *\n",
        "1115": "   * <p>It's acceptable for the underlying multimap to contain null keys and null values provided\n",
        "1116": "   * that the transformer is capable of accepting null inputs. The transformed multimap might\n",
        "1117": "   * contain null values if the transformer sometimes gives a null result.\n",
        "1118": "   *\n",
        "1119": "   * <p>The returned multimap is not thread-safe or serializable, even if the underlying multimap\n",
        "1120": "   * is. The {@code equals} and {@code hashCode} methods of the returned multimap are meaningless,\n",
        "1121": "   * since there is not a definition of {@code equals} or {@code hashCode} for general collections,\n",
        "1122": "   * and {@code get()} will return a general {@code Collection} as opposed to a {@code List} or a\n",
        "1123": "   * {@code Set}.\n",
        "1124": "   *\n",
        "1125": "   * <p>The transformer is applied lazily, invoked when needed. This is necessary for the returned\n",
        "1126": "   * multimap to be a view, but it means that the transformer will be applied many times for bulk\n",
        "1127": "   * operations like {@link Multimap#containsValue} and {@link Object#toString}. For this to perform\n",
        "1128": "   * well, {@code transformer} should be fast. To avoid lazy evaluation when the returned multimap\n",
        "1129": "   * doesn't need to be a view, copy the returned multimap into a new multimap of your choosing.\n",
        "1130": "   *\n",
        "1131": "   * <p><b>Warning:</b> This method assumes that for any instance {@code k} of {@code\n",
        "1132": "   * EntryTransformer} key type {@code K}, {@code k.equals(k2)} implies that {@code k2} is also of\n",
        "1133": "   * type {@code K}. Using an {@code EntryTransformer} key type for which this may not hold, such as\n",
        "1134": "   * {@code ArrayList}, may risk a {@code ClassCastException} when calling methods on the\n",
        "1135": "   * transformed multimap.\n",
        "1257": "   * Returns a view of a {@code ListMultimap} where each value is transformed by a function. All\n",
        "1258": "   * other properties of the multimap, such as iteration order, are left intact. For example, the\n",
        "1259": "   * code:\n",
        "1260": "   *\n",
        "1261": "   * <pre>{@code\n",
        "1262": "   * ListMultimap<String, Integer> multimap\n",
        "1263": "   *      = ImmutableListMultimap.of(\"a\", 4, \"a\", 16, \"b\", 9);\n",
        "1264": "   * Function<Integer, Double> sqrt =\n",
        "1265": "   *     new Function<Integer, Double>() {\n",
        "1266": "   *       public Double apply(Integer in) {\n",
        "1267": "   *         return Math.sqrt((int) in);\n",
        "1268": "   *       }\n",
        "1269": "   *     };\n",
        "1270": "   * ListMultimap<String, Double> transformed = Multimaps.transformValues(map,\n",
        "1271": "   *     sqrt);\n",
        "1272": "   * System.out.println(transformed);\n",
        "1273": "   * }</pre>\n",
        "1277": "   * <p>Changes in the underlying multimap are reflected in this view. Conversely, this view\n",
        "1278": "   * supports removal operations, and these are reflected in the underlying multimap.\n",
        "1280": "   * <p>It's acceptable for the underlying multimap to contain null keys, and even null values\n",
        "1281": "   * provided that the function is capable of accepting null input. The transformed multimap might\n",
        "1282": "   * contain null values, if the function sometimes gives a null result.\n",
        "1284": "   * <p>The returned multimap is not thread-safe or serializable, even if the underlying multimap\n",
        "1285": "   * is.\n",
        "1287": "   * <p>The function is applied lazily, invoked when needed. This is necessary for the returned\n",
        "1288": "   * multimap to be a view, but it means that the function will be applied many times for bulk\n",
        "1289": "   * operations like {@link Multimap#containsValue} and {@code Multimap.toString()}. For this to\n",
        "1290": "   * perform well, {@code function} should be fast. To avoid lazy evaluation when the returned\n",
        "1291": "   * multimap doesn't need to be a view, copy the returned multimap into a new multimap of your\n",
        "1292": "   * choosing.\n",
        "1304": "   * Returns a view of a {@code ListMultimap} whose values are derived from the original multimap's\n",
        "1305": "   * entries. In contrast to {@link #transformValues(ListMultimap, Function)}, this method's\n",
        "1308": "   * <p>All other properties of the transformed multimap, such as iteration order, are left intact.\n",
        "1309": "   * For example, the code:\n",
        "1310": "   *\n",
        "1311": "   * <pre>{@code\n",
        "1312": "   * Multimap<String, Integer> multimap =\n",
        "1313": "   *     ImmutableMultimap.of(\"a\", 1, \"a\", 4, \"b\", 6);\n",
        "1314": "   * EntryTransformer<String, Integer, String> transformer =\n",
        "1315": "   *     new EntryTransformer<String, Integer, String>() {\n",
        "1316": "   *       public String transformEntry(String key, Integer value) {\n",
        "1317": "   *         return key + value;\n",
        "1318": "   *       }\n",
        "1319": "   *     };\n",
        "1320": "   * Multimap<String, String> transformed =\n",
        "1321": "   *     Multimaps.transformEntries(multimap, transformer);\n",
        "1322": "   * System.out.println(transformed);\n",
        "1323": "   * }</pre>\n",
        "1327": "   * <p>Changes in the underlying multimap are reflected in this view. Conversely, this view\n",
        "1328": "   * supports removal operations, and these are reflected in the underlying multimap.\n",
        "1329": "   *\n",
        "1330": "   * <p>It's acceptable for the underlying multimap to contain null keys and null values provided\n",
        "1331": "   * that the transformer is capable of accepting null inputs. The transformed multimap might\n",
        "1332": "   * contain null values if the transformer sometimes gives a null result.\n",
        "1333": "   *\n",
        "1334": "   * <p>The returned multimap is not thread-safe or serializable, even if the underlying multimap\n",
        "1335": "   * is.\n",
        "1336": "   *\n",
        "1337": "   * <p>The transformer is applied lazily, invoked when needed. This is necessary for the returned\n",
        "1338": "   * multimap to be a view, but it means that the transformer will be applied many times for bulk\n",
        "1339": "   * operations like {@link Multimap#containsValue} and {@link Object#toString}. For this to perform\n",
        "1340": "   * well, {@code transformer} should be fast. To avoid lazy evaluation when the returned multimap\n",
        "1341": "   * doesn't need to be a view, copy the returned multimap into a new multimap of your choosing.\n",
        "1342": "   *\n",
        "1343": "   * <p><b>Warning:</b> This method assumes that for any instance {@code k} of {@code\n",
        "1344": "   * EntryTransformer} key type {@code K}, {@code k.equals(k2)} implies that {@code k2} is also of\n",
        "1345": "   * type {@code K}. Using an {@code EntryTransformer} key type for which this may not hold, such as\n",
        "1346": "   * {@code ArrayList}, may risk a {@code ClassCastException} when calling methods on the\n",
        "1347": "   * transformed multimap.\n",
        "1387": "   * Creates an index {@code ImmutableListMultimap} that contains the results of applying a\n",
        "1388": "   * specified function to each item in an {@code Iterable} of values. Each value will be stored as\n",
        "1389": "   * a value in the resulting multimap, yielding a multimap with the same size as the input\n",
        "1390": "   * iterable. The key used to store that value in the multimap will be the result of calling the\n",
        "1391": "   * function on that value. The resulting multimap is created as an immutable snapshot. In the\n",
        "1392": "   * returned multimap, keys appear in the order they are first encountered, and the values\n",
        "1393": "   * corresponding to each key appear in the same order as they are encountered.\n",
        "1394": "   *\n",
        "1395": "   * <p>For example,\n",
        "1396": "   *\n",
        "1397": "   * <pre>{@code\n",
        "1398": "   * List<String> badGuys =\n",
        "1399": "   *     Arrays.asList(\"Inky\", \"Blinky\", \"Pinky\", \"Pinky\", \"Clyde\");\n",
        "1400": "   * Function<String, Integer> stringLengthFunction = ...;\n",
        "1401": "   * Multimap<Integer, String> index =\n",
        "1402": "   *     Multimaps.index(badGuys, stringLengthFunction);\n",
        "1403": "   * System.out.println(index);\n",
        "1404": "   * }</pre>\n",
        "1405": "   *\n",
        "1406": "   * <p>prints\n",
        "1407": "   *\n",
        "1408": "   * <pre>{@code\n",
        "1409": "   * {4=[Inky], 6=[Blinky], 5=[Pinky, Pinky, Clyde]}\n",
        "1410": "   * }</pre>\n",
        "1411": "   *\n",
        "1412": "   * <p>The returned multimap is serializable if its keys and values are all serializable.\n",
        "1413": "   *\n",
        "1414": "   * @param values the values to use when constructing the {@code ImmutableListMultimap}\n",
        "1416": "   * @return {@code ImmutableListMultimap} mapping the result of evaluating the function {@code\n",
        "1417": "   *     keyFunction} on each value in the input collection to that value\n",
        "1427": "   * Creates an index {@code ImmutableListMultimap} that contains the results of applying a\n",
        "1428": "   * specified function to each item in an {@code Iterator} of values. Each value will be stored as\n",
        "1429": "   * a value in the resulting multimap, yielding a multimap with the same size as the input\n",
        "1430": "   * iterator. The key used to store that value in the multimap will be the result of calling the\n",
        "1431": "   * function on that value. The resulting multimap is created as an immutable snapshot. In the\n",
        "1432": "   * returned multimap, keys appear in the order they are first encountered, and the values\n",
        "1433": "   * corresponding to each key appear in the same order as they are encountered.\n",
        "1434": "   *\n",
        "1435": "   * <p>For example,\n",
        "1436": "   *\n",
        "1437": "   * <pre>{@code\n",
        "1438": "   * List<String> badGuys =\n",
        "1439": "   *     Arrays.asList(\"Inky\", \"Blinky\", \"Pinky\", \"Pinky\", \"Clyde\");\n",
        "1440": "   * Function<String, Integer> stringLengthFunction = ...;\n",
        "1441": "   * Multimap<Integer, String> index =\n",
        "1442": "   *     Multimaps.index(badGuys.iterator(), stringLengthFunction);\n",
        "1443": "   * System.out.println(index);\n",
        "1444": "   * }</pre>\n",
        "1445": "   *\n",
        "1446": "   * <p>prints\n",
        "1447": "   *\n",
        "1448": "   * <pre>{@code\n",
        "1449": "   * {4=[Inky], 6=[Blinky], 5=[Pinky, Pinky, Clyde]}\n",
        "1450": "   * }</pre>\n",
        "1451": "   *\n",
        "1452": "   * <p>The returned multimap is serializable if its keys and values are all serializable.\n",
        "1453": "   *\n",
        "1454": "   * @param values the values to use when constructing the {@code ImmutableListMultimap}\n",
        "1456": "   * @return {@code ImmutableListMultimap} mapping the result of evaluating the function {@code\n",
        "1457": "   *     keyFunction} on each value in the input collection to that value\n",
        "1611": "  /** A skeleton implementation of {@link Multimap#entries()}. */\n",
        "1644": "  /** A skeleton implementation of {@link Multimap#asMap()}. */\n",
        "1729": "   * Returns a multimap containing the mappings in {@code unfiltered} whose keys satisfy a\n",
        "1730": "   * predicate. The returned multimap is a live view of {@code unfiltered}; changes to one affect\n",
        "1731": "   * the other.\n",
        "1733": "   * <p>The resulting multimap's views have iterators that don't support {@code remove()}, but all\n",
        "1734": "   * other methods are supported by the multimap and its views. When adding a key that doesn't\n",
        "1735": "   * satisfy the predicate, the multimap's {@code put()}, {@code putAll()}, and {@code\n",
        "1736": "   * replaceValues()} methods throw an {@link IllegalArgumentException}.\n",
        "1738": "   * <p>When methods such as {@code removeAll()} and {@code clear()} are called on the filtered\n",
        "1739": "   * multimap or its views, only mappings whose keys satisfy the filter will be removed from the\n",
        "1740": "   * underlying multimap.\n",
        "1742": "   * <p>The returned multimap isn't threadsafe or serializable, even if {@code unfiltered} is.\n",
        "1744": "   * <p>Many of the filtered multimap's methods, such as {@code size()}, iterate across every\n",
        "1745": "   * key/value mapping in the underlying multimap and determine which satisfy the filter. When a\n",
        "1746": "   * live view is <i>not</i> needed, it may be faster to copy the filtered multimap and use the\n",
        "1747": "   * copy.\n",
        "1749": "   * <p><b>Warning:</b> {@code keyPredicate} must be <i>consistent with equals</i>, as documented at\n",
        "1750": "   * {@link Predicate#apply}. Do not provide a predicate such as {@code\n",
        "1751": "   * Predicates.instanceOf(ArrayList.class)}, which is inconsistent with equals.\n",
        "1774": "   * Returns a multimap containing the mappings in {@code unfiltered} whose keys satisfy a\n",
        "1775": "   * predicate. The returned multimap is a live view of {@code unfiltered}; changes to one affect\n",
        "1776": "   * the other.\n",
        "1778": "   * <p>The resulting multimap's views have iterators that don't support {@code remove()}, but all\n",
        "1779": "   * other methods are supported by the multimap and its views. When adding a key that doesn't\n",
        "1780": "   * satisfy the predicate, the multimap's {@code put()}, {@code putAll()}, and {@code\n",
        "1781": "   * replaceValues()} methods throw an {@link IllegalArgumentException}.\n",
        "1783": "   * <p>When methods such as {@code removeAll()} and {@code clear()} are called on the filtered\n",
        "1784": "   * multimap or its views, only mappings whose keys satisfy the filter will be removed from the\n",
        "1785": "   * underlying multimap.\n",
        "1787": "   * <p>The returned multimap isn't threadsafe or serializable, even if {@code unfiltered} is.\n",
        "1789": "   * <p>Many of the filtered multimap's methods, such as {@code size()}, iterate across every\n",
        "1790": "   * key/value mapping in the underlying multimap and determine which satisfy the filter. When a\n",
        "1791": "   * live view is <i>not</i> needed, it may be faster to copy the filtered multimap and use the\n",
        "1792": "   * copy.\n",
        "1794": "   * <p><b>Warning:</b> {@code keyPredicate} must be <i>consistent with equals</i>, as documented at\n",
        "1795": "   * {@link Predicate#apply}. Do not provide a predicate such as {@code\n",
        "1796": "   * Predicates.instanceOf(ArrayList.class)}, which is inconsistent with equals.\n",
        "1815": "   * Returns a multimap containing the mappings in {@code unfiltered} whose keys satisfy a\n",
        "1816": "   * predicate. The returned multimap is a live view of {@code unfiltered}; changes to one affect\n",
        "1817": "   * the other.\n",
        "1819": "   * <p>The resulting multimap's views have iterators that don't support {@code remove()}, but all\n",
        "1820": "   * other methods are supported by the multimap and its views. When adding a key that doesn't\n",
        "1821": "   * satisfy the predicate, the multimap's {@code put()}, {@code putAll()}, and {@code\n",
        "1822": "   * replaceValues()} methods throw an {@link IllegalArgumentException}.\n",
        "1824": "   * <p>When methods such as {@code removeAll()} and {@code clear()} are called on the filtered\n",
        "1825": "   * multimap or its views, only mappings whose keys satisfy the filter will be removed from the\n",
        "1826": "   * underlying multimap.\n",
        "1828": "   * <p>The returned multimap isn't threadsafe or serializable, even if {@code unfiltered} is.\n",
        "1830": "   * <p>Many of the filtered multimap's methods, such as {@code size()}, iterate across every\n",
        "1831": "   * key/value mapping in the underlying multimap and determine which satisfy the filter. When a\n",
        "1832": "   * live view is <i>not</i> needed, it may be faster to copy the filtered multimap and use the\n",
        "1833": "   * copy.\n",
        "1835": "   * <p><b>Warning:</b> {@code keyPredicate} must be <i>consistent with equals</i>, as documented at\n",
        "1836": "   * {@link Predicate#apply}. Do not provide a predicate such as {@code\n",
        "1837": "   * Predicates.instanceOf(ArrayList.class)}, which is inconsistent with equals.\n",
        "1853": "   * Returns a multimap containing the mappings in {@code unfiltered} whose values satisfy a\n",
        "1854": "   * predicate. The returned multimap is a live view of {@code unfiltered}; changes to one affect\n",
        "1855": "   * the other.\n",
        "1857": "   * <p>The resulting multimap's views have iterators that don't support {@code remove()}, but all\n",
        "1858": "   * other methods are supported by the multimap and its views. When adding a value that doesn't\n",
        "1859": "   * satisfy the predicate, the multimap's {@code put()}, {@code putAll()}, and {@code\n",
        "1860": "   * replaceValues()} methods throw an {@link IllegalArgumentException}.\n",
        "1862": "   * <p>When methods such as {@code removeAll()} and {@code clear()} are called on the filtered\n",
        "1863": "   * multimap or its views, only mappings whose value satisfy the filter will be removed from the\n",
        "1864": "   * underlying multimap.\n",
        "1866": "   * <p>The returned multimap isn't threadsafe or serializable, even if {@code unfiltered} is.\n",
        "1868": "   * <p>Many of the filtered multimap's methods, such as {@code size()}, iterate across every\n",
        "1869": "   * key/value mapping in the underlying multimap and determine which satisfy the filter. When a\n",
        "1870": "   * live view is <i>not</i> needed, it may be faster to copy the filtered multimap and use the\n",
        "1871": "   * copy.\n",
        "1873": "   * <p><b>Warning:</b> {@code valuePredicate} must be <i>consistent with equals</i>, as documented\n",
        "1874": "   * at {@link Predicate#apply}. Do not provide a predicate such as {@code\n",
        "1875": "   * Predicates.instanceOf(ArrayList.class)}, which is inconsistent with equals.\n",
        "1885": "   * Returns a multimap containing the mappings in {@code unfiltered} whose values satisfy a\n",
        "1886": "   * predicate. The returned multimap is a live view of {@code unfiltered}; changes to one affect\n",
        "1887": "   * the other.\n",
        "1889": "   * <p>The resulting multimap's views have iterators that don't support {@code remove()}, but all\n",
        "1890": "   * other methods are supported by the multimap and its views. When adding a value that doesn't\n",
        "1891": "   * satisfy the predicate, the multimap's {@code put()}, {@code putAll()}, and {@code\n",
        "1892": "   * replaceValues()} methods throw an {@link IllegalArgumentException}.\n",
        "1894": "   * <p>When methods such as {@code removeAll()} and {@code clear()} are called on the filtered\n",
        "1895": "   * multimap or its views, only mappings whose value satisfy the filter will be removed from the\n",
        "1896": "   * underlying multimap.\n",
        "1898": "   * <p>The returned multimap isn't threadsafe or serializable, even if {@code unfiltered} is.\n",
        "1900": "   * <p>Many of the filtered multimap's methods, such as {@code size()}, iterate across every\n",
        "1901": "   * key/value mapping in the underlying multimap and determine which satisfy the filter. When a\n",
        "1902": "   * live view is <i>not</i> needed, it may be faster to copy the filtered multimap and use the\n",
        "1903": "   * copy.\n",
        "1905": "   * <p><b>Warning:</b> {@code valuePredicate} must be <i>consistent with equals</i>, as documented\n",
        "1906": "   * at {@link Predicate#apply}. Do not provide a predicate such as {@code\n",
        "1907": "   * Predicates.instanceOf(ArrayList.class)}, which is inconsistent with equals.\n",
        "1917": "   * Returns a multimap containing the mappings in {@code unfiltered} that satisfy a predicate. The\n",
        "1918": "   * returned multimap is a live view of {@code unfiltered}; changes to one affect the other.\n",
        "1920": "   * <p>The resulting multimap's views have iterators that don't support {@code remove()}, but all\n",
        "1921": "   * other methods are supported by the multimap and its views. When adding a key/value pair that\n",
        "1922": "   * doesn't satisfy the predicate, multimap's {@code put()}, {@code putAll()}, and {@code\n",
        "1923": "   * replaceValues()} methods throw an {@link IllegalArgumentException}.\n",
        "1925": "   * <p>When methods such as {@code removeAll()} and {@code clear()} are called on the filtered\n",
        "1926": "   * multimap or its views, only mappings whose keys satisfy the filter will be removed from the\n",
        "1927": "   * underlying multimap.\n",
        "1929": "   * <p>The returned multimap isn't threadsafe or serializable, even if {@code unfiltered} is.\n",
        "1931": "   * <p>Many of the filtered multimap's methods, such as {@code size()}, iterate across every\n",
        "1932": "   * key/value mapping in the underlying multimap and determine which satisfy the filter. When a\n",
        "1933": "   * live view is <i>not</i> needed, it may be faster to copy the filtered multimap and use the\n",
        "1934": "   * copy.\n",
        "1936": "   * <p><b>Warning:</b> {@code entryPredicate} must be <i>consistent with equals</i>, as documented\n",
        "1937": "   * at {@link Predicate#apply}.\n",
        "1953": "   * Returns a multimap containing the mappings in {@code unfiltered} that satisfy a predicate. The\n",
        "1954": "   * returned multimap is a live view of {@code unfiltered}; changes to one affect the other.\n",
        "1956": "   * <p>The resulting multimap's views have iterators that don't support {@code remove()}, but all\n",
        "1957": "   * other methods are supported by the multimap and its views. When adding a key/value pair that\n",
        "1958": "   * doesn't satisfy the predicate, multimap's {@code put()}, {@code putAll()}, and {@code\n",
        "1959": "   * replaceValues()} methods throw an {@link IllegalArgumentException}.\n",
        "1961": "   * <p>When methods such as {@code removeAll()} and {@code clear()} are called on the filtered\n",
        "1962": "   * multimap or its views, only mappings whose keys satisfy the filter will be removed from the\n",
        "1963": "   * underlying multimap.\n",
        "1965": "   * <p>The returned multimap isn't threadsafe or serializable, even if {@code unfiltered} is.\n",
        "1967": "   * <p>Many of the filtered multimap's methods, such as {@code size()}, iterate across every\n",
        "1968": "   * key/value mapping in the underlying multimap and determine which satisfy the filter. When a\n",
        "1969": "   * live view is <i>not</i> needed, it may be faster to copy the filtered multimap and use the\n",
        "1970": "   * copy.\n",
        "1972": "   * <p><b>Warning:</b> {@code entryPredicate} must be <i>consistent with equals</i>, as documented\n",
        "1973": "   * at {@link Predicate#apply}.\n",
        "1986": "   * Support removal operations when filtering a filtered multimap. Since a filtered multimap has\n",
        "1987": "   * iterators that don't support remove, passing one to the FilteredEntryMultimap constructor would\n",
        "1988": "   * lead to a multimap whose removal operations would fail. This method combines the predicates to\n",
        "1989": "   * avoid that problem.\n"
    },
    "removed": {
        "56": " * \"https://github.com/google/guava/wiki/CollectionUtilitiesExplained#multimaps\">\n",
        "57": " * {@code Multimaps}</a>.\n",
        "70": "   * Creates a new {@code Multimap} backed by {@code map}, whose internal value\n",
        "71": "   * collections are generated by {@code factory}.\n",
        "72": "   *\n",
        "73": "   * <b>Warning: do not use</b> this method when the collections returned by\n",
        "74": "   * {@code factory} implement either {@link List} or {@code Set}! Use the more\n",
        "75": "   * specific method {@link #newListMultimap}, {@link #newSetMultimap} or {@link\n",
        "76": "   * #newSortedSetMultimap} instead, to avoid very surprising behavior from\n",
        "77": "   * {@link Multimap#equals}.\n",
        "78": "   *\n",
        "79": "   * <p>The {@code factory}-generated and {@code map} classes determine the\n",
        "80": "   * multimap iteration order. They also specify the behavior of the\n",
        "81": "   * {@code equals}, {@code hashCode}, and {@code toString} methods for the\n",
        "82": "   * multimap and its returned views. However, the multimap's {@code get}\n",
        "83": "   * method returns instances of a different class than {@code factory.get()}\n",
        "84": "   * does.\n",
        "85": "   *\n",
        "86": "   * <p>The multimap is serializable if {@code map}, {@code factory}, the\n",
        "87": "   * collections generated by {@code factory}, and the multimap contents are all\n",
        "88": "   * serializable.\n",
        "89": "   *\n",
        "90": "   * <p>The multimap is not threadsafe when any concurrent operations update the\n",
        "91": "   * multimap, even if {@code map} and the instances generated by\n",
        "92": "   * {@code factory} are. Concurrent read operations will work correctly. To\n",
        "93": "   * allow concurrent update operations, wrap the multimap with a call to\n",
        "94": "   * {@link #synchronizedMultimap}.\n",
        "95": "   *\n",
        "96": "   * <p>Call this method only when the simpler methods\n",
        "97": "   * {@link ArrayListMultimap#create()}, {@link HashMultimap#create()},\n",
        "98": "   * {@link LinkedHashMultimap#create()}, {@link LinkedListMultimap#create()},\n",
        "99": "   * {@link TreeMultimap#create()}, and\n",
        "100": "   * {@link TreeMultimap#create(Comparator, Comparator)} won't suffice.\n",
        "101": "   *\n",
        "102": "   * <p>Note: the multimap assumes complete ownership over of {@code map} and\n",
        "103": "   * the collections returned by {@code factory}. Those objects should not be\n",
        "104": "   * manually updated and they should not use soft, weak, or phantom references.\n",
        "105": "   *\n",
        "106": "   * @param map place to store the mapping from each key to its corresponding\n",
        "107": "   *     values\n",
        "108": "   * @param factory supplier of new, empty collections that will each hold all\n",
        "109": "   *     values for a given key\n",
        "155": "   * Creates a new {@code ListMultimap} that uses the provided map and factory.\n",
        "156": "   * It can generate a multimap based on arbitrary {@link Map} and {@link List}\n",
        "157": "   * classes.\n",
        "158": "   *\n",
        "159": "   * <p>The {@code factory}-generated and {@code map} classes determine the\n",
        "160": "   * multimap iteration order. They also specify the behavior of the\n",
        "161": "   * {@code equals}, {@code hashCode}, and {@code toString} methods for the\n",
        "162": "   * multimap and its returned views. The multimap's {@code get}, {@code\n",
        "163": "   * removeAll}, and {@code replaceValues} methods return {@code RandomAccess}\n",
        "164": "   * lists if the factory does. However, the multimap's {@code get} method\n",
        "165": "   * returns instances of a different class than does {@code factory.get()}.\n",
        "166": "   *\n",
        "167": "   * <p>The multimap is serializable if {@code map}, {@code factory}, the\n",
        "168": "   * lists generated by {@code factory}, and the multimap contents are all\n",
        "169": "   * serializable.\n",
        "170": "   *\n",
        "171": "   * <p>The multimap is not threadsafe when any concurrent operations update the\n",
        "172": "   * multimap, even if {@code map} and the instances generated by\n",
        "173": "   * {@code factory} are. Concurrent read operations will work correctly. To\n",
        "174": "   * allow concurrent update operations, wrap the multimap with a call to\n",
        "175": "   * {@link #synchronizedListMultimap}.\n",
        "176": "   *\n",
        "177": "   * <p>Call this method only when the simpler methods\n",
        "178": "   * {@link ArrayListMultimap#create()} and {@link LinkedListMultimap#create()}\n",
        "179": "   * won't suffice.\n",
        "180": "   *\n",
        "181": "   * <p>Note: the multimap assumes complete ownership over of {@code map} and\n",
        "182": "   * the lists returned by {@code factory}. Those objects should not be manually\n",
        "183": "   * updated, they should be empty when provided, and they should not use soft,\n",
        "184": "   * weak, or phantom references.\n",
        "186": "   * @param map place to store the mapping from each key to its corresponding\n",
        "187": "   *     values\n",
        "188": "   * @param factory supplier of new, empty lists that will each hold all values\n",
        "189": "   *     for a given key\n",
        "232": "   * Creates a new {@code SetMultimap} that uses the provided map and factory.\n",
        "233": "   * It can generate a multimap based on arbitrary {@link Map} and {@link Set}\n",
        "234": "   * classes.\n",
        "235": "   *\n",
        "236": "   * <p>The {@code factory}-generated and {@code map} classes determine the\n",
        "237": "   * multimap iteration order. They also specify the behavior of the\n",
        "238": "   * {@code equals}, {@code hashCode}, and {@code toString} methods for the\n",
        "239": "   * multimap and its returned views. However, the multimap's {@code get}\n",
        "240": "   * method returns instances of a different class than {@code factory.get()}\n",
        "241": "   * does.\n",
        "242": "   *\n",
        "243": "   * <p>The multimap is serializable if {@code map}, {@code factory}, the\n",
        "244": "   * sets generated by {@code factory}, and the multimap contents are all\n",
        "245": "   * serializable.\n",
        "246": "   *\n",
        "247": "   * <p>The multimap is not threadsafe when any concurrent operations update the\n",
        "248": "   * multimap, even if {@code map} and the instances generated by\n",
        "249": "   * {@code factory} are. Concurrent read operations will work correctly. To\n",
        "250": "   * allow concurrent update operations, wrap the multimap with a call to\n",
        "251": "   * {@link #synchronizedSetMultimap}.\n",
        "252": "   *\n",
        "253": "   * <p>Call this method only when the simpler methods\n",
        "254": "   * {@link HashMultimap#create()}, {@link LinkedHashMultimap#create()},\n",
        "255": "   * {@link TreeMultimap#create()}, and\n",
        "256": "   * {@link TreeMultimap#create(Comparator, Comparator)} won't suffice.\n",
        "257": "   *\n",
        "258": "   * <p>Note: the multimap assumes complete ownership over of {@code map} and\n",
        "259": "   * the sets returned by {@code factory}. Those objects should not be manually\n",
        "260": "   * updated and they should not use soft, weak, or phantom references.\n",
        "261": "   *\n",
        "262": "   * @param map place to store the mapping from each key to its corresponding\n",
        "263": "   *     values\n",
        "264": "   * @param factory supplier of new, empty sets that will each hold all values\n",
        "265": "   *     for a given key\n",
        "308": "   * Creates a new {@code SortedSetMultimap} that uses the provided map and\n",
        "309": "   * factory. It can generate a multimap based on arbitrary {@link Map} and\n",
        "310": "   * {@link SortedSet} classes.\n",
        "311": "   *\n",
        "312": "   * <p>The {@code factory}-generated and {@code map} classes determine the\n",
        "313": "   * multimap iteration order. They also specify the behavior of the\n",
        "314": "   * {@code equals}, {@code hashCode}, and {@code toString} methods for the\n",
        "315": "   * multimap and its returned views. However, the multimap's {@code get}\n",
        "316": "   * method returns instances of a different class than {@code factory.get()}\n",
        "317": "   * does.\n",
        "318": "   *\n",
        "319": "   * <p>The multimap is serializable if {@code map}, {@code factory}, the\n",
        "320": "   * sets generated by {@code factory}, and the multimap contents are all\n",
        "321": "   * serializable.\n",
        "322": "   *\n",
        "323": "   * <p>The multimap is not threadsafe when any concurrent operations update the\n",
        "324": "   * multimap, even if {@code map} and the instances generated by\n",
        "325": "   * {@code factory} are. Concurrent read operations will work correctly. To\n",
        "326": "   * allow concurrent update operations, wrap the multimap with a call to\n",
        "327": "   * {@link #synchronizedSortedSetMultimap}.\n",
        "328": "   *\n",
        "329": "   * <p>Call this method only when the simpler methods\n",
        "330": "   * {@link TreeMultimap#create()} and\n",
        "331": "   * {@link TreeMultimap#create(Comparator, Comparator)} won't suffice.\n",
        "332": "   *\n",
        "333": "   * <p>Note: the multimap assumes complete ownership over of {@code map} and\n",
        "334": "   * the sets returned by {@code factory}. Those objects should not be manually\n",
        "335": "   * updated and they should not use soft, weak, or phantom references.\n",
        "336": "   *\n",
        "337": "   * @param map place to store the mapping from each key to its corresponding\n",
        "338": "   *     values\n",
        "339": "   * @param factory supplier of new, empty sorted sets that will each hold\n",
        "340": "   *     all values for a given key\n",
        "391": "   * Copies each key-value mapping in {@code source} into {@code dest}, with\n",
        "392": "   * its key and value reversed.\n",
        "394": "   * <p>If {@code source} is an {@link ImmutableMultimap}, consider using\n",
        "395": "   * {@link ImmutableMultimap#inverse} instead.\n",
        "412": "   * Returns a synchronized (thread-safe) multimap backed by the specified\n",
        "413": "   * multimap. In order to guarantee serial access, it is critical that\n",
        "414": "   * <b>all</b> access to the backing multimap is accomplished through the\n",
        "415": "   * returned multimap.\n",
        "416": "   *\n",
        "417": "   * <p>It is imperative that the user manually synchronize on the returned\n",
        "418": "   * multimap when accessing any of its collection views: <pre>   {@code\n",
        "419": "   *\n",
        "420": "   *   Multimap<K, V> multimap = Multimaps.synchronizedMultimap(\n",
        "421": "   *       HashMultimap.<K, V>create());\n",
        "422": "   *   ...\n",
        "423": "   *   Collection<V> values = multimap.get(key);  // Needn't be in synchronized block\n",
        "424": "   *   ...\n",
        "425": "   *   synchronized (multimap) {  // Synchronizing on multimap, not values!\n",
        "426": "   *     Iterator<V> i = values.iterator(); // Must be in synchronized block\n",
        "427": "   *     while (i.hasNext()) {\n",
        "428": "   *       foo(i.next());\n",
        "429": "   *     }\n",
        "430": "   *   }}</pre>\n",
        "434": "   * <p>Note that the generated multimap's {@link Multimap#removeAll} and\n",
        "435": "   * {@link Multimap#replaceValues} methods return collections that aren't\n",
        "436": "   * synchronized.\n",
        "438": "   * <p>The returned multimap will be serializable if the specified multimap is\n",
        "439": "   * serializable.\n",
        "449": "   * Returns an unmodifiable view of the specified multimap. Query operations on\n",
        "450": "   * the returned multimap \"read through\" to the specified multimap, and\n",
        "451": "   * attempts to modify the returned multimap, either directly or through the\n",
        "452": "   * multimap's views, result in an {@code UnsupportedOperationException}.\n",
        "454": "   * <p>Note that the generated multimap's {@link Multimap#removeAll} and\n",
        "455": "   * {@link Multimap#replaceValues} methods return collections that are\n",
        "456": "   * modifiable.\n",
        "458": "   * <p>The returned multimap will be serializable if the specified multimap is\n",
        "459": "   * serializable.\n",
        "461": "   * @param delegate the multimap for which an unmodifiable view is to be\n",
        "462": "   *     returned\n",
        "701": "   * Returns a synchronized (thread-safe) {@code SetMultimap} backed by the\n",
        "702": "   * specified multimap.\n",
        "706": "   * <p>The returned multimap will be serializable if the specified multimap is\n",
        "707": "   * serializable.\n",
        "717": "   * Returns an unmodifiable view of the specified {@code SetMultimap}. Query\n",
        "718": "   * operations on the returned multimap \"read through\" to the specified\n",
        "719": "   * multimap, and attempts to modify the returned multimap, either directly or\n",
        "720": "   * through the multimap's views, result in an\n",
        "721": "   * {@code UnsupportedOperationException}.\n",
        "723": "   * <p>Note that the generated multimap's {@link Multimap#removeAll} and\n",
        "724": "   * {@link Multimap#replaceValues} methods return collections that are\n",
        "725": "   * modifiable.\n",
        "727": "   * <p>The returned multimap will be serializable if the specified multimap is\n",
        "728": "   * serializable.\n",
        "730": "   * @param delegate the multimap for which an unmodifiable view is to be\n",
        "731": "   *     returned\n",
        "754": "   * Returns a synchronized (thread-safe) {@code SortedSetMultimap} backed by\n",
        "755": "   * the specified multimap.\n",
        "759": "   * <p>The returned multimap will be serializable if the specified multimap is\n",
        "760": "   * serializable.\n",
        "771": "   * Returns an unmodifiable view of the specified {@code SortedSetMultimap}.\n",
        "772": "   * Query operations on the returned multimap \"read through\" to the specified\n",
        "773": "   * multimap, and attempts to modify the returned multimap, either directly or\n",
        "774": "   * through the multimap's views, result in an\n",
        "775": "   * {@code UnsupportedOperationException}.\n",
        "777": "   * <p>Note that the generated multimap's {@link Multimap#removeAll} and\n",
        "778": "   * {@link Multimap#replaceValues} methods return collections that are\n",
        "779": "   * modifiable.\n",
        "781": "   * <p>The returned multimap will be serializable if the specified multimap is\n",
        "782": "   * serializable.\n",
        "784": "   * @param delegate the multimap for which an unmodifiable view is to be\n",
        "785": "   *     returned\n",
        "797": "   * Returns a synchronized (thread-safe) {@code ListMultimap} backed by the\n",
        "798": "   * specified multimap.\n",
        "810": "   * Returns an unmodifiable view of the specified {@code ListMultimap}. Query\n",
        "811": "   * operations on the returned multimap \"read through\" to the specified\n",
        "812": "   * multimap, and attempts to modify the returned multimap, either directly or\n",
        "813": "   * through the multimap's views, result in an\n",
        "814": "   * {@code UnsupportedOperationException}.\n",
        "816": "   * <p>Note that the generated multimap's {@link Multimap#removeAll} and\n",
        "817": "   * {@link Multimap#replaceValues} methods return collections that are\n",
        "818": "   * modifiable.\n",
        "820": "   * <p>The returned multimap will be serializable if the specified multimap is\n",
        "821": "   * serializable.\n",
        "823": "   * @param delegate the multimap for which an unmodifiable view is to be\n",
        "824": "   *     returned\n",
        "847": "   * Returns an unmodifiable view of the specified collection, preserving the\n",
        "848": "   * interface for instances of {@code SortedSet}, {@code Set}, {@code List} and\n",
        "849": "   * {@code Collection}, in that order of preference.\n",
        "866": "   * Returns an unmodifiable view of the specified collection of entries. The\n",
        "867": "   * {@link Entry#setValue} operation throws an {@link\n",
        "868": "   * UnsupportedOperationException}. If the specified collection is a {@code\n",
        "869": "   * Set}, the returned collection is also a {@code Set}.\n",
        "883": "   * Returns {@link ListMultimap#asMap multimap.asMap()}, with its type\n",
        "884": "   * corrected from {@code Map<K, Collection<V>>} to {@code Map<K, List<V>>}.\n",
        "896": "   * Returns {@link SetMultimap#asMap multimap.asMap()}, with its type corrected\n",
        "897": "   * from {@code Map<K, Collection<V>>} to {@code Map<K, Set<V>>}.\n",
        "909": "   * Returns {@link SortedSetMultimap#asMap multimap.asMap()}, with its type\n",
        "910": "   * corrected from {@code Map<K, Collection<V>>} to\n",
        "911": "   * {@code Map<K, SortedSet<V>>}.\n",
        "923": "   * Returns {@link Multimap#asMap multimap.asMap()}. This is provided for\n",
        "924": "   * parity with the other more strongly-typed {@code asMap()} implementations.\n",
        "934": "   * Returns a multimap view of the specified map. The multimap is backed by the\n",
        "935": "   * map, so changes to the map are reflected in the multimap, and vice versa.\n",
        "936": "   * If the map is modified while an iteration over one of the multimap's\n",
        "937": "   * collection views is in progress (except through the iterator's own {@code\n",
        "938": "   * remove} operation, or through the {@code setValue} operation on a map entry\n",
        "939": "   * returned by the iterator), the results of the iteration are undefined.\n",
        "941": "   * <p>The multimap supports mapping removal, which removes the corresponding\n",
        "942": "   * mapping from the map. It does not support any operations which might add\n",
        "943": "   * mappings, such as {@code put}, {@code putAll} or {@code replaceValues}.\n",
        "945": "   * <p>The returned multimap will be serializable if the specified map is\n",
        "946": "   * serializable.\n",
        "1095": "   * Returns a view of a multimap where each value is transformed by a function.\n",
        "1096": "   * All other properties of the multimap, such as iteration order, are left\n",
        "1097": "   * intact. For example, the code: <pre>   {@code\n",
        "1108": "   *   System.out.println(transformed);}</pre>\n",
        "1112": "   * <p>Changes in the underlying multimap are reflected in this view.\n",
        "1113": "   * Conversely, this view supports removal operations, and these are reflected\n",
        "1114": "   * in the underlying multimap.\n",
        "1115": "   *\n",
        "1116": "   * <p>It's acceptable for the underlying multimap to contain null keys, and\n",
        "1117": "   * even null values provided that the function is capable of accepting null\n",
        "1118": "   * input.  The transformed multimap might contain null values, if the function\n",
        "1119": "   * sometimes gives a null result.\n",
        "1120": "   *\n",
        "1121": "   * <p>The returned multimap is not thread-safe or serializable, even if the\n",
        "1122": "   * underlying multimap is.  The {@code equals} and {@code hashCode} methods\n",
        "1123": "   * of the returned multimap are meaningless, since there is not a definition\n",
        "1124": "   * of {@code equals} or {@code hashCode} for general collections, and\n",
        "1125": "   * {@code get()} will return a general {@code Collection} as opposed to a\n",
        "1126": "   * {@code List} or a {@code Set}.\n",
        "1127": "   *\n",
        "1128": "   * <p>The function is applied lazily, invoked when needed. This is necessary\n",
        "1129": "   * for the returned multimap to be a view, but it means that the function will\n",
        "1130": "   * be applied many times for bulk operations like\n",
        "1131": "   * {@link Multimap#containsValue} and {@code Multimap.toString()}. For this to\n",
        "1132": "   * perform well, {@code function} should be fast. To avoid lazy evaluation\n",
        "1133": "   * when the returned multimap doesn't need to be a view, copy the returned\n",
        "1134": "   * multimap into a new multimap of your choosing.\n",
        "1146": "   * Returns a view of a multimap whose values are derived from the original\n",
        "1147": "   * multimap's entries. In contrast to {@link #transformValues}, this method's\n",
        "1148": "   * entry-transformation logic may depend on the key as well as the value.\n",
        "1149": "   *\n",
        "1150": "   * <p>All other properties of the transformed multimap, such as iteration\n",
        "1151": "   * order, are left intact. For example, the code: <pre>   {@code\n",
        "1152": "   *\n",
        "1153": "   *   SetMultimap<String, Integer> multimap =\n",
        "1154": "   *       ImmutableSetMultimap.of(\"a\", 1, \"a\", 4, \"b\", -6);\n",
        "1155": "   *   EntryTransformer<String, Integer, String> transformer =\n",
        "1156": "   *       new EntryTransformer<String, Integer, String>() {\n",
        "1157": "   *         public String transformEntry(String key, Integer value) {\n",
        "1158": "   *            return (value >= 0) ? key : \"no\" + key;\n",
        "1159": "   *         }\n",
        "1160": "   *       };\n",
        "1161": "   *   Multimap<String, String> transformed =\n",
        "1162": "   *       Multimaps.transformEntries(multimap, transformer);\n",
        "1163": "   *   System.out.println(transformed);}</pre>\n",
        "1167": "   * <p>Changes in the underlying multimap are reflected in this view.\n",
        "1168": "   * Conversely, this view supports removal operations, and these are reflected\n",
        "1169": "   * in the underlying multimap.\n",
        "1170": "   *\n",
        "1171": "   * <p>It's acceptable for the underlying multimap to contain null keys and\n",
        "1172": "   * null values provided that the transformer is capable of accepting null\n",
        "1173": "   * inputs. The transformed multimap might contain null values if the\n",
        "1174": "   * transformer sometimes gives a null result.\n",
        "1175": "   *\n",
        "1176": "   * <p>The returned multimap is not thread-safe or serializable, even if the\n",
        "1177": "   * underlying multimap is.  The {@code equals} and {@code hashCode} methods\n",
        "1178": "   * of the returned multimap are meaningless, since there is not a definition\n",
        "1179": "   * of {@code equals} or {@code hashCode} for general collections, and\n",
        "1180": "   * {@code get()} will return a general {@code Collection} as opposed to a\n",
        "1181": "   * {@code List} or a {@code Set}.\n",
        "1182": "   *\n",
        "1183": "   * <p>The transformer is applied lazily, invoked when needed. This is\n",
        "1184": "   * necessary for the returned multimap to be a view, but it means that the\n",
        "1185": "   * transformer will be applied many times for bulk operations like {@link\n",
        "1186": "   * Multimap#containsValue} and {@link Object#toString}. For this to perform\n",
        "1187": "   * well, {@code transformer} should be fast. To avoid lazy evaluation when the\n",
        "1188": "   * returned multimap doesn't need to be a view, copy the returned multimap\n",
        "1189": "   * into a new multimap of your choosing.\n",
        "1190": "   *\n",
        "1191": "   * <p><b>Warning:</b> This method assumes that for any instance {@code k} of\n",
        "1192": "   * {@code EntryTransformer} key type {@code K}, {@code k.equals(k2)} implies\n",
        "1193": "   * that {@code k2} is also of type {@code K}. Using an {@code\n",
        "1194": "   * EntryTransformer} key type for which this may not hold, such as {@code\n",
        "1195": "   * ArrayList}, may risk a {@code ClassCastException} when calling methods on\n",
        "1196": "   * the transformed multimap.\n",
        "1318": "   * Returns a view of a {@code ListMultimap} where each value is transformed by\n",
        "1319": "   * a function. All other properties of the multimap, such as iteration order,\n",
        "1320": "   * are left intact. For example, the code: <pre>   {@code\n",
        "1321": "   *\n",
        "1322": "   *   ListMultimap<String, Integer> multimap\n",
        "1323": "   *        = ImmutableListMultimap.of(\"a\", 4, \"a\", 16, \"b\", 9);\n",
        "1324": "   *   Function<Integer, Double> sqrt =\n",
        "1325": "   *       new Function<Integer, Double>() {\n",
        "1326": "   *         public Double apply(Integer in) {\n",
        "1327": "   *           return Math.sqrt((int) in);\n",
        "1328": "   *         }\n",
        "1329": "   *       };\n",
        "1330": "   *   ListMultimap<String, Double> transformed = Multimaps.transformValues(map,\n",
        "1331": "   *       sqrt);\n",
        "1332": "   *   System.out.println(transformed);}</pre>\n",
        "1336": "   * <p>Changes in the underlying multimap are reflected in this view.\n",
        "1337": "   * Conversely, this view supports removal operations, and these are reflected\n",
        "1338": "   * in the underlying multimap.\n",
        "1340": "   * <p>It's acceptable for the underlying multimap to contain null keys, and\n",
        "1341": "   * even null values provided that the function is capable of accepting null\n",
        "1342": "   * input.  The transformed multimap might contain null values, if the function\n",
        "1343": "   * sometimes gives a null result.\n",
        "1345": "   * <p>The returned multimap is not thread-safe or serializable, even if the\n",
        "1346": "   * underlying multimap is.\n",
        "1348": "   * <p>The function is applied lazily, invoked when needed. This is necessary\n",
        "1349": "   * for the returned multimap to be a view, but it means that the function will\n",
        "1350": "   * be applied many times for bulk operations like\n",
        "1351": "   * {@link Multimap#containsValue} and {@code Multimap.toString()}. For this to\n",
        "1352": "   * perform well, {@code function} should be fast. To avoid lazy evaluation\n",
        "1353": "   * when the returned multimap doesn't need to be a view, copy the returned\n",
        "1354": "   * multimap into a new multimap of your choosing.\n",
        "1366": "   * Returns a view of a {@code ListMultimap} whose values are derived from the\n",
        "1367": "   * original multimap's entries. In contrast to\n",
        "1368": "   * {@link #transformValues(ListMultimap, Function)}, this method's\n",
        "1371": "   * <p>All other properties of the transformed multimap, such as iteration\n",
        "1372": "   * order, are left intact. For example, the code: <pre>   {@code\n",
        "1373": "   *\n",
        "1374": "   *   Multimap<String, Integer> multimap =\n",
        "1375": "   *       ImmutableMultimap.of(\"a\", 1, \"a\", 4, \"b\", 6);\n",
        "1376": "   *   EntryTransformer<String, Integer, String> transformer =\n",
        "1377": "   *       new EntryTransformer<String, Integer, String>() {\n",
        "1378": "   *         public String transformEntry(String key, Integer value) {\n",
        "1379": "   *           return key + value;\n",
        "1380": "   *         }\n",
        "1381": "   *       };\n",
        "1382": "   *   Multimap<String, String> transformed =\n",
        "1383": "   *       Multimaps.transformEntries(multimap, transformer);\n",
        "1384": "   *   System.out.println(transformed);}</pre>\n",
        "1388": "   * <p>Changes in the underlying multimap are reflected in this view.\n",
        "1389": "   * Conversely, this view supports removal operations, and these are reflected\n",
        "1390": "   * in the underlying multimap.\n",
        "1391": "   *\n",
        "1392": "   * <p>It's acceptable for the underlying multimap to contain null keys and\n",
        "1393": "   * null values provided that the transformer is capable of accepting null\n",
        "1394": "   * inputs. The transformed multimap might contain null values if the\n",
        "1395": "   * transformer sometimes gives a null result.\n",
        "1396": "   *\n",
        "1397": "   * <p>The returned multimap is not thread-safe or serializable, even if the\n",
        "1398": "   * underlying multimap is.\n",
        "1399": "   *\n",
        "1400": "   * <p>The transformer is applied lazily, invoked when needed. This is\n",
        "1401": "   * necessary for the returned multimap to be a view, but it means that the\n",
        "1402": "   * transformer will be applied many times for bulk operations like {@link\n",
        "1403": "   * Multimap#containsValue} and {@link Object#toString}. For this to perform\n",
        "1404": "   * well, {@code transformer} should be fast. To avoid lazy evaluation when the\n",
        "1405": "   * returned multimap doesn't need to be a view, copy the returned multimap\n",
        "1406": "   * into a new multimap of your choosing.\n",
        "1407": "   *\n",
        "1408": "   * <p><b>Warning:</b> This method assumes that for any instance {@code k} of\n",
        "1409": "   * {@code EntryTransformer} key type {@code K}, {@code k.equals(k2)} implies\n",
        "1410": "   * that {@code k2} is also of type {@code K}. Using an {@code\n",
        "1411": "   * EntryTransformer} key type for which this may not hold, such as {@code\n",
        "1412": "   * ArrayList}, may risk a {@code ClassCastException} when calling methods on\n",
        "1413": "   * the transformed multimap.\n",
        "1453": "   * Creates an index {@code ImmutableListMultimap} that contains the results of\n",
        "1454": "   * applying a specified function to each item in an {@code Iterable} of\n",
        "1455": "   * values. Each value will be stored as a value in the resulting multimap,\n",
        "1456": "   * yielding a multimap with the same size as the input iterable. The key used\n",
        "1457": "   * to store that value in the multimap will be the result of calling the\n",
        "1458": "   * function on that value. The resulting multimap is created as an immutable\n",
        "1459": "   * snapshot. In the returned multimap, keys appear in the order they are first\n",
        "1460": "   * encountered, and the values corresponding to each key appear in the same\n",
        "1461": "   * order as they are encountered.\n",
        "1462": "   *\n",
        "1463": "   * <p>For example, <pre>   {@code\n",
        "1464": "   *\n",
        "1465": "   *   List<String> badGuys =\n",
        "1466": "   *       Arrays.asList(\"Inky\", \"Blinky\", \"Pinky\", \"Pinky\", \"Clyde\");\n",
        "1467": "   *   Function<String, Integer> stringLengthFunction = ...;\n",
        "1468": "   *   Multimap<Integer, String> index =\n",
        "1469": "   *       Multimaps.index(badGuys, stringLengthFunction);\n",
        "1470": "   *   System.out.println(index);}</pre>\n",
        "1471": "   *\n",
        "1472": "   * <p>prints <pre>   {@code\n",
        "1473": "   *\n",
        "1474": "   *   {4=[Inky], 6=[Blinky], 5=[Pinky, Pinky, Clyde]}}</pre>\n",
        "1475": "   *\n",
        "1476": "   * <p>The returned multimap is serializable if its keys and values are all\n",
        "1477": "   * serializable.\n",
        "1478": "   *\n",
        "1479": "   * @param values the values to use when constructing the {@code\n",
        "1480": "   *     ImmutableListMultimap}\n",
        "1482": "   * @return {@code ImmutableListMultimap} mapping the result of evaluating the\n",
        "1483": "   *     function {@code keyFunction} on each value in the input collection to\n",
        "1484": "   *     that value\n",
        "1494": "   * Creates an index {@code ImmutableListMultimap} that contains the results of\n",
        "1495": "   * applying a specified function to each item in an {@code Iterator} of\n",
        "1496": "   * values. Each value will be stored as a value in the resulting multimap,\n",
        "1497": "   * yielding a multimap with the same size as the input iterator. The key used\n",
        "1498": "   * to store that value in the multimap will be the result of calling the\n",
        "1499": "   * function on that value. The resulting multimap is created as an immutable\n",
        "1500": "   * snapshot. In the returned multimap, keys appear in the order they are first\n",
        "1501": "   * encountered, and the values corresponding to each key appear in the same\n",
        "1502": "   * order as they are encountered.\n",
        "1503": "   *\n",
        "1504": "   * <p>For example, <pre>   {@code\n",
        "1505": "   *\n",
        "1506": "   *   List<String> badGuys =\n",
        "1507": "   *       Arrays.asList(\"Inky\", \"Blinky\", \"Pinky\", \"Pinky\", \"Clyde\");\n",
        "1508": "   *   Function<String, Integer> stringLengthFunction = ...;\n",
        "1509": "   *   Multimap<Integer, String> index =\n",
        "1510": "   *       Multimaps.index(badGuys.iterator(), stringLengthFunction);\n",
        "1511": "   *   System.out.println(index);}</pre>\n",
        "1512": "   *\n",
        "1513": "   * <p>prints <pre>   {@code\n",
        "1514": "   *\n",
        "1515": "   *   {4=[Inky], 6=[Blinky], 5=[Pinky, Pinky, Clyde]}}</pre>\n",
        "1516": "   *\n",
        "1517": "   * <p>The returned multimap is serializable if its keys and values are all\n",
        "1518": "   * serializable.\n",
        "1519": "   *\n",
        "1520": "   * @param values the values to use when constructing the {@code\n",
        "1521": "   *     ImmutableListMultimap}\n",
        "1523": "   * @return {@code ImmutableListMultimap} mapping the result of evaluating the\n",
        "1524": "   *     function {@code keyFunction} on each value in the input collection to\n",
        "1525": "   *     that value\n",
        "1679": "  /**\n",
        "1680": "   * A skeleton implementation of {@link Multimap#entries()}.\n",
        "1681": "   */\n",
        "1714": "  /**\n",
        "1715": "   * A skeleton implementation of {@link Multimap#asMap()}.\n",
        "1716": "   */\n",
        "1801": "   * Returns a multimap containing the mappings in {@code unfiltered} whose keys\n",
        "1802": "   * satisfy a predicate. The returned multimap is a live view of\n",
        "1803": "   * {@code unfiltered}; changes to one affect the other.\n",
        "1805": "   * <p>The resulting multimap's views have iterators that don't support\n",
        "1806": "   * {@code remove()}, but all other methods are supported by the multimap and\n",
        "1807": "   * its views. When adding a key that doesn't satisfy the predicate, the\n",
        "1808": "   * multimap's {@code put()}, {@code putAll()}, and {@code replaceValues()}\n",
        "1809": "   * methods throw an {@link IllegalArgumentException}.\n",
        "1811": "   * <p>When methods such as {@code removeAll()} and {@code clear()} are called on\n",
        "1812": "   * the filtered multimap or its views, only mappings whose keys satisfy the\n",
        "1813": "   * filter will be removed from the underlying multimap.\n",
        "1815": "   * <p>The returned multimap isn't threadsafe or serializable, even if\n",
        "1816": "   * {@code unfiltered} is.\n",
        "1818": "   * <p>Many of the filtered multimap's methods, such as {@code size()}, iterate\n",
        "1819": "   * across every key/value mapping in the underlying multimap and determine\n",
        "1820": "   * which satisfy the filter. When a live view is <i>not</i> needed, it may be\n",
        "1821": "   * faster to copy the filtered multimap and use the copy.\n",
        "1823": "   * <p><b>Warning:</b> {@code keyPredicate} must be <i>consistent with equals</i>,\n",
        "1824": "   * as documented at {@link Predicate#apply}. Do not provide a predicate such\n",
        "1825": "   * as {@code Predicates.instanceOf(ArrayList.class)}, which is inconsistent\n",
        "1826": "   * with equals.\n",
        "1849": "   * Returns a multimap containing the mappings in {@code unfiltered} whose keys\n",
        "1850": "   * satisfy a predicate. The returned multimap is a live view of\n",
        "1851": "   * {@code unfiltered}; changes to one affect the other.\n",
        "1853": "   * <p>The resulting multimap's views have iterators that don't support\n",
        "1854": "   * {@code remove()}, but all other methods are supported by the multimap and\n",
        "1855": "   * its views. When adding a key that doesn't satisfy the predicate, the\n",
        "1856": "   * multimap's {@code put()}, {@code putAll()}, and {@code replaceValues()}\n",
        "1857": "   * methods throw an {@link IllegalArgumentException}.\n",
        "1859": "   * <p>When methods such as {@code removeAll()} and {@code clear()} are called on\n",
        "1860": "   * the filtered multimap or its views, only mappings whose keys satisfy the\n",
        "1861": "   * filter will be removed from the underlying multimap.\n",
        "1863": "   * <p>The returned multimap isn't threadsafe or serializable, even if\n",
        "1864": "   * {@code unfiltered} is.\n",
        "1866": "   * <p>Many of the filtered multimap's methods, such as {@code size()}, iterate\n",
        "1867": "   * across every key/value mapping in the underlying multimap and determine\n",
        "1868": "   * which satisfy the filter. When a live view is <i>not</i> needed, it may be\n",
        "1869": "   * faster to copy the filtered multimap and use the copy.\n",
        "1871": "   * <p><b>Warning:</b> {@code keyPredicate} must be <i>consistent with equals</i>,\n",
        "1872": "   * as documented at {@link Predicate#apply}. Do not provide a predicate such\n",
        "1873": "   * as {@code Predicates.instanceOf(ArrayList.class)}, which is inconsistent\n",
        "1874": "   * with equals.\n",
        "1893": "   * Returns a multimap containing the mappings in {@code unfiltered} whose keys\n",
        "1894": "   * satisfy a predicate. The returned multimap is a live view of\n",
        "1895": "   * {@code unfiltered}; changes to one affect the other.\n",
        "1897": "   * <p>The resulting multimap's views have iterators that don't support\n",
        "1898": "   * {@code remove()}, but all other methods are supported by the multimap and\n",
        "1899": "   * its views. When adding a key that doesn't satisfy the predicate, the\n",
        "1900": "   * multimap's {@code put()}, {@code putAll()}, and {@code replaceValues()}\n",
        "1901": "   * methods throw an {@link IllegalArgumentException}.\n",
        "1903": "   * <p>When methods such as {@code removeAll()} and {@code clear()} are called on\n",
        "1904": "   * the filtered multimap or its views, only mappings whose keys satisfy the\n",
        "1905": "   * filter will be removed from the underlying multimap.\n",
        "1907": "   * <p>The returned multimap isn't threadsafe or serializable, even if\n",
        "1908": "   * {@code unfiltered} is.\n",
        "1910": "   * <p>Many of the filtered multimap's methods, such as {@code size()}, iterate\n",
        "1911": "   * across every key/value mapping in the underlying multimap and determine\n",
        "1912": "   * which satisfy the filter. When a live view is <i>not</i> needed, it may be\n",
        "1913": "   * faster to copy the filtered multimap and use the copy.\n",
        "1915": "   * <p><b>Warning:</b> {@code keyPredicate} must be <i>consistent with equals</i>,\n",
        "1916": "   * as documented at {@link Predicate#apply}. Do not provide a predicate such\n",
        "1917": "   * as {@code Predicates.instanceOf(ArrayList.class)}, which is inconsistent\n",
        "1918": "   * with equals.\n",
        "1934": "   * Returns a multimap containing the mappings in {@code unfiltered} whose values\n",
        "1935": "   * satisfy a predicate. The returned multimap is a live view of\n",
        "1936": "   * {@code unfiltered}; changes to one affect the other.\n",
        "1938": "   * <p>The resulting multimap's views have iterators that don't support\n",
        "1939": "   * {@code remove()}, but all other methods are supported by the multimap and\n",
        "1940": "   * its views. When adding a value that doesn't satisfy the predicate, the\n",
        "1941": "   * multimap's {@code put()}, {@code putAll()}, and {@code replaceValues()}\n",
        "1942": "   * methods throw an {@link IllegalArgumentException}.\n",
        "1944": "   * <p>When methods such as {@code removeAll()} and {@code clear()} are called on\n",
        "1945": "   * the filtered multimap or its views, only mappings whose value satisfy the\n",
        "1946": "   * filter will be removed from the underlying multimap.\n",
        "1948": "   * <p>The returned multimap isn't threadsafe or serializable, even if\n",
        "1949": "   * {@code unfiltered} is.\n",
        "1951": "   * <p>Many of the filtered multimap's methods, such as {@code size()}, iterate\n",
        "1952": "   * across every key/value mapping in the underlying multimap and determine\n",
        "1953": "   * which satisfy the filter. When a live view is <i>not</i> needed, it may be\n",
        "1954": "   * faster to copy the filtered multimap and use the copy.\n",
        "1956": "   * <p><b>Warning:</b> {@code valuePredicate} must be <i>consistent with\n",
        "1957": "   * equals</i>, as documented at {@link Predicate#apply}. Do not provide a\n",
        "1958": "   * predicate such as {@code Predicates.instanceOf(ArrayList.class)}, which is\n",
        "1959": "   * inconsistent with equals.\n",
        "1969": "   * Returns a multimap containing the mappings in {@code unfiltered} whose values\n",
        "1970": "   * satisfy a predicate. The returned multimap is a live view of\n",
        "1971": "   * {@code unfiltered}; changes to one affect the other.\n",
        "1973": "   * <p>The resulting multimap's views have iterators that don't support\n",
        "1974": "   * {@code remove()}, but all other methods are supported by the multimap and\n",
        "1975": "   * its views. When adding a value that doesn't satisfy the predicate, the\n",
        "1976": "   * multimap's {@code put()}, {@code putAll()}, and {@code replaceValues()}\n",
        "1977": "   * methods throw an {@link IllegalArgumentException}.\n",
        "1979": "   * <p>When methods such as {@code removeAll()} and {@code clear()} are called on\n",
        "1980": "   * the filtered multimap or its views, only mappings whose value satisfy the\n",
        "1981": "   * filter will be removed from the underlying multimap.\n",
        "1983": "   * <p>The returned multimap isn't threadsafe or serializable, even if\n",
        "1984": "   * {@code unfiltered} is.\n",
        "1986": "   * <p>Many of the filtered multimap's methods, such as {@code size()}, iterate\n",
        "1987": "   * across every key/value mapping in the underlying multimap and determine\n",
        "1988": "   * which satisfy the filter. When a live view is <i>not</i> needed, it may be\n",
        "1989": "   * faster to copy the filtered multimap and use the copy.\n",
        "1991": "   * <p><b>Warning:</b> {@code valuePredicate} must be <i>consistent with\n",
        "1992": "   * equals</i>, as documented at {@link Predicate#apply}. Do not provide a\n",
        "1993": "   * predicate such as {@code Predicates.instanceOf(ArrayList.class)}, which is\n",
        "1994": "   * inconsistent with equals.\n",
        "2004": "   * Returns a multimap containing the mappings in {@code unfiltered} that\n",
        "2005": "   * satisfy a predicate. The returned multimap is a live view of\n",
        "2006": "   * {@code unfiltered}; changes to one affect the other.\n",
        "2008": "   * <p>The resulting multimap's views have iterators that don't support\n",
        "2009": "   * {@code remove()}, but all other methods are supported by the multimap and\n",
        "2010": "   * its views. When adding a key/value pair that doesn't satisfy the predicate,\n",
        "2011": "   * multimap's {@code put()}, {@code putAll()}, and {@code replaceValues()}\n",
        "2012": "   * methods throw an {@link IllegalArgumentException}.\n",
        "2014": "   * <p>When methods such as {@code removeAll()} and {@code clear()} are called on\n",
        "2015": "   * the filtered multimap or its views, only mappings whose keys satisfy the\n",
        "2016": "   * filter will be removed from the underlying multimap.\n",
        "2018": "   * <p>The returned multimap isn't threadsafe or serializable, even if\n",
        "2019": "   * {@code unfiltered} is.\n",
        "2021": "   * <p>Many of the filtered multimap's methods, such as {@code size()}, iterate\n",
        "2022": "   * across every key/value mapping in the underlying multimap and determine\n",
        "2023": "   * which satisfy the filter. When a live view is <i>not</i> needed, it may be\n",
        "2024": "   * faster to copy the filtered multimap and use the copy.\n",
        "2026": "   * <p><b>Warning:</b> {@code entryPredicate} must be <i>consistent with\n",
        "2027": "   * equals</i>, as documented at {@link Predicate#apply}.\n",
        "2043": "   * Returns a multimap containing the mappings in {@code unfiltered} that\n",
        "2044": "   * satisfy a predicate. The returned multimap is a live view of\n",
        "2045": "   * {@code unfiltered}; changes to one affect the other.\n",
        "2047": "   * <p>The resulting multimap's views have iterators that don't support\n",
        "2048": "   * {@code remove()}, but all other methods are supported by the multimap and\n",
        "2049": "   * its views. When adding a key/value pair that doesn't satisfy the predicate,\n",
        "2050": "   * multimap's {@code put()}, {@code putAll()}, and {@code replaceValues()}\n",
        "2051": "   * methods throw an {@link IllegalArgumentException}.\n",
        "2053": "   * <p>When methods such as {@code removeAll()} and {@code clear()} are called on\n",
        "2054": "   * the filtered multimap or its views, only mappings whose keys satisfy the\n",
        "2055": "   * filter will be removed from the underlying multimap.\n",
        "2057": "   * <p>The returned multimap isn't threadsafe or serializable, even if\n",
        "2058": "   * {@code unfiltered} is.\n",
        "2060": "   * <p>Many of the filtered multimap's methods, such as {@code size()}, iterate\n",
        "2061": "   * across every key/value mapping in the underlying multimap and determine\n",
        "2062": "   * which satisfy the filter. When a live view is <i>not</i> needed, it may be\n",
        "2063": "   * faster to copy the filtered multimap and use the copy.\n",
        "2065": "   * <p><b>Warning:</b> {@code entryPredicate} must be <i>consistent with\n",
        "2066": "   * equals</i>, as documented at {@link Predicate#apply}.\n",
        "2079": "   * Support removal operations when filtering a filtered multimap. Since a\n",
        "2080": "   * filtered multimap has iterators that don't support remove, passing one to\n",
        "2081": "   * the FilteredEntryMultimap constructor would lead to a multimap whose removal\n",
        "2082": "   * operations would fail. This method combines the predicates to avoid that\n",
        "2083": "   * problem.\n"
    }
}