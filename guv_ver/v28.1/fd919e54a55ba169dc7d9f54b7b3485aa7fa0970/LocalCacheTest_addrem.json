{
    "addition": {
        "80": "/** @author Charles Fry */\n",
        "103": "    suite.addTest(\n",
        "104": "        ConcurrentMapTestSuiteBuilder.using(new TestStringCacheGenerator(createCacheBuilder()))\n",
        "105": "            .named(\"LocalCache with defaults\")\n",
        "106": "            .withFeatures(\n",
        "107": "                CollectionSize.ANY,\n",
        "108": "                MapFeature.GENERAL_PURPOSE,\n",
        "109": "                CollectionFeature.SUPPORTS_ITERATOR_REMOVE)\n",
        "110": "            .createTestSuite());\n",
        "111": "    suite.addTest(\n",
        "112": "        ConcurrentMapTestSuiteBuilder.using(\n",
        "113": "                new TestStringCacheGenerator(createCacheBuilder().concurrencyLevel(1)))\n",
        "114": "            .named(\"LocalCache with concurrencyLevel[1]\")\n",
        "115": "            .withFeatures(\n",
        "116": "                CollectionSize.ANY,\n",
        "117": "                MapFeature.GENERAL_PURPOSE,\n",
        "118": "                CollectionFeature.SUPPORTS_ITERATOR_REMOVE)\n",
        "119": "            .createTestSuite());\n",
        "120": "    suite.addTest(\n",
        "121": "        ConcurrentMapTestSuiteBuilder.using(\n",
        "122": "                new TestStringCacheGenerator(createCacheBuilder().maximumSize(Integer.MAX_VALUE)))\n",
        "123": "            .named(\"LocalCache with maximumSize\")\n",
        "124": "            .withFeatures(\n",
        "125": "                CollectionSize.ANY,\n",
        "126": "                MapFeature.GENERAL_PURPOSE,\n",
        "127": "                CollectionFeature.SUPPORTS_ITERATOR_REMOVE)\n",
        "128": "            .createTestSuite());\n",
        "129": "    suite.addTest(\n",
        "130": "        ConcurrentMapTestSuiteBuilder.using(\n",
        "131": "                new TestStringCacheGenerator(\n",
        "132": "                    createCacheBuilder()\n",
        "133": "                        .maximumWeight(Integer.MAX_VALUE)\n",
        "134": "                        .weigher(new SerializableWeigher<String, String>())))\n",
        "135": "            .named(\"LocalCache with maximumWeight\")\n",
        "136": "            .withFeatures(\n",
        "137": "                CollectionSize.ANY,\n",
        "138": "                MapFeature.GENERAL_PURPOSE,\n",
        "139": "                CollectionFeature.SUPPORTS_ITERATOR_REMOVE)\n",
        "140": "            .createTestSuite());\n",
        "141": "    suite.addTest(\n",
        "142": "        ConcurrentMapTestSuiteBuilder.using(\n",
        "143": "                new TestStringCacheGenerator(createCacheBuilder().weakKeys()))\n",
        "144": "            .named(\"LocalCache with weakKeys\") // keys are string literals and won't be GC'd\n",
        "145": "            .withFeatures(\n",
        "146": "                CollectionSize.ANY,\n",
        "147": "                MapFeature.GENERAL_PURPOSE,\n",
        "148": "                CollectionFeature.SUPPORTS_ITERATOR_REMOVE)\n",
        "149": "            .createTestSuite());\n",
        "150": "    suite.addTest(\n",
        "151": "        ConcurrentMapTestSuiteBuilder.using(\n",
        "152": "                new TestStringCacheGenerator(createCacheBuilder().weakValues()))\n",
        "153": "            .named(\"LocalCache with weakValues\") // values are string literals and won't be GC'd\n",
        "154": "            .withFeatures(\n",
        "155": "                CollectionSize.ANY,\n",
        "156": "                MapFeature.GENERAL_PURPOSE,\n",
        "157": "                CollectionFeature.SUPPORTS_ITERATOR_REMOVE)\n",
        "158": "            .createTestSuite());\n",
        "159": "    suite.addTest(\n",
        "160": "        ConcurrentMapTestSuiteBuilder.using(\n",
        "161": "                new TestStringCacheGenerator(createCacheBuilder().softValues()))\n",
        "162": "            .named(\"LocalCache with softValues\") // values are string literals and won't be GC'd\n",
        "163": "            .withFeatures(\n",
        "164": "                CollectionSize.ANY,\n",
        "165": "                MapFeature.GENERAL_PURPOSE,\n",
        "166": "                CollectionFeature.SUPPORTS_ITERATOR_REMOVE)\n",
        "167": "            .createTestSuite());\n",
        "168": "    suite.addTest(\n",
        "169": "        ConcurrentMapTestSuiteBuilder.using(\n",
        "170": "                new TestStringCacheGenerator(\n",
        "171": "                    createCacheBuilder()\n",
        "172": "                        .expireAfterAccess(1, SECONDS)\n",
        "173": "                        .ticker(new SerializableTicker())))\n",
        "174": "            .named(\"LocalCache with expireAfterAccess\") // SerializableTicker never advances\n",
        "175": "            .withFeatures(\n",
        "176": "                CollectionSize.ANY,\n",
        "177": "                MapFeature.GENERAL_PURPOSE,\n",
        "178": "                CollectionFeature.SUPPORTS_ITERATOR_REMOVE)\n",
        "179": "            .createTestSuite());\n",
        "180": "    suite.addTest(\n",
        "181": "        ConcurrentMapTestSuiteBuilder.using(\n",
        "182": "                new TestStringCacheGenerator(\n",
        "183": "                    createCacheBuilder()\n",
        "184": "                        .expireAfterWrite(1, SECONDS)\n",
        "185": "                        .ticker(new SerializableTicker())))\n",
        "186": "            .named(\"LocalCache with expireAfterWrite\") // SerializableTicker never advances\n",
        "187": "            .withFeatures(\n",
        "188": "                CollectionSize.ANY,\n",
        "189": "                MapFeature.GENERAL_PURPOSE,\n",
        "190": "                CollectionFeature.SUPPORTS_ITERATOR_REMOVE)\n",
        "191": "            .createTestSuite());\n",
        "192": "    suite.addTest(\n",
        "193": "        ConcurrentMapTestSuiteBuilder.using(\n",
        "194": "                new TestStringCacheGenerator(\n",
        "195": "                    createCacheBuilder()\n",
        "196": "                        .removalListener(new SerializableRemovalListener<String, String>())))\n",
        "197": "            .named(\"LocalCache with removalListener\")\n",
        "198": "            .withFeatures(\n",
        "199": "                CollectionSize.ANY,\n",
        "200": "                MapFeature.GENERAL_PURPOSE,\n",
        "201": "                CollectionFeature.SUPPORTS_ITERATOR_REMOVE)\n",
        "202": "            .createTestSuite());\n",
        "203": "    suite.addTest(\n",
        "204": "        ConcurrentMapTestSuiteBuilder.using(\n",
        "205": "                new TestStringCacheGenerator(createCacheBuilder().recordStats()))\n",
        "206": "            .named(\"LocalCache with recordStats\")\n",
        "207": "            .withFeatures(\n",
        "208": "                CollectionSize.ANY,\n",
        "209": "                MapFeature.GENERAL_PURPOSE,\n",
        "210": "                CollectionFeature.SUPPORTS_ITERATOR_REMOVE)\n",
        "211": "            .createTestSuite());\n",
        "292": "    Equivalence<Object> testEquivalence =\n",
        "293": "        new Equivalence<Object>() {\n",
        "294": "          @Override\n",
        "295": "          protected boolean doEquivalent(Object a, Object b) {\n",
        "296": "            return false;\n",
        "297": "          }\n",
        "299": "          @Override\n",
        "300": "          protected int doHash(Object t) {\n",
        "301": "            return 0;\n",
        "302": "          }\n",
        "303": "        };\n",
        "312": "    Equivalence<Object> testEquivalence =\n",
        "313": "        new Equivalence<Object>() {\n",
        "314": "          @Override\n",
        "315": "          protected boolean doEquivalent(Object a, Object b) {\n",
        "316": "            return false;\n",
        "317": "          }\n",
        "319": "          @Override\n",
        "320": "          protected int doHash(Object t) {\n",
        "321": "            return 0;\n",
        "322": "          }\n",
        "323": "        };\n",
        "386": "    LocalCache<Object, Object> map =\n",
        "387": "        makeLocalCache(\n",
        "388": "            createCacheBuilder()\n",
        "389": "                .concurrencyLevel(concurrencyLevel)\n",
        "390": "                .initialCapacity(initialCapacity));\n",
        "422": "    LocalCache<Object, Object> map =\n",
        "423": "        makeLocalCache(\n",
        "424": "            createCacheBuilder()\n",
        "425": "                .concurrencyLevel(concurrencyLevel)\n",
        "426": "                .initialCapacity(initialCapacity)\n",
        "427": "                .maximumSize(maxSize));\n",
        "429": "    assertTrue(\n",
        "430": "        \"segments=\" + map.segments.length + \", maxSize=\" + maxSize,\n",
        "437": "    map =\n",
        "438": "        makeLocalCache(\n",
        "439": "            createCacheBuilder()\n",
        "440": "                .concurrencyLevel(concurrencyLevel)\n",
        "441": "                .initialCapacity(initialCapacity)\n",
        "442": "                .maximumWeight(maxSize)\n",
        "443": "                .weigher(constantWeigher(1)));\n",
        "444": "    assertTrue(\n",
        "445": "        \"segments=\" + map.segments.length + \", maxSize=\" + maxSize,\n",
        "455": "    Weigher<Object, Object> testWeigher =\n",
        "456": "        new Weigher<Object, Object>() {\n",
        "457": "          @Override\n",
        "458": "          public int weigh(Object key, Object value) {\n",
        "459": "            return 42;\n",
        "460": "          }\n",
        "461": "        };\n",
        "525": "    Ticker testTicker =\n",
        "526": "        new Ticker() {\n",
        "527": "          @Override\n",
        "528": "          public long read() {\n",
        "529": "            return 0;\n",
        "530": "          }\n",
        "531": "        };\n",
        "537": "    assertSame(EntryFactory.STRONG, EntryFactory.getFactory(Strength.STRONG, false, false));\n",
        "538": "    assertSame(EntryFactory.STRONG_ACCESS, EntryFactory.getFactory(Strength.STRONG, true, false));\n",
        "539": "    assertSame(EntryFactory.STRONG_WRITE, EntryFactory.getFactory(Strength.STRONG, false, true));\n",
        "540": "    assertSame(\n",
        "541": "        EntryFactory.STRONG_ACCESS_WRITE, EntryFactory.getFactory(Strength.STRONG, true, true));\n",
        "542": "    assertSame(EntryFactory.WEAK, EntryFactory.getFactory(Strength.WEAK, false, false));\n",
        "543": "    assertSame(EntryFactory.WEAK_ACCESS, EntryFactory.getFactory(Strength.WEAK, true, false));\n",
        "544": "    assertSame(EntryFactory.WEAK_WRITE, EntryFactory.getFactory(Strength.WEAK, false, true));\n",
        "545": "    assertSame(EntryFactory.WEAK_ACCESS_WRITE, EntryFactory.getFactory(Strength.WEAK, true, true));\n",
        "565": "      LocalCache<Object, Object> map = makeLocalCache(builder.concurrencyLevel(1));\n",
        "678": "    CacheBuilder<Object, Object> builder =\n",
        "679": "        createCacheBuilder().expireAfterWrite(1, TimeUnit.NANOSECONDS);\n",
        "709": "    final CacheLoader<Object, Object> loader =\n",
        "710": "        new CacheLoader<Object, Object>() {\n",
        "711": "          @Override\n",
        "712": "          public Object load(Object key) throws Exception {\n",
        "713": "            computingSignal.countDown();\n",
        "714": "            startSignal.await();\n",
        "715": "            return computedObject;\n",
        "716": "          }\n",
        "717": "        };\n",
        "720": "    CacheBuilder<Object, Object> builder =\n",
        "721": "        createCacheBuilder().concurrencyLevel(1).removalListener(listener);\n",
        "786": "    RemovalListener<Object, Object> listener =\n",
        "787": "        new RemovalListener<Object, Object>() {\n",
        "788": "          @Override\n",
        "789": "          public void onRemoval(RemovalNotification<Object, Object> notification) {\n",
        "790": "            throw e;\n",
        "791": "          }\n",
        "792": "        };\n",
        "810": "    final CacheLoader<Object, Object> loader =\n",
        "811": "        new CacheLoader<Object, Object>() {\n",
        "812": "          @Override\n",
        "813": "          public Object load(Object key) throws Exception {\n",
        "814": "            computingSignal.countDown();\n",
        "815": "            startSignal.await();\n",
        "816": "            return computedObject;\n",
        "817": "          }\n",
        "818": "        };\n",
        "862": "    LocalCache<Object, Object> map = makeLocalCache(createCacheBuilder().concurrencyLevel(1));\n",
        "883": "    LocalCache<Object, Object> map = makeLocalCache(createCacheBuilder().removalListener(listener));\n",
        "924": "    LocalCache<Object, Object> map = makeLocalCache(createCacheBuilder().removalListener(listener));\n",
        "951": "    LocalCache<Object, Object> map =\n",
        "952": "        makeLocalCache(\n",
        "953": "            createCacheBuilder().concurrencyLevel(1).softValues().removalListener(listener));\n",
        "976": "    LocalCache<Object, Object> map =\n",
        "977": "        makeLocalCache(\n",
        "978": "            createCacheBuilder()\n",
        "979": "                .concurrencyLevel(1)\n",
        "980": "                .expireAfterWrite(3, TimeUnit.NANOSECONDS)\n",
        "981": "                .ticker(ticker)\n",
        "982": "                .removalListener(listener));\n",
        "1006": "    LocalCache<Object, Object> map =\n",
        "1007": "        makeLocalCache(\n",
        "1008": "            createCacheBuilder().concurrencyLevel(1).maximumSize(2).removalListener(listener));\n",
        "1118": "    LocalCache<Object, Object> map =\n",
        "1119": "        makeLocalCache(\n",
        "1120": "            createCacheBuilder()\n",
        "1121": "                .concurrencyLevel(1)\n",
        "1122": "                .ticker(ticker)\n",
        "1123": "                .expireAfterAccess(1, TimeUnit.NANOSECONDS));\n",
        "1383": "    LocalCache<Object, Object> map =\n",
        "1384": "        makeLocalCache(createCacheBuilder().concurrencyLevel(1).removalListener(listener));\n",
        "1588": "        segment.get(\n",
        "1589": "            key,\n",
        "1590": "            key.hashCode(),\n",
        "1591": "            new CacheLoader<Object, Object>() {\n",
        "1592": "              @Override\n",
        "1593": "              public Object load(Object key) {\n",
        "1594": "                return value;\n",
        "1595": "              }\n",
        "1596": "            });\n",
        "1634": "    LocalCache<Object, Object> map =\n",
        "1635": "        makeLocalCache(\n",
        "1636": "            createCacheBuilder()\n",
        "1637": "                .concurrencyLevel(1)\n",
        "1638": "                .initialCapacity(1)\n",
        "1639": "                .maximumSize(SMALL_MAX_SIZE)\n",
        "1640": "                .expireAfterWrite(99999, SECONDS)\n",
        "1641": "                .removalListener(listener));\n",
        "1659": "        createDummyEntry(keyThree, hashThree, valueThree, entryTwo);\n",
        "1703": "        createDummyEntry(keyThree, hashThree, valueThree, entryTwo);\n",
        "1790": "    LocalCache<Object, Object> map =\n",
        "1791": "        makeLocalCache(\n",
        "1792": "            createCacheBuilder()\n",
        "1793": "                .concurrencyLevel(1)\n",
        "1794": "                .initialCapacity(1)\n",
        "1795": "                .maximumSize(SMALL_MAX_SIZE)\n",
        "1796": "                .expireAfterWrite(99999, SECONDS));\n",
        "1826": "    LocalCache<Object, Object> map =\n",
        "1827": "        makeLocalCache(\n",
        "1828": "            createCacheBuilder()\n",
        "1829": "                .concurrencyLevel(1)\n",
        "1830": "                .initialCapacity(1)\n",
        "1831": "                .maximumSize(SMALL_MAX_SIZE)\n",
        "1832": "                .expireAfterWrite(99999, SECONDS)\n",
        "1833": "                .removalListener(listener));\n",
        "1863": "    LocalCache<Object, Object> map =\n",
        "1864": "        makeLocalCache(\n",
        "1865": "            createCacheBuilder()\n",
        "1866": "                .concurrencyLevel(1)\n",
        "1867": "                .initialCapacity(1)\n",
        "1868": "                .maximumSize(SMALL_MAX_SIZE)\n",
        "1869": "                .expireAfterWrite(99999, SECONDS)\n",
        "1870": "                .removalListener(countingRemovalListener()));\n",
        "1897": "    CountingRemovalListener<Object, Object> listener = countingRemovalListener();\n",
        "1898": "    LocalCache<Object, Object> map =\n",
        "1899": "        makeLocalCache(\n",
        "1900": "            createCacheBuilder()\n",
        "1901": "                .concurrencyLevel(1)\n",
        "1902": "                .initialCapacity(1)\n",
        "1903": "                .maximumSize(SMALL_MAX_SIZE)\n",
        "1904": "                .expireAfterWrite(99999, SECONDS)\n",
        "1905": "                .removalListener(listener));\n",
        "1947": "    LocalCache<Object, Object> map =\n",
        "1948": "        makeLocalCache(\n",
        "1949": "            createCacheBuilder()\n",
        "1950": "                .concurrencyLevel(1)\n",
        "1951": "                .initialCapacity(1)\n",
        "1952": "                .maximumSize(SMALL_MAX_SIZE)\n",
        "1953": "                .expireAfterWrite(99999, SECONDS)\n",
        "1954": "                .removalListener(countingRemovalListener()));\n",
        "2197": "  static <K, V> void checkAndDrainRecencyQueue(\n",
        "2198": "      LocalCache<K, V> map, Segment<K, V> segment, List<ReferenceEntry<K, V>> reads) {\n",
        "2205": "  static <K, V> void checkEvictionQueues(\n",
        "2206": "      LocalCache<K, V> map,\n",
        "2207": "      Segment<K, V> segment,\n",
        "2208": "      List<ReferenceEntry<K, V>> readOrder,\n",
        "2218": "  private static <K, V> void assertSameEntries(\n",
        "2219": "      List<ReferenceEntry<K, V>> expectedEntries, List<ReferenceEntry<K, V>> actualEntries) {\n",
        "2264": "    LocalCache<Object, Object> map =\n",
        "2265": "        makeLocalCache(\n",
        "2266": "            createCacheBuilder()\n",
        "2267": "                .concurrencyLevel(1)\n",
        "2268": "                .ticker(ticker)\n",
        "2269": "                .expireAfterWrite(2, TimeUnit.NANOSECONDS));\n",
        "2305": "    LocalCache<Object, Object> map =\n",
        "2306": "        makeLocalCache(\n",
        "2307": "            createCacheBuilder()\n",
        "2308": "                .concurrencyLevel(1)\n",
        "2309": "                .ticker(ticker)\n",
        "2310": "                .expireAfterAccess(2, TimeUnit.NANOSECONDS));\n",
        "2402": "      LocalCache<Object, Object> map = makeLocalCache(builder.concurrencyLevel(1));\n",
        "2431": "      LocalCache<Object, Object> map = makeLocalCache(builder.concurrencyLevel(1));\n",
        "2461": "      LocalCache<Object, Object> map = makeLocalCache(builder.concurrencyLevel(1));\n",
        "2491": "      LocalCache<Object, Object> map = makeLocalCache(builder.concurrencyLevel(1));\n",
        "2533": "    LocalLoadingCache<Object, Object> one =\n",
        "2534": "        (LocalLoadingCache)\n",
        "2535": "            CacheBuilder.newBuilder()\n",
        "2536": "                .weakKeys()\n",
        "2537": "                .softValues()\n",
        "2538": "                .expireAfterAccess(123, SECONDS)\n",
        "2539": "                .expireAfterWrite(456, MINUTES)\n",
        "2540": "                .maximumWeight(789)\n",
        "2541": "                .weigher(weigher)\n",
        "2542": "                .concurrencyLevel(12)\n",
        "2543": "                .removalListener(listener)\n",
        "2544": "                .ticker(ticker)\n",
        "2545": "                .build(loader);\n",
        "2591": "    LocalManualCache<Object, Object> one =\n",
        "2592": "        (LocalManualCache)\n",
        "2593": "            CacheBuilder.newBuilder()\n",
        "2594": "                .weakKeys()\n",
        "2595": "                .softValues()\n",
        "2596": "                .expireAfterAccess(123, NANOSECONDS)\n",
        "2597": "                .maximumWeight(789)\n",
        "2598": "                .weigher(weigher)\n",
        "2599": "                .concurrencyLevel(12)\n",
        "2600": "                .removalListener(listener)\n",
        "2601": "                .ticker(ticker)\n",
        "2602": "                .build();\n",
        "2649": "    List<CacheBuilder<Object, Object>> result = newArrayList(allKeyValueStrengthMakers());\n",
        "2668": "  /** Returns an iterable containing all combinations of maximumSize and expireAfterAccess/Write. */\n",
        "2671": "    return ImmutableList.of(\n",
        "2672": "        createCacheBuilder().maximumSize(SMALL_MAX_SIZE),\n",
        "2683": "  /** Returns an iterable containing all combinations weakKeys and weak/softValues. */\n",
        "2686": "    return ImmutableList.of(\n",
        "2687": "        createCacheBuilder(),\n",
        "2892": "  private static class SerializableCacheLoader extends CacheLoader<Object, Object>\n",
        "2893": "      implements Serializable {\n"
    },
    "removed": {
        "80": "/**\n",
        "81": " * @author Charles Fry\n",
        "82": " */\n",
        "105": "    suite.addTest(ConcurrentMapTestSuiteBuilder\n",
        "106": "        .using(new TestStringCacheGenerator(createCacheBuilder()))\n",
        "107": "        .named(\"LocalCache with defaults\")\n",
        "108": "        .withFeatures(CollectionSize.ANY, MapFeature.GENERAL_PURPOSE,\n",
        "109": "            CollectionFeature.SUPPORTS_ITERATOR_REMOVE)\n",
        "110": "        .createTestSuite());\n",
        "111": "    suite.addTest(ConcurrentMapTestSuiteBuilder\n",
        "112": "        .using(new TestStringCacheGenerator(\n",
        "113": "            createCacheBuilder().concurrencyLevel(1)))\n",
        "114": "        .named(\"LocalCache with concurrencyLevel[1]\")\n",
        "115": "        .withFeatures(CollectionSize.ANY, MapFeature.GENERAL_PURPOSE,\n",
        "116": "            CollectionFeature.SUPPORTS_ITERATOR_REMOVE)\n",
        "117": "        .createTestSuite());\n",
        "118": "    suite.addTest(ConcurrentMapTestSuiteBuilder\n",
        "119": "        .using(new TestStringCacheGenerator(\n",
        "120": "            createCacheBuilder().maximumSize(Integer.MAX_VALUE)))\n",
        "121": "        .named(\"LocalCache with maximumSize\")\n",
        "122": "        .withFeatures(CollectionSize.ANY, MapFeature.GENERAL_PURPOSE,\n",
        "123": "            CollectionFeature.SUPPORTS_ITERATOR_REMOVE)\n",
        "124": "        .createTestSuite());\n",
        "125": "    suite.addTest(ConcurrentMapTestSuiteBuilder\n",
        "126": "        .using(new TestStringCacheGenerator(\n",
        "127": "            createCacheBuilder()\n",
        "128": "                .maximumWeight(Integer.MAX_VALUE)\n",
        "129": "                .weigher(new SerializableWeigher<String, String>())))\n",
        "130": "        .named(\"LocalCache with maximumWeight\")\n",
        "131": "        .withFeatures(CollectionSize.ANY, MapFeature.GENERAL_PURPOSE,\n",
        "132": "            CollectionFeature.SUPPORTS_ITERATOR_REMOVE)\n",
        "133": "        .createTestSuite());\n",
        "134": "    suite.addTest(ConcurrentMapTestSuiteBuilder\n",
        "135": "        .using(new TestStringCacheGenerator(\n",
        "136": "            createCacheBuilder().weakKeys()))\n",
        "137": "        .named(\"LocalCache with weakKeys\") // keys are string literals and won't be GC'd\n",
        "138": "        .withFeatures(CollectionSize.ANY, MapFeature.GENERAL_PURPOSE,\n",
        "139": "            CollectionFeature.SUPPORTS_ITERATOR_REMOVE)\n",
        "140": "        .createTestSuite());\n",
        "141": "    suite.addTest(ConcurrentMapTestSuiteBuilder\n",
        "142": "        .using(new TestStringCacheGenerator(\n",
        "143": "            createCacheBuilder().weakValues()))\n",
        "144": "        .named(\"LocalCache with weakValues\") // values are string literals and won't be GC'd\n",
        "145": "        .withFeatures(CollectionSize.ANY, MapFeature.GENERAL_PURPOSE,\n",
        "146": "            CollectionFeature.SUPPORTS_ITERATOR_REMOVE)\n",
        "147": "        .createTestSuite());\n",
        "148": "    suite.addTest(ConcurrentMapTestSuiteBuilder\n",
        "149": "        .using(new TestStringCacheGenerator(\n",
        "150": "            createCacheBuilder().softValues()))\n",
        "151": "        .named(\"LocalCache with softValues\") // values are string literals and won't be GC'd\n",
        "152": "        .withFeatures(CollectionSize.ANY, MapFeature.GENERAL_PURPOSE,\n",
        "153": "            CollectionFeature.SUPPORTS_ITERATOR_REMOVE)\n",
        "154": "        .createTestSuite());\n",
        "155": "    suite.addTest(ConcurrentMapTestSuiteBuilder\n",
        "156": "        .using(new TestStringCacheGenerator(\n",
        "157": "            createCacheBuilder().expireAfterAccess(1, SECONDS).ticker(new SerializableTicker())))\n",
        "158": "        .named(\"LocalCache with expireAfterAccess\") // SerializableTicker never advances\n",
        "159": "        .withFeatures(CollectionSize.ANY, MapFeature.GENERAL_PURPOSE,\n",
        "160": "            CollectionFeature.SUPPORTS_ITERATOR_REMOVE)\n",
        "161": "        .createTestSuite());\n",
        "162": "    suite.addTest(ConcurrentMapTestSuiteBuilder\n",
        "163": "        .using(new TestStringCacheGenerator(\n",
        "164": "            createCacheBuilder().expireAfterWrite(1, SECONDS).ticker(new SerializableTicker())))\n",
        "165": "        .named(\"LocalCache with expireAfterWrite\") // SerializableTicker never advances\n",
        "166": "        .withFeatures(CollectionSize.ANY, MapFeature.GENERAL_PURPOSE,\n",
        "167": "            CollectionFeature.SUPPORTS_ITERATOR_REMOVE)\n",
        "168": "        .createTestSuite());\n",
        "169": "    suite.addTest(ConcurrentMapTestSuiteBuilder\n",
        "170": "        .using(new TestStringCacheGenerator(\n",
        "171": "            createCacheBuilder()\n",
        "172": "                .removalListener(new SerializableRemovalListener<String, String>())))\n",
        "173": "        .named(\"LocalCache with removalListener\")\n",
        "174": "        .withFeatures(CollectionSize.ANY, MapFeature.GENERAL_PURPOSE,\n",
        "175": "            CollectionFeature.SUPPORTS_ITERATOR_REMOVE)\n",
        "176": "        .createTestSuite());\n",
        "177": "    suite.addTest(ConcurrentMapTestSuiteBuilder\n",
        "178": "        .using(new TestStringCacheGenerator(createCacheBuilder().recordStats()))\n",
        "179": "        .named(\"LocalCache with recordStats\")\n",
        "180": "        .withFeatures(CollectionSize.ANY, MapFeature.GENERAL_PURPOSE,\n",
        "181": "            CollectionFeature.SUPPORTS_ITERATOR_REMOVE)\n",
        "182": "        .createTestSuite());\n",
        "263": "    Equivalence<Object> testEquivalence = new Equivalence<Object>() {\n",
        "264": "      @Override\n",
        "265": "      protected boolean doEquivalent(Object a, Object b) {\n",
        "266": "        return false;\n",
        "267": "      }\n",
        "269": "      @Override\n",
        "270": "      protected int doHash(Object t) {\n",
        "271": "        return 0;\n",
        "272": "      }\n",
        "273": "    };\n",
        "282": "    Equivalence<Object> testEquivalence = new Equivalence<Object>() {\n",
        "283": "      @Override\n",
        "284": "      protected boolean doEquivalent(Object a, Object b) {\n",
        "285": "        return false;\n",
        "286": "      }\n",
        "288": "      @Override\n",
        "289": "      protected int doHash(Object t) {\n",
        "290": "        return 0;\n",
        "291": "      }\n",
        "292": "    };\n",
        "355": "    LocalCache<Object, Object> map = makeLocalCache(\n",
        "356": "        createCacheBuilder().concurrencyLevel(concurrencyLevel).initialCapacity(initialCapacity));\n",
        "388": "    LocalCache<Object, Object> map = makeLocalCache(createCacheBuilder()\n",
        "389": "        .concurrencyLevel(concurrencyLevel)\n",
        "390": "        .initialCapacity(initialCapacity)\n",
        "391": "        .maximumSize(maxSize));\n",
        "393": "    assertTrue(\"segments=\" + map.segments.length + \", maxSize=\" + maxSize,\n",
        "400": "    map = makeLocalCache(createCacheBuilder()\n",
        "401": "        .concurrencyLevel(concurrencyLevel)\n",
        "402": "        .initialCapacity(initialCapacity)\n",
        "403": "        .maximumWeight(maxSize)\n",
        "404": "        .weigher(constantWeigher(1)));\n",
        "405": "    assertTrue(\"segments=\" + map.segments.length + \", maxSize=\" + maxSize,\n",
        "415": "    Weigher<Object, Object> testWeigher = new Weigher<Object, Object>() {\n",
        "416": "      @Override\n",
        "417": "      public int weigh(Object key, Object value) {\n",
        "418": "        return 42;\n",
        "419": "      }\n",
        "420": "    };\n",
        "484": "    Ticker testTicker = new Ticker() {\n",
        "485": "      @Override\n",
        "486": "      public long read() {\n",
        "487": "        return 0;\n",
        "488": "      }\n",
        "489": "    };\n",
        "495": "    assertSame(EntryFactory.STRONG,\n",
        "496": "        EntryFactory.getFactory(Strength.STRONG, false, false));\n",
        "497": "    assertSame(EntryFactory.STRONG_ACCESS,\n",
        "498": "        EntryFactory.getFactory(Strength.STRONG, true, false));\n",
        "499": "    assertSame(EntryFactory.STRONG_WRITE,\n",
        "500": "        EntryFactory.getFactory(Strength.STRONG, false, true));\n",
        "501": "    assertSame(EntryFactory.STRONG_ACCESS_WRITE,\n",
        "502": "        EntryFactory.getFactory(Strength.STRONG, true, true));\n",
        "503": "    assertSame(EntryFactory.WEAK,\n",
        "504": "        EntryFactory.getFactory(Strength.WEAK, false, false));\n",
        "505": "    assertSame(EntryFactory.WEAK_ACCESS,\n",
        "506": "        EntryFactory.getFactory(Strength.WEAK, true, false));\n",
        "507": "    assertSame(EntryFactory.WEAK_WRITE,\n",
        "508": "        EntryFactory.getFactory(Strength.WEAK, false, true));\n",
        "509": "    assertSame(EntryFactory.WEAK_ACCESS_WRITE,\n",
        "510": "        EntryFactory.getFactory(Strength.WEAK, true, true));\n",
        "530": "      LocalCache<Object, Object> map =\n",
        "531": "          makeLocalCache(builder.concurrencyLevel(1));\n",
        "644": "    CacheBuilder<Object, Object> builder = createCacheBuilder()\n",
        "645": "        .expireAfterWrite(1, TimeUnit.NANOSECONDS);\n",
        "675": "    final CacheLoader<Object, Object> loader = new CacheLoader<Object, Object>() {\n",
        "676": "      @Override\n",
        "677": "      public Object load(Object key) throws Exception {\n",
        "678": "        computingSignal.countDown();\n",
        "679": "        startSignal.await();\n",
        "680": "        return computedObject;\n",
        "681": "      }\n",
        "682": "    };\n",
        "685": "    CacheBuilder<Object, Object> builder = createCacheBuilder()\n",
        "686": "        .concurrencyLevel(1)\n",
        "687": "        .removalListener(listener);\n",
        "752": "    RemovalListener<Object, Object> listener = new RemovalListener<Object, Object>() {\n",
        "753": "      @Override\n",
        "754": "      public void onRemoval(RemovalNotification<Object, Object> notification) {\n",
        "755": "        throw e;\n",
        "756": "      }\n",
        "757": "    };\n",
        "775": "    final CacheLoader<Object, Object> loader = new CacheLoader<Object, Object>() {\n",
        "776": "      @Override\n",
        "777": "      public Object load(Object key) throws Exception {\n",
        "778": "        computingSignal.countDown();\n",
        "779": "        startSignal.await();\n",
        "780": "        return computedObject;\n",
        "781": "      }\n",
        "782": "    };\n",
        "826": "    LocalCache<Object, Object> map = makeLocalCache(createCacheBuilder()\n",
        "827": "        .concurrencyLevel(1));\n",
        "848": "    LocalCache<Object, Object> map = makeLocalCache(createCacheBuilder()\n",
        "849": "        .removalListener(listener));\n",
        "890": "    LocalCache<Object, Object> map = makeLocalCache(createCacheBuilder()\n",
        "891": "        .removalListener(listener));\n",
        "918": "    LocalCache<Object, Object> map = makeLocalCache(createCacheBuilder()\n",
        "919": "        .concurrencyLevel(1)\n",
        "920": "        .softValues()\n",
        "921": "        .removalListener(listener));\n",
        "944": "    LocalCache<Object, Object> map = makeLocalCache(createCacheBuilder()\n",
        "945": "        .concurrencyLevel(1)\n",
        "946": "        .expireAfterWrite(3, TimeUnit.NANOSECONDS)\n",
        "947": "        .ticker(ticker)\n",
        "948": "        .removalListener(listener));\n",
        "972": "    LocalCache<Object, Object> map = makeLocalCache(createCacheBuilder()\n",
        "973": "        .concurrencyLevel(1)\n",
        "974": "        .maximumSize(2)\n",
        "975": "        .removalListener(listener));\n",
        "1085": "    LocalCache<Object, Object> map = makeLocalCache(createCacheBuilder()\n",
        "1086": "        .concurrencyLevel(1)\n",
        "1087": "        .ticker(ticker)\n",
        "1088": "        .expireAfterAccess(1, TimeUnit.NANOSECONDS));\n",
        "1348": "    LocalCache<Object, Object> map = makeLocalCache(createCacheBuilder()\n",
        "1349": "        .concurrencyLevel(1)\n",
        "1350": "        .removalListener(listener));\n",
        "1554": "        segment.get(key, key.hashCode(), new CacheLoader<Object, Object>() {\n",
        "1555": "          @Override\n",
        "1556": "          public Object load(Object key) {\n",
        "1557": "            return value;\n",
        "1558": "          }\n",
        "1559": "        });\n",
        "1597": "    LocalCache<Object, Object> map = makeLocalCache(createCacheBuilder()\n",
        "1598": "        .concurrencyLevel(1)\n",
        "1599": "        .initialCapacity(1)\n",
        "1600": "        .maximumSize(SMALL_MAX_SIZE)\n",
        "1601": "        .expireAfterWrite(99999, SECONDS)\n",
        "1602": "        .removalListener(listener));\n",
        "1620": "      createDummyEntry(keyThree, hashThree, valueThree, entryTwo);\n",
        "1664": "      createDummyEntry(keyThree, hashThree, valueThree, entryTwo);\n",
        "1751": "    LocalCache<Object, Object> map = makeLocalCache(createCacheBuilder()\n",
        "1752": "        .concurrencyLevel(1)\n",
        "1753": "        .initialCapacity(1)\n",
        "1754": "        .maximumSize(SMALL_MAX_SIZE)\n",
        "1755": "        .expireAfterWrite(99999, SECONDS));\n",
        "1785": "    LocalCache<Object, Object> map = makeLocalCache(createCacheBuilder()\n",
        "1786": "        .concurrencyLevel(1)\n",
        "1787": "        .initialCapacity(1)\n",
        "1788": "        .maximumSize(SMALL_MAX_SIZE)\n",
        "1789": "        .expireAfterWrite(99999, SECONDS)\n",
        "1790": "        .removalListener(listener));\n",
        "1820": "    LocalCache<Object, Object> map = makeLocalCache(createCacheBuilder()\n",
        "1821": "        .concurrencyLevel(1)\n",
        "1822": "        .initialCapacity(1)\n",
        "1823": "        .maximumSize(SMALL_MAX_SIZE)\n",
        "1824": "        .expireAfterWrite(99999, SECONDS)\n",
        "1825": "        .removalListener(countingRemovalListener()));\n",
        "1852": "    CountingRemovalListener<Object, Object> listener =\n",
        "1853": "        countingRemovalListener();\n",
        "1854": "    LocalCache<Object, Object> map = makeLocalCache(createCacheBuilder()\n",
        "1855": "        .concurrencyLevel(1)\n",
        "1856": "        .initialCapacity(1)\n",
        "1857": "        .maximumSize(SMALL_MAX_SIZE)\n",
        "1858": "        .expireAfterWrite(99999, SECONDS)\n",
        "1859": "        .removalListener(listener));\n",
        "1901": "    LocalCache<Object, Object> map = makeLocalCache(createCacheBuilder()\n",
        "1902": "        .concurrencyLevel(1)\n",
        "1903": "        .initialCapacity(1)\n",
        "1904": "        .maximumSize(SMALL_MAX_SIZE)\n",
        "1905": "        .expireAfterWrite(99999, SECONDS)\n",
        "1906": "        .removalListener(countingRemovalListener()));\n",
        "2149": "  static <K, V> void checkAndDrainRecencyQueue(LocalCache<K, V> map,\n",
        "2150": "      Segment<K, V> segment, List<ReferenceEntry<K, V>> reads) {\n",
        "2157": "  static <K, V> void checkEvictionQueues(LocalCache<K, V> map,\n",
        "2158": "      Segment<K, V> segment, List<ReferenceEntry<K, V>> readOrder,\n",
        "2168": "  private static <K, V> void assertSameEntries(List<ReferenceEntry<K, V>> expectedEntries,\n",
        "2169": "      List<ReferenceEntry<K, V>> actualEntries) {\n",
        "2214": "    LocalCache<Object, Object> map = makeLocalCache(createCacheBuilder()\n",
        "2215": "        .concurrencyLevel(1)\n",
        "2216": "        .ticker(ticker)\n",
        "2217": "        .expireAfterWrite(2, TimeUnit.NANOSECONDS));\n",
        "2253": "    LocalCache<Object, Object> map = makeLocalCache(createCacheBuilder()\n",
        "2254": "        .concurrencyLevel(1)\n",
        "2255": "        .ticker(ticker)\n",
        "2256": "        .expireAfterAccess(2, TimeUnit.NANOSECONDS));\n",
        "2348": "      LocalCache<Object, Object> map =\n",
        "2349": "          makeLocalCache(builder.concurrencyLevel(1));\n",
        "2378": "      LocalCache<Object, Object> map =\n",
        "2379": "          makeLocalCache(builder.concurrencyLevel(1));\n",
        "2409": "      LocalCache<Object, Object> map =\n",
        "2410": "          makeLocalCache(builder.concurrencyLevel(1));\n",
        "2440": "      LocalCache<Object, Object> map =\n",
        "2441": "          makeLocalCache(builder.concurrencyLevel(1));\n",
        "2483": "    LocalLoadingCache<Object, Object> one = (LocalLoadingCache) CacheBuilder.newBuilder()\n",
        "2484": "        .weakKeys()\n",
        "2485": "        .softValues()\n",
        "2486": "        .expireAfterAccess(123, SECONDS)\n",
        "2487": "        .expireAfterWrite(456, MINUTES)\n",
        "2488": "        .maximumWeight(789)\n",
        "2489": "        .weigher(weigher)\n",
        "2490": "        .concurrencyLevel(12)\n",
        "2491": "        .removalListener(listener)\n",
        "2492": "        .ticker(ticker)\n",
        "2493": "        .build(loader);\n",
        "2539": "    LocalManualCache<Object, Object> one = (LocalManualCache) CacheBuilder.newBuilder()\n",
        "2540": "        .weakKeys()\n",
        "2541": "        .softValues()\n",
        "2542": "        .expireAfterAccess(123, NANOSECONDS)\n",
        "2543": "        .maximumWeight(789)\n",
        "2544": "        .weigher(weigher)\n",
        "2545": "        .concurrencyLevel(12)\n",
        "2546": "        .removalListener(listener)\n",
        "2547": "        .ticker(ticker)\n",
        "2548": "        .build();\n",
        "2595": "    List<CacheBuilder<Object, Object>> result =\n",
        "2596": "        newArrayList(allKeyValueStrengthMakers());\n",
        "2615": "  /**\n",
        "2616": "   * Returns an iterable containing all combinations of maximumSize and expireAfterAccess/Write.\n",
        "2617": "   */\n",
        "2620": "    return ImmutableList.of(createCacheBuilder().maximumSize(SMALL_MAX_SIZE),\n",
        "2631": "  /**\n",
        "2632": "   * Returns an iterable containing all combinations weakKeys and weak/softValues.\n",
        "2633": "   */\n",
        "2636": "    return ImmutableList.of(createCacheBuilder(),\n",
        "2841": "  private static class SerializableCacheLoader\n",
        "2842": "      extends CacheLoader<Object, Object> implements Serializable {\n"
    }
}