[{"func":{"oldfunccode":"","newfunccode":"d0dc9ce896df6299de427063fa69bd348937ef1f/Codes/Match_newfunccode_d0dc9ce896df6299de427063fa69bd348937ef1f_1.txt","newdoc":"","newJdoc":"","olddoc":"","oldJdoc":"","path":"/home/pritish/Documents/IP work/guv_ver/v28.1/d0dc9ce896df6299de427063fa69bd348937ef1f/AbstractGraph","pathinproj":"guava/src/com/google/common/graph/AbstractGraph.java","addlines":[192,193,194,195,196,197,198,153,154,155,156,157,158,159,160,161,162,163,164,165,166,107,108,109,110,111,112,113,114,115,116,117,118,119,120,185,186,187,188,189,190,191],"dellines":[],"addcode":["  @Override\n","  public final boolean equals(@Nullable Object obj) {\n","    if (obj == this) {\n","      return true;\n","    }\n","    if (!(obj instanceof Graph)) {\n","      return false;\n","    }\n","    Graph<?> other = (Graph<?>) obj;\n","\n","    return isDirected() == other.isDirected()\n","        && nodes().equals(other.nodes())\n","        && edges().equals(other.edges());\n","  }\n","  @Override\n","  public final boolean equals(@Nullable Object obj) {\n","    if (obj == this) {\n","      return true;\n","    }\n","    if (!(obj instanceof Network)) {\n","      return false;\n","    }\n","    Network<?, ?> other = (Network<?, ?>) obj;\n","\n","    return isDirected() == other.isDirected()\n","        && nodes().equals(other.nodes())\n","        && edgeIncidentNodesMap(this).equals(edgeIncidentNodesMap(other));\n","  }\n","  @Override\n","  public final boolean equals(@Nullable Object obj) {\n","    if (obj == this) {\n","      return true;\n","    }\n","    if (!(obj instanceof ValueGraph)) {\n","      return false;\n","    }\n","    ValueGraph<?, ?> other = (ValueGraph<?, ?>) obj;\n","\n","    return isDirected() == other.isDirected()\n","        && nodes().equals(other.nodes())\n","        && edgeValueMap(this).equals(edgeValueMap(other));\n","  }\n"],"delcode":[],"methodSig":"public final boolean equals(@Nullable Object obj)"},"doc":{"oldfunccode":"d0dc9ce896df6299de427063fa69bd348937ef1f/Codes/Match_olddocfunccode_d0dc9ce896df6299de427063fa69bd348937ef1f_1.txt","newfunccode":"d0dc9ce896df6299de427063fa69bd348937ef1f/Codes/Match_newdocfunccode_d0dc9ce896df6299de427063fa69bd348937ef1f_1.txt","newdoc":"","newJdoc":"d0dc9ce896df6299de427063fa69bd348937ef1f/Codes/Match_newdocnewJdoc_d0dc9ce896df6299de427063fa69bd348937ef1f_1.txt","olddoc":"","oldJdoc":"d0dc9ce896df6299de427063fa69bd348937ef1f/Codes/Match_olddocJdoc_d0dc9ce896df6299de427063fa69bd348937ef1f_1.txt","path":"/home/pritish/Documents/IP work/guv_ver/v28.1/d0dc9ce896df6299de427063fa69bd348937ef1f/Network","pathinproj":"guava/src/com/google/common/graph/Network.java","addlines":[256,257,258,259,291,292,294,295,296,297,298,299,300,301,302,303,304,305,306,307,308,210,211,213,214,215,216,217,218,219,220,221,222,223,224,225,226,242,243,245,246,247,248,249,250,251,252,253,254,255],"dellines":[291,292,293,295,296,242,210,243,211,244,212,246,214,247,215],"addcode":["   * Returns {@code true} iff {@code object} is a {@link Network} that has the same elements and the\n","   * same structural relationships as those in this network.\n","   * <p>Thus, two networks A and B are equal if <b>all</b> of the following are true:\n","   *\n","   * <ul>\n","   * <li>A and B have equal {@link #isDirected() directedness}.\n","   * <li>A and B have equal {@link #nodes() node sets}.\n","   * <li>A and B have equal {@link #edges() edge sets}.\n","   * <li>Every edge in A and B connects the same nodes in the same direction (if any).\n","   * </ul>\n","   *\n","   * <p>Network properties besides {@link #isDirected() directedness} do <b>not</b> affect equality.\n","   * For example, two networks may be considered equal even if one allows parallel edges and the\n","   * other doesn't. Additionally, the order in which nodes or edges are added to the network, and\n","   * the order in which they are iterated over, are irrelevant.\n","   *\n","   * <p>A reference implementation of this is provided by {@link AbstractNetwork#equals(Object)}.\n","   * Returns {@code true} iff {@code object} is a {@link ValueGraph} that has the same elements and\n","   * the same structural relationships as those in this graph.\n","   * <p>Thus, two value graphs A and B are equal if <b>all</b> of the following are true:\n","   *\n","   * <ul>\n","   * <li>A and B have equal {@link #isDirected() directedness}.\n","   * <li>A and B have equal {@link #nodes() node sets}.\n","   * <li>A and B have equal {@link #edges() edge sets}.\n","   * <li>Every edge in A and B are associated with equal {@link #edgeValue(Object, Object) values}.\n","   * </ul>\n","   *\n","   * <p>Graph properties besides {@link #isDirected() directedness} do <b>not</b> affect equality.\n","   * For example, two graphs may be considered equal even if one allows self-loops and the other\n","   * doesn't. Additionally, the order in which nodes or edges are added to the graph, and the order\n","   * in which they are iterated over, are irrelevant.\n","   *\n","   * <p>A reference implementation of this is provided by {@link AbstractValueGraph#equals(Object)}.\n","   * Returns {@code true} iff {@code object} is a {@link Graph} that has the same elements and the\n","   * same structural relationships as those in this graph.\n","   * <p>Thus, two graphs A and B are equal if <b>all</b> of the following are true:\n","   *\n","   * <ul>\n","   * <li>A and B have equal {@link #isDirected() directedness}.\n","   * <li>A and B have equal {@link #nodes() node sets}.\n","   * <li>A and B have equal {@link #edges() edge sets}.\n","   * </ul>\n","   *\n","   * <p>Graph properties besides {@link #isDirected() directedness} do <b>not</b> affect equality.\n","   * For example, two graphs may be considered equal even if one allows self-loops and the other\n","   * doesn't. Additionally, the order in which nodes or edges are added to the graph, and the order\n","   * in which they are iterated over, are irrelevant.\n","   *\n","   * <p>A reference implementation of this is provided by {@link AbstractGraph#equals(Object)}.\n"],"delcode":["   * For the default {@link Network} implementations, returns true if {@code this == object}\n","   * (reference equality). External implementations are free to define this method as they see fit,\n","   * as long as they satisfy the {@link Object#equals(Object)} contract.\n","   * <p>To compare two {@link Network}s based on their contents rather than their references, see\n","   * {@link Graphs#equivalent(Network, Network)}.\n","   * For the default {@link ValueGraph} implementations, returns true if {@code this == object}\n","   * (reference equality). External implementations are free to define this method as they see fit,\n","   * as long as they satisfy the {@link Object#equals(Object)} contract.\n","   * <p>To compare two {@link ValueGraph}s based on their contents rather than their references, see\n","   * {@link Graphs#equivalent(ValueGraph, ValueGraph)}.\n","   * For the default {@link Graph} implementations, returns true if {@code this == object}\n","   * (reference equality). External implementations are free to define this method as they see fit,\n","   * as long as they satisfy the {@link Object#equals(Object)} contract.\n","   * <p>To compare two {@link Graph}s based on their contents rather than their references, see\n","   * {@link Graphs#equivalent(Graph, Graph)}.\n"],"methodSig":" boolean equals(@Nullable Object object)"},"id":3,"flag":1,"commit":"d0dc9ce896df6299de427063fa69bd348937ef1f"},{"func":{"oldfunccode":"d0dc9ce896df6299de427063fa69bd348937ef1f/Codes/Match_oldfunccode_d0dc9ce896df6299de427063fa69bd348937ef1f_2.txt","newfunccode":"d0dc9ce896df6299de427063fa69bd348937ef1f/Codes/Match_newfunccode_d0dc9ce896df6299de427063fa69bd348937ef1f_2.txt","newdoc":"","newJdoc":"d0dc9ce896df6299de427063fa69bd348937ef1f/Codes/Match_newfuncnewJdoc_d0dc9ce896df6299de427063fa69bd348937ef1f_2.txt","olddoc":"","oldJdoc":"d0dc9ce896df6299de427063fa69bd348937ef1f/Codes/Match_oldfuncoldJdoc_d0dc9ce896df6299de427063fa69bd348937ef1f_2.txt","path":"/home/pritish/Documents/IP work/guv_ver/v28.1/d0dc9ce896df6299de427063fa69bd348937ef1f/AbstractNetwork","pathinproj":"guava/src/com/google/common/graph/AbstractNetwork.java","addlines":[210,180,181],"dellines":[160,190],"addcode":["    return String.format(\n","        GRAPH_STRING_FORMAT, propertiesString, nodes(), edgeIncidentNodesMap(this));\n","    return String.format(GRAPH_STRING_FORMAT, propertiesString, nodes(), edgeValueMap(this));\n"],"delcode":["    return String.format(GRAPH_STRING_FORMAT, propertiesString, nodes(), edgeIncidentNodesMap());\n","    return String.format(GRAPH_STRING_FORMAT, propertiesString, nodes(), edgeValueMap());\n"],"methodSig":"public String toString()"},"doc":{"oldfunccode":"d0dc9ce896df6299de427063fa69bd348937ef1f/Codes/Match_olddocfunccode_d0dc9ce896df6299de427063fa69bd348937ef1f_2.txt","newfunccode":"d0dc9ce896df6299de427063fa69bd348937ef1f/Codes/Match_newdocfunccode_d0dc9ce896df6299de427063fa69bd348937ef1f_2.txt","newdoc":"","newJdoc":"d0dc9ce896df6299de427063fa69bd348937ef1f/Codes/Match_newdocnewJdoc_d0dc9ce896df6299de427063fa69bd348937ef1f_2.txt","olddoc":"","oldJdoc":"d0dc9ce896df6299de427063fa69bd348937ef1f/Codes/Match_olddocJdoc_d0dc9ce896df6299de427063fa69bd348937ef1f_2.txt","path":"/home/pritish/Documents/IP work/guv_ver/v28.1/d0dc9ce896df6299de427063fa69bd348937ef1f/Network","pathinproj":"guava/src/com/google/common/graph/Network.java","addlines":[256,257,258,259,291,292,294,295,296,297,298,299,300,301,302,303,304,305,306,307,308,210,211,213,214,215,216,217,218,219,220,221,222,223,224,225,226,242,243,245,246,247,248,249,250,251,252,253,254,255],"dellines":[291,292,293,295,296,242,210,243,211,244,212,246,214,247,215],"addcode":["   * Returns {@code true} iff {@code object} is a {@link Network} that has the same elements and the\n","   * same structural relationships as those in this network.\n","   * <p>Thus, two networks A and B are equal if <b>all</b> of the following are true:\n","   *\n","   * <ul>\n","   * <li>A and B have equal {@link #isDirected() directedness}.\n","   * <li>A and B have equal {@link #nodes() node sets}.\n","   * <li>A and B have equal {@link #edges() edge sets}.\n","   * <li>Every edge in A and B connects the same nodes in the same direction (if any).\n","   * </ul>\n","   *\n","   * <p>Network properties besides {@link #isDirected() directedness} do <b>not</b> affect equality.\n","   * For example, two networks may be considered equal even if one allows parallel edges and the\n","   * other doesn't. Additionally, the order in which nodes or edges are added to the network, and\n","   * the order in which they are iterated over, are irrelevant.\n","   *\n","   * <p>A reference implementation of this is provided by {@link AbstractNetwork#equals(Object)}.\n","   * Returns {@code true} iff {@code object} is a {@link ValueGraph} that has the same elements and\n","   * the same structural relationships as those in this graph.\n","   * <p>Thus, two value graphs A and B are equal if <b>all</b> of the following are true:\n","   *\n","   * <ul>\n","   * <li>A and B have equal {@link #isDirected() directedness}.\n","   * <li>A and B have equal {@link #nodes() node sets}.\n","   * <li>A and B have equal {@link #edges() edge sets}.\n","   * <li>Every edge in A and B are associated with equal {@link #edgeValue(Object, Object) values}.\n","   * </ul>\n","   *\n","   * <p>Graph properties besides {@link #isDirected() directedness} do <b>not</b> affect equality.\n","   * For example, two graphs may be considered equal even if one allows self-loops and the other\n","   * doesn't. Additionally, the order in which nodes or edges are added to the graph, and the order\n","   * in which they are iterated over, are irrelevant.\n","   *\n","   * <p>A reference implementation of this is provided by {@link AbstractValueGraph#equals(Object)}.\n","   * Returns {@code true} iff {@code object} is a {@link Graph} that has the same elements and the\n","   * same structural relationships as those in this graph.\n","   * <p>Thus, two graphs A and B are equal if <b>all</b> of the following are true:\n","   *\n","   * <ul>\n","   * <li>A and B have equal {@link #isDirected() directedness}.\n","   * <li>A and B have equal {@link #nodes() node sets}.\n","   * <li>A and B have equal {@link #edges() edge sets}.\n","   * </ul>\n","   *\n","   * <p>Graph properties besides {@link #isDirected() directedness} do <b>not</b> affect equality.\n","   * For example, two graphs may be considered equal even if one allows self-loops and the other\n","   * doesn't. Additionally, the order in which nodes or edges are added to the graph, and the order\n","   * in which they are iterated over, are irrelevant.\n","   *\n","   * <p>A reference implementation of this is provided by {@link AbstractGraph#equals(Object)}.\n"],"delcode":["   * For the default {@link Network} implementations, returns true if {@code this == object}\n","   * (reference equality). External implementations are free to define this method as they see fit,\n","   * as long as they satisfy the {@link Object#equals(Object)} contract.\n","   * <p>To compare two {@link Network}s based on their contents rather than their references, see\n","   * {@link Graphs#equivalent(Network, Network)}.\n","   * For the default {@link ValueGraph} implementations, returns true if {@code this == object}\n","   * (reference equality). External implementations are free to define this method as they see fit,\n","   * as long as they satisfy the {@link Object#equals(Object)} contract.\n","   * <p>To compare two {@link ValueGraph}s based on their contents rather than their references, see\n","   * {@link Graphs#equivalent(ValueGraph, ValueGraph)}.\n","   * For the default {@link Graph} implementations, returns true if {@code this == object}\n","   * (reference equality). External implementations are free to define this method as they see fit,\n","   * as long as they satisfy the {@link Object#equals(Object)} contract.\n","   * <p>To compare two {@link Graph}s based on their contents rather than their references, see\n","   * {@link Graphs#equivalent(Graph, Graph)}.\n"],"methodSig":" boolean equals(@Nullable Object object)"},"id":3,"flag":1,"commit":"d0dc9ce896df6299de427063fa69bd348937ef1f"},{"func":{"oldfunccode":"","newfunccode":"d0dc9ce896df6299de427063fa69bd348937ef1f/Codes/Match_newfunccode_d0dc9ce896df6299de427063fa69bd348937ef1f_3.txt","newdoc":"","newJdoc":"","olddoc":"","oldJdoc":"","path":"/home/pritish/Documents/IP work/guv_ver/v28.1/d0dc9ce896df6299de427063fa69bd348937ef1f/AbstractNetwork","pathinproj":"guava/src/com/google/common/graph/AbstractNetwork.java","addlines":[192,184,189],"dellines":[],"addcode":["  private static <N, E> Map<E, EndpointPair<N>> edgeIncidentNodesMap(final Network<N, E> network) {\n","            return network.incidentNodes(edge);\n","    return Maps.asMap(network.edges(), edgeToIncidentNodesFn);\n"],"delcode":[],"methodSig":"private static Map<E, EndpointPair<N>> edgeIncidentNodesMap(final Network<N, E> network)"},"doc":{"oldfunccode":"d0dc9ce896df6299de427063fa69bd348937ef1f/Codes/Match_olddocfunccode_d0dc9ce896df6299de427063fa69bd348937ef1f_3.txt","newfunccode":"d0dc9ce896df6299de427063fa69bd348937ef1f/Codes/Match_newdocfunccode_d0dc9ce896df6299de427063fa69bd348937ef1f_3.txt","newdoc":"","newJdoc":"d0dc9ce896df6299de427063fa69bd348937ef1f/Codes/Match_newdocnewJdoc_d0dc9ce896df6299de427063fa69bd348937ef1f_3.txt","olddoc":"","oldJdoc":"d0dc9ce896df6299de427063fa69bd348937ef1f/Codes/Match_olddocJdoc_d0dc9ce896df6299de427063fa69bd348937ef1f_3.txt","path":"/home/pritish/Documents/IP work/guv_ver/v28.1/d0dc9ce896df6299de427063fa69bd348937ef1f/Network","pathinproj":"guava/src/com/google/common/graph/Network.java","addlines":[256,257,258,259,291,292,294,295,296,297,298,299,300,301,302,303,304,305,306,307,308,210,211,213,214,215,216,217,218,219,220,221,222,223,224,225,226,242,243,245,246,247,248,249,250,251,252,253,254,255],"dellines":[291,292,293,295,296,242,210,243,211,244,212,246,214,247,215],"addcode":["   * Returns {@code true} iff {@code object} is a {@link Network} that has the same elements and the\n","   * same structural relationships as those in this network.\n","   * <p>Thus, two networks A and B are equal if <b>all</b> of the following are true:\n","   *\n","   * <ul>\n","   * <li>A and B have equal {@link #isDirected() directedness}.\n","   * <li>A and B have equal {@link #nodes() node sets}.\n","   * <li>A and B have equal {@link #edges() edge sets}.\n","   * <li>Every edge in A and B connects the same nodes in the same direction (if any).\n","   * </ul>\n","   *\n","   * <p>Network properties besides {@link #isDirected() directedness} do <b>not</b> affect equality.\n","   * For example, two networks may be considered equal even if one allows parallel edges and the\n","   * other doesn't. Additionally, the order in which nodes or edges are added to the network, and\n","   * the order in which they are iterated over, are irrelevant.\n","   *\n","   * <p>A reference implementation of this is provided by {@link AbstractNetwork#equals(Object)}.\n","   * Returns {@code true} iff {@code object} is a {@link ValueGraph} that has the same elements and\n","   * the same structural relationships as those in this graph.\n","   * <p>Thus, two value graphs A and B are equal if <b>all</b> of the following are true:\n","   *\n","   * <ul>\n","   * <li>A and B have equal {@link #isDirected() directedness}.\n","   * <li>A and B have equal {@link #nodes() node sets}.\n","   * <li>A and B have equal {@link #edges() edge sets}.\n","   * <li>Every edge in A and B are associated with equal {@link #edgeValue(Object, Object) values}.\n","   * </ul>\n","   *\n","   * <p>Graph properties besides {@link #isDirected() directedness} do <b>not</b> affect equality.\n","   * For example, two graphs may be considered equal even if one allows self-loops and the other\n","   * doesn't. Additionally, the order in which nodes or edges are added to the graph, and the order\n","   * in which they are iterated over, are irrelevant.\n","   *\n","   * <p>A reference implementation of this is provided by {@link AbstractValueGraph#equals(Object)}.\n","   * Returns {@code true} iff {@code object} is a {@link Graph} that has the same elements and the\n","   * same structural relationships as those in this graph.\n","   * <p>Thus, two graphs A and B are equal if <b>all</b> of the following are true:\n","   *\n","   * <ul>\n","   * <li>A and B have equal {@link #isDirected() directedness}.\n","   * <li>A and B have equal {@link #nodes() node sets}.\n","   * <li>A and B have equal {@link #edges() edge sets}.\n","   * </ul>\n","   *\n","   * <p>Graph properties besides {@link #isDirected() directedness} do <b>not</b> affect equality.\n","   * For example, two graphs may be considered equal even if one allows self-loops and the other\n","   * doesn't. Additionally, the order in which nodes or edges are added to the graph, and the order\n","   * in which they are iterated over, are irrelevant.\n","   *\n","   * <p>A reference implementation of this is provided by {@link AbstractGraph#equals(Object)}.\n"],"delcode":["   * For the default {@link Network} implementations, returns true if {@code this == object}\n","   * (reference equality). External implementations are free to define this method as they see fit,\n","   * as long as they satisfy the {@link Object#equals(Object)} contract.\n","   * <p>To compare two {@link Network}s based on their contents rather than their references, see\n","   * {@link Graphs#equivalent(Network, Network)}.\n","   * For the default {@link ValueGraph} implementations, returns true if {@code this == object}\n","   * (reference equality). External implementations are free to define this method as they see fit,\n","   * as long as they satisfy the {@link Object#equals(Object)} contract.\n","   * <p>To compare two {@link ValueGraph}s based on their contents rather than their references, see\n","   * {@link Graphs#equivalent(ValueGraph, ValueGraph)}.\n","   * For the default {@link Graph} implementations, returns true if {@code this == object}\n","   * (reference equality). External implementations are free to define this method as they see fit,\n","   * as long as they satisfy the {@link Object#equals(Object)} contract.\n","   * <p>To compare two {@link Graph}s based on their contents rather than their references, see\n","   * {@link Graphs#equivalent(Graph, Graph)}.\n"],"methodSig":" boolean equals(@Nullable Object object)"},"id":3,"flag":1,"commit":"d0dc9ce896df6299de427063fa69bd348937ef1f"},{"func":{"oldfunccode":"d0dc9ce896df6299de427063fa69bd348937ef1f/Codes/Match_oldfunccode_d0dc9ce896df6299de427063fa69bd348937ef1f_4.txt","newfunccode":"","newdoc":"","newJdoc":"","olddoc":"","oldJdoc":"","path":"/home/pritish/Documents/IP work/guv_ver/v28.1/d0dc9ce896df6299de427063fa69bd348937ef1f/AbstractValueGraph","pathinproj":"guava/src/com/google/common/graph/AbstractValueGraph.java","addlines":[],"dellines":[193,198,201],"addcode":[],"delcode":["  private Map<EndpointPair<N>, V> edgeValueMap() {\n","            return edgeValue(edge.nodeU(), edge.nodeV());\n","    return Maps.asMap(edges(), edgeToValueFn);\n"],"methodSig":"private Map<EndpointPair<N>, V> edgeValueMap()"},"doc":{"oldfunccode":"d0dc9ce896df6299de427063fa69bd348937ef1f/Codes/Match_olddocfunccode_d0dc9ce896df6299de427063fa69bd348937ef1f_4.txt","newfunccode":"d0dc9ce896df6299de427063fa69bd348937ef1f/Codes/Match_newdocfunccode_d0dc9ce896df6299de427063fa69bd348937ef1f_4.txt","newdoc":"","newJdoc":"d0dc9ce896df6299de427063fa69bd348937ef1f/Codes/Match_newdocnewJdoc_d0dc9ce896df6299de427063fa69bd348937ef1f_4.txt","olddoc":"","oldJdoc":"d0dc9ce896df6299de427063fa69bd348937ef1f/Codes/Match_olddocJdoc_d0dc9ce896df6299de427063fa69bd348937ef1f_4.txt","path":"/home/pritish/Documents/IP work/guv_ver/v28.1/d0dc9ce896df6299de427063fa69bd348937ef1f/Network","pathinproj":"guava/src/com/google/common/graph/Network.java","addlines":[256,257,258,259,291,292,294,295,296,297,298,299,300,301,302,303,304,305,306,307,308,210,211,213,214,215,216,217,218,219,220,221,222,223,224,225,226,242,243,245,246,247,248,249,250,251,252,253,254,255],"dellines":[291,292,293,295,296,242,210,243,211,244,212,246,214,247,215],"addcode":["   * Returns {@code true} iff {@code object} is a {@link Network} that has the same elements and the\n","   * same structural relationships as those in this network.\n","   * <p>Thus, two networks A and B are equal if <b>all</b> of the following are true:\n","   *\n","   * <ul>\n","   * <li>A and B have equal {@link #isDirected() directedness}.\n","   * <li>A and B have equal {@link #nodes() node sets}.\n","   * <li>A and B have equal {@link #edges() edge sets}.\n","   * <li>Every edge in A and B connects the same nodes in the same direction (if any).\n","   * </ul>\n","   *\n","   * <p>Network properties besides {@link #isDirected() directedness} do <b>not</b> affect equality.\n","   * For example, two networks may be considered equal even if one allows parallel edges and the\n","   * other doesn't. Additionally, the order in which nodes or edges are added to the network, and\n","   * the order in which they are iterated over, are irrelevant.\n","   *\n","   * <p>A reference implementation of this is provided by {@link AbstractNetwork#equals(Object)}.\n","   * Returns {@code true} iff {@code object} is a {@link ValueGraph} that has the same elements and\n","   * the same structural relationships as those in this graph.\n","   * <p>Thus, two value graphs A and B are equal if <b>all</b> of the following are true:\n","   *\n","   * <ul>\n","   * <li>A and B have equal {@link #isDirected() directedness}.\n","   * <li>A and B have equal {@link #nodes() node sets}.\n","   * <li>A and B have equal {@link #edges() edge sets}.\n","   * <li>Every edge in A and B are associated with equal {@link #edgeValue(Object, Object) values}.\n","   * </ul>\n","   *\n","   * <p>Graph properties besides {@link #isDirected() directedness} do <b>not</b> affect equality.\n","   * For example, two graphs may be considered equal even if one allows self-loops and the other\n","   * doesn't. Additionally, the order in which nodes or edges are added to the graph, and the order\n","   * in which they are iterated over, are irrelevant.\n","   *\n","   * <p>A reference implementation of this is provided by {@link AbstractValueGraph#equals(Object)}.\n","   * Returns {@code true} iff {@code object} is a {@link Graph} that has the same elements and the\n","   * same structural relationships as those in this graph.\n","   * <p>Thus, two graphs A and B are equal if <b>all</b> of the following are true:\n","   *\n","   * <ul>\n","   * <li>A and B have equal {@link #isDirected() directedness}.\n","   * <li>A and B have equal {@link #nodes() node sets}.\n","   * <li>A and B have equal {@link #edges() edge sets}.\n","   * </ul>\n","   *\n","   * <p>Graph properties besides {@link #isDirected() directedness} do <b>not</b> affect equality.\n","   * For example, two graphs may be considered equal even if one allows self-loops and the other\n","   * doesn't. Additionally, the order in which nodes or edges are added to the graph, and the order\n","   * in which they are iterated over, are irrelevant.\n","   *\n","   * <p>A reference implementation of this is provided by {@link AbstractGraph#equals(Object)}.\n"],"delcode":["   * For the default {@link Network} implementations, returns true if {@code this == object}\n","   * (reference equality). External implementations are free to define this method as they see fit,\n","   * as long as they satisfy the {@link Object#equals(Object)} contract.\n","   * <p>To compare two {@link Network}s based on their contents rather than their references, see\n","   * {@link Graphs#equivalent(Network, Network)}.\n","   * For the default {@link ValueGraph} implementations, returns true if {@code this == object}\n","   * (reference equality). External implementations are free to define this method as they see fit,\n","   * as long as they satisfy the {@link Object#equals(Object)} contract.\n","   * <p>To compare two {@link ValueGraph}s based on their contents rather than their references, see\n","   * {@link Graphs#equivalent(ValueGraph, ValueGraph)}.\n","   * For the default {@link Graph} implementations, returns true if {@code this == object}\n","   * (reference equality). External implementations are free to define this method as they see fit,\n","   * as long as they satisfy the {@link Object#equals(Object)} contract.\n","   * <p>To compare two {@link Graph}s based on their contents rather than their references, see\n","   * {@link Graphs#equivalent(Graph, Graph)}.\n"],"methodSig":" boolean equals(@Nullable Object object)"},"id":3,"flag":1,"commit":"d0dc9ce896df6299de427063fa69bd348937ef1f"},{"func":{"oldfunccode":"","newfunccode":"d0dc9ce896df6299de427063fa69bd348937ef1f/Codes/Match_newfunccode_d0dc9ce896df6299de427063fa69bd348937ef1f_5.txt","newdoc":"","newJdoc":"","olddoc":"","oldJdoc":"","path":"/home/pritish/Documents/IP work/guv_ver/v28.1/d0dc9ce896df6299de427063fa69bd348937ef1f/AbstractValueGraph","pathinproj":"guava/src/com/google/common/graph/AbstractValueGraph.java","addlines":[213,218,221],"dellines":[],"addcode":["  private static <N, V> Map<EndpointPair<N>, V> edgeValueMap(final ValueGraph<N, V> graph) {\n","            return graph.edgeValue(edge.nodeU(), edge.nodeV());\n","    return Maps.asMap(graph.edges(), edgeToValueFn);\n"],"delcode":[],"methodSig":"private static Map<EndpointPair<N>, V> edgeValueMap(final ValueGraph<N, V> graph)"},"doc":{"oldfunccode":"d0dc9ce896df6299de427063fa69bd348937ef1f/Codes/Match_olddocfunccode_d0dc9ce896df6299de427063fa69bd348937ef1f_5.txt","newfunccode":"d0dc9ce896df6299de427063fa69bd348937ef1f/Codes/Match_newdocfunccode_d0dc9ce896df6299de427063fa69bd348937ef1f_5.txt","newdoc":"","newJdoc":"d0dc9ce896df6299de427063fa69bd348937ef1f/Codes/Match_newdocnewJdoc_d0dc9ce896df6299de427063fa69bd348937ef1f_5.txt","olddoc":"","oldJdoc":"d0dc9ce896df6299de427063fa69bd348937ef1f/Codes/Match_olddocJdoc_d0dc9ce896df6299de427063fa69bd348937ef1f_5.txt","path":"/home/pritish/Documents/IP work/guv_ver/v28.1/d0dc9ce896df6299de427063fa69bd348937ef1f/Network","pathinproj":"guava/src/com/google/common/graph/Network.java","addlines":[256,257,258,259,291,292,294,295,296,297,298,299,300,301,302,303,304,305,306,307,308,210,211,213,214,215,216,217,218,219,220,221,222,223,224,225,226,242,243,245,246,247,248,249,250,251,252,253,254,255],"dellines":[291,292,293,295,296,242,210,243,211,244,212,246,214,247,215],"addcode":["   * Returns {@code true} iff {@code object} is a {@link Network} that has the same elements and the\n","   * same structural relationships as those in this network.\n","   * <p>Thus, two networks A and B are equal if <b>all</b> of the following are true:\n","   *\n","   * <ul>\n","   * <li>A and B have equal {@link #isDirected() directedness}.\n","   * <li>A and B have equal {@link #nodes() node sets}.\n","   * <li>A and B have equal {@link #edges() edge sets}.\n","   * <li>Every edge in A and B connects the same nodes in the same direction (if any).\n","   * </ul>\n","   *\n","   * <p>Network properties besides {@link #isDirected() directedness} do <b>not</b> affect equality.\n","   * For example, two networks may be considered equal even if one allows parallel edges and the\n","   * other doesn't. Additionally, the order in which nodes or edges are added to the network, and\n","   * the order in which they are iterated over, are irrelevant.\n","   *\n","   * <p>A reference implementation of this is provided by {@link AbstractNetwork#equals(Object)}.\n","   * Returns {@code true} iff {@code object} is a {@link ValueGraph} that has the same elements and\n","   * the same structural relationships as those in this graph.\n","   * <p>Thus, two value graphs A and B are equal if <b>all</b> of the following are true:\n","   *\n","   * <ul>\n","   * <li>A and B have equal {@link #isDirected() directedness}.\n","   * <li>A and B have equal {@link #nodes() node sets}.\n","   * <li>A and B have equal {@link #edges() edge sets}.\n","   * <li>Every edge in A and B are associated with equal {@link #edgeValue(Object, Object) values}.\n","   * </ul>\n","   *\n","   * <p>Graph properties besides {@link #isDirected() directedness} do <b>not</b> affect equality.\n","   * For example, two graphs may be considered equal even if one allows self-loops and the other\n","   * doesn't. Additionally, the order in which nodes or edges are added to the graph, and the order\n","   * in which they are iterated over, are irrelevant.\n","   *\n","   * <p>A reference implementation of this is provided by {@link AbstractValueGraph#equals(Object)}.\n","   * Returns {@code true} iff {@code object} is a {@link Graph} that has the same elements and the\n","   * same structural relationships as those in this graph.\n","   * <p>Thus, two graphs A and B are equal if <b>all</b> of the following are true:\n","   *\n","   * <ul>\n","   * <li>A and B have equal {@link #isDirected() directedness}.\n","   * <li>A and B have equal {@link #nodes() node sets}.\n","   * <li>A and B have equal {@link #edges() edge sets}.\n","   * </ul>\n","   *\n","   * <p>Graph properties besides {@link #isDirected() directedness} do <b>not</b> affect equality.\n","   * For example, two graphs may be considered equal even if one allows self-loops and the other\n","   * doesn't. Additionally, the order in which nodes or edges are added to the graph, and the order\n","   * in which they are iterated over, are irrelevant.\n","   *\n","   * <p>A reference implementation of this is provided by {@link AbstractGraph#equals(Object)}.\n"],"delcode":["   * For the default {@link Network} implementations, returns true if {@code this == object}\n","   * (reference equality). External implementations are free to define this method as they see fit,\n","   * as long as they satisfy the {@link Object#equals(Object)} contract.\n","   * <p>To compare two {@link Network}s based on their contents rather than their references, see\n","   * {@link Graphs#equivalent(Network, Network)}.\n","   * For the default {@link ValueGraph} implementations, returns true if {@code this == object}\n","   * (reference equality). External implementations are free to define this method as they see fit,\n","   * as long as they satisfy the {@link Object#equals(Object)} contract.\n","   * <p>To compare two {@link ValueGraph}s based on their contents rather than their references, see\n","   * {@link Graphs#equivalent(ValueGraph, ValueGraph)}.\n","   * For the default {@link Graph} implementations, returns true if {@code this == object}\n","   * (reference equality). External implementations are free to define this method as they see fit,\n","   * as long as they satisfy the {@link Object#equals(Object)} contract.\n","   * <p>To compare two {@link Graph}s based on their contents rather than their references, see\n","   * {@link Graphs#equivalent(Graph, Graph)}.\n"],"methodSig":" boolean equals(@Nullable Object object)"},"id":3,"flag":1,"commit":"d0dc9ce896df6299de427063fa69bd348937ef1f"},{"func":{"oldfunccode":"","newfunccode":"d0dc9ce896df6299de427063fa69bd348937ef1f/Codes/Match_newfunccode_d0dc9ce896df6299de427063fa69bd348937ef1f_6.txt","newdoc":"","newJdoc":"","olddoc":"","oldJdoc":"","path":"/home/pritish/Documents/IP work/guv_ver/v28.1/d0dc9ce896df6299de427063fa69bd348937ef1f/AbstractGraph","pathinproj":"guava/src/com/google/common/graph/AbstractGraph.java","addlines":[168,200,169,201,122,170,202,123,171,203,124,125],"dellines":[],"addcode":["  @Override\n","  public final int hashCode() {\n","    return edges().hashCode();\n","  }\n","  @Override\n","  public final int hashCode() {\n","    return edgeIncidentNodesMap(this).hashCode();\n","  }\n","  @Override\n","  public final int hashCode() {\n","    return edgeValueMap(this).hashCode();\n","  }\n"],"delcode":[],"methodSig":"public final int hashCode()"},"doc":{"oldfunccode":"d0dc9ce896df6299de427063fa69bd348937ef1f/Codes/Match_olddocfunccode_d0dc9ce896df6299de427063fa69bd348937ef1f_6.txt","newfunccode":"d0dc9ce896df6299de427063fa69bd348937ef1f/Codes/Match_newdocfunccode_d0dc9ce896df6299de427063fa69bd348937ef1f_6.txt","newdoc":"","newJdoc":"d0dc9ce896df6299de427063fa69bd348937ef1f/Codes/Match_newdocnewJdoc_d0dc9ce896df6299de427063fa69bd348937ef1f_6.txt","olddoc":"","oldJdoc":"d0dc9ce896df6299de427063fa69bd348937ef1f/Codes/Match_olddocJdoc_d0dc9ce896df6299de427063fa69bd348937ef1f_6.txt","path":"/home/pritish/Documents/IP work/guv_ver/v28.1/d0dc9ce896df6299de427063fa69bd348937ef1f/Network","pathinproj":"guava/src/com/google/common/graph/Network.java","addlines":[256,257,258,259,291,292,294,295,296,297,298,299,300,301,302,303,304,305,306,307,308,210,211,213,214,215,216,217,218,219,220,221,222,223,224,225,226,242,243,245,246,247,248,249,250,251,252,253,254,255],"dellines":[291,292,293,295,296,242,210,243,211,244,212,246,214,247,215],"addcode":["   * Returns {@code true} iff {@code object} is a {@link Network} that has the same elements and the\n","   * same structural relationships as those in this network.\n","   * <p>Thus, two networks A and B are equal if <b>all</b> of the following are true:\n","   *\n","   * <ul>\n","   * <li>A and B have equal {@link #isDirected() directedness}.\n","   * <li>A and B have equal {@link #nodes() node sets}.\n","   * <li>A and B have equal {@link #edges() edge sets}.\n","   * <li>Every edge in A and B connects the same nodes in the same direction (if any).\n","   * </ul>\n","   *\n","   * <p>Network properties besides {@link #isDirected() directedness} do <b>not</b> affect equality.\n","   * For example, two networks may be considered equal even if one allows parallel edges and the\n","   * other doesn't. Additionally, the order in which nodes or edges are added to the network, and\n","   * the order in which they are iterated over, are irrelevant.\n","   *\n","   * <p>A reference implementation of this is provided by {@link AbstractNetwork#equals(Object)}.\n","   * Returns {@code true} iff {@code object} is a {@link ValueGraph} that has the same elements and\n","   * the same structural relationships as those in this graph.\n","   * <p>Thus, two value graphs A and B are equal if <b>all</b> of the following are true:\n","   *\n","   * <ul>\n","   * <li>A and B have equal {@link #isDirected() directedness}.\n","   * <li>A and B have equal {@link #nodes() node sets}.\n","   * <li>A and B have equal {@link #edges() edge sets}.\n","   * <li>Every edge in A and B are associated with equal {@link #edgeValue(Object, Object) values}.\n","   * </ul>\n","   *\n","   * <p>Graph properties besides {@link #isDirected() directedness} do <b>not</b> affect equality.\n","   * For example, two graphs may be considered equal even if one allows self-loops and the other\n","   * doesn't. Additionally, the order in which nodes or edges are added to the graph, and the order\n","   * in which they are iterated over, are irrelevant.\n","   *\n","   * <p>A reference implementation of this is provided by {@link AbstractValueGraph#equals(Object)}.\n","   * Returns {@code true} iff {@code object} is a {@link Graph} that has the same elements and the\n","   * same structural relationships as those in this graph.\n","   * <p>Thus, two graphs A and B are equal if <b>all</b> of the following are true:\n","   *\n","   * <ul>\n","   * <li>A and B have equal {@link #isDirected() directedness}.\n","   * <li>A and B have equal {@link #nodes() node sets}.\n","   * <li>A and B have equal {@link #edges() edge sets}.\n","   * </ul>\n","   *\n","   * <p>Graph properties besides {@link #isDirected() directedness} do <b>not</b> affect equality.\n","   * For example, two graphs may be considered equal even if one allows self-loops and the other\n","   * doesn't. Additionally, the order in which nodes or edges are added to the graph, and the order\n","   * in which they are iterated over, are irrelevant.\n","   *\n","   * <p>A reference implementation of this is provided by {@link AbstractGraph#equals(Object)}.\n"],"delcode":["   * For the default {@link Network} implementations, returns true if {@code this == object}\n","   * (reference equality). External implementations are free to define this method as they see fit,\n","   * as long as they satisfy the {@link Object#equals(Object)} contract.\n","   * <p>To compare two {@link Network}s based on their contents rather than their references, see\n","   * {@link Graphs#equivalent(Network, Network)}.\n","   * For the default {@link ValueGraph} implementations, returns true if {@code this == object}\n","   * (reference equality). External implementations are free to define this method as they see fit,\n","   * as long as they satisfy the {@link Object#equals(Object)} contract.\n","   * <p>To compare two {@link ValueGraph}s based on their contents rather than their references, see\n","   * {@link Graphs#equivalent(ValueGraph, ValueGraph)}.\n","   * For the default {@link Graph} implementations, returns true if {@code this == object}\n","   * (reference equality). External implementations are free to define this method as they see fit,\n","   * as long as they satisfy the {@link Object#equals(Object)} contract.\n","   * <p>To compare two {@link Graph}s based on their contents rather than their references, see\n","   * {@link Graphs#equivalent(Graph, Graph)}.\n"],"methodSig":" boolean equals(@Nullable Object object)"},"id":3,"flag":1,"commit":"d0dc9ce896df6299de427063fa69bd348937ef1f"},{"func":{"oldfunccode":"d0dc9ce896df6299de427063fa69bd348937ef1f/Codes/Match_oldfunccode_d0dc9ce896df6299de427063fa69bd348937ef1f_7.txt","newfunccode":"","newdoc":"","newJdoc":"","olddoc":"","oldJdoc":"","path":"/home/pritish/Documents/IP work/guv_ver/v28.1/d0dc9ce896df6299de427063fa69bd348937ef1f/AbstractNetwork","pathinproj":"guava/src/com/google/common/graph/AbstractNetwork.java","addlines":[],"dellines":[163,168,171],"addcode":[],"delcode":["  private Map<E, EndpointPair<N>> edgeIncidentNodesMap() {\n","            return incidentNodes(edge);\n","    return Maps.asMap(edges(), edgeToIncidentNodesFn);\n"],"methodSig":"private Map<E, EndpointPair<N>> edgeIncidentNodesMap()"},"doc":{"oldfunccode":"d0dc9ce896df6299de427063fa69bd348937ef1f/Codes/Match_olddocfunccode_d0dc9ce896df6299de427063fa69bd348937ef1f_7.txt","newfunccode":"d0dc9ce896df6299de427063fa69bd348937ef1f/Codes/Match_newdocfunccode_d0dc9ce896df6299de427063fa69bd348937ef1f_7.txt","newdoc":"","newJdoc":"d0dc9ce896df6299de427063fa69bd348937ef1f/Codes/Match_newdocnewJdoc_d0dc9ce896df6299de427063fa69bd348937ef1f_7.txt","olddoc":"","oldJdoc":"d0dc9ce896df6299de427063fa69bd348937ef1f/Codes/Match_olddocJdoc_d0dc9ce896df6299de427063fa69bd348937ef1f_7.txt","path":"/home/pritish/Documents/IP work/guv_ver/v28.1/d0dc9ce896df6299de427063fa69bd348937ef1f/Network","pathinproj":"guava/src/com/google/common/graph/Network.java","addlines":[256,257,258,259,291,292,294,295,296,297,298,299,300,301,302,303,304,305,306,307,308,210,211,213,214,215,216,217,218,219,220,221,222,223,224,225,226,242,243,245,246,247,248,249,250,251,252,253,254,255],"dellines":[291,292,293,295,296,242,210,243,211,244,212,246,214,247,215],"addcode":["   * Returns {@code true} iff {@code object} is a {@link Network} that has the same elements and the\n","   * same structural relationships as those in this network.\n","   * <p>Thus, two networks A and B are equal if <b>all</b> of the following are true:\n","   *\n","   * <ul>\n","   * <li>A and B have equal {@link #isDirected() directedness}.\n","   * <li>A and B have equal {@link #nodes() node sets}.\n","   * <li>A and B have equal {@link #edges() edge sets}.\n","   * <li>Every edge in A and B connects the same nodes in the same direction (if any).\n","   * </ul>\n","   *\n","   * <p>Network properties besides {@link #isDirected() directedness} do <b>not</b> affect equality.\n","   * For example, two networks may be considered equal even if one allows parallel edges and the\n","   * other doesn't. Additionally, the order in which nodes or edges are added to the network, and\n","   * the order in which they are iterated over, are irrelevant.\n","   *\n","   * <p>A reference implementation of this is provided by {@link AbstractNetwork#equals(Object)}.\n","   * Returns {@code true} iff {@code object} is a {@link ValueGraph} that has the same elements and\n","   * the same structural relationships as those in this graph.\n","   * <p>Thus, two value graphs A and B are equal if <b>all</b> of the following are true:\n","   *\n","   * <ul>\n","   * <li>A and B have equal {@link #isDirected() directedness}.\n","   * <li>A and B have equal {@link #nodes() node sets}.\n","   * <li>A and B have equal {@link #edges() edge sets}.\n","   * <li>Every edge in A and B are associated with equal {@link #edgeValue(Object, Object) values}.\n","   * </ul>\n","   *\n","   * <p>Graph properties besides {@link #isDirected() directedness} do <b>not</b> affect equality.\n","   * For example, two graphs may be considered equal even if one allows self-loops and the other\n","   * doesn't. Additionally, the order in which nodes or edges are added to the graph, and the order\n","   * in which they are iterated over, are irrelevant.\n","   *\n","   * <p>A reference implementation of this is provided by {@link AbstractValueGraph#equals(Object)}.\n","   * Returns {@code true} iff {@code object} is a {@link Graph} that has the same elements and the\n","   * same structural relationships as those in this graph.\n","   * <p>Thus, two graphs A and B are equal if <b>all</b> of the following are true:\n","   *\n","   * <ul>\n","   * <li>A and B have equal {@link #isDirected() directedness}.\n","   * <li>A and B have equal {@link #nodes() node sets}.\n","   * <li>A and B have equal {@link #edges() edge sets}.\n","   * </ul>\n","   *\n","   * <p>Graph properties besides {@link #isDirected() directedness} do <b>not</b> affect equality.\n","   * For example, two graphs may be considered equal even if one allows self-loops and the other\n","   * doesn't. Additionally, the order in which nodes or edges are added to the graph, and the order\n","   * in which they are iterated over, are irrelevant.\n","   *\n","   * <p>A reference implementation of this is provided by {@link AbstractGraph#equals(Object)}.\n"],"delcode":["   * For the default {@link Network} implementations, returns true if {@code this == object}\n","   * (reference equality). External implementations are free to define this method as they see fit,\n","   * as long as they satisfy the {@link Object#equals(Object)} contract.\n","   * <p>To compare two {@link Network}s based on their contents rather than their references, see\n","   * {@link Graphs#equivalent(Network, Network)}.\n","   * For the default {@link ValueGraph} implementations, returns true if {@code this == object}\n","   * (reference equality). External implementations are free to define this method as they see fit,\n","   * as long as they satisfy the {@link Object#equals(Object)} contract.\n","   * <p>To compare two {@link ValueGraph}s based on their contents rather than their references, see\n","   * {@link Graphs#equivalent(ValueGraph, ValueGraph)}.\n","   * For the default {@link Graph} implementations, returns true if {@code this == object}\n","   * (reference equality). External implementations are free to define this method as they see fit,\n","   * as long as they satisfy the {@link Object#equals(Object)} contract.\n","   * <p>To compare two {@link Graph}s based on their contents rather than their references, see\n","   * {@link Graphs#equivalent(Graph, Graph)}.\n"],"methodSig":" boolean equals(@Nullable Object object)"},"id":3,"flag":1,"commit":"d0dc9ce896df6299de427063fa69bd348937ef1f"}]