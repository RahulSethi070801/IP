{"id": "d0dc9ce896df6299de427063fa69bd348937ef1f", "code": [{"0": "guava-tests/test/com/google/common/graph/GraphEquivalenceTest.java", "added": {"1": ["    assertThat(graph).isNotEqualTo(g2);\n"], "2": ["    assertThat(graph).isNotEqualTo(g2);\n"], "3": ["    assertThat(graph).isNotEqualTo(g2);\n"], "4": ["    assertThat(graph).isEqualTo(g2);\n"], "5": ["    assertThat(g1).isEqualTo(g2);\n"], "6": ["        assertThat(graph).isEqualTo(g2);\n", "        assertThat(graph).isNotEqualTo(g2);\n"]}, "removed": {"1": ["    assertThat(Graphs.equivalent(graph, g2)).isFalse();\n"], "2": ["    assertThat(Graphs.equivalent(graph, g2)).isFalse();\n"], "3": ["    assertThat(Graphs.equivalent(graph, g2)).isFalse();\n"], "4": ["    assertThat(Graphs.equivalent(graph, g2)).isTrue();\n"], "5": ["    assertThat(Graphs.equivalent(g1, g2)).isTrue();\n"], "6": ["        assertThat(Graphs.equivalent(graph, g2)).isTrue();\n", "        assertThat(Graphs.equivalent(graph, g2)).isFalse();\n"]}, "added_lines": {"1": [84], "2": [95], "3": [106], "4": [119], "5": [138], "6": [150, 153]}, "removed_lines": {"1": [84], "2": [95], "3": [106], "4": [119], "5": [138], "6": [150, 153]}}, {"1": "guava-tests/test/com/google/common/graph/GraphsTest.java", "added": {"1": ["    assertThat(transpose).isEqualTo(expectedTranspose);\n"], "2": ["    assertThat(transpose).isEqualTo(expectedTranspose);\n"], "3": ["    assertThat(transpose).isEqualTo(expectedTranspose);\n"], "4": ["    assertThat(inducedSubgraph(directedGraph, nodeSubset)).isEqualTo(expectedSubgraph);\n"], "5": ["    assertThat(inducedSubgraph(directedGraph, nodeSubset)).isEqualTo(expectedSubgraph);\n"], "6": ["    assertThat(inducedSubgraph(directedGraph, nodeSubset)).isEqualTo(expectedSubgraph);\n"], "7": ["    assertThat(copy).isEqualTo(directedGraph);\n"], "8": ["    assertThat(copy).isEqualTo(undirectedGraph);\n"], "9": ["    assertThat(copy).isEqualTo(directedGraph);\n"], "10": ["    assertThat(copy).isEqualTo(undirectedGraph);\n"], "11": ["    assertThat(copy).isEqualTo(directedGraph);\n"], "12": ["    assertThat(copy).isEqualTo(undirectedGraph);\n"], "13": ["    assertThat(transitiveClosure(originalGraph)).isEqualTo(expectedClosure);\n"]}, "removed": {"1": ["    assertThat(Graphs.equivalent(transpose, expectedTranspose)).isTrue();\n"], "2": ["    assertThat(Graphs.equivalent(transpose, expectedTranspose)).isTrue();\n"], "3": ["    assertThat(Graphs.equivalent(transpose, expectedTranspose)).isTrue();\n"], "4": ["    assertThat(Graphs.equivalent(inducedSubgraph(directedGraph, nodeSubset), expectedSubgraph))\n", "        .isTrue();\n"], "5": ["    assertThat(Graphs.equivalent(inducedSubgraph(directedGraph, nodeSubset), expectedSubgraph))\n", "        .isTrue();\n"], "6": ["    assertThat(Graphs.equivalent(inducedSubgraph(directedGraph, nodeSubset), expectedSubgraph))\n", "        .isTrue();\n"], "7": ["    assertThat(Graphs.equivalent(copy, directedGraph)).isTrue();\n"], "8": ["    assertThat(Graphs.equivalent(copy, undirectedGraph)).isTrue();\n"], "9": ["    assertThat(Graphs.equivalent(copy, directedGraph)).isTrue();\n"], "10": ["    assertThat(Graphs.equivalent(copy, undirectedGraph)).isTrue();\n"], "11": ["    assertThat(Graphs.equivalent(copy, directedGraph)).isTrue();\n"], "12": ["    assertThat(Graphs.equivalent(copy, undirectedGraph)).isTrue();\n"], "13": ["    assertThat(Graphs.equivalent(transitiveClosure(originalGraph), expectedClosure)).isTrue();\n"]}, "added_lines": {"1": [229], "2": [267], "3": [307], "4": [334], "5": [355], "6": [376], "7": [404], "8": [412], "9": [420], "10": [428], "11": [436], "12": [444], "13": [588]}, "removed_lines": {"1": [229], "2": [267], "3": [307], "4": [334, 335], "5": [356, 357], "6": [378, 379], "7": [407], "8": [415], "9": [423], "10": [431], "11": [439], "12": [447], "13": [591]}}, {"2": "guava-tests/test/com/google/common/graph/ImmutableGraphTest.java", "added": {"1": ["    assertThat(immutableGraph).isEqualTo(mutableGraph);\n", "    assertThat(immutableGraph).isNotEqualTo(mutableGraph);\n"], "2": ["    assertThat(immutableValueGraph).isEqualTo(mutableValueGraph);\n", "    assertThat(immutableValueGraph).isNotEqualTo(mutableValueGraph);\n"]}, "removed": {"1": ["    assertThat(Graphs.equivalent(immutableGraph, mutableGraph)).isTrue();\n", "    assertThat(Graphs.equivalent(immutableGraph, mutableGraph)).isFalse();\n"], "2": ["    assertThat(Graphs.equivalent(immutableValueGraph, mutableValueGraph)).isTrue();\n", "    assertThat(Graphs.equivalent(immutableValueGraph, mutableValueGraph)).isFalse();\n"]}, "added_lines": {"1": [36, 39], "2": [51, 54]}, "removed_lines": {"1": [36, 39], "2": [51, 54]}}, {"3": "guava-tests/test/com/google/common/graph/ImmutableNetworkTest.java", "added": {"1": ["    assertThat(immutableNetwork).isEqualTo(mutableNetwork);\n", "    assertThat(immutableNetwork).isNotEqualTo(mutableNetwork);\n"]}, "removed": {"1": ["    assertThat(Graphs.equivalent(immutableNetwork, mutableNetwork)).isTrue();\n", "    assertThat(Graphs.equivalent(immutableNetwork, mutableNetwork)).isFalse();\n"]}, "added_lines": {"1": [37, 40]}, "removed_lines": {"1": [37, 40]}}, {"4": "guava-tests/test/com/google/common/graph/NetworkEquivalenceTest.java", "added": {"1": ["    assertThat(network).isNotEqualTo(g2);\n"], "2": ["    assertThat(network).isNotEqualTo(g2);\n"], "3": ["    assertThat(network).isNotEqualTo(g2);\n"], "4": ["    assertThat(network).isNotEqualTo(g2);\n"], "5": ["    assertThat(network).isNotEqualTo(g2);\n"], "6": ["    assertThat(network).isEqualTo(g2);\n"], "7": ["    assertThat(g1).isEqualTo(g2);\n"], "8": ["        assertThat(network).isEqualTo(g2);\n", "        assertThat(network).isNotEqualTo(g2);\n"]}, "removed": {"1": ["    assertThat(Graphs.equivalent(network, g2)).isFalse();\n"], "2": ["    assertThat(Graphs.equivalent(network, g2)).isFalse();\n"], "3": ["    assertThat(Graphs.equivalent(network, g2)).isFalse();\n"], "4": ["    assertThat(Graphs.equivalent(network, g2)).isFalse();\n"], "5": ["    assertThat(Graphs.equivalent(network, g2)).isFalse();\n"], "6": ["    assertThat(Graphs.equivalent(network, g2)).isTrue();\n"], "7": ["    assertThat(Graphs.equivalent(g1, g2)).isTrue();\n"], "8": ["        assertThat(Graphs.equivalent(network, g2)).isTrue();\n", "        assertThat(Graphs.equivalent(network, g2)).isFalse();\n"]}, "added_lines": {"1": [89], "2": [100], "3": [111], "4": [122], "5": [136], "6": [152], "7": [172], "8": [184, 187]}, "removed_lines": {"1": [89], "2": [100], "3": [111], "4": [122], "5": [136], "6": [152], "7": [172], "8": [184, 187]}}, {"5": "guava-tests/test/com/google/common/graph/TestUtil.java", "added": {"1": ["    // Properties not covered by equals()\n", "    assertThat(graphA).isEqualTo(graphB);\n", "    // Properties not covered by equals()\n", "    assertThat(graphA).isEqualTo(graphB);\n", "    // Properties not covered by equals()\n", "    assertThat(networkA).isEqualTo(networkB);\n"]}, "removed": {"1": ["    // Properties not covered by Graphs.equivalent()\n", "    assertThat(Graphs.equivalent(graphA, graphB)).isTrue();\n", "    // Properties not covered by Graphs.equivalent()\n", "    assertThat(Graphs.equivalent(graphA, graphB)).isTrue();\n", "    // Properties not covered by Graphs.equivalent()\n", "    assertThat(Graphs.equivalent(networkA, networkB)).isTrue();\n"]}, "added_lines": {"1": [32, 36, 40, 44, 48, 54]}, "removed_lines": {"1": [32, 36, 40, 44, 48, 54]}}, {"6": "guava-tests/test/com/google/common/graph/ValueGraphTest.java", "added": {"1": ["    assertThat(graph).isEqualTo(otherGraph);\n", "    assertThat(graph).isNotEqualTo(otherGraph); // values differ\n"]}, "removed": {"1": ["    assertThat(Graphs.equivalent(graph, otherGraph)).isTrue();\n", "    assertThat(Graphs.equivalent(graph, otherGraph)).isFalse(); // values differ\n"]}, "added_lines": {"1": [190, 193]}, "removed_lines": {"1": [190, 193]}}, {"7": "guava/src/com/google/common/graph/AbstractGraph.java", "added": {"1": ["  @Override\n", "  public final boolean equals(@Nullable Object obj) {\n", "    if (obj == this) {\n", "      return true;\n", "    }\n", "    if (!(obj instanceof Graph)) {\n", "      return false;\n", "    }\n", "    Graph<?> other = (Graph<?>) obj;\n", "\n", "    return isDirected() == other.isDirected()\n", "        && nodes().equals(other.nodes())\n", "        && edges().equals(other.edges());\n", "  }\n", "\n", "  @Override\n", "  public final int hashCode() {\n", "    return edges().hashCode();\n", "  }\n", "\n"]}, "removed": {}, "added_lines": {"1": [107, 108, 109, 110, 111, 112, 113, 114, 115, 116, 117, 118, 119, 120, 121, 122, 123, 124, 125, 126]}, "removed_lines": {}}, {"8": "guava/src/com/google/common/graph/AbstractNetwork.java", "added": {"1": ["  @Override\n", "  public final boolean equals(@Nullable Object obj) {\n", "    if (obj == this) {\n", "      return true;\n", "    }\n", "    if (!(obj instanceof Network)) {\n", "      return false;\n", "    }\n", "    Network<?, ?> other = (Network<?, ?>) obj;\n", "\n", "    return isDirected() == other.isDirected()\n", "        && nodes().equals(other.nodes())\n", "        && edgeIncidentNodesMap(this).equals(edgeIncidentNodesMap(other));\n", "  }\n", "\n", "  @Override\n", "  public final int hashCode() {\n", "    return edgeIncidentNodesMap(this).hashCode();\n", "  }\n", "\n"], "2": ["    return String.format(\n", "        GRAPH_STRING_FORMAT, propertiesString, nodes(), edgeIncidentNodesMap(this));\n", "  private static <N, E> Map<E, EndpointPair<N>> edgeIncidentNodesMap(final Network<N, E> network) {\n", "            return network.incidentNodes(edge);\n", "    return Maps.asMap(network.edges(), edgeToIncidentNodesFn);\n"]}, "removed": {"2": ["    return String.format(GRAPH_STRING_FORMAT, propertiesString, nodes(), edgeIncidentNodesMap());\n", "  private Map<E, EndpointPair<N>> edgeIncidentNodesMap() {\n", "            return incidentNodes(edge);\n", "    return Maps.asMap(edges(), edgeToIncidentNodesFn);\n"]}, "added_lines": {"1": [153, 154, 155, 156, 157, 158, 159, 160, 161, 162, 163, 164, 165, 166, 167, 168, 169, 170, 171, 172], "2": [180, 181, 184, 189, 192]}, "removed_lines": {"2": [160, 163, 168, 171]}}, {"9": "guava/src/com/google/common/graph/AbstractValueGraph.java", "added": {"1": ["  @Override\n", "  public final boolean equals(@Nullable Object obj) {\n", "    if (obj == this) {\n", "      return true;\n", "    }\n", "    if (!(obj instanceof ValueGraph)) {\n", "      return false;\n", "    }\n", "    ValueGraph<?, ?> other = (ValueGraph<?, ?>) obj;\n", "\n", "    return isDirected() == other.isDirected()\n", "        && nodes().equals(other.nodes())\n", "        && edgeValueMap(this).equals(edgeValueMap(other));\n", "  }\n", "\n", "  @Override\n", "  public final int hashCode() {\n", "    return edgeValueMap(this).hashCode();\n", "  }\n", "\n", "    return String.format(GRAPH_STRING_FORMAT, propertiesString, nodes(), edgeValueMap(this));\n", "  private static <N, V> Map<EndpointPair<N>, V> edgeValueMap(final ValueGraph<N, V> graph) {\n", "            return graph.edgeValue(edge.nodeU(), edge.nodeV());\n", "    return Maps.asMap(graph.edges(), edgeToValueFn);\n"]}, "removed": {"1": ["    return String.format(GRAPH_STRING_FORMAT, propertiesString, nodes(), edgeValueMap());\n", "  private Map<EndpointPair<N>, V> edgeValueMap() {\n", "            return edgeValue(edge.nodeU(), edge.nodeV());\n", "    return Maps.asMap(edges(), edgeToValueFn);\n"]}, "added_lines": {"1": [185, 186, 187, 188, 189, 190, 191, 192, 193, 194, 195, 196, 197, 198, 199, 200, 201, 202, 203, 204, 210, 213, 218, 221]}, "removed_lines": {"1": [190, 193, 198, 201]}}, {"10": "guava/src/com/google/common/graph/Graph.java", "added": {"1": ["   * Returns {@code true} iff {@code object} is a {@link Graph} that has the same elements and the\n", "   * same structural relationships as those in this graph.\n", "   * <p>Thus, two graphs A and B are equal if <b>all</b> of the following are true:\n", "   *\n", "   * <ul>\n", "   * <li>A and B have equal {@link #isDirected() directedness}.\n", "   * <li>A and B have equal {@link #nodes() node sets}.\n", "   * <li>A and B have equal {@link #edges() edge sets}.\n", "   * </ul>\n", "   *\n", "   * <p>Graph properties besides {@link #isDirected() directedness} do <b>not</b> affect equality.\n", "   * For example, two graphs may be considered equal even if one allows self-loops and the other\n", "   * doesn't. Additionally, the order in which nodes or edges are added to the graph, and the order\n", "   * in which they are iterated over, are irrelevant.\n", "   *\n", "   * <p>A reference implementation of this is provided by {@link AbstractGraph#equals(Object)}.\n", "   * Returns the hash code for this graph. The hash code of a graph is defined as the hash code of\n", "   * the set returned by {@link #edges()}.\n", "   *\n", "   * <p>A reference implementation of this is provided by {@link AbstractGraph#hashCode()}.\n"]}, "removed": {"1": ["   * For the default {@link Graph} implementations, returns true if {@code this == object}\n", "   * (reference equality). External implementations are free to define this method as they see fit,\n", "   * as long as they satisfy the {@link Object#equals(Object)} contract.\n", "   * <p>To compare two {@link Graph}s based on their contents rather than their references, see\n", "   * {@link Graphs#equivalent(Graph, Graph)}.\n", "   * For the default {@link Graph} implementations, returns {@code System.identityHashCode(this)}.\n", "   * External implementations are free to define this method as they see fit, as long as they\n", "   * satisfy the {@link Object#hashCode()} contract.\n"]}, "added_lines": {"1": [210, 211, 213, 214, 215, 216, 217, 218, 219, 220, 221, 222, 223, 224, 225, 226, 232, 233, 234, 235]}, "removed_lines": {"1": [210, 211, 212, 214, 215, 221, 222, 223]}}, {"11": "guava/src/com/google/common/graph/Graphs.java", "added": {"1": ["   * @deprecated Use {@link Graph#equals(Object)} instead. This method will be removed in late 2017.\n", "  // TODO(user): Delete this method.\n", "  @Deprecated\n", "    return Objects.equal(graphA, graphB);\n", "   * @deprecated Use {@link ValueGraph#equals(Object)} instead. This method will be removed in late\n", "   * 2017.\n", "  // TODO(user): Delete this method.\n", "  @Deprecated\n", "    return Objects.equal(graphA, graphB);\n", "   * @deprecated Use {@link Network#equals(Object)} instead. This method will be removed in late\n", "   * 2017.\n", "  // TODO(user): Delete this method.\n", "  @Deprecated\n", "    return Objects.equal(networkA, networkB);\n"]}, "removed": {"1": ["   * Returns {@code true} if {@code graphA} and {@code graphB} have the same elements and the same\n", "   * relationships between elements, as exposed via the {@link Graph} interface.\n", "   *\n", "   * <p>Thus, two graphs A and B are equivalent if both are null or <b>all</b> of the following are\n", "   * true:\n", "   *\n", "   * <ul>\n", "   * <li>A and B have equal {@link Graph#isDirected() directedness}.\n", "   * <li>A and B have equal {@link Graph#nodes() node sets}.\n", "   * <li>A and B have equal {@link Graph#edges() edge sets}.\n", "   * </ul>\n", "   *\n", "   * <p>Graph properties besides {@link Graph#isDirected() directedness} do <b>not</b> affect\n", "   * equivalence. For example, two graphs may be considered equivalent even if one allows self-loops\n", "   * and the other doesn't. Additionally, the order in which nodes or edges are added to the graph,\n", "   * and the order in which they are iterated over, are irrelevant.\n", "    if (graphA == graphB) {\n", "      return true;\n", "    }\n", "    if (graphA == null || graphB == null) {\n", "      return false;\n", "    }\n", "\n", "    return graphA.isDirected() == graphB.isDirected()\n", "        && graphA.nodes().equals(graphB.nodes())\n", "        && graphA.edges().equals(graphB.edges());\n", "   * Returns {@code true} if {@code graphA} and {@code graphB} have the same elements (including\n", "   * edge values) and the same relationships between elements, as exposed via the {@link ValueGraph}\n", "   * interface.\n", "   *\n", "   * <p>Thus, two value graphs A and B are equivalent if both are null or <b>all</b> of the\n", "   * following are true:\n", "   *\n", "   * <ul>\n", "   * <li>A and B have equal {@link Graph#isDirected() directedness}.\n", "   * <li>A and B have equal {@link Graph#nodes() node sets}.\n", "   * <li>A and B have equal {@link Graph#edges() edge sets}.\n", "   * <li>Each edge in A has a {@link ValueGraph#edgeValue(Object, Object) value} equal to the {@link\n", "   *     ValueGraph#edgeValue(Object, Object) value} of the corresponding edge in B.\n", "   * </ul>\n", "   *\n", "   * <p>Graph properties besides {@link Graph#isDirected() directedness} do <b>not</b> affect\n", "   * equivalence. For example, two graphs may be considered equivalent even if one allows self-loops\n", "   * and the other doesn't. Additionally, the order in which nodes or edges are added to the graph,\n", "   * and the order in which they are iterated over, are irrelevant.\n", "    if (graphA == graphB) {\n", "      return true;\n", "    }\n", "    if (graphA == null || graphB == null) {\n", "      return false;\n", "    }\n", "\n", "    if (graphA.isDirected() != graphB.isDirected()\n", "        || !graphA.nodes().equals(graphB.nodes())\n", "        || !graphA.edges().equals(graphB.edges())) {\n", "      return false;\n", "    }\n", "\n", "    for (EndpointPair<?> edge : graphA.edges()) {\n", "      if (!graphA\n", "          .edgeValue(edge.nodeU(), edge.nodeV())\n", "          .equals(graphB.edgeValue(edge.nodeU(), edge.nodeV()))) {\n", "        return false;\n", "      }\n", "    }\n", "\n", "    return true;\n", "   * Returns {@code true} if {@code networkA} and {@code networkB} have the same elements and the\n", "   * same relationships between elements, as exposed via the {@link Network} interface.\n", "   *\n", "   * <p>Thus, two networks A and B are equivalent if both are null or <b>all</b> of the following\n", "   * are true:\n", "   *\n", "   * <ul>\n", "   * <li>A and B have equal {@link Network#isDirected() directedness}.\n", "   * <li>A and B have equal {@link Network#nodes() node sets}.\n", "   * <li>A and B have equal {@link Network#edges() edge sets}.\n", "   * <li>Each edge in A connects the same nodes in the same direction (if any) as the corresponding\n", "   *     edge in B.\n", "   * </ul>\n", "   *\n", "   * <p>Network properties besides {@link Network#isDirected() directedness} do <b>not</b> affect\n", "   * equivalence. For example, two networks may be considered equal even if one allows parallel\n", "   * edges and the other doesn't. Additionally, the order in which nodes or edges are added to the\n", "   * network, and the order in which they are iterated over, are irrelevant.\n", "    if (networkA == networkB) {\n", "      return true;\n", "    }\n", "    if (networkA == null || networkB == null) {\n", "      return false;\n", "    }\n", "\n", "    if (networkA.isDirected() != networkB.isDirected()\n", "        || !networkA.nodes().equals(networkB.nodes())\n", "        || !networkA.edges().equals(networkB.edges())) {\n", "      return false;\n", "    }\n", "\n", "    for (Object edge : networkA.edges()) {\n", "      if (!networkA.incidentNodes(edge).equals(networkB.incidentNodes(edge))) {\n", "        return false;\n", "      }\n", "    }\n", "\n", "    return true;\n"]}, "added_lines": {"1": [213, 215, 216, 218, 222, 223, 225, 226, 229, 233, 234, 236, 237, 240]}, "removed_lines": {"1": [213, 214, 215, 216, 217, 218, 219, 220, 221, 222, 223, 224, 225, 226, 227, 228, 231, 232, 233, 234, 235, 236, 237, 238, 239, 240, 244, 245, 246, 247, 248, 249, 250, 251, 252, 253, 254, 255, 256, 257, 258, 259, 260, 261, 262, 266, 267, 268, 269, 270, 271, 272, 273, 274, 275, 276, 277, 278, 279, 280, 281, 282, 283, 284, 285, 286, 287, 291, 292, 293, 294, 295, 296, 297, 298, 299, 300, 301, 302, 303, 304, 305, 306, 307, 308, 312, 313, 314, 315, 316, 317, 318, 319, 320, 321, 322, 323, 324, 325, 326, 327, 328, 329, 330, 331]}}, {"12": "guava/src/com/google/common/graph/Network.java", "added": {"1": ["   * Returns {@code true} iff {@code object} is a {@link Network} that has the same elements and the\n", "   * same structural relationships as those in this network.\n", "   * <p>Thus, two networks A and B are equal if <b>all</b> of the following are true:\n", "   *\n", "   * <ul>\n", "   * <li>A and B have equal {@link #isDirected() directedness}.\n", "   * <li>A and B have equal {@link #nodes() node sets}.\n", "   * <li>A and B have equal {@link #edges() edge sets}.\n", "   * <li>Every edge in A and B connects the same nodes in the same direction (if any).\n", "   * </ul>\n", "   *\n", "   * <p>Network properties besides {@link #isDirected() directedness} do <b>not</b> affect equality.\n", "   * For example, two networks may be considered equal even if one allows parallel edges and the\n", "   * other doesn't. Additionally, the order in which nodes or edges are added to the network, and\n", "   * the order in which they are iterated over, are irrelevant.\n", "   *\n", "   * <p>A reference implementation of this is provided by {@link AbstractNetwork#equals(Object)}.\n", "   * Returns the hash code for this network. The hash code of a network is defined as the hash code\n", "   * of a map from each of its {@link #edges() edges} to their {@link #incidentNodes(Object)\n", "   * incident nodes}.\n", "   *\n", "   * <p>A reference implementation of this is provided by {@link AbstractNetwork#hashCode()}.\n"]}, "removed": {"1": ["   * For the default {@link Network} implementations, returns true if {@code this == object}\n", "   * (reference equality). External implementations are free to define this method as they see fit,\n", "   * as long as they satisfy the {@link Object#equals(Object)} contract.\n", "   * <p>To compare two {@link Network}s based on their contents rather than their references, see\n", "   * {@link Graphs#equivalent(Network, Network)}.\n", "   * For the default {@link Network} implementations, returns {@code System.identityHashCode(this)}.\n", "   * External implementations are free to define this method as they see fit, as long as they\n", "   * satisfy the {@link Object#hashCode()} contract.\n"]}, "added_lines": {"1": [291, 292, 294, 295, 296, 297, 298, 299, 300, 301, 302, 303, 304, 305, 306, 307, 308, 314, 315, 316, 317, 318]}, "removed_lines": {"1": [291, 292, 293, 295, 296, 302, 303, 304]}}, {"13": "guava/src/com/google/common/graph/ValueGraph.java", "added": {"1": ["   * Returns {@code true} iff {@code object} is a {@link ValueGraph} that has the same elements and\n", "   * the same structural relationships as those in this graph.\n", "   * <p>Thus, two value graphs A and B are equal if <b>all</b> of the following are true:\n", "   *\n", "   * <ul>\n", "   * <li>A and B have equal {@link #isDirected() directedness}.\n", "   * <li>A and B have equal {@link #nodes() node sets}.\n", "   * <li>A and B have equal {@link #edges() edge sets}.\n", "   * <li>Every edge in A and B are associated with equal {@link #edgeValue(Object, Object) values}.\n", "   * </ul>\n", "   *\n", "   * <p>Graph properties besides {@link #isDirected() directedness} do <b>not</b> affect equality.\n", "   * For example, two graphs may be considered equal even if one allows self-loops and the other\n", "   * doesn't. Additionally, the order in which nodes or edges are added to the graph, and the order\n", "   * in which they are iterated over, are irrelevant.\n", "   *\n", "   * <p>A reference implementation of this is provided by {@link AbstractValueGraph#equals(Object)}.\n", "   * Returns the hash code for this graph. The hash code of a graph is defined as the hash code of a\n", "   * map from each of its {@link #edges() edges} to the associated {@link #edgeValue(Object, Object)\n", "   * edge value}.\n", "   *\n", "   * <p>A reference implementation of this is provided by {@link AbstractValueGraph#hashCode()}.\n"]}, "removed": {"1": ["   * For the default {@link ValueGraph} implementations, returns true if {@code this == object}\n", "   * (reference equality). External implementations are free to define this method as they see fit,\n", "   * as long as they satisfy the {@link Object#equals(Object)} contract.\n", "   * <p>To compare two {@link ValueGraph}s based on their contents rather than their references, see\n", "   * {@link Graphs#equivalent(ValueGraph, ValueGraph)}.\n", "   * For the default {@link ValueGraph} implementations, returns {@code\n", "   * System.identityHashCode(this)}. External implementations are free to define this method as they\n", "   * see fit, as long as they satisfy the {@link Object#hashCode()} contract.\n"]}, "added_lines": {"1": [242, 243, 245, 246, 247, 248, 249, 250, 251, 252, 253, 254, 255, 256, 257, 258, 259, 265, 266, 267, 268, 269]}, "removed_lines": {"1": [242, 243, 244, 246, 247, 253, 254, 255]}}]}
