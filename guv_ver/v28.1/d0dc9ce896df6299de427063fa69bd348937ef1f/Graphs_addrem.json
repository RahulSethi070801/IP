{
    "addition": {
        "213": "   * @deprecated Use {@link Graph#equals(Object)} instead. This method will be removed in late 2017.\n",
        "215": "  // TODO(user): Delete this method.\n",
        "216": "  @Deprecated\n",
        "218": "    return Objects.equal(graphA, graphB);\n",
        "222": "   * @deprecated Use {@link ValueGraph#equals(Object)} instead. This method will be removed in late\n",
        "223": "   * 2017.\n",
        "225": "  // TODO(user): Delete this method.\n",
        "226": "  @Deprecated\n",
        "229": "    return Objects.equal(graphA, graphB);\n",
        "233": "   * @deprecated Use {@link Network#equals(Object)} instead. This method will be removed in late\n",
        "234": "   * 2017.\n",
        "236": "  // TODO(user): Delete this method.\n",
        "237": "  @Deprecated\n",
        "240": "    return Objects.equal(networkA, networkB);\n"
    },
    "removed": {
        "213": "   * Returns {@code true} if {@code graphA} and {@code graphB} have the same elements and the same\n",
        "214": "   * relationships between elements, as exposed via the {@link Graph} interface.\n",
        "215": "   *\n",
        "216": "   * <p>Thus, two graphs A and B are equivalent if both are null or <b>all</b> of the following are\n",
        "217": "   * true:\n",
        "218": "   *\n",
        "219": "   * <ul>\n",
        "220": "   * <li>A and B have equal {@link Graph#isDirected() directedness}.\n",
        "221": "   * <li>A and B have equal {@link Graph#nodes() node sets}.\n",
        "222": "   * <li>A and B have equal {@link Graph#edges() edge sets}.\n",
        "223": "   * </ul>\n",
        "224": "   *\n",
        "225": "   * <p>Graph properties besides {@link Graph#isDirected() directedness} do <b>not</b> affect\n",
        "226": "   * equivalence. For example, two graphs may be considered equivalent even if one allows self-loops\n",
        "227": "   * and the other doesn't. Additionally, the order in which nodes or edges are added to the graph,\n",
        "228": "   * and the order in which they are iterated over, are irrelevant.\n",
        "231": "    if (graphA == graphB) {\n",
        "232": "      return true;\n",
        "233": "    }\n",
        "234": "    if (graphA == null || graphB == null) {\n",
        "235": "      return false;\n",
        "236": "    }\n",
        "237": "\n",
        "238": "    return graphA.isDirected() == graphB.isDirected()\n",
        "239": "        && graphA.nodes().equals(graphB.nodes())\n",
        "240": "        && graphA.edges().equals(graphB.edges());\n",
        "244": "   * Returns {@code true} if {@code graphA} and {@code graphB} have the same elements (including\n",
        "245": "   * edge values) and the same relationships between elements, as exposed via the {@link ValueGraph}\n",
        "246": "   * interface.\n",
        "247": "   *\n",
        "248": "   * <p>Thus, two value graphs A and B are equivalent if both are null or <b>all</b> of the\n",
        "249": "   * following are true:\n",
        "250": "   *\n",
        "251": "   * <ul>\n",
        "252": "   * <li>A and B have equal {@link Graph#isDirected() directedness}.\n",
        "253": "   * <li>A and B have equal {@link Graph#nodes() node sets}.\n",
        "254": "   * <li>A and B have equal {@link Graph#edges() edge sets}.\n",
        "255": "   * <li>Each edge in A has a {@link ValueGraph#edgeValue(Object, Object) value} equal to the {@link\n",
        "256": "   *     ValueGraph#edgeValue(Object, Object) value} of the corresponding edge in B.\n",
        "257": "   * </ul>\n",
        "258": "   *\n",
        "259": "   * <p>Graph properties besides {@link Graph#isDirected() directedness} do <b>not</b> affect\n",
        "260": "   * equivalence. For example, two graphs may be considered equivalent even if one allows self-loops\n",
        "261": "   * and the other doesn't. Additionally, the order in which nodes or edges are added to the graph,\n",
        "262": "   * and the order in which they are iterated over, are irrelevant.\n",
        "266": "    if (graphA == graphB) {\n",
        "267": "      return true;\n",
        "268": "    }\n",
        "269": "    if (graphA == null || graphB == null) {\n",
        "270": "      return false;\n",
        "271": "    }\n",
        "272": "\n",
        "273": "    if (graphA.isDirected() != graphB.isDirected()\n",
        "274": "        || !graphA.nodes().equals(graphB.nodes())\n",
        "275": "        || !graphA.edges().equals(graphB.edges())) {\n",
        "276": "      return false;\n",
        "277": "    }\n",
        "278": "\n",
        "279": "    for (EndpointPair<?> edge : graphA.edges()) {\n",
        "280": "      if (!graphA\n",
        "281": "          .edgeValue(edge.nodeU(), edge.nodeV())\n",
        "282": "          .equals(graphB.edgeValue(edge.nodeU(), edge.nodeV()))) {\n",
        "283": "        return false;\n",
        "284": "      }\n",
        "285": "    }\n",
        "286": "\n",
        "287": "    return true;\n",
        "291": "   * Returns {@code true} if {@code networkA} and {@code networkB} have the same elements and the\n",
        "292": "   * same relationships between elements, as exposed via the {@link Network} interface.\n",
        "293": "   *\n",
        "294": "   * <p>Thus, two networks A and B are equivalent if both are null or <b>all</b> of the following\n",
        "295": "   * are true:\n",
        "296": "   *\n",
        "297": "   * <ul>\n",
        "298": "   * <li>A and B have equal {@link Network#isDirected() directedness}.\n",
        "299": "   * <li>A and B have equal {@link Network#nodes() node sets}.\n",
        "300": "   * <li>A and B have equal {@link Network#edges() edge sets}.\n",
        "301": "   * <li>Each edge in A connects the same nodes in the same direction (if any) as the corresponding\n",
        "302": "   *     edge in B.\n",
        "303": "   * </ul>\n",
        "304": "   *\n",
        "305": "   * <p>Network properties besides {@link Network#isDirected() directedness} do <b>not</b> affect\n",
        "306": "   * equivalence. For example, two networks may be considered equal even if one allows parallel\n",
        "307": "   * edges and the other doesn't. Additionally, the order in which nodes or edges are added to the\n",
        "308": "   * network, and the order in which they are iterated over, are irrelevant.\n",
        "312": "    if (networkA == networkB) {\n",
        "313": "      return true;\n",
        "314": "    }\n",
        "315": "    if (networkA == null || networkB == null) {\n",
        "316": "      return false;\n",
        "317": "    }\n",
        "318": "\n",
        "319": "    if (networkA.isDirected() != networkB.isDirected()\n",
        "320": "        || !networkA.nodes().equals(networkB.nodes())\n",
        "321": "        || !networkA.edges().equals(networkB.edges())) {\n",
        "322": "      return false;\n",
        "323": "    }\n",
        "324": "\n",
        "325": "    for (Object edge : networkA.edges()) {\n",
        "326": "      if (!networkA.incidentNodes(edge).equals(networkB.incidentNodes(edge))) {\n",
        "327": "        return false;\n",
        "328": "      }\n",
        "329": "    }\n",
        "330": "\n",
        "331": "    return true;\n"
    }
}