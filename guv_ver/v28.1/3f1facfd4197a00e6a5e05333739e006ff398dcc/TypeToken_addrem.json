{
    "addition": {
        "950": "   *\n",
        "957": "   *\n",
        "958": "   * Note that condition 2 isn't technically accurate under the context of a recursively bounded\n",
        "959": "   * type variables. For example, {@code Enum<? extends Enum<E>>} canonicalizes to {@code Enum<?>}\n",
        "960": "   * where {@code E} is the type variable declared on the {@code Enum} class declaration. It's\n",
        "961": "   * technically <em>not</em> true that {@code Foo<Enum<? extends Enum<E>>>} is a subtype of {@code\n",
        "962": "   * Foo<Enum<?>>} according to JLS. See testRecursiveWildcardSubtypeBug() for a real example.\n",
        "969": "   * @param declaration The type variable in the context of a parameterized type. Used to infer type\n",
        "970": "   *     bound when {@code formalType} is a wildcard with implicit upper bound.\n",
        "986": "    return canonicalizeWildcardsInType(runtimeType).equals(canonicalizeWildcardsInType(formalType));\n",
        "994": "   *\n",
        "996": "   *   <li>{@code canonicalize(t)} always produces the equal result for equivalent types. For\n",
        "997": "   *       example both {@code Enum<?>} and {@code Enum<? extends Enum<?>>} canonicalize to {@code\n",
        "998": "   *       Enum<? extends Enum<E>}.\n",
        "999": "   *   <li>{@code canonicalize(t)} produces a \"literal\" supertype of t. For example: {@code Enum<?\n",
        "1000": "   *       extends Enum<?>>} canonicalizes to {@code Enum<?>}, which is a supertype (if we disregard\n",
        "1001": "   *       the upper bound is implicitly an Enum too).\n",
        "1002": "   *   <li>If {@code canonicalize(A) == canonicalize(B)}, then {@code Foo<A>.isSubtypeOf(Foo<B>)}\n",
        "1003": "   *       and vice versa. i.e. {@code A.is(B)} and {@code B.is(A)}.\n",
        "1004": "   *   <li>{@code canonicalize(canonicalize(A)) == canonicalize(A)}.\n"
    },
    "removed": {
        "956": "   * Note that condition 2 isn't technically accurate under the context of a recursively\n",
        "957": "   * bounded type variables. For example, {@code Enum<? extends Enum<E>>} canonicalizes to\n",
        "958": "   * {@code Enum<?>} where {@code E} is the type variable declared on the {@code Enum} class\n",
        "959": "   * declaration. It's technically <em>not</em> true that {@code Foo<Enum<? extends Enum<E>>>} is a\n",
        "960": "   * subtype of {@code Foo<Enum<?>>} according to JLS. See testRecursiveWildcardSubtypeBug() for\n",
        "961": "   * a real example.\n",
        "968": "   * @param declaration The type variable in the context of a parameterized type. Used to infer\n",
        "969": "   *        type bound when {@code formalType} is a wildcard with implicit upper bound.\n",
        "985": "    return canonicalizeWildcardsInType(runtimeType)\n",
        "986": "        .equals(canonicalizeWildcardsInType(formalType));\n",
        "995": "   * <li>{@code canonicalize(t)} always produces the equal result for equivalent types. For example\n",
        "996": "   *     both {@code Enum<?>} and {@code Enum<? extends Enum<?>>} canonicalize to\n",
        "997": "   *     {@code Enum<? extends Enum<E>}.\n",
        "998": "   * <li>{@code canonicalize(t)} produces a \"literal\" supertype of t.\n",
        "999": "   *     For example: {@code Enum<? extends Enum<?>>} canonicalizes to {@code Enum<?>}, which is\n",
        "1000": "   *     a supertype (if we disregard the upper bound is implicitly an Enum too).\n",
        "1001": "   * <li>If {@code canonicalize(A) == canonicalize(B)}, then {@code Foo<A>.isSubtypeOf(Foo<B>)} and\n",
        "1002": "   *     vice versa. i.e. {@code A.is(B)} and {@code B.is(A)}.\n",
        "1003": "   * <li>{@code canonicalize(canonicalize(A)) == canonicalize(A)}.\n"
    }
}