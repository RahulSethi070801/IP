{
    "addition": {
        "25": "import com.google.common.math.DoubleMath;\n",
        "35": "import java.math.RoundingMode;\n",
        "43": " * <p>If you are unfamiliar with Bloom filters, this nice <a\n",
        "44": " * href=\"http://llimllib.github.com/bloomfilter-tutorial/\">tutorial</a> may help you understand how\n",
        "45": " * they work.\n",
        "47": " * <p>The false positive probability ({@code FPP}) of a Bloom filter is defined as the probability\n",
        "54": " * of the code may not be readable by older versions of the code (e.g., a serialized Bloom filter\n",
        "155": "   * @return true if the Bloom filter's bits changed as a result of this operation. If the bits\n",
        "183": "  /**\n",
        "184": "   * Returns an estimate for the total number of distinct elements that have been added to this\n",
        "185": "   * Bloom filter. This approximation is reasonably accurate if it does not exceed the value of\n",
        "186": "   * {@code expectedInsertions} that was used when constructing the filter.\n",
        "187": "   *\n",
        "188": "   * @since 22.0\n",
        "189": "   */\n",
        "190": "  public long approximateCount() {\n",
        "191": "    long bitSize = bits.bitSize();\n",
        "192": "    long bitCount = bits.bitCount();\n",
        "193": "\n",
        "194": "    /**\n",
        "195": "     * Each insertion is expected to reduce the # of clear bits by a factor of\n",
        "196": "     * `numHashFunctions/bitSize`. So, after n insertions, expected bitCount is `bitSize * (1 - (1 -\n",
        "197": "     * numHashFunctions/bitSize)^n)`. Solving that for n, and approximating `ln x` as `x - 1` when x\n",
        "198": "     * is close to 1 (why?), gives the following formula.\n",
        "199": "     */\n",
        "200": "    double fractionOfBitsSet = (double) bitCount / bitSize;\n",
        "201": "    return DoubleMath.roundToLong(\n",
        "202": "        -Math.log1p(-fractionOfBitsSet) * bitSize / numHashFunctions, RoundingMode.HALF_UP);\n",
        "203": "  }\n",
        "204": "\n",
        "214": "   * Determines whether a given Bloom filter is compatible with this Bloom filter. For two Bloom\n",
        "218": "   *   <li>not be the same instance\n",
        "219": "   *   <li>have the same number of hash functions\n",
        "220": "   *   <li>have the same bit size\n",
        "221": "   *   <li>have the same strategy\n",
        "222": "   *   <li>have equal funnels\n",
        "223": "   *       <ul>\n",
        "224": "   *\n",
        "225": "   * @param that The Bloom filter to check for compatibility.\n",
        "238": "   * Combines this Bloom filter with another Bloom filter by performing a bitwise OR of the\n",
        "239": "   * underlying data. The mutations happen to <b>this</b> instance. Callers must ensure the Bloom\n",
        "242": "   * @param that The Bloom filter to combine this Bloom filter with. It is not mutated.\n"
    },
    "removed": {
        "41": " * <p>If you are unfamiliar with Bloom filters, this nice\n",
        "42": " * <a href=\"http://llimllib.github.com/bloomfilter-tutorial/\">tutorial</a> may help you understand\n",
        "43": " * how they work.\n",
        "45": " * <p>The false positive probability ({@code FPP}) of a bloom filter is defined as the probability\n",
        "52": " * of the code may not be readable by older versions of the code (e.g., a serialized bloom filter\n",
        "153": "   * @return true if the bloom filter's bits changed as a result of this operation. If the bits\n",
        "190": "   * Determines whether a given bloom filter is compatible with this bloom filter. For two bloom\n",
        "194": "   * <li>not be the same instance\n",
        "195": "   * <li>have the same number of hash functions\n",
        "196": "   * <li>have the same bit size\n",
        "197": "   * <li>have the same strategy\n",
        "198": "   * <li>have equal funnels\n",
        "199": "   * <ul>\n",
        "200": "   *\n",
        "201": "   * @param that The bloom filter to check for compatibility.\n",
        "214": "   * Combines this bloom filter with another bloom filter by performing a bitwise OR of the\n",
        "215": "   * underlying data. The mutations happen to <b>this</b> instance. Callers must ensure the bloom\n",
        "218": "   * @param that The bloom filter to combine this bloom filter with. It is not mutated.\n",
        "220": "   *\n"
    }
}