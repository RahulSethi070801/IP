{"id": "d7f2dddae1f04e5040faca34819cb5d1c700d48f", "code": [{"0": "guava-tests/test/com/google/common/hash/BloomFilterTest.java", "added": {"1": ["  /**\n", "   * Asserts that {@link BloomFilter#approximateCount} is within 1 percent of the expected value.\n", "   */\n", "  private static void assertApproximateCountGuess(BloomFilter<?> bf, int sizeGuess) {\n", "    assertThat(bf.approximateCount()).isAtLeast((long) (sizeGuess * 0.99));\n", "    assertThat(bf.approximateCount()).isAtMost((long) (sizeGuess * 1.01));\n", "  }\n", "\n"], "2": ["    assertApproximateCountGuess(bf, numInsertions);\n"], "3": ["    assertApproximateCountGuess(bf, numInsertions);\n"], "4": ["    assertApproximateCountGuess(bf, numInsertions);\n"], "5": ["  private static void checkSanity(BloomFilter<Object> bf) {\n"], "6": ["  public void testApproximateCount() {\n", "    int numInsertions = 1000;\n", "    BloomFilter<Integer> bf = BloomFilter.create(Funnels.integerFunnel(), numInsertions);\n", "    bf.put(-1);\n", "    for (int i = 0; i < numInsertions; i++) {\n", "      bf.put(i);\n", "    }\n", "    assertApproximateCountGuess(bf, numInsertions);\n", "  }\n", "\n"]}, "removed": {"5": ["  private void checkSanity(BloomFilter<Object> bf) {\n"]}, "added_lines": {"1": [56, 57, 58, 59, 60, 61, 62, 63], "2": [74], "3": [116], "4": [158], "5": [287], "6": [331, 332, 333, 334, 335, 336, 337, 338, 339, 340]}, "removed_lines": {"5": [276]}}, {"1": "guava/src/com/google/common/hash/BloomFilter.java", "added": {"1": ["import com.google.common.math.DoubleMath;\n"], "2": ["import java.math.RoundingMode;\n"], "3": [" * <p>If you are unfamiliar with Bloom filters, this nice <a\n", " * href=\"http://llimllib.github.com/bloomfilter-tutorial/\">tutorial</a> may help you understand how\n", " * they work.\n", " * <p>The false positive probability ({@code FPP}) of a Bloom filter is defined as the probability\n", " * of the code may not be readable by older versions of the code (e.g., a serialized Bloom filter\n"], "4": ["   * @return true if the Bloom filter's bits changed as a result of this operation. If the bits\n"], "5": ["  /**\n", "   * Returns an estimate for the total number of distinct elements that have been added to this\n", "   * Bloom filter. This approximation is reasonably accurate if it does not exceed the value of\n", "   * {@code expectedInsertions} that was used when constructing the filter.\n", "   *\n", "   * @since 22.0\n", "   */\n", "  public long approximateCount() {\n", "    long bitSize = bits.bitSize();\n", "    long bitCount = bits.bitCount();\n", "\n", "    /**\n", "     * Each insertion is expected to reduce the # of clear bits by a factor of\n", "     * `numHashFunctions/bitSize`. So, after n insertions, expected bitCount is `bitSize * (1 - (1 -\n", "     * numHashFunctions/bitSize)^n)`. Solving that for n, and approximating `ln x` as `x - 1` when x\n", "     * is close to 1 (why?), gives the following formula.\n", "     */\n", "    double fractionOfBitsSet = (double) bitCount / bitSize;\n", "    return DoubleMath.roundToLong(\n", "        -Math.log1p(-fractionOfBitsSet) * bitSize / numHashFunctions, RoundingMode.HALF_UP);\n", "  }\n", "\n"], "6": ["   * Determines whether a given Bloom filter is compatible with this Bloom filter. For two Bloom\n", "   *   <li>not be the same instance\n", "   *   <li>have the same number of hash functions\n", "   *   <li>have the same bit size\n", "   *   <li>have the same strategy\n", "   *   <li>have equal funnels\n", "   *       <ul>\n", "   *\n", "   * @param that The Bloom filter to check for compatibility.\n"], "7": ["   * Combines this Bloom filter with another Bloom filter by performing a bitwise OR of the\n", "   * underlying data. The mutations happen to <b>this</b> instance. Callers must ensure the Bloom\n", "   * @param that The Bloom filter to combine this Bloom filter with. It is not mutated.\n"]}, "removed": {"3": [" * <p>If you are unfamiliar with Bloom filters, this nice\n", " * <a href=\"http://llimllib.github.com/bloomfilter-tutorial/\">tutorial</a> may help you understand\n", " * how they work.\n", " * <p>The false positive probability ({@code FPP}) of a bloom filter is defined as the probability\n", " * of the code may not be readable by older versions of the code (e.g., a serialized bloom filter\n"], "4": ["   * @return true if the bloom filter's bits changed as a result of this operation. If the bits\n"], "6": ["   * Determines whether a given bloom filter is compatible with this bloom filter. For two bloom\n", "   * <li>not be the same instance\n", "   * <li>have the same number of hash functions\n", "   * <li>have the same bit size\n", "   * <li>have the same strategy\n", "   * <li>have equal funnels\n", "   * <ul>\n", "   *\n", "   * @param that The bloom filter to check for compatibility.\n"], "7": ["   * Combines this bloom filter with another bloom filter by performing a bitwise OR of the\n", "   * underlying data. The mutations happen to <b>this</b> instance. Callers must ensure the bloom\n", "   * @param that The bloom filter to combine this bloom filter with. It is not mutated.\n", "   *\n"]}, "added_lines": {"1": [25], "2": [35], "3": [43, 44, 45, 47, 54], "4": [155], "5": [183, 184, 185, 186, 187, 188, 189, 190, 191, 192, 193, 194, 195, 196, 197, 198, 199, 200, 201, 202, 203, 204], "6": [214, 218, 219, 220, 221, 222, 223, 224, 225], "7": [238, 239, 242]}, "removed_lines": {"3": [41, 42, 43, 45, 52], "4": [153], "6": [190, 194, 195, 196, 197, 198, 199, 200, 201], "7": [214, 215, 218, 220]}}]}
