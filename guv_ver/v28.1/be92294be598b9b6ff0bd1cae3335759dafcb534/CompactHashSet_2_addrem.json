{
    "addition": {
        "24": "import com.google.common.annotations.VisibleForTesting;\n",
        "29": "import java.io.InvalidObjectException;\n",
        "132": "  @VisibleForTesting static final int DEFAULT_SIZE = 3;\n",
        "191": "    this.loadFactor = loadFactor;\n",
        "192": "    this.threshold = Math.max(1, expectedSize); // Save expectedSize for use in allocArrays()\n",
        "193": "  }\n",
        "194": "\n",
        "195": "  /** Returns whether arrays need to be allocated. */\n",
        "196": "  boolean needsAllocArrays() {\n",
        "197": "    return table == null;\n",
        "198": "  }\n",
        "199": "\n",
        "200": "  /** Handle lazy allocation of arrays. */\n",
        "201": "  void allocArrays() {\n",
        "202": "    Preconditions.checkState(needsAllocArrays(), \"Arrays already allocated\");\n",
        "203": "\n",
        "204": "    int expectedSize = threshold;\n",
        "207": "\n",
        "209": "\n",
        "247": "    if (needsAllocArrays()) {\n",
        "248": "      allocArrays();\n",
        "249": "    }\n",
        "293": "  /** Resizes the entries storage if necessary. */\n",
        "349": "    if (needsAllocArrays()) {\n",
        "350": "      return false;\n",
        "351": "    }\n",
        "367": "    if (needsAllocArrays()) {\n",
        "368": "      return false;\n",
        "369": "    }\n",
        "503": "    if (needsAllocArrays()) {\n",
        "504": "      return Spliterators.spliterator(new Object[0], Spliterator.DISTINCT | Spliterator.ORDERED);\n",
        "505": "    }\n",
        "529": "    if (needsAllocArrays()) {\n",
        "530": "      return new Object[0];\n",
        "531": "    }\n",
        "538": "    if (needsAllocArrays()) {\n",
        "539": "      if (a.length > 0) {\n",
        "540": "        a[0] = null;\n",
        "541": "      }\n",
        "542": "      return a;\n",
        "543": "    }\n",
        "552": "    if (needsAllocArrays()) {\n",
        "553": "      return;\n",
        "554": "    }\n",
        "578": "    if (needsAllocArrays()) {\n",
        "579": "      return;\n",
        "580": "    }\n",
        "584": "    Arrays.fill(entries, 0, size, UNSET);\n",
        "595": "    for (int i = firstEntryIndex(); i >= 0; i = getSuccessor(i)) {\n",
        "596": "      stream.writeObject(elements[i]);\n",
        "604": "    if (elementCount < 0) {\n",
        "605": "      throw new InvalidObjectException(\"Invalid size: \" + elementCount);\n",
        "606": "    }\n",
        "607": "    init(elementCount, DEFAULT_LOAD_FACTOR);\n",
        "608": "    for (int i = 0; i < elementCount; i++) {\n"
    },
    "removed": {
        "130": "  private static final int DEFAULT_SIZE = 3;\n",
        "191": "    this.loadFactor = loadFactor;\n",
        "273": "  /** Returns currentSize + 1, after resizing the entries storage if necessary. */\n",
        "540": "    Arrays.fill(entries, UNSET);\n",
        "551": "    for (E e : this) {\n",
        "552": "      stream.writeObject(e);\n",
        "559": "    init(DEFAULT_SIZE, DEFAULT_LOAD_FACTOR);\n",
        "561": "    for (int i = elementCount; --i >= 0; ) {\n"
    }
}