{"id": "f91ef6ca6dd95bd3806c8b573f54cd429abc5857", "code": [{"0": "android/guava-tests/benchmark/com/google/common/collect/BinaryTreeTraverserBenchmark.java", "added": {"1": ["import com.google.common.collect.ImmutableList;\n", " * Benchmarks for the {@code TreeTraverser} operations on binary trees.\n"], "2": ["          return Optional.presentInstances(ImmutableList.of(root.left, root.right));\n"], "3": ["    this.view = traversal.view(topology.createTree(size, rng).get(), VIEWER);\n"]}, "removed": {"1": [" * Benchmarks for the {@code TreeTraverser} and optimized {@code BinaryTreeTraverser} operations on\n", " * binary trees.\n"], "2": ["  private static final BinaryTreeTraverser<BinaryNode> BINARY_VIEWER =\n", "      new BinaryTreeTraverser<BinaryNode>() {\n", "\n", "        @Override\n", "        public Optional<BinaryNode> leftChild(BinaryNode node) {\n", "          return node.left;\n", "        }\n", "\n", "        @Override\n", "        public Optional<BinaryNode> rightChild(BinaryNode node) {\n", "          return node.right;\n", "        }\n", "      };\n", "\n", "          return BINARY_VIEWER.children(root);\n"], "3": ["  @Param boolean useBinaryTraverser;\n", "\n", "    this.view =\n", "        traversal.view(\n", "            topology.createTree(size, rng).get(), useBinaryTraverser ? BINARY_VIEWER : VIEWER);\n"]}, "added_lines": {"1": [21, 27], "2": [117], "3": [158]}, "removed_lines": {"1": [26, 27], "2": [113, 114, 115, 116, 117, 118, 119, 120, 121, 122, 123, 124, 125, 126, 131], "3": [167, 168, 174, 175, 176]}}, {"1": "android/guava-tests/test/com/google/common/collect/TreeTraverserTest.java", "added": {"2": ["  private static class Node {\n", "    Node(char value) {\n", "  private static final class Tree extends Node {\n", "    final List<Tree> children;\n", "    public Tree(char value, Tree... children) {\n", "      super(value);\n", "      this.children = Arrays.asList(children);\n"], "4": ["  static String iterationOrder(Iterable<? extends Node> iterable) {\n", "    for (Node t : iterable) {\n"]}, "removed": {"1": ["import com.google.common.base.Optional;\n", "import org.checkerframework.checker.nullness.compatqual.NullableDecl;\n"], "2": ["  private static final class Tree {\n", "    final List<Tree> children;\n", "    public Tree(char value, Tree... children) {\n", "      this.children = Arrays.asList(children);\n", "  private static final class BinaryTree {\n", "    final char value;\n", "    @NullableDecl final BinaryTree left;\n", "    @NullableDecl final BinaryTree right;\n", "    private BinaryTree(char value, BinaryTree left, BinaryTree right) {\n", "      this.value = value;\n", "      this.left = left;\n", "      this.right = right;\n"], "3": ["  private static final BinaryTreeTraverser<BinaryTree> BIN_ADAPTER =\n", "      new BinaryTreeTraverser<BinaryTree>() {\n", "\n", "        @Override\n", "        public Optional<BinaryTree> leftChild(BinaryTree node) {\n", "          return Optional.fromNullable(node.left);\n", "        }\n", "\n", "        @Override\n", "        public Optional<BinaryTree> rightChild(BinaryTree node) {\n", "          return Optional.fromNullable(node.right);\n", "        }\n", "      };\n", "\n"], "4": ["  //      d\n", "  //     / \\\n", "  //    b   e\n", "  //   / \\   \\\n", "  //  a   c   f\n", "  //         /\n", "  //        g\n", "  static final BinaryTree ba = new BinaryTree('a', null, null);\n", "  static final BinaryTree bc = new BinaryTree('c', null, null);\n", "  static final BinaryTree bb = new BinaryTree('b', ba, bc);\n", "  static final BinaryTree bg = new BinaryTree('g', null, null);\n", "  static final BinaryTree bf = new BinaryTree('f', bg, null);\n", "  static final BinaryTree be = new BinaryTree('e', null, bf);\n", "  static final BinaryTree bd = new BinaryTree('d', bb, be);\n", "\n", "  static String iterationOrder(Iterable<Tree> iterable) {\n", "    StringBuilder builder = new StringBuilder();\n", "    for (Tree t : iterable) {\n", "      builder.append(t.value);\n", "    }\n", "    return builder.toString();\n", "  }\n", "\n", "  static String binaryIterationOrder(Iterable<BinaryTree> iterable) {\n", "    for (BinaryTree t : iterable) {\n"], "5": ["    assertThat(binaryIterationOrder(BIN_ADAPTER.preOrderTraversal(bd))).isEqualTo(\"dbacefg\");\n", "    assertThat(binaryIterationOrder(BIN_ADAPTER.postOrderTraversal(bd))).isEqualTo(\"acbgfed\");\n", "    assertThat(binaryIterationOrder(BIN_ADAPTER.breadthFirstTraversal(bd))).isEqualTo(\"dbeacfg\");\n", "  }\n", "\n", "  public void testInOrder() {\n", "    assertThat(binaryIterationOrder(BIN_ADAPTER.inOrderTraversal(bd))).isEqualTo(\"abcdegf\");\n"], "6": ["    tester.testAllPublicInstanceMethods(BIN_ADAPTER);\n"]}, "added_lines": {"2": [34, 37, 42, 43, 45, 46, 47], "4": [84, 86]}, "removed_lines": {"1": [22, 27], "2": [36, 38, 40, 42, 46, 47, 48, 49, 51, 52, 53, 54], "3": [75, 76, 77, 78, 79, 80, 81, 82, 83, 84, 85, 86, 87, 88], "4": [105, 106, 107, 108, 109, 110, 111, 112, 113, 114, 115, 116, 117, 118, 119, 120, 121, 122, 123, 124, 125, 126, 127, 128, 130], "5": [138, 143, 148, 149, 150, 151, 152], "6": [163]}}, {"2": "android/guava-tests/test/com/google/common/util/concurrent/FuturesTest.java", "added": {}, "removed": {"1": ["import static com.google.common.util.concurrent.Futures.dereference;\n"], "2": ["  public void testDereference_genericsWildcard() throws Exception {\n", "    ListenableFuture<?> inner = immediateFuture(null);\n", "    @SuppressWarnings(\"FutureReturnValueIgnored\")\n", "    ListenableFuture<ListenableFuture<?>> outer =\n", "        Futures.<ListenableFuture<?>>immediateFuture(inner);\n", "    ListenableFuture<?> dereferenced = dereference(outer);\n", "    assertNull(getDone(dereferenced));\n", "  }\n", "\n", "  public void testDereference_genericsHierarchy() throws Exception {\n", "    FooChild fooChild = new FooChild();\n", "    ListenableFuture<FooChild> inner = immediateFuture(fooChild);\n", "    @SuppressWarnings(\"FutureReturnValueIgnored\")\n", "    ListenableFuture<ListenableFuture<FooChild>> outer = immediateFuture(inner);\n", "    ListenableFuture<Foo> dereferenced = Futures.<Foo>dereference(outer);\n", "    assertSame(fooChild, getDone(dereferenced));\n", "  }\n", "\n", "  public void testDereference_resultCancelsOuter() throws Exception {\n", "    @SuppressWarnings(\"FutureReturnValueIgnored\")\n", "    ListenableFuture<ListenableFuture<Foo>> outer = SettableFuture.create();\n", "    ListenableFuture<Foo> dereferenced = dereference(outer);\n", "    dereferenced.cancel(true);\n", "    assertTrue(outer.isCancelled());\n", "  }\n", "\n", "  public void testDereference_resultCancelsInner() throws Exception {\n", "    ListenableFuture<Foo> inner = SettableFuture.create();\n", "    @SuppressWarnings(\"FutureReturnValueIgnored\")\n", "    ListenableFuture<ListenableFuture<Foo>> outer = immediateFuture(inner);\n", "    ListenableFuture<Foo> dereferenced = dereference(outer);\n", "    dereferenced.cancel(true);\n", "    assertTrue(inner.isCancelled());\n", "  }\n", "\n", "  public void testDereference_outerCancelsResult() throws Exception {\n", "    @SuppressWarnings(\"FutureReturnValueIgnored\")\n", "    ListenableFuture<ListenableFuture<Foo>> outer = SettableFuture.create();\n", "    ListenableFuture<Foo> dereferenced = dereference(outer);\n", "    outer.cancel(true);\n", "    assertTrue(dereferenced.isCancelled());\n", "  }\n", "\n", "  public void testDereference_innerCancelsResult() throws Exception {\n", "    ListenableFuture<Foo> inner = SettableFuture.create();\n", "    @SuppressWarnings(\"FutureReturnValueIgnored\")\n", "    ListenableFuture<ListenableFuture<Foo>> outer = immediateFuture(inner);\n", "    ListenableFuture<Foo> dereferenced = dereference(outer);\n", "    inner.cancel(true);\n", "    assertTrue(dereferenced.isCancelled());\n", "  }\n", "\n"]}, "added_lines": {}, "removed_lines": {"1": [30], "2": [2085, 2086, 2087, 2088, 2089, 2090, 2091, 2092, 2093, 2094, 2095, 2096, 2097, 2098, 2099, 2100, 2101, 2102, 2103, 2104, 2105, 2106, 2107, 2108, 2109, 2110, 2111, 2112, 2113, 2114, 2115, 2116, 2117, 2118, 2119, 2120, 2121, 2122, 2123, 2124, 2125, 2126, 2127, 2128, 2129, 2130, 2131, 2132, 2133, 2134, 2135, 2136]}}, {"3": "android/guava/src/com/google/common/base/Predicates.java", "added": {"1": ["   *     to be removed in April 2018.\n", "  // TODO(b/72241559): Remove by 2018-04\n"]}, "removed": {"1": ["   *     to be removed in January 2018.\n"]}, "added_lines": {"1": [193, 196]}, "removed_lines": {"1": [193]}}, {"4": "android/guava/src/com/google/common/collect/BinaryTreeTraverser.java", "added": {}, "removed": {"1": ["/*\n", " * Copyright (C) 2012 The Guava Authors\n", " *\n", " * Licensed under the Apache License, Version 2.0 (the \"License\");\n", " * you may not use this file except in compliance with the License.\n", " * You may obtain a copy of the License at\n", " *\n", " * http://www.apache.org/licenses/LICENSE-2.0\n", " *\n", " * Unless required by applicable law or agreed to in writing, software\n", " * distributed under the License is distributed on an \"AS IS\" BASIS,\n", " * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n", " * See the License for the specific language governing permissions and\n", " * limitations under the License.\n", " */\n", "\n", "package com.google.common.collect;\n", "\n", "import static com.google.common.base.Preconditions.checkNotNull;\n", "\n", "import com.google.common.annotations.Beta;\n", "import com.google.common.annotations.GwtCompatible;\n", "import com.google.common.base.Optional;\n", "import java.util.ArrayDeque;\n", "import java.util.BitSet;\n", "import java.util.Deque;\n", "import java.util.Iterator;\n", "\n", "/**\n", " * A variant of {@link TreeTraverser} for binary trees, providing additional traversals specific to\n", " * binary trees.\n", " *\n", " * @author Louis Wasserman\n", " * @since 15.0\n", " * @deprecated Use {@link com.google.common.graph.Traverser} instead. All instance methods except\n", " *     for {@link #inOrderTraversal} have their equivalent on the result of {@code\n", " *     Traverser.forTree(tree)} where {@code tree} implements {@code SuccessorsFunction}, which has\n", " *     a similar API as {@link #children}.\n", " *     <p>This class is scheduled to be removed in January 2018.\n", " */\n", "@Deprecated\n", "@Beta\n", "@GwtCompatible\n", "public abstract class BinaryTreeTraverser<T> extends TreeTraverser<T> {\n", "\n", "  /**\n", "   * Returns the left child of the specified node, or {@link Optional#absent()} if the specified\n", "   * node has no left child.\n", "   */\n", "  public abstract Optional<T> leftChild(T root);\n", "\n", "  /**\n", "   * Returns the right child of the specified node, or {@link Optional#absent()} if the specified\n", "   * node has no right child.\n", "   */\n", "  public abstract Optional<T> rightChild(T root);\n", "\n", "  /** Returns the children of this node, in left-to-right order. */\n", "  @Override\n", "  public final Iterable<T> children(final T root) {\n", "    checkNotNull(root);\n", "    return new FluentIterable<T>() {\n", "      @Override\n", "      public Iterator<T> iterator() {\n", "        return new AbstractIterator<T>() {\n", "          boolean doneLeft;\n", "          boolean doneRight;\n", "\n", "          @Override\n", "          protected T computeNext() {\n", "            if (!doneLeft) {\n", "              doneLeft = true;\n", "              Optional<T> left = leftChild(root);\n", "              if (left.isPresent()) {\n", "                return left.get();\n", "              }\n", "            }\n", "            if (!doneRight) {\n", "              doneRight = true;\n", "              Optional<T> right = rightChild(root);\n", "              if (right.isPresent()) {\n", "                return right.get();\n", "              }\n", "            }\n", "            return endOfData();\n", "          }\n", "        };\n", "      }\n", "    };\n", "  }\n", "\n", "  @Override\n", "  UnmodifiableIterator<T> preOrderIterator(T root) {\n", "    return new PreOrderIterator(root);\n", "  }\n", "\n", "  /*\n", "   * Optimized implementation of preOrderIterator for binary trees.\n", "   */\n", "  private final class PreOrderIterator extends UnmodifiableIterator<T>\n", "      implements PeekingIterator<T> {\n", "    private final Deque<T> stack;\n", "\n", "    PreOrderIterator(T root) {\n", "      this.stack = new ArrayDeque<T>(8);\n", "      stack.addLast(root);\n", "    }\n", "\n", "    @Override\n", "    public boolean hasNext() {\n", "      return !stack.isEmpty();\n", "    }\n", "\n", "    @Override\n", "    public T next() {\n", "      T result = stack.removeLast();\n", "      pushIfPresent(stack, rightChild(result));\n", "      pushIfPresent(stack, leftChild(result));\n", "      return result;\n", "    }\n", "\n", "    @Override\n", "    public T peek() {\n", "      return stack.getLast();\n", "    }\n", "  }\n", "\n", "  @Override\n", "  UnmodifiableIterator<T> postOrderIterator(T root) {\n", "    return new PostOrderIterator(root);\n", "  }\n", "\n", "  /*\n", "   * Optimized implementation of postOrderIterator for binary trees.\n", "   */\n", "  private final class PostOrderIterator extends UnmodifiableIterator<T> {\n", "    private final Deque<T> stack;\n", "    private final BitSet hasExpanded;\n", "\n", "    PostOrderIterator(T root) {\n", "      this.stack = new ArrayDeque<T>(8);\n", "      stack.addLast(root);\n", "      this.hasExpanded = new BitSet();\n", "    }\n", "\n", "    @Override\n", "    public boolean hasNext() {\n", "      return !stack.isEmpty();\n", "    }\n", "\n", "    @Override\n", "    public T next() {\n", "      while (true) {\n", "        T node = stack.getLast();\n", "        boolean expandedNode = hasExpanded.get(stack.size() - 1);\n", "        if (expandedNode) {\n", "          stack.removeLast();\n", "          hasExpanded.clear(stack.size());\n", "          return node;\n", "        } else {\n", "          hasExpanded.set(stack.size() - 1);\n", "          pushIfPresent(stack, rightChild(node));\n", "          pushIfPresent(stack, leftChild(node));\n", "        }\n", "      }\n", "    }\n", "  }\n", "\n", "  // TODO(lowasser): see if any significant optimizations are possible for breadthFirstIterator\n", "\n", "  public final FluentIterable<T> inOrderTraversal(final T root) {\n", "    checkNotNull(root);\n", "    return new FluentIterable<T>() {\n", "      @Override\n", "      public UnmodifiableIterator<T> iterator() {\n", "        return new InOrderIterator(root);\n", "      }\n", "    };\n", "  }\n", "\n", "  private final class InOrderIterator extends AbstractIterator<T> {\n", "    private final Deque<T> stack;\n", "    private final BitSet hasExpandedLeft;\n", "\n", "    InOrderIterator(T root) {\n", "      this.stack = new ArrayDeque<T>(8);\n", "      this.hasExpandedLeft = new BitSet();\n", "      stack.addLast(root);\n", "    }\n", "\n", "    @Override\n", "    protected T computeNext() {\n", "      while (!stack.isEmpty()) {\n", "        T node = stack.getLast();\n", "        if (hasExpandedLeft.get(stack.size() - 1)) {\n", "          stack.removeLast();\n", "          hasExpandedLeft.clear(stack.size());\n", "          pushIfPresent(stack, rightChild(node));\n", "          return node;\n", "        } else {\n", "          hasExpandedLeft.set(stack.size() - 1);\n", "          pushIfPresent(stack, leftChild(node));\n", "        }\n", "      }\n", "      return endOfData();\n", "    }\n", "  }\n", "\n", "  private static <T> void pushIfPresent(Deque<T> stack, Optional<T> node) {\n", "    if (node.isPresent()) {\n", "      stack.addLast(node.get());\n", "    }\n", "  }\n", "}\n"]}, "added_lines": {}, "removed_lines": {"1": [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 58, 59, 60, 61, 62, 63, 64, 65, 66, 67, 68, 69, 70, 71, 72, 73, 74, 75, 76, 77, 78, 79, 80, 81, 82, 83, 84, 85, 86, 87, 88, 89, 90, 91, 92, 93, 94, 95, 96, 97, 98, 99, 100, 101, 102, 103, 104, 105, 106, 107, 108, 109, 110, 111, 112, 113, 114, 115, 116, 117, 118, 119, 120, 121, 122, 123, 124, 125, 126, 127, 128, 129, 130, 131, 132, 133, 134, 135, 136, 137, 138, 139, 140, 141, 142, 143, 144, 145, 146, 147, 148, 149, 150, 151, 152, 153, 154, 155, 156, 157, 158, 159, 160, 161, 162, 163, 164, 165, 166, 167, 168, 169, 170, 171, 172, 173, 174, 175, 176, 177, 178, 179, 180, 181, 182, 183, 184, 185, 186, 187, 188, 189, 190, 191, 192, 193, 194, 195, 196, 197, 198, 199, 200, 201, 202, 203, 204, 205, 206, 207, 208, 209, 210, 211, 212, 213, 214]}}, {"5": "android/guava/src/com/google/common/collect/TreeTraverser.java", "added": {"1": [" *     <p>This class is scheduled to be removed in April 2018.\n"]}, "removed": {"1": [" *     <p>This class is scheduled to be removed in January 2018.\n"], "2": ["  // overridden in BinaryTreeTraverser\n"], "3": ["  // overridden in BinaryTreeTraverser\n"]}, "added_lines": {"1": [70]}, "removed_lines": {"1": [70], "2": [123], "3": [177]}}, {"6": "android/guava/src/com/google/common/graph/Graphs.java", "added": {"1": ["   * @deprecated Use {@link Graph#equals(Object)} instead. This method is scheduled to be removed in\n", "   *     April 2018.\n", "  // TODO(b/72241742): Remove by 2018-04\n", "   * @deprecated Use {@link ValueGraph#equals(Object)} instead. This method is scheduled to be\n", "   *     removed in April 2018.\n", "  // TODO(b/72241742): Remove by 2018-04\n"], "2": ["   * @deprecated Use {@link Network#equals(Object)} instead. This method is scheduled to be removed\n", "   *     in April 2018.\n", "  // TODO(b/72241742): Remove by 2018-04\n"]}, "removed": {"1": ["   * @deprecated Use {@link Graph#equals(Object)} instead. This method will be removed in January\n", "   *     2018.\n", "  // TODO(user): Delete this method.\n", "   * @deprecated Use {@link ValueGraph#equals(Object)} instead. This method will be removed in\n", "   *     January 2018.\n", "  // TODO(user): Delete this method.\n"], "2": ["   * @deprecated Use {@link Network#equals(Object)} instead. This method will be removed in January\n", "   *     2018.\n", "  // TODO(user): Delete this method.\n"]}, "added_lines": {"1": [213, 214, 216, 223, 224, 226], "2": [234, 235, 237]}, "removed_lines": {"1": [213, 214, 216, 223, 224, 226], "2": [234, 235, 237]}}, {"7": "android/guava/src/com/google/common/util/concurrent/Futures.java", "added": {"1": ["   *     themselves. This method is scheduled for removal from Guava in April 2018.\n", "  // TODO(b/72241575): Remove by 2018-04\n"], "2": ["   *     themselves. This method is scheduled for removal from Guava in April 2018.\n", "  // TODO(b/72241893): Remove by 2018-04\n"], "3": ["   *     themselves. This method is scheduled for removal from Guava in April 2018.\n", "  // TODO(b/72241500): Remove by 2018-04\n"]}, "removed": {"1": ["   *     themselves. This method is scheduled for removal from Guava in February 2018.\n"], "2": ["   *     themselves. This method is scheduled for removal from Guava in February 2018.\n"], "3": ["   *     themselves. This method is scheduled for removal from Guava in February 2018.\n"], "4": ["  /**\n", "   * Returns a new {@code ListenableFuture} whose result is the product of calling {@code get()} on\n", "   * the {@code Future} nested within the given {@code Future}, effectively chaining the futures one\n", "   * after the other. Example:\n", "   *\n", "   * <pre>{@code\n", "   * SettableFuture<ListenableFuture<String>> nested = SettableFuture.create();\n", "   * ListenableFuture<String> dereferenced = dereference(nested);\n", "   * }</pre>\n", "   *\n", "   * <p>Most users will not need this method. To create a {@code Future} that completes with the\n", "   * result of another {@code Future}, create a {@link SettableFuture}, and call {@link\n", "   * SettableFuture#setFuture setFuture(otherFuture)} on it.\n", "   *\n", "   * <p>{@code dereference} has the same cancellation and execution semantics as {@link\n", "   * #transformAsync(ListenableFuture, AsyncFunction, Executor)}, in that the returned {@code\n", "   * Future} attempts to keep its cancellation state in sync with both the input {@code Future} and\n", "   * the nested {@code Future}. The transformation is very lightweight and therefore takes place in\n", "   * the same thread (either the thread that called {@code dereference}, or the thread in which the\n", "   * dereferenced future completes).\n", "   *\n", "   * @deprecated Use {@link #submitAsync(AsyncCallable, Executor)} or {@link\n", "   *     SettableFuture#setFuture} instead. Or, if you're dereferencing the output of {@link\n", "   *     #transform} or {@link #catching}, switch to {@link #transformAsync} or {@link\n", "   *     #catchingAsync} (and likewise for similar APIs). If the cancellation of this method's\n", "   *     output future races with completion of the outer input future, cancellation may not be\n", "   *     propagated to the inner input future. This method is scheduled to be removed in January\n", "   *     2018.\n", "   * @param nested The nested future to transform.\n", "   * @return A future that holds result of the inner future.\n", "   * @since 13.0\n", "   */\n", "  @Deprecated\n", "  @SuppressWarnings({\"rawtypes\", \"unchecked\"})\n", "  public static <V> ListenableFuture<V> dereference(\n", "      ListenableFuture<? extends ListenableFuture<? extends V>> nested) {\n", "    return transformAsync(\n", "        (ListenableFuture) nested, (AsyncFunction) DEREFERENCER, directExecutor());\n", "  }\n", "\n", "  /** Helper {@code Function} for {@link #dereference}. */\n", "  private static final AsyncFunction<ListenableFuture<Object>, Object> DEREFERENCER =\n", "      new AsyncFunction<ListenableFuture<Object>, Object>() {\n", "        @Override\n", "        public ListenableFuture<Object> apply(ListenableFuture<Object> input) {\n", "          return input;\n", "        }\n", "      };\n", "\n"]}, "added_lines": {"1": [147, 149], "2": [186, 188], "3": [233, 235]}, "removed_lines": {"1": [147], "2": [185], "3": [231], "4": [770, 771, 772, 773, 774, 775, 776, 777, 778, 779, 780, 781, 782, 783, 784, 785, 786, 787, 788, 789, 790, 791, 792, 793, 794, 795, 796, 797, 798, 799, 800, 801, 802, 803, 804, 805, 806, 807, 808, 809, 810, 811, 812, 813, 814, 815, 816, 817, 818]}}, {"8": "android/guava/src/com/google/common/util/concurrent/MoreExecutors.java", "added": {}, "removed": {"1": ["  /**\n", "   * Returns an {@link Executor} that runs each task executed sequentially, such that no two tasks\n", "   * are running concurrently. Submitted tasks have a happens-before order as defined in the Java\n", "   * Language Specification.\n", "   *\n", "   * <p>The executor uses {@code delegate} in order to {@link Executor#execute execute} each task in\n", "   * turn, and does not create any threads of its own.\n", "   *\n", "   * <p>After execution begins on a thread from the {@code delegate} {@link Executor}, tasks are\n", "   * polled and executed from a task queue until there are no more tasks. The thread will not be\n", "   * released until there are no more tasks to run.\n", "   *\n", "   * <p>If a task is submitted while a thread is executing tasks from the task queue, the thread\n", "   * will not be released until that submitted task is also complete.\n", "   *\n", "   * <p>Tasks are always started with the Thread in an uninterrupted state.\n", "   *\n", "   * <p>If the thread is {@linkplain Thread#interrupt interrupted} while a task is running or before\n", "   * the thread is taken by the Executor:\n", "   *\n", "   * <ol>\n", "   *   <li>execution will not stop until the task queue is empty.\n", "   *   <li>the interrupt will be restored to the thread after it completes so that its {@code\n", "   *       delegate} Executor may process the interrupt.\n", "   * </ol>\n", "   *\n", "   * <p>{@code RuntimeException}s thrown by tasks are simply logged and the executor keeps trucking.\n", "   * If an {@code Error} is thrown, the error will propagate and execution will stop until the next\n", "   * time a task is submitted.\n", "   *\n", "   * <p>When an {@code Error} is thrown by an executed task, previously submitted tasks may never\n", "   * run. An attempt will be made to restart execution on the next call to {@code execute}. If the\n", "   * {@code delegate} has begun to reject execution, the previously submitted tasks may never run,\n", "   * despite not throwing a RejectedExecutionException synchronously with the call to {@code\n", "   * execute}. If this behaviour is problematic, use an Executor with a single thread (e.g. {@link\n", "   * Executors#newSingleThreadExecutor}).\n", "   *\n", "   * @deprecated Use {@link #newSequentialExecutor}. This method is scheduled for removal in January\n", "   *     2018.\n", "   * @since 23.1\n", "   */\n", "  @Beta\n", "  @Deprecated\n", "  @GwtIncompatible\n", "  public static Executor sequentialExecutor(Executor delegate) {\n", "    return new SequentialExecutor(delegate);\n", "  }\n", "\n"]}, "added_lines": {}, "removed_lines": {"1": [407, 408, 409, 410, 411, 412, 413, 414, 415, 416, 417, 418, 419, 420, 421, 422, 423, 424, 425, 426, 427, 428, 429, 430, 431, 432, 433, 434, 435, 436, 437, 438, 439, 440, 441, 442, 443, 444, 445, 446, 447, 448, 449, 450, 451, 452, 453, 454]}}, {"9": "guava-gwt/test/com/google/common/collect/TreeTraverserTest_gwt.java", "added": {}, "removed": {"1": ["public void testInOrder() throws Exception {\n", "  com.google.common.collect.TreeTraverserTest testCase = new com.google.common.collect.TreeTraverserTest();\n", "  testCase.testInOrder();\n", "}\n", "\n"]}, "added_lines": {}, "removed_lines": {"1": [26, 27, 28, 29, 30]}}, {"10": "guava-gwt/test/com/google/common/util/concurrent/FuturesTest_gwt.java", "added": {}, "removed": {"1": ["public void testDereference_genericsHierarchy() throws Exception {\n", "  com.google.common.util.concurrent.FuturesTest testCase = new com.google.common.util.concurrent.FuturesTest();\n", "  testCase.setUp();\n", "  Throwable failure = null;\n", "  try {\n", "    testCase.testDereference_genericsHierarchy();\n", "  } catch (Throwable t) {\n", "    failure = t;\n", "  }\n", "  try {\n", "    testCase.tearDown();\n", "  } catch (Throwable t) {\n", "    if (failure == null) {\n", "      failure = t;\n", "    }\n", "  }\n", "  if (failure instanceof Exception) {\n", "    throw (Exception) failure;\n", "  }\n", "  if (failure instanceof Error) {\n", "    throw (Error) failure;\n", "  }\n", "  if (failure != null) {\n", "    throw new RuntimeException(failure);\n", "  }\n", "}\n", "\n", "public void testDereference_genericsWildcard() throws Exception {\n", "  com.google.common.util.concurrent.FuturesTest testCase = new com.google.common.util.concurrent.FuturesTest();\n", "  testCase.setUp();\n", "  Throwable failure = null;\n", "  try {\n", "    testCase.testDereference_genericsWildcard();\n", "  } catch (Throwable t) {\n", "    failure = t;\n", "  }\n", "  try {\n", "    testCase.tearDown();\n", "  } catch (Throwable t) {\n", "    if (failure == null) {\n", "      failure = t;\n", "    }\n", "  }\n", "  if (failure instanceof Exception) {\n", "    throw (Exception) failure;\n", "  }\n", "  if (failure instanceof Error) {\n", "    throw (Error) failure;\n", "  }\n", "  if (failure != null) {\n", "    throw new RuntimeException(failure);\n", "  }\n", "}\n", "\n", "public void testDereference_innerCancelsResult() throws Exception {\n", "  com.google.common.util.concurrent.FuturesTest testCase = new com.google.common.util.concurrent.FuturesTest();\n", "  testCase.setUp();\n", "  Throwable failure = null;\n", "  try {\n", "    testCase.testDereference_innerCancelsResult();\n", "  } catch (Throwable t) {\n", "    failure = t;\n", "  }\n", "  try {\n", "    testCase.tearDown();\n", "  } catch (Throwable t) {\n", "    if (failure == null) {\n", "      failure = t;\n", "    }\n", "  }\n", "  if (failure instanceof Exception) {\n", "    throw (Exception) failure;\n", "  }\n", "  if (failure instanceof Error) {\n", "    throw (Error) failure;\n", "  }\n", "  if (failure != null) {\n", "    throw new RuntimeException(failure);\n", "  }\n", "}\n", "\n", "public void testDereference_outerCancelsResult() throws Exception {\n", "  com.google.common.util.concurrent.FuturesTest testCase = new com.google.common.util.concurrent.FuturesTest();\n", "  testCase.setUp();\n", "  Throwable failure = null;\n", "  try {\n", "    testCase.testDereference_outerCancelsResult();\n", "  } catch (Throwable t) {\n", "    failure = t;\n", "  }\n", "  try {\n", "    testCase.tearDown();\n", "  } catch (Throwable t) {\n", "    if (failure == null) {\n", "      failure = t;\n", "    }\n", "  }\n", "  if (failure instanceof Exception) {\n", "    throw (Exception) failure;\n", "  }\n", "  if (failure instanceof Error) {\n", "    throw (Error) failure;\n", "  }\n", "  if (failure != null) {\n", "    throw new RuntimeException(failure);\n", "  }\n", "}\n", "\n", "public void testDereference_resultCancelsInner() throws Exception {\n", "  com.google.common.util.concurrent.FuturesTest testCase = new com.google.common.util.concurrent.FuturesTest();\n", "  testCase.setUp();\n", "  Throwable failure = null;\n", "  try {\n", "    testCase.testDereference_resultCancelsInner();\n", "  } catch (Throwable t) {\n", "    failure = t;\n", "  }\n", "  try {\n", "    testCase.tearDown();\n", "  } catch (Throwable t) {\n", "    if (failure == null) {\n", "      failure = t;\n", "    }\n", "  }\n", "  if (failure instanceof Exception) {\n", "    throw (Exception) failure;\n", "  }\n", "  if (failure instanceof Error) {\n", "    throw (Error) failure;\n", "  }\n", "  if (failure != null) {\n", "    throw new RuntimeException(failure);\n", "  }\n", "}\n", "\n", "public void testDereference_resultCancelsOuter() throws Exception {\n", "  com.google.common.util.concurrent.FuturesTest testCase = new com.google.common.util.concurrent.FuturesTest();\n", "  testCase.setUp();\n", "  Throwable failure = null;\n", "  try {\n", "    testCase.testDereference_resultCancelsOuter();\n", "  } catch (Throwable t) {\n", "    failure = t;\n", "  }\n", "  try {\n", "    testCase.tearDown();\n", "  } catch (Throwable t) {\n", "    if (failure == null) {\n", "      failure = t;\n", "    }\n", "  }\n", "  if (failure instanceof Exception) {\n", "    throw (Exception) failure;\n", "  }\n", "  if (failure instanceof Error) {\n", "    throw (Error) failure;\n", "  }\n", "  if (failure != null) {\n", "    throw new RuntimeException(failure);\n", "  }\n", "}\n", "\n"]}, "added_lines": {}, "removed_lines": {"1": [1641, 1642, 1643, 1644, 1645, 1646, 1647, 1648, 1649, 1650, 1651, 1652, 1653, 1654, 1655, 1656, 1657, 1658, 1659, 1660, 1661, 1662, 1663, 1664, 1665, 1666, 1667, 1668, 1669, 1670, 1671, 1672, 1673, 1674, 1675, 1676, 1677, 1678, 1679, 1680, 1681, 1682, 1683, 1684, 1685, 1686, 1687, 1688, 1689, 1690, 1691, 1692, 1693, 1694, 1695, 1696, 1697, 1698, 1699, 1700, 1701, 1702, 1703, 1704, 1705, 1706, 1707, 1708, 1709, 1710, 1711, 1712, 1713, 1714, 1715, 1716, 1717, 1718, 1719, 1720, 1721, 1722, 1723, 1724, 1725, 1726, 1727, 1728, 1729, 1730, 1731, 1732, 1733, 1734, 1735, 1736, 1737, 1738, 1739, 1740, 1741, 1742, 1743, 1744, 1745, 1746, 1747, 1748, 1749, 1750, 1751, 1752, 1753, 1754, 1755, 1756, 1757, 1758, 1759, 1760, 1761, 1762, 1763, 1764, 1765, 1766, 1767, 1768, 1769, 1770, 1771, 1772, 1773, 1774, 1775, 1776, 1777, 1778, 1779, 1780, 1781, 1782, 1783, 1784, 1785, 1786, 1787, 1788, 1789, 1790, 1791, 1792, 1793, 1794, 1795, 1796, 1797, 1798, 1799, 1800, 1801, 1802]}}, {"11": "guava-tests/benchmark/com/google/common/collect/BinaryTreeTraverserBenchmark.java", "added": {"1": ["import com.google.common.collect.ImmutableList;\n", " * Benchmarks for the {@code TreeTraverser} operations on binary trees.\n"], "2": ["          return Optional.presentInstances(ImmutableList.of(root.left, root.right));\n"], "3": ["    this.view = traversal.view(topology.createTree(size, rng).get(), VIEWER);\n"]}, "removed": {"1": [" * Benchmarks for the {@code TreeTraverser} and optimized {@code BinaryTreeTraverser} operations on\n", " * binary trees.\n"], "2": ["  private static final BinaryTreeTraverser<BinaryNode> BINARY_VIEWER =\n", "      new BinaryTreeTraverser<BinaryNode>() {\n", "\n", "        @Override\n", "        public Optional<BinaryNode> leftChild(BinaryNode node) {\n", "          return node.left;\n", "        }\n", "\n", "        @Override\n", "        public Optional<BinaryNode> rightChild(BinaryNode node) {\n", "          return node.right;\n", "        }\n", "      };\n", "\n", "          return BINARY_VIEWER.children(root);\n"], "3": ["  @Param boolean useBinaryTraverser;\n", "\n", "    this.view =\n", "        traversal.view(\n", "            topology.createTree(size, rng).get(), useBinaryTraverser ? BINARY_VIEWER : VIEWER);\n"]}, "added_lines": {"1": [21, 27], "2": [117], "3": [158]}, "removed_lines": {"1": [26, 27], "2": [113, 114, 115, 116, 117, 118, 119, 120, 121, 122, 123, 124, 125, 126, 131], "3": [167, 168, 174, 175, 176]}}, {"12": "guava-tests/test/com/google/common/collect/TreeTraverserTest.java", "added": {}, "removed": {"1": ["import com.google.common.base.Optional;\n", "import org.checkerframework.checker.nullness.compatqual.NullableDecl;\n"], "2": ["  private static final class BinaryTree extends Node {\n", "    @NullableDecl final BinaryTree left;\n", "    @NullableDecl final BinaryTree right;\n", "\n", "    private BinaryTree(char value, BinaryTree left, BinaryTree right) {\n", "      super(value);\n", "      this.left = left;\n", "      this.right = right;\n", "    }\n", "  }\n", "\n"], "3": ["  private static final BinaryTreeTraverser<BinaryTree> BIN_ADAPTER =\n", "      new BinaryTreeTraverser<BinaryTree>() {\n", "\n", "        @Override\n", "        public Optional<BinaryTree> leftChild(BinaryTree node) {\n", "          return Optional.fromNullable(node.left);\n", "        }\n", "\n", "        @Override\n", "        public Optional<BinaryTree> rightChild(BinaryTree node) {\n", "          return Optional.fromNullable(node.right);\n", "        }\n", "      };\n", "\n"], "4": ["  //      d\n", "  //     / \\\n", "  //    b   e\n", "  //   / \\   \\\n", "  //  a   c   f\n", "  //         /\n", "  //        g\n", "  static final BinaryTree ba = new BinaryTree('a', null, null);\n", "  static final BinaryTree bc = new BinaryTree('c', null, null);\n", "  static final BinaryTree bb = new BinaryTree('b', ba, bc);\n", "  static final BinaryTree bg = new BinaryTree('g', null, null);\n", "  static final BinaryTree bf = new BinaryTree('f', bg, null);\n", "  static final BinaryTree be = new BinaryTree('e', null, bf);\n", "  static final BinaryTree bd = new BinaryTree('d', bb, be);\n", "\n"], "5": ["    assertThat(iterationOrder(BIN_ADAPTER.preOrderTraversal(bd))).isEqualTo(\"dbacefg\");\n", "    assertThat(iterationOrder(BIN_ADAPTER.postOrderTraversal(bd))).isEqualTo(\"acbgfed\");\n", "    assertThat(iterationOrder(BIN_ADAPTER.breadthFirstTraversal(bd))).isEqualTo(\"dbeacfg\");\n", "  }\n", "\n", "  public void testInOrder() {\n", "    assertThat(iterationOrder(BIN_ADAPTER.inOrderTraversal(bd))).isEqualTo(\"abcdegf\");\n"], "6": ["    tester.testAllPublicInstanceMethods(BIN_ADAPTER);\n"]}, "added_lines": {}, "removed_lines": {"1": [22, 27], "2": [53, 54, 55, 56, 57, 58, 59, 60, 61, 62, 63], "3": [81, 82, 83, 84, 85, 86, 87, 88, 89, 90, 91, 92, 93, 94], "4": [111, 112, 113, 114, 115, 116, 117, 118, 119, 120, 121, 122, 123, 124, 125], "5": [141, 146, 151, 152, 153, 154, 155], "6": [166]}}, {"13": "guava-tests/test/com/google/common/util/concurrent/FuturesTest.java", "added": {}, "removed": {"1": ["import static com.google.common.util.concurrent.Futures.dereference;\n"], "2": ["  public void testDereference_genericsWildcard() throws Exception {\n", "    ListenableFuture<?> inner = immediateFuture(null);\n", "    @SuppressWarnings(\"FutureReturnValueIgnored\")\n", "    ListenableFuture<ListenableFuture<?>> outer =\n", "        Futures.<ListenableFuture<?>>immediateFuture(inner);\n", "    ListenableFuture<?> dereferenced = dereference(outer);\n", "    assertNull(getDone(dereferenced));\n", "  }\n", "\n", "  public void testDereference_genericsHierarchy() throws Exception {\n", "    FooChild fooChild = new FooChild();\n", "    ListenableFuture<FooChild> inner = immediateFuture(fooChild);\n", "    @SuppressWarnings(\"FutureReturnValueIgnored\")\n", "    ListenableFuture<ListenableFuture<FooChild>> outer = immediateFuture(inner);\n", "    ListenableFuture<Foo> dereferenced = Futures.<Foo>dereference(outer);\n", "    assertSame(fooChild, getDone(dereferenced));\n", "  }\n", "\n", "  public void testDereference_resultCancelsOuter() throws Exception {\n", "    @SuppressWarnings(\"FutureReturnValueIgnored\")\n", "    ListenableFuture<ListenableFuture<Foo>> outer = SettableFuture.create();\n", "    ListenableFuture<Foo> dereferenced = dereference(outer);\n", "    dereferenced.cancel(true);\n", "    assertTrue(outer.isCancelled());\n", "  }\n", "\n", "  public void testDereference_resultCancelsInner() throws Exception {\n", "    ListenableFuture<Foo> inner = SettableFuture.create();\n", "    @SuppressWarnings(\"FutureReturnValueIgnored\")\n", "    ListenableFuture<ListenableFuture<Foo>> outer = immediateFuture(inner);\n", "    ListenableFuture<Foo> dereferenced = dereference(outer);\n", "    dereferenced.cancel(true);\n", "    assertTrue(inner.isCancelled());\n", "  }\n", "\n", "  public void testDereference_outerCancelsResult() throws Exception {\n", "    @SuppressWarnings(\"FutureReturnValueIgnored\")\n", "    ListenableFuture<ListenableFuture<Foo>> outer = SettableFuture.create();\n", "    ListenableFuture<Foo> dereferenced = dereference(outer);\n", "    outer.cancel(true);\n", "    assertTrue(dereferenced.isCancelled());\n", "  }\n", "\n", "  public void testDereference_innerCancelsResult() throws Exception {\n", "    ListenableFuture<Foo> inner = SettableFuture.create();\n", "    @SuppressWarnings(\"FutureReturnValueIgnored\")\n", "    ListenableFuture<ListenableFuture<Foo>> outer = immediateFuture(inner);\n", "    ListenableFuture<Foo> dereferenced = dereference(outer);\n", "    inner.cancel(true);\n", "    assertTrue(dereferenced.isCancelled());\n", "  }\n", "\n"]}, "added_lines": {}, "removed_lines": {"1": [30], "2": [2085, 2086, 2087, 2088, 2089, 2090, 2091, 2092, 2093, 2094, 2095, 2096, 2097, 2098, 2099, 2100, 2101, 2102, 2103, 2104, 2105, 2106, 2107, 2108, 2109, 2110, 2111, 2112, 2113, 2114, 2115, 2116, 2117, 2118, 2119, 2120, 2121, 2122, 2123, 2124, 2125, 2126, 2127, 2128, 2129, 2130, 2131, 2132, 2133, 2134, 2135, 2136]}}, {"14": "guava/src/com/google/common/base/Predicates.java", "added": {"1": ["   *     to be removed in April 2018.\n", "  // TODO(b/72241559): Remove by 2018-04\n"]}, "removed": {"1": ["   *     to be removed in January 2018.\n"]}, "added_lines": {"1": [193, 196]}, "removed_lines": {"1": [193]}}, {"15": "guava/src/com/google/common/collect/BinaryTreeTraverser.java", "added": {}, "removed": {"1": ["/*\n", " * Copyright (C) 2012 The Guava Authors\n", " *\n", " * Licensed under the Apache License, Version 2.0 (the \"License\");\n", " * you may not use this file except in compliance with the License.\n", " * You may obtain a copy of the License at\n", " *\n", " * http://www.apache.org/licenses/LICENSE-2.0\n", " *\n", " * Unless required by applicable law or agreed to in writing, software\n", " * distributed under the License is distributed on an \"AS IS\" BASIS,\n", " * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n", " * See the License for the specific language governing permissions and\n", " * limitations under the License.\n", " */\n", "\n", "package com.google.common.collect;\n", "\n", "import static com.google.common.base.Preconditions.checkNotNull;\n", "\n", "import com.google.common.annotations.Beta;\n", "import com.google.common.annotations.GwtCompatible;\n", "import com.google.common.base.Optional;\n", "import java.util.ArrayDeque;\n", "import java.util.BitSet;\n", "import java.util.Deque;\n", "import java.util.Iterator;\n", "import java.util.function.Consumer;\n", "\n", "/**\n", " * A variant of {@link TreeTraverser} for binary trees, providing additional traversals specific to\n", " * binary trees.\n", " *\n", " * @author Louis Wasserman\n", " * @since 15.0\n", " * @deprecated Use {@link com.google.common.graph.Traverser} instead. All instance methods except\n", " *     for {@link #inOrderTraversal} have their equivalent on the result of {@code\n", " *     Traverser.forTree(tree)} where {@code tree} implements {@code SuccessorsFunction}, which has\n", " *     a similar API as {@link #children}.\n", " *     <p>This class is scheduled to be removed in January 2018.\n", " */\n", "@Deprecated\n", "@Beta\n", "@GwtCompatible\n", "public abstract class BinaryTreeTraverser<T> extends TreeTraverser<T> {\n", "\n", "  /**\n", "   * Returns the left child of the specified node, or {@link Optional#absent()} if the specified\n", "   * node has no left child.\n", "   */\n", "  public abstract Optional<T> leftChild(T root);\n", "\n", "  /**\n", "   * Returns the right child of the specified node, or {@link Optional#absent()} if the specified\n", "   * node has no right child.\n", "   */\n", "  public abstract Optional<T> rightChild(T root);\n", "\n", "  /** Returns the children of this node, in left-to-right order. */\n", "  @Override\n", "  public final Iterable<T> children(final T root) {\n", "    checkNotNull(root);\n", "    return new FluentIterable<T>() {\n", "      @Override\n", "      public Iterator<T> iterator() {\n", "        return new AbstractIterator<T>() {\n", "          boolean doneLeft;\n", "          boolean doneRight;\n", "\n", "          @Override\n", "          protected T computeNext() {\n", "            if (!doneLeft) {\n", "              doneLeft = true;\n", "              Optional<T> left = leftChild(root);\n", "              if (left.isPresent()) {\n", "                return left.get();\n", "              }\n", "            }\n", "            if (!doneRight) {\n", "              doneRight = true;\n", "              Optional<T> right = rightChild(root);\n", "              if (right.isPresent()) {\n", "                return right.get();\n", "              }\n", "            }\n", "            return endOfData();\n", "          }\n", "        };\n", "      }\n", "\n", "      @Override\n", "      public void forEach(Consumer<? super T> action) {\n", "        acceptIfPresent(action, leftChild(root));\n", "        acceptIfPresent(action, rightChild(root));\n", "      }\n", "    };\n", "  }\n", "\n", "  @Override\n", "  UnmodifiableIterator<T> preOrderIterator(T root) {\n", "    return new PreOrderIterator(root);\n", "  }\n", "\n", "  /*\n", "   * Optimized implementation of preOrderIterator for binary trees.\n", "   */\n", "  private final class PreOrderIterator extends UnmodifiableIterator<T>\n", "      implements PeekingIterator<T> {\n", "    private final Deque<T> stack;\n", "\n", "    PreOrderIterator(T root) {\n", "      this.stack = new ArrayDeque<T>(8);\n", "      stack.addLast(root);\n", "    }\n", "\n", "    @Override\n", "    public boolean hasNext() {\n", "      return !stack.isEmpty();\n", "    }\n", "\n", "    @Override\n", "    public T next() {\n", "      T result = stack.removeLast();\n", "      pushIfPresent(stack, rightChild(result));\n", "      pushIfPresent(stack, leftChild(result));\n", "      return result;\n", "    }\n", "\n", "    @Override\n", "    public T peek() {\n", "      return stack.getLast();\n", "    }\n", "  }\n", "\n", "  @Override\n", "  UnmodifiableIterator<T> postOrderIterator(T root) {\n", "    return new PostOrderIterator(root);\n", "  }\n", "\n", "  /*\n", "   * Optimized implementation of postOrderIterator for binary trees.\n", "   */\n", "  private final class PostOrderIterator extends UnmodifiableIterator<T> {\n", "    private final Deque<T> stack;\n", "    private final BitSet hasExpanded;\n", "\n", "    PostOrderIterator(T root) {\n", "      this.stack = new ArrayDeque<T>(8);\n", "      stack.addLast(root);\n", "      this.hasExpanded = new BitSet();\n", "    }\n", "\n", "    @Override\n", "    public boolean hasNext() {\n", "      return !stack.isEmpty();\n", "    }\n", "\n", "    @Override\n", "    public T next() {\n", "      while (true) {\n", "        T node = stack.getLast();\n", "        boolean expandedNode = hasExpanded.get(stack.size() - 1);\n", "        if (expandedNode) {\n", "          stack.removeLast();\n", "          hasExpanded.clear(stack.size());\n", "          return node;\n", "        } else {\n", "          hasExpanded.set(stack.size() - 1);\n", "          pushIfPresent(stack, rightChild(node));\n", "          pushIfPresent(stack, leftChild(node));\n", "        }\n", "      }\n", "    }\n", "  }\n", "\n", "  // TODO(lowasser): see if any significant optimizations are possible for breadthFirstIterator\n", "\n", "  public final FluentIterable<T> inOrderTraversal(final T root) {\n", "    checkNotNull(root);\n", "    return new FluentIterable<T>() {\n", "      @Override\n", "      public UnmodifiableIterator<T> iterator() {\n", "        return new InOrderIterator(root);\n", "      }\n", "\n", "      @Override\n", "      public void forEach(Consumer<? super T> action) {\n", "        checkNotNull(action);\n", "        new Consumer<T>() {\n", "          @Override\n", "          public void accept(T t) {\n", "            acceptIfPresent(this, leftChild(t));\n", "            action.accept(t);\n", "            acceptIfPresent(this, rightChild(t));\n", "          }\n", "        }.accept(root);\n", "      }\n", "    };\n", "  }\n", "\n", "  private final class InOrderIterator extends AbstractIterator<T> {\n", "    private final Deque<T> stack;\n", "    private final BitSet hasExpandedLeft;\n", "\n", "    InOrderIterator(T root) {\n", "      this.stack = new ArrayDeque<T>(8);\n", "      this.hasExpandedLeft = new BitSet();\n", "      stack.addLast(root);\n", "    }\n", "\n", "    @Override\n", "    protected T computeNext() {\n", "      while (!stack.isEmpty()) {\n", "        T node = stack.getLast();\n", "        if (hasExpandedLeft.get(stack.size() - 1)) {\n", "          stack.removeLast();\n", "          hasExpandedLeft.clear(stack.size());\n", "          pushIfPresent(stack, rightChild(node));\n", "          return node;\n", "        } else {\n", "          hasExpandedLeft.set(stack.size() - 1);\n", "          pushIfPresent(stack, leftChild(node));\n", "        }\n", "      }\n", "      return endOfData();\n", "    }\n", "  }\n", "\n", "  private static <T> void pushIfPresent(Deque<T> stack, Optional<T> node) {\n", "    if (node.isPresent()) {\n", "      stack.addLast(node.get());\n", "    }\n", "  }\n", "\n", "  private static <T> void acceptIfPresent(Consumer<? super T> action, Optional<T> node) {\n", "    if (node.isPresent()) {\n", "      action.accept(node.get());\n", "    }\n", "  }\n", "}\n"]}, "added_lines": {}, "removed_lines": {"1": [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 58, 59, 60, 61, 62, 63, 64, 65, 66, 67, 68, 69, 70, 71, 72, 73, 74, 75, 76, 77, 78, 79, 80, 81, 82, 83, 84, 85, 86, 87, 88, 89, 90, 91, 92, 93, 94, 95, 96, 97, 98, 99, 100, 101, 102, 103, 104, 105, 106, 107, 108, 109, 110, 111, 112, 113, 114, 115, 116, 117, 118, 119, 120, 121, 122, 123, 124, 125, 126, 127, 128, 129, 130, 131, 132, 133, 134, 135, 136, 137, 138, 139, 140, 141, 142, 143, 144, 145, 146, 147, 148, 149, 150, 151, 152, 153, 154, 155, 156, 157, 158, 159, 160, 161, 162, 163, 164, 165, 166, 167, 168, 169, 170, 171, 172, 173, 174, 175, 176, 177, 178, 179, 180, 181, 182, 183, 184, 185, 186, 187, 188, 189, 190, 191, 192, 193, 194, 195, 196, 197, 198, 199, 200, 201, 202, 203, 204, 205, 206, 207, 208, 209, 210, 211, 212, 213, 214, 215, 216, 217, 218, 219, 220, 221, 222, 223, 224, 225, 226, 227, 228, 229, 230, 231, 232, 233, 234, 235, 236, 237, 238, 239, 240]}}, {"16": "guava/src/com/google/common/collect/TreeTraverser.java", "added": {"1": [" *     <p>This class is scheduled to be removed in April 2018.\n"]}, "removed": {"1": [" *     <p>This class is scheduled to be removed in January 2018.\n"], "2": ["  // overridden in BinaryTreeTraverser\n"], "3": ["  // overridden in BinaryTreeTraverser\n"]}, "added_lines": {"1": [71]}, "removed_lines": {"1": [71], "2": [136], "3": [202]}}, {"17": "guava/src/com/google/common/graph/Graphs.java", "added": {"1": ["   * @deprecated Use {@link Graph#equals(Object)} instead. This method is scheduled to be removed in\n", "   *     April 2018.\n", "  // TODO(b/72241742): Remove by 2018-04\n", "   * @deprecated Use {@link ValueGraph#equals(Object)} instead. This method is scheduled to be\n", "   *     removed in April 2018.\n", "  // TODO(b/72241742): Remove by 2018-04\n"], "2": ["   * @deprecated Use {@link Network#equals(Object)} instead. This method is scheduled to be removed\n", "   *     in April 2018.\n", "  // TODO(b/72241742): Remove by 2018-04\n"]}, "removed": {"1": ["   * @deprecated Use {@link Graph#equals(Object)} instead. This method will be removed in January\n", "   *     2018.\n", "  // TODO(user): Delete this method.\n", "   * @deprecated Use {@link ValueGraph#equals(Object)} instead. This method will be removed in\n", "   *     January 2018.\n", "  // TODO(user): Delete this method.\n"], "2": ["   * @deprecated Use {@link Network#equals(Object)} instead. This method will be removed in January\n", "   *     2018.\n", "  // TODO(user): Delete this method.\n"]}, "added_lines": {"1": [214, 215, 217, 224, 225, 227], "2": [235, 236, 238]}, "removed_lines": {"1": [214, 215, 217, 224, 225, 227], "2": [235, 236, 238]}}, {"18": "guava/src/com/google/common/util/concurrent/Futures.java", "added": {"1": ["   *     themselves. This method is scheduled for removal from Guava in April 2018.\n", "  // TODO(b/72241575): Remove by 2018-04\n"], "2": ["   *     themselves. This method is scheduled for removal from Guava in April 2018.\n", "  // TODO(b/72241893): Remove by 2018-04\n"], "3": ["   *     themselves. This method is scheduled for removal from Guava in April 2018.\n", "  // TODO(b/72241500): Remove by 2018-04\n"]}, "removed": {"1": ["   *     themselves. This method is scheduled for removal from Guava in February 2018.\n"], "2": ["   *     themselves. This method is scheduled for removal from Guava in February 2018.\n"], "3": ["   *     themselves. This method is scheduled for removal from Guava in February 2018.\n"], "4": ["  /**\n", "   * Returns a new {@code ListenableFuture} whose result is the product of calling {@code get()} on\n", "   * the {@code Future} nested within the given {@code Future}, effectively chaining the futures one\n", "   * after the other. Example:\n", "   *\n", "   * <pre>{@code\n", "   * SettableFuture<ListenableFuture<String>> nested = SettableFuture.create();\n", "   * ListenableFuture<String> dereferenced = dereference(nested);\n", "   * }</pre>\n", "   *\n", "   * <p>Most users will not need this method. To create a {@code Future} that completes with the\n", "   * result of another {@code Future}, create a {@link SettableFuture}, and call {@link\n", "   * SettableFuture#setFuture setFuture(otherFuture)} on it.\n", "   *\n", "   * <p>{@code dereference} has the same cancellation and execution semantics as {@link\n", "   * #transformAsync(ListenableFuture, AsyncFunction, Executor)}, in that the returned {@code\n", "   * Future} attempts to keep its cancellation state in sync with both the input {@code Future} and\n", "   * the nested {@code Future}. The transformation is very lightweight and therefore takes place in\n", "   * the same thread (either the thread that called {@code dereference}, or the thread in which the\n", "   * dereferenced future completes).\n", "   *\n", "   * @deprecated Use {@link #submitAsync(AsyncCallable, Executor)} or {@link\n", "   *     SettableFuture#setFuture} instead. Or, if you're dereferencing the output of {@link\n", "   *     #transform} or {@link #catching}, switch to {@link #transformAsync} or {@link\n", "   *     #catchingAsync} (and likewise for similar APIs). If the cancellation of this method's\n", "   *     output future races with completion of the outer input future, cancellation may not be\n", "   *     propagated to the inner input future. This method is scheduled to be removed in January\n", "   *     2018.\n", "   * @param nested The nested future to transform.\n", "   * @return A future that holds result of the inner future.\n", "   * @since 13.0\n", "   */\n", "  @Deprecated\n", "  @SuppressWarnings({\"rawtypes\", \"unchecked\"})\n", "  public static <V> ListenableFuture<V> dereference(\n", "      ListenableFuture<? extends ListenableFuture<? extends V>> nested) {\n", "    return transformAsync(\n", "        (ListenableFuture) nested, (AsyncFunction) DEREFERENCER, directExecutor());\n", "  }\n", "\n", "  /** Helper {@code Function} for {@link #dereference}. */\n", "  private static final AsyncFunction<ListenableFuture<Object>, Object> DEREFERENCER =\n", "      new AsyncFunction<ListenableFuture<Object>, Object>() {\n", "        @Override\n", "        public ListenableFuture<Object> apply(ListenableFuture<Object> input) {\n", "          return input;\n", "        }\n", "      };\n", "\n"]}, "added_lines": {"1": [147, 149], "2": [186, 188], "3": [233, 235]}, "removed_lines": {"1": [147], "2": [185], "3": [231], "4": [770, 771, 772, 773, 774, 775, 776, 777, 778, 779, 780, 781, 782, 783, 784, 785, 786, 787, 788, 789, 790, 791, 792, 793, 794, 795, 796, 797, 798, 799, 800, 801, 802, 803, 804, 805, 806, 807, 808, 809, 810, 811, 812, 813, 814, 815, 816, 817, 818]}}, {"19": "guava/src/com/google/common/util/concurrent/MoreExecutors.java", "added": {}, "removed": {"1": ["  /**\n", "   * Returns an {@link Executor} that runs each task executed sequentially, such that no two tasks\n", "   * are running concurrently. Submitted tasks have a happens-before order as defined in the Java\n", "   * Language Specification.\n", "   *\n", "   * <p>The executor uses {@code delegate} in order to {@link Executor#execute execute} each task in\n", "   * turn, and does not create any threads of its own.\n", "   *\n", "   * <p>After execution begins on a thread from the {@code delegate} {@link Executor}, tasks are\n", "   * polled and executed from a task queue until there are no more tasks. The thread will not be\n", "   * released until there are no more tasks to run.\n", "   *\n", "   * <p>If a task is submitted while a thread is executing tasks from the task queue, the thread\n", "   * will not be released until that submitted task is also complete.\n", "   *\n", "   * <p>Tasks are always started with the Thread in an uninterrupted state.\n", "   *\n", "   * <p>If the thread is {@linkplain Thread#interrupt interrupted} while a task is running or before\n", "   * the thread is taken by the Executor:\n", "   *\n", "   * <ol>\n", "   *   <li>execution will not stop until the task queue is empty.\n", "   *   <li>the interrupt will be restored to the thread after it completes so that its {@code\n", "   *       delegate} Executor may process the interrupt.\n", "   * </ol>\n", "   *\n", "   * <p>{@code RuntimeException}s thrown by tasks are simply logged and the executor keeps trucking.\n", "   * If an {@code Error} is thrown, the error will propagate and execution will stop until the next\n", "   * time a task is submitted.\n", "   *\n", "   * <p>When an {@code Error} is thrown by an executed task, previously submitted tasks may never\n", "   * run. An attempt will be made to restart execution on the next call to {@code execute}. If the\n", "   * {@code delegate} has begun to reject execution, the previously submitted tasks may never run,\n", "   * despite not throwing a RejectedExecutionException synchronously with the call to {@code\n", "   * execute}. If this behaviour is problematic, use an Executor with a single thread (e.g. {@link\n", "   * Executors#newSingleThreadExecutor}).\n", "   *\n", "   * @deprecated Use {@link #newSequentialExecutor}. This method is scheduled for removal in January\n", "   *     2018.\n", "   * @since 23.1\n", "   */\n", "  @Beta\n", "  @Deprecated\n", "  @GwtIncompatible\n", "  public static Executor sequentialExecutor(Executor delegate) {\n", "    return new SequentialExecutor(delegate);\n", "  }\n", "\n"]}, "added_lines": {}, "removed_lines": {"1": [407, 408, 409, 410, 411, 412, 413, 414, 415, 416, 417, 418, 419, 420, 421, 422, 423, 424, 425, 426, 427, 428, 429, 430, 431, 432, 433, 434, 435, 436, 437, 438, 439, 440, 441, 442, 443, 444, 445, 446, 447, 448, 449, 450, 451, 452, 453, 454]}}]}
