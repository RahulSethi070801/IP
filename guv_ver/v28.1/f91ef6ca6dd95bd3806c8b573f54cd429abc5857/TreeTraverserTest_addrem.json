{
    "addition": {
        "34": "  private static class Node {\n",
        "37": "    Node(char value) {\n",
        "42": "  private static final class Tree extends Node {\n",
        "43": "    final List<Tree> children;\n",
        "45": "    public Tree(char value, Tree... children) {\n",
        "46": "      super(value);\n",
        "47": "      this.children = Arrays.asList(children);\n",
        "84": "  static String iterationOrder(Iterable<? extends Node> iterable) {\n",
        "86": "    for (Node t : iterable) {\n"
    },
    "removed": {
        "22": "import com.google.common.base.Optional;\n",
        "27": "import org.checkerframework.checker.nullness.compatqual.NullableDecl;\n",
        "36": "  private static final class Tree {\n",
        "38": "    final List<Tree> children;\n",
        "40": "    public Tree(char value, Tree... children) {\n",
        "42": "      this.children = Arrays.asList(children);\n",
        "46": "  private static final class BinaryTree {\n",
        "47": "    final char value;\n",
        "48": "    @NullableDecl final BinaryTree left;\n",
        "49": "    @NullableDecl final BinaryTree right;\n",
        "51": "    private BinaryTree(char value, BinaryTree left, BinaryTree right) {\n",
        "52": "      this.value = value;\n",
        "53": "      this.left = left;\n",
        "54": "      this.right = right;\n",
        "75": "  private static final BinaryTreeTraverser<BinaryTree> BIN_ADAPTER =\n",
        "76": "      new BinaryTreeTraverser<BinaryTree>() {\n",
        "77": "\n",
        "78": "        @Override\n",
        "79": "        public Optional<BinaryTree> leftChild(BinaryTree node) {\n",
        "80": "          return Optional.fromNullable(node.left);\n",
        "81": "        }\n",
        "82": "\n",
        "83": "        @Override\n",
        "84": "        public Optional<BinaryTree> rightChild(BinaryTree node) {\n",
        "85": "          return Optional.fromNullable(node.right);\n",
        "86": "        }\n",
        "87": "      };\n",
        "88": "\n",
        "105": "  //      d\n",
        "106": "  //     / \\\n",
        "107": "  //    b   e\n",
        "108": "  //   / \\   \\\n",
        "109": "  //  a   c   f\n",
        "110": "  //         /\n",
        "111": "  //        g\n",
        "112": "  static final BinaryTree ba = new BinaryTree('a', null, null);\n",
        "113": "  static final BinaryTree bc = new BinaryTree('c', null, null);\n",
        "114": "  static final BinaryTree bb = new BinaryTree('b', ba, bc);\n",
        "115": "  static final BinaryTree bg = new BinaryTree('g', null, null);\n",
        "116": "  static final BinaryTree bf = new BinaryTree('f', bg, null);\n",
        "117": "  static final BinaryTree be = new BinaryTree('e', null, bf);\n",
        "118": "  static final BinaryTree bd = new BinaryTree('d', bb, be);\n",
        "119": "\n",
        "120": "  static String iterationOrder(Iterable<Tree> iterable) {\n",
        "121": "    StringBuilder builder = new StringBuilder();\n",
        "122": "    for (Tree t : iterable) {\n",
        "123": "      builder.append(t.value);\n",
        "124": "    }\n",
        "125": "    return builder.toString();\n",
        "126": "  }\n",
        "127": "\n",
        "128": "  static String binaryIterationOrder(Iterable<BinaryTree> iterable) {\n",
        "130": "    for (BinaryTree t : iterable) {\n",
        "138": "    assertThat(binaryIterationOrder(BIN_ADAPTER.preOrderTraversal(bd))).isEqualTo(\"dbacefg\");\n",
        "143": "    assertThat(binaryIterationOrder(BIN_ADAPTER.postOrderTraversal(bd))).isEqualTo(\"acbgfed\");\n",
        "148": "    assertThat(binaryIterationOrder(BIN_ADAPTER.breadthFirstTraversal(bd))).isEqualTo(\"dbeacfg\");\n",
        "149": "  }\n",
        "150": "\n",
        "151": "  public void testInOrder() {\n",
        "152": "    assertThat(binaryIterationOrder(BIN_ADAPTER.inOrderTraversal(bd))).isEqualTo(\"abcdegf\");\n",
        "163": "    tester.testAllPublicInstanceMethods(BIN_ADAPTER);\n"
    }
}