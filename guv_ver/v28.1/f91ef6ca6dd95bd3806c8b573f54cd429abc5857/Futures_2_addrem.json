{
    "addition": {
        "147": "   *     themselves. This method is scheduled for removal from Guava in April 2018.\n",
        "149": "  // TODO(b/72241575): Remove by 2018-04\n",
        "186": "   *     themselves. This method is scheduled for removal from Guava in April 2018.\n",
        "188": "  // TODO(b/72241893): Remove by 2018-04\n",
        "233": "   *     themselves. This method is scheduled for removal from Guava in April 2018.\n",
        "235": "  // TODO(b/72241500): Remove by 2018-04\n"
    },
    "removed": {
        "147": "   *     themselves. This method is scheduled for removal from Guava in February 2018.\n",
        "185": "   *     themselves. This method is scheduled for removal from Guava in February 2018.\n",
        "231": "   *     themselves. This method is scheduled for removal from Guava in February 2018.\n",
        "770": "  /**\n",
        "771": "   * Returns a new {@code ListenableFuture} whose result is the product of calling {@code get()} on\n",
        "772": "   * the {@code Future} nested within the given {@code Future}, effectively chaining the futures one\n",
        "773": "   * after the other. Example:\n",
        "774": "   *\n",
        "775": "   * <pre>{@code\n",
        "776": "   * SettableFuture<ListenableFuture<String>> nested = SettableFuture.create();\n",
        "777": "   * ListenableFuture<String> dereferenced = dereference(nested);\n",
        "778": "   * }</pre>\n",
        "779": "   *\n",
        "780": "   * <p>Most users will not need this method. To create a {@code Future} that completes with the\n",
        "781": "   * result of another {@code Future}, create a {@link SettableFuture}, and call {@link\n",
        "782": "   * SettableFuture#setFuture setFuture(otherFuture)} on it.\n",
        "783": "   *\n",
        "784": "   * <p>{@code dereference} has the same cancellation and execution semantics as {@link\n",
        "785": "   * #transformAsync(ListenableFuture, AsyncFunction, Executor)}, in that the returned {@code\n",
        "786": "   * Future} attempts to keep its cancellation state in sync with both the input {@code Future} and\n",
        "787": "   * the nested {@code Future}. The transformation is very lightweight and therefore takes place in\n",
        "788": "   * the same thread (either the thread that called {@code dereference}, or the thread in which the\n",
        "789": "   * dereferenced future completes).\n",
        "790": "   *\n",
        "791": "   * @deprecated Use {@link #submitAsync(AsyncCallable, Executor)} or {@link\n",
        "792": "   *     SettableFuture#setFuture} instead. Or, if you're dereferencing the output of {@link\n",
        "793": "   *     #transform} or {@link #catching}, switch to {@link #transformAsync} or {@link\n",
        "794": "   *     #catchingAsync} (and likewise for similar APIs). If the cancellation of this method's\n",
        "795": "   *     output future races with completion of the outer input future, cancellation may not be\n",
        "796": "   *     propagated to the inner input future. This method is scheduled to be removed in January\n",
        "797": "   *     2018.\n",
        "798": "   * @param nested The nested future to transform.\n",
        "799": "   * @return A future that holds result of the inner future.\n",
        "800": "   * @since 13.0\n",
        "801": "   */\n",
        "802": "  @Deprecated\n",
        "803": "  @SuppressWarnings({\"rawtypes\", \"unchecked\"})\n",
        "804": "  public static <V> ListenableFuture<V> dereference(\n",
        "805": "      ListenableFuture<? extends ListenableFuture<? extends V>> nested) {\n",
        "806": "    return transformAsync(\n",
        "807": "        (ListenableFuture) nested, (AsyncFunction) DEREFERENCER, directExecutor());\n",
        "808": "  }\n",
        "809": "\n",
        "810": "  /** Helper {@code Function} for {@link #dereference}. */\n",
        "811": "  private static final AsyncFunction<ListenableFuture<Object>, Object> DEREFERENCER =\n",
        "812": "      new AsyncFunction<ListenableFuture<Object>, Object>() {\n",
        "813": "        @Override\n",
        "814": "        public ListenableFuture<Object> apply(ListenableFuture<Object> input) {\n",
        "815": "          return input;\n",
        "816": "        }\n",
        "817": "      };\n",
        "818": "\n"
    }
}