[{"func":{"oldfunccode":"40564c7415ab5fbd2dc89527d38493bc0bd2bf86/Codes_neg/Match_oldfunccode_40564c7415ab5fbd2dc89527d38493bc0bd2bf86_1.txt","newfunccode":"40564c7415ab5fbd2dc89527d38493bc0bd2bf86/Codes_neg/Match_newfunccode_40564c7415ab5fbd2dc89527d38493bc0bd2bf86_1.txt","newdoc":" Remove the interrupt bit before each task. The interrupt is for the \"current task\" when\n it is sent, so subsequent tasks in the queue should not be caused to be interrupted\n by a previous one in the queue being interrupted.\n Ensure that if the thread was interrupted at all while processing the task queue, it\n is returned to the delegate Executor interrupted so that it may handle the\n interruption if it likes.\n","newJdoc":"40564c7415ab5fbd2dc89527d38493bc0bd2bf86/Codes_neg/Match_newfuncnewJdoc_40564c7415ab5fbd2dc89527d38493bc0bd2bf86_1.txt","olddoc":" TODO(user): How should we handle interrupts and shutdowns?\n","oldJdoc":"","path":"/home/pritish/Documents/IP work/guv_ver/v28.1/40564c7415ab5fbd2dc89527d38493bc0bd2bf86/SequentialExecutor_2","pathinproj":"guava/src/com/google/common/util/concurrent/SequentialExecutor.java","addlines":[162,163,136,137,138,139,143,144,145,146,147,148,149,150,151,152,153,154,155,158],"dellines":[128,129,130,131,134,135,136,137,124,125,126],"addcode":["      boolean interruptedDuringTask = false;\n","\n","      try {\n","        while (true) {\n","          interruptedDuringTask |= Thread.interrupted();\n","          Runnable task;\n","          synchronized (queue) {\n","            task = queue.poll();\n","            if (task == null) {\n","              isWorkerRunning = false;\n","              return;\n","            }\n","          }\n","          try {\n","            task.run();\n","          } catch (RuntimeException e) {\n","            log.log(Level.SEVERE, \"Exception while executing runnable \" + task, e);\n","      } finally {\n","        if (interruptedDuringTask) {\n","          Thread.currentThread().interrupt();\n","      boolean interruptedDuringTask = false;\n","\n","      try {\n","        while (true) {\n","          interruptedDuringTask |= Thread.interrupted();\n","          Runnable task;\n","          synchronized (queue) {\n","            task = queue.poll();\n","            if (task == null) {\n","              isWorkerRunning = false;\n","              return;\n","            }\n","          }\n","          try {\n","            task.run();\n","          } catch (RuntimeException e) {\n","            log.log(Level.SEVERE, \"Exception while executing runnable \" + task, e);\n","      } finally {\n","        if (interruptedDuringTask) {\n","          Thread.currentThread().interrupt();\n"],"delcode":["      while (true) {\n","        Runnable task = null;\n","        synchronized (queue) {\n","          task = queue.poll();\n","          if (task == null) {\n","            isWorkerRunning = false;\n","            return;\n","        try {\n","          task.run();\n","        } catch (RuntimeException e) {\n","          log.log(Level.SEVERE, \"Exception while executing runnable \" + task, e);\n","      while (true) {\n","        Runnable task = null;\n","        synchronized (queue) {\n","          task = queue.poll();\n","          if (task == null) {\n","            isWorkerRunning = false;\n","            return;\n","        try {\n","          task.run();\n","        } catch (RuntimeException e) {\n","          log.log(Level.SEVERE, \"Exception while executing runnable \" + task, e);\n"],"methodSig":"private void workOnQueue()"},"doc":{"oldfunccode":"40564c7415ab5fbd2dc89527d38493bc0bd2bf86/Codes_neg/Match_olddocfunccode_40564c7415ab5fbd2dc89527d38493bc0bd2bf86_1.txt","newfunccode":"40564c7415ab5fbd2dc89527d38493bc0bd2bf86/Codes_neg/Match_newdocfunccode_40564c7415ab5fbd2dc89527d38493bc0bd2bf86_1.txt","newdoc":"","newJdoc":"40564c7415ab5fbd2dc89527d38493bc0bd2bf86/Codes_neg/Match_newdocnewJdoc_40564c7415ab5fbd2dc89527d38493bc0bd2bf86_1.txt","olddoc":"","oldJdoc":"40564c7415ab5fbd2dc89527d38493bc0bd2bf86/Codes_neg/Match_olddocJdoc_40564c7415ab5fbd2dc89527d38493bc0bd2bf86_1.txt","path":"/home/pritish/Documents/IP work/guv_ver/v28.1/40564c7415ab5fbd2dc89527d38493bc0bd2bf86/MoreExecutors_2","pathinproj":"guava/src/com/google/common/util/concurrent/MoreExecutors.java","addlines":[407,408,413,414,415,416,417,418,419,420,421,422,423,424,425,426,427,428,429,430,431,432,433,435,436,437,438,439,440],"dellines":[416,417,419,420,421,422,409,410,415],"addcode":["   * Returns an {@link Executor} that runs each task executed sequentially, such that no two tasks\n","   * are running concurrently.\n","   * <p>After execution begins on a thread from the {@code delegate} {@link Executor}, tasks are\n","   * polled and executed from a task queue until there are no more tasks. The thread will not be\n","   * released until there are no more tasks to run.\n","   *\n","   * <p>If a task is submitted while a thread is executing tasks from the task queue, the thread\n","   * will not be released until that submitted task is also complete.\n","   *\n","   * <p>Tasks are always started with the Thread in an uninterrupted state.\n","   *\n","   * <p>If the thread is {@linkplain Thread#interrupt interrupted} while a task is running or before\n","   * the thread is taken by the Executor:\n","   *\n","   * <ol>\n","   *   <li>execution will not stop until the task queue is empty.\n","   *   <li>the interrupt will be restored to the thread after it completes so that its {@code\n","   *       delegate} Executor may process the interrupt.\n","   * </ol>\n","   *\n","   * <p>{@code RuntimeException}s thrown by tasks are simply logged and the executor keeps trucking.\n","   * If an {@code Error} is thrown, the error will propagate and execution will stop until the next\n","   * time a task is submitted.\n","   * <p>When an {@code Error} is thrown by an executed task, previously submitted tasks may never\n","   * run. An attempt will be made to restart execution on the next call to {@code execute}. If the\n","   * {@code delegate} has begun to reject execution, the previously submitted tasks may never run,\n","   * despite not throwing a RejectedExecutionException synchronously with the call to {@code\n","   * execute}. If this behaviour is problematic, use an Executor with a single thread (e.g. {@link\n","   * Executors#newSingleThreadExecutor}).\n","   * Returns an {@link Executor} that runs each task executed sequentially, such that no two tasks\n","   * are running concurrently.\n","   * <p>After execution begins on a thread from the {@code delegate} {@link Executor}, tasks are\n","   * polled and executed from a task queue until there are no more tasks. The thread will not be\n","   * released until there are no more tasks to run.\n","   *\n","   * <p>If a task is submitted while a thread is executing tasks from the task queue, the thread\n","   * will not be released until that submitted task is also complete.\n","   *\n","   * <p>Tasks are always started with the Thread in an uninterrupted state.\n","   *\n","   * <p>If the thread is {@linkplain Thread#interrupt interrupted} while a task is running or before\n","   * the thread is taken by the Executor:\n","   *\n","   * <ol>\n","   *   <li>execution will not stop until the task queue is empty.\n","   *   <li>the interrupt will be restored to the thread after it completes so that its {@code\n","   *       delegate} Executor may process the interrupt.\n","   * </ol>\n","   *\n","   * <p>{@code RuntimeException}s thrown by tasks are simply logged and the executor keeps trucking.\n","   * If an {@code Error} is thrown, the error will propagate and execution will stop until the next\n","   * time a task is submitted.\n","   * <p>When an {@code Error} is thrown by an executed task, previously submitted tasks may never\n","   * run. An attempt will be made to restart execution on the next call to {@code execute}. If the\n","   * {@code delegate} has begun to reject execution, the previously submitted tasks may never run,\n","   * despite not throwing a RejectedExecutionException synchronously with the call to {@code\n","   * execute}. If this behaviour is problematic, use an Executor with a single thread (e.g. {@link\n","   * Executors#newSingleThreadExecutor}).\n"],"delcode":["   * Returns an {@link Executor} that runs each task executed sequentially, such that no\n","   * two tasks are running concurrently.\n","   * <p>After execution starts on the {@code delegate} {@link Executor}, tasks are polled and\n","   * executed from the queue until there are no more tasks. The thread will not be released until\n","   * there are no more tasks to run.\n","   * <p>If a task is {@linkplain Thread#interrupt interrupted}, execution of subsequent tasks\n","   * continues. {@code RuntimeException}s thrown by tasks are simply logged and the executor keeps\n","   * trucking. If an {@code Error} is thrown, the error will propagate and execution will stop until\n","   * the next time a task is submitted.\n","   * Returns an {@link Executor} that runs each task executed sequentially, such that no\n","   * two tasks are running concurrently.\n","   * <p>After execution starts on the {@code delegate} {@link Executor}, tasks are polled and\n","   * executed from the queue until there are no more tasks. The thread will not be released until\n","   * there are no more tasks to run.\n","   * <p>If a task is {@linkplain Thread#interrupt interrupted}, execution of subsequent tasks\n","   * continues. {@code RuntimeException}s thrown by tasks are simply logged and the executor keeps\n","   * trucking. If an {@code Error} is thrown, the error will propagate and execution will stop until\n","   * the next time a task is submitted.\n"],"methodSig":"public static Executor sequentialExecutor(Executor delegate)"},"id":1,"flag":1,"commit":"40564c7415ab5fbd2dc89527d38493bc0bd2bf86"}]