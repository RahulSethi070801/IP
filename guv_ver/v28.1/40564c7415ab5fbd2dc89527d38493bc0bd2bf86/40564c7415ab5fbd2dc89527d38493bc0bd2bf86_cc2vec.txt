{"id": "40564c7415ab5fbd2dc89527d38493bc0bd2bf86", "code": [{"0": "android/guava-tests/test/com/google/common/util/concurrent/SequentialExecutorTest.java", "added": {"1": ["import static com.google.common.truth.Truth.assertThat;\n", "\n"], "2": ["\n", "\n", "    @Override\n", "    public void execute(Runnable command) {\n"], "3": ["    Runnable intCounter =\n", "        new Runnable() {\n", "          @Override\n", "          public void run() {\n", "            totalCalls.incrementAndGet();\n", "            // Make sure that no other tasks are scheduled to run while this is running.\n", "            assertFalse(fakePool.hasNext());\n", "          }\n", "        };\n"], "4": ["    Runnable runMe =\n", "        new Runnable() {\n", "          @Override\n", "          public void run() {\n", "            numCalls.incrementAndGet();\n", "            throw new RuntimeException(\"FAKE EXCEPTION!\");\n", "          }\n", "        };\n"], "5": ["  public void testInterrupt_beforeRunRestoresInterruption() throws Exception {\n", "    // Run a task on the composed Executor that interrupts its thread (i.e. this thread).\n", "    fakePool.execute(\n", "        new Runnable() {\n", "          @Override\n", "          public void run() {\n", "            Thread.currentThread().interrupt();\n", "          }\n", "        });\n", "    // Run a task that expects that it is not interrupted while it is running.\n", "    e.execute(\n", "        new Runnable() {\n", "          @Override\n", "          public void run() {\n", "            assertThat(Thread.currentThread().isInterrupted()).isFalse();\n", "          }\n", "        });\n", "\n", "    // Run these together.\n", "    fakePool.runAll();\n", "\n", "    // Check that this thread has been marked as interrupted again now that the thread has been\n", "    // returned by SequentialExecutor. Clear the bit while checking so that the test doesn't hose\n", "    // JUnit or some other test case.\n", "    assertThat(Thread.currentThread().interrupted()).isTrue();\n", "  }\n", "\n", "  public void testInterrupt_doesNotInterruptSubsequentTask() throws Exception {\n", "    // Run a task that interrupts its thread (i.e. this thread).\n", "    e.execute(\n", "        new Runnable() {\n", "          @Override\n", "          public void run() {\n", "            Thread.currentThread().interrupt();\n", "          }\n", "        });\n", "    // Run a task that expects that it is not interrupted while it is running.\n", "    e.execute(\n", "        new Runnable() {\n", "          @Override\n", "          public void run() {\n", "            assertThat(Thread.currentThread().isInterrupted()).isFalse();\n", "          }\n", "        });\n", "\n", "    // Run those tasks together.\n", "    fakePool.runAll();\n", "\n", "    // Check that the interruption of a SequentialExecutor's task is restored to the thread once\n", "    // it is yielded.\n", "    assertThat(Thread.currentThread().isInterrupted()).isTrue();\n", "  }\n", "\n", "    Runnable runMe =\n", "        new Runnable() {\n", "          @Override\n", "          public void run() {\n", "            numCalls.incrementAndGet();\n", "          }\n", "        };\n"], "6": ["    final SequentialExecutor executor =\n", "        new SequentialExecutor(\n", "            new Executor() {\n", "              @Override\n", "              public void execute(Runnable r) {\n", "                if (reject.get()) {\n", "                  throw new RejectedExecutionException();\n", "                }\n", "                r.run();\n", "              }\n", "            });\n", "    Runnable task =\n", "        new Runnable() {\n", "          @Override\n", "          public void run() {\n", "            numCalls.incrementAndGet();\n", "        };\n", "    } catch (RejectedExecutionException expected) {\n", "    }\n"], "7": ["      Runnable errorTask =\n", "          new Runnable() {\n", "            @Override\n", "            public void run() {\n", "              throw new MyError();\n", "            }\n", "          };\n", "      Runnable barrierTask =\n", "          new Runnable() {\n", "            @Override\n", "            public void run() {\n", "              try {\n", "                barrier.await();\n", "              } catch (Exception e) {\n", "                throw new RuntimeException(e);\n", "              }\n", "            }\n", "          };\n", "      service.execute(barrierTask); // submit directly to the service\n", "      barrier.await(1, TimeUnit.SECONDS);\n", "      barrier.await(1, TimeUnit.SECONDS);\n"]}, "removed": {"2": ["    @Override public void execute(Runnable command) {\n"], "3": ["    Runnable intCounter = new Runnable() {\n", "      @Override\n", "      public void run() {\n", "        totalCalls.incrementAndGet();\n", "        // Make sure that no other tasks are scheduled to run while this is running.\n", "        assertFalse(fakePool.hasNext());\n", "      }\n", "    };\n"], "4": ["    Runnable runMe = new Runnable() {\n", "      @Override\n", "      public void run() {\n", "        numCalls.incrementAndGet();\n", "        throw new RuntimeException(\"FAKE EXCEPTION!\");\n", "      }\n", "    };\n"], "5": ["    Runnable runMe = new Runnable() {\n", "      @Override\n", "      public void run() {\n", "        numCalls.incrementAndGet();\n", "      }\n", "    };\n"], "6": ["    final SequentialExecutor executor = new SequentialExecutor(\n", "        new Executor() {\n", "          @Override public void execute(Runnable r) {\n", "            if (reject.get()) {\n", "              throw new RejectedExecutionException();\n", "            }\n", "            r.run();\n", "        });\n", "    Runnable task = new Runnable() {\n", "      @Override\n", "      public void run() {\n", "        numCalls.incrementAndGet();\n", "      }\n", "    };\n", "    } catch (RejectedExecutionException expected) {}\n"], "7": ["      Runnable errorTask = new Runnable() {\n", "        @Override\n", "        public void run() {\n", "          throw new MyError();\n", "        }\n", "      };\n", "      Runnable barrierTask = new Runnable() {\n", "        @Override\n", "        public void run() {\n", "          try {\n", "            barrier.await();\n", "          } catch (Exception e) {\n", "            throw new RuntimeException(e);\n", "          }\n", "        }\n", "      };\n", "      service.execute(barrierTask);  // submit directly to the service\n", "      barrier.await(10, TimeUnit.SECONDS);\n", "      barrier.await(10, TimeUnit.SECONDS);\n"]}, "added_lines": {"1": [19, 20], "2": [42, 45, 46, 47], "3": [86, 87, 88, 89, 90, 91, 92, 93, 94], "4": [147, 148, 149, 150, 151, 152, 153, 154], "5": [163, 164, 165, 166, 167, 168, 169, 170, 171, 172, 173, 174, 175, 176, 177, 178, 179, 180, 181, 182, 183, 184, 185, 186, 187, 188, 189, 190, 191, 192, 193, 194, 195, 196, 197, 198, 199, 200, 201, 202, 203, 204, 205, 206, 207, 208, 209, 210, 211, 212, 213, 214, 215, 220, 221, 222, 223, 224, 225, 226], "6": [242, 243, 244, 245, 246, 247, 248, 249, 250, 251, 252, 253, 254, 255, 256, 257, 259, 263, 264], "7": [278, 279, 280, 281, 282, 283, 284, 285, 286, 287, 288, 289, 290, 291, 292, 293, 294, 295, 297, 300, 303]}, "removed_lines": {"2": [42], "3": [80, 81, 82, 83, 84, 85, 86, 87], "4": [140, 141, 142, 143, 144, 145, 146], "5": [159, 160, 161, 162, 163, 164], "6": [179, 180, 181, 182, 183, 184, 185, 187, 188, 189, 190, 191, 192, 193, 197], "7": [211, 212, 213, 214, 215, 216, 217, 218, 219, 220, 221, 222, 223, 224, 225, 226, 228, 231, 234]}}, {"1": "android/guava/src/com/google/common/util/concurrent/MoreExecutors.java", "added": {"1": ["    /** Lock used whenever accessing the state variables (runningTasks, shutdown) of the executor */\n"], "2": ["   /**\n"], "3": ["   * Returns an {@link Executor} that runs each task executed sequentially, such that no two tasks\n", "   * are running concurrently.\n", "   * <p>After execution begins on a thread from the {@code delegate} {@link Executor}, tasks are\n", "   * polled and executed from a task queue until there are no more tasks. The thread will not be\n", "   * released until there are no more tasks to run.\n", "   *\n", "   * <p>If a task is submitted while a thread is executing tasks from the task queue, the thread\n", "   * will not be released until that submitted task is also complete.\n", "   *\n", "   * <p>Tasks are always started with the Thread in an uninterrupted state.\n", "   *\n", "   * <p>If the thread is {@linkplain Thread#interrupt interrupted} while a task is running or before\n", "   * the thread is taken by the Executor:\n", "   *\n", "   * <ol>\n", "   *   <li>execution will not stop until the task queue is empty.\n", "   *   <li>the interrupt will be restored to the thread after it completes so that its {@code\n", "   *       delegate} Executor may process the interrupt.\n", "   * </ol>\n", "   *\n", "   * <p>{@code RuntimeException}s thrown by tasks are simply logged and the executor keeps trucking.\n", "   * If an {@code Error} is thrown, the error will propagate and execution will stop until the next\n", "   * time a task is submitted.\n", "   * <p>When an {@code Error} is thrown by an executed task, previously submitted tasks may never\n", "   * run. An attempt will be made to restart execution on the next call to {@code execute}. If the\n", "   * {@code delegate} has begun to reject execution, the previously submitted tasks may never run,\n", "   * despite not throwing a RejectedExecutionException synchronously with the call to {@code\n", "   * execute}. If this behaviour is problematic, use an Executor with a single thread (e.g. {@link\n", "   * Executors#newSingleThreadExecutor}).\n"], "4": ["   * <p>After execution begins on a thread from the {@code delegate} {@link Executor}, tasks are\n", "   * polled and executed from a task queue until there are no more tasks. The thread will not be\n", "   * released until there are no more tasks to run.\n", "   *\n", "   * <p>If a task is submitted while a thread is executing tasks from the task queue, the thread\n", "   * will not be released until that submitted task is also complete.\n", "   *\n", "   * <p>If a task is {@linkplain Thread#interrupt interrupted} while a task is running:\n", "   *\n", "   * <ol>\n", "   *   <li>execution will not stop until the task queue is empty.\n", "   *   <li>tasks will begin execution with the thread marked as not interrupted - any interruption\n", "   *       applies only to the task that was running at the point of interruption.\n", "   *   <li>if the thread was interrupted before the SequentialExecutor's worker begins execution,\n", "   *       the interrupt will be restored to the thread after it completes so that its {@code\n", "   *       delegate} Executor may process the interrupt.\n", "   *   <li>subtasks are run with the thread uninterrupted and interrupts received during execution\n", "   *       of a task are ignored.\n", "   * </ol>\n", "   *\n", "   * <p>{@code RuntimeException}s thrown by tasks are simply logged and the executor keeps trucking.\n", "   * If an {@code Error} is thrown, the error will propagate and execution will stop until the next\n", "   * time a task is submitted.\n", "   * <p>When an {@code Error} is thrown by an executed task, previously submitted tasks may never\n", "   * run. An attempt will be made to restart execution on the next call to {@code execute}. If the\n", "   * {@code delegate} has begun to reject execution, the previously submitted tasks may never run,\n", "   * despite not throwing a RejectedExecutionException synchronously with the call to {@code\n", "   * execute}. If this behaviour is problematic, use an Executor with a single thread (e.g. {@link\n", "   * Executors#newSingleThreadExecutor}).\n"]}, "removed": {"1": ["    /**\n", "     * Lock used whenever accessing the state variables (runningTasks, shutdown) of the executor\n", "     */\n"], "2": ["    /**\n"], "3": ["   * Returns an {@link Executor} that runs each task executed sequentially, such that no\n", "   * two tasks are running concurrently.\n", "   * <p>After execution starts on the {@code delegate} {@link Executor}, tasks are polled and\n", "   * executed from the queue until there are no more tasks. The thread will not be released until\n", "   * there are no more tasks to run.\n", "   * <p>If a task is {@linkplain Thread#interrupt interrupted}, execution of subsequent tasks\n", "   * continues. {@code RuntimeException}s thrown by tasks are simply logged and the executor keeps\n", "   * trucking. If an {@code Error} is thrown, the error will propagate and execution will stop until\n", "   * the next time a task is submitted.\n"], "4": ["   * <p>After execution starts on the {@code delegate} {@link Executor}, tasks are polled and\n", "   * executed from the queue until there are no more tasks. The thread will not be released until\n", "   * there are no more tasks to run.\n", "   * <p>If a task is {@linkplain Thread#interrupt interrupted}, execution of subsequent tasks\n", "   * continues. {@code RuntimeException}s thrown by tasks are simply logged and the executor keeps\n", "   * trucking. If an {@code Error} is thrown, the error will propagate and execution will stop until\n", "   * the next time a task is submitted.\n"]}, "added_lines": {"1": [238], "2": [327], "3": [407, 408, 413, 414, 415, 416, 417, 418, 419, 420, 421, 422, 423, 424, 425, 426, 427, 428, 429, 430, 431, 432, 433, 435, 436, 437, 438, 439, 440], "4": [460, 461, 462, 463, 464, 465, 466, 467, 468, 469, 470, 471, 472, 473, 474, 475, 476, 477, 478, 479, 480, 481, 482, 484, 485, 486, 487, 488, 489]}, "removed_lines": {"1": [238, 239, 240], "2": [329], "3": [409, 410, 415, 416, 417, 419, 420, 421, 422], "4": [442, 443, 444, 446, 447, 448, 449]}}, {"2": "android/guava/src/com/google/common/util/concurrent/SequentialExecutor.java", "added": {"1": [" * continues. See {@link QueueWorker#workOnQueue} for details.\n", " *\n", " * <p>{@code RuntimeException}s thrown by tasks are simply logged and the executor keeps trucking.\n", " * If an {@code Error} is thrown, the error will propagate and execution will stop until it is\n", " * restarted by a call to {@link #execute}.\n"], "2": ["  /** Worker that runs tasks from {@link #queue} until it is empty. */\n"], "3": ["    /**\n", "     * Continues executing tasks from {@link #queue} until it is empty.\n", "     *\n", "     * <p>The thread's interrupt bit is cleared before execution of each task.\n", "     *\n", "     * <p>If the Thread in use is interrupted before or during execution of the tasks in\n", "     * {@link #queue}, the Executor will complete its tasks, and then restore the interruption.\n", "     * This means that once the Thread returns to the Executor that this Executor composes, the\n", "     * interruption will still be present. If the composed Executor is an ExecutorService, it can\n", "     * respond to shutdown() by returning tasks queued on that Thread after {@link #worker} drains\n", "     * the queue.\n", "     */\n", "      boolean interruptedDuringTask = false;\n", "\n", "      try {\n", "        while (true) {\n", "          // Remove the interrupt bit before each task. The interrupt is for the \"current task\" when\n", "          // it is sent, so subsequent tasks in the queue should not be caused to be interrupted\n", "          // by a previous one in the queue being interrupted.\n", "          interruptedDuringTask |= Thread.interrupted();\n", "          Runnable task;\n", "          synchronized (queue) {\n", "            task = queue.poll();\n", "            if (task == null) {\n", "              isWorkerRunning = false;\n", "              return;\n", "            }\n", "          }\n", "          try {\n", "            task.run();\n", "          } catch (RuntimeException e) {\n", "            log.log(Level.SEVERE, \"Exception while executing runnable \" + task, e);\n", "      } finally {\n", "        // Ensure that if the thread was interrupted at all while processing the task queue, it\n", "        // is returned to the delegate Executor interrupted so that it may handle the\n", "        // interruption if it likes.\n", "        if (interruptedDuringTask) {\n", "          Thread.currentThread().interrupt();\n"]}, "removed": {"1": [" * continues. {@code RuntimeException}s thrown by tasks are simply logged and the executor keeps\n", " * trucking. If an {@code Error} is thrown, the error will propagate and execution will stop until\n", " * it is restarted by a call to {@link #execute}.\n"], "2": ["  /**\n", "   * Worker that runs tasks from {@link #queue} until it is empty.\n", "   */\n"], "3": ["      while (true) {\n", "        Runnable task = null;\n", "        synchronized (queue) {\n", "          // TODO(user): How should we handle interrupts and shutdowns?\n", "          task = queue.poll();\n", "          if (task == null) {\n", "            isWorkerRunning = false;\n", "            return;\n", "        try {\n", "          task.run();\n", "        } catch (RuntimeException e) {\n", "          log.log(Level.SEVERE, \"Exception while executing runnable \" + task, e);\n"]}, "added_lines": {"1": [35, 36, 37, 38, 39], "2": [105], "3": [123, 124, 125, 126, 127, 128, 129, 130, 131, 132, 133, 134, 136, 137, 138, 139, 140, 141, 142, 143, 144, 145, 146, 147, 148, 149, 150, 151, 152, 153, 154, 155, 158, 159, 160, 161, 162, 163]}, "removed_lines": {"1": [35, 36, 37], "2": [103, 104, 105], "3": [124, 125, 126, 127, 128, 129, 130, 131, 134, 135, 136, 137]}}, {"3": "guava-tests/test/com/google/common/util/concurrent/SequentialExecutorTest.java", "added": {"1": ["import static com.google.common.truth.Truth.assertThat;\n", "\n"], "2": ["\n", "\n", "    @Override\n", "    public void execute(Runnable command) {\n"], "3": ["    Runnable intCounter =\n", "        new Runnable() {\n", "          @Override\n", "          public void run() {\n", "            totalCalls.incrementAndGet();\n", "            // Make sure that no other tasks are scheduled to run while this is running.\n", "            assertFalse(fakePool.hasNext());\n", "          }\n", "        };\n"], "4": ["    Runnable runMe =\n", "        new Runnable() {\n", "          @Override\n", "          public void run() {\n", "            numCalls.incrementAndGet();\n", "            throw new RuntimeException(\"FAKE EXCEPTION!\");\n", "          }\n", "        };\n"], "5": ["  public void testInterrupt_beforeRunRestoresInterruption() throws Exception {\n", "    // Run a task on the composed Executor that interrupts its thread (i.e. this thread).\n", "    fakePool.execute(\n", "        new Runnable() {\n", "          @Override\n", "          public void run() {\n", "            Thread.currentThread().interrupt();\n", "          }\n", "        });\n", "    // Run a task that expects that it is not interrupted while it is running.\n", "    e.execute(\n", "        new Runnable() {\n", "          @Override\n", "          public void run() {\n", "            assertThat(Thread.currentThread().isInterrupted()).isFalse();\n", "          }\n", "        });\n", "\n", "    // Run these together.\n", "    fakePool.runAll();\n", "\n", "    // Check that this thread has been marked as interrupted again now that the thread has been\n", "    // returned by SequentialExecutor. Clear the bit while checking so that the test doesn't hose\n", "    // JUnit or some other test case.\n", "    assertThat(Thread.currentThread().interrupted()).isTrue();\n", "  }\n", "\n", "  public void testInterrupt_doesNotInterruptSubsequentTask() throws Exception {\n", "    // Run a task that interrupts its thread (i.e. this thread).\n", "    e.execute(\n", "        new Runnable() {\n", "          @Override\n", "          public void run() {\n", "            Thread.currentThread().interrupt();\n", "          }\n", "        });\n", "    // Run a task that expects that it is not interrupted while it is running.\n", "    e.execute(\n", "        new Runnable() {\n", "          @Override\n", "          public void run() {\n", "            assertThat(Thread.currentThread().isInterrupted()).isFalse();\n", "          }\n", "        });\n", "\n", "    // Run those tasks together.\n", "    fakePool.runAll();\n", "\n", "    // Check that the interruption of a SequentialExecutor's task is restored to the thread once\n", "    // it is yielded.\n", "    assertThat(Thread.currentThread().isInterrupted()).isTrue();\n", "  }\n", "\n", "    Runnable runMe =\n", "        new Runnable() {\n", "          @Override\n", "          public void run() {\n", "            numCalls.incrementAndGet();\n", "          }\n", "        };\n"], "6": ["    final SequentialExecutor executor =\n", "        new SequentialExecutor(\n", "            new Executor() {\n", "              @Override\n", "              public void execute(Runnable r) {\n", "                if (reject.get()) {\n", "                  throw new RejectedExecutionException();\n", "                }\n", "                r.run();\n", "              }\n", "            });\n", "    Runnable task =\n", "        new Runnable() {\n", "          @Override\n", "          public void run() {\n", "            numCalls.incrementAndGet();\n", "        };\n", "    } catch (RejectedExecutionException expected) {\n", "    }\n"], "7": ["      Runnable errorTask =\n", "          new Runnable() {\n", "            @Override\n", "            public void run() {\n", "              throw new MyError();\n", "            }\n", "          };\n", "      Runnable barrierTask =\n", "          new Runnable() {\n", "            @Override\n", "            public void run() {\n", "              try {\n", "                barrier.await();\n", "              } catch (Exception e) {\n", "                throw new RuntimeException(e);\n", "              }\n", "            }\n", "          };\n", "      service.execute(barrierTask); // submit directly to the service\n", "      barrier.await(1, TimeUnit.SECONDS);\n", "      barrier.await(1, TimeUnit.SECONDS);\n"]}, "removed": {"2": ["    @Override public void execute(Runnable command) {\n"], "3": ["    Runnable intCounter = new Runnable() {\n", "      @Override\n", "      public void run() {\n", "        totalCalls.incrementAndGet();\n", "        // Make sure that no other tasks are scheduled to run while this is running.\n", "        assertFalse(fakePool.hasNext());\n", "      }\n", "    };\n"], "4": ["    Runnable runMe = new Runnable() {\n", "      @Override\n", "      public void run() {\n", "        numCalls.incrementAndGet();\n", "        throw new RuntimeException(\"FAKE EXCEPTION!\");\n", "      }\n", "    };\n"], "5": ["    Runnable runMe = new Runnable() {\n", "      @Override\n", "      public void run() {\n", "        numCalls.incrementAndGet();\n", "      }\n", "    };\n"], "6": ["    final SequentialExecutor executor = new SequentialExecutor(\n", "        new Executor() {\n", "          @Override public void execute(Runnable r) {\n", "            if (reject.get()) {\n", "              throw new RejectedExecutionException();\n", "            }\n", "            r.run();\n", "        });\n", "    Runnable task = new Runnable() {\n", "      @Override\n", "      public void run() {\n", "        numCalls.incrementAndGet();\n", "      }\n", "    };\n", "    } catch (RejectedExecutionException expected) {}\n"], "7": ["      Runnable errorTask = new Runnable() {\n", "        @Override\n", "        public void run() {\n", "          throw new MyError();\n", "        }\n", "      };\n", "      Runnable barrierTask = new Runnable() {\n", "        @Override\n", "        public void run() {\n", "          try {\n", "            barrier.await();\n", "          } catch (Exception e) {\n", "            throw new RuntimeException(e);\n", "          }\n", "        }\n", "      };\n", "      service.execute(barrierTask);  // submit directly to the service\n", "      barrier.await(10, TimeUnit.SECONDS);\n", "      barrier.await(10, TimeUnit.SECONDS);\n"]}, "added_lines": {"1": [19, 20], "2": [42, 45, 46, 47], "3": [86, 87, 88, 89, 90, 91, 92, 93, 94], "4": [147, 148, 149, 150, 151, 152, 153, 154], "5": [163, 164, 165, 166, 167, 168, 169, 170, 171, 172, 173, 174, 175, 176, 177, 178, 179, 180, 181, 182, 183, 184, 185, 186, 187, 188, 189, 190, 191, 192, 193, 194, 195, 196, 197, 198, 199, 200, 201, 202, 203, 204, 205, 206, 207, 208, 209, 210, 211, 212, 213, 214, 215, 220, 221, 222, 223, 224, 225, 226], "6": [242, 243, 244, 245, 246, 247, 248, 249, 250, 251, 252, 253, 254, 255, 256, 257, 259, 263, 264], "7": [278, 279, 280, 281, 282, 283, 284, 285, 286, 287, 288, 289, 290, 291, 292, 293, 294, 295, 297, 300, 303]}, "removed_lines": {"2": [42], "3": [80, 81, 82, 83, 84, 85, 86, 87], "4": [140, 141, 142, 143, 144, 145, 146], "5": [159, 160, 161, 162, 163, 164], "6": [179, 180, 181, 182, 183, 184, 185, 187, 188, 189, 190, 191, 192, 193, 197], "7": [211, 212, 213, 214, 215, 216, 217, 218, 219, 220, 221, 222, 223, 224, 225, 226, 228, 231, 234]}}, {"4": "guava/src/com/google/common/util/concurrent/MoreExecutors.java", "added": {"1": ["    /** Lock used whenever accessing the state variables (runningTasks, shutdown) of the executor */\n"], "2": ["   /**\n"], "3": ["   * Returns an {@link Executor} that runs each task executed sequentially, such that no two tasks\n", "   * are running concurrently.\n", "   * <p>After execution begins on a thread from the {@code delegate} {@link Executor}, tasks are\n", "   * polled and executed from a task queue until there are no more tasks. The thread will not be\n", "   * released until there are no more tasks to run.\n", "   *\n", "   * <p>If a task is submitted while a thread is executing tasks from the task queue, the thread\n", "   * will not be released until that submitted task is also complete.\n", "   *\n", "   * <p>Tasks are always started with the Thread in an uninterrupted state.\n", "   *\n", "   * <p>If the thread is {@linkplain Thread#interrupt interrupted} while a task is running or before\n", "   * the thread is taken by the Executor:\n", "   *\n", "   * <ol>\n", "   *   <li>execution will not stop until the task queue is empty.\n", "   *   <li>the interrupt will be restored to the thread after it completes so that its {@code\n", "   *       delegate} Executor may process the interrupt.\n", "   * </ol>\n", "   *\n", "   * <p>{@code RuntimeException}s thrown by tasks are simply logged and the executor keeps trucking.\n", "   * If an {@code Error} is thrown, the error will propagate and execution will stop until the next\n", "   * time a task is submitted.\n", "   * <p>When an {@code Error} is thrown by an executed task, previously submitted tasks may never\n", "   * run. An attempt will be made to restart execution on the next call to {@code execute}. If the\n", "   * {@code delegate} has begun to reject execution, the previously submitted tasks may never run,\n", "   * despite not throwing a RejectedExecutionException synchronously with the call to {@code\n", "   * execute}. If this behaviour is problematic, use an Executor with a single thread (e.g. {@link\n", "   * Executors#newSingleThreadExecutor}).\n"], "4": ["   * <p>After execution begins on a thread from the {@code delegate} {@link Executor}, tasks are\n", "   * polled and executed from a task queue until there are no more tasks. The thread will not be\n", "   * released until there are no more tasks to run.\n", "   *\n", "   * <p>If a task is submitted while a thread is executing tasks from the task queue, the thread\n", "   * will not be released until that submitted task is also complete.\n", "   *\n", "   * <p>If a task is {@linkplain Thread#interrupt interrupted} while a task is running:\n", "   *\n", "   * <ol>\n", "   *   <li>execution will not stop until the task queue is empty.\n", "   *   <li>tasks will begin execution with the thread marked as not interrupted - any interruption\n", "   *       applies only to the task that was running at the point of interruption.\n", "   *   <li>if the thread was interrupted before the SequentialExecutor's worker begins execution,\n", "   *       the interrupt will be restored to the thread after it completes so that its {@code\n", "   *       delegate} Executor may process the interrupt.\n", "   *   <li>subtasks are run with the thread uninterrupted and interrupts received during execution\n", "   *       of a task are ignored.\n", "   * </ol>\n", "   *\n", "   * <p>{@code RuntimeException}s thrown by tasks are simply logged and the executor keeps trucking.\n", "   * If an {@code Error} is thrown, the error will propagate and execution will stop until the next\n", "   * time a task is submitted.\n", "   * <p>When an {@code Error} is thrown by an executed task, previously submitted tasks may never\n", "   * run. An attempt will be made to restart execution on the next call to {@code execute}. If the\n", "   * {@code delegate} has begun to reject execution, the previously submitted tasks may never run,\n", "   * despite not throwing a RejectedExecutionException synchronously with the call to {@code\n", "   * execute}. If this behaviour is problematic, use an Executor with a single thread (e.g. {@link\n", "   * Executors#newSingleThreadExecutor}).\n"]}, "removed": {"1": ["    /**\n", "     * Lock used whenever accessing the state variables (runningTasks, shutdown) of the executor\n", "     */\n"], "2": ["    /**\n"], "3": ["   * Returns an {@link Executor} that runs each task executed sequentially, such that no\n", "   * two tasks are running concurrently.\n", "   * <p>After execution starts on the {@code delegate} {@link Executor}, tasks are polled and\n", "   * executed from the queue until there are no more tasks. The thread will not be released until\n", "   * there are no more tasks to run.\n", "   * <p>If a task is {@linkplain Thread#interrupt interrupted}, execution of subsequent tasks\n", "   * continues. {@code RuntimeException}s thrown by tasks are simply logged and the executor keeps\n", "   * trucking. If an {@code Error} is thrown, the error will propagate and execution will stop until\n", "   * the next time a task is submitted.\n"], "4": ["   * <p>After execution starts on the {@code delegate} {@link Executor}, tasks are polled and\n", "   * executed from the queue until there are no more tasks. The thread will not be released until\n", "   * there are no more tasks to run.\n", "   * <p>If a task is {@linkplain Thread#interrupt interrupted}, execution of subsequent tasks\n", "   * continues. {@code RuntimeException}s thrown by tasks are simply logged and the executor keeps\n", "   * trucking. If an {@code Error} is thrown, the error will propagate and execution will stop until\n", "   * the next time a task is submitted.\n"]}, "added_lines": {"1": [238], "2": [327], "3": [407, 408, 413, 414, 415, 416, 417, 418, 419, 420, 421, 422, 423, 424, 425, 426, 427, 428, 429, 430, 431, 432, 433, 435, 436, 437, 438, 439, 440], "4": [460, 461, 462, 463, 464, 465, 466, 467, 468, 469, 470, 471, 472, 473, 474, 475, 476, 477, 478, 479, 480, 481, 482, 484, 485, 486, 487, 488, 489]}, "removed_lines": {"1": [238, 239, 240], "2": [329], "3": [409, 410, 415, 416, 417, 419, 420, 421, 422], "4": [442, 443, 444, 446, 447, 448, 449]}}, {"5": "guava/src/com/google/common/util/concurrent/SequentialExecutor.java", "added": {"1": [" * continues. See {@link QueueWorker#workOnQueue} for details.\n", " *\n", " * <p>{@code RuntimeException}s thrown by tasks are simply logged and the executor keeps trucking.\n", " * If an {@code Error} is thrown, the error will propagate and execution will stop until it is\n", " * restarted by a call to {@link #execute}.\n"], "2": ["  /** Worker that runs tasks from {@link #queue} until it is empty. */\n"], "3": ["    /**\n", "     * Continues executing tasks from {@link #queue} until it is empty.\n", "     *\n", "     * <p>The thread's interrupt bit is cleared before execution of each task.\n", "     *\n", "     * <p>If the Thread in use is interrupted before or during execution of the tasks in\n", "     * {@link #queue}, the Executor will complete its tasks, and then restore the interruption.\n", "     * This means that once the Thread returns to the Executor that this Executor composes, the\n", "     * interruption will still be present. If the composed Executor is an ExecutorService, it can\n", "     * respond to shutdown() by returning tasks queued on that Thread after {@link #worker} drains\n", "     * the queue.\n", "     */\n", "      boolean interruptedDuringTask = false;\n", "\n", "      try {\n", "        while (true) {\n", "          // Remove the interrupt bit before each task. The interrupt is for the \"current task\" when\n", "          // it is sent, so subsequent tasks in the queue should not be caused to be interrupted\n", "          // by a previous one in the queue being interrupted.\n", "          interruptedDuringTask |= Thread.interrupted();\n", "          Runnable task;\n", "          synchronized (queue) {\n", "            task = queue.poll();\n", "            if (task == null) {\n", "              isWorkerRunning = false;\n", "              return;\n", "            }\n", "          }\n", "          try {\n", "            task.run();\n", "          } catch (RuntimeException e) {\n", "            log.log(Level.SEVERE, \"Exception while executing runnable \" + task, e);\n", "      } finally {\n", "        // Ensure that if the thread was interrupted at all while processing the task queue, it\n", "        // is returned to the delegate Executor interrupted so that it may handle the\n", "        // interruption if it likes.\n", "        if (interruptedDuringTask) {\n", "          Thread.currentThread().interrupt();\n"]}, "removed": {"1": [" * continues. {@code RuntimeException}s thrown by tasks are simply logged and the executor keeps\n", " * trucking. If an {@code Error} is thrown, the error will propagate and execution will stop until\n", " * it is restarted by a call to {@link #execute}.\n"], "2": ["  /**\n", "   * Worker that runs tasks from {@link #queue} until it is empty.\n", "   */\n"], "3": ["      while (true) {\n", "        Runnable task = null;\n", "        synchronized (queue) {\n", "          // TODO(user): How should we handle interrupts and shutdowns?\n", "          task = queue.poll();\n", "          if (task == null) {\n", "            isWorkerRunning = false;\n", "            return;\n", "        try {\n", "          task.run();\n", "        } catch (RuntimeException e) {\n", "          log.log(Level.SEVERE, \"Exception while executing runnable \" + task, e);\n"]}, "added_lines": {"1": [35, 36, 37, 38, 39], "2": [105], "3": [123, 124, 125, 126, 127, 128, 129, 130, 131, 132, 133, 134, 136, 137, 138, 139, 140, 141, 142, 143, 144, 145, 146, 147, 148, 149, 150, 151, 152, 153, 154, 155, 158, 159, 160, 161, 162, 163]}, "removed_lines": {"1": [35, 36, 37], "2": [103, 104, 105], "3": [124, 125, 126, 127, 128, 129, 130, 131, 134, 135, 136, 137]}}]}
