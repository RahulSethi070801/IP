{"id": "c7769b29de954b3469fb1d9a25a80cb333fdd0ae", "code": [{"0": "guava-tests/test/com/google/common/io/CharSourceTest.java", "added": {"1": ["import static com.google.common.collect.ImmutableList.toImmutableList;\n"], "2": ["import java.util.stream.Stream;\n"], "3": ["  private static final ImmutableList<String> SPLIT_LINES =\n", "      ImmutableList.of(\"foo\", \"bar\", \"baz\", \"something\");\n"], "4": ["  public void testLines() throws IOException {\n", "    source = new TestCharSource(LINES);\n", "\n", "    ImmutableList<String> lines;\n", "    try (Stream<String> linesStream = source.lines()) {\n", "      assertTrue(source.wasStreamOpened());\n", "      assertFalse(source.wasStreamClosed());\n", "\n", "      lines = linesStream.collect(toImmutableList());\n", "    }\n", "\n", "    assertTrue(source.wasStreamClosed());\n", "    assertEquals(SPLIT_LINES, lines);\n", "  }\n", "\n"]}, "removed": {}, "added_lines": {"1": [19], "2": [37], "3": [62, 63], "4": [90, 91, 92, 93, 94, 95, 96, 97, 98, 99, 100, 101, 102, 103, 104]}, "removed_lines": {}}, {"1": "guava-tests/test/com/google/common/io/CharSourceTester.java", "added": {"1": ["import static com.google.common.collect.ImmutableList.toImmutableList;\n", "import com.google.common.io.SourceSinkFactory.ByteSourceFactory;\n", "import com.google.common.io.SourceSinkFactory.CharSourceFactory;\n"], "2": ["import java.util.stream.Stream;\n"], "3": ["  public void testLines() throws IOException {\n", "    try (Stream<String> lines = source.lines()) {\n", "      assertExpectedLines(lines.collect(toImmutableList()));\n", "    }\n", "  }\n", "\n"]}, "removed": {"1": ["import static com.google.common.io.SourceSinkFactory.ByteSourceFactory;\n", "import static com.google.common.io.SourceSinkFactory.CharSourceFactory;\n"]}, "added_lines": {"1": [19, 25, 26], "2": [34], "3": [127, 128, 129, 130, 131, 132]}, "removed_lines": {"1": [19, 20]}}, {"2": "guava/src/com/google/common/io/ByteSink.java", "added": {"1": ["   * Opens a new {@link OutputStream} for writing to this sink. This method returns a new,\n", "   * @throws IOException if an I/O error occurs while opening the stream\n"], "2": ["   * additional buffering (for example, a {@code ByteArrayOutputStream}). This method returns a new,\n", "   * independent stream each time it is called.\n", "   * @throws IOException if an I/O error occurs while opening the stream\n"], "3": ["   * @throws IOException if an I/O occurs while writing to this sink\n"], "4": ["   * @throws IOException if an I/O occurs while reading from {@code input} or writing to this sink\n"]}, "removed": {"1": ["   * Opens a new {@link OutputStream} for writing to this sink. This method should return a new,\n", "   * @throws IOException if an I/O error occurs in the process of opening the stream\n"], "2": ["   * additional buffering (for example, a {@code ByteArrayOutputStream}). This method should return\n", "   * a new, independent stream each time it is called.\n", "   * @throws IOException if an I/O error occurs in the process of opening the stream\n"], "3": ["   * @throws IOException if an I/O occurs in the process of writing to this sink\n"], "4": ["   * @throws IOException if an I/O occurs in the process of reading from {@code input} or writing to\n", "   *     this sink\n"]}, "added_lines": {"1": [64, 69], "2": [77, 78, 82], "3": [95], "4": [117]}, "removed_lines": {"1": [64, 69], "2": [77, 78, 82], "3": [95], "4": [117, 118]}}, {"3": "guava/src/com/google/common/io/ByteSource.java", "added": {"1": ["   * Opens a new {@link InputStream} for reading from this source. This method returns a new,\n", "   * @throws IOException if an I/O error occurs while opening the stream\n"], "2": ["   * additional buffering (for example, a {@code ByteArrayInputStream}). This method returns a\n", "   * @throws IOException if an I/O error occurs while opening the stream\n"], "3": ["   * @throws IOException if an I/O error occurs while reading the size of this source\n"], "4": ["   * @throws IOException if an I/O error occurs while reading from this source or writing to\n", "   *     {@code output}\n"], "5": ["   * @throws IOException if an I/O error occurs while reading from this source or writing to\n", "   *     {@code sink}\n"], "6": ["   * @throws IOException if an I/O error occurs while reading from this source\n"], "7": ["   * @throws IOException if an I/O error occurs while reading from this source or if\n"], "8": ["   * @throws IOException if an I/O error occurs while reading from this source\n"], "9": ["   * @throws IOException if an I/O error occurs while reading from this source or {@code other}\n"], "10": ["  class AsCharSource extends CharSource {\n"]}, "removed": {"1": ["   * Opens a new {@link InputStream} for reading from this source. This method should return a new,\n", "   * @throws IOException if an I/O error occurs in the process of opening the stream\n"], "2": ["   * additional buffering (for example, a {@code ByteArrayInputStream}). This method should return a\n", "   * @throws IOException if an I/O error occurs in the process of opening the stream\n"], "3": ["   * @throws IOException if an I/O error occurs in the process of reading the size of this source\n"], "4": ["   * @throws IOException if an I/O error occurs in the process of reading from this source or\n", "   *     writing to {@code output}\n"], "5": ["   * @throws IOException if an I/O error occurs in the process of reading from this source or\n", "   *     writing to {@code sink}\n"], "6": ["   * @throws IOException if an I/O error occurs in the process of reading from this source\n"], "7": ["   * @throws IOException if an I/O error occurs in the process of reading from this source or if\n"], "8": ["   * @throws IOException if an I/O error occurs in the process of reading from this source\n"], "9": ["   * @throws IOException if an I/O error occurs in the process of reading from this source or\n", "   *     {@code other}\n"], "10": ["  private final class AsCharSource extends CharSource {\n"]}, "added_lines": {"1": [83, 88], "2": [96, 101], "3": [189], "4": [236, 237], "5": [258, 259], "6": [280], "7": [299], "8": [322], "9": [334], "10": [437]}, "removed_lines": {"1": [83, 88], "2": [96, 101], "3": [189], "4": [236, 237], "5": [258, 259], "6": [280], "7": [299], "8": [322], "9": [334, 335], "10": [438]}}, {"4": "guava/src/com/google/common/io/CharSink.java", "added": {"1": ["   * Opens a new {@link Writer} for writing to this sink. This method returns a new, independent\n", "   * writer each time it is called.\n", "   * @throws IOException if an I/O error occurs while opening the writer\n"], "2": ["   * buffering. This method returns a new, independent writer each time it is called.\n", "   * @throws IOException if an I/O error occurs while opening the writer\n"], "3": ["   * @throws IOException if an I/O error while writing to this sink\n"], "4": ["   * @throws IOException if an I/O error occurs while writing to this sink\n"], "5": ["   * @throws IOException if an I/O error occurs while writing to this sink\n"], "6": ["   * @throws IOException if an I/O error occurs while reading from {@code readable} or writing to\n", "   *     this sink\n"]}, "removed": {"1": ["   * Opens a new {@link Writer} for writing to this sink. This method should return a new,\n", "   * independent writer each time it is called.\n", "   * @throws IOException if an I/O error occurs in the process of opening the writer\n"], "2": ["   * buffering. This method should return a new, independent writer each time it is called.\n", "   * @throws IOException if an I/O error occurs in the process of opening the writer\n"], "3": ["   * @throws IOException if an I/O error in the process of writing to this sink\n"], "4": ["   * @throws IOException if an I/O error occurs in the process of writing to this sink\n"], "5": ["   * @throws IOException if an I/O error occurs in the process of writing to this sink\n"], "6": ["   * @throws IOException if an I/O error occurs in the process of reading from {@code readable} or\n", "   *     writing to this sink\n"]}, "added_lines": {"1": [58, 59, 63], "2": [71, 75], "3": [88], "4": [110], "5": [120], "6": [146, 147]}, "removed_lines": {"1": [58, 59, 63], "2": [71, 75], "3": [88], "4": [110], "5": [120], "6": [146, 147]}}, {"5": "guava/src/com/google/common/io/CharSource.java", "added": {"1": ["import com.google.common.collect.Streams;\n", "import com.google.errorprone.annotations.MustBeClosed;\n", "import java.io.UncheckedIOException;\n", "import java.util.stream.Stream;\n"], "2": ["   * Opens a new {@link Reader} for reading from this source. This method returns a new, independent\n", "   * reader each time it is called.\n", "   * @throws IOException if an I/O error occurs while opening the reader\n", "   * Opens a new {@link BufferedReader} for reading from this source. This method returns a new,\n", "   * independent reader each time it is called.\n", "   * @throws IOException if an I/O error occurs while of opening the reader\n"], "3": ["  /**\n", "   * Opens a new {@link Stream} for reading text one line at a time from this source. This method\n", "   * returns a new, independent stream each time it is called.\n", "   *\n", "   * <p>The returned stream is lazy and only reads from the source in the terminal operation. If an\n", "   * I/O error occurs while the stream is reading from the source or when the stream is closed, an\n", "   * {@link UncheckedIOException} is thrown.\n", "   *\n", "   * <p>Like {@link BufferedReader#readLine}, this method considers a line to be a sequence of text\n", "   * that is terminated by (but does not include) one of {@code \\r\\n}, {@code \\r} or {@code \\n}. If\n", "   * the source's content does not end in a line termination sequence, it is treated as if it does.\n", "   *\n", "   * <p>The caller is responsible for ensuring that the returned stream is closed. For example:\n", "   *\n", "   * <pre>{@code\n", "   * try (Stream<String> lines = source.lines()) {\n", "   *   lines.map(...)\n", "   *      .filter(...)\n", "   *      .forEach(...);\n", "   * }\n", "   * }</pre>\n", "   *\n", "   * @throws IOException if an I/O error occurs while opening the stream\n", "   * @since 22.0\n", "   */\n", "  @Beta\n", "  @MustBeClosed\n", "  public Stream<String> lines() throws IOException {\n", "    BufferedReader reader = openBufferedStream();\n", "    return reader.lines().onClose(() -> {\n", "      try {\n", "        reader.close();\n", "      } catch (IOException e) {\n", "        throw new UncheckedIOException(e);\n", "      }\n", "    });\n", "  }\n", "\n"], "4": ["   * @throws IOException if an I/O error occurs while reading the length of this source\n"], "5": ["   * @throws IOException if an I/O error occurs while reading from this source or writing to\n", "   *     {@code appendable}\n"], "6": ["   * @throws IOException if an I/O error occurs while reading from this source or writing to\n", "   *     {@code sink}\n"], "7": ["   * @throws IOException if an I/O error occurs while reading from this source\n"], "8": ["   * <p>Like {@link BufferedReader#readLine}, this method considers a line to be a sequence of text\n", "   * that is terminated by (but does not include) one of {@code \\r\\n}, {@code \\r} or {@code \\n}. If\n", "   * the source's content does not end in a line termination sequence, it is treated as if it does.\n", "   * @throws IOException if an I/O error occurs while reading from this source\n"], "9": ["   * <p>Like {@link BufferedReader#readLine}, this method considers a line to be a sequence of text\n", "   * that is terminated by (but does not include) one of {@code \\r\\n}, {@code \\r} or {@code \\n}. If\n", "   * the source's content does not end in a line termination sequence, it is treated as if it does.\n", "   * @throws IOException if an I/O error occurs while reading from this source\n"], "10": ["   * <p>Like {@link BufferedReader#readLine}, this method considers a line to be a sequence of text\n", "   * that is terminated by (but does not include) one of {@code \\r\\n}, {@code \\r} or {@code \\n}. If\n", "   * the source's content does not end in a line termination sequence, it is treated as if it does.\n", "   * @throws IOException if an I/O error occurs while reading from this source or if\n"], "11": ["     * Returns an iterator over the lines in the string. If the string ends in a newline, a final\n", "     * empty string is not included, to match the behavior of BufferedReader/LineReader.readLine().\n", "    private Iterator<String> linesIterator() {\n", "      return new AbstractIterator<String>() {\n", "        Iterator<String> lines = LINE_SPLITTER.split(seq).iterator();\n", "\n", "        protected String computeNext() {\n", "          if (lines.hasNext()) {\n", "            String next = lines.next();\n", "            // skip last line if it's empty\n", "            if (lines.hasNext() || !next.isEmpty()) {\n", "              return next;\n", "          }\n", "          return endOfData();\n", "    @Override\n", "    public Stream<String> lines() {\n", "      return Streams.stream(linesIterator());\n", "    }\n", "\n", "      Iterator<String> lines = linesIterator();\n", "      return ImmutableList.copyOf(linesIterator());\n", "      Iterator<String> lines = linesIterator();\n", "      while (lines.hasNext()) {\n", "        if (!processor.processLine(lines.next())) {\n"]}, "removed": {"2": ["   * Opens a new {@link Reader} for reading from this source. This method should return a new,\n", "   * independent reader each time it is called.\n", "   * @throws IOException if an I/O error occurs in the process of opening the reader\n", "   * Opens a new {@link BufferedReader} for reading from this source. This method should return a\n", "   * new, independent reader each time it is called.\n", "   * @throws IOException if an I/O error occurs in the process of opening the reader\n"], "4": ["   * @throws IOException if an I/O error occurs in the process of reading the length of this source\n"], "5": ["   * @throws IOException if an I/O error occurs in the process of reading from this source or\n", "   *     writing to {@code appendable}\n"], "6": ["   * @throws IOException if an I/O error occurs in the process of reading from this source or\n", "   *     writing to {@code sink}\n"], "7": ["   * @throws IOException if an I/O error occurs in the process of reading from this source\n"], "8": ["   * <p>Like {@link BufferedReader}, this method breaks lines on any of {@code \\n}, {@code \\r} or\n", "   * {@code \\r\\n}, does not include the line separator in the returned line and does not consider\n", "   * there to be an extra empty line at the end if the content is terminated with a line separator.\n", "   * @throws IOException if an I/O error occurs in the process of reading from this source\n"], "9": ["   * <p>Like {@link BufferedReader}, this method breaks lines on any of {@code \\n}, {@code \\r} or\n", "   * {@code \\r\\n}, does not include the line separator in the returned lines and does not consider\n", "   * there to be an extra empty line at the end if the content is terminated with a line separator.\n", "   * @throws IOException if an I/O error occurs in the process of reading from this source\n"], "10": ["   * <p>Like {@link BufferedReader}, this method breaks lines on any of {@code \\n}, {@code \\r} or\n", "   * {@code \\r\\n}, does not include the line separator in the lines passed to the {@code processor}\n", "   * and does not consider there to be an extra empty line at the end if the content is terminated\n", "   * with a line separator.\n", "   * @throws IOException if an I/O error occurs in the process of reading from this source or if\n"], "11": ["     * Returns an iterable over the lines in the string. If the string ends in a newline, a final\n", "     * empty string is not included to match the behavior of BufferedReader/LineReader.readLine().\n", "    private Iterable<String> lines() {\n", "      return new Iterable<String>() {\n", "        public Iterator<String> iterator() {\n", "          return new AbstractIterator<String>() {\n", "            Iterator<String> lines = LINE_SPLITTER.split(seq).iterator();\n", "\n", "            @Override\n", "            protected String computeNext() {\n", "              if (lines.hasNext()) {\n", "                String next = lines.next();\n", "                // skip last line if it's empty\n", "                if (lines.hasNext() || !next.isEmpty()) {\n", "                  return next;\n", "                }\n", "              }\n", "              return endOfData();\n", "          };\n", "      Iterator<String> lines = lines().iterator();\n", "      return ImmutableList.copyOf(lines());\n", "      for (String line : lines()) {\n", "        if (!processor.processLine(line)) {\n"]}, "added_lines": {"1": [27, 29, 34, 39], "2": [93, 94, 98, 103, 104, 108], "3": [117, 118, 119, 120, 121, 122, 123, 124, 125, 126, 127, 128, 129, 130, 131, 132, 133, 134, 135, 136, 137, 138, 139, 140, 141, 142, 143, 144, 145, 146, 147, 148, 149, 150, 151, 152, 153, 154], "4": [190], "5": [225, 226], "6": [247, 248], "7": [269], "8": [286, 287, 288, 290], "9": [309, 310, 311, 313], "10": [337, 338, 339, 341], "11": [528, 529, 531, 532, 533, 534, 536, 537, 538, 539, 540, 541, 543, 544, 549, 550, 551, 552, 553, 556, 562, 567, 568, 569]}, "removed_lines": {"2": [89, 90, 94, 99, 100, 104], "4": [148], "5": [183, 184], "6": [205, 206], "7": [227], "8": [244, 245, 246, 248], "9": [267, 268, 269, 271], "10": [295, 296, 297, 298, 300], "11": [487, 488, 490, 491, 493, 494, 495, 496, 497, 498, 499, 500, 501, 502, 503, 504, 505, 506, 508, 515, 521, 526, 527]}}, {"6": "guava/src/com/google/common/io/MoreFiles.java", "added": {"1": ["import com.google.common.io.ByteSource.AsCharSource;\n"], "2": ["import java.util.stream.Stream;\n"], "3": ["    @Override\n", "    public CharSource asCharSource(Charset charset) {\n", "      if (options.length == 0) {\n", "        // If no OpenOptions were passed, delegate to Files.lines, which could have performance\n", "        // advantages. (If OpenOptions were passed we can't, because Files.lines doesn't have an\n", "        // overload taking OpenOptions, meaning we can't guarantee the same behavior w.r.t. things\n", "        // like following/not following symlinks.\n", "        return new AsCharSource(charset) {\n", "          @SuppressWarnings(\"FilesLinesLeak\") // the user needs to close it in this case\n", "          @Override\n", "          public Stream<String> lines() throws IOException {\n", "            return Files.lines(path, charset);\n", "          }\n", "        };\n", "      }\n", "\n", "      return super.asCharSource(charset);\n", "    }\n", "\n"]}, "removed": {}, "added_lines": {"1": [28], "2": [55], "3": [165, 166, 167, 168, 169, 170, 171, 172, 173, 174, 175, 176, 177, 178, 179, 180, 181, 182, 183]}, "removed_lines": {}}, {"7": "pom.xml", "added": {"1": ["        <version>2.0.18</version>\n"]}, "removed": {"1": ["        <version>2.0.15</version>\n"]}, "added_lines": {"1": [210]}, "removed_lines": {"1": [210]}}]}
