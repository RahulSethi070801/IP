{
    "addition": {
        "27": "import com.google.common.collect.Streams;\n",
        "29": "import com.google.errorprone.annotations.MustBeClosed;\n",
        "34": "import java.io.UncheckedIOException;\n",
        "39": "import java.util.stream.Stream;\n",
        "93": "   * Opens a new {@link Reader} for reading from this source. This method returns a new, independent\n",
        "94": "   * reader each time it is called.\n",
        "98": "   * @throws IOException if an I/O error occurs while opening the reader\n",
        "103": "   * Opens a new {@link BufferedReader} for reading from this source. This method returns a new,\n",
        "104": "   * independent reader each time it is called.\n",
        "108": "   * @throws IOException if an I/O error occurs while of opening the reader\n",
        "117": "  /**\n",
        "118": "   * Opens a new {@link Stream} for reading text one line at a time from this source. This method\n",
        "119": "   * returns a new, independent stream each time it is called.\n",
        "120": "   *\n",
        "121": "   * <p>The returned stream is lazy and only reads from the source in the terminal operation. If an\n",
        "122": "   * I/O error occurs while the stream is reading from the source or when the stream is closed, an\n",
        "123": "   * {@link UncheckedIOException} is thrown.\n",
        "124": "   *\n",
        "125": "   * <p>Like {@link BufferedReader#readLine}, this method considers a line to be a sequence of text\n",
        "126": "   * that is terminated by (but does not include) one of {@code \\r\\n}, {@code \\r} or {@code \\n}. If\n",
        "127": "   * the source's content does not end in a line termination sequence, it is treated as if it does.\n",
        "128": "   *\n",
        "129": "   * <p>The caller is responsible for ensuring that the returned stream is closed. For example:\n",
        "130": "   *\n",
        "131": "   * <pre>{@code\n",
        "132": "   * try (Stream<String> lines = source.lines()) {\n",
        "133": "   *   lines.map(...)\n",
        "134": "   *      .filter(...)\n",
        "135": "   *      .forEach(...);\n",
        "136": "   * }\n",
        "137": "   * }</pre>\n",
        "138": "   *\n",
        "139": "   * @throws IOException if an I/O error occurs while opening the stream\n",
        "140": "   * @since 22.0\n",
        "141": "   */\n",
        "142": "  @Beta\n",
        "143": "  @MustBeClosed\n",
        "144": "  public Stream<String> lines() throws IOException {\n",
        "145": "    BufferedReader reader = openBufferedStream();\n",
        "146": "    return reader.lines().onClose(() -> {\n",
        "147": "      try {\n",
        "148": "        reader.close();\n",
        "149": "      } catch (IOException e) {\n",
        "150": "        throw new UncheckedIOException(e);\n",
        "151": "      }\n",
        "152": "    });\n",
        "153": "  }\n",
        "154": "\n",
        "190": "   * @throws IOException if an I/O error occurs while reading the length of this source\n",
        "225": "   * @throws IOException if an I/O error occurs while reading from this source or writing to\n",
        "226": "   *     {@code appendable}\n",
        "247": "   * @throws IOException if an I/O error occurs while reading from this source or writing to\n",
        "248": "   *     {@code sink}\n",
        "269": "   * @throws IOException if an I/O error occurs while reading from this source\n",
        "286": "   * <p>Like {@link BufferedReader#readLine}, this method considers a line to be a sequence of text\n",
        "287": "   * that is terminated by (but does not include) one of {@code \\r\\n}, {@code \\r} or {@code \\n}. If\n",
        "288": "   * the source's content does not end in a line termination sequence, it is treated as if it does.\n",
        "290": "   * @throws IOException if an I/O error occurs while reading from this source\n",
        "309": "   * <p>Like {@link BufferedReader#readLine}, this method considers a line to be a sequence of text\n",
        "310": "   * that is terminated by (but does not include) one of {@code \\r\\n}, {@code \\r} or {@code \\n}. If\n",
        "311": "   * the source's content does not end in a line termination sequence, it is treated as if it does.\n",
        "313": "   * @throws IOException if an I/O error occurs while reading from this source\n",
        "337": "   * <p>Like {@link BufferedReader#readLine}, this method considers a line to be a sequence of text\n",
        "338": "   * that is terminated by (but does not include) one of {@code \\r\\n}, {@code \\r} or {@code \\n}. If\n",
        "339": "   * the source's content does not end in a line termination sequence, it is treated as if it does.\n",
        "341": "   * @throws IOException if an I/O error occurs while reading from this source or if\n",
        "528": "     * Returns an iterator over the lines in the string. If the string ends in a newline, a final\n",
        "529": "     * empty string is not included, to match the behavior of BufferedReader/LineReader.readLine().\n",
        "531": "    private Iterator<String> linesIterator() {\n",
        "532": "      return new AbstractIterator<String>() {\n",
        "533": "        Iterator<String> lines = LINE_SPLITTER.split(seq).iterator();\n",
        "534": "\n",
        "536": "        protected String computeNext() {\n",
        "537": "          if (lines.hasNext()) {\n",
        "538": "            String next = lines.next();\n",
        "539": "            // skip last line if it's empty\n",
        "540": "            if (lines.hasNext() || !next.isEmpty()) {\n",
        "541": "              return next;\n",
        "543": "          }\n",
        "544": "          return endOfData();\n",
        "549": "    @Override\n",
        "550": "    public Stream<String> lines() {\n",
        "551": "      return Streams.stream(linesIterator());\n",
        "552": "    }\n",
        "553": "\n",
        "556": "      Iterator<String> lines = linesIterator();\n",
        "562": "      return ImmutableList.copyOf(linesIterator());\n",
        "567": "      Iterator<String> lines = linesIterator();\n",
        "568": "      while (lines.hasNext()) {\n",
        "569": "        if (!processor.processLine(lines.next())) {\n"
    },
    "removed": {
        "89": "   * Opens a new {@link Reader} for reading from this source. This method should return a new,\n",
        "90": "   * independent reader each time it is called.\n",
        "94": "   * @throws IOException if an I/O error occurs in the process of opening the reader\n",
        "99": "   * Opens a new {@link BufferedReader} for reading from this source. This method should return a\n",
        "100": "   * new, independent reader each time it is called.\n",
        "104": "   * @throws IOException if an I/O error occurs in the process of opening the reader\n",
        "148": "   * @throws IOException if an I/O error occurs in the process of reading the length of this source\n",
        "183": "   * @throws IOException if an I/O error occurs in the process of reading from this source or\n",
        "184": "   *     writing to {@code appendable}\n",
        "205": "   * @throws IOException if an I/O error occurs in the process of reading from this source or\n",
        "206": "   *     writing to {@code sink}\n",
        "227": "   * @throws IOException if an I/O error occurs in the process of reading from this source\n",
        "244": "   * <p>Like {@link BufferedReader}, this method breaks lines on any of {@code \\n}, {@code \\r} or\n",
        "245": "   * {@code \\r\\n}, does not include the line separator in the returned line and does not consider\n",
        "246": "   * there to be an extra empty line at the end if the content is terminated with a line separator.\n",
        "248": "   * @throws IOException if an I/O error occurs in the process of reading from this source\n",
        "267": "   * <p>Like {@link BufferedReader}, this method breaks lines on any of {@code \\n}, {@code \\r} or\n",
        "268": "   * {@code \\r\\n}, does not include the line separator in the returned lines and does not consider\n",
        "269": "   * there to be an extra empty line at the end if the content is terminated with a line separator.\n",
        "271": "   * @throws IOException if an I/O error occurs in the process of reading from this source\n",
        "295": "   * <p>Like {@link BufferedReader}, this method breaks lines on any of {@code \\n}, {@code \\r} or\n",
        "296": "   * {@code \\r\\n}, does not include the line separator in the lines passed to the {@code processor}\n",
        "297": "   * and does not consider there to be an extra empty line at the end if the content is terminated\n",
        "298": "   * with a line separator.\n",
        "300": "   * @throws IOException if an I/O error occurs in the process of reading from this source or if\n",
        "487": "     * Returns an iterable over the lines in the string. If the string ends in a newline, a final\n",
        "488": "     * empty string is not included to match the behavior of BufferedReader/LineReader.readLine().\n",
        "490": "    private Iterable<String> lines() {\n",
        "491": "      return new Iterable<String>() {\n",
        "493": "        public Iterator<String> iterator() {\n",
        "494": "          return new AbstractIterator<String>() {\n",
        "495": "            Iterator<String> lines = LINE_SPLITTER.split(seq).iterator();\n",
        "496": "\n",
        "497": "            @Override\n",
        "498": "            protected String computeNext() {\n",
        "499": "              if (lines.hasNext()) {\n",
        "500": "                String next = lines.next();\n",
        "501": "                // skip last line if it's empty\n",
        "502": "                if (lines.hasNext() || !next.isEmpty()) {\n",
        "503": "                  return next;\n",
        "504": "                }\n",
        "505": "              }\n",
        "506": "              return endOfData();\n",
        "508": "          };\n",
        "515": "      Iterator<String> lines = lines().iterator();\n",
        "521": "      return ImmutableList.copyOf(lines());\n",
        "526": "      for (String line : lines()) {\n",
        "527": "        if (!processor.processLine(line)) {\n"
    }
}