{"id": "32f2d770f7117015385083ec6e755336ddf18f21", "code": [{"0": "android/guava-tests/test/com/google/common/graph/TraverserTest.java", "added": {"1": ["  @Test\n", "  public void forGraph_breadthFirst_infinite() {\n", "    Iterable<Integer> result =\n", "        Traverser.forGraph(fixedSuccessors(Iterables.cycle(1, 2, 3))).breadthFirst(0);\n", "    assertThat(Iterables.limit(result, 4)).containsExactly(0, 1, 2, 3).inOrder();\n", "  }\n", "\n"], "2": ["  @Test\n", "  public void forGraph_depthFirstPreOrder_infinite() {\n", "    Iterable<Integer> result =\n", "        Traverser.forGraph(fixedSuccessors(Iterables.cycle(1, 2, 3))).breadthFirst(0);\n", "    assertThat(Iterables.limit(result, 2)).containsExactly(0, 1).inOrder();\n", "  }\n", "\n"], "3": ["  @Test\n", "  public void forTree_breadthFirst_infinite() {\n", "    Iterable<Integer> result =\n", "        Traverser.forTree(fixedSuccessors(Iterables.cycle(1, 2, 3))).breadthFirst(0);\n", "    assertThat(Iterables.limit(result, 8)).containsExactly(0, 1, 2, 3, 1, 2, 3, 1).inOrder();\n", "  }\n", "\n"], "4": ["  @Test\n", "  public void forTree_depthFirstPreOrder_infinite() {\n", "    Iterable<Integer> result =\n", "        Traverser.forTree(fixedSuccessors(Iterables.cycle(1, 2, 3))).depthFirstPreOrder(0);\n", "    assertThat(Iterables.limit(result, 3)).containsExactly(0, 1, 1).inOrder();\n", "  }\n", "\n"], "5": ["\n", "  private static <N> SuccessorsFunction<N> fixedSuccessors(final Iterable<N> successors) {\n", "    return new SuccessorsFunction<N>() {\n", "      @Override\n", "      public Iterable<N> successors(N n) {\n", "        return successors;\n", "      }\n", "    };\n", "  }\n"]}, "removed": {}, "added_lines": {"1": [187, 188, 189, 190, 191, 192, 193], "2": [383, 384, 385, 386, 387, 388, 389], "3": [801, 802, 803, 804, 805, 806, 807], "4": [936, 937, 938, 939, 940, 941, 942], "5": [1269, 1270, 1271, 1272, 1273, 1274, 1275, 1276, 1277]}, "removed_lines": {}}, {"1": "android/guava/src/com/google/common/graph/Traverser.java", "added": {"2": ["  private final SuccessorsFunction<N> successorFunction;\n", "\n", "  private Traverser(SuccessorsFunction<N> successorFunction) {\n", "    this.successorFunction = checkNotNull(successorFunction);\n", "  }\n"], "3": ["  public static <N> Traverser<N> forGraph(final SuccessorsFunction<N> graph) {\n", "    return new Traverser<N>(graph) {\n", "      @Override\n", "      Traversal<N> newTraversal() {\n", "        return Traversal.inGraph(graph);\n", "      }\n", "    };\n"], "4": ["  public static <N> Traverser<N> forTree(final SuccessorsFunction<N> tree) {\n", "    return new Traverser<N>(tree) {\n", "      @Override\n", "      Traversal<N> newTraversal() {\n", "        return Traversal.inTree(tree);\n", "      }\n", "    };\n"], "5": ["  public final Iterable<N> breadthFirst(N startNode) {\n", "    return breadthFirst(ImmutableSet.of(startNode));\n", "  }\n"], "6": ["  public final Iterable<N> breadthFirst(Iterable<? extends N> startNodes) {\n", "    final ImmutableSet<N> validated = validate(startNodes);\n", "    return new Iterable<N>() {\n", "      @Override\n", "      public Iterator<N> iterator() {\n", "        return newTraversal().breadthFirst(validated.iterator());\n", "      }\n", "    };\n", "  }\n"], "7": ["  public final Iterable<N> depthFirstPreOrder(N startNode) {\n", "    return depthFirstPreOrder(ImmutableSet.of(startNode));\n", "  }\n"], "8": ["  public final Iterable<N> depthFirstPreOrder(Iterable<? extends N> startNodes) {\n", "    final ImmutableSet<N> validated = validate(startNodes);\n", "    return new Iterable<N>() {\n", "      @Override\n", "      public Iterator<N> iterator() {\n", "        return newTraversal().preOrder(validated.iterator());\n", "      }\n", "    };\n", "  }\n"], "9": ["  public final Iterable<N> depthFirstPostOrder(N startNode) {\n", "    return depthFirstPostOrder(ImmutableSet.of(startNode));\n", "  }\n"], "10": ["  public final Iterable<N> depthFirstPostOrder(Iterable<? extends N> startNodes) {\n", "    final ImmutableSet<N> validated = validate(startNodes);\n", "    return new Iterable<N>() {\n", "      public Iterator<N> iterator() {\n", "        return newTraversal().postOrder(validated.iterator());\n", "    };\n", "  abstract Traversal<N> newTraversal();\n", "  @SuppressWarnings(\"CheckReturnValue\")\n", "  private ImmutableSet<N> validate(Iterable<? extends N> startNodes) {\n", "    ImmutableSet<N> copy = ImmutableSet.copyOf(startNodes);\n", "    for (N node : copy) {\n", "      successorFunction.successors(node); // Will throw if node doesn't exist\n", "    return copy;\n"], "11": ["  private abstract static class Traversal<N> {\n", "    Traversal(SuccessorsFunction<N> successorFunction) {\n", "      this.successorFunction = successorFunction;\n", "    static <N> Traversal<N> inGraph(SuccessorsFunction<N> graph) {\n", "      return new Traversal<N>(graph) {\n"], "12": ["    static <N> Traversal<N> inTree(SuccessorsFunction<N> tree) {\n", "      return new Traversal<N>(tree) {\n"], "13": ["    final Iterator<N> breadthFirst(Iterator<? extends N> startNodes) {\n", "      return topDown(startNodes, InsertionOrder.BACK);\n", "    }\n", "\n", "      return topDown(startNodes, InsertionOrder.FRONT);\n", "    }\n", "\n", "    /**\n", "     * In top-down traversal, an ancestor node is always traversed before any of its descendant\n", "     * nodes. The traversal order among descendant nodes (particularly aunts and nieces) are\n", "     * determined by the {@code InsertionOrder} parameter: nieces are placed at the FRONT before\n", "     * aunts for pre-order; while in BFS they are placed at the BACK after aunts.\n", "     */\n", "    private Iterator<N> topDown(Iterator<? extends N> startNodes, final InsertionOrder order) {\n", "      horizon.add(startNodes);\n"], "14": ["                // BFS: horizon.addLast(successors)\n", "                // Pre-order: horizon.addFirst(successors)\n", "                order.insertInto(horizon, successors);\n"], "15": ["      final Deque<Iterator<? extends N>> horizon = new ArrayDeque<>();\n", "      horizon.add(startNodes);\n"], "16": ["     * Null is returned to indicate reaching the end of the top iterator.\n"], "17": ["\n", "  /** Poor man's method reference for {@code Deque::addFirst} and {@code Deque::addLast}. */\n", "  private enum InsertionOrder {\n", "    FRONT {\n", "      @Override\n", "      <T> void insertInto(Deque<T> deque, T value) {\n", "        deque.addFirst(value);\n", "      }\n", "    },\n", "    BACK {\n", "      @Override\n", "      <T> void insertInto(Deque<T> deque, T value) {\n", "        deque.addLast(value);\n", "      }\n", "    };\n", "\n", "    abstract <T> void insertInto(Deque<T> deque, T value);\n", "  }\n"]}, "removed": {"1": ["import com.google.common.collect.Iterables;\n", "import com.google.common.collect.UnmodifiableIterator;\n", "import java.util.Queue;\n"], "3": ["  public static <N> Traverser<N> forGraph(SuccessorsFunction<N> graph) {\n", "    checkNotNull(graph);\n", "    return new GraphTraverser<>(graph);\n"], "4": ["  public static <N> Traverser<N> forTree(SuccessorsFunction<N> tree) {\n", "    checkNotNull(tree);\n", "    return new TreeTraverser<>(tree);\n"], "5": ["  public abstract Iterable<N> breadthFirst(N startNode);\n"], "6": ["  public abstract Iterable<N> breadthFirst(Iterable<? extends N> startNodes);\n"], "7": ["  public abstract Iterable<N> depthFirstPreOrder(N startNode);\n"], "8": ["  public abstract Iterable<N> depthFirstPreOrder(Iterable<? extends N> startNodes);\n"], "9": ["  public abstract Iterable<N> depthFirstPostOrder(N startNode);\n"], "10": ["  public abstract Iterable<N> depthFirstPostOrder(Iterable<? extends N> startNodes);\n", "\n", "  // Avoid subclasses outside of this class\n", "  private Traverser() {}\n", "\n", "  private static final class GraphTraverser<N> extends Traverser<N> {\n", "    private final SuccessorsFunction<N> graph;\n", "\n", "    GraphTraverser(SuccessorsFunction<N> graph) {\n", "      this.graph = checkNotNull(graph);\n", "    }\n", "\n", "    @Override\n", "    public Iterable<N> breadthFirst(final N startNode) {\n", "      checkNotNull(startNode);\n", "      return breadthFirst(ImmutableSet.of(startNode));\n", "    }\n", "\n", "    @Override\n", "    public Iterable<N> breadthFirst(final Iterable<? extends N> startNodes) {\n", "      checkNotNull(startNodes);\n", "      if (Iterables.isEmpty(startNodes)) {\n", "        return ImmutableSet.of();\n", "      }\n", "      for (N startNode : startNodes) {\n", "        checkThatNodeIsInGraph(startNode);\n", "      }\n", "      return new Iterable<N>() {\n", "        @Override\n", "        public Iterator<N> iterator() {\n", "          return new BreadthFirstIterator(startNodes);\n", "        }\n", "      };\n", "    }\n", "\n", "    @Override\n", "    public Iterable<N> depthFirstPreOrder(final N startNode) {\n", "      checkNotNull(startNode);\n", "      return depthFirstPreOrder(ImmutableSet.of(startNode));\n", "    }\n", "\n", "    @Override\n", "    public Iterable<N> depthFirstPreOrder(final Iterable<? extends N> startNodes) {\n", "      checkNotNull(startNodes);\n", "      if (Iterables.isEmpty(startNodes)) {\n", "        return ImmutableSet.of();\n", "      }\n", "      for (N startNode : startNodes) {\n", "        checkThatNodeIsInGraph(startNode);\n", "      }\n", "      return new Iterable<N>() {\n", "        @Override\n", "        public Iterator<N> iterator() {\n", "          return Walker.inGraph(graph).preOrder(startNodes.iterator());\n", "        }\n", "      };\n", "    }\n", "\n", "    @Override\n", "    public Iterable<N> depthFirstPostOrder(final N startNode) {\n", "      checkNotNull(startNode);\n", "      return depthFirstPostOrder(ImmutableSet.of(startNode));\n", "    }\n", "\n", "    @Override\n", "    public Iterable<N> depthFirstPostOrder(final Iterable<? extends N> startNodes) {\n", "      checkNotNull(startNodes);\n", "      if (Iterables.isEmpty(startNodes)) {\n", "        return ImmutableSet.of();\n", "      }\n", "      for (N startNode : startNodes) {\n", "        checkThatNodeIsInGraph(startNode);\n", "      }\n", "      return new Iterable<N>() {\n", "        @Override\n", "        public Iterator<N> iterator() {\n", "          return Walker.inGraph(graph).postOrder(startNodes.iterator());\n", "        }\n", "      };\n", "    }\n", "\n", "    @SuppressWarnings(\"CheckReturnValue\")\n", "    private void checkThatNodeIsInGraph(N startNode) {\n", "      // successors() throws an IllegalArgumentException for nodes that are not an element of the\n", "      // graph.\n", "      graph.successors(startNode);\n", "    }\n", "\n", "    private final class BreadthFirstIterator extends UnmodifiableIterator<N> {\n", "      private final Queue<N> queue = new ArrayDeque<>();\n", "      private final Set<N> visited = new HashSet<>();\n", "\n", "      BreadthFirstIterator(Iterable<? extends N> roots) {\n", "        for (N root : roots) {\n", "          // add all roots to the queue, skipping duplicates\n", "          if (visited.add(root)) {\n", "            queue.add(root);\n", "          }\n", "        }\n", "      }\n", "\n", "      public boolean hasNext() {\n", "        return !queue.isEmpty();\n", "\n", "      @Override\n", "      public N next() {\n", "        N current = queue.remove();\n", "        for (N neighbor : graph.successors(current)) {\n", "          if (visited.add(neighbor)) {\n", "            queue.add(neighbor);\n", "          }\n", "        }\n", "        return current;\n", "      }\n", "    }\n", "  private static final class TreeTraverser<N> extends Traverser<N> {\n", "    private final SuccessorsFunction<N> tree;\n", "\n", "    TreeTraverser(SuccessorsFunction<N> tree) {\n", "      this.tree = checkNotNull(tree);\n", "    }\n", "\n", "    @Override\n", "    public Iterable<N> breadthFirst(final N startNode) {\n", "      checkNotNull(startNode);\n", "      return breadthFirst(ImmutableSet.of(startNode));\n", "    }\n", "\n", "    @Override\n", "    public Iterable<N> breadthFirst(final Iterable<? extends N> startNodes) {\n", "      checkNotNull(startNodes);\n", "      if (Iterables.isEmpty(startNodes)) {\n", "        return ImmutableSet.of();\n", "      }\n", "      for (N startNode : startNodes) {\n", "        checkThatNodeIsInTree(startNode);\n", "      }\n", "      return new Iterable<N>() {\n", "        @Override\n", "        public Iterator<N> iterator() {\n", "          return new BreadthFirstIterator(startNodes);\n", "        }\n", "      };\n", "    }\n", "\n", "    @Override\n", "    public Iterable<N> depthFirstPreOrder(final N startNode) {\n", "      checkNotNull(startNode);\n", "      return depthFirstPreOrder(ImmutableSet.of(startNode));\n", "    }\n", "    @Override\n", "    public Iterable<N> depthFirstPreOrder(final Iterable<? extends N> startNodes) {\n", "      checkNotNull(startNodes);\n", "      if (Iterables.isEmpty(startNodes)) {\n", "        return ImmutableSet.of();\n", "      }\n", "      for (N node : startNodes) {\n", "        checkThatNodeIsInTree(node);\n", "      }\n", "      return new Iterable<N>() {\n", "        @Override\n", "        public Iterator<N> iterator() {\n", "          return Walker.inTree(tree).preOrder(startNodes.iterator());\n", "        }\n", "      };\n", "    }\n", "\n", "    @Override\n", "    public Iterable<N> depthFirstPostOrder(final N startNode) {\n", "      checkNotNull(startNode);\n", "      return depthFirstPostOrder(ImmutableSet.of(startNode));\n", "    }\n", "\n", "    @Override\n", "    public Iterable<N> depthFirstPostOrder(final Iterable<? extends N> startNodes) {\n", "      checkNotNull(startNodes);\n", "      if (Iterables.isEmpty(startNodes)) {\n", "        return ImmutableSet.of();\n", "      }\n", "      for (N startNode : startNodes) {\n", "        checkThatNodeIsInTree(startNode);\n", "      }\n", "      return new Iterable<N>() {\n", "        @Override\n", "        public Iterator<N> iterator() {\n", "          return Walker.inTree(tree).postOrder(startNodes.iterator());\n", "        }\n", "      };\n", "    }\n", "\n", "    @SuppressWarnings(\"CheckReturnValue\")\n", "    private void checkThatNodeIsInTree(N startNode) {\n", "      // successors() throws an IllegalArgumentException for nodes that are not an element of the\n", "      // graph.\n", "      tree.successors(startNode);\n", "    }\n", "\n", "    private final class BreadthFirstIterator extends UnmodifiableIterator<N> {\n", "      private final Queue<N> queue = new ArrayDeque<>();\n", "\n", "      BreadthFirstIterator(Iterable<? extends N> roots) {\n", "        for (N root : roots) {\n", "          queue.add(root);\n", "        }\n", "      }\n", "\n", "      @Override\n", "      public boolean hasNext() {\n", "        return !queue.isEmpty();\n", "      }\n", "\n", "      @Override\n", "      public N next() {\n", "        N current = queue.remove();\n", "        Iterables.addAll(queue, tree.successors(current));\n", "        return current;\n", "      }\n"], "11": ["  private abstract static class Walker<N> {\n", "    Walker(SuccessorsFunction<N> successorFunction) {\n", "      this.successorFunction = checkNotNull(successorFunction);\n", "    static <N> Walker<N> inGraph(SuccessorsFunction<N> graph) {\n", "      return new Walker<N>(graph) {\n"], "12": ["    static <N> Walker<N> inTree(SuccessorsFunction<N> tree) {\n", "      return new Walker<N>(tree) {\n"], "13": ["      horizon.addFirst(startNodes);\n"], "14": ["                horizon.addFirst(successors);\n"], "15": ["      final Deque<Iterator<? extends N>> horizon = new ArrayDeque<>();\n", "      horizon.addFirst(startNodes);\n"], "16": ["     * Null is returned to indicate reaching the end of the top iterator, which can be used by the\n", "     * traversal strategies to decide what to return in such case: in pre-order, continue to poll\n", "     * the next top iterator with {@code visitNext()}; in post-order, return the parent node.\n"]}, "added_lines": {"2": [63, 64, 65, 66, 67], "3": [93, 94, 95, 96, 97, 98, 99], "4": [175, 182, 183, 184, 185, 186, 187], "5": [221, 222, 223], "6": [235, 236, 237, 238, 239, 240, 241, 242, 243], "7": [276, 277, 278], "8": [290, 291, 292, 293, 294, 295, 296, 297, 298], "9": [331, 332, 333], "10": [345, 346, 347, 349, 350, 352, 355, 357, 358, 359, 360, 361, 363], "11": [371, 374, 375, 378, 380], "12": [396, 397], "13": [410, 411, 412, 413, 415, 416, 417, 418, 419, 420, 421, 422, 423, 424, 426], "14": [435, 436, 437], "15": [449, 450], "16": [469], "17": [480, 481, 482, 483, 484, 485, 486, 487, 488, 489, 490, 491, 492, 493, 494, 495, 496, 497]}, "removed_lines": {"1": [25, 26, 31], "3": [91, 92, 93], "4": [169, 170, 177], "5": [211], "6": [223], "7": [256], "8": [268], "9": [301], "10": [313, 314, 315, 316, 317, 318, 319, 320, 321, 322, 323, 324, 325, 326, 327, 328, 329, 330, 331, 332, 333, 334, 335, 336, 337, 338, 339, 340, 341, 342, 343, 344, 345, 346, 347, 348, 349, 350, 351, 352, 353, 354, 355, 356, 357, 358, 359, 360, 361, 362, 363, 364, 365, 366, 367, 368, 369, 370, 371, 372, 373, 374, 375, 376, 377, 378, 379, 380, 381, 382, 383, 384, 385, 386, 387, 388, 389, 390, 391, 392, 393, 394, 395, 396, 397, 398, 399, 400, 401, 402, 403, 404, 405, 406, 407, 408, 409, 410, 411, 412, 413, 415, 416, 418, 419, 420, 421, 422, 423, 424, 425, 426, 427, 428, 429, 432, 433, 434, 435, 436, 437, 438, 439, 440, 441, 442, 443, 444, 445, 446, 447, 448, 449, 450, 451, 452, 453, 454, 455, 456, 457, 458, 459, 460, 461, 462, 463, 464, 465, 466, 468, 469, 470, 471, 472, 473, 474, 475, 476, 477, 478, 479, 480, 481, 482, 483, 484, 485, 486, 487, 488, 489, 490, 491, 492, 493, 494, 495, 496, 497, 498, 499, 500, 501, 502, 503, 504, 505, 506, 507, 508, 509, 510, 511, 512, 513, 514, 515, 516, 517, 518, 519, 520, 521, 522, 523, 524, 525, 526, 527, 528, 529, 530, 531, 532, 533, 534], "11": [543, 546, 547, 550, 552], "12": [568, 569], "13": [584], "14": [593], "15": [604, 605], "16": [625, 626, 627]}}, {"2": "guava-tests/test/com/google/common/graph/TraverserTest.java", "added": {"1": ["  @Test\n", "  public void forGraph_breadthFirst_infinite() {\n", "    Iterable<Integer> result =\n", "        Traverser.forGraph(fixedSuccessors(Iterables.cycle(1, 2, 3))).breadthFirst(0);\n", "    assertThat(Iterables.limit(result, 4)).containsExactly(0, 1, 2, 3).inOrder();\n", "  }\n", "\n"], "2": ["  @Test\n", "  public void forGraph_depthFirstPreOrder_infinite() {\n", "    Iterable<Integer> result =\n", "        Traverser.forGraph(fixedSuccessors(Iterables.cycle(1, 2, 3))).breadthFirst(0);\n", "    assertThat(Iterables.limit(result, 2)).containsExactly(0, 1).inOrder();\n", "  }\n", "\n"], "3": ["  @Test\n", "  public void forTree_breadthFirst_infinite() {\n", "    Iterable<Integer> result =\n", "        Traverser.forTree(fixedSuccessors(Iterables.cycle(1, 2, 3))).breadthFirst(0);\n", "    assertThat(Iterables.limit(result, 8)).containsExactly(0, 1, 2, 3, 1, 2, 3, 1).inOrder();\n", "  }\n", "\n"], "4": ["  @Test\n", "  public void forTree_depthFirstPreOrder_infinite() {\n", "    Iterable<Integer> result =\n", "        Traverser.forTree(fixedSuccessors(Iterables.cycle(1, 2, 3))).depthFirstPreOrder(0);\n", "    assertThat(Iterables.limit(result, 3)).containsExactly(0, 1, 1).inOrder();\n", "  }\n", "\n"], "5": ["\n", "  private static <N> SuccessorsFunction<N> fixedSuccessors(final Iterable<N> successors) {\n", "    return new SuccessorsFunction<N>() {\n", "      @Override\n", "      public Iterable<N> successors(N n) {\n", "        return successors;\n", "      }\n", "    };\n", "  }\n"]}, "removed": {}, "added_lines": {"1": [187, 188, 189, 190, 191, 192, 193], "2": [383, 384, 385, 386, 387, 388, 389], "3": [801, 802, 803, 804, 805, 806, 807], "4": [936, 937, 938, 939, 940, 941, 942], "5": [1269, 1270, 1271, 1272, 1273, 1274, 1275, 1276, 1277]}, "removed_lines": {}}, {"3": "guava/src/com/google/common/graph/Traverser.java", "added": {"2": ["  private final SuccessorsFunction<N> successorFunction;\n", "\n", "  private Traverser(SuccessorsFunction<N> successorFunction) {\n", "    this.successorFunction = checkNotNull(successorFunction);\n", "  }\n"], "3": ["  public static <N> Traverser<N> forGraph(final SuccessorsFunction<N> graph) {\n", "    return new Traverser<N>(graph) {\n", "      @Override\n", "      Traversal<N> newTraversal() {\n", "        return Traversal.inGraph(graph);\n", "      }\n", "    };\n"], "4": ["  public static <N> Traverser<N> forTree(final SuccessorsFunction<N> tree) {\n", "    return new Traverser<N>(tree) {\n", "      @Override\n", "      Traversal<N> newTraversal() {\n", "        return Traversal.inTree(tree);\n", "      }\n", "    };\n"], "5": ["  public final Iterable<N> breadthFirst(N startNode) {\n", "    return breadthFirst(ImmutableSet.of(startNode));\n", "  }\n"], "6": ["  public final Iterable<N> breadthFirst(Iterable<? extends N> startNodes) {\n", "    final ImmutableSet<N> validated = validate(startNodes);\n", "    return new Iterable<N>() {\n", "      @Override\n", "      public Iterator<N> iterator() {\n", "        return newTraversal().breadthFirst(validated.iterator());\n", "      }\n", "    };\n", "  }\n"], "7": ["  public final Iterable<N> depthFirstPreOrder(N startNode) {\n", "    return depthFirstPreOrder(ImmutableSet.of(startNode));\n", "  }\n"], "8": ["  public final Iterable<N> depthFirstPreOrder(Iterable<? extends N> startNodes) {\n", "    final ImmutableSet<N> validated = validate(startNodes);\n", "    return new Iterable<N>() {\n", "      @Override\n", "      public Iterator<N> iterator() {\n", "        return newTraversal().preOrder(validated.iterator());\n", "      }\n", "    };\n", "  }\n"], "9": ["  public final Iterable<N> depthFirstPostOrder(N startNode) {\n", "    return depthFirstPostOrder(ImmutableSet.of(startNode));\n", "  }\n"], "10": ["  public final Iterable<N> depthFirstPostOrder(Iterable<? extends N> startNodes) {\n", "    final ImmutableSet<N> validated = validate(startNodes);\n", "    return new Iterable<N>() {\n", "      public Iterator<N> iterator() {\n", "        return newTraversal().postOrder(validated.iterator());\n", "    };\n", "  abstract Traversal<N> newTraversal();\n", "  @SuppressWarnings(\"CheckReturnValue\")\n", "  private ImmutableSet<N> validate(Iterable<? extends N> startNodes) {\n", "    ImmutableSet<N> copy = ImmutableSet.copyOf(startNodes);\n", "    for (N node : copy) {\n", "      successorFunction.successors(node); // Will throw if node doesn't exist\n", "    return copy;\n"], "11": ["  private abstract static class Traversal<N> {\n", "    Traversal(SuccessorsFunction<N> successorFunction) {\n", "      this.successorFunction = successorFunction;\n", "    static <N> Traversal<N> inGraph(SuccessorsFunction<N> graph) {\n", "      return new Traversal<N>(graph) {\n"], "12": ["    static <N> Traversal<N> inTree(SuccessorsFunction<N> tree) {\n", "      return new Traversal<N>(tree) {\n"], "13": ["    final Iterator<N> breadthFirst(Iterator<? extends N> startNodes) {\n", "      return topDown(startNodes, InsertionOrder.BACK);\n", "    }\n", "\n", "      return topDown(startNodes, InsertionOrder.FRONT);\n", "    }\n", "\n", "    /**\n", "     * In top-down traversal, an ancestor node is always traversed before any of its descendant\n", "     * nodes. The traversal order among descendant nodes (particularly aunts and nieces) are\n", "     * determined by the {@code InsertionOrder} parameter: nieces are placed at the FRONT before\n", "     * aunts for pre-order; while in BFS they are placed at the BACK after aunts.\n", "     */\n", "    private Iterator<N> topDown(Iterator<? extends N> startNodes, final InsertionOrder order) {\n", "      horizon.add(startNodes);\n"], "14": ["                // BFS: horizon.addLast(successors)\n", "                // Pre-order: horizon.addFirst(successors)\n", "                order.insertInto(horizon, successors);\n"], "15": ["      final Deque<Iterator<? extends N>> horizon = new ArrayDeque<>();\n", "      horizon.add(startNodes);\n"], "16": ["     * Null is returned to indicate reaching the end of the top iterator.\n"], "17": ["\n", "  /** Poor man's method reference for {@code Deque::addFirst} and {@code Deque::addLast}. */\n", "  private enum InsertionOrder {\n", "    FRONT {\n", "      @Override\n", "      <T> void insertInto(Deque<T> deque, T value) {\n", "        deque.addFirst(value);\n", "      }\n", "    },\n", "    BACK {\n", "      @Override\n", "      <T> void insertInto(Deque<T> deque, T value) {\n", "        deque.addLast(value);\n", "      }\n", "    };\n", "\n", "    abstract <T> void insertInto(Deque<T> deque, T value);\n", "  }\n"]}, "removed": {"1": ["import com.google.common.collect.Iterables;\n", "import com.google.common.collect.UnmodifiableIterator;\n", "import java.util.Queue;\n"], "3": ["  public static <N> Traverser<N> forGraph(SuccessorsFunction<N> graph) {\n", "    checkNotNull(graph);\n", "    return new GraphTraverser<>(graph);\n"], "4": ["  public static <N> Traverser<N> forTree(SuccessorsFunction<N> tree) {\n", "    checkNotNull(tree);\n", "    return new TreeTraverser<>(tree);\n"], "5": ["  public abstract Iterable<N> breadthFirst(N startNode);\n"], "6": ["  public abstract Iterable<N> breadthFirst(Iterable<? extends N> startNodes);\n"], "7": ["  public abstract Iterable<N> depthFirstPreOrder(N startNode);\n"], "8": ["  public abstract Iterable<N> depthFirstPreOrder(Iterable<? extends N> startNodes);\n"], "9": ["  public abstract Iterable<N> depthFirstPostOrder(N startNode);\n"], "10": ["  public abstract Iterable<N> depthFirstPostOrder(Iterable<? extends N> startNodes);\n", "\n", "  // Avoid subclasses outside of this class\n", "  private Traverser() {}\n", "\n", "  private static final class GraphTraverser<N> extends Traverser<N> {\n", "    private final SuccessorsFunction<N> graph;\n", "\n", "    GraphTraverser(SuccessorsFunction<N> graph) {\n", "      this.graph = checkNotNull(graph);\n", "    }\n", "\n", "    @Override\n", "    public Iterable<N> breadthFirst(final N startNode) {\n", "      checkNotNull(startNode);\n", "      return breadthFirst(ImmutableSet.of(startNode));\n", "    }\n", "\n", "    @Override\n", "    public Iterable<N> breadthFirst(final Iterable<? extends N> startNodes) {\n", "      checkNotNull(startNodes);\n", "      if (Iterables.isEmpty(startNodes)) {\n", "        return ImmutableSet.of();\n", "      }\n", "      for (N startNode : startNodes) {\n", "        checkThatNodeIsInGraph(startNode);\n", "      }\n", "      return new Iterable<N>() {\n", "        @Override\n", "        public Iterator<N> iterator() {\n", "          return new BreadthFirstIterator(startNodes);\n", "        }\n", "      };\n", "    }\n", "\n", "    @Override\n", "    public Iterable<N> depthFirstPreOrder(final N startNode) {\n", "      checkNotNull(startNode);\n", "      return depthFirstPreOrder(ImmutableSet.of(startNode));\n", "    }\n", "\n", "    @Override\n", "    public Iterable<N> depthFirstPreOrder(final Iterable<? extends N> startNodes) {\n", "      checkNotNull(startNodes);\n", "      if (Iterables.isEmpty(startNodes)) {\n", "        return ImmutableSet.of();\n", "      }\n", "      for (N startNode : startNodes) {\n", "        checkThatNodeIsInGraph(startNode);\n", "      }\n", "      return new Iterable<N>() {\n", "        @Override\n", "        public Iterator<N> iterator() {\n", "          return Walker.inGraph(graph).preOrder(startNodes.iterator());\n", "        }\n", "      };\n", "    }\n", "\n", "    @Override\n", "    public Iterable<N> depthFirstPostOrder(final N startNode) {\n", "      checkNotNull(startNode);\n", "      return depthFirstPostOrder(ImmutableSet.of(startNode));\n", "    }\n", "\n", "    @Override\n", "    public Iterable<N> depthFirstPostOrder(final Iterable<? extends N> startNodes) {\n", "      checkNotNull(startNodes);\n", "      if (Iterables.isEmpty(startNodes)) {\n", "        return ImmutableSet.of();\n", "      }\n", "      for (N startNode : startNodes) {\n", "        checkThatNodeIsInGraph(startNode);\n", "      }\n", "      return new Iterable<N>() {\n", "        @Override\n", "        public Iterator<N> iterator() {\n", "          return Walker.inGraph(graph).postOrder(startNodes.iterator());\n", "        }\n", "      };\n", "    }\n", "\n", "    @SuppressWarnings(\"CheckReturnValue\")\n", "    private void checkThatNodeIsInGraph(N startNode) {\n", "      // successors() throws an IllegalArgumentException for nodes that are not an element of the\n", "      // graph.\n", "      graph.successors(startNode);\n", "    }\n", "\n", "    private final class BreadthFirstIterator extends UnmodifiableIterator<N> {\n", "      private final Queue<N> queue = new ArrayDeque<>();\n", "      private final Set<N> visited = new HashSet<>();\n", "\n", "      BreadthFirstIterator(Iterable<? extends N> roots) {\n", "        for (N root : roots) {\n", "          // add all roots to the queue, skipping duplicates\n", "          if (visited.add(root)) {\n", "            queue.add(root);\n", "          }\n", "        }\n", "      }\n", "\n", "      public boolean hasNext() {\n", "        return !queue.isEmpty();\n", "\n", "      @Override\n", "      public N next() {\n", "        N current = queue.remove();\n", "        for (N neighbor : graph.successors(current)) {\n", "          if (visited.add(neighbor)) {\n", "            queue.add(neighbor);\n", "          }\n", "        }\n", "        return current;\n", "      }\n", "    }\n", "  private static final class TreeTraverser<N> extends Traverser<N> {\n", "    private final SuccessorsFunction<N> tree;\n", "\n", "    TreeTraverser(SuccessorsFunction<N> tree) {\n", "      this.tree = checkNotNull(tree);\n", "    }\n", "\n", "    @Override\n", "    public Iterable<N> breadthFirst(final N startNode) {\n", "      checkNotNull(startNode);\n", "      return breadthFirst(ImmutableSet.of(startNode));\n", "    }\n", "\n", "    @Override\n", "    public Iterable<N> breadthFirst(final Iterable<? extends N> startNodes) {\n", "      checkNotNull(startNodes);\n", "      if (Iterables.isEmpty(startNodes)) {\n", "        return ImmutableSet.of();\n", "      }\n", "      for (N startNode : startNodes) {\n", "        checkThatNodeIsInTree(startNode);\n", "      }\n", "      return new Iterable<N>() {\n", "        @Override\n", "        public Iterator<N> iterator() {\n", "          return new BreadthFirstIterator(startNodes);\n", "        }\n", "      };\n", "    }\n", "\n", "    @Override\n", "    public Iterable<N> depthFirstPreOrder(final N startNode) {\n", "      checkNotNull(startNode);\n", "      return depthFirstPreOrder(ImmutableSet.of(startNode));\n", "    }\n", "    @Override\n", "    public Iterable<N> depthFirstPreOrder(final Iterable<? extends N> startNodes) {\n", "      checkNotNull(startNodes);\n", "      if (Iterables.isEmpty(startNodes)) {\n", "        return ImmutableSet.of();\n", "      }\n", "      for (N node : startNodes) {\n", "        checkThatNodeIsInTree(node);\n", "      }\n", "      return new Iterable<N>() {\n", "        @Override\n", "        public Iterator<N> iterator() {\n", "          return Walker.inTree(tree).preOrder(startNodes.iterator());\n", "        }\n", "      };\n", "    }\n", "\n", "    @Override\n", "    public Iterable<N> depthFirstPostOrder(final N startNode) {\n", "      checkNotNull(startNode);\n", "      return depthFirstPostOrder(ImmutableSet.of(startNode));\n", "    }\n", "\n", "    @Override\n", "    public Iterable<N> depthFirstPostOrder(final Iterable<? extends N> startNodes) {\n", "      checkNotNull(startNodes);\n", "      if (Iterables.isEmpty(startNodes)) {\n", "        return ImmutableSet.of();\n", "      }\n", "      for (N startNode : startNodes) {\n", "        checkThatNodeIsInTree(startNode);\n", "      }\n", "      return new Iterable<N>() {\n", "        @Override\n", "        public Iterator<N> iterator() {\n", "          return Walker.inTree(tree).postOrder(startNodes.iterator());\n", "        }\n", "      };\n", "    }\n", "\n", "    @SuppressWarnings(\"CheckReturnValue\")\n", "    private void checkThatNodeIsInTree(N startNode) {\n", "      // successors() throws an IllegalArgumentException for nodes that are not an element of the\n", "      // graph.\n", "      tree.successors(startNode);\n", "    }\n", "\n", "    private final class BreadthFirstIterator extends UnmodifiableIterator<N> {\n", "      private final Queue<N> queue = new ArrayDeque<>();\n", "\n", "      BreadthFirstIterator(Iterable<? extends N> roots) {\n", "        for (N root : roots) {\n", "          queue.add(root);\n", "        }\n", "      }\n", "\n", "      @Override\n", "      public boolean hasNext() {\n", "        return !queue.isEmpty();\n", "      }\n", "\n", "      @Override\n", "      public N next() {\n", "        N current = queue.remove();\n", "        Iterables.addAll(queue, tree.successors(current));\n", "        return current;\n", "      }\n"], "11": ["  private abstract static class Walker<N> {\n", "    Walker(SuccessorsFunction<N> successorFunction) {\n", "      this.successorFunction = checkNotNull(successorFunction);\n", "    static <N> Walker<N> inGraph(SuccessorsFunction<N> graph) {\n", "      return new Walker<N>(graph) {\n"], "12": ["    static <N> Walker<N> inTree(SuccessorsFunction<N> tree) {\n", "      return new Walker<N>(tree) {\n"], "13": ["      horizon.addFirst(startNodes);\n"], "14": ["                horizon.addFirst(successors);\n"], "15": ["      final Deque<Iterator<? extends N>> horizon = new ArrayDeque<>();\n", "      horizon.addFirst(startNodes);\n"], "16": ["     * Null is returned to indicate reaching the end of the top iterator, which can be used by the\n", "     * traversal strategies to decide what to return in such case: in pre-order, continue to poll\n", "     * the next top iterator with {@code visitNext()}; in post-order, return the parent node.\n"]}, "added_lines": {"2": [63, 64, 65, 66, 67], "3": [93, 94, 95, 96, 97, 98, 99], "4": [175, 182, 183, 184, 185, 186, 187], "5": [221, 222, 223], "6": [235, 236, 237, 238, 239, 240, 241, 242, 243], "7": [276, 277, 278], "8": [290, 291, 292, 293, 294, 295, 296, 297, 298], "9": [331, 332, 333], "10": [345, 346, 347, 349, 350, 352, 355, 357, 358, 359, 360, 361, 363], "11": [371, 374, 375, 378, 380], "12": [396, 397], "13": [410, 411, 412, 413, 415, 416, 417, 418, 419, 420, 421, 422, 423, 424, 426], "14": [435, 436, 437], "15": [449, 450], "16": [469], "17": [480, 481, 482, 483, 484, 485, 486, 487, 488, 489, 490, 491, 492, 493, 494, 495, 496, 497]}, "removed_lines": {"1": [25, 26, 31], "3": [91, 92, 93], "4": [169, 170, 177], "5": [211], "6": [223], "7": [256], "8": [268], "9": [301], "10": [313, 314, 315, 316, 317, 318, 319, 320, 321, 322, 323, 324, 325, 326, 327, 328, 329, 330, 331, 332, 333, 334, 335, 336, 337, 338, 339, 340, 341, 342, 343, 344, 345, 346, 347, 348, 349, 350, 351, 352, 353, 354, 355, 356, 357, 358, 359, 360, 361, 362, 363, 364, 365, 366, 367, 368, 369, 370, 371, 372, 373, 374, 375, 376, 377, 378, 379, 380, 381, 382, 383, 384, 385, 386, 387, 388, 389, 390, 391, 392, 393, 394, 395, 396, 397, 398, 399, 400, 401, 402, 403, 404, 405, 406, 407, 408, 409, 410, 411, 412, 413, 415, 416, 418, 419, 420, 421, 422, 423, 424, 425, 426, 427, 428, 429, 432, 433, 434, 435, 436, 437, 438, 439, 440, 441, 442, 443, 444, 445, 446, 447, 448, 449, 450, 451, 452, 453, 454, 455, 456, 457, 458, 459, 460, 461, 462, 463, 464, 465, 466, 468, 469, 470, 471, 472, 473, 474, 475, 476, 477, 478, 479, 480, 481, 482, 483, 484, 485, 486, 487, 488, 489, 490, 491, 492, 493, 494, 495, 496, 497, 498, 499, 500, 501, 502, 503, 504, 505, 506, 507, 508, 509, 510, 511, 512, 513, 514, 515, 516, 517, 518, 519, 520, 521, 522, 523, 524, 525, 526, 527, 528, 529, 530, 531, 532, 533, 534], "11": [543, 546, 547, 550, 552], "12": [568, 569], "13": [584], "14": [593], "15": [604, 605], "16": [625, 626, 627]}}]}
