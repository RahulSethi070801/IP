{
    "addition": {
        "63": "  private final SuccessorsFunction<N> successorFunction;\n",
        "64": "\n",
        "65": "  private Traverser(SuccessorsFunction<N> successorFunction) {\n",
        "66": "    this.successorFunction = checkNotNull(successorFunction);\n",
        "67": "  }\n",
        "93": "  public static <N> Traverser<N> forGraph(final SuccessorsFunction<N> graph) {\n",
        "94": "    return new Traverser<N>(graph) {\n",
        "95": "      @Override\n",
        "96": "      Traversal<N> newTraversal() {\n",
        "97": "        return Traversal.inGraph(graph);\n",
        "98": "      }\n",
        "99": "    };\n",
        "175": "  public static <N> Traverser<N> forTree(final SuccessorsFunction<N> tree) {\n",
        "182": "    return new Traverser<N>(tree) {\n",
        "183": "      @Override\n",
        "184": "      Traversal<N> newTraversal() {\n",
        "185": "        return Traversal.inTree(tree);\n",
        "186": "      }\n",
        "187": "    };\n",
        "221": "  public final Iterable<N> breadthFirst(N startNode) {\n",
        "222": "    return breadthFirst(ImmutableSet.of(startNode));\n",
        "223": "  }\n",
        "235": "  public final Iterable<N> breadthFirst(Iterable<? extends N> startNodes) {\n",
        "236": "    final ImmutableSet<N> validated = validate(startNodes);\n",
        "237": "    return new Iterable<N>() {\n",
        "238": "      @Override\n",
        "239": "      public Iterator<N> iterator() {\n",
        "240": "        return newTraversal().breadthFirst(validated.iterator());\n",
        "241": "      }\n",
        "242": "    };\n",
        "243": "  }\n",
        "276": "  public final Iterable<N> depthFirstPreOrder(N startNode) {\n",
        "277": "    return depthFirstPreOrder(ImmutableSet.of(startNode));\n",
        "278": "  }\n",
        "290": "  public final Iterable<N> depthFirstPreOrder(Iterable<? extends N> startNodes) {\n",
        "291": "    final ImmutableSet<N> validated = validate(startNodes);\n",
        "292": "    return new Iterable<N>() {\n",
        "293": "      @Override\n",
        "294": "      public Iterator<N> iterator() {\n",
        "295": "        return newTraversal().preOrder(validated.iterator());\n",
        "296": "      }\n",
        "297": "    };\n",
        "298": "  }\n",
        "331": "  public final Iterable<N> depthFirstPostOrder(N startNode) {\n",
        "332": "    return depthFirstPostOrder(ImmutableSet.of(startNode));\n",
        "333": "  }\n",
        "345": "  public final Iterable<N> depthFirstPostOrder(Iterable<? extends N> startNodes) {\n",
        "346": "    final ImmutableSet<N> validated = validate(startNodes);\n",
        "347": "    return new Iterable<N>() {\n",
        "349": "      public Iterator<N> iterator() {\n",
        "350": "        return newTraversal().postOrder(validated.iterator());\n",
        "352": "    };\n",
        "355": "  abstract Traversal<N> newTraversal();\n",
        "357": "  @SuppressWarnings(\"CheckReturnValue\")\n",
        "358": "  private ImmutableSet<N> validate(Iterable<? extends N> startNodes) {\n",
        "359": "    ImmutableSet<N> copy = ImmutableSet.copyOf(startNodes);\n",
        "360": "    for (N node : copy) {\n",
        "361": "      successorFunction.successors(node); // Will throw if node doesn't exist\n",
        "363": "    return copy;\n",
        "371": "  private abstract static class Traversal<N> {\n",
        "374": "    Traversal(SuccessorsFunction<N> successorFunction) {\n",
        "375": "      this.successorFunction = successorFunction;\n",
        "378": "    static <N> Traversal<N> inGraph(SuccessorsFunction<N> graph) {\n",
        "380": "      return new Traversal<N>(graph) {\n",
        "396": "    static <N> Traversal<N> inTree(SuccessorsFunction<N> tree) {\n",
        "397": "      return new Traversal<N>(tree) {\n",
        "410": "    final Iterator<N> breadthFirst(Iterator<? extends N> startNodes) {\n",
        "411": "      return topDown(startNodes, InsertionOrder.BACK);\n",
        "412": "    }\n",
        "413": "\n",
        "415": "      return topDown(startNodes, InsertionOrder.FRONT);\n",
        "416": "    }\n",
        "417": "\n",
        "418": "    /**\n",
        "419": "     * In top-down traversal, an ancestor node is always traversed before any of its descendant\n",
        "420": "     * nodes. The traversal order among descendant nodes (particularly aunts and nieces) are\n",
        "421": "     * determined by the {@code InsertionOrder} parameter: nieces are placed at the FRONT before\n",
        "422": "     * aunts for pre-order; while in BFS they are placed at the BACK after aunts.\n",
        "423": "     */\n",
        "424": "    private Iterator<N> topDown(Iterator<? extends N> startNodes, final InsertionOrder order) {\n",
        "426": "      horizon.add(startNodes);\n",
        "435": "                // BFS: horizon.addLast(successors)\n",
        "436": "                // Pre-order: horizon.addFirst(successors)\n",
        "437": "                order.insertInto(horizon, successors);\n",
        "449": "      final Deque<Iterator<? extends N>> horizon = new ArrayDeque<>();\n",
        "450": "      horizon.add(startNodes);\n",
        "469": "     * Null is returned to indicate reaching the end of the top iterator.\n",
        "480": "\n",
        "481": "  /** Poor man's method reference for {@code Deque::addFirst} and {@code Deque::addLast}. */\n",
        "482": "  private enum InsertionOrder {\n",
        "483": "    FRONT {\n",
        "484": "      @Override\n",
        "485": "      <T> void insertInto(Deque<T> deque, T value) {\n",
        "486": "        deque.addFirst(value);\n",
        "487": "      }\n",
        "488": "    },\n",
        "489": "    BACK {\n",
        "490": "      @Override\n",
        "491": "      <T> void insertInto(Deque<T> deque, T value) {\n",
        "492": "        deque.addLast(value);\n",
        "493": "      }\n",
        "494": "    };\n",
        "495": "\n",
        "496": "    abstract <T> void insertInto(Deque<T> deque, T value);\n",
        "497": "  }\n"
    },
    "removed": {
        "25": "import com.google.common.collect.Iterables;\n",
        "26": "import com.google.common.collect.UnmodifiableIterator;\n",
        "31": "import java.util.Queue;\n",
        "91": "  public static <N> Traverser<N> forGraph(SuccessorsFunction<N> graph) {\n",
        "92": "    checkNotNull(graph);\n",
        "93": "    return new GraphTraverser<>(graph);\n",
        "169": "  public static <N> Traverser<N> forTree(SuccessorsFunction<N> tree) {\n",
        "170": "    checkNotNull(tree);\n",
        "177": "    return new TreeTraverser<>(tree);\n",
        "211": "  public abstract Iterable<N> breadthFirst(N startNode);\n",
        "223": "  public abstract Iterable<N> breadthFirst(Iterable<? extends N> startNodes);\n",
        "256": "  public abstract Iterable<N> depthFirstPreOrder(N startNode);\n",
        "268": "  public abstract Iterable<N> depthFirstPreOrder(Iterable<? extends N> startNodes);\n",
        "301": "  public abstract Iterable<N> depthFirstPostOrder(N startNode);\n",
        "313": "  public abstract Iterable<N> depthFirstPostOrder(Iterable<? extends N> startNodes);\n",
        "314": "\n",
        "315": "  // Avoid subclasses outside of this class\n",
        "316": "  private Traverser() {}\n",
        "317": "\n",
        "318": "  private static final class GraphTraverser<N> extends Traverser<N> {\n",
        "319": "    private final SuccessorsFunction<N> graph;\n",
        "320": "\n",
        "321": "    GraphTraverser(SuccessorsFunction<N> graph) {\n",
        "322": "      this.graph = checkNotNull(graph);\n",
        "323": "    }\n",
        "324": "\n",
        "325": "    @Override\n",
        "326": "    public Iterable<N> breadthFirst(final N startNode) {\n",
        "327": "      checkNotNull(startNode);\n",
        "328": "      return breadthFirst(ImmutableSet.of(startNode));\n",
        "329": "    }\n",
        "330": "\n",
        "331": "    @Override\n",
        "332": "    public Iterable<N> breadthFirst(final Iterable<? extends N> startNodes) {\n",
        "333": "      checkNotNull(startNodes);\n",
        "334": "      if (Iterables.isEmpty(startNodes)) {\n",
        "335": "        return ImmutableSet.of();\n",
        "336": "      }\n",
        "337": "      for (N startNode : startNodes) {\n",
        "338": "        checkThatNodeIsInGraph(startNode);\n",
        "339": "      }\n",
        "340": "      return new Iterable<N>() {\n",
        "341": "        @Override\n",
        "342": "        public Iterator<N> iterator() {\n",
        "343": "          return new BreadthFirstIterator(startNodes);\n",
        "344": "        }\n",
        "345": "      };\n",
        "346": "    }\n",
        "347": "\n",
        "348": "    @Override\n",
        "349": "    public Iterable<N> depthFirstPreOrder(final N startNode) {\n",
        "350": "      checkNotNull(startNode);\n",
        "351": "      return depthFirstPreOrder(ImmutableSet.of(startNode));\n",
        "352": "    }\n",
        "353": "\n",
        "354": "    @Override\n",
        "355": "    public Iterable<N> depthFirstPreOrder(final Iterable<? extends N> startNodes) {\n",
        "356": "      checkNotNull(startNodes);\n",
        "357": "      if (Iterables.isEmpty(startNodes)) {\n",
        "358": "        return ImmutableSet.of();\n",
        "359": "      }\n",
        "360": "      for (N startNode : startNodes) {\n",
        "361": "        checkThatNodeIsInGraph(startNode);\n",
        "362": "      }\n",
        "363": "      return new Iterable<N>() {\n",
        "364": "        @Override\n",
        "365": "        public Iterator<N> iterator() {\n",
        "366": "          return Walker.inGraph(graph).preOrder(startNodes.iterator());\n",
        "367": "        }\n",
        "368": "      };\n",
        "369": "    }\n",
        "370": "\n",
        "371": "    @Override\n",
        "372": "    public Iterable<N> depthFirstPostOrder(final N startNode) {\n",
        "373": "      checkNotNull(startNode);\n",
        "374": "      return depthFirstPostOrder(ImmutableSet.of(startNode));\n",
        "375": "    }\n",
        "376": "\n",
        "377": "    @Override\n",
        "378": "    public Iterable<N> depthFirstPostOrder(final Iterable<? extends N> startNodes) {\n",
        "379": "      checkNotNull(startNodes);\n",
        "380": "      if (Iterables.isEmpty(startNodes)) {\n",
        "381": "        return ImmutableSet.of();\n",
        "382": "      }\n",
        "383": "      for (N startNode : startNodes) {\n",
        "384": "        checkThatNodeIsInGraph(startNode);\n",
        "385": "      }\n",
        "386": "      return new Iterable<N>() {\n",
        "387": "        @Override\n",
        "388": "        public Iterator<N> iterator() {\n",
        "389": "          return Walker.inGraph(graph).postOrder(startNodes.iterator());\n",
        "390": "        }\n",
        "391": "      };\n",
        "392": "    }\n",
        "393": "\n",
        "394": "    @SuppressWarnings(\"CheckReturnValue\")\n",
        "395": "    private void checkThatNodeIsInGraph(N startNode) {\n",
        "396": "      // successors() throws an IllegalArgumentException for nodes that are not an element of the\n",
        "397": "      // graph.\n",
        "398": "      graph.successors(startNode);\n",
        "399": "    }\n",
        "400": "\n",
        "401": "    private final class BreadthFirstIterator extends UnmodifiableIterator<N> {\n",
        "402": "      private final Queue<N> queue = new ArrayDeque<>();\n",
        "403": "      private final Set<N> visited = new HashSet<>();\n",
        "404": "\n",
        "405": "      BreadthFirstIterator(Iterable<? extends N> roots) {\n",
        "406": "        for (N root : roots) {\n",
        "407": "          // add all roots to the queue, skipping duplicates\n",
        "408": "          if (visited.add(root)) {\n",
        "409": "            queue.add(root);\n",
        "410": "          }\n",
        "411": "        }\n",
        "412": "      }\n",
        "413": "\n",
        "415": "      public boolean hasNext() {\n",
        "416": "        return !queue.isEmpty();\n",
        "418": "\n",
        "419": "      @Override\n",
        "420": "      public N next() {\n",
        "421": "        N current = queue.remove();\n",
        "422": "        for (N neighbor : graph.successors(current)) {\n",
        "423": "          if (visited.add(neighbor)) {\n",
        "424": "            queue.add(neighbor);\n",
        "425": "          }\n",
        "426": "        }\n",
        "427": "        return current;\n",
        "428": "      }\n",
        "429": "    }\n",
        "432": "  private static final class TreeTraverser<N> extends Traverser<N> {\n",
        "433": "    private final SuccessorsFunction<N> tree;\n",
        "434": "\n",
        "435": "    TreeTraverser(SuccessorsFunction<N> tree) {\n",
        "436": "      this.tree = checkNotNull(tree);\n",
        "437": "    }\n",
        "438": "\n",
        "439": "    @Override\n",
        "440": "    public Iterable<N> breadthFirst(final N startNode) {\n",
        "441": "      checkNotNull(startNode);\n",
        "442": "      return breadthFirst(ImmutableSet.of(startNode));\n",
        "443": "    }\n",
        "444": "\n",
        "445": "    @Override\n",
        "446": "    public Iterable<N> breadthFirst(final Iterable<? extends N> startNodes) {\n",
        "447": "      checkNotNull(startNodes);\n",
        "448": "      if (Iterables.isEmpty(startNodes)) {\n",
        "449": "        return ImmutableSet.of();\n",
        "450": "      }\n",
        "451": "      for (N startNode : startNodes) {\n",
        "452": "        checkThatNodeIsInTree(startNode);\n",
        "453": "      }\n",
        "454": "      return new Iterable<N>() {\n",
        "455": "        @Override\n",
        "456": "        public Iterator<N> iterator() {\n",
        "457": "          return new BreadthFirstIterator(startNodes);\n",
        "458": "        }\n",
        "459": "      };\n",
        "460": "    }\n",
        "461": "\n",
        "462": "    @Override\n",
        "463": "    public Iterable<N> depthFirstPreOrder(final N startNode) {\n",
        "464": "      checkNotNull(startNode);\n",
        "465": "      return depthFirstPreOrder(ImmutableSet.of(startNode));\n",
        "466": "    }\n",
        "468": "    @Override\n",
        "469": "    public Iterable<N> depthFirstPreOrder(final Iterable<? extends N> startNodes) {\n",
        "470": "      checkNotNull(startNodes);\n",
        "471": "      if (Iterables.isEmpty(startNodes)) {\n",
        "472": "        return ImmutableSet.of();\n",
        "473": "      }\n",
        "474": "      for (N node : startNodes) {\n",
        "475": "        checkThatNodeIsInTree(node);\n",
        "476": "      }\n",
        "477": "      return new Iterable<N>() {\n",
        "478": "        @Override\n",
        "479": "        public Iterator<N> iterator() {\n",
        "480": "          return Walker.inTree(tree).preOrder(startNodes.iterator());\n",
        "481": "        }\n",
        "482": "      };\n",
        "483": "    }\n",
        "484": "\n",
        "485": "    @Override\n",
        "486": "    public Iterable<N> depthFirstPostOrder(final N startNode) {\n",
        "487": "      checkNotNull(startNode);\n",
        "488": "      return depthFirstPostOrder(ImmutableSet.of(startNode));\n",
        "489": "    }\n",
        "490": "\n",
        "491": "    @Override\n",
        "492": "    public Iterable<N> depthFirstPostOrder(final Iterable<? extends N> startNodes) {\n",
        "493": "      checkNotNull(startNodes);\n",
        "494": "      if (Iterables.isEmpty(startNodes)) {\n",
        "495": "        return ImmutableSet.of();\n",
        "496": "      }\n",
        "497": "      for (N startNode : startNodes) {\n",
        "498": "        checkThatNodeIsInTree(startNode);\n",
        "499": "      }\n",
        "500": "      return new Iterable<N>() {\n",
        "501": "        @Override\n",
        "502": "        public Iterator<N> iterator() {\n",
        "503": "          return Walker.inTree(tree).postOrder(startNodes.iterator());\n",
        "504": "        }\n",
        "505": "      };\n",
        "506": "    }\n",
        "507": "\n",
        "508": "    @SuppressWarnings(\"CheckReturnValue\")\n",
        "509": "    private void checkThatNodeIsInTree(N startNode) {\n",
        "510": "      // successors() throws an IllegalArgumentException for nodes that are not an element of the\n",
        "511": "      // graph.\n",
        "512": "      tree.successors(startNode);\n",
        "513": "    }\n",
        "514": "\n",
        "515": "    private final class BreadthFirstIterator extends UnmodifiableIterator<N> {\n",
        "516": "      private final Queue<N> queue = new ArrayDeque<>();\n",
        "517": "\n",
        "518": "      BreadthFirstIterator(Iterable<? extends N> roots) {\n",
        "519": "        for (N root : roots) {\n",
        "520": "          queue.add(root);\n",
        "521": "        }\n",
        "522": "      }\n",
        "523": "\n",
        "524": "      @Override\n",
        "525": "      public boolean hasNext() {\n",
        "526": "        return !queue.isEmpty();\n",
        "527": "      }\n",
        "528": "\n",
        "529": "      @Override\n",
        "530": "      public N next() {\n",
        "531": "        N current = queue.remove();\n",
        "532": "        Iterables.addAll(queue, tree.successors(current));\n",
        "533": "        return current;\n",
        "534": "      }\n",
        "543": "  private abstract static class Walker<N> {\n",
        "546": "    Walker(SuccessorsFunction<N> successorFunction) {\n",
        "547": "      this.successorFunction = checkNotNull(successorFunction);\n",
        "550": "    static <N> Walker<N> inGraph(SuccessorsFunction<N> graph) {\n",
        "552": "      return new Walker<N>(graph) {\n",
        "568": "    static <N> Walker<N> inTree(SuccessorsFunction<N> tree) {\n",
        "569": "      return new Walker<N>(tree) {\n",
        "584": "      horizon.addFirst(startNodes);\n",
        "593": "                horizon.addFirst(successors);\n",
        "604": "      final Deque<Iterator<? extends N>> horizon = new ArrayDeque<>();\n",
        "605": "      horizon.addFirst(startNodes);\n",
        "625": "     * Null is returned to indicate reaching the end of the top iterator, which can be used by the\n",
        "626": "     * traversal strategies to decide what to return in such case: in pre-order, continue to poll\n",
        "627": "     * the next top iterator with {@code visitNext()}; in post-order, return the parent node.\n"
    }
}