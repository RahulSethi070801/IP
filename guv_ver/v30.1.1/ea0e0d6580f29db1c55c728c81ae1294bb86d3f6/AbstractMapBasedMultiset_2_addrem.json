{
    "addition": {
        "21": "import static com.google.common.base.Preconditions.checkState;\n",
        "24": "import static java.util.Objects.requireNonNull;\n",
        "38": "import javax.annotation.CheckForNull;\n",
        "50": "@ElementTypesAreNonnullByDefault\n",
        "51": "abstract class AbstractMapBasedMultiset<E extends @Nullable Object> extends AbstractMultiset<E>\n",
        "52": "    implements Serializable {\n",
        "92": "      @CheckForNull Map.Entry<E, Count> toRemove;\n",
        "100": "      @ParametricNullness\n",
        "109": "        checkState(toRemove != null, \"no calls to next() since the last call to remove()\");\n",
        "121": "      @CheckForNull Map.Entry<E, Count> toRemove;\n",
        "134": "          @ParametricNullness\n",
        "155": "        checkState(toRemove != null, \"no calls to next() since the last call to remove()\");\n",
        "202": "    @CheckForNull Map.Entry<E, Count> currentEntry;\n",
        "216": "    @ParametricNullness\n",
        "224": "      /*\n",
        "225": "       * requireNonNull is safe because occurrencesLeft starts at 0, forcing us to initialize\n",
        "226": "       * currentEntry above. After that, we never clear it.\n",
        "227": "       */\n",
        "228": "      return requireNonNull(currentEntry).getKey();\n",
        "234": "      /*\n",
        "235": "       * requireNonNull is safe because canRemove is set to true only after we initialize\n",
        "236": "       * currentEntry (which we never subsequently clear).\n",
        "237": "       */\n",
        "238": "      int frequency = requireNonNull(currentEntry).getValue().get();\n",
        "251": "  public int count(@CheckForNull Object element) {\n",
        "266": "  public int add(@ParametricNullness E element, int occurrences) {\n",
        "288": "  public int remove(@CheckForNull Object element, int occurrences) {\n",
        "316": "  public int setCount(@ParametricNullness E element, int count) {\n",
        "337": "  private static int getAndSet(@CheckForNull Count i, int count) {\n"
    },
    "removed": {
        "47": "abstract class AbstractMapBasedMultiset<E> extends AbstractMultiset<E> implements Serializable {\n",
        "87": "      Map.@Nullable Entry<E, Count> toRemove;\n",
        "103": "        checkRemove(toRemove != null);\n",
        "115": "      Map.@Nullable Entry<E, Count> toRemove;\n",
        "148": "        checkRemove(toRemove != null);\n",
        "195": "    Map.@Nullable Entry<E, Count> currentEntry;\n",
        "216": "      return currentEntry.getKey();\n",
        "222": "      int frequency = currentEntry.getValue().get();\n",
        "235": "  public int count(@Nullable Object element) {\n",
        "250": "  public int add(@Nullable E element, int occurrences) {\n",
        "272": "  public int remove(@Nullable Object element, int occurrences) {\n",
        "300": "  public int setCount(@Nullable E element, int count) {\n",
        "321": "  private static int getAndSet(@Nullable Count i, int count) {\n"
    }
}