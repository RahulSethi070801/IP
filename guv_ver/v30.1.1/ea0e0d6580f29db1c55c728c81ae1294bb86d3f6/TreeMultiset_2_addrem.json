{
    "addition": {
        "23": "import static com.google.common.collect.NullnessCasts.uncheckedCastNullableTToT;\n",
        "24": "import static java.util.Objects.requireNonNull;\n",
        "40": "import javax.annotation.CheckForNull;\n",
        "62": "@ElementTypesAreNonnullByDefault\n",
        "63": "public final class TreeMultiset<E extends @Nullable Object> extends AbstractSortedMultiset<E>\n",
        "64": "    implements Serializable {\n",
        "94": "  public static <E extends @Nullable Object> TreeMultiset<E> create(\n",
        "95": "      @CheckForNull Comparator<? super E> comparator) {\n",
        "130": "    this.header = new AvlNode<>();\n",
        "144": "      long treeAggregate(@CheckForNull AvlNode<?> root) {\n",
        "155": "      long treeAggregate(@CheckForNull AvlNode<?> root) {\n",
        "162": "    abstract long treeAggregate(@CheckForNull AvlNode<?> root);\n",
        "177": "  private long aggregateBelowRange(Aggregate aggr, @CheckForNull AvlNode<E> node) {\n",
        "181": "    // The cast is safe because we call this method only if hasLowerBound().\n",
        "182": "    int cmp =\n",
        "183": "        comparator()\n",
        "184": "            .compare(uncheckedCastNullableTToT(range.getLowerEndpoint()), node.getElement());\n",
        "203": "  private long aggregateAboveRange(Aggregate aggr, @CheckForNull AvlNode<E> node) {\n",
        "207": "    // The cast is safe because we call this method only if hasUpperBound().\n",
        "208": "    int cmp =\n",
        "209": "        comparator()\n",
        "210": "            .compare(uncheckedCastNullableTToT(range.getUpperEndpoint()), node.getElement());\n",
        "239": "  static int distinctElements(@CheckForNull AvlNode<?> node) {\n",
        "244": "  public int count(@CheckForNull Object element) {\n",
        "260": "  public int add(@ParametricNullness E element, int occurrences) {\n",
        "282": "  public int remove(@CheckForNull Object element, int occurrences) {\n",
        "306": "  public int setCount(@ParametricNullness E element, int count) {\n",
        "328": "  public boolean setCount(@ParametricNullness E element, int oldCount, int newCount) {\n",
        "354": "      for (AvlNode<E> current = header.succ(); current != header; ) {\n",
        "355": "        AvlNode<E> next = current.succ();\n",
        "377": "      @ParametricNullness\n",
        "395": "  @CheckForNull\n",
        "396": "  private AvlNode<E> firstNode() {\n",
        "403": "      // The cast is safe because of the hasLowerBound check.\n",
        "404": "      E endpoint = uncheckedCastNullableTToT(range.getLowerEndpoint());\n",
        "405": "      node = root.ceiling(comparator(), endpoint);\n",
        "411": "        node = node.succ();\n",
        "414": "      node = header.succ();\n",
        "419": "  @CheckForNull\n",
        "420": "  private AvlNode<E> lastNode() {\n",
        "427": "      // The cast is safe because of the hasUpperBound check.\n",
        "428": "      E endpoint = uncheckedCastNullableTToT(range.getUpperEndpoint());\n",
        "429": "      node = root.floor(comparator(), endpoint);\n",
        "435": "        node = node.pred();\n",
        "438": "      node = header.pred();\n",
        "451": "      @CheckForNull AvlNode<E> current = firstNode();\n",
        "452": "      @CheckForNull Entry<E> prevEntry;\n",
        "471": "        // requireNonNull is safe because current is only nulled out after iteration is complete.\n",
        "472": "        Entry<E> result = wrapEntry(requireNonNull(current));\n",
        "474": "        if (current.succ() == header) {\n",
        "477": "          current = current.succ();\n",
        "484": "        checkState(prevEntry != null, \"no calls to next() since the last call to remove()\");\n",
        "494": "      @CheckForNull AvlNode<E> current = lastNode();\n",
        "495": "      @CheckForNull Entry<E> prevEntry = null;\n",
        "514": "        // requireNonNull is safe because current is only nulled out after iteration is complete.\n",
        "515": "        requireNonNull(current);\n",
        "518": "        if (current.pred() == header) {\n",
        "521": "          current = current.pred();\n",
        "528": "        checkState(prevEntry != null, \"no calls to next() since the last call to remove()\");\n",
        "540": "        node = node.succ()) {\n",
        "551": "  public SortedMultiset<E> headMultiset(@ParametricNullness E upperBound, BoundType boundType) {\n",
        "559": "  public SortedMultiset<E> tailMultiset(@ParametricNullness E lowerBound, BoundType boundType) {\n",
        "567": "    @CheckForNull private T value;\n",
        "569": "    @CheckForNull\n",
        "570": "    public T get() {\n",
        "574": "    public void checkAndSet(@CheckForNull T expected, @CheckForNull T newValue) {\n",
        "586": "  private static final class AvlNode<E extends @Nullable Object> {\n",
        "587": "    /*\n",
        "588": "     * For \"normal\" nodes, the type of this field is `E`, not `@Nullable E` (though note that E is a\n",
        "589": "     * type that can include null, as in a TreeMultiset<@Nullable String>).\n",
        "590": "     *\n",
        "591": "     * For the header node, though, this field contains `null`, regardless of the type of the\n",
        "592": "     * multiset.\n",
        "593": "     *\n",
        "594": "     * Most code that operates on an AvlNode never operates on the header node. Such code can access\n",
        "595": "     * the elem field without a null check by calling getElement().\n",
        "596": "     */\n",
        "597": "    @CheckForNull private final E elem;\n",
        "605": "    @CheckForNull private AvlNode<E> left;\n",
        "606": "    @CheckForNull private AvlNode<E> right;\n",
        "607": "    /*\n",
        "608": "     * pred and succ are nullable after construction, but we always call successor() to initialize\n",
        "609": "     * them immediately thereafter.\n",
        "610": "     *\n",
        "611": "     * They may be subsequently nulled out by TreeMultiset.clear(). I think that the only place that\n",
        "612": "     * we can reference a node whose fields have been cleared is inside the iterator (and presumably\n",
        "613": "     * only under concurrent modification).\n",
        "614": "     *\n",
        "615": "     * To access these fields when you know that they are not null, call the pred() and succ()\n",
        "616": "     * methods, which perform null checks before returning the fields.\n",
        "617": "     */\n",
        "618": "    @CheckForNull private AvlNode<E> pred;\n",
        "619": "    @CheckForNull private AvlNode<E> succ;\n",
        "620": "\n",
        "621": "    AvlNode(@ParametricNullness E elem, int elemCount) {\n",
        "632": "    /** Constructor for the header node. */\n",
        "633": "    AvlNode() {\n",
        "634": "      this.elem = null;\n",
        "635": "      this.elemCount = 1;\n",
        "636": "    }\n",
        "637": "\n",
        "638": "    // For discussion of pred() and succ(), see the comment on the pred and succ fields.\n",
        "639": "\n",
        "640": "    private AvlNode<E> pred() {\n",
        "641": "      return requireNonNull(pred);\n",
        "642": "    }\n",
        "643": "\n",
        "644": "    private AvlNode<E> succ() {\n",
        "645": "      return requireNonNull(succ);\n",
        "646": "    }\n",
        "647": "\n",
        "648": "    int count(Comparator<? super E> comparator, @ParametricNullness E e) {\n",
        "649": "      int cmp = comparator.compare(e, getElement());\n",
        "659": "    private AvlNode<E> addRightChild(@ParametricNullness E e, int count) {\n",
        "661": "      successor(this, right, succ());\n",
        "668": "    private AvlNode<E> addLeftChild(@ParametricNullness E e, int count) {\n",
        "670": "      successor(pred(), left, this);\n",
        "677": "    AvlNode<E> add(\n",
        "678": "        Comparator<? super E> comparator, @ParametricNullness E e, int count, int[] result) {\n",
        "683": "      int cmp = comparator.compare(e, getElement());\n",
        "723": "    @CheckForNull\n",
        "724": "    AvlNode<E> remove(\n",
        "725": "        Comparator<? super E> comparator, @ParametricNullness E e, int count, int[] result) {\n",
        "726": "      int cmp = comparator.compare(e, getElement());\n",
        "776": "    @CheckForNull\n",
        "777": "    AvlNode<E> setCount(\n",
        "778": "        Comparator<? super E> comparator, @ParametricNullness E e, int count, int[] result) {\n",
        "779": "      int cmp = comparator.compare(e, getElement());\n",
        "826": "    @CheckForNull\n",
        "829": "        @ParametricNullness E e,\n",
        "833": "      int cmp = comparator.compare(e, getElement());\n",
        "890": "    @CheckForNull\n",
        "894": "      successor(pred(), succ());\n",
        "900": "        AvlNode<E> newTop = pred();\n",
        "908": "        AvlNode<E> newTop = succ();\n",
        "918": "    @CheckForNull\n",
        "931": "    @CheckForNull\n",
        "961": "          // requireNonNull is safe because right must exist in order to get a negative factor.\n",
        "962": "          requireNonNull(right);\n",
        "968": "          // requireNonNull is safe because left must exist in order to get a positive factor.\n",
        "969": "          requireNonNull(left);\n",
        "1008": "    private static long totalCount(@CheckForNull AvlNode<?> node) {\n",
        "1012": "    private static int height(@CheckForNull AvlNode<?> node) {\n",
        "1016": "    @CheckForNull\n",
        "1017": "    private AvlNode<E> ceiling(Comparator<? super E> comparator, @ParametricNullness E e) {\n",
        "1018": "      int cmp = comparator.compare(e, getElement());\n",
        "1028": "    @CheckForNull\n",
        "1029": "    private AvlNode<E> floor(Comparator<? super E> comparator, @ParametricNullness E e) {\n",
        "1030": "      int cmp = comparator.compare(e, getElement());\n",
        "1040": "    @ParametricNullness\n",
        "1042": "      // For discussion of this cast, see the comment on the elem field.\n",
        "1043": "      return uncheckedCastNullableTToT(elem);\n",
        "1056": "  private static <T extends @Nullable Object> void successor(AvlNode<T> a, AvlNode<T> b) {\n",
        "1061": "  private static <T extends @Nullable Object> void successor(\n",
        "1062": "      AvlNode<T> a, AvlNode<T> b, AvlNode<T> c) {\n",
        "1095": "    AvlNode<E> header = new AvlNode<>();\n"
    },
    "removed": {
        "23": "import static com.google.common.collect.CollectPreconditions.checkRemove;\n",
        "60": "public final class TreeMultiset<E> extends AbstractSortedMultiset<E> implements Serializable {\n",
        "90": "  public static <E> TreeMultiset<E> create(@Nullable Comparator<? super E> comparator) {\n",
        "125": "    this.header = new AvlNode<E>(null, 1);\n",
        "139": "      long treeAggregate(@Nullable AvlNode<?> root) {\n",
        "150": "      long treeAggregate(@Nullable AvlNode<?> root) {\n",
        "157": "    abstract long treeAggregate(@Nullable AvlNode<?> root);\n",
        "172": "  private long aggregateBelowRange(Aggregate aggr, @Nullable AvlNode<E> node) {\n",
        "176": "    int cmp = comparator().compare(range.getLowerEndpoint(), node.elem);\n",
        "195": "  private long aggregateAboveRange(Aggregate aggr, @Nullable AvlNode<E> node) {\n",
        "199": "    int cmp = comparator().compare(range.getUpperEndpoint(), node.elem);\n",
        "228": "  static int distinctElements(@Nullable AvlNode<?> node) {\n",
        "233": "  public int count(@Nullable Object element) {\n",
        "249": "  public int add(@Nullable E element, int occurrences) {\n",
        "271": "  public int remove(@Nullable Object element, int occurrences) {\n",
        "295": "  public int setCount(@Nullable E element, int count) {\n",
        "317": "  public boolean setCount(@Nullable E element, int oldCount, int newCount) {\n",
        "343": "      for (AvlNode<E> current = header.succ; current != header; ) {\n",
        "344": "        AvlNode<E> next = current.succ;\n",
        "383": "  private @Nullable AvlNode<E> firstNode() {\n",
        "390": "      E endpoint = range.getLowerEndpoint();\n",
        "391": "      node = rootReference.get().ceiling(comparator(), endpoint);\n",
        "397": "        node = node.succ;\n",
        "400": "      node = header.succ;\n",
        "405": "  private @Nullable AvlNode<E> lastNode() {\n",
        "412": "      E endpoint = range.getUpperEndpoint();\n",
        "413": "      node = rootReference.get().floor(comparator(), endpoint);\n",
        "419": "        node = node.pred;\n",
        "422": "      node = header.pred;\n",
        "435": "      AvlNode<E> current = firstNode();\n",
        "436": "      @Nullable Entry<E> prevEntry;\n",
        "455": "        Entry<E> result = wrapEntry(current);\n",
        "457": "        if (current.succ == header) {\n",
        "460": "          current = current.succ;\n",
        "467": "        checkRemove(prevEntry != null);\n",
        "477": "      AvlNode<E> current = lastNode();\n",
        "478": "      Entry<E> prevEntry = null;\n",
        "499": "        if (current.pred == header) {\n",
        "502": "          current = current.pred;\n",
        "509": "        checkRemove(prevEntry != null);\n",
        "521": "        node = node.succ) {\n",
        "532": "  public SortedMultiset<E> headMultiset(@Nullable E upperBound, BoundType boundType) {\n",
        "540": "  public SortedMultiset<E> tailMultiset(@Nullable E lowerBound, BoundType boundType) {\n",
        "548": "    private @Nullable T value;\n",
        "550": "    public @Nullable T get() {\n",
        "554": "    public void checkAndSet(@Nullable T expected, T newValue) {\n",
        "566": "  private static final class AvlNode<E> {\n",
        "567": "    private final @Nullable E elem;\n",
        "575": "    private @Nullable AvlNode<E> left;\n",
        "576": "    private @Nullable AvlNode<E> right;\n",
        "577": "    private @Nullable AvlNode<E> pred;\n",
        "578": "    private @Nullable AvlNode<E> succ;\n",
        "579": "\n",
        "580": "    AvlNode(@Nullable E elem, int elemCount) {\n",
        "591": "    public int count(Comparator<? super E> comparator, E e) {\n",
        "592": "      int cmp = comparator.compare(e, elem);\n",
        "602": "    private AvlNode<E> addRightChild(E e, int count) {\n",
        "604": "      successor(this, right, succ);\n",
        "611": "    private AvlNode<E> addLeftChild(E e, int count) {\n",
        "613": "      successor(pred, left, this);\n",
        "620": "    AvlNode<E> add(Comparator<? super E> comparator, @Nullable E e, int count, int[] result) {\n",
        "625": "      int cmp = comparator.compare(e, elem);\n",
        "665": "    AvlNode<E> remove(Comparator<? super E> comparator, @Nullable E e, int count, int[] result) {\n",
        "666": "      int cmp = comparator.compare(e, elem);\n",
        "716": "    AvlNode<E> setCount(Comparator<? super E> comparator, @Nullable E e, int count, int[] result) {\n",
        "717": "      int cmp = comparator.compare(e, elem);\n",
        "766": "        @Nullable E e,\n",
        "770": "      int cmp = comparator.compare(e, elem);\n",
        "830": "      successor(pred, succ);\n",
        "836": "        AvlNode<E> newTop = pred;\n",
        "844": "        AvlNode<E> newTop = succ;\n",
        "938": "    private static long totalCount(@Nullable AvlNode<?> node) {\n",
        "942": "    private static int height(@Nullable AvlNode<?> node) {\n",
        "946": "    private @Nullable AvlNode<E> ceiling(Comparator<? super E> comparator, E e) {\n",
        "947": "      int cmp = comparator.compare(e, elem);\n",
        "957": "    private @Nullable AvlNode<E> floor(Comparator<? super E> comparator, E e) {\n",
        "958": "      int cmp = comparator.compare(e, elem);\n",
        "969": "      return elem;\n",
        "982": "  private static <T> void successor(AvlNode<T> a, AvlNode<T> b) {\n",
        "987": "  private static <T> void successor(AvlNode<T> a, AvlNode<T> b, AvlNode<T> c) {\n",
        "1020": "    AvlNode<E> header = new AvlNode<E>(null, 1);\n"
    }
}