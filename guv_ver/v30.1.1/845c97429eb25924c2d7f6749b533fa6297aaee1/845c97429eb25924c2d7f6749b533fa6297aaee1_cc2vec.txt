{"id": "845c97429eb25924c2d7f6749b533fa6297aaee1", "code": [{"0": "android/guava-tests/test/com/google/common/graph/ValueGraphTest.java", "added": {"1": ["  @Test\n", "  public void incidentEdges_stableIncidentEdgeOrder_preservesIncidentEdgesOrder() {\n", "    graph = ValueGraphBuilder.directed().incidentEdgeOrder(ElementOrder.stable()).build();\n", "    graph.putEdgeValue(2, 1, \"2-1\");\n", "    graph.putEdgeValue(2, 3, \"2-3\");\n", "    graph.putEdgeValue(1, 2, \"1-2\");\n", "\n", "    assertThat(graph.incidentEdges(2))\n", "        .containsExactly(\n", "            EndpointPair.ordered(2, 1), EndpointPair.ordered(2, 3), EndpointPair.ordered(1, 2))\n", "        .inOrder();\n", "  }\n", "\n"]}, "removed": {}, "added_lines": {"1": [341, 342, 343, 344, 345, 346, 347, 348, 349, 350, 351, 352, 353]}, "removed_lines": {}}, {"1": "android/guava/src/com/google/common/graph/ValueGraphBuilder.java", "added": {"1": ["import static com.google.common.base.Preconditions.checkArgument;\n"], "2": ["    // TODO(b/142723300): Add incidentEdgeOrder\n"], "3": ["   * <p>Note that the returned builder will always have {@link #incidentEdgeOrder} set to {@link\n", "   * ElementOrder#stable()}, regardless of the value that was set in this builder.\n", "   *\n"], "4": ["  /**\n", "   * Specifies the order of iteration for the elements of {@link ValueGraph#edges()}, {@link\n", "   * ValueGraph#adjacentNodes(Object)}, {@link ValueGraph#predecessors(Object)}, {@link\n", "   * ValueGraph#successors(Object)} and {@link ValueGraph#incidentEdges(Object)}.\n", "   *\n", "   * <p>The default value is {@link ElementOrder#unordered() unordered} for mutable graphs. For\n", "   * immutable graphs, this value is ignored; they always have a {@link ElementOrder#stable()\n", "   * stable} order.\n", "   *\n", "   * @throws IllegalArgumentException if {@code incidentEdgeOrder} is not either {@code\n", "   *     ElementOrder.unordered()} or {@code ElementOrder.stable()}.\n", "   */\n", "  // TODO(b/142723300): Make this method public\n", "  <N1 extends N> ValueGraphBuilder<N1, V> incidentEdgeOrder(ElementOrder<N1> incidentEdgeOrder) {\n", "    checkArgument(\n", "        incidentEdgeOrder.type() == ElementOrder.Type.UNORDERED\n", "            || incidentEdgeOrder.type() == ElementOrder.Type.STABLE,\n", "        \"The given elementOrder (%s) is unsupported. incidentEdgeOrder() only supports\"\n", "            + \" ElementOrder.unordered() and ElementOrder.stable().\",\n", "        incidentEdgeOrder);\n", "    ValueGraphBuilder<N1, V> newBuilder = cast();\n", "    newBuilder.incidentEdgeOrder = checkNotNull(incidentEdgeOrder);\n", "    return newBuilder;\n", "  }\n"]}, "removed": {}, "added_lines": {"1": [19], "2": [98], "3": [107, 108, 109], "4": [150, 151, 152, 153, 154, 155, 156, 157, 158, 159, 160, 161, 162, 163, 164, 165, 166, 167, 168, 169, 170, 171, 172, 173]}, "removed_lines": {}}, {"2": "guava-tests/test/com/google/common/graph/ValueGraphTest.java", "added": {"1": ["  @Test\n", "  public void incidentEdges_stableIncidentEdgeOrder_preservesIncidentEdgesOrder() {\n", "    graph = ValueGraphBuilder.directed().incidentEdgeOrder(ElementOrder.stable()).build();\n", "    graph.putEdgeValue(2, 1, \"2-1\");\n", "    graph.putEdgeValue(2, 3, \"2-3\");\n", "    graph.putEdgeValue(1, 2, \"1-2\");\n", "\n", "    assertThat(graph.incidentEdges(2))\n", "        .containsExactly(\n", "            EndpointPair.ordered(2, 1), EndpointPair.ordered(2, 3), EndpointPair.ordered(1, 2))\n", "        .inOrder();\n", "  }\n", "\n"]}, "removed": {}, "added_lines": {"1": [401, 402, 403, 404, 405, 406, 407, 408, 409, 410, 411, 412, 413]}, "removed_lines": {}}, {"3": "guava/src/com/google/common/graph/ValueGraphBuilder.java", "added": {"1": ["import static com.google.common.base.Preconditions.checkArgument;\n"], "2": ["    // TODO(b/142723300): Add incidentEdgeOrder\n"], "3": ["   * <p>Note that the returned builder will always have {@link #incidentEdgeOrder} set to {@link\n", "   * ElementOrder#stable()}, regardless of the value that was set in this builder.\n", "   *\n"], "4": ["  /**\n", "   * Specifies the order of iteration for the elements of {@link ValueGraph#edges()}, {@link\n", "   * ValueGraph#adjacentNodes(Object)}, {@link ValueGraph#predecessors(Object)}, {@link\n", "   * ValueGraph#successors(Object)} and {@link ValueGraph#incidentEdges(Object)}.\n", "   *\n", "   * <p>The default value is {@link ElementOrder#unordered() unordered} for mutable graphs. For\n", "   * immutable graphs, this value is ignored; they always have a {@link ElementOrder#stable()\n", "   * stable} order.\n", "   *\n", "   * @throws IllegalArgumentException if {@code incidentEdgeOrder} is not either {@code\n", "   *     ElementOrder.unordered()} or {@code ElementOrder.stable()}.\n", "   */\n", "  // TODO(b/142723300): Make this method public\n", "  <N1 extends N> ValueGraphBuilder<N1, V> incidentEdgeOrder(ElementOrder<N1> incidentEdgeOrder) {\n", "    checkArgument(\n", "        incidentEdgeOrder.type() == ElementOrder.Type.UNORDERED\n", "            || incidentEdgeOrder.type() == ElementOrder.Type.STABLE,\n", "        \"The given elementOrder (%s) is unsupported. incidentEdgeOrder() only supports\"\n", "            + \" ElementOrder.unordered() and ElementOrder.stable().\",\n", "        incidentEdgeOrder);\n", "    ValueGraphBuilder<N1, V> newBuilder = cast();\n", "    newBuilder.incidentEdgeOrder = checkNotNull(incidentEdgeOrder);\n", "    return newBuilder;\n", "  }\n"]}, "removed": {}, "added_lines": {"1": [19], "2": [98], "3": [107, 108, 109], "4": [150, 151, 152, 153, 154, 155, 156, 157, 158, 159, 160, 161, 162, 163, 164, 165, 166, 167, 168, 169, 170, 171, 172, 173]}, "removed_lines": {}}]}
