[{"func":{"oldfunccode":"786c3d84f11482451217a9fd76b886a0d2a8afe3/Codes_neg/Match_oldfunccode_786c3d84f11482451217a9fd76b886a0d2a8afe3_1.txt","newfunccode":"786c3d84f11482451217a9fd76b886a0d2a8afe3/Codes_neg/Match_newfunccode_786c3d84f11482451217a9fd76b886a0d2a8afe3_1.txt","newdoc":" Calculate the quotients and remainders in the integer division x = k * (N - 1) / q, i.e.\n index * (dataset.length - 1) / scale for each index in indexes. For each, if there is no\n remainder, we can just select the value whose index in the sorted dataset equals the\n quotient; if there is a remainder, we interpolate between that and the next value.\n The indexes to select. In the worst case, we'll need one each side of each quantile.\n Since index and (dataset.length - 1) are non-negative ints, their product can be\n Since scale is a positive int, index is in [0, scale], and (dataset.length - 1) is a\n non-negative int, we can do long-arithmetic on index * (dataset.length - 1) / scale to\n get a rounded ratio and a remainder which can be expressed as ints, without risk of\n expressed as a long, without risk of overflow:\n overflow:\n","newJdoc":"786c3d84f11482451217a9fd76b886a0d2a8afe3/Codes_neg/Match_newfuncnewJdoc_786c3d84f11482451217a9fd76b886a0d2a8afe3_1.txt","olddoc":" Calculate the quotients and remainders in the integer division x = k * (N - 1) / q, i.e.\n index * (dataset.length - 1) / scale for each index in indexes. For each, if there is no\n remainder, we can just select the value whose index in the sorted dataset equals the\n quotient; if there is a remainder, we interpolate between that and the next value.\n The indexes to select. In the worst case, we'll need one each side of each quantile.\n Since index and (dataset.length - 1) are non-negative ints, their product can be\n Since scale is a positive int, index is in [0, scale], and (dataset.length - 1) is a\n non-negative int, we can do long-arithmetic on index * (dataset.length - 1) / scale to\n get a rounded ratio and a remainder which can be expressed as ints, without risk of\n expressed as a long, without risk of overflow:\n overflow:\n","oldJdoc":"786c3d84f11482451217a9fd76b886a0d2a8afe3/Codes_neg/Match_oldfuncoldJdoc_786c3d84f11482451217a9fd76b886a0d2a8afe3_1.txt","path":"/home/pritish/Documents/IP work/guv_ver/v30.1.1/786c3d84f11482451217a9fd76b886a0d2a8afe3/Quantiles","pathinproj":"android/guava/src/com/google/common/math/Quantiles.java","addlines":[438,399],"dellines":[389,428],"addcode":["        Map<Integer, Double> nanMap = new LinkedHashMap<>();\n","      Map<Integer, Double> ret = new LinkedHashMap<>();\n","        Map<Integer, Double> nanMap = new LinkedHashMap<>();\n","      Map<Integer, Double> ret = new LinkedHashMap<>();\n"],"delcode":["        Map<Integer, Double> nanMap = new HashMap<>();\n","      Map<Integer, Double> ret = new HashMap<>();\n","        Map<Integer, Double> nanMap = new HashMap<>();\n","      Map<Integer, Double> ret = new HashMap<>();\n"],"methodSig":"public Map<Integer, Double> computeInPlace(double... dataset)"},"doc":{"oldfunccode":"786c3d84f11482451217a9fd76b886a0d2a8afe3/Codes_neg/Match_olddocfunccode_786c3d84f11482451217a9fd76b886a0d2a8afe3_1.txt","newfunccode":"786c3d84f11482451217a9fd76b886a0d2a8afe3/Codes_neg/Match_newdocfunccode_786c3d84f11482451217a9fd76b886a0d2a8afe3_1.txt","newdoc":"","newJdoc":"786c3d84f11482451217a9fd76b886a0d2a8afe3/Codes_neg/Match_newdocnewJdoc_786c3d84f11482451217a9fd76b886a0d2a8afe3_1.txt","olddoc":"","oldJdoc":"786c3d84f11482451217a9fd76b886a0d2a8afe3/Codes_neg/Match_olddocJdoc_786c3d84f11482451217a9fd76b886a0d2a8afe3_1.txt","path":"/home/pritish/Documents/IP work/guv_ver/v30.1.1/786c3d84f11482451217a9fd76b886a0d2a8afe3/Quantiles","pathinproj":"android/guava/src/com/google/common/math/Quantiles.java","addlines":[377,378,379,380],"dellines":[371,372],"addcode":["     * @return an unmodifiable, ordered map of results: the keys will be the specified quantile\n","     *     indexes, and the values the corresponding quantile values. When iterating, entries in the\n","     *     map are ordered by quantile index in the same order they were passed to the {@code\n","     *     indexes} method.\n","     * @return an unmodifiable, ordered map of results: the keys will be the specified quantile\n","     *     indexes, and the values the corresponding quantile values. When iterating, entries in the\n","     *     map are ordered by quantile index in the same order they were passed to the {@code\n","     *     indexes} method.\n"],"delcode":["     * @return an unmodifiable map of results: the keys will be the specified quantile indexes, and\n","     *     the values the corresponding quantile values\n","     * @return an unmodifiable map of results: the keys will be the specified quantile indexes, and\n","     *     the values the corresponding quantile values\n"],"methodSig":"public Map<Integer, Double> compute(int... dataset)"},"id":1,"flag":1,"commit":"786c3d84f11482451217a9fd76b886a0d2a8afe3"},{"func":{"oldfunccode":"786c3d84f11482451217a9fd76b886a0d2a8afe3/Codes_neg/Match_oldfunccode_786c3d84f11482451217a9fd76b886a0d2a8afe3_2.txt","newfunccode":"786c3d84f11482451217a9fd76b886a0d2a8afe3/Codes_neg/Match_newfunccode_786c3d84f11482451217a9fd76b886a0d2a8afe3_2.txt","newdoc":" Calculate the quotients and remainders in the integer division x = k * (N - 1) / q, i.e.\n index * (dataset.length - 1) / scale for each index in indexes. For each, if there is no\n remainder, we can just select the value whose index in the sorted dataset equals the\n quotient; if there is a remainder, we interpolate between that and the next value.\n The indexes to select. In the worst case, we'll need one each side of each quantile.\n Since index and (dataset.length - 1) are non-negative ints, their product can be\n Since scale is a positive int, index is in [0, scale], and (dataset.length - 1) is a\n non-negative int, we can do long-arithmetic on index * (dataset.length - 1) / scale to\n get a rounded ratio and a remainder which can be expressed as ints, without risk of\n expressed as a long, without risk of overflow:\n overflow:\n Calculate the quotients and remainders in the integer division x = k * (N - 1) / q, i.e.\n index * (dataset.length - 1) / scale for each index in indexes. For each, if there is no\n remainder, we can just select the value whose index in the sorted dataset equals the\n quotient; if there is a remainder, we interpolate between that and the next value.\n The indexes to select. In the worst case, we'll need one each side of each quantile.\n Since index and (dataset.length - 1) are non-negative ints, their product can be\n Since scale is a positive int, index is in [0, scale], and (dataset.length - 1) is a\n non-negative int, we can do long-arithmetic on index * (dataset.length - 1) / scale to\n get a rounded ratio and a remainder which can be expressed as ints, without risk of\n expressed as a long, without risk of overflow:\n overflow:\n","newJdoc":"786c3d84f11482451217a9fd76b886a0d2a8afe3/Codes_neg/Match_newfuncnewJdoc_786c3d84f11482451217a9fd76b886a0d2a8afe3_2.txt","olddoc":" Calculate the quotients and remainders in the integer division x = k * (N - 1) / q, i.e.\n index * (dataset.length - 1) / scale for each index in indexes. For each, if there is no\n remainder, we can just select the value whose index in the sorted dataset equals the\n quotient; if there is a remainder, we interpolate between that and the next value.\n The indexes to select. In the worst case, we'll need one each side of each quantile.\n Since index and (dataset.length - 1) are non-negative ints, their product can be\n Since scale is a positive int, index is in [0, scale], and (dataset.length - 1) is a\n non-negative int, we can do long-arithmetic on index * (dataset.length - 1) / scale to\n get a rounded ratio and a remainder which can be expressed as ints, without risk of\n expressed as a long, without risk of overflow:\n overflow:\n Calculate the quotients and remainders in the integer division x = k * (N - 1) / q, i.e.\n index * (dataset.length - 1) / scale for each index in indexes. For each, if there is no\n remainder, we can just select the value whose index in the sorted dataset equals the\n quotient; if there is a remainder, we interpolate between that and the next value.\n The indexes to select. In the worst case, we'll need one each side of each quantile.\n Since index and (dataset.length - 1) are non-negative ints, their product can be\n Since scale is a positive int, index is in [0, scale], and (dataset.length - 1) is a\n non-negative int, we can do long-arithmetic on index * (dataset.length - 1) / scale to\n get a rounded ratio and a remainder which can be expressed as ints, without risk of\n expressed as a long, without risk of overflow:\n overflow:\n","oldJdoc":"786c3d84f11482451217a9fd76b886a0d2a8afe3/Codes_neg/Match_oldfuncoldJdoc_786c3d84f11482451217a9fd76b886a0d2a8afe3_2.txt","path":"/home/pritish/Documents/IP work/guv_ver/v30.1.1/786c3d84f11482451217a9fd76b886a0d2a8afe3/Quantiles","pathinproj":"android/guava/src/com/google/common/math/Quantiles.java","addlines":[438,399],"dellines":[389,428],"addcode":["        Map<Integer, Double> nanMap = new LinkedHashMap<>();\n","      Map<Integer, Double> ret = new LinkedHashMap<>();\n","        Map<Integer, Double> nanMap = new LinkedHashMap<>();\n","      Map<Integer, Double> ret = new LinkedHashMap<>();\n"],"delcode":["        Map<Integer, Double> nanMap = new HashMap<>();\n","      Map<Integer, Double> ret = new HashMap<>();\n","        Map<Integer, Double> nanMap = new HashMap<>();\n","      Map<Integer, Double> ret = new HashMap<>();\n"],"methodSig":"public Map<Integer, Double> computeInPlace(double... dataset)"},"doc":{"oldfunccode":"786c3d84f11482451217a9fd76b886a0d2a8afe3/Codes_neg/Match_olddocfunccode_786c3d84f11482451217a9fd76b886a0d2a8afe3_2.txt","newfunccode":"786c3d84f11482451217a9fd76b886a0d2a8afe3/Codes_neg/Match_newdocfunccode_786c3d84f11482451217a9fd76b886a0d2a8afe3_2.txt","newdoc":"","newJdoc":"786c3d84f11482451217a9fd76b886a0d2a8afe3/Codes_neg/Match_newdocnewJdoc_786c3d84f11482451217a9fd76b886a0d2a8afe3_2.txt","olddoc":"","oldJdoc":"786c3d84f11482451217a9fd76b886a0d2a8afe3/Codes_neg/Match_olddocJdoc_786c3d84f11482451217a9fd76b886a0d2a8afe3_2.txt","path":"/home/pritish/Documents/IP work/guv_ver/v30.1.1/786c3d84f11482451217a9fd76b886a0d2a8afe3/Quantiles","pathinproj":"android/guava/src/com/google/common/math/Quantiles.java","addlines":[348,349,350,351],"dellines":[346,347],"addcode":["     * @return an unmodifiable, ordered map of results: the keys will be the specified quantile\n","     *     indexes, and the values the corresponding quantile values. When iterating, entries in the\n","     *     map are ordered by quantile index in the same order they were passed to the {@code\n","     *     indexes} method.\n","     * @return an unmodifiable, ordered map of results: the keys will be the specified quantile\n","     *     indexes, and the values the corresponding quantile values. When iterating, entries in the\n","     *     map are ordered by quantile index in the same order they were passed to the {@code\n","     *     indexes} method.\n"],"delcode":["     * @return an unmodifiable map of results: the keys will be the specified quantile indexes, and\n","     *     the values the corresponding quantile values\n","     * @return an unmodifiable map of results: the keys will be the specified quantile indexes, and\n","     *     the values the corresponding quantile values\n"],"methodSig":"public Map<Integer, Double> compute(double... dataset)"},"id":1,"flag":1,"commit":"786c3d84f11482451217a9fd76b886a0d2a8afe3"}]