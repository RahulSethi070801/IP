{
    "addition": {
        "31": "import com.google.common.base.Function;\n",
        "259": "            ? LocalCache.<RemovalNotification<K, V>>discardingQueue()\n",
        "260": "            : new ConcurrentLinkedQueue<RemovalNotification<K, V>>();\n",
        "664": "     * Returns true if a new value is currently loading, regardless of whether or not there is an\n",
        "665": "     * existing value. It is assumed that the return value of this method is constant for any given\n",
        "1743": "   * loading, or expired. Unlike {@link Segment#getLiveValue} this method does not attempt to\n",
        "1744": "   * cleanup stale entries. As such it should only be called outside of a segment context, such as\n",
        "1745": "   * during iteration.\n",
        "1949": "      keyReferenceQueue = map.usesKeyReferences() ? new ReferenceQueue<K>() : null;\n",
        "1951": "      valueReferenceQueue = map.usesValueReferences() ? new ReferenceQueue<V>() : null;\n",
        "1954": "          map.usesAccessQueue()\n",
        "1955": "              ? new ConcurrentLinkedQueue<ReferenceEntry<K, V>>()\n",
        "1956": "              : LocalCache.<ReferenceEntry<K, V>>discardingQueue();\n",
        "1958": "      writeQueue =\n",
        "1959": "          map.usesWriteQueue()\n",
        "1960": "              ? new WriteQueue<K, V>()\n",
        "1961": "              : LocalCache.<ReferenceEntry<K, V>>discardingQueue();\n",
        "1963": "      accessQueue =\n",
        "1964": "          map.usesAccessQueue()\n",
        "1965": "              ? new AccessQueue<K, V>()\n",
        "1966": "              : LocalCache.<ReferenceEntry<K, V>>discardingQueue();\n",
        "2211": "          new Runnable() {\n",
        "2212": "            @Override\n",
        "2213": "            public void run() {\n",
        "2214": "              try {\n",
        "2215": "                getAndRecordStats(key, hash, loadingValueReference, loadingFuture);\n",
        "2216": "              } catch (Throwable t) {\n",
        "2217": "                logger.log(Level.WARNING, \"Exception thrown during refresh\", t);\n",
        "2218": "                loadingValueReference.setException(t);\n",
        "2219": "              }\n",
        "2485": "        // all of the segment's entries.\n",
        "3269": "        if (!isHeldByCurrentThread()) { // don't cleanup inside of put\n",
        "3462": "            new Function<V, V>() {\n",
        "3463": "              @Override\n",
        "3464": "              public V apply(V newValue) {\n",
        "3465": "                LoadingValueReference.this.set(newValue);\n",
        "3466": "                return newValue;\n",
        "3467": "              }\n",
        "3810": "    for (int i = 0; i < segments.length; ++i) {\n",
        "3811": "      if (segments[i].count != 0) {\n",
        "3814": "      sum += segments[i].modCount;\n",
        "3818": "      for (int i = 0; i < segments.length; ++i) {\n",
        "3819": "        if (segments[i].count != 0) {\n",
        "3822": "        sum -= segments[i].modCount;\n",
        "3832": "    for (int i = 0; i < segments.length; ++i) {\n",
        "3833": "      sum += Math.max(0, segments[i].count); // see https://github.com/google/guava/issues/2108\n",
        "4401": "    ArrayList<E> result = new ArrayList<E>(c.size());\n",
        "4657": "    public final V apply(K key) {\n",
        "4675": "      this(new LocalCache<K, V>(builder, null));\n",
        "4773": "      super(new LocalCache<K, V>(builder, checkNotNull(loader)));\n"
    },
    "removed": {
        "258": "            ? LocalCache.discardingQueue()\n",
        "259": "            : new ConcurrentLinkedQueue<>();\n",
        "663": "     * Returns true if a new value is currently loading, regardless of whether there is an existing\n",
        "664": "     * value. It is assumed that the return value of this method is constant for any given\n",
        "1742": "   * loading, or expired. Unlike {@link Segment#getLiveValue} this method does not attempt to clean\n",
        "1743": "   * up stale entries. As such it should only be called outside a segment context, such as during\n",
        "1744": "   * iteration.\n",
        "1948": "      keyReferenceQueue = map.usesKeyReferences() ? new ReferenceQueue<>() : null;\n",
        "1950": "      valueReferenceQueue = map.usesValueReferences() ? new ReferenceQueue<>() : null;\n",
        "1953": "          map.usesAccessQueue() ? new ConcurrentLinkedQueue<>() : LocalCache.discardingQueue();\n",
        "1955": "      writeQueue = map.usesWriteQueue() ? new WriteQueue<>() : LocalCache.discardingQueue();\n",
        "1957": "      accessQueue = map.usesAccessQueue() ? new AccessQueue<>() : LocalCache.discardingQueue();\n",
        "2202": "          () -> {\n",
        "2203": "            try {\n",
        "2204": "              getAndRecordStats(key, hash, loadingValueReference, loadingFuture);\n",
        "2205": "            } catch (Throwable t) {\n",
        "2206": "              logger.log(Level.WARNING, \"Exception thrown during refresh\", t);\n",
        "2207": "              loadingValueReference.setException(t);\n",
        "2473": "        // all the segment's entries.\n",
        "3257": "        if (!isHeldByCurrentThread()) { // don't clean up inside of put\n",
        "3450": "            newResult -> {\n",
        "3451": "              LoadingValueReference.this.set(newResult);\n",
        "3452": "              return newResult;\n",
        "3795": "    for (Segment<K, V> segment : segments) {\n",
        "3796": "      if (segment.count != 0) {\n",
        "3799": "      sum += segment.modCount;\n",
        "3803": "      for (Segment<K, V> segment : segments) {\n",
        "3804": "        if (segment.count != 0) {\n",
        "3807": "        sum -= segment.modCount;\n",
        "3817": "    for (Segment<K, V> segment : segments) {\n",
        "3818": "      sum += Math.max(0, segment.count); // see https://github.com/google/guava/issues/2108\n",
        "4386": "    ArrayList<E> result = new ArrayList<>(c.size());\n",
        "4642": "    public V apply(K key) {\n",
        "4660": "      this(new LocalCache<>(builder, null));\n",
        "4758": "      super(new LocalCache<>(builder, checkNotNull(loader)));\n"
    }
}