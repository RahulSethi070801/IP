[{"func":{"oldfunccode":"","newfunccode":"e1ec6968a7d584281f56a38674d6722bea83811c/Codes_neg/Match_newfunccode_e1ec6968a7d584281f56a38674d6722bea83811c_1.txt","newdoc":" Add target first; it must be last in the chain because its entry hasn't yet been created\n Loop over current hashtable\n Rebuild hash using entry hashPrefix and tableIndex (\"hashSuffix\")\n","newJdoc":"","olddoc":"","oldJdoc":"","path":"/home/pritish/Documents/IP work/guv_ver/v30.1.1/e1ec6968a7d584281f56a38674d6722bea83811c/CompactHashSet_2","pathinproj":"guava/src/com/google/common/collect/CompactHashSet.java","addlines":[449,450,387,453,454,392,457,458,459,396,460,461,397,462,398,463,399,400,464,401,402,466,403,404,469,470,407,473,410,411,414,432,436,441,445,383],"dellines":[],"addcode":["  private int resizeTable(int oldMask, int newCapacity, int targetHash, int targetEntryIndex) {\n","    Object oldTable = requireTable();\n","    for (int oldTableIndex = 0; oldTableIndex <= oldMask; oldTableIndex++) {\n","      int oldNext = CompactHashing.tableGet(oldTable, oldTableIndex);\n","      while (oldNext != UNSET) {\n","        int entryIndex = oldNext - 1;\n","        int oldEntry = entries[entryIndex];\n","        int hash = CompactHashing.getHashPrefix(oldEntry, oldMask) | oldTableIndex;\n","        CompactHashing.tableSet(newTable, newTableIndex, oldNext);\n","        oldNext = CompactHashing.getNext(oldEntry, oldMask);\n","  private int resizeTable(int oldMask, int newCapacity, int targetHash, int targetEntryIndex) {\n","    Object oldTable = requireTable();\n","    for (int oldTableIndex = 0; oldTableIndex <= oldMask; oldTableIndex++) {\n","      int oldNext = CompactHashing.tableGet(oldTable, oldTableIndex);\n","      while (oldNext != UNSET) {\n","        int entryIndex = oldNext - 1;\n","        int oldEntry = entries[entryIndex];\n","\n","        int hash = CompactHashing.getHashPrefix(oldEntry, oldMask) | oldTableIndex;\n","        CompactHashing.tableSet(newTable, newTableIndex, oldNext);\n","        oldNext = CompactHashing.getNext(oldEntry, oldMask);\n","  private int resizeTable(int oldMask, int newCapacity, int targetHash, int targetEntryIndex) {\n","    Object oldTable = requireTable();\n","    for (int oldTableIndex = 0; oldTableIndex <= oldMask; oldTableIndex++) {\n","      int oldNext = CompactHashing.tableGet(oldTable, oldTableIndex);\n","      while (oldNext != UNSET) {\n","        int entryIndex = oldNext - 1;\n","        int oldEntry = entries[entryIndex];\n","        int hash = CompactHashing.getHashPrefix(oldEntry, oldMask) | oldTableIndex;\n","        CompactHashing.tableSet(newTable, newTableIndex, oldNext);\n","        oldNext = CompactHashing.getNext(oldEntry, oldMask);\n","  private int resizeTable(int oldMask, int newCapacity, int targetHash, int targetEntryIndex) {\n","    Object oldTable = requireTable();\n","    for (int oldTableIndex = 0; oldTableIndex <= oldMask; oldTableIndex++) {\n","      int oldNext = CompactHashing.tableGet(oldTable, oldTableIndex);\n","      while (oldNext != UNSET) {\n","        int entryIndex = oldNext - 1;\n","        int oldEntry = entries[entryIndex];\n","\n","        int hash = CompactHashing.getHashPrefix(oldEntry, oldMask) | oldTableIndex;\n","        CompactHashing.tableSet(newTable, newTableIndex, oldNext);\n","        oldNext = CompactHashing.getNext(oldEntry, oldMask);\n"],"delcode":[],"methodSig":"private int resizeTable(int oldMask, int newCapacity, int targetHash, int targetEntryIndex)"},"doc":{"oldfunccode":"e1ec6968a7d584281f56a38674d6722bea83811c/Codes_neg/Match_olddocfunccode_e1ec6968a7d584281f56a38674d6722bea83811c_1.txt","newfunccode":"e1ec6968a7d584281f56a38674d6722bea83811c/Codes_neg/Match_newdocfunccode_e1ec6968a7d584281f56a38674d6722bea83811c_1.txt","newdoc":" unsigned read\n unsigned read\n","newJdoc":"e1ec6968a7d584281f56a38674d6722bea83811c/Codes_neg/Match_newdocnewJdoc_e1ec6968a7d584281f56a38674d6722bea83811c_1.txt","olddoc":" unsigned read\n unsigned read\n","oldJdoc":"","path":"/home/pritish/Documents/IP work/guv_ver/v30.1.1/e1ec6968a7d584281f56a38674d6722bea83811c/CompactHashing","pathinproj":"android/guava/src/com/google/common/collect/CompactHashing.java","addlines":[101,102,103,104,105],"dellines":[],"addcode":["  /**\n","   * Returns {@code table[index]}, where {@code table} is actually a {@code byte[]}, {@code\n","   * short[]}, or {@code int[]}. When it is a {@code byte[]} or {@code short[]}, the returned value\n","   * is unsigned, so the range of possible returned values is 0–255 or 0–65535, respectively.\n","   */\n","  /**\n","   * Returns {@code table[index]}, where {@code table} is actually a {@code byte[]}, {@code\n","   * short[]}, or {@code int[]}. When it is a {@code byte[]} or {@code short[]}, the returned value\n","   * is unsigned, so the range of possible returned values is 0–255 or 0–65535, respectively.\n","   */\n"],"delcode":[],"methodSig":" static int tableGet(Object table, int index)"},"id":1,"flag":1,"commit":"e1ec6968a7d584281f56a38674d6722bea83811c"},{"func":{"oldfunccode":"e1ec6968a7d584281f56a38674d6722bea83811c/Codes_neg/Match_oldfunccode_e1ec6968a7d584281f56a38674d6722bea83811c_2.txt","newfunccode":"","newdoc":"","newJdoc":"","olddoc":" Add target first; it must be last in the chain because its entry hasn't yet been created\n Loop over current hashtable\n Rebuild hash using entry hashPrefix and tableIndex (\"hashSuffix\")\n","oldJdoc":"","path":"/home/pritish/Documents/IP work/guv_ver/v30.1.1/e1ec6968a7d584281f56a38674d6722bea83811c/CompactHashSet_2","pathinproj":"guava/src/com/google/common/collect/CompactHashSet.java","addlines":[],"dellines":[386,388,390,392,393,394,395,396,397,398,399,400,401,402,403,404,405,406,407,408,410,413,414,417,379,383],"addcode":[],"delcode":["  private int resizeTable(int mask, int newCapacity, int targetHash, int targetEntryIndex) {\n","    Object table = requireTable();\n","    for (int tableIndex = 0; tableIndex <= mask; tableIndex++) {\n","      int next = CompactHashing.tableGet(table, tableIndex);\n","      while (next != UNSET) {\n","        int entryIndex = next - 1;\n","        int entry = entries[entryIndex];\n","        int hash = CompactHashing.getHashPrefix(entry, mask) | tableIndex;\n","        CompactHashing.tableSet(newTable, newTableIndex, next);\n","        next = CompactHashing.getNext(entry, mask);\n","  private int resizeTable(int mask, int newCapacity, int targetHash, int targetEntryIndex) {\n","    Object table = requireTable();\n","    for (int tableIndex = 0; tableIndex <= mask; tableIndex++) {\n","      int next = CompactHashing.tableGet(table, tableIndex);\n","      while (next != UNSET) {\n","        int entryIndex = next - 1;\n","        int entry = entries[entryIndex];\n","\n","        int hash = CompactHashing.getHashPrefix(entry, mask) | tableIndex;\n","        CompactHashing.tableSet(newTable, newTableIndex, next);\n","        next = CompactHashing.getNext(entry, mask);\n","  private int resizeTable(int mask, int newCapacity, int targetHash, int targetEntryIndex) {\n","    Object table = requireTable();\n","    for (int tableIndex = 0; tableIndex <= mask; tableIndex++) {\n","      int next = CompactHashing.tableGet(table, tableIndex);\n","      while (next != UNSET) {\n","        int entryIndex = next - 1;\n","        int entry = entries[entryIndex];\n","        int hash = CompactHashing.getHashPrefix(entry, mask) | tableIndex;\n","        CompactHashing.tableSet(newTable, newTableIndex, next);\n","        next = CompactHashing.getNext(entry, mask);\n","  private int resizeTable(int mask, int newCapacity, int targetHash, int targetEntryIndex) {\n","    Object table = requireTable();\n","    for (int tableIndex = 0; tableIndex <= mask; tableIndex++) {\n","      int next = CompactHashing.tableGet(table, tableIndex);\n","      while (next != UNSET) {\n","        int entryIndex = next - 1;\n","        int entry = entries[entryIndex];\n","\n","        int hash = CompactHashing.getHashPrefix(entry, mask) | tableIndex;\n","        CompactHashing.tableSet(newTable, newTableIndex, next);\n","        next = CompactHashing.getNext(entry, mask);\n"],"methodSig":"private int resizeTable(int mask, int newCapacity, int targetHash, int targetEntryIndex)"},"doc":{"oldfunccode":"e1ec6968a7d584281f56a38674d6722bea83811c/Codes_neg/Match_olddocfunccode_e1ec6968a7d584281f56a38674d6722bea83811c_2.txt","newfunccode":"e1ec6968a7d584281f56a38674d6722bea83811c/Codes_neg/Match_newdocfunccode_e1ec6968a7d584281f56a38674d6722bea83811c_2.txt","newdoc":" unsigned read\n unsigned read\n unsigned read\n unsigned read\n","newJdoc":"e1ec6968a7d584281f56a38674d6722bea83811c/Codes_neg/Match_newdocnewJdoc_e1ec6968a7d584281f56a38674d6722bea83811c_2.txt","olddoc":" unsigned read\n unsigned read\n unsigned read\n unsigned read\n","oldJdoc":"","path":"/home/pritish/Documents/IP work/guv_ver/v30.1.1/e1ec6968a7d584281f56a38674d6722bea83811c/CompactHashing","pathinproj":"android/guava/src/com/google/common/collect/CompactHashing.java","addlines":[101,102,103,104,105],"dellines":[],"addcode":["  /**\n","   * Returns {@code table[index]}, where {@code table} is actually a {@code byte[]}, {@code\n","   * short[]}, or {@code int[]}. When it is a {@code byte[]} or {@code short[]}, the returned value\n","   * is unsigned, so the range of possible returned values is 0–255 or 0–65535, respectively.\n","   */\n","  /**\n","   * Returns {@code table[index]}, where {@code table} is actually a {@code byte[]}, {@code\n","   * short[]}, or {@code int[]}. When it is a {@code byte[]} or {@code short[]}, the returned value\n","   * is unsigned, so the range of possible returned values is 0–255 or 0–65535, respectively.\n","   */\n"],"delcode":[],"methodSig":" static int tableGet(Object table, int index)"},"id":1,"flag":1,"commit":"e1ec6968a7d584281f56a38674d6722bea83811c"}]