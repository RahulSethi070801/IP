{"id": "e1ec6968a7d584281f56a38674d6722bea83811c", "code": [{"0": "android/guava/src/com/google/common/collect/CompactHashMap.java", "added": {"1": ["  // The way the `table`, `entries`, `keys`, and `values` arrays work together is as follows.\n", "  //\n", "  // The `table` array always has a size that is a power of 2. The hashcode of a key in the map\n", "  // is masked in order to correspond to the current table size. For example, if the table size\n", "  // is 128 then the mask is 127 == 0x7f, keeping the bottom 7 bits of the hash value.\n", "  // If a key hashes to 0x89abcdef the mask reduces it to 0x89abcdef & 0x7f == 0x6f. We'll call this\n", "  // the \"short hash\".\n", "  //\n", "  // The `keys`, `values`, and `entries` arrays always have the same size as each other. They can be\n", "  // seen as fields of an imaginary `Entry` object like this:\n", "  //\n", "  // class Entry {\n", "  //    int hash;\n", "  //    Entry next;\n", "  //    K key;\n", "  //    V value;\n", "  // }\n", "  //\n", "  // The imaginary `hash` and `next` values are combined into a single `int` value in the `entries`\n", "  // array. The top bits of this value are the remaining bits of the hash value that were not used\n", "  // in the short hash. We saw that a mask of 0x7f would keep the 7-bit value 0x6f from a full\n", "  // hashcode of 0x89abcdef. The imaginary `hash` value would then be the remaining top 25 bits,\n", "  // 0x89abcd80. To this is added (or'd) the `next` value, which is an index within `entries`\n", "  // (and therefore within `keys` and `values`) of another entry that has the same short hash\n", "  // value. In our example, it would be another entry for a key whose short hash is also 0x6f.\n", "  //\n", "  // Essentially, then, `table[h]` gives us the start of a linked list in `entries`, where every\n", "  // element of the list has the short hash value h.\n", "  //\n", "  // A wrinkle here is that the value 0 (called UNSET in the code) is used as the equivalent of a\n", "  // null pointer. If `table[h] == 0` that means there are no keys in the map whose short hash is h.\n", "  // If the `next` bits in `entries[i]` are 0 that means there are no further entries for the given\n", "  // short hash. But 0 is also a valid index in `entries`, so we add 1 to these indices before\n", "  // putting them in `table` or in `next` bits, and subtract 1 again when we need an index value.\n", "  //\n", "  // The elements of `keys`, `values`, and `entries` are added sequentially, so that elements 0 to\n", "  // `size() - 1` are used and remaining elements are not. This makes iteration straightforward.\n", "  // Removing an entry generally involves moving the last element of each array to where the removed\n", "  // entry was, and adjusting index links accordingly.\n", "\n"], "2": ["   * mask  = 00000fff\n", "   * next  = 00000bbb\n", "   * entry = aaaaabbb\n"], "3": ["   *\n", "   * <p>For a new instance, where the arrays above have not yet been allocated, the value of {@code\n", "   * metadata} is the size that the arrays should be allocated with. Once the arrays have been\n", "   * allocated, the value of {@code metadata} combines the number of bits in the \"short hash\", in\n", "   * its bottom {@value CompactHashing#HASH_TABLE_BITS_MAX_BITS} bits, with a modification count in\n", "   * the remaining bits that is used to detect concurrent modification during iteration.\n"], "4": ["  private int resizeTable(int oldMask, int newCapacity, int targetHash, int targetEntryIndex) {\n"], "5": ["    Object oldTable = requireTable();\n", "    // Loop over `oldTable` to construct its replacement, ``newTable`. The entries do not move, so\n", "    // the `keys` and `values` arrays do not need to change. But because the \"short hash\" now has a\n", "    // different number of bits, we must rewrite each element of `entries` so that its contribution\n", "    // to the full hashcode reflects the change, and so that its `next` link corresponds to the new\n", "    // linked list of entries with the new short hash.\n", "    for (int oldTableIndex = 0; oldTableIndex <= oldMask; oldTableIndex++) {\n", "      int oldNext = CompactHashing.tableGet(oldTable, oldTableIndex);\n", "      // Each element of `oldTable` is the head of a (possibly empty) linked list of elements in\n", "      // `entries`. The `oldNext` loop is going to traverse that linked list.\n", "      // We need to rewrite the `next` link of each of the elements so that it is in the appropriate\n", "      // linked list starting from `newTable`. In general, each element from the old linked list\n", "      // belongs to a different linked list from `newTable`. We insert each element in turn at the\n", "      // head of its appropriate `newTable` linked list.\n", "      while (oldNext != UNSET) {\n", "        int entryIndex = oldNext - 1;\n", "        int oldEntry = entries[entryIndex];\n", "\n", "        // Rebuild the full 32-bit hash using entry hashPrefix and oldTableIndex (\"hashSuffix\").\n", "        int hash = CompactHashing.getHashPrefix(oldEntry, oldMask) | oldTableIndex;\n", "        CompactHashing.tableSet(newTable, newTableIndex, oldNext);\n", "        oldNext = CompactHashing.getNext(oldEntry, oldMask);\n"]}, "removed": {"2": ["   * mask  = 0000ffff\n", "   * next  = 0000bbbb\n", "   * entry = aaaabbbb\n"], "4": ["  private int resizeTable(int mask, int newCapacity, int targetHash, int targetEntryIndex) {\n"], "5": ["    Object table = requireTable();\n", "    // Loop over current hashtable\n", "    for (int tableIndex = 0; tableIndex <= mask; tableIndex++) {\n", "      int next = CompactHashing.tableGet(table, tableIndex);\n", "      while (next != UNSET) {\n", "        int entryIndex = next - 1;\n", "        int entry = entries[entryIndex];\n", "\n", "        // Rebuild hash using entry hashPrefix and tableIndex (\"hashSuffix\")\n", "        int hash = CompactHashing.getHashPrefix(entry, mask) | tableIndex;\n", "        CompactHashing.tableSet(newTable, newTableIndex, next);\n", "        next = CompactHashing.getNext(entry, mask);\n"]}, "added_lines": {"1": [126, 127, 128, 129, 130, 131, 132, 133, 134, 135, 136, 137, 138, 139, 140, 141, 142, 143, 144, 145, 146, 147, 148, 149, 150, 151, 152, 153, 154, 155, 156, 157, 158, 159, 160, 161, 162, 163, 164, 165], "2": [195, 196, 197], "3": [221, 222, 223, 224, 225, 226], "4": [432], "5": [441, 444, 445, 446, 447, 448, 449, 450, 451, 452, 453, 454, 455, 456, 457, 458, 459, 460, 461, 462, 466, 469]}, "removed_lines": {"2": [155, 156, 157], "4": [386], "5": [395, 398, 399, 400, 401, 402, 403, 404, 405, 406, 410, 413]}}, {"1": "android/guava/src/com/google/common/collect/CompactHashSet.java", "added": {"1": ["  // See CompactHashMap for a detailed description of how the following fields work. That\n", "  // description talks about `keys`, `values`, and `entries`; here the `keys` and `values` arrays\n", "  // are replaced by a single `elements` array but everything else works similarly.\n", "\n"], "2": ["   * mask  = 00000fff\n", "   * next  = 00000bbb\n", "   * entry = aaaaabbb\n"], "3": ["  private int resizeTable(int oldMask, int newCapacity, int targetHash, int targetEntryIndex) {\n"], "4": ["    Object oldTable = requireTable();\n", "    for (int oldTableIndex = 0; oldTableIndex <= oldMask; oldTableIndex++) {\n", "      int oldNext = CompactHashing.tableGet(oldTable, oldTableIndex);\n", "      while (oldNext != UNSET) {\n", "        int entryIndex = oldNext - 1;\n", "        int oldEntry = entries[entryIndex];\n", "        int hash = CompactHashing.getHashPrefix(oldEntry, oldMask) | oldTableIndex;\n", "        CompactHashing.tableSet(newTable, newTableIndex, oldNext);\n", "        oldNext = CompactHashing.getNext(oldEntry, oldMask);\n"]}, "removed": {"2": ["   * mask  = 0000ffff\n", "   * next  = 0000bbbb\n", "   * entry = aaaabbbb\n"], "3": ["  private int resizeTable(int mask, int newCapacity, int targetHash, int targetEntryIndex) {\n"], "4": ["    Object table = requireTable();\n", "    for (int tableIndex = 0; tableIndex <= mask; tableIndex++) {\n", "      int next = CompactHashing.tableGet(table, tableIndex);\n", "      while (next != UNSET) {\n", "        int entryIndex = next - 1;\n", "        int entry = entries[entryIndex];\n", "        int hash = CompactHashing.getHashPrefix(entry, mask) | tableIndex;\n", "        CompactHashing.tableSet(newTable, newTableIndex, next);\n", "        next = CompactHashing.getNext(entry, mask);\n"]}, "added_lines": {"1": [140, 141, 142, 143], "2": [173, 174, 175], "3": [383], "4": [392, 396, 397, 398, 399, 400, 403, 407, 410]}, "removed_lines": {"2": [169, 170, 171], "3": [379], "4": [388, 392, 393, 394, 395, 396, 399, 403, 406]}}, {"2": "android/guava/src/com/google/common/collect/CompactHashing.java", "added": {"1": ["  /**\n", "   * Returns {@code table[index]}, where {@code table} is actually a {@code byte[]}, {@code\n", "   * short[]}, or {@code int[]}. When it is a {@code byte[]} or {@code short[]}, the returned value\n", "   * is unsigned, so the range of possible returned values is 0\u2013255 or 0\u201365535, respectively.\n", "   */\n"], "2": ["  /**\n", "   * Sets {@code table[index]} to {@code entry}, where {@code table} is actually a {@code byte[]},\n", "   * {@code short[]}, or {@code int[]}. The value of {@code entry} should fit in the size of the\n", "   * assigned array element, when seen as an unsigned value. So if {@code table} is a {@code byte[]}\n", "   * then we should have {@code 0 \u2264 entry \u2264 255}, and if {@code table} is a {@code short[]} then we\n", "   * should have {@code 0 \u2264 entry \u2264 65535}. It is the caller's responsibility to ensure this.\n", "   */\n"]}, "removed": {}, "added_lines": {"1": [101, 102, 103, 104, 105], "2": [116, 117, 118, 119, 120, 121, 122]}, "removed_lines": {}}, {"3": "guava/src/com/google/common/collect/CompactHashMap.java", "added": {"1": ["  // The way the `table`, `entries`, `keys`, and `values` arrays work together is as follows.\n", "  //\n", "  // The `table` array always has a size that is a power of 2. The hashcode of a key in the map\n", "  // is masked in order to correspond to the current table size. For example, if the table size\n", "  // is 128 then the mask is 127 == 0x7f, keeping the bottom 7 bits of the hash value.\n", "  // If a key hashes to 0x89abcdef the mask reduces it to 0x89abcdef & 0x7f == 0x6f. We'll call this\n", "  // the \"short hash\".\n", "  //\n", "  // The `keys`, `values`, and `entries` arrays always have the same size as each other. They can be\n", "  // seen as fields of an imaginary `Entry` object like this:\n", "  //\n", "  // class Entry {\n", "  //    int hash;\n", "  //    Entry next;\n", "  //    K key;\n", "  //    V value;\n", "  // }\n", "  //\n", "  // The imaginary `hash` and `next` values are combined into a single `int` value in the `entries`\n", "  // array. The top bits of this value are the remaining bits of the hash value that were not used\n", "  // in the short hash. We saw that a mask of 0x7f would keep the 7-bit value 0x6f from a full\n", "  // hashcode of 0x89abcdef. The imaginary `hash` value would then be the remaining top 25 bits,\n", "  // 0x89abcd80. To this is added (or'd) the `next` value, which is an index within `entries`\n", "  // (and therefore within `keys` and `values`) of another entry that has the same short hash\n", "  // value. In our example, it would be another entry for a key whose short hash is also 0x6f.\n", "  //\n", "  // Essentially, then, `table[h]` gives us the start of a linked list in `entries`, where every\n", "  // element of the list has the short hash value h.\n", "  //\n", "  // A wrinkle here is that the value 0 (called UNSET in the code) is used as the equivalent of a\n", "  // null pointer. If `table[h] == 0` that means there are no keys in the map whose short hash is h.\n", "  // If the `next` bits in `entries[i]` are 0 that means there are no further entries for the given\n", "  // short hash. But 0 is also a valid index in `entries`, so we add 1 to these indices before\n", "  // putting them in `table` or in `next` bits, and subtract 1 again when we need an index value.\n", "  //\n", "  // The elements of `keys`, `values`, and `entries` are added sequentially, so that elements 0 to\n", "  // `size() - 1` are used and remaining elements are not. This makes iteration straightforward.\n", "  // Removing an entry generally involves moving the last element of each array to where the removed\n", "  // entry was, and adjusting index links accordingly.\n", "\n"], "2": ["   * mask  = 00000fff\n", "   * next  = 00000bbb\n", "   * entry = aaaaabbb\n"], "3": ["   *\n", "   * <p>For a new instance, where the arrays above have not yet been allocated, the value of {@code\n", "   * metadata} is the size that the arrays should be allocated with. Once the arrays have been\n", "   * allocated, the value of {@code metadata} combines the number of bits in the \"short hash\", in\n", "   * its bottom {@value CompactHashing#HASH_TABLE_BITS_MAX_BITS} bits, with a modification count in\n", "   * the remaining bits that is used to detect concurrent modification during iteration.\n"], "4": ["  private int resizeTable(int oldMask, int newCapacity, int targetHash, int targetEntryIndex) {\n"], "5": ["    Object oldTable = requireTable();\n", "    // Loop over `oldTable` to construct its replacement, ``newTable`. The entries do not move, so\n", "    // the `keys` and `values` arrays do not need to change. But because the \"short hash\" now has a\n", "    // different number of bits, we must rewrite each element of `entries` so that its contribution\n", "    // to the full hashcode reflects the change, and so that its `next` link corresponds to the new\n", "    // linked list of entries with the new short hash.\n", "    for (int oldTableIndex = 0; oldTableIndex <= oldMask; oldTableIndex++) {\n", "      int oldNext = CompactHashing.tableGet(oldTable, oldTableIndex);\n", "      // Each element of `oldTable` is the head of a (possibly empty) linked list of elements in\n", "      // `entries`. The `oldNext` loop is going to traverse that linked list.\n", "      // We need to rewrite the `next` link of each of the elements so that it is in the appropriate\n", "      // linked list starting from `newTable`. In general, each element from the old linked list\n", "      // belongs to a different linked list from `newTable`. We insert each element in turn at the\n", "      // head of its appropriate `newTable` linked list.\n", "      while (oldNext != UNSET) {\n", "        int entryIndex = oldNext - 1;\n", "        int oldEntry = entries[entryIndex];\n", "\n", "        // Rebuild the full 32-bit hash using entry hashPrefix and oldTableIndex (\"hashSuffix\").\n", "        int hash = CompactHashing.getHashPrefix(oldEntry, oldMask) | oldTableIndex;\n", "        CompactHashing.tableSet(newTable, newTableIndex, oldNext);\n", "        oldNext = CompactHashing.getNext(oldEntry, oldMask);\n"]}, "removed": {"2": ["   * mask  = 0000ffff\n", "   * next  = 0000bbbb\n", "   * entry = aaaabbbb\n"], "4": ["  private int resizeTable(int mask, int newCapacity, int targetHash, int targetEntryIndex) {\n"], "5": ["    Object table = requireTable();\n", "    // Loop over current hashtable\n", "    for (int tableIndex = 0; tableIndex <= mask; tableIndex++) {\n", "      int next = CompactHashing.tableGet(table, tableIndex);\n", "      while (next != UNSET) {\n", "        int entryIndex = next - 1;\n", "        int entry = entries[entryIndex];\n", "\n", "        // Rebuild hash using entry hashPrefix and tableIndex (\"hashSuffix\")\n", "        int hash = CompactHashing.getHashPrefix(entry, mask) | tableIndex;\n", "        CompactHashing.tableSet(newTable, newTableIndex, next);\n", "        next = CompactHashing.getNext(entry, mask);\n"]}, "added_lines": {"1": [130, 131, 132, 133, 134, 135, 136, 137, 138, 139, 140, 141, 142, 143, 144, 145, 146, 147, 148, 149, 150, 151, 152, 153, 154, 155, 156, 157, 158, 159, 160, 161, 162, 163, 164, 165, 166, 167, 168, 169], "2": [199, 200, 201], "3": [225, 226, 227, 228, 229, 230], "4": [436], "5": [445, 448, 449, 450, 451, 452, 453, 454, 455, 456, 457, 458, 459, 460, 461, 462, 463, 464, 465, 466, 470, 473]}, "removed_lines": {"2": [159, 160, 161], "4": [390], "5": [399, 402, 403, 404, 405, 406, 407, 408, 409, 410, 414, 417]}}, {"4": "guava/src/com/google/common/collect/CompactHashSet.java", "added": {"1": ["  // See CompactHashMap for a detailed description of how the following fields work. That\n", "  // description talks about `keys`, `values`, and `entries`; here the `keys` and `values` arrays\n", "  // are replaced by a single `elements` array but everything else works similarly.\n", "\n"], "2": ["   * mask  = 00000fff\n", "   * next  = 00000bbb\n", "   * entry = aaaaabbb\n"], "3": ["  private int resizeTable(int oldMask, int newCapacity, int targetHash, int targetEntryIndex) {\n"], "4": ["    Object oldTable = requireTable();\n", "    for (int oldTableIndex = 0; oldTableIndex <= oldMask; oldTableIndex++) {\n", "      int oldNext = CompactHashing.tableGet(oldTable, oldTableIndex);\n", "      while (oldNext != UNSET) {\n", "        int entryIndex = oldNext - 1;\n", "        int oldEntry = entries[entryIndex];\n", "        int hash = CompactHashing.getHashPrefix(oldEntry, oldMask) | oldTableIndex;\n", "        CompactHashing.tableSet(newTable, newTableIndex, oldNext);\n", "        oldNext = CompactHashing.getNext(oldEntry, oldMask);\n"]}, "removed": {"2": ["   * mask  = 0000ffff\n", "   * next  = 0000bbbb\n", "   * entry = aaaabbbb\n"], "3": ["  private int resizeTable(int mask, int newCapacity, int targetHash, int targetEntryIndex) {\n"], "4": ["    Object table = requireTable();\n", "    for (int tableIndex = 0; tableIndex <= mask; tableIndex++) {\n", "      int next = CompactHashing.tableGet(table, tableIndex);\n", "      while (next != UNSET) {\n", "        int entryIndex = next - 1;\n", "        int entry = entries[entryIndex];\n", "        int hash = CompactHashing.getHashPrefix(entry, mask) | tableIndex;\n", "        CompactHashing.tableSet(newTable, newTableIndex, next);\n", "        next = CompactHashing.getNext(entry, mask);\n"]}, "added_lines": {"1": [144, 145, 146, 147], "2": [177, 178, 179], "3": [387], "4": [396, 400, 401, 402, 403, 404, 407, 411, 414]}, "removed_lines": {"2": [173, 174, 175], "3": [383], "4": [392, 396, 397, 398, 399, 400, 403, 407, 410]}}, {"5": "guava/src/com/google/common/collect/CompactHashing.java", "added": {"1": ["  /**\n", "   * Returns {@code table[index]}, where {@code table} is actually a {@code byte[]}, {@code\n", "   * short[]}, or {@code int[]}. When it is a {@code byte[]} or {@code short[]}, the returned value\n", "   * is unsigned, so the range of possible returned values is 0\u2013255 or 0\u201365535, respectively.\n", "   */\n"], "2": ["  /**\n", "   * Sets {@code table[index]} to {@code entry}, where {@code table} is actually a {@code byte[]},\n", "   * {@code short[]}, or {@code int[]}. The value of {@code entry} should fit in the size of the\n", "   * assigned array element, when seen as an unsigned value. So if {@code table} is a {@code byte[]}\n", "   * then we should have {@code 0 \u2264 entry \u2264 255}, and if {@code table} is a {@code short[]} then we\n", "   * should have {@code 0 \u2264 entry \u2264 65535}. It is the caller's responsibility to ensure this.\n", "   */\n"]}, "removed": {}, "added_lines": {"1": [101, 102, 103, 104, 105], "2": [116, 117, 118, 119, 120, 121, 122]}, "removed_lines": {}}]}
