{
    "addition": {
        "126": "  // The way the `table`, `entries`, `keys`, and `values` arrays work together is as follows.\n",
        "127": "  //\n",
        "128": "  // The `table` array always has a size that is a power of 2. The hashcode of a key in the map\n",
        "129": "  // is masked in order to correspond to the current table size. For example, if the table size\n",
        "130": "  // is 128 then the mask is 127 == 0x7f, keeping the bottom 7 bits of the hash value.\n",
        "131": "  // If a key hashes to 0x89abcdef the mask reduces it to 0x89abcdef & 0x7f == 0x6f. We'll call this\n",
        "132": "  // the \"short hash\".\n",
        "133": "  //\n",
        "134": "  // The `keys`, `values`, and `entries` arrays always have the same size as each other. They can be\n",
        "135": "  // seen as fields of an imaginary `Entry` object like this:\n",
        "136": "  //\n",
        "137": "  // class Entry {\n",
        "138": "  //    int hash;\n",
        "139": "  //    Entry next;\n",
        "140": "  //    K key;\n",
        "141": "  //    V value;\n",
        "142": "  // }\n",
        "143": "  //\n",
        "144": "  // The imaginary `hash` and `next` values are combined into a single `int` value in the `entries`\n",
        "145": "  // array. The top bits of this value are the remaining bits of the hash value that were not used\n",
        "146": "  // in the short hash. We saw that a mask of 0x7f would keep the 7-bit value 0x6f from a full\n",
        "147": "  // hashcode of 0x89abcdef. The imaginary `hash` value would then be the remaining top 25 bits,\n",
        "148": "  // 0x89abcd80. To this is added (or'd) the `next` value, which is an index within `entries`\n",
        "149": "  // (and therefore within `keys` and `values`) of another entry that has the same short hash\n",
        "150": "  // value. In our example, it would be another entry for a key whose short hash is also 0x6f.\n",
        "151": "  //\n",
        "152": "  // Essentially, then, `table[h]` gives us the start of a linked list in `entries`, where every\n",
        "153": "  // element of the list has the short hash value h.\n",
        "154": "  //\n",
        "155": "  // A wrinkle here is that the value 0 (called UNSET in the code) is used as the equivalent of a\n",
        "156": "  // null pointer. If `table[h] == 0` that means there are no keys in the map whose short hash is h.\n",
        "157": "  // If the `next` bits in `entries[i]` are 0 that means there are no further entries for the given\n",
        "158": "  // short hash. But 0 is also a valid index in `entries`, so we add 1 to these indices before\n",
        "159": "  // putting them in `table` or in `next` bits, and subtract 1 again when we need an index value.\n",
        "160": "  //\n",
        "161": "  // The elements of `keys`, `values`, and `entries` are added sequentially, so that elements 0 to\n",
        "162": "  // `size() - 1` are used and remaining elements are not. This makes iteration straightforward.\n",
        "163": "  // Removing an entry generally involves moving the last element of each array to where the removed\n",
        "164": "  // entry was, and adjusting index links accordingly.\n",
        "165": "\n",
        "195": "   * mask  = 00000fff\n",
        "196": "   * next  = 00000bbb\n",
        "197": "   * entry = aaaaabbb\n",
        "221": "   *\n",
        "222": "   * <p>For a new instance, where the arrays above have not yet been allocated, the value of {@code\n",
        "223": "   * metadata} is the size that the arrays should be allocated with. Once the arrays have been\n",
        "224": "   * allocated, the value of {@code metadata} combines the number of bits in the \"short hash\", in\n",
        "225": "   * its bottom {@value CompactHashing#HASH_TABLE_BITS_MAX_BITS} bits, with a modification count in\n",
        "226": "   * the remaining bits that is used to detect concurrent modification during iteration.\n",
        "432": "  private int resizeTable(int oldMask, int newCapacity, int targetHash, int targetEntryIndex) {\n",
        "441": "    Object oldTable = requireTable();\n",
        "444": "    // Loop over `oldTable` to construct its replacement, ``newTable`. The entries do not move, so\n",
        "445": "    // the `keys` and `values` arrays do not need to change. But because the \"short hash\" now has a\n",
        "446": "    // different number of bits, we must rewrite each element of `entries` so that its contribution\n",
        "447": "    // to the full hashcode reflects the change, and so that its `next` link corresponds to the new\n",
        "448": "    // linked list of entries with the new short hash.\n",
        "449": "    for (int oldTableIndex = 0; oldTableIndex <= oldMask; oldTableIndex++) {\n",
        "450": "      int oldNext = CompactHashing.tableGet(oldTable, oldTableIndex);\n",
        "451": "      // Each element of `oldTable` is the head of a (possibly empty) linked list of elements in\n",
        "452": "      // `entries`. The `oldNext` loop is going to traverse that linked list.\n",
        "453": "      // We need to rewrite the `next` link of each of the elements so that it is in the appropriate\n",
        "454": "      // linked list starting from `newTable`. In general, each element from the old linked list\n",
        "455": "      // belongs to a different linked list from `newTable`. We insert each element in turn at the\n",
        "456": "      // head of its appropriate `newTable` linked list.\n",
        "457": "      while (oldNext != UNSET) {\n",
        "458": "        int entryIndex = oldNext - 1;\n",
        "459": "        int oldEntry = entries[entryIndex];\n",
        "460": "\n",
        "461": "        // Rebuild the full 32-bit hash using entry hashPrefix and oldTableIndex (\"hashSuffix\").\n",
        "462": "        int hash = CompactHashing.getHashPrefix(oldEntry, oldMask) | oldTableIndex;\n",
        "466": "        CompactHashing.tableSet(newTable, newTableIndex, oldNext);\n",
        "469": "        oldNext = CompactHashing.getNext(oldEntry, oldMask);\n"
    },
    "removed": {
        "155": "   * mask  = 0000ffff\n",
        "156": "   * next  = 0000bbbb\n",
        "157": "   * entry = aaaabbbb\n",
        "386": "  private int resizeTable(int mask, int newCapacity, int targetHash, int targetEntryIndex) {\n",
        "395": "    Object table = requireTable();\n",
        "398": "    // Loop over current hashtable\n",
        "399": "    for (int tableIndex = 0; tableIndex <= mask; tableIndex++) {\n",
        "400": "      int next = CompactHashing.tableGet(table, tableIndex);\n",
        "401": "      while (next != UNSET) {\n",
        "402": "        int entryIndex = next - 1;\n",
        "403": "        int entry = entries[entryIndex];\n",
        "404": "\n",
        "405": "        // Rebuild hash using entry hashPrefix and tableIndex (\"hashSuffix\")\n",
        "406": "        int hash = CompactHashing.getHashPrefix(entry, mask) | tableIndex;\n",
        "410": "        CompactHashing.tableSet(newTable, newTableIndex, next);\n",
        "413": "        next = CompactHashing.getNext(entry, mask);\n"
    }
}