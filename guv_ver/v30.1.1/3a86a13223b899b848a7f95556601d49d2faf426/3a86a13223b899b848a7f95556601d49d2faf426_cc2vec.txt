{"id": "3a86a13223b899b848a7f95556601d49d2faf426", "code": [{"0": "android/guava/src/com/google/common/collect/ComparisonChain.java", "added": {"1": ["import org.checkerframework.checker.nullness.qual.Nullable;\n"], "2": ["@ElementTypesAreNonnullByDefault\n"], "3": ["        @SuppressWarnings(\"unchecked\") // unsafe; see discussion on supertype\n", "        public ComparisonChain compare(Comparable<?> left, Comparable<?> right) {\n", "          return classify(((Comparable<Object>) left).compareTo(right));\n", "        public <T extends @Nullable Object> ComparisonChain compare(\n", "            @ParametricNullness T left, @ParametricNullness T right, Comparator<T> comparator) {\n"], "4": ["    public ComparisonChain compare(Comparable<?> left, Comparable<?> right) {\n", "    public <T extends @Nullable Object> ComparisonChain compare(\n", "        @ParametricNullness T left, @ParametricNullness T right, Comparator<T> comparator) {\n"], "5": ["   *\n", "   * <p>This method is declared to accept any 2 {@code Comparable} objects, even if they are not <a\n", "   * href=\"https://docs.oracle.com/javase/tutorial/collections/interfaces/order.html\">mutually\n", "   * comparable</a>. If you pass objects that are not mutually comparable, this method may throw an\n", "   * exception. (The reason for this decision is lost to time, but the reason <i>might</i> be that\n", "   * we wanted to support legacy classes that implement the raw type {@code Comparable} (instead of\n", "   * implementing {@code Comparable<Foo>}) without producing warnings. If so, we would prefer today\n", "   * to produce warnings in that case, and we may change this method to do so in the future. Support\n", "   * for raw {@code Comparable} types in Guava in general is tracked as <a\n", "   * href=\"https://github.com/google/guava/issues/989\">#989</a>.)\n", "   *\n", "   * @throws ClassCastException if the parameters are not mutually comparable\n"], "6": ["  public abstract <T extends @Nullable Object> ComparisonChain compare(\n", "      @ParametricNullness T left, @ParametricNullness T right, Comparator<T> comparator);\n"]}, "removed": {"1": ["import org.checkerframework.checker.nullness.compatqual.NullableDecl;\n"], "3": ["        @SuppressWarnings(\"unchecked\")\n", "        public ComparisonChain compare(Comparable left, Comparable right) {\n", "          return classify(left.compareTo(right));\n", "        public <T> ComparisonChain compare(\n", "            @NullableDecl T left, @NullableDecl T right, Comparator<T> comparator) {\n"], "4": ["    public ComparisonChain compare(@NullableDecl Comparable left, @NullableDecl Comparable right) {\n", "    public <T> ComparisonChain compare(\n", "        @NullableDecl T left, @NullableDecl T right, @NullableDecl Comparator<T> comparator) {\n"], "6": ["  public abstract <T> ComparisonChain compare(\n", "      @NullableDecl T left, @NullableDecl T right, Comparator<T> comparator);\n"]}, "added_lines": {"1": [24], "2": [60], "3": [71, 73, 74, 78, 79], "4": [135, 140, 141], "5": [184, 185, 186, 187, 188, 189, 190, 191, 192, 193, 194, 195], "6": [203, 204]}, "removed_lines": {"1": [24], "3": [70, 72, 73, 77, 78], "4": [134, 139, 140], "6": [190, 191]}}, {"1": "android/guava/src/com/google/common/collect/ComputationException.java", "added": {"1": ["import javax.annotation.CheckForNull;\n"], "2": ["@ElementTypesAreNonnullByDefault\n", "  public ComputationException(@CheckForNull Throwable cause) {\n"]}, "removed": {"1": ["import org.checkerframework.checker.nullness.compatqual.NullableDecl;\n"], "2": ["  public ComputationException(@NullableDecl Throwable cause) {\n"]}, "added_lines": {"1": [20], "2": [37, 40]}, "removed_lines": {"1": [20], "2": [39]}}, {"2": "android/guava/src/com/google/common/collect/EvictingQueue.java", "added": {"1": ["@ElementTypesAreNonnullByDefault\n"], "2": ["  public boolean contains(\n", "      // TODO(cpovirk): Consider accepting null.\n", "      @SuppressWarnings(\"nullness\") Object object) {\n", "  public boolean remove(\n", "      // TODO(cpovirk): Consider accepting null.\n", "      @SuppressWarnings(\"nullness\") Object object) {\n"]}, "removed": {"2": ["  public boolean contains(Object object) {\n", "  public boolean remove(Object object) {\n"]}, "added_lines": {"1": [48], "2": [130, 131, 132, 138, 139, 140]}, "removed_lines": {"2": [129, 135]}}, {"3": "android/guava/src/com/google/common/collect/FluentIterable.java", "added": {"1": ["import java.util.Collections;\n", "import javax.annotation.CheckForNull;\n", "import org.checkerframework.checker.nullness.qual.Nullable;\n"], "2": ["@ElementTypesAreNonnullByDefault\n", "public abstract class FluentIterable<E extends @Nullable Object> implements Iterable<E> {\n", "  // Optional.of(this). To access the delegate iterable, call #getDelegate(), which converts to\n"], "3": ["    this.iterableDelegate = Optional.of(iterable);\n"], "4": ["  public static <E extends @Nullable Object> FluentIterable<E> from(final Iterable<E> iterable) {\n"], "5": ["  public static <E extends @Nullable Object> FluentIterable<E> from(E[] elements) {\n"], "6": ["  public static <E extends @Nullable Object> FluentIterable<E> from(FluentIterable<E> iterable) {\n"], "7": ["  public static <T extends @Nullable Object> FluentIterable<T> concat(\n", "      Iterable<? extends T> a, Iterable<? extends T> b) {\n"], "8": ["  public static <T extends @Nullable Object> FluentIterable<T> concat(\n"], "9": ["  public static <T extends @Nullable Object> FluentIterable<T> concat(\n"], "10": ["  public static <T extends @Nullable Object> FluentIterable<T> concat(\n", "      Iterable<? extends T>... inputs) {\n"], "11": ["  public static <T extends @Nullable Object> FluentIterable<T> concat(\n"], "12": ["  private static <T extends @Nullable Object> FluentIterable<T> concatNoDefensiveCopy(\n"], "13": ["  public static <E extends @Nullable Object> FluentIterable<E> of() {\n", "    return FluentIterable.from(Collections.<E>emptyList());\n"], "14": ["  public static <E extends @Nullable Object> FluentIterable<E> of(\n", "      @ParametricNullness E element, E... elements) {\n"], "15": ["  public final boolean contains(@CheckForNull Object target) {\n"], "16": ["  @SuppressWarnings(\"nullness\") // Unsafe, but we can't do much about it now.\n"], "17": ["  public final <T extends @Nullable Object> FluentIterable<T> transform(\n", "      Function<? super E, T> function) {\n"], "18": ["  public <T extends @Nullable Object> FluentIterable<T> transformAndConcat(\n"], "19": ["  @SuppressWarnings(\"nullness\") // Unsafe, but we can't do much about it now.\n"], "20": ["  @SuppressWarnings(\"nullness\") // Unsafe, but we can't do much about it now.\n"], "21": ["  @SuppressWarnings(\"nullness\") // Unsafe, but we can't do much about it now.\n"], "22": ["  @SuppressWarnings(\"nullness\") // Unsafe, but we can't do much about it now.\n"], "23": ["  @SuppressWarnings(\"nullness\") // Unsafe, but we can't do much about it now.\n"], "24": ["  @SuppressWarnings(\"nullness\") // Unsafe, but we can't do much about it now.\n"], "25": ["  @SuppressWarnings(\"nullness\") // Unsafe, but we can't do much about it now.\n"], "26": ["  @SuppressWarnings(\"nullness\") // Unsafe, but we can't do much about it now.\n"], "27": ["  @SuppressWarnings(\"nullness\") // Unsafe, but we can't do much about it now.\n"], "28": ["  @SuppressWarnings(\"nullness\") // Unsafe, but we can't do much about it now.\n"], "29": ["  /*\n", "   * Both the declaration of our Class<E> parameter and its usage in a call to Iterables.toArray\n", "   * produce a nullness error: E may be a nullable type, and our nullness checker has Class's type\n", "   * parameter bounded to non-null types. To avoid that, we'd use Class<@Nonnull E> if we could.\n", "   * (Granted, this is only one of many nullness-checking problems that arise from letting\n", "   * FluentIterable support null elements, and most of the other produce outright unsoundness.)\n", "   */\n", "  @SuppressWarnings(\"nullness\")\n", "  public final @Nullable E[] toArray(Class<E> type) {\n"], "30": ["  @ParametricNullness\n", "  private static class FromIterableFunction<E extends @Nullable Object>\n", "      implements Function<Iterable<E>, FluentIterable<E>> {\n"]}, "removed": {"1": ["import org.checkerframework.checker.nullness.compatqual.NullableDecl;\n"], "2": ["public abstract class FluentIterable<E> implements Iterable<E> {\n", "  // Optional.of(this). To access the iterator delegate, call #getDelegate(), which converts to\n"], "3": ["    checkNotNull(iterable);\n", "    this.iterableDelegate = Optional.fromNullable(this != iterable ? iterable : null);\n"], "4": ["  public static <E> FluentIterable<E> from(final Iterable<E> iterable) {\n"], "5": ["  public static <E> FluentIterable<E> from(E[] elements) {\n"], "6": ["  public static <E> FluentIterable<E> from(FluentIterable<E> iterable) {\n"], "7": ["  public static <T> FluentIterable<T> concat(Iterable<? extends T> a, Iterable<? extends T> b) {\n"], "8": ["  public static <T> FluentIterable<T> concat(\n"], "9": ["  public static <T> FluentIterable<T> concat(\n"], "10": ["  public static <T> FluentIterable<T> concat(Iterable<? extends T>... inputs) {\n"], "11": ["  public static <T> FluentIterable<T> concat(\n"], "12": ["  private static <T> FluentIterable<T> concatNoDefensiveCopy(\n"], "13": ["  public static <E> FluentIterable<E> of() {\n", "    return FluentIterable.from(ImmutableList.<E>of());\n"], "14": ["  public static <E> FluentIterable<E> of(@NullableDecl E element, E... elements) {\n"], "15": ["  public final boolean contains(@NullableDecl Object target) {\n"], "17": ["  public final <T> FluentIterable<T> transform(Function<? super E, T> function) {\n"], "18": ["  public <T> FluentIterable<T> transformAndConcat(\n"], "29": ["  public final E[] toArray(Class<E> type) {\n"], "30": ["  // TODO(kevinb): add @NullableDecl?\n", "  private static class FromIterableFunction<E> implements Function<Iterable<E>, FluentIterable<E>> {\n"]}, "added_lines": {"1": [30, 35, 36], "2": [115, 116, 120], "3": [130], "4": [144], "5": [166], "6": [182], "7": [199, 200], "8": [218], "9": [238], "10": [262, 263], "11": [282], "12": [294], "13": [322, 323], "14": [335, 336], "15": [367], "16": [477], "17": [492, 493], "18": [510], "19": [525], "20": [542], "21": [632], "22": [650], "23": [665], "24": [684], "25": [698], "26": [720], "27": [743], "28": [780], "29": [798, 799, 800, 801, 802, 803, 804, 805, 806], "30": [862, 868, 869]}, "removed_lines": {"1": [34], "2": [113, 117], "3": [127, 128], "4": [142], "5": [164], "6": [180], "7": [197], "8": [215], "9": [235], "10": [259], "11": [278], "12": [290], "13": [318, 319], "14": [331], "15": [362], "17": [486], "18": [503], "29": [781], "30": [837, 843]}}, {"4": "android/guava/src/com/google/common/collect/Interner.java", "added": {"1": ["@ElementTypesAreNonnullByDefault\n"]}, "removed": {}, "added_lines": {"1": [36]}, "removed_lines": {}}, {"5": "android/guava/src/com/google/common/collect/Interners.java", "added": {"1": ["import javax.annotation.CheckForNull;\n"], "2": ["@ElementTypesAreNonnullByDefault\n"], "3": ["        @SuppressWarnings(\"rawtypes\") // using raw types to avoid a bug in our nullness checker :(\n", "        InternalEntry entry = map.getEntry(sample);\n", "          Object canonical = entry.getKey();\n", "            // The compiler would know this is safe if not for our use of raw types (see above).\n", "            @SuppressWarnings(\"unchecked\")\n", "            E result = (E) canonical;\n", "            return result;\n"], "4": ["    public boolean equals(@CheckForNull Object other) {\n"]}, "removed": {"3": ["        InternalEntry<E, Dummy, ?> entry = map.getEntry(sample);\n", "          E canonical = entry.getKey();\n", "            return canonical;\n"], "4": ["    public boolean equals(Object other) {\n"]}, "added_lines": {"1": [25], "2": [34], "3": [127, 128, 130, 132, 133, 134, 135], "4": [183]}, "removed_lines": {"3": [125, 127, 129], "4": [177]}}, {"6": "android/guava/src/com/google/common/collect/Iterables.java", "added": {"1": ["  public static <T extends @Nullable Object> Iterable<List<@Nullable T>> paddedPartition(\n", "    return new FluentIterable<List<@Nullable T>>() {\n", "      public Iterator<List<@Nullable T>> iterator() {\n"]}, "removed": {"1": ["  public static <T extends @Nullable Object> Iterable<List<T>> paddedPartition(\n", "    return new FluentIterable<List<T>>() {\n", "      public Iterator<List<T>> iterator() {\n"]}, "added_lines": {"1": [588, 592, 594]}, "removed_lines": {"1": [588, 592, 594]}}, {"7": "android/guava/src/com/google/common/collect/Iterators.java", "added": {"1": ["  public static <T extends @Nullable Object>\n", "      UnmodifiableIterator<List<@Nullable T>> paddedPartition(Iterator<T> iterator, int size) {\n", "  private static <T extends @Nullable Object> UnmodifiableIterator<List<@Nullable T>> partitionImpl(\n", "    return new UnmodifiableIterator<List<@Nullable T>>() {\n", "      public List<@Nullable T> next() {\n", "        T[] array = (@Nullable T[]) new Object[size];\n"], "2": ["        List<@Nullable T> list = Collections.unmodifiableList(Arrays.asList(array));\n", "        // TODO(b/192579700): Use a ternary once it no longer confuses our nullness checker.\n", "        if (pad || count == size) {\n", "          return list;\n", "        } else {\n", "          return list.subList(0, count);\n", "        }\n"]}, "removed": {"1": ["  public static <T extends @Nullable Object> UnmodifiableIterator<List<T>> paddedPartition(\n", "      Iterator<T> iterator, int size) {\n", "  private static <T extends @Nullable Object> UnmodifiableIterator<List<T>> partitionImpl(\n", "    return new UnmodifiableIterator<List<T>>() {\n", "      public List<T> next() {\n", "        T[] array = (T[]) new Object[size];\n"], "2": ["        List<T> list = Collections.unmodifiableList((List<T>) Arrays.asList(array));\n", "        return (pad || count == size) ? list : list.subList(0, count);\n"]}, "added_lines": {"1": [614, 615, 619, 623, 630, 636], "2": [645, 646, 647, 648, 649, 650, 651]}, "removed_lines": {"1": [614, 615, 619, 623, 630, 636], "2": [645, 646]}}, {"8": "android/guava/src/com/google/common/collect/MapDifference.java", "added": {"1": ["import javax.annotation.CheckForNull;\n", "import org.checkerframework.checker.nullness.qual.Nullable;\n"], "2": ["@ElementTypesAreNonnullByDefault\n", "public interface MapDifference<K extends @Nullable Object, V extends @Nullable Object> {\n"], "3": ["  boolean equals(@CheckForNull Object object);\n"], "4": ["  interface ValueDifference<V extends @Nullable Object> {\n", "    @ParametricNullness\n", "    @ParametricNullness\n"], "5": ["    boolean equals(@CheckForNull Object other);\n"]}, "removed": {"1": ["import org.checkerframework.checker.nullness.compatqual.NullableDecl;\n"], "2": ["public interface MapDifference<K, V> {\n"], "3": ["  boolean equals(@NullableDecl Object object);\n"], "4": ["  interface ValueDifference<V> {\n"], "5": ["    boolean equals(@NullableDecl Object other);\n"]}, "added_lines": {"1": [22, 23], "2": [33, 34], "3": [72], "4": [92, 94, 98], "5": [106]}, "removed_lines": {"1": [22], "2": [32], "3": [70], "4": [90], "5": [102]}}, {"9": "android/guava/src/com/google/common/collect/MapMaker.java", "added": {"1": ["import javax.annotation.CheckForNull;\n"], "2": ["@ElementTypesAreNonnullByDefault\n"], "3": ["  @CheckForNull Strength keyStrength;\n", "  @CheckForNull Strength valueStrength;\n", "  @CheckForNull Equivalence<Object> keyEquivalence;\n"]}, "removed": {"1": ["import org.checkerframework.checker.nullness.compatqual.NullableDecl;\n"], "3": ["  @NullableDecl Strength keyStrength;\n", "  @NullableDecl Strength valueStrength;\n", "  @NullableDecl Equivalence<Object> keyEquivalence;\n"]}, "added_lines": {"1": [33], "2": [89], "3": [102, 103, 105]}, "removed_lines": {"1": [33], "3": [101, 102, 104]}}, {"10": "android/guava/src/com/google/common/collect/MinMaxPriorityQueue.java", "added": {"1": ["import static java.util.Objects.requireNonNull;\n"], "2": ["import javax.annotation.CheckForNull;\n", "import org.checkerframework.checker.nullness.qual.Nullable;\n"], "3": ["@ElementTypesAreNonnullByDefault\n"], "4": ["  /*\n", "   * TODO(cpovirk): Change to Comparator<? super B> to permit Comparator<@Nullable ...> and\n", "   * Comparator<SupertypeOfB>? What we have here matches the immutable collections, but those also\n", "   * expose a public Builder constructor that accepts \"? super.\" So maybe we should do *that*\n", "   * instead.\n", "   */\n"], "5": ["  private @Nullable Object[] queue;\n"], "6": ["  @CheckForNull\n", "    /*\n", "     * requireNonNull is safe as long as we're careful to call this method only with populated\n", "     * indexes.\n", "     */\n", "    return (E) requireNonNull(queue[index]);\n", "  @CheckForNull\n"], "7": ["  @CheckForNull\n"], "8": ["  @CheckForNull\n"], "9": ["  @CheckForNull\n"], "10": ["  @CheckForNull\n"], "11": ["  @CheckForNull\n"], "12": ["  @CheckForNull\n"], "13": ["    @Weak Heap otherHeap; // always initialized immediately after construction\n"], "14": ["    @CheckForNull\n"], "15": ["    @CheckForNull private Queue<E> forgetMeNot;\n", "    @CheckForNull private List<E> skipMe;\n", "    @CheckForNull private E lastFromForgetMeNot;\n"], "16": ["          // Either both are null or neither is, but we check both to satisfy the nullness checker.\n", "          if (forgetMeNot == null || skipMe == null) {\n"], "17": ["        checkState(removeExact(requireNonNull(lastFromForgetMeNot)));\n"]}, "removed": {"2": ["import org.checkerframework.checker.nullness.compatqual.NullableDecl;\n"], "5": ["  private Object[] queue;\n"], "6": ["    return (E) queue[index];\n"], "13": ["    @Weak @NullableDecl Heap otherHeap;\n"], "15": ["    @NullableDecl private Queue<E> forgetMeNot;\n", "    @NullableDecl private List<E> skipMe;\n", "    @NullableDecl private E lastFromForgetMeNot;\n"], "16": ["          if (forgetMeNot == null) {\n"], "17": ["        checkState(removeExact(lastFromForgetMeNot));\n"]}, "added_lines": {"1": [24], "2": [45, 46], "3": [103], "4": [127, 128, 129, 130, 131, 132], "5": [236], "6": [304, 311, 312, 313, 314, 315, 319], "7": [343], "8": [362], "9": [372], "10": [394], "11": [414], "12": [450], "13": [528], "14": [542], "15": [776, 777, 778], "16": [816, 817], "17": [831]}, "removed_lines": {"2": [44], "5": [227], "6": [301], "13": [507], "15": [754, 755, 756], "16": [794], "17": [808]}}, {"11": "android/guava/src/com/google/common/collect/SortedMapDifference.java", "added": {"1": ["import org.checkerframework.checker.nullness.qual.Nullable;\n"], "2": ["@ElementTypesAreNonnullByDefault\n", "public interface SortedMapDifference<K extends @Nullable Object, V extends @Nullable Object>\n", "    extends MapDifference<K, V> {\n"]}, "removed": {"2": ["public interface SortedMapDifference<K, V> extends MapDifference<K, V> {\n"]}, "added_lines": {"1": [21], "2": [30, 31, 32]}, "removed_lines": {"2": [29]}}, {"12": "android/guava/src/com/google/common/collect/TreeTraverser.java", "added": {"1": ["import javax.annotation.CheckForNull;\n"], "2": ["@ElementTypesAreNonnullByDefault\n"], "3": ["    @CheckForNull\n"]}, "removed": {}, "added_lines": {"1": [28], "2": [77], "3": [202]}, "removed_lines": {}}, {"13": "android/guava/src/com/google/common/reflect/Parameter.java", "added": {"1": ["import org.checkerframework.checker.nullness.qual.Nullable;\n"], "2": ["    @Nullable\n", "    A[] result = FluentIterable.from(annotations).filter(annotationType).toArray(annotationType);\n", "    @SuppressWarnings(\"nullness\") // safe because the input list contains no nulls\n", "    A[] cast = (A[]) result;\n", "    return cast;\n"]}, "removed": {"2": ["    return FluentIterable.from(annotations).filter(annotationType).toArray(annotationType);\n"]}, "added_lines": {"1": [25], "2": [106, 107, 108, 109, 110]}, "removed_lines": {"2": [105]}}, {"14": "guava/src/com/google/common/collect/ComparisonChain.java", "added": {"1": ["@ElementTypesAreNonnullByDefault\n"], "2": ["        @SuppressWarnings(\"unchecked\") // unsafe; see discussion on supertype\n", "        public ComparisonChain compare(Comparable<?> left, Comparable<?> right) {\n", "          return classify(((Comparable<Object>) left).compareTo(right));\n", "        public <T extends @Nullable Object> ComparisonChain compare(\n", "            @ParametricNullness T left, @ParametricNullness T right, Comparator<T> comparator) {\n"], "3": ["    public ComparisonChain compare(Comparable<?> left, Comparable<?> right) {\n", "    public <T extends @Nullable Object> ComparisonChain compare(\n", "        @ParametricNullness T left, @ParametricNullness T right, Comparator<T> comparator) {\n"], "4": ["   *\n", "   * <p>This method is declared to accept any 2 {@code Comparable} objects, even if they are not <a\n", "   * href=\"https://docs.oracle.com/javase/tutorial/collections/interfaces/order.html\">mutually\n", "   * comparable</a>. If you pass objects that are not mutually comparable, this method may throw an\n", "   * exception. (The reason for this decision is lost to time, but the reason <i>might</i> be that\n", "   * we wanted to support legacy classes that implement the raw type {@code Comparable} (instead of\n", "   * implementing {@code Comparable<Foo>}) without producing warnings. If so, we would prefer today\n", "   * to produce warnings in that case, and we may change this method to do so in the future. Support\n", "   * for raw {@code Comparable} types in Guava in general is tracked as <a\n", "   * href=\"https://github.com/google/guava/issues/989\">#989</a>.)\n", "   *\n", "   * @throws ClassCastException if the parameters are not mutually comparable\n"], "5": ["  public abstract <T extends @Nullable Object> ComparisonChain compare(\n", "      @ParametricNullness T left, @ParametricNullness T right, Comparator<T> comparator);\n"]}, "removed": {"2": ["        @SuppressWarnings(\"unchecked\")\n", "        public ComparisonChain compare(Comparable left, Comparable right) {\n", "          return classify(left.compareTo(right));\n", "        public <T> ComparisonChain compare(\n", "            @Nullable T left, @Nullable T right, Comparator<T> comparator) {\n"], "3": ["    public ComparisonChain compare(@Nullable Comparable left, @Nullable Comparable right) {\n", "    public <T> ComparisonChain compare(\n", "        @Nullable T left, @Nullable T right, @Nullable Comparator<T> comparator) {\n"], "5": ["  public abstract <T> ComparisonChain compare(\n", "      @Nullable T left, @Nullable T right, Comparator<T> comparator);\n"]}, "added_lines": {"1": [60], "2": [71, 73, 74, 78, 79], "3": [135, 140, 141], "4": [184, 185, 186, 187, 188, 189, 190, 191, 192, 193, 194, 195], "5": [203, 204]}, "removed_lines": {"2": [70, 72, 73, 77, 78], "3": [134, 139, 140], "5": [190, 191]}}, {"15": "guava/src/com/google/common/collect/ComputationException.java", "added": {"1": ["import javax.annotation.CheckForNull;\n"], "2": ["@ElementTypesAreNonnullByDefault\n", "  public ComputationException(@CheckForNull Throwable cause) {\n"]}, "removed": {"1": ["import org.checkerframework.checker.nullness.qual.Nullable;\n"], "2": ["  public ComputationException(@Nullable Throwable cause) {\n"]}, "added_lines": {"1": [20], "2": [37, 40]}, "removed_lines": {"1": [20], "2": [39]}}, {"16": "guava/src/com/google/common/collect/EvictingQueue.java", "added": {"1": ["@ElementTypesAreNonnullByDefault\n"], "2": ["  public boolean contains(\n", "      // TODO(cpovirk): Consider accepting null.\n", "      @SuppressWarnings(\"nullness\") Object object) {\n", "  public boolean remove(\n", "      // TODO(cpovirk): Consider accepting null.\n", "      @SuppressWarnings(\"nullness\") Object object) {\n"]}, "removed": {"2": ["  public boolean contains(Object object) {\n", "  public boolean remove(Object object) {\n"]}, "added_lines": {"1": [48], "2": [130, 131, 132, 138, 139, 140]}, "removed_lines": {"2": [129, 135]}}, {"17": "guava/src/com/google/common/collect/FluentIterable.java", "added": {"1": ["import java.util.Collections;\n", "import javax.annotation.CheckForNull;\n"], "2": ["@ElementTypesAreNonnullByDefault\n", "public abstract class FluentIterable<E extends @Nullable Object> implements Iterable<E> {\n", "  // Optional.of(this). To access the delegate iterable, call #getDelegate(), which converts to\n"], "3": ["    this.iterableDelegate = Optional.of(iterable);\n"], "4": ["  public static <E extends @Nullable Object> FluentIterable<E> from(final Iterable<E> iterable) {\n"], "5": ["  public static <E extends @Nullable Object> FluentIterable<E> from(E[] elements) {\n"], "6": ["  public static <E extends @Nullable Object> FluentIterable<E> from(FluentIterable<E> iterable) {\n"], "7": ["  public static <T extends @Nullable Object> FluentIterable<T> concat(\n", "      Iterable<? extends T> a, Iterable<? extends T> b) {\n"], "8": ["  public static <T extends @Nullable Object> FluentIterable<T> concat(\n"], "9": ["  public static <T extends @Nullable Object> FluentIterable<T> concat(\n"], "10": ["  public static <T extends @Nullable Object> FluentIterable<T> concat(\n", "      Iterable<? extends T>... inputs) {\n"], "11": ["  public static <T extends @Nullable Object> FluentIterable<T> concat(\n"], "12": ["  private static <T extends @Nullable Object> FluentIterable<T> concatNoDefensiveCopy(\n"], "13": ["  public static <E extends @Nullable Object> FluentIterable<E> of() {\n", "    return FluentIterable.from(Collections.<E>emptyList());\n"], "14": ["  public static <E extends @Nullable Object> FluentIterable<E> of(\n", "      @ParametricNullness E element, E... elements) {\n"], "15": ["  public final boolean contains(@CheckForNull Object target) {\n"], "16": ["  @SuppressWarnings(\"nullness\") // Unsafe, but we can't do much about it now.\n"], "17": ["  public final <T extends @Nullable Object> FluentIterable<T> transform(\n", "      Function<? super E, T> function) {\n"], "18": ["  public <T extends @Nullable Object> FluentIterable<T> transformAndConcat(\n"], "19": ["  @SuppressWarnings(\"nullness\") // Unsafe, but we can't do much about it now.\n"], "20": ["  @SuppressWarnings(\"nullness\") // Unsafe, but we can't do much about it now.\n"], "21": ["  @SuppressWarnings(\"nullness\") // Unsafe, but we can't do much about it now.\n"], "22": ["  @SuppressWarnings(\"nullness\") // Unsafe, but we can't do much about it now.\n"], "23": ["  @SuppressWarnings(\"nullness\") // Unsafe, but we can't do much about it now.\n"], "24": ["  @SuppressWarnings(\"nullness\") // Unsafe, but we can't do much about it now.\n"], "25": ["  @SuppressWarnings(\"nullness\") // Unsafe, but we can't do much about it now.\n"], "26": ["  @SuppressWarnings(\"nullness\") // Unsafe, but we can't do much about it now.\n"], "27": ["  @SuppressWarnings(\"nullness\") // Unsafe, but we can't do much about it now.\n"], "28": ["  @SuppressWarnings(\"nullness\") // Unsafe, but we can't do much about it now.\n"], "29": ["  /*\n", "   * Both the declaration of our Class<E> parameter and its usage in a call to Iterables.toArray\n", "   * produce a nullness error: E may be a nullable type, and our nullness checker has Class's type\n", "   * parameter bounded to non-null types. To avoid that, we'd use Class<@Nonnull E> if we could.\n", "   * (Granted, this is only one of many nullness-checking problems that arise from letting\n", "   * FluentIterable support null elements, and most of the other produce outright unsoundness.)\n", "   */\n", "  @SuppressWarnings(\"nullness\")\n", "  public final @Nullable E[] toArray(Class<E> type) {\n"], "30": ["  @ParametricNullness\n"], "31": ["  private static class FromIterableFunction<E extends @Nullable Object>\n", "      implements Function<Iterable<E>, FluentIterable<E>> {\n"]}, "removed": {"2": ["public abstract class FluentIterable<E> implements Iterable<E> {\n", "  // Optional.of(this). To access the iterator delegate, call #getDelegate(), which converts to\n"], "3": ["    checkNotNull(iterable);\n", "    this.iterableDelegate = Optional.fromNullable(this != iterable ? iterable : null);\n"], "4": ["  public static <E> FluentIterable<E> from(final Iterable<E> iterable) {\n"], "5": ["  public static <E> FluentIterable<E> from(E[] elements) {\n"], "6": ["  public static <E> FluentIterable<E> from(FluentIterable<E> iterable) {\n"], "7": ["  public static <T> FluentIterable<T> concat(Iterable<? extends T> a, Iterable<? extends T> b) {\n"], "8": ["  public static <T> FluentIterable<T> concat(\n"], "9": ["  public static <T> FluentIterable<T> concat(\n"], "10": ["  public static <T> FluentIterable<T> concat(Iterable<? extends T>... inputs) {\n"], "11": ["  public static <T> FluentIterable<T> concat(\n"], "12": ["  private static <T> FluentIterable<T> concatNoDefensiveCopy(\n"], "13": ["  public static <E> FluentIterable<E> of() {\n", "    return FluentIterable.from(ImmutableList.<E>of());\n"], "14": ["  public static <E> FluentIterable<E> of(@Nullable E element, E... elements) {\n"], "15": ["  public final boolean contains(@Nullable Object target) {\n"], "17": ["  public final <T> FluentIterable<T> transform(Function<? super E, T> function) {\n"], "18": ["  public <T> FluentIterable<T> transformAndConcat(\n"], "29": ["  public final E[] toArray(Class<E> type) {\n"], "30": ["  // TODO(kevinb): add @Nullable?\n"], "31": ["  private static class FromIterableFunction<E> implements Function<Iterable<E>, FluentIterable<E>> {\n"]}, "added_lines": {"1": [30, 36], "2": [112, 113, 117], "3": [127], "4": [141], "5": [163], "6": [179], "7": [196, 197], "8": [215], "9": [235], "10": [259, 260], "11": [279], "12": [291], "13": [319, 320], "14": [332, 333], "15": [364], "16": [474], "17": [489, 490], "18": [507], "19": [522], "20": [539], "21": [629], "22": [646], "23": [661], "24": [679], "25": [693], "26": [714], "27": [737], "28": [772], "29": [790, 791, 792, 793, 794, 795, 796, 797, 798], "30": [854], "31": [874, 875]}, "removed_lines": {"2": [110, 114], "3": [124, 125], "4": [139], "5": [161], "6": [177], "7": [194], "8": [212], "9": [232], "10": [256], "11": [275], "12": [287], "13": [315, 316], "14": [328], "15": [359], "17": [483], "18": [500], "29": [773], "30": [829], "31": [849]}}, {"18": "guava/src/com/google/common/collect/Interner.java", "added": {"1": ["@ElementTypesAreNonnullByDefault\n"]}, "removed": {}, "added_lines": {"1": [36]}, "removed_lines": {}}, {"19": "guava/src/com/google/common/collect/Interners.java", "added": {"1": ["import javax.annotation.CheckForNull;\n"], "2": ["@ElementTypesAreNonnullByDefault\n"], "3": ["        @SuppressWarnings(\"rawtypes\") // using raw types to avoid a bug in our nullness checker :(\n", "        InternalEntry entry = map.getEntry(sample);\n", "          Object canonical = entry.getKey();\n", "            // The compiler would know this is safe if not for our use of raw types (see above).\n", "            @SuppressWarnings(\"unchecked\")\n", "            E result = (E) canonical;\n", "            return result;\n"], "4": ["    public boolean equals(@CheckForNull Object other) {\n"]}, "removed": {"3": ["        InternalEntry<E, Dummy, ?> entry = map.getEntry(sample);\n", "          E canonical = entry.getKey();\n", "            return canonical;\n"], "4": ["    public boolean equals(Object other) {\n"]}, "added_lines": {"1": [25], "2": [34], "3": [127, 128, 130, 132, 133, 134, 135], "4": [183]}, "removed_lines": {"3": [125, 127, 129], "4": [177]}}, {"20": "guava/src/com/google/common/collect/Iterables.java", "added": {"1": ["  public static <T extends @Nullable Object> Iterable<List<@Nullable T>> paddedPartition(\n", "    return new FluentIterable<List<@Nullable T>>() {\n", "      public Iterator<List<@Nullable T>> iterator() {\n"]}, "removed": {"1": ["  public static <T extends @Nullable Object> Iterable<List<T>> paddedPartition(\n", "    return new FluentIterable<List<T>>() {\n", "      public Iterator<List<T>> iterator() {\n"]}, "added_lines": {"1": [555, 559, 561]}, "removed_lines": {"1": [555, 559, 561]}}, {"21": "guava/src/com/google/common/collect/Iterators.java", "added": {"1": ["  public static <T extends @Nullable Object>\n", "      UnmodifiableIterator<List<@Nullable T>> paddedPartition(Iterator<T> iterator, int size) {\n", "  private static <T extends @Nullable Object> UnmodifiableIterator<List<@Nullable T>> partitionImpl(\n", "    return new UnmodifiableIterator<List<@Nullable T>>() {\n", "      public List<@Nullable T> next() {\n", "        T[] array = (@Nullable T[]) new Object[size];\n"], "2": ["        List<@Nullable T> list = Collections.unmodifiableList(Arrays.asList(array));\n", "        // TODO(b/192579700): Use a ternary once it no longer confuses our nullness checker.\n", "        if (pad || count == size) {\n", "          return list;\n", "        } else {\n", "          return list.subList(0, count);\n", "        }\n"]}, "removed": {"1": ["  public static <T extends @Nullable Object> UnmodifiableIterator<List<T>> paddedPartition(\n", "      Iterator<T> iterator, int size) {\n", "  private static <T extends @Nullable Object> UnmodifiableIterator<List<T>> partitionImpl(\n", "    return new UnmodifiableIterator<List<T>>() {\n", "      public List<T> next() {\n", "        T[] array = (T[]) new Object[size];\n"], "2": ["        List<T> list = Collections.unmodifiableList((List<T>) Arrays.asList(array));\n", "        return (pad || count == size) ? list : list.subList(0, count);\n"]}, "added_lines": {"1": [614, 615, 619, 623, 630, 636], "2": [645, 646, 647, 648, 649, 650, 651]}, "removed_lines": {"1": [614, 615, 619, 623, 630, 636], "2": [645, 646]}}, {"22": "guava/src/com/google/common/collect/MapDifference.java", "added": {"1": ["import javax.annotation.CheckForNull;\n"], "2": ["@ElementTypesAreNonnullByDefault\n", "public interface MapDifference<K extends @Nullable Object, V extends @Nullable Object> {\n"], "3": ["  boolean equals(@CheckForNull Object object);\n"], "4": ["  interface ValueDifference<V extends @Nullable Object> {\n", "    @ParametricNullness\n", "    @ParametricNullness\n"], "5": ["    boolean equals(@CheckForNull Object other);\n"]}, "removed": {"2": ["public interface MapDifference<K, V> {\n"], "3": ["  boolean equals(@Nullable Object object);\n"], "4": ["  interface ValueDifference<V> {\n"], "5": ["    boolean equals(@Nullable Object other);\n"]}, "added_lines": {"1": [22], "2": [33, 34], "3": [72], "4": [92, 94, 98], "5": [106]}, "removed_lines": {"2": [32], "3": [70], "4": [90], "5": [102]}}, {"23": "guava/src/com/google/common/collect/MapMaker.java", "added": {"1": ["import javax.annotation.CheckForNull;\n"], "2": ["@ElementTypesAreNonnullByDefault\n"], "3": ["  @CheckForNull Strength keyStrength;\n", "  @CheckForNull Strength valueStrength;\n", "  @CheckForNull Equivalence<Object> keyEquivalence;\n"]}, "removed": {"1": ["import org.checkerframework.checker.nullness.qual.Nullable;\n"], "3": ["  @Nullable Strength keyStrength;\n", "  @Nullable Strength valueStrength;\n", "  @Nullable Equivalence<Object> keyEquivalence;\n"]}, "added_lines": {"1": [33], "2": [89], "3": [102, 103, 105]}, "removed_lines": {"1": [33], "3": [101, 102, 104]}}, {"24": "guava/src/com/google/common/collect/MinMaxPriorityQueue.java", "added": {"1": ["import static java.util.Objects.requireNonNull;\n"], "2": ["import javax.annotation.CheckForNull;\n"], "3": ["@ElementTypesAreNonnullByDefault\n"], "4": ["  /*\n", "   * TODO(cpovirk): Change to Comparator<? super B> to permit Comparator<@Nullable ...> and\n", "   * Comparator<SupertypeOfB>? What we have here matches the immutable collections, but those also\n", "   * expose a public Builder constructor that accepts \"? super.\" So maybe we should do *that*\n", "   * instead.\n", "   */\n"], "5": ["  private @Nullable Object[] queue;\n"], "6": ["  @CheckForNull\n", "    /*\n", "     * requireNonNull is safe as long as we're careful to call this method only with populated\n", "     * indexes.\n", "     */\n", "    return (E) requireNonNull(queue[index]);\n", "  @CheckForNull\n"], "7": ["  @CheckForNull\n"], "8": ["  @CheckForNull\n"], "9": ["  @CheckForNull\n"], "10": ["  @CheckForNull\n"], "11": ["  @CheckForNull\n"], "12": ["  @CheckForNull\n"], "13": ["    @Weak Heap otherHeap; // always initialized immediately after construction\n"], "14": ["    @CheckForNull\n"], "15": ["    @CheckForNull private Queue<E> forgetMeNot;\n", "    @CheckForNull private List<E> skipMe;\n", "    @CheckForNull private E lastFromForgetMeNot;\n"], "16": ["          // Either both are null or neither is, but we check both to satisfy the nullness checker.\n", "          if (forgetMeNot == null || skipMe == null) {\n"], "17": ["        checkState(removeExact(requireNonNull(lastFromForgetMeNot)));\n"]}, "removed": {"5": ["  private Object[] queue;\n"], "6": ["    return (E) queue[index];\n"], "13": ["    @Weak @Nullable Heap otherHeap;\n"], "15": ["    private @Nullable Queue<E> forgetMeNot;\n", "    private @Nullable List<E> skipMe;\n", "    private @Nullable E lastFromForgetMeNot;\n"], "16": ["          if (forgetMeNot == null) {\n"], "17": ["        checkState(removeExact(lastFromForgetMeNot));\n"]}, "added_lines": {"1": [24], "2": [45], "3": [103], "4": [127, 128, 129, 130, 131, 132], "5": [236], "6": [304, 311, 312, 313, 314, 315, 319], "7": [343], "8": [362], "9": [372], "10": [394], "11": [414], "12": [450], "13": [528], "14": [542], "15": [776, 777, 778], "16": [816, 817], "17": [831]}, "removed_lines": {"5": [227], "6": [301], "13": [507], "15": [754, 755, 756], "16": [794], "17": [808]}}, {"25": "guava/src/com/google/common/collect/SortedMapDifference.java", "added": {"1": ["import org.checkerframework.checker.nullness.qual.Nullable;\n"], "2": ["@ElementTypesAreNonnullByDefault\n", "public interface SortedMapDifference<K extends @Nullable Object, V extends @Nullable Object>\n", "    extends MapDifference<K, V> {\n"]}, "removed": {"2": ["public interface SortedMapDifference<K, V> extends MapDifference<K, V> {\n"]}, "added_lines": {"1": [21], "2": [30, 31, 32]}, "removed_lines": {"2": [29]}}, {"26": "guava/src/com/google/common/collect/TreeTraverser.java", "added": {"1": ["import javax.annotation.CheckForNull;\n"], "2": ["@ElementTypesAreNonnullByDefault\n"], "3": ["    @CheckForNull\n"]}, "removed": {}, "added_lines": {"1": [29], "2": [78], "3": [227]}, "removed_lines": {}}, {"27": "guava/src/com/google/common/reflect/Parameter.java", "added": {"1": ["import org.checkerframework.checker.nullness.qual.Nullable;\n"], "2": ["    @Nullable\n", "    A[] result = FluentIterable.from(annotations).filter(annotationType).toArray(annotationType);\n", "    @SuppressWarnings(\"nullness\") // safe because the input list contains no nulls\n", "    A[] cast = (A[]) result;\n", "    return cast;\n"]}, "removed": {"2": ["    return FluentIterable.from(annotations).filter(annotationType).toArray(annotationType);\n"]}, "added_lines": {"1": [26], "2": [116, 117, 118, 119, 120]}, "removed_lines": {"2": [115]}}]}
