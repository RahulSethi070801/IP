{
    "addition": {
        "30": "import java.util.Collections;\n",
        "36": "import javax.annotation.CheckForNull;\n",
        "112": "@ElementTypesAreNonnullByDefault\n",
        "113": "public abstract class FluentIterable<E extends @Nullable Object> implements Iterable<E> {\n",
        "117": "  // Optional.of(this). To access the delegate iterable, call #getDelegate(), which converts to\n",
        "127": "    this.iterableDelegate = Optional.of(iterable);\n",
        "141": "  public static <E extends @Nullable Object> FluentIterable<E> from(final Iterable<E> iterable) {\n",
        "163": "  public static <E extends @Nullable Object> FluentIterable<E> from(E[] elements) {\n",
        "179": "  public static <E extends @Nullable Object> FluentIterable<E> from(FluentIterable<E> iterable) {\n",
        "196": "  public static <T extends @Nullable Object> FluentIterable<T> concat(\n",
        "197": "      Iterable<? extends T> a, Iterable<? extends T> b) {\n",
        "215": "  public static <T extends @Nullable Object> FluentIterable<T> concat(\n",
        "235": "  public static <T extends @Nullable Object> FluentIterable<T> concat(\n",
        "259": "  public static <T extends @Nullable Object> FluentIterable<T> concat(\n",
        "260": "      Iterable<? extends T>... inputs) {\n",
        "279": "  public static <T extends @Nullable Object> FluentIterable<T> concat(\n",
        "291": "  private static <T extends @Nullable Object> FluentIterable<T> concatNoDefensiveCopy(\n",
        "319": "  public static <E extends @Nullable Object> FluentIterable<E> of() {\n",
        "320": "    return FluentIterable.from(Collections.<E>emptyList());\n",
        "332": "  public static <E extends @Nullable Object> FluentIterable<E> of(\n",
        "333": "      @ParametricNullness E element, E... elements) {\n",
        "364": "  public final boolean contains(@CheckForNull Object target) {\n",
        "474": "  @SuppressWarnings(\"nullness\") // Unsafe, but we can't do much about it now.\n",
        "489": "  public final <T extends @Nullable Object> FluentIterable<T> transform(\n",
        "490": "      Function<? super E, T> function) {\n",
        "507": "  public <T extends @Nullable Object> FluentIterable<T> transformAndConcat(\n",
        "522": "  @SuppressWarnings(\"nullness\") // Unsafe, but we can't do much about it now.\n",
        "539": "  @SuppressWarnings(\"nullness\") // Unsafe, but we can't do much about it now.\n",
        "629": "  @SuppressWarnings(\"nullness\") // Unsafe, but we can't do much about it now.\n",
        "646": "  @SuppressWarnings(\"nullness\") // Unsafe, but we can't do much about it now.\n",
        "661": "  @SuppressWarnings(\"nullness\") // Unsafe, but we can't do much about it now.\n",
        "679": "  @SuppressWarnings(\"nullness\") // Unsafe, but we can't do much about it now.\n",
        "693": "  @SuppressWarnings(\"nullness\") // Unsafe, but we can't do much about it now.\n",
        "714": "  @SuppressWarnings(\"nullness\") // Unsafe, but we can't do much about it now.\n",
        "737": "  @SuppressWarnings(\"nullness\") // Unsafe, but we can't do much about it now.\n",
        "772": "  @SuppressWarnings(\"nullness\") // Unsafe, but we can't do much about it now.\n",
        "790": "  /*\n",
        "791": "   * Both the declaration of our Class<E> parameter and its usage in a call to Iterables.toArray\n",
        "792": "   * produce a nullness error: E may be a nullable type, and our nullness checker has Class's type\n",
        "793": "   * parameter bounded to non-null types. To avoid that, we'd use Class<@Nonnull E> if we could.\n",
        "794": "   * (Granted, this is only one of many nullness-checking problems that arise from letting\n",
        "795": "   * FluentIterable support null elements, and most of the other produce outright unsoundness.)\n",
        "796": "   */\n",
        "797": "  @SuppressWarnings(\"nullness\")\n",
        "798": "  public final @Nullable E[] toArray(Class<E> type) {\n",
        "854": "  @ParametricNullness\n",
        "874": "  private static class FromIterableFunction<E extends @Nullable Object>\n",
        "875": "      implements Function<Iterable<E>, FluentIterable<E>> {\n"
    },
    "removed": {
        "110": "public abstract class FluentIterable<E> implements Iterable<E> {\n",
        "114": "  // Optional.of(this). To access the iterator delegate, call #getDelegate(), which converts to\n",
        "124": "    checkNotNull(iterable);\n",
        "125": "    this.iterableDelegate = Optional.fromNullable(this != iterable ? iterable : null);\n",
        "139": "  public static <E> FluentIterable<E> from(final Iterable<E> iterable) {\n",
        "161": "  public static <E> FluentIterable<E> from(E[] elements) {\n",
        "177": "  public static <E> FluentIterable<E> from(FluentIterable<E> iterable) {\n",
        "194": "  public static <T> FluentIterable<T> concat(Iterable<? extends T> a, Iterable<? extends T> b) {\n",
        "212": "  public static <T> FluentIterable<T> concat(\n",
        "232": "  public static <T> FluentIterable<T> concat(\n",
        "256": "  public static <T> FluentIterable<T> concat(Iterable<? extends T>... inputs) {\n",
        "275": "  public static <T> FluentIterable<T> concat(\n",
        "287": "  private static <T> FluentIterable<T> concatNoDefensiveCopy(\n",
        "315": "  public static <E> FluentIterable<E> of() {\n",
        "316": "    return FluentIterable.from(ImmutableList.<E>of());\n",
        "328": "  public static <E> FluentIterable<E> of(@Nullable E element, E... elements) {\n",
        "359": "  public final boolean contains(@Nullable Object target) {\n",
        "483": "  public final <T> FluentIterable<T> transform(Function<? super E, T> function) {\n",
        "500": "  public <T> FluentIterable<T> transformAndConcat(\n",
        "773": "  public final E[] toArray(Class<E> type) {\n",
        "829": "  // TODO(kevinb): add @Nullable?\n",
        "849": "  private static class FromIterableFunction<E> implements Function<Iterable<E>, FluentIterable<E>> {\n"
    }
}