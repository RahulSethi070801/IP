{"id": "53fd1d7612a96053e6e0b68dac86531b0d697497", "code": [{"0": "android/guava-tests/test/com/google/common/net/HostAndPortTest.java", "added": {"1": ["  public void testFromStringNonAsciiDigits() {\n", "    // Same as testFromStringUnusedDefaultPort but with Gujarati digits for port numbers.\n", "    checkFromStringCase(\"gmail.com:\u0aee1\", 77, null, -1, false);\n", "    checkFromStringCase(\"192.0.2.2:\u0aee\u0ae9\", 77, null, -1, false);\n", "    checkFromStringCase(\"[2001::2]:\u0aee\u0aeb\", 77, null, -1, false);\n", "  }\n", "\n"]}, "removed": {}, "added_lines": {"1": [62, 63, 64, 65, 66, 67, 68]}, "removed_lines": {}}, {"1": "android/guava-tests/test/com/google/common/net/InetAddressesTest.java", "added": {"1": ["  public void testForStringIPv4NonAsciiInput() throws UnknownHostException {\n", "    String ipStr = \"\u0ae7\u0aef\u0ae8.\u0ae7\u0aec\u0aee.\u0ae6.\u0ae7\"; // 192.168.0.1 in Gujarati digits\n", "    // Shouldn't hit DNS, because it's an IP string literal.\n", "    InetAddress ipv4Addr;\n", "    try {\n", "      ipv4Addr = InetAddress.getByName(ipStr);\n", "    } catch (UnknownHostException e) {\n", "      // OK: this is probably Android, which is stricter.\n", "      return;\n", "    }\n", "    assertEquals(ipv4Addr, InetAddresses.forString(ipStr));\n", "    assertTrue(InetAddresses.isInetAddress(ipStr));\n", "  }\n", "\n"], "2": ["  public void testForStringIPv6NonAsciiInput() throws UnknownHostException {\n", "    String ipStr = \"\u0ae9ffe::\u0ae7\"; // 3ffe::1 with Gujarati digits for 3 and 1\n", "    // Shouldn't hit DNS, because it's an IP string literal.\n", "    InetAddress ipv6Addr;\n", "    try {\n", "      ipv6Addr = InetAddress.getByName(ipStr);\n", "    } catch (UnknownHostException e) {\n", "      // OK: this is probably Android, which is stricter.\n", "      return;\n", "    }\n", "    assertEquals(ipv6Addr, InetAddresses.forString(ipStr));\n", "    assertTrue(InetAddresses.isInetAddress(ipStr));\n", "  }\n", "\n"]}, "removed": {}, "added_lines": {"1": [138, 139, 140, 141, 142, 143, 144, 145, 146, 147, 148, 149, 150, 151], "2": [160, 161, 162, 163, 164, 165, 166, 167, 168, 169, 170, 171, 172, 173]}, "removed_lines": {}}, {"2": "android/guava/src/com/google/common/net/HostAndPort.java", "added": {"1": ["import com.google.common.base.CharMatcher;\n"], "2": ["      checkArgument(\n", "          !portString.startsWith(\"+\") && CharMatcher.ascii().matchesAllOf(portString),\n", "          \"Unparseable port number: %s\",\n", "          hostPortString);\n"]}, "removed": {"2": ["      checkArgument(!portString.startsWith(\"+\"), \"Unparseable port number: %s\", hostPortString);\n"]}, "added_lines": {"1": [23], "2": [194, 195, 196, 197]}, "removed_lines": {"2": [193]}}, {"3": "android/guava/src/com/google/common/net/InetAddresses.java", "added": {"1": ["   * <p>This method accepts non-ASCII digits, for example {@code \"\uff11\uff19\uff12.\uff11\uff16\uff18.\uff10.\uff11\"} (those are fullwidth\n", "   * characters). That is consistent with {@link InetAddress}, but not with various RFCs. If you\n", "   * want to accept ASCII digits only, you can use something like {@code\n", "   * CharMatcher.ascii().matchesAllOf(ipString)}.\n", "   *\n"], "2": ["   * <p>This method accepts non-ASCII digits, for example {@code \"\uff11\uff19\uff12.\uff11\uff16\uff18.\uff10.\uff11\"} (those are fullwidth\n", "   * characters). That is consistent with {@link InetAddress}, but not with various RFCs. If you\n", "   * want to accept ASCII digits only, you can use something like {@code\n", "   * CharMatcher.ascii().matchesAllOf(ipString)}.\n", "   *\n"], "3": ["   * <p>This method is similar to {@link InetAddresses#forString(String)}, however, it requires that\n", "   * IPv6 addresses are surrounded by square brackets.\n", "   *\n", "   * <p>This method is the inverse of {@link InetAddresses#toUriString(java.net.InetAddress)}.\n", "   * <p>This method accepts non-ASCII digits, for example {@code \"\uff11\uff19\uff12.\uff11\uff16\uff18.\uff10.\uff11\"} (those are fullwidth\n", "   * characters). That is consistent with {@link InetAddress}, but not with various RFCs. If you\n", "   * want to accept ASCII digits only, you can use something like {@code\n", "   * CharMatcher.ascii().matchesAllOf(ipString)}.\n"], "4": ["   * <p>This method accepts non-ASCII digits, for example {@code \"\uff11\uff19\uff12.\uff11\uff16\uff18.\uff10.\uff11\"} (those are fullwidth\n", "   * characters). That is consistent with {@link InetAddress}, but not with various RFCs. If you\n", "   * want to accept ASCII digits only, you can use something like {@code\n", "   * CharMatcher.ascii().matchesAllOf(ipString)}.\n", "   *\n"], "5": ["   * <p>This method accepts non-ASCII digits. That is consistent with {@link InetAddress}, but not\n", "   * with various RFCs. If you want to accept ASCII digits only, you can use something like {@code\n", "   * CharMatcher.ascii().matchesAllOf(ipString)}.\n", "   *\n"], "6": ["   * This method does so by hashing 64 bits of the IPv6 address into {@code 224.0.0.0/3} (64 bits\n"], "7": ["   * <p>NOTE: This method is failsafe for security purposes: ALL IPv6 addresses (except localhost\n"]}, "removed": {"3": ["   * <p>This function is similar to {@link InetAddresses#forString(String)}, however, it requires\n", "   * that IPv6 addresses are surrounded by square brackets.\n", "   * <p>This function is the inverse of {@link InetAddresses#toUriString(java.net.InetAddress)}.\n"], "6": ["   * This function does so by hashing 64 bits of the IPv6 address into {@code 224.0.0.0/3} (64 bits\n"], "7": ["   * <p>NOTE: This function is failsafe for security purposes: ALL IPv6 addresses (except localhost\n"]}, "added_lines": {"1": [137, 138, 139, 140, 141], "2": [162, 163, 164, 165, 166], "3": [515, 516, 517, 518, 520, 521, 522, 523], "4": [567, 568, 569, 570, 571], "5": [867, 868, 869, 870], "6": [898], "7": [908]}, "removed_lines": {"3": [505, 506, 508], "6": [874], "7": [884]}}, {"4": "guava-tests/test/com/google/common/net/HostAndPortTest.java", "added": {"1": ["  public void testFromStringNonAsciiDigits() {\n", "    // Same as testFromStringUnusedDefaultPort but with Gujarati digits for port numbers.\n", "    checkFromStringCase(\"gmail.com:\u0aee1\", 77, null, -1, false);\n", "    checkFromStringCase(\"192.0.2.2:\u0aee\u0ae9\", 77, null, -1, false);\n", "    checkFromStringCase(\"[2001::2]:\u0aee\u0aeb\", 77, null, -1, false);\n", "  }\n", "\n"]}, "removed": {}, "added_lines": {"1": [62, 63, 64, 65, 66, 67, 68]}, "removed_lines": {}}, {"5": "guava-tests/test/com/google/common/net/InetAddressesTest.java", "added": {"1": ["  public void testForStringIPv4NonAsciiInput() throws UnknownHostException {\n", "    String ipStr = \"\u0ae7\u0aef\u0ae8.\u0ae7\u0aec\u0aee.\u0ae6.\u0ae7\"; // 192.168.0.1 in Gujarati digits\n", "    // Shouldn't hit DNS, because it's an IP string literal.\n", "    InetAddress ipv4Addr;\n", "    try {\n", "      ipv4Addr = InetAddress.getByName(ipStr);\n", "    } catch (UnknownHostException e) {\n", "      // OK: this is probably Android, which is stricter.\n", "      return;\n", "    }\n", "    assertEquals(ipv4Addr, InetAddresses.forString(ipStr));\n", "    assertTrue(InetAddresses.isInetAddress(ipStr));\n", "  }\n", "\n"], "2": ["  public void testForStringIPv6NonAsciiInput() throws UnknownHostException {\n", "    String ipStr = \"\u0ae9ffe::\u0ae7\"; // 3ffe::1 with Gujarati digits for 3 and 1\n", "    // Shouldn't hit DNS, because it's an IP string literal.\n", "    InetAddress ipv6Addr;\n", "    try {\n", "      ipv6Addr = InetAddress.getByName(ipStr);\n", "    } catch (UnknownHostException e) {\n", "      // OK: this is probably Android, which is stricter.\n", "      return;\n", "    }\n", "    assertEquals(ipv6Addr, InetAddresses.forString(ipStr));\n", "    assertTrue(InetAddresses.isInetAddress(ipStr));\n", "  }\n", "\n"]}, "removed": {}, "added_lines": {"1": [138, 139, 140, 141, 142, 143, 144, 145, 146, 147, 148, 149, 150, 151], "2": [160, 161, 162, 163, 164, 165, 166, 167, 168, 169, 170, 171, 172, 173]}, "removed_lines": {}}, {"6": "guava/src/com/google/common/net/HostAndPort.java", "added": {"1": ["import com.google.common.base.CharMatcher;\n"], "2": ["      checkArgument(\n", "          !portString.startsWith(\"+\") && CharMatcher.ascii().matchesAllOf(portString),\n", "          \"Unparseable port number: %s\",\n", "          hostPortString);\n"]}, "removed": {"2": ["      checkArgument(!portString.startsWith(\"+\"), \"Unparseable port number: %s\", hostPortString);\n"]}, "added_lines": {"1": [23], "2": [194, 195, 196, 197]}, "removed_lines": {"2": [193]}}, {"7": "guava/src/com/google/common/net/InetAddresses.java", "added": {"1": ["   * <p>This method accepts non-ASCII digits, for example {@code \"\uff11\uff19\uff12.\uff11\uff16\uff18.\uff10.\uff11\"} (those are fullwidth\n", "   * characters). That is consistent with {@link InetAddress}, but not with various RFCs. If you\n", "   * want to accept ASCII digits only, you can use something like {@code\n", "   * CharMatcher.ascii().matchesAllOf(ipString)}.\n", "   *\n"], "2": ["   * <p>This method accepts non-ASCII digits, for example {@code \"\uff11\uff19\uff12.\uff11\uff16\uff18.\uff10.\uff11\"} (those are fullwidth\n", "   * characters). That is consistent with {@link InetAddress}, but not with various RFCs. If you\n", "   * want to accept ASCII digits only, you can use something like {@code\n", "   * CharMatcher.ascii().matchesAllOf(ipString)}.\n", "   *\n"], "3": ["   * <p>This method is similar to {@link InetAddresses#forString(String)}, however, it requires that\n", "   * IPv6 addresses are surrounded by square brackets.\n", "   *\n", "   * <p>This method is the inverse of {@link InetAddresses#toUriString(java.net.InetAddress)}.\n", "   * <p>This method accepts non-ASCII digits, for example {@code \"\uff11\uff19\uff12.\uff11\uff16\uff18.\uff10.\uff11\"} (those are fullwidth\n", "   * characters). That is consistent with {@link InetAddress}, but not with various RFCs. If you\n", "   * want to accept ASCII digits only, you can use something like {@code\n", "   * CharMatcher.ascii().matchesAllOf(ipString)}.\n"], "4": ["   * <p>This method accepts non-ASCII digits, for example {@code \"\uff11\uff19\uff12.\uff11\uff16\uff18.\uff10.\uff11\"} (those are fullwidth\n", "   * characters). That is consistent with {@link InetAddress}, but not with various RFCs. If you\n", "   * want to accept ASCII digits only, you can use something like {@code\n", "   * CharMatcher.ascii().matchesAllOf(ipString)}.\n", "   *\n"], "5": ["   * <p>This method accepts non-ASCII digits. That is consistent with {@link InetAddress}, but not\n", "   * with various RFCs. If you want to accept ASCII digits only, you can use something like {@code\n", "   * CharMatcher.ascii().matchesAllOf(ipString)}.\n", "   *\n"], "6": ["   * This method does so by hashing 64 bits of the IPv6 address into {@code 224.0.0.0/3} (64 bits\n"], "7": ["   * <p>NOTE: This method is failsafe for security purposes: ALL IPv6 addresses (except localhost\n"]}, "removed": {"3": ["   * <p>This function is similar to {@link InetAddresses#forString(String)}, however, it requires\n", "   * that IPv6 addresses are surrounded by square brackets.\n", "   * <p>This function is the inverse of {@link InetAddresses#toUriString(java.net.InetAddress)}.\n"], "6": ["   * This function does so by hashing 64 bits of the IPv6 address into {@code 224.0.0.0/3} (64 bits\n"], "7": ["   * <p>NOTE: This function is failsafe for security purposes: ALL IPv6 addresses (except localhost\n"]}, "added_lines": {"1": [137, 138, 139, 140, 141], "2": [162, 163, 164, 165, 166], "3": [515, 516, 517, 518, 520, 521, 522, 523], "4": [567, 568, 569, 570, 571], "5": [867, 868, 869, 870], "6": [898], "7": [908]}, "removed_lines": {"3": [505, 506, 508], "6": [874], "7": [884]}}]}
