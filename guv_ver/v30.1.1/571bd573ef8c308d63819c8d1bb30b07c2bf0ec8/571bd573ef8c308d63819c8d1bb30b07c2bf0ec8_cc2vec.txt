{"id": "571bd573ef8c308d63819c8d1bb30b07c2bf0ec8", "code": [{"0": "android/guava-tests/test/com/google/common/util/concurrent/AbstractScheduledServiceTest.java", "added": {"1": ["import com.google.common.util.concurrent.AbstractScheduledService.Cancellable;\n"], "2": ["import java.util.concurrent.Delayed;\n"], "3": ["      Cancellable unused =\n"], "4": ["                  return new ThrowingScheduledFuture<>();\n"], "5": ["      Cancellable unused =\n"], "6": ["                  return new ThrowingScheduledFuture<>();\n", "    private static final class ThrowingScheduledFuture<V> extends ForwardingFuture<V>\n", "        implements ScheduledFuture<V> {\n", "      @Override\n", "      protected Future<V> delegate() {\n", "        throw new UnsupportedOperationException(\"test should not care about this\");\n", "      }\n", "\n", "      @Override\n", "      public long getDelay(TimeUnit unit) {\n", "        throw new UnsupportedOperationException(\"test should not care about this\");\n", "      }\n", "\n", "      @Override\n", "      public int compareTo(Delayed other) {\n", "        throw new UnsupportedOperationException(\"test should not care about this\");\n", "      }\n", "    }\n", "\n"], "7": ["      Cancellable future = scheduler.schedule(null, Executors.newScheduledThreadPool(10), task);\n"]}, "removed": {"3": ["      Future<?> unused =\n"], "4": ["                  return null;\n"], "5": ["      Future<?> unused =\n"], "6": ["                  return null;\n"], "7": ["      Future<?> future = scheduler.schedule(null, Executors.newScheduledThreadPool(10), task);\n"]}, "added_lines": {"1": [24], "2": [32], "3": [393], "4": [401], "5": [410], "6": [418, 425, 426, 427, 428, 429, 430, 431, 432, 433, 434, 435, 436, 437, 438, 439, 440, 441, 442], "7": [520]}, "removed_lines": {"3": [391], "4": [399], "5": [408], "6": [416], "7": [500]}}, {"1": "android/guava/src/com/google/common/util/concurrent/AbstractScheduledService.java", "added": {"1": ["import static com.google.common.util.concurrent.Futures.immediateCancelledFuture;\n", "import com.google.common.util.concurrent.ForwardingFuture.SimpleForwardingFuture;\n"], "2": ["import java.util.concurrent.ScheduledFuture;\n"], "3": ["        public Cancellable schedule(\n", "          return new FutureAsCancellable<>(\n", "              executor.scheduleWithFixedDelay(task, initialDelay, delay, unit));\n"], "4": ["        public Cancellable schedule(\n", "          return new FutureAsCancellable<>(\n", "              executor.scheduleAtFixedRate(task, initialDelay, period, unit));\n", "    abstract Cancellable schedule(\n"], "5": ["    @NullableDecl private volatile Cancellable runningTask;\n"], "6": ["  interface Cancellable {\n", "    @CanIgnoreReturnValue\n", "    boolean cancel(boolean mayInterruptIfRunning);\n", "\n", "    boolean isCancelled();\n", "  }\n", "\n", "  private static final class FutureAsCancellable<V> extends SimpleForwardingFuture<V>\n", "      implements Cancellable {\n", "    FutureAsCancellable(Future<V> delegate) {\n", "      super(delegate);\n", "    }\n", "  }\n", "\n"], "7": ["    private final class ReschedulableCallable implements Callable<Void> {\n"], "8": ["      private SupplantableFuture cancellationDelegate;\n"], "9": ["      /**\n", "       * Atomically reschedules this task and assigns the new future to {@link\n", "       * #cancellationDelegate}.\n", "       */\n", "      @CanIgnoreReturnValue\n", "      public Cancellable reschedule() {\n", "          return new FutureAsCancellable<>(immediateCancelledFuture());\n", "        Cancellable toReturn;\n", "          toReturn = initializeOrUpdateCancellationDelegate(schedule);\n"], "10": ["          toReturn = new FutureAsCancellable<>(immediateCancelledFuture());\n"], "11": ["        return toReturn;\n", "      }\n", "\n", "      @GuardedBy(\"lock\")\n", "      /*\n", "       * The GuardedBy checker warns us that we're not holding cancellationDelegate.lock. But in\n", "       * fact we are holding it because it is the same as this.lock, which we know we are holding,\n", "       * thanks to @GuardedBy above. (cancellationDelegate.lock is initialized to this.lock in the\n", "       * call to `new SupplantableFuture` below.)\n", "       */\n", "      @SuppressWarnings(\"GuardedBy\")\n", "      private Cancellable initializeOrUpdateCancellationDelegate(Schedule schedule) {\n", "        if (cancellationDelegate == null) {\n", "          return cancellationDelegate = new SupplantableFuture(lock, submitToExecutor(schedule));\n", "        }\n", "        if (!cancellationDelegate.currentFuture.isCancelled()) {\n", "          cancellationDelegate.currentFuture = submitToExecutor(schedule);\n", "        }\n", "        return cancellationDelegate;\n", "      }\n", "\n", "      private ScheduledFuture<Void> submitToExecutor(Schedule schedule) {\n", "        return executor.schedule(this, schedule.delay, schedule.unit);\n", "      }\n", "    }\n", "\n", "    /**\n", "     * Contains the most recently submitted {@code Future}, which may be cancelled or updated,\n", "     * always under a lock.\n", "     */\n", "    private static final class SupplantableFuture implements Cancellable {\n", "      private final ReentrantLock lock;\n", "\n", "      @GuardedBy(\"lock\")\n", "      private Future<Void> currentFuture;\n", "\n", "      SupplantableFuture(ReentrantLock lock, Future<Void> currentFuture) {\n", "        this.lock = lock;\n", "        this.currentFuture = currentFuture;\n", "        /*\n", "         * Lock to ensure that a task cannot be rescheduled while a cancel is ongoing.\n", "         *\n", "         * In theory, cancel() could execute arbitrary listeners -- bad to do while holding a lock.\n", "         * However, we don't expose currentFuture to users, so they can't attach listeners. And the\n", "         * Future might not even be a ListenableFuture, just a plain Future. That said, similar\n", "         * problems can exist with methods like FutureTask.done(), not to mention slow calls to\n", "         * Thread.interrupt() (as discussed in InterruptibleTask). At the end of the day, it's\n", "         * unlikely that cancel() will be slow, so we can probably get away with calling it while\n", "         * holding a lock. Still, it would be nice to avoid somehow.\n", "         */\n"], "12": ["    final Cancellable schedule(\n", "      return new ReschedulableCallable(service, executor, runnable).reschedule();\n"]}, "removed": {"3": ["        public Future<?> schedule(\n", "          return executor.scheduleWithFixedDelay(task, initialDelay, delay, unit);\n"], "4": ["        public Future<?> schedule(\n", "          return executor.scheduleAtFixedRate(task, initialDelay, period, unit);\n", "    abstract Future<?> schedule(\n"], "5": ["    @NullableDecl private volatile Future<?> runningTask;\n"], "7": ["    private class ReschedulableCallable extends ForwardingFuture<Void> implements Callable<Void> {\n"], "8": ["      private Future<Void> currentFuture;\n"], "9": ["      /** Atomically reschedules this task and assigns the new future to {@link #currentFuture}. */\n", "      public void reschedule() {\n", "          return;\n", "          if (currentFuture == null || !currentFuture.isCancelled()) {\n", "            currentFuture = executor.schedule(this, schedule.delay, schedule.unit);\n", "          }\n"], "11": ["      // N.B. Only protect cancel and isCancelled because those are the only methods that are\n", "      // invoked by the AbstractScheduledService.\n", "        // Ensure that a task cannot be rescheduled while a cancel is ongoing.\n"], "12": ["\n", "      @Override\n", "      protected Future<Void> delegate() {\n", "        throw new UnsupportedOperationException(\n", "            \"Only cancel and isCancelled is supported by this future\");\n", "      }\n", "    final Future<?> schedule(\n", "      ReschedulableCallable task = new ReschedulableCallable(service, executor, runnable);\n", "      task.reschedule();\n", "      return task;\n"]}, "added_lines": {"1": [19, 24], "2": [33], "3": [132, 134, 135], "4": [155, 157, 158, 164], "5": [178], "6": [438, 439, 440, 441, 442, 443, 444, 445, 446, 447, 448, 449, 450, 451], "7": [463], "8": [487], "9": [503, 504, 505, 506, 507, 508, 515, 522, 525], "10": [536], "11": [544, 545, 546, 547, 548, 549, 550, 551, 552, 553, 554, 555, 556, 557, 558, 559, 560, 561, 562, 563, 564, 565, 566, 567, 568, 569, 570, 571, 572, 573, 574, 575, 576, 577, 578, 579, 580, 581, 582, 587, 588, 589, 590, 591, 592, 593, 594, 595, 596, 597], "12": [618, 620]}, "removed_lines": {"3": [129, 131], "4": [151, 153, 159], "5": [173], "7": [444], "8": [468], "9": [484, 485, 492, 501, 502, 503], "11": [523, 524, 527], "12": [545, 546, 547, 548, 549, 550, 554, 556, 557, 558]}}, {"2": "guava-tests/test/com/google/common/util/concurrent/AbstractScheduledServiceTest.java", "added": {"1": ["import com.google.common.util.concurrent.AbstractScheduledService.Cancellable;\n"], "2": ["import java.util.concurrent.Delayed;\n"], "3": ["      Cancellable unused =\n"], "4": ["                  return new ThrowingScheduledFuture<>();\n"], "5": ["      Cancellable unused =\n"], "6": ["                  return new ThrowingScheduledFuture<>();\n", "    private static final class ThrowingScheduledFuture<V> extends ForwardingFuture<V>\n", "        implements ScheduledFuture<V> {\n", "      @Override\n", "      protected Future<V> delegate() {\n", "        throw new UnsupportedOperationException(\"test should not care about this\");\n", "      }\n", "\n", "      @Override\n", "      public long getDelay(TimeUnit unit) {\n", "        throw new UnsupportedOperationException(\"test should not care about this\");\n", "      }\n", "\n", "      @Override\n", "      public int compareTo(Delayed other) {\n", "        throw new UnsupportedOperationException(\"test should not care about this\");\n", "      }\n", "    }\n", "\n"], "7": ["      Cancellable future = scheduler.schedule(null, Executors.newScheduledThreadPool(10), task);\n"]}, "removed": {"3": ["      Future<?> unused =\n"], "4": ["                  return null;\n"], "5": ["      Future<?> unused =\n"], "6": ["                  return null;\n"], "7": ["      Future<?> future = scheduler.schedule(null, Executors.newScheduledThreadPool(10), task);\n"]}, "added_lines": {"1": [24], "2": [32], "3": [393], "4": [401], "5": [410], "6": [418, 425, 426, 427, 428, 429, 430, 431, 432, 433, 434, 435, 436, 437, 438, 439, 440, 441, 442], "7": [520]}, "removed_lines": {"3": [391], "4": [399], "5": [408], "6": [416], "7": [500]}}, {"3": "guava/src/com/google/common/util/concurrent/AbstractScheduledService.java", "added": {"1": ["import static com.google.common.util.concurrent.Futures.immediateCancelledFuture;\n", "import com.google.common.util.concurrent.ForwardingFuture.SimpleForwardingFuture;\n"], "2": ["import java.util.concurrent.ScheduledFuture;\n"], "3": ["        public Cancellable schedule(\n", "          return new FutureAsCancellable<>(\n", "              executor.scheduleWithFixedDelay(task, initialDelay, delay, unit));\n"], "4": ["        public Cancellable schedule(\n", "          return new FutureAsCancellable<>(\n", "              executor.scheduleAtFixedRate(task, initialDelay, period, unit));\n", "    abstract Cancellable schedule(\n"], "5": ["    private volatile @Nullable Cancellable runningTask;\n"], "6": ["  interface Cancellable {\n", "    @CanIgnoreReturnValue\n", "    boolean cancel(boolean mayInterruptIfRunning);\n", "\n", "    boolean isCancelled();\n", "  }\n", "\n", "  private static final class FutureAsCancellable<V> extends SimpleForwardingFuture<V>\n", "      implements Cancellable {\n", "    FutureAsCancellable(Future<V> delegate) {\n", "      super(delegate);\n", "    }\n", "  }\n", "\n"], "7": ["    private final class ReschedulableCallable implements Callable<Void> {\n"], "8": ["      private @Nullable SupplantableFuture cancellationDelegate;\n"], "9": ["      /**\n", "       * Atomically reschedules this task and assigns the new future to {@link\n", "       * #cancellationDelegate}.\n", "       */\n", "      @CanIgnoreReturnValue\n", "      public Cancellable reschedule() {\n", "          return new FutureAsCancellable<>(immediateCancelledFuture());\n", "        Cancellable toReturn;\n", "          toReturn = initializeOrUpdateCancellationDelegate(schedule);\n"], "10": ["          toReturn = new FutureAsCancellable<>(immediateCancelledFuture());\n"], "11": ["        return toReturn;\n", "      }\n", "\n", "      @GuardedBy(\"lock\")\n", "      /*\n", "       * The GuardedBy checker warns us that we're not holding cancellationDelegate.lock. But in\n", "       * fact we are holding it because it is the same as this.lock, which we know we are holding,\n", "       * thanks to @GuardedBy above. (cancellationDelegate.lock is initialized to this.lock in the\n", "       * call to `new SupplantableFuture` below.)\n", "       */\n", "      @SuppressWarnings(\"GuardedBy\")\n", "      private Cancellable initializeOrUpdateCancellationDelegate(Schedule schedule) {\n", "        if (cancellationDelegate == null) {\n", "          return cancellationDelegate = new SupplantableFuture(lock, submitToExecutor(schedule));\n", "        }\n", "        if (!cancellationDelegate.currentFuture.isCancelled()) {\n", "          cancellationDelegate.currentFuture = submitToExecutor(schedule);\n", "        }\n", "        return cancellationDelegate;\n", "      }\n", "\n", "      private ScheduledFuture<Void> submitToExecutor(Schedule schedule) {\n", "        return executor.schedule(this, schedule.delay, schedule.unit);\n", "      }\n", "    }\n", "\n", "    /**\n", "     * Contains the most recently submitted {@code Future}, which may be cancelled or updated,\n", "     * always under a lock.\n", "     */\n", "    private static final class SupplantableFuture implements Cancellable {\n", "      private final ReentrantLock lock;\n", "\n", "      @GuardedBy(\"lock\")\n", "      private Future<Void> currentFuture;\n", "\n", "      SupplantableFuture(ReentrantLock lock, Future<Void> currentFuture) {\n", "        this.lock = lock;\n", "        this.currentFuture = currentFuture;\n", "        /*\n", "         * Lock to ensure that a task cannot be rescheduled while a cancel is ongoing.\n", "         *\n", "         * In theory, cancel() could execute arbitrary listeners -- bad to do while holding a lock.\n", "         * However, we don't expose currentFuture to users, so they can't attach listeners. And the\n", "         * Future might not even be a ListenableFuture, just a plain Future. That said, similar\n", "         * problems can exist with methods like FutureTask.done(), not to mention slow calls to\n", "         * Thread.interrupt() (as discussed in InterruptibleTask). At the end of the day, it's\n", "         * unlikely that cancel() will be slow, so we can probably get away with calling it while\n", "         * holding a lock. Still, it would be nice to avoid somehow.\n", "         */\n"], "12": ["    final Cancellable schedule(\n", "      return new ReschedulableCallable(service, executor, runnable).reschedule();\n"]}, "removed": {"3": ["        public Future<?> schedule(\n", "          return executor.scheduleWithFixedDelay(task, initialDelay, delay, unit);\n"], "4": ["        public Future<?> schedule(\n", "          return executor.scheduleAtFixedRate(task, initialDelay, period, unit);\n", "    abstract Future<?> schedule(\n"], "5": ["    private volatile @Nullable Future<?> runningTask;\n"], "7": ["    private class ReschedulableCallable extends ForwardingFuture<Void> implements Callable<Void> {\n"], "8": ["      private @Nullable Future<Void> currentFuture;\n"], "9": ["      /** Atomically reschedules this task and assigns the new future to {@link #currentFuture}. */\n", "      public void reschedule() {\n", "          return;\n", "          if (currentFuture == null || !currentFuture.isCancelled()) {\n", "            currentFuture = executor.schedule(this, schedule.delay, schedule.unit);\n", "          }\n"], "11": ["      // N.B. Only protect cancel and isCancelled because those are the only methods that are\n", "      // invoked by the AbstractScheduledService.\n", "        // Ensure that a task cannot be rescheduled while a cancel is ongoing.\n"], "12": ["\n", "      @Override\n", "      protected Future<Void> delegate() {\n", "        throw new UnsupportedOperationException(\n", "            \"Only cancel and isCancelled is supported by this future\");\n", "      }\n", "    final Future<?> schedule(\n", "      ReschedulableCallable task = new ReschedulableCallable(service, executor, runnable);\n", "      task.reschedule();\n", "      return task;\n"]}, "added_lines": {"1": [19, 25], "2": [35], "3": [148, 150, 151], "4": [184, 186, 187, 193], "5": [207], "6": [479, 480, 481, 482, 483, 484, 485, 486, 487, 488, 489, 490, 491, 492], "7": [504], "8": [527], "9": [543, 544, 545, 546, 547, 548, 555, 562, 565], "10": [576], "11": [584, 585, 586, 587, 588, 589, 590, 591, 592, 593, 594, 595, 596, 597, 598, 599, 600, 601, 602, 603, 604, 605, 606, 607, 608, 609, 610, 611, 612, 613, 614, 615, 616, 617, 618, 619, 620, 621, 622, 627, 628, 629, 630, 631, 632, 633, 634, 635, 636, 637], "12": [658, 660]}, "removed_lines": {"3": [145, 147], "4": [180, 182, 188], "5": [202], "7": [485], "8": [508], "9": [524, 525, 532, 541, 542, 543], "11": [563, 564, 567], "12": [585, 586, 587, 588, 589, 590, 594, 596, 597, 598]}}]}
