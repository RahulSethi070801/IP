{
    "addition": {
        "19": "import static com.google.common.util.concurrent.Futures.immediateCancelledFuture;\n",
        "25": "import com.google.common.util.concurrent.ForwardingFuture.SimpleForwardingFuture;\n",
        "35": "import java.util.concurrent.ScheduledFuture;\n",
        "148": "        public Cancellable schedule(\n",
        "150": "          return new FutureAsCancellable<>(\n",
        "151": "              executor.scheduleWithFixedDelay(task, initialDelay, delay, unit));\n",
        "184": "        public Cancellable schedule(\n",
        "186": "          return new FutureAsCancellable<>(\n",
        "187": "              executor.scheduleAtFixedRate(task, initialDelay, period, unit));\n",
        "193": "    abstract Cancellable schedule(\n",
        "207": "    private volatile @Nullable Cancellable runningTask;\n",
        "479": "  interface Cancellable {\n",
        "480": "    @CanIgnoreReturnValue\n",
        "481": "    boolean cancel(boolean mayInterruptIfRunning);\n",
        "482": "\n",
        "483": "    boolean isCancelled();\n",
        "484": "  }\n",
        "485": "\n",
        "486": "  private static final class FutureAsCancellable<V> extends SimpleForwardingFuture<V>\n",
        "487": "      implements Cancellable {\n",
        "488": "    FutureAsCancellable(Future<V> delegate) {\n",
        "489": "      super(delegate);\n",
        "490": "    }\n",
        "491": "  }\n",
        "492": "\n",
        "504": "    private final class ReschedulableCallable implements Callable<Void> {\n",
        "527": "      private @Nullable SupplantableFuture cancellationDelegate;\n",
        "543": "      /**\n",
        "544": "       * Atomically reschedules this task and assigns the new future to {@link\n",
        "545": "       * #cancellationDelegate}.\n",
        "546": "       */\n",
        "547": "      @CanIgnoreReturnValue\n",
        "548": "      public Cancellable reschedule() {\n",
        "555": "          return new FutureAsCancellable<>(immediateCancelledFuture());\n",
        "562": "        Cancellable toReturn;\n",
        "565": "          toReturn = initializeOrUpdateCancellationDelegate(schedule);\n",
        "576": "          toReturn = new FutureAsCancellable<>(immediateCancelledFuture());\n",
        "584": "        return toReturn;\n",
        "585": "      }\n",
        "586": "\n",
        "587": "      @GuardedBy(\"lock\")\n",
        "588": "      /*\n",
        "589": "       * The GuardedBy checker warns us that we're not holding cancellationDelegate.lock. But in\n",
        "590": "       * fact we are holding it because it is the same as this.lock, which we know we are holding,\n",
        "591": "       * thanks to @GuardedBy above. (cancellationDelegate.lock is initialized to this.lock in the\n",
        "592": "       * call to `new SupplantableFuture` below.)\n",
        "593": "       */\n",
        "594": "      @SuppressWarnings(\"GuardedBy\")\n",
        "595": "      private Cancellable initializeOrUpdateCancellationDelegate(Schedule schedule) {\n",
        "596": "        if (cancellationDelegate == null) {\n",
        "597": "          return cancellationDelegate = new SupplantableFuture(lock, submitToExecutor(schedule));\n",
        "598": "        }\n",
        "599": "        if (!cancellationDelegate.currentFuture.isCancelled()) {\n",
        "600": "          cancellationDelegate.currentFuture = submitToExecutor(schedule);\n",
        "601": "        }\n",
        "602": "        return cancellationDelegate;\n",
        "603": "      }\n",
        "604": "\n",
        "605": "      private ScheduledFuture<Void> submitToExecutor(Schedule schedule) {\n",
        "606": "        return executor.schedule(this, schedule.delay, schedule.unit);\n",
        "607": "      }\n",
        "608": "    }\n",
        "609": "\n",
        "610": "    /**\n",
        "611": "     * Contains the most recently submitted {@code Future}, which may be cancelled or updated,\n",
        "612": "     * always under a lock.\n",
        "613": "     */\n",
        "614": "    private static final class SupplantableFuture implements Cancellable {\n",
        "615": "      private final ReentrantLock lock;\n",
        "616": "\n",
        "617": "      @GuardedBy(\"lock\")\n",
        "618": "      private Future<Void> currentFuture;\n",
        "619": "\n",
        "620": "      SupplantableFuture(ReentrantLock lock, Future<Void> currentFuture) {\n",
        "621": "        this.lock = lock;\n",
        "622": "        this.currentFuture = currentFuture;\n",
        "627": "        /*\n",
        "628": "         * Lock to ensure that a task cannot be rescheduled while a cancel is ongoing.\n",
        "629": "         *\n",
        "630": "         * In theory, cancel() could execute arbitrary listeners -- bad to do while holding a lock.\n",
        "631": "         * However, we don't expose currentFuture to users, so they can't attach listeners. And the\n",
        "632": "         * Future might not even be a ListenableFuture, just a plain Future. That said, similar\n",
        "633": "         * problems can exist with methods like FutureTask.done(), not to mention slow calls to\n",
        "634": "         * Thread.interrupt() (as discussed in InterruptibleTask). At the end of the day, it's\n",
        "635": "         * unlikely that cancel() will be slow, so we can probably get away with calling it while\n",
        "636": "         * holding a lock. Still, it would be nice to avoid somehow.\n",
        "637": "         */\n",
        "658": "    final Cancellable schedule(\n",
        "660": "      return new ReschedulableCallable(service, executor, runnable).reschedule();\n"
    },
    "removed": {
        "145": "        public Future<?> schedule(\n",
        "147": "          return executor.scheduleWithFixedDelay(task, initialDelay, delay, unit);\n",
        "180": "        public Future<?> schedule(\n",
        "182": "          return executor.scheduleAtFixedRate(task, initialDelay, period, unit);\n",
        "188": "    abstract Future<?> schedule(\n",
        "202": "    private volatile @Nullable Future<?> runningTask;\n",
        "485": "    private class ReschedulableCallable extends ForwardingFuture<Void> implements Callable<Void> {\n",
        "508": "      private @Nullable Future<Void> currentFuture;\n",
        "524": "      /** Atomically reschedules this task and assigns the new future to {@link #currentFuture}. */\n",
        "525": "      public void reschedule() {\n",
        "532": "          return;\n",
        "541": "          if (currentFuture == null || !currentFuture.isCancelled()) {\n",
        "542": "            currentFuture = executor.schedule(this, schedule.delay, schedule.unit);\n",
        "543": "          }\n",
        "563": "      // N.B. Only protect cancel and isCancelled because those are the only methods that are\n",
        "564": "      // invoked by the AbstractScheduledService.\n",
        "567": "        // Ensure that a task cannot be rescheduled while a cancel is ongoing.\n",
        "585": "\n",
        "586": "      @Override\n",
        "587": "      protected Future<Void> delegate() {\n",
        "588": "        throw new UnsupportedOperationException(\n",
        "589": "            \"Only cancel and isCancelled is supported by this future\");\n",
        "590": "      }\n",
        "594": "    final Future<?> schedule(\n",
        "596": "      ReschedulableCallable task = new ReschedulableCallable(service, executor, runnable);\n",
        "597": "      task.reschedule();\n",
        "598": "      return task;\n"
    }
}