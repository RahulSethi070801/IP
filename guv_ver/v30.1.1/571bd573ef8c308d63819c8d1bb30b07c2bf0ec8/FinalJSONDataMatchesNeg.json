[{"func":{"oldfunccode":"","newfunccode":"571bd573ef8c308d63819c8d1bb30b07c2bf0ec8/Codes_neg/Match_newfunccode_571bd573ef8c308d63819c8d1bb30b07c2bf0ec8_1.txt","newdoc":"","newJdoc":"571bd573ef8c308d63819c8d1bb30b07c2bf0ec8/Codes_neg/Match_newfuncnewJdoc_571bd573ef8c308d63819c8d1bb30b07c2bf0ec8_1.txt","olddoc":"","oldJdoc":"","path":"/home/pritish/Documents/IP work/guv_ver/v30.1.1/571bd573ef8c308d63819c8d1bb30b07c2bf0ec8/AbstractScheduledService","pathinproj":"android/guava/src/com/google/common/util/concurrent/AbstractScheduledService.java","addlines":[193,164],"dellines":[],"addcode":["    abstract Cancellable schedule(\n","    abstract Cancellable schedule(\n"],"delcode":[],"methodSig":" abstract Cancellable schedule(AbstractService service, ScheduledExecutorService executor, Runnable runnable)"},"doc":{"oldfunccode":"571bd573ef8c308d63819c8d1bb30b07c2bf0ec8/Codes_neg/Match_olddocfunccode_571bd573ef8c308d63819c8d1bb30b07c2bf0ec8_1.txt","newfunccode":"571bd573ef8c308d63819c8d1bb30b07c2bf0ec8/Codes_neg/Match_newdocfunccode_571bd573ef8c308d63819c8d1bb30b07c2bf0ec8_1.txt","newdoc":"\n         * Lock to ensure that a task cannot be rescheduled while a cancel is ongoing.\n         *\n         * In theory, cancel() could execute arbitrary listeners -- bad to do while holding a lock.\n         * However, we don't expose currentFuture to users, so they can't attach listeners. And the\n         * Future might not even be a ListenableFuture, just a plain Future. That said, similar\n         * problems can exist with methods like FutureTask.done(), not to mention slow calls to\n         * Thread.interrupt() (as discussed in InterruptibleTask). At the end of the day, it's\n         * unlikely that cancel() will be slow, so we can probably get away with calling it while\n         * holding a lock. Still, it would be nice to avoid somehow.\n         \n","newJdoc":"","olddoc":" Ensure that a task cannot be rescheduled while a cancel is ongoing.\n","oldJdoc":"571bd573ef8c308d63819c8d1bb30b07c2bf0ec8/Codes_neg/Match_olddocJdoc_571bd573ef8c308d63819c8d1bb30b07c2bf0ec8_1.txt","path":"/home/pritish/Documents/IP work/guv_ver/v30.1.1/571bd573ef8c308d63819c8d1bb30b07c2bf0ec8/AbstractScheduledService","pathinproj":"android/guava/src/com/google/common/util/concurrent/AbstractScheduledService.java","addlines":[],"dellines":[564,524],"addcode":[],"delcode":["      // invoked by the AbstractScheduledService.\n","      // invoked by the AbstractScheduledService.\n"],"methodSig":"public boolean cancel(boolean mayInterruptIfRunning)"},"id":1,"flag":1,"commit":"571bd573ef8c308d63819c8d1bb30b07c2bf0ec8"},{"func":{"oldfunccode":"","newfunccode":"571bd573ef8c308d63819c8d1bb30b07c2bf0ec8/Codes_neg/Match_newfunccode_571bd573ef8c308d63819c8d1bb30b07c2bf0ec8_2.txt","newdoc":" We reschedule ourselves with a lock held for two reasons. 1. we want to make sure that\n cancel calls cancel on the correct future. 2. we want to make sure that the assignment\n to currentFuture doesn't race with itself so that currentFuture is assigned in the\n invoke the callback outside the lock, prevents some shenanigans.\n correct order.\n If an exception is thrown by the subclass then we need to make sure that the service\n notices and transitions to the FAILED state. We do it by calling notifyFailed directly\n because the service does not monitor the state of the future so if the exception is not\n caught and forwarded to the service the task would stop executing but the service would\n have no idea.\n TODO(lukes): consider building everything in terms of ListenableScheduledFuture then\n the AbstractService could monitor the future directly. Rescheduling is still hard...\n but it would help with some of these lock ordering issues.\n Call notifyFailed outside the lock to avoid lock ordering issues.\n","newJdoc":"571bd573ef8c308d63819c8d1bb30b07c2bf0ec8/Codes_neg/Match_newfuncnewJdoc_571bd573ef8c308d63819c8d1bb30b07c2bf0ec8_2.txt","olddoc":"","oldJdoc":"","path":"/home/pritish/Documents/IP work/guv_ver/v30.1.1/571bd573ef8c308d63819c8d1bb30b07c2bf0ec8/AbstractScheduledService","pathinproj":"android/guava/src/com/google/common/util/concurrent/AbstractScheduledService.java","addlines":[544,576,545,515,547,548,584,585,522,555,525,562,565,536,507,508],"dellines":[],"addcode":["      @CanIgnoreReturnValue\n","      public Cancellable reschedule() {\n","          return new FutureAsCancellable<>(immediateCancelledFuture());\n","        Cancellable toReturn;\n","          toReturn = initializeOrUpdateCancellationDelegate(schedule);\n","          toReturn = new FutureAsCancellable<>(immediateCancelledFuture());\n","        return toReturn;\n","      }\n","      @CanIgnoreReturnValue\n","      public Cancellable reschedule() {\n","          return new FutureAsCancellable<>(immediateCancelledFuture());\n","        Cancellable toReturn;\n","          toReturn = initializeOrUpdateCancellationDelegate(schedule);\n","          toReturn = new FutureAsCancellable<>(immediateCancelledFuture());\n","        return toReturn;\n","      }\n"],"delcode":[],"methodSig":"public Cancellable reschedule()"},"doc":{"oldfunccode":"571bd573ef8c308d63819c8d1bb30b07c2bf0ec8/Codes_neg/Match_olddocfunccode_571bd573ef8c308d63819c8d1bb30b07c2bf0ec8_2.txt","newfunccode":"571bd573ef8c308d63819c8d1bb30b07c2bf0ec8/Codes_neg/Match_newdocfunccode_571bd573ef8c308d63819c8d1bb30b07c2bf0ec8_2.txt","newdoc":"\n         * Lock to ensure that a task cannot be rescheduled while a cancel is ongoing.\n         *\n         * In theory, cancel() could execute arbitrary listeners -- bad to do while holding a lock.\n         * However, we don't expose currentFuture to users, so they can't attach listeners. And the\n         * Future might not even be a ListenableFuture, just a plain Future. That said, similar\n         * problems can exist with methods like FutureTask.done(), not to mention slow calls to\n         * Thread.interrupt() (as discussed in InterruptibleTask). At the end of the day, it's\n         * unlikely that cancel() will be slow, so we can probably get away with calling it while\n         * holding a lock. Still, it would be nice to avoid somehow.\n         \n\n         * Lock to ensure that a task cannot be rescheduled while a cancel is ongoing.\n         *\n         * In theory, cancel() could execute arbitrary listeners -- bad to do while holding a lock.\n         * However, we don't expose currentFuture to users, so they can't attach listeners. And the\n         * Future might not even be a ListenableFuture, just a plain Future. That said, similar\n         * problems can exist with methods like FutureTask.done(), not to mention slow calls to\n         * Thread.interrupt() (as discussed in InterruptibleTask). At the end of the day, it's\n         * unlikely that cancel() will be slow, so we can probably get away with calling it while\n         * holding a lock. Still, it would be nice to avoid somehow.\n         \n","newJdoc":"","olddoc":" Ensure that a task cannot be rescheduled while a cancel is ongoing.\n Ensure that a task cannot be rescheduled while a cancel is ongoing.\n","oldJdoc":"571bd573ef8c308d63819c8d1bb30b07c2bf0ec8/Codes_neg/Match_olddocJdoc_571bd573ef8c308d63819c8d1bb30b07c2bf0ec8_2.txt","path":"/home/pritish/Documents/IP work/guv_ver/v30.1.1/571bd573ef8c308d63819c8d1bb30b07c2bf0ec8/AbstractScheduledService","pathinproj":"android/guava/src/com/google/common/util/concurrent/AbstractScheduledService.java","addlines":[],"dellines":[564,524],"addcode":[],"delcode":["      // invoked by the AbstractScheduledService.\n","      // invoked by the AbstractScheduledService.\n"],"methodSig":"public boolean cancel(boolean mayInterruptIfRunning)"},"id":1,"flag":1,"commit":"571bd573ef8c308d63819c8d1bb30b07c2bf0ec8"}]