{
    "addition": {
        "19": "import static com.google.common.util.concurrent.Futures.immediateCancelledFuture;\n",
        "24": "import com.google.common.util.concurrent.ForwardingFuture.SimpleForwardingFuture;\n",
        "33": "import java.util.concurrent.ScheduledFuture;\n",
        "132": "        public Cancellable schedule(\n",
        "134": "          return new FutureAsCancellable<>(\n",
        "135": "              executor.scheduleWithFixedDelay(task, initialDelay, delay, unit));\n",
        "155": "        public Cancellable schedule(\n",
        "157": "          return new FutureAsCancellable<>(\n",
        "158": "              executor.scheduleAtFixedRate(task, initialDelay, period, unit));\n",
        "164": "    abstract Cancellable schedule(\n",
        "178": "    @NullableDecl private volatile Cancellable runningTask;\n",
        "438": "  interface Cancellable {\n",
        "439": "    @CanIgnoreReturnValue\n",
        "440": "    boolean cancel(boolean mayInterruptIfRunning);\n",
        "441": "\n",
        "442": "    boolean isCancelled();\n",
        "443": "  }\n",
        "444": "\n",
        "445": "  private static final class FutureAsCancellable<V> extends SimpleForwardingFuture<V>\n",
        "446": "      implements Cancellable {\n",
        "447": "    FutureAsCancellable(Future<V> delegate) {\n",
        "448": "      super(delegate);\n",
        "449": "    }\n",
        "450": "  }\n",
        "451": "\n",
        "463": "    private final class ReschedulableCallable implements Callable<Void> {\n",
        "487": "      private SupplantableFuture cancellationDelegate;\n",
        "503": "      /**\n",
        "504": "       * Atomically reschedules this task and assigns the new future to {@link\n",
        "505": "       * #cancellationDelegate}.\n",
        "506": "       */\n",
        "507": "      @CanIgnoreReturnValue\n",
        "508": "      public Cancellable reschedule() {\n",
        "515": "          return new FutureAsCancellable<>(immediateCancelledFuture());\n",
        "522": "        Cancellable toReturn;\n",
        "525": "          toReturn = initializeOrUpdateCancellationDelegate(schedule);\n",
        "536": "          toReturn = new FutureAsCancellable<>(immediateCancelledFuture());\n",
        "544": "        return toReturn;\n",
        "545": "      }\n",
        "546": "\n",
        "547": "      @GuardedBy(\"lock\")\n",
        "548": "      /*\n",
        "549": "       * The GuardedBy checker warns us that we're not holding cancellationDelegate.lock. But in\n",
        "550": "       * fact we are holding it because it is the same as this.lock, which we know we are holding,\n",
        "551": "       * thanks to @GuardedBy above. (cancellationDelegate.lock is initialized to this.lock in the\n",
        "552": "       * call to `new SupplantableFuture` below.)\n",
        "553": "       */\n",
        "554": "      @SuppressWarnings(\"GuardedBy\")\n",
        "555": "      private Cancellable initializeOrUpdateCancellationDelegate(Schedule schedule) {\n",
        "556": "        if (cancellationDelegate == null) {\n",
        "557": "          return cancellationDelegate = new SupplantableFuture(lock, submitToExecutor(schedule));\n",
        "558": "        }\n",
        "559": "        if (!cancellationDelegate.currentFuture.isCancelled()) {\n",
        "560": "          cancellationDelegate.currentFuture = submitToExecutor(schedule);\n",
        "561": "        }\n",
        "562": "        return cancellationDelegate;\n",
        "563": "      }\n",
        "564": "\n",
        "565": "      private ScheduledFuture<Void> submitToExecutor(Schedule schedule) {\n",
        "566": "        return executor.schedule(this, schedule.delay, schedule.unit);\n",
        "567": "      }\n",
        "568": "    }\n",
        "569": "\n",
        "570": "    /**\n",
        "571": "     * Contains the most recently submitted {@code Future}, which may be cancelled or updated,\n",
        "572": "     * always under a lock.\n",
        "573": "     */\n",
        "574": "    private static final class SupplantableFuture implements Cancellable {\n",
        "575": "      private final ReentrantLock lock;\n",
        "576": "\n",
        "577": "      @GuardedBy(\"lock\")\n",
        "578": "      private Future<Void> currentFuture;\n",
        "579": "\n",
        "580": "      SupplantableFuture(ReentrantLock lock, Future<Void> currentFuture) {\n",
        "581": "        this.lock = lock;\n",
        "582": "        this.currentFuture = currentFuture;\n",
        "587": "        /*\n",
        "588": "         * Lock to ensure that a task cannot be rescheduled while a cancel is ongoing.\n",
        "589": "         *\n",
        "590": "         * In theory, cancel() could execute arbitrary listeners -- bad to do while holding a lock.\n",
        "591": "         * However, we don't expose currentFuture to users, so they can't attach listeners. And the\n",
        "592": "         * Future might not even be a ListenableFuture, just a plain Future. That said, similar\n",
        "593": "         * problems can exist with methods like FutureTask.done(), not to mention slow calls to\n",
        "594": "         * Thread.interrupt() (as discussed in InterruptibleTask). At the end of the day, it's\n",
        "595": "         * unlikely that cancel() will be slow, so we can probably get away with calling it while\n",
        "596": "         * holding a lock. Still, it would be nice to avoid somehow.\n",
        "597": "         */\n",
        "618": "    final Cancellable schedule(\n",
        "620": "      return new ReschedulableCallable(service, executor, runnable).reschedule();\n"
    },
    "removed": {
        "129": "        public Future<?> schedule(\n",
        "131": "          return executor.scheduleWithFixedDelay(task, initialDelay, delay, unit);\n",
        "151": "        public Future<?> schedule(\n",
        "153": "          return executor.scheduleAtFixedRate(task, initialDelay, period, unit);\n",
        "159": "    abstract Future<?> schedule(\n",
        "173": "    @NullableDecl private volatile Future<?> runningTask;\n",
        "444": "    private class ReschedulableCallable extends ForwardingFuture<Void> implements Callable<Void> {\n",
        "468": "      private Future<Void> currentFuture;\n",
        "484": "      /** Atomically reschedules this task and assigns the new future to {@link #currentFuture}. */\n",
        "485": "      public void reschedule() {\n",
        "492": "          return;\n",
        "501": "          if (currentFuture == null || !currentFuture.isCancelled()) {\n",
        "502": "            currentFuture = executor.schedule(this, schedule.delay, schedule.unit);\n",
        "503": "          }\n",
        "523": "      // N.B. Only protect cancel and isCancelled because those are the only methods that are\n",
        "524": "      // invoked by the AbstractScheduledService.\n",
        "527": "        // Ensure that a task cannot be rescheduled while a cancel is ongoing.\n",
        "545": "\n",
        "546": "      @Override\n",
        "547": "      protected Future<Void> delegate() {\n",
        "548": "        throw new UnsupportedOperationException(\n",
        "549": "            \"Only cancel and isCancelled is supported by this future\");\n",
        "550": "      }\n",
        "554": "    final Future<?> schedule(\n",
        "556": "      ReschedulableCallable task = new ReschedulableCallable(service, executor, runnable);\n",
        "557": "      task.reschedule();\n",
        "558": "      return task;\n"
    }
}