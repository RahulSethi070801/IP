{"id": "e2f4eba6369abc8f1e5790304d8374807ada8027", "code": [{"0": "android/guava-tests/test/com/google/common/math/StatsAccumulatorTest.java", "added": {"1": ["  private StatsAccumulator manyValuesAccumulatorByAddAllStatsAccumulator;\n"], "2": ["    manyValuesAccumulatorByAddAllStatsAccumulator = new StatsAccumulator();\n", "    manyValuesAccumulatorByAddAllStatsAccumulator.addAll(\n", "        statsAccumulatorOf(MANY_VALUES.subList(0, MANY_VALUES.size() / 2)));\n", "    manyValuesAccumulatorByAddAllStatsAccumulator.addAll(\n", "        statsAccumulatorOf(MANY_VALUES.subList(MANY_VALUES.size() / 2, MANY_VALUES.size())));\n", "\n"], "3": ["  private static StatsAccumulator statsAccumulatorOf(Iterable<? extends Number> values) {\n", "    StatsAccumulator accumulator = new StatsAccumulator();\n", "    accumulator.addAll(values);\n", "    return accumulator;\n", "  }\n", "\n"], "4": ["    assertThat(manyValuesAccumulatorByAddAllStatsAccumulator.count()).isEqualTo(MANY_VALUES_COUNT);\n"], "5": ["    assertThat(manyValuesAccumulatorByAddAllStatsAccumulator.mean())\n", "        .isWithin(ALLOWED_ERROR)\n", "        .of(MANY_VALUES_MEAN);\n"], "6": ["        .isWithin(ALLOWED_ERROR * INTEGER_MANY_VALUES_MEAN)\n", "        .isWithin(ALLOWED_ERROR * LONG_MANY_VALUES_MEAN)\n", "        .isWithin(ALLOWED_ERROR * LONG_MANY_VALUES_MEAN)\n"], "7": ["    assertThat(manyValuesAccumulatorByAddAllStatsAccumulator.sum())\n", "        .of(MANY_VALUES_MEAN * MANY_VALUES_COUNT);\n", "    assertThat(integerManyValuesAccumulatorByAddAllIterable.sum())\n", "        .isWithin(ALLOWED_ERROR * INTEGER_MANY_VALUES_MEAN)\n", "        .isWithin(ALLOWED_ERROR * LONG_MANY_VALUES_MEAN)\n", "        .isWithin(ALLOWED_ERROR * LONG_MANY_VALUES_MEAN)\n"], "8": ["    assertThat(manyValuesAccumulatorByAddAllStatsAccumulator.populationVariance())\n", "        .isWithin(ALLOWED_ERROR)\n", "        .of(MANY_VALUES_SUM_OF_SQUARES_OF_DELTAS / MANY_VALUES_COUNT);\n"], "9": ["        .isWithin(ALLOWED_ERROR * INTEGER_MANY_VALUES_SUM_OF_SQUARES_OF_DELTAS)\n", "        .isWithin(ALLOWED_ERROR * LONG_MANY_VALUES_SUM_OF_SQUARES_OF_DELTAS)\n", "        .isWithin(ALLOWED_ERROR * LONG_MANY_VALUES_SUM_OF_SQUARES_OF_DELTAS)\n"], "10": ["    assertThat(manyValuesAccumulatorByAddAllStatsAccumulator.populationStandardDeviation())\n", "        .of(sqrt(MANY_VALUES_SUM_OF_SQUARES_OF_DELTAS / MANY_VALUES_COUNT));\n", "    assertThat(integerManyValuesAccumulatorByAddAllIterable.populationStandardDeviation())\n", "        .isWithin(ALLOWED_ERROR * sqrt(INTEGER_MANY_VALUES_SUM_OF_SQUARES_OF_DELTAS))\n", "        .isWithin(ALLOWED_ERROR * sqrt(LONG_MANY_VALUES_SUM_OF_SQUARES_OF_DELTAS))\n", "        .isWithin(ALLOWED_ERROR * sqrt(LONG_MANY_VALUES_SUM_OF_SQUARES_OF_DELTAS))\n"], "11": ["    assertThat(manyValuesAccumulatorByAddAllStatsAccumulator.sampleVariance())\n", "        .of(MANY_VALUES_SUM_OF_SQUARES_OF_DELTAS / (MANY_VALUES_COUNT - 1));\n", "    assertThat(integerManyValuesAccumulatorByAddAllIterable.sampleVariance())\n", "        .isWithin(ALLOWED_ERROR * INTEGER_MANY_VALUES_SUM_OF_SQUARES_OF_DELTAS)\n", "        .isWithin(ALLOWED_ERROR * LONG_MANY_VALUES_SUM_OF_SQUARES_OF_DELTAS)\n", "        .isWithin(ALLOWED_ERROR * LONG_MANY_VALUES_SUM_OF_SQUARES_OF_DELTAS)\n"], "12": ["    assertThat(manyValuesAccumulatorByAddAllStatsAccumulator.sampleStandardDeviation())\n", "        .of(sqrt(MANY_VALUES_SUM_OF_SQUARES_OF_DELTAS / (MANY_VALUES_COUNT - 1)));\n", "    assertThat(integerManyValuesAccumulatorByAddAllIterable.sampleStandardDeviation())\n", "        .isWithin(ALLOWED_ERROR * sqrt(INTEGER_MANY_VALUES_SUM_OF_SQUARES_OF_DELTAS))\n", "        .isWithin(ALLOWED_ERROR * LONG_MANY_VALUES_SUM_OF_SQUARES_OF_DELTAS)\n", "        .isWithin(ALLOWED_ERROR * LONG_MANY_VALUES_SUM_OF_SQUARES_OF_DELTAS)\n"], "13": ["    assertThat(oneValueAccumulator.max()).isEqualTo(ONE_VALUE);\n", "    assertThat(oneValueAccumulatorByAddAllEmptyStats.max()).isEqualTo(ONE_VALUE);\n", "    assertThat(twoValuesAccumulator.max()).isEqualTo(TWO_VALUES_MAX);\n", "    assertThat(twoValuesAccumulatorByAddAllStats.max()).isEqualTo(TWO_VALUES_MAX);\n", "    assertThat(manyValuesAccumulatorByAddAllIterable.max()).isEqualTo(MANY_VALUES_MAX);\n", "    assertThat(manyValuesAccumulatorByAddAllIterator.max()).isEqualTo(MANY_VALUES_MAX);\n", "    assertThat(manyValuesAccumulatorByAddAllVarargs.max()).isEqualTo(MANY_VALUES_MAX);\n", "    assertThat(manyValuesAccumulatorByRepeatedAdd.max()).isEqualTo(MANY_VALUES_MAX);\n", "    assertThat(manyValuesAccumulatorByAddAndAddAll.max()).isEqualTo(MANY_VALUES_MAX);\n", "    assertThat(manyValuesAccumulatorByAddAllStats.max()).isEqualTo(MANY_VALUES_MAX);\n", "    assertThat(manyValuesAccumulatorByAddAllStatsAccumulator.max()).isEqualTo(MANY_VALUES_MAX);\n"], "14": ["        assertWithMessage(\"max of \" + values).that(max).isEqualTo(MANY_VALUES_MAX);\n", "            .isEqualTo(MANY_VALUES_MAX);\n", "        .isEqualTo(INTEGER_MANY_VALUES_MAX);\n", "    assertThat(longManyValuesAccumulatorByAddAllIterator.max()).isEqualTo(LONG_MANY_VALUES_MAX);\n", "    assertThat(longManyValuesAccumulatorByAddAllVarargs.max()).isEqualTo(LONG_MANY_VALUES_MAX);\n"], "15": ["    assertThat(oneValueAccumulator.min()).isEqualTo(ONE_VALUE);\n", "    assertThat(oneValueAccumulatorByAddAllEmptyStats.min()).isEqualTo(ONE_VALUE);\n", "    assertThat(twoValuesAccumulator.min()).isEqualTo(TWO_VALUES_MIN);\n", "    assertThat(twoValuesAccumulatorByAddAllStats.min()).isEqualTo(TWO_VALUES_MIN);\n", "    assertThat(manyValuesAccumulatorByAddAllIterable.min()).isEqualTo(MANY_VALUES_MIN);\n", "    assertThat(manyValuesAccumulatorByAddAllIterator.min()).isEqualTo(MANY_VALUES_MIN);\n", "    assertThat(manyValuesAccumulatorByAddAllVarargs.min()).isEqualTo(MANY_VALUES_MIN);\n", "    assertThat(manyValuesAccumulatorByRepeatedAdd.min()).isEqualTo(MANY_VALUES_MIN);\n", "    assertThat(manyValuesAccumulatorByAddAndAddAll.min()).isEqualTo(MANY_VALUES_MIN);\n", "    assertThat(manyValuesAccumulatorByAddAllStats.min()).isEqualTo(MANY_VALUES_MIN);\n", "    assertThat(manyValuesAccumulatorByAddAllStatsAccumulator.min()).isEqualTo(MANY_VALUES_MIN);\n"], "16": ["        assertWithMessage(\"min of \" + values).that(min).isEqualTo(MANY_VALUES_MIN);\n", "            .isEqualTo(MANY_VALUES_MIN);\n", "        .isEqualTo(INTEGER_MANY_VALUES_MIN);\n", "    assertThat(longManyValuesAccumulatorByAddAllIterator.min()).isEqualTo(LONG_MANY_VALUES_MIN);\n", "    assertThat(longManyValuesAccumulatorByAddAllVarargs.min()).isEqualTo(LONG_MANY_VALUES_MIN);\n"]}, "removed": {"6": ["        .isWithin(ALLOWED_ERROR)\n", "        .isWithin(ALLOWED_ERROR)\n", "        .isWithin(ALLOWED_ERROR)\n"], "7": ["    assertThat(integerManyValuesAccumulatorByAddAllIterable.sum())\n", "        .isWithin(ALLOWED_ERROR)\n", "        .isWithin(ALLOWED_ERROR)\n"], "9": ["        .isWithin(ALLOWED_ERROR)\n", "        .isWithin(ALLOWED_ERROR)\n", "        .isWithin(ALLOWED_ERROR)\n"], "10": ["    assertThat(integerManyValuesAccumulatorByAddAllIterable.populationStandardDeviation())\n", "        .isWithin(ALLOWED_ERROR)\n", "        .isWithin(ALLOWED_ERROR)\n"], "11": ["    assertThat(integerManyValuesAccumulatorByAddAllIterable.sampleVariance())\n", "        .isWithin(ALLOWED_ERROR)\n", "        .isWithin(ALLOWED_ERROR)\n"], "12": ["    assertThat(integerManyValuesAccumulatorByAddAllIterable.sampleStandardDeviation())\n", "        .isWithin(ALLOWED_ERROR)\n", "        .isWithin(ALLOWED_ERROR)\n"], "13": ["    assertThat(oneValueAccumulator.max()).isWithin(ALLOWED_ERROR).of(ONE_VALUE);\n", "    assertThat(oneValueAccumulatorByAddAllEmptyStats.max()).isWithin(ALLOWED_ERROR).of(ONE_VALUE);\n", "    assertThat(twoValuesAccumulator.max()).isWithin(ALLOWED_ERROR).of(TWO_VALUES_MAX);\n", "    assertThat(twoValuesAccumulatorByAddAllStats.max()).isWithin(ALLOWED_ERROR).of(TWO_VALUES_MAX);\n", "    assertThat(manyValuesAccumulatorByAddAllIterable.max())\n", "        .isWithin(ALLOWED_ERROR)\n", "        .of(MANY_VALUES_MAX);\n", "    assertThat(manyValuesAccumulatorByAddAllIterator.max())\n", "        .isWithin(ALLOWED_ERROR)\n", "        .of(MANY_VALUES_MAX);\n", "    assertThat(manyValuesAccumulatorByAddAllVarargs.max())\n", "        .isWithin(ALLOWED_ERROR)\n", "        .of(MANY_VALUES_MAX);\n", "    assertThat(manyValuesAccumulatorByRepeatedAdd.max())\n", "        .isWithin(ALLOWED_ERROR)\n", "        .of(MANY_VALUES_MAX);\n", "    assertThat(manyValuesAccumulatorByAddAndAddAll.max())\n", "        .isWithin(ALLOWED_ERROR)\n", "        .of(MANY_VALUES_MAX);\n", "    assertThat(manyValuesAccumulatorByAddAllStats.max())\n", "        .isWithin(ALLOWED_ERROR)\n", "        .of(MANY_VALUES_MAX);\n"], "14": ["        assertWithMessage(\"max of \" + values).that(max).isWithin(ALLOWED_ERROR).of(MANY_VALUES_MAX);\n", "            .isWithin(ALLOWED_ERROR)\n", "            .of(MANY_VALUES_MAX);\n", "        .isWithin(ALLOWED_ERROR)\n", "        .of(INTEGER_MANY_VALUES_MAX);\n", "    assertThat(longManyValuesAccumulatorByAddAllIterator.max())\n", "        .isWithin(ALLOWED_ERROR)\n", "        .of(LONG_MANY_VALUES_MAX);\n", "    assertThat(longManyValuesAccumulatorByAddAllVarargs.max())\n", "        .isWithin(ALLOWED_ERROR)\n", "        .of(LONG_MANY_VALUES_MAX);\n"], "15": ["    assertThat(oneValueAccumulator.min()).isWithin(ALLOWED_ERROR).of(ONE_VALUE);\n", "    assertThat(oneValueAccumulatorByAddAllEmptyStats.min()).isWithin(ALLOWED_ERROR).of(ONE_VALUE);\n", "    assertThat(twoValuesAccumulator.min()).isWithin(ALLOWED_ERROR).of(TWO_VALUES_MIN);\n", "    assertThat(twoValuesAccumulatorByAddAllStats.min()).isWithin(ALLOWED_ERROR).of(TWO_VALUES_MIN);\n", "    assertThat(manyValuesAccumulatorByAddAllIterable.min())\n", "        .isWithin(ALLOWED_ERROR)\n", "        .of(MANY_VALUES_MIN);\n", "    assertThat(manyValuesAccumulatorByAddAllIterator.min())\n", "        .isWithin(ALLOWED_ERROR)\n", "        .of(MANY_VALUES_MIN);\n", "    assertThat(manyValuesAccumulatorByAddAllVarargs.min())\n", "        .isWithin(ALLOWED_ERROR)\n", "        .of(MANY_VALUES_MIN);\n", "    assertThat(manyValuesAccumulatorByRepeatedAdd.min())\n", "        .isWithin(ALLOWED_ERROR)\n", "        .of(MANY_VALUES_MIN);\n", "    assertThat(manyValuesAccumulatorByAddAndAddAll.min())\n", "        .isWithin(ALLOWED_ERROR)\n", "        .of(MANY_VALUES_MIN);\n", "    assertThat(manyValuesAccumulatorByAddAllStats.min())\n", "        .isWithin(ALLOWED_ERROR)\n", "        .of(MANY_VALUES_MIN);\n"], "16": ["        assertWithMessage(\"min of \" + values).that(min).isWithin(ALLOWED_ERROR).of(MANY_VALUES_MIN);\n", "            .isWithin(ALLOWED_ERROR)\n", "            .of(MANY_VALUES_MIN);\n", "        .isWithin(ALLOWED_ERROR)\n", "        .of(INTEGER_MANY_VALUES_MIN);\n", "    assertThat(longManyValuesAccumulatorByAddAllIterator.min())\n", "        .isWithin(ALLOWED_ERROR)\n", "        .of(LONG_MANY_VALUES_MIN);\n", "    assertThat(longManyValuesAccumulatorByAddAllVarargs.min())\n", "        .isWithin(ALLOWED_ERROR)\n", "        .of(LONG_MANY_VALUES_MIN);\n"]}, "added_lines": {"1": [79], "2": [134, 135, 136, 137, 138, 139], "3": [150, 151, 152, 153, 154, 155], "4": [170], "5": [230, 231, 232], "6": [272, 275, 278], "7": [310, 312, 313, 314, 317, 320], "8": [366, 367, 368], "9": [397, 400, 403], "10": [451, 453, 454, 455, 458, 461], "11": [515, 517, 518, 519, 522, 525], "12": [579, 581, 582, 583, 586, 589], "13": [609, 610, 611, 612, 613, 614, 615, 616, 617, 618, 619], "14": [640, 643, 647, 648, 649], "15": [668, 669, 670, 671, 672, 673, 674, 675, 676, 677, 678], "16": [699, 702, 706, 707, 708]}, "removed_lines": {"6": [255, 258, 261], "7": [293, 297, 300], "9": [374, 377, 380], "10": [428, 432, 435], "11": [489, 493, 496], "12": [550, 554, 557], "13": [577, 578, 579, 580, 581, 582, 583, 584, 585, 586, 587, 588, 589, 590, 591, 592, 593, 594, 595, 596, 597, 598], "14": [619, 622, 623, 627, 628, 629, 630, 631, 632, 633, 634], "15": [653, 654, 655, 656, 657, 658, 659, 660, 661, 662, 663, 664, 665, 666, 667, 668, 669, 670, 671, 672, 673, 674], "16": [695, 698, 699, 703, 704, 705, 706, 707, 708, 709, 710]}}, {"1": "android/guava-tests/test/com/google/common/math/StatsTest.java", "added": {"1": ["        .isWithin(ALLOWED_ERROR * INTEGER_MANY_VALUES_MEAN)\n", "        .isWithin(ALLOWED_ERROR * INTEGER_MANY_VALUES_MEAN)\n", "        .isWithin(ALLOWED_ERROR * LONG_MANY_VALUES_MEAN)\n", "        .isWithin(ALLOWED_ERROR * LONG_MANY_VALUES_MEAN)\n"], "2": ["        .isWithin(ALLOWED_ERROR * INTEGER_MANY_VALUES_MEAN)\n", "        .isWithin(ALLOWED_ERROR * INTEGER_MANY_VALUES_MEAN)\n", "        .isWithin(ALLOWED_ERROR * LONG_MANY_VALUES_MEAN)\n", "        .isWithin(ALLOWED_ERROR * LONG_MANY_VALUES_MEAN)\n"], "3": ["        .isWithin(ALLOWED_ERROR * INTEGER_MANY_VALUES_SUM_OF_SQUARES_OF_DELTAS)\n", "        .isWithin(ALLOWED_ERROR * INTEGER_MANY_VALUES_SUM_OF_SQUARES_OF_DELTAS)\n", "        .isWithin(ALLOWED_ERROR * LONG_MANY_VALUES_SUM_OF_SQUARES_OF_DELTAS)\n", "        .isWithin(ALLOWED_ERROR * LONG_MANY_VALUES_SUM_OF_SQUARES_OF_DELTAS)\n"], "4": ["        .isWithin(ALLOWED_ERROR * sqrt(INTEGER_MANY_VALUES_SUM_OF_SQUARES_OF_DELTAS))\n", "        .isWithin(ALLOWED_ERROR * sqrt(INTEGER_MANY_VALUES_SUM_OF_SQUARES_OF_DELTAS))\n", "        .isWithin(ALLOWED_ERROR * sqrt(LONG_MANY_VALUES_SUM_OF_SQUARES_OF_DELTAS))\n", "        .isWithin(ALLOWED_ERROR * sqrt(LONG_MANY_VALUES_SUM_OF_SQUARES_OF_DELTAS))\n"], "5": ["        .isWithin(ALLOWED_ERROR * INTEGER_MANY_VALUES_SUM_OF_SQUARES_OF_DELTAS)\n", "        .isWithin(ALLOWED_ERROR * INTEGER_MANY_VALUES_SUM_OF_SQUARES_OF_DELTAS)\n", "        .isWithin(ALLOWED_ERROR * LONG_MANY_VALUES_SUM_OF_SQUARES_OF_DELTAS)\n", "        .isWithin(ALLOWED_ERROR * LONG_MANY_VALUES_SUM_OF_SQUARES_OF_DELTAS)\n"], "6": ["        .isWithin(ALLOWED_ERROR * sqrt(INTEGER_MANY_VALUES_SUM_OF_SQUARES_OF_DELTAS))\n", "        .isWithin(ALLOWED_ERROR * sqrt(INTEGER_MANY_VALUES_SUM_OF_SQUARES_OF_DELTAS))\n", "        .isWithin(ALLOWED_ERROR * sqrt(LONG_MANY_VALUES_SUM_OF_SQUARES_OF_DELTAS))\n", "        .isWithin(ALLOWED_ERROR * sqrt(LONG_MANY_VALUES_SUM_OF_SQUARES_OF_DELTAS))\n"], "7": ["    assertThat(ONE_VALUE_STATS.max()).isEqualTo(ONE_VALUE);\n", "    assertThat(TWO_VALUES_STATS.max()).isEqualTo(TWO_VALUES_MAX);\n", "    assertThat(MANY_VALUES_STATS_VARARGS.max()).isEqualTo(MANY_VALUES_MAX);\n", "    assertThat(MANY_VALUES_STATS_ITERABLE.max()).isEqualTo(MANY_VALUES_MAX);\n"], "8": ["        assertWithMessage(\"max of \" + values).that(max).isEqualTo(MANY_VALUES_MAX);\n", "    assertThat(MANY_VALUES_STATS_SNAPSHOT.max()).isEqualTo(MANY_VALUES_MAX);\n", "    assertThat(INTEGER_MANY_VALUES_STATS_VARARGS.max()).isEqualTo(INTEGER_MANY_VALUES_MAX);\n", "    assertThat(INTEGER_MANY_VALUES_STATS_ITERABLE.max()).isEqualTo(INTEGER_MANY_VALUES_MAX);\n", "    assertThat(LONG_MANY_VALUES_STATS_ITERATOR.max()).isEqualTo(LONG_MANY_VALUES_MAX);\n", "    assertThat(LONG_MANY_VALUES_STATS_SNAPSHOT.max()).isEqualTo(LONG_MANY_VALUES_MAX);\n"], "9": ["    assertThat(ONE_VALUE_STATS.min()).isEqualTo(ONE_VALUE);\n", "    assertThat(TWO_VALUES_STATS.min()).isEqualTo(TWO_VALUES_MIN);\n", "    assertThat(MANY_VALUES_STATS_VARARGS.min()).isEqualTo(MANY_VALUES_MIN);\n", "    assertThat(MANY_VALUES_STATS_ITERABLE.min()).isEqualTo(MANY_VALUES_MIN);\n", "    assertThat(MANY_VALUES_STATS_ITERATOR.min()).isEqualTo(MANY_VALUES_MIN);\n"], "10": ["        assertWithMessage(\"min of \" + values).that(min).isEqualTo(MANY_VALUES_MIN);\n", "    assertThat(INTEGER_MANY_VALUES_STATS_VARARGS.min()).isEqualTo(INTEGER_MANY_VALUES_MIN);\n", "    assertThat(INTEGER_MANY_VALUES_STATS_ITERABLE.min()).isEqualTo(INTEGER_MANY_VALUES_MIN);\n", "    assertThat(LONG_MANY_VALUES_STATS_ITERATOR.min()).isEqualTo(LONG_MANY_VALUES_MIN);\n", "    assertThat(LONG_MANY_VALUES_STATS_SNAPSHOT.min()).isEqualTo(LONG_MANY_VALUES_MIN);\n"], "11": ["        .isWithin(ALLOWED_ERROR * INTEGER_MANY_VALUES_MEAN)\n", "        .isWithin(ALLOWED_ERROR * INTEGER_MANY_VALUES_MEAN)\n", "    assertThat(Stats.meanOf(LONG_MANY_VALUES))\n", "        .isWithin(ALLOWED_ERROR * LONG_MANY_VALUES_MEAN)\n", "        .of(LONG_MANY_VALUES_MEAN);\n", "        .isWithin(ALLOWED_ERROR * LONG_MANY_VALUES_MEAN)\n"]}, "removed": {"1": ["        .isWithin(ALLOWED_ERROR)\n", "        .isWithin(ALLOWED_ERROR)\n", "        .isWithin(ALLOWED_ERROR)\n", "        .isWithin(ALLOWED_ERROR)\n"], "2": ["        .isWithin(ALLOWED_ERROR)\n", "        .isWithin(ALLOWED_ERROR)\n", "        .isWithin(ALLOWED_ERROR)\n", "        .isWithin(ALLOWED_ERROR)\n"], "3": ["        .isWithin(ALLOWED_ERROR)\n", "        .isWithin(ALLOWED_ERROR)\n", "        .isWithin(ALLOWED_ERROR)\n", "        .isWithin(ALLOWED_ERROR)\n"], "4": ["        .isWithin(ALLOWED_ERROR)\n", "        .isWithin(ALLOWED_ERROR)\n", "        .isWithin(ALLOWED_ERROR)\n", "        .isWithin(ALLOWED_ERROR)\n"], "5": ["        .isWithin(ALLOWED_ERROR)\n", "        .isWithin(ALLOWED_ERROR)\n", "        .isWithin(ALLOWED_ERROR)\n", "        .isWithin(ALLOWED_ERROR)\n"], "6": ["        .isWithin(ALLOWED_ERROR)\n", "        .isWithin(ALLOWED_ERROR)\n", "        .isWithin(ALLOWED_ERROR)\n", "        .isWithin(ALLOWED_ERROR)\n"], "7": ["    assertThat(ONE_VALUE_STATS.max()).isWithin(ALLOWED_ERROR).of(ONE_VALUE);\n", "    assertThat(TWO_VALUES_STATS.max()).isWithin(ALLOWED_ERROR).of(TWO_VALUES_MAX);\n", "    assertThat(MANY_VALUES_STATS_VARARGS.max()).isWithin(ALLOWED_ERROR).of(MANY_VALUES_MAX);\n", "    assertThat(MANY_VALUES_STATS_ITERABLE.max()).isWithin(ALLOWED_ERROR).of(MANY_VALUES_MAX);\n"], "8": ["        assertWithMessage(\"max of \" + values).that(max).isWithin(ALLOWED_ERROR).of(MANY_VALUES_MAX);\n", "    assertThat(MANY_VALUES_STATS_SNAPSHOT.max()).isWithin(ALLOWED_ERROR).of(MANY_VALUES_MAX);\n", "    assertThat(INTEGER_MANY_VALUES_STATS_VARARGS.max())\n", "        .isWithin(ALLOWED_ERROR)\n", "        .of(INTEGER_MANY_VALUES_MAX);\n", "    assertThat(INTEGER_MANY_VALUES_STATS_ITERABLE.max())\n", "        .isWithin(ALLOWED_ERROR)\n", "        .of(INTEGER_MANY_VALUES_MAX);\n", "    assertThat(LONG_MANY_VALUES_STATS_ITERATOR.max())\n", "        .isWithin(ALLOWED_ERROR)\n", "        .of(LONG_MANY_VALUES_MAX);\n", "    assertThat(LONG_MANY_VALUES_STATS_SNAPSHOT.max())\n", "        .isWithin(ALLOWED_ERROR)\n", "        .of(LONG_MANY_VALUES_MAX);\n"], "9": ["    assertThat(ONE_VALUE_STATS.min()).isWithin(ALLOWED_ERROR).of(ONE_VALUE);\n", "    assertThat(TWO_VALUES_STATS.min()).isWithin(ALLOWED_ERROR).of(TWO_VALUES_MIN);\n", "    assertThat(MANY_VALUES_STATS_VARARGS.min()).isWithin(ALLOWED_ERROR).of(MANY_VALUES_MIN);\n", "    assertThat(MANY_VALUES_STATS_ITERABLE.min()).isWithin(ALLOWED_ERROR).of(MANY_VALUES_MIN);\n", "    assertThat(MANY_VALUES_STATS_ITERATOR.min()).isWithin(ALLOWED_ERROR).of(MANY_VALUES_MIN);\n"], "10": ["        assertWithMessage(\"min of \" + values).that(min).isWithin(ALLOWED_ERROR).of(MANY_VALUES_MIN);\n", "    assertThat(INTEGER_MANY_VALUES_STATS_VARARGS.min())\n", "        .isWithin(ALLOWED_ERROR)\n", "        .of(INTEGER_MANY_VALUES_MIN);\n", "    assertThat(INTEGER_MANY_VALUES_STATS_ITERABLE.min())\n", "        .isWithin(ALLOWED_ERROR)\n", "        .of(INTEGER_MANY_VALUES_MIN);\n", "    assertThat(LONG_MANY_VALUES_STATS_ITERATOR.min())\n", "        .isWithin(ALLOWED_ERROR)\n", "        .of(LONG_MANY_VALUES_MIN);\n", "    assertThat(LONG_MANY_VALUES_STATS_SNAPSHOT.min())\n", "        .isWithin(ALLOWED_ERROR)\n", "        .of(LONG_MANY_VALUES_MIN);\n"], "11": ["        .isWithin(ALLOWED_ERROR)\n", "        .isWithin(ALLOWED_ERROR)\n", "    assertThat(Stats.meanOf(LONG_MANY_VALUES)).isWithin(ALLOWED_ERROR).of(LONG_MANY_VALUES_MEAN);\n", "        .isWithin(ALLOWED_ERROR)\n"]}, "added_lines": {"1": [148, 151, 157, 160], "2": [185, 188, 191, 194], "3": [239, 242, 248, 251], "4": [286, 289, 292, 295], "5": [331, 334, 337, 340], "6": [376, 379, 382, 385], "7": [400, 404, 405, 406], "8": [416, 419, 420, 421, 422, 423], "9": [437, 441, 442, 443, 444], "10": [456, 459, 460, 461, 462], "11": [545, 548, 550, 551, 552, 554]}, "removed_lines": {"1": [148, 151, 157, 160], "2": [185, 188, 191, 194], "3": [239, 242, 248, 251], "4": [286, 289, 292, 295], "5": [331, 334, 337, 340], "6": [376, 379, 382, 385], "7": [400, 404, 405, 406], "8": [416, 419, 420, 421, 422, 423, 424, 425, 426, 427, 428, 429, 430, 431], "9": [445, 449, 450, 451, 452], "10": [464, 467, 468, 469, 470, 471, 472, 473, 474, 475, 476, 477, 478], "11": [561, 564, 566, 568]}}, {"2": "android/guava-tests/test/com/google/common/math/StatsTesting.java", "added": {"1": ["  static final Stats MANY_VALUES_STATS_SNAPSHOT = buildManyValuesStatsSnapshot();\n"], "2": ["  static final Stats LONG_MANY_VALUES_STATS_SNAPSHOT = buildLongManyValuesStatsSnapshot();\n", "  private static Stats buildManyValuesStatsSnapshot() {\n", "    Stats stats = accumulator.snapshot();\n", "    return stats;\n", "  private static Stats buildLongManyValuesStatsSnapshot() {\n", "    return accumulator.snapshot();\n"], "3": ["  static final PairedStats MANY_VALUES_PAIRED_STATS = buildManyValuesPairedStats();\n", "  static final PairedStats HORIZONTAL_VALUES_PAIRED_STATS = buildHorizontalValuesPairedStats();\n", "  static final PairedStats VERTICAL_VALUES_PAIRED_STATS = buildVerticalValuesPairedStats();\n", "  static final PairedStats CONSTANT_VALUES_PAIRED_STATS = buildConstantValuesPairedStats();\n", "  private static PairedStats buildManyValuesPairedStats() {\n", "    PairedStats stats = accumulator.snapshot();\n", "    return stats;\n", "  private static PairedStats buildHorizontalValuesPairedStats() {\n", "    return accumulator.snapshot();\n", "  private static PairedStats buildVerticalValuesPairedStats() {\n", "    return accumulator.snapshot();\n", "  private static PairedStats buildConstantValuesPairedStats() {\n", "    return accumulator.snapshot();\n"]}, "removed": {"1": ["  static final Stats MANY_VALUES_STATS_SNAPSHOT;\n"], "2": ["  static final Stats LONG_MANY_VALUES_STATS_SNAPSHOT;\n", "  static {\n", "    MANY_VALUES_STATS_SNAPSHOT = accumulator.snapshot();\n", "  static {\n", "    LONG_MANY_VALUES_STATS_SNAPSHOT = accumulator.snapshot();\n"], "3": ["  static final PairedStats MANY_VALUES_PAIRED_STATS;\n", "  static final PairedStats HORIZONTAL_VALUES_PAIRED_STATS;\n", "  static final PairedStats VERTICAL_VALUES_PAIRED_STATS;\n", "  static final PairedStats CONSTANT_VALUES_PAIRED_STATS;\n", "  static {\n", "    MANY_VALUES_PAIRED_STATS = accumulator.snapshot();\n", "  static {\n", "    HORIZONTAL_VALUES_PAIRED_STATS = accumulator.snapshot();\n", "  static {\n", "    VERTICAL_VALUES_PAIRED_STATS = accumulator.snapshot();\n", "  static {\n", "    CONSTANT_VALUES_PAIRED_STATS = accumulator.snapshot();\n"]}, "added_lines": {"1": [225], "2": [233, 236, 239, 241, 244, 247], "3": [279, 282, 283, 284, 286, 289, 291, 294, 299, 302, 307, 310, 315]}, "removed_lines": {"1": [225], "2": [233, 236, 239, 243, 246], "3": [278, 281, 282, 283, 285, 288, 292, 297, 300, 305, 308, 313]}}, {"3": "android/guava/src/com/google/common/math/Stats.java", "added": {"1": ["   * Returns statistics over a dataset containing the given values. The iterator will be completely\n", "   * consumed by this method.\n"]}, "removed": {"1": ["   * Returns statistics over a dataset containing the given values.\n"]}, "added_lines": {"1": [106, 107]}, "removed_lines": {"1": [106]}}, {"4": "android/guava/src/com/google/common/math/StatsAccumulator.java", "added": {"1": ["    merge(values.count(), values.mean(), values.sumOfSquaresOfDeltas(), values.min(), values.max());\n", "  }\n", "\n", "  /**\n", "   * Adds the given statistics to the dataset, as if the individual values used to compute the\n", "   * statistics had been added directly.\n", "   *\n", "   * @since NEXT\n", "   */\n", "  public void addAll(StatsAccumulator values) {\n", "    if (values.count() == 0) {\n", "      return;\n", "    }\n", "    merge(values.count(), values.mean(), values.sumOfSquaresOfDeltas(), values.min(), values.max());\n", "  }\n", "  private void merge(\n", "      long otherCount,\n", "      double otherMean,\n", "      double otherSumOfSquaresOfDeltas,\n", "      double otherMin,\n", "      double otherMax) {\n", "      count = otherCount;\n", "      mean = otherMean;\n", "      sumOfSquaresOfDeltas = otherSumOfSquaresOfDeltas;\n", "      min = otherMin;\n", "      max = otherMax;\n", "      count += otherCount;\n", "      if (isFinite(mean) && isFinite(otherMean)) {\n", "        double delta = otherMean - mean;\n", "        mean += delta * otherCount / count;\n", "        sumOfSquaresOfDeltas += otherSumOfSquaresOfDeltas + delta * (otherMean - mean) * otherCount;\n", "        mean = calculateNewMeanNonFinite(mean, otherMean);\n", "      min = Math.min(min, otherMin);\n", "      max = Math.max(max, otherMax);\n"]}, "removed": {"1": ["      count = values.count();\n", "      mean = values.mean();\n", "      sumOfSquaresOfDeltas = values.sumOfSquaresOfDeltas();\n", "      min = values.min();\n", "      max = values.max();\n", "      count += values.count();\n", "      if (isFinite(mean) && isFinite(values.mean())) {\n", "        double delta = values.mean() - mean;\n", "        mean += delta * values.count() / count;\n", "        sumOfSquaresOfDeltas +=\n", "            values.sumOfSquaresOfDeltas() + delta * (values.mean() - mean) * values.count();\n", "        mean = calculateNewMeanNonFinite(mean, values.mean());\n", "      min = Math.min(min, values.min());\n", "      max = Math.max(max, values.max());\n"]}, "added_lines": {"1": [139, 140, 141, 142, 143, 144, 145, 146, 147, 148, 149, 150, 151, 152, 153, 155, 156, 157, 158, 159, 160, 162, 163, 164, 165, 166, 168, 169, 171, 172, 173, 175, 178, 179]}, "removed_lines": {"1": [141, 142, 143, 144, 145, 147, 148, 150, 151, 152, 153, 155, 158, 159]}}, {"5": "guava-tests/test/com/google/common/math/StatsAccumulatorTest.java", "added": {"1": ["import static com.google.common.math.StatsTesting.MEGA_STREAM_COUNT;\n", "import static com.google.common.math.StatsTesting.MEGA_STREAM_MAX;\n", "import static com.google.common.math.StatsTesting.MEGA_STREAM_MEAN;\n", "import static com.google.common.math.StatsTesting.MEGA_STREAM_MIN;\n", "import static com.google.common.math.StatsTesting.MEGA_STREAM_POPULATION_VARIANCE;\n"], "2": ["import static com.google.common.math.StatsTesting.megaPrimitiveDoubleStreamPart1;\n", "import static com.google.common.math.StatsTesting.megaPrimitiveDoubleStreamPart2;\n"], "3": ["  private StatsAccumulator manyValuesAccumulatorByAddAllStatsAccumulator;\n"], "4": ["    manyValuesAccumulatorByAddAllStatsAccumulator = new StatsAccumulator();\n", "    manyValuesAccumulatorByAddAllStatsAccumulator.addAll(\n", "        statsAccumulatorOf(MANY_VALUES.subList(0, MANY_VALUES.size() / 2)));\n", "    manyValuesAccumulatorByAddAllStatsAccumulator.addAll(\n", "        statsAccumulatorOf(MANY_VALUES.subList(MANY_VALUES.size() / 2, MANY_VALUES.size())));\n", "\n"], "5": ["  private static StatsAccumulator statsAccumulatorOf(Iterable<? extends Number> values) {\n", "    StatsAccumulator accumulator = new StatsAccumulator();\n", "    accumulator.addAll(values);\n", "    return accumulator;\n", "  }\n", "\n"], "6": ["    assertThat(manyValuesAccumulatorByAddAllStatsAccumulator.count()).isEqualTo(MANY_VALUES_COUNT);\n"], "7": ["    assertThat(manyValuesAccumulatorByAddAllStatsAccumulator.mean())\n", "        .isWithin(ALLOWED_ERROR)\n", "        .of(MANY_VALUES_MEAN);\n"], "8": ["        .isWithin(ALLOWED_ERROR * INTEGER_MANY_VALUES_MEAN)\n", "        .isWithin(ALLOWED_ERROR * LONG_MANY_VALUES_MEAN)\n", "        .isWithin(ALLOWED_ERROR * LONG_MANY_VALUES_MEAN)\n"], "9": ["    assertThat(manyValuesAccumulatorByAddAllStatsAccumulator.sum())\n", "        .of(MANY_VALUES_MEAN * MANY_VALUES_COUNT);\n", "    assertThat(integerManyValuesAccumulatorByAddAllIterable.sum())\n", "        .isWithin(ALLOWED_ERROR * INTEGER_MANY_VALUES_MEAN)\n", "        .isWithin(ALLOWED_ERROR * LONG_MANY_VALUES_MEAN)\n", "        .isWithin(ALLOWED_ERROR * LONG_MANY_VALUES_MEAN)\n"], "10": ["    assertThat(manyValuesAccumulatorByAddAllStatsAccumulator.populationVariance())\n", "        .isWithin(ALLOWED_ERROR)\n", "        .of(MANY_VALUES_SUM_OF_SQUARES_OF_DELTAS / MANY_VALUES_COUNT);\n"], "11": ["        .isWithin(ALLOWED_ERROR * INTEGER_MANY_VALUES_SUM_OF_SQUARES_OF_DELTAS)\n", "        .isWithin(ALLOWED_ERROR * LONG_MANY_VALUES_SUM_OF_SQUARES_OF_DELTAS)\n", "        .isWithin(ALLOWED_ERROR * LONG_MANY_VALUES_SUM_OF_SQUARES_OF_DELTAS)\n"], "12": ["    assertThat(manyValuesAccumulatorByAddAllStatsAccumulator.populationStandardDeviation())\n", "        .of(sqrt(MANY_VALUES_SUM_OF_SQUARES_OF_DELTAS / MANY_VALUES_COUNT));\n", "    assertThat(integerManyValuesAccumulatorByAddAllIterable.populationStandardDeviation())\n", "        .isWithin(ALLOWED_ERROR * sqrt(INTEGER_MANY_VALUES_SUM_OF_SQUARES_OF_DELTAS))\n", "        .isWithin(ALLOWED_ERROR * sqrt(LONG_MANY_VALUES_SUM_OF_SQUARES_OF_DELTAS))\n", "        .isWithin(ALLOWED_ERROR * sqrt(LONG_MANY_VALUES_SUM_OF_SQUARES_OF_DELTAS))\n"], "13": ["    assertThat(manyValuesAccumulatorByAddAllStatsAccumulator.sampleVariance())\n", "        .of(MANY_VALUES_SUM_OF_SQUARES_OF_DELTAS / (MANY_VALUES_COUNT - 1));\n", "    assertThat(integerManyValuesAccumulatorByAddAllIterable.sampleVariance())\n", "        .isWithin(ALLOWED_ERROR * INTEGER_MANY_VALUES_SUM_OF_SQUARES_OF_DELTAS)\n", "        .isWithin(ALLOWED_ERROR * LONG_MANY_VALUES_SUM_OF_SQUARES_OF_DELTAS)\n", "        .isWithin(ALLOWED_ERROR * LONG_MANY_VALUES_SUM_OF_SQUARES_OF_DELTAS)\n"], "14": ["    assertThat(manyValuesAccumulatorByAddAllStatsAccumulator.sampleStandardDeviation())\n", "        .of(sqrt(MANY_VALUES_SUM_OF_SQUARES_OF_DELTAS / (MANY_VALUES_COUNT - 1)));\n", "    assertThat(integerManyValuesAccumulatorByAddAllIterable.sampleStandardDeviation())\n", "        .isWithin(ALLOWED_ERROR * sqrt(INTEGER_MANY_VALUES_SUM_OF_SQUARES_OF_DELTAS))\n", "        .isWithin(ALLOWED_ERROR * LONG_MANY_VALUES_SUM_OF_SQUARES_OF_DELTAS)\n", "        .isWithin(ALLOWED_ERROR * LONG_MANY_VALUES_SUM_OF_SQUARES_OF_DELTAS)\n"], "15": ["    assertThat(oneValueAccumulator.max()).isEqualTo(ONE_VALUE);\n", "    assertThat(oneValueAccumulatorByAddAllEmptyStats.max()).isEqualTo(ONE_VALUE);\n", "    assertThat(twoValuesAccumulator.max()).isEqualTo(TWO_VALUES_MAX);\n", "    assertThat(twoValuesAccumulatorByAddAllStats.max()).isEqualTo(TWO_VALUES_MAX);\n", "    assertThat(manyValuesAccumulatorByAddAllIterable.max()).isEqualTo(MANY_VALUES_MAX);\n", "    assertThat(manyValuesAccumulatorByAddAllIterator.max()).isEqualTo(MANY_VALUES_MAX);\n", "    assertThat(manyValuesAccumulatorByAddAllVarargs.max()).isEqualTo(MANY_VALUES_MAX);\n", "    assertThat(manyValuesAccumulatorByRepeatedAdd.max()).isEqualTo(MANY_VALUES_MAX);\n", "    assertThat(manyValuesAccumulatorByAddAndAddAll.max()).isEqualTo(MANY_VALUES_MAX);\n", "    assertThat(manyValuesAccumulatorByAddAllStats.max()).isEqualTo(MANY_VALUES_MAX);\n", "    assertThat(manyValuesAccumulatorByAddAllStatsAccumulator.max()).isEqualTo(MANY_VALUES_MAX);\n"], "16": ["        assertWithMessage(\"max of \" + values).that(max).isEqualTo(MANY_VALUES_MAX);\n", "            .isEqualTo(MANY_VALUES_MAX);\n", "        .isEqualTo(INTEGER_MANY_VALUES_MAX);\n", "    assertThat(longManyValuesAccumulatorByAddAllIterator.max()).isEqualTo(LONG_MANY_VALUES_MAX);\n", "    assertThat(longManyValuesAccumulatorByAddAllVarargs.max()).isEqualTo(LONG_MANY_VALUES_MAX);\n"], "17": ["    assertThat(oneValueAccumulator.min()).isEqualTo(ONE_VALUE);\n", "    assertThat(oneValueAccumulatorByAddAllEmptyStats.min()).isEqualTo(ONE_VALUE);\n", "    assertThat(twoValuesAccumulator.min()).isEqualTo(TWO_VALUES_MIN);\n", "    assertThat(twoValuesAccumulatorByAddAllStats.min()).isEqualTo(TWO_VALUES_MIN);\n", "    assertThat(manyValuesAccumulatorByAddAllIterable.min()).isEqualTo(MANY_VALUES_MIN);\n", "    assertThat(manyValuesAccumulatorByAddAllIterator.min()).isEqualTo(MANY_VALUES_MIN);\n", "    assertThat(manyValuesAccumulatorByAddAllVarargs.min()).isEqualTo(MANY_VALUES_MIN);\n", "    assertThat(manyValuesAccumulatorByRepeatedAdd.min()).isEqualTo(MANY_VALUES_MIN);\n", "    assertThat(manyValuesAccumulatorByAddAndAddAll.min()).isEqualTo(MANY_VALUES_MIN);\n", "    assertThat(manyValuesAccumulatorByAddAllStats.min()).isEqualTo(MANY_VALUES_MIN);\n", "    assertThat(manyValuesAccumulatorByAddAllStatsAccumulator.min()).isEqualTo(MANY_VALUES_MIN);\n"], "18": ["        assertWithMessage(\"min of \" + values).that(min).isEqualTo(MANY_VALUES_MIN);\n", "            .isEqualTo(MANY_VALUES_MIN);\n", "        .isEqualTo(INTEGER_MANY_VALUES_MIN);\n", "    assertThat(longManyValuesAccumulatorByAddAllIterator.min()).isEqualTo(LONG_MANY_VALUES_MIN);\n", "    assertThat(longManyValuesAccumulatorByAddAllVarargs.min()).isEqualTo(LONG_MANY_VALUES_MIN);\n", "  }\n", "\n", "  public void testAddAllPrimitiveDoubleStream() {\n", "    StatsAccumulator accumulator = new StatsAccumulator();\n", "    accumulator.addAll(megaPrimitiveDoubleStreamPart1());\n", "    accumulator.addAll(megaPrimitiveDoubleStreamPart2());\n", "    assertThat(accumulator.count()).isEqualTo(MEGA_STREAM_COUNT);\n", "    assertThat(accumulator.mean()).isWithin(ALLOWED_ERROR * MEGA_STREAM_COUNT).of(MEGA_STREAM_MEAN);\n", "    assertThat(accumulator.populationVariance())\n", "        .isWithin(ALLOWED_ERROR * MEGA_STREAM_COUNT)\n", "        .of(MEGA_STREAM_POPULATION_VARIANCE);\n", "    assertThat(accumulator.min()).isEqualTo(MEGA_STREAM_MIN);\n", "    assertThat(accumulator.max()).isEqualTo(MEGA_STREAM_MAX);\n", "  }\n", "\n", "  public void testAddAllPrimitiveIntStream() {\n", "    StatsAccumulator accumulator = new StatsAccumulator();\n", "    accumulator.addAll(megaPrimitiveDoubleStreamPart1().mapToInt(x -> (int) x));\n", "    accumulator.addAll(megaPrimitiveDoubleStreamPart2().mapToInt(x -> (int) x));\n", "    assertThat(accumulator.count()).isEqualTo(MEGA_STREAM_COUNT);\n", "    assertThat(accumulator.mean()).isWithin(ALLOWED_ERROR * MEGA_STREAM_COUNT).of(MEGA_STREAM_MEAN);\n", "    assertThat(accumulator.populationVariance())\n", "        .isWithin(ALLOWED_ERROR * MEGA_STREAM_COUNT)\n", "        .of(MEGA_STREAM_POPULATION_VARIANCE);\n", "    assertThat(accumulator.min()).isEqualTo(MEGA_STREAM_MIN);\n", "    assertThat(accumulator.max()).isEqualTo(MEGA_STREAM_MAX);\n", "  }\n", "\n", "  public void testAddAllPrimitiveLongStream() {\n", "    StatsAccumulator accumulator = new StatsAccumulator();\n", "    accumulator.addAll(megaPrimitiveDoubleStreamPart1().mapToLong(x -> (long) x));\n", "    accumulator.addAll(megaPrimitiveDoubleStreamPart2().mapToLong(x -> (long) x));\n", "    assertThat(accumulator.count()).isEqualTo(MEGA_STREAM_COUNT);\n", "    assertThat(accumulator.mean()).isWithin(ALLOWED_ERROR * MEGA_STREAM_COUNT).of(MEGA_STREAM_MEAN);\n", "    assertThat(accumulator.populationVariance())\n", "        .isWithin(ALLOWED_ERROR * MEGA_STREAM_COUNT)\n", "        .of(MEGA_STREAM_POPULATION_VARIANCE);\n", "    assertThat(accumulator.min()).isEqualTo(MEGA_STREAM_MIN);\n", "    assertThat(accumulator.max()).isEqualTo(MEGA_STREAM_MAX);\n"]}, "removed": {"8": ["        .isWithin(ALLOWED_ERROR)\n", "        .isWithin(ALLOWED_ERROR)\n", "        .isWithin(ALLOWED_ERROR)\n"], "9": ["    assertThat(integerManyValuesAccumulatorByAddAllIterable.sum())\n", "        .isWithin(ALLOWED_ERROR)\n", "        .isWithin(ALLOWED_ERROR)\n"], "11": ["        .isWithin(ALLOWED_ERROR)\n", "        .isWithin(ALLOWED_ERROR)\n", "        .isWithin(ALLOWED_ERROR)\n"], "12": ["    assertThat(integerManyValuesAccumulatorByAddAllIterable.populationStandardDeviation())\n", "        .isWithin(ALLOWED_ERROR)\n", "        .isWithin(ALLOWED_ERROR)\n"], "13": ["    assertThat(integerManyValuesAccumulatorByAddAllIterable.sampleVariance())\n", "        .isWithin(ALLOWED_ERROR)\n", "        .isWithin(ALLOWED_ERROR)\n"], "14": ["    assertThat(integerManyValuesAccumulatorByAddAllIterable.sampleStandardDeviation())\n", "        .isWithin(ALLOWED_ERROR)\n", "        .isWithin(ALLOWED_ERROR)\n"], "15": ["    assertThat(oneValueAccumulator.max()).isWithin(ALLOWED_ERROR).of(ONE_VALUE);\n", "    assertThat(oneValueAccumulatorByAddAllEmptyStats.max()).isWithin(ALLOWED_ERROR).of(ONE_VALUE);\n", "    assertThat(twoValuesAccumulator.max()).isWithin(ALLOWED_ERROR).of(TWO_VALUES_MAX);\n", "    assertThat(twoValuesAccumulatorByAddAllStats.max()).isWithin(ALLOWED_ERROR).of(TWO_VALUES_MAX);\n", "    assertThat(manyValuesAccumulatorByAddAllIterable.max())\n", "        .isWithin(ALLOWED_ERROR)\n", "        .of(MANY_VALUES_MAX);\n", "    assertThat(manyValuesAccumulatorByAddAllIterator.max())\n", "        .isWithin(ALLOWED_ERROR)\n", "        .of(MANY_VALUES_MAX);\n", "    assertThat(manyValuesAccumulatorByAddAllVarargs.max())\n", "        .isWithin(ALLOWED_ERROR)\n", "        .of(MANY_VALUES_MAX);\n", "    assertThat(manyValuesAccumulatorByRepeatedAdd.max())\n", "        .isWithin(ALLOWED_ERROR)\n", "        .of(MANY_VALUES_MAX);\n", "    assertThat(manyValuesAccumulatorByAddAndAddAll.max())\n", "        .isWithin(ALLOWED_ERROR)\n", "        .of(MANY_VALUES_MAX);\n", "    assertThat(manyValuesAccumulatorByAddAllStats.max())\n", "        .isWithin(ALLOWED_ERROR)\n", "        .of(MANY_VALUES_MAX);\n"], "16": ["        assertWithMessage(\"max of \" + values).that(max).isWithin(ALLOWED_ERROR).of(MANY_VALUES_MAX);\n", "            .isWithin(ALLOWED_ERROR)\n", "            .of(MANY_VALUES_MAX);\n", "        .isWithin(ALLOWED_ERROR)\n", "        .of(INTEGER_MANY_VALUES_MAX);\n", "    assertThat(longManyValuesAccumulatorByAddAllIterator.max())\n", "        .isWithin(ALLOWED_ERROR)\n", "        .of(LONG_MANY_VALUES_MAX);\n", "    assertThat(longManyValuesAccumulatorByAddAllVarargs.max())\n", "        .isWithin(ALLOWED_ERROR)\n", "        .of(LONG_MANY_VALUES_MAX);\n"], "17": ["    assertThat(oneValueAccumulator.min()).isWithin(ALLOWED_ERROR).of(ONE_VALUE);\n", "    assertThat(oneValueAccumulatorByAddAllEmptyStats.min()).isWithin(ALLOWED_ERROR).of(ONE_VALUE);\n", "    assertThat(twoValuesAccumulator.min()).isWithin(ALLOWED_ERROR).of(TWO_VALUES_MIN);\n", "    assertThat(twoValuesAccumulatorByAddAllStats.min()).isWithin(ALLOWED_ERROR).of(TWO_VALUES_MIN);\n", "    assertThat(manyValuesAccumulatorByAddAllIterable.min())\n", "        .isWithin(ALLOWED_ERROR)\n", "        .of(MANY_VALUES_MIN);\n", "    assertThat(manyValuesAccumulatorByAddAllIterator.min())\n", "        .isWithin(ALLOWED_ERROR)\n", "        .of(MANY_VALUES_MIN);\n", "    assertThat(manyValuesAccumulatorByAddAllVarargs.min())\n", "        .isWithin(ALLOWED_ERROR)\n", "        .of(MANY_VALUES_MIN);\n", "    assertThat(manyValuesAccumulatorByRepeatedAdd.min())\n", "        .isWithin(ALLOWED_ERROR)\n", "        .of(MANY_VALUES_MIN);\n", "    assertThat(manyValuesAccumulatorByAddAndAddAll.min())\n", "        .isWithin(ALLOWED_ERROR)\n", "        .of(MANY_VALUES_MIN);\n", "    assertThat(manyValuesAccumulatorByAddAllStats.min())\n", "        .isWithin(ALLOWED_ERROR)\n", "        .of(MANY_VALUES_MIN);\n"], "18": ["        assertWithMessage(\"min of \" + values).that(min).isWithin(ALLOWED_ERROR).of(MANY_VALUES_MIN);\n", "            .isWithin(ALLOWED_ERROR)\n", "            .of(MANY_VALUES_MIN);\n", "        .isWithin(ALLOWED_ERROR)\n", "        .of(INTEGER_MANY_VALUES_MIN);\n", "    assertThat(longManyValuesAccumulatorByAddAllIterator.min())\n", "        .isWithin(ALLOWED_ERROR)\n", "        .of(LONG_MANY_VALUES_MIN);\n", "    assertThat(longManyValuesAccumulatorByAddAllVarargs.min())\n", "        .isWithin(ALLOWED_ERROR)\n", "        .of(LONG_MANY_VALUES_MIN);\n"]}, "added_lines": {"1": [39, 40, 41, 42, 43], "2": [51, 52], "3": [86], "4": [141, 142, 143, 144, 145, 146], "5": [157, 158, 159, 160, 161, 162], "6": [177], "7": [237, 238, 239], "8": [279, 282, 285], "9": [317, 319, 320, 321, 324, 327], "10": [373, 374, 375], "11": [404, 407, 410], "12": [458, 460, 461, 462, 465, 468], "13": [522, 524, 525, 526, 529, 532], "14": [586, 588, 589, 590, 593, 596], "15": [616, 617, 618, 619, 620, 621, 622, 623, 624, 625, 626], "16": [647, 650, 654, 655, 656], "17": [675, 676, 677, 678, 679, 680, 681, 682, 683, 684, 685], "18": [706, 709, 713, 714, 715, 716, 717, 718, 719, 720, 721, 722, 723, 724, 725, 726, 727, 728, 729, 730, 731, 732, 733, 734, 735, 736, 737, 738, 739, 740, 741, 742, 743, 744, 745, 746, 747, 748, 749, 750, 751, 752, 753, 754]}, "removed_lines": {"8": [255, 258, 261], "9": [293, 297, 300], "11": [374, 377, 380], "12": [428, 432, 435], "13": [489, 493, 496], "14": [550, 554, 557], "15": [577, 578, 579, 580, 581, 582, 583, 584, 585, 586, 587, 588, 589, 590, 591, 592, 593, 594, 595, 596, 597, 598], "16": [619, 622, 623, 627, 628, 629, 630, 631, 632, 633, 634], "17": [653, 654, 655, 656, 657, 658, 659, 660, 661, 662, 663, 664, 665, 666, 667, 668, 669, 670, 671, 672, 673, 674], "18": [695, 698, 699, 703, 704, 705, 706, 707, 708, 709, 710]}}, {"6": "guava-tests/test/com/google/common/math/StatsTest.java", "added": {"1": ["import static com.google.common.math.Stats.toStats;\n"], "2": ["import static com.google.common.math.StatsTesting.MEGA_STREAM_COUNT;\n", "import static com.google.common.math.StatsTesting.MEGA_STREAM_MAX;\n", "import static com.google.common.math.StatsTesting.MEGA_STREAM_MEAN;\n", "import static com.google.common.math.StatsTesting.MEGA_STREAM_MIN;\n", "import static com.google.common.math.StatsTesting.MEGA_STREAM_POPULATION_VARIANCE;\n"], "3": ["import static com.google.common.math.StatsTesting.megaPrimitiveDoubleStream;\n"], "4": ["import java.math.BigDecimal;\n"], "5": ["        .isWithin(ALLOWED_ERROR * INTEGER_MANY_VALUES_MEAN)\n", "        .isWithin(ALLOWED_ERROR * INTEGER_MANY_VALUES_MEAN)\n", "        .isWithin(ALLOWED_ERROR * LONG_MANY_VALUES_MEAN)\n", "        .isWithin(ALLOWED_ERROR * LONG_MANY_VALUES_MEAN)\n"], "6": ["        .isWithin(ALLOWED_ERROR * INTEGER_MANY_VALUES_MEAN)\n", "        .isWithin(ALLOWED_ERROR * INTEGER_MANY_VALUES_MEAN)\n", "        .isWithin(ALLOWED_ERROR * LONG_MANY_VALUES_MEAN)\n", "        .isWithin(ALLOWED_ERROR * LONG_MANY_VALUES_MEAN)\n"], "7": ["        .isWithin(ALLOWED_ERROR * INTEGER_MANY_VALUES_SUM_OF_SQUARES_OF_DELTAS)\n", "        .isWithin(ALLOWED_ERROR * INTEGER_MANY_VALUES_SUM_OF_SQUARES_OF_DELTAS)\n", "        .isWithin(ALLOWED_ERROR * LONG_MANY_VALUES_SUM_OF_SQUARES_OF_DELTAS)\n", "        .isWithin(ALLOWED_ERROR * LONG_MANY_VALUES_SUM_OF_SQUARES_OF_DELTAS)\n"], "8": ["        .isWithin(ALLOWED_ERROR * sqrt(INTEGER_MANY_VALUES_SUM_OF_SQUARES_OF_DELTAS))\n", "        .isWithin(ALLOWED_ERROR * sqrt(INTEGER_MANY_VALUES_SUM_OF_SQUARES_OF_DELTAS))\n", "        .isWithin(ALLOWED_ERROR * sqrt(LONG_MANY_VALUES_SUM_OF_SQUARES_OF_DELTAS))\n", "        .isWithin(ALLOWED_ERROR * sqrt(LONG_MANY_VALUES_SUM_OF_SQUARES_OF_DELTAS))\n"], "9": ["        .isWithin(ALLOWED_ERROR * INTEGER_MANY_VALUES_SUM_OF_SQUARES_OF_DELTAS)\n", "        .isWithin(ALLOWED_ERROR * INTEGER_MANY_VALUES_SUM_OF_SQUARES_OF_DELTAS)\n", "        .isWithin(ALLOWED_ERROR * LONG_MANY_VALUES_SUM_OF_SQUARES_OF_DELTAS)\n", "        .isWithin(ALLOWED_ERROR * LONG_MANY_VALUES_SUM_OF_SQUARES_OF_DELTAS)\n"], "10": ["        .isWithin(ALLOWED_ERROR * sqrt(INTEGER_MANY_VALUES_SUM_OF_SQUARES_OF_DELTAS))\n", "        .isWithin(ALLOWED_ERROR * sqrt(INTEGER_MANY_VALUES_SUM_OF_SQUARES_OF_DELTAS))\n", "        .isWithin(ALLOWED_ERROR * sqrt(LONG_MANY_VALUES_SUM_OF_SQUARES_OF_DELTAS))\n", "        .isWithin(ALLOWED_ERROR * sqrt(LONG_MANY_VALUES_SUM_OF_SQUARES_OF_DELTAS))\n"], "11": ["    assertThat(ONE_VALUE_STATS.max()).isEqualTo(ONE_VALUE);\n", "    assertThat(TWO_VALUES_STATS.max()).isEqualTo(TWO_VALUES_MAX);\n", "    assertThat(MANY_VALUES_STATS_VARARGS.max()).isEqualTo(MANY_VALUES_MAX);\n", "    assertThat(MANY_VALUES_STATS_ITERABLE.max()).isEqualTo(MANY_VALUES_MAX);\n"], "12": ["        assertWithMessage(\"max of \" + values).that(max).isEqualTo(MANY_VALUES_MAX);\n", "    assertThat(MANY_VALUES_STATS_SNAPSHOT.max()).isEqualTo(MANY_VALUES_MAX);\n", "    assertThat(INTEGER_MANY_VALUES_STATS_VARARGS.max()).isEqualTo(INTEGER_MANY_VALUES_MAX);\n", "    assertThat(INTEGER_MANY_VALUES_STATS_ITERABLE.max()).isEqualTo(INTEGER_MANY_VALUES_MAX);\n", "    assertThat(LONG_MANY_VALUES_STATS_ITERATOR.max()).isEqualTo(LONG_MANY_VALUES_MAX);\n", "    assertThat(LONG_MANY_VALUES_STATS_SNAPSHOT.max()).isEqualTo(LONG_MANY_VALUES_MAX);\n"], "13": ["    assertThat(ONE_VALUE_STATS.min()).isEqualTo(ONE_VALUE);\n", "    assertThat(TWO_VALUES_STATS.min()).isEqualTo(TWO_VALUES_MIN);\n", "    assertThat(MANY_VALUES_STATS_VARARGS.min()).isEqualTo(MANY_VALUES_MIN);\n", "    assertThat(MANY_VALUES_STATS_ITERABLE.min()).isEqualTo(MANY_VALUES_MIN);\n", "    assertThat(MANY_VALUES_STATS_ITERATOR.min()).isEqualTo(MANY_VALUES_MIN);\n"], "14": ["        assertWithMessage(\"min of \" + values).that(min).isEqualTo(MANY_VALUES_MIN);\n", "    assertThat(INTEGER_MANY_VALUES_STATS_VARARGS.min()).isEqualTo(INTEGER_MANY_VALUES_MIN);\n", "    assertThat(INTEGER_MANY_VALUES_STATS_ITERABLE.min()).isEqualTo(INTEGER_MANY_VALUES_MIN);\n", "    assertThat(LONG_MANY_VALUES_STATS_ITERATOR.min()).isEqualTo(LONG_MANY_VALUES_MIN);\n", "    assertThat(LONG_MANY_VALUES_STATS_SNAPSHOT.min()).isEqualTo(LONG_MANY_VALUES_MIN);\n", "  }\n", "\n", "  public void testOfPrimitiveDoubleStream() {\n", "    Stats stats = Stats.of(megaPrimitiveDoubleStream());\n", "    assertThat(stats.count()).isEqualTo(MEGA_STREAM_COUNT);\n", "    assertThat(stats.mean()).isWithin(ALLOWED_ERROR * MEGA_STREAM_COUNT).of(MEGA_STREAM_MEAN);\n", "    assertThat(stats.populationVariance())\n", "        .isWithin(ALLOWED_ERROR * MEGA_STREAM_COUNT)\n", "        .of(MEGA_STREAM_POPULATION_VARIANCE);\n", "    assertThat(stats.min()).isEqualTo(MEGA_STREAM_MIN);\n", "    assertThat(stats.max()).isEqualTo(MEGA_STREAM_MAX);\n", "  }\n", "\n", "  public void testOfPrimitiveIntStream() {\n", "    Stats stats = Stats.of(megaPrimitiveDoubleStream().mapToInt(x -> (int) x));\n", "    assertThat(stats.count()).isEqualTo(MEGA_STREAM_COUNT);\n", "    assertThat(stats.mean()).isWithin(ALLOWED_ERROR * MEGA_STREAM_COUNT).of(MEGA_STREAM_MEAN);\n", "    assertThat(stats.populationVariance())\n", "        .isWithin(ALLOWED_ERROR * MEGA_STREAM_COUNT)\n", "        .of(MEGA_STREAM_POPULATION_VARIANCE);\n", "    assertThat(stats.min()).isEqualTo(MEGA_STREAM_MIN);\n", "    assertThat(stats.max()).isEqualTo(MEGA_STREAM_MAX);\n", "  }\n", "\n", "  public void testOfPrimitiveLongStream() {\n", "    Stats stats = Stats.of(megaPrimitiveDoubleStream().mapToLong(x -> (long) x));\n", "    assertThat(stats.count()).isEqualTo(MEGA_STREAM_COUNT);\n", "    assertThat(stats.mean()).isWithin(ALLOWED_ERROR * MEGA_STREAM_COUNT).of(MEGA_STREAM_MEAN);\n", "    assertThat(stats.populationVariance())\n", "        .isWithin(ALLOWED_ERROR * MEGA_STREAM_COUNT)\n", "        .of(MEGA_STREAM_POPULATION_VARIANCE);\n", "    assertThat(stats.min()).isEqualTo(MEGA_STREAM_MIN);\n", "    assertThat(stats.max()).isEqualTo(MEGA_STREAM_MAX);\n", "  }\n", "\n", "  public void testBoxedDoubleStreamToStats() {\n", "    Stats stats = megaPrimitiveDoubleStream().boxed().collect(toStats());\n", "    assertThat(stats.count()).isEqualTo(MEGA_STREAM_COUNT);\n", "    assertThat(stats.mean()).isWithin(ALLOWED_ERROR * MEGA_STREAM_COUNT).of(MEGA_STREAM_MEAN);\n", "    assertThat(stats.populationVariance())\n", "        .isWithin(ALLOWED_ERROR * MEGA_STREAM_COUNT)\n", "        .of(MEGA_STREAM_POPULATION_VARIANCE);\n", "    assertThat(stats.min()).isEqualTo(MEGA_STREAM_MIN);\n", "    assertThat(stats.max()).isEqualTo(MEGA_STREAM_MAX);\n", "  }\n", "\n", "  public void testBoxedBigDecimalStreamToStats() {\n", "    Stats stats = megaPrimitiveDoubleStream().mapToObj(BigDecimal::valueOf).collect(toStats());\n", "    assertThat(stats.count()).isEqualTo(MEGA_STREAM_COUNT);\n", "    assertThat(stats.mean()).isWithin(ALLOWED_ERROR * MEGA_STREAM_COUNT).of(MEGA_STREAM_MEAN);\n", "    assertThat(stats.populationVariance())\n", "        .isWithin(ALLOWED_ERROR * MEGA_STREAM_COUNT)\n", "        .of(MEGA_STREAM_POPULATION_VARIANCE);\n", "    assertThat(stats.min()).isEqualTo(MEGA_STREAM_MIN);\n", "    assertThat(stats.max()).isEqualTo(MEGA_STREAM_MAX);\n"], "15": ["        .isWithin(ALLOWED_ERROR * INTEGER_MANY_VALUES_MEAN)\n", "        .isWithin(ALLOWED_ERROR * INTEGER_MANY_VALUES_MEAN)\n", "    assertThat(Stats.meanOf(LONG_MANY_VALUES))\n", "        .isWithin(ALLOWED_ERROR * LONG_MANY_VALUES_MEAN)\n", "        .of(LONG_MANY_VALUES_MEAN);\n", "        .isWithin(ALLOWED_ERROR * LONG_MANY_VALUES_MEAN)\n"]}, "removed": {"5": ["        .isWithin(ALLOWED_ERROR)\n", "        .isWithin(ALLOWED_ERROR)\n", "        .isWithin(ALLOWED_ERROR)\n", "        .isWithin(ALLOWED_ERROR)\n"], "6": ["        .isWithin(ALLOWED_ERROR)\n", "        .isWithin(ALLOWED_ERROR)\n", "        .isWithin(ALLOWED_ERROR)\n", "        .isWithin(ALLOWED_ERROR)\n"], "7": ["        .isWithin(ALLOWED_ERROR)\n", "        .isWithin(ALLOWED_ERROR)\n", "        .isWithin(ALLOWED_ERROR)\n", "        .isWithin(ALLOWED_ERROR)\n"], "8": ["        .isWithin(ALLOWED_ERROR)\n", "        .isWithin(ALLOWED_ERROR)\n", "        .isWithin(ALLOWED_ERROR)\n", "        .isWithin(ALLOWED_ERROR)\n"], "9": ["        .isWithin(ALLOWED_ERROR)\n", "        .isWithin(ALLOWED_ERROR)\n", "        .isWithin(ALLOWED_ERROR)\n", "        .isWithin(ALLOWED_ERROR)\n"], "10": ["        .isWithin(ALLOWED_ERROR)\n", "        .isWithin(ALLOWED_ERROR)\n", "        .isWithin(ALLOWED_ERROR)\n", "        .isWithin(ALLOWED_ERROR)\n"], "11": ["    assertThat(ONE_VALUE_STATS.max()).isWithin(ALLOWED_ERROR).of(ONE_VALUE);\n", "    assertThat(TWO_VALUES_STATS.max()).isWithin(ALLOWED_ERROR).of(TWO_VALUES_MAX);\n", "    assertThat(MANY_VALUES_STATS_VARARGS.max()).isWithin(ALLOWED_ERROR).of(MANY_VALUES_MAX);\n", "    assertThat(MANY_VALUES_STATS_ITERABLE.max()).isWithin(ALLOWED_ERROR).of(MANY_VALUES_MAX);\n"], "12": ["        assertWithMessage(\"max of \" + values).that(max).isWithin(ALLOWED_ERROR).of(MANY_VALUES_MAX);\n", "    assertThat(MANY_VALUES_STATS_SNAPSHOT.max()).isWithin(ALLOWED_ERROR).of(MANY_VALUES_MAX);\n", "    assertThat(INTEGER_MANY_VALUES_STATS_VARARGS.max())\n", "        .isWithin(ALLOWED_ERROR)\n", "        .of(INTEGER_MANY_VALUES_MAX);\n", "    assertThat(INTEGER_MANY_VALUES_STATS_ITERABLE.max())\n", "        .isWithin(ALLOWED_ERROR)\n", "        .of(INTEGER_MANY_VALUES_MAX);\n", "    assertThat(LONG_MANY_VALUES_STATS_ITERATOR.max())\n", "        .isWithin(ALLOWED_ERROR)\n", "        .of(LONG_MANY_VALUES_MAX);\n", "    assertThat(LONG_MANY_VALUES_STATS_SNAPSHOT.max())\n", "        .isWithin(ALLOWED_ERROR)\n", "        .of(LONG_MANY_VALUES_MAX);\n"], "13": ["    assertThat(ONE_VALUE_STATS.min()).isWithin(ALLOWED_ERROR).of(ONE_VALUE);\n", "    assertThat(TWO_VALUES_STATS.min()).isWithin(ALLOWED_ERROR).of(TWO_VALUES_MIN);\n", "    assertThat(MANY_VALUES_STATS_VARARGS.min()).isWithin(ALLOWED_ERROR).of(MANY_VALUES_MIN);\n", "    assertThat(MANY_VALUES_STATS_ITERABLE.min()).isWithin(ALLOWED_ERROR).of(MANY_VALUES_MIN);\n", "    assertThat(MANY_VALUES_STATS_ITERATOR.min()).isWithin(ALLOWED_ERROR).of(MANY_VALUES_MIN);\n"], "14": ["        assertWithMessage(\"min of \" + values).that(min).isWithin(ALLOWED_ERROR).of(MANY_VALUES_MIN);\n", "    assertThat(INTEGER_MANY_VALUES_STATS_VARARGS.min())\n", "        .isWithin(ALLOWED_ERROR)\n", "        .of(INTEGER_MANY_VALUES_MIN);\n", "    assertThat(INTEGER_MANY_VALUES_STATS_ITERABLE.min())\n", "        .isWithin(ALLOWED_ERROR)\n", "        .of(INTEGER_MANY_VALUES_MIN);\n", "    assertThat(LONG_MANY_VALUES_STATS_ITERATOR.min())\n", "        .isWithin(ALLOWED_ERROR)\n", "        .of(LONG_MANY_VALUES_MIN);\n", "    assertThat(LONG_MANY_VALUES_STATS_SNAPSHOT.min())\n", "        .isWithin(ALLOWED_ERROR)\n", "        .of(LONG_MANY_VALUES_MIN);\n"], "15": ["        .isWithin(ALLOWED_ERROR)\n", "        .isWithin(ALLOWED_ERROR)\n", "    assertThat(Stats.meanOf(LONG_MANY_VALUES)).isWithin(ALLOWED_ERROR).of(LONG_MANY_VALUES_MEAN);\n", "        .isWithin(ALLOWED_ERROR)\n"]}, "added_lines": {"1": [19], "2": [59, 60, 61, 62, 63], "3": [72], "4": [87], "5": [158, 161, 167, 170], "6": [195, 198, 201, 204], "7": [249, 252, 258, 261], "8": [296, 299, 302, 305], "9": [341, 344, 347, 350], "10": [386, 389, 392, 395], "11": [410, 414, 415, 416], "12": [426, 429, 430, 431, 432, 433], "13": [447, 451, 452, 453, 454], "14": [466, 469, 470, 471, 472, 473, 474, 475, 476, 477, 478, 479, 480, 481, 482, 483, 484, 485, 486, 487, 488, 489, 490, 491, 492, 493, 494, 495, 496, 497, 498, 499, 500, 501, 502, 503, 504, 505, 506, 507, 508, 509, 510, 511, 512, 513, 514, 515, 516, 517, 518, 519, 520, 521, 522, 523, 524, 525, 526, 527], "15": [610, 613, 615, 616, 617, 619]}, "removed_lines": {"5": [150, 153, 159, 162], "6": [187, 190, 193, 196], "7": [241, 244, 250, 253], "8": [288, 291, 294, 297], "9": [333, 336, 339, 342], "10": [378, 381, 384, 387], "11": [402, 406, 407, 408], "12": [418, 421, 422, 423, 424, 425, 426, 427, 428, 429, 430, 431, 432, 433], "13": [447, 451, 452, 453, 454], "14": [466, 469, 470, 471, 472, 473, 474, 475, 476, 477, 478, 479, 480], "15": [563, 566, 568, 570]}}, {"7": "guava-tests/test/com/google/common/math/StatsTesting.java", "added": {"1": ["import java.util.stream.DoubleStream;\n"], "2": ["  /**\n", "   * Returns a stream of a million primitive doubles. The stream is parallel, which should cause\n", "   * {@code collect} calls to run in multi-threaded mode, so testing the combiner as well as the\n", "   * supplier and accumulator.\n", "   */\n", "  static DoubleStream megaPrimitiveDoubleStream() {\n", "    return DoubleStream.iterate(0.0, x -> x + 1.0).limit(MEGA_STREAM_COUNT).parallel();\n", "  }\n", "\n", "  /** Returns a stream containing half the values from {@link #megaPrimitiveDoubleStream}. */\n", "  static DoubleStream megaPrimitiveDoubleStreamPart1() {\n", "    return DoubleStream.iterate(0.0, x -> x + 2.0).limit(MEGA_STREAM_COUNT / 2).parallel();\n", "  }\n", "\n", "  /**\n", "   * Returns a stream containing the values from {@link #megaPrimitiveDoubleStream} not in {@link\n", "   * #megaPrimitiveDoubleStreamPart1()}.\n", "   */\n", "  static DoubleStream megaPrimitiveDoubleStreamPart2() {\n", "    return DoubleStream.iterate(999_999.0, x -> x - 2.0).limit(MEGA_STREAM_COUNT / 2).parallel();\n", "  }\n", "\n", "  static final long MEGA_STREAM_COUNT = 1_000_000;\n", "  static final double MEGA_STREAM_MEAN = 999_999.0 / 2;\n", "  static final double MEGA_STREAM_POPULATION_VARIANCE = 999_999.0 * 1_000_001.0 / 12;\n", "  static final double MEGA_STREAM_MIN = 0.0;\n", "  static final double MEGA_STREAM_MAX = 999_999.0;\n", "\n"], "3": ["  static final Stats MANY_VALUES_STATS_SNAPSHOT = buildManyValuesStatsSnapshot();\n"], "4": ["  static final Stats LONG_MANY_VALUES_STATS_SNAPSHOT = buildLongManyValuesStatsSnapshot();\n", "  private static Stats buildManyValuesStatsSnapshot() {\n", "    Stats stats = accumulator.snapshot();\n", "    return stats;\n", "  private static Stats buildLongManyValuesStatsSnapshot() {\n", "    return accumulator.snapshot();\n"], "5": ["  static final PairedStats MANY_VALUES_PAIRED_STATS = buildManyValuesPairedStats();\n", "  static final PairedStats HORIZONTAL_VALUES_PAIRED_STATS = buildHorizontalValuesPairedStats();\n", "  static final PairedStats VERTICAL_VALUES_PAIRED_STATS = buildVerticalValuesPairedStats();\n", "  static final PairedStats CONSTANT_VALUES_PAIRED_STATS = buildConstantValuesPairedStats();\n", "  private static PairedStats buildManyValuesPairedStats() {\n", "    PairedStats stats = accumulator.snapshot();\n", "    return stats;\n", "  private static PairedStats buildHorizontalValuesPairedStats() {\n", "    return accumulator.snapshot();\n", "  private static PairedStats buildVerticalValuesPairedStats() {\n", "    return accumulator.snapshot();\n", "  private static PairedStats buildConstantValuesPairedStats() {\n", "    return accumulator.snapshot();\n"]}, "removed": {"3": ["  static final Stats MANY_VALUES_STATS_SNAPSHOT;\n"], "4": ["  static final Stats LONG_MANY_VALUES_STATS_SNAPSHOT;\n", "  static {\n", "    MANY_VALUES_STATS_SNAPSHOT = accumulator.snapshot();\n", "  static {\n", "    LONG_MANY_VALUES_STATS_SNAPSHOT = accumulator.snapshot();\n"], "5": ["  static final PairedStats MANY_VALUES_PAIRED_STATS;\n", "  static final PairedStats HORIZONTAL_VALUES_PAIRED_STATS;\n", "  static final PairedStats VERTICAL_VALUES_PAIRED_STATS;\n", "  static final PairedStats CONSTANT_VALUES_PAIRED_STATS;\n", "  static {\n", "    MANY_VALUES_PAIRED_STATS = accumulator.snapshot();\n", "  static {\n", "    HORIZONTAL_VALUES_PAIRED_STATS = accumulator.snapshot();\n", "  static {\n", "    VERTICAL_VALUES_PAIRED_STATS = accumulator.snapshot();\n", "  static {\n", "    CONSTANT_VALUES_PAIRED_STATS = accumulator.snapshot();\n"]}, "added_lines": {"1": [34], "2": [215, 216, 217, 218, 219, 220, 221, 222, 223, 224, 225, 226, 227, 228, 229, 230, 231, 232, 233, 234, 235, 236, 237, 238, 239, 240, 241, 242], "3": [254], "4": [262, 265, 268, 270, 273, 276], "5": [308, 311, 312, 313, 315, 318, 320, 323, 328, 331, 336, 339, 344]}, "removed_lines": {"3": [225], "4": [233, 236, 239, 243, 246], "5": [278, 281, 282, 283, 285, 288, 292, 297, 300, 305, 308, 313]}}, {"8": "guava/src/com/google/common/math/Stats.java", "added": {"1": ["import java.util.stream.Collector;\n", "import java.util.stream.DoubleStream;\n", "import java.util.stream.IntStream;\n", "import java.util.stream.LongStream;\n"], "2": ["   * Returns statistics over a dataset containing the given values. The iterator will be completely\n", "   * consumed by this method.\n"], "3": ["  /**\n", "   * Returns statistics over a dataset containing the given values. The stream will be completely\n", "   * consumed by this method.\n", "   *\n", "   * <p>If you have a {@code Stream<Double>} rather than a {@code DoubleStream}, you should collect\n", "   * the values using {@link #toStats()} instead.\n", "   *\n", "   * @param values a series of values\n", "   * @since NEXT\n", "   */\n", "  public static Stats of(DoubleStream values) {\n", "    return values\n", "        .collect(StatsAccumulator::new, StatsAccumulator::add, StatsAccumulator::addAll)\n", "        .snapshot();\n", "  }\n", "\n", "  /**\n", "   * Returns statistics over a dataset containing the given values. The stream will be completely\n", "   * consumed by this method.\n", "   *\n", "   * <p>If you have a {@code Stream<Integer>} rather than an {@code IntStream}, you should collect\n", "   * the values using {@link #toStats()} instead.\n", "   *\n", "   * @param values a series of values\n", "   * @since NEXT\n", "   */\n", "  public static Stats of(IntStream values) {\n", "    return values\n", "        .collect(StatsAccumulator::new, StatsAccumulator::add, StatsAccumulator::addAll)\n", "        .snapshot();\n", "  }\n", "\n", "  /**\n", "   * Returns statistics over a dataset containing the given values. The stream will be completely\n", "   * consumed by this method.\n", "   *\n", "   * <p>If you have a {@code Stream<Long>} rather than a {@code LongStream}, you should collect the\n", "   * values using {@link #toStats()} instead.\n", "   *\n", "   * @param values a series of values, which will be converted to {@code double} values (this may\n", "   *     cause loss of precision for longs of magnitude over 2^53 (slightly over 9e15))\n", "   * @since NEXT\n", "   */\n", "  public static Stats of(LongStream values) {\n", "    return values\n", "        .collect(StatsAccumulator::new, StatsAccumulator::add, StatsAccumulator::addAll)\n", "        .snapshot();\n", "  }\n", "\n", "  /**\n", "   * Returns a {@link Collector} which accumulates statistics from a {@link java.util.stream.Stream}\n", "   * of any type of boxed {@link Number} into a {@link Stats}. Use by calling {@code\n", "   * boxedNumericStream.collect(toStats())}. The numbers will be converted to {@code double} values\n", "   * (which may cause loss of precision).\n", "   *\n", "   * <p>If you have any of the primitive streams {@code DoubleStream}, {@code IntStream}, or {@code\n", "   * LongStream}, you should use the factory method {@link #of} instead.\n", "   *\n", "   * @since NEXT\n", "   */\n", "  public static Collector<Number, StatsAccumulator, Stats> toStats() {\n", "    return Collector.of(\n", "        StatsAccumulator::new,\n", "        (a, x) -> a.add(x.doubleValue()),\n", "        (l, r) -> {\n", "          l.addAll(r);\n", "          return l;\n", "        },\n", "        StatsAccumulator::snapshot,\n", "        Collector.Characteristics.UNORDERED);\n", "  }\n", "\n"]}, "removed": {"2": ["   * Returns statistics over a dataset containing the given values.\n"]}, "added_lines": {"1": [35, 36, 37, 38], "2": [110, 111], "3": [156, 157, 158, 159, 160, 161, 162, 163, 164, 165, 166, 167, 168, 169, 170, 171, 172, 173, 174, 175, 176, 177, 178, 179, 180, 181, 182, 183, 184, 185, 186, 187, 188, 189, 190, 191, 192, 193, 194, 195, 196, 197, 198, 199, 200, 201, 202, 203, 204, 205, 206, 207, 208, 209, 210, 211, 212, 213, 214, 215, 216, 217, 218, 219, 220, 221, 222, 223, 224, 225, 226, 227]}, "removed_lines": {"2": [106]}}, {"9": "guava/src/com/google/common/math/StatsAccumulator.java", "added": {"1": ["import java.util.stream.DoubleStream;\n", "import java.util.stream.IntStream;\n", "import java.util.stream.LongStream;\n"], "2": ["  /**\n", "   * Adds the given values to the dataset. The stream will be completely consumed by this method.\n", "   *\n", "   * @param values a series of values\n", "   * @since NEXT\n", "   */\n", "  public void addAll(DoubleStream values) {\n", "    addAll(values.collect(StatsAccumulator::new, StatsAccumulator::add, StatsAccumulator::addAll));\n", "  }\n", "\n", "  /**\n", "   * Adds the given values to the dataset. The stream will be completely consumed by this method.\n", "   *\n", "   * @param values a series of values\n", "   * @since NEXT\n", "   */\n", "  public void addAll(IntStream values) {\n", "    addAll(values.collect(StatsAccumulator::new, StatsAccumulator::add, StatsAccumulator::addAll));\n", "  }\n", "\n", "  /**\n", "   * Adds the given values to the dataset. The stream will be completely consumed by this method.\n", "   *\n", "   * @param values a series of values, which will be converted to {@code double} values (this may\n", "   *     cause loss of precision for longs of magnitude over 2^53 (slightly over 9e15))\n", "   * @since NEXT\n", "   */\n", "  public void addAll(LongStream values) {\n", "    addAll(values.collect(StatsAccumulator::new, StatsAccumulator::add, StatsAccumulator::addAll));\n", "  }\n", "\n"], "3": ["    merge(values.count(), values.mean(), values.sumOfSquaresOfDeltas(), values.min(), values.max());\n", "  }\n", "\n", "  /**\n", "   * Adds the given statistics to the dataset, as if the individual values used to compute the\n", "   * statistics had been added directly.\n", "   *\n", "   * @since NEXT\n", "   */\n", "  public void addAll(StatsAccumulator values) {\n", "    if (values.count() == 0) {\n", "      return;\n", "    }\n", "    merge(values.count(), values.mean(), values.sumOfSquaresOfDeltas(), values.min(), values.max());\n", "  }\n", "  private void merge(\n", "      long otherCount,\n", "      double otherMean,\n", "      double otherSumOfSquaresOfDeltas,\n", "      double otherMin,\n", "      double otherMax) {\n", "      count = otherCount;\n", "      mean = otherMean;\n", "      sumOfSquaresOfDeltas = otherSumOfSquaresOfDeltas;\n", "      min = otherMin;\n", "      max = otherMax;\n", "      count += otherCount;\n", "      if (isFinite(mean) && isFinite(otherMean)) {\n", "        double delta = otherMean - mean;\n", "        mean += delta * otherCount / count;\n", "        sumOfSquaresOfDeltas += otherSumOfSquaresOfDeltas + delta * (otherMean - mean) * otherCount;\n", "        mean = calculateNewMeanNonFinite(mean, otherMean);\n", "      min = Math.min(min, otherMin);\n", "      max = Math.max(max, otherMax);\n"]}, "removed": {"3": ["      count = values.count();\n", "      mean = values.mean();\n", "      sumOfSquaresOfDeltas = values.sumOfSquaresOfDeltas();\n", "      min = values.min();\n", "      max = values.max();\n", "      count += values.count();\n", "      if (isFinite(mean) && isFinite(values.mean())) {\n", "        double delta = values.mean() - mean;\n", "        mean += delta * values.count() / count;\n", "        sumOfSquaresOfDeltas +=\n", "            values.sumOfSquaresOfDeltas() + delta * (values.mean() - mean) * values.count();\n", "        mean = calculateNewMeanNonFinite(mean, values.mean());\n", "      min = Math.min(min, values.min());\n", "      max = Math.max(max, values.max());\n"]}, "added_lines": {"1": [26, 27, 28], "2": [134, 135, 136, 137, 138, 139, 140, 141, 142, 143, 144, 145, 146, 147, 148, 149, 150, 151, 152, 153, 154, 155, 156, 157, 158, 159, 160, 161, 162, 163, 164], "3": [173, 174, 175, 176, 177, 178, 179, 180, 181, 182, 183, 184, 185, 186, 187, 189, 190, 191, 192, 193, 194, 196, 197, 198, 199, 200, 202, 203, 205, 206, 207, 209, 212, 213]}, "removed_lines": {"3": [141, 142, 143, 144, 145, 147, 148, 150, 151, 152, 153, 155, 158, 159]}}]}
