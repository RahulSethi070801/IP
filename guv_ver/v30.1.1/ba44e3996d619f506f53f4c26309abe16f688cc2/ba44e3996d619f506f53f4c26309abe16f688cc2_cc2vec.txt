{"id": "ba44e3996d619f506f53f4c26309abe16f688cc2", "code": [{"0": "android/guava/src/com/google/common/cache/CacheBuilder.java", "added": {"1": [" * <p>These features are all optional; caches can be created using all or none of them. By default,\n"], "2": ["  static final Supplier<StatsCounter> CACHE_STATS_COUNTER = SimpleStatsCounter::new;\n"], "3": ["   * same instance, but only the returned reference has the correct generic type information to\n", "   * ensure type safety. For best results, use the standard method-chaining idiom illustrated in the\n", "   * class documentation above, configuring a builder and building your cache in a single statement.\n", "   * Failure to heed this advice can result in a {@link ClassCastException} being thrown by a cache\n", "   * operation at some <i>undefined</i> point in the future.\n"]}, "removed": {"1": [" * <p>These features are all optional; caches can be created using all or none of them. By default\n"], "2": ["  static final Supplier<StatsCounter> CACHE_STATS_COUNTER =\n", "      new Supplier<StatsCounter>() {\n", "        @Override\n", "        public StatsCounter get() {\n", "          return new SimpleStatsCounter();\n", "        }\n", "      };\n"], "3": ["   * same instance, but only the returned reference has the correct generic type information so as\n", "   * to ensure type safety. For best results, use the standard method-chaining idiom illustrated in\n", "   * the class documentation above, configuring a builder and building your cache in a single\n", "   * statement. Failure to heed this advice can result in a {@link ClassCastException} being thrown\n", "   * by a cache operation at some <i>undefined</i> point in the future.\n"]}, "added_lines": {"1": [100], "2": [234], "3": [822, 823, 824, 825, 826]}, "removed_lines": {"1": [100], "2": [234, 235, 236, 237, 238, 239, 240], "3": [828, 829, 830, 831, 832]}}, {"1": "android/guava/src/com/google/common/cache/CacheLoader.java", "added": {"2": ["    return new SupplierToCacheLoader<>(supplier);\n"], "3": ["      public ListenableFuture<V> reload(final K key, final V oldValue) {\n", "            ListenableFutureTask.create(() -> loader.reload(key, oldValue).get());\n"]}, "removed": {"1": ["import java.util.concurrent.Callable;\n"], "2": ["    return new SupplierToCacheLoader<V>(supplier);\n"], "3": ["      public ListenableFuture<V> reload(final K key, final V oldValue) throws Exception {\n", "            ListenableFutureTask.create(\n", "                new Callable<V>() {\n", "                  @Override\n", "                  public V call() throws Exception {\n", "                    return loader.reload(key, oldValue).get();\n", "                  }\n", "                });\n"]}, "added_lines": {"2": [156], "3": [197, 199]}, "removed_lines": {"1": [29], "2": [157], "3": [198, 200, 201, 202, 203, 204, 205, 206]}}, {"2": "android/guava/src/com/google/common/cache/CacheStats.java", "added": {"1": ["   * values. This includes both successful load operations and those that threw exceptions. This is\n", "   * defined as {@code loadSuccessCount + loadExceptionCount}.\n"]}, "removed": {"1": ["   * values. This includes both successful load operations, as well as those that threw exceptions.\n", "   * This is defined as {@code loadSuccessCount + loadExceptionCount}.\n"]}, "added_lines": {"1": [155, 156]}, "removed_lines": {"1": [155, 156]}}, {"3": "android/guava/src/com/google/common/cache/LocalCache.java", "added": {"2": ["            ? LocalCache.discardingQueue()\n", "            : new ConcurrentLinkedQueue<>();\n"], "3": ["     * Returns true if a new value is currently loading, regardless of whether there is an existing\n", "     * value. It is assumed that the return value of this method is constant for any given\n"], "4": ["   * loading, or expired. Unlike {@link Segment#getLiveValue} this method does not attempt to clean\n", "   * up stale entries. As such it should only be called outside a segment context, such as during\n", "   * iteration.\n"], "5": ["      keyReferenceQueue = map.usesKeyReferences() ? new ReferenceQueue<>() : null;\n", "      valueReferenceQueue = map.usesValueReferences() ? new ReferenceQueue<>() : null;\n", "          map.usesAccessQueue() ? new ConcurrentLinkedQueue<>() : LocalCache.discardingQueue();\n", "      writeQueue = map.usesWriteQueue() ? new WriteQueue<>() : LocalCache.discardingQueue();\n", "      accessQueue = map.usesAccessQueue() ? new AccessQueue<>() : LocalCache.discardingQueue();\n"], "6": ["          () -> {\n", "            try {\n", "              getAndRecordStats(key, hash, loadingValueReference, loadingFuture);\n", "            } catch (Throwable t) {\n", "              logger.log(Level.WARNING, \"Exception thrown during refresh\", t);\n", "              loadingValueReference.setException(t);\n"], "7": ["        // all the segment's entries.\n"], "8": ["        if (!isHeldByCurrentThread()) { // don't clean up inside of put\n"], "9": ["            newResult -> {\n", "              LoadingValueReference.this.set(newResult);\n", "              return newResult;\n"], "10": ["    for (Segment<K, V> segment : segments) {\n", "      if (segment.count != 0) {\n", "      sum += segment.modCount;\n", "      for (Segment<K, V> segment : segments) {\n", "        if (segment.count != 0) {\n", "        sum -= segment.modCount;\n"], "11": ["    for (Segment<K, V> segment : segments) {\n", "      sum += Math.max(0, segment.count); // see https://github.com/google/guava/issues/2108\n"], "12": ["    ArrayList<E> result = new ArrayList<>(c.size());\n"], "13": ["    public V apply(K key) {\n"], "14": ["      this(new LocalCache<>(builder, null));\n"], "15": ["      super(new LocalCache<>(builder, checkNotNull(loader)));\n"]}, "removed": {"1": ["import com.google.common.base.Function;\n"], "2": ["            ? LocalCache.<RemovalNotification<K, V>>discardingQueue()\n", "            : new ConcurrentLinkedQueue<RemovalNotification<K, V>>();\n"], "3": ["     * Returns true if a new value is currently loading, regardless of whether or not there is an\n", "     * existing value. It is assumed that the return value of this method is constant for any given\n"], "4": ["   * loading, or expired. Unlike {@link Segment#getLiveValue} this method does not attempt to\n", "   * cleanup stale entries. As such it should only be called outside of a segment context, such as\n", "   * during iteration.\n"], "5": ["      keyReferenceQueue = map.usesKeyReferences() ? new ReferenceQueue<K>() : null;\n", "      valueReferenceQueue = map.usesValueReferences() ? new ReferenceQueue<V>() : null;\n", "          map.usesAccessQueue()\n", "              ? new ConcurrentLinkedQueue<ReferenceEntry<K, V>>()\n", "              : LocalCache.<ReferenceEntry<K, V>>discardingQueue();\n", "      writeQueue =\n", "          map.usesWriteQueue()\n", "              ? new WriteQueue<K, V>()\n", "              : LocalCache.<ReferenceEntry<K, V>>discardingQueue();\n", "      accessQueue =\n", "          map.usesAccessQueue()\n", "              ? new AccessQueue<K, V>()\n", "              : LocalCache.<ReferenceEntry<K, V>>discardingQueue();\n"], "6": ["          new Runnable() {\n", "            @Override\n", "            public void run() {\n", "              try {\n", "                getAndRecordStats(key, hash, loadingValueReference, loadingFuture);\n", "              } catch (Throwable t) {\n", "                logger.log(Level.WARNING, \"Exception thrown during refresh\", t);\n", "                loadingValueReference.setException(t);\n", "              }\n"], "7": ["        // all of the segment's entries.\n"], "8": ["        if (!isHeldByCurrentThread()) { // don't cleanup inside of put\n"], "9": ["            new Function<V, V>() {\n", "              @Override\n", "              public V apply(V newValue) {\n", "                LoadingValueReference.this.set(newValue);\n", "                return newValue;\n", "              }\n"], "10": ["    for (int i = 0; i < segments.length; ++i) {\n", "      if (segments[i].count != 0) {\n", "      sum += segments[i].modCount;\n", "      for (int i = 0; i < segments.length; ++i) {\n", "        if (segments[i].count != 0) {\n", "        sum -= segments[i].modCount;\n"], "11": ["    for (int i = 0; i < segments.length; ++i) {\n", "      sum += Math.max(0, segments[i].count); // see https://github.com/google/guava/issues/2108\n"], "12": ["    ArrayList<E> result = new ArrayList<E>(c.size());\n"], "13": ["    public final V apply(K key) {\n"], "14": ["      this(new LocalCache<K, V>(builder, null));\n"], "15": ["      super(new LocalCache<K, V>(builder, checkNotNull(loader)));\n"]}, "added_lines": {"2": [258, 259], "3": [663, 664], "4": [1742, 1743, 1744], "5": [1948, 1950, 1953, 1955, 1957], "6": [2202, 2203, 2204, 2205, 2206, 2207], "7": [2473], "8": [3257], "9": [3450, 3451, 3452], "10": [3795, 3796, 3799, 3803, 3804, 3807], "11": [3817, 3818], "12": [4386], "13": [4642], "14": [4660], "15": [4758]}, "removed_lines": {"1": [31], "2": [259, 260], "3": [664, 665], "4": [1743, 1744, 1745], "5": [1949, 1951, 1954, 1955, 1956, 1958, 1959, 1960, 1961, 1963, 1964, 1965, 1966], "6": [2211, 2212, 2213, 2214, 2215, 2216, 2217, 2218, 2219], "7": [2485], "8": [3269], "9": [3462, 3463, 3464, 3465, 3466, 3467], "10": [3810, 3811, 3814, 3818, 3819, 3822], "11": [3832, 3833], "12": [4401], "13": [4657], "14": [4675], "15": [4773]}}, {"4": "guava/src/com/google/common/cache/CacheBuilder.java", "added": {"1": [" * <p>These features are all optional; caches can be created using all or none of them. By default,\n"], "2": ["  static final Supplier<StatsCounter> CACHE_STATS_COUNTER = SimpleStatsCounter::new;\n"], "3": ["   * same instance, but only the returned reference has the correct generic type information to\n", "   * ensure type safety. For best results, use the standard method-chaining idiom illustrated in the\n", "   * class documentation above, configuring a builder and building your cache in a single statement.\n", "   * Failure to heed this advice can result in a {@link ClassCastException} being thrown by a cache\n", "   * operation at some <i>undefined</i> point in the future.\n"]}, "removed": {"1": [" * <p>These features are all optional; caches can be created using all or none of them. By default\n"], "2": ["  static final Supplier<StatsCounter> CACHE_STATS_COUNTER =\n", "      new Supplier<StatsCounter>() {\n", "        @Override\n", "        public StatsCounter get() {\n", "          return new SimpleStatsCounter();\n", "        }\n", "      };\n"], "3": ["   * same instance, but only the returned reference has the correct generic type information so as\n", "   * to ensure type safety. For best results, use the standard method-chaining idiom illustrated in\n", "   * the class documentation above, configuring a builder and building your cache in a single\n", "   * statement. Failure to heed this advice can result in a {@link ClassCastException} being thrown\n", "   * by a cache operation at some <i>undefined</i> point in the future.\n"]}, "added_lines": {"1": [99], "2": [233], "3": [923, 924, 925, 926, 927]}, "removed_lines": {"1": [99], "2": [233, 234, 235, 236, 237, 238, 239], "3": [929, 930, 931, 932, 933]}}, {"5": "guava/src/com/google/common/cache/CacheLoader.java", "added": {"2": ["    return new SupplierToCacheLoader<>(supplier);\n"], "3": ["      public ListenableFuture<V> reload(final K key, final V oldValue) {\n", "            ListenableFutureTask.create(() -> loader.reload(key, oldValue).get());\n"]}, "removed": {"1": ["import java.util.concurrent.Callable;\n"], "2": ["    return new SupplierToCacheLoader<V>(supplier);\n"], "3": ["      public ListenableFuture<V> reload(final K key, final V oldValue) throws Exception {\n", "            ListenableFutureTask.create(\n", "                new Callable<V>() {\n", "                  @Override\n", "                  public V call() throws Exception {\n", "                    return loader.reload(key, oldValue).get();\n", "                  }\n", "                });\n"]}, "added_lines": {"2": [155], "3": [196, 198]}, "removed_lines": {"1": [29], "2": [156], "3": [197, 199, 200, 201, 202, 203, 204, 205]}}, {"6": "guava/src/com/google/common/cache/CacheStats.java", "added": {"1": ["   * values. This includes both successful load operations and those that threw exceptions. This is\n", "   * defined as {@code loadSuccessCount + loadExceptionCount}.\n"]}, "removed": {"1": ["   * values. This includes both successful load operations, as well as those that threw exceptions.\n", "   * This is defined as {@code loadSuccessCount + loadExceptionCount}.\n"]}, "added_lines": {"1": [155, 156]}, "removed_lines": {"1": [155, 156]}}, {"7": "guava/src/com/google/common/cache/LocalCache.java", "added": {"1": ["            ? LocalCache.discardingQueue()\n", "            : new ConcurrentLinkedQueue<>();\n"], "2": ["     * Returns true if a new value is currently loading, regardless of whether there is an existing\n", "     * value. It is assumed that the return value of this method is constant for any given\n"], "3": ["   * loading, or expired. Unlike {@link Segment#getLiveValue} this method does not attempt to clean\n", "   * up stale entries. As such it should only be called outside a segment context, such as during\n", "   * iteration.\n", "  @Nullable V getLiveValue(ReferenceEntry<K, V> entry, long now) {\n"], "4": ["      keyReferenceQueue = map.usesKeyReferences() ? new ReferenceQueue<>() : null;\n", "      valueReferenceQueue = map.usesValueReferences() ? new ReferenceQueue<>() : null;\n", "          map.usesAccessQueue() ? new ConcurrentLinkedQueue<>() : LocalCache.discardingQueue();\n", "      writeQueue = map.usesWriteQueue() ? new WriteQueue<>() : LocalCache.discardingQueue();\n", "      accessQueue = map.usesAccessQueue() ? new AccessQueue<>() : LocalCache.discardingQueue();\n"], "5": ["          () -> {\n", "            try {\n", "              getAndRecordStats(key, hash, loadingValueReference, loadingFuture);\n", "            } catch (Throwable t) {\n", "              logger.log(Level.WARNING, \"Exception thrown during refresh\", t);\n", "              loadingValueReference.setException(t);\n"], "6": ["        // all the segment's entries.\n"], "7": ["        if (!isHeldByCurrentThread()) { // don't clean up inside of put\n"], "8": ["      this.oldValue = (oldValue == null) ? LocalCache.unset() : oldValue;\n"], "9": ["            newResult -> {\n", "              LoadingValueReference.this.set(newResult);\n", "              return newResult;\n"], "10": ["    for (Segment<K, V> segment : segments) {\n", "      if (segment.count != 0) {\n", "      sum += segment.modCount;\n", "      for (Segment<K, V> segment : segments) {\n", "        if (segment.count != 0) {\n", "        sum -= segment.modCount;\n"], "11": ["    for (Segment<K, V> segment : segments) {\n", "      sum += segment.count;\n"], "12": ["    ArrayList<E> result = new ArrayList<>(c.size());\n"], "13": ["    public V apply(K key) {\n"], "14": ["      this(new LocalCache<>(builder, null));\n"], "15": ["      super(new LocalCache<>(builder, checkNotNull(loader)));\n"]}, "removed": {"1": ["            ? LocalCache.<RemovalNotification<K, V>>discardingQueue()\n", "            : new ConcurrentLinkedQueue<RemovalNotification<K, V>>();\n"], "2": ["     * Returns true if a new value is currently loading, regardless of whether or not there is an\n", "     * existing value. It is assumed that the return value of this method is constant for any given\n"], "3": ["   * loading, or expired. Unlike {@link Segment#getLiveValue} this method does not attempt to\n", "   * cleanup stale entries. As such it should only be called outside of a segment context, such as\n", "   * during iteration.\n", "  @Nullable\n", "  V getLiveValue(ReferenceEntry<K, V> entry, long now) {\n"], "4": ["      keyReferenceQueue = map.usesKeyReferences() ? new ReferenceQueue<K>() : null;\n", "      valueReferenceQueue = map.usesValueReferences() ? new ReferenceQueue<V>() : null;\n", "          map.usesAccessQueue()\n", "              ? new ConcurrentLinkedQueue<ReferenceEntry<K, V>>()\n", "              : LocalCache.<ReferenceEntry<K, V>>discardingQueue();\n", "      writeQueue =\n", "          map.usesWriteQueue()\n", "              ? new WriteQueue<K, V>()\n", "              : LocalCache.<ReferenceEntry<K, V>>discardingQueue();\n", "      accessQueue =\n", "          map.usesAccessQueue()\n", "              ? new AccessQueue<K, V>()\n", "              : LocalCache.<ReferenceEntry<K, V>>discardingQueue();\n"], "5": ["          new Runnable() {\n", "            @Override\n", "            public void run() {\n", "              try {\n", "                getAndRecordStats(key, hash, loadingValueReference, loadingFuture);\n", "              } catch (Throwable t) {\n", "                logger.log(Level.WARNING, \"Exception thrown during refresh\", t);\n", "                loadingValueReference.setException(t);\n", "              }\n"], "6": ["        // all of the segment's entries.\n"], "7": ["        if (!isHeldByCurrentThread()) { // don't cleanup inside of put\n"], "8": ["      this.oldValue = (oldValue == null) ? LocalCache.<K, V>unset() : oldValue;\n"], "9": ["            new com.google.common.base.Function<V, V>() {\n", "              @Override\n", "              public V apply(V newValue) {\n", "                LoadingValueReference.this.set(newValue);\n", "                return newValue;\n", "              }\n"], "10": ["    for (int i = 0; i < segments.length; ++i) {\n", "      if (segments[i].count != 0) {\n", "      sum += segments[i].modCount;\n", "      for (int i = 0; i < segments.length; ++i) {\n", "        if (segments[i].count != 0) {\n", "        sum -= segments[i].modCount;\n"], "11": ["    for (int i = 0; i < segments.length; ++i) {\n", "      sum += segments[i].count;\n"], "12": ["    ArrayList<E> result = new ArrayList<E>(c.size());\n"], "13": ["    public final V apply(K key) {\n"], "14": ["      this(new LocalCache<K, V>(builder, null));\n"], "15": ["      super(new LocalCache<K, V>(builder, checkNotNull(loader)));\n"]}, "added_lines": {"1": [261, 262], "2": [666, 667], "3": [1743, 1744, 1745, 1747], "4": [1948, 1950, 1953, 1955, 1957], "5": [2284, 2285, 2286, 2287, 2288, 2289], "6": [2555], "7": [3339], "8": [3472], "9": [3532, 3533, 3534], "10": [3907, 3908, 3911, 3915, 3916, 3919], "11": [3929, 3930], "12": [4528], "13": [4813], "14": [4831], "15": [4928]}, "removed_lines": {"1": [261, 262], "2": [666, 667], "3": [1743, 1744, 1745, 1747, 1748], "4": [1949, 1951, 1954, 1955, 1956, 1958, 1959, 1960, 1961, 1963, 1964, 1965, 1966], "5": [2293, 2294, 2295, 2296, 2297, 2298, 2299, 2300, 2301], "6": [2567], "7": [3351], "8": [3484], "9": [3544, 3545, 3546, 3547, 3548, 3549], "10": [3922, 3923, 3926, 3930, 3931, 3934], "11": [3944, 3945], "12": [4543], "13": [4828], "14": [4846], "15": [4943]}}]}
