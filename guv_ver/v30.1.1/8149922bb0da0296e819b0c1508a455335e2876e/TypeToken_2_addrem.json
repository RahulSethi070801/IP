{
    "addition": {
        "20": "import static java.util.Objects.requireNonNull;\n",
        "50": "import javax.annotation.CheckForNull;\n",
        "102": "@ElementTypesAreNonnullByDefault\n",
        "108": "  @CheckForNull private transient TypeResolver invariantTypeResolver;\n",
        "111": "  @CheckForNull private transient TypeResolver covariantTypeResolver;\n",
        "225": "  /*\n",
        "226": "   * TODO(cpovirk): Is there any way for us to support TypeParameter instances for type parameters\n",
        "227": "   * that have nullable bounds? Unfortunately, if we change the parameter to TypeParameter<? extends\n",
        "228": "   * @Nullable X>, then users might pass a TypeParameter<Y>, where Y is a subtype of X, while still\n",
        "229": "   * passing a TypeToken<X>. This would be invalid. Maybe we could accept a TypeParameter<@PolyNull\n",
        "230": "   * X> if we support such a thing? It would be weird or misleading for users to be able to pass\n",
        "231": "   * `new TypeParameter<@Nullable T>() {}` and have it act as a plain `TypeParameter<T>`, but\n",
        "232": "   * hopefully no one would do that, anyway. See also the comment on TypeParameter itself.\n",
        "233": "   *\n",
        "234": "   * TODO(cpovirk): Elaborate on this / merge with other comment?\n",
        "235": "   */\n",
        "264": "  /*\n",
        "265": "   * TODO(cpovirk): Is there any way for us to support TypeParameter instances for type parameters\n",
        "266": "   * that have nullable bounds? See discussion on the other overload of this method.\n",
        "267": "   */\n",
        "308": "  @CheckForNull\n",
        "309": "  final TypeToken<? super T> getGenericSuperclass() {\n",
        "327": "  @CheckForNull\n",
        "328": "  private TypeToken<? super T> boundAsSuperclass(Type bound) {\n",
        "580": "  @CheckForNull\n",
        "581": "  public final TypeToken<?> getComponentType() {\n",
        "675": "    @CheckForNull private transient ImmutableSet<TypeToken<? super T>> types;\n",
        "721": "    @CheckForNull private transient ImmutableSet<TypeToken<? super T>> interfaces;\n",
        "774": "    @CheckForNull private transient ImmutableSet<TypeToken<? super T>> classes;\n",
        "839": "  public boolean equals(@CheckForNull Object o) {\n",
        "1153": "  @CheckForNull\n",
        "1154": "  private Type getOwnerTypeIfPresent() {\n",
        "1243": "    TypeToken componentType = getComponentType();\n",
        "1244": "    // TODO(cpovirk): checkArgument?\n",
        "1245": "    if (componentType == null) {\n",
        "1246": "      throw new IllegalArgumentException(supertype + \" isn't a super type of \" + this);\n",
        "1247": "    }\n",
        "1250": "    /*\n",
        "1251": "     * requireNonNull is safe because we call getArraySupertype only after checking\n",
        "1252": "     * supertype.isArray().\n",
        "1253": "     */\n",
        "1254": "    TypeToken<?> componentSupertype =\n",
        "1255": "        componentType.getSupertype(requireNonNull(supertype.getComponentType()));\n",
        "1265": "    Class<?> subclassComponentType = subclass.getComponentType();\n",
        "1266": "    if (subclassComponentType == null) {\n",
        "1267": "      throw new IllegalArgumentException(subclass + \" does not appear to be a subtype of \" + this);\n",
        "1268": "    }\n",
        "1270": "    // requireNonNull is safe because we call getArraySubtype only when isArray().\n",
        "1271": "    TypeToken<?> componentSubtype =\n",
        "1272": "        requireNonNull(getComponentType()).getSubtype(subclassComponentType);\n",
        "1345": "          @CheckForNull\n",
        "1364": "          @CheckForNull\n",
        "1436": "              // requireNonNull is safe because we are passing keys in the map.\n",
        "1437": "              return valueComparator.compare(\n",
        "1438": "                  requireNonNull(map.get(left)), requireNonNull(map.get(right)));\n",
        "1448": "    @CheckForNull\n",
        "1449": "    abstract K getSuperclass(K type);\n",
        "1470": "      @CheckForNull\n"
    },
    "removed": {
        "49": "import org.checkerframework.checker.nullness.qual.Nullable;\n",
        "106": "  private transient @Nullable TypeResolver invariantTypeResolver;\n",
        "109": "  private transient @Nullable TypeResolver covariantTypeResolver;\n",
        "291": "  final @Nullable TypeToken<? super T> getGenericSuperclass() {\n",
        "309": "  private @Nullable TypeToken<? super T> boundAsSuperclass(Type bound) {\n",
        "561": "  public final @Nullable TypeToken<?> getComponentType() {\n",
        "655": "    private transient @Nullable ImmutableSet<TypeToken<? super T>> types;\n",
        "701": "    private transient @Nullable ImmutableSet<TypeToken<? super T>> interfaces;\n",
        "754": "    private transient @Nullable ImmutableSet<TypeToken<? super T>> classes;\n",
        "819": "  public boolean equals(@Nullable Object o) {\n",
        "1133": "  private @Nullable Type getOwnerTypeIfPresent() {\n",
        "1222": "    TypeToken componentType =\n",
        "1223": "        checkNotNull(getComponentType(), \"%s isn't a super type of %s\", supertype, this);\n",
        "1226": "    TypeToken<?> componentSupertype = componentType.getSupertype(supertype.getComponentType());\n",
        "1237": "    TypeToken<?> componentSubtype = getComponentType().getSubtype(subclass.getComponentType());\n",
        "1310": "          @Nullable\n",
        "1329": "          @Nullable\n",
        "1401": "              return valueComparator.compare(map.get(left), map.get(right));\n",
        "1411": "    abstract @Nullable K getSuperclass(K type);\n"
    }
}