{
    "addition": {
        "261": "            ? LocalCache.discardingQueue()\n",
        "262": "            : new ConcurrentLinkedQueue<>();\n",
        "666": "     * Returns true if a new value is currently loading, regardless of whether there is an existing\n",
        "667": "     * value. It is assumed that the return value of this method is constant for any given\n",
        "1743": "   * loading, or expired. Unlike {@link Segment#getLiveValue} this method does not attempt to clean\n",
        "1744": "   * up stale entries. As such it should only be called outside a segment context, such as during\n",
        "1745": "   * iteration.\n",
        "1747": "  @Nullable V getLiveValue(ReferenceEntry<K, V> entry, long now) {\n",
        "1948": "      keyReferenceQueue = map.usesKeyReferences() ? new ReferenceQueue<>() : null;\n",
        "1950": "      valueReferenceQueue = map.usesValueReferences() ? new ReferenceQueue<>() : null;\n",
        "1953": "          map.usesAccessQueue() ? new ConcurrentLinkedQueue<>() : LocalCache.discardingQueue();\n",
        "1955": "      writeQueue = map.usesWriteQueue() ? new WriteQueue<>() : LocalCache.discardingQueue();\n",
        "1957": "      accessQueue = map.usesAccessQueue() ? new AccessQueue<>() : LocalCache.discardingQueue();\n",
        "2284": "          () -> {\n",
        "2285": "            try {\n",
        "2286": "              getAndRecordStats(key, hash, loadingValueReference, loadingFuture);\n",
        "2287": "            } catch (Throwable t) {\n",
        "2288": "              logger.log(Level.WARNING, \"Exception thrown during refresh\", t);\n",
        "2289": "              loadingValueReference.setException(t);\n",
        "2555": "        // all the segment's entries.\n",
        "3339": "        if (!isHeldByCurrentThread()) { // don't clean up inside of put\n",
        "3472": "      this.oldValue = (oldValue == null) ? LocalCache.unset() : oldValue;\n",
        "3532": "            newResult -> {\n",
        "3533": "              LoadingValueReference.this.set(newResult);\n",
        "3534": "              return newResult;\n",
        "3907": "    for (Segment<K, V> segment : segments) {\n",
        "3908": "      if (segment.count != 0) {\n",
        "3911": "      sum += segment.modCount;\n",
        "3915": "      for (Segment<K, V> segment : segments) {\n",
        "3916": "        if (segment.count != 0) {\n",
        "3919": "        sum -= segment.modCount;\n",
        "3929": "    for (Segment<K, V> segment : segments) {\n",
        "3930": "      sum += segment.count;\n",
        "4528": "    ArrayList<E> result = new ArrayList<>(c.size());\n",
        "4813": "    public V apply(K key) {\n",
        "4831": "      this(new LocalCache<>(builder, null));\n",
        "4928": "      super(new LocalCache<>(builder, checkNotNull(loader)));\n"
    },
    "removed": {
        "261": "            ? LocalCache.<RemovalNotification<K, V>>discardingQueue()\n",
        "262": "            : new ConcurrentLinkedQueue<RemovalNotification<K, V>>();\n",
        "666": "     * Returns true if a new value is currently loading, regardless of whether or not there is an\n",
        "667": "     * existing value. It is assumed that the return value of this method is constant for any given\n",
        "1743": "   * loading, or expired. Unlike {@link Segment#getLiveValue} this method does not attempt to\n",
        "1744": "   * cleanup stale entries. As such it should only be called outside of a segment context, such as\n",
        "1745": "   * during iteration.\n",
        "1747": "  @Nullable\n",
        "1748": "  V getLiveValue(ReferenceEntry<K, V> entry, long now) {\n",
        "1949": "      keyReferenceQueue = map.usesKeyReferences() ? new ReferenceQueue<K>() : null;\n",
        "1951": "      valueReferenceQueue = map.usesValueReferences() ? new ReferenceQueue<V>() : null;\n",
        "1954": "          map.usesAccessQueue()\n",
        "1955": "              ? new ConcurrentLinkedQueue<ReferenceEntry<K, V>>()\n",
        "1956": "              : LocalCache.<ReferenceEntry<K, V>>discardingQueue();\n",
        "1958": "      writeQueue =\n",
        "1959": "          map.usesWriteQueue()\n",
        "1960": "              ? new WriteQueue<K, V>()\n",
        "1961": "              : LocalCache.<ReferenceEntry<K, V>>discardingQueue();\n",
        "1963": "      accessQueue =\n",
        "1964": "          map.usesAccessQueue()\n",
        "1965": "              ? new AccessQueue<K, V>()\n",
        "1966": "              : LocalCache.<ReferenceEntry<K, V>>discardingQueue();\n",
        "2293": "          new Runnable() {\n",
        "2294": "            @Override\n",
        "2295": "            public void run() {\n",
        "2296": "              try {\n",
        "2297": "                getAndRecordStats(key, hash, loadingValueReference, loadingFuture);\n",
        "2298": "              } catch (Throwable t) {\n",
        "2299": "                logger.log(Level.WARNING, \"Exception thrown during refresh\", t);\n",
        "2300": "                loadingValueReference.setException(t);\n",
        "2301": "              }\n",
        "2567": "        // all of the segment's entries.\n",
        "3351": "        if (!isHeldByCurrentThread()) { // don't cleanup inside of put\n",
        "3484": "      this.oldValue = (oldValue == null) ? LocalCache.<K, V>unset() : oldValue;\n",
        "3544": "            new com.google.common.base.Function<V, V>() {\n",
        "3545": "              @Override\n",
        "3546": "              public V apply(V newValue) {\n",
        "3547": "                LoadingValueReference.this.set(newValue);\n",
        "3548": "                return newValue;\n",
        "3549": "              }\n",
        "3922": "    for (int i = 0; i < segments.length; ++i) {\n",
        "3923": "      if (segments[i].count != 0) {\n",
        "3926": "      sum += segments[i].modCount;\n",
        "3930": "      for (int i = 0; i < segments.length; ++i) {\n",
        "3931": "        if (segments[i].count != 0) {\n",
        "3934": "        sum -= segments[i].modCount;\n",
        "3944": "    for (int i = 0; i < segments.length; ++i) {\n",
        "3945": "      sum += segments[i].count;\n",
        "4543": "    ArrayList<E> result = new ArrayList<E>(c.size());\n",
        "4828": "    public final V apply(K key) {\n",
        "4846": "      this(new LocalCache<K, V>(builder, null));\n",
        "4943": "      super(new LocalCache<K, V>(builder, checkNotNull(loader)));\n"
    }
}