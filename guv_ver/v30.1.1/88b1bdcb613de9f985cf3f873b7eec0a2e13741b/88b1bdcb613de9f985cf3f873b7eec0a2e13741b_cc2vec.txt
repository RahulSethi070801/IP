{"id": "88b1bdcb613de9f985cf3f873b7eec0a2e13741b", "code": [{"0": "android/guava/src/com/google/common/collect/ContiguousSet.java", "added": {"1": ["import static java.util.Objects.requireNonNull;\n"], "2": ["@ElementTypesAreNonnullByDefault\n"], "3": ["    boolean empty;\n", "    if (effectiveRange.isEmpty()) {\n", "      empty = true;\n", "    } else {\n", "      /*\n", "       * requireNonNull is safe because the effectiveRange operations above would have thrown or\n", "       * effectiveRange.isEmpty() would have returned true.\n", "       */\n", "      C afterLower = requireNonNull(range.lowerBound.leastValueAbove(domain));\n", "      C beforeUpper = requireNonNull(range.upperBound.greatestValueBelow(domain));\n", "      // Per class spec, we are allowed to throw CCE if necessary\n", "      empty = Range.compareOrThrow(afterLower, beforeUpper) > 0;\n", "    }\n"]}, "removed": {"3": ["    // Per class spec, we are allowed to throw CCE if necessary\n", "    boolean empty =\n", "        effectiveRange.isEmpty()\n", "            || Range.compareOrThrow(\n", "                    range.lowerBound.leastValueAbove(domain),\n", "                    range.upperBound.greatestValueBelow(domain))\n", "                > 0;\n"]}, "added_lines": {"1": [19], "2": [53], "3": [79, 80, 81, 82, 83, 84, 85, 86, 87, 88, 89, 90, 91]}, "removed_lines": {"3": [77, 78, 79, 80, 81, 82, 83]}}, {"1": "android/guava/src/com/google/common/collect/ImmutableRangeMap.java", "added": {"2": ["@ElementTypesAreNonnullByDefault\n"], "3": ["  public boolean equals(@CheckForNull Object o) {\n"]}, "removed": {"1": ["import org.checkerframework.checker.nullness.compatqual.NullableDecl;\n"], "3": ["  public boolean equals(@NullableDecl Object o) {\n"]}, "added_lines": {"2": [45], "3": [361]}, "removed_lines": {"1": [35], "3": [361]}}, {"2": "android/guava/src/com/google/common/collect/RangeMap.java", "added": {"1": ["import javax.annotation.CheckForNull;\n"], "2": ["@ElementTypesAreNonnullByDefault\n", "  /*\n", "   * TODO(cpovirk): These docs sometimes say \"map\" and sometimes say \"range map.\" Pick one, or at\n", "   * least decide on a policy for when to use which.\n", "   */\n", "\n", "  @CheckForNull\n", "  @CheckForNull\n"], "3": ["  // TODO(cpovirk): Consider documenting that IAE on the various methods that can throw it.\n"], "4": ["  boolean equals(@CheckForNull Object o);\n"]}, "removed": {"1": ["import org.checkerframework.checker.nullness.compatqual.NullableDecl;\n"], "2": ["  @NullableDecl\n", "  @NullableDecl\n"], "4": ["  boolean equals(@NullableDecl Object o);\n"]}, "added_lines": {"1": [26], "2": [41, 43, 44, 45, 46, 47, 54, 61], "3": [155], "4": [163]}, "removed_lines": {"1": [26], "2": [48, 55], "4": [156]}}, {"3": "android/guava/src/com/google/common/collect/TreeRangeMap.java", "added": {"1": ["import static java.util.Objects.requireNonNull;\n"], "2": ["import javax.annotation.CheckForNull;\n"], "3": ["@ElementTypesAreNonnullByDefault\n"], "4": ["  @CheckForNull\n", "  @CheckForNull\n"], "5": ["      Range<K> range, V value, @CheckForNull Entry<Cut<K>, RangeMapEntry<K, V>> entry) {\n"], "6": ["    // Either both are null or neither is, but we check both to satisfy the nullness checker.\n", "    if (firstEntry == null || lastEntry == null) {\n"], "7": ["    public boolean containsKey(@CheckForNull Object key) {\n", "    @CheckForNull\n", "    public V get(@CheckForNull Object key) {\n"], "8": ["    return (RangeMap<K, V>) (RangeMap<?, ?>) EMPTY_SUB_RANGE_MAP;\n", "  @SuppressWarnings(\"ConstantCaseForConstants\") // This RangeMap is immutable.\n", "  private static final RangeMap<Comparable<?>, Object> EMPTY_SUB_RANGE_MAP =\n", "      new RangeMap<Comparable<?>, Object>() {\n", "        @CheckForNull\n", "        public Object get(Comparable<?> key) {\n", "        @CheckForNull\n", "        public Entry<Range<Comparable<?>>, Object> getEntry(Comparable<?> key) {\n", "        public Range<Comparable<?>> span() {\n", "        public void put(Range<Comparable<?>> range, Object value) {\n", "        public void putCoalescing(Range<Comparable<?>> range, Object value) {\n", "        public void putAll(RangeMap<Comparable<?>, Object> rangeMap) {\n"], "9": ["        public void remove(Range<Comparable<?>> range) {\n", "        public Map<Range<Comparable<?>>, Object> asMapOfRanges() {\n", "        public Map<Range<Comparable<?>>, Object> asDescendingMapOfRanges() {\n", "        public RangeMap<Comparable<?>, Object> subRangeMap(Range<Comparable<?>> range) {\n"], "10": ["    @CheckForNull\n", "    @CheckForNull\n"], "11": ["            @CheckForNull\n"], "12": ["    public boolean equals(@CheckForNull Object o) {\n"], "13": ["      public boolean containsKey(@CheckForNull Object key) {\n", "      @CheckForNull\n", "      public V get(@CheckForNull Object key) {\n"], "14": ["      @CheckForNull\n", "      public V remove(@CheckForNull Object key) {\n", "          // it's definitely in the map, so the cast and requireNonNull are safe\n", "          @SuppressWarnings(\"unchecked\")\n", "          Range<K> range = (Range<K>) requireNonNull(key);\n"], "15": ["          public boolean remove(@CheckForNull Object o) {\n"], "16": ["          @CheckForNull\n"], "17": ["  public boolean equals(@CheckForNull Object o) {\n"]}, "removed": {"2": ["import org.checkerframework.checker.nullness.compatqual.NullableDecl;\n"], "4": ["  @NullableDecl\n", "  @NullableDecl\n"], "5": ["      Range<K> range, V value, @NullableDecl Entry<Cut<K>, RangeMapEntry<K, V>> entry) {\n"], "6": ["    if (firstEntry == null) {\n"], "7": ["    public boolean containsKey(@NullableDecl Object key) {\n", "    public V get(@NullableDecl Object key) {\n"], "8": ["    return EMPTY_SUB_RANGE_MAP;\n", "  private static final RangeMap EMPTY_SUB_RANGE_MAP =\n", "      new RangeMap() {\n", "        @NullableDecl\n", "        public Object get(Comparable key) {\n", "        @NullableDecl\n", "        public Entry<Range, Object> getEntry(Comparable key) {\n", "        public Range span() {\n", "        public void put(Range range, Object value) {\n", "        public void putCoalescing(Range range, Object value) {\n", "        public void putAll(RangeMap rangeMap) {\n"], "9": ["        public void remove(Range range) {\n", "        public Map<Range, Object> asMapOfRanges() {\n", "        public Map<Range, Object> asDescendingMapOfRanges() {\n", "        public RangeMap subRangeMap(Range range) {\n"], "10": ["    @NullableDecl\n", "    @NullableDecl\n"], "12": ["    public boolean equals(@NullableDecl Object o) {\n"], "13": ["      public boolean containsKey(Object key) {\n", "      public V get(Object key) {\n"], "14": ["      public V remove(Object key) {\n", "          @SuppressWarnings(\"unchecked\") // it's definitely in the map, so safe\n", "          Range<K> range = (Range<K>) key;\n"], "15": ["          public boolean remove(@NullableDecl Object o) {\n"], "17": ["  public boolean equals(@NullableDecl Object o) {\n"]}, "added_lines": {"1": [24], "2": [41], "3": [54], "4": [105, 112], "5": [160], "6": [185, 186], "7": [267, 272, 273], "8": [306, 309, 310, 311, 313, 314, 319, 320, 325, 330, 337, 344], "9": [355, 360, 365, 370], "10": [385, 391], "11": [507], "12": [524], "13": [545, 550, 551], "14": [584, 585, 588, 589, 590], "15": [619], "16": [672], "17": [706]}, "removed_lines": {"2": [40], "4": [103, 110], "5": [158], "6": [183], "7": [264, 269], "8": [302, 305, 306, 308, 309, 314, 315, 320, 325, 332, 339], "9": [350, 355, 360, 365], "10": [380, 386], "12": [518], "13": [539, 544], "14": [577, 580, 581], "15": [610], "17": [696]}}, {"4": "guava/src/com/google/common/collect/ContiguousSet.java", "added": {"1": ["import static java.util.Objects.requireNonNull;\n"], "2": ["@ElementTypesAreNonnullByDefault\n"], "3": ["    boolean empty;\n", "    if (effectiveRange.isEmpty()) {\n", "      empty = true;\n", "    } else {\n", "      /*\n", "       * requireNonNull is safe because the effectiveRange operations above would have thrown or\n", "       * effectiveRange.isEmpty() would have returned true.\n", "       */\n", "      C afterLower = requireNonNull(range.lowerBound.leastValueAbove(domain));\n", "      C beforeUpper = requireNonNull(range.upperBound.greatestValueBelow(domain));\n", "      // Per class spec, we are allowed to throw CCE if necessary\n", "      empty = Range.compareOrThrow(afterLower, beforeUpper) > 0;\n", "    }\n"]}, "removed": {"3": ["    // Per class spec, we are allowed to throw CCE if necessary\n", "    boolean empty =\n", "        effectiveRange.isEmpty()\n", "            || Range.compareOrThrow(\n", "                    range.lowerBound.leastValueAbove(domain),\n", "                    range.upperBound.greatestValueBelow(domain))\n", "                > 0;\n"]}, "added_lines": {"1": [19], "2": [53], "3": [79, 80, 81, 82, 83, 84, 85, 86, 87, 88, 89, 90, 91]}, "removed_lines": {"3": [77, 78, 79, 80, 81, 82, 83]}}, {"5": "guava/src/com/google/common/collect/ImmutableRangeMap.java", "added": {"1": ["@ElementTypesAreNonnullByDefault\n"], "2": ["  public static <T extends @Nullable Object, K extends Comparable<? super K>, V>\n"], "3": ["      @CheckForNull V value,\n", "      BiFunction<? super V, ? super @Nullable V, ? extends @Nullable V> remappingFunction) {\n"], "4": ["  public boolean equals(@CheckForNull Object o) {\n"]}, "removed": {"2": ["  public static <T, K extends Comparable<? super K>, V>\n"], "3": ["      @Nullable V value,\n", "      BiFunction<? super V, ? super V, ? extends V> remappingFunction) {\n"], "4": ["  public boolean equals(@Nullable Object o) {\n"]}, "added_lines": {"1": [49], "2": [61], "3": [302, 303], "4": [394]}, "removed_lines": {"2": [60], "3": [301, 302], "4": [393]}}, {"6": "guava/src/com/google/common/collect/RangeMap.java", "added": {"1": ["import javax.annotation.CheckForNull;\n"], "2": ["@ElementTypesAreNonnullByDefault\n", "  /*\n", "   * TODO(cpovirk): These docs sometimes say \"map\" and sometimes say \"range map.\" Pick one, or at\n", "   * least decide on a policy for when to use which.\n", "   */\n", "\n", "  @CheckForNull\n", "  @CheckForNull\n"], "3": ["   * Merges a value into a part of the map by applying a remapping function.\n", "   * <p>If any parts of the range are already present in this map, those parts are mapped to new\n", "   * values by applying the remapping function. The remapping function accepts the map's existing\n", "   * value for that part of the range and the given value. It returns the value to be associated\n", "   * with that part of the map, or it returns {@code null} to clear that part of the map.\n", "   * <p>Any parts of the range not already present in this map are mapped to the specified value,\n", "   * unless the value is {@code null}.\n", "   * <p>Any existing entry spanning either range boundary may be split at the boundary, even if the\n", "   * merge does not affect its value. For example, if {@code rangeMap} had one entry {@code [1, 5]\n", "   * => 3} then {@code rangeMap.merge(Range.closed(0,2), 3, Math::max)} could yield a map with the\n", "   * entries {@code [0, 1) => 3, [1, 2] => 3, (2, 5] => 3}.\n", "      @CheckForNull V value,\n", "      BiFunction<? super V, ? super @Nullable V, ? extends @Nullable V> remappingFunction);\n"], "4": ["  // TODO(cpovirk): Consider documenting that IAE on the various methods that can throw it.\n"], "5": ["  boolean equals(@CheckForNull Object o);\n"]}, "removed": {"2": ["  @Nullable\n", "  @Nullable\n"], "3": ["   * Merges a value into the map over a range by applying a remapping function.\n", "   * <p>If any parts of the range are already present in this range map, those parts are mapped to\n", "   * new values by applying the remapping function. Any parts of the range not already present in\n", "   * this range map are mapped to the specified value, unless the value is {@code null}.\n", "   * <p>Any existing map entry spanning either range boundary may be split at the boundary, even if\n", "   * the merge does not affect its value.\n", "   * <p>For example, if {@code rangeMap} had one entry {@code [1, 5] => 3} then {@code\n", "   * rangeMap.merge(Range.closed(0,2), 3, Math::max)} could yield a range map with the entries\n", "   * {@code [0, 1) => 3, [1, 2] => 3, (2, 5] => 3}.\n", "      @Nullable V value,\n", "      BiFunction<? super V, ? super V, ? extends V> remappingFunction);\n"], "5": ["  boolean equals(@Nullable Object o);\n"]}, "added_lines": {"1": [27], "2": [43, 45, 46, 47, 48, 49, 56, 63], "3": [121, 123, 124, 125, 126, 128, 129, 131, 132, 133, 134, 140, 141], "4": [180], "5": [188]}, "removed_lines": {"2": [49, 56], "3": [114, 116, 117, 118, 120, 121, 123, 124, 125, 131, 132], "5": [178]}}, {"7": "guava/src/com/google/common/collect/TreeRangeMap.java", "added": {"1": ["import static java.util.Objects.requireNonNull;\n"], "2": ["import javax.annotation.CheckForNull;\n"], "3": ["@ElementTypesAreNonnullByDefault\n"], "4": ["  @CheckForNull\n", "  public V get(K key) {\n", "  @CheckForNull\n", "  public Entry<Range<K>, V> getEntry(K key) {\n"], "5": ["      Range<K> range, V value, @CheckForNull Entry<Cut<K>, RangeMapEntry<K, V>> entry) {\n"], "6": ["    // Either both are null or neither is, but we check both to satisfy the nullness checker.\n", "    if (firstEntry == null || lastEntry == null) {\n"], "7": ["      @CheckForNull V value,\n", "      BiFunction<? super V, ? super @Nullable V, ? extends @Nullable V> remappingFunction) {\n"], "8": ["    public boolean containsKey(@CheckForNull Object key) {\n", "    @CheckForNull\n", "    public V get(@CheckForNull Object key) {\n"], "9": ["    return (RangeMap<K, V>) (RangeMap<?, ?>) EMPTY_SUB_RANGE_MAP;\n", "  @SuppressWarnings(\"ConstantCaseForConstants\") // This RangeMap is immutable.\n", "  private static final RangeMap<Comparable<?>, Object> EMPTY_SUB_RANGE_MAP =\n", "      new RangeMap<Comparable<?>, Object>() {\n", "        @CheckForNull\n", "        public Object get(Comparable<?> key) {\n", "        @CheckForNull\n", "        public Entry<Range<Comparable<?>>, Object> getEntry(Comparable<?> key) {\n", "        public Range<Comparable<?>> span() {\n", "        public void put(Range<Comparable<?>> range, Object value) {\n", "        public void putCoalescing(Range<Comparable<?>> range, Object value) {\n", "        public void putAll(RangeMap<Comparable<?>, Object> rangeMap) {\n"], "10": ["        public void remove(Range<Comparable<?>> range) {\n", "        public void merge(\n", "            Range<Comparable<?>> range,\n", "            @CheckForNull Object value,\n", "            BiFunction<? super Object, ? super Object, ? extends Object> remappingFunction) {\n", "        public Map<Range<Comparable<?>>, Object> asMapOfRanges() {\n", "        public Map<Range<Comparable<?>>, Object> asDescendingMapOfRanges() {\n", "        public RangeMap<Comparable<?>, Object> subRangeMap(Range<Comparable<?>> range) {\n"], "11": ["    @CheckForNull\n", "    public V get(K key) {\n", "    @CheckForNull\n", "    public Entry<Range<K>, V> getEntry(K key) {\n"], "12": ["        @CheckForNull V value,\n", "        BiFunction<? super V, ? super @Nullable V, ? extends @Nullable V> remappingFunction) {\n"], "13": ["            @CheckForNull\n"], "14": ["    public boolean equals(@CheckForNull Object o) {\n"], "15": ["      public boolean containsKey(@CheckForNull Object key) {\n", "      @CheckForNull\n", "      public V get(@CheckForNull Object key) {\n"], "16": ["      @CheckForNull\n", "      public V remove(@CheckForNull Object key) {\n", "          // it's definitely in the map, so the cast and requireNonNull are safe\n", "          @SuppressWarnings(\"unchecked\")\n", "          Range<K> range = (Range<K>) requireNonNull(key);\n"], "17": ["          public boolean remove(@CheckForNull Object o) {\n"], "18": ["          @CheckForNull\n"], "19": ["  public boolean equals(@CheckForNull Object o) {\n"]}, "removed": {"4": ["  public @Nullable V get(K key) {\n", "  public @Nullable Entry<Range<K>, V> getEntry(K key) {\n"], "5": ["      Range<K> range, V value, @Nullable Entry<Cut<K>, RangeMapEntry<K, V>> entry) {\n"], "6": ["    if (firstEntry == null) {\n"], "7": ["      @Nullable V value,\n", "      BiFunction<? super V, ? super V, ? extends V> remappingFunction) {\n"], "8": ["    public boolean containsKey(@Nullable Object key) {\n", "    public V get(@Nullable Object key) {\n"], "9": ["    return EMPTY_SUB_RANGE_MAP;\n", "  private static final RangeMap EMPTY_SUB_RANGE_MAP =\n", "      new RangeMap() {\n", "        public @Nullable Object get(Comparable key) {\n", "        public @Nullable Entry<Range, Object> getEntry(Comparable key) {\n", "        public Range span() {\n", "        public void put(Range range, Object value) {\n", "        public void putCoalescing(Range range, Object value) {\n", "        public void putAll(RangeMap rangeMap) {\n"], "10": ["        public void remove(Range range) {\n", "        @SuppressWarnings(\"rawtypes\") // necessary for static EMPTY_SUB_RANGE_MAP instance\n", "        public void merge(Range range, @Nullable Object value, BiFunction remappingFunction) {\n", "        public Map<Range, Object> asMapOfRanges() {\n", "        public Map<Range, Object> asDescendingMapOfRanges() {\n", "        public RangeMap subRangeMap(Range range) {\n"], "11": ["    public @Nullable V get(K key) {\n", "    public @Nullable Entry<Range<K>, V> getEntry(K key) {\n"], "12": ["        @Nullable V value,\n", "        BiFunction<? super V, ? super V, ? extends V> remappingFunction) {\n"], "14": ["    public boolean equals(@Nullable Object o) {\n"], "15": ["      public boolean containsKey(Object key) {\n", "      public V get(Object key) {\n"], "16": ["      public V remove(Object key) {\n", "          @SuppressWarnings(\"unchecked\") // it's definitely in the map, so safe\n", "          Range<K> range = (Range<K>) key;\n"], "17": ["          public boolean remove(@Nullable Object o) {\n"], "19": ["  public boolean equals(@Nullable Object o) {\n"]}, "added_lines": {"1": [24], "2": [42], "3": [56], "4": [107, 108, 114, 115], "5": [162], "6": [187, 188], "7": [271, 272], "8": [343, 348, 349], "9": [382, 385, 386, 387, 389, 390, 395, 396, 401, 406, 413, 420], "10": [431, 436, 437, 438, 439, 446, 451, 456], "11": [471, 472, 477, 478], "12": [564, 565], "13": [606], "14": [623], "15": [644, 649, 650], "16": [683, 684, 687, 688, 689], "17": [718], "18": [771], "19": [805]}, "removed_lines": {"4": [104, 110], "5": [157], "6": [182], "7": [265, 266], "8": [337, 342], "9": [375, 378, 379, 381, 386, 391, 396, 403, 410], "10": [421, 426, 427, 434, 439, 444], "11": [459, 464], "12": [550, 551], "14": [608], "15": [629, 634], "16": [667, 670, 671], "17": [700], "19": [786]}}]}
