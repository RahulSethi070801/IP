{
    "addition": {
        "22": "import static java.util.Objects.requireNonNull;\n",
        "29": "import javax.annotation.CheckForNull;\n",
        "30": "import org.checkerframework.checker.nullness.qual.Nullable;\n",
        "38": "@ElementTypesAreNonnullByDefault\n",
        "70": "  @CheckForNull private final transient Object hashTable;\n",
        "71": "  @VisibleForTesting final transient @Nullable Object[] alternatingKeysAndValues;\n",
        "75": "  static <K, V> RegularImmutableMap<K, V> create(\n",
        "76": "      int n, @Nullable Object[] alternatingKeysAndValues) {\n",
        "80": "      // requireNonNull is safe because the first `2*n` elements have been filled in.\n",
        "81": "      checkEntryNotNull(\n",
        "82": "          requireNonNull(alternatingKeysAndValues[0]), requireNonNull(alternatingKeysAndValues[1]));\n",
        "95": "  @CheckForNull\n",
        "97": "      @Nullable Object[] alternatingKeysAndValues, int n, int tableSize, int keyOffset) {\n",
        "100": "      // requireNonNull is safe because the first `2*n` elements have been filled in.\n",
        "102": "          requireNonNull(alternatingKeysAndValues[keyOffset]),\n",
        "103": "          requireNonNull(alternatingKeysAndValues[keyOffset ^ 1]));\n",
        "119": "        // requireNonNull is safe because the first `2*n` elements have been filled in.\n",
        "120": "        Object key = requireNonNull(alternatingKeysAndValues[keyIndex]);\n",
        "121": "        Object value = requireNonNull(alternatingKeysAndValues[keyIndex ^ 1]);\n",
        "129": "          } else if (key.equals(alternatingKeysAndValues[previousKeyIndex])) {\n",
        "147": "        // requireNonNull is safe because the first `2*n` elements have been filled in.\n",
        "148": "        Object key = requireNonNull(alternatingKeysAndValues[keyIndex]);\n",
        "149": "        Object value = requireNonNull(alternatingKeysAndValues[keyIndex ^ 1]);\n",
        "157": "          } else if (key.equals(alternatingKeysAndValues[previousKeyIndex])) {\n",
        "172": "        // requireNonNull is safe because the first `2*n` elements have been filled in.\n",
        "173": "        Object key = requireNonNull(alternatingKeysAndValues[keyIndex]);\n",
        "174": "        Object value = requireNonNull(alternatingKeysAndValues[keyIndex ^ 1]);\n",
        "182": "          } else if (key.equals(alternatingKeysAndValues[previousKeyIndex])) {\n",
        "192": "      Object key, Object value, @Nullable Object[] alternatingKeysAndValues, int previousKeyIndex) {\n",
        "204": "  private RegularImmutableMap(\n",
        "205": "      @CheckForNull Object hashTable, @Nullable Object[] alternatingKeysAndValues, int size) {\n",
        "218": "  @CheckForNull\n",
        "219": "  public V get(@CheckForNull Object key) {\n",
        "220": "    Object result = get(hashTable, alternatingKeysAndValues, size, 0, key);\n",
        "221": "    /*\n",
        "222": "     * We can't simply cast the result of `RegularImmutableMap.get` to V because of a bug in our\n",
        "223": "     * nullness checker (resulting from https://github.com/jspecify/checker-framework/issues/8).\n",
        "224": "     */\n",
        "225": "    if (result == null) {\n",
        "226": "      return null;\n",
        "227": "    } else {\n",
        "228": "      return (V) result;\n",
        "229": "    }\n",
        "232": "  @CheckForNull\n",
        "234": "      @CheckForNull Object hashTableObject,\n",
        "235": "      @Nullable Object[] alternatingKeysAndValues,\n",
        "238": "      @CheckForNull Object key) {\n",
        "242": "      // requireNonNull is safe because the first 2 elements have been filled in.\n",
        "243": "      return requireNonNull(alternatingKeysAndValues[keyOffset]).equals(key)\n",
        "244": "          ? requireNonNull(alternatingKeysAndValues[keyOffset ^ 1])\n",
        "257": "        } else if (key.equals(alternatingKeysAndValues[keyIndex])) {\n",
        "269": "        } else if (key.equals(alternatingKeysAndValues[keyIndex])) {\n",
        "281": "        } else if (key.equals(alternatingKeysAndValues[keyIndex])) {\n",
        "295": "    private final transient @Nullable Object[] alternatingKeysAndValues;\n",
        "299": "    EntrySet(\n",
        "300": "        ImmutableMap<K, V> map,\n",
        "301": "        @Nullable Object[] alternatingKeysAndValues,\n",
        "302": "        int keyOffset,\n",
        "303": "        int size) {\n",
        "326": "          /*\n",
        "327": "           * requireNonNull is safe because the first `2*(size+keyOffset)` elements have been filled\n",
        "328": "           * in.\n",
        "329": "           */\n",
        "331": "          K key = (K) requireNonNull(alternatingKeysAndValues[2 * index + keyOffset]);\n",
        "333": "          V value = (V) requireNonNull(alternatingKeysAndValues[2 * index + (keyOffset ^ 1)]);\n",
        "350": "    public boolean contains(@CheckForNull Object object) {\n",
        "380": "    private final transient @Nullable Object[] alternatingKeysAndValues;\n",
        "384": "    KeysOrValuesAsList(@Nullable Object[] alternatingKeysAndValues, int offset, int size) {\n",
        "393": "      // requireNonNull is safe because the first `2*(size+offset)` elements have been filled in.\n",
        "394": "      return requireNonNull(alternatingKeysAndValues[2 * index + offset]);\n",
        "433": "    public boolean contains(@CheckForNull Object object) {\n"
    },
    "removed": {
        "28": "import org.checkerframework.checker.nullness.compatqual.NullableDecl;\n",
        "67": "  private final transient Object hashTable;\n",
        "68": "  @VisibleForTesting final transient Object[] alternatingKeysAndValues;\n",
        "72": "  static <K, V> RegularImmutableMap<K, V> create(int n, Object[] alternatingKeysAndValues) {\n",
        "76": "      checkEntryNotNull(alternatingKeysAndValues[0], alternatingKeysAndValues[1]);\n",
        "90": "      Object[] alternatingKeysAndValues, int n, int tableSize, int keyOffset) {\n",
        "94": "          alternatingKeysAndValues[keyOffset], alternatingKeysAndValues[keyOffset ^ 1]);\n",
        "110": "        Object key = alternatingKeysAndValues[keyIndex];\n",
        "111": "        Object value = alternatingKeysAndValues[keyIndex ^ 1];\n",
        "119": "          } else if (alternatingKeysAndValues[previousKeyIndex].equals(key)) {\n",
        "137": "        Object key = alternatingKeysAndValues[keyIndex];\n",
        "138": "        Object value = alternatingKeysAndValues[keyIndex ^ 1];\n",
        "146": "          } else if (alternatingKeysAndValues[previousKeyIndex].equals(key)) {\n",
        "161": "        Object key = alternatingKeysAndValues[keyIndex];\n",
        "162": "        Object value = alternatingKeysAndValues[keyIndex ^ 1];\n",
        "170": "          } else if (alternatingKeysAndValues[previousKeyIndex].equals(key)) {\n",
        "180": "      Object key, Object value, Object[] alternatingKeysAndValues, int previousKeyIndex) {\n",
        "192": "  private RegularImmutableMap(Object hashTable, Object[] alternatingKeysAndValues, int size) {\n",
        "205": "  @NullableDecl\n",
        "206": "  public V get(@NullableDecl Object key) {\n",
        "207": "    return (V) get(hashTable, alternatingKeysAndValues, size, 0, key);\n",
        "211": "      @NullableDecl Object hashTableObject,\n",
        "212": "      @NullableDecl Object[] alternatingKeysAndValues,\n",
        "215": "      @NullableDecl Object key) {\n",
        "219": "      return alternatingKeysAndValues[keyOffset].equals(key)\n",
        "220": "          ? alternatingKeysAndValues[keyOffset ^ 1]\n",
        "233": "        } else if (alternatingKeysAndValues[keyIndex].equals(key)) {\n",
        "245": "        } else if (alternatingKeysAndValues[keyIndex].equals(key)) {\n",
        "257": "        } else if (alternatingKeysAndValues[keyIndex].equals(key)) {\n",
        "271": "    private final transient Object[] alternatingKeysAndValues;\n",
        "275": "    EntrySet(ImmutableMap<K, V> map, Object[] alternatingKeysAndValues, int keyOffset, int size) {\n",
        "299": "          K key = (K) alternatingKeysAndValues[2 * index + keyOffset];\n",
        "301": "          V value = (V) alternatingKeysAndValues[2 * index + (keyOffset ^ 1)];\n",
        "318": "    public boolean contains(Object object) {\n",
        "348": "    private final transient Object[] alternatingKeysAndValues;\n",
        "352": "    KeysOrValuesAsList(Object[] alternatingKeysAndValues, int offset, int size) {\n",
        "361": "      return alternatingKeysAndValues[2 * index + offset];\n",
        "400": "    public boolean contains(@NullableDecl Object object) {\n"
    }
}