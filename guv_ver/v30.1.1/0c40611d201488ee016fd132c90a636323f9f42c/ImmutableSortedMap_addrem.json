{
    "addition": {
        "23": "import static java.util.Objects.requireNonNull;\n",
        "37": "import org.checkerframework.checker.nullness.qual.Nullable;\n",
        "304": "      @Nullable Entry<K, V>[] entryArray,\n",
        "310": "        // requireNonNull is safe because the first `size` elements have been filled in.\n",
        "311": "        Entry<K, V> onlyEntry = requireNonNull(entryArray[0]);\n",
        "312": "        return of(comparator, onlyEntry.getKey(), onlyEntry.getValue());\n",
        "319": "            // requireNonNull is safe because the first `size` elements have been filled in.\n",
        "320": "            Entry<K, V> entry = requireNonNull(entryArray[i]);\n",
        "321": "            Object key = entry.getKey();\n",
        "322": "            Object value = entry.getValue();\n",
        "335": "              new Comparator<@Nullable Entry<K, V>>() {\n",
        "337": "                public int compare(@CheckForNull Entry<K, V> e1, @CheckForNull Entry<K, V> e2) {\n",
        "338": "                  // requireNonNull is safe because the first `size` elements have been filled in.\n",
        "339": "                  requireNonNull(e1);\n",
        "340": "                  requireNonNull(e2);\n",
        "344": "          // requireNonNull is safe because the first `size` elements have been filled in.\n",
        "345": "          Entry<K, V> firstEntry = requireNonNull(entryArray[0]);\n",
        "346": "          K prevKey = firstEntry.getKey();\n",
        "348": "          values[0] = firstEntry.getValue();\n",
        "351": "            // requireNonNull is safe because the first `size` elements have been filled in.\n",
        "352": "            Entry<K, V> prevEntry = requireNonNull(entryArray[i - 1]);\n",
        "353": "            Entry<K, V> entry = requireNonNull(entryArray[i]);\n",
        "354": "            K key = entry.getKey();\n",
        "355": "            V value = entry.getValue();\n",
        "359": "            checkNoConflict(comparator.compare(prevKey, key) != 0, \"key\", prevEntry, entry);\n",
        "419": "    private transient @Nullable Object[] keys;\n",
        "420": "    private transient @Nullable Object[] values;\n",
        "434": "      this.keys = new @Nullable Object[initialCapacity];\n",
        "435": "      this.values = new @Nullable Object[initialCapacity];\n",
        "542": "          // requireNonNull is safe because the first `size` elements have been filled in.\n",
        "543": "          return of(comparator, (K) requireNonNull(keys[0]), (V) requireNonNull(values[0]));\n",
        "561": "            // requireNonNull is safe because the first `size` elements have been filled in.\n",
        "562": "            int index =\n",
        "563": "                Arrays.binarySearch((K[]) sortedKeys, (K) requireNonNull(keys[i]), comparator);\n",
        "564": "            sortedValues[index] = requireNonNull(values[i]);\n"
    },
    "removed": {
        "302": "      Entry<K, V>[] entryArray,\n",
        "308": "        return ImmutableSortedMap.<K, V>of(\n",
        "309": "            comparator, entryArray[0].getKey(), entryArray[0].getValue());\n",
        "316": "            Object key = entryArray[i].getKey();\n",
        "317": "            Object value = entryArray[i].getValue();\n",
        "330": "              new Comparator<Entry<K, V>>() {\n",
        "332": "                public int compare(Entry<K, V> e1, Entry<K, V> e2) {\n",
        "336": "          K prevKey = entryArray[0].getKey();\n",
        "338": "          values[0] = entryArray[0].getValue();\n",
        "341": "            K key = entryArray[i].getKey();\n",
        "342": "            V value = entryArray[i].getValue();\n",
        "346": "            checkNoConflict(\n",
        "347": "                comparator.compare(prevKey, key) != 0, \"key\", entryArray[i - 1], entryArray[i]);\n",
        "407": "    private transient Object[] keys;\n",
        "408": "    private transient Object[] values;\n",
        "422": "      this.keys = new Object[initialCapacity];\n",
        "423": "      this.values = new Object[initialCapacity];\n",
        "530": "          return of(comparator, (K) keys[0], (V) values[0]);\n",
        "548": "            int index = Arrays.binarySearch((K[]) sortedKeys, (K) keys[i], comparator);\n",
        "549": "            sortedValues[index] = values[i];\n"
    }
}