{
    "addition": {
        "23": "import static java.util.Objects.requireNonNull;\n",
        "68": "@ElementTypesAreNonnullByDefault\n",
        "83": "  public static <T extends @Nullable Object, K, V>\n",
        "84": "      Collector<T, ?, ImmutableMap<K, V>> toImmutableMap(\n",
        "85": "          Function<? super T, ? extends K> keyFunction,\n",
        "86": "          Function<? super T, ? extends V> valueFunction) {\n",
        "100": "  public static <T extends @Nullable Object, K, V>\n",
        "101": "      Collector<T, ?, ImmutableMap<K, V>> toImmutableMap(\n",
        "102": "          Function<? super T, ? extends K> keyFunction,\n",
        "103": "          Function<? super T, ? extends V> valueFunction,\n",
        "104": "          BinaryOperator<V> mergeFunction) {\n",
        "252": "    @CheckForNull Comparator<? super V> valueComparator;\n",
        "253": "    @Nullable Entry<K, V>[] entries;\n",
        "265": "    @SuppressWarnings({\"unchecked\", \"rawtypes\"})\n",
        "267": "      this.entries = new @Nullable Entry[initialCapacity];\n",
        "393": "          // requireNonNull is safe because the first `size` elements have been filled in.\n",
        "394": "          Entry<K, V> onlyEntry = requireNonNull(entries[0]);\n",
        "395": "          return of(onlyEntry.getKey(), onlyEntry.getValue());\n",
        "410": "          // requireNonNull is safe because the first `size` elements have been filled in.\n",
        "411": "          Entry<K, V> onlyEntry = requireNonNull(entries[0]);\n",
        "412": "          return of(onlyEntry.getKey(), onlyEntry.getValue());\n",
        "464": "        // requireNonNull is safe because the first `size` elements have been filled in.\n",
        "465": "        Entry<K, V> onlyEntry = requireNonNull(entryArray[0]);\n",
        "479": "    for (Entry<K, V> entry : copy.entrySet()) {\n",
        "536": "  @CheckForNull\n",
        "551": "  @CheckForNull\n",
        "577": "  @CheckForNull\n",
        "619": "  public final V compute(\n",
        "620": "      K key, BiFunction<? super K, ? super @Nullable V, ? extends V> remappingFunction) {\n",
        "673": "  @CheckForNull\n",
        "674": "  public final V remove(@CheckForNull Object o) {\n",
        "687": "  public final boolean remove(@CheckForNull Object key, @CheckForNull Object value) {\n",
        "710": "  public boolean containsKey(@CheckForNull Object key) {\n",
        "715": "  public boolean containsValue(@CheckForNull Object value) {\n",
        "722": "  public abstract V get(@CheckForNull Object key);\n",
        "730": "  @CheckForNull\n",
        "731": "  public final V getOrDefault(@CheckForNull Object key, @CheckForNull V defaultValue) {\n",
        "733": "    // TODO(b/192579700): Use a ternary once it no longer confuses our nullness checker.\n",
        "734": "    if (result != null) {\n",
        "735": "      return result;\n",
        "736": "    } else {\n",
        "737": "      return defaultValue;\n",
        "738": "    }\n",
        "741": "  @LazyInit @RetainedWith @CheckForNull private transient ImmutableSet<Entry<K, V>> entrySet;\n",
        "755": "  @LazyInit @RetainedWith @CheckForNull private transient ImmutableSet<K> keySet;\n",
        "793": "  @LazyInit @RetainedWith @CheckForNull private transient ImmutableCollection<V> values;\n",
        "813": "  @LazyInit @CheckForNull private transient ImmutableSetMultimap<K, V> multimapView;\n",
        "846": "    public boolean containsKey(@CheckForNull Object key) {\n",
        "851": "    @CheckForNull\n",
        "852": "    public ImmutableSet<V> get(@CheckForNull Object key) {\n",
        "902": "  public boolean equals(@CheckForNull Object object) {\n",
        "943": "        // \"extends Object\" works around https://github.com/typetools/checker-framework/issues/3013\n",
        "944": "        for (Entry<? extends Object, ? extends Object> entry : map.entrySet()) {\n"
    },
    "removed": {
        "81": "  public static <T, K, V> Collector<T, ?, ImmutableMap<K, V>> toImmutableMap(\n",
        "82": "      Function<? super T, ? extends K> keyFunction,\n",
        "83": "      Function<? super T, ? extends V> valueFunction) {\n",
        "97": "  public static <T, K, V> Collector<T, ?, ImmutableMap<K, V>> toImmutableMap(\n",
        "98": "      Function<? super T, ? extends K> keyFunction,\n",
        "99": "      Function<? super T, ? extends V> valueFunction,\n",
        "100": "      BinaryOperator<V> mergeFunction) {\n",
        "248": "    @Nullable Comparator<? super V> valueComparator;\n",
        "249": "    Entry<K, V>[] entries;\n",
        "261": "    @SuppressWarnings(\"unchecked\")\n",
        "263": "      this.entries = new Entry[initialCapacity];\n",
        "389": "          return of(entries[0].getKey(), entries[0].getValue());\n",
        "404": "          return of(entries[0].getKey(), entries[0].getValue());\n",
        "456": "        Entry<K, V> onlyEntry = entryArray[0];\n",
        "470": "    for (Entry<?, ?> entry : copy.entrySet()) {\n",
        "607": "  public final V compute(K key, BiFunction<? super K, ? super V, ? extends V> remappingFunction) {\n",
        "660": "  public final V remove(Object o) {\n",
        "673": "  public final boolean remove(Object key, Object value) {\n",
        "696": "  public boolean containsKey(@Nullable Object key) {\n",
        "701": "  public boolean containsValue(@Nullable Object value) {\n",
        "708": "  public abstract V get(@Nullable Object key);\n",
        "716": "  public final V getOrDefault(@Nullable Object key, @Nullable V defaultValue) {\n",
        "718": "    return (result != null) ? result : defaultValue;\n",
        "721": "  @LazyInit @RetainedWith private transient ImmutableSet<Entry<K, V>> entrySet;\n",
        "735": "  @LazyInit @RetainedWith private transient ImmutableSet<K> keySet;\n",
        "773": "  @LazyInit @RetainedWith private transient ImmutableCollection<V> values;\n",
        "793": "  @LazyInit private transient ImmutableSetMultimap<K, V> multimapView;\n",
        "826": "    public boolean containsKey(@Nullable Object key) {\n",
        "831": "    public ImmutableSet<V> get(@Nullable Object key) {\n",
        "881": "  public boolean equals(@Nullable Object object) {\n",
        "922": "        for (Entry<?, ?> entry : map.entrySet()) {\n"
    }
}