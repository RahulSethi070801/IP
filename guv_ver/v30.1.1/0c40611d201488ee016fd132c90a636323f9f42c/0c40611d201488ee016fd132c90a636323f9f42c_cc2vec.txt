{"id": "0c40611d201488ee016fd132c90a636323f9f42c", "code": [{"0": "android/guava/src/com/google/common/collect/ImmutableClassToInstanceMap.java", "added": {"1": ["import javax.annotation.CheckForNull;\n"], "2": ["@ElementTypesAreNonnullByDefault\n"], "3": ["  @CheckForNull\n"], "4": ["  @CheckForNull\n"]}, "removed": {"1": ["import org.checkerframework.checker.nullness.compatqual.NullableDecl;\n"], "3": ["  @NullableDecl\n"]}, "added_lines": {"1": [28], "2": [39], "3": [177], "4": [192]}, "removed_lines": {"1": [28], "3": [176]}}, {"1": "android/guava/src/com/google/common/collect/ImmutableEntry.java", "added": {"1": ["import org.checkerframework.checker.nullness.qual.Nullable;\n", "@ElementTypesAreNonnullByDefault\n", "class ImmutableEntry<K extends @Nullable Object, V extends @Nullable Object>\n", "    extends AbstractMapEntry<K, V> implements Serializable {\n", "  @ParametricNullness final K key;\n", "  @ParametricNullness final V value;\n", "  ImmutableEntry(@ParametricNullness K key, @ParametricNullness V value) {\n", "  @ParametricNullness\n", "  @ParametricNullness\n", "  @ParametricNullness\n", "  public final V setValue(@ParametricNullness V value) {\n"]}, "removed": {"1": ["import org.checkerframework.checker.nullness.compatqual.NullableDecl;\n", "class ImmutableEntry<K, V> extends AbstractMapEntry<K, V> implements Serializable {\n", "  @NullableDecl final K key;\n", "  @NullableDecl final V value;\n", "  ImmutableEntry(@NullableDecl K key, @NullableDecl V value) {\n", "  @NullableDecl\n", "  @NullableDecl\n", "  public final V setValue(V value) {\n"]}, "added_lines": {"1": [21, 25, 26, 27, 28, 29, 31, 37, 43, 49, 50]}, "removed_lines": {"1": [21, 25, 26, 27, 29, 35, 41, 47]}}, {"2": "android/guava/src/com/google/common/collect/ImmutableEnumMap.java", "added": {"1": ["import javax.annotation.CheckForNull;\n"], "2": ["@ElementTypesAreNonnullByDefault\n"], "3": ["  public boolean containsKey(@CheckForNull Object key) {\n", "  @CheckForNull\n", "  public V get(@CheckForNull Object key) {\n", "  public boolean equals(@CheckForNull Object object) {\n"]}, "removed": {"1": ["import org.checkerframework.checker.nullness.compatqual.NullableDecl;\n"], "3": ["  public boolean containsKey(@NullableDecl Object key) {\n", "  public V get(Object key) {\n", "  public boolean equals(Object object) {\n"]}, "added_lines": {"1": [25], "2": [34], "3": [66, 71, 72, 77]}, "removed_lines": {"1": [25], "3": [65, 70, 75]}}, {"3": "android/guava/src/com/google/common/collect/ImmutableMap.java", "added": {"1": ["import static java.util.Objects.requireNonNull;\n"], "2": ["import org.checkerframework.checker.nullness.qual.Nullable;\n"], "3": ["@ElementTypesAreNonnullByDefault\n"], "4": ["    @CheckForNull Comparator<? super V> valueComparator;\n", "    @Nullable Object[] alternatingKeysAndValues;\n"], "5": ["    @SuppressWarnings({\"unchecked\", \"rawtypes\"})\n", "      this.alternatingKeysAndValues = new @Nullable Object[2 * initialCapacity];\n"], "6": ["          // requireNonNull is safe because the first `2*size` elements have been filled in.\n", "                  (K) requireNonNull(alternatingKeysAndValues[2 * i]),\n", "                  (V) requireNonNull(alternatingKeysAndValues[2 * i + 1]));\n"], "7": ["  @CheckForNull\n"], "8": ["  @CheckForNull\n", "  public final V remove(@CheckForNull Object o) {\n"], "9": ["  public boolean containsKey(@CheckForNull Object key) {\n", "  public boolean containsValue(@CheckForNull Object value) {\n", "  public abstract V get(@CheckForNull Object key);\n"], "10": ["  @CheckForNull\n", "  public final V getOrDefault(@CheckForNull Object key, @CheckForNull V defaultValue) {\n", "    // TODO(b/192579700): Use a ternary once it no longer confuses our nullness checker.\n", "    if (result != null) {\n", "      return result;\n", "    } else {\n", "      return defaultValue;\n", "    }\n", "  @LazyInit @RetainedWith @CheckForNull private transient ImmutableSet<Entry<K, V>> entrySet;\n"], "11": ["  @LazyInit @RetainedWith @CheckForNull private transient ImmutableSet<K> keySet;\n"], "12": ["  @LazyInit @RetainedWith @CheckForNull private transient ImmutableCollection<V> values;\n"], "13": ["  @LazyInit @CheckForNull private transient ImmutableSetMultimap<K, V> multimapView;\n"], "14": ["    public boolean containsKey(@CheckForNull Object key) {\n", "    @CheckForNull\n", "    public ImmutableSet<V> get(@CheckForNull Object key) {\n"], "15": ["  public boolean equals(@CheckForNull Object object) {\n"], "16": ["        // \"extends Object\" works around https://github.com/typetools/checker-framework/issues/3013\n", "        for (Entry<? extends Object, ? extends Object> entry : map.entrySet()) {\n"]}, "removed": {"2": ["import org.checkerframework.checker.nullness.compatqual.NullableDecl;\n"], "4": ["    @NullableDecl Comparator<? super V> valueComparator;\n", "    Object[] alternatingKeysAndValues;\n"], "5": ["    @SuppressWarnings(\"unchecked\")\n", "      this.alternatingKeysAndValues = new Object[2 * initialCapacity];\n"], "6": ["                  (K) alternatingKeysAndValues[2 * i], (V) alternatingKeysAndValues[2 * i + 1]);\n"], "8": ["  public final V remove(Object o) {\n"], "9": ["  public boolean containsKey(@NullableDecl Object key) {\n", "  public boolean containsValue(@NullableDecl Object value) {\n", "  public abstract V get(@NullableDecl Object key);\n"], "10": ["  public final V getOrDefault(@NullableDecl Object key, @NullableDecl V defaultValue) {\n", "    return (result != null) ? result : defaultValue;\n", "  @LazyInit @RetainedWith private transient ImmutableSet<Entry<K, V>> entrySet;\n"], "11": ["  @LazyInit @RetainedWith private transient ImmutableSet<K> keySet;\n"], "12": ["  @LazyInit @RetainedWith private transient ImmutableCollection<V> values;\n"], "13": ["  @LazyInit private transient ImmutableSetMultimap<K, V> multimapView;\n"], "14": ["    public boolean containsKey(@NullableDecl Object key) {\n", "    public ImmutableSet<V> get(@NullableDecl Object key) {\n"], "15": ["  public boolean equals(@NullableDecl Object object) {\n"], "16": ["        for (Entry<?, ?> entry : map.entrySet()) {\n"]}, "added_lines": {"1": [23], "2": [44], "3": [60], "4": [220, 221], "5": [233, 235], "6": [371, 374, 375], "7": [474], "8": [488, 489], "9": [525, 530, 537], "10": [551, 552, 554, 555, 556, 557, 558, 559, 562], "11": [576], "12": [610], "13": [630], "14": [663, 668, 669], "15": [719], "16": [760, 761]}, "removed_lines": {"2": [43], "4": [218, 219], "5": [231, 233], "6": [371], "8": [483], "9": [519, 524, 531], "10": [545, 547, 550], "11": [564], "12": [598], "13": [618], "14": [651, 656], "15": [706], "16": [747]}}, {"4": "android/guava/src/com/google/common/collect/ImmutableMapEntrySet.java", "added": {"1": ["import javax.annotation.CheckForNull;\n", "import org.checkerframework.checker.nullness.qual.Nullable;\n"], "2": ["@ElementTypesAreNonnullByDefault\n"], "3": ["    int copyIntoArray(@Nullable Object[] dst, int offset) {\n"], "4": ["  public boolean contains(@CheckForNull Object object) {\n"]}, "removed": {"1": ["import org.checkerframework.checker.nullness.compatqual.NullableDecl;\n"], "3": ["    int copyIntoArray(Object[] dst, int offset) {\n"], "4": ["  public boolean contains(@NullableDecl Object object) {\n"]}, "added_lines": {"1": [23, 24], "2": [33], "3": [55], "4": [80]}, "removed_lines": {"1": [23], "3": [53], "4": [78]}}, {"5": "android/guava/src/com/google/common/collect/ImmutableMapKeySet.java", "added": {"1": ["import javax.annotation.CheckForNull;\n"], "2": ["@ElementTypesAreNonnullByDefault\n"], "3": ["  public boolean contains(@CheckForNull Object object) {\n"]}, "removed": {"1": ["import org.checkerframework.checker.nullness.compatqual.NullableDecl;\n"], "3": ["  public boolean contains(@NullableDecl Object object) {\n"]}, "added_lines": {"1": [22], "2": [31], "3": [50]}, "removed_lines": {"1": [22], "3": [49]}}, {"6": "android/guava/src/com/google/common/collect/ImmutableMapValues.java", "added": {"1": ["import javax.annotation.CheckForNull;\n"], "2": ["@ElementTypesAreNonnullByDefault\n"], "3": ["  public boolean contains(@CheckForNull Object object) {\n"]}, "removed": {"1": ["import org.checkerframework.checker.nullness.compatqual.NullableDecl;\n"], "3": ["  public boolean contains(@NullableDecl Object object) {\n"]}, "added_lines": {"1": [23], "2": [32], "3": [63]}, "removed_lines": {"1": [23], "3": [62]}}, {"7": "android/guava/src/com/google/common/collect/ImmutableSortedMap.java", "added": {"1": ["import static java.util.Objects.requireNonNull;\n"], "2": ["import org.checkerframework.checker.nullness.qual.Nullable;\n"], "3": ["      @Nullable Entry<K, V>[] entryArray,\n", "        // requireNonNull is safe because the first `size` elements have been filled in.\n", "        Entry<K, V> onlyEntry = requireNonNull(entryArray[0]);\n", "        return of(comparator, onlyEntry.getKey(), onlyEntry.getValue());\n", "            // requireNonNull is safe because the first `size` elements have been filled in.\n", "            Entry<K, V> entry = requireNonNull(entryArray[i]);\n", "            Object key = entry.getKey();\n", "            Object value = entry.getValue();\n"], "4": ["              new Comparator<@Nullable Entry<K, V>>() {\n", "                public int compare(@CheckForNull Entry<K, V> e1, @CheckForNull Entry<K, V> e2) {\n", "                  // requireNonNull is safe because the first `size` elements have been filled in.\n", "                  requireNonNull(e1);\n", "                  requireNonNull(e2);\n", "          // requireNonNull is safe because the first `size` elements have been filled in.\n", "          Entry<K, V> firstEntry = requireNonNull(entryArray[0]);\n", "          K prevKey = firstEntry.getKey();\n", "          values[0] = firstEntry.getValue();\n", "            // requireNonNull is safe because the first `size` elements have been filled in.\n", "            Entry<K, V> prevEntry = requireNonNull(entryArray[i - 1]);\n", "            Entry<K, V> entry = requireNonNull(entryArray[i]);\n", "            K key = entry.getKey();\n", "            V value = entry.getValue();\n", "            checkNoConflict(comparator.compare(prevKey, key) != 0, \"key\", prevEntry, entry);\n"], "5": ["    private transient @Nullable Object[] keys;\n", "    private transient @Nullable Object[] values;\n"], "6": ["      this.keys = new @Nullable Object[initialCapacity];\n", "      this.values = new @Nullable Object[initialCapacity];\n"], "7": ["          // requireNonNull is safe because the first `size` elements have been filled in.\n", "          return of(comparator, (K) requireNonNull(keys[0]), (V) requireNonNull(values[0]));\n"], "8": ["            // requireNonNull is safe because the first `size` elements have been filled in.\n", "            int index =\n", "                Arrays.binarySearch((K[]) sortedKeys, (K) requireNonNull(keys[i]), comparator);\n", "            sortedValues[index] = requireNonNull(values[i]);\n"]}, "removed": {"3": ["      Entry<K, V>[] entryArray,\n", "        return ImmutableSortedMap.<K, V>of(\n", "            comparator, entryArray[0].getKey(), entryArray[0].getValue());\n", "            Object key = entryArray[i].getKey();\n", "            Object value = entryArray[i].getValue();\n"], "4": ["              new Comparator<Entry<K, V>>() {\n", "                public int compare(Entry<K, V> e1, Entry<K, V> e2) {\n", "          K prevKey = entryArray[0].getKey();\n", "          values[0] = entryArray[0].getValue();\n", "            K key = entryArray[i].getKey();\n", "            V value = entryArray[i].getValue();\n", "            checkNoConflict(\n", "                comparator.compare(prevKey, key) != 0, \"key\", entryArray[i - 1], entryArray[i]);\n"], "5": ["    private transient Object[] keys;\n", "    private transient Object[] values;\n"], "6": ["      this.keys = new Object[initialCapacity];\n", "      this.values = new Object[initialCapacity];\n"], "7": ["          return of(comparator, (K) keys[0], (V) values[0]);\n"], "8": ["            int index = Arrays.binarySearch((K[]) sortedKeys, (K) keys[i], comparator);\n", "            sortedValues[index] = values[i];\n"]}, "added_lines": {"1": [23], "2": [37], "3": [304, 310, 311, 312, 319, 320, 321, 322], "4": [335, 337, 338, 339, 340, 344, 345, 346, 348, 351, 352, 353, 354, 355, 359], "5": [419, 420], "6": [434, 435], "7": [542, 543], "8": [561, 562, 563, 564]}, "removed_lines": {"3": [302, 308, 309, 316, 317], "4": [330, 332, 336, 338, 341, 342, 346, 347], "5": [407, 408], "6": [422, 423], "7": [530], "8": [548, 549]}}, {"8": "android/guava/src/com/google/common/collect/RegularImmutableBiMap.java", "added": {"1": ["import org.checkerframework.checker.nullness.qual.Nullable;\n"], "2": ["  @VisibleForTesting final transient @Nullable Object[] alternatingKeysAndValues;\n"], "3": ["  RegularImmutableBiMap(@Nullable Object[] alternatingKeysAndValues, int size) {\n"], "4": ["      @CheckForNull Object valueHashTable,\n", "      @Nullable Object[] alternatingKeysAndValues,\n"], "5": ["    Object result =\n", "    /*\n", "     * We can't simply cast the result of `RegularImmutableMap.get` to V because of a bug in our\n", "     * nullness checker (resulting from https://github.com/jspecify/checker-framework/issues/8).\n", "     */\n", "    if (result == null) {\n", "      return null;\n", "    } else {\n", "      return (V) result;\n", "    }\n"]}, "removed": {"2": ["  @VisibleForTesting final transient Object[] alternatingKeysAndValues;\n"], "3": ["  RegularImmutableBiMap(Object[] alternatingKeysAndValues, int size) {\n"], "4": ["      Object valueHashTable,\n", "      Object[] alternatingKeysAndValues,\n"], "5": ["    return (V)\n"]}, "added_lines": {"1": [22], "2": [36], "3": [52], "4": [67, 68], "5": [92, 94, 95, 96, 97, 98, 99, 100, 101, 102]}, "removed_lines": {"2": [35], "3": [51], "4": [66, 67], "5": [91]}}, {"9": "android/guava/src/com/google/common/collect/RegularImmutableMap.java", "added": {"1": ["import static java.util.Objects.requireNonNull;\n", "import javax.annotation.CheckForNull;\n", "import org.checkerframework.checker.nullness.qual.Nullable;\n"], "2": ["@ElementTypesAreNonnullByDefault\n"], "3": ["  @CheckForNull private final transient Object hashTable;\n", "  @VisibleForTesting final transient @Nullable Object[] alternatingKeysAndValues;\n", "  static <K, V> RegularImmutableMap<K, V> create(\n", "      int n, @Nullable Object[] alternatingKeysAndValues) {\n", "      // requireNonNull is safe because the first `2*n` elements have been filled in.\n", "      checkEntryNotNull(\n", "          requireNonNull(alternatingKeysAndValues[0]), requireNonNull(alternatingKeysAndValues[1]));\n"], "4": ["  @CheckForNull\n", "      @Nullable Object[] alternatingKeysAndValues, int n, int tableSize, int keyOffset) {\n", "      // requireNonNull is safe because the first `2*n` elements have been filled in.\n", "          requireNonNull(alternatingKeysAndValues[keyOffset]),\n", "          requireNonNull(alternatingKeysAndValues[keyOffset ^ 1]));\n"], "5": ["        // requireNonNull is safe because the first `2*n` elements have been filled in.\n", "        Object key = requireNonNull(alternatingKeysAndValues[keyIndex]);\n", "        Object value = requireNonNull(alternatingKeysAndValues[keyIndex ^ 1]);\n"], "6": ["          } else if (key.equals(alternatingKeysAndValues[previousKeyIndex])) {\n"], "7": ["        // requireNonNull is safe because the first `2*n` elements have been filled in.\n", "        Object key = requireNonNull(alternatingKeysAndValues[keyIndex]);\n", "        Object value = requireNonNull(alternatingKeysAndValues[keyIndex ^ 1]);\n"], "8": ["          } else if (key.equals(alternatingKeysAndValues[previousKeyIndex])) {\n"], "9": ["        // requireNonNull is safe because the first `2*n` elements have been filled in.\n", "        Object key = requireNonNull(alternatingKeysAndValues[keyIndex]);\n", "        Object value = requireNonNull(alternatingKeysAndValues[keyIndex ^ 1]);\n"], "10": ["          } else if (key.equals(alternatingKeysAndValues[previousKeyIndex])) {\n"], "11": ["      Object key, Object value, @Nullable Object[] alternatingKeysAndValues, int previousKeyIndex) {\n"], "12": ["  private RegularImmutableMap(\n", "      @CheckForNull Object hashTable, @Nullable Object[] alternatingKeysAndValues, int size) {\n"], "13": ["  @CheckForNull\n", "  public V get(@CheckForNull Object key) {\n", "    Object result = get(hashTable, alternatingKeysAndValues, size, 0, key);\n", "    /*\n", "     * We can't simply cast the result of `RegularImmutableMap.get` to V because of a bug in our\n", "     * nullness checker (resulting from https://github.com/jspecify/checker-framework/issues/8).\n", "     */\n", "    if (result == null) {\n", "      return null;\n", "    } else {\n", "      return (V) result;\n", "    }\n", "  @CheckForNull\n", "      @CheckForNull Object hashTableObject,\n", "      @Nullable Object[] alternatingKeysAndValues,\n", "      @CheckForNull Object key) {\n", "      // requireNonNull is safe because the first 2 elements have been filled in.\n", "      return requireNonNull(alternatingKeysAndValues[keyOffset]).equals(key)\n", "          ? requireNonNull(alternatingKeysAndValues[keyOffset ^ 1])\n"], "14": ["        } else if (key.equals(alternatingKeysAndValues[keyIndex])) {\n"], "15": ["        } else if (key.equals(alternatingKeysAndValues[keyIndex])) {\n"], "16": ["        } else if (key.equals(alternatingKeysAndValues[keyIndex])) {\n"], "17": ["    private final transient @Nullable Object[] alternatingKeysAndValues;\n", "    EntrySet(\n", "        ImmutableMap<K, V> map,\n", "        @Nullable Object[] alternatingKeysAndValues,\n", "        int keyOffset,\n", "        int size) {\n"], "18": ["          /*\n", "           * requireNonNull is safe because the first `2*(size+keyOffset)` elements have been filled\n", "           * in.\n", "           */\n", "          K key = (K) requireNonNull(alternatingKeysAndValues[2 * index + keyOffset]);\n", "          V value = (V) requireNonNull(alternatingKeysAndValues[2 * index + (keyOffset ^ 1)]);\n"], "19": ["    public boolean contains(@CheckForNull Object object) {\n"], "20": ["    private final transient @Nullable Object[] alternatingKeysAndValues;\n", "    KeysOrValuesAsList(@Nullable Object[] alternatingKeysAndValues, int offset, int size) {\n"], "21": ["      // requireNonNull is safe because the first `2*(size+offset)` elements have been filled in.\n", "      return requireNonNull(alternatingKeysAndValues[2 * index + offset]);\n"], "22": ["    public boolean contains(@CheckForNull Object object) {\n"]}, "removed": {"1": ["import org.checkerframework.checker.nullness.compatqual.NullableDecl;\n"], "3": ["  private final transient Object hashTable;\n", "  @VisibleForTesting final transient Object[] alternatingKeysAndValues;\n", "  static <K, V> RegularImmutableMap<K, V> create(int n, Object[] alternatingKeysAndValues) {\n", "      checkEntryNotNull(alternatingKeysAndValues[0], alternatingKeysAndValues[1]);\n"], "4": ["      Object[] alternatingKeysAndValues, int n, int tableSize, int keyOffset) {\n", "          alternatingKeysAndValues[keyOffset], alternatingKeysAndValues[keyOffset ^ 1]);\n"], "5": ["        Object key = alternatingKeysAndValues[keyIndex];\n", "        Object value = alternatingKeysAndValues[keyIndex ^ 1];\n"], "6": ["          } else if (alternatingKeysAndValues[previousKeyIndex].equals(key)) {\n"], "7": ["        Object key = alternatingKeysAndValues[keyIndex];\n", "        Object value = alternatingKeysAndValues[keyIndex ^ 1];\n"], "8": ["          } else if (alternatingKeysAndValues[previousKeyIndex].equals(key)) {\n"], "9": ["        Object key = alternatingKeysAndValues[keyIndex];\n", "        Object value = alternatingKeysAndValues[keyIndex ^ 1];\n"], "10": ["          } else if (alternatingKeysAndValues[previousKeyIndex].equals(key)) {\n"], "11": ["      Object key, Object value, Object[] alternatingKeysAndValues, int previousKeyIndex) {\n"], "12": ["  private RegularImmutableMap(Object hashTable, Object[] alternatingKeysAndValues, int size) {\n"], "13": ["  @NullableDecl\n", "  public V get(@NullableDecl Object key) {\n", "    return (V) get(hashTable, alternatingKeysAndValues, size, 0, key);\n", "      @NullableDecl Object hashTableObject,\n", "      @NullableDecl Object[] alternatingKeysAndValues,\n", "      @NullableDecl Object key) {\n", "      return alternatingKeysAndValues[keyOffset].equals(key)\n", "          ? alternatingKeysAndValues[keyOffset ^ 1]\n"], "14": ["        } else if (alternatingKeysAndValues[keyIndex].equals(key)) {\n"], "15": ["        } else if (alternatingKeysAndValues[keyIndex].equals(key)) {\n"], "16": ["        } else if (alternatingKeysAndValues[keyIndex].equals(key)) {\n"], "17": ["    private final transient Object[] alternatingKeysAndValues;\n", "    EntrySet(ImmutableMap<K, V> map, Object[] alternatingKeysAndValues, int keyOffset, int size) {\n"], "18": ["          K key = (K) alternatingKeysAndValues[2 * index + keyOffset];\n", "          V value = (V) alternatingKeysAndValues[2 * index + (keyOffset ^ 1)];\n"], "19": ["    public boolean contains(Object object) {\n"], "20": ["    private final transient Object[] alternatingKeysAndValues;\n", "    KeysOrValuesAsList(Object[] alternatingKeysAndValues, int offset, int size) {\n"], "21": ["      return alternatingKeysAndValues[2 * index + offset];\n"], "22": ["    public boolean contains(@NullableDecl Object object) {\n"]}, "added_lines": {"1": [22, 29, 30], "2": [38], "3": [70, 71, 75, 76, 80, 81, 82], "4": [95, 97, 100, 102, 103], "5": [119, 120, 121], "6": [129], "7": [147, 148, 149], "8": [157], "9": [172, 173, 174], "10": [182], "11": [192], "12": [204, 205], "13": [218, 219, 220, 221, 222, 223, 224, 225, 226, 227, 228, 229, 232, 234, 235, 238, 242, 243, 244], "14": [257], "15": [269], "16": [281], "17": [295, 299, 300, 301, 302, 303], "18": [326, 327, 328, 329, 331, 333], "19": [350], "20": [380, 384], "21": [393, 394], "22": [433]}, "removed_lines": {"1": [28], "3": [67, 68, 72, 76], "4": [90, 94], "5": [110, 111], "6": [119], "7": [137, 138], "8": [146], "9": [161, 162], "10": [170], "11": [180], "12": [192], "13": [205, 206, 207, 211, 212, 215, 219, 220], "14": [233], "15": [245], "16": [257], "17": [271, 275], "18": [299, 301], "19": [318], "20": [348, 352], "21": [361], "22": [400]}}, {"10": "guava/src/com/google/common/collect/ImmutableBiMap.java", "added": {"1": ["import static java.util.Objects.requireNonNull;\n"], "2": ["          // requireNonNull is safe because the first `size` elements have been filled in.\n", "          Entry<K, V> onlyEntry = requireNonNull(entries[0]);\n", "          return of(onlyEntry.getKey(), onlyEntry.getValue());\n"], "3": ["          // requireNonNull is safe because the first `size` elements have been filled in.\n", "          Entry<K, V> onlyEntry = requireNonNull(entries[0]);\n", "          return of(onlyEntry.getKey(), onlyEntry.getValue());\n"]}, "removed": {"2": ["          return of(entries[0].getKey(), entries[0].getValue());\n"], "3": ["          return of(entries[0].getKey(), entries[0].getValue());\n"]}, "added_lines": {"1": [21], "2": [281, 282, 283], "3": [317, 318, 319]}, "removed_lines": {"2": [280], "3": [314]}}, {"11": "guava/src/com/google/common/collect/ImmutableClassToInstanceMap.java", "added": {"1": ["import javax.annotation.CheckForNull;\n"], "2": ["@ElementTypesAreNonnullByDefault\n"], "3": ["  @CheckForNull\n", "  public <T extends B> T getInstance(Class<T> type) {\n"], "4": ["  @CheckForNull\n"]}, "removed": {"1": ["import org.checkerframework.checker.nullness.qual.Nullable;\n"], "3": ["  public <T extends B> @Nullable T getInstance(Class<T> type) {\n"]}, "added_lines": {"1": [28], "2": [39], "3": [177, 178], "4": [192]}, "removed_lines": {"1": [28], "3": [176]}}, {"12": "guava/src/com/google/common/collect/ImmutableEntry.java", "added": {"1": ["@ElementTypesAreNonnullByDefault\n", "class ImmutableEntry<K extends @Nullable Object, V extends @Nullable Object>\n", "    extends AbstractMapEntry<K, V> implements Serializable {\n", "  @ParametricNullness final K key;\n", "  @ParametricNullness final V value;\n", "  ImmutableEntry(@ParametricNullness K key, @ParametricNullness V value) {\n", "  @ParametricNullness\n", "  public final K getKey() {\n", "  @ParametricNullness\n", "  public final V getValue() {\n", "  @ParametricNullness\n", "  public final V setValue(@ParametricNullness V value) {\n"]}, "removed": {"1": ["class ImmutableEntry<K, V> extends AbstractMapEntry<K, V> implements Serializable {\n", "  final @Nullable K key;\n", "  final @Nullable V value;\n", "  ImmutableEntry(@Nullable K key, @Nullable V value) {\n", "  public final @Nullable K getKey() {\n", "  public final @Nullable V getValue() {\n", "  public final V setValue(V value) {\n"]}, "added_lines": {"1": [25, 26, 27, 28, 29, 31, 37, 38, 43, 44, 49, 50]}, "removed_lines": {"1": [25, 26, 27, 29, 35, 40, 45]}}, {"13": "guava/src/com/google/common/collect/ImmutableEnumMap.java", "added": {"1": ["import javax.annotation.CheckForNull;\n"], "2": ["@ElementTypesAreNonnullByDefault\n"], "3": ["  public boolean containsKey(@CheckForNull Object key) {\n", "  @CheckForNull\n", "  public V get(@CheckForNull Object key) {\n", "  public boolean equals(@CheckForNull Object object) {\n"]}, "removed": {"1": ["import org.checkerframework.checker.nullness.qual.Nullable;\n"], "3": ["  public boolean containsKey(@Nullable Object key) {\n", "  public V get(Object key) {\n", "  public boolean equals(Object object) {\n"]}, "added_lines": {"1": [27], "2": [36], "3": [73, 78, 79, 84]}, "removed_lines": {"1": [27], "3": [72, 77, 82]}}, {"14": "guava/src/com/google/common/collect/ImmutableMap.java", "added": {"1": ["import static java.util.Objects.requireNonNull;\n"], "2": ["@ElementTypesAreNonnullByDefault\n"], "3": ["  public static <T extends @Nullable Object, K, V>\n", "      Collector<T, ?, ImmutableMap<K, V>> toImmutableMap(\n", "          Function<? super T, ? extends K> keyFunction,\n", "          Function<? super T, ? extends V> valueFunction) {\n"], "4": ["  public static <T extends @Nullable Object, K, V>\n", "      Collector<T, ?, ImmutableMap<K, V>> toImmutableMap(\n", "          Function<? super T, ? extends K> keyFunction,\n", "          Function<? super T, ? extends V> valueFunction,\n", "          BinaryOperator<V> mergeFunction) {\n"], "5": ["    @CheckForNull Comparator<? super V> valueComparator;\n", "    @Nullable Entry<K, V>[] entries;\n"], "6": ["    @SuppressWarnings({\"unchecked\", \"rawtypes\"})\n", "      this.entries = new @Nullable Entry[initialCapacity];\n"], "7": ["          // requireNonNull is safe because the first `size` elements have been filled in.\n", "          Entry<K, V> onlyEntry = requireNonNull(entries[0]);\n", "          return of(onlyEntry.getKey(), onlyEntry.getValue());\n"], "8": ["          // requireNonNull is safe because the first `size` elements have been filled in.\n", "          Entry<K, V> onlyEntry = requireNonNull(entries[0]);\n", "          return of(onlyEntry.getKey(), onlyEntry.getValue());\n"], "9": ["        // requireNonNull is safe because the first `size` elements have been filled in.\n", "        Entry<K, V> onlyEntry = requireNonNull(entryArray[0]);\n"], "10": ["    for (Entry<K, V> entry : copy.entrySet()) {\n"], "11": ["  @CheckForNull\n"], "12": ["  @CheckForNull\n"], "13": ["  @CheckForNull\n"], "14": ["  public final V compute(\n", "      K key, BiFunction<? super K, ? super @Nullable V, ? extends V> remappingFunction) {\n"], "15": ["  @CheckForNull\n", "  public final V remove(@CheckForNull Object o) {\n"], "16": ["  public final boolean remove(@CheckForNull Object key, @CheckForNull Object value) {\n"], "17": ["  public boolean containsKey(@CheckForNull Object key) {\n", "  public boolean containsValue(@CheckForNull Object value) {\n", "  public abstract V get(@CheckForNull Object key);\n"], "18": ["  @CheckForNull\n", "  public final V getOrDefault(@CheckForNull Object key, @CheckForNull V defaultValue) {\n", "    // TODO(b/192579700): Use a ternary once it no longer confuses our nullness checker.\n", "    if (result != null) {\n", "      return result;\n", "    } else {\n", "      return defaultValue;\n", "    }\n", "  @LazyInit @RetainedWith @CheckForNull private transient ImmutableSet<Entry<K, V>> entrySet;\n"], "19": ["  @LazyInit @RetainedWith @CheckForNull private transient ImmutableSet<K> keySet;\n"], "20": ["  @LazyInit @RetainedWith @CheckForNull private transient ImmutableCollection<V> values;\n"], "21": ["  @LazyInit @CheckForNull private transient ImmutableSetMultimap<K, V> multimapView;\n"], "22": ["    public boolean containsKey(@CheckForNull Object key) {\n", "    @CheckForNull\n", "    public ImmutableSet<V> get(@CheckForNull Object key) {\n"], "23": ["  public boolean equals(@CheckForNull Object object) {\n"], "24": ["        // \"extends Object\" works around https://github.com/typetools/checker-framework/issues/3013\n", "        for (Entry<? extends Object, ? extends Object> entry : map.entrySet()) {\n"]}, "removed": {"3": ["  public static <T, K, V> Collector<T, ?, ImmutableMap<K, V>> toImmutableMap(\n", "      Function<? super T, ? extends K> keyFunction,\n", "      Function<? super T, ? extends V> valueFunction) {\n"], "4": ["  public static <T, K, V> Collector<T, ?, ImmutableMap<K, V>> toImmutableMap(\n", "      Function<? super T, ? extends K> keyFunction,\n", "      Function<? super T, ? extends V> valueFunction,\n", "      BinaryOperator<V> mergeFunction) {\n"], "5": ["    @Nullable Comparator<? super V> valueComparator;\n", "    Entry<K, V>[] entries;\n"], "6": ["    @SuppressWarnings(\"unchecked\")\n", "      this.entries = new Entry[initialCapacity];\n"], "7": ["          return of(entries[0].getKey(), entries[0].getValue());\n"], "8": ["          return of(entries[0].getKey(), entries[0].getValue());\n"], "9": ["        Entry<K, V> onlyEntry = entryArray[0];\n"], "10": ["    for (Entry<?, ?> entry : copy.entrySet()) {\n"], "14": ["  public final V compute(K key, BiFunction<? super K, ? super V, ? extends V> remappingFunction) {\n"], "15": ["  public final V remove(Object o) {\n"], "16": ["  public final boolean remove(Object key, Object value) {\n"], "17": ["  public boolean containsKey(@Nullable Object key) {\n", "  public boolean containsValue(@Nullable Object value) {\n", "  public abstract V get(@Nullable Object key);\n"], "18": ["  public final V getOrDefault(@Nullable Object key, @Nullable V defaultValue) {\n", "    return (result != null) ? result : defaultValue;\n", "  @LazyInit @RetainedWith private transient ImmutableSet<Entry<K, V>> entrySet;\n"], "19": ["  @LazyInit @RetainedWith private transient ImmutableSet<K> keySet;\n"], "20": ["  @LazyInit @RetainedWith private transient ImmutableCollection<V> values;\n"], "21": ["  @LazyInit private transient ImmutableSetMultimap<K, V> multimapView;\n"], "22": ["    public boolean containsKey(@Nullable Object key) {\n", "    public ImmutableSet<V> get(@Nullable Object key) {\n"], "23": ["  public boolean equals(@Nullable Object object) {\n"], "24": ["        for (Entry<?, ?> entry : map.entrySet()) {\n"]}, "added_lines": {"1": [23], "2": [68], "3": [83, 84, 85, 86], "4": [100, 101, 102, 103, 104], "5": [252, 253], "6": [265, 267], "7": [393, 394, 395], "8": [410, 411, 412], "9": [464, 465], "10": [479], "11": [536], "12": [551], "13": [577], "14": [619, 620], "15": [673, 674], "16": [687], "17": [710, 715, 722], "18": [730, 731, 733, 734, 735, 736, 737, 738, 741], "19": [755], "20": [793], "21": [813], "22": [846, 851, 852], "23": [902], "24": [943, 944]}, "removed_lines": {"3": [81, 82, 83], "4": [97, 98, 99, 100], "5": [248, 249], "6": [261, 263], "7": [389], "8": [404], "9": [456], "10": [470], "14": [607], "15": [660], "16": [673], "17": [696, 701, 708], "18": [716, 718, 721], "19": [735], "20": [773], "21": [793], "22": [826, 831], "23": [881], "24": [922]}}, {"15": "guava/src/com/google/common/collect/ImmutableMapEntry.java", "added": {"1": ["import javax.annotation.CheckForNull;\n"], "2": ["@ElementTypesAreNonnullByDefault\n", "   *\n", "   * <p>The returned array has all its elements set to their initial null values. However, we don't\n", "   * declare it as {@code @Nullable ImmutableMapEntry[]} because our checker doesn't require newly\n", "   * created arrays to have a {@code @Nullable} element type even when they're created directly with\n", "   * {@code new ImmutableMapEntry[...]}, so it seems silly to insist on that only here.\n"], "3": ["  @CheckForNull\n", "  @CheckForNull\n"], "4": ["    /*\n", "     * Yes, we sometimes set nextInKeyBucket to null, even for this \"non-terminal\" entry. We don't\n", "     * do that with a plain NonTerminalImmutableMapEntry, but we do do it with the BiMap-specific\n", "     * subclass below. That's because the Entry might be non-terminal in the key bucket but terminal\n", "     * in the value bucket (or vice versa).\n", "     */\n", "    @CheckForNull private final transient ImmutableMapEntry<K, V> nextInKeyBucket;\n", "\n", "    NonTerminalImmutableMapEntry(\n", "        K key, V value, @CheckForNull ImmutableMapEntry<K, V> nextInKeyBucket) {\n", "    @CheckForNull\n", "    final ImmutableMapEntry<K, V> getNextInKeyBucket() {\n"], "5": ["    @CheckForNull private final transient ImmutableMapEntry<K, V> nextInValueBucket;\n", "        @CheckForNull ImmutableMapEntry<K, V> nextInKeyBucket,\n", "        @CheckForNull ImmutableMapEntry<K, V> nextInValueBucket) {\n", "    @CheckForNull\n"]}, "removed": {"1": ["import org.checkerframework.checker.nullness.qual.Nullable;\n"], "3": ["  @Nullable\n", "  @Nullable\n"], "4": ["    private final transient ImmutableMapEntry<K, V> nextInKeyBucket;\n", "\n", "    NonTerminalImmutableMapEntry(K key, V value, ImmutableMapEntry<K, V> nextInKeyBucket) {\n", "    final @Nullable ImmutableMapEntry<K, V> getNextInKeyBucket() {\n"], "5": ["    private final transient ImmutableMapEntry<K, V> nextInValueBucket;\n", "        ImmutableMapEntry<K, V> nextInKeyBucket,\n", "        ImmutableMapEntry<K, V> nextInValueBucket) {\n", "    @Nullable\n"]}, "added_lines": {"1": [22], "2": [36, 41, 42, 43, 44, 45], "3": [62, 67], "4": [81, 82, 83, 84, 85, 86, 87, 88, 89, 90, 96, 97], "5": [109, 114, 115, 121]}, "removed_lines": {"1": [22], "3": [56, 61], "4": [75, 76, 77, 83], "5": [95, 100, 101, 107]}}, {"16": "guava/src/com/google/common/collect/ImmutableMapEntrySet.java", "added": {"1": ["import javax.annotation.CheckForNull;\n"], "2": ["@ElementTypesAreNonnullByDefault\n"], "3": ["    int copyIntoArray(@Nullable Object[] dst, int offset) {\n"], "4": ["  public boolean contains(@CheckForNull Object object) {\n"]}, "removed": {"3": ["    int copyIntoArray(Object[] dst, int offset) {\n"], "4": ["  public boolean contains(@Nullable Object object) {\n"]}, "added_lines": {"1": [25], "2": [35], "3": [57], "4": [92]}, "removed_lines": {"3": [55], "4": [90]}}, {"17": "guava/src/com/google/common/collect/ImmutableMapKeySet.java", "added": {"1": ["import javax.annotation.CheckForNull;\n"], "2": ["@ElementTypesAreNonnullByDefault\n"], "3": ["  public boolean contains(@CheckForNull Object object) {\n"]}, "removed": {"1": ["import org.checkerframework.checker.nullness.qual.Nullable;\n"], "3": ["  public boolean contains(@Nullable Object object) {\n"]}, "added_lines": {"1": [26], "2": [35], "3": [59]}, "removed_lines": {"1": [26], "3": [58]}}, {"18": "guava/src/com/google/common/collect/ImmutableMapValues.java", "added": {"1": ["import javax.annotation.CheckForNull;\n"], "2": ["@ElementTypesAreNonnullByDefault\n"], "3": ["  public boolean contains(@CheckForNull Object object) {\n"]}, "removed": {"1": ["import org.checkerframework.checker.nullness.qual.Nullable;\n"], "3": ["  public boolean contains(@Nullable Object object) {\n"]}, "added_lines": {"1": [27], "2": [36], "3": [72]}, "removed_lines": {"1": [27], "3": [71]}}, {"19": "guava/src/com/google/common/collect/ImmutableSortedMap.java", "added": {"1": ["import static java.util.Objects.requireNonNull;\n"], "2": ["      @Nullable Entry<K, V>[] entryArray,\n", "        // requireNonNull is safe because the first `size` elements have been filled in.\n", "        Entry<K, V> onlyEntry = requireNonNull(entryArray[0]);\n", "        return of(comparator, onlyEntry.getKey(), onlyEntry.getValue());\n", "            // requireNonNull is safe because the first `size` elements have been filled in.\n", "            Entry<K, V> entry = requireNonNull(entryArray[i]);\n", "            Object key = entry.getKey();\n", "            Object value = entry.getValue();\n"], "3": ["              new Comparator<@Nullable Entry<K, V>>() {\n", "                public int compare(@CheckForNull Entry<K, V> e1, @CheckForNull Entry<K, V> e2) {\n", "                  // requireNonNull is safe because the first `size` elements have been filled in.\n", "                  requireNonNull(e1);\n", "                  requireNonNull(e2);\n", "          // requireNonNull is safe because the first `size` elements have been filled in.\n", "          Entry<K, V> firstEntry = requireNonNull(entryArray[0]);\n", "          K prevKey = firstEntry.getKey();\n", "          values[0] = firstEntry.getValue();\n", "            // requireNonNull is safe because the first `size` elements have been filled in.\n", "            Entry<K, V> prevEntry = requireNonNull(entryArray[i - 1]);\n", "            Entry<K, V> entry = requireNonNull(entryArray[i]);\n", "            K key = entry.getKey();\n", "            V value = entry.getValue();\n", "            checkNoConflict(comparator.compare(prevKey, key) != 0, \"key\", prevEntry, entry);\n"], "4": ["          // requireNonNull is safe because the first `size` elements have been filled in.\n", "          Entry<K, V> onlyEntry = requireNonNull(entries[0]);\n", "          return of(comparator, onlyEntry.getKey(), onlyEntry.getValue());\n"]}, "removed": {"2": ["      Entry<K, V>[] entryArray,\n", "        return ImmutableSortedMap.<K, V>of(\n", "            comparator, entryArray[0].getKey(), entryArray[0].getValue());\n", "            Object key = entryArray[i].getKey();\n", "            Object value = entryArray[i].getValue();\n"], "3": ["              new Comparator<Entry<K, V>>() {\n", "                public int compare(Entry<K, V> e1, Entry<K, V> e2) {\n", "          K prevKey = entryArray[0].getKey();\n", "          values[0] = entryArray[0].getValue();\n", "            K key = entryArray[i].getKey();\n", "            V value = entryArray[i].getValue();\n", "            checkNoConflict(\n", "                comparator.compare(prevKey, key) != 0, \"key\", entryArray[i - 1], entryArray[i]);\n"], "4": ["          return of(comparator, entries[0].getKey(), entries[0].getValue());\n"]}, "added_lines": {"1": [23], "2": [351, 357, 358, 359, 366, 367, 368, 369], "3": [382, 384, 385, 386, 387, 391, 392, 393, 395, 398, 399, 400, 401, 402, 406], "4": [566, 567, 568]}, "removed_lines": {"2": [350, 356, 357, 364, 365], "3": [378, 380, 384, 386, 389, 390, 394, 395], "4": [555]}}, {"20": "guava/src/com/google/common/collect/JdkBackedImmutableBiMap.java", "added": {"1": ["import static java.util.Objects.requireNonNull;\n", "\n"], "2": ["import org.checkerframework.checker.nullness.qual.Nullable;\n"], "3": ["  static <K, V> ImmutableBiMap<K, V> create(int n, @Nullable Entry<K, V>[] entryArray) {\n", "      // requireNonNull is safe because the first `n` elements have been filled in.\n", "      Entry<K, V> e = RegularImmutableMap.makeImmutable(requireNonNull(entryArray[i]));\n"]}, "removed": {"3": ["  static <K, V> ImmutableBiMap<K, V> create(int n, Entry<K, V>[] entryArray) {\n", "      Entry<K, V> e = RegularImmutableMap.makeImmutable(entryArray[i]);\n"]}, "added_lines": {"1": [18, 19], "2": [27], "3": [37, 41, 42]}, "removed_lines": {"3": [34, 38]}}, {"21": "guava/src/com/google/common/collect/JdkBackedImmutableMap.java", "added": {"1": ["import static java.util.Objects.requireNonNull;\n", "import javax.annotation.CheckForNull;\n"], "2": ["@ElementTypesAreNonnullByDefault\n", "  static <K, V> ImmutableMap<K, V> create(int n, @Nullable Entry<K, V>[] entryArray) {\n", "      // requireNonNull is safe because the first `n` elements have been filled in.\n", "      entryArray[i] = makeImmutable(requireNonNull(entryArray[i]));\n"], "3": ["  @CheckForNull\n", "  public V get(@CheckForNull Object key) {\n"]}, "removed": {"2": ["  static <K, V> ImmutableMap<K, V> create(int n, Entry<K, V>[] entryArray) {\n", "      entryArray[i] = makeImmutable(entryArray[i]);\n"], "3": ["  public V get(@Nullable Object key) {\n"]}, "added_lines": {"1": [21, 26], "2": [34, 41, 44, 45], "3": [68, 69]}, "removed_lines": {"2": [38, 41], "3": [64]}}, {"22": "guava/src/com/google/common/collect/RegularImmutableBiMap.java", "added": {"1": ["import static java.util.Objects.requireNonNull;\n"], "2": ["  static <K, V> ImmutableBiMap<K, V> fromEntryArray(int n, @Nullable Entry<K, V>[] entryArray) {\n", "    /*\n", "     * The cast is safe: n==entryArray.length means that we have filled the whole array with Entry\n", "     * instances, in which case it is safe to cast it from an array of nullable entries to an array\n", "     * of non-null entries.\n", "     */\n", "    @SuppressWarnings(\"nullness\")\n", "    Entry<K, V>[] entries =\n", "        (n == entryArray.length) ? (Entry<K, V>[]) entryArray : createEntryArray(n);\n", "      // requireNonNull is safe because the first `n` elements have been filled in.\n", "      Entry<K, V> entry = requireNonNull(entryArray[i]);\n"]}, "removed": {"2": ["  static <K, V> ImmutableBiMap<K, V> fromEntryArray(int n, Entry<K, V>[] entryArray) {\n", "    Entry<K, V>[] entries;\n", "    if (n == entryArray.length) {\n", "      entries = entryArray;\n", "    } else {\n", "      entries = createEntryArray(n);\n", "    }\n", "      Entry<K, V> entry = entryArray[i];\n"]}, "added_lines": {"1": [24], "2": [63, 69, 70, 71, 72, 73, 74, 75, 76, 80, 81]}, "removed_lines": {"2": [62, 68, 69, 70, 71, 72, 73, 77]}}, {"23": "guava/src/com/google/common/collect/RegularImmutableMap.java", "added": {"1": ["import static java.util.Objects.requireNonNull;\n"], "2": ["import javax.annotation.CheckForNull;\n"], "3": ["@ElementTypesAreNonnullByDefault\n"], "4": ["  @CheckForNull private final transient @Nullable ImmutableMapEntry<K, V>[] table;\n"], "5": ["  static <K, V> ImmutableMap<K, V> fromEntryArray(int n, @Nullable Entry<K, V>[] entryArray) {\n", "    /*\n", "     * The cast is safe: n==entryArray.length means that we have filled the whole array with Entry\n", "     * instances, in which case it is safe to cast it from an array of nullable entries to an array\n", "     * of non-null entries.\n", "     */\n", "    @SuppressWarnings(\"nullness\")\n", "    Entry<K, V>[] entries =\n", "        (n == entryArray.length) ? (Entry<K, V>[]) entryArray : createEntryArray(n);\n", "    @Nullable ImmutableMapEntry<K, V>[] table = createEntryArray(tableSize);\n", "      // requireNonNull is safe because the first `n` elements have been filled in.\n", "      Entry<K, V> entry = requireNonNull(entryArray[entryIndex]);\n", "      ImmutableMapEntry<K, V> existing = table[tableIndex];\n"], "6": ["  private RegularImmutableMap(\n", "      Entry<K, V>[] entries, @CheckForNull @Nullable ImmutableMapEntry<K, V>[] table, int mask) {\n"], "7": ["      Object key, Entry<?, ?> entry, @CheckForNull ImmutableMapEntry<?, ?> keyBucketHead) {\n"], "8": ["  @CheckForNull\n", "  public V get(@CheckForNull Object key) {\n", "  @CheckForNull\n", "  static <V> V get(\n", "      @CheckForNull Object key,\n", "      @CheckForNull @Nullable ImmutableMapEntry<?, V>[] keyTable,\n", "      int mask) {\n"], "9": ["    public boolean contains(@CheckForNull Object object) {\n"]}, "removed": {"4": ["  private final transient ImmutableMapEntry<K, V>[] table;\n"], "5": ["  static <K, V> ImmutableMap<K, V> fromEntryArray(int n, Entry<K, V>[] entryArray) {\n", "    Entry<K, V>[] entries;\n", "    if (n == entryArray.length) {\n", "      entries = entryArray;\n", "    } else {\n", "      entries = createEntryArray(n);\n", "    }\n", "    ImmutableMapEntry<K, V>[] table = createEntryArray(tableSize);\n", "      Entry<K, V> entry = entryArray[entryIndex];\n", "      @Nullable ImmutableMapEntry<K, V> existing = table[tableIndex];\n"], "6": ["  private RegularImmutableMap(Entry<K, V>[] entries, ImmutableMapEntry<K, V>[] table, int mask) {\n"], "7": ["      Object key, Entry<?, ?> entry, @Nullable ImmutableMapEntry<?, ?> keyBucketHead) {\n"], "8": ["  public V get(@Nullable Object key) {\n", "  static <V> @Nullable V get(\n", "      @Nullable Object key, ImmutableMapEntry<?, V> @Nullable [] keyTable, int mask) {\n"], "9": ["    public boolean contains(Object object) {\n"]}, "added_lines": {"1": [23], "2": [32], "3": [43], "4": [71], "5": [84, 89, 90, 91, 92, 93, 94, 95, 96, 98, 101, 102, 107], "6": [137, 138], "7": [150], "8": [160, 161, 165, 166, 167, 168, 169], "9": [234]}, "removed_lines": {"4": [68], "5": [81, 86, 87, 88, 89, 90, 91, 93, 96, 101], "6": [131], "7": [143], "8": [153, 157, 158], "9": [223]}}]}
