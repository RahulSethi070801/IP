{
    "addition": {
        "50": " * another (and thus be aware of each other).  It is designed exclusively to\n",
        "58": " * <li>Expose a public method, known as the <i>event subscriber</i>, which accepts\n",
        "59": " *     a single argument of the type of event desired;</li>\n",
        "62": " *     </li>\n",
        "66": " * <p>To post an event, simply provide the event object to the\n",
        "67": " * {@link #post(Object)} method.  The EventBus instance will determine the type\n",
        "68": " * of event and route it to all registered listeners.\n",
        "71": " * to any subscriber for any type to which the event is <em>assignable.</em>  This\n",
        "75": " * <p>When {@code post} is called, all registered subscribers for an event are run\n",
        "76": " * in sequence, so subscribers should be reasonably quick.  If an event may trigger\n",
        "78": " * later.  (For a convenient way to do this, use an {@link AsyncEventBus}.)\n",
        "80": " * <h2>Subscriber Methods</h2>\n",
        "81": " * <p>Event subscriber methods must accept only one argument: the event.\n",
        "83": " * <p>Subscribers should not, in general, throw.  If they do, the EventBus will\n",
        "84": " * catch and log the exception.  This is rarely the right solution for error\n",
        "85": " * handling and should not be relied upon; it is intended solely to help find\n",
        "86": " * problems during development.\n",
        "87": " *\n",
        "88": " * <p>The EventBus guarantees that it will not call a subscriber method from\n",
        "90": " * bearing the {@link AllowConcurrentEvents} annotation.  If this annotation is\n",
        "91": " * not present, subscriber methods need not worry about being reentrant, unless\n",
        "95": " * <p>If an event is posted, but no registered subscribers can accept it, it is\n",
        "96": " * considered \"dead.\"  To give the system a second chance to handle dead events,\n",
        "99": " * <p>If a subscriber for a supertype of all events (such as Object) is registered,\n",
        "101": " * Accordingly, while DeadEvent extends {@link Object}, a subscriber registered to\n",
        "107": " * \"http://code.google.com/p/guava-libraries/wiki/EventBusExplained\">\n",
        "108": " * {@code EventBus}</a>.\n",
        "133": "   * All registered event subscribers, indexed by event type.\n",
        "136": "   * made after acquiring a read or write lock via {@link #subscribersByTypeLock}.\n",
        "138": "  private final SetMultimap<Class<?>, EventSubscriber> subscribersByType =\n",
        "140": "  private final ReadWriteLock subscribersByTypeLock = new ReentrantReadWriteLock();\n",
        "143": "   * Strategy for finding subscriber methods in registered objects.  Currently,\n",
        "144": "   * only the {@link AnnotatedSubscriberFinder} is supported, but this is\n",
        "147": "  private final SubscriberFindingStrategy finder = new AnnotatedSubscriberFinder();\n",
        "150": "  private final ThreadLocal<Queue<EventWithSubscriber>> eventsToDispatch =\n",
        "151": "      new ThreadLocal<Queue<EventWithSubscriber>>() {\n",
        "152": "    @Override protected Queue<EventWithSubscriber> initialValue() {\n",
        "153": "      return new LinkedList<EventWithSubscriber>();\n",
        "195": "   * Registers all subscriber methods on {@code object} to receive events.\n",
        "196": "   * Subscriber methods are selected and classified using this EventBus's\n",
        "197": "   * {@link SubscriberFindingStrategy}; the default strategy is the\n",
        "198": "   * {@link AnnotatedSubscriberFinder}.\n",
        "200": "   * @param object  object whose subscriber methods should be registered.\n",
        "203": "    Multimap<Class<?>, EventSubscriber> methodsInListener =\n",
        "204": "        finder.findAllSubscribers(object);\n",
        "205": "    subscribersByTypeLock.writeLock().lock();\n",
        "207": "      subscribersByType.putAll(methodsInListener);\n",
        "209": "      subscribersByTypeLock.writeLock().unlock();\n",
        "214": "   * Unregisters all subscriber methods on a registered {@code object}.\n",
        "216": "   * @param object  object whose subscriber methods should be unregistered.\n",
        "217": "   * @throws IllegalArgumentException if the object was not previously registered.\n",
        "220": "    Multimap<Class<?>, EventSubscriber> methodsInListener = finder.findAllSubscribers(object);\n",
        "221": "    for (Entry<Class<?>, Collection<EventSubscriber>> entry :\n",
        "222": "          methodsInListener.asMap().entrySet()) {\n",
        "224": "      Collection<EventSubscriber> eventMethodsInListener = entry.getValue();\n",
        "226": "      subscribersByTypeLock.writeLock().lock();\n",
        "228": "        Set<EventSubscriber> currentSubscribers = subscribersByType.get(eventType);\n",
        "229": "        if (!currentSubscribers.containsAll(eventMethodsInListener)) {\n",
        "231": "              \"missing event subscriber for an annotated method. Is \" + object + \" registered?\");\n",
        "233": "        currentSubscribers.removeAll(eventMethodsInListener);\n",
        "235": "        subscribersByTypeLock.writeLock().unlock();\n",
        "241": "   * Posts an event to all registered subscribers.  This method will return\n",
        "242": "   * successfully after the event has been posted to all subscribers, and\n",
        "243": "   * regardless of any exceptions thrown by subscribers.\n",
        "245": "   * <p>If no subscribers have been subscribed for {@code event}'s class, and\n",
        "256": "      subscribersByTypeLock.readLock().lock();\n",
        "258": "        Set<EventSubscriber> wrappers = subscribersByType.get(eventType);\n",
        "262": "          for (EventSubscriber wrapper : wrappers) {\n",
        "267": "        subscribersByTypeLock.readLock().unlock();\n",
        "283": "  void enqueueEvent(Object event, EventSubscriber subscriber) {\n",
        "284": "    eventsToDispatch.get().offer(new EventWithSubscriber(event, subscriber));\n",
        "301": "      Queue<EventWithSubscriber> events = eventsToDispatch.get();\n",
        "302": "      EventWithSubscriber eventWithSubscriber;\n",
        "303": "      while ((eventWithSubscriber = events.poll()) != null) {\n",
        "304": "        dispatch(eventWithSubscriber.event, eventWithSubscriber.subscriber);\n",
        "313": "   * Dispatches {@code event} to the subscriber in {@code wrapper}.  This method\n",
        "318": "   * @param wrapper  wrapper that will call the subscriber.\n",
        "320": "  void dispatch(Object event, EventSubscriber wrapper) {\n",
        "390": "  /** simple struct representing an event and it's subscriber */\n",
        "391": "  static class EventWithSubscriber {\n",
        "393": "    final EventSubscriber subscriber;\n",
        "394": "    public EventWithSubscriber(Object event, EventSubscriber subscriber) {\n",
        "396": "      this.subscriber = checkNotNull(subscriber);\n"
    },
    "removed": {
        "50": " * another (and thus be aware of each other). It is designed exclusively to\n",
        "58": " * <li>Expose a public method, known as the <i>event handler</i>, which accepts\n",
        "59": " * a single argument of the type of event desired;</li>\n",
        "62": " * </li>\n",
        "66": " * <p>To post an event, simply provide the event object to the {@link\n",
        "67": " * #post(Object)} method. The EventBus instance will determine the type of event\n",
        "68": " * and route it to all registered listeners.\n",
        "71": " * to any handler for any type to which the event is <em>assignable.</em> This\n",
        "75": " * <p>When {@code post} is called, all registered handlers for an event are run\n",
        "76": " * in sequence, so handlers should be reasonably quick. If an event may trigger\n",
        "78": " * later. (For a convenient way to do this, use an {@link AsyncEventBus}.)\n",
        "80": " * <h2>Handler Methods</h2>\n",
        "81": " * <p>Event handler methods must accept only one argument: the event.\n",
        "83": " * <p>The EventBus guarantees that it will not call a handler method from\n",
        "85": " * bearing the {@link AllowConcurrentEvents} annotation. If this annotation is\n",
        "86": " * not present, handler methods need not worry about being reentrant, unless\n",
        "90": " * <p>If an event is posted, but no registered handlers can accept it, it is\n",
        "91": " * considered \"dead.\" To give the system a second chance to handle dead events,\n",
        "94": " * <p>If a handler for a supertype of all events (such as Object) is registered,\n",
        "96": " * Accordingly, while DeadEvent extends {@link Object}, a handler registered to\n",
        "99": " * <h2>Exception Handling</h2>\n",
        "100": " *\n",
        "101": " * <p>When a subscriber throws an exception while handling event, the {@link\n",
        "102": " * SubscriberExceptionHandler} is called.\n",
        "103": " *\n",
        "107": " * \"http://code.google.com/p/guava-libraries/wiki/EventBusExplained\">{@code\n",
        "108": " * EventBus}</a>.\n",
        "133": "   * All registered event handlers, indexed by event type.\n",
        "136": "   * made after acquiring a read or write lock via {@link #handlersByTypeLock}.\n",
        "138": "  private final SetMultimap<Class<?>, EventHandler> handlersByType =\n",
        "140": "  private final ReadWriteLock handlersByTypeLock = new ReentrantReadWriteLock();\n",
        "143": "   * Strategy for finding handler methods in registered objects.  Currently,\n",
        "144": "   * only the {@link AnnotatedHandlerFinder} is supported, but this is\n",
        "147": "  private final HandlerFindingStrategy finder = new AnnotatedHandlerFinder();\n",
        "150": "  private final ThreadLocal<Queue<EventWithHandler>> eventsToDispatch =\n",
        "151": "      new ThreadLocal<Queue<EventWithHandler>>() {\n",
        "152": "    @Override protected Queue<EventWithHandler> initialValue() {\n",
        "153": "      return new LinkedList<EventWithHandler>();\n",
        "195": "   * Registers all handler methods on {@code object} to receive events.\n",
        "196": "   * Handler methods are selected and classified using this EventBus's\n",
        "197": "   * {@link HandlerFindingStrategy}; the default strategy is the\n",
        "198": "   * {@link AnnotatedHandlerFinder}.\n",
        "200": "   * @param object  object whose handler methods should be registered.\n",
        "203": "    Multimap<Class<?>, EventHandler> methodsInListener =\n",
        "204": "        finder.findAllHandlers(object);\n",
        "205": "    handlersByTypeLock.writeLock().lock();\n",
        "207": "      handlersByType.putAll(methodsInListener);\n",
        "209": "      handlersByTypeLock.writeLock().unlock();\n",
        "214": "   * Unregisters all handler methods on a registered {@code object}.\n",
        "216": "   * @param object object whose handler methods should be unregistered.\n",
        "217": "   * @throws IllegalArgumentException if the object was not previously\n",
        "218": "   *         registered.\n",
        "221": "    Multimap<Class<?>, EventHandler> methodsInListener = finder.findAllHandlers(object);\n",
        "222": "    for (Entry<Class<?>, Collection<EventHandler>> entry : methodsInListener.asMap().entrySet()) {\n",
        "224": "      Collection<EventHandler> eventMethodsInListener = entry.getValue();\n",
        "226": "      handlersByTypeLock.writeLock().lock();\n",
        "228": "        Set<EventHandler> currentHandlers = handlersByType.get(eventType);\n",
        "229": "        if (!currentHandlers.containsAll(eventMethodsInListener)) {\n",
        "231": "              \"missing event handler for an annotated method. Is \" + object + \" registered?\");\n",
        "233": "        currentHandlers.removeAll(eventMethodsInListener);\n",
        "235": "        handlersByTypeLock.writeLock().unlock();\n",
        "241": "   * Posts an event to all registered handlers.  This method will return\n",
        "242": "   * successfully after the event has been posted to all handlers, and\n",
        "243": "   * regardless of any exceptions thrown by handlers.\n",
        "245": "   * <p>If no handlers have been subscribed for {@code event}'s class, and\n",
        "256": "      handlersByTypeLock.readLock().lock();\n",
        "258": "        Set<EventHandler> wrappers = handlersByType.get(eventType);\n",
        "262": "          for (EventHandler wrapper : wrappers) {\n",
        "267": "        handlersByTypeLock.readLock().unlock();\n",
        "283": "  void enqueueEvent(Object event, EventHandler handler) {\n",
        "284": "    eventsToDispatch.get().offer(new EventWithHandler(event, handler));\n",
        "301": "      Queue<EventWithHandler> events = eventsToDispatch.get();\n",
        "302": "      EventWithHandler eventWithHandler;\n",
        "303": "      while ((eventWithHandler = events.poll()) != null) {\n",
        "304": "        dispatch(eventWithHandler.event, eventWithHandler.handler);\n",
        "313": "   * Dispatches {@code event} to the handler in {@code wrapper}.  This method\n",
        "318": "   * @param wrapper  wrapper that will call the handler.\n",
        "320": "  void dispatch(Object event, EventHandler wrapper) {\n",
        "390": "  /** simple struct representing an event and it's handler */\n",
        "391": "  static class EventWithHandler {\n",
        "393": "    final EventHandler handler;\n",
        "394": "    public EventWithHandler(Object event, EventHandler handler) {\n",
        "396": "      this.handler = checkNotNull(handler);\n"
    }
}