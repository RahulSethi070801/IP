{"id": "af79a1939d2900ecaae92a5538760369eaa60b9b", "code": [{"0": "guava-tests/test/com/google/common/eventbus/EventSubscriberTest.java", "added": {"1": [" * Test case for {@link EventSubscriber}.\n", "public class EventSubscriberTest extends TestCase {\n"], "2": ["    EventSubscriber subscriber = new EventSubscriber(this, method);\n", "    subscriber.handleEvent(FIXTURE_ARGUMENT);\n", "    assertTrue(\"Subscriber must call provided method.\", methodCalled);\n", "    assertTrue(\"Subscriber argument must be *exactly* the provided object.\",\n", "    EventSubscriber subscriber = new EventSubscriber(this, method);\n", "      subscriber.handleEvent(new Object());\n", "      fail(\"Subscribers whose methods throw must throw InvocationTargetException\");\n"], "3": ["    EventSubscriber subscriber = new EventSubscriber(this, method);\n", "      subscriber.handleEvent(new Object());\n", "      fail(\"Subscribers whose methods throw Errors must rethrow them\");\n"], "4": ["            new EventSubscriber(\"foo\", charAt), new EventSubscriber(\"foo\", charAt))\n", "        .addEqualityGroup(new EventSubscriber(\"bar\", charAt))\n", "        .addEqualityGroup(new EventSubscriber(\"foo\", concat))\n"], "5": ["          \"Someone changed EventSubscriberTest#recordingMethod's visibility, \" +\n"], "6": ["          \"Someone changed EventSubscriberTest#exceptionThrowingMethod's \" +\n"], "7": ["          \"Someone changed EventSubscriberTest#errorThrowingMethod's \" +\n"], "8": ["   * {@link #methodCalled}.  This method is called reflectively by EventSubscriber\n"]}, "removed": {"1": [" * Test case for {@link EventHandler}.\n", "public class EventHandlerTest extends TestCase {\n"], "2": ["    EventHandler handler = new EventHandler(this, method);\n", "    handler.handleEvent(FIXTURE_ARGUMENT);\n", "    assertTrue(\"Handler must call provided method.\", methodCalled);\n", "    assertTrue(\"Handler argument must be *exactly* the provided object.\",\n", "    EventHandler handler = new EventHandler(this, method);\n", "      handler.handleEvent(new Object());\n", "      fail(\"Handlers whose methods throw must throw InvocationTargetException\");\n"], "3": ["    EventHandler handler = new EventHandler(this, method);\n", "      handler.handleEvent(new Object());\n", "      fail(\"Handlers whose methods throw Errors must rethrow them\");\n"], "4": ["            new EventHandler(\"foo\", charAt), new EventHandler(\"foo\", charAt))\n", "        .addEqualityGroup(new EventHandler(\"bar\", charAt))\n", "        .addEqualityGroup(new EventHandler(\"foo\", concat))\n"], "5": ["          \"Someone changed EventHandlerTest#recordingMethod's visibility, \" +\n"], "6": ["          \"Someone changed EventHandlerTest#exceptionThrowingMethod's \" +\n"], "7": ["          \"Someone changed EventHandlerTest#errorThrowingMethod's \" +\n"], "8": ["   * {@link #methodCalled}.  This method is called reflectively by EventHandler\n"]}, "added_lines": {"1": [27, 31], "2": [53, 55, 57, 58, 64, 67, 68], "3": [77, 80, 81], "4": [92, 93, 94], "5": [115], "6": [138], "7": [161], "8": [169]}, "removed_lines": {"1": [27, 31], "2": [53, 55, 57, 58, 64, 67, 68], "3": [77, 80, 81], "4": [92, 93, 94], "5": [115], "6": [138], "7": [161], "8": [169]}}, {"1": "guava-tests/test/com/google/common/eventbus/PackageSanityTests.java", "added": {"1": ["    setDefault(EventSubscriber.class, new DummySubscriber().toEventSubscriber());\n", "    setDefault(Method.class, DummySubscriber.subscriberMethod());\n", "  private static class DummySubscriber {\n", "    EventSubscriber toEventSubscriber() throws Exception {\n", "      return new EventSubscriber(this, subscriberMethod());\n", "    private static Method subscriberMethod() throws NoSuchMethodException {\n", "      return DummySubscriber.class.getMethod(\"handle\", Object.class);\n"]}, "removed": {"1": ["    setDefault(EventHandler.class, new DummyHandler().toEventHandler());\n", "    setDefault(Method.class, DummyHandler.handlerMethod());\n", "  private static class DummyHandler {\n", "    EventHandler toEventHandler() throws Exception {\n", "      return new EventHandler(this, handlerMethod());\n", "    private static Method handlerMethod() throws NoSuchMethodException {\n", "      return DummyHandler.class.getMethod(\"handle\", Object.class);\n"]}, "added_lines": {"1": [34, 35, 38, 43, 44, 47, 48]}, "removed_lines": {"1": [34, 35, 38, 43, 44, 47, 48]}}, {"2": "guava-tests/test/com/google/common/eventbus/StringCatcher.java", "added": {"1": [" * A simple EventSubscriber mock that records Strings.\n"]}, "removed": {"1": [" * A simple EventHandler mock that records Strings.\n"]}, "added_lines": {"1": [28]}, "removed_lines": {"1": [28]}}, {"3": "guava-tests/test/com/google/common/eventbus/outside/AnnotatedSubscriberFinderTests.java", "added": {"1": [" * Test that EventBus finds the correct subscribers.\n", "public class AnnotatedSubscriberFinderTests {\n", "    abstract H createSubscriber();\n", "    private H subscriber;\n", "    H getSubscriber() {\n", "      return subscriber;\n", "      subscriber = createSubscriber();\n", "      bus.register(subscriber);\n", "      subscriber = null;\n", "  public static class BaseSubscriberFinderTest extends\n", "      AbstractEventBusTest<BaseSubscriberFinderTest.Subscriber> {\n", "    static class Subscriber {\n"], "2": ["      ASSERT.that(getSubscriber().nonSubscriberEvents).isEmpty();\n", "      ASSERT.that(getSubscriber().subscriberEvents).has().item(EVENT);\n", "    Subscriber createSubscriber() {\n", "      return new Subscriber();\n"], "3": ["      ASSERT.that(getSubscriber().overriddenAndAnnotatedInSubclassEvents).has().item(EVENT);\n", "      ASSERT.that(getSubscriber().overriddenInSubclassEvents).has().item(EVENT);\n", "    SubClass createSubscriber() {\n"], "4": ["      ASSERT.that(getSubscriber().notOverriddenInSubclassEvents).has().item(EVENT);\n", "      ASSERT.that(getSubscriber().overriddenNotAnnotatedInSubclassEvents).has().item(EVENT);\n", "          .that(getSubscriber().differentlyOverriddenNotAnnotatedInSubclassGoodEvents)\n", "      ASSERT.that(getSubscriber().differentlyOverriddenNotAnnotatedInSubclassBadEvents).isEmpty();\n", "      ASSERT.that(getSubscriber().overriddenAndAnnotatedInSubclassEvents).has().item(EVENT);\n", "          .that(getSubscriber().differentlyOverriddenAnnotatedInSubclassGoodEvents)\n", "      ASSERT.that(getSubscriber().differentlyOverriddenAnnotatedInSubclassBadEvents).isEmpty();\n", "    SubClass createSubscriber() {\n"], "5": ["      ASSERT.that(getSubscriber().overriddenAndAnnotatedInSubclassEvents).has().item(EVENT);\n", "      ASSERT.that(getSubscriber().overriddenInSubclassNowhereAnnotatedEvents).isEmpty();\n", "    SubClass createSubscriber() {\n"], "6": ["      ASSERT.that(getSubscriber().neitherOverriddenNorAnnotatedEvents).isEmpty();\n", "      ASSERT.that(getSubscriber().overriddenInSubclassNowhereAnnotatedEvents).isEmpty();\n", "      ASSERT.that(getSubscriber().overriddenAndAnnotatedInSubclassEvents).has().item(EVENT);\n", "    SubClass createSubscriber() {\n", "      AbstractEventBusTest<DeepInterfaceTest.SubscriberClass> {\n"], "7": ["    static class SubscriberClass implements Interface2 {\n"], "8": ["      ASSERT.that(getSubscriber().annotatedIn1Events).has().item(EVENT);\n", "      ASSERT.that(getSubscriber().annotatedIn2Events).has().item(EVENT);\n", "      ASSERT.that(getSubscriber().annotatedIn1And2Events).has().item(EVENT);\n", "      ASSERT.that(getSubscriber().annotatedIn1And2AndClassEvents).has().item(EVENT);\n", "      ASSERT.that(getSubscriber().declaredIn1AnnotatedIn2Events).has().item(EVENT);\n", "      ASSERT.that(getSubscriber().declaredIn1AnnotatedInClassEvents).has().item(EVENT);\n", "      ASSERT.that(getSubscriber().declaredIn2AnnotatedInClassEvents).has().item(EVENT);\n", "      ASSERT.that(getSubscriber().nowhereAnnotatedEvents).isEmpty();\n", "    SubscriberClass createSubscriber() {\n", "      return new SubscriberClass();\n"]}, "removed": {"1": [" * Test that EventBus finds the correct handlers.\n", "public class AnnotatedHandlerFinderTests {\n", "    abstract H createHandler();\n", "    private H handler;\n", "    H getHandler() {\n", "      return handler;\n", "      handler = createHandler();\n", "      bus.register(handler);\n", "      handler = null;\n", "  public static class BaseHandlerFinderTest extends\n", "      AbstractEventBusTest<BaseHandlerFinderTest.Handler> {\n", "    static class Handler {\n"], "2": ["      ASSERT.that(getHandler().nonSubscriberEvents).isEmpty();\n", "      ASSERT.that(getHandler().subscriberEvents).has().item(EVENT);\n", "    Handler createHandler() {\n", "      return new Handler();\n"], "3": ["      ASSERT.that(getHandler().overriddenAndAnnotatedInSubclassEvents).has().item(EVENT);\n", "      ASSERT.that(getHandler().overriddenInSubclassEvents).has().item(EVENT);\n", "    SubClass createHandler() {\n"], "4": ["      ASSERT.that(getHandler().notOverriddenInSubclassEvents).has().item(EVENT);\n", "      ASSERT.that(getHandler().overriddenNotAnnotatedInSubclassEvents).has().item(EVENT);\n", "          .that(getHandler().differentlyOverriddenNotAnnotatedInSubclassGoodEvents)\n", "      ASSERT.that(getHandler().differentlyOverriddenNotAnnotatedInSubclassBadEvents).isEmpty();\n", "      ASSERT.that(getHandler().overriddenAndAnnotatedInSubclassEvents).has().item(EVENT);\n", "          .that(getHandler().differentlyOverriddenAnnotatedInSubclassGoodEvents)\n", "      ASSERT.that(getHandler().differentlyOverriddenAnnotatedInSubclassBadEvents).isEmpty();\n", "    SubClass createHandler() {\n"], "5": ["      ASSERT.that(getHandler().overriddenAndAnnotatedInSubclassEvents).has().item(EVENT);\n", "      ASSERT.that(getHandler().overriddenInSubclassNowhereAnnotatedEvents).isEmpty();\n", "    SubClass createHandler() {\n"], "6": ["      ASSERT.that(getHandler().neitherOverriddenNorAnnotatedEvents).isEmpty();\n", "      ASSERT.that(getHandler().overriddenInSubclassNowhereAnnotatedEvents).isEmpty();\n", "      ASSERT.that(getHandler().overriddenAndAnnotatedInSubclassEvents).has().item(EVENT);\n", "    SubClass createHandler() {\n", "      AbstractEventBusTest<DeepInterfaceTest.HandlerClass> {\n"], "7": ["    static class HandlerClass implements Interface2 {\n"], "8": ["      ASSERT.that(getHandler().annotatedIn1Events).has().item(EVENT);\n", "      ASSERT.that(getHandler().annotatedIn2Events).has().item(EVENT);\n", "      ASSERT.that(getHandler().annotatedIn1And2Events).has().item(EVENT);\n", "      ASSERT.that(getHandler().annotatedIn1And2AndClassEvents).has().item(EVENT);\n", "      ASSERT.that(getHandler().declaredIn1AnnotatedIn2Events).has().item(EVENT);\n", "      ASSERT.that(getHandler().declaredIn1AnnotatedInClassEvents).has().item(EVENT);\n", "      ASSERT.that(getHandler().declaredIn2AnnotatedInClassEvents).has().item(EVENT);\n", "      ASSERT.that(getHandler().nowhereAnnotatedEvents).isEmpty();\n", "    HandlerClass createHandler() {\n", "      return new HandlerClass();\n"]}, "added_lines": {"1": [30, 35, 40, 42, 44, 45, 50, 52, 58, 65, 66, 67], "2": [82, 86, 90, 91], "3": [122, 126, 130], "4": [202, 206, 211, 213, 217, 222, 224, 228], "5": [258, 262, 266], "6": [305, 309, 313, 317, 323], "7": [360], "8": [415, 419, 423, 427, 431, 435, 439, 443, 447, 448]}, "removed_lines": {"1": [30, 35, 40, 42, 44, 45, 50, 52, 58, 65, 66, 67], "2": [82, 86, 90, 91], "3": [122, 126, 130], "4": [202, 206, 211, 213, 217, 222, 224, 228], "5": [258, 262, 266], "6": [305, 309, 313, 317, 323], "7": [360], "8": [415, 419, 423, 427, 431, 435, 439, 443, 447, 448]}}, {"4": "guava/src/com/google/common/eventbus/AllowConcurrentEvents.java", "added": {"1": [" * Marks an event subscriber method as being thread-safe.  This annotation\n", " * indicates that EventBus may invoke the event subscriber simultaneously from\n", " * <p>This does not mark the method, and so should be used in combination with\n", " * {@link Subscribe}.\n"]}, "removed": {"1": [" * Marks an event handling method as being thread-safe.  This annotation\n", " * indicates that EventBus may invoke the event handler simultaneously from\n", " * <p>This does not mark the method as an event handler, and so should be used\n", " * in combination with {@link Subscribe}.\n"]}, "added_lines": {"1": [27, 28, 31, 32]}, "removed_lines": {"1": [27, 28, 31, 32]}}, {"5": "guava/src/com/google/common/eventbus/AnnotatedSubscriberFinder.java", "added": {"1": [" * A {@link SubscriberFindingStrategy} for collecting all event subscriber methods that are marked\n", " * with the {@link Subscribe} annotation.\n", "class AnnotatedSubscriberFinder implements SubscriberFindingStrategy {\n", "  private static final LoadingCache<Class<?>, ImmutableList<Method>> subscriberMethodsCache =\n"], "2": ["  public Multimap<Class<?>, EventSubscriber> findAllSubscribers(Object listener) {\n", "    Multimap<Class<?>, EventSubscriber> methodsInListener = HashMultimap.create();\n", "      EventSubscriber subscriber = makeSubscriber(listener, method);\n", "      methodsInListener.put(eventType, subscriber);\n", "      return subscriberMethodsCache.getUnchecked(clazz);\n"], "3": ["                + \" arguments.  Event subscriber methods must require a single argument.\");\n"], "4": ["   * Creates an {@code EventSubscriber} for subsequently calling {@code method} on\n", "   * Selects an EventSubscriber implementation based on the annotations on\n", "   * @param listener  object bearing the event subscriber method.\n", "   * @param method  the event subscriber method to wrap in an EventSubscriber.\n", "   * @return an EventSubscriber that will call {@code method} on {@code listener}\n", "  private static EventSubscriber makeSubscriber(Object listener, Method method) {\n", "    EventSubscriber wrapper;\n", "      wrapper = new EventSubscriber(listener, method);\n", "      wrapper = new SynchronizedEventSubscriber(listener, method);\n"], "5": ["   * @param method  subscriber method to check.\n", "   * @return {@code true} if {@code subscriber} is marked as thread-safe,\n"]}, "removed": {"1": [" * A {@link HandlerFindingStrategy} for collecting all event handler methods that are marked with\n", " * the {@link Subscribe} annotation.\n", "class AnnotatedHandlerFinder implements HandlerFindingStrategy {\n", "  private static final LoadingCache<Class<?>, ImmutableList<Method>> handlerMethodsCache =\n"], "2": ["  public Multimap<Class<?>, EventHandler> findAllHandlers(Object listener) {\n", "    Multimap<Class<?>, EventHandler> methodsInListener = HashMultimap.create();\n", "      EventHandler handler = makeHandler(listener, method);\n", "      methodsInListener.put(eventType, handler);\n", "      return handlerMethodsCache.getUnchecked(clazz);\n"], "3": ["                + \" arguments.  Event handler methods must require a single argument.\");\n"], "4": ["   * Creates an {@code EventHandler} for subsequently calling {@code method} on\n", "   * Selects an EventHandler implementation based on the annotations on\n", "   * @param listener  object bearing the event handler method.\n", "   * @param method  the event handler method to wrap in an EventHandler.\n", "   * @return an EventHandler that will call {@code method} on {@code listener}\n", "  private static EventHandler makeHandler(Object listener, Method method) {\n", "    EventHandler wrapper;\n", "      wrapper = new EventHandler(listener, method);\n", "      wrapper = new SynchronizedEventHandler(listener, method);\n"], "5": ["   * @param method  handler method to check.\n", "   * @return {@code true} if {@code handler} is marked as thread-safe,\n"]}, "added_lines": {"1": [40, 41, 46, 53], "2": [69, 70, 75, 76, 83], "3": [123], "4": [137, 139, 142, 143, 144, 147, 148, 150, 152], "5": [161, 162]}, "removed_lines": {"1": [40, 41, 46, 53], "2": [69, 70, 75, 76, 83], "3": [123], "4": [137, 139, 142, 143, 144, 147, 148, 150, 152], "5": [161, 162]}}, {"6": "guava/src/com/google/common/eventbus/AsyncEventBus.java", "added": {"1": ["  private final ConcurrentLinkedQueue<EventWithSubscriber> eventsToDispatch =\n", "      new ConcurrentLinkedQueue<EventWithSubscriber>();\n"], "2": ["  void enqueueEvent(Object event, EventSubscriber subscriber) {\n", "    eventsToDispatch.offer(new EventWithSubscriber(event, subscriber));\n"], "3": ["      EventWithSubscriber eventWithSubscriber = eventsToDispatch.poll();\n", "      if (eventWithSubscriber == null) {\n", "      dispatch(eventWithSubscriber.event, eventWithSubscriber.subscriber);\n", "   * Calls the {@link #executor} to dispatch {@code event} to {@code subscriber}.\n", "  void dispatch(final Object event, final EventSubscriber subscriber) {\n", "    checkNotNull(subscriber);\n", "            AsyncEventBus.super.dispatch(event, subscriber);\n"]}, "removed": {"1": ["  private final ConcurrentLinkedQueue<EventWithHandler> eventsToDispatch =\n", "      new ConcurrentLinkedQueue<EventWithHandler>();\n"], "2": ["  void enqueueEvent(Object event, EventHandler handler) {\n", "    eventsToDispatch.offer(new EventWithHandler(event, handler));\n"], "3": ["      EventWithHandler eventWithHandler = eventsToDispatch.poll();\n", "      if (eventWithHandler == null) {\n", "      dispatch(eventWithHandler.event, eventWithHandler.handler);\n", "   * Calls the {@link #executor} to dispatch {@code event} to {@code handler}.\n", "  void dispatch(final Object event, final EventHandler handler) {\n", "    checkNotNull(handler);\n", "            AsyncEventBus.super.dispatch(event, handler);\n"]}, "added_lines": {"1": [38, 39], "2": [85, 86], "3": [97, 98, 102, 107, 110, 112, 117]}, "removed_lines": {"1": [38, 39], "2": [85, 86], "3": [97, 98, 102, 107, 110, 112, 117]}}, {"7": "guava/src/com/google/common/eventbus/DeadEvent.java", "added": {"1": [" * <p>Registering a DeadEvent subscriber is useful for debugging or logging, as\n", " * it can detect misconfigurations in a system's event distribution.\n"], "2": ["   * to any registered subscriber.\n"]}, "removed": {"1": [" * <p>Subscribing a DeadEvent handler is useful for debugging or logging, as it\n", " * can detect misconfigurations in a system's event distribution.\n"], "2": ["   * to any registered handler.\n"]}, "added_lines": {"1": [27, 28], "2": [63]}, "removed_lines": {"1": [27, 28], "2": [63]}}, {"8": "guava/src/com/google/common/eventbus/EventBus.java", "added": {"1": [" * another (and thus be aware of each other).  It is designed exclusively to\n"], "2": [" * <li>Expose a public method, known as the <i>event subscriber</i>, which accepts\n", " *     a single argument of the type of event desired;</li>\n", " *     </li>\n", " * <p>To post an event, simply provide the event object to the\n", " * {@link #post(Object)} method.  The EventBus instance will determine the type\n", " * of event and route it to all registered listeners.\n", " * to any subscriber for any type to which the event is <em>assignable.</em>  This\n", " * <p>When {@code post} is called, all registered subscribers for an event are run\n", " * in sequence, so subscribers should be reasonably quick.  If an event may trigger\n", " * later.  (For a convenient way to do this, use an {@link AsyncEventBus}.)\n", " * <h2>Subscriber Methods</h2>\n", " * <p>Event subscriber methods must accept only one argument: the event.\n", " * <p>Subscribers should not, in general, throw.  If they do, the EventBus will\n", " * catch and log the exception.  This is rarely the right solution for error\n", " * handling and should not be relied upon; it is intended solely to help find\n", " * problems during development.\n", " *\n", " * <p>The EventBus guarantees that it will not call a subscriber method from\n", " * bearing the {@link AllowConcurrentEvents} annotation.  If this annotation is\n", " * not present, subscriber methods need not worry about being reentrant, unless\n", " * <p>If an event is posted, but no registered subscribers can accept it, it is\n", " * considered \"dead.\"  To give the system a second chance to handle dead events,\n", " * <p>If a subscriber for a supertype of all events (such as Object) is registered,\n", " * Accordingly, while DeadEvent extends {@link Object}, a subscriber registered to\n", " * \"http://code.google.com/p/guava-libraries/wiki/EventBusExplained\">\n", " * {@code EventBus}</a>.\n"], "3": ["   * All registered event subscribers, indexed by event type.\n", "   * made after acquiring a read or write lock via {@link #subscribersByTypeLock}.\n", "  private final SetMultimap<Class<?>, EventSubscriber> subscribersByType =\n", "  private final ReadWriteLock subscribersByTypeLock = new ReentrantReadWriteLock();\n", "   * Strategy for finding subscriber methods in registered objects.  Currently,\n", "   * only the {@link AnnotatedSubscriberFinder} is supported, but this is\n", "  private final SubscriberFindingStrategy finder = new AnnotatedSubscriberFinder();\n", "  private final ThreadLocal<Queue<EventWithSubscriber>> eventsToDispatch =\n", "      new ThreadLocal<Queue<EventWithSubscriber>>() {\n", "    @Override protected Queue<EventWithSubscriber> initialValue() {\n", "      return new LinkedList<EventWithSubscriber>();\n"], "4": ["   * Registers all subscriber methods on {@code object} to receive events.\n", "   * Subscriber methods are selected and classified using this EventBus's\n", "   * {@link SubscriberFindingStrategy}; the default strategy is the\n", "   * {@link AnnotatedSubscriberFinder}.\n", "   * @param object  object whose subscriber methods should be registered.\n", "    Multimap<Class<?>, EventSubscriber> methodsInListener =\n", "        finder.findAllSubscribers(object);\n", "    subscribersByTypeLock.writeLock().lock();\n", "      subscribersByType.putAll(methodsInListener);\n", "      subscribersByTypeLock.writeLock().unlock();\n", "   * Unregisters all subscriber methods on a registered {@code object}.\n", "   * @param object  object whose subscriber methods should be unregistered.\n", "   * @throws IllegalArgumentException if the object was not previously registered.\n", "    Multimap<Class<?>, EventSubscriber> methodsInListener = finder.findAllSubscribers(object);\n", "    for (Entry<Class<?>, Collection<EventSubscriber>> entry :\n", "          methodsInListener.asMap().entrySet()) {\n", "      Collection<EventSubscriber> eventMethodsInListener = entry.getValue();\n", "      subscribersByTypeLock.writeLock().lock();\n", "        Set<EventSubscriber> currentSubscribers = subscribersByType.get(eventType);\n", "        if (!currentSubscribers.containsAll(eventMethodsInListener)) {\n", "              \"missing event subscriber for an annotated method. Is \" + object + \" registered?\");\n", "        currentSubscribers.removeAll(eventMethodsInListener);\n", "        subscribersByTypeLock.writeLock().unlock();\n", "   * Posts an event to all registered subscribers.  This method will return\n", "   * successfully after the event has been posted to all subscribers, and\n", "   * regardless of any exceptions thrown by subscribers.\n", "   * <p>If no subscribers have been subscribed for {@code event}'s class, and\n"], "5": ["      subscribersByTypeLock.readLock().lock();\n", "        Set<EventSubscriber> wrappers = subscribersByType.get(eventType);\n", "          for (EventSubscriber wrapper : wrappers) {\n", "        subscribersByTypeLock.readLock().unlock();\n"], "6": ["  void enqueueEvent(Object event, EventSubscriber subscriber) {\n", "    eventsToDispatch.get().offer(new EventWithSubscriber(event, subscriber));\n"], "7": ["      Queue<EventWithSubscriber> events = eventsToDispatch.get();\n", "      EventWithSubscriber eventWithSubscriber;\n", "      while ((eventWithSubscriber = events.poll()) != null) {\n", "        dispatch(eventWithSubscriber.event, eventWithSubscriber.subscriber);\n"], "8": ["   * Dispatches {@code event} to the subscriber in {@code wrapper}.  This method\n", "   * @param wrapper  wrapper that will call the subscriber.\n", "  void dispatch(Object event, EventSubscriber wrapper) {\n"], "9": ["  /** simple struct representing an event and it's subscriber */\n", "  static class EventWithSubscriber {\n", "    final EventSubscriber subscriber;\n", "    public EventWithSubscriber(Object event, EventSubscriber subscriber) {\n", "      this.subscriber = checkNotNull(subscriber);\n"]}, "removed": {"1": [" * another (and thus be aware of each other). It is designed exclusively to\n"], "2": [" * <li>Expose a public method, known as the <i>event handler</i>, which accepts\n", " * a single argument of the type of event desired;</li>\n", " * </li>\n", " * <p>To post an event, simply provide the event object to the {@link\n", " * #post(Object)} method. The EventBus instance will determine the type of event\n", " * and route it to all registered listeners.\n", " * to any handler for any type to which the event is <em>assignable.</em> This\n", " * <p>When {@code post} is called, all registered handlers for an event are run\n", " * in sequence, so handlers should be reasonably quick. If an event may trigger\n", " * later. (For a convenient way to do this, use an {@link AsyncEventBus}.)\n", " * <h2>Handler Methods</h2>\n", " * <p>Event handler methods must accept only one argument: the event.\n", " * <p>The EventBus guarantees that it will not call a handler method from\n", " * bearing the {@link AllowConcurrentEvents} annotation. If this annotation is\n", " * not present, handler methods need not worry about being reentrant, unless\n", " * <p>If an event is posted, but no registered handlers can accept it, it is\n", " * considered \"dead.\" To give the system a second chance to handle dead events,\n", " * <p>If a handler for a supertype of all events (such as Object) is registered,\n", " * Accordingly, while DeadEvent extends {@link Object}, a handler registered to\n", " * <h2>Exception Handling</h2>\n", " *\n", " * <p>When a subscriber throws an exception while handling event, the {@link\n", " * SubscriberExceptionHandler} is called.\n", " *\n", " * \"http://code.google.com/p/guava-libraries/wiki/EventBusExplained\">{@code\n", " * EventBus}</a>.\n"], "3": ["   * All registered event handlers, indexed by event type.\n", "   * made after acquiring a read or write lock via {@link #handlersByTypeLock}.\n", "  private final SetMultimap<Class<?>, EventHandler> handlersByType =\n", "  private final ReadWriteLock handlersByTypeLock = new ReentrantReadWriteLock();\n", "   * Strategy for finding handler methods in registered objects.  Currently,\n", "   * only the {@link AnnotatedHandlerFinder} is supported, but this is\n", "  private final HandlerFindingStrategy finder = new AnnotatedHandlerFinder();\n", "  private final ThreadLocal<Queue<EventWithHandler>> eventsToDispatch =\n", "      new ThreadLocal<Queue<EventWithHandler>>() {\n", "    @Override protected Queue<EventWithHandler> initialValue() {\n", "      return new LinkedList<EventWithHandler>();\n"], "4": ["   * Registers all handler methods on {@code object} to receive events.\n", "   * Handler methods are selected and classified using this EventBus's\n", "   * {@link HandlerFindingStrategy}; the default strategy is the\n", "   * {@link AnnotatedHandlerFinder}.\n", "   * @param object  object whose handler methods should be registered.\n", "    Multimap<Class<?>, EventHandler> methodsInListener =\n", "        finder.findAllHandlers(object);\n", "    handlersByTypeLock.writeLock().lock();\n", "      handlersByType.putAll(methodsInListener);\n", "      handlersByTypeLock.writeLock().unlock();\n", "   * Unregisters all handler methods on a registered {@code object}.\n", "   * @param object object whose handler methods should be unregistered.\n", "   * @throws IllegalArgumentException if the object was not previously\n", "   *         registered.\n", "    Multimap<Class<?>, EventHandler> methodsInListener = finder.findAllHandlers(object);\n", "    for (Entry<Class<?>, Collection<EventHandler>> entry : methodsInListener.asMap().entrySet()) {\n", "      Collection<EventHandler> eventMethodsInListener = entry.getValue();\n", "      handlersByTypeLock.writeLock().lock();\n", "        Set<EventHandler> currentHandlers = handlersByType.get(eventType);\n", "        if (!currentHandlers.containsAll(eventMethodsInListener)) {\n", "              \"missing event handler for an annotated method. Is \" + object + \" registered?\");\n", "        currentHandlers.removeAll(eventMethodsInListener);\n", "        handlersByTypeLock.writeLock().unlock();\n", "   * Posts an event to all registered handlers.  This method will return\n", "   * successfully after the event has been posted to all handlers, and\n", "   * regardless of any exceptions thrown by handlers.\n", "   * <p>If no handlers have been subscribed for {@code event}'s class, and\n"], "5": ["      handlersByTypeLock.readLock().lock();\n", "        Set<EventHandler> wrappers = handlersByType.get(eventType);\n", "          for (EventHandler wrapper : wrappers) {\n", "        handlersByTypeLock.readLock().unlock();\n"], "6": ["  void enqueueEvent(Object event, EventHandler handler) {\n", "    eventsToDispatch.get().offer(new EventWithHandler(event, handler));\n"], "7": ["      Queue<EventWithHandler> events = eventsToDispatch.get();\n", "      EventWithHandler eventWithHandler;\n", "      while ((eventWithHandler = events.poll()) != null) {\n", "        dispatch(eventWithHandler.event, eventWithHandler.handler);\n"], "8": ["   * Dispatches {@code event} to the handler in {@code wrapper}.  This method\n", "   * @param wrapper  wrapper that will call the handler.\n", "  void dispatch(Object event, EventHandler wrapper) {\n"], "9": ["  /** simple struct representing an event and it's handler */\n", "  static class EventWithHandler {\n", "    final EventHandler handler;\n", "    public EventWithHandler(Object event, EventHandler handler) {\n", "      this.handler = checkNotNull(handler);\n"]}, "added_lines": {"1": [50], "2": [58, 59, 62, 66, 67, 68, 71, 75, 76, 78, 80, 81, 83, 84, 85, 86, 87, 88, 90, 91, 95, 96, 99, 101, 107, 108], "3": [133, 136, 138, 140, 143, 144, 147, 150, 151, 152, 153], "4": [195, 196, 197, 198, 200, 203, 204, 205, 207, 209, 214, 216, 217, 220, 221, 222, 224, 226, 228, 229, 231, 233, 235, 241, 242, 243, 245], "5": [256, 258, 262, 267], "6": [283, 284], "7": [301, 302, 303, 304], "8": [313, 318, 320], "9": [390, 391, 393, 394, 396]}, "removed_lines": {"1": [50], "2": [58, 59, 62, 66, 67, 68, 71, 75, 76, 78, 80, 81, 83, 85, 86, 90, 91, 94, 96, 99, 100, 101, 102, 103, 107, 108], "3": [133, 136, 138, 140, 143, 144, 147, 150, 151, 152, 153], "4": [195, 196, 197, 198, 200, 203, 204, 205, 207, 209, 214, 216, 217, 218, 221, 222, 224, 226, 228, 229, 231, 233, 235, 241, 242, 243, 245], "5": [256, 258, 262, 267], "6": [283, 284], "7": [301, 302, 303, 304], "8": [313, 318, 320], "9": [390, 391, 393, 394, 396]}}, {"9": "guava/src/com/google/common/eventbus/EventSubscriber.java", "added": {"1": [" * Wraps a single-argument subscriber method on a specific object.\n", " * <p>Two EventSubscribers are equivalent when they refer to the same method on the\n", " * same object (not class).   This property is used to ensure that no subscriber\n", "class EventSubscriber {\n", "  /** Object sporting the subscriber method. */\n", "  /** Subscriber method. */\n", "   * Creates a new EventSubscriber to wrap {@code method} on @{code target}.\n", "   * @param method  subscriber method.\n", "  EventSubscriber(Object target, Method method) {\n", "        \"EventSubscriber target cannot be null.\");\n", "    Preconditions.checkNotNull(method, \"EventSubscriber method cannot be null.\");\n"], "2": ["   * Invokes the wrapped subscriber method to handle {@code event}.\n"], "3": ["    if (obj instanceof EventSubscriber) {\n", "      EventSubscriber that = (EventSubscriber) obj;\n"], "4": ["  public Object getSubscriber() {\n", "  public Method getMethod() {\n"]}, "removed": {"1": [" * Wraps a single-argument 'handler' method on a specific object.\n", " * <p>Two EventHandlers are equivalent when they refer to the same method on the\n", " * same object (not class).   This property is used to ensure that no handler\n", "class EventHandler {\n", "  /** Object sporting the handler method. */\n", "  /** Handler method. */\n", "   * Creates a new EventHandler to wrap {@code method} on @{code target}.\n", "   * @param method  handler method.\n", "  EventHandler(Object target, Method method) {\n", "        \"EventHandler target cannot be null.\");\n", "    Preconditions.checkNotNull(method, \"EventHandler method cannot be null.\");\n"], "2": ["   * Invokes the wrapped handler method to handle {@code event}.\n"], "3": ["    if (obj instanceof EventHandler) {\n", "      EventHandler that = (EventHandler) obj;\n"], "4": ["  Object getSubscriber() {\n", "  Method getMethod() {\n"]}, "added_lines": {"1": [29, 34, 35, 40, 42, 44, 48, 51, 53, 55, 56], "2": [64], "3": [98, 99], "4": [108, 112]}, "removed_lines": {"1": [29, 34, 35, 40, 42, 44, 48, 51, 53, 55, 56], "2": [64], "3": [98, 99], "4": [108, 112]}}, {"10": "guava/src/com/google/common/eventbus/Subscribe.java", "added": {"1": [" * Marks a method as an event subscriber.\n", " * <p>Unless also annotated with @{@link AllowConcurrentEvents}, event subscriber\n"]}, "removed": {"1": [" * Marks a method as an event handler, as used by\n", " * {@link AnnotatedHandlerFinder} and {@link EventBus}.\n", " * <p>Unless also annotated with @{@link AllowConcurrentEvents}, event handler\n"]}, "added_lines": {"1": [27, 34]}, "removed_lines": {"1": [27, 28, 35]}}, {"11": "guava/src/com/google/common/eventbus/SubscriberFindingStrategy.java", "added": {"1": [" * A method for finding event subscriber methods in objects, for use by\n", "interface SubscriberFindingStrategy {\n", "   * Finds all suitable event subscriber methods in {@code source}, organizes them\n", "   * by the type of event they handle, and wraps them in {@link EventSubscriber} instances.\n", "   * @param source  object whose subscribers are desired.\n", "   * @return EventSubscriber objects for each subscriber method, organized by event\n", "  Multimap<Class<?>, EventSubscriber> findAllSubscribers(Object source);\n"]}, "removed": {"1": [" * A method for finding event handler methods in objects, for use by\n", "interface HandlerFindingStrategy {\n", "   * Finds all suitable event handler methods in {@code source}, organizes them\n", "   * by the type of event they handle, and wraps them in {@link EventHandler} instances.\n", "   * @param source  object whose handlers are desired.\n", "   * @return EventHandler objects for each handler method, organized by event\n", "  Multimap<Class<?>, EventHandler> findAllHandlers(Object source);\n"]}, "added_lines": {"1": [22, 27, 30, 31, 33, 34, 40]}, "removed_lines": {"1": [22, 27, 30, 31, 33, 34, 40]}}, {"12": "guava/src/com/google/common/eventbus/SynchronizedEventSubscriber.java", "added": {"1": [" * Wraps a single-argument subscriber method on a specific object, and ensures\n", " * {@link EventSubscriber}.\n", "final class SynchronizedEventSubscriber extends EventSubscriber {\n", "   * Creates a new SynchronizedEventSubscriber to wrap {@code method} on\n", "   * @param method  subscriber method.\n", "  public SynchronizedEventSubscriber(Object target, Method method) {\n"]}, "removed": {"1": [" * Wraps a single-argument 'handler' method on a specific object, and ensures\n", " * {@link EventHandler}.\n", "final class SynchronizedEventHandler extends EventHandler {\n", "   * Creates a new SynchronizedEventHandler to wrap {@code method} on\n", "   * @param method  handler method.\n", "  public SynchronizedEventHandler(Object target, Method method) {\n"]}, "added_lines": {"1": [23, 27, 31, 33, 37, 39]}, "removed_lines": {"1": [23, 27, 31, 33, 37, 39]}}, {"13": "guava/src/com/google/common/eventbus/package-info.java", "added": {"1": [" *     EventBus, so that its <em>subscriber methods</em> will receive events.</dd>\n", " *     <em>subscriber methods</em>.</dt>\n", " * <dt>Subscriber method</dt><dd>A public method that the EventBus should use to\n", " *     deliver <em>posted</em> events.  Subscriber methods are marked by the\n"], "2": [" * <h3>Why use an annotation to mark subscriber methods, rather than requiring the\n", " * so), while leaving you free to place event subscriber methods wherever you wish\n"], "3": [" * and the event subscriber has a clear and meaningful name.\n", " * <h3>What about a generic {@code Subscriber<T>} interface?</h3>\n", " * <p>Some have proposed a generic {@code Subscriber<T>} interface for EventBus\n", " *   interface Subscriber<T> {\n"], "4": [" * <p>Event subscriber methods, on the other hand, must explicitly declare their\n", " * searching for references to an event class will instantly find all subscriber\n", " * methods for that event, and renaming the type will affect all subscriber methods\n", " * <p>It's true that you can rename your {@code @Subscribed} event subscriber\n", " * rename because, to Event Bus, the names of your subscriber methods are\n", " * <h3>What happens if I {@code register} a listener without any subscriber\n"], "5": [" * hook into the system's event model simply by exposing subscriber methods.\n", " * example, defining a subscriber method for a nonexistent event type.\n", " * registered is checked for the <i>well-formedness</i> of its subscriber methods.\n"], "6": [" * <p>To handle such events, register a subscriber method for the {@code DeadEvent}\n", " * class.  Whenever EventBus receives an event with no registered subscribers, it\n", " * <h3>How do I test event listeners and their subscriber methods?</h3>\n", " * <p>Because subscriber methods on your listener classes are normal methods, you can\n"]}, "removed": {"1": [" *     EventBus, so that its <em>handler methods</em> will receive events.</dd>\n", " *     <em>handler methods</em>.</dt>\n", " * <dt>Handler method</dt><dd>A public method that the EventBus should use to\n", " *     deliver <em>posted</em> events.  Handler methods are marked by the\n"], "2": [" * <h3>Why use an annotation to mark handler methods, rather than requiring the\n", " * so), while leaving you free to place event handler methods wherever you wish\n"], "3": [" * and the event handler has a clear and meaningful name.\n", " * <h3>What about a generic {@code Handler<T>} interface?</h3>\n", " * <p>Some have proposed a generic {@code Handler<T>} interface for EventBus\n", " *   interface Handler<T> {\n"], "4": [" * <p>Event handler methods, on the other hand, must explicitly declare their\n", " * searching for references to an event class will instantly find all handler\n", " * methods for that event, and renaming the type will affect all handler methods\n", " * <p>It's true that you can rename your {@code @Subscribed} event handler\n", " * rename because, to Event Bus, the names of your handler methods are\n", " * <h3>What happens if I {@code register} a listener without any handler\n"], "5": [" * hook into the system's event model simply by exposing handler methods.\n", " * example, defining a handler method for a nonexistent event type.\n", " * registered is checked for the <i>well-formedness</i> of its handler methods.\n"], "6": [" * <p>To handle such events, register a handler method for the {@code DeadEvent}\n", " * class.  Whenever EventBus receives an event with no registered handlers, it\n", " * <h3>How do I test event listeners and their handler methods?</h3>\n", " * <p>Because handler methods on your listener classes are normal methods, you can\n"]}, "added_lines": {"1": [100, 102, 103, 104], "2": [126, 130], "3": [169, 171, 172, 177], "4": [196, 198, 199, 202, 204, 208], "5": [218, 222, 226], "6": [245, 246, 250, 251]}, "removed_lines": {"1": [100, 102, 103, 104], "2": [126, 130], "3": [169, 171, 172, 177], "4": [196, 198, 199, 202, 204, 208], "5": [218, 222, 226], "6": [245, 246, 250, 251]}}]}
