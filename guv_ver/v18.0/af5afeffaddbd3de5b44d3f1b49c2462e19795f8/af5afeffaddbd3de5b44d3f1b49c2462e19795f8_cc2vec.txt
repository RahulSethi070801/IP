{"id": "af5afeffaddbd3de5b44d3f1b49c2462e19795f8", "code": [{"0": "guava-gwt/src-super/com/google/common/primitives/super/com/google/common/primitives/Ints.java", "added": {"1": ["import java.util.Arrays;\n"], "2": ["  \n", "  private static final byte[] asciiDigits = new byte[128];\n", "  \n", "  static {\n", "    Arrays.fill(asciiDigits, (byte) -1);\n", "    for (int i = 0; i <= 9; i++) {\n", "      asciiDigits['0' + i] = (byte) i;\n", "    }\n", "    for (int i = 0; i <= 26; i++) {\n", "      asciiDigits['A' + i] = (byte) (10 + i);\n", "      asciiDigits['a' + i] = (byte) (10 + i);\n", "    }\n", "  }\n", "  \n", "  private static int digit(char c) {\n", "    return (c < 128) ? asciiDigits[c] : -1;\n", "  }\n"]}, "removed": {}, "added_lines": {"1": [30], "2": [585, 586, 587, 588, 589, 590, 591, 592, 593, 594, 595, 596, 597, 598, 599, 600, 601]}, "removed_lines": {}}, {"1": "guava-tests/test/com/google/common/primitives/IntsTest.java", "added": {"1": ["    assertNull(Ints.tryParse(\"\\u0662\\u06f3\"));\n"]}, "removed": {}, "added_lines": {"1": [484]}, "removed_lines": {}}, {"2": "guava-tests/test/com/google/common/primitives/LongsTest.java", "added": {"1": ["    assertNull(Longs.tryParse(\"\\u0662\\u06f3\"));\n"]}, "removed": {}, "added_lines": {"1": [467]}, "removed_lines": {}}, {"3": "guava/src/com/google/common/primitives/Ints.java", "added": {"1": ["  private static final byte[] asciiDigits = new byte[128];\n", "\n", "  static {\n", "    Arrays.fill(asciiDigits, (byte) -1);\n", "    for (int i = 0; i <= 9; i++) {\n", "      asciiDigits['0' + i] = (byte) i;\n", "    }\n", "    for (int i = 0; i <= 26; i++) {\n", "      asciiDigits['A' + i] = (byte) (10 + i);\n", "      asciiDigits['a' + i] = (byte) (10 + i);\n", "    }\n", "  }\n", "\n", "  private static int digit(char c) {\n", "    return (c < 128) ? asciiDigits[c] : -1;\n", "  }\n", "\n"], "2": ["   * Additionally, this method only accepts ASCII digits, and returns\n", "   * {@code null} if non-ASCII digits are present in the string.\n"], "3": ["    return tryParse(string, 10);\n", "  }\n", "\n", "  /**\n", "   * Parses the specified string as a signed integer value using the specified\n", "   * radix. The ASCII character {@code '-'} (<code>'&#92;u002D'</code>) is\n", "   * recognized as the minus sign.\n", "   *\n", "   * <p>Unlike {@link Integer#parseInt(String, int)}, this method returns\n", "   * {@code null} instead of throwing an exception if parsing fails.\n", "   * Additionally, this method only accepts ASCII digits, and returns\n", "   * {@code null} if non-ASCII digits are present in the string.\n", "   *\n", "   * <p>Note that strings prefixed with ASCII {@code '+'} are rejected, even\n", "   * under JDK 7, despite the change to {@link Integer#parseInt(String, int)}\n", "   * for that version.\n", "   *\n", "   * @param string the string representation of an integer value\n", "   * @param radix the radix to use when parsing\n", "   * @return the integer value represented by {@code string} using\n", "   *     {@code radix}, or {@code null} if {@code string} has a length of zero\n", "   *     or cannot be parsed as an integer value\n", "   * @throws IllegalArgumentException if {@code radix < Character.MIN_RADIX} or\n", "   *     {@code radix > Character.MAX_RADIX}\n", "   */\n", "  @CheckForNull\n", "  @GwtIncompatible(\"TODO\") static Integer tryParse(\n", "      String string, int radix) {\n", "    if (checkNotNull(string).isEmpty()) {\n", "      return null;\n", "    }\n", "    if (radix < Character.MIN_RADIX || radix > Character.MAX_RADIX) {\n", "      throw new IllegalArgumentException(\n", "          \"radix must be between MIN_RADIX and MAX_RADIX but was \" + radix);\n", "    }\n", "    boolean negative = string.charAt(0) == '-';\n", "    int index = negative ? 1 : 0;\n", "    if (index == string.length()) {\n", "      return null;\n", "    }\n", "    int digit = digit(string.charAt(index++));\n", "    if (digit < 0 || digit >= radix) {\n", "      return null;\n", "    }\n", "    int accum = -digit;\n", "\n", "    int cap = Integer.MIN_VALUE / radix;\n", "\n", "    while (index < string.length()) {\n", "      digit = digit(string.charAt(index++));\n", "      if (digit < 0 || digit >= radix || accum < cap) {\n", "        return null;\n", "      }\n", "      accum *= radix;\n", "      if (accum < Integer.MIN_VALUE + digit) {\n", "        return null;\n", "      }\n", "      accum -= digit;\n", "    }\n", "\n", "    if (negative) {\n", "      return accum;\n", "    } else if (accum == Integer.MIN_VALUE) {\n", "      return null;\n", "    } else {\n", "      return -accum;\n", "    }\n"]}, "removed": {"3": ["    return AndroidInteger.tryParse(string, 10);\n"]}, "added_lines": {"1": [640, 641, 642, 643, 644, 645, 646, 647, 648, 649, 650, 651, 652, 653, 654, 655, 656], "2": [664, 665], "3": [681, 682, 683, 684, 685, 686, 687, 688, 689, 690, 691, 692, 693, 694, 695, 696, 697, 698, 699, 700, 701, 702, 703, 704, 705, 706, 707, 708, 709, 710, 711, 712, 713, 714, 715, 716, 717, 718, 719, 720, 721, 722, 723, 724, 725, 726, 727, 728, 729, 730, 731, 732, 733, 734, 735, 736, 737, 738, 739, 740, 741, 742, 743, 744, 745, 746, 747]}, "removed_lines": {"3": [662]}}, {"4": "guava/src/com/google/common/primitives/Longs.java", "added": {"1": ["   * Additionally, this method only accepts ASCII digits, and returns\n", "   * {@code null} if non-ASCII digits are present in the string.\n"]}, "removed": {}, "added_lines": {"1": [323, 324]}, "removed_lines": {}}]}
