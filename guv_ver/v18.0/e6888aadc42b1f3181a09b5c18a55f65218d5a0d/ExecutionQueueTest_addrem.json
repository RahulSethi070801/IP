{
    "addition": {},
    "removed": {
        "1": "/*\n",
        "2": " * Copyright (C) 2013 The Guava Authors\n",
        "3": " *\n",
        "4": " * Licensed under the Apache License, Version 2.0 (the \"License\");\n",
        "5": " * you may not use this file except in compliance with the License.\n",
        "6": " * You may obtain a copy of the License at\n",
        "7": " *\n",
        "8": " * http://www.apache.org/licenses/LICENSE-2.0\n",
        "9": " *\n",
        "10": " * Unless required by applicable law or agreed to in writing, software\n",
        "11": " * distributed under the License is distributed on an \"AS IS\" BASIS,\n",
        "12": " * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n",
        "13": " * See the License for the specific language governing permissions and\n",
        "14": " * limitations under the License.\n",
        "15": " */\n",
        "16": "package com.google.common.util.concurrent;\n",
        "17": "\n",
        "18": "import junit.framework.TestCase;\n",
        "19": "\n",
        "20": "import java.util.concurrent.CountDownLatch;\n",
        "21": "import java.util.concurrent.CyclicBarrier;\n",
        "22": "import java.util.concurrent.Executor;\n",
        "23": "import java.util.concurrent.ExecutorService;\n",
        "24": "import java.util.concurrent.Executors;\n",
        "25": "import java.util.concurrent.LinkedBlockingQueue;\n",
        "26": "import java.util.concurrent.ThreadPoolExecutor;\n",
        "27": "import java.util.concurrent.TimeUnit;\n",
        "28": "import java.util.concurrent.atomic.AtomicInteger;\n",
        "29": "\n",
        "30": "/**\n",
        "31": " * Tests for {@link ExecutionQueue}.\n",
        "32": " *\n",
        "33": " * @author Luke Sandberg\n",
        "34": " */\n",
        "35": "public class ExecutionQueueTest extends TestCase {\n",
        "36": "  private final ExecutionQueue queue = new ExecutionQueue();\n",
        "37": "\n",
        "38": "  public void testAddAndExecuteMultipleRounds() throws InterruptedException {\n",
        "39": "    Executor executor = MoreExecutors.sameThreadExecutor();\n",
        "40": "    addAndExecuteMultipleTimes(executor);\n",
        "41": "  }\n",
        "42": "\n",
        "43": "  public void testAddAndExecuteMultipleRounds_multipleThreads() throws InterruptedException {\n",
        "44": "    ExecutorService executor = Executors.newCachedThreadPool();\n",
        "45": "    try {\n",
        "46": "      addAndExecuteMultipleTimes(executor);\n",
        "47": "    } finally {\n",
        "48": "      executor.shutdown();\n",
        "49": "    }\n",
        "50": "  }\n",
        "51": "\n",
        "52": "  /**\n",
        "53": "   * Test that tasks are submitted to the executor in the correct order even when there are many\n",
        "54": "   * concurrent calls to execute and add.\n",
        "55": "   */\n",
        "56": "\n",
        "57": "  public void testAddAndConcurrentExecute() throws InterruptedException {\n",
        "58": "    final int numThreads = 20;\n",
        "59": "    final ExecutorService executor = Executors.newFixedThreadPool(numThreads);\n",
        "60": "    final CountDownLatch latch = new CountDownLatch(numThreads);\n",
        "61": "    // make sure all the threads are started\n",
        "62": "    for (int i = 0; i < numThreads; i++) {\n",
        "63": "      executor.execute(new Runnable() {\n",
        "64": "        @Override public void run() {\n",
        "65": "          latch.countDown();\n",
        "66": "        }\n",
        "67": "      });\n",
        "68": "    }\n",
        "69": "    latch.await();\n",
        "70": "    final AtomicInteger integer = new AtomicInteger();\n",
        "71": "    final int numTasks = 10000;\n",
        "72": "    final CountDownLatch taskLatch = new CountDownLatch(numTasks);\n",
        "73": "    final CyclicBarrier startBarrier = new CyclicBarrier(numThreads);\n",
        "74": "    executor.execute(new Runnable() {\n",
        "75": "      @Override public void run() {\n",
        "76": "        // We are only interested in testing the order in which things are added to the executor,\n",
        "77": "        // but by using a single threaded executor we know that the runnables are executed in the\n",
        "78": "        // same order that they are added to the queue managed by this executor.\n",
        "79": "        final ExecutorService callbackExecutor = singleThreadedExecutorService();\n",
        "80": "        // We want to delay starting until all the threads calling execute have started.\n",
        "81": "        try {\n",
        "82": "          startBarrier.await();\n",
        "83": "        } catch (Exception e) {\n",
        "84": "          throw new RuntimeException(e);\n",
        "85": "        }\n",
        "86": "        for (int i = 0; i < numTasks; i++) {\n",
        "87": "          final int expectedCount = i;\n",
        "88": "          queue.add(new Runnable() {\n",
        "89": "            @Override public void run() {\n",
        "90": "              integer.compareAndSet(expectedCount, expectedCount + 1);\n",
        "91": "              taskLatch.countDown();\n",
        "92": "              if (taskLatch.getCount() == 0) {\n",
        "93": "                callbackExecutor.shutdown();\n",
        "94": "              }\n",
        "95": "            }\n",
        "96": "          }, callbackExecutor);\n",
        "97": "        }\n",
        "98": "      }\n",
        "99": "\n",
        "100": "    });\n",
        "101": "    for (int i = 0; i < numThreads - 1; i++) {\n",
        "102": "      executor.execute(new Runnable() {\n",
        "103": "        @Override public void run() {\n",
        "104": "          // We want to delay starting until all the threads calling execute have started.\n",
        "105": "          try {\n",
        "106": "            startBarrier.await();\n",
        "107": "          } catch (Exception e) {\n",
        "108": "            throw new RuntimeException(e);\n",
        "109": "          }\n",
        "110": "          while (taskLatch.getCount() > 0) {\n",
        "111": "            queue.execute();\n",
        "112": "          }\n",
        "113": "        }});\n",
        "114": "    }\n",
        "115": "    taskLatch.await();  // wait for them all to finish\n",
        "116": "    assertEquals(numTasks, integer.get());\n",
        "117": "    executor.shutdown();\n",
        "118": "  }\n",
        "119": "\n",
        "120": "  private ExecutorService singleThreadedExecutorService() {\n",
        "121": "    final ExecutorService callbackExecutor = new ThreadPoolExecutor(1, 1,\n",
        "122": "        0L, TimeUnit.MILLISECONDS,\n",
        "123": "        new LinkedBlockingQueue<Runnable>()) {\n",
        "124": "      @Override public void execute(Runnable command) {\n",
        "125": "        // Yields to try to force more thread interleavings\n",
        "126": "        Thread.yield();\n",
        "127": "        super.execute(command);\n",
        "128": "        Thread.yield();\n",
        "129": "      }\n",
        "130": "    };\n",
        "131": "    return callbackExecutor;\n",
        "132": "  }\n",
        "133": "\n",
        "134": "  private void addAndExecuteMultipleTimes(Executor executor) throws InterruptedException {\n",
        "135": "    for (int i = 0; i < 10; i++) {\n",
        "136": "      CountDownLatch countDownLatch = new CountDownLatch(3);\n",
        "137": "      queue.add(new CountDownRunnable(countDownLatch), executor);\n",
        "138": "      queue.add(new CountDownRunnable(countDownLatch), executor);\n",
        "139": "      queue.add(new CountDownRunnable(countDownLatch), executor);\n",
        "140": "      assertEquals(countDownLatch.getCount(), 3L);\n",
        "141": "      queue.execute();\n",
        "142": "      assertTrue(countDownLatch.await(1, TimeUnit.SECONDS));\n",
        "143": "    }\n",
        "144": "  }\n",
        "145": "\n",
        "146": "  private class CountDownRunnable implements Runnable {\n",
        "147": "    final CountDownLatch countDownLatch;\n",
        "148": "\n",
        "149": "    CountDownRunnable(CountDownLatch countDownLatch) {\n",
        "150": "      this.countDownLatch = countDownLatch;\n",
        "151": "    }\n",
        "152": "\n",
        "153": "    @Override public void run() {\n",
        "154": "      countDownLatch.countDown();\n",
        "155": "    }\n",
        "156": "  }\n",
        "157": "}\n"
    }
}