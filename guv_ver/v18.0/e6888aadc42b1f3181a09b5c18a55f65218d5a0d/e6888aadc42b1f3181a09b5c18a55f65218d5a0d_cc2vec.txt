{"id": "e6888aadc42b1f3181a09b5c18a55f65218d5a0d", "code": [{"0": "guava-tests/test/com/google/common/util/concurrent/ExecutionQueueTest.java", "added": {}, "removed": {"1": ["/*\n", " * Copyright (C) 2013 The Guava Authors\n", " *\n", " * Licensed under the Apache License, Version 2.0 (the \"License\");\n", " * you may not use this file except in compliance with the License.\n", " * You may obtain a copy of the License at\n", " *\n", " * http://www.apache.org/licenses/LICENSE-2.0\n", " *\n", " * Unless required by applicable law or agreed to in writing, software\n", " * distributed under the License is distributed on an \"AS IS\" BASIS,\n", " * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n", " * See the License for the specific language governing permissions and\n", " * limitations under the License.\n", " */\n", "package com.google.common.util.concurrent;\n", "\n", "import junit.framework.TestCase;\n", "\n", "import java.util.concurrent.CountDownLatch;\n", "import java.util.concurrent.CyclicBarrier;\n", "import java.util.concurrent.Executor;\n", "import java.util.concurrent.ExecutorService;\n", "import java.util.concurrent.Executors;\n", "import java.util.concurrent.LinkedBlockingQueue;\n", "import java.util.concurrent.ThreadPoolExecutor;\n", "import java.util.concurrent.TimeUnit;\n", "import java.util.concurrent.atomic.AtomicInteger;\n", "\n", "/**\n", " * Tests for {@link ExecutionQueue}.\n", " *\n", " * @author Luke Sandberg\n", " */\n", "public class ExecutionQueueTest extends TestCase {\n", "  private final ExecutionQueue queue = new ExecutionQueue();\n", "\n", "  public void testAddAndExecuteMultipleRounds() throws InterruptedException {\n", "    Executor executor = MoreExecutors.sameThreadExecutor();\n", "    addAndExecuteMultipleTimes(executor);\n", "  }\n", "\n", "  public void testAddAndExecuteMultipleRounds_multipleThreads() throws InterruptedException {\n", "    ExecutorService executor = Executors.newCachedThreadPool();\n", "    try {\n", "      addAndExecuteMultipleTimes(executor);\n", "    } finally {\n", "      executor.shutdown();\n", "    }\n", "  }\n", "\n", "  /**\n", "   * Test that tasks are submitted to the executor in the correct order even when there are many\n", "   * concurrent calls to execute and add.\n", "   */\n", "\n", "  public void testAddAndConcurrentExecute() throws InterruptedException {\n", "    final int numThreads = 20;\n", "    final ExecutorService executor = Executors.newFixedThreadPool(numThreads);\n", "    final CountDownLatch latch = new CountDownLatch(numThreads);\n", "    // make sure all the threads are started\n", "    for (int i = 0; i < numThreads; i++) {\n", "      executor.execute(new Runnable() {\n", "        @Override public void run() {\n", "          latch.countDown();\n", "        }\n", "      });\n", "    }\n", "    latch.await();\n", "    final AtomicInteger integer = new AtomicInteger();\n", "    final int numTasks = 10000;\n", "    final CountDownLatch taskLatch = new CountDownLatch(numTasks);\n", "    final CyclicBarrier startBarrier = new CyclicBarrier(numThreads);\n", "    executor.execute(new Runnable() {\n", "      @Override public void run() {\n", "        // We are only interested in testing the order in which things are added to the executor,\n", "        // but by using a single threaded executor we know that the runnables are executed in the\n", "        // same order that they are added to the queue managed by this executor.\n", "        final ExecutorService callbackExecutor = singleThreadedExecutorService();\n", "        // We want to delay starting until all the threads calling execute have started.\n", "        try {\n", "          startBarrier.await();\n", "        } catch (Exception e) {\n", "          throw new RuntimeException(e);\n", "        }\n", "        for (int i = 0; i < numTasks; i++) {\n", "          final int expectedCount = i;\n", "          queue.add(new Runnable() {\n", "            @Override public void run() {\n", "              integer.compareAndSet(expectedCount, expectedCount + 1);\n", "              taskLatch.countDown();\n", "              if (taskLatch.getCount() == 0) {\n", "                callbackExecutor.shutdown();\n", "              }\n", "            }\n", "          }, callbackExecutor);\n", "        }\n", "      }\n", "\n", "    });\n", "    for (int i = 0; i < numThreads - 1; i++) {\n", "      executor.execute(new Runnable() {\n", "        @Override public void run() {\n", "          // We want to delay starting until all the threads calling execute have started.\n", "          try {\n", "            startBarrier.await();\n", "          } catch (Exception e) {\n", "            throw new RuntimeException(e);\n", "          }\n", "          while (taskLatch.getCount() > 0) {\n", "            queue.execute();\n", "          }\n", "        }});\n", "    }\n", "    taskLatch.await();  // wait for them all to finish\n", "    assertEquals(numTasks, integer.get());\n", "    executor.shutdown();\n", "  }\n", "\n", "  private ExecutorService singleThreadedExecutorService() {\n", "    final ExecutorService callbackExecutor = new ThreadPoolExecutor(1, 1,\n", "        0L, TimeUnit.MILLISECONDS,\n", "        new LinkedBlockingQueue<Runnable>()) {\n", "      @Override public void execute(Runnable command) {\n", "        // Yields to try to force more thread interleavings\n", "        Thread.yield();\n", "        super.execute(command);\n", "        Thread.yield();\n", "      }\n", "    };\n", "    return callbackExecutor;\n", "  }\n", "\n", "  private void addAndExecuteMultipleTimes(Executor executor) throws InterruptedException {\n", "    for (int i = 0; i < 10; i++) {\n", "      CountDownLatch countDownLatch = new CountDownLatch(3);\n", "      queue.add(new CountDownRunnable(countDownLatch), executor);\n", "      queue.add(new CountDownRunnable(countDownLatch), executor);\n", "      queue.add(new CountDownRunnable(countDownLatch), executor);\n", "      assertEquals(countDownLatch.getCount(), 3L);\n", "      queue.execute();\n", "      assertTrue(countDownLatch.await(1, TimeUnit.SECONDS));\n", "    }\n", "  }\n", "\n", "  private class CountDownRunnable implements Runnable {\n", "    final CountDownLatch countDownLatch;\n", "\n", "    CountDownRunnable(CountDownLatch countDownLatch) {\n", "      this.countDownLatch = countDownLatch;\n", "    }\n", "\n", "    @Override public void run() {\n", "      countDownLatch.countDown();\n", "    }\n", "  }\n", "}\n"]}, "added_lines": {}, "removed_lines": {"1": [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 58, 59, 60, 61, 62, 63, 64, 65, 66, 67, 68, 69, 70, 71, 72, 73, 74, 75, 76, 77, 78, 79, 80, 81, 82, 83, 84, 85, 86, 87, 88, 89, 90, 91, 92, 93, 94, 95, 96, 97, 98, 99, 100, 101, 102, 103, 104, 105, 106, 107, 108, 109, 110, 111, 112, 113, 114, 115, 116, 117, 118, 119, 120, 121, 122, 123, 124, 125, 126, 127, 128, 129, 130, 131, 132, 133, 134, 135, 136, 137, 138, 139, 140, 141, 142, 143, 144, 145, 146, 147, 148, 149, 150, 151, 152, 153, 154, 155, 156, 157]}}, {"1": "guava-tests/test/com/google/common/util/concurrent/ListenerCallQueueTest.java", "added": {"1": ["/*\n", " * Copyright (C) 2014 The Guava Authors\n", " *\n", " * Licensed under the Apache License, Version 2.0 (the \"License\");\n", " * you may not use this file except in compliance with the License.\n", " * You may obtain a copy of the License at\n", " *\n", " * http://www.apache.org/licenses/LICENSE-2.0\n", " *\n", " * Unless required by applicable law or agreed to in writing, software\n", " * distributed under the License is distributed on an \"AS IS\" BASIS,\n", " * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n", " * See the License for the specific language governing permissions and\n", " * limitations under the License.\n", " */\n", "\n", "package com.google.common.util.concurrent;\n", "\n", "import com.google.common.util.concurrent.ListenerCallQueue.Callback;\n", "\n", "import junit.framework.TestCase;\n", "\n", "import java.util.concurrent.CountDownLatch;\n", "import java.util.concurrent.ExecutorService;\n", "import java.util.concurrent.Executors;\n", "import java.util.concurrent.atomic.AtomicInteger;\n", "\n", "/**\n", " * Tests for {@link ListenerCallQueue}.\n", " */\n", "public class ListenerCallQueueTest extends TestCase {\n", "\n", "  private static final Callback<Object> THROWING_CALLBACK = new Callback<Object>(\"throwing()\") {\n", "    @Override public void call(Object object) {\n", "      throw new RuntimeException();\n", "    }\n", "  };\n", "\n", "  public void testAddAndExecute() {\n", "    Object listenerInstance = new Object();\n", "    ListenerCallQueue<Object> queue =\n", "        new ListenerCallQueue<Object>(listenerInstance, MoreExecutors.sameThreadExecutor());\n", "\n", "    AtomicInteger counter = new AtomicInteger();\n", "    queue.add(incrementingCallback(counter, 1));\n", "    queue.add(incrementingCallback(counter, 2));\n", "    queue.add(incrementingCallback(counter, 3));\n", "    queue.add(incrementingCallback(counter, 4));\n", "    assertEquals(0, counter.get());\n", "    queue.execute();\n", "    assertEquals(4, counter.get());\n", "  }\n", "\n", "  public void testAddAndExecute_withExceptions() {\n", "    Object listenerInstance = new Object();\n", "    ListenerCallQueue<Object> queue =\n", "        new ListenerCallQueue<Object>(listenerInstance, MoreExecutors.sameThreadExecutor());\n", "\n", "    AtomicInteger counter = new AtomicInteger();\n", "    queue.add(incrementingCallback(counter, 1));\n", "    queue.add(THROWING_CALLBACK);\n", "    queue.add(incrementingCallback(counter, 2));\n", "    queue.add(THROWING_CALLBACK);\n", "    queue.add(incrementingCallback(counter, 3));\n", "    queue.add(THROWING_CALLBACK);\n", "    queue.add(incrementingCallback(counter, 4));\n", "    queue.add(THROWING_CALLBACK);\n", "    assertEquals(0, counter.get());\n", "    queue.execute();\n", "    assertEquals(4, counter.get());\n", "  }\n", "\n", "  public void testAddAndExecute_multithreaded() throws InterruptedException {\n", "    ExecutorService service = Executors.newFixedThreadPool(4);\n", "    try {\n", "      ListenerCallQueue<Object> queue =\n", "          new ListenerCallQueue<Object>(new Object(), service);\n", "\n", "      final CountDownLatch latch = new CountDownLatch(1);\n", "      AtomicInteger counter = new AtomicInteger();\n", "      queue.add(incrementingCallback(counter, 1));\n", "      queue.add(incrementingCallback(counter, 2));\n", "      queue.add(incrementingCallback(counter, 3));\n", "      queue.add(incrementingCallback(counter, 4));\n", "      queue.add(countDownCallback(latch));\n", "      assertEquals(0, counter.get());\n", "      queue.execute();\n", "      latch.await();\n", "      assertEquals(4, counter.get());\n", "    } finally {\n", "      service.shutdown();\n", "    }\n", "  }\n", "\n", "  public void testAddAndExecute_multithreaded_withThrowingRunnable() throws InterruptedException {\n", "    ExecutorService service = Executors.newFixedThreadPool(4);\n", "    try {\n", "      ListenerCallQueue<Object> queue =\n", "          new ListenerCallQueue<Object>(new Object(), service);\n", "\n", "      final CountDownLatch latch = new CountDownLatch(1);\n", "      AtomicInteger counter = new AtomicInteger();\n", "      queue.add(incrementingCallback(counter, 1));\n", "      queue.add(THROWING_CALLBACK);\n", "      queue.add(incrementingCallback(counter, 2));\n", "      queue.add(THROWING_CALLBACK);\n", "      queue.add(incrementingCallback(counter, 3));\n", "      queue.add(THROWING_CALLBACK);\n", "      queue.add(incrementingCallback(counter, 4));\n", "      queue.add(THROWING_CALLBACK);\n", "      queue.add(countDownCallback(latch));\n", "      assertEquals(0, counter.get());\n", "      queue.execute();\n", "      latch.await();\n", "      assertEquals(4, counter.get());\n", "    } finally {\n", "      service.shutdown();\n", "    }\n", "  }\n", "\n", "  private Callback<Object> incrementingCallback(final AtomicInteger counter, final int expected) {\n", "    return new Callback<Object>(\"incrementing\") {\n", "      @Override void call(Object listener) {\n", "        assertEquals(expected, counter.incrementAndGet());\n", "      }\n", "    };\n", "  }\n", "\n", "  private Callback<Object> countDownCallback(final CountDownLatch latch) {\n", "    return new Callback<Object>(\"countDown\") {\n", "      @Override void call(Object listener) {\n", "        latch.countDown();\n", "      }\n", "    };\n", "  }\n", "}\n"]}, "removed": {}, "added_lines": {"1": [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 58, 59, 60, 61, 62, 63, 64, 65, 66, 67, 68, 69, 70, 71, 72, 73, 74, 75, 76, 77, 78, 79, 80, 81, 82, 83, 84, 85, 86, 87, 88, 89, 90, 91, 92, 93, 94, 95, 96, 97, 98, 99, 100, 101, 102, 103, 104, 105, 106, 107, 108, 109, 110, 111, 112, 113, 114, 115, 116, 117, 118, 119, 120, 121, 122, 123, 124, 125, 126, 127, 128, 129, 130, 131, 132, 133, 134, 135, 136]}, "removed_lines": {}}, {"2": "guava/src/com/google/common/util/concurrent/AbstractService.java", "added": {"1": ["import com.google.common.util.concurrent.ListenerCallQueue.Callback;\n", "import java.util.ArrayList;\n", "import java.util.Collections;\n"], "2": ["  private static final Callback<Listener> STARTING_CALLBACK =\n", "      new Callback<Listener>(\"starting()\") {\n", "        @Override void call(Listener listener) {\n", "          listener.starting();\n", "        }\n", "      };\n", "  private static final Callback<Listener> RUNNING_CALLBACK =\n", "      new Callback<Listener>(\"running()\") {\n", "        @Override void call(Listener listener) {\n", "          listener.running();\n", "        }\n", "      };\n", "  private static final Callback<Listener> STOPPING_FROM_STARTING_CALLBACK =\n", "      stoppingCallback(STARTING);\n", "  private static final Callback<Listener> STOPPING_FROM_RUNNING_CALLBACK =\n", "      stoppingCallback(RUNNING);\n", "\n", "  private static final Callback<Listener> TERMINATED_FROM_NEW_CALLBACK =\n", "      terminatedCallback(NEW);\n", "  private static final Callback<Listener> TERMINATED_FROM_RUNNING_CALLBACK =\n", "      terminatedCallback(RUNNING);\n", "  private static final Callback<Listener> TERMINATED_FROM_STOPPING_CALLBACK =\n", "      terminatedCallback(STOPPING);\n", "\n", "  private static Callback<Listener> terminatedCallback(final State from) {\n", "    return new Callback<Listener>(\"terminated({from = \" + from + \"})\") {\n", "      @Override void call(Listener listener) {\n", "        listener.terminated(from);\n", "      }\n", "    };\n", "  }\n", "\n", "  private static Callback<Listener> stoppingCallback(final State from) {\n", "    return new Callback<Listener>(\"stopping({from = \" + from + \"})\") {\n", "      @Override void call(Listener listener) {\n", "        listener.stopping(from);\n", "      }\n", "    };\n", "  }\n", "\n"], "3": ["  private final List<ListenerCallQueue<Listener>> listeners =\n", "      Collections.synchronizedList(new ArrayList<ListenerCallQueue<Listener>>());\n"], "4": ["      if (!state().isTerminal()) {\n", "        listeners.add(new ListenerCallQueue<Listener>(listener, executor));\n"], "5": ["   * Attempts to execute all the listeners in {@link #listeners} while not holding the\n", "      // iterate by index to avoid concurrent modification exceptions\n", "      for (int i = 0; i < listeners.size(); i++) {\n", "        listeners.get(i).execute();\n", "      }\n", "    STARTING_CALLBACK.enqueueOn(listeners);\n", "    RUNNING_CALLBACK.enqueueOn(listeners);\n", "    if (from == State.STARTING) {\n", "      STOPPING_FROM_STARTING_CALLBACK.enqueueOn(listeners);\n", "    } else if (from == State.RUNNING) {\n", "      STOPPING_FROM_RUNNING_CALLBACK.enqueueOn(listeners);\n", "    } else {\n", "      throw new AssertionError();\n", "    switch(from) {\n", "      case NEW:\n", "        TERMINATED_FROM_NEW_CALLBACK.enqueueOn(listeners);\n", "        break;\n", "      case RUNNING:\n", "        TERMINATED_FROM_RUNNING_CALLBACK.enqueueOn(listeners);\n", "        break;\n", "      case STOPPING:\n", "        TERMINATED_FROM_STOPPING_CALLBACK.enqueueOn(listeners);\n", "        break;\n", "      case STARTING:\n", "      case TERMINATED:\n", "      case FAILED:\n", "      default:\n", "        throw new AssertionError();\n", "    // can't memoize this one due to the exception\n", "    new Callback<Listener>(\"failed({from = \" + from + \", cause = \" + cause + \"})\") {\n", "      @Override void call(Listener listener) {\n", "        listener.failed(from, cause);\n", "      }\n", "    }.enqueueOn(listeners);\n"]}, "removed": {"1": ["import com.google.common.collect.Lists;\n"], "3": ["  private final List<ListenerExecutorPair> listeners = Lists.newArrayList();\n", "\n", "  /**\n", "   * The queue of listeners that are waiting to be executed.\n", "   *\n", "   * <p>Enqueue operations should be protected by {@link #monitor} while calling\n", "   * {@link ExecutionQueue#execute()} should not be protected.\n", "   */\n", "  private final ExecutionQueue queuedListeners = new ExecutionQueue();\n"], "4": ["      State currentState = state();\n", "      if (currentState != TERMINATED && currentState != FAILED) {\n", "        listeners.add(new ListenerExecutorPair(listener, executor));\n"], "5": ["   * Attempts to execute all the listeners in {@link #queuedListeners} while not holding the\n", "      queuedListeners.execute();\n", "    for (final ListenerExecutorPair pair : listeners) {\n", "      queuedListeners.add(new Runnable() {\n", "        @Override public void run() {\n", "          pair.listener.starting();\n", "        }\n", "      }, pair.executor);\n", "    }\n", "    for (final ListenerExecutorPair pair : listeners) {\n", "      queuedListeners.add(new Runnable() {\n", "        @Override public void run() {\n", "          pair.listener.running();\n", "        }\n", "      }, pair.executor);\n", "    }\n", "    for (final ListenerExecutorPair pair : listeners) {\n", "      queuedListeners.add(new Runnable() {\n", "        @Override public void run() {\n", "          pair.listener.stopping(from);\n", "        }\n", "      }, pair.executor);\n", "    for (final ListenerExecutorPair pair : listeners) {\n", "      queuedListeners.add(new Runnable() {\n", "        @Override public void run() {\n", "          pair.listener.terminated(from);\n", "        }\n", "      }, pair.executor);\n", "    // There are no more state transitions so we can clear this out.\n", "    listeners.clear();\n", "    for (final ListenerExecutorPair pair : listeners) {\n", "      queuedListeners.add(new Runnable() {\n", "        @Override public void run() {\n", "          pair.listener.failed(from, cause);\n", "        }\n", "      }, pair.executor);\n", "    }\n", "    // There are no more state transitions so we can clear this out.\n", "    listeners.clear();\n", "  }\n", "\n", "  /** A simple holder for a listener and its executor. */\n", "  private static class ListenerExecutorPair {\n", "    final Listener listener;\n", "    final Executor executor;\n", "\n", "    ListenerExecutorPair(Listener listener, Executor executor) {\n", "      this.listener = listener;\n", "      this.executor = executor;\n", "    }\n"]}, "added_lines": {"1": [30, 34, 35], "2": [57, 58, 59, 60, 61, 62, 63, 64, 65, 66, 67, 68, 69, 70, 71, 72, 73, 74, 75, 76, 77, 78, 79, 80, 81, 82, 83, 84, 85, 86, 87, 88, 89, 90, 91, 92, 93, 94, 95, 96], "3": [127, 128], "4": [413, 414], "5": [426, 431, 432, 433, 434, 440, 445, 450, 451, 452, 453, 454, 455, 461, 462, 463, 464, 465, 466, 467, 468, 469, 470, 471, 472, 473, 474, 475, 481, 482, 483, 484, 485, 486]}, "removed_lines": {"1": [30], "3": [84, 85, 86, 87, 88, 89, 90, 91, 92], "4": [377, 378, 379], "5": [391, 396, 402, 403, 404, 405, 406, 407, 408, 413, 414, 415, 416, 417, 418, 419, 424, 425, 426, 427, 428, 429, 435, 436, 437, 438, 439, 440, 442, 443, 448, 449, 450, 451, 452, 453, 454, 455, 456, 457, 458, 459, 460, 461, 462, 463, 464, 465, 466, 467]}}, {"3": "guava/src/com/google/common/util/concurrent/ExecutionQueue.java", "added": {}, "removed": {"1": ["/*\n", " * Copyright (C) 2013 The Guava Authors\n", " *\n", " * Licensed under the Apache License, Version 2.0 (the \"License\");\n", " * you may not use this file except in compliance with the License.\n", " * You may obtain a copy of the License at\n", " *\n", " * http://www.apache.org/licenses/LICENSE-2.0\n", " *\n", " * Unless required by applicable law or agreed to in writing, software\n", " * distributed under the License is distributed on an \"AS IS\" BASIS,\n", " * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n", " * See the License for the specific language governing permissions and\n", " * limitations under the License.\n", " */\n", "\n", "package com.google.common.util.concurrent;\n", "\n", "import static com.google.common.base.Preconditions.checkNotNull;\n", "\n", "import com.google.common.collect.Queues;\n", "\n", "import java.util.Iterator;\n", "import java.util.concurrent.ConcurrentLinkedQueue;\n", "import java.util.concurrent.Executor;\n", "import java.util.concurrent.locks.ReentrantLock;\n", "import java.util.logging.Level;\n", "import java.util.logging.Logger;\n", "\n", "import javax.annotation.concurrent.GuardedBy;\n", "import javax.annotation.concurrent.ThreadSafe;\n", "\n", "/**\n", " * A thread-safe queue of listeners, each with an associated {@code Executor}, that guarantees\n", " * that every {@code Runnable} that is {@linkplain #add added} will be\n", " * {@link Executor#execute(Runnable) executed} in the same order that it was added.\n", " *\n", " * <p>While similar in structure and API to {@link ExecutionList}, this class differs in several\n", " * ways:\n", " *\n", " * <ul>\n", " *    <li>This class makes strict ordering guarantees. ExecutionList makes no ordering guarantees.\n", " *    <li>{@link ExecutionQueue#execute} executes all currently pending listeners. Later calls\n", " *        to {@link ExecutionQueue#add} are delayed until the <em>next</em> call to execute.\n", " *        {@link ExecutionList#execute()} executes all current listeners and also causes immediate\n", " *        execution on subsequent calls to {@link ExecutionList#add}.\n", " * </ul>\n", " *\n", " * <p>These differences make {@link ExecutionQueue} suitable for when you need to execute callbacks\n", " * multiple times in response to different events. ExecutionList is suitable for when you have a\n", " * single event.\n", " *\n", " * <p>For example, this implements a simple atomic data structure that lets a listener\n", " * asynchronously listen to changes to a value: <pre>   {@code\n", " *   interface CountListener {\n", " *     void update(int v);\n", " *   }\n", " *\n", " *   class AtomicListenableCounter {\n", " *     private int value;\n", " *     private final ExecutionQueue queue = new ExecutionQueue();\n", " *     private final CountListener listener;\n", " *     private final Executor executor;\n", " *\n", " *     AtomicListenableCounter(CountListener listener, Executor executor) {\n", " *       this.listener = listener;\n", " *       this.exeucutor = executor;\n", " *     }\n", " *\n", " *     void add(int amt) {\n", " *       synchronized (this) {\n", " *         v += amt;\n", " *         final int currentValue = v;\n", " *         queue.add(new Runnable() {\n", " *           public void run() {\n", " *             listener.update(currentValue);\n", " *           }\n", " *         }, executor);\n", " *       }\n", " *       queue.execute();\n", " *   }\n", " * }}</pre>\n", " *\n", " * <p>This AtomicListenableCounter allows a listener to be run asynchronously on every update and\n", " * the ExecutionQueue enforces that:\n", " *\n", " * <ul>\n", " *   <li>The listener is never run with the lock held (even if the executor is the\n", " *       {@link MoreExecutors#sameThreadExecutor()})\n", " *   <li>The listeners are never run out of order\n", " *   <li>Each added listener is called only once.\n", " * </ul>\n", " *\n", " * <p>Exceptions thrown by a listener will be propagated up to the executor. Any exception thrown\n", " * during {@code Executor.execute} (e.g., a {@code RejectedExecutionException} or an exception\n", " * thrown by {@linkplain MoreExecutors#sameThreadExecutor inline execution}) will be caught and\n", " * logged.\n", " *\n", " * @author Luke Sandberg\n", " */\n", "@ThreadSafe\n", "final class ExecutionQueue {\n", "  private static final Logger logger = Logger.getLogger(ExecutionQueue.class.getName());\n", "\n", "  /** The listeners to execute in order.  */\n", "  private final ConcurrentLinkedQueue<RunnableExecutorPair> queuedListeners =\n", "      Queues.newConcurrentLinkedQueue();\n", "  /**\n", "   * This lock is used with {@link RunnableExecutorPair#submit} to ensure that each listener is\n", "   * executed at most once.\n", "   */\n", "  private final ReentrantLock lock = new ReentrantLock();\n", "\n", "  /**\n", "   * Adds the {@code Runnable} and accompanying {@code Executor} to the queue of listeners to\n", "   * execute.\n", "   *\n", "   * <p>Note: This method will never directly invoke {@code executor.execute(runnable)}, though your\n", "   * runnable may be executed before it returns if another thread has concurrently called\n", "   * {@link #execute}.\n", "   */\n", "  public void add(Runnable runnable, Executor executor) {\n", "    queuedListeners.add(new RunnableExecutorPair(runnable, executor));\n", "  }\n", "\n", "  /**\n", "   * Executes all listeners in the queue.\n", "   *\n", "   * <p>Note that there is no guarantee that concurrently {@linkplain #add added} listeners will be\n", "   * executed prior to the return of this method, only that all calls to {@link #add} that\n", "   * happen-before this call will be executed.\n", "   */\n", "  public void execute() {\n", "    // We need to make sure that listeners are submitted to their executors in the correct order. So\n", "    // we cannot remove a listener from the queue until we know that it has been submited to its\n", "    // executor.  So we use an iterator and only call remove after submit.  This iterator is 'weakly\n", "    // consistent' which means it observes the list in the correct order but not neccesarily all of\n", "    // it (i.e. concurrently added or removed items may or may not be observed correctly by this\n", "    // iterator).  This is fine because 1. our contract says we may not execute all concurrently\n", "    // added items and 2. calling listener.submit is idempotent, so it is safe (and generally cheap)\n", "    // to call it multiple times.\n", "    // TODO(user): we are relying on an underdocumented feature of ConcurrentLinkedQueue, the\n", "    // general strategy in other JDK libraries appears to be bring-your-own-queue :(  Consider doing\n", "    // that.\n", "    Iterator<RunnableExecutorPair> iterator = queuedListeners.iterator();\n", "    while (iterator.hasNext()) {\n", "      iterator.next().submit();\n", "      iterator.remove();\n", "    }\n", "  }\n", "\n", "  /**\n", "   * The listener object for the queue.\n", "   *\n", "   * <p>This ensures that:\n", "   * <ol>\n", "   *   <li>{@link #executor executor}.{@link Executor#execute execute} is called at most once\n", "   *   <li>{@link #runnable runnable}.{@link Runnable#run run} is called at most once by the\n", "   *        executor\n", "   *   <li>{@link #lock lock} is not held when {@link #runnable runnable}.{@link Runnable#run run}\n", "   *       is called\n", "   *   <li>no thread calling {@link #submit} can return until the task has been accepted by the\n", "   *       executor\n", "   * </ol>\n", "   */\n", "  private final class RunnableExecutorPair implements Runnable {\n", "    private final Executor executor;\n", "    private final Runnable runnable;\n", "    /**\n", "     * Should be set to {@code true} after {@link #executor}.{@link Executor#execute execute} has\n", "     * been called.\n", "     */\n", "    @GuardedBy(\"lock\")\n", "    private boolean hasBeenExecuted = false;\n", "\n", "    RunnableExecutorPair(Runnable runnable, Executor executor) {\n", "      this.runnable = checkNotNull(runnable);\n", "      this.executor = checkNotNull(executor);\n", "    }\n", "\n", "    /** Submit this listener to its executor */\n", "    private void submit() {\n", "      lock.lock();\n", "      try {\n", "        if (!hasBeenExecuted) {\n", "          try {\n", "            executor.execute(this);\n", "          } catch (Exception e) {\n", "            logger.log(Level.SEVERE, \"Exception while executing listener \" + runnable\n", "                + \" with executor \" + executor, e);\n", "          }\n", "        }\n", "      } finally {\n", "        // If the executor was the sameThreadExecutor we may have already released the lock, so\n", "        // check for that here.\n", "        if (lock.isHeldByCurrentThread()) {\n", "          hasBeenExecuted = true;\n", "          lock.unlock();\n", "        }\n", "      }\n", "    }\n", "\n", "    @Override public final void run() {\n", "      // If the executor was the sameThreadExecutor then we might still be holding the lock and\n", "      // hasBeenExecuted may not have been assigned yet so we unlock now to ensure that we are not\n", "      // still holding the lock while execute is called.\n", "      if (lock.isHeldByCurrentThread()) {\n", "        hasBeenExecuted = true;\n", "        lock.unlock();\n", "      }\n", "      runnable.run();\n", "    }\n", "  }\n", "}\n"]}, "added_lines": {}, "removed_lines": {"1": [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 58, 59, 60, 61, 62, 63, 64, 65, 66, 67, 68, 69, 70, 71, 72, 73, 74, 75, 76, 77, 78, 79, 80, 81, 82, 83, 84, 85, 86, 87, 88, 89, 90, 91, 92, 93, 94, 95, 96, 97, 98, 99, 100, 101, 102, 103, 104, 105, 106, 107, 108, 109, 110, 111, 112, 113, 114, 115, 116, 117, 118, 119, 120, 121, 122, 123, 124, 125, 126, 127, 128, 129, 130, 131, 132, 133, 134, 135, 136, 137, 138, 139, 140, 141, 142, 143, 144, 145, 146, 147, 148, 149, 150, 151, 152, 153, 154, 155, 156, 157, 158, 159, 160, 161, 162, 163, 164, 165, 166, 167, 168, 169, 170, 171, 172, 173, 174, 175, 176, 177, 178, 179, 180, 181, 182, 183, 184, 185, 186, 187, 188, 189, 190, 191, 192, 193, 194, 195, 196, 197, 198, 199, 200, 201, 202, 203, 204, 205, 206, 207, 208, 209, 210, 211, 212, 213, 214]}}, {"4": "guava/src/com/google/common/util/concurrent/ListenerCallQueue.java", "added": {"1": ["/*\n", " * Copyright (C) 2014 The Guava Authors\n", " *\n", " * Licensed under the Apache License, Version 2.0 (the \"License\");\n", " * you may not use this file except in compliance with the License.\n", " * You may obtain a copy of the License at\n", " *\n", " * http://www.apache.org/licenses/LICENSE-2.0\n", " *\n", " * Unless required by applicable law or agreed to in writing, software\n", " * distributed under the License is distributed on an \"AS IS\" BASIS,\n", " * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n", " * See the License for the specific language governing permissions and\n", " * limitations under the License.\n", " */\n", "\n", "package com.google.common.util.concurrent;\n", "\n", "import static com.google.common.base.Preconditions.checkNotNull;\n", "\n", "import com.google.common.base.Preconditions;\n", "import com.google.common.collect.Queues;\n", "\n", "import java.util.Queue;\n", "import java.util.concurrent.Executor;\n", "import java.util.logging.Level;\n", "import java.util.logging.Logger;\n", "\n", "import javax.annotation.concurrent.GuardedBy;\n", "\n", "/**\n", " * A special purpose queue/executor that executes listener callbacks serially on a configured\n", " * executor.  Each callback task can be enqueued and executed as separate phases.\n", " * \n", " * <p>This class is very similar to {@link SerializingExecutor} with the exception that tasks can\n", " * be enqueued without necessarily executing immediately.\n", " */\n", "final class ListenerCallQueue<L> implements Runnable {\n", "  // TODO(cpovirk): consider using the logger associated with listener.getClass().\n", "  private static final Logger logger = Logger.getLogger(ListenerCallQueue.class.getName());\n", "\n", "  abstract static class Callback<L> {\n", "    private final String methodCall;\n", "\n", "    Callback(String methodCall) {\n", "      this.methodCall = methodCall;\n", "    }\n", "\n", "    abstract void call(L listener);\n", "    \n", "    /** Helper method to add this callback to all the queues. */\n", "    void enqueueOn(Iterable<ListenerCallQueue<L>> queues) {\n", "      for (ListenerCallQueue<L> queue : queues) {\n", "        queue.add(this);\n", "      }\n", "    }\n", "  }\n", "\n", "  private final L listener;\n", "  private final Executor executor;\n", "\n", "  @GuardedBy(\"this\") private final Queue<Callback<L>> waitQueue = Queues.newArrayDeque();\n", "  @GuardedBy(\"this\") private boolean isThreadScheduled;\n", "\n", "  ListenerCallQueue(L listener, Executor executor) {\n", "    this.listener = checkNotNull(listener);\n", "    this.executor = checkNotNull(executor);\n", "  }\n", "\n", "  /** Enqueues a task to be run. */\n", "  synchronized void add(Callback<L> callback) {\n", "    waitQueue.add(callback);\n", "  }\n", "\n", "  /** Executes all listeners {@linkplain #add added} prior to this call, serially and in order.*/\n", "  void execute() {\n", "    boolean scheduleTaskRunner = false;\n", "    synchronized (this) {\n", "      if (!isThreadScheduled) {\n", "        isThreadScheduled = true;\n", "        scheduleTaskRunner = true;\n", "      }\n", "    }\n", "    if (scheduleTaskRunner) {\n", "      try {\n", "        executor.execute(this);\n", "      } catch (RuntimeException e) {\n", "        // reset state in case of an error so that later calls to execute will actually do something\n", "        synchronized (this) {\n", "          isThreadScheduled = false;\n", "        }\n", "        // Log it and keep going.\n", "        logger.log(Level.SEVERE,\n", "            \"Exception while running callbacks for \" + listener + \" on \" + executor, \n", "            e);\n", "        throw e;\n", "      }\n", "    }\n", "  }\n", "\n", "  @Override public void run() {\n", "    boolean stillRunning = true;\n", "    try {\n", "      while (true) {\n", "        Callback<L> nextToRun;\n", "        synchronized (ListenerCallQueue.this) {\n", "          Preconditions.checkState(isThreadScheduled);\n", "          nextToRun = waitQueue.poll();\n", "          if (nextToRun == null) {\n", "            isThreadScheduled = false;\n", "            stillRunning = false;\n", "            break;\n", "          }\n", "        }\n", "\n", "        // Always run while _not_ holding the lock, to avoid deadlocks.\n", "        try {\n", "          nextToRun.call(listener);\n", "        } catch (RuntimeException e) {\n", "          // Log it and keep going.\n", "          logger.log(Level.SEVERE, \n", "              \"Exception while executing callback: \" + listener + \".\" + nextToRun.methodCall, \n", "              e);\n", "        }\n", "      }\n", "    } finally {\n", "      if (stillRunning) {\n", "        // An Error is bubbling up, we should mark ourselves as no longer\n", "        // running, that way if anyone tries to keep using us we won't be\n", "        // corrupted.\n", "        synchronized (ListenerCallQueue.this) {\n", "          isThreadScheduled = false;\n", "        }\n", "      }\n", "    }\n", "  }\n", "}\n"]}, "removed": {}, "added_lines": {"1": [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 58, 59, 60, 61, 62, 63, 64, 65, 66, 67, 68, 69, 70, 71, 72, 73, 74, 75, 76, 77, 78, 79, 80, 81, 82, 83, 84, 85, 86, 87, 88, 89, 90, 91, 92, 93, 94, 95, 96, 97, 98, 99, 100, 101, 102, 103, 104, 105, 106, 107, 108, 109, 110, 111, 112, 113, 114, 115, 116, 117, 118, 119, 120, 121, 122, 123, 124, 125, 126, 127, 128, 129, 130, 131, 132, 133, 134, 135, 136, 137]}, "removed_lines": {}}, {"5": "guava/src/com/google/common/util/concurrent/Service.java", "added": {"1": ["   * <p>{@code addListener} guarantees execution ordering across calls to a given listener but not\n", "   * across calls to multiple listeners. Specifically, a given listener will have its callbacks\n", "   * invoked in the same order as the underlying service enters those states. Additionally, at most\n", "   * one of the listener's callbacks will execute at once. However, multiple listeners' callbacks\n", "   * may execute concurrently, and listeners may execute in an order different from the one in which\n", "   * they were registered.\n", "   * <p>RuntimeExceptions thrown by a listener will be caught and logged. Any exception thrown \n", "   * during {@code Executor.execute} (e.g., a {@code RejectedExecutionException}) will be caught and\n"]}, "removed": {"1": ["   * <p>There is no guaranteed ordering of execution of listeners, but any listener added through \n", "   * this method is guaranteed to be called whenever there is a state change.\n", "   * <p>Exceptions thrown by a listener will be propagated up to the executor. Any exception thrown \n", "   * during {@code Executor.execute} (e.g., a {@code RejectedExecutionException} or an exception \n", "   * thrown by {@linkplain MoreExecutors#sameThreadExecutor inline execution}) will be caught and\n"]}, "added_lines": {"1": [154, 155, 156, 157, 158, 159, 161, 162]}, "removed_lines": {"1": [154, 155, 157, 158, 159]}}, {"6": "guava/src/com/google/common/util/concurrent/ServiceManager.java", "added": {"1": ["import com.google.common.util.concurrent.ListenerCallQueue.Callback;\n", "import java.util.ArrayList;\n"], "3": ["  private static final Callback<Listener> HEALTHY_CALLBACK = new Callback<Listener>(\"healthy()\") {\n", "    @Override void call(Listener listener) {\n", "      listener.healthy();\n", "    }\n", "  };\n", "  private static final Callback<Listener> STOPPED_CALLBACK = new Callback<Listener>(\"stopped()\") {\n", "    @Override void call(Listener listener) {\n", "      listener.stopped();\n", "    }\n", "  };\n"], "4": ["    Executor sameThreadExecutor = MoreExecutors.sameThreadExecutor();\n"], "5": ["      service.addListener(new ServiceListener(service, stateReference), sameThreadExecutor);\n"], "6": ["   * <p>{@code addListener} guarantees execution ordering across calls to a given listener but not\n", "   * across calls to multiple listeners. Specifically, a given listener will have its callbacks\n", "   * invoked in the same order as the underlying service enters those states. Additionally, at most\n", "   * one of the listener's callbacks will execute at once. However, multiple listeners' callbacks\n", "   * may execute concurrently, and listeners may execute in an order different from the one in which\n", "   * they were registered.\n", "   * <p>RuntimeExceptions thrown by a listener will be caught and logged. Any exception thrown \n", "   * during {@code Executor.execute} (e.g., a {@code RejectedExecutionException}) will be caught and\n"], "7": ["   * <p>{@code addListener} guarantees execution ordering across calls to a given listener but not\n", "   * across calls to multiple listeners. Specifically, a given listener will have its callbacks\n", "   * invoked in the same order as the underlying service enters those states. Additionally, at most\n", "   * one of the listener's callbacks will execute at once. However, multiple listeners' callbacks\n", "   * may execute concurrently, and listeners may execute in an order different from the one in which\n", "   * they were registered.\n", "   * <p>RuntimeExceptions thrown by a listener will be caught and logged.\n"], "8": ["    final List<ListenerCallQueue<Listener>> listeners = \n", "        Collections.synchronizedList(new ArrayList<ListenerCallQueue<Listener>>());\n"], "9": ["          listeners.add(new ListenerCallQueue<Listener>(listener, executor));\n"], "10": ["            logger.log(Level.FINE, \"Started {0} in {1}.\", new Object[] {service, stopwatch});\n"], "12": ["      STOPPED_CALLBACK.enqueueOn(listeners);\n", "      HEALTHY_CALLBACK.enqueueOn(listeners);\n", "      new Callback<Listener>(\"failed({service=\" + service + \"})\") {\n", "        @Override void call(Listener listener) {\n", "          listener.failure(service);\n", "        }\n", "      }.enqueueOn(listeners);\n", "    /** Attempts to execute all the listeners in {@link #listeners}. */\n", "      // iterate by index to avoid concurrent modification exceptions\n", "      for (int i = 0; i < listeners.size(); i++) {\n", "        listeners.get(i).execute();\n", "      }\n"]}, "removed": {"2": ["import javax.annotation.concurrent.Immutable;\n"], "5": ["      service.addListener(new ServiceListener(service, stateReference), new SynchronizedExecutor());\n"], "6": ["   * <p>There is no guaranteed ordering of execution of listeners, but any listener added through \n", "   * this method is guaranteed to be called whenever there is a state change.\n", "   * <p>Exceptions thrown by a listener will be propagated up to the executor. Any exception thrown \n", "   * during {@code Executor.execute} (e.g., a {@code RejectedExecutionException} or an exception \n", "   * thrown by {@linkplain MoreExecutors#sameThreadExecutor inline execution}) will be caught and\n"], "7": ["   * <p>There is no guaranteed ordering of execution of listeners, but any listener added through \n", "   * this method is guaranteed to be called whenever there is a state change.\n", "   * <p>Exceptions thrown by a listener will be will be caught and logged.\n"], "8": ["    final List<ListenerExecutorPair> listeners = Lists.newArrayList();\n", "\n", "    /**\n", "     * The queue of listeners that are waiting to be executed.\n", "     *\n", "     * <p>Enqueue operations should be protected by {@link #monitor} while dequeue operations are\n", "     * not protected. Holding {@link #monitor} while enqueuing ensures that listeners in the queue\n", "     * are in the correct order and {@link ExecutionQueue} ensures that they are executed in the\n", "     * correct order.\n", "     */\n", "    @GuardedBy(\"monitor\")\n", "    final ExecutionQueue queuedListeners = new ExecutionQueue();\n"], "9": ["          listeners.add(new ListenerExecutorPair(listener, executor));\n"], "10": ["            logger.log(Level.FINE, \"Started {0} in {1}.\",\n", "                new Object[] {service, stopwatch});\n"], "11": ["          // no more listeners could possibly be called, so clear them out to save some memory.\n", "          listeners.clear();\n"], "12": ["      for (final ListenerExecutorPair pair : listeners) {\n", "        queuedListeners.add(new Runnable() {\n", "          @Override public void run() {\n", "            pair.listener.stopped();\n", "          }\n", "        }, pair.executor);\n", "      }\n", "      for (final ListenerExecutorPair pair : listeners) {\n", "        queuedListeners.add(new Runnable() {\n", "          @Override public void run() {\n", "            pair.listener.healthy();\n", "          }\n", "        }, pair.executor);\n", "      }\n", "      for (final ListenerExecutorPair pair : listeners) {\n", "        queuedListeners.add(new Runnable() {\n", "          @Override public void run() {\n", "            pair.listener.failure(service);\n", "          }\n", "        }, pair.executor);\n", "      }\n", "    /** Attempts to execute all the listeners in {@link #queuedListeners}. */\n", "      queuedListeners.execute();\n"], "13": ["  /** Simple value object binding a listener to its executor. */\n", "  @Immutable private static final class ListenerExecutorPair {\n", "    final Listener listener;\n", "    final Executor executor;\n", "    \n", "    ListenerExecutorPair(Listener listener, Executor executor) {\n", "      this.listener = listener;\n", "      this.executor = executor;\n", "    }\n", "  }\n", "  \n"], "14": ["  \n", "  /** \n", "   * A same-thread executor that executes all the runnables from within a synchronized block.\n", "   * \n", "   * <p>This ensures that tasks submitted to the executor run in the same order that they were \n", "   * submitted.\n", "   */\n", "  private static final class SynchronizedExecutor implements Executor {\n", "    @Override public synchronized void execute(Runnable command) {\n", "      command.run();\n", "    }\n", "  }\n"]}, "added_lines": {"1": [52, 56], "3": [127, 128, 129, 130, 131, 132, 133, 134, 135, 136], "4": [205], "5": [215], "6": [231, 232, 233, 234, 235, 236, 238, 239], "7": [257, 258, 259, 260, 261, 262, 264], "8": [469, 470], "9": [519], "10": [651], "12": [677, 682, 687, 688, 689, 690, 691, 694, 698, 699, 700, 701]}, "removed_lines": {"2": [69], "5": [203], "6": [219, 220, 222, 223, 224], "7": [242, 243, 245], "8": [450, 451, 452, 453, 454, 455, 456, 457, 458, 459, 460, 461], "9": [510], "10": [642, 643], "11": [659, 660], "12": [671, 672, 673, 674, 675, 676, 677, 682, 683, 684, 685, 686, 687, 688, 693, 694, 695, 696, 697, 698, 699, 702, 706], "13": [784, 785, 786, 787, 788, 789, 790, 791, 792, 793, 794], "14": [810, 811, 812, 813, 814, 815, 816, 817, 818, 819, 820, 821]}}]}
