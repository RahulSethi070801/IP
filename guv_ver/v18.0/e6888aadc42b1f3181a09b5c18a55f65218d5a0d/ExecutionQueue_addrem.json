{
    "addition": {},
    "removed": {
        "1": "/*\n",
        "2": " * Copyright (C) 2013 The Guava Authors\n",
        "3": " *\n",
        "4": " * Licensed under the Apache License, Version 2.0 (the \"License\");\n",
        "5": " * you may not use this file except in compliance with the License.\n",
        "6": " * You may obtain a copy of the License at\n",
        "7": " *\n",
        "8": " * http://www.apache.org/licenses/LICENSE-2.0\n",
        "9": " *\n",
        "10": " * Unless required by applicable law or agreed to in writing, software\n",
        "11": " * distributed under the License is distributed on an \"AS IS\" BASIS,\n",
        "12": " * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n",
        "13": " * See the License for the specific language governing permissions and\n",
        "14": " * limitations under the License.\n",
        "15": " */\n",
        "16": "\n",
        "17": "package com.google.common.util.concurrent;\n",
        "18": "\n",
        "19": "import static com.google.common.base.Preconditions.checkNotNull;\n",
        "20": "\n",
        "21": "import com.google.common.collect.Queues;\n",
        "22": "\n",
        "23": "import java.util.Iterator;\n",
        "24": "import java.util.concurrent.ConcurrentLinkedQueue;\n",
        "25": "import java.util.concurrent.Executor;\n",
        "26": "import java.util.concurrent.locks.ReentrantLock;\n",
        "27": "import java.util.logging.Level;\n",
        "28": "import java.util.logging.Logger;\n",
        "29": "\n",
        "30": "import javax.annotation.concurrent.GuardedBy;\n",
        "31": "import javax.annotation.concurrent.ThreadSafe;\n",
        "32": "\n",
        "33": "/**\n",
        "34": " * A thread-safe queue of listeners, each with an associated {@code Executor}, that guarantees\n",
        "35": " * that every {@code Runnable} that is {@linkplain #add added} will be\n",
        "36": " * {@link Executor#execute(Runnable) executed} in the same order that it was added.\n",
        "37": " *\n",
        "38": " * <p>While similar in structure and API to {@link ExecutionList}, this class differs in several\n",
        "39": " * ways:\n",
        "40": " *\n",
        "41": " * <ul>\n",
        "42": " *    <li>This class makes strict ordering guarantees. ExecutionList makes no ordering guarantees.\n",
        "43": " *    <li>{@link ExecutionQueue#execute} executes all currently pending listeners. Later calls\n",
        "44": " *        to {@link ExecutionQueue#add} are delayed until the <em>next</em> call to execute.\n",
        "45": " *        {@link ExecutionList#execute()} executes all current listeners and also causes immediate\n",
        "46": " *        execution on subsequent calls to {@link ExecutionList#add}.\n",
        "47": " * </ul>\n",
        "48": " *\n",
        "49": " * <p>These differences make {@link ExecutionQueue} suitable for when you need to execute callbacks\n",
        "50": " * multiple times in response to different events. ExecutionList is suitable for when you have a\n",
        "51": " * single event.\n",
        "52": " *\n",
        "53": " * <p>For example, this implements a simple atomic data structure that lets a listener\n",
        "54": " * asynchronously listen to changes to a value: <pre>   {@code\n",
        "55": " *   interface CountListener {\n",
        "56": " *     void update(int v);\n",
        "57": " *   }\n",
        "58": " *\n",
        "59": " *   class AtomicListenableCounter {\n",
        "60": " *     private int value;\n",
        "61": " *     private final ExecutionQueue queue = new ExecutionQueue();\n",
        "62": " *     private final CountListener listener;\n",
        "63": " *     private final Executor executor;\n",
        "64": " *\n",
        "65": " *     AtomicListenableCounter(CountListener listener, Executor executor) {\n",
        "66": " *       this.listener = listener;\n",
        "67": " *       this.exeucutor = executor;\n",
        "68": " *     }\n",
        "69": " *\n",
        "70": " *     void add(int amt) {\n",
        "71": " *       synchronized (this) {\n",
        "72": " *         v += amt;\n",
        "73": " *         final int currentValue = v;\n",
        "74": " *         queue.add(new Runnable() {\n",
        "75": " *           public void run() {\n",
        "76": " *             listener.update(currentValue);\n",
        "77": " *           }\n",
        "78": " *         }, executor);\n",
        "79": " *       }\n",
        "80": " *       queue.execute();\n",
        "81": " *   }\n",
        "82": " * }}</pre>\n",
        "83": " *\n",
        "84": " * <p>This AtomicListenableCounter allows a listener to be run asynchronously on every update and\n",
        "85": " * the ExecutionQueue enforces that:\n",
        "86": " *\n",
        "87": " * <ul>\n",
        "88": " *   <li>The listener is never run with the lock held (even if the executor is the\n",
        "89": " *       {@link MoreExecutors#sameThreadExecutor()})\n",
        "90": " *   <li>The listeners are never run out of order\n",
        "91": " *   <li>Each added listener is called only once.\n",
        "92": " * </ul>\n",
        "93": " *\n",
        "94": " * <p>Exceptions thrown by a listener will be propagated up to the executor. Any exception thrown\n",
        "95": " * during {@code Executor.execute} (e.g., a {@code RejectedExecutionException} or an exception\n",
        "96": " * thrown by {@linkplain MoreExecutors#sameThreadExecutor inline execution}) will be caught and\n",
        "97": " * logged.\n",
        "98": " *\n",
        "99": " * @author Luke Sandberg\n",
        "100": " */\n",
        "101": "@ThreadSafe\n",
        "102": "final class ExecutionQueue {\n",
        "103": "  private static final Logger logger = Logger.getLogger(ExecutionQueue.class.getName());\n",
        "104": "\n",
        "105": "  /** The listeners to execute in order.  */\n",
        "106": "  private final ConcurrentLinkedQueue<RunnableExecutorPair> queuedListeners =\n",
        "107": "      Queues.newConcurrentLinkedQueue();\n",
        "108": "  /**\n",
        "109": "   * This lock is used with {@link RunnableExecutorPair#submit} to ensure that each listener is\n",
        "110": "   * executed at most once.\n",
        "111": "   */\n",
        "112": "  private final ReentrantLock lock = new ReentrantLock();\n",
        "113": "\n",
        "114": "  /**\n",
        "115": "   * Adds the {@code Runnable} and accompanying {@code Executor} to the queue of listeners to\n",
        "116": "   * execute.\n",
        "117": "   *\n",
        "118": "   * <p>Note: This method will never directly invoke {@code executor.execute(runnable)}, though your\n",
        "119": "   * runnable may be executed before it returns if another thread has concurrently called\n",
        "120": "   * {@link #execute}.\n",
        "121": "   */\n",
        "122": "  public void add(Runnable runnable, Executor executor) {\n",
        "123": "    queuedListeners.add(new RunnableExecutorPair(runnable, executor));\n",
        "124": "  }\n",
        "125": "\n",
        "126": "  /**\n",
        "127": "   * Executes all listeners in the queue.\n",
        "128": "   *\n",
        "129": "   * <p>Note that there is no guarantee that concurrently {@linkplain #add added} listeners will be\n",
        "130": "   * executed prior to the return of this method, only that all calls to {@link #add} that\n",
        "131": "   * happen-before this call will be executed.\n",
        "132": "   */\n",
        "133": "  public void execute() {\n",
        "134": "    // We need to make sure that listeners are submitted to their executors in the correct order. So\n",
        "135": "    // we cannot remove a listener from the queue until we know that it has been submited to its\n",
        "136": "    // executor.  So we use an iterator and only call remove after submit.  This iterator is 'weakly\n",
        "137": "    // consistent' which means it observes the list in the correct order but not neccesarily all of\n",
        "138": "    // it (i.e. concurrently added or removed items may or may not be observed correctly by this\n",
        "139": "    // iterator).  This is fine because 1. our contract says we may not execute all concurrently\n",
        "140": "    // added items and 2. calling listener.submit is idempotent, so it is safe (and generally cheap)\n",
        "141": "    // to call it multiple times.\n",
        "142": "    // TODO(user): we are relying on an underdocumented feature of ConcurrentLinkedQueue, the\n",
        "143": "    // general strategy in other JDK libraries appears to be bring-your-own-queue :(  Consider doing\n",
        "144": "    // that.\n",
        "145": "    Iterator<RunnableExecutorPair> iterator = queuedListeners.iterator();\n",
        "146": "    while (iterator.hasNext()) {\n",
        "147": "      iterator.next().submit();\n",
        "148": "      iterator.remove();\n",
        "149": "    }\n",
        "150": "  }\n",
        "151": "\n",
        "152": "  /**\n",
        "153": "   * The listener object for the queue.\n",
        "154": "   *\n",
        "155": "   * <p>This ensures that:\n",
        "156": "   * <ol>\n",
        "157": "   *   <li>{@link #executor executor}.{@link Executor#execute execute} is called at most once\n",
        "158": "   *   <li>{@link #runnable runnable}.{@link Runnable#run run} is called at most once by the\n",
        "159": "   *        executor\n",
        "160": "   *   <li>{@link #lock lock} is not held when {@link #runnable runnable}.{@link Runnable#run run}\n",
        "161": "   *       is called\n",
        "162": "   *   <li>no thread calling {@link #submit} can return until the task has been accepted by the\n",
        "163": "   *       executor\n",
        "164": "   * </ol>\n",
        "165": "   */\n",
        "166": "  private final class RunnableExecutorPair implements Runnable {\n",
        "167": "    private final Executor executor;\n",
        "168": "    private final Runnable runnable;\n",
        "169": "    /**\n",
        "170": "     * Should be set to {@code true} after {@link #executor}.{@link Executor#execute execute} has\n",
        "171": "     * been called.\n",
        "172": "     */\n",
        "173": "    @GuardedBy(\"lock\")\n",
        "174": "    private boolean hasBeenExecuted = false;\n",
        "175": "\n",
        "176": "    RunnableExecutorPair(Runnable runnable, Executor executor) {\n",
        "177": "      this.runnable = checkNotNull(runnable);\n",
        "178": "      this.executor = checkNotNull(executor);\n",
        "179": "    }\n",
        "180": "\n",
        "181": "    /** Submit this listener to its executor */\n",
        "182": "    private void submit() {\n",
        "183": "      lock.lock();\n",
        "184": "      try {\n",
        "185": "        if (!hasBeenExecuted) {\n",
        "186": "          try {\n",
        "187": "            executor.execute(this);\n",
        "188": "          } catch (Exception e) {\n",
        "189": "            logger.log(Level.SEVERE, \"Exception while executing listener \" + runnable\n",
        "190": "                + \" with executor \" + executor, e);\n",
        "191": "          }\n",
        "192": "        }\n",
        "193": "      } finally {\n",
        "194": "        // If the executor was the sameThreadExecutor we may have already released the lock, so\n",
        "195": "        // check for that here.\n",
        "196": "        if (lock.isHeldByCurrentThread()) {\n",
        "197": "          hasBeenExecuted = true;\n",
        "198": "          lock.unlock();\n",
        "199": "        }\n",
        "200": "      }\n",
        "201": "    }\n",
        "202": "\n",
        "203": "    @Override public final void run() {\n",
        "204": "      // If the executor was the sameThreadExecutor then we might still be holding the lock and\n",
        "205": "      // hasBeenExecuted may not have been assigned yet so we unlock now to ensure that we are not\n",
        "206": "      // still holding the lock while execute is called.\n",
        "207": "      if (lock.isHeldByCurrentThread()) {\n",
        "208": "        hasBeenExecuted = true;\n",
        "209": "        lock.unlock();\n",
        "210": "      }\n",
        "211": "      runnable.run();\n",
        "212": "    }\n",
        "213": "  }\n",
        "214": "}\n"
    }
}