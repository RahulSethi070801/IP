{
    "addition": {
        "52": "import com.google.common.util.concurrent.ListenerCallQueue.Callback;\n",
        "56": "import java.util.ArrayList;\n",
        "127": "  private static final Callback<Listener> HEALTHY_CALLBACK = new Callback<Listener>(\"healthy()\") {\n",
        "128": "    @Override void call(Listener listener) {\n",
        "129": "      listener.healthy();\n",
        "130": "    }\n",
        "131": "  };\n",
        "132": "  private static final Callback<Listener> STOPPED_CALLBACK = new Callback<Listener>(\"stopped()\") {\n",
        "133": "    @Override void call(Listener listener) {\n",
        "134": "      listener.stopped();\n",
        "135": "    }\n",
        "136": "  };\n",
        "205": "    Executor sameThreadExecutor = MoreExecutors.sameThreadExecutor();\n",
        "215": "      service.addListener(new ServiceListener(service, stateReference), sameThreadExecutor);\n",
        "231": "   * <p>{@code addListener} guarantees execution ordering across calls to a given listener but not\n",
        "232": "   * across calls to multiple listeners. Specifically, a given listener will have its callbacks\n",
        "233": "   * invoked in the same order as the underlying service enters those states. Additionally, at most\n",
        "234": "   * one of the listener's callbacks will execute at once. However, multiple listeners' callbacks\n",
        "235": "   * may execute concurrently, and listeners may execute in an order different from the one in which\n",
        "236": "   * they were registered.\n",
        "238": "   * <p>RuntimeExceptions thrown by a listener will be caught and logged. Any exception thrown \n",
        "239": "   * during {@code Executor.execute} (e.g., a {@code RejectedExecutionException}) will be caught and\n",
        "257": "   * <p>{@code addListener} guarantees execution ordering across calls to a given listener but not\n",
        "258": "   * across calls to multiple listeners. Specifically, a given listener will have its callbacks\n",
        "259": "   * invoked in the same order as the underlying service enters those states. Additionally, at most\n",
        "260": "   * one of the listener's callbacks will execute at once. However, multiple listeners' callbacks\n",
        "261": "   * may execute concurrently, and listeners may execute in an order different from the one in which\n",
        "262": "   * they were registered.\n",
        "264": "   * <p>RuntimeExceptions thrown by a listener will be caught and logged.\n",
        "469": "    final List<ListenerCallQueue<Listener>> listeners = \n",
        "470": "        Collections.synchronizedList(new ArrayList<ListenerCallQueue<Listener>>());\n",
        "519": "          listeners.add(new ListenerCallQueue<Listener>(listener, executor));\n",
        "651": "            logger.log(Level.FINE, \"Started {0} in {1}.\", new Object[] {service, stopwatch});\n",
        "677": "      STOPPED_CALLBACK.enqueueOn(listeners);\n",
        "682": "      HEALTHY_CALLBACK.enqueueOn(listeners);\n",
        "687": "      new Callback<Listener>(\"failed({service=\" + service + \"})\") {\n",
        "688": "        @Override void call(Listener listener) {\n",
        "689": "          listener.failure(service);\n",
        "690": "        }\n",
        "691": "      }.enqueueOn(listeners);\n",
        "694": "    /** Attempts to execute all the listeners in {@link #listeners}. */\n",
        "698": "      // iterate by index to avoid concurrent modification exceptions\n",
        "699": "      for (int i = 0; i < listeners.size(); i++) {\n",
        "700": "        listeners.get(i).execute();\n",
        "701": "      }\n"
    },
    "removed": {
        "69": "import javax.annotation.concurrent.Immutable;\n",
        "203": "      service.addListener(new ServiceListener(service, stateReference), new SynchronizedExecutor());\n",
        "219": "   * <p>There is no guaranteed ordering of execution of listeners, but any listener added through \n",
        "220": "   * this method is guaranteed to be called whenever there is a state change.\n",
        "222": "   * <p>Exceptions thrown by a listener will be propagated up to the executor. Any exception thrown \n",
        "223": "   * during {@code Executor.execute} (e.g., a {@code RejectedExecutionException} or an exception \n",
        "224": "   * thrown by {@linkplain MoreExecutors#sameThreadExecutor inline execution}) will be caught and\n",
        "242": "   * <p>There is no guaranteed ordering of execution of listeners, but any listener added through \n",
        "243": "   * this method is guaranteed to be called whenever there is a state change.\n",
        "245": "   * <p>Exceptions thrown by a listener will be will be caught and logged.\n",
        "450": "    final List<ListenerExecutorPair> listeners = Lists.newArrayList();\n",
        "451": "\n",
        "452": "    /**\n",
        "453": "     * The queue of listeners that are waiting to be executed.\n",
        "454": "     *\n",
        "455": "     * <p>Enqueue operations should be protected by {@link #monitor} while dequeue operations are\n",
        "456": "     * not protected. Holding {@link #monitor} while enqueuing ensures that listeners in the queue\n",
        "457": "     * are in the correct order and {@link ExecutionQueue} ensures that they are executed in the\n",
        "458": "     * correct order.\n",
        "459": "     */\n",
        "460": "    @GuardedBy(\"monitor\")\n",
        "461": "    final ExecutionQueue queuedListeners = new ExecutionQueue();\n",
        "510": "          listeners.add(new ListenerExecutorPair(listener, executor));\n",
        "642": "            logger.log(Level.FINE, \"Started {0} in {1}.\",\n",
        "643": "                new Object[] {service, stopwatch});\n",
        "659": "          // no more listeners could possibly be called, so clear them out to save some memory.\n",
        "660": "          listeners.clear();\n",
        "671": "      for (final ListenerExecutorPair pair : listeners) {\n",
        "672": "        queuedListeners.add(new Runnable() {\n",
        "673": "          @Override public void run() {\n",
        "674": "            pair.listener.stopped();\n",
        "675": "          }\n",
        "676": "        }, pair.executor);\n",
        "677": "      }\n",
        "682": "      for (final ListenerExecutorPair pair : listeners) {\n",
        "683": "        queuedListeners.add(new Runnable() {\n",
        "684": "          @Override public void run() {\n",
        "685": "            pair.listener.healthy();\n",
        "686": "          }\n",
        "687": "        }, pair.executor);\n",
        "688": "      }\n",
        "693": "      for (final ListenerExecutorPair pair : listeners) {\n",
        "694": "        queuedListeners.add(new Runnable() {\n",
        "695": "          @Override public void run() {\n",
        "696": "            pair.listener.failure(service);\n",
        "697": "          }\n",
        "698": "        }, pair.executor);\n",
        "699": "      }\n",
        "702": "    /** Attempts to execute all the listeners in {@link #queuedListeners}. */\n",
        "706": "      queuedListeners.execute();\n",
        "784": "  /** Simple value object binding a listener to its executor. */\n",
        "785": "  @Immutable private static final class ListenerExecutorPair {\n",
        "786": "    final Listener listener;\n",
        "787": "    final Executor executor;\n",
        "788": "    \n",
        "789": "    ListenerExecutorPair(Listener listener, Executor executor) {\n",
        "790": "      this.listener = listener;\n",
        "791": "      this.executor = executor;\n",
        "792": "    }\n",
        "793": "  }\n",
        "794": "  \n",
        "810": "  \n",
        "811": "  /** \n",
        "812": "   * A same-thread executor that executes all the runnables from within a synchronized block.\n",
        "813": "   * \n",
        "814": "   * <p>This ensures that tasks submitted to the executor run in the same order that they were \n",
        "815": "   * submitted.\n",
        "816": "   */\n",
        "817": "  private static final class SynchronizedExecutor implements Executor {\n",
        "818": "    @Override public synchronized void execute(Runnable command) {\n",
        "819": "      command.run();\n",
        "820": "    }\n",
        "821": "  }\n"
    }
}