{
    "addition": {
        "30": "import com.google.common.util.concurrent.ListenerCallQueue.Callback;\n",
        "34": "import java.util.ArrayList;\n",
        "35": "import java.util.Collections;\n",
        "57": "  private static final Callback<Listener> STARTING_CALLBACK =\n",
        "58": "      new Callback<Listener>(\"starting()\") {\n",
        "59": "        @Override void call(Listener listener) {\n",
        "60": "          listener.starting();\n",
        "61": "        }\n",
        "62": "      };\n",
        "63": "  private static final Callback<Listener> RUNNING_CALLBACK =\n",
        "64": "      new Callback<Listener>(\"running()\") {\n",
        "65": "        @Override void call(Listener listener) {\n",
        "66": "          listener.running();\n",
        "67": "        }\n",
        "68": "      };\n",
        "69": "  private static final Callback<Listener> STOPPING_FROM_STARTING_CALLBACK =\n",
        "70": "      stoppingCallback(STARTING);\n",
        "71": "  private static final Callback<Listener> STOPPING_FROM_RUNNING_CALLBACK =\n",
        "72": "      stoppingCallback(RUNNING);\n",
        "73": "\n",
        "74": "  private static final Callback<Listener> TERMINATED_FROM_NEW_CALLBACK =\n",
        "75": "      terminatedCallback(NEW);\n",
        "76": "  private static final Callback<Listener> TERMINATED_FROM_RUNNING_CALLBACK =\n",
        "77": "      terminatedCallback(RUNNING);\n",
        "78": "  private static final Callback<Listener> TERMINATED_FROM_STOPPING_CALLBACK =\n",
        "79": "      terminatedCallback(STOPPING);\n",
        "80": "\n",
        "81": "  private static Callback<Listener> terminatedCallback(final State from) {\n",
        "82": "    return new Callback<Listener>(\"terminated({from = \" + from + \"})\") {\n",
        "83": "      @Override void call(Listener listener) {\n",
        "84": "        listener.terminated(from);\n",
        "85": "      }\n",
        "86": "    };\n",
        "87": "  }\n",
        "88": "\n",
        "89": "  private static Callback<Listener> stoppingCallback(final State from) {\n",
        "90": "    return new Callback<Listener>(\"stopping({from = \" + from + \"})\") {\n",
        "91": "      @Override void call(Listener listener) {\n",
        "92": "        listener.stopping(from);\n",
        "93": "      }\n",
        "94": "    };\n",
        "95": "  }\n",
        "96": "\n",
        "127": "  private final List<ListenerCallQueue<Listener>> listeners =\n",
        "128": "      Collections.synchronizedList(new ArrayList<ListenerCallQueue<Listener>>());\n",
        "413": "      if (!state().isTerminal()) {\n",
        "414": "        listeners.add(new ListenerCallQueue<Listener>(listener, executor));\n",
        "426": "   * Attempts to execute all the listeners in {@link #listeners} while not holding the\n",
        "431": "      // iterate by index to avoid concurrent modification exceptions\n",
        "432": "      for (int i = 0; i < listeners.size(); i++) {\n",
        "433": "        listeners.get(i).execute();\n",
        "434": "      }\n",
        "440": "    STARTING_CALLBACK.enqueueOn(listeners);\n",
        "445": "    RUNNING_CALLBACK.enqueueOn(listeners);\n",
        "450": "    if (from == State.STARTING) {\n",
        "451": "      STOPPING_FROM_STARTING_CALLBACK.enqueueOn(listeners);\n",
        "452": "    } else if (from == State.RUNNING) {\n",
        "453": "      STOPPING_FROM_RUNNING_CALLBACK.enqueueOn(listeners);\n",
        "454": "    } else {\n",
        "455": "      throw new AssertionError();\n",
        "461": "    switch(from) {\n",
        "462": "      case NEW:\n",
        "463": "        TERMINATED_FROM_NEW_CALLBACK.enqueueOn(listeners);\n",
        "464": "        break;\n",
        "465": "      case RUNNING:\n",
        "466": "        TERMINATED_FROM_RUNNING_CALLBACK.enqueueOn(listeners);\n",
        "467": "        break;\n",
        "468": "      case STOPPING:\n",
        "469": "        TERMINATED_FROM_STOPPING_CALLBACK.enqueueOn(listeners);\n",
        "470": "        break;\n",
        "471": "      case STARTING:\n",
        "472": "      case TERMINATED:\n",
        "473": "      case FAILED:\n",
        "474": "      default:\n",
        "475": "        throw new AssertionError();\n",
        "481": "    // can't memoize this one due to the exception\n",
        "482": "    new Callback<Listener>(\"failed({from = \" + from + \", cause = \" + cause + \"})\") {\n",
        "483": "      @Override void call(Listener listener) {\n",
        "484": "        listener.failed(from, cause);\n",
        "485": "      }\n",
        "486": "    }.enqueueOn(listeners);\n"
    },
    "removed": {
        "30": "import com.google.common.collect.Lists;\n",
        "84": "  private final List<ListenerExecutorPair> listeners = Lists.newArrayList();\n",
        "85": "\n",
        "86": "  /**\n",
        "87": "   * The queue of listeners that are waiting to be executed.\n",
        "88": "   *\n",
        "89": "   * <p>Enqueue operations should be protected by {@link #monitor} while calling\n",
        "90": "   * {@link ExecutionQueue#execute()} should not be protected.\n",
        "91": "   */\n",
        "92": "  private final ExecutionQueue queuedListeners = new ExecutionQueue();\n",
        "377": "      State currentState = state();\n",
        "378": "      if (currentState != TERMINATED && currentState != FAILED) {\n",
        "379": "        listeners.add(new ListenerExecutorPair(listener, executor));\n",
        "391": "   * Attempts to execute all the listeners in {@link #queuedListeners} while not holding the\n",
        "396": "      queuedListeners.execute();\n",
        "402": "    for (final ListenerExecutorPair pair : listeners) {\n",
        "403": "      queuedListeners.add(new Runnable() {\n",
        "404": "        @Override public void run() {\n",
        "405": "          pair.listener.starting();\n",
        "406": "        }\n",
        "407": "      }, pair.executor);\n",
        "408": "    }\n",
        "413": "    for (final ListenerExecutorPair pair : listeners) {\n",
        "414": "      queuedListeners.add(new Runnable() {\n",
        "415": "        @Override public void run() {\n",
        "416": "          pair.listener.running();\n",
        "417": "        }\n",
        "418": "      }, pair.executor);\n",
        "419": "    }\n",
        "424": "    for (final ListenerExecutorPair pair : listeners) {\n",
        "425": "      queuedListeners.add(new Runnable() {\n",
        "426": "        @Override public void run() {\n",
        "427": "          pair.listener.stopping(from);\n",
        "428": "        }\n",
        "429": "      }, pair.executor);\n",
        "435": "    for (final ListenerExecutorPair pair : listeners) {\n",
        "436": "      queuedListeners.add(new Runnable() {\n",
        "437": "        @Override public void run() {\n",
        "438": "          pair.listener.terminated(from);\n",
        "439": "        }\n",
        "440": "      }, pair.executor);\n",
        "442": "    // There are no more state transitions so we can clear this out.\n",
        "443": "    listeners.clear();\n",
        "448": "    for (final ListenerExecutorPair pair : listeners) {\n",
        "449": "      queuedListeners.add(new Runnable() {\n",
        "450": "        @Override public void run() {\n",
        "451": "          pair.listener.failed(from, cause);\n",
        "452": "        }\n",
        "453": "      }, pair.executor);\n",
        "454": "    }\n",
        "455": "    // There are no more state transitions so we can clear this out.\n",
        "456": "    listeners.clear();\n",
        "457": "  }\n",
        "458": "\n",
        "459": "  /** A simple holder for a listener and its executor. */\n",
        "460": "  private static class ListenerExecutorPair {\n",
        "461": "    final Listener listener;\n",
        "462": "    final Executor executor;\n",
        "463": "\n",
        "464": "    ListenerExecutorPair(Listener listener, Executor executor) {\n",
        "465": "      this.listener = listener;\n",
        "466": "      this.executor = executor;\n",
        "467": "    }\n"
    }
}