{
    "addition": {
        "1": "/*\n",
        "2": " * Copyright (C) 2008 The Guava Authors\n",
        "3": " *\n",
        "4": " * Licensed under the Apache License, Version 2.0 (the \"License\");\n",
        "5": " * you may not use this file except in compliance with the License.\n",
        "6": " * You may obtain a copy of the License at\n",
        "7": " *\n",
        "8": " * http://www.apache.org/licenses/LICENSE-2.0\n",
        "9": " *\n",
        "10": " * Unless required by applicable law or agreed to in writing, software\n",
        "11": " * distributed under the License is distributed on an \"AS IS\" BASIS,\n",
        "12": " * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n",
        "13": " * See the License for the specific language governing permissions and\n",
        "14": " * limitations under the License.\n",
        "15": " */\n",
        "16": "\n",
        "17": "package com.google.common.base;\n",
        "18": "\n",
        "19": "import static com.google.common.base.Preconditions.checkNotNull;\n",
        "20": "\n",
        "21": "import com.google.common.annotations.Beta;\n",
        "22": "import com.google.common.annotations.GwtCompatible;\n",
        "23": "\n",
        "24": "import java.io.Serializable;\n",
        "25": "import java.util.Iterator;\n",
        "26": "\n",
        "27": "import javax.annotation.Nullable;\n",
        "28": "\n",
        "29": "/**\n",
        "30": " * A function from {@code A} to {@code B} with an associated <i>reverse</i> function from {@code B}\n",
        "31": " * to {@code A}; used for converting back and forth between <i>different representations of the same\n",
        "32": " * information</i>.\n",
        "33": " *\n",
        "34": " * <h3>Invertibility</h3>\n",
        "35": " *\n",
        "36": " * <p>The reverse operation <b>may</b> be a strict <i>inverse</i> (meaning that {@code\n",
        "37": " * converter.reverse().convert(converter.convert(a)).equals(a)} is always true). However, it is\n",
        "38": " * very common (perhaps <i>more</i> common) for round-trip conversion to be <i>lossy</i>. Consider\n",
        "39": " * an example round-trip using {@link com.google.common.primitives.Doubles#stringConverter}:\n",
        "40": " *\n",
        "41": " * <ol>\n",
        "42": " * <li>{@code stringConverter().convert(\"1.00\")} returns the {@code Double} value {@code 1.0}\n",
        "43": " * <li>{@code stringConverter().reverse().convert(1.0)} returns the string {@code \"1.0\"} --\n",
        "44": " *     <i>not</i> the same string ({@code \"1.00\"}) we started with\n",
        "45": " * </ol>\n",
        "46": " *\n",
        "47": " * <p>Note that it should still be the case that the round-tripped and original objects are\n",
        "48": " * <i>similar</i>.\n",
        "49": " *\n",
        "50": " * <h3>Nullability</h3>\n",
        "51": " *\n",
        "52": " * <p>A converter always converts {@code null} to {@code null} and non-null references to non-null\n",
        "53": " * references. It would not make sense to consider {@code null} and a non-null reference to be\n",
        "54": " * \"different representations of the same information\", since one is distinguishable from\n",
        "55": " * <i>missing</i> information and the other is not. The {@link #convert} method handles this null\n",
        "56": " * behavior for all converters; implementations of {@link #doForward} and {@link #doBackward} are\n",
        "57": " * guaranteed to never be passed {@code null}, and must never return {@code null}.\n",
        "58": " *\n",
        "59": "\n",
        "60": " * <h3>Common ways to use</h3>\n",
        "61": " *\n",
        "62": " * <p>Creating a converter:\n",
        "63": " *\n",
        "64": " * <ul>\n",
        "65": " * <li>Extend this class and override {@link #doForward} and {@link #doBackward}\n",
        "66": " * </ul>\n",
        "67": " *\n",
        "68": " * <p>Using a converter:\n",
        "69": " *\n",
        "70": " * <ul>\n",
        "71": " * <li>Convert one instance in the \"forward\" direction using {@code converter.convert(a)}\n",
        "72": " * <li>Convert multiple instances \"forward\" using {@code converter.convertAll(as)}\n",
        "73": " * <li>Convert in the \"backward\" direction using {@code converter.reverse().convert(b)} or {@code\n",
        "74": " *     converter.reverse().convertAll(bs)}\n",
        "75": " * <li>Use {@code converter} or {@code converter.reverse()} anywhere a {@link Function} is accepted\n",
        "76": " * </ul>\n",
        "77": " *\n",
        "78": " * @author Mike Ward\n",
        "79": " * @author Kurt Alfred Kluever\n",
        "80": " * @author Gregory Kick\n",
        "81": " * @since 16.0\n",
        "82": " */\n",
        "83": "@Beta\n",
        "84": "@GwtCompatible\n",
        "85": "public abstract class Converter<A, B> implements Function<A, B> {\n",
        "86": "  private final boolean handleNullAutomatically;\n",
        "87": "\n",
        "88": "  /** Constructor for use by subclasses. */\n",
        "89": "  protected Converter() {\n",
        "90": "    this(\n",
        "91": "        true\n",
        "92": "        );\n",
        "93": "  }\n",
        "94": "\n",
        "95": "  /**\n",
        "96": "   * Constructor used only by {@code LegacyConverter} to suspend automatic null-handling.\n",
        "97": "   */\n",
        "98": "  Converter(boolean handleNullAutomatically) {\n",
        "99": "    this.handleNullAutomatically = handleNullAutomatically;\n",
        "100": "  }\n",
        "101": "\n",
        "102": "  // SPI methods (what subclasses must implement)\n",
        "103": "\n",
        "104": "  /**\n",
        "105": "   * Returns a representation of {@code a} as an instance of type {@code B}.\n",
        "106": "   *\n",
        "107": "   * @param a the instance to convert; will never be null\n",
        "108": "   * @return the converted instance; <b>must not</b> be null\n",
        "109": "   */\n",
        "110": "  protected abstract B doForward(A a);\n",
        "111": "\n",
        "112": "  /**\n",
        "113": "   * Returns a representation of {@code b} as an instance of type {@code A}.\n",
        "114": "   *\n",
        "115": "   * @param b the instance to convert; will never be null\n",
        "116": "   * @return the converted instance; <b>must not</b> be null\n",
        "117": "   * @throws RuntimeException if {@code b} is not an instance this converter can convert; this\n",
        "118": "   *     should typically be an {@code IllegalArgumentException}\n",
        "119": "   * @throws UnsupportedOperationException if this converter cannot convert in the reverse\n",
        "120": "   *     direction. This should be very rare. Note that if backward conversion is not only\n",
        "121": "   *     unimplemented but unimplement<i>able</i> (for example, consider a {@code\n",
        "122": "   *     Converter<Chicken, ChickenNugget>}), then this is not logically a converter at all, and it\n",
        "123": "   *     would be misleading to extend this class.\n",
        "124": "   */\n",
        "125": "  protected abstract A doBackward(B b);\n",
        "126": "\n",
        "127": "  // API (consumer-side) methods\n",
        "128": "\n",
        "129": "  /**\n",
        "130": "   * Returns a representation of {@code a} as an instance of type {@code B}.\n",
        "131": "   *\n",
        "132": "   * @return the converted value; is null <i>if and only if</i> {@code a} is null\n",
        "133": "   */\n",
        "134": "  @Nullable public final B convert(@Nullable A a) {\n",
        "135": "    return correctedDoForward(a);\n",
        "136": "  }\n",
        "137": "\n",
        "138": "  B correctedDoForward(A a) {\n",
        "139": "    if (handleNullAutomatically) {\n",
        "140": "      return a == null ? null : checkNotNull(doForward(a));\n",
        "141": "    } else {\n",
        "142": "      return doForward(a);\n",
        "143": "    }\n",
        "144": "  }\n",
        "145": "\n",
        "146": "  A correctedDoBackward(B b) {\n",
        "147": "    if (handleNullAutomatically) {\n",
        "148": "      return b == null ? null : checkNotNull(doBackward(b));\n",
        "149": "    } else {\n",
        "150": "      return doBackward(b);\n",
        "151": "    }\n",
        "152": "  }\n",
        "153": "\n",
        "154": "  /**\n",
        "155": "   * Returns an iterable that applies {@code convert} to each element of {@code fromIterable}. The\n",
        "156": "   * conversion is done lazily.\n",
        "157": "   *\n",
        "158": "   * <p>The returned iterable's iterator supports {@code remove()} if the input iterator does. After\n",
        "159": "   * a successful {@code remove()} call, {@code fromIterable} no longer contains the corresponding\n",
        "160": "   * element.\n",
        "161": "   */\n",
        "162": "  public Iterable<B> convertAll(final Iterable<? extends A> fromIterable) {\n",
        "163": "    checkNotNull(fromIterable, \"fromIterable\");\n",
        "164": "    return new Iterable<B>() {\n",
        "165": "      @Override public Iterator<B> iterator() {\n",
        "166": "        return new Iterator<B>() {\n",
        "167": "          private final Iterator<? extends A> fromIterator = fromIterable.iterator();\n",
        "168": "          @Override public boolean hasNext() {\n",
        "169": "            return fromIterator.hasNext();\n",
        "170": "          }\n",
        "171": "          @Override public B next() {\n",
        "172": "            return convert(fromIterator.next());\n",
        "173": "          }\n",
        "174": "          @Override public void remove() {\n",
        "175": "            fromIterator.remove();\n",
        "176": "          }\n",
        "177": "        };\n",
        "178": "      }\n",
        "179": "    };\n",
        "180": "  }\n",
        "181": "\n",
        "182": "  /**\n",
        "183": "   * Returns the reversed view of this converter, which converts {@code this.convert(a)} back to a\n",
        "184": "   * value roughly equivalent to {@code a}.\n",
        "185": "   *\n",
        "186": "   * <p>The returned converter is serializable if {@code this} converter is.\n",
        "187": "   */\n",
        "188": "  public Converter<B, A> reverse() {\n",
        "189": "    return new ReverseConverter<A, B>(this);\n",
        "190": "  }\n",
        "191": "\n",
        "192": "  private static final class ReverseConverter<A, B>\n",
        "193": "      extends Converter<B, A> implements Serializable {\n",
        "194": "    final Converter<A, B> original;\n",
        "195": "\n",
        "196": "    ReverseConverter(Converter<A, B> original) {\n",
        "197": "      // Rely on backing converter to handle null if desired, not us.\n",
        "198": "      // Actually, since we override correctedDo*, nothing will use this field now anyway.\n",
        "199": "      super(false);\n",
        "200": "      this.original = original;\n",
        "201": "    }\n",
        "202": "\n",
        "203": "    /*\n",
        "204": "     * These gymnastics are a little confusing. Basically this class has neither legacy nor\n",
        "205": "     * non-legacy behavior; it just needs to let the behavior of the backing converter shine\n",
        "206": "     * through. So, we override the correctedDo* methods, after which the do* methods should never\n",
        "207": "     * be reached.\n",
        "208": "     */\n",
        "209": "\n",
        "210": "    @Override protected A doForward(@Nullable B b) {\n",
        "211": "      throw new AssertionError();\n",
        "212": "    }\n",
        "213": "\n",
        "214": "    @Override protected B doBackward(@Nullable A a) {\n",
        "215": "      throw new AssertionError();\n",
        "216": "    }\n",
        "217": "\n",
        "218": "    @Override A correctedDoForward(B b) {\n",
        "219": "      return original.correctedDoBackward(b);\n",
        "220": "    }\n",
        "221": "\n",
        "222": "    @Override B correctedDoBackward(A a) {\n",
        "223": "      return original.correctedDoForward(a);\n",
        "224": "    }\n",
        "225": "\n",
        "226": "    @Override public Converter<A, B> reverse() {\n",
        "227": "      return original;\n",
        "228": "    }\n",
        "229": "\n",
        "230": "    @Override public boolean equals(@Nullable Object object) {\n",
        "231": "      if (object instanceof ReverseConverter) {\n",
        "232": "        ReverseConverter<?, ?> that = (ReverseConverter<?, ?>) object;\n",
        "233": "        return this.original.equals(that.original);\n",
        "234": "      }\n",
        "235": "      return false;\n",
        "236": "    }\n",
        "237": "\n",
        "238": "    @Override public int hashCode() {\n",
        "239": "      return ~original.hashCode();\n",
        "240": "    }\n",
        "241": "\n",
        "242": "    @Override public String toString() {\n",
        "243": "      return original + \".reverse()\";\n",
        "244": "    }\n",
        "245": "\n",
        "246": "    private static final long serialVersionUID = 0L;\n",
        "247": "  }\n",
        "248": "\n",
        "249": "  /**\n",
        "250": "   * Returns a converter whose {@code convert} method applies {@code secondConverter} to the result\n",
        "251": "   * of this converter. Its {@code reverse} method applies the converters in reverse order.\n",
        "252": "   *\n",
        "253": "   * <p>The returned converter is serializable if {@code this} converter and {@code secondConverter}\n",
        "254": "   * are.\n",
        "255": "   */\n",
        "256": "  public <C> Converter<A, C> andThen(Converter<B, C> secondConverter) {\n",
        "257": "    return ConverterComposition.of(this, checkNotNull(secondConverter, \"secondConverter\"));\n",
        "258": "  }\n",
        "259": "\n",
        "260": "  private static final class ConverterComposition<A, B, C>\n",
        "261": "      extends Converter<A, C> implements Serializable {\n",
        "262": "    final Converter<A, B> first;\n",
        "263": "    final Converter<B, C> second;\n",
        "264": "\n",
        "265": "    ConverterComposition(Converter<A, B> first, Converter<B, C> second) {\n",
        "266": "      // Rely on backing converter to handle null if desired, not us.\n",
        "267": "      // Actually, since we override correctedDo*, nothing will use this field now anyway.\n",
        "268": "      super(false);\n",
        "269": "      this.first = first;\n",
        "270": "      this.second = second;\n",
        "271": "    }\n",
        "272": "\n",
        "273": "    /*\n",
        "274": "     * These gymnastics are a little confusing. Basically this class has neither legacy nor\n",
        "275": "     * non-legacy behavior; it just needs to let the behaviors of the backing converters shine\n",
        "276": "     * through (which might even differ from each other!). So, we override the correctedDo* methods,\n",
        "277": "     * after which the do* methods should never be reached.\n",
        "278": "     */\n",
        "279": "\n",
        "280": "    @Override protected C doForward(@Nullable A a) {\n",
        "281": "      throw new AssertionError();\n",
        "282": "    }\n",
        "283": "\n",
        "284": "    @Override protected A doBackward(@Nullable C c) {\n",
        "285": "      throw new AssertionError();\n",
        "286": "    }\n",
        "287": "\n",
        "288": "    @Override C correctedDoForward(@Nullable A a) {\n",
        "289": "      return second.correctedDoForward(first.correctedDoForward(a));\n",
        "290": "    }\n",
        "291": "\n",
        "292": "    @Override A correctedDoBackward(@Nullable C c) {\n",
        "293": "      return first.correctedDoBackward(second.correctedDoBackward(c));\n",
        "294": "    }\n",
        "295": "\n",
        "296": "    @Override public boolean equals(@Nullable Object object) {\n",
        "297": "      if (object instanceof ConverterComposition) {\n",
        "298": "        ConverterComposition<?, ?, ?> that = (ConverterComposition<?, ?, ?>) object;\n",
        "299": "        return this.first.equals(that.first)\n",
        "300": "            && this.second.equals(that.second);\n",
        "301": "      }\n",
        "302": "      return false;\n",
        "303": "    }\n",
        "304": "\n",
        "305": "    @Override public int hashCode() {\n",
        "306": "      return 31 * first.hashCode() + second.hashCode();\n",
        "307": "    }\n",
        "308": "\n",
        "309": "    @Override public String toString() {\n",
        "310": "      return first + \".andThen(\" + second + \")\";\n",
        "311": "    }\n",
        "312": "\n",
        "313": "    static <A, B, C> Converter<A, C> of(Converter<A, B> first, Converter<B, C> second) {\n",
        "314": "      return new ConverterComposition<A, B, C>(first, second);\n",
        "315": "    }\n",
        "316": "\n",
        "317": "    private static final long serialVersionUID = 0L;\n",
        "318": "  }\n",
        "319": "\n",
        "320": "  /**\n",
        "321": "   * @deprecated Provided to satisfy the {@code Function} interface; use {@link #convert} instead.\n",
        "322": "   */\n",
        "323": "  @Deprecated\n",
        "324": "  @Override\n",
        "325": "  @Nullable public final B apply(@Nullable A a) {\n",
        "326": "    return convert(a);\n",
        "327": "  }\n",
        "328": "\n",
        "329": "  /**\n",
        "330": "   * Indicates whether another object is equal to this converter.\n",
        "331": "   *\n",
        "332": "   * <p>Most implementations will have no reason to override the behavior of {@link Object#equals}.\n",
        "333": "   * However, an implementation may also choose to return {@code true} whenever {@code object} is a\n",
        "334": "   * {@link Converter} that it considers <i>interchangeable</i> with this one. \"Interchangeable\"\n",
        "335": "   * <i>typically</i> means that {@code Objects.equal(this.convert(a), that.convert(a))} is true for\n",
        "336": "   * all {@code a} of type {@code A} (and similarly for {@code reverse}). Note that a {@code false}\n",
        "337": "   * result from this method does not imply that the converters are known <i>not</i> to be\n",
        "338": "   * interchangeable.\n",
        "339": "   */\n",
        "340": "  @Override\n",
        "341": "  public boolean equals(@Nullable Object object) {\n",
        "342": "    return super.equals(object);\n",
        "343": "  }\n",
        "344": "\n",
        "345": "  // Static singleton converters\n",
        "346": "\n",
        "347": "  /**\n",
        "348": "   * Returns a serializable converter that always converts or reverses an object to itself.\n",
        "349": "   */\n",
        "350": "  @SuppressWarnings(\"unchecked\") // implementation is \"fully variant\"\n",
        "351": "  public static <T> Converter<T, T> identity() {\n",
        "352": "    return (IdentityConverter<T>) IdentityConverter.INSTANCE;\n",
        "353": "  }\n",
        "354": "\n",
        "355": "  /**\n",
        "356": "   * A converter that always converts or reverses an object to itself. Note that T is now a\n",
        "357": "   * \"pass-through type\".\n",
        "358": "   */\n",
        "359": "  private static final class IdentityConverter<T> extends Converter<T, T> implements Serializable {\n",
        "360": "    static final IdentityConverter INSTANCE = new IdentityConverter();\n",
        "361": "\n",
        "362": "    @Override protected T doForward(@Nullable T t) {\n",
        "363": "      return t;\n",
        "364": "    }\n",
        "365": "\n",
        "366": "    @Override protected T doBackward(@Nullable T t) {\n",
        "367": "      return t;\n",
        "368": "    }\n",
        "369": "\n",
        "370": "    @Override public IdentityConverter<T> reverse() {\n",
        "371": "      return this;\n",
        "372": "    }\n",
        "373": "\n",
        "374": "    @Override public <S> Converter<T, S> andThen(Converter<T, S> otherConverter) {\n",
        "375": "      return checkNotNull(otherConverter, \"otherConverter\");\n",
        "376": "    }\n",
        "377": "\n",
        "378": "    /*\n",
        "379": "     * We *could* override convertAll() to return its input, but it's a rather pointless\n",
        "380": "     * optimization and opened up a weird type-safety problem.\n",
        "381": "     */\n",
        "382": "\n",
        "383": "    @Override public String toString() {\n",
        "384": "      return \"Converter.identity()\";\n",
        "385": "    }\n",
        "386": "\n",
        "387": "    private Object readResolve() {\n",
        "388": "      return INSTANCE;\n",
        "389": "    }\n",
        "390": "\n",
        "391": "    private static final long serialVersionUID = 0L;\n",
        "392": "  }\n",
        "393": "}\n"
    },
    "removed": {}
}