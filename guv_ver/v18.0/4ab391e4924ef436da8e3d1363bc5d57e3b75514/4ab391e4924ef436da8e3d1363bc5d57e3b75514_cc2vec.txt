{"id": "4ab391e4924ef436da8e3d1363bc5d57e3b75514", "code": [{"0": "guava/src/com/google/common/base/Converter.java", "added": {"1": ["   * Returns a representation of {@code a} as an instance of type {@code B}. If {@code a} cannot be\n", "   * converted, an unchecked exception (such as {@link IllegalArgumentException}) should be thrown.\n"], "2": ["   * Returns a representation of {@code b} as an instance of type {@code A}. If {@code b} cannot be\n", "   * converted, an unchecked exception (such as {@link IllegalArgumentException}) should be thrown.\n", "   * @throws UnsupportedOperationException if backward conversion is not implemented; this should be\n", "   *     very rare. Note that if backward conversion is not only unimplemented but\n", "   *     unimplement<i>able</i> (for example, consider a {@code Converter<Chicken, ChickenNugget>}),\n", "   *     then this is not logically a {@code Converter} at all, and should just implement {@link\n", "   *     Function}.\n"], "3": ["      // TODO(kevinb): we shouldn't be checking for a null result at runtime. Assert?\n"], "4": ["      // TODO(kevinb): we shouldn't be checking for a null result at runtime. Assert?\n"], "5": ["  // Static converters\n", "\n", "  private static final class FunctionBasedConverter<A, B>\n", "      extends Converter<A, B> implements Serializable {\n", "    private final Function<? super A, ? extends B> forwardFunction;\n", "    private final Function<? super B, ? extends A> backwardFunction;\n", "\n", "    private FunctionBasedConverter(\n", "        Function<? super A, ? extends B> forwardFunction,\n", "        Function<? super B, ? extends A> backwardFunction) {\n", "      this.forwardFunction = checkNotNull(forwardFunction);\n", "      this.backwardFunction = checkNotNull(backwardFunction);\n", "    }\n", "\n", "    @Override protected B doForward(A a) {\n", "      return forwardFunction.apply(a);\n", "    }\n", "\n", "    @Override protected A doBackward(B b) {\n", "      return backwardFunction.apply(b);\n", "    }\n", "\n", "    @Override public boolean equals(@Nullable Object object) {\n", "      if (object instanceof FunctionBasedConverter) {\n", "        FunctionBasedConverter<?, ?> that = (FunctionBasedConverter<?, ?>) object;\n", "        return this.forwardFunction.equals(that.forwardFunction)\n", "            && this.backwardFunction.equals(that.backwardFunction);\n", "      }\n", "      return false;\n", "    }\n", "\n", "    @Override public int hashCode() {\n", "      return forwardFunction.hashCode() * 31 + backwardFunction.hashCode();\n", "    }\n", "\n", "    @Override public String toString() {\n", "      return \"Converter.from(\" + forwardFunction + \", \" + backwardFunction + \")\";\n", "    }\n", "  }\n"]}, "removed": {"1": ["   * Returns a representation of {@code a} as an instance of type {@code B}.\n"], "2": ["   * Returns a representation of {@code b} as an instance of type {@code A}.\n", "   * @throws RuntimeException if {@code b} is not an instance this converter can convert; this\n", "   *     should typically be an {@code IllegalArgumentException}\n", "   * @throws UnsupportedOperationException if this converter cannot convert in the reverse\n", "   *     direction. This should be very rare. Note that if backward conversion is not only\n", "   *     unimplemented but unimplement<i>able</i> (for example, consider a {@code\n", "   *     Converter<Chicken, ChickenNugget>}), then this is not logically a converter at all, and it\n", "   *     would be misleading to extend this class.\n"], "5": ["  // Static singleton converters\n"]}, "added_lines": {"1": [103, 104], "2": [112, 113, 117, 118, 119, 120, 121], "3": [138], "4": [147], "5": [345, 346, 347, 348, 349, 350, 351, 352, 353, 354, 355, 356, 357, 358, 359, 360, 361, 362, 363, 364, 365, 366, 367, 368, 369, 370, 371, 372, 373, 374, 375, 376, 377, 378, 379, 380, 381, 382, 383]}, "removed_lines": {"1": [103], "2": [111, 115, 116, 117, 118, 119, 120, 121], "5": [343]}}]}
