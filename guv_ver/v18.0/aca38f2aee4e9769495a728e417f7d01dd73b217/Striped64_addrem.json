{
    "addition": {
        "9": " * http://gee.cs.oswego.edu/cgi-bin/viewcvs.cgi/jsr166/src/jsr166e/Striped64.java?revision=1.9\n",
        "16": "import javax.annotation.Nullable;\n",
        "17": "\n",
        "51": "     * There is no need for a blocking lock; when the lock is not\n",
        "122": "     * ThreadLocal holding a single-slot int array holding hash code.\n",
        "123": "     * Unlike the JDK8 version of this class, we use a suboptimal\n",
        "124": "     * int[] representation to avoid introducing a new type that can\n",
        "125": "     * impede class-unloading when ThreadLocals are not removed.\n",
        "127": "    static final ThreadLocal<int[]> threadHashCode = new ThreadLocal<int[]>();\n",
        "130": "     * Generator of new random hash codes\n",
        "132": "    static final Random rng = new Random();\n",
        "195": "    final void retryUpdate(long x, @Nullable int[] hc, boolean wasUncontended) {\n",
        "196": "        int h;\n",
        "197": "        if (hc == null) {\n",
        "198": "            threadHashCode.set(hc = new int[1]); // Initialize randomly\n",
        "199": "            int r = rng.nextInt(); // Avoid zero to allow xorShift rehash\n",
        "200": "            h = hc[0] = (r == 0) ? 1 : r;\n",
        "201": "        }\n",
        "202": "        else\n",
        "203": "            h = hc[0];\n",
        "256": "                hc[0] = h;                      // Record index for next time\n"
    },
    "removed": {
        "9": " * http://gee.cs.oswego.edu/cgi-bin/viewcvs.cgi/jsr166/src/jsr166e/Striped64.java?revision=1.7\n",
        "49": "     * There is no need for a blocking lock: When the lock is not\n",
        "120": "     * Holder for the thread-local hash code. The code is initially\n",
        "121": "     * random, but may be set to a different value upon collisions.\n",
        "123": "    static final class HashCode {\n",
        "124": "        static final Random rng = new Random();\n",
        "125": "        int code;\n",
        "126": "        HashCode() {\n",
        "127": "            int h = rng.nextInt(); // Avoid zero to allow xorShift rehash\n",
        "128": "            code = (h == 0) ? 1 : h;\n",
        "129": "        }\n",
        "130": "    }\n",
        "133": "     * The corresponding ThreadLocal class\n",
        "135": "    static final class ThreadHashCode extends ThreadLocal<HashCode> {\n",
        "136": "        public HashCode initialValue() { return new HashCode(); }\n",
        "137": "    }\n",
        "138": "\n",
        "139": "    /**\n",
        "140": "     * Static per-thread hash codes. Shared across all instances to\n",
        "141": "     * reduce ThreadLocal pollution and because adjustments due to\n",
        "142": "     * collisions in one table are likely to be appropriate for\n",
        "143": "     * others.\n",
        "144": "     */\n",
        "145": "    static final ThreadHashCode threadHashCode = new ThreadHashCode();\n",
        "208": "    final void retryUpdate(long x, HashCode hc, boolean wasUncontended) {\n",
        "209": "        int h = hc.code;\n",
        "281": "        hc.code = h;                            // Record index for next time\n"
    }
}