{"id": "807760488eaaab1ced435ec07dab6be7e991fc47", "code": [{"0": "guava-testlib/src/com/google/common/graph/testing/TestGraphBuilder.java", "added": {"1": ["/*\n", " * Copyright (C) 2016 The Guava Authors\n", " *\n", " * Licensed under the Apache License, Version 2.0 (the \"License\");\n", " * you may not use this file except in compliance with the License.\n", " * You may obtain a copy of the License at\n", " *\n", " * http://www.apache.org/licenses/LICENSE-2.0\n", " *\n", " * Unless required by applicable law or agreed to in writing, software\n", " * distributed under the License is distributed on an \"AS IS\" BASIS,\n", " * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n", " * See the License for the specific language governing permissions and\n", " * limitations under the License.\n", " */\n", "\n", "package com.google.common.graph.testing;\n", "\n", "import com.google.common.graph.Graph;\n", "import com.google.common.graph.GraphBuilder;\n", "import com.google.common.graph.ImmutableGraph;\n", "\n", "/**\n", " * This class is useful for fluently building an immutable graph in tests. Example usage:\n", " * <pre><code>\n", " * // Constructs the following graph: (A)    (B)--->(C)\n", " * private static final ImmutableGraph<String, String> GRAPH =\n", " *     TestGraphBuilder.<String, String>init(GraphBuilder.directed())\n", " *         .addNode(\"A\")\n", " *         .addNode(\"B\")\n", " *         .addNode(\"C\")\n", " *         .addEdge(\"B->C\", \"B\", \"C\")\n", " *         .toImmutableGraph();\n", " * </code></pre>\n", " */\n", "public final class TestGraphBuilder<N, E> {\n", "  private final Graph<N, E> graph;\n", "\n", "  private TestGraphBuilder(Graph<N, E> graph) {\n", "    this.graph = graph;\n", "  }\n", "\n", "  public static <N, E> TestGraphBuilder<N, E> init(GraphBuilder<? super N, ? super E> builder) {\n", "    return new TestGraphBuilder<N, E>(builder.<N, E>build());\n", "  }\n", "\n", "  public TestGraphBuilder<N, E> addNode(N node) {\n", "    graph.addNode(node);\n", "    return this;\n", "  }\n", "\n", "  public TestGraphBuilder<N, E> addEdge(E edge, N node1, N node2) {\n", "    graph.addEdge(edge, node1, node2);\n", "    return this;\n", "  }\n", "\n", "  public ImmutableGraph<N, E> toImmutableGraph() {\n", "    return ImmutableGraph.copyOf(graph);\n", "  }\n", "}\n"]}, "removed": {}, "added_lines": {"1": [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 58, 59, 60]}, "removed_lines": {}}, {"1": "guava-tests/test/com/google/common/graph/AbstractDirectedGraphTest.java", "added": {"1": ["import static com.google.common.graph.Graphs.getPropertiesString;\n"], "2": [" * Abstract base class for testing implementations of {@link Graph} interface.\n", " * <p>This class is responsible for testing that a directed implementation of {@link Graph}\n", " * is correctly handling directed edges. Implementation-dependent test cases are left to\n", " * subclasses. Test cases that do not require the graph to be directed are found in superclasses.\n", "    for (Integer node : graph.nodes()) {\n", "      for (String inEdge : graph.inEdges(node)) {\n", "        Integer oppositeNode = Graphs.oppositeNode(graph, inEdge, node);\n", "        assertThat(graph.source(inEdge)).isEqualTo(oppositeNode);\n", "        assertThat(graph.target(inEdge)).isEqualTo(node);\n", "      for (String outEdge : graph.outEdges(node)) {\n", "        Integer oppositeNode = Graphs.oppositeNode(graph, outEdge, node);\n", "        assertThat(graph.source(outEdge)).isEqualTo(node);\n", "        assertThat(graph.target(outEdge)).isEqualTo(oppositeNode);\n", "      for (Integer adjacentNode : graph.adjacentNodes(node)) {\n", "        Set<String> edges = graph.edgesConnecting(node, adjacentNode);\n", "        Set<String> antiParallelEdges = graph.edgesConnecting(adjacentNode, node);\n"], "3": ["    assertThat(graph.edgesConnecting(N1, N2)).containsExactly(E12);\n", "    assertThat(graph.edgesConnecting(N2, N1)).isEmpty();\n", "    assertThat(graph.inEdges(N2)).containsExactly(E12);\n", "    assertThat(graph.inEdges(N1)).isEmpty();\n", "    assertThat(graph.outEdges(N1)).containsExactly(E12);\n", "    assertThat(graph.outEdges(N2)).isEmpty();\n", "    assertThat(graph.predecessors(N2)).containsExactly(N1);\n", "    assertThat(graph.predecessors(N1)).isEmpty();\n", "    assertThat(graph.successors(N1)).containsExactly(N2);\n", "    assertThat(graph.successors(N2)).isEmpty();\n", "    assertEquals(1, graph.inDegree(N2));\n", "    assertEquals(0, graph.inDegree(N1));\n", "    assertEquals(1, graph.outDegree(N1));\n", "    assertEquals(0, graph.outDegree(N2));\n", "    assertEquals(N1, graph.source(E12));\n", "      graph.source(EDGE_NOT_IN_GRAPH);\n"], "4": ["    assertEquals(N2, graph.target(E12));\n", "      graph.target(EDGE_NOT_IN_GRAPH);\n"], "5": ["    assertThat(graph.edges()).contains(E12);\n", "    assertThat(graph.edgesConnecting(N1, N2)).containsExactly(E12);\n", "    assertThat(graph.edgesConnecting(N2, N1)).isEmpty();\n", "    ImmutableSet<String> edges = ImmutableSet.copyOf(graph.edges());\n", "    assertThat(graph.edges()).containsExactlyElementsIn(edges);\n"], "6": ["    assertTrue(graph.removeEdge(E12));\n", "    assertThat(graph.edges()).doesNotContain(E12);\n", "    assertThat(graph.edgesConnecting(N1, N2)).isEmpty();\n", "    assertThat(graph.toString()).isEqualTo(String.format(\"%s, nodes: %s, edges: {}\",\n", "        getPropertiesString(graph), graph.nodes()));\n", "    assertThat(graph.toString()).isEqualTo(String.format(\"%s, nodes: %s, edges: {}\",\n", "        getPropertiesString(graph), graph.nodes()));\n", "        \"%s, nodes: %s, edges: {%s=<%s -> %s>}\",\n", "        getPropertiesString(graph), graph.nodes(), E12, N1, N2));\n"], "7": ["        \"%s, nodes: %s, edges: {%s=<%s -> %s>, %s=<%s -> %s>}\",\n", "        getPropertiesString(graph),\n"]}, "removed": {"2": [" * Abstract base class for testing implementations of {@link DirectedGraph} interface.\n", " * <p>This class is responsible for testing that an implementation of the interface\n", " * {@code DirectedGraph} is correctly handling directed edges.\n", " * Implementation-dependent test cases are left to subclasses. Test cases that\n", " * do not require the graph to be directed are found in superclasses.\n", "  DirectedGraph<Integer, String> directedGraph;\n", "\n", "  @Override\n", "  public abstract DirectedGraph<Integer, String> createGraph();\n", "\n", "  @Override\n", "  public void init() {\n", "    graph = directedGraph = createGraph();\n", "  }\n", "    for (Integer node : directedGraph.nodes()) {\n", "      for (String inEdge : directedGraph.inEdges(node)) {\n", "        Integer oppositeNode = Graphs.oppositeNode(directedGraph, inEdge, node);\n", "        assertThat(directedGraph.source(inEdge)).isEqualTo(oppositeNode);\n", "        assertThat(directedGraph.target(inEdge)).isEqualTo(node);\n", "      for (String outEdge : directedGraph.outEdges(node)) {\n", "        Integer oppositeNode = Graphs.oppositeNode(directedGraph, outEdge, node);\n", "        assertThat(directedGraph.source(outEdge)).isEqualTo(node);\n", "        assertThat(directedGraph.target(outEdge)).isEqualTo(oppositeNode);\n", "      for (Integer adjacentNode : directedGraph.adjacentNodes(node)) {\n", "        Set<String> edges = directedGraph.edgesConnecting(node, adjacentNode);\n", "        Set<String> antiParallelEdges = directedGraph.edgesConnecting(adjacentNode, node);\n"], "3": ["    assertThat(directedGraph.edgesConnecting(N1, N2)).containsExactly(E12);\n", "    assertThat(directedGraph.edgesConnecting(N2, N1)).isEmpty();\n", "    assertThat(directedGraph.inEdges(N2)).containsExactly(E12);\n", "    assertThat(directedGraph.inEdges(N1)).isEmpty();\n", "    assertThat(directedGraph.outEdges(N1)).containsExactly(E12);\n", "    assertThat(directedGraph.outEdges(N2)).isEmpty();\n", "    assertThat(directedGraph.predecessors(N2)).containsExactly(N1);\n", "    assertThat(directedGraph.predecessors(N1)).isEmpty();\n", "    assertThat(directedGraph.successors(N1)).containsExactly(N2);\n", "    assertThat(directedGraph.successors(N2)).isEmpty();\n", "    assertEquals(1, directedGraph.inDegree(N2));\n", "    assertEquals(0, directedGraph.inDegree(N1));\n", "    assertEquals(1, directedGraph.outDegree(N1));\n", "    assertEquals(0, directedGraph.outDegree(N2));\n", "    assertEquals(N1, directedGraph.source(E12));\n", "      directedGraph.source(EDGE_NOT_IN_GRAPH);\n"], "4": ["    assertEquals(N2, directedGraph.target(E12));\n", "      directedGraph.target(EDGE_NOT_IN_GRAPH);\n"], "5": ["    assertThat(directedGraph.edges()).contains(E12);\n", "    assertThat(directedGraph.edgesConnecting(N1, N2)).containsExactly(E12);\n", "    assertThat(directedGraph.edgesConnecting(N2, N1)).isEmpty();\n", "    ImmutableSet<String> edges = ImmutableSet.copyOf(directedGraph.edges());\n", "    assertThat(directedGraph.edges()).containsExactlyElementsIn(edges);\n"], "6": ["    assertTrue(directedGraph.removeEdge(E12));\n", "    assertThat(directedGraph.edges()).doesNotContain(E12);\n", "    assertThat(directedGraph.edgesConnecting(N1, N2)).isEmpty();\n", "    assertThat(graph.toString()).isEqualTo(String.format(\"config: %s, nodes: %s, edges: {}\",\n", "        graph.config(), graph.nodes()));\n", "    assertThat(graph.toString()).isEqualTo(String.format(\"config: %s, nodes: %s, edges: {}\",\n", "        graph.config(), graph.nodes()));\n", "        \"config: %s, nodes: %s, edges: {%s=<%s -> %s>}\",\n", "        graph.config(), graph.nodes(), E12, N1, N2));\n"], "7": ["        \"config: %s, nodes: %s, edges: {%s=<%s -> %s>, %s=<%s -> %s>}\",\n", "        graph.config(),\n"]}, "added_lines": {"1": [19], "2": [35, 37, 38, 39, 46, 47, 48, 49, 50, 53, 54, 55, 56, 59, 60, 61], "3": [77, 80, 86, 88, 94, 96, 102, 104, 110, 112, 118, 120, 126, 128, 134, 140], "4": [150, 156], "5": [172, 173, 175, 181, 183], "6": [219, 220, 221, 226, 227, 233, 234, 241, 242], "7": [250, 251]}, "removed_lines": {"2": [34, 36, 37, 38, 39, 43, 44, 45, 46, 47, 48, 49, 50, 51, 55, 56, 57, 58, 59, 62, 63, 64, 65, 68, 69, 70], "3": [86, 89, 95, 97, 103, 105, 111, 113, 119, 121, 127, 129, 135, 137, 143, 149], "4": [159, 165], "5": [181, 182, 184, 190, 192], "6": [228, 229, 230, 235, 236, 242, 243, 250, 251], "7": [259, 260]}}, {"2": "guava-tests/test/com/google/common/graph/AbstractGraphTest.java", "added": {"1": ["    new EqualsTester().addEqualityGroup(graph, ImmutableGraph.copyOf(graph)).testEquals();\n"]}, "removed": {"1": ["    new EqualsTester().addEqualityGroup(graph).testEquals();\n"]}, "added_lines": {"1": [150]}, "removed_lines": {"1": [150]}}, {"3": "guava-tests/test/com/google/common/graph/AbstractImmutableDirectedGraphTest.java", "added": {}, "removed": {"1": ["/*\n", " * Copyright (C) 2014 The Guava Authors\n", " *\n", " * Licensed under the Apache License, Version 2.0 (the \"License\");\n", " * you may not use this file except in compliance with the License.\n", " * You may obtain a copy of the License at\n", " *\n", " * http://www.apache.org/licenses/LICENSE-2.0\n", " *\n", " * Unless required by applicable law or agreed to in writing, software\n", " * distributed under the License is distributed on an \"AS IS\" BASIS,\n", " * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n", " * See the License for the specific language governing permissions and\n", " * limitations under the License.\n", " */\n", "\n", "package com.google.common.graph;\n", "\n", "import org.junit.Rule;\n", "import org.junit.Test;\n", "import org.junit.rules.ExpectedException;\n", "\n", "/**\n", " * Abstract base class for testing immutable implementations of the {@link DirectedGraph}\n", " * interface.\n", " *\n", " * <p>This class is testing that all mutation methods called directly\n", " * on the immutable graph will throw {@code UnsupportedOperationException}. Also,\n", " * it tests the builder mutation methods {@code addNode} and {@code addEdge}.\n", " * Any other test cases should be either included in the superclasses or subclasses.\n", " *\n", " */\n", "public abstract class AbstractImmutableDirectedGraphTest extends AbstractDirectedGraphTest {\n", "  @Rule public final ExpectedException expectedException = ExpectedException.none();\n", "\n", "  @Override\n", "  @Test\n", "  public final void nodes_checkReturnedSetMutability() {\n", "    expectedException.expect(UnsupportedOperationException.class);\n", "    graph.nodes().add(N2);\n", "  }\n", "\n", "  @Override\n", "  @Test\n", "  public final void edges_checkReturnedSetMutability() {\n", "    expectedException.expect(UnsupportedOperationException.class);\n", "    graph.edges().add(E12);\n", "  }\n", "\n", "  @Override\n", "  @Test\n", "  public final void incidentEdges_checkReturnedSetMutability() {\n", "    addNode(N1);\n", "    expectedException.expect(UnsupportedOperationException.class);\n", "    graph.incidentEdges(N1).add(E12);\n", "  }\n", "\n", "  @Override\n", "  @Test\n", "  public final void incidentNodes_checkReturnedSetMutability() {\n", "    addEdge(E12, N1, N2);\n", "    expectedException.expect(UnsupportedOperationException.class);\n", "    graph.incidentNodes(E12).add(N2);\n", "  }\n", "\n", "  @Override\n", "  @Test\n", "  public final void adjacentNodes_checkReturnedSetMutability() {\n", "    addNode(N1);\n", "    expectedException.expect(UnsupportedOperationException.class);\n", "    graph.adjacentNodes(N1).add(N2);\n", "  }\n", "\n", "  @Override\n", "  @Test\n", "  public final void adjacentEdges_checkReturnedSetMutability() {\n", "    addEdge(E12, N1, N2);\n", "    expectedException.expect(UnsupportedOperationException.class);\n", "    graph.adjacentEdges(E12).add(E23);\n", "  }\n", "\n", "  @Override\n", "  @Test\n", "  public final void edgesConnecting_checkReturnedSetMutability() {\n", "    addEdge(E12, N1, N2);\n", "    expectedException.expect(UnsupportedOperationException.class);\n", "    graph.edgesConnecting(N1, N2).add(E23);\n", "  }\n", "\n", "  @Override\n", "  @Test\n", "  public final void inEdges_checkReturnedSetMutability() {\n", "    addEdge(E12, N1, N2);\n", "    expectedException.expect(UnsupportedOperationException.class);\n", "    graph.inEdges(N2).add(E23);\n", "  }\n", "\n", "  @Override\n", "  @Test\n", "  public final void outEdges_checkReturnedSetMutability() {\n", "    addEdge(E12, N1, N2);\n", "    expectedException.expect(UnsupportedOperationException.class);\n", "    graph.outEdges(N1).add(E23);\n", "  }\n", "\n", "  @Override\n", "  @Test\n", "  public final void predecessors_checkReturnedSetMutability() {\n", "    addEdge(E12, N1, N2);\n", "    expectedException.expect(UnsupportedOperationException.class);\n", "    graph.predecessors(N2).add(N1);\n", "  }\n", "\n", "  @Override\n", "  @Test\n", "  public final void successors_checkReturnedSetMutability() {\n", "    addEdge(E12, N1, N2);\n", "    expectedException.expect(UnsupportedOperationException.class);\n", "    graph.successors(N1).add(N2);\n", "  }\n", "\n", "  // Builder mutation methods only support addition, not removal, so these tests would fail.\n", "  @Override\n", "  @Test\n", "  public void removeNode_existingNode() {\n", "    expectedException.expect(UnsupportedOperationException.class);\n", "    super.removeNode_existingNode();\n", "  }\n", "\n", "  @Override\n", "  public void removeNode_invalidArgument() {\n", "    expectedException.expect(UnsupportedOperationException.class);\n", "    super.removeNode_invalidArgument();\n", "  }\n", "\n", "  @Override\n", "  @Test\n", "  public void removeEdge_existingEdge() {\n", "    expectedException.expect(UnsupportedOperationException.class);\n", "    super.removeEdge_existingEdge();\n", "  }\n", "\n", "  @Override\n", "  @Test\n", "  public void removeEdge_oneOfMany() {\n", "    expectedException.expect(UnsupportedOperationException.class);\n", "    super.removeEdge_oneOfMany();\n", "  }\n", "\n", "  @Override\n", "  @Test\n", "  public void removeEdge_invalidArgument() {\n", "    expectedException.expect(UnsupportedOperationException.class);\n", "    super.removeEdge_invalidArgument();\n", "  }\n", "\n", "  // Test that adding to the graph directly (as opposed to via the proxy methods) is not supported.\n", "  @Test\n", "  public void addNode_immutable() {\n", "    expectedException.expect(UnsupportedOperationException.class);\n", "    graph.addNode(N3);\n", "  }\n", "\n", "  @Test\n", "  public void addEdge_immutable() {\n", "    expectedException.expect(UnsupportedOperationException.class);\n", "    graph.addEdge(E13, N1, N3);\n", "  }\n", "}\n"]}, "added_lines": {}, "removed_lines": {"1": [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 58, 59, 60, 61, 62, 63, 64, 65, 66, 67, 68, 69, 70, 71, 72, 73, 74, 75, 76, 77, 78, 79, 80, 81, 82, 83, 84, 85, 86, 87, 88, 89, 90, 91, 92, 93, 94, 95, 96, 97, 98, 99, 100, 101, 102, 103, 104, 105, 106, 107, 108, 109, 110, 111, 112, 113, 114, 115, 116, 117, 118, 119, 120, 121, 122, 123, 124, 125, 126, 127, 128, 129, 130, 131, 132, 133, 134, 135, 136, 137, 138, 139, 140, 141, 142, 143, 144, 145, 146, 147, 148, 149, 150, 151, 152, 153, 154, 155, 156, 157, 158, 159, 160, 161, 162, 163, 164, 165, 166, 167, 168, 169]}}, {"4": "guava-tests/test/com/google/common/graph/AbstractImmutableUndirectedGraphTest.java", "added": {}, "removed": {"1": ["/*\n", " * Copyright (C) 2014 The Guava Authors\n", " *\n", " * Licensed under the Apache License, Version 2.0 (the \"License\");\n", " * you may not use this file except in compliance with the License.\n", " * You may obtain a copy of the License at\n", " *\n", " * http://www.apache.org/licenses/LICENSE-2.0\n", " *\n", " * Unless required by applicable law or agreed to in writing, software\n", " * distributed under the License is distributed on an \"AS IS\" BASIS,\n", " * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n", " * See the License for the specific language governing permissions and\n", " * limitations under the License.\n", " */\n", "\n", "package com.google.common.graph;\n", "\n", "import org.junit.Rule;\n", "import org.junit.Test;\n", "import org.junit.rules.ExpectedException;\n", "\n", "/**\n", " * Abstract base class for testing immutable implementations of the {@link UndirectedGraph}\n", " * interface.\n", " *\n", " * <p>This class is testing that all mutation methods called directly\n", " * on the immutable graph will throw {@code UnsupportedOperationException}. Also,\n", " * it tests the builder mutation methods {@code addNode} and {@code addEdge}.\n", " * Any other test cases should be either included in the superclasses or subclasses.\n", " *\n", " */\n", "public abstract class AbstractImmutableUndirectedGraphTest extends AbstractUndirectedGraphTest {\n", "  @Rule public final ExpectedException expectedException = ExpectedException.none();\n", "\n", "  @Override\n", "  @Test\n", "  public final void nodes_checkReturnedSetMutability() {\n", "    expectedException.expect(UnsupportedOperationException.class);\n", "    graph.nodes().add(N2);\n", "  }\n", "\n", "  @Override\n", "  @Test\n", "  public final void edges_checkReturnedSetMutability() {\n", "    expectedException.expect(UnsupportedOperationException.class);\n", "    graph.edges().add(E12);\n", "  }\n", "\n", "  @Override\n", "  @Test\n", "  public final void incidentEdges_checkReturnedSetMutability() {\n", "    addNode(N1);\n", "    expectedException.expect(UnsupportedOperationException.class);\n", "    graph.incidentEdges(N1).add(E12);\n", "  }\n", "\n", "  @Override\n", "  @Test\n", "  public final void incidentNodes_checkReturnedSetMutability() {\n", "    addEdge(E12, N1, N2);\n", "    expectedException.expect(UnsupportedOperationException.class);\n", "    graph.incidentNodes(E12).add(N2);\n", "  }\n", "\n", "  @Override\n", "  @Test\n", "  public final void adjacentNodes_checkReturnedSetMutability() {\n", "    addNode(N1);\n", "    expectedException.expect(UnsupportedOperationException.class);\n", "    graph.adjacentNodes(N1).add(N2);\n", "  }\n", "\n", "  @Override\n", "  @Test\n", "  public final void adjacentEdges_checkReturnedSetMutability() {\n", "    addEdge(E12, N1, N2);\n", "    expectedException.expect(UnsupportedOperationException.class);\n", "    graph.adjacentEdges(E12).add(E23);\n", "  }\n", "\n", "  @Override\n", "  @Test\n", "  public final void edgesConnecting_checkReturnedSetMutability() {\n", "    addEdge(E12, N1, N2);\n", "    expectedException.expect(UnsupportedOperationException.class);\n", "    graph.edgesConnecting(N1, N2).add(E23);\n", "  }\n", "\n", "  @Override\n", "  @Test\n", "  public final void inEdges_checkReturnedSetMutability() {\n", "    addEdge(E12, N1, N2);\n", "    expectedException.expect(UnsupportedOperationException.class);\n", "    graph.inEdges(N2).add(E23);\n", "  }\n", "\n", "  @Override\n", "  @Test\n", "  public final void outEdges_checkReturnedSetMutability() {\n", "    addEdge(E12, N1, N2);\n", "    expectedException.expect(UnsupportedOperationException.class);\n", "    graph.outEdges(N1).add(E23);\n", "  }\n", "\n", "  @Override\n", "  @Test\n", "  public final void predecessors_checkReturnedSetMutability() {\n", "    addEdge(E12, N1, N2);\n", "    expectedException.expect(UnsupportedOperationException.class);\n", "    graph.predecessors(N2).add(N1);\n", "  }\n", "\n", "  @Override\n", "  @Test\n", "  public final void successors_checkReturnedSetMutability() {\n", "    addEdge(E12, N1, N2);\n", "    expectedException.expect(UnsupportedOperationException.class);\n", "    graph.successors(N1).add(N2);\n", "  }\n", "\n", "  // Builder mutation methods only support addition, not removal, so these tests would fail.\n", "  @Override\n", "  @Test\n", "  public void removeNode_existingNode() {\n", "    expectedException.expect(UnsupportedOperationException.class);\n", "    super.removeNode_existingNode();\n", "  }\n", "\n", "  @Override\n", "  @Test\n", "  public void removeNode_invalidArgument() {\n", "    expectedException.expect(UnsupportedOperationException.class);\n", "    super.removeNode_invalidArgument();\n", "  }\n", "\n", "  @Override\n", "  @Test\n", "  public void removeEdge_existingEdge() {\n", "    expectedException.expect(UnsupportedOperationException.class);\n", "    super.removeEdge_existingEdge();\n", "  }\n", "\n", "  @Override\n", "  @Test\n", "  public void removeEdge_oneOfMany() {\n", "    expectedException.expect(UnsupportedOperationException.class);\n", "    super.removeEdge_oneOfMany();\n", "  }\n", "\n", "  @Override\n", "  @Test\n", "  public void removeEdge_invalidArgument() {\n", "    expectedException.expect(UnsupportedOperationException.class);\n", "    super.removeEdge_invalidArgument();\n", "  }\n", "\n", "  // Test that adding to the graph directly (as opposed to via the proxy methods) is not supported.\n", "  @Test\n", "  public void addNode_immutable() {\n", "    expectedException.expect(UnsupportedOperationException.class);\n", "    graph.addNode(N3);\n", "  }\n", "\n", "  @Test\n", "  public void addEdge_immutable() {\n", "    expectedException.expect(UnsupportedOperationException.class);\n", "    graph.addEdge(E13, N1, N3);\n", "  }\n", "}\n"]}, "added_lines": {}, "removed_lines": {"1": [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 58, 59, 60, 61, 62, 63, 64, 65, 66, 67, 68, 69, 70, 71, 72, 73, 74, 75, 76, 77, 78, 79, 80, 81, 82, 83, 84, 85, 86, 87, 88, 89, 90, 91, 92, 93, 94, 95, 96, 97, 98, 99, 100, 101, 102, 103, 104, 105, 106, 107, 108, 109, 110, 111, 112, 113, 114, 115, 116, 117, 118, 119, 120, 121, 122, 123, 124, 125, 126, 127, 128, 129, 130, 131, 132, 133, 134, 135, 136, 137, 138, 139, 140, 141, 142, 143, 144, 145, 146, 147, 148, 149, 150, 151, 152, 153, 154, 155, 156, 157, 158, 159, 160, 161, 162, 163, 164, 165, 166, 167, 168, 169, 170]}}, {"5": "guava-tests/test/com/google/common/graph/AbstractUndirectedGraphTest.java", "added": {"1": ["import static com.google.common.graph.Graphs.getPropertiesString;\n"], "2": [" * Abstract base class for testing undirected implementations of the {@link Graph} interface.\n", " * <p>This class is responsible for testing that an undirected implementation of {@link Graph}\n", " * is correctly handling undirected edges.  Implementation-dependent test cases are left to\n", " * subclasses. Test cases that do not require the graph to be undirected are found in superclasses.\n", "    for (Integer node : graph.nodes()) {\n", "          .addEqualityGroup(graph.inEdges(node), graph.outEdges(node), graph.incidentEdges(node))\n", "          .addEqualityGroup(graph.predecessors(node), graph.successors(node),\n", "              graph.adjacentNodes(node))\n", "      for (Integer adjacentNode : graph.adjacentNodes(node)) {\n", "        assertThat(graph.edgesConnecting(node, adjacentNode))\n", "            .containsExactlyElementsIn(graph.edgesConnecting(adjacentNode, node));\n"], "3": ["    assertThat(graph.edgesConnecting(N1, N2)).containsExactly(E12);\n", "    assertThat(graph.edgesConnecting(N2, N1)).containsExactly(E12);\n", "    assertThat(graph.inEdges(N2)).containsExactly(E12);\n", "    assertThat(graph.inEdges(N1)).containsExactly(E12);\n", "    assertThat(graph.outEdges(N2)).containsExactly(E12);\n", "    assertThat(graph.outEdges(N1)).containsExactly(E12);\n", "    assertThat(graph.predecessors(N2)).containsExactly(N1);\n", "    assertThat(graph.predecessors(N1)).containsExactly(N2);\n", "    assertThat(graph.successors(N1)).containsExactly(N2);\n", "    assertThat(graph.successors(N2)).containsExactly(N1);\n", "    assertEquals(1, graph.inDegree(N2));\n", "    assertEquals(1, graph.inDegree(N1));\n", "    assertEquals(1, graph.outDegree(N1));\n", "    assertEquals(1, graph.outDegree(N2));\n"], "4": ["    assertThat(graph.edges()).contains(E12);\n", "    assertThat(graph.edgesConnecting(N1, N2)).containsExactly(E12);\n", "    assertThat(graph.edgesConnecting(N2, N1)).containsExactly(E12);\n", "    ImmutableSet<String> edges = ImmutableSet.copyOf(graph.edges());\n", "    assertThat(graph.edges()).containsExactlyElementsIn(edges);\n", "    assertThat(graph.edges()).containsExactlyElementsIn(edges);\n"], "5": ["    assertTrue(graph.removeEdge(E12));\n", "    assertThat(graph.edges()).doesNotContain(E12);\n", "    assertThat(graph.edgesConnecting(N1, N2)).isEmpty();\n", "    assertThat(graph.edgesConnecting(N2, N1)).isEmpty();\n", "    assertThat(graph.toString()).isEqualTo(String.format(\"%s, nodes: %s, edges: {}\",\n", "        getPropertiesString(graph), graph.nodes()));\n", "    assertThat(graph.toString()).isEqualTo(String.format(\"%s, nodes: %s, edges: {}\",\n", "        getPropertiesString(graph), graph.nodes()));\n", "        \"%s, nodes: %s, edges: {%s=[%s, %s]}\",\n", "        getPropertiesString(graph), graph.nodes(), E12, N1, N2));\n"], "6": ["        \"%s, nodes: %s, edges: {%s=[%s, %s], %s=[%s, %s]}\",\n", "        getPropertiesString(graph),\n"]}, "removed": {"2": [" * Abstract base class for testing implementations of {@link UndirectedGraph} interface.\n", " *\n", " * <p>This class is responsible for testing that an implementation of the interface\n", " * {@code UndirectedGraph} is correctly handling undirected edges.\n", " * Implementation-dependent test cases are left to subclasses. Test cases that\n", " * do not require the graph to be undirected are found in superclasses.\n", "  UndirectedGraph<Integer, String> undirectedGraph;\n", "\n", "  @Override\n", "  public abstract UndirectedGraph<Integer, String> createGraph();\n", "\n", "  @Override\n", "  public void init() {\n", "    graph = undirectedGraph = createGraph();\n", "  }\n", "    for (Integer node : undirectedGraph.nodes()) {\n", "          .addEqualityGroup(undirectedGraph.inEdges(node), undirectedGraph.outEdges(node),\n", "              undirectedGraph.incidentEdges(node))\n", "          .addEqualityGroup(undirectedGraph.predecessors(node), undirectedGraph.successors(node),\n", "              undirectedGraph.adjacentNodes(node))\n", "      for (Integer adjacentNode : undirectedGraph.adjacentNodes(node)) {\n", "        assertThat(undirectedGraph.edgesConnecting(node, adjacentNode))\n", "            .containsExactlyElementsIn(undirectedGraph.edgesConnecting(adjacentNode, node));\n"], "3": ["    assertThat(undirectedGraph.edgesConnecting(N1, N2)).containsExactly(E12);\n", "    assertThat(undirectedGraph.edgesConnecting(N2, N1)).containsExactly(E12);\n", "    assertThat(undirectedGraph.inEdges(N2)).containsExactly(E12);\n", "    assertThat(undirectedGraph.inEdges(N1)).containsExactly(E12);\n", "    assertThat(undirectedGraph.outEdges(N2)).containsExactly(E12);\n", "    assertThat(undirectedGraph.outEdges(N1)).containsExactly(E12);\n", "    assertThat(undirectedGraph.predecessors(N2)).containsExactly(N1);\n", "    assertThat(undirectedGraph.predecessors(N1)).containsExactly(N2);\n", "    assertThat(undirectedGraph.successors(N1)).containsExactly(N2);\n", "    assertThat(undirectedGraph.successors(N2)).containsExactly(N1);\n", "    assertEquals(1, undirectedGraph.inDegree(N2));\n", "    assertEquals(1, undirectedGraph.inDegree(N1));\n", "    assertEquals(1, undirectedGraph.outDegree(N1));\n", "    assertEquals(1, undirectedGraph.outDegree(N2));\n"], "4": ["    assertThat(undirectedGraph.edges()).contains(E12);\n", "    assertThat(undirectedGraph.edgesConnecting(N1, N2)).containsExactly(E12);\n", "    assertThat(undirectedGraph.edgesConnecting(N2, N1)).containsExactly(E12);\n", "    ImmutableSet<String> edges = ImmutableSet.copyOf(undirectedGraph.edges());\n", "    assertThat(undirectedGraph.edges()).containsExactlyElementsIn(edges);\n", "    assertThat(undirectedGraph.edges()).containsExactlyElementsIn(edges);\n"], "5": ["    assertTrue(undirectedGraph.removeEdge(E12));\n", "    assertThat(undirectedGraph.edges()).doesNotContain(E12);\n", "    assertThat(undirectedGraph.edgesConnecting(N1, N2)).isEmpty();\n", "    assertThat(undirectedGraph.edgesConnecting(N2, N1)).isEmpty();\n", "    assertThat(graph.toString()).isEqualTo(String.format(\"config: %s, nodes: %s, edges: {}\",\n", "        graph.config(), graph.nodes()));\n", "    assertThat(graph.toString()).isEqualTo(String.format(\"config: %s, nodes: %s, edges: {}\",\n", "        graph.config(), graph.nodes()));\n", "        \"config: %s, nodes: %s, edges: {%s=[%s, %s]}\",\n", "        graph.config(), graph.nodes(), E12, N1, N2));\n"], "6": ["        \"config: %s, nodes: %s, edges: {%s=[%s, %s], %s=[%s, %s]}\",\n", "        graph.config(),\n"]}, "added_lines": {"1": [19], "2": [33, 35, 36, 37, 43, 45, 48, 49, 52, 53, 54], "3": [62, 63, 69, 70, 76, 77, 83, 84, 90, 91, 97, 98, 104, 105], "4": [117, 118, 119, 125, 127, 129], "5": [164, 165, 166, 167, 172, 173, 179, 180, 187, 188], "6": [196, 197]}, "removed_lines": {"2": [32, 33, 34, 35, 36, 37, 41, 42, 43, 44, 45, 46, 47, 48, 49, 53, 55, 56, 59, 60, 63, 64, 65], "3": [73, 74, 80, 81, 87, 88, 94, 95, 101, 102, 108, 109, 115, 116], "4": [128, 129, 130, 136, 138, 140], "5": [175, 176, 177, 178, 183, 184, 190, 191, 198, 199], "6": [207, 208]}}, {"6": "guava-tests/test/com/google/common/graph/ConfigurableDirectedGraphTest.java", "added": {"1": ["import static com.google.common.graph.Graphs.getPropertiesString;\n"], "2": [" * Tests for a directed {@link ConfigurableGraph} with default graph properties.\n", "public class ConfigurableDirectedGraphTest extends ConfigurableSimpleDirectedGraphTest {\n", "  public Graph<Integer, String> createGraph() {\n", "    return GraphBuilder.directed().build();\n"], "3": ["    assertThat(graph.edgesConnecting(N1, N1)).containsExactly(E11);\n", "    assertThat(graph.edgesConnecting(N1, N2)).containsExactly(E12);\n", "    assertThat(graph.edgesConnecting(N1, N1)).containsExactly(E11);\n", "    assertThat(graph.inEdges(N1)).containsExactly(E11);\n", "    assertThat(graph.inEdges(N1)).containsExactly(E11, E41);\n", "    assertThat(graph.outEdges(N1)).containsExactly(E11);\n", "    assertThat(graph.outEdges(N1)).containsExactly(E11, E12);\n", "    assertThat(graph.predecessors(N1)).containsExactly(N1);\n", "    assertThat(graph.predecessors(N1)).containsExactly(N1, N4);\n", "    assertThat(graph.successors(N1)).containsExactly(N1);\n", "    assertThat(graph.successors(N1)).containsExactly(N1, N2);\n"], "4": ["    assertEquals(1, graph.inDegree(N1));\n", "    assertEquals(2, graph.inDegree(N1));\n", "    assertEquals(1, graph.outDegree(N1));\n", "    assertEquals(2, graph.outDegree(N1));\n", "    assertEquals(N1, graph.source(E11));\n", "    assertEquals(N1, graph.target(E11));\n"], "5": ["    Graph<Integer, String> graphA = createGraph();\n", "    Graph<Integer, String> graphB = createGraph();\n"], "6": ["        \"%s, nodes: %s, edges: {%s=<%s -> %s>}\",\n", "        getPropertiesString(graph), graph.nodes(), E11, N1, N1));\n"]}, "removed": {"2": [" * Tests for {@link IncidenceSetDirectedGraph} with default graph configuration.\n", " *\n", " * @see GraphConfig\n", "public class IncidenceSetDirectedGraphTest extends IncidenceSetSimpleDirectedGraphTest {\n", "  public DirectedGraph<Integer, String> createGraph() {\n", "    return Graphs.createDirected();\n"], "3": ["    assertThat(directedGraph.edgesConnecting(N1, N1)).containsExactly(E11);\n", "    assertThat(directedGraph.edgesConnecting(N1, N2)).containsExactly(E12);\n", "    assertThat(directedGraph.edgesConnecting(N1, N1)).containsExactly(E11);\n", "    assertThat(directedGraph.inEdges(N1)).containsExactly(E11);\n", "    assertThat(directedGraph.inEdges(N1)).containsExactly(E11, E41);\n", "    assertThat(directedGraph.outEdges(N1)).containsExactly(E11);\n", "    assertThat(directedGraph.outEdges(N1)).containsExactly(E11, E12);\n", "    assertThat(directedGraph.predecessors(N1)).containsExactly(N1);\n", "    assertThat(directedGraph.predecessors(N1)).containsExactly(N1, N4);\n", "    assertThat(directedGraph.successors(N1)).containsExactly(N1);\n", "    assertThat(directedGraph.successors(N1)).containsExactly(N1, N2);\n"], "4": ["    assertEquals(1, directedGraph.inDegree(N1));\n", "    assertEquals(2, directedGraph.inDegree(N1));\n", "    assertEquals(1, directedGraph.outDegree(N1));\n", "    assertEquals(2, directedGraph.outDegree(N1));\n", "    assertEquals(N1, directedGraph.source(E11));\n", "    assertEquals(N1, directedGraph.target(E11));\n"], "5": ["    DirectedGraph<Integer, String> graphA = createGraph();\n", "    DirectedGraph<Integer, String> graphB = createGraph();\n"], "6": ["        \"config: %s, nodes: %s, edges: {%s=<%s -> %s>}\",\n", "        graph.config(), graph.nodes(), E11, N1, N1));\n"]}, "added_lines": {"1": [19], "2": [34, 37, 40, 41], "3": [81, 83, 84, 90, 92, 98, 100, 106, 108, 114, 116], "4": [130, 132, 138, 140, 146, 152], "5": [226, 228], "6": [241, 242]}, "removed_lines": {"2": [33, 34, 35, 38, 41, 42], "3": [82, 84, 85, 91, 93, 99, 101, 107, 109, 115, 117], "4": [131, 133, 139, 141, 147, 153], "5": [227, 229], "6": [242, 243]}}, {"7": "guava-tests/test/com/google/common/graph/ConfigurableDirectedMultigraphTest.java", "added": {"1": ["import static com.google.common.graph.Graphs.getPropertiesString;\n"], "2": [" * Tests for a directed {@link ConfigurableGraph} allowing parallel edges.\n", "public class ConfigurableDirectedMultigraphTest extends ConfigurableDirectedGraphTest {\n", "  public Graph<Integer, String> createGraph() {\n", "    return GraphBuilder.directed().allowsParallelEdges(true).build();\n", "    assertThat(graph.edgesConnecting(N1, N2)).containsExactly(E12, E12_A);\n", "    assertThat(graph.edgesConnecting(N2, N1)).isEmpty();\n", "    assertThat(graph.edgesConnecting(N1, N1)).containsExactly(E11, E11_A);\n"], "3": ["    assertThat(graph.edgesConnecting(N1, N2)).containsExactly(E12, E12_A);\n"], "4": ["    assertThat(graph.edgesConnecting(N1, N1)).containsExactly(E11, E11_A);\n"], "5": ["    assertThat(graph.edgesConnecting(N1, N2)).containsExactly(E12);\n"], "6": ["    assertTrue(graph.removeEdge(E11_A));\n", "    assertThat(graph.edgesConnecting(N1, N1)).containsExactly(E11);\n", "    assertThat(graph.edgesConnecting(N1, N2)).containsExactly(E12);\n", "    assertTrue(graph.removeEdge(E11));\n", "    assertThat(graph.edgesConnecting(N1, N1)).isEmpty();\n", "    assertThat(graph.edgesConnecting(N1, N2)).containsExactly(E12);\n"], "7": ["        \"%s, nodes: %s, edges: {%s=<%s -> %s>, %s=<%s -> %s>, %s=<%s -> %s>, %s=<%s -> %s>}\",\n", "        getPropertiesString(graph),\n"]}, "removed": {"2": [" * Tests for {@link IncidenceSetDirectedGraph} allowing parallel edges.\n", "public class IncidenceSetDirectedMultigraphTest extends IncidenceSetDirectedGraphTest {\n", "  public DirectedGraph<Integer, String> createGraph() {\n", "    return Graphs.createDirected(Graphs.MULTIGRAPH);\n", "    assertThat(directedGraph.edgesConnecting(N1, N2)).containsExactly(E12, E12_A);\n", "    assertThat(directedGraph.edgesConnecting(N2, N1)).isEmpty();\n", "    assertThat(directedGraph.edgesConnecting(N1, N1)).containsExactly(E11, E11_A);\n"], "3": ["    assertThat(directedGraph.edgesConnecting(N1, N2)).containsExactly(E12, E12_A);\n"], "4": ["    assertThat(directedGraph.edgesConnecting(N1, N1)).containsExactly(E11, E11_A);\n"], "5": ["    assertThat(directedGraph.edgesConnecting(N1, N2)).containsExactly(E12);\n"], "6": ["    assertTrue(directedGraph.removeEdge(E11_A));\n", "    assertThat(directedGraph.edgesConnecting(N1, N1)).containsExactly(E11);\n", "    assertThat(directedGraph.edgesConnecting(N1, N2)).containsExactly(E12);\n", "    assertTrue(directedGraph.removeEdge(E11));\n", "    assertThat(directedGraph.edgesConnecting(N1, N1)).isEmpty();\n", "    assertThat(directedGraph.edgesConnecting(N1, N2)).containsExactly(E12);\n"], "7": ["        \"config: %s, nodes: %s, \"\n", "            + \"edges: {%s=<%s -> %s>, %s=<%s -> %s>, %s=<%s -> %s>, %s=<%s -> %s>}\",\n", "        graph.config(),\n"]}, "added_lines": {"1": [19], "2": [28, 31, 33, 34, 41, 44, 51], "3": [59], "4": [67], "5": [75], "6": [83, 84, 85, 86, 87, 88], "7": [98, 99]}, "removed_lines": {"2": [27, 30, 32, 33, 40, 43, 50], "3": [58], "4": [66], "5": [74], "6": [82, 83, 84, 85, 86, 87], "7": [97, 98, 99]}}, {"8": "guava-tests/test/com/google/common/graph/ConfigurableSimpleDirectedGraphTest.java", "added": {"1": [" * Tests for a directed {@link ConfigurableGraph}, creating a simple directed graph (parallel\n", " * and self-loop edges are not allowed).\n", "public class ConfigurableSimpleDirectedGraphTest extends AbstractDirectedGraphTest {\n", "  public Graph<Integer, String> createGraph() {\n", "    return GraphBuilder.directed().allowsSelfLoops(false).build();\n", "    Set<Integer> nodes = graph.nodes();\n", "      assertThat(graph.nodes()).containsExactlyElementsIn(nodes);\n", "    Set<String> edges = graph.edges();\n", "      assertThat(graph.edges()).containsExactlyElementsIn(edges);\n"], "2": ["    Set<String> incidentEdges = graph.incidentEdges(N1);\n", "      assertThat(graph.incidentEdges(N1)).containsExactlyElementsIn(incidentEdges);\n"], "3": ["    Set<Integer> incidentNodes = graph.incidentNodes(E12);\n"], "4": ["    Set<Integer> adjacentNodes = graph.adjacentNodes(N1);\n", "      assertThat(graph.adjacentNodes(N1)).containsExactlyElementsIn(adjacentNodes);\n"], "5": ["    Set<String> adjacentEdges = graph.adjacentEdges(E12);\n", "      assertThat(graph.adjacentEdges(E12)).containsExactlyElementsIn(adjacentEdges);\n"], "6": ["    Set<String> edgesConnecting = graph.edgesConnecting(N1, N2);\n", "      assertThat(graph.edgesConnecting(N1, N2)).containsExactlyElementsIn(edgesConnecting);\n"], "7": ["    Set<String> inEdges = graph.inEdges(N2);\n", "      assertThat(graph.inEdges(N2)).containsExactlyElementsIn(inEdges);\n"], "8": ["    Set<String> outEdges = graph.outEdges(N1);\n", "      assertThat(graph.outEdges(N1)).containsExactlyElementsIn(outEdges);\n"], "9": ["    Set<Integer> predecessors = graph.predecessors(N2);\n", "      assertThat(graph.predecessors(N2)).containsExactlyElementsIn(predecessors);\n"], "10": ["    Set<Integer> successors = graph.successors(N1);\n", "      assertThat(successors).containsExactlyElementsIn(graph.successors(N1));\n"], "11": ["    graph.addNode(N1);\n", "    assertTrue(graph.addEdge(E15, N1, N5));\n", "    assertTrue(graph.addEdge(E41, N4, N1));\n", "    assertTrue(graph.addEdge(E23, N2, N3));\n", "    assertThat(graph.nodes()).containsExactly(N1, N5, N4, N2, N3).inOrder();\n", "    assertThat(graph.edges()).containsExactly(E15, E41, E23).inOrder();\n", "    assertThat(graph.edgesConnecting(N1, N5)).containsExactly(E15);\n", "    assertThat(graph.edgesConnecting(N4, N1)).containsExactly(E41);\n", "    assertThat(graph.edgesConnecting(N2, N3)).containsExactly(E23);\n", "    assertThat(graph.edgesConnecting(N3, N2)).isEmpty();\n"]}, "removed": {"1": [" * Tests for {@link IncidenceSetDirectedGraph}, creating a simple directed graph (parallel and\n", " * self-loop edges are not allowed).\n", "public class IncidenceSetSimpleDirectedGraphTest extends AbstractDirectedGraphTest {\n", "  public DirectedGraph<Integer, String> createGraph() {\n", "    return Graphs.createDirected(Graphs.config().noSelfLoops());\n", "    Set<Integer> nodes = directedGraph.nodes();\n", "      assertThat(directedGraph.nodes()).containsExactlyElementsIn(nodes);\n", "    Set<String> edges = directedGraph.edges();\n", "      assertThat(directedGraph.edges()).containsExactlyElementsIn(edges);\n"], "2": ["    Set<String> incidentEdges = directedGraph.incidentEdges(N1);\n", "      assertThat(directedGraph.incidentEdges(N1)).containsExactlyElementsIn(incidentEdges);\n"], "3": ["    Set<Integer> incidentNodes = directedGraph.incidentNodes(E12);\n"], "4": ["    Set<Integer> adjacentNodes = directedGraph.adjacentNodes(N1);\n", "      assertThat(directedGraph.adjacentNodes(N1)).containsExactlyElementsIn(adjacentNodes);\n"], "5": ["    Set<String> adjacentEdges = directedGraph.adjacentEdges(E12);\n", "      assertThat(directedGraph.adjacentEdges(E12)).containsExactlyElementsIn(adjacentEdges);\n"], "6": ["    Set<String> edgesConnecting = directedGraph.edgesConnecting(N1, N2);\n", "      assertThat(directedGraph.edgesConnecting(N1, N2)).containsExactlyElementsIn(edgesConnecting);\n"], "7": ["    Set<String> inEdges = directedGraph.inEdges(N2);\n", "      assertThat(directedGraph.inEdges(N2)).containsExactlyElementsIn(inEdges);\n"], "8": ["    Set<String> outEdges = directedGraph.outEdges(N1);\n", "      assertThat(directedGraph.outEdges(N1)).containsExactlyElementsIn(outEdges);\n"], "9": ["    Set<Integer> predecessors = directedGraph.predecessors(N2);\n", "      assertThat(directedGraph.predecessors(N2)).containsExactlyElementsIn(predecessors);\n"], "10": ["    Set<Integer> successors = directedGraph.successors(N1);\n", "      assertThat(successors).containsExactlyElementsIn(directedGraph.successors(N1));\n"], "11": ["    directedGraph.addNode(N1);\n", "    assertTrue(directedGraph.addEdge(E15, N1, N5));\n", "    assertTrue(directedGraph.addEdge(E41, N4, N1));\n", "    assertTrue(directedGraph.addEdge(E23, N2, N3));\n", "    assertThat(directedGraph.nodes()).containsExactly(N1, N5, N4, N2, N3).inOrder();\n", "    assertThat(directedGraph.edges()).containsExactly(E15, E41, E23).inOrder();\n", "    assertThat(directedGraph.edgesConnecting(N1, N5)).containsExactly(E15);\n", "    assertThat(directedGraph.edgesConnecting(N4, N1)).containsExactly(E41);\n", "    assertThat(directedGraph.edgesConnecting(N2, N3)).containsExactly(E23);\n", "    assertThat(directedGraph.edgesConnecting(N3, N2)).isEmpty();\n"]}, "added_lines": {"1": [30, 31, 34, 37, 38, 44, 50, 57, 63], "2": [71, 77], "3": [85], "4": [97, 103], "5": [111, 117], "6": [126, 132], "7": [140, 146], "8": [154, 160], "9": [168, 174], "10": [182, 188], "11": [213, 214, 215, 216, 217, 218, 219, 220, 221, 223]}, "removed_lines": {"1": [30, 31, 34, 37, 38, 44, 50, 57, 63], "2": [71, 77], "3": [85], "4": [97, 103], "5": [111, 117], "6": [126, 132], "7": [140, 146], "8": [154, 160], "9": [168, 174], "10": [182, 188], "11": [213, 214, 215, 216, 217, 218, 219, 220, 221, 223]}}, {"9": "guava-tests/test/com/google/common/graph/ConfigurableSimpleUndirectedGraphTest.java", "added": {"1": [" * Tests for an undirected {@link ConfigurableGraph}, creating a simple undirected graph (parallel\n", " * and self-loop edges are not allowed).\n", "public class ConfigurableSimpleUndirectedGraphTest extends AbstractUndirectedGraphTest {\n", "  public Graph<Integer, String> createGraph() {\n", "    return GraphBuilder.undirected().allowsSelfLoops(false).build();\n", "    Set<Integer> nodes = graph.nodes();\n", "      assertThat(graph.nodes()).containsExactlyElementsIn(nodes);\n", "    Set<String> edges = graph.edges();\n", "      assertThat(graph.edges()).containsExactlyElementsIn(edges);\n"], "2": ["    Set<String> incidentEdges = graph.incidentEdges(N1);\n", "      assertThat(graph.incidentEdges(N1)).containsExactlyElementsIn(incidentEdges);\n"], "3": ["    Set<Integer> incidentNodes = graph.incidentNodes(E12);\n"], "4": ["    Set<Integer> adjacentNodes = graph.adjacentNodes(N1);\n", "      assertThat(graph.adjacentNodes(N1)).containsExactlyElementsIn(adjacentNodes);\n"], "5": ["    Set<String> adjacentEdges = graph.adjacentEdges(E12);\n", "      assertThat(graph.adjacentEdges(E12)).containsExactlyElementsIn(adjacentEdges);\n"], "6": ["    Set<String> edgesConnecting = graph.edgesConnecting(N1, N2);\n", "      assertThat(graph.edgesConnecting(N1, N2))\n"], "7": ["    Set<String> inEdges = graph.inEdges(N2);\n", "      assertThat(graph.inEdges(N2)).containsExactlyElementsIn(inEdges);\n"], "8": ["    Set<String> outEdges = graph.outEdges(N1);\n", "      assertThat(graph.outEdges(N1)).containsExactlyElementsIn(outEdges);\n"], "9": ["    Set<Integer> predecessors = graph.predecessors(N2);\n", "      assertThat(graph.predecessors(N2)).containsExactlyElementsIn(predecessors);\n"], "10": ["    Set<Integer> successors = graph.successors(N1);\n", "      assertThat(graph.successors(N1)).containsExactlyElementsIn(successors);\n"], "11": ["    graph.addNode(N1);\n", "    assertTrue(graph.addEdge(E15, N1, N5));\n", "    assertTrue(graph.addEdge(E41, N4, N1));\n", "    assertTrue(graph.addEdge(E23, N2, N3));\n", "    assertThat(graph.nodes()).containsExactly(N1, N5, N4, N2, N3).inOrder();\n", "    assertThat(graph.edges()).containsExactly(E15, E41, E23).inOrder();\n", "    assertThat(graph.edgesConnecting(N1, N5)).containsExactly(E15);\n", "    assertThat(graph.edgesConnecting(N4, N1)).containsExactly(E41);\n", "    assertThat(graph.edgesConnecting(N2, N3)).containsExactly(E23);\n", "    assertThat(graph.edgesConnecting(N3, N2)).containsExactly(E23);\n"]}, "removed": {"1": [" * Tests for {@link IncidenceSetUndirectedGraph}, creating a simple undirected graph (parallel and\n", " * self-loop edges are not allowed).\n", "public class IncidenceSetSimpleUndirectedGraphTest extends AbstractUndirectedGraphTest {\n", "  public UndirectedGraph<Integer, String> createGraph() {\n", "    return Graphs.createUndirected(Graphs.config().noSelfLoops());\n", "    Set<Integer> nodes = undirectedGraph.nodes();\n", "      assertThat(undirectedGraph.nodes()).containsExactlyElementsIn(nodes);\n", "    Set<String> edges = undirectedGraph.edges();\n", "      assertThat(undirectedGraph.edges()).containsExactlyElementsIn(edges);\n"], "2": ["    Set<String> incidentEdges = undirectedGraph.incidentEdges(N1);\n", "      assertThat(undirectedGraph.incidentEdges(N1)).containsExactlyElementsIn(incidentEdges);\n"], "3": ["    Set<Integer> incidentNodes = undirectedGraph.incidentNodes(E12);\n"], "4": ["    Set<Integer> adjacentNodes = undirectedGraph.adjacentNodes(N1);\n", "      assertThat(undirectedGraph.adjacentNodes(N1)).containsExactlyElementsIn(adjacentNodes);\n"], "5": ["    Set<String> adjacentEdges = undirectedGraph.adjacentEdges(E12);\n", "      assertThat(undirectedGraph.adjacentEdges(E12)).containsExactlyElementsIn(adjacentEdges);\n"], "6": ["    Set<String> edgesConnecting = undirectedGraph.edgesConnecting(N1, N2);\n", "      assertThat(undirectedGraph.edgesConnecting(N1, N2))\n"], "7": ["    Set<String> inEdges = undirectedGraph.inEdges(N2);\n", "      assertThat(undirectedGraph.inEdges(N2)).containsExactlyElementsIn(inEdges);\n"], "8": ["    Set<String> outEdges = undirectedGraph.outEdges(N1);\n", "      assertThat(undirectedGraph.outEdges(N1)).containsExactlyElementsIn(outEdges);\n"], "9": ["    Set<Integer> predecessors = undirectedGraph.predecessors(N2);\n", "      assertThat(undirectedGraph.predecessors(N2)).containsExactlyElementsIn(predecessors);\n"], "10": ["    Set<Integer> successors = undirectedGraph.successors(N1);\n", "      assertThat(undirectedGraph.successors(N1)).containsExactlyElementsIn(successors);\n"], "11": ["    undirectedGraph.addNode(N1);\n", "    assertTrue(undirectedGraph.addEdge(E15, N1, N5));\n", "    assertTrue(undirectedGraph.addEdge(E41, N4, N1));\n", "    assertTrue(undirectedGraph.addEdge(E23, N2, N3));\n", "    assertThat(undirectedGraph.nodes()).containsExactly(N1, N5, N4, N2, N3).inOrder();\n", "    assertThat(undirectedGraph.edges()).containsExactly(E15, E41, E23).inOrder();\n", "    assertThat(undirectedGraph.edgesConnecting(N1, N5)).containsExactly(E15);\n", "    assertThat(undirectedGraph.edgesConnecting(N4, N1)).containsExactly(E41);\n", "    assertThat(undirectedGraph.edgesConnecting(N2, N3)).containsExactly(E23);\n", "    assertThat(undirectedGraph.edgesConnecting(N3, N2)).containsExactly(E23);\n"]}, "added_lines": {"1": [30, 31, 34, 37, 38, 44, 50, 57, 63], "2": [71, 77], "3": [85], "4": [97, 103], "5": [111, 117], "6": [126, 132], "7": [141, 147], "8": [155, 161], "9": [169, 175], "10": [183, 189], "11": [214, 215, 216, 217, 218, 219, 220, 221, 222, 223]}, "removed_lines": {"1": [30, 31, 34, 37, 38, 44, 50, 57, 63], "2": [71, 77], "3": [85], "4": [97, 103], "5": [111, 117], "6": [126, 132], "7": [141, 147], "8": [155, 161], "9": [169, 175], "10": [183, 189], "11": [214, 215, 216, 217, 218, 219, 220, 221, 222, 223]}}, {"10": "guava-tests/test/com/google/common/graph/ConfigurableUndirectedGraphTest.java", "added": {"1": ["import static com.google.common.graph.Graphs.getPropertiesString;\n"], "2": [" * Tests for an undirected {@link ConfigurableGraph} with default graph properties.\n", "public class ConfigurableUndirectedGraphTest extends ConfigurableSimpleUndirectedGraphTest {\n", "\n", "  public Graph<Integer, String> createGraph() {\n", "    return GraphBuilder.undirected().build();\n"], "3": ["    assertThat(graph.edgesConnecting(N1, N1)).containsExactly(E11);\n", "    assertThat(graph.edgesConnecting(N1, N2)).containsExactly(E12);\n", "    assertThat(graph.edgesConnecting(N2, N1)).containsExactly(E12);\n", "    assertThat(graph.edgesConnecting(N1, N1)).containsExactly(E11);\n", "    assertThat(graph.inEdges(N1)).containsExactly(E11);\n", "    assertThat(graph.inEdges(N1)).containsExactly(E11, E12);\n", "    assertThat(graph.outEdges(N1)).containsExactly(E11);\n", "    assertThat(graph.outEdges(N1)).containsExactly(E11, E12);\n", "    assertThat(graph.predecessors(N1)).containsExactly(N1);\n", "    assertThat(graph.predecessors(N1)).containsExactly(N1, N2);\n", "    assertThat(graph.successors(N1)).containsExactly(N1);\n", "    assertThat(graph.successors(N1)).containsExactly(N1, N2);\n"], "4": ["    assertEquals(1, graph.inDegree(N1));\n", "    assertEquals(2, graph.inDegree(N1));\n", "    assertEquals(1, graph.outDegree(N1));\n", "    assertEquals(2, graph.outDegree(N1));\n"], "5": ["    Graph<Integer, String> graphA = createGraph();\n", "    Graph<Integer, String> graphB = createGraph();\n"], "6": ["        \"%s, nodes: %s, edges: {%s=[%s]}\",\n", "        getPropertiesString(graph), graph.nodes(), E11, N1));\n"]}, "removed": {"2": [" * Tests for {@link IncidenceSetUndirectedGraph} with default graph configuration.\n", " *\n", " * @see GraphConfig\n", "public class IncidenceSetUndirectedGraphTest extends IncidenceSetSimpleUndirectedGraphTest {\n", "  public UndirectedGraph<Integer, String> createGraph() {\n", "    return Graphs.createUndirected();\n"], "3": ["    assertThat(undirectedGraph.edgesConnecting(N1, N1)).containsExactly(E11);\n", "    assertThat(undirectedGraph.edgesConnecting(N1, N2)).containsExactly(E12);\n", "    assertThat(undirectedGraph.edgesConnecting(N2, N1)).containsExactly(E12);\n", "    assertThat(undirectedGraph.edgesConnecting(N1, N1)).containsExactly(E11);\n", "    assertThat(undirectedGraph.inEdges(N1)).containsExactly(E11);\n", "    assertThat(undirectedGraph.inEdges(N1)).containsExactly(E11, E12);\n", "    assertThat(undirectedGraph.outEdges(N1)).containsExactly(E11);\n", "    assertThat(undirectedGraph.outEdges(N1)).containsExactly(E11, E12);\n", "    assertThat(undirectedGraph.predecessors(N1)).containsExactly(N1);\n", "    assertThat(undirectedGraph.predecessors(N1)).containsExactly(N1, N2);\n", "    assertThat(undirectedGraph.successors(N1)).containsExactly(N1);\n", "    assertThat(undirectedGraph.successors(N1)).containsExactly(N1, N2);\n"], "4": ["    assertEquals(1, undirectedGraph.inDegree(N1));\n", "    assertEquals(2, undirectedGraph.inDegree(N1));\n", "    assertEquals(1, undirectedGraph.outDegree(N1));\n", "    assertEquals(2, undirectedGraph.outDegree(N1));\n"], "5": ["    UndirectedGraph<Integer, String> graphA = createGraph();\n", "    UndirectedGraph<Integer, String> graphB = createGraph();\n"], "6": ["        \"config: %s, nodes: %s, edges: {%s=[%s]}\",\n", "        graph.config(), graph.nodes(), E11, N1));\n"]}, "added_lines": {"1": [19], "2": [34, 37, 38, 40, 41], "3": [81, 83, 84, 85, 91, 93, 99, 101, 107, 109, 115, 117], "4": [131, 133, 139, 141], "5": [215, 217], "6": [230, 231]}, "removed_lines": {"2": [33, 34, 35, 38, 40, 41], "3": [81, 83, 84, 85, 91, 93, 99, 101, 107, 109, 115, 117], "4": [131, 133, 139, 141], "5": [215, 217], "6": [230, 231]}}, {"11": "guava-tests/test/com/google/common/graph/ConfigurableUndirectedMultigraphTest.java", "added": {"1": ["import static com.google.common.graph.Graphs.getPropertiesString;\n"], "2": [" * Tests for an undirected {@link ConfigurableGraph} allowing parallel edges.\n", "public class ConfigurableUndirectedMultigraphTest extends ConfigurableUndirectedGraphTest {\n", "  public Graph<Integer, String> createGraph() {\n", "    return GraphBuilder.undirected().allowsParallelEdges(true).build();\n"], "3": ["    assertThat(graph.edgesConnecting(N1, N2)).containsExactly(E12, E12_A, E21);\n", "    assertThat(graph.edgesConnecting(N2, N1)).containsExactly(E12, E12_A, E21);\n", "    assertThat(graph.edgesConnecting(N1, N1)).containsExactly(E11, E11_A);\n"], "4": ["    assertThat(graph.edgesConnecting(N1, N2)).containsExactly(E12, E12_A, E21);\n"], "5": ["    assertThat(graph.edgesConnecting(N1, N1)).containsExactly(E11, E11_A);\n"], "6": ["    assertThat(graph.edgesConnecting(N1, N2)).containsExactly(E12, E21);\n"], "7": ["    assertTrue(graph.removeEdge(E11_A));\n", "    assertThat(graph.edgesConnecting(N1, N1)).containsExactly(E11);\n", "    assertThat(graph.edgesConnecting(N1, N2)).containsExactly(E12);\n", "    assertTrue(graph.removeEdge(E11));\n", "    assertThat(graph.edgesConnecting(N1, N1)).isEmpty();\n", "    assertThat(graph.edgesConnecting(N1, N2)).containsExactly(E12);\n"], "8": ["        \"%s, nodes: %s, edges: {%s=[%s, %s], %s=[%s, %s], %s=[%s], %s=[%s]}\",\n", "        getPropertiesString(graph),\n"]}, "removed": {"2": [" * Tests for {@link IncidenceSetUndirectedGraph} allowing parallel edges.\n", "public class IncidenceSetUndirectedMultigraphTest extends IncidenceSetUndirectedGraphTest {\n", "  public UndirectedGraph<Integer, String> createGraph() {\n", "    return Graphs.createUndirected(Graphs.MULTIGRAPH);\n"], "3": ["    assertThat(undirectedGraph.edgesConnecting(N1, N2)).containsExactly(E12, E12_A, E21);\n", "    assertThat(undirectedGraph.edgesConnecting(N2, N1)).containsExactly(E12, E12_A, E21);\n", "    assertThat(undirectedGraph.edgesConnecting(N1, N1)).containsExactly(E11, E11_A);\n"], "4": ["    assertThat(undirectedGraph.edgesConnecting(N1, N2)).containsExactly(E12, E12_A, E21);\n"], "5": ["    assertThat(undirectedGraph.edgesConnecting(N1, N1)).containsExactly(E11, E11_A);\n"], "6": ["    assertThat(undirectedGraph.edgesConnecting(N1, N2)).containsExactly(E12, E21);\n"], "7": ["    assertTrue(undirectedGraph.removeEdge(E11_A));\n", "    assertThat(undirectedGraph.edgesConnecting(N1, N1)).containsExactly(E11);\n", "    assertThat(undirectedGraph.edgesConnecting(N1, N2)).containsExactly(E12);\n", "    assertTrue(undirectedGraph.removeEdge(E11));\n", "    assertThat(undirectedGraph.edgesConnecting(N1, N1)).isEmpty();\n", "    assertThat(undirectedGraph.edgesConnecting(N1, N2)).containsExactly(E12);\n"], "8": ["        \"config: %s, nodes: %s, edges: {%s=[%s, %s], %s=[%s, %s], %s=[%s], %s=[%s]}\",\n", "        graph.config(),\n"]}, "added_lines": {"1": [19], "2": [28, 31, 33, 34], "3": [42, 43, 50], "4": [59], "5": [67], "6": [76], "7": [84, 85, 86, 87, 88, 89], "8": [99, 100]}, "removed_lines": {"2": [27, 30, 32, 33], "3": [41, 42, 49], "4": [58], "5": [66], "6": [75], "7": [83, 84, 85, 86, 87, 88], "8": [98, 99]}}, {"12": "guava-tests/test/com/google/common/graph/GraphConfigTest.java", "added": {}, "removed": {"1": ["/*\n", " * Copyright (C) 2015 The Guava Authors\n", " *\n", " * Licensed under the Apache License, Version 2.0 (the \"License\");\n", " * you may not use this file except in compliance with the License.\n", " * You may obtain a copy of the License at\n", " *\n", " * http://www.apache.org/licenses/LICENSE-2.0\n", " *\n", " * Unless required by applicable law or agreed to in writing, software\n", " * distributed under the License is distributed on an \"AS IS\" BASIS,\n", " * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n", " * See the License for the specific language governing permissions and\n", " * limitations under the License.\n", " */\n", "\n", "package com.google.common.graph;\n", "\n", "import static com.google.common.truth.Truth.assertThat;\n", "\n", "import com.google.common.testing.EqualsTester;\n", "\n", "import org.junit.Test;\n", "import org.junit.runner.RunWith;\n", "import org.junit.runners.JUnit4;\n", "\n", "@RunWith(JUnit4.class)\n", "public final class GraphConfigTest {\n", "\n", "  @Test\n", "  public void testEquals() throws Exception {\n", "    GraphConfig configA1 = Graphs.config().expectedNodeCount(5);\n", "    GraphConfig configA2 = Graphs.config().expectedNodeCount(5);\n", "\n", "    GraphConfig configB = Graphs.config().expectedNodeCount(10);\n", "\n", "    new EqualsTester()\n", "        .addEqualityGroup(configA1, configA2)\n", "        .addEqualityGroup(configB)\n", "        .testEquals();\n", "  }\n", "\n", "  @Test\n", "  public void toString_selfLoops() {\n", "    assertThat(Graphs.config().toString())\n", "        .isEqualTo(\"self-loops allowed\");\n", "  }\n", "\n", "  @Test\n", "  public void toString_noSelfLoops() {\n", "    assertThat(Graphs.config().noSelfLoops().toString())\n", "        .isEqualTo(\"self-loops disallowed\");\n", "  }\n", "\n", "  @Test\n", "  public void toString_selfLoops_multigraph() {\n", "    assertThat(Graphs.config().multigraph().toString())\n", "        .isEqualTo(\"multigraph,self-loops allowed\");\n", "  }\n", "\n", "  @Test\n", "  public void toString_noSelfLoops_multigraph() {\n", "    assertThat(Graphs.config().noSelfLoops().multigraph().toString())\n", "        .isEqualTo(\"multigraph,self-loops disallowed\");\n", "  }\n", "\n", "  @Test\n", "  public void compatibleWith_default() {\n", "    assertThat(Graphs.config().compatibleWith(Graphs.config())).isTrue();\n", "  }\n", "\n", "  @Test\n", "  public void compatibleWith_multigraph_compatible() {\n", "    assertThat(Graphs.config().multigraph().compatibleWith(\n", "        Graphs.config().multigraph())).isTrue();\n", "\n", "    assertThat(Graphs.config().multigraph().compatibleWith(\n", "      Graphs.config())).isTrue();\n", "  }\n", "\n", "  @Test\n", "  public void compatibleWith_multigraph_incompatible() {\n", "    assertThat(Graphs.config().compatibleWith(\n", "        Graphs.config().multigraph())).isFalse();\n", "  }\n", "\n", "  @Test\n", "  public void compatibleWith_selfLoops_compatible() {\n", "    assertThat(Graphs.config().noSelfLoops().compatibleWith(\n", "        Graphs.config().noSelfLoops())).isTrue();\n", "\n", "    assertThat(Graphs.config().compatibleWith(\n", "        Graphs.config().noSelfLoops())).isTrue();\n", "  }\n", "\n", "  @Test\n", "  public void compatibleWith_selfLoops_incompatible() {\n", "    assertThat(Graphs.config().noSelfLoops().compatibleWith(\n", "        Graphs.config())).isFalse();\n", "  }\n", "}\n"]}, "added_lines": {}, "removed_lines": {"1": [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 58, 59, 60, 61, 62, 63, 64, 65, 66, 67, 68, 69, 70, 71, 72, 73, 74, 75, 76, 77, 78, 79, 80, 81, 82, 83, 84, 85, 86, 87, 88, 89, 90, 91, 92, 93, 94, 95, 96, 97, 98, 99, 100, 101]}}, {"13": "guava-tests/test/com/google/common/graph/GraphEqualsTest.java", "added": {"2": ["    this.graph = createGraph(graphType);\n", "  private static Graph<Integer, String> createGraph(GraphType graphType) {\n", "    switch (graphType) {\n", "      case UNDIRECTED:\n", "        return GraphBuilder.undirected().build();\n", "      case DIRECTED:\n", "        return GraphBuilder.directed().build();\n", "      default:\n", "        throw new IllegalStateException(\"Unexpected graph type: \" + graphType);\n", "    }\n", "  private static GraphType oppositeType(GraphType graphType) {\n", "        return GraphType.DIRECTED;\n", "        return GraphType.UNDIRECTED;\n"], "3": ["    Graph<Integer, String> g2 = createGraph(graphType);\n"], "4": ["    Graph<Integer, String> g2 = createGraph(graphType);\n"], "5": ["    Graph<Integer, String> g2 = createGraph(oppositeType(graphType));\n"], "6": ["    Graph<Integer, String> g2 = createGraph(oppositeType(graphType));\n"], "7": ["    Graph<Integer, String> g2 = createGraph(graphType);\n"], "8": ["  // Node/edge sets and node/edge connections are the same, but graph properties differ.\n", "  // (In this case the graphs are considered equal; the property differences are irrelevant.)\n", "  public void equals_propertiesDiffer() {\n", "    Graph<Integer, String> g2 = GraphBuilder.from(graph)\n", "        .allowsParallelEdges(!graph.allowsParallelEdges())\n", "        .allowsSelfLoops(!graph.allowsSelfLoops())\n", "        .build();\n"], "9": ["    GraphBuilder<Integer, String> builder = GraphBuilder.from(graph).allowsParallelEdges(true);\n", "    Graph<Integer, String> g1 = builder.build();\n", "    Graph<Integer, String> g2 = builder.build();\n"], "10": ["    Graph<Integer, String> g2 = createGraph(graphType);\n"]}, "removed": {"1": ["import static com.google.common.graph.Graphs.MULTIGRAPH;\n", "\n"], "2": ["    this.graph = createGraph();\n", "  private Graph<Integer, String> createGraph() {\n", "    return createGraph(Graphs.config());\n", "  private Graph<Integer, String> createGraph(GraphConfig config) {\n", "        return Graphs.createUndirected(config);\n", "        return Graphs.createDirected(config);\n"], "3": ["    Graph<Integer, String> g2 = createGraph();\n"], "4": ["    Graph<Integer, String> g2 = createGraph();\n"], "5": ["    Graph<Integer, String> g2;\n", "    switch (graphType) {\n", "      case UNDIRECTED:\n", "        g2 = Graphs.createDirected();\n", "        break;\n", "      case DIRECTED:\n", "        g2 = Graphs.createUndirected();\n", "        break;\n", "      default:\n", "        throw new IllegalStateException(\"Unexpected graph type: \" + graphType);\n", "    }\n", "\n"], "6": ["    Graph<Integer, String> g2;\n", "    switch (graphType) {\n", "      case UNDIRECTED:\n", "        g2 = Graphs.createDirected();\n", "        break;\n", "      case DIRECTED:\n", "        g2 = Graphs.createUndirected();\n", "        break;\n", "      default:\n", "        throw new IllegalStateException(\"Unexpected graph type: \" + graphType);\n", "    }\n", "\n"], "7": ["    Graph<Integer, String> g2 = createGraph();\n"], "8": ["  // Node/edge sets and node/edge connections are the same, but GraphConfigs differ.\n", "  // (In this case the graphs are considered equal; the config differences are irrelevant.)\n", "  public void equals_configsDiffer() {\n", "    Graph<Integer, String> g2 = createGraph(MULTIGRAPH.noSelfLoops());\n"], "9": ["    Graph<Integer, String> g1 = createGraph(MULTIGRAPH);\n", "    Graph<Integer, String> g2 = createGraph(MULTIGRAPH);\n"], "10": ["    Graph<Integer, String> g2 = createGraph();\n"]}, "added_lines": {"2": [59, 62, 63, 64, 65, 66, 67, 68, 69, 70, 73, 76, 78], "3": [88], "4": [99], "5": [110], "6": [122], "7": [134], "8": [142, 143, 145, 148, 149, 150, 151], "9": [161, 162, 163], "10": [180]}, "removed_lines": {"1": [19, 20], "2": [61, 64, 65, 68, 71, 73], "3": [83], "4": [94], "5": [105, 106, 107, 108, 109, 110, 111, 112, 113, 114, 115, 116], "6": [128, 129, 130, 131, 132, 133, 134, 135, 136, 137, 138, 139], "7": [151], "8": [159, 160, 162, 165], "9": [175, 176], "10": [193]}}, {"14": "guava-tests/test/com/google/common/graph/GraphPropertiesTest.java", "added": {"2": ["    Graph<Integer, String> directedGraph = GraphBuilder.directed().build();\n", "    Graph<Integer, String> directedGraph = GraphBuilder.directed().build();\n"], "3": ["    Graph<Integer, String> directedGraph = GraphBuilder.directed().build();\n", "    Graph<Integer, String> directedGraph = GraphBuilder.directed().build();\n", "    Graph<Integer, String> directedGraph =\n", "        GraphBuilder.directed().allowsParallelEdges(true).build();\n"], "4": ["    Graph<Integer, String> directedGraph = GraphBuilder.directed().build();\n"], "5": ["    Graph<Integer, String> directedGraph = GraphBuilder.directed().build();\n"], "6": ["    Graph<Integer, String> directedGraph = GraphBuilder.directed().build();\n"], "7": ["    Graph<Integer, String> directedGraph = GraphBuilder.directed().build();\n"], "8": ["    Graph<Integer, String> directedGraph = GraphBuilder.directed().build();\n"], "9": ["    Graph<Integer, String> directedGraph =\n", "        GraphBuilder.directed().allowsParallelEdges(true).build();\n"], "10": ["    Graph<Integer, String> directedGraph =\n", "        GraphBuilder.directed().allowsParallelEdges(true).build();\n"], "11": ["    Graph<Integer, String> directedGraph = GraphBuilder.directed().build();\n", "    Graph<Integer, String> directedGraph = GraphBuilder.directed().build();\n", "    Graph<Integer, String> directedGraph = GraphBuilder.directed().build();\n"], "12": ["    Graph<Integer, String> directedGraph = GraphBuilder.directed().build();\n"], "13": ["    Graph<Integer, String> directedGraph = GraphBuilder.directed().build();\n"], "14": ["    Graph<Integer, String> directedGraph = GraphBuilder.directed().build();\n"]}, "removed": {"1": ["import static com.google.common.graph.Graphs.config;\n"], "2": ["    DirectedGraph<Integer, String> directedGraph = Graphs.createDirected();\n", "    DirectedGraph<Integer, String> directedGraph = Graphs.createDirected();\n"], "3": ["    DirectedGraph<Integer, String> directedGraph = Graphs.createDirected();\n", "    DirectedGraph<Integer, String> directedGraph = Graphs.createDirected();\n", "    DirectedGraph<Integer, String> directedGraph = Graphs.createDirected(config().multigraph());\n"], "4": ["    DirectedGraph<Integer, String> directedGraph = Graphs.createDirected();\n"], "5": ["    DirectedGraph<Integer, String> directedGraph = Graphs.createDirected();\n"], "6": ["    DirectedGraph<Integer, String> directedGraph = Graphs.createDirected();\n"], "7": ["    DirectedGraph<Integer, String> directedGraph = Graphs.createDirected();\n"], "8": ["    DirectedGraph<Integer, String> directedGraph = Graphs.createDirected();\n"], "9": ["    DirectedGraph<Integer, String> directedGraph = Graphs.createDirected(config().multigraph());\n"], "10": ["    DirectedGraph<Integer, String> directedGraph = Graphs.createDirected(config().multigraph());\n"], "11": ["    DirectedGraph<Integer, String> directedGraph = Graphs.createDirected();\n", "    DirectedGraph<Integer, String> directedGraph = Graphs.createDirected();\n", "    DirectedGraph<Integer, String> directedGraph = Graphs.createDirected();\n"], "12": ["    DirectedGraph<Integer, String> directedGraph = Graphs.createDirected();\n"], "13": ["    DirectedGraph<Integer, String> directedGraph = Graphs.createDirected();\n"], "14": ["    DirectedGraph<Integer, String> directedGraph = Graphs.createDirected();\n"]}, "added_lines": {"2": [47, 53], "3": [62, 69, 76, 77], "4": [85], "5": [93], "6": [101], "7": [110], "8": [119], "9": [128, 129], "10": [139, 140], "11": [150, 156, 163], "12": [171], "13": [179], "14": [187]}, "removed_lines": {"1": [21], "2": [48, 54], "3": [63, 70, 77], "4": [85], "5": [93], "6": [101], "7": [110], "8": [119], "9": [128], "10": [138], "11": [148, 154, 161], "12": [169], "13": [177], "14": [185]}}, {"15": "guava-tests/test/com/google/common/graph/GraphsTest.java", "added": {"2": ["        GraphBuilder.directed().<Integer, String>build(),\n", "        GraphBuilder.undirected().<Integer, String>build());\n"], "3": ["        GraphBuilder.directed().allowsParallelEdges(true).<Integer, String>build(),\n", "        GraphBuilder.undirected().allowsParallelEdges(true).<Integer, String>build());\n"], "4": ["        GraphBuilder.directed().<Integer, String>build(),\n", "        GraphBuilder.undirected().<Integer, String>build());\n"], "5": ["        GraphBuilder.directed().<Integer, String>build(),\n", "        GraphBuilder.undirected().<Integer, String>build());\n"], "6": ["    Graph<Integer, String> directedGraph =\n", "        GraphBuilder.directed().allowsParallelEdges(true).build();\n"], "7": ["    Graph<Integer, String> directedGraph =\n", "        GraphBuilder.directed().allowsParallelEdges(true).build();\n"], "8": ["    Graph<Integer, String> undirectedGraph =\n", "        GraphBuilder.undirected().allowsParallelEdges(true).build();\n"], "9": ["    Graph<Integer, String> undirectedGraph =\n", "        GraphBuilder.undirected().allowsParallelEdges(true).build();\n"], "10": ["    Graph<Integer, String> undirectedGraph =\n", "        GraphBuilder.undirected().allowsParallelEdges(true).build();\n"], "11": ["    Graph<Integer, String> directedGraph = GraphBuilder.directed().build();\n"], "12": ["    Graph<Integer, String> undirectedGraph = GraphBuilder.undirected().build();\n"], "13": ["    Graph<Integer, String> directedMultigraph =\n", "        GraphBuilder.directed().allowsParallelEdges(true).build();\n"], "14": ["    Graph<Integer, String> undirectedMultigraph =\n", "        GraphBuilder.undirected().allowsParallelEdges(true).build();\n"], "15": ["    Graph<Integer, String> directedGraph = GraphBuilder.directed()\n", "        .expectedNodeCount(NODE_COUNT)\n", "        .build();\n"], "16": ["    Graph<Integer, String> undirectedGraph = GraphBuilder.undirected()\n", "        .expectedNodeCount(NODE_COUNT)\n", "        .build();\n", "  public void builder_expectedNodeCount_negative() {\n", "      GraphBuilder.directed().expectedNodeCount(-1);\n", "    Graph<Integer, String> directedGraph = GraphBuilder.directed()\n", "        .expectedEdgeCount(EDGE_COUNT)\n", "        .build();\n"], "17": ["    Graph<Integer, String> undirectedGraph = GraphBuilder.undirected()\n", "        .expectedEdgeCount(EDGE_COUNT)\n", "        .build();\n", "  public void builder_expectedEdgeCount_negative() {\n", "      GraphBuilder.directed().expectedEdgeCount(-1);\n", "    Graph<Integer, String> directedGraph = GraphBuilder.directed().allowsSelfLoops(false).build();\n"], "18": ["    Graph<Integer, String> undirectedGraph =\n", "        GraphBuilder.undirected().allowsSelfLoops(false).build();\n"], "20": ["      addEdge(GraphBuilder.directed().build(), E11, null);\n"], "21": ["      addEdge(GraphBuilder.directed().<Integer, String>build(), E11, ImmutableSet.of(N1, N2, N3));\n"], "22": ["      addEdge(GraphBuilder.directed().build(), E11, ImmutableSet.of());\n"], "23": ["    Graph<Integer, String> directedGraph = GraphBuilder.directed().build();\n"], "24": ["    Graph<Integer, String> directedGraph = GraphBuilder.directed().build();\n"], "25": ["      copyOf(null);\n"], "26": ["    Graph<Integer, String> directedGraph = buildDirectedTestGraph();\n", "    Graph<Integer, String> copy = copyOf(directedGraph);\n", "    Graph<Integer, String> undirectedGraph = buildUndirectedTestGraph();\n", "    Graph<Integer, String> copy = copyOf(undirectedGraph);\n"], "27": ["    Graph<Integer, String> undirectedGraph = buildUndirectedTestGraph();\n", "    Graph<Integer, String> filteredCopy =\n", "    Graph<Integer, String> expectedGraph =\n", "        GraphBuilder.undirected().allowsParallelEdges(true).build();\n"], "28": ["    Graph<Integer, String> directedGraph = buildDirectedTestGraph();\n", "    Graph<Integer, String> filteredCopy =\n", "    Graph<Integer, String> expectedGraph =\n", "        GraphBuilder.directed().allowsParallelEdges(true).build();\n"], "29": ["    Graph<Integer, String> directedGraph = buildDirectedTestGraph();\n", "    Graph<Integer, String> actualGraph = GraphBuilder.directed().build();\n", "    Graph<Integer, String> expectedGraph = GraphBuilder.directed().build();\n"], "30": ["    Graph<Integer, String> directedGraph = buildDirectedTestGraph();\n", "    Graph<Integer, String> actualGraph = GraphBuilder.directed().build();\n", "    Graph<Integer, String> expectedGraph = GraphBuilder.directed().build();\n"], "31": ["    Graph<Integer, String> directedGraph = buildDirectedTestGraph();\n", "    Graph<Integer, String> actualGraph = GraphBuilder.directed().allowsParallelEdges(true).build();\n", "    Graph<Integer, String> expectedGraph = buildDirectedTestGraph();\n"], "32": ["    Graph<Integer, String> directedGraph = buildDirectedTestGraph();\n", "    Graph<Integer, String> actualGraph = GraphBuilder.directed().allowsParallelEdges(true).build();\n"], "33": ["    Graph<Integer, String> expectedGraph =\n", "        GraphBuilder.directed().allowsParallelEdges(true).build();\n"], "34": ["    Graph<Integer, String> undirectedGraph = buildUndirectedTestGraph();\n", "    Graph<Integer, String> actualGraph = GraphBuilder.undirected().build();\n", "    Graph<Integer, String> expectedGraph = GraphBuilder.undirected().build();\n"], "35": ["    Graph<Integer, String> undirectedGraph = buildUndirectedTestGraph();\n", "    Graph<Integer, String> actualGraph = GraphBuilder.undirected().build();\n", "    Graph<Integer, String> expectedGraph = GraphBuilder.undirected().build();\n"], "36": ["    Graph<Integer, String> undirectedGraph = buildUndirectedTestGraph();\n", "    Graph<Integer, String> actualGraph =\n", "        GraphBuilder.undirected().allowsParallelEdges(true).build();\n", "    Graph<Integer, String> expectedGraph = buildUndirectedTestGraph();\n"], "37": ["    Graph<Integer, String> undirectedGraph = buildUndirectedTestGraph();\n", "    Graph<Integer, String> actualGraph =\n", "        GraphBuilder.undirected().allowsParallelEdges(true).build();\n"], "38": ["    Graph<Integer, String> expectedGraph =\n", "        GraphBuilder.undirected().allowsParallelEdges(true).build();\n"], "39": ["  private static Graph<Integer, String> buildDirectedTestGraph() {\n", "    Graph<Integer, String> directedGraph =\n", "        GraphBuilder.directed().allowsParallelEdges(true).build();\n"], "40": ["  private static Graph<Integer, String> buildUndirectedTestGraph() {\n", "    Graph<Integer, String> undirectedGraph =\n", "        GraphBuilder.undirected().allowsParallelEdges(true).build();\n"]}, "removed": {"1": ["import static com.google.common.graph.Graphs.MULTIGRAPH;\n", "import static com.google.common.graph.Graphs.config;\n"], "2": ["        Graphs.<Integer, String>createDirected(), Graphs.<Integer, String>createUndirected());\n"], "3": ["        Graphs.<Integer, String>createDirected(MULTIGRAPH),\n", "        Graphs.<Integer, String>createUndirected(MULTIGRAPH));\n"], "4": ["        Graphs.<Integer, String>createDirected(), Graphs.<Integer, String>createUndirected());\n"], "5": ["        Graphs.<Integer, String>createDirected(), Graphs.<Integer, String>createUndirected());\n"], "6": ["    DirectedGraph<Integer, String> directedGraph = Graphs.createDirected(MULTIGRAPH);\n"], "7": ["    DirectedGraph<Integer, String> directedGraph = Graphs.createDirected(MULTIGRAPH);\n"], "8": ["    UndirectedGraph<Integer, String> undirectedGraph = Graphs.createUndirected(MULTIGRAPH);\n"], "9": ["    UndirectedGraph<Integer, String> undirectedGraph = Graphs.createUndirected(MULTIGRAPH);\n"], "10": ["    UndirectedGraph<Integer, String> undirectedGraph = Graphs.createUndirected(MULTIGRAPH);\n"], "11": ["    DirectedGraph<Integer, String> directedGraph = Graphs.createDirected();\n"], "12": ["    UndirectedGraph<Integer, String> undirectedGraph = Graphs.createUndirected();\n"], "13": ["    DirectedGraph<Integer, String> directedMultigraph =\n", "        Graphs.createDirected(config().multigraph());\n"], "14": ["    UndirectedGraph<Integer, String> undirectedMultigraph =\n", "        Graphs.createUndirected(Graphs.MULTIGRAPH);\n"], "15": ["    DirectedGraph<Integer, String> directedGraph =\n", "        Graphs.createDirected(config().expectedNodeCount(NODE_COUNT));\n"], "16": ["    UndirectedGraph<Integer, String> undirectedGraph =\n", "        Graphs.createUndirected(config().expectedNodeCount(NODE_COUNT));\n", "  public void config_expectedNodeCount_negative() {\n", "      config().expectedNodeCount(-1);\n", "  @Test\n", "  public void config_expectedNodeCount_overridden() {\n", "    GraphConfig oldConfig = config().expectedNodeCount(NODE_COUNT);\n", "    assertThat(oldConfig.getExpectedNodeCount().get()).isEqualTo(NODE_COUNT);\n", "    GraphConfig newConfig = oldConfig.expectedNodeCount(NODE_COUNT + 1);\n", "    assertThat(oldConfig.getExpectedNodeCount().get()).isEqualTo(NODE_COUNT);\n", "    assertThat(newConfig.getExpectedNodeCount().get()).isEqualTo(NODE_COUNT + 1);\n", "  }\n", "\n", "    DirectedGraph<Integer, String> directedGraph =\n", "        Graphs.createDirected(config().expectedEdgeCount(EDGE_COUNT));\n"], "17": ["    UndirectedGraph<Integer, String> undirectedGraph =\n", "        Graphs.createUndirected(config().expectedEdgeCount(EDGE_COUNT));\n", "  public void config_expectedEdgeCount_negative() {\n", "      config().expectedEdgeCount(-1);\n", "  @Test\n", "  public void config_expectedEdgeCount_overridden() {\n", "    GraphConfig oldConfig = config().expectedEdgeCount(EDGE_COUNT);\n", "    assertThat(oldConfig.getExpectedEdgeCount().get()).isEqualTo(EDGE_COUNT);\n", "    GraphConfig newConfig = oldConfig.expectedEdgeCount(EDGE_COUNT + 1);\n", "    assertThat(oldConfig.getExpectedEdgeCount().get()).isEqualTo(EDGE_COUNT);\n", "    assertThat(newConfig.getExpectedEdgeCount().get()).isEqualTo(EDGE_COUNT + 1);\n", "  }\n", "\n", "    DirectedGraph<Integer, String> directedGraph = Graphs.createDirected(config().noSelfLoops());\n"], "18": ["    UndirectedGraph<Integer, String> undirectedGraph =\n", "        Graphs.createUndirected(config().noSelfLoops());\n"], "19": ["  // Note that this test works precisely because config() returns a new object every time.\n", "  @Test\n", "  public void config_immutability() {\n", "    GraphConfig unused = config().multigraph();\n", "    assertThat(config().isMultigraph()).isFalse();\n", "    unused = config().expectedNodeCount(NODE_COUNT);\n", "    assertThat(config().getExpectedNodeCount()).isAbsent();\n", "    unused = config().expectedEdgeCount(EDGE_COUNT);\n", "    assertThat(config().getExpectedEdgeCount()).isAbsent();\n", "    unused = config().noSelfLoops();\n", "    assertThat(config().isSelfLoopsAllowed()).isTrue();\n", "  }\n", "\n"], "20": ["      addEdge(Graphs.createDirected(), E11, null);\n"], "21": ["      addEdge(Graphs.<Integer, String>createDirected(), E11, ImmutableSet.<Integer>of(N1, N2, N3));\n"], "22": ["      addEdge(Graphs.createDirected(), E11, ImmutableSet.of());\n"], "23": ["    DirectedGraph<Integer, String> directedGraph = Graphs.createDirected();\n"], "24": ["    DirectedGraph<Integer, String> directedGraph = Graphs.createDirected();\n"], "25": ["      copyOf((DirectedGraph) null);\n", "      fail(\"Should have rejected a null graph\");\n", "    } catch (NullPointerException expected) {\n", "    }\n", "    try {\n", "      copyOf((UndirectedGraph) null);\n"], "26": ["    DirectedGraph<Integer, String> directedGraph = buildDirectedTestGraph();\n", "    DirectedGraph<Integer, String> copy = copyOf(directedGraph);\n", "    UndirectedGraph<Integer, String> undirectedGraph = buildUndirectedTestGraph();\n", "    UndirectedGraph<Integer, String> copy = copyOf(undirectedGraph);\n"], "27": ["    UndirectedGraph<Integer, String> undirectedGraph = buildUndirectedTestGraph();\n", "    UndirectedGraph<Integer, String> filteredCopy =\n", "    UndirectedGraph<Integer, String> expectedGraph = Graphs.createUndirected(MULTIGRAPH);\n"], "28": ["    DirectedGraph<Integer, String> directedGraph = buildDirectedTestGraph();\n", "    DirectedGraph<Integer, String> filteredCopy =\n", "    DirectedGraph<Integer, String> expectedGraph = Graphs.createDirected(MULTIGRAPH);\n"], "29": ["    DirectedGraph<Integer, String> directedGraph = buildDirectedTestGraph();\n", "    DirectedGraph<Integer, String> actualGraph = Graphs.createDirected();\n", "    DirectedGraph<Integer, String> expectedGraph = Graphs.createDirected();\n"], "30": ["    DirectedGraph<Integer, String> directedGraph = buildDirectedTestGraph();\n", "    DirectedGraph<Integer, String> actualGraph = Graphs.createDirected();\n", "    DirectedGraph<Integer, String> expectedGraph = Graphs.createDirected();\n"], "31": ["    DirectedGraph<Integer, String> directedGraph = buildDirectedTestGraph();\n", "    DirectedGraph<Integer, String> actualGraph = Graphs.createDirected(MULTIGRAPH);\n", "    DirectedGraph<Integer, String> expectedGraph = buildDirectedTestGraph();\n"], "32": ["    DirectedGraph<Integer, String> directedGraph = buildDirectedTestGraph();\n", "    DirectedGraph<Integer, String> actualGraph = Graphs.createDirected(MULTIGRAPH);\n"], "33": ["    DirectedGraph<Integer, String> expectedGraph = Graphs.createDirected(MULTIGRAPH);\n"], "34": ["    UndirectedGraph<Integer, String> undirectedGraph = buildUndirectedTestGraph();\n", "    UndirectedGraph<Integer, String> actualGraph = Graphs.createUndirected();\n", "    UndirectedGraph<Integer, String> expectedGraph = Graphs.createUndirected();\n"], "35": ["    UndirectedGraph<Integer, String> undirectedGraph = buildUndirectedTestGraph();\n", "    UndirectedGraph<Integer, String> actualGraph = Graphs.createUndirected();\n", "    UndirectedGraph<Integer, String> expectedGraph = Graphs.createUndirected();\n"], "36": ["    UndirectedGraph<Integer, String> undirectedGraph = buildUndirectedTestGraph();\n", "    UndirectedGraph<Integer, String> actualGraph = Graphs.createUndirected(MULTIGRAPH);\n", "    UndirectedGraph<Integer, String> expectedGraph = buildUndirectedTestGraph();\n"], "37": ["    UndirectedGraph<Integer, String> undirectedGraph = buildUndirectedTestGraph();\n", "    UndirectedGraph<Integer, String> actualGraph = Graphs.createUndirected(MULTIGRAPH);\n"], "38": ["    UndirectedGraph<Integer, String> expectedGraph = Graphs.createUndirected(MULTIGRAPH);\n"], "39": ["  private static DirectedGraph<Integer, String> buildDirectedTestGraph() {\n", "    DirectedGraph<Integer, String> directedGraph = Graphs.createDirected(MULTIGRAPH);\n"], "40": ["  private static UndirectedGraph<Integer, String> buildUndirectedTestGraph() {\n", "    UndirectedGraph<Integer, String> undirectedGraph = Graphs.createUndirected(MULTIGRAPH);\n"]}, "added_lines": {"2": [78, 79], "3": [90, 91], "4": [105, 106], "5": [116, 117], "6": [131, 132], "7": [143, 144], "8": [153, 154], "9": [165, 166], "10": [175, 176], "11": [192], "12": [211], "13": [236, 237], "14": [246, 247], "15": [257, 258, 259], "16": [267, 268, 269, 276, 278, 287, 288, 289], "17": [297, 298, 299, 306, 308, 317], "18": [328, 329], "20": [350], "21": [359], "22": [368], "23": [376], "24": [385], "25": [395], "26": [403, 405, 411, 413], "27": [421, 426, 429, 430], "28": [440, 445, 448, 449], "29": [459, 462, 469], "30": [480, 484, 491], "31": [502, 504, 511], "32": [519, 523], "33": [532, 533], "34": [548, 551, 558], "35": [569, 573, 580], "36": [591, 593, 594, 601], "37": [609, 613, 614], "38": [623, 624], "39": [637, 638, 639], "40": [649, 650, 651]}, "removed_lines": {"1": [20, 22], "2": [80], "3": [91, 92], "4": [106], "5": [116], "6": [130], "7": [141], "8": [150], "9": [161], "10": [170], "11": [186], "12": [205], "13": [230, 231], "14": [240, 241], "15": [251, 252], "16": [260, 261, 268, 270, 277, 278, 279, 280, 281, 282, 283, 284, 285, 288, 289], "17": [297, 298, 305, 307, 314, 315, 316, 317, 318, 319, 320, 321, 322, 325], "18": [336, 337], "19": [346, 347, 348, 349, 350, 351, 352, 353, 354, 355, 356, 357, 358], "20": [371], "21": [380], "22": [389], "23": [397], "24": [406], "25": [416, 417, 418, 419, 420, 421], "26": [429, 431, 437, 439], "27": [447, 452, 455], "28": [465, 470, 473], "29": [483, 486, 493], "30": [504, 508, 515], "31": [526, 528, 535], "32": [543, 547], "33": [556], "34": [571, 574, 581], "35": [592, 596, 603], "36": [614, 616, 623], "37": [631, 635], "38": [644], "39": [657, 658], "40": [668, 669]}}, {"16": "guava-tests/test/com/google/common/graph/ImmutableDirectedGraphTest.java", "added": {}, "removed": {"1": ["/*\n", " * Copyright (C) 2014 The Guava Authors\n", " *\n", " * Licensed under the Apache License, Version 2.0 (the \"License\");\n", " * you may not use this file except in compliance with the License.\n", " * You may obtain a copy of the License at\n", " *\n", " * http://www.apache.org/licenses/LICENSE-2.0\n", " *\n", " * Unless required by applicable law or agreed to in writing, software\n", " * distributed under the License is distributed on an \"AS IS\" BASIS,\n", " * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n", " * See the License for the specific language governing permissions and\n", " * limitations under the License.\n", " */\n", "\n", "package com.google.common.graph;\n", "\n", "import static com.google.common.truth.Truth.assertThat;\n", "import static org.junit.Assert.assertEquals;\n", "import static org.junit.Assert.assertTrue;\n", "import static org.junit.Assert.fail;\n", "\n", "import org.junit.Test;\n", "import org.junit.runner.RunWith;\n", "import org.junit.runners.JUnit4;\n", "\n", "/**\n", " * Tests for {@link ImmutableDirectedGraph} with default graph configuration.\n", " *\n", " * @see GraphConfig\n", " */\n", "@RunWith(JUnit4.class)\n", "public class ImmutableDirectedGraphTest extends ImmutableSimpleDirectedGraphTest {\n", "  @Override\n", "  public ImmutableDirectedGraph<Integer, String> createGraph() {\n", "    builder = ImmutableDirectedGraph.builder();\n", "    return builder.build();\n", "  }\n", "\n", "  @Test\n", "  public void edges_selfLoop() {\n", "    addEdge(E11, N1, N1);\n", "    assertThat(graph.edges()).containsExactly(E11);\n", "  }\n", "\n", "  @Test\n", "  public void incidentEdges_selfLoop() {\n", "    addEdge(E11, N1, N1);\n", "    assertThat(graph.incidentEdges(N1)).containsExactly(E11);\n", "  }\n", "\n", "  @Test\n", "  public void incidentNodes_selfLoop() {\n", "    addEdge(E11, N1, N1);\n", "    assertThat(graph.incidentNodes(E11)).containsExactly(N1);\n", "  }\n", "\n", "  @Test\n", "  public void adjacentNodes_selfLoop() {\n", "    addEdge(E11, N1, N1);\n", "    addEdge(E12, N1, N2);\n", "    assertThat(graph.adjacentNodes(N1)).containsExactly(N1, N2);\n", "  }\n", "\n", "  @Test\n", "  public void adjacentEdges_selfLoop() {\n", "    // An edge is never adjacent to itself\n", "    addEdge(E11, N1, N1);\n", "    assertThat(graph.adjacentEdges(E11)).isEmpty();\n", "    addEdge(E12, N1, N2);\n", "    assertThat(graph.adjacentEdges(E11)).containsExactly(E12);\n", "  }\n", "\n", "  @Test\n", "  public void edgesConnecting_selfLoop() {\n", "    addEdge(E11, N1, N1);\n", "    assertThat(directedGraph.edgesConnecting(N1, N1)).containsExactly(E11);\n", "    addEdge(E12, N1, N2);\n", "    assertThat(directedGraph.edgesConnecting(N1, N2)).containsExactly(E12);\n", "  }\n", "\n", "  @Test\n", "  public void inEdges_selfLoop() {\n", "    addEdge(E11, N1, N1);\n", "    assertThat(directedGraph.inEdges(N1)).containsExactly(E11);\n", "    addEdge(E41, N4, N1);\n", "    assertThat(directedGraph.inEdges(N1)).containsExactly(E11, E41);\n", "  }\n", "\n", "  @Test\n", "  public void outEdges_selfLoop() {\n", "    addEdge(E11, N1, N1);\n", "    assertThat(directedGraph.outEdges(N1)).containsExactly(E11);\n", "    addEdge(E12, N1, N2);\n", "    assertThat(directedGraph.outEdges(N1)).containsExactly(E11, E12);\n", "  }\n", "\n", "  @Test\n", "  public void predecessors_selfLoop() {\n", "    addEdge(E11, N1, N1);\n", "    assertThat(directedGraph.predecessors(N1)).containsExactly(N1);\n", "    addEdge(E41, N4, N1);\n", "    assertThat(directedGraph.predecessors(N1)).containsExactly(N1, N4);\n", "  }\n", "\n", "  @Test\n", "  public void successors_selfLoop() {\n", "    addEdge(E11, N1, N1);\n", "    assertThat(directedGraph.successors(N1)).containsExactly(N1);\n", "    addEdge(E12, N1, N2);\n", "    assertThat(directedGraph.successors(N1)).containsExactly(N1, N2);\n", "  }\n", "\n", "  @Test\n", "  public void degree_selfLoop() {\n", "    addEdge(E11, N1, N1);\n", "    assertEquals(1, graph.degree(N1));\n", "    addEdge(E12, N1, N2);\n", "    assertEquals(2, graph.degree(N1));\n", "  }\n", "\n", "  @Test\n", "  public void inDegree_selfLoop() {\n", "    addEdge(E11, N1, N1);\n", "    assertEquals(1, directedGraph.inDegree(N1));\n", "    addEdge(E41, N4, N1);\n", "    assertEquals(2, directedGraph.inDegree(N1));\n", "  }\n", "\n", "  @Test\n", "  public void outDegree_selfLoop() {\n", "    addEdge(E11, N1, N1);\n", "    assertEquals(1, directedGraph.outDegree(N1));\n", "    addEdge(E12, N1, N2);\n", "    assertEquals(2, directedGraph.outDegree(N1));\n", "  }\n", "\n", "  @Test\n", "  public void source_selfLoop() {\n", "    addEdge(E11, N1, N1);\n", "    assertEquals(N1, directedGraph.source(E11));\n", "  }\n", "\n", "  @Test\n", "  public void target_selfLoop() {\n", "    addEdge(E11, N1, N1);\n", "    assertEquals(N1, directedGraph.target(E11));\n", "  }\n", "\n", "  // Builder mutation methods\n", "\n", "  @Override\n", "  @Test\n", "  public void addEdge_selfLoop() {\n", "    assertTrue(addEdge(E11, N1, N1));\n", "    assertThat(graph.edges()).contains(E11);\n", "    assertThat(graph.edgesConnecting(N1, N1)).containsExactly(E11);\n", "  }\n", "\n", "  @Test\n", "  public void addEdge_existingEdgeBetweenDifferentNodes_selfLoops() {\n", "    addEdge(E11, N1, N1);\n", "    try {\n", "      addEdge(E11, N1, N2);\n", "      fail(\"Reusing an existing self-loop edge to connect different nodes succeeded\");\n", "    } catch (IllegalArgumentException e) {\n", "      assertThat(e.getMessage()).contains(ERROR_REUSE_EDGE);\n", "    }\n", "    try {\n", "      addEdge(E11, N2, N2);\n", "      fail(\"Reusing an existing self-loop edge to make a different self-loop edge succeeded\");\n", "    } catch (IllegalArgumentException e) {\n", "      assertThat(e.getMessage()).contains(ERROR_REUSE_EDGE);\n", "    }\n", "    addEdge(E12, N1, N2);\n", "    try {\n", "      addEdge(E12, N1, N1);\n", "      fail(\"Reusing an existing edge to add a self-loop edge between different nodes succeeded\");\n", "    } catch (IllegalArgumentException e) {\n", "      assertThat(e.getMessage()).contains(ERROR_REUSE_EDGE);\n", "    }\n", "  }\n", "\n", "  @Test\n", "  public void addEdge_parallelSelfLoopEdge() {\n", "    addEdge(E11, N1, N1);\n", "    try {\n", "      addEdge(EDGE_NOT_IN_GRAPH, N1, N1);\n", "      fail(\"Adding a parallel self-loop edge succeeded\");\n", "    } catch (IllegalArgumentException e) {\n", "      assertThat(e.getMessage()).contains(ERROR_PARALLEL_EDGE);\n", "    }\n", "  }\n", "\n", "  @Test\n", "  public void toString_selfLoop() {\n", "    addEdge(E11, N1, N1);\n", "    assertThat(graph.toString()).isEqualTo(String.format(\n", "        \"config: %s, nodes: %s, edges: {%s=<%s -> %s>}\",\n", "        graph.config(), graph.nodes(), E11, N1, N1));\n", "  }\n", "\n", "  @Override\n", "  protected void populateInputGraph(DirectedGraph<Integer, String> graph) {\n", "    super.populateInputGraph(graph);\n", "    // add a self-loop\n", "    graph.addEdge(E11, N1, N1);\n", "  }\n", "}\n"]}, "added_lines": {}, "removed_lines": {"1": [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 58, 59, 60, 61, 62, 63, 64, 65, 66, 67, 68, 69, 70, 71, 72, 73, 74, 75, 76, 77, 78, 79, 80, 81, 82, 83, 84, 85, 86, 87, 88, 89, 90, 91, 92, 93, 94, 95, 96, 97, 98, 99, 100, 101, 102, 103, 104, 105, 106, 107, 108, 109, 110, 111, 112, 113, 114, 115, 116, 117, 118, 119, 120, 121, 122, 123, 124, 125, 126, 127, 128, 129, 130, 131, 132, 133, 134, 135, 136, 137, 138, 139, 140, 141, 142, 143, 144, 145, 146, 147, 148, 149, 150, 151, 152, 153, 154, 155, 156, 157, 158, 159, 160, 161, 162, 163, 164, 165, 166, 167, 168, 169, 170, 171, 172, 173, 174, 175, 176, 177, 178, 179, 180, 181, 182, 183, 184, 185, 186, 187, 188, 189, 190, 191, 192, 193, 194, 195, 196, 197, 198, 199, 200, 201, 202, 203, 204, 205, 206, 207, 208, 209, 210]}}, {"17": "guava-tests/test/com/google/common/graph/ImmutableDirectedMultigraphTest.java", "added": {}, "removed": {"1": ["/*\n", " * Copyright (C) 2014 The Guava Authors\n", " *\n", " * Licensed under the Apache License, Version 2.0 (the \"License\");\n", " * you may not use this file except in compliance with the License.\n", " * You may obtain a copy of the License at\n", " *\n", " * http://www.apache.org/licenses/LICENSE-2.0\n", " *\n", " * Unless required by applicable law or agreed to in writing, software\n", " * distributed under the License is distributed on an \"AS IS\" BASIS,\n", " * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n", " * See the License for the specific language governing permissions and\n", " * limitations under the License.\n", " */\n", "\n", "package com.google.common.graph;\n", "\n", "import static com.google.common.truth.Truth.assertThat;\n", "import static org.junit.Assert.assertTrue;\n", "\n", "import org.junit.Test;\n", "import org.junit.runner.RunWith;\n", "import org.junit.runners.JUnit4;\n", "\n", "/**\n", " * Tests for {@link ImmutableDirectedGraph} allowing parallel edges.\n", " */\n", "@RunWith(JUnit4.class)\n", "public class ImmutableDirectedMultigraphTest extends ImmutableDirectedGraphTest {\n", "  @Override\n", "  public ImmutableDirectedGraph<Integer, String> createGraph() {\n", "    builder = ImmutableDirectedGraph.builder(Graphs.MULTIGRAPH);\n", "    return builder.build();\n", "  }\n", "\n", "  @Test\n", "  public void edgesConnecting_parallelEdges() {\n", "    assertTrue(addEdge(E12, N1, N2));\n", "    assertTrue(addEdge(E12_A, N1, N2));\n", "    assertThat(directedGraph.edgesConnecting(N1, N2)).containsExactly(E12, E12_A);\n", "    // Passed nodes should be in the correct edge direction, first is the\n", "    // source node and the second is the target node\n", "    assertThat(directedGraph.edgesConnecting(N2, N1)).isEmpty();\n", "  }\n", "\n", "  @Test\n", "  public void edgesConnecting_parallelSelfLoopEdges() {\n", "    assertTrue(addEdge(E11, N1, N1));\n", "    assertTrue(addEdge(E11_A, N1, N1));\n", "    assertThat(directedGraph.edgesConnecting(N1, N1)).containsExactly(E11, E11_A);\n", "  }\n", "\n", "  @Override\n", "  @Test\n", "  public void addEdge_parallelEdge() {\n", "    assertTrue(addEdge(E12, N1, N2));\n", "    assertTrue(addEdge(E12_A, N1, N2));\n", "    assertThat(directedGraph.edges()).containsExactly(E12, E12_A).inOrder();\n", "  }\n", "\n", "  @Override\n", "  @Test\n", "  public void addEdge_parallelSelfLoopEdge() {\n", "    assertTrue(addEdge(E11, N1, N1));\n", "    assertTrue(addEdge(E11_A, N1, N1));\n", "    assertThat(directedGraph.edges()).containsExactly(E11, E11_A).inOrder();\n", "  }\n", "\n", "  @Test\n", "  public void toString_parallelEdges() {\n", "    addEdge(E12, N1, N2);\n", "    addEdge(E12_A, N1, N2);\n", "    addEdge(E11, N1, N1);\n", "    addEdge(E11_A, N1, N1);\n", "    assertThat(graph.toString()).isEqualTo(String.format(\n", "        \"config: %s, nodes: %s, \"\n", "            + \"edges: {%s=<%s -> %s>, %s=<%s -> %s>, %s=<%s -> %s>, %s=<%s -> %s>}\",\n", "        graph.config(),\n", "        graph.nodes(),\n", "        E12, N1, N2,\n", "        E12_A, N1, N2,\n", "        E11, N1, N1,\n", "        E11_A, N1, N1\n", "    ));\n", "  }\n", "\n", "  @Override\n", "  protected void populateInputGraph(DirectedGraph<Integer, String> graph) {\n", "    super.populateInputGraph(graph);\n", "    // Add some parallel edges\n", "    graph.addEdge(E11_A, N1, N1);\n", "    graph.addEdge(E12_A, N1, N2);\n", "  }\n", "}\n"]}, "added_lines": {}, "removed_lines": {"1": [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 58, 59, 60, 61, 62, 63, 64, 65, 66, 67, 68, 69, 70, 71, 72, 73, 74, 75, 76, 77, 78, 79, 80, 81, 82, 83, 84, 85, 86, 87, 88, 89, 90, 91, 92, 93, 94, 95]}}, {"18": "guava-tests/test/com/google/common/graph/ImmutableGraphTest.java", "added": {"1": ["/*\n", " * Copyright (C) 2014 The Guava Authors\n", " *\n", " * Licensed under the Apache License, Version 2.0 (the \"License\");\n", " * you may not use this file except in compliance with the License.\n", " * You may obtain a copy of the License at\n", " *\n", " * http://www.apache.org/licenses/LICENSE-2.0\n", " *\n", " * Unless required by applicable law or agreed to in writing, software\n", " * distributed under the License is distributed on an \"AS IS\" BASIS,\n", " * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n", " * See the License for the specific language governing permissions and\n", " * limitations under the License.\n", " */\n", "\n", "package com.google.common.graph;\n", "\n", "import static com.google.common.truth.Truth.assertThat;\n", "import static org.junit.Assert.fail;\n", "\n", "import com.google.common.graph.testing.TestGraphBuilder;\n", "\n", "import org.junit.Test;\n", "import org.junit.runner.RunWith;\n", "import org.junit.runners.JUnit4;\n", "\n", "/**\n", " * Tests for {@link ImmutableGraph}.\n", " */\n", "@RunWith(JUnit4.class)\n", "public class ImmutableGraphTest {\n", "\n", "  @Test\n", "  public void addNode_immutable() {\n", "    Graph<String, String> graph = TestGraphBuilder.<String, String>init(GraphBuilder.directed())\n", "        .toImmutableGraph();\n", "    try {\n", "      graph.addNode(\"node\");\n", "      fail(\"Expected UnsupportedOperationException\");\n", "    } catch (UnsupportedOperationException expected) {\n", "    }\n", "    assertThat(graph.nodes()).isEmpty();\n", "  }\n", "\n", "  @Test\n", "  public void addEdge_immutable() {\n", "    Graph<String, String> graph = TestGraphBuilder.<String, String>init(GraphBuilder.directed())\n", "        .toImmutableGraph();\n", "    try {\n", "      graph.addEdge(\"edge\", \"node1\", \"node2\");\n", "      fail(\"Expected UnsupportedOperationException\");\n", "    } catch (UnsupportedOperationException expected) {\n", "    }\n", "    assertThat(graph.edges()).isEmpty();\n", "  }\n", "\n", "  @Test\n", "  public void removeNode_immutable() {\n", "    Graph<String, String> graph = TestGraphBuilder.<String, String>init(GraphBuilder.directed())\n", "        .addNode(\"node\")\n", "        .toImmutableGraph();\n", "    try {\n", "      graph.removeNode(\"node\");\n", "      fail(\"Expected UnsupportedOperationException\");\n", "    } catch (UnsupportedOperationException expected) {\n", "    }\n", "    assertThat(graph.nodes()).containsExactly(\"node\");\n", "  }\n", "\n", "  @Test\n", "  public void removeEdge_immutable() {\n", "    Graph<String, String> graph = TestGraphBuilder.<String, String>init(GraphBuilder.directed())\n", "        .addEdge(\"edge\", \"node1\", \"node2\")\n", "        .toImmutableGraph();\n", "    try {\n", "      graph.removeEdge(\"edge\");\n", "      fail(\"Expected UnsupportedOperationException\");\n", "    } catch (UnsupportedOperationException expected) {\n", "    }\n", "    assertThat(graph.edges()).containsExactly(\"edge\");\n", "  }\n", "\n", "  @Test\n", "  public void copyOfImmutableGraph_optimized() {\n", "    Graph<String, String> graph1 = ImmutableGraph.copyOf(\n", "        GraphBuilder.directed().<String, String>build());\n", "    Graph<String, String> graph2 = ImmutableGraph.copyOf(graph1);\n", "\n", "    assertThat(graph2).isSameAs(graph1);\n", "  }\n", "\n", "  @Test\n", "  public void edgesConnecting_directed() {\n", "    Graph<String, String> mutableGraph = GraphBuilder.directed().build();\n", "    mutableGraph.addEdge(\"AA\", \"A\", \"A\");\n", "    mutableGraph.addEdge(\"AB\", \"A\", \"B\");\n", "    Graph<String, String> graph = ImmutableGraph.copyOf(mutableGraph);\n", "\n", "    assertThat(graph.edgesConnecting(\"A\", \"A\")).containsExactly(\"AA\");\n", "    assertThat(graph.edgesConnecting(\"A\", \"B\")).containsExactly(\"AB\");\n", "    assertThat(graph.edgesConnecting(\"B\", \"A\")).isEmpty();\n", "  }\n", "\n", "  @Test\n", "  public void edgesConnecting_undirected() {\n", "    Graph<String, String> mutableGraph = GraphBuilder.undirected().build();\n", "    mutableGraph.addEdge(\"AA\", \"A\", \"A\");\n", "    mutableGraph.addEdge(\"AB\", \"A\", \"B\");\n", "    Graph<String, String> graph = ImmutableGraph.copyOf(mutableGraph);\n", "\n", "    assertThat(graph.edgesConnecting(\"A\", \"A\")).containsExactly(\"AA\");\n", "    assertThat(graph.edgesConnecting(\"A\", \"B\")).containsExactly(\"AB\");\n", "    assertThat(graph.edgesConnecting(\"B\", \"A\")).containsExactly(\"AB\");\n", "  }\n", "}\n"]}, "removed": {}, "added_lines": {"1": [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 58, 59, 60, 61, 62, 63, 64, 65, 66, 67, 68, 69, 70, 71, 72, 73, 74, 75, 76, 77, 78, 79, 80, 81, 82, 83, 84, 85, 86, 87, 88, 89, 90, 91, 92, 93, 94, 95, 96, 97, 98, 99, 100, 101, 102, 103, 104, 105, 106, 107, 108, 109, 110, 111, 112, 113, 114, 115, 116]}, "removed_lines": {}}, {"19": "guava-tests/test/com/google/common/graph/ImmutableSimpleDirectedGraphTest.java", "added": {}, "removed": {"1": ["/*\n", " * Copyright (C) 2014 The Guava Authors\n", " *\n", " * Licensed under the Apache License, Version 2.0 (the \"License\");\n", " * you may not use this file except in compliance with the License.\n", " * You may obtain a copy of the License at\n", " *\n", " * http://www.apache.org/licenses/LICENSE-2.0\n", " *\n", " * Unless required by applicable law or agreed to in writing, software\n", " * distributed under the License is distributed on an \"AS IS\" BASIS,\n", " * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n", " * See the License for the specific language governing permissions and\n", " * limitations under the License.\n", " */\n", "\n", "package com.google.common.graph;\n", "\n", "import static com.google.common.truth.Truth.assertThat;\n", "import static org.junit.Assert.assertTrue;\n", "import static org.junit.Assert.fail;\n", "\n", "import com.google.errorprone.annotations.CanIgnoreReturnValue;\n", "\n", "import org.junit.Test;\n", "import org.junit.runner.RunWith;\n", "import org.junit.runners.JUnit4;\n", "\n", "/**\n", " * Tests for {@link ImmutableDirectedGraph}, creating a simple directed graph (parallel and\n", " * self-loop edges are not allowed).\n", " */\n", "@RunWith(JUnit4.class)\n", "public class ImmutableSimpleDirectedGraphTest extends AbstractImmutableDirectedGraphTest {\n", "  protected ImmutableDirectedGraph.Builder<Integer, String> builder;\n", "\n", "  @Override\n", "  @CanIgnoreReturnValue\n", "  final boolean addNode(Integer n) {\n", "    DirectedGraph<Integer, String> oldGraph = Graphs.copyOf(directedGraph);\n", "    graph = directedGraph = builder.addNode(n).build();\n", "    return !graph.equals(oldGraph);\n", "  }\n", "\n", "  @Override\n", "  @CanIgnoreReturnValue\n", "  final boolean addEdge(String e, Integer n1, Integer n2) {\n", "    DirectedGraph<Integer, String> oldGraph = Graphs.copyOf(directedGraph);\n", "    graph = directedGraph = builder.addEdge(e, n1, n2).build();\n", "    return !graph.equals(oldGraph);\n", "  }\n", "\n", "  @Override\n", "  public ImmutableDirectedGraph<Integer, String> createGraph() {\n", "    builder = ImmutableDirectedGraph.builder(Graphs.config().noSelfLoops());\n", "    return builder.build();\n", "  }\n", "\n", "  @Test\n", "  public void addEdge_selfLoop() {\n", "    try {\n", "      addEdge(E11, N1, N1);\n", "      fail(ERROR_ADDED_SELF_LOOP);\n", "    } catch (IllegalArgumentException e) {\n", "      assertThat(e.getMessage()).contains(ERROR_SELF_LOOP);\n", "    }\n", "  }\n", "\n", "  /**\n", "   * This test checks an implementation dependent feature. It tests that\n", "   * the method {@code addEdge} will silently add the missing nodes to the builder,\n", "   * then add the edge connecting them.\n", "   */\n", "  @Test\n", "  public void addEdge_nodesNotInGraph() {\n", "    addNode(N1);\n", "    assertTrue(addEdge(E15, N1, N5));\n", "    assertTrue(addEdge(E41, N4, N1));\n", "    assertTrue(addEdge(E23, N2, N3));\n", "    assertThat(directedGraph.nodes()).containsExactly(N1, N5, N4, N2, N3).inOrder();\n", "    assertThat(directedGraph.edges()).containsExactly(E15, E41, E23).inOrder();\n", "    assertThat(directedGraph.edgesConnecting(N1, N5)).containsExactly(E15);\n", "    assertThat(directedGraph.edgesConnecting(N4, N1)).containsExactly(E41);\n", "    assertThat(directedGraph.edgesConnecting(N2, N3)).containsExactly(E23);\n", "    // Direction of the added edge is correctly handled\n", "    assertThat(directedGraph.edgesConnecting(N3, N2)).isEmpty();\n", "  }\n", "\n", "  @Test\n", "  public void copyOf() {\n", "    DirectedGraph<Integer, String> graph = Graphs.createDirected(directedGraph.config());\n", "    populateInputGraph(graph);\n", "    assertThat(ImmutableDirectedGraph.copyOf(graph)).isEqualTo(graph);\n", "  }\n", "\n", "  @Test\n", "  public void addGraph() {\n", "    DirectedGraph<Integer, String> graph = Graphs.createDirected(directedGraph.config());\n", "    populateInputGraph(graph);\n", "    assertThat(builder.addGraph(graph).build()).isEqualTo(graph);\n", "  }\n", "\n", "  @Test\n", "  public void addGraph_overlap() {\n", "    DirectedGraph<Integer, String> graph = Graphs.createDirected(directedGraph.config());\n", "    populateInputGraph(graph);\n", "    // Add an edge that is in 'graph' (overlap)\n", "    builder.addEdge(E12, N1, N2);\n", "    builder.addGraph(graph);\n", "    assertThat(builder.build()).isEqualTo(graph);\n", "  }\n", "\n", "  @Test\n", "  public void addGraph_inconsistentEdges() {\n", "    DirectedGraph<Integer, String> graph = Graphs.createDirected(directedGraph.config());\n", "    populateInputGraph(graph);\n", "    builder.addEdge(E21, N3, N1);\n", "    try {\n", "      builder.addGraph(graph);\n", "      fail(\"Should have rejected a graph whose edge definitions were inconsistent with existing\"\n", "          + \"builder state\");\n", "    } catch (IllegalArgumentException expected) {\n", "    }\n", "  }\n", "\n", "  protected void populateInputGraph(DirectedGraph<Integer, String> graph) {\n", "    graph.addEdge(E12, N1, N2);\n", "    graph.addEdge(E21, N2, N1);\n", "    graph.addEdge(E23, N2, N3);\n", "    graph.addNode(N5);\n", "  }\n", "}\n"]}, "added_lines": {}, "removed_lines": {"1": [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 58, 59, 60, 61, 62, 63, 64, 65, 66, 67, 68, 69, 70, 71, 72, 73, 74, 75, 76, 77, 78, 79, 80, 81, 82, 83, 84, 85, 86, 87, 88, 89, 90, 91, 92, 93, 94, 95, 96, 97, 98, 99, 100, 101, 102, 103, 104, 105, 106, 107, 108, 109, 110, 111, 112, 113, 114, 115, 116, 117, 118, 119, 120, 121, 122, 123, 124, 125, 126, 127, 128, 129, 130, 131, 132]}}, {"20": "guava-tests/test/com/google/common/graph/ImmutableSimpleUndirectedGraphTest.java", "added": {}, "removed": {"1": ["/*\n", " * Copyright (C) 2014 The Guava Authors\n", " *\n", " * Licensed under the Apache License, Version 2.0 (the \"License\");\n", " * you may not use this file except in compliance with the License.\n", " * You may obtain a copy of the License at\n", " *\n", " * http://www.apache.org/licenses/LICENSE-2.0\n", " *\n", " * Unless required by applicable law or agreed to in writing, software\n", " * distributed under the License is distributed on an \"AS IS\" BASIS,\n", " * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n", " * See the License for the specific language governing permissions and\n", " * limitations under the License.\n", " */\n", "\n", "package com.google.common.graph;\n", "\n", "import static com.google.common.truth.Truth.assertThat;\n", "import static org.junit.Assert.assertTrue;\n", "import static org.junit.Assert.fail;\n", "\n", "import com.google.errorprone.annotations.CanIgnoreReturnValue;\n", "\n", "import org.junit.Test;\n", "import org.junit.runner.RunWith;\n", "import org.junit.runners.JUnit4;\n", "\n", "/**\n", " * Tests for {@link ImmutableUndirectedGraph}, creating a simple undirected graph (parallel and\n", " * self-loop edges are not allowed)\n", " */\n", "@RunWith(JUnit4.class)\n", "public class ImmutableSimpleUndirectedGraphTest extends AbstractImmutableUndirectedGraphTest {\n", "  protected ImmutableUndirectedGraph.Builder<Integer, String> builder;\n", "\n", "  @Override\n", "  @CanIgnoreReturnValue\n", "  final boolean addNode(Integer n) {\n", "    UndirectedGraph<Integer, String> oldGraph = Graphs.copyOf(undirectedGraph);\n", "    graph = undirectedGraph = builder.addNode(n).build();\n", "    return !graph.equals(oldGraph);\n", "  }\n", "\n", "  @Override\n", "  @CanIgnoreReturnValue\n", "  final boolean addEdge(String e, Integer n1, Integer n2) {\n", "    UndirectedGraph<Integer, String> oldGraph = Graphs.copyOf(undirectedGraph);\n", "    graph = undirectedGraph = builder.addEdge(e, n1, n2).build();\n", "    return !graph.equals(oldGraph);\n", "  }\n", "\n", "  @Override\n", "  public ImmutableUndirectedGraph<Integer, String> createGraph() {\n", "    builder = ImmutableUndirectedGraph.builder(Graphs.config().noSelfLoops());\n", "    return builder.build();\n", "  }\n", "\n", "  @Test\n", "  public void addEdge_selfLoop() {\n", "    try {\n", "      addEdge(E11, N1, N1);\n", "      fail(ERROR_ADDED_SELF_LOOP);\n", "    } catch (IllegalArgumentException e) {\n", "      assertThat(e.getMessage()).contains(ERROR_SELF_LOOP);\n", "    }\n", "  }\n", "\n", "  /**\n", "   * This test checks an implementation dependent feature. It tests that\n", "   * the method {@code addEdge} will silently add the missing nodes to the builder,\n", "   * then add the edge connecting them. We are not using the proxy methods here\n", "   * as we want to test {@code addEdge} when the end-points are not elements\n", "   * of the graph.\n", "   */\n", "  @Test\n", "  public void addEdge_nodesNotInGraph() {\n", "    addNode(N1);\n", "    assertTrue(addEdge(E15, N1, N5));\n", "    assertTrue(addEdge(E41, N4, N1));\n", "    assertTrue(addEdge(E23, N2, N3));\n", "    assertThat(undirectedGraph.nodes()).containsExactly(N1, N5, N4, N2, N3).inOrder();\n", "    assertThat(undirectedGraph.edges()).containsExactly(E15, E41, E23).inOrder();\n", "    assertThat(undirectedGraph.edgesConnecting(N1, N5)).containsExactly(E15);\n", "    assertThat(undirectedGraph.edgesConnecting(N4, N1)).containsExactly(E41);\n", "    assertThat(undirectedGraph.edgesConnecting(N2, N3)).containsExactly(E23);\n", "    assertThat(undirectedGraph.edgesConnecting(N3, N2)).containsExactly(E23);\n", "  }\n", "\n", "  @Test\n", "  public void copyOf_nullArgument() {\n", "    try {\n", "      ImmutableUndirectedGraph.copyOf(null);\n", "      fail(\"Should have rejected a null graph\");\n", "    } catch (NullPointerException expected) {\n", "    }\n", "  }\n", "\n", "  @Test\n", "  public void copyOf() {\n", "    UndirectedGraph<Integer, String> graph = Graphs.createUndirected(undirectedGraph.config());\n", "    populateInputGraph(graph);\n", "    assertThat(ImmutableUndirectedGraph.copyOf(graph)).isEqualTo(graph);\n", "  }\n", "\n", "  @Test\n", "  public void addGraph() {\n", "    UndirectedGraph<Integer, String> graph = Graphs.createUndirected(undirectedGraph.config());\n", "    populateInputGraph(graph);\n", "    assertThat(builder.addGraph(graph).build()).isEqualTo(graph);\n", "  }\n", "\n", "  @Test\n", "  public void addGraph_overlap() {\n", "    UndirectedGraph<Integer, String> graph = Graphs.createUndirected(undirectedGraph.config());\n", "    populateInputGraph(graph);\n", "    // Add an edge that is in 'graph' (overlap)\n", "    builder.addEdge(E12, N1, N2);\n", "    builder.addGraph(graph);\n", "    assertThat(builder.build()).isEqualTo(graph);\n", "  }\n", "\n", "  @Test\n", "  public void addGraph_inconsistentEdges() {\n", "    UndirectedGraph<Integer, String> graph = Graphs.createUndirected(undirectedGraph.config());\n", "    populateInputGraph(graph);\n", "    builder.addEdge(E12, N5, N1);\n", "    try {\n", "      builder.addGraph(graph);\n", "      fail(\"Should have rejected a graph whose edge definitions were inconsistent with existing\"\n", "          + \"builder state\");\n", "    } catch (IllegalArgumentException expected) {\n", "    }\n", "  }\n", "\n", "  protected void populateInputGraph(UndirectedGraph<Integer, String> graph) {\n", "    graph.addEdge(E12, N1, N2);\n", "    graph.addEdge(E23, N2, N3);\n", "    graph.addNode(N5);\n", "  }\n", "}\n"]}, "added_lines": {}, "removed_lines": {"1": [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 58, 59, 60, 61, 62, 63, 64, 65, 66, 67, 68, 69, 70, 71, 72, 73, 74, 75, 76, 77, 78, 79, 80, 81, 82, 83, 84, 85, 86, 87, 88, 89, 90, 91, 92, 93, 94, 95, 96, 97, 98, 99, 100, 101, 102, 103, 104, 105, 106, 107, 108, 109, 110, 111, 112, 113, 114, 115, 116, 117, 118, 119, 120, 121, 122, 123, 124, 125, 126, 127, 128, 129, 130, 131, 132, 133, 134, 135, 136, 137, 138, 139, 140, 141]}}, {"21": "guava-tests/test/com/google/common/graph/ImmutableUndirectedGraphTest.java", "added": {}, "removed": {"1": ["/*\n", " * Copyright (C) 2014 The Guava Authors\n", " *\n", " * Licensed under the Apache License, Version 2.0 (the \"License\");\n", " * you may not use this file except in compliance with the License.\n", " * You may obtain a copy of the License at\n", " *\n", " * http://www.apache.org/licenses/LICENSE-2.0\n", " *\n", " * Unless required by applicable law or agreed to in writing, software\n", " * distributed under the License is distributed on an \"AS IS\" BASIS,\n", " * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n", " * See the License for the specific language governing permissions and\n", " * limitations under the License.\n", " */\n", "\n", "package com.google.common.graph;\n", "\n", "import static com.google.common.truth.Truth.assertThat;\n", "import static org.junit.Assert.assertEquals;\n", "import static org.junit.Assert.assertTrue;\n", "import static org.junit.Assert.fail;\n", "\n", "import org.junit.Test;\n", "import org.junit.runner.RunWith;\n", "import org.junit.runners.JUnit4;\n", "\n", "/**\n", " * Tests for {@link ImmutableUndirectedGraph} with default graph configuration.\n", " *\n", " * @see GraphConfig\n", " */\n", "@RunWith(JUnit4.class)\n", "public class ImmutableUndirectedGraphTest extends ImmutableSimpleUndirectedGraphTest {\n", "\n", "  @Override\n", "  public ImmutableUndirectedGraph<Integer, String> createGraph() {\n", "    builder = ImmutableUndirectedGraph.builder();\n", "    return builder.build();\n", "  }\n", "\n", "  @Test\n", "  public void edges_selfLoop() {\n", "    addEdge(E11, N1, N1);\n", "    assertThat(graph.edges()).containsExactly(E11);\n", "  }\n", "\n", "  @Test\n", "  public void incidentEdges_selfLoop() {\n", "    addEdge(E11, N1, N1);\n", "    assertThat(graph.incidentEdges(N1)).containsExactly(E11);\n", "  }\n", "\n", "  @Test\n", "  public void incidentNodes_selfLoop() {\n", "    addEdge(E11, N1, N1);\n", "    assertThat(graph.incidentNodes(E11)).containsExactly(N1);\n", "  }\n", "\n", "  @Test\n", "  public void adjacentNodes_selfLoop() {\n", "    addEdge(E11, N1, N1);\n", "    addEdge(E12, N1, N2);\n", "    assertThat(graph.adjacentNodes(N1)).containsExactly(N1, N2);\n", "  }\n", "\n", "  @Test\n", "  public void adjacentEdges_selfLoop() {\n", "    // An edge is never adjacent to itself\n", "    addEdge(E11, N1, N1);\n", "    assertThat(graph.adjacentEdges(E11)).isEmpty();\n", "    addEdge(E12, N1, N2);\n", "    assertThat(graph.adjacentEdges(E11)).containsExactly(E12);\n", "  }\n", "\n", "  @Test\n", "  public void edgesConnecting_selfLoop() {\n", "    addEdge(E11, N1, N1);\n", "    assertThat(undirectedGraph.edgesConnecting(N1, N1)).containsExactly(E11);\n", "    addEdge(E12, N1, N2);\n", "    assertThat(undirectedGraph.edgesConnecting(N1, N2)).containsExactly(E12);\n", "    assertThat(undirectedGraph.edgesConnecting(N2, N1)).containsExactly(E12);\n", "  }\n", "\n", "  @Test\n", "  public void inEdges_selfLoop() {\n", "    addEdge(E11, N1, N1);\n", "    assertThat(undirectedGraph.inEdges(N1)).containsExactly(E11);\n", "    addEdge(E12, N1, N2);\n", "    assertThat(undirectedGraph.inEdges(N1)).containsExactly(E11, E12);\n", "  }\n", "\n", "  @Test\n", "  public void outEdges_selfLoop() {\n", "    addEdge(E11, N1, N1);\n", "    assertThat(undirectedGraph.outEdges(N1)).containsExactly(E11);\n", "    addEdge(E12, N2, N1);\n", "    assertThat(undirectedGraph.outEdges(N1)).containsExactly(E11, E12);\n", "  }\n", "\n", "  @Test\n", "  public void predecessors_selfLoop() {\n", "    addEdge(E11, N1, N1);\n", "    assertThat(undirectedGraph.predecessors(N1)).containsExactly(N1);\n", "    addEdge(E12, N1, N2);\n", "    assertThat(undirectedGraph.predecessors(N1)).containsExactly(N1, N2);\n", "  }\n", "\n", "  @Test\n", "  public void successors_selfLoop() {\n", "    addEdge(E11, N1, N1);\n", "    assertThat(undirectedGraph.successors(N1)).containsExactly(N1);\n", "    addEdge(E12, N2, N1);\n", "    assertThat(undirectedGraph.successors(N1)).containsExactly(N1, N2);\n", "  }\n", "\n", "  @Test\n", "  public void degree_selfLoop() {\n", "    addEdge(E11, N1, N1);\n", "    assertEquals(1, graph.degree(N1));\n", "    addEdge(E12, N1, N2);\n", "    assertEquals(2, graph.degree(N1));\n", "  }\n", "\n", "  @Test\n", "  public void inDegree_selfLoop() {\n", "    addEdge(E11, N1, N1);\n", "    assertEquals(1, undirectedGraph.inDegree(N1));\n", "    addEdge(E12, N1, N2);\n", "    assertEquals(2, undirectedGraph.inDegree(N1));\n", "  }\n", "\n", "  @Test\n", "  public void outDegree_selfLoop() {\n", "    addEdge(E11, N1, N1);\n", "    assertEquals(1, undirectedGraph.outDegree(N1));\n", "    addEdge(E12, N2, N1);\n", "    assertEquals(2, undirectedGraph.outDegree(N1));\n", "  }\n", "\n", "  // Builder mutation methods\n", "\n", "  @Override\n", "  @Test\n", "  public void addEdge_selfLoop() {\n", "    assertTrue(addEdge(E11, N1, N1));\n", "    assertThat(graph.edges()).contains(E11);\n", "    assertThat(graph.edgesConnecting(N1, N1)).containsExactly(E11);\n", "  }\n", "\n", "  @Test\n", "  public void addEdge_existingEdgeBetweenDifferentNodes_selfLoops() {\n", "    addEdge(E11, N1, N1);\n", "    try {\n", "      addEdge(E11, N1, N2);\n", "      fail(\"Reusing an existing self-loop edge to connect different nodes succeeded\");\n", "    } catch (IllegalArgumentException e) {\n", "      assertThat(e.getMessage()).contains(ERROR_REUSE_EDGE);\n", "    }\n", "    try {\n", "      addEdge(E11, N2, N2);\n", "      fail(\"Reusing an existing self-loop edge to make a different self-loop edge succeeded\");\n", "    } catch (IllegalArgumentException e) {\n", "      assertThat(e.getMessage()).contains(ERROR_REUSE_EDGE);\n", "    }\n", "    addEdge(E12, N1, N2);\n", "    try {\n", "      addEdge(E12, N1, N1);\n", "      fail(\"Reusing an existing edge to add a self-loop edge between different nodes succeeded\");\n", "    } catch (IllegalArgumentException e) {\n", "      assertThat(e.getMessage()).contains(ERROR_REUSE_EDGE);\n", "    }\n", "  }\n", "\n", "  @Test\n", "  public void addEdge_parallelSelfLoopEdge() {\n", "    addEdge(E11, N1, N1);\n", "    try {\n", "      addEdge(EDGE_NOT_IN_GRAPH, N1, N1);\n", "      fail(\"Adding a parallel self-loop edge succeeded\");\n", "    } catch (IllegalArgumentException e) {\n", "      assertThat(e.getMessage()).contains(ERROR_PARALLEL_EDGE);\n", "    }\n", "  }\n", "\n", "  @Test\n", "  public void toString_selfLoop() {\n", "    addEdge(E11, N1, N1);\n", "    assertThat(graph.toString()).isEqualTo(String.format(\n", "        \"config: %s, nodes: %s, edges: {%s=[%s]}\",\n", "        graph.config(), graph.nodes(), E11, N1));\n", "  }\n", "\n", "  @Override\n", "  protected void populateInputGraph(UndirectedGraph<Integer, String> graph) {\n", "    super.populateInputGraph(graph);\n", "    // add a self-loop\n", "    graph.addEdge(E11, N1, N1);\n", "  }\n", "}\n"]}, "added_lines": {}, "removed_lines": {"1": [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 58, 59, 60, 61, 62, 63, 64, 65, 66, 67, 68, 69, 70, 71, 72, 73, 74, 75, 76, 77, 78, 79, 80, 81, 82, 83, 84, 85, 86, 87, 88, 89, 90, 91, 92, 93, 94, 95, 96, 97, 98, 99, 100, 101, 102, 103, 104, 105, 106, 107, 108, 109, 110, 111, 112, 113, 114, 115, 116, 117, 118, 119, 120, 121, 122, 123, 124, 125, 126, 127, 128, 129, 130, 131, 132, 133, 134, 135, 136, 137, 138, 139, 140, 141, 142, 143, 144, 145, 146, 147, 148, 149, 150, 151, 152, 153, 154, 155, 156, 157, 158, 159, 160, 161, 162, 163, 164, 165, 166, 167, 168, 169, 170, 171, 172, 173, 174, 175, 176, 177, 178, 179, 180, 181, 182, 183, 184, 185, 186, 187, 188, 189, 190, 191, 192, 193, 194, 195, 196, 197, 198, 199, 200]}}, {"22": "guava-tests/test/com/google/common/graph/ImmutableUndirectedMultigraphTest.java", "added": {}, "removed": {"1": ["/*\n", " * Copyright (C) 2014 The Guava Authors\n", " *\n", " * Licensed under the Apache License, Version 2.0 (the \"License\");\n", " * you may not use this file except in compliance with the License.\n", " * You may obtain a copy of the License at\n", " *\n", " * http://www.apache.org/licenses/LICENSE-2.0\n", " *\n", " * Unless required by applicable law or agreed to in writing, software\n", " * distributed under the License is distributed on an \"AS IS\" BASIS,\n", " * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n", " * See the License for the specific language governing permissions and\n", " * limitations under the License.\n", " */\n", "\n", "package com.google.common.graph;\n", "\n", "import static com.google.common.truth.Truth.assertThat;\n", "import static org.junit.Assert.assertTrue;\n", "\n", "import org.junit.Test;\n", "import org.junit.runner.RunWith;\n", "import org.junit.runners.JUnit4;\n", "\n", "/**\n", " * Tests for {@link ImmutableUndirectedGraph} allowing parallel edges.\n", " */\n", "@RunWith(JUnit4.class)\n", "public class ImmutableUndirectedMultigraphTest extends ImmutableUndirectedGraphTest {\n", "\n", "  @Override\n", "  public ImmutableUndirectedGraph<Integer, String> createGraph() {\n", "    builder = ImmutableUndirectedGraph.builder(Graphs.MULTIGRAPH);\n", "    return builder.build();\n", "  }\n", "\n", "  @Test\n", "  public void edgesConnecting_parallelEdges() {\n", "    assertTrue(addEdge(E12, N1, N2));\n", "    assertTrue(addEdge(E12_A, N1, N2));\n", "    assertTrue(addEdge(E21, N2, N1));\n", "    assertThat(undirectedGraph.edgesConnecting(N1, N2)).containsExactly(E12, E12_A, E21);\n", "    assertThat(undirectedGraph.edgesConnecting(N2, N1)).containsExactly(E12, E12_A, E21);\n", "  }\n", "\n", "  @Test\n", "  public void edgesConnecting_parallelSelfLoopEdges() {\n", "    assertTrue(addEdge(E11, N1, N1));\n", "    assertTrue(addEdge(E11_A, N1, N1));\n", "    assertThat(undirectedGraph.edgesConnecting(N1, N1)).containsExactly(E11, E11_A);\n", "  }\n", "\n", "  @Override\n", "  @Test\n", "  public void addEdge_parallelEdge() {\n", "    assertTrue(addEdge(E12, N1, N2));\n", "    assertTrue(addEdge(E12_A, N1, N2));\n", "    assertTrue(addEdge(E21, N2, N1));\n", "    assertThat(undirectedGraph.edges()).containsExactly(E12, E12_A, E21).inOrder();\n", "  }\n", "\n", "  @Override\n", "  @Test\n", "  public void addEdge_parallelSelfLoopEdge() {\n", "    assertTrue(addEdge(E11, N1, N1));\n", "    assertTrue(addEdge(E11_A, N1, N1));\n", "    assertThat(undirectedGraph.edges()).containsExactly(E11, E11_A).inOrder();\n", "  }\n", "\n", "  @Test\n", "  public void toString_parallelEdges() {\n", "    addEdge(E12, N1, N2);\n", "    addEdge(E12_A, N1, N2);\n", "    addEdge(E11, N1, N1);\n", "    addEdge(E11_A, N1, N1);\n", "    assertThat(graph.toString()).isEqualTo(String.format(\n", "        \"config: %s, nodes: %s, edges: {%s=[%s, %s], %s=[%s, %s], %s=[%s], %s=[%s]}\",\n", "        graph.config(),\n", "        graph.nodes(),\n", "        E12, N1, N2,\n", "        E12_A, N1, N2,\n", "        E11, N1,\n", "        E11_A, N1\n", "    ));\n", "  }\n", "\n", "  @Override\n", "  protected void populateInputGraph(UndirectedGraph<Integer, String> graph) {\n", "    super.populateInputGraph(graph);\n", "    // Add some parallel edges\n", "    graph.addEdge(E11_A, N1, N1);\n", "    graph.addEdge(E12_A, N1, N2);\n", "  }\n", "}\n"]}, "added_lines": {}, "removed_lines": {"1": [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 58, 59, 60, 61, 62, 63, 64, 65, 66, 67, 68, 69, 70, 71, 72, 73, 74, 75, 76, 77, 78, 79, 80, 81, 82, 83, 84, 85, 86, 87, 88, 89, 90, 91, 92, 93, 94, 95]}}, {"23": "guava-tests/test/com/google/common/graph/PackageSanityTests.java", "added": {"1": ["import com.google.common.graph.testing.TestGraphBuilder;\n"], "2": ["  private static final GraphBuilder<?, ?> BUILDER_A =\n", "      GraphBuilder.directed().allowsParallelEdges(true).expectedNodeCount(10);\n", "  private static final GraphBuilder<?, ?> BUILDER_B =\n", "      GraphBuilder.directed().allowsSelfLoops(false).expectedNodeCount(16);\n", "  private static final ImmutableGraph<String, String> IMMUTABLE_GRAPH_A =\n", "      TestGraphBuilder.<String, String>init(GraphBuilder.directed())\n", "          .addNode(\"A\")\n", "          .toImmutableGraph();\n", "  private static final ImmutableGraph<String, String> IMMUTABLE_GRAPH_B =\n", "      TestGraphBuilder.<String, String>init(GraphBuilder.directed())\n", "          .addNode(\"B\")\n", "          .toImmutableGraph();\n", "    setDistinctValues(GraphBuilder.class, BUILDER_A, BUILDER_B);\n", "    setDistinctValues(Graph.class, IMMUTABLE_GRAPH_A, IMMUTABLE_GRAPH_B);\n", "    // testEquals() methods in ConfigurableUndirectedGraphTest and ConfigurableDirectedGraphTest.\n", "    // graphs by passing different instances of GraphBuilder into their constructors. However,\n", "    // the GraphBuilder instances are *not* used to determine equality for mutable graphs.\n", "    // Therefore, the tool ends up creating 2 equal mutable instances and it causes failures.\n"]}, "removed": {"2": ["  private static final GraphConfig CONFIG_A = Graphs.config().multigraph().expectedNodeCount(10);\n", "  private static final GraphConfig CONFIG_B = Graphs.config().noSelfLoops().expectedNodeCount(16);\n", "  private static final ImmutableDirectedGraph<String, String> IMMUTABLE_DIRECTED_A =\n", "      ImmutableDirectedGraph.<String, String>builder().addNode(\"A\").build();\n", "  private static final ImmutableDirectedGraph<String, String> IMMUTABLE_DIRECTED_B =\n", "      ImmutableDirectedGraph.<String, String>builder().addNode(\"B\").build();\n", "\n", "  private static final ImmutableUndirectedGraph<String, String> IMMUTABLE_UNDIRECTED_A =\n", "      ImmutableUndirectedGraph.<String, String>builder().addNode(\"A\").build();\n", "  private static final ImmutableUndirectedGraph<String, String> IMMUTABLE_UNDIRECTED_B =\n", "      ImmutableUndirectedGraph.<String, String>builder().addNode(\"B\").build();\n", "    setDistinctValues(GraphConfig.class, CONFIG_A, CONFIG_B);\n", "\n", "    setDistinctValues(DirectedGraph.class, IMMUTABLE_DIRECTED_A, IMMUTABLE_DIRECTED_B);\n", "    setDistinctValues(UndirectedGraph.class, IMMUTABLE_UNDIRECTED_A, IMMUTABLE_UNDIRECTED_B);\n", "    // testEquals() methods in IncidenceSetUndirectedGraphTest and IncidenceSetDirectedGraphTest.\n", "    // graphs by passing different instances of GraphConfig into their constructors. However,\n", "    // the GraphConfig instances are *not* used to determine equality for mutable graphs. Therefore,\n", "    // the tool ends up creating 2 equal mutable instances and it causes failures.\n"]}, "added_lines": {"1": [21], "2": [34, 35, 36, 37, 39, 40, 41, 42, 43, 44, 45, 46, 49, 50, 53, 55, 56, 57]}, "removed_lines": {"2": [33, 34, 36, 37, 38, 39, 40, 41, 42, 43, 44, 47, 48, 49, 50, 53, 55, 56, 57]}}, {"24": "guava/src/com/google/common/graph/AbstractGraph.java", "added": {}, "removed": {"1": ["  protected final GraphConfig config;\n", "\n", "  /**\n", "   * Not all subclasses necessarily need to expose a constructor that takes a {@link GraphConfig},\n", "   * but they do need to provide the {@code config} here that will be returned by {@link #config()}.\n", "   */\n", "  protected AbstractGraph(GraphConfig config) {\n", "    this.config = config;\n", "  }\n", "\n", "  @Override\n", "  public GraphConfig config() {\n", "    return config;\n", "  }\n", "\n"]}, "added_lines": {}, "removed_lines": {"1": [32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46]}}, {"25": "guava/src/com/google/common/graph/AbstractImmutableGraph.java", "added": {}, "removed": {"1": ["/*\n", " * Copyright (C) 2014 The Guava Authors\n", " *\n", " * Licensed under the Apache License, Version 2.0 (the \"License\");\n", " * you may not use this file except in compliance with the License.\n", " * You may obtain a copy of the License at\n", " *\n", " * http://www.apache.org/licenses/LICENSE-2.0\n", " *\n", " * Unless required by applicable law or agreed to in writing, software\n", " * distributed under the License is distributed on an \"AS IS\" BASIS,\n", " * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n", " * See the License for the specific language governing permissions and\n", " * limitations under the License.\n", " */\n", "\n", "package com.google.common.graph;\n", "\n", "import static com.google.common.base.Preconditions.checkArgument;\n", "import static com.google.common.base.Preconditions.checkNotNull;\n", "\n", "import com.google.common.collect.ImmutableMap;\n", "import com.google.common.collect.ImmutableSet;\n", "import com.google.errorprone.annotations.CanIgnoreReturnValue;\n", "\n", "import java.util.Set;\n", "\n", "/**\n", " * Abstract base class for implementation of immutable graphs.\n", " *\n", " * <p>All mutation methods throw {@link UnsupportedOperationException} as the graph\n", " * can't be modified.\n", " *\n", " * <p>The time complexity of {@code edgesConnecting(node1, node2)} is O(min(outD_node1, inD_node2)).\n", " *\n", " * @author James Sexton\n", " * @author Joshua O'Madadhain\n", " * @author Omar Darwish\n", " * @param <N> Node parameter type\n", " * @param <E> Edge parameter type\n", " */\n", "//TODO(user): Add support for sorted nodes/edges and/or hypergraphs.\n", "abstract class AbstractImmutableGraph<N, E> extends AbstractConfigurableGraph<N, E> {\n", "\n", "  AbstractImmutableGraph(Builder<N, E> builder) {\n", "    super(builder.graph.config(), builder.getNodeConnections(), builder.getEdgeToIncidentNodes());\n", "  }\n", "\n", "  @Override\n", "  final NodeConnections<N, E> newNodeConnections() {\n", "    throw new UnsupportedOperationException();\n", "  }\n", "\n", "  @Override\n", "  public final boolean addNode(N node) {\n", "    throw new UnsupportedOperationException();\n", "  }\n", "\n", "  @Override\n", "  public final boolean addEdge(E edge, N node1, N node2) {\n", "    throw new UnsupportedOperationException();\n", "  }\n", "\n", "  @Override\n", "  public final boolean removeNode(Object node) {\n", "    throw new UnsupportedOperationException();\n", "  }\n", "\n", "  @Override\n", "  public final boolean removeEdge(Object edge) {\n", "    throw new UnsupportedOperationException();\n", "  }\n", "\n", "  @Override\n", "  public Set<E> edgesConnecting(Object node1, Object node2) {\n", "    // This set is calculated as the intersection of two sets, and is likely to be small.\n", "    // As an optimization, copy it to an ImmutableSet so re-iterating is fast.\n", "    return ImmutableSet.copyOf(super.edgesConnecting(node1, node2));\n", "  }\n", "\n", "  /**\n", "   * An abstract class for builders of immutable graph instances.\n", "   *\n", "   * @param <N> Node parameter type\n", "   * @param <E> Edge parameter type\n", "   */\n", "  abstract static class Builder<N, E> {\n", "\n", "    final Graph<N, E> graph;\n", "\n", "    Builder(Graph<N, E> graph) {\n", "      this.graph = checkNotNull(graph, \"graph\");\n", "    }\n", "\n", "    abstract NodeConnections<N, E> nodeConnectionsOf(N node);\n", "\n", "    /**\n", "     * Creates and returns a new instance of {@code AbstractImmutableGraph}\n", "     * based on the contents of the {@code Builder}.\n", "     */\n", "    public abstract AbstractImmutableGraph<N, E> build();\n", "\n", "    /**\n", "     * Adds {@code node} to the graph being built.\n", "     *\n", "     * @return this {@code Builder} instance\n", "     * @throws NullPointerException if {@code node} is null\n", "     */\n", "    @CanIgnoreReturnValue\n", "    public Builder<N, E> addNode(N node) {\n", "      graph.addNode(node);\n", "      return this;\n", "    }\n", "\n", "    /**\n", "     * Adds {@code edge} to the graph being built, connecting {@code node1} and {@code node2};\n", "     * adds {@code node1} and {@code node2} if not already present.\n", "     *\n", "     * @return this {@code Builder} instance\n", "     * @throws IllegalArgumentException when {@code Graph.addEdge(edge, node1, node2)} throws\n", "     *     on the graph being built\n", "     * @throws NullPointerException if {@code edge}, {@code node1}, or {@code node2} is null\n", "     * @see Graph#addEdge\n", "     */\n", "    @CanIgnoreReturnValue\n", "    public Builder<N, E> addEdge(E edge, N node1, N node2) {\n", "      graph.addEdge(edge, node1, node2);\n", "      return this;\n", "    }\n", "\n", "    /**\n", "     * Adds all elements of {@code graph} to the graph being built.\n", "     *\n", "     * @throws IllegalArgumentException under either of two conditions:\n", "     *     (1) the {@code GraphConfig} objects held by the graph being built and by {@code graph}\n", "     *     are not compatible\n", "     *     (2) calling {@link Graphs#addEdge} on the graph being built throws IAE\n", "     * @see Graph#addEdge\n", "     */\n", "    @CanIgnoreReturnValue\n", "    public Builder<N, E> addGraph(Graph<N, E> graphToAdd) {\n", "      checkArgument(\n", "          graph.config().compatibleWith(graphToAdd.config()),\n", "          \"GraphConfigs for input and for graph being built are not compatible: input: %s, \"\n", "              + \"this graph: %s\",\n", "          graphToAdd.config(),\n", "          graph.config());\n", "\n", "      for (N node : graphToAdd.nodes()) {\n", "        graph.addNode(node);\n", "      }\n", "      for (E edge : graphToAdd.edges()) {\n", "        Graphs.addEdge(graph, edge, graphToAdd.incidentNodes(edge));\n", "      }\n", "      return this;\n", "    }\n", "\n", "    private ImmutableMap<N, NodeConnections<N, E>> getNodeConnections() {\n", "      ImmutableMap.Builder<N, NodeConnections<N, E>> nodeConnections = ImmutableMap.builder();\n", "      for (N node : graph.nodes()) {\n", "        nodeConnections.put(node, nodeConnectionsOf(node));\n", "      }\n", "      return nodeConnections.build();\n", "    }\n", "\n", "    private ImmutableMap<E, IncidentNodes<N>> getEdgeToIncidentNodes() {\n", "      ImmutableMap.Builder<E, IncidentNodes<N>> edgeToIncidentNodes = ImmutableMap.builder();\n", "      for (E edge : graph.edges()) {\n", "        edgeToIncidentNodes.put(edge, IncidentNodes.of(graph.incidentNodes(edge)));\n", "      }\n", "      return edgeToIncidentNodes.build();\n", "    }\n", "  }\n", "}\n"]}, "added_lines": {}, "removed_lines": {"1": [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 58, 59, 60, 61, 62, 63, 64, 65, 66, 67, 68, 69, 70, 71, 72, 73, 74, 75, 76, 77, 78, 79, 80, 81, 82, 83, 84, 85, 86, 87, 88, 89, 90, 91, 92, 93, 94, 95, 96, 97, 98, 99, 100, 101, 102, 103, 104, 105, 106, 107, 108, 109, 110, 111, 112, 113, 114, 115, 116, 117, 118, 119, 120, 121, 122, 123, 124, 125, 126, 127, 128, 129, 130, 131, 132, 133, 134, 135, 136, 137, 138, 139, 140, 141, 142, 143, 144, 145, 146, 147, 148, 149, 150, 151, 152, 153, 154, 155, 156, 157, 158, 159, 160, 161, 162, 163, 164, 165, 166, 167, 168, 169, 170, 171, 172, 173, 174]}}, {"26": "guava/src/com/google/common/graph/ConfigurableGraph.java", "added": {"1": ["import static com.google.common.graph.GraphErrorMessageUtils.NOT_AVAILABLE_ON_UNDIRECTED;\n"], "2": [" * Instances of this class should be constructed with {@link GraphBuilder}.\n"], "3": [" * <p>The time complexity of all {@code Set}-returning accessors is O(1), since views are returned.\n", " *\n", " * <p>Time complexities for mutation methods:\n", " * <ul>\n", " * <li>{@code addNode(N node)}: O(1).\n", " * <li>{@code addEdge(E edge, N node1, N node2)}: O(1).\n", " * <li>{@code removeNode(N node)}: O(d_node).\n", " * <li>{@code removeEdge(E edge)}: O(1), unless this graph allows parallel edges;\n", " *     in that case this method is O(min(outD_edgeSource, inD_edgeTarget)).\n", " * </ul>\n", " * where d_node is the degree of node, inD_node is the in-degree of node, and outD_node is the\n", " * out-degree of node.\n", "class ConfigurableGraph<N, E> extends AbstractGraph<N, E> {\n", "  private final boolean isDirected;\n", "  private final boolean allowsParallelEdges;\n", "  private final boolean allowsSelfLoops;\n", "\n", "   * Constructs a mutable graph with the properties specified in {@code builder}.\n", "  ConfigurableGraph(GraphBuilder<? super N, ? super E> builder) {\n", "    this(\n", "        builder,\n", "        Maps.<N, NodeConnections<N, E>>newLinkedHashMapWithExpectedSize(\n", "            builder.expectedNodeCount.or(DEFAULT_MAP_SIZE)),\n", "        Maps.<E, IncidentNodes<N>>newLinkedHashMapWithExpectedSize(\n", "            builder.expectedEdgeCount.or(DEFAULT_MAP_SIZE)));\n", "   * Constructs a graph with the properties specified in {@code builder}, initialized with\n", "   * the given node and edge maps. May be used for either mutable or immutable graphs.\n", "  ConfigurableGraph(GraphBuilder<? super N, ? super E> builder,\n", "      Map<N, NodeConnections<N, E>> nodeConnections,\n", "    this.isDirected = builder.directed;\n", "    this.allowsParallelEdges = builder.allowsParallelEdges;\n", "    this.allowsSelfLoops = builder.allowsSelfLoops;\n", "    this.nodeConnections = checkNotNull(nodeConnections);\n", "    this.edgeToIncidentNodes = checkNotNull(edgeToIncidentNodes);\n"], "4": ["  @Override\n", "  public boolean isDirected() {\n", "    return isDirected;\n", "  }\n", "\n", "  @Override\n", "  public boolean allowsParallelEdges() {\n", "    return allowsParallelEdges;\n", "  }\n", "\n", "  @Override\n", "  public boolean allowsSelfLoops() {\n", "    return allowsSelfLoops;\n", "  }\n", "\n"], "5": ["      if (!allowsSelfLoops) {\n"], "6": ["  @Override\n", "  public N source(Object edge) {\n", "    if (!isDirected) {\n", "      throw new UnsupportedOperationException(NOT_AVAILABLE_ON_UNDIRECTED);\n", "    }\n", "    return checkedIncidentNodes(edge).node1();\n", "  }\n", "\n", "  @Override\n", "  public N target(Object edge) {\n", "    if (!isDirected) {\n", "      throw new UnsupportedOperationException(NOT_AVAILABLE_ON_UNDIRECTED);\n", "    }\n", "    return checkedIncidentNodes(edge).node2();\n", "  }\n", "\n"], "7": ["    checkArgument(allowsSelfLoops || !incidentNodes.isSelfLoop(), SELF_LOOPS_NOT_ALLOWED, node1);\n", "    } else if (!allowsParallelEdges) {\n"], "8": ["  private NodeConnections<N, E> newNodeConnections() {\n", "    return isDirected\n", "        ? DirectedNodeConnections.<N, E>of()\n", "        : UndirectedNodeConnections.<N, E>of();\n", "  }\n", "\n", "  private NodeConnections<N, E> checkedConnections(Object node) {\n", "  private IncidentNodes<N> checkedIncidentNodes(Object edge) {\n"]}, "removed": {"3": [" * <p>The time complexity of all {@code Set}-returning accessors is O(1), since we\n", " * are returning views.\n", " * @see Graph\n", "abstract class AbstractConfigurableGraph<N, E> extends AbstractGraph<N, E> {\n", "   * Constructs a mutable graph with the specified configuration.\n", "  AbstractConfigurableGraph(GraphConfig config) {\n", "    super(config);\n", "    this.nodeConnections =\n", "        Maps.newLinkedHashMapWithExpectedSize(config.getExpectedNodeCount().or(DEFAULT_MAP_SIZE));\n", "    this.edgeToIncidentNodes =\n", "        Maps.newLinkedHashMapWithExpectedSize(config.getExpectedEdgeCount().or(DEFAULT_MAP_SIZE));\n", "   * Constructs a graph with the specified configuration and node/edge relationships.\n", "   * May be used for immutable graphs.\n", "  AbstractConfigurableGraph(GraphConfig config, Map<N, NodeConnections<N, E>> nodeConnections,\n", "    super(config);\n", "    this.nodeConnections = nodeConnections;\n", "    this.edgeToIncidentNodes = edgeToIncidentNodes;\n", "  abstract NodeConnections<N, E> newNodeConnections();\n", "\n"], "5": ["      if (!config.isSelfLoopsAllowed()) {\n"], "7": ["    checkArgument(config.isSelfLoopsAllowed() || !incidentNodes.isSelfLoop(),\n", "        SELF_LOOPS_NOT_ALLOWED, node1);\n", "    } else if (!config.isMultigraph()) {\n"], "8": ["  NodeConnections<N, E> checkedConnections(Object node) {\n", "  IncidentNodes<N> checkedIncidentNodes(Object edge) {\n"]}, "added_lines": {"1": [24], "2": [41], "3": [57, 58, 59, 60, 61, 62, 63, 64, 65, 66, 67, 68, 77, 81, 82, 83, 84, 89, 91, 92, 93, 94, 95, 96, 97, 101, 102, 104, 105, 107, 108, 109, 110, 111], "4": [124, 125, 126, 127, 128, 129, 130, 131, 132, 133, 134, 135, 136, 137, 138], "5": [177], "6": [209, 210, 211, 212, 213, 214, 215, 216, 217, 218, 219, 220, 221, 222, 223, 224], "7": [254, 261], "8": [332, 333, 334, 335, 336, 337, 338, 345]}, "removed_lines": {"3": [55, 56, 63, 66, 74, 76, 77, 78, 79, 80, 81, 85, 86, 88, 90, 91, 92, 95, 96], "5": [145], "7": [206, 207, 214], "8": [285, 292]}}, {"27": "guava/src/com/google/common/graph/DirectedGraph.java", "added": {}, "removed": {"1": ["/*\n", " * Copyright (C) 2014 The Guava Authors\n", " *\n", " * Licensed under the Apache License, Version 2.0 (the \"License\");\n", " * you may not use this file except in compliance with the License.\n", " * You may obtain a copy of the License at\n", " *\n", " * http://www.apache.org/licenses/LICENSE-2.0\n", " *\n", " * Unless required by applicable law or agreed to in writing, software\n", " * distributed under the License is distributed on an \"AS IS\" BASIS,\n", " * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n", " * See the License for the specific language governing permissions and\n", " * limitations under the License.\n", " */\n", "\n", "package com.google.common.graph;\n", "\n", "import com.google.common.annotations.Beta;\n", "import com.google.errorprone.annotations.CanIgnoreReturnValue;\n", "\n", "import java.util.Set;\n", "\n", "/**\n", " * A subinterface of {@code Graph} for graphs whose edges are all directed.\n", " *\n", " * @author Joshua O'Madadhain\n", " * @param <N> Node parameter type\n", " * @param <E> Edge parameter type\n", " * @since 20.0\n", " */\n", "@Beta\n", "public interface DirectedGraph<N, E> extends Graph<N, E> {\n", "  /**\n", "   * Returns the node for which {@code edge} is an outgoing edge.\n", "   *\n", "   * @throws IllegalArgumentException if {@code edge} is not an element of this graph\n", "   */\n", "  N source(Object edge);\n", "\n", "  /**\n", "   * Returns the node for which {@code edge} is an incoming edge.\n", "   *\n", "   * @throws IllegalArgumentException if {@code edge} is not an element of this graph\n", "   */\n", "  N target(Object edge);\n", "\n", "  /**\n", "   * {@inheritDoc}\n", "   *\n", "   * <p>If {@code edge} is not a self-loop, the iteration order will be\n", "   * {@code [source(edge), target(edge)]}.\n", "   *\n", "   */\n", "  @Override\n", "  Set<N> incidentNodes(Object edge);\n", "\n", "  /**\n", "   * {@inheritDoc}\n", "   *\n", "   * <p>The {@linkplain #source(Object) source} and {@linkplain #target(Object) target}\n", "   * of the edges returned must be {@code source} and {@code target}, respectively.\n", "   *\n", "   */\n", "  @Override\n", "  Set<E> edgesConnecting(Object source, Object target);\n", "\n", "  /**\n", "   * {@inheritDoc}\n", "   *\n", "   * <p>{@code edge} is an outgoing edge of {@code source} and an incoming edge of {@code target}.\n", "   */\n", "  @Override\n", "  @CanIgnoreReturnValue\n", "  boolean addEdge(E edge, N source, N target);\n", "}\n"]}, "added_lines": {}, "removed_lines": {"1": [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 58, 59, 60, 61, 62, 63, 64, 65, 66, 67, 68, 69, 70, 71, 72, 73, 74, 75, 76]}}, {"28": "guava/src/com/google/common/graph/Graph.java", "added": {"1": ["  //\n", "  // Graph properties\n", "  //\n", "\n", "  /**\n", "   * Returns true if the edges in this graph have a direction associated with them.\n", "   *\n", "   * <p>A directed edge is an {@linkplain #outEdges(Object) outgoing edge} of its\n", "   * {@linkplain #source(Object) source}, and an {@linkplain #inEdges(Object) incoming edge} of its\n", "   * {@linkplain #target(Object) target}. An undirected edge connects its\n", "   * {@linkplain #incidentNodes(Object) incident nodes} to each other, and is both an\n", "   * {@linkplain #outEdges(Object) outgoing edge} and {@linkplain #inEdges(Object) incoming edge}\n", "   * of each incident node.\n", "   */\n", "  boolean isDirected();\n", "\n", "  /**\n", "   * Returns true if this graph allows parallel edges. Attempting to add a parallel edge to a graph\n", "   * that does not allow them will throw an {@link UnsupportedOperationException}.\n", "   */\n", "  boolean allowsParallelEdges();\n", "\n", "  /**\n", "   * Returns true if this graph allows self-loops (edges that connect a node to itself).\n", "   * Attempting to add a self-loop to a graph that does not allow them will throw an\n", "   * {@link UnsupportedOperationException}.\n", "   */\n", "  boolean allowsSelfLoops();\n"], "2": ["   * <p>For self-loop edges, the returned set's size will be 1. If the graph is\n", "   * {@linkplain #isDirected() directed} and {@code edge} is not a self-loop, the\n", "   * iteration order will be {@code [source(edge), target(edge)]}.\n"], "3": ["   * Returns the set of edges that connect {@code node1} to {@code node2}.\n", "   *\n", "   * <p>This set is the intersection of {@code outEdges(node1)} and {@code inEdges(node2)}. If\n", "   * {@code node1} is equal to {@code node2}, then it is the set of self-loop edges for that node.\n"], "4": ["  /**\n", "   * For a directed graph, returns the node for which {@code edge} is an outgoing edge.\n", "   * For an undirected graph, throws an {@link UnsupportedOperationException}.\n", "   */\n", "  N source(Object edge);\n", "\n", "  /**\n", "   * For a directed graph, returns the node for which {@code edge} is an incoming edge.\n", "   * For an undirected graph, throws an {@link UnsupportedOperationException}.\n", "   */\n", "  N target(Object edge);\n", "\n"], "5": ["   * Adds {@code edge} to this graph, connecting {@code node1} to {@code node2}\n"], "6": ["   * <p>Graph properties are <b>not</b> respected by this method. For example, two graphs may be\n", "   * considered equal even if one allows parallel edges and the other doesn't. Additionally, the\n", "   * order in which edges or nodes are added to the graph, and the order in which they are iterated\n", "   * over, are irrelevant.\n"]}, "removed": {"1": ["  /** Returns the {@link GraphConfig} that defines this instance's configuration. */\n", "  GraphConfig config();\n"], "2": ["   * <p>For non-hypergraphs, the returned set will always contain either one\n", "   * (if {@code edge} is a self-loop) or two nodes.\n"], "3": ["   * Returns the edges that are {@linkplain #incidentEdges(Object) incident} in this graph\n", "   * to both nodes {@code node1} and {@code node2}.\n"], "5": ["   * Adds {@code edge} to this graph, connecting {@code node1} and {@code node2}\n"], "6": ["   * <p>Properties that are <b>not</b> respected by this method:\n", "   * <ul>\n", "   * <li>{@code GraphConfig} configurations.  If two graphs are equal by the above criteria but have\n", "   * different configurations, they are still equal.  (For example: two graphs may be considered\n", "   * equal even if one allows parallel edges and the other doesn't.)\n", "   * <li>Edge/node ordering.  The order in which edges or nodes are added to the graph, and the\n", "   * order in which they are iterated over, are irrelevant.\n", "   * </ul>\n"]}, "added_lines": {"1": [214, 215, 216, 217, 218, 219, 220, 221, 222, 223, 224, 225, 226, 227, 228, 229, 230, 231, 232, 233, 234, 235, 236, 237, 238, 239, 240, 241], "2": [257, 258, 259], "3": [285, 286, 287, 288], "4": [336, 337, 338, 339, 340, 341, 342, 343, 344, 345, 346, 347], "5": [400], "6": [457, 458, 459, 460]}, "removed_lines": {"1": [214, 215], "2": [231, 232], "3": [258, 259], "5": [359], "6": [416, 417, 418, 419, 420, 421, 422, 423]}}, {"29": "guava/src/com/google/common/graph/GraphBuilder.java", "added": {"1": ["/*\n", " * Copyright (C) 2016 The Guava Authors\n", " *\n", " * Licensed under the Apache License, Version 2.0 (the \"License\");\n", " * you may not use this file except in compliance with the License.\n", " * You may obtain a copy of the License at\n", " *\n", " * http://www.apache.org/licenses/LICENSE-2.0\n", " *\n", " * Unless required by applicable law or agreed to in writing, software\n", " * distributed under the License is distributed on an \"AS IS\" BASIS,\n", " * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n", " * See the License for the specific language governing permissions and\n", " * limitations under the License.\n", " */\n", "\n", "package com.google.common.graph;\n", "\n", "import static com.google.common.base.Preconditions.checkArgument;\n", "\n", "import com.google.common.base.Optional;\n", "\n", "import java.util.Comparator;\n", "\n", "/**\n", " * A builder for constructing instances of {@link Graph} with user-defined properties.\n", " *\n", " * <p>A graph built by this class will have the following properties by default:\n", " * <ul>\n", " * <li>does not allow parallel edges\n", " * <li>allows self-loops\n", " * </ul>\n", " *\n", " * @author James Sexton\n", " * @author Joshua O'Madadhain\n", " * @since 20.0\n", " */\n", "// TODO(b/24620028): Add support for sorted nodes/edges. Use the same pattern as CacheBuilder\n", "// to narrow the generic <N, E> type when Comparators are provided.\n", "public final class GraphBuilder<N, E> {\n", "  Boolean directed = null; // No default value to enforce that this is set before building\n", "  boolean allowsParallelEdges = false;\n", "  boolean allowsSelfLoops = true;\n", "  Comparator<N> nodeComparator = null;\n", "  Comparator<E> edgeComparator = null;\n", "  Optional<Integer> expectedNodeCount = Optional.absent();\n", "  Optional<Integer> expectedEdgeCount = Optional.absent();\n", "\n", "  private GraphBuilder() {}\n", "\n", "  /**\n", "   * Returns a {@link GraphBuilder} for building directed graphs.\n", "   */\n", "  public static GraphBuilder<Object, Object> directed() {\n", "    return new GraphBuilder<Object, Object>().directed(true);\n", "  }\n", "\n", "  /**\n", "   * Returns a {@link GraphBuilder} for building undirected graphs.\n", "   */\n", "  public static GraphBuilder<Object, Object> undirected() {\n", "    return new GraphBuilder<Object, Object>().directed(false);\n", "  }\n", "\n", "  /**\n", "   * Returns a {@link GraphBuilder} initialized with all properties queryable from {@code graph}.\n", "   *\n", "   * <p>The \"queryable\" properties are those that are exposed through the {@link Graph} interface,\n", "   * such as {@link Graph#isDirected()}. Other properties, such as {@link #expectedNodeCount(int)},\n", "   * are not set in the new builder.\n", "   */\n", "  public static <N, E> GraphBuilder<N, E> from(Graph<N, E> graph) {\n", "    return new GraphBuilder<N, E>()\n", "        .directed(graph.isDirected())\n", "        .allowsParallelEdges(graph.allowsParallelEdges())\n", "        .allowsSelfLoops(graph.allowsSelfLoops());\n", "  }\n", "\n", "  /**\n", "   * This value should be set by {@link #directed()}, {@link #undirected()},\n", "   * or {@link #from(Graph)}.\n", "   */\n", "  private GraphBuilder<N, E> directed(boolean directed) {\n", "    this.directed = directed;\n", "    return this;\n", "  }\n", "\n", "  /**\n", "   * Specifies whether the graph will allow parallel edges. Attempting to add a parallel edge to\n", "   * a graph that does not allow them will throw an {@link UnsupportedOperationException}.\n", "   */\n", "  public GraphBuilder<N, E> allowsParallelEdges(boolean allowsParallelEdges) {\n", "    this.allowsParallelEdges = allowsParallelEdges;\n", "    return this;\n", "  }\n", "\n", "  /**\n", "   * Specifies whether the graph will allow self-loops (edges that connect a node to itself).\n", "   * Attempting to add a self-loop to a graph that does not allow them will throw an\n", "   * {@link UnsupportedOperationException}.\n", "   */\n", "  public GraphBuilder<N, E> allowsSelfLoops(boolean allowsSelfLoops) {\n", "    this.allowsSelfLoops = allowsSelfLoops;\n", "    return this;\n", "  }\n", "\n", "  /**\n", "   * Specifies the expected number of nodes in the graph.\n", "   *\n", "   * @throws IllegalArgumentException if {@code expectedNodeCount} is negative\n", "   */\n", "  public GraphBuilder<N, E> expectedNodeCount(int expectedNodeCount) {\n", "    checkArgument(expectedNodeCount >= 0, \"The expected number of nodes can't be negative: %s\",\n", "        expectedNodeCount);\n", "    this.expectedNodeCount = Optional.of(expectedNodeCount);\n", "    return this;\n", "  }\n", "\n", "  /**\n", "   * Specifies the expected number of edges in the graph.\n", "   *\n", "   * @throws IllegalArgumentException if {@code expectedEdgeCount} is negative\n", "   */\n", "  public GraphBuilder<N, E> expectedEdgeCount(int expectedEdgeCount) {\n", "    checkArgument(expectedEdgeCount >= 0, \"The expected number of edges can't be negative: %s\",\n", "        expectedEdgeCount);\n", "    this.expectedEdgeCount = Optional.of(expectedEdgeCount);\n", "    return this;\n", "  }\n", "\n", "  /**\n", "   * Returns an empty mutable {@link Graph} with the properties of this {@link GraphBuilder}.\n", "   */\n", "  public <N1 extends N, E1 extends E> Graph<N1, E1> build() {\n", "    return new ConfigurableGraph<N1, E1>(this);\n", "  }\n", "}\n"]}, "removed": {}, "added_lines": {"1": [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 58, 59, 60, 61, 62, 63, 64, 65, 66, 67, 68, 69, 70, 71, 72, 73, 74, 75, 76, 77, 78, 79, 80, 81, 82, 83, 84, 85, 86, 87, 88, 89, 90, 91, 92, 93, 94, 95, 96, 97, 98, 99, 100, 101, 102, 103, 104, 105, 106, 107, 108, 109, 110, 111, 112, 113, 114, 115, 116, 117, 118, 119, 120, 121, 122, 123, 124, 125, 126, 127, 128, 129, 130, 131, 132, 133, 134, 135, 136, 137]}, "removed_lines": {}}, {"30": "guava/src/com/google/common/graph/GraphConfig.java", "added": {}, "removed": {"1": ["/*\n", " * Copyright (C) 2014 The Guava Authors\n", " *\n", " * Licensed under the Apache License, Version 2.0 (the \"License\");\n", " * you may not use this file except in compliance with the License.\n", " * You may obtain a copy of the License at\n", " *\n", " * http://www.apache.org/licenses/LICENSE-2.0\n", " *\n", " * Unless required by applicable law or agreed to in writing, software\n", " * distributed under the License is distributed on an \"AS IS\" BASIS,\n", " * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n", " * See the License for the specific language governing permissions and\n", " * limitations under the License.\n", " */\n", "\n", "package com.google.common.graph;\n", "\n", "import static com.google.common.base.Preconditions.checkArgument;\n", "import static com.google.common.base.Preconditions.checkNotNull;\n", "\n", "import com.google.common.annotations.Beta;\n", "import com.google.common.base.Joiner;\n", "import com.google.common.base.Objects;\n", "import com.google.common.base.Optional;\n", "import com.google.common.collect.Lists;\n", "\n", "import java.util.List;\n", "\n", "import javax.annotation.Nullable;\n", "\n", "/**\n", " * A class for configuring different types of graphs.\n", " *\n", " * <p>{@code Graphs.config()} should be used to get an instance of this class.\n", " *\n", " * <p>Currently, this class supports the following graph configurations (all combinations\n", " * of these properties are valid unless stated otherwise):\n", " * <ul>\n", " * <li>Multigraphs.\n", " * <li>Expected number of nodes/edges.\n", " * <li>Self-loop edges.\n", " * </ul>\n", " *\n", " * <p>Default graph configuration:\n", " * <ul>\n", " * <li>Self-loop edges are allowed.\n", " * <li>It is not a multigraph: parallel edges (multiple edges directed from n1\n", " *     to n2, or between them in case of undirected graphs) are not allowed.\n", " * <li>In case of directed graphs, anti-parallel edges (same incident nodes but\n", " *     in opposite direction, e.g. (n1, n2) and (n2, n1)) are allowed.\n", " * <li>Nodes and edges are not sorted.\n", " * </ul>\n", " *\n", " * <p>{@code GraphConfig} instances are thread-safe immutable, and are therefore safe to\n", " * store as {@code static final} constants.\n", " *\n", " * @author Joshua O'Madadhain\n", " * @see Graphs\n", " * @since 20.0\n", " */\n", "// TODO(user): Add support for sorted nodes/edges. Use Object as\n", "//     the node and edge types in this case: the same scheme used in CacheBuilder.\n", "// TODO(user): Add support for hypergraphs.\n", "// TODO(user): Handle sorted nodes/edges and expected number of nodes/edges together,\n", "//     in case sorted nodes/edges is supported.\n", "@Beta\n", "public final class GraphConfig {\n", "  private final boolean multigraph;\n", "  private final boolean selfLoopsAllowed;\n", "  private final Optional<Integer> expectedNodeCount;\n", "  private final Optional<Integer> expectedEdgeCount;\n", "\n", "  // Creates an instance of this class with the default graph configuration.\n", "  GraphConfig() {\n", "    multigraph = false;\n", "    selfLoopsAllowed = true;\n", "    expectedNodeCount = Optional.absent();\n", "    expectedEdgeCount = Optional.absent();\n", "  }\n", "\n", "  private GraphConfig(\n", "      boolean multigraph,\n", "      boolean selfLoopsAllowed,\n", "      Optional<Integer> expectedNodeCount,\n", "      Optional<Integer> expectedEdgeCount) {\n", "    this.multigraph = multigraph;\n", "    this.selfLoopsAllowed = selfLoopsAllowed;\n", "    this.expectedNodeCount = expectedNodeCount;\n", "    this.expectedEdgeCount = expectedEdgeCount;\n", "  }\n", "\n", "  public boolean isMultigraph() {\n", "    return multigraph;\n", "  }\n", "\n", "  public boolean isSelfLoopsAllowed() {\n", "    return selfLoopsAllowed;\n", "  }\n", "\n", "  public Optional<Integer> getExpectedNodeCount() {\n", "    return expectedNodeCount;\n", "  }\n", "\n", "  public Optional<Integer> getExpectedEdgeCount() {\n", "    return expectedEdgeCount;\n", "  }\n", "\n", "  /**\n", "   * Specifies the expected number of nodes in the graph configuration.\n", "   *\n", "   * @return a new {@code GraphConfig} instance that augments the existing configuration\n", "   *         by specifying the expected number of nodes.\n", "   * @throws IllegalArgumentException if {@code expectedNodeCount} is negative\n", "   */\n", "  public GraphConfig expectedNodeCount(int expectedNodeCount) {\n", "    checkArgument(expectedNodeCount >= 0, \"The expected number of nodes can't be negative\");\n", "    return new GraphConfig(\n", "        multigraph, selfLoopsAllowed, Optional.of(expectedNodeCount), expectedEdgeCount);\n", "  }\n", "\n", "  /**\n", "   * Specifies the expected number of edges in the graph configuration.\n", "   *\n", "   * @return a new {@code GraphConfig} instance that augments the existing configuration\n", "   *         by specifying the expected number of edges.\n", "   * @throws IllegalArgumentException if {@code expectedEdgeCount} is negative\n", "   */\n", "  public GraphConfig expectedEdgeCount(int expectedEdgeCount) {\n", "    checkArgument(expectedEdgeCount >= 0, \"The expected number of edges can't be negative\");\n", "    return new GraphConfig(\n", "        multigraph, selfLoopsAllowed, expectedNodeCount, Optional.of(expectedEdgeCount));\n", "  }\n", "\n", "  /**\n", "   * Specifies that this graph is a multigraph (allows parallel edges).\n", "   *\n", "   * @return a new {@code GraphConfig} instance that augments the existing configuration\n", "   *         by allowing parallel edges (multigraph).\n", "   */\n", "  public GraphConfig multigraph() {\n", "    return new GraphConfig(true, selfLoopsAllowed, expectedNodeCount, expectedEdgeCount);\n", "  }\n", "\n", "  /**\n", "   * Specifies that this graph does not allow self-loop edges.\n", "   *\n", "   * @return a new {@code GraphConfig} instance that augments the existing configuration\n", "   *         by disallowing self-loop edges.\n", "   */\n", "  public GraphConfig noSelfLoops() {\n", "    return new GraphConfig(multigraph, false, expectedNodeCount, expectedEdgeCount);\n", "  }\n", "\n", "  /**\n", "   * Returns true iff the configuration defined by this object is <i>compatible with</i> the\n", "   * configuration defined by {@code that}.  Intuitively, this checks for structural properties\n", "   * and ignores non-structural properties.  Specifically, this method checks whether the\n", "   * configurations have compatible support for:\n", "   * <ul>\n", "   * <li>parallel edges\n", "   * <li>self-loops\n", "   * </ul>\n", "   *\n", "   * By \"compatible with\", we mean that this instance must be at least as permissive as the input\n", "   * config ({@code that}).  Thus, for example, if the input permits parallel edges, this instance\n", "   * must also permit parallel edges in order for the configurations to be compatible.\n", "   *\n", "   * <p>It does not compare expected values for numbers of edges or nodes,\n", "   * and it is not equivalent to {@code Object.equals}.\n", "   */\n", "  public boolean compatibleWith(GraphConfig that) {\n", "    checkNotNull(that, \"that\");\n", "    if (that.multigraph && !this.multigraph) {\n", "      return false;\n", "    }\n", "    if (that.selfLoopsAllowed && !this.selfLoopsAllowed) {\n", "      return false;\n", "    }\n", "    return true;\n", "  }\n", "\n", "  @Override\n", "  public boolean equals(@Nullable Object object) {\n", "    if (object instanceof GraphConfig) {\n", "      GraphConfig that = (GraphConfig) object;\n", "      return this.multigraph == that.multigraph\n", "          && this.selfLoopsAllowed == that.selfLoopsAllowed\n", "          && this.expectedNodeCount.equals(that.expectedNodeCount)\n", "          && this.expectedEdgeCount.equals(that.expectedEdgeCount);\n", "    }\n", "    return false;\n", "  }\n", "\n", "  @Override\n", "  public int hashCode() {\n", "    return Objects.hashCode(expectedNodeCount, expectedEdgeCount, multigraph, selfLoopsAllowed);\n", "  }\n", "\n", "  @Override\n", "  public String toString() {\n", "    List<String> properties = Lists.newArrayList();\n", "    if (multigraph) {\n", "      properties.add(\"multigraph\");\n", "    }\n", "\n", "    if (selfLoopsAllowed) {\n", "      properties.add(\"self-loops allowed\");\n", "    } else {\n", "      properties.add(\"self-loops disallowed\");\n", "    }\n", "\n", "    return Joiner.on(',').join(properties);\n", "  }\n", "}\n"]}, "added_lines": {}, "removed_lines": {"1": [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 58, 59, 60, 61, 62, 63, 64, 65, 66, 67, 68, 69, 70, 71, 72, 73, 74, 75, 76, 77, 78, 79, 80, 81, 82, 83, 84, 85, 86, 87, 88, 89, 90, 91, 92, 93, 94, 95, 96, 97, 98, 99, 100, 101, 102, 103, 104, 105, 106, 107, 108, 109, 110, 111, 112, 113, 114, 115, 116, 117, 118, 119, 120, 121, 122, 123, 124, 125, 126, 127, 128, 129, 130, 131, 132, 133, 134, 135, 136, 137, 138, 139, 140, 141, 142, 143, 144, 145, 146, 147, 148, 149, 150, 151, 152, 153, 154, 155, 156, 157, 158, 159, 160, 161, 162, 163, 164, 165, 166, 167, 168, 169, 170, 171, 172, 173, 174, 175, 176, 177, 178, 179, 180, 181, 182, 183, 184, 185, 186, 187, 188, 189, 190, 191, 192, 193, 194, 195, 196, 197, 198, 199, 200, 201, 202, 203, 204, 205, 206, 207, 208, 209, 210, 211, 212, 213, 214, 215]}}, {"31": "guava/src/com/google/common/graph/GraphErrorMessageUtils.java", "added": {"1": ["  static final String NOT_AVAILABLE_ON_UNDIRECTED =\n", "      \"Cannot call source()/target() on an undirected graph. \"\n", "          + \"Consider using incidentNodes() (if you don't know either incident node) \"\n", "          + \"or Graphs.oppositeNode() (if you know one of the incident nodes).\";\n"]}, "removed": {}, "added_lines": {"1": [35, 36, 37, 38]}, "removed_lines": {}}, {"32": "guava/src/com/google/common/graph/GraphProperties.java", "added": {"1": ["import static com.google.common.base.Preconditions.checkArgument;\n"], "2": ["// TODO(b/27628622): Move these methods to {@link Graphs}? Or at least rename this class to\n", "// something besides \"GraphProperties\", and consider putting in graph/algorithms/.\n"], "3": ["  public static boolean isCyclic(Graph<?, ?> graph) {\n", "    // TODO(user): Implement an algorithm that also works on undirected graphs.\n", "    // For instance, we should keep track of the edge used to reach a node to avoid\n", "    // reusing it (making a cycle by getting back to that node). Also, parallel edges\n", "    // will need to be carefully handled for undirected graphs.\n", "    checkArgument(graph.isDirected(), \"isCyclic() currently only works on directed graphs\");\n", "\n"], "4": ["      Graph<?, ?> graph, Map<Object, NodeVisitState> nodeToVisitState, Object node) {\n"], "5": ["   * Returns the set of all nodes in {@code graph} that have no predecessors.\n", "   *\n", "   * <p>Note that in an undirected graph, this is equivalent to all isolated nodes.\n", "  public static <N> ImmutableSet<N> roots(Graph<N, ?> graph) {\n", "    for (N node : graph.nodes()) {\n", "      if (graph.predecessors(node).isEmpty()) {\n"]}, "removed": {"1": ["import static com.google.common.base.Preconditions.checkNotNull;\n"], "3": ["  // TODO(user): Implement a similar method for undirected graphs, taking into\n", "  // consideration the difference in implementation, due to the notion of undirected\n", "  // edges. For instance, we should keep track of the edge used to reach a node to avoid\n", "  // reusing it (making a cycle by getting back to that node). Also, parallel edges will\n", "  // need to be carefully handled for undirected graphs.\n", "  public static boolean isCyclic(DirectedGraph<?, ?> graph) {\n", "    checkNotNull(graph, \"Directed graph passed can't be null.\");\n"], "4": ["      DirectedGraph<?, ?> graph, Map<Object, NodeVisitState> nodeToVisitState, Object node) {\n"], "5": ["   * Returns the set of all nodes in {@code directedGraph} that have no predecessors.\n", "  public static <N> ImmutableSet<N> roots(DirectedGraph<N, ?> directedGraph) {\n", "    for (N node : directedGraph.nodes()) {\n", "      if (directedGraph.predecessors(node).isEmpty()) {\n"]}, "added_lines": {"1": [19], "2": [33, 34], "3": [43, 44, 45, 46, 47, 48, 49], "4": [66], "5": [94, 95, 96, 98, 100, 101]}, "removed_lines": {"1": [19], "3": [41, 42, 43, 44, 45, 46, 47], "4": [64], "5": [92, 94, 96, 97]}}, {"33": "guava/src/com/google/common/graph/Graphs.java", "added": {"1": ["import com.google.common.annotations.VisibleForTesting;\n"], "3": ["    if (!graph.allowsParallelEdges()) {\n"], "4": ["  public static <N, E> Graph<N, E> copyOf(Graph<N, E> graph) {\n", "    return copyOf(graph, Predicates.alwaysTrue(), Predicates.alwaysTrue());\n", "  public static <N, E> Graph<N, E> copyOf(\n", "      Graph<N, E> graph,\n", "    Graph<N, E> copy = GraphBuilder.from(graph)\n", "        .expectedNodeCount(graph.nodes().size()).expectedEdgeCount(graph.edges().size()).build();\n", "    // We can't just call mergeEdgesFrom(graph, copy, edgePredicate) because addEdge() can add\n", "    // the edge's incident nodes if they are not present.\n", "        Set<N> incidentNodes = graph.incidentNodes(edge);\n", "        if (copy.nodes().containsAll(incidentNodes)) {\n", "          addEdge(copy, edge, incidentNodes);\n"], "5": ["    mergeNodesFrom(original, copy, Predicates.alwaysTrue());\n"], "6": ["    for (N node : Sets.filter(original.nodes(), nodePredicate)) {\n", "      copy.addNode(node);\n", "   * Copies all edges from {@code original} into {@code copy}. Also copies all nodes incident\n", "  public static <N, E> void mergeEdgesFrom(Graph<N, E> original, Graph<N, E> copy) {\n", "    mergeEdgesFrom(original, copy, Predicates.alwaysTrue());\n"], "7": ["      Graph<N, E> original, Graph<N, E> copy, Predicate<? super E> edgePredicate) {\n", "    for (E edge : Sets.filter(original.edges(), edgePredicate)) {\n"], "8": ["      boolean bothUndirected = !graph1.isDirected() && !graph2.isDirected();\n", "      if (!bothUndirected && !graph1.outEdges(node).equals(graph2.outEdges(node))) {\n"], "9": ["   * is directed.\n", "    return String.format(\"%s, nodes: %s, edges: %s\",\n", "        getPropertiesString(graph),\n"], "10": ["    if (graph.isDirected()) {\n", "              graph.source(edge), graph.target(edge));\n"], "11": ["\n", "  /**\n", "   * Returns a string representation of the properties of {@code graph}.\n", "   */\n", "  @VisibleForTesting\n", "  static String getPropertiesString(Graph<?, ?> graph) {\n", "    return String.format(\"isDirected: %s , allowsParallelEdges: %s, allowsSelfLoops: %s\",\n", "        graph.isDirected(), graph.allowsParallelEdges(), graph.allowsSelfLoops());\n", "  }\n"]}, "removed": {"2": [" * @see Graph\n", "  public static final GraphConfig MULTIGRAPH = config().multigraph();\n", "\n"], "3": ["    if (!graph.config().isMultigraph()) {\n"], "4": ["  public static <N, E> DirectedGraph<N, E> copyOf(DirectedGraph<N, E> graph) {\n", "    checkNotNull(graph, \"graph\");\n", "    DirectedGraph<N, E> copy = createDirected(graph.config()\n", "            .expectedNodeCount(graph.nodes().size())\n", "            .expectedEdgeCount(graph.edges().size()));\n", "    mergeNodesFrom(graph, copy);\n", "    mergeEdgesFrom(graph, copy);\n", "    return copy;\n", "  public static <N, E> DirectedGraph<N, E> copyOf(\n", "      DirectedGraph<N, E> graph,\n", "    DirectedGraph<N, E> copy = createDirected(graph.config()\n", "            .expectedNodeCount(graph.nodes().size())\n", "            .expectedEdgeCount(graph.edges().size()));\n", "    // We can't just call mergeEdgesFrom(graph, copy, edgePredicate) because addEdge() can add\n", "    // the edge's incident nodes if they are not present; we need to run them past nodePredicate.\n", "    if (edgePredicate.equals(Predicates.<E>alwaysFalse())) {\n", "      return copy; // no edges to add\n", "    }\n", "        N source = graph.source(edge);\n", "        N target = graph.target(edge);\n", "        if (nodePredicate.apply(source) && nodePredicate.apply(target)) {\n", "          copy.addEdge(edge, source, target);\n"], "5": ["    checkNotNull(original, \"original\");\n", "    checkNotNull(copy, \"copy\");\n", "    for (N node : original.nodes()) {\n", "      copy.addNode(node);\n", "    }\n"], "6": ["    if (nodePredicate.equals(Predicates.<N>alwaysFalse())) {\n", "      return; // nothing to do\n", "    }\n", "\n", "    if (nodePredicate.equals(Predicates.<N>alwaysTrue())) {\n", "      mergeNodesFrom(original, copy); // optimization\n", "    } else {\n", "      for (N node : original.nodes()) {\n", "        if (nodePredicate.apply(node)) {\n", "          copy.addNode(node);\n", "        }\n", "      }\n", "   * Copies all edges from {@code original} into {@code copy}.  Also copies all nodes incident\n", "  public static <N, E> void mergeEdgesFrom(DirectedGraph<N, E> original, DirectedGraph<N, E> copy) {\n", "    checkNotNull(original, \"original\");\n", "    checkNotNull(copy, \"copy\");\n", "    for (E edge : original.edges()) {\n", "      copy.addEdge(edge, original.source(edge), original.target(edge));\n", "    }\n"], "7": ["      DirectedGraph<N, E> original, DirectedGraph<N, E> copy, Predicate<? super E> edgePredicate) {\n", "    if (edgePredicate.equals(Predicates.<E>alwaysFalse())) {\n", "      return; // nothing to do\n", "    }\n", "\n", "    if (edgePredicate.equals(Predicates.<E>alwaysTrue())) {\n", "      mergeEdgesFrom(original, copy); // optimization\n", "    } else {\n", "      for (E edge : original.edges()) {\n", "        if (edgePredicate.apply(edge)) {\n", "          copy.addEdge(edge, original.source(edge), original.target(edge));\n", "        }\n", "      }\n", "    }\n", "  }\n", "\n", "  /**\n", "   * Creates a mutable copy of {@code graph}, using the same node and edge elements.\n", "   */\n", "  public static <N, E> UndirectedGraph<N, E> copyOf(UndirectedGraph<N, E> graph) {\n", "    checkNotNull(graph, \"graph\");\n", "    UndirectedGraph<N, E> copy = createUndirected(graph.config()\n", "            .expectedNodeCount(graph.nodes().size())\n", "            .expectedEdgeCount(graph.edges().size()));\n", "    mergeNodesFrom(graph, copy);\n", "    mergeEdgesFrom(graph, copy);\n", "    return copy;\n", "  }\n", "\n", "  /**\n", "   * Creates a mutable copy of {@code graph}, using all of its elements that satisfy\n", "   * {@code nodePredicate} and {@code edgePredicate}.\n", "   */\n", "  public static <N, E> UndirectedGraph<N, E> copyOf(\n", "      UndirectedGraph<N, E> graph,\n", "      Predicate<? super N> nodePredicate,\n", "      Predicate<? super E> edgePredicate) {\n", "    checkNotNull(graph, \"graph\");\n", "    checkNotNull(nodePredicate, \"nodePredicate\");\n", "    checkNotNull(edgePredicate, \"edgePredicate\");\n", "    UndirectedGraph<N, E> copy = createUndirected(graph.config()\n", "            .expectedNodeCount(graph.nodes().size())\n", "            .expectedEdgeCount(graph.edges().size()));\n", "    mergeNodesFrom(graph, copy, nodePredicate);\n", "\n", "    // We can't just call mergeEdgesFrom(graph, copy, edgePredicate) because addEdge() can add\n", "    // the edge's incident nodes if they are not present; we need to run them past nodePredicate.\n", "    for (E edge : graph.edges()) {\n", "      if (edgePredicate.apply(edge)) {\n", "        boolean nodesOk = true;\n", "        Set<N> incidentNodes = graph.incidentNodes(edge);\n", "        for (N node : incidentNodes) {\n", "          nodesOk &= nodePredicate.apply(node);\n", "        }\n", "        if (nodesOk) {\n", "          addEdge(copy, edge, incidentNodes);\n", "        }\n", "      }\n", "    }\n", "\n", "    return copy;\n", "  }\n", "\n", "  /**\n", "   * Copies all edges from {@code original} into {@code copy}.  Also copies all nodes incident\n", "   * to these edges.\n", "   */\n", "  public static <N, E> void mergeEdgesFrom(Graph<N, E> original, Graph<N, E> copy) {\n", "    checkNotNull(original, \"original\");\n", "    checkNotNull(copy, \"copy\");\n", "    for (E edge : original.edges()) {\n", "  /**\n", "   * Copies all edges from {@code original} into {@code copy} that satisfy {@code edgePredicate}.\n", "   * Also copies all nodes incident to these edges.\n", "   */\n", "  // NOTE: this is identical to mergeEdgesFrom(DirectedGraph) except for the call to addEdge\n", "  public static <N, E> void mergeEdgesFrom(Graph<N, E> original, Graph<N, E> copy,\n", "      Predicate<? super E> edgePredicate) {\n", "    checkNotNull(original, \"original\");\n", "    checkNotNull(copy, \"copy\");\n", "    checkNotNull(edgePredicate, \"edgePredicate\");\n", "    if (edgePredicate.equals(Predicates.<E>alwaysFalse())) {\n", "      return; // nothing to do\n", "    }\n", "\n", "    if (edgePredicate.equals(Predicates.<E>alwaysTrue())) {\n", "      mergeEdgesFrom(original, copy); // optimization\n", "    } else {\n", "      for (E edge : original.edges()) {\n", "        if (edgePredicate.apply(edge)) {\n", "          addEdge(copy, edge, original.incidentNodes(edge));\n", "        }\n", "      }\n", "    }\n", "  }\n", "\n", "  /**\n", "   * Copies all nodes and edges from {@code original} to {@code copy} that satisfy\n", "   * {@code nodePredicate} and {@code edgePredicate}.\n", "   */\n", "  public static <N, E> void copyFrom(\n", "      Graph<N, E> original,\n", "      Graph<N, E> copy,\n", "      Predicate<? super N> nodePredicate,\n", "      Predicate<? super E> edgePredicate) {\n", "    checkNotNull(original, \"original\");\n", "    checkNotNull(copy, \"copy\");\n", "    checkNotNull(nodePredicate, \"nodePredicate\");\n", "    checkNotNull(edgePredicate, \"edgePredicate\");\n", "    mergeNodesFrom(original, copy, nodePredicate);\n", "    mergeEdgesFrom(original, copy, edgePredicate);\n", "  }\n", "\n", "  /**\n", "   * Returns a new default instance of {@code GraphConfig}.\n", "   *\n", "   * @see GraphConfig\n", "   */\n", "  public static GraphConfig config() {\n", "    return new GraphConfig();\n", "  }\n", "\n", "  /**\n", "   * Returns a new instance of {@link DirectedGraph} with the default\n", "   * graph configuration.\n", "   *\n", "   * @see GraphConfig\n", "   */\n", "  public static <N, E> DirectedGraph<N, E> createDirected() {\n", "    return new IncidenceSetDirectedGraph<N, E>(config());\n", "  }\n", "\n", "  /**\n", "   * Returns a new instance of {@link DirectedGraph} with the graph\n", "   * configuration specified by {@code config}.\n", "   */\n", "  public static <N, E> DirectedGraph<N, E> createDirected(GraphConfig config) {\n", "    return new IncidenceSetDirectedGraph<N, E>(config);\n", "  }\n", "\n", "  /**\n", "   * Returns a new instance of {@link UndirectedGraph} with the default\n", "   * graph configuration.\n", "   *\n", "   * @see GraphConfig\n", "   */\n", "  public static <N, E> UndirectedGraph<N, E> createUndirected() {\n", "    return new IncidenceSetUndirectedGraph<N, E>(config());\n", "  }\n", "\n", "  /**\n", "   * Returns a new instance of {@link UndirectedGraph} with the graph\n", "   * configuration specified by {@code config}.\n", "   */\n", "  public static <N, E> UndirectedGraph<N, E> createUndirected(GraphConfig config) {\n", "    return new IncidenceSetUndirectedGraph<N, E>(config);\n", "  }\n", "\n"], "8": ["      // TODO(b/27195992): Consider an optimization for the case where both graphs are undirected.\n", "      if (!graph1.outEdges(node).equals(graph2.outEdges(node))) {\n"], "9": ["   * is a {@link DirectedGraph}.\n", "    return String.format(\"config: %s, nodes: %s, edges: %s\",\n", "        graph.config(),\n"], "10": ["    if (graph instanceof DirectedGraph) {\n", "      @SuppressWarnings(\"unchecked\")\n", "      final DirectedGraph<?, ?> directedGraph = (DirectedGraph<?, ?>) graph;\n", "              directedGraph.source(edge), directedGraph.target(edge));\n"]}, "added_lines": {"1": [23], "3": [85], "4": [120, 121, 128, 129, 135, 136, 139, 140, 143, 144, 145], "5": [157], "6": [168, 169, 174, 177, 178], "7": [186, 190], "8": [221, 222], "9": [241, 244, 245], "10": [286, 291], "11": [302, 303, 304, 305, 306, 307, 308, 309, 310]}, "removed_lines": {"2": [41, 47, 48], "3": [87], "4": [122, 123, 124, 125, 126, 127, 128, 129, 136, 137, 143, 144, 145, 147, 148, 149, 150, 151, 155, 156, 157, 158], "5": [170, 171, 172, 173, 174], "6": [185, 186, 187, 188, 189, 190, 191, 192, 193, 194, 195, 196, 201, 204, 205, 206, 207, 208, 209], "7": [217, 221, 222, 223, 224, 225, 226, 227, 228, 229, 230, 231, 232, 233, 234, 235, 236, 237, 238, 239, 240, 241, 242, 243, 244, 245, 246, 247, 248, 249, 250, 251, 252, 253, 254, 255, 256, 257, 258, 259, 260, 261, 262, 263, 264, 265, 266, 267, 268, 269, 270, 271, 272, 273, 274, 275, 276, 277, 278, 279, 280, 281, 282, 283, 284, 285, 286, 287, 288, 289, 290, 295, 296, 297, 298, 299, 300, 301, 302, 303, 304, 305, 306, 307, 308, 309, 310, 311, 312, 313, 314, 315, 316, 317, 318, 319, 320, 321, 322, 323, 324, 325, 326, 327, 328, 329, 330, 331, 332, 333, 334, 335, 336, 337, 338, 339, 340, 341, 342, 343, 344, 345, 346, 347, 348, 349, 350, 351, 352, 353, 354, 355, 356, 357, 358, 359, 360, 361, 362, 363, 364, 365, 366, 367, 368, 369, 370, 371, 372, 373, 374, 375, 376, 377, 378, 379, 380, 381], "8": [408, 409], "9": [428, 431, 432], "10": [473, 474, 475, 480]}}, {"34": "guava/src/com/google/common/graph/Hypergraph.java", "added": {"1": ["  /**\n", "   * Source is not applicable to hypergraphs.\n", "   *\n", "   * @throws UnsupportedOperationException always\n", "   * @deprecated Unsupported operation. Call {@link #incidentNodes(Object)} instead.\n", "   */\n", "  @Deprecated\n", "  @Override\n", "  N source(Object edge);\n", "\n", "  /**\n", "   * Target is not applicable to hypergraphs.\n", "   *\n", "   * @throws UnsupportedOperationException always\n", "   * @deprecated Unsupported operation. Call {@link #incidentNodes(Object)} instead.\n", "   */\n", "  @Deprecated\n", "  @Override\n", "  N target(Object edge);\n", "\n"]}, "removed": {}, "added_lines": {"1": [41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 58, 59, 60]}, "removed_lines": {}}, {"35": "guava/src/com/google/common/graph/ImmutableDirectedGraph.java", "added": {}, "removed": {"1": ["/*\n", " * Copyright (C) 2014 The Guava Authors\n", " *\n", " * Licensed under the Apache License, Version 2.0 (the \"License\");\n", " * you may not use this file except in compliance with the License.\n", " * You may obtain a copy of the License at\n", " *\n", " * http://www.apache.org/licenses/LICENSE-2.0\n", " *\n", " * Unless required by applicable law or agreed to in writing, software\n", " * distributed under the License is distributed on an \"AS IS\" BASIS,\n", " * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n", " * See the License for the specific language governing permissions and\n", " * limitations under the License.\n", " */\n", "\n", "package com.google.common.graph;\n", "\n", "import com.google.common.annotations.Beta;\n", "import com.google.errorprone.annotations.CanIgnoreReturnValue;\n", "\n", "/**\n", " * Implementation of an immutable directed graph consisting of nodes of type N\n", " * and edges of type E.\n", " *\n", " * <p>Some invariants/assumptions are maintained in this implementation:\n", " * <ul>\n", " * <li>An edge has exactly two end-points (source node and target node), which\n", " *     may or may not be distinct.\n", " * <li>By default, this is not a multigraph, that is, parallel edges (multiple\n", " *     edges directed from node1 to node2) are not allowed.  If you want a multigraph,\n", " *     build the graph with the 'multigraph' option:\n", " *     <pre>ImmutableDirectedGraph.builder(Graphs.config().multigraph()).build();</pre>\n", " * <li>Anti-parallel edges (same incident nodes but in opposite direction,\n", " *     e.g. (node1, node2) and (node2, node1)) are always allowed.\n", " * <li>Edges are not adjacent to themselves by definition. In the case of a\n", " *     self-loop, a node can be adjacent to itself, but an edge will never be.\n", " * </ul>\n", " *\n", " * @author James Sexton\n", " * @author Joshua O'Madadhain\n", " * @author Omar Darwish\n", " * @param <N> Node parameter type\n", " * @param <E> Edge parameter type\n", " * @see AbstractConfigurableGraph\n", " * @see AbstractImmutableGraph\n", " * @since 20.0\n", " */\n", "@Beta\n", "public final class ImmutableDirectedGraph<N, E> extends AbstractImmutableGraph<N, E>\n", "    implements DirectedGraph<N, E> {\n", "\n", "  private ImmutableDirectedGraph(Builder<N, E> builder) {\n", "    super(builder);\n", "  }\n", "\n", "  @Override\n", "  public N source(Object edge) {\n", "    return checkedIncidentNodes(edge).node1();\n", "  }\n", "\n", "  @Override\n", "  public N target(Object edge) {\n", "    return checkedIncidentNodes(edge).node2();\n", "  }\n", "\n", "  /**\n", "   * Returns a new builder. The generated builder is equivalent to the builder\n", "   * created by the {@code Builder} constructor.\n", "   */\n", "  public static <N, E> Builder<N, E> builder() {\n", "    return new Builder<N, E>();\n", "  }\n", "\n", "  /**\n", "   * Returns a new builder. The generated builder is equivalent to the builder\n", "   * created by the {@code Builder} constructor.\n", "   *\n", "   * @param config an instance of {@code GraphConfig} with the intended\n", "   *        graph configuration.\n", "   */\n", "  public static <N, E> Builder<N, E> builder(GraphConfig config) {\n", "    return new Builder<N, E>(config);\n", "  }\n", "\n", "  /**\n", "   * Returns an immutable copy of the input graph.\n", "   */\n", "  public static <N, E> ImmutableDirectedGraph<N, E> copyOf(DirectedGraph<N, E> graph) {\n", "    return new Builder<N, E>(graph).build();\n", "  }\n", "\n", "  /**\n", "   * A builder for creating immutable directed graph instances.\n", "   *\n", "   * @param <N> Node parameter type\n", "   * @param <E> edge parameter type\n", "   * @see GraphConfig\n", "   */\n", "  public static final class Builder<N, E> extends AbstractImmutableGraph.Builder<N, E> {\n", "\n", "    /**\n", "     * Creates a new builder with the default graph configuration.\n", "     */\n", "    public Builder() {\n", "      super(Graphs.<N, E>createDirected());\n", "    }\n", "\n", "    /**\n", "     * Creates a new builder with the specified graph configuration.\n", "     */\n", "    public Builder(GraphConfig config) {\n", "      super(Graphs.<N, E>createDirected(config));\n", "    }\n", "\n", "    /**\n", "     * Creates a new builder whose internal state is that of {@code graph}.\n", "     *\n", "     * <p>NOTE: This constructor should only be used in the case where it will be immediately\n", "     * followed by a call to {@code build}, to ensure that the input graph will not be modified.\n", "     * Currently the only such context is {@code Immutable*Graph.copyOf()}, which use these\n", "     * constructors to avoid making an extra copy of the graph state.\n", "     * @see ImmutableDirectedGraph#copyOf(DirectedGraph)\n", "     */\n", "    private Builder(DirectedGraph<N, E> graph) {\n", "      super(graph);\n", "    }\n", "\n", "    @Override\n", "    NodeConnections<N, E> nodeConnectionsOf(N node) {\n", "      return DirectedNodeConnections.ofImmutable(\n", "          graph.predecessors(node), graph.successors(node),\n", "          graph.inEdges(node), graph.outEdges(node));\n", "    }\n", "\n", "    @Override\n", "    public ImmutableDirectedGraph<N, E> build() {\n", "      return new ImmutableDirectedGraph<N, E>(this);\n", "    }\n", "\n", "    @Override\n", "    @CanIgnoreReturnValue\n", "    public Builder<N, E> addNode(N node) {\n", "      return (Builder<N, E>) super.addNode(node); // Refine the return type\n", "    }\n", "\n", "    @Override\n", "    @CanIgnoreReturnValue\n", "    public Builder<N, E> addEdge(E edge, N node1, N node2) {\n", "      return (Builder<N, E>) super.addEdge(edge, node1, node2); // Refine the return type\n", "    }\n", "\n", "    @Override\n", "    @CanIgnoreReturnValue\n", "    public Builder<N, E> addGraph(Graph<N, E> graphToAdd) {\n", "      return (Builder<N, E>) super.addGraph(graphToAdd); // Refine the return type\n", "    }\n", "  }\n", "}\n"]}, "added_lines": {}, "removed_lines": {"1": [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 58, 59, 60, 61, 62, 63, 64, 65, 66, 67, 68, 69, 70, 71, 72, 73, 74, 75, 76, 77, 78, 79, 80, 81, 82, 83, 84, 85, 86, 87, 88, 89, 90, 91, 92, 93, 94, 95, 96, 97, 98, 99, 100, 101, 102, 103, 104, 105, 106, 107, 108, 109, 110, 111, 112, 113, 114, 115, 116, 117, 118, 119, 120, 121, 122, 123, 124, 125, 126, 127, 128, 129, 130, 131, 132, 133, 134, 135, 136, 137, 138, 139, 140, 141, 142, 143, 144, 145, 146, 147, 148, 149, 150, 151, 152, 153, 154, 155, 156, 157, 158, 159]}}, {"36": "guava/src/com/google/common/graph/ImmutableGraph.java", "added": {"1": ["/*\n", " * Copyright (C) 2014 The Guava Authors\n", " *\n", " * Licensed under the Apache License, Version 2.0 (the \"License\");\n", " * you may not use this file except in compliance with the License.\n", " * You may obtain a copy of the License at\n", " *\n", " * http://www.apache.org/licenses/LICENSE-2.0\n", " *\n", " * Unless required by applicable law or agreed to in writing, software\n", " * distributed under the License is distributed on an \"AS IS\" BASIS,\n", " * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n", " * See the License for the specific language governing permissions and\n", " * limitations under the License.\n", " */\n", "\n", "package com.google.common.graph;\n", "\n", "import static com.google.common.base.Preconditions.checkNotNull;\n", "\n", "import com.google.common.collect.ImmutableMap;\n", "import com.google.common.collect.ImmutableSet;\n", "import com.google.errorprone.annotations.CanIgnoreReturnValue;\n", "\n", "import java.util.Map;\n", "import java.util.Set;\n", "\n", "/**\n", " * A {@link Graph} whose contents will never change. Instances of this class should be obtained\n", " * with {@link #copyOf(Graph)}.\n", " *\n", " * <p>The time complexity of {@code edgesConnecting(node1, node2)} is O(min(outD_node1, inD_node2)).\n", " *\n", " * @author James Sexton\n", " * @author Joshua O'Madadhain\n", " * @author Omar Darwish\n", " * @param <N> Node parameter type\n", " * @param <E> Edge parameter type\n", " */\n", "public final class ImmutableGraph<N, E> extends ConfigurableGraph<N, E> {\n", "\n", "  private ImmutableGraph(Graph<N, E> graph) {\n", "    super(GraphBuilder.from(graph), getNodeConnections(graph), getEdgeToIncidentNodes(graph));\n", "  }\n", "\n", "  /**\n", "   * Returns an immutable copy of {@code graph}.\n", "   */\n", "  public static <N, E> ImmutableGraph<N, E> copyOf(Graph<N, E> graph) {\n", "    return (graph instanceof ImmutableGraph)\n", "        ? (ImmutableGraph<N, E>) graph\n", "        : new ImmutableGraph<N, E>(graph);\n", "  }\n", "\n", "  /**\n", "   * Simply returns its argument.\n", "   *\n", "   * @deprecated no need to use this\n", "   */\n", "  @Deprecated\n", "  public static <N, E> ImmutableGraph<N, E> copyOf(ImmutableGraph<N, E> graph) {\n", "    return checkNotNull(graph);\n", "  }\n", "\n", "  /**\n", "   * Guaranteed to throw an exception and leave the graph unmodified.\n", "   *\n", "   * @throws UnsupportedOperationException always\n", "   * @deprecated Unsupported operation.\n", "   */\n", "  @CanIgnoreReturnValue\n", "  @Deprecated\n", "  @Override\n", "  public final boolean addNode(N node) {\n", "    throw new UnsupportedOperationException();\n", "  }\n", "\n", "  /**\n", "   * Guaranteed to throw an exception and leave the graph unmodified.\n", "   *\n", "   * @throws UnsupportedOperationException always\n", "   * @deprecated Unsupported operation.\n", "   */\n", "  @CanIgnoreReturnValue\n", "  @Deprecated\n", "  @Override\n", "  public final boolean addEdge(E edge, N node1, N node2) {\n", "    throw new UnsupportedOperationException();\n", "  }\n", "\n", "  /**\n", "   * Guaranteed to throw an exception and leave the graph unmodified.\n", "   *\n", "   * @throws UnsupportedOperationException always\n", "   * @deprecated Unsupported operation.\n", "   */\n", "  @CanIgnoreReturnValue\n", "  @Deprecated\n", "  @Override\n", "  public final boolean removeNode(Object node) {\n", "    throw new UnsupportedOperationException();\n", "  }\n", "\n", "  /**\n", "   * Guaranteed to throw an exception and leave the graph unmodified.\n", "   *\n", "   * @throws UnsupportedOperationException always\n", "   * @deprecated Unsupported operation.\n", "   */\n", "  @CanIgnoreReturnValue\n", "  @Deprecated\n", "  @Override\n", "  public final boolean removeEdge(Object edge) {\n", "    throw new UnsupportedOperationException();\n", "  }\n", "\n", "  @Override\n", "  public Set<E> edgesConnecting(Object node1, Object node2) {\n", "    // This set is calculated as the intersection of two sets, and is likely to be small.\n", "    // As an optimization, copy it to an ImmutableSet so re-iterating is fast.\n", "    return ImmutableSet.copyOf(super.edgesConnecting(node1, node2));\n", "  }\n", "\n", "  private static <N, E> Map<N, NodeConnections<N, E>> getNodeConnections(Graph<N, E> graph) {\n", "    ImmutableMap.Builder<N, NodeConnections<N, E>> nodeConnections = ImmutableMap.builder();\n", "    for (N node : graph.nodes()) {\n", "      nodeConnections.put(node, nodeConnectionsOf(graph, node));\n", "    }\n", "    return nodeConnections.build();\n", "  }\n", "\n", "  private static <N, E> Map<E, IncidentNodes<N>> getEdgeToIncidentNodes(Graph<N, E> graph) {\n", "    ImmutableMap.Builder<E, IncidentNodes<N>> edgeToIncidentNodes = ImmutableMap.builder();\n", "    for (E edge : graph.edges()) {\n", "      edgeToIncidentNodes.put(edge, IncidentNodes.of(graph.incidentNodes(edge)));\n", "    }\n", "    return edgeToIncidentNodes.build();\n", "  }\n", "\n", "  private static <N, E> NodeConnections<N, E> nodeConnectionsOf(Graph<N, E> graph, N node) {\n", "    return graph.isDirected()\n", "        ? DirectedNodeConnections.ofImmutable(\n", "            graph.predecessors(node), graph.successors(node),\n", "            graph.inEdges(node), graph.outEdges(node))\n", "        : UndirectedNodeConnections.ofImmutable(\n", "            graph.adjacentNodes(node), graph.incidentEdges(node));\n", "  }\n", "}\n"]}, "removed": {}, "added_lines": {"1": [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 58, 59, 60, 61, 62, 63, 64, 65, 66, 67, 68, 69, 70, 71, 72, 73, 74, 75, 76, 77, 78, 79, 80, 81, 82, 83, 84, 85, 86, 87, 88, 89, 90, 91, 92, 93, 94, 95, 96, 97, 98, 99, 100, 101, 102, 103, 104, 105, 106, 107, 108, 109, 110, 111, 112, 113, 114, 115, 116, 117, 118, 119, 120, 121, 122, 123, 124, 125, 126, 127, 128, 129, 130, 131, 132, 133, 134, 135, 136, 137, 138, 139, 140, 141, 142, 143, 144, 145, 146, 147, 148]}, "removed_lines": {}}, {"37": "guava/src/com/google/common/graph/ImmutableUndirectedGraph.java", "added": {}, "removed": {"1": ["/*\n", " * Copyright (C) 2014 The Guava Authors\n", " *\n", " * Licensed under the Apache License, Version 2.0 (the \"License\");\n", " * you may not use this file except in compliance with the License.\n", " * You may obtain a copy of the License at\n", " *\n", " * http://www.apache.org/licenses/LICENSE-2.0\n", " *\n", " * Unless required by applicable law or agreed to in writing, software\n", " * distributed under the License is distributed on an \"AS IS\" BASIS,\n", " * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n", " * See the License for the specific language governing permissions and\n", " * limitations under the License.\n", " */\n", "\n", "package com.google.common.graph;\n", "\n", "import com.google.common.annotations.Beta;\n", "import com.google.errorprone.annotations.CanIgnoreReturnValue;\n", "\n", "/**\n", " * Implementation of an immutable undirected graph consisting of nodes of type N\n", " * and edges of type E.\n", " *\n", " * <p>Some invariants/assumptions are maintained in this implementation:\n", " * <ul>\n", " * <li>An edge has exactly two end-points, which may or may not be distinct.\n", " * <li>By default, this is not a multigraph, that is, parallel edges (multiple\n", " *     edges between n1 and n2) are not allowed.  If you want a multigraph,\n", " *     build the graph with the 'multigraph' option:\n", " *     <pre>ImmutableUndirectedGraph.builder(Graphs.config().multigraph()).build();</pre>\n", " * <li>Edges are not adjacent to themselves by definition. In the case of a\n", " *     self-loop, a node can be adjacent to itself, but an edge will never be adjacent to itself.\n", " * </ul>\n", " *\n", " * @author James Sexton\n", " * @author Joshua O'Madadhain\n", " * @author Omar Darwish\n", " * @param <N> Node parameter type\n", " * @param <E> Edge parameter type\n", " * @see AbstractConfigurableGraph\n", " * @see AbstractImmutableGraph\n", " * @since 20.0\n", " */\n", "@Beta\n", "public final class ImmutableUndirectedGraph<N, E> extends AbstractImmutableGraph<N, E>\n", "    implements UndirectedGraph<N, E> {\n", "\n", "  private ImmutableUndirectedGraph(Builder<N, E> builder) {\n", "    super(builder);\n", "  }\n", "\n", "  /**\n", "   * Returns a new builder. The generated builder is equivalent to the builder\n", "   * created by the {@code Builder} constructor.\n", "   */\n", "  public static <N, E> Builder<N, E> builder() {\n", "    return new Builder<N, E>();\n", "  }\n", "\n", "  /**\n", "   * Returns a new builder. The generated builder is equivalent to the builder\n", "   * created by the {@code Builder} constructor.\n", "   *\n", "   * @param config an instance of {@code GraphConfig} with the intended\n", "   *        graph configuration.\n", "   */\n", "  public static <N, E> Builder<N, E> builder(GraphConfig config) {\n", "    return new Builder<N, E>(config);\n", "  }\n", "\n", "  /**\n", "   * Returns an immutable copy of the input graph.\n", "   */\n", "  public static <N, E> ImmutableUndirectedGraph<N, E> copyOf(UndirectedGraph<N, E> graph) {\n", "    return new Builder<N, E>(graph).build();\n", "  }\n", "\n", "  /**\n", "   * A builder for creating immutable undirected graph instances.\n", "   *\n", "   * @param <N> Node parameter type\n", "   * @param <E> edge parameter type\n", "   * @see GraphConfig\n", "   */\n", "  public static final class Builder<N, E> extends AbstractImmutableGraph.Builder<N, E> {\n", "\n", "    /**\n", "     * Creates a new builder with the default graph configuration.\n", "     */\n", "    public Builder() {\n", "      super(Graphs.<N, E>createUndirected());\n", "    }\n", "\n", "    /**\n", "     * Creates a new builder with the specified configuration.\n", "     */\n", "    public Builder(GraphConfig config) {\n", "      super(Graphs.<N, E>createUndirected(config));\n", "    }\n", "\n", "    /**\n", "     * Creates a new builder whose internal state is that of {@code graph}.\n", "     *\n", "     * <p>NOTE: This constructor should only be used in the case where it will be immediately\n", "     * followed by a call to {@code build}, so that the input graph will not be modified.\n", "     * Currently the only such contexts are {@code Immutable*Graph.copyOf()}, which use these\n", "     * constructors to avoid making an extra copy of the graph state.\n", "     * @see ImmutableUndirectedGraph#copyOf(UndirectedGraph)\n", "     */\n", "    private Builder(UndirectedGraph<N, E> graph) {\n", "      super(graph);\n", "    }\n", "\n", "    @Override\n", "    NodeConnections<N, E> nodeConnectionsOf(N node) {\n", "      return UndirectedNodeConnections.ofImmutable(\n", "          graph.adjacentNodes(node), graph.incidentEdges(node));\n", "    }\n", "\n", "    @Override\n", "    public ImmutableUndirectedGraph<N, E> build() {\n", "      return new ImmutableUndirectedGraph<N, E>(this);\n", "    }\n", "\n", "    @Override\n", "    @CanIgnoreReturnValue\n", "    public Builder<N, E> addNode(N node) {\n", "      return (Builder<N, E>) super.addNode(node); // Refine the return type\n", "    }\n", "\n", "    @Override\n", "    @CanIgnoreReturnValue\n", "    public Builder<N, E> addEdge(E edge, N node1, N node2) {\n", "      return (Builder<N, E>) super.addEdge(edge, node1, node2); // Refine the return type\n", "    }\n", "\n", "    @Override\n", "    @CanIgnoreReturnValue\n", "    public Builder<N, E> addGraph(Graph<N, E> graphToAdd) {\n", "      return (Builder<N, E>) super.addGraph(graphToAdd); // Refine the return type\n", "    }\n", "  }\n", "}\n"]}, "added_lines": {}, "removed_lines": {"1": [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 58, 59, 60, 61, 62, 63, 64, 65, 66, 67, 68, 69, 70, 71, 72, 73, 74, 75, 76, 77, 78, 79, 80, 81, 82, 83, 84, 85, 86, 87, 88, 89, 90, 91, 92, 93, 94, 95, 96, 97, 98, 99, 100, 101, 102, 103, 104, 105, 106, 107, 108, 109, 110, 111, 112, 113, 114, 115, 116, 117, 118, 119, 120, 121, 122, 123, 124, 125, 126, 127, 128, 129, 130, 131, 132, 133, 134, 135, 136, 137, 138, 139, 140, 141, 142, 143, 144, 145]}}, {"38": "guava/src/com/google/common/graph/IncidenceSetDirectedGraph.java", "added": {}, "removed": {"1": ["/*\n", " * Copyright (C) 2014 The Guava Authors\n", " *\n", " * Licensed under the Apache License, Version 2.0 (the \"License\");\n", " * you may not use this file except in compliance with the License.\n", " * You may obtain a copy of the License at\n", " *\n", " * http://www.apache.org/licenses/LICENSE-2.0\n", " *\n", " * Unless required by applicable law or agreed to in writing, software\n", " * distributed under the License is distributed on an \"AS IS\" BASIS,\n", " * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n", " * See the License for the specific language governing permissions and\n", " * limitations under the License.\n", " */\n", "\n", "package com.google.common.graph;\n", "\n", "/**\n", " * Configurable implementation of a directed graph consisting of nodes of type N\n", " * and edges of type E.\n", " *\n", " * <p>{@link Graphs#createDirected()} should be used to get an instance of this class.\n", " *\n", " * <p>Some invariants/assumptions are maintained in this implementation:\n", " * <ul>\n", " * <li>An edge has exactly two end-points (source node and target node), which\n", " *     may or may not be distinct.\n", " * <li>By default, this is not a multigraph, that is, parallel edges (multiple\n", " *     edges directed from n1 to n2) are not allowed.  If you want a multigraph,\n", " *     create the graph with the 'multigraph' option:\n", " *     <pre>Graphs.createDirected(Graphs.config().multigraph());</pre>\n", " * <li>Anti-parallel edges (same incident nodes but in opposite direction,\n", " *     e.g. (n1, n2) and (n2, n1)) are always allowed.\n", " * <li>By default, self-loop edges are allowed. If you want to disallow them,\n", " *     create the graph without the option of self-loops:\n", " *     <pre>Graphs.createDirected(Graphs.config().noSelfLoops());</pre>\n", " * <li>Edges are not adjacent to themselves by definition. In the case of a\n", " *     self-loop, a node can be adjacent to itself, but an edge will never be.\n", " * </ul>\n", " *\n", " * <p>Time complexities for mutation methods:\n", " * <ul>\n", " * <li>{@code addNode}: O(1).\n", " * <li>{@code addEdge(E edge, N node1, N node2)}: O(1).\n", " * <li>{@code removeNode(node)}: O(d_node).\n", " * <li>{@code removeEdge}: O(1), unless this graph is a multigraph (supports parallel edges);\n", " *     in that case this method is O(min(outD_edgeSource, inD_edgeTarget)).\n", " * </ul>\n", " * where d_node is the degree of node, inD_node is the in-degree of node, and outD_node is the\n", " * out-degree of node.\n", " *\n", " * @author James Sexton\n", " * @author Joshua O'Madadhain\n", " * @author Omar Darwish\n", " * @param <N> Node parameter type\n", " * @param <E> Edge parameter type\n", " * @see AbstractConfigurableGraph\n", " * @see Graphs\n", " */\n", "final class IncidenceSetDirectedGraph<N, E> extends AbstractConfigurableGraph<N, E>\n", "    implements DirectedGraph<N, E> {\n", "\n", "  IncidenceSetDirectedGraph(GraphConfig config) {\n", "    super(config);\n", "  }\n", "\n", "  @Override\n", "  NodeConnections<N, E> newNodeConnections() {\n", "    return DirectedNodeConnections.of();\n", "  }\n", "\n", "  @Override\n", "  public N source(Object edge) {\n", "    return checkedIncidentNodes(edge).node1();\n", "  }\n", "\n", "  @Override\n", "  public N target(Object edge) {\n", "    return checkedIncidentNodes(edge).node2();\n", "  }\n", "}\n"]}, "added_lines": {}, "removed_lines": {"1": [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 58, 59, 60, 61, 62, 63, 64, 65, 66, 67, 68, 69, 70, 71, 72, 73, 74, 75, 76, 77, 78, 79, 80, 81, 82]}}, {"39": "guava/src/com/google/common/graph/IncidenceSetUndirectedGraph.java", "added": {}, "removed": {"1": ["/*\n", " * Copyright (C) 2014 The Guava Authors\n", " *\n", " * Licensed under the Apache License, Version 2.0 (the \"License\");\n", " * you may not use this file except in compliance with the License.\n", " * You may obtain a copy of the License at\n", " *\n", " * http://www.apache.org/licenses/LICENSE-2.0\n", " *\n", " * Unless required by applicable law or agreed to in writing, software\n", " * distributed under the License is distributed on an \"AS IS\" BASIS,\n", " * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n", " * See the License for the specific language governing permissions and\n", " * limitations under the License.\n", " */\n", "\n", "package com.google.common.graph;\n", "\n", "/**\n", " * Configurable implementation of an undirected graph consisting of nodes of type N\n", " * and edges of type E.\n", " *\n", " * <p>{@link Graphs#createUndirected} should be used to get an instance of this class.\n", " *\n", " * <p>Some invariants/assumptions are maintained in this implementation:\n", " * <ul>\n", " * <li>An edge has exactly two end-points, which may or may not be distinct.\n", " * <li>By default, this is not a multigraph, that is, parallel edges (multiple\n", " *     edges between node1 and node2) are not allowed.  If you want a multigraph,\n", " *     create the graph with the 'multigraph' option:\n", " *     <pre>Graphs.createUndirected(Graphs.config().multigraph());</pre>\n", " * <li>By default, self-loop edges are allowed. If you want to disallow them,\n", " *     create the graph without the option of self-loops:\n", " *     <pre>Graphs.createUndirected(Graphs.config().noSelfLoops());</pre>\n", " * <li>Edges are not adjacent to themselves by definition. In the case of a\n", " *     self-loop, a node can be adjacent to itself, but an edge will never be.\n", " * </ul>\n", " *\n", " * <p>Time complexities for mutation methods:\n", " * <ul>\n", " * <li>{@code addNode}: O(1).\n", " * <li>{@code addEdge(E edge, N node1, N node2)}: O(1).\n", " * <li>{@code removeNode(node)}: O(d_node).\n", " * <li>{@code removeEdge}: O(1), unless this graph is a multigraph (supports parallel edges);\n", " *     in that case this method is O(min(d_edgeNode1, d_edgeNode2)).\n", " * </ul>\n", " * where d_node is the degree of node.\n", " *\n", " * @author James Sexton\n", " * @author Joshua O'Madadhain\n", " * @author Omar Darwish\n", " * @param <N> Node parameter type\n", " * @param <E> Edge parameter type\n", " * @see AbstractConfigurableGraph\n", " * @see Graphs\n", " */\n", "final class IncidenceSetUndirectedGraph<N, E> extends AbstractConfigurableGraph<N, E>\n", "    implements UndirectedGraph<N, E> {\n", "\n", "  IncidenceSetUndirectedGraph(GraphConfig config) {\n", "    super(config);\n", "  }\n", "\n", "  @Override\n", "  NodeConnections<N, E> newNodeConnections() {\n", "    return UndirectedNodeConnections.of();\n", "  }\n", "}\n"]}, "added_lines": {}, "removed_lines": {"1": [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 58, 59, 60, 61, 62, 63, 64, 65, 66, 67, 68]}}, {"40": "guava/src/com/google/common/graph/UndirectedGraph.java", "added": {}, "removed": {"1": ["/*\n", " * Copyright (C) 2014 The Guava Authors\n", " *\n", " * Licensed under the Apache License, Version 2.0 (the \"License\");\n", " * you may not use this file except in compliance with the License.\n", " * You may obtain a copy of the License at\n", " *\n", " * http://www.apache.org/licenses/LICENSE-2.0\n", " *\n", " * Unless required by applicable law or agreed to in writing, software\n", " * distributed under the License is distributed on an \"AS IS\" BASIS,\n", " * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n", " * See the License for the specific language governing permissions and\n", " * limitations under the License.\n", " */\n", "\n", "package com.google.common.graph;\n", "\n", "import com.google.common.annotations.Beta;\n", "\n", "/**\n", " * A tagging/marker subinterface of {@code Graph} for graphs whose edges are all undirected.\n", " *\n", " * @author Joshua O'Madadhain\n", " * @param <N> Node parameter type\n", " * @param <E> Edge parameter type\n", " * @since 20.0\n", " */\n", "@Beta\n", "public interface UndirectedGraph<N, E> extends Graph<N, E> {}"]}, "added_lines": {}, "removed_lines": {"1": [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30]}}]}
