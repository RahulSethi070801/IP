{
    "addition": {
        "23": "import static com.google.common.graph.Graphs.oppositeNode;\n",
        "57": " * <p>Most of the {@code Set}-returning accessors return an immutable set which is an internal\n",
        "58": " * data structure, hence they have a time complexity of O(1). The rest of these accessors build\n",
        "59": " * and return an immutable set that is <b>derived</b> from the internal data structures, hence\n",
        "60": " * they have the following time complexities:\n",
        "61": " * <ul>\n",
        "62": " * <li>Methods that ask for adjacent nodes (e.g. {@code adjacentNodes}): O(d_node), where\n",
        "63": " *     node is the node on which the method is called.\n",
        "64": " * <li>{@code adjacentEdges(edge)}: O(d_node1 + d_node2), where node1 and node2 are {@code edge}'s\n",
        "65": " *     incident nodes.\n",
        "66": " * <li>{@code edgesConnecting(node1, node2)}: O(min(d_node1, d_node2)).\n",
        "67": " * </ul>\n",
        "68": " * where d_node is the degree of node. The set returned by these methods is <b>not</b> cached,\n",
        "69": " * so every time the user calls the method, the same set will be reconstructed again.\n",
        "84": "  private final ImmutableMap<N, ImmutableSet<E>> nodeToIncidentEdges;\n",
        "91": "    ImmutableMap.Builder<N, ImmutableSet<E>> nodeToEdgesBuilder = ImmutableMap.builder();\n",
        "93": "      nodeToEdgesBuilder.put(node, ImmutableSet.copyOf(undirectedGraph.incidentEdges(node)));\n",
        "95": "    nodeToIncidentEdges = nodeToEdgesBuilder.build();\n",
        "100": "    edgeToIncidentNodes = edgeToNodesBuilder.build();\n",
        "101": "    config = undirectedGraph.config();\n",
        "106": "    return nodeToIncidentEdges.keySet();\n",
        "121": "    checkNotNull(node, \"node\");\n",
        "122": "    ImmutableSet<E> incidentEdges = nodeToIncidentEdges.get(node);\n",
        "123": "    checkArgument(incidentEdges != null, NODE_NOT_IN_GRAPH, node);\n",
        "124": "    return incidentEdges;\n",
        "137": "    ImmutableSet.Builder<N> adjacentNodesBuilder = ImmutableSet.builder();\n",
        "138": "    for (E edge : incidentEdges(node)) {\n",
        "139": "      adjacentNodesBuilder.add(oppositeNode(this, edge, node));\n",
        "140": "    }\n",
        "141": "    return adjacentNodesBuilder.build();\n",
        "156": "   * If {@code node1} is equal to {@code node2}, a {@code Set} instance is returned,\n",
        "157": "   * calculating the set of self-loop edges. Otherwise, this method returns the\n",
        "158": "   * intersection of these two sets, using {@code Sets.intersection}:\n",
        "160": "   * <li>{@code node1}'s incident edges.\n",
        "161": "   * <li>{@code node2}'s incident edges.\n",
        "163": "   * The first argument passed to {@code Sets.intersection} is the smaller of\n",
        "164": "   * the two sets.\n",
        "165": "   *\n",
        "166": "   * @see Sets#intersection\n",
        "170": "    checkNotNull(node1, \"node1\");\n",
        "171": "    checkNotNull(node2, \"node2\");\n",
        "174": "      Set<E> returnSet = Sets.newLinkedHashSet();\n",
        "175": "      for (E edge : incidentEdgesN1) {\n",
        "176": "        if (edgeToIncidentNodes.get(edge).isSelfLoop()) {\n",
        "177": "          returnSet.add(edge);\n",
        "178": "        }\n",
        "180": "      return Collections.unmodifiableSet(returnSet);\n",
        "183": "    return incidentEdgesN1.size() <= incidentEdgesN2.size()\n",
        "225": "    return (object instanceof UndirectedGraph) && Graphs.equal(this, (UndirectedGraph) object);\n",
        "230": "    // This map encapsulates all of the structural relationships of this graph, so its hash code\n",
        "231": "    // is consistent with the above definition of equals().\n",
        "232": "    return nodeToIncidentEdges.hashCode();\n",
        "261": "  @Override\n",
        "262": "  public String toString() {\n",
        "263": "    return String.format(\"config: %s, nodes: %s, edges: %s\",\n",
        "264": "        config,\n",
        "265": "        nodeToIncidentEdges.keySet(),\n",
        "266": "        edgeToIncidentNodes);\n",
        "267": "  }\n",
        "268": "\n",
        "328": "     * @see Graph#addEdge(e, n1, n2)\n"
    },
    "removed": {
        "25": "import com.google.common.base.Objects;\n",
        "28": "import com.google.common.collect.Iterables;\n",
        "58": " * <p>The time complexity of all {@code Set}-returning accessors is O(1), since we\n",
        "59": " * are returning views. An exception to this is {@code edgesConnecting(node1, node2)},\n",
        "60": " * which is O(min(d_node1, d_node2)).\n",
        "75": "  private final ImmutableMap<N, NodeConnections<N, E>> nodeConnections;\n",
        "82": "    ImmutableMap.Builder<N, NodeConnections<N, E>> nodeConnectionsBuilder =\n",
        "83": "        ImmutableMap.builder();\n",
        "85": "      nodeConnectionsBuilder.put(node, UndirectedNodeConnections.ofImmutable(\n",
        "86": "          undirectedGraph.adjacentNodes(node), undirectedGraph.incidentEdges(node)));\n",
        "88": "    this.nodeConnections = nodeConnectionsBuilder.build();\n",
        "93": "    this.edgeToIncidentNodes = edgeToNodesBuilder.build();\n",
        "94": "    this.config = undirectedGraph.config();\n",
        "99": "    return nodeConnections.keySet();\n",
        "114": "    return checkedConnections(node).incidentEdges();\n",
        "127": "    return checkedConnections(node).adjacentNodes();\n",
        "142": "   * If {@code node1} is equal to {@code node2}, the set of self-loop edges is returned.\n",
        "143": "   * Otherwise, returns the intersection of these two sets, using {@link Sets#intersection}:\n",
        "145": "   * <li>Incident edges of {@code node1}.\n",
        "146": "   * <li>Incident edges of {@code node2}.\n",
        "153": "      if (!config.isSelfLoopsAllowed()) {\n",
        "154": "        return ImmutableSet.of();\n",
        "156": "      return ImmutableSet.copyOf(Iterables.filter(incidentEdgesN1, Graphs.selfLoopPredicate(this)));\n",
        "159": "    return (incidentEdgesN1.size() <= incidentEdgesN2.size())\n",
        "201": "    return (object instanceof UndirectedGraph)\n",
        "202": "        && Graphs.equal(this, (UndirectedGraph<?, ?>) object);\n",
        "207": "    // The node set is included in the hash to differentiate between graphs with isolated nodes.\n",
        "208": "    return Objects.hashCode(nodes(), edgeToIncidentNodes);\n",
        "209": "  }\n",
        "210": "\n",
        "211": "  @Override\n",
        "212": "  public String toString() {\n",
        "213": "    return String.format(\"config: %s, nodes: %s, edges: %s\",\n",
        "214": "        config,\n",
        "215": "        nodes(),\n",
        "216": "        edgeToIncidentNodes);\n",
        "217": "  }\n",
        "218": "\n",
        "219": "  private NodeConnections<N, E> checkedConnections(Object node) {\n",
        "220": "    checkNotNull(node, \"node\");\n",
        "221": "    NodeConnections<N, E> connections = nodeConnections.get(node);\n",
        "222": "    checkArgument(connections != null, NODE_NOT_IN_GRAPH, node);\n",
        "223": "    return connections;\n",
        "311": "     * @see Graph#addEdge\n"
    }
}