{
    "addition": {
        "2": " * Copyright (C) 2014 The Guava Authors\n",
        "35": " * complexity they are: {@link Graph}, {@link ValueGraph}, and {@link Network}. You should generally\n",
        "42": " *     <p>Yes: Go to question 2. No: Use {@link Graph}.\n",
        "46": " *     <p>Yes: Go to question 3. No: Use {@link ValueGraph}.\n",
        "53": " *     <p>Yes: Use {@link Network}. No: Use {@link ValueGraph}.\n",
        "56": " * <p>Although {@link MutableValueGraph} and {@link MutableNetwork} both require users to provide\n",
        "57": " * objects to associate with edges when adding them, the differentiating factor is that in {@link\n",
        "58": " * ValueGraph}s, these objects can be any arbitrary data. Like the values in a {@link Map}, they do\n",
        "59": " * not have to be unique, and can be mutated while in the graph. In a {@link Network}, these objects\n",
        "60": " * serve as keys into the data structure. Like the keys in a {@link Map}, they must be unique, and\n",
        "61": " * cannot be mutated in a way that affects their equals/hashcode or the data structure will become\n",
        "62": " * corrupted.\n",
        "66": " * <p>The {@link Graph} interface does not support parallel {@link #edges()}, and forbids\n",
        "67": " * implementations or extensions with parallel edges. It is possible to encode a notion of edge\n",
        "68": " * multiplicity into the values of a {@ValueGraph} (e.g. with an integer or a list of values), but\n",
        "69": " * this will not be reflected in methods such as {@link Graph#degree(Object)}. For that\n",
        "70": " * functionality, use {@link Network}s.\n",
        "71": " *\n",
        "90": " * MutableGraph<String> managementGraph = GraphBuilder.directed().build();\n",
        "91": " * managementGraph.putEdge(\"Big Boss\", \"Middle Manager Jack\");\n",
        "92": " * managementGraph.putEdge(\"Big Boss\", \"Middle Manager Jill\");\n",
        "93": " * managementGraph.putEdge(\"Middle Manager Jack\", \"Joe\");\n",
        "94": " * managementGraph.putEdge(\"Middle Manager Jack\", \"Schmoe\");\n",
        "95": " * managementGraph.putEdge(\"Middle Manager Jill\", \"Jane\");\n",
        "96": " * managementGraph.putEdge(\"Middle Manager Jill\", \"Doe\");\n",
        "97": " * for (String employee : managementGraph.nodes()) {\n",
        "98": " *   Set<String> reports = managementGraph.successors(employee);\n",
        "99": " *   if (!reports.isEmpty()) {\n",
        "100": " *     System.out.format(\"%s has the following direct reports: %s%n\", employee, reports);\n",
        "106": " * @author Joshua O'Madadhain\n",
        "111": "public interface Graph<N> {\n",
        "120": "  Set<EndpointPair<N>> edges();\n",
        "128": "   * EndpointPair#source() source node} to a {@link EndpointPair#target() target node}, while\n",
        "129": "   * undirected edges connect a pair of nodes to each other.\n",
        "217": "   * For the default {@link Graph} implementations, returns true iff {@code this == object} (i.e.\n",
        "218": "   * reference equality). External implementations are free to define this method as they see fit,\n",
        "219": "   * as long as they satisfy the {@link Object#equals(Object)} contract.\n",
        "221": "   * <p>To compare two {@link Graph}s based on their contents rather than their references, see\n",
        "222": "   * {@link Graphs#equivalent(Graph, Graph)}.\n",
        "228": "   * For the default {@link Graph} implementations, returns {@code System.identityHashCode(this)}.\n",
        "229": "   * External implementations are free to define this method as they see fit, as long as they\n",
        "230": "   * satisfy the {@link Object#hashCode()} contract.\n"
    },
    "removed": {
        "2": " * Copyright (C) 2016 The Guava Authors\n",
        "35": " * complexity they are: {@link BasicGraph}, {@link Graph}, and {@link Network}. You should generally\n",
        "42": " *     <p>Yes: Go to question 2. No: Use {@link BasicGraph}.\n",
        "46": " *     <p>Yes: Go to question 3. No: Use {@link Graph}.\n",
        "53": " *     <p>Yes: Use {@link Network}. No: Use {@link Graph}.\n",
        "56": " * <p>Although {@link MutableGraph} and {@link MutableNetwork} both require users to provide objects\n",
        "57": " * to associate with edges when adding them, the differentiating factor is that in {@link Graph}s,\n",
        "58": " * these objects can be any arbitrary data. Like the values in a {@link Map}, they do not have to be\n",
        "59": " * unique, and can be mutated while in the graph. In a {@link Network}, these objects serve as keys\n",
        "60": " * into the data structure. Like the keys in a {@link Map}, they must be unique, and cannot be\n",
        "61": " * mutated in a way that affects their equals/hashcode or the data structure will become corrupted.\n",
        "83": " * MutableGraph<String, Double> synonymGraph = GraphBuilder.undirected().build();\n",
        "84": " * synonymGraph.putEdgeValue(\"large\", \"big\", 0.9);\n",
        "85": " * synonymGraph.putEdgeValue(\"large\", \"huge\", 0.9);\n",
        "86": " * synonymGraph.putEdgeValue(\"large\", \"grand\", 0.6);\n",
        "87": " * synonymGraph.putEdgeValue(\"large\", \"cold\", 0.0);\n",
        "88": " * synonymGraph.putEdgeValue(\"large\", \"small\", -1.0);\n",
        "89": " * for (String word : synonymGraph.adjacentNodes(\"large\")) {\n",
        "90": " *   if (synonymGraph.edgeValue(word, \"large\") > 0.5) {\n",
        "91": " *     System.out.println(word + \" is a synonym for large\");\n",
        "98": " * @param <V> Value parameter type\n",
        "102": "public interface Graph<N, V> {\n",
        "111": "  Set<Endpoints<N>> edges();\n",
        "119": "   * Endpoints#source() source node} to a {@link Endpoints#target() target node}, while undirected\n",
        "120": "   * edges connect a pair of nodes to each other.\n",
        "203": "  /**\n",
        "204": "   * If there is an edge connecting {@code nodeA} to {@code nodeB}, returns the non-null value\n",
        "205": "   * associated with that edge.\n",
        "206": "   *\n",
        "207": "   * <p>In an undirected graph, this is equal to {@code edgeValue(nodeB, nodeA)}.\n",
        "208": "   *\n",
        "209": "   * @throws IllegalArgumentException if there is no edge connecting {@code nodeA} to {@code nodeB}\n",
        "210": "   */\n",
        "211": "  V edgeValue(Object nodeA, Object nodeB);\n",
        "212": "\n",
        "213": "  /**\n",
        "214": "   * If there is an edge connecting {@code nodeA} to {@code nodeB}, returns the non-null value\n",
        "215": "   * associated with that edge; otherwise, returns {@code defaultValue}.\n",
        "216": "   *\n",
        "217": "   * <p>In an undirected graph, this is equal to {@code edgeValueOrDefault(nodeB, nodeA,\n",
        "218": "   * defaultValue)}.\n",
        "219": "   *\n",
        "220": "   * @throws IllegalArgumentException if {@code nodeA} or {@code nodeB} is not an element of this\n",
        "221": "   *     graph\n",
        "222": "   */\n",
        "223": "  V edgeValueOrDefault(Object nodeA, Object nodeB, @Nullable V defaultValue);\n",
        "224": "\n",
        "230": "   * Returns {@code true} iff {@code object} is a {@link Graph} that has the same elements and the\n",
        "231": "   * same structural relationships as those in this graph.\n",
        "232": "   *\n",
        "233": "   * <p>Thus, two graphs A and B are equal if <b>all</b> of the following are true:\n",
        "235": "   * <ul>\n",
        "236": "   * <li>A and B have equal {@link #isDirected() directedness}.\n",
        "237": "   * <li>A and B have equal {@link #nodes() node sets}.\n",
        "238": "   * <li>A and B have equal {@link #edges() edge sets}.\n",
        "239": "   * <li>Every edge in A and B are associated with equal {@link #edgeValue(Object, Object) values}.\n",
        "240": "   * </ul>\n",
        "241": "   *\n",
        "242": "   * <p>Graph properties besides {@link #isDirected() directedness} do <b>not</b> affect equality.\n",
        "243": "   * For example, two graphs may be considered equal even if one allows self-loops and the other\n",
        "244": "   * doesn't. Additionally, the order in which nodes or edges are added to the graph, and the order\n",
        "245": "   * in which they are iterated over, are irrelevant.\n",
        "246": "   *\n",
        "247": "   * <p>A reference implementation of this is provided by {@link AbstractGraph#equals(Object)}.\n",
        "253": "   * Returns the hash code for this graph. The hash code of a graph is defined as the hash code of a\n",
        "254": "   * map from each of its {@link #edges() edges} to the associated {@link #edgeValue(Object, Object)\n",
        "255": "   * edge value}.\n",
        "256": "   *\n",
        "257": "   * <p>A reference implementation of this is provided by {@link AbstractGraph#hashCode()}.\n"
    }
}