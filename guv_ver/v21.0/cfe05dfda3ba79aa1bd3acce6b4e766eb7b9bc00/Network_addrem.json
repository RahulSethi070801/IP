{
    "addition": {
        "35": " * complexity they are: {@link Graph}, {@link ValueGraph}, and {@link Network}. You should generally\n",
        "40": " *     <p>Yes: Go to question 2. No: Use {@link Graph}.\n",
        "44": " *     <p>Yes: Go to question 3. No: Use {@link ValueGraph}.\n",
        "51": " *     <p>Yes: Use {@link Network}. No: Use {@link ValueGraph}.\n",
        "54": " * <p>Although {@link MutableValueGraph} and {@link MutableNetwork} both require users to provide\n",
        "55": " * objects to associate with edges when adding them, the differentiating factor is that in {@link\n",
        "56": " * ValueGraph}s, these objects can be any arbitrary data. Like the values in a {@link Map}, they do\n",
        "57": " * not have to be unique, and can be mutated while in the graph. In a {@link Network}, these objects\n",
        "58": " * serve as keys into the data structure. Like the keys in a {@link Map}, they must be unique, and\n",
        "59": " * cannot be mutated in a way that affects their equals/hashcode or the data structure will become\n",
        "60": " * corrupted.\n",
        "88": " *   EndpointPair<String> cities = roadNetwork.incidentNodes(roadToQuery);\n",
        "89": " *   System.out.format(\"%s and %s connected via %s\", cities.nodeU(), cities.nodeV(), roadToQuery);\n",
        "119": "  Graph<N> asGraph();\n",
        "127": "   * EndpointPair#source() source node} to a {@link EndpointPair#target() target node}, while\n",
        "128": "   * undirected edges connect a pair of nodes to each other.\n",
        "253": "  EndpointPair<N> incidentNodes(Object edge);\n",
        "264": "   * Returns the set of edges that connect {@code nodeU} to {@code nodeV}.\n",
        "266": "   * <p>In an undirected network, this is equal to {@code edgesConnecting(nodeV, nodeU)}.\n",
        "268": "   * @throws IllegalArgumentException if {@code nodeU} or {@code nodeV} is not an element of this\n",
        "271": "  Set<E> edgesConnecting(Object nodeU, Object nodeV);\n",
        "278": "   * For the default {@link Network} implementations, returns true iff {@code this == object} (i.e.\n",
        "279": "   * reference equality). External implementations are free to define this method as they see fit,\n",
        "280": "   * as long as they satisfy the {@link Object#equals(Object)} contract.\n",
        "282": "   * <p>To compare two {@link Network}s based on their contents rather than their references, see\n",
        "283": "   * {@link Graphs#equivalent(Network, Network)}.\n",
        "289": "   * For the default {@link Network} implementations, returns {@code System.identityHashCode(this)}.\n",
        "290": "   * External implementations are free to define this method as they see fit, as long as they\n",
        "291": "   * satisfy the {@link Object#hashCode()} contract.\n"
    },
    "removed": {
        "35": " * complexity they are: {@link BasicGraph}, {@link Graph}, and {@link Network}. You should generally\n",
        "40": " *     <p>Yes: Go to question 2. No: Use {@link BasicGraph}.\n",
        "44": " *     <p>Yes: Go to question 3. No: Use {@link Graph}.\n",
        "51": " *     <p>Yes: Use {@link Network}. No: Use {@link Graph}.\n",
        "54": " * <p>Although {@link MutableGraph} and {@link MutableNetwork} both require users to provide objects\n",
        "55": " * to associate with edges when adding them, the differentiating factor is that in {@link Graph}s,\n",
        "56": " * these objects can be any arbitrary data. Like the values in a {@link Map}, they do not have to be\n",
        "57": " * unique, and can be mutated while in the graph. In a {@link Network}, these objects serve as keys\n",
        "58": " * into the data structure. Like the keys in a {@link Map}, they must be unique, and cannot be\n",
        "59": " * mutated in a way that affects their equals/hashcode or the data structure will become corrupted.\n",
        "87": " *   Endpoints<String> cities = roadNetwork.incidentNodes(roadToQuery);\n",
        "88": " *   System.out.format(\"%s and %s connected via %s\", cities.nodeA(), cities.nodeB(), roadToQuery);\n",
        "114": "   * <p>{@link Graph#edgeValue(Object, Object)} will return the set of edges connecting node A to\n",
        "115": "   * node B if the set is non-empty, otherwise, it will throw {@link IllegalArgumentException}.\n",
        "116": "   *\n",
        "121": "  Graph<N, Set<E>> asGraph();\n",
        "129": "   * Endpoints#source() source node} to a {@link Endpoints#target() target node}, while undirected\n",
        "130": "   * edges connect a pair of nodes to each other.\n",
        "255": "  Endpoints<N> incidentNodes(Object edge);\n",
        "266": "   * Returns the set of edges that connect {@code nodeA} to {@code nodeB}.\n",
        "268": "   * <p>In an undirected network, this is equal to {@code edgesConnecting(nodeB, nodeA)}.\n",
        "270": "   * @throws IllegalArgumentException if {@code nodeA} or {@code nodeB} is not an element of this\n",
        "273": "  Set<E> edgesConnecting(Object nodeA, Object nodeB);\n",
        "280": "   * Returns {@code true} iff {@code object} is a {@link Network} that has the same elements and the\n",
        "281": "   * same structural relationships as those in this network.\n",
        "282": "   *\n",
        "283": "   * <p>Thus, two networks A and B are equal if <b>all</b> of the following are true:\n",
        "284": "   *\n",
        "285": "   * <ul>\n",
        "286": "   * <li>A and B have equal {@link #isDirected() directedness}.\n",
        "287": "   * <li>A and B have equal {@link #nodes() node sets}.\n",
        "288": "   * <li>A and B have equal {@link #edges() edge sets}.\n",
        "289": "   * <li>Every edge in A and B connects the same nodes in the same direction (if any).\n",
        "290": "   * </ul>\n",
        "292": "   * <p>Network properties besides {@link #isDirected() directedness} do <b>not</b> affect equality.\n",
        "293": "   * For example, two networks may be considered equal even if one allows parallel edges and the\n",
        "294": "   * other doesn't. Additionally, the order in which nodes or edges are added to the network, and\n",
        "295": "   * the order in which they are iterated over, are irrelevant.\n",
        "296": "   *\n",
        "297": "   * <p>A reference implementation of this is provided by {@link AbstractNetwork#equals(Object)}.\n",
        "303": "   * Returns the hash code for this network. The hash code of a network is defined as the hash code\n",
        "304": "   * of a map from each of its {@link #edges() edges} to their {@link #incidentNodes(Object)\n",
        "305": "   * incident nodes}.\n",
        "306": "   *\n",
        "307": "   * <p>A reference implementation of this is provided by {@link AbstractNetwork#hashCode()}.\n"
    }
}