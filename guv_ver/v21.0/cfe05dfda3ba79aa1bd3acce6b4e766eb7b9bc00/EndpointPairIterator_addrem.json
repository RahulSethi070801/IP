{
    "addition": {
        "32": "abstract class EndpointPairIterator<N> extends AbstractIterator<EndpointPair<N>> {\n",
        "33": "  private final Graph<N> graph;\n",
        "39": "  static <N> EndpointPairIterator<N> of(Graph<N> graph) {\n",
        "43": "  EndpointPairIterator(Graph<N> graph) {\n",
        "66": "  private static final class Directed<N> extends EndpointPairIterator<N> {\n",
        "67": "    Directed(Graph<N> graph){\n",
        "72": "    protected EndpointPair<N> computeNext() {\n",
        "75": "          return EndpointPair.ordered(node, successorIterator.next());\n",
        "87": "   * {@link EndpointPair}, we keep track of the nodes that we have visited. When processing endpoint\n",
        "88": "   * pairs, we skip if the \"other node\" is in the visited set, as shown below:\n",
        "96": "   * EndpointPair [N1, N2] - return\n",
        "97": "   * EndpointPair [N1, N3] - return\n",
        "99": "   * EndpointPair [N2, N1] - skip\n",
        "100": "   * EndpointPair [N2, N3] - return\n",
        "102": "   * EndpointPair [N3, N1] - skip\n",
        "103": "   * EndpointPair [N3, N2] - skip\n",
        "105": "   * EndpointPair [N4, N4] - return\n",
        "108": "  private static final class Undirected<N> extends EndpointPairIterator<N> {\n",
        "111": "    Undirected(Graph<N> graph) {\n",
        "117": "    protected EndpointPair<N> computeNext() {\n",
        "122": "            return EndpointPair.unordered(node, otherNode);\n"
    },
    "removed": {
        "31": " * @since 20.0\n",
        "33": "abstract class EndpointsIterator<N> extends AbstractIterator<Endpoints<N>> {\n",
        "34": "  private final Graph<N, ?> graph;\n",
        "40": "  static <N> EndpointsIterator<N> of(Graph<N, ?> graph) {\n",
        "44": "  EndpointsIterator(Graph<N, ?> graph) {\n",
        "67": "  private static final class Directed<N> extends EndpointsIterator<N> {\n",
        "68": "    Directed(Graph<N, ?> graph){\n",
        "73": "    protected Endpoints<N> computeNext() {\n",
        "76": "          return Endpoints.ofDirected(node, successorIterator.next());\n",
        "88": "   * {@link Endpoints}, we keep track of the nodes that we have visited. When processing node pairs,\n",
        "89": "   * we skip if the \"other node\" is in the visited set, as shown below:\n",
        "97": "   * Endpoints [N1, N2] - return\n",
        "98": "   * Endpoints [N1, N3] - return\n",
        "100": "   * Endpoints [N2, N1] - skip\n",
        "101": "   * Endpoints [N2, N3] - return\n",
        "103": "   * Endpoints [N3, N1] - skip\n",
        "104": "   * Endpoints [N3, N2] - skip\n",
        "106": "   * Endpoints [N4, N4] - return\n",
        "109": "  private static final class Undirected<N> extends EndpointsIterator<N> {\n",
        "112": "    Undirected(Graph<N, ?> graph) {\n",
        "118": "    protected Endpoints<N> computeNext() {\n",
        "123": "            return Endpoints.ofUndirected(node, otherNode);\n"
    }
}