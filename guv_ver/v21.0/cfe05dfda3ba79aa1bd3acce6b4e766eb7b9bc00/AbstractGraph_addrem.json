{
    "addition": {
        "31": " * this class rather than implement {@link Graph} directly.\n",
        "38": "public abstract class AbstractGraph<N> implements Graph<N> {\n",
        "60": "  public Set<EndpointPair<N>> edges() {\n",
        "61": "    return new AbstractSet<EndpointPair<N>>() {\n",
        "63": "      public Iterator<EndpointPair<N>> iterator() {\n",
        "64": "        return EndpointPairIterator.of(AbstractGraph.this);\n",
        "74": "        if (!(obj instanceof EndpointPair)) {\n",
        "77": "        EndpointPair<?> endpointPair = (EndpointPair<?>) obj;\n",
        "78": "        return isDirected() == endpointPair.isOrdered()\n",
        "79": "            && nodes().contains(endpointPair.nodeU())\n",
        "80": "            && successors(endpointPair.nodeU()).contains(endpointPair.nodeV());\n",
        "111": "    return toString(this);\n",
        "112": "  }\n",
        "113": "\n",
        "114": "  static String toString(Graph<?> graph) {\n",
        "116": "        \"isDirected: %s, allowsSelfLoops: %s\", graph.isDirected(), graph.allowsSelfLoops());\n",
        "119": "        graph.nodes(),\n",
        "120": "        graph.edges());\n"
    },
    "removed": {
        "23": "import com.google.common.base.Function;\n",
        "24": "import com.google.common.collect.Maps;\n",
        "29": "import java.util.Map;\n",
        "31": "import javax.annotation.Nullable;\n",
        "35": " * this class rather than implement {@link Graph} directly, to ensure consistent {@link\n",
        "36": " * #equals(Object)} and {@link #hashCode()} results across different graph implementations.\n",
        "40": " * @param <V> Value parameter type\n",
        "44": "public abstract class AbstractGraph<N, V> implements Graph<N, V> {\n",
        "66": "  public Set<Endpoints<N>> edges() {\n",
        "67": "    return new AbstractSet<Endpoints<N>>() {\n",
        "69": "      public Iterator<Endpoints<N>> iterator() {\n",
        "70": "        return EndpointsIterator.of(AbstractGraph.this);\n",
        "80": "        if (!(obj instanceof Endpoints)) {\n",
        "83": "        Endpoints<?> endpoints = (Endpoints<?>) obj;\n",
        "84": "        return isDirected() == endpoints.isDirected()\n",
        "85": "            && nodes().contains(endpoints.nodeA())\n",
        "86": "            && successors(endpoints.nodeA()).contains(endpoints.nodeB());\n",
        "112": "  @Override\n",
        "113": "  public final boolean equals(@Nullable Object obj) {\n",
        "114": "    if (obj == this) {\n",
        "115": "      return true;\n",
        "116": "    }\n",
        "117": "    if (!(obj instanceof Graph)) {\n",
        "118": "      return false;\n",
        "119": "    }\n",
        "120": "    Graph<?, ?> other = (Graph<?, ?>) obj;\n",
        "121": "\n",
        "122": "    if (isDirected() != other.isDirected()\n",
        "123": "        || !nodes().equals(other.nodes())\n",
        "124": "        || !edges().equals(other.edges())) {\n",
        "125": "      return false;\n",
        "126": "    }\n",
        "127": "\n",
        "128": "    for (Endpoints<N> edge : edges()) {\n",
        "129": "      if (!edgeValue(edge.nodeA(), edge.nodeB()).equals(\n",
        "130": "          other.edgeValue(edge.nodeA(), edge.nodeB()))) {\n",
        "131": "        return false;\n",
        "132": "      }\n",
        "133": "    }\n",
        "134": "\n",
        "135": "    return true;\n",
        "136": "  }\n",
        "137": "\n",
        "138": "  @Override\n",
        "139": "  public final int hashCode() {\n",
        "140": "    return edgeValueMap().hashCode();\n",
        "141": "  }\n",
        "142": "\n",
        "149": "        \"isDirected: %s, allowsSelfLoops: %s\", isDirected(), allowsSelfLoops());\n",
        "152": "        nodes(),\n",
        "153": "        edgeValueMap());\n",
        "154": "  }\n",
        "155": "\n",
        "156": "  private Map<Endpoints<N>, V> edgeValueMap() {\n",
        "157": "    Function<Endpoints<N>, V> edgeToValueFn = new Function<Endpoints<N>, V>() {\n",
        "158": "      @Override\n",
        "159": "      public V apply(Endpoints<N> edge) {\n",
        "160": "        return edgeValue(edge.nodeA(), edge.nodeB());\n",
        "161": "      }\n",
        "162": "    };\n",
        "163": "    return Maps.asMap(edges(), edgeToValueFn);\n"
    }
}