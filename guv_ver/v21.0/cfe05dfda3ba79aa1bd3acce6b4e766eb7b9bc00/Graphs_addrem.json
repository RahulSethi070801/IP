{
    "addition": {
        "57": "  public static boolean hasCycle(Graph<?> graph) {\n",
        "99": "      Graph<?> graph,\n",
        "129": "      Graph<?> graph, Object nextNode, @Nullable Object previousNode) {\n",
        "144": "   * of the transitive closure of {@code graph}. In other words, the returned {@link Graph} will not\n",
        "145": "   * be updated after modifications to {@code graph}.\n",
        "147": "  public static <N> Graph<N> transitiveClosure(Graph<N> graph) {\n",
        "148": "    MutableGraph<N> transitiveClosure = GraphBuilder.from(graph).allowsSelfLoops(true).build();\n",
        "168": "            N nodeU = reachableNodes.get(a);\n",
        "170": "              N nodeV = reachableNodes.get(b);\n",
        "171": "              transitiveClosure.putEdge(nodeU, nodeV);\n",
        "193": "  public static <N> Set<N> reachableNodes(Graph<N> graph, Object node) {\n",
        "212": "   * Returns {@code true} iff {@code graphA} and {@code graphB} have the same elements and the same\n",
        "213": "   * relationships between elements, as exposed via the {@link Graph} interface.\n",
        "214": "   *\n",
        "215": "   * <p>Thus, two graphs A and B are equivalent if <b>all</b> of the following are true:\n",
        "216": "   *\n",
        "217": "   * <ul>\n",
        "218": "   * <li>A and B have equal {@link Graph#isDirected() directedness}.\n",
        "219": "   * <li>A and B have equal {@link Graph#nodes() node sets}.\n",
        "220": "   * <li>A and B have equal {@link Graph#edges() edge sets}.\n",
        "221": "   * </ul>\n",
        "222": "   *\n",
        "223": "   * <p>Graph properties besides {@link Graph#isDirected() directedness} do <b>not</b> affect\n",
        "224": "   * equivalence. For example, two graphs may be considered equivalent even if one allows self-loops\n",
        "225": "   * and the other doesn't. Additionally, the order in which nodes or edges are added to the graph,\n",
        "226": "   * and the order in which they are iterated over, are irrelevant.\n",
        "228": "  public static boolean equivalent(@Nullable Graph<?> graphA, @Nullable Graph<?> graphB) {\n",
        "229": "    if (graphA == graphB) {\n",
        "230": "      return true;\n",
        "231": "    }\n",
        "232": "    if (graphA == null || graphB == null) {\n",
        "233": "      return false;\n",
        "234": "    }\n",
        "236": "    return graphA.isDirected() == graphB.isDirected()\n",
        "237": "        && graphA.nodes().equals(graphB.nodes())\n",
        "238": "        && graphA.edges().equals(graphB.edges());\n",
        "239": "  }\n",
        "241": "  /**\n",
        "242": "   * Returns {@code true} iff {@code graphA} and {@code graphB} have the same elements (including\n",
        "243": "   * edge values) and the same relationships between elements, as exposed via the {@link ValueGraph}\n",
        "244": "   * interface.\n",
        "245": "   *\n",
        "246": "   * <p>Thus, two value graphs A and B are equivalent if <b>all</b> of the following are true:\n",
        "247": "   *\n",
        "248": "   * <ul>\n",
        "249": "   * <li>A and B have equal {@link Graph#isDirected() directedness}.\n",
        "250": "   * <li>A and B have equal {@link Graph#nodes() node sets}.\n",
        "251": "   * <li>A and B have equal {@link Graph#edges() edge sets}.\n",
        "252": "   * <li>Each edge in A has a {@link ValueGraph#edgeValue(Object, Object) value} equal to the\n",
        "253": "   *     {@link ValueGraph#edgeValue(Object, Object) value} of the corresponding edge in B.\n",
        "254": "   * </ul>\n",
        "255": "   *\n",
        "256": "   * <p>Graph properties besides {@link Graph#isDirected() directedness} do <b>not</b> affect\n",
        "257": "   * equivalence. For example, two graphs may be considered equivalent even if one allows self-loops\n",
        "258": "   * and the other doesn't. Additionally, the order in which nodes or edges are added to the graph,\n",
        "259": "   * and the order in which they are iterated over, are irrelevant.\n",
        "260": "   */\n",
        "261": "  public static boolean equivalent(\n",
        "262": "      @Nullable ValueGraph<?, ?> graphA, @Nullable ValueGraph<?, ?> graphB) {\n",
        "263": "    if (graphA == graphB) {\n",
        "264": "      return true;\n",
        "265": "    }\n",
        "266": "    if (graphA == null || graphB == null) {\n",
        "267": "      return false;\n",
        "268": "    }\n",
        "270": "    // TODO(b/31166974): If we add a Map of edgeValues, we can check against that for equality.\n",
        "271": "    if (graphA.isDirected() != graphB.isDirected()\n",
        "272": "        || !graphA.nodes().equals(graphB.nodes())\n",
        "273": "        || !graphA.edges().equals(graphB.edges())) {\n",
        "274": "      return false;\n",
        "275": "    }\n",
        "277": "    for (EndpointPair<?> edge : graphA.edges()) {\n",
        "278": "      if (!graphA.edgeValue(edge.nodeU(), edge.nodeV()).equals(\n",
        "279": "          graphB.edgeValue(edge.nodeU(), edge.nodeV()))) {\n",
        "280": "        return false;\n",
        "282": "    }\n",
        "284": "    return true;\n",
        "285": "  }\n",
        "287": "  /**\n",
        "288": "   * Returns {@code true} iff {@code networkA} and {@code networkB} have the same elements and the\n",
        "289": "   * same relationships between elements, as exposed via the {@link Network} interface.\n",
        "290": "   *\n",
        "291": "   * <p>Thus, two networks A and B are equivalent if <b>all</b> of the following are true:\n",
        "292": "   *\n",
        "293": "   * <ul>\n",
        "294": "   * <li>A and B have equal {@link Network#isDirected() directedness}.\n",
        "295": "   * <li>A and B have equal {@link Network#nodes() node sets}.\n",
        "296": "   * <li>A and B have equal {@link Network#edges() edge sets}.\n",
        "297": "   * <li>Each edge in A connects the same nodes in the same direction (if any) as the corresponding\n",
        "298": "   *     edge in B.\n",
        "299": "   * </ul>\n",
        "300": "   *\n",
        "301": "   * <p>Network properties besides {@link Network#isDirected() directedness} do <b>not</b> affect\n",
        "302": "   * equivalence. For example, two networks may be considered equal even if one allows parallel\n",
        "303": "   * edges and the other doesn't. Additionally, the order in which nodes or edges are added to the\n",
        "304": "   * network, and the order in which they are iterated over, are irrelevant.\n",
        "305": "   */\n",
        "306": "  public static boolean equivalent(\n",
        "307": "      @Nullable Network<?, ?> networkA, @Nullable Network<?, ?> networkB) {\n",
        "308": "    if (networkA == networkB) {\n",
        "309": "      return true;\n",
        "310": "    }\n",
        "311": "    if (networkA == null || networkB == null) {\n",
        "312": "      return false;\n",
        "313": "    }\n",
        "315": "    if (networkA.isDirected() != networkB.isDirected()\n",
        "316": "        || !networkA.nodes().equals(networkB.nodes())\n",
        "317": "        || !networkA.edges().equals(networkB.edges())) {\n",
        "318": "      return false;\n",
        "319": "    }\n",
        "321": "    for (Object edge : networkA.edges()) {\n",
        "322": "      if (!networkA.incidentNodes(edge).equals(networkB.incidentNodes(edge))) {\n",
        "323": "        return false;\n",
        "325": "    }\n",
        "327": "    return true;\n",
        "330": "  // Graph mutation methods\n",
        "332": "  // Graph view methods\n",
        "338": "  public static <N> Graph<N> transpose(Graph<N> graph) {\n",
        "344": "      return ((TransposedGraph<N>) graph).graph;\n",
        "347": "    return new TransposedGraph<N>(graph);\n",
        "350": "  private static class TransposedGraph<N> extends AbstractGraph<N> {\n",
        "351": "    private final Graph<N> graph;\n",
        "353": "    TransposedGraph(Graph<N> graph) {\n",
        "362": "    /**\n",
        "363": "     * Defer to {@link AbstractGraph#edges()} (based on {@link #successors(Object)}) for full\n",
        "364": "     * edges() implementation.\n",
        "365": "     */\n",
        "366": "    @Override\n",
        "367": "    protected long edgeCount() {\n",
        "368": "      return graph.edges().size();\n",
        "369": "    }\n",
        "400": "  }\n",
        "402": "  /**\n",
        "403": "   * Returns a view of {@code graph} with the direction (if any) of every edge reversed. All other\n",
        "404": "   * properties remain intact, and further updates to {@code graph} will be reflected in the view.\n",
        "405": "   */\n",
        "406": "  public static <N, V> ValueGraph<N, V> transpose(ValueGraph<N, V> graph) {\n",
        "407": "    if (!graph.isDirected()) {\n",
        "408": "      return graph; // the transpose of an undirected graph is an identical graph\n",
        "409": "    }\n",
        "410": "\n",
        "411": "    if (graph instanceof TransposedValueGraph) {\n",
        "412": "      return ((TransposedValueGraph<N, V>) graph).graph;\n",
        "413": "    }\n",
        "414": "\n",
        "415": "    return new TransposedValueGraph<N, V>(graph);\n",
        "416": "  }\n",
        "417": "\n",
        "418": "  private static class TransposedValueGraph<N, V> extends AbstractValueGraph<N, V> {\n",
        "419": "    private final ValueGraph<N, V> graph;\n",
        "420": "\n",
        "421": "    TransposedValueGraph(ValueGraph<N, V> graph) {\n",
        "422": "      this.graph = graph;\n",
        "426": "    public Set<N> nodes() {\n",
        "427": "      return graph.nodes();\n",
        "430": "    /**\n",
        "431": "     * Defer to {@link AbstractGraph#edges()} (based on {@link #successors(Object)}) for full\n",
        "432": "     * edges() implementation.\n",
        "433": "     */\n",
        "438": "\n",
        "439": "    @Override\n",
        "440": "    public boolean isDirected() {\n",
        "441": "      return graph.isDirected();\n",
        "442": "    }\n",
        "443": "\n",
        "444": "    @Override\n",
        "445": "    public boolean allowsSelfLoops() {\n",
        "446": "      return graph.allowsSelfLoops();\n",
        "447": "    }\n",
        "448": "\n",
        "449": "    @Override\n",
        "450": "    public ElementOrder<N> nodeOrder() {\n",
        "451": "      return graph.nodeOrder();\n",
        "452": "    }\n",
        "453": "\n",
        "454": "    @Override\n",
        "455": "    public Set<N> adjacentNodes(Object node) {\n",
        "456": "      return graph.adjacentNodes(node);\n",
        "457": "    }\n",
        "458": "\n",
        "459": "    @Override\n",
        "460": "    public Set<N> predecessors(Object node) {\n",
        "461": "      return graph.successors(node); // transpose\n",
        "462": "    }\n",
        "463": "\n",
        "464": "    @Override\n",
        "465": "    public Set<N> successors(Object node) {\n",
        "466": "      return graph.predecessors(node); // transpose\n",
        "467": "    }\n",
        "468": "\n",
        "469": "    @Override\n",
        "470": "    public V edgeValue(Object nodeU, Object nodeV) {\n",
        "471": "      return graph.edgeValue(nodeV, nodeU); // transpose\n",
        "472": "    }\n",
        "473": "\n",
        "474": "    @Override\n",
        "475": "    public V edgeValueOrDefault(Object nodeU, Object nodeV, V defaultValue) {\n",
        "476": "      return graph.edgeValueOrDefault(nodeV, nodeU, defaultValue); // transpose\n",
        "477": "    }\n",
        "569": "    public EndpointPair<N> incidentNodes(Object edge) {\n",
        "570": "      EndpointPair<N> endpointPair = network.incidentNodes(edge);\n",
        "571": "      return EndpointPair.of(network, endpointPair.nodeV(), endpointPair.nodeU()); // transpose\n",
        "580": "    public Set<E> edgesConnecting(Object nodeU, Object nodeV) {\n",
        "581": "      return network.edgesConnecting(nodeV, nodeU); // transpose\n",
        "594": "  public static <N> MutableGraph<N> inducedSubgraph(Graph<N> graph,\n",
        "596": "    MutableGraph<N> subgraph = GraphBuilder.from(graph).build();\n",
        "617": "  public static <N, V> MutableValueGraph<N, V> inducedSubgraph(ValueGraph<N, V> graph,\n",
        "619": "    MutableValueGraph<N, V> subgraph = ValueGraphBuilder.from(graph).build();\n",
        "660": "  public static <N> MutableGraph<N> copyOf(Graph<N> graph) {\n",
        "661": "    MutableGraph<N> copy = GraphBuilder.from(graph)\n",
        "667": "    for (EndpointPair<N> edge : graph.edges()) {\n",
        "668": "      copy.putEdge(edge.nodeU(), edge.nodeV());\n",
        "676": "  public static <N, V> MutableValueGraph<N, V> copyOf(ValueGraph<N, V> graph) {\n",
        "677": "    MutableValueGraph<N, V> copy = ValueGraphBuilder.from(graph)\n",
        "683": "    for (EndpointPair<N> edge : graph.edges()) {\n",
        "684": "      copy.putEdgeValue(edge.nodeU(), edge.nodeV(), graph.edgeValue(edge.nodeU(), edge.nodeV()));\n",
        "701": "      EndpointPair<N> endpointPair = graph.incidentNodes(edge);\n",
        "702": "      copy.addEdge(endpointPair.nodeU(), endpointPair.nodeV(), edge);\n"
    },
    "removed": {
        "20": "import static com.google.common.base.Preconditions.checkNotNull;\n",
        "28": "import com.google.common.graph.BasicGraph.Presence;\n",
        "59": "  public static boolean hasCycle(Graph<?, ?> graph) {\n",
        "101": "      Graph<?, ?> graph,\n",
        "131": "      Graph<?, ?> graph, Object nextNode, @Nullable Object previousNode) {\n",
        "146": "   * of the transitive closure of {@code graph}. In other words, the returned {@link BasicGraph}\n",
        "147": "   * will not be updated after modifications to {@code graph}.\n",
        "149": "  public static <N> BasicGraph<N> transitiveClosure(Graph<N, ?> graph) {\n",
        "150": "    MutableBasicGraph<N> transitiveClosure =\n",
        "151": "        BasicGraphBuilder.from(graph).allowsSelfLoops(true).build();\n",
        "171": "            N nodeA = reachableNodes.get(a);\n",
        "173": "              N nodeB = reachableNodes.get(b);\n",
        "174": "              transitiveClosure.putEdge(nodeA, nodeB);\n",
        "196": "  public static <N> Set<N> reachableNodes(Graph<N, ?> graph, Object node) {\n",
        "214": "  // Graph mutation methods\n",
        "215": "\n",
        "216": "  // Graph view methods\n",
        "217": "\n",
        "219": "   * Returns a view of {@code graph} as a {@link BasicGraph}. If {@code graph} is already a basic\n",
        "220": "   * graph, it will be {@link Graph#equals(Object) equal} to the returned graph.\n",
        "222": "  public static <N> BasicGraph<N> asBasicGraph(final Graph<N, ?> graph) {\n",
        "223": "    if (graph instanceof BasicGraph) {\n",
        "224": "      @SuppressWarnings(\"unchecked\")\n",
        "225": "      BasicGraph<N> basicGraph = (BasicGraph<N>) graph;\n",
        "226": "      return basicGraph;\n",
        "227": "    }\n",
        "228": "\n",
        "229": "    checkNotNull(graph);\n",
        "230": "    return new AbstractBasicGraph<N>() {\n",
        "231": "      @Override\n",
        "232": "      public Set<N> nodes() {\n",
        "233": "        return graph.nodes();\n",
        "234": "      }\n",
        "236": "      @Override\n",
        "237": "      public Set<Endpoints<N>> edges() {\n",
        "238": "        return graph.edges();\n",
        "239": "      }\n",
        "241": "      @Override\n",
        "242": "      public boolean isDirected() {\n",
        "243": "        return graph.isDirected();\n",
        "244": "      }\n",
        "246": "      @Override\n",
        "247": "      public boolean allowsSelfLoops() {\n",
        "248": "        return graph.allowsSelfLoops();\n",
        "249": "      }\n",
        "251": "      @Override\n",
        "252": "      public ElementOrder<N> nodeOrder() {\n",
        "253": "        return graph.nodeOrder();\n",
        "256": "      @Override\n",
        "257": "      public Set<N> adjacentNodes(Object node) {\n",
        "258": "        return graph.adjacentNodes(node);\n",
        "259": "      }\n",
        "261": "      @Override\n",
        "262": "      public Set<N> predecessors(Object node) {\n",
        "263": "        return graph.predecessors(node);\n",
        "264": "      }\n",
        "266": "      @Override\n",
        "267": "      public Set<N> successors(Object node) {\n",
        "268": "        return graph.successors(node);\n",
        "269": "      }\n",
        "271": "      @Override\n",
        "272": "      public Presence edgeValue(Object nodeA, Object nodeB) {\n",
        "273": "        checkNotNull(graph.edgeValue(nodeA, nodeB));\n",
        "274": "        return Presence.EDGE_EXISTS;\n",
        "277": "      @Override\n",
        "278": "      public Presence edgeValueOrDefault(Object nodeA, Object nodeB, Presence defaultValue) {\n",
        "279": "        Object value = graph.edgeValueOrDefault(nodeA, nodeB, null);\n",
        "280": "        return (value == null) ? defaultValue : Presence.EDGE_EXISTS;\n",
        "281": "      }\n",
        "282": "    };\n",
        "285": "  /**\n",
        "286": "   * Simply returns its argument.\n",
        "287": "   *\n",
        "288": "   * @deprecated no need to use this\n",
        "289": "   */\n",
        "290": "  @Deprecated\n",
        "291": "  public static <N> BasicGraph<N> asBasicGraph(BasicGraph<N> graph) {\n",
        "292": "    return checkNotNull(graph);\n",
        "293": "  }\n",
        "295": "  /**\n",
        "296": "   * Returns a view of {@code graph} with the direction (if any) of every edge reversed. All other\n",
        "297": "   * properties remain intact, and further updates to {@code graph} will be reflected in the view.\n",
        "298": "   */\n",
        "299": "  public static <N> BasicGraph<N> transpose(BasicGraph<N> graph) {\n",
        "300": "    return asBasicGraph(transpose((Graph<N, Presence>) graph));\n",
        "301": "  }\n",
        "307": "  public static <N, V> Graph<N, V> transpose(Graph<N, V> graph) {\n",
        "313": "      return ((TransposedGraph<N, V>) graph).graph;\n",
        "316": "    return new TransposedGraph<N, V>(graph);\n",
        "319": "  private static class TransposedGraph<N, V> extends AbstractGraph<N, V> {\n",
        "320": "    private final Graph<N, V> graph;\n",
        "322": "    TransposedGraph(Graph<N, V> graph) {\n",
        "331": "    // Defer to AbstractGraph's implementation of edges(), which is based of successors().\n",
        "363": "    @Override\n",
        "364": "    public V edgeValue(Object nodeA, Object nodeB) {\n",
        "365": "      return graph.edgeValue(nodeB, nodeA); // transpose\n",
        "369": "    public V edgeValueOrDefault(Object nodeA, Object nodeB, V defaultValue) {\n",
        "370": "      return graph.edgeValueOrDefault(nodeB, nodeA, defaultValue); // transpose\n",
        "468": "    public Endpoints<N> incidentNodes(Object edge) {\n",
        "469": "      Endpoints<N> endpoints = network.incidentNodes(edge);\n",
        "470": "      return Endpoints.of(network, endpoints.nodeB(), endpoints.nodeA()); // transpose\n",
        "479": "    public Set<E> edgesConnecting(Object nodeA, Object nodeB) {\n",
        "480": "      return network.edgesConnecting(nodeB, nodeA); // transpose\n",
        "493": "  public static <N> MutableBasicGraph<N> inducedSubgraph(BasicGraph<N> graph,\n",
        "495": "    MutableBasicGraph<N> subgraph = BasicGraphBuilder.from(graph).build();\n",
        "516": "  public static <N, V> MutableGraph<N, V> inducedSubgraph(Graph<N, V> graph,\n",
        "518": "    MutableGraph<N, V> subgraph = GraphBuilder.from(graph).build();\n",
        "559": "  public static <N> MutableBasicGraph<N> copyOf(BasicGraph<N> graph) {\n",
        "560": "    MutableBasicGraph<N> copy = BasicGraphBuilder.from(graph)\n",
        "566": "    for (Endpoints<N> endpoints : graph.edges()) {\n",
        "567": "      copy.putEdge(endpoints.nodeA(), endpoints.nodeB());\n",
        "575": "  public static <N, V> MutableGraph<N, V> copyOf(Graph<N, V> graph) {\n",
        "576": "    MutableGraph<N, V> copy = GraphBuilder.from(graph)\n",
        "582": "    for (Endpoints<N> edge : graph.edges()) {\n",
        "583": "      copy.putEdgeValue(edge.nodeA(), edge.nodeB(), graph.edgeValue(edge.nodeA(), edge.nodeB()));\n",
        "600": "      Endpoints<N> endpoints = graph.incidentNodes(edge);\n",
        "601": "      copy.addEdge(endpoints.nodeA(), endpoints.nodeB(), edge);\n"
    }
}