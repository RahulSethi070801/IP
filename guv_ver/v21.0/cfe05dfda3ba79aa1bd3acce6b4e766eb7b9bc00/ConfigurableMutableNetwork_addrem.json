{
    "addition": {
        "79": "  public boolean addEdge(N nodeU, N nodeV, E edge) {\n",
        "81": "    checkNotNull(nodeU, \"nodeU\");\n",
        "82": "    checkNotNull(nodeV, \"nodeV\");\n",
        "85": "      EndpointPair<N> existingIncidentNodes = incidentNodes(edge);\n",
        "86": "      EndpointPair<N> newIncidentNodes = EndpointPair.of(this, nodeU, nodeV);\n",
        "87": "      checkArgument(existingIncidentNodes.equals(newIncidentNodes),\n",
        "88": "          REUSING_EDGE, edge, existingIncidentNodes, newIncidentNodes);\n",
        "91": "    NetworkConnections<N, E> connectionsU = nodeConnections.get(nodeU);\n",
        "93": "      checkArgument(!(connectionsU != null && connectionsU.successors().contains(nodeV)),\n",
        "94": "          PARALLEL_EDGES_NOT_ALLOWED, nodeU, nodeV);\n",
        "96": "    boolean isSelfLoop = nodeU.equals(nodeV);\n",
        "98": "      checkArgument(!isSelfLoop, SELF_LOOPS_NOT_ALLOWED, nodeU);\n",
        "101": "    if (connectionsU == null) {\n",
        "102": "      connectionsU = addNodeInternal(nodeU);\n",
        "104": "    connectionsU.addOutEdge(edge, nodeV);\n",
        "105": "    NetworkConnections<N, E> connectionsV = nodeConnections.get(nodeV);\n",
        "106": "    if (connectionsV == null) {\n",
        "107": "      connectionsV = addNodeInternal(nodeV);\n",
        "109": "    connectionsV.addInEdge(edge, nodeU, isSelfLoop);\n",
        "110": "    edgeToReferenceNode.put(edge, nodeU);\n",
        "138": "    N nodeU = edgeToReferenceNode.get(edge);\n",
        "139": "    if (nodeU == null) {\n",
        "143": "    NetworkConnections<N, E> connectionsU = nodeConnections.get(nodeU);\n",
        "144": "    N nodeV = connectionsU.oppositeNode(edge);\n",
        "145": "    NetworkConnections<N, E> connectionsV = nodeConnections.get(nodeV);\n",
        "146": "    connectionsU.removeOutEdge(edge);\n",
        "147": "    connectionsV.removeInEdge(edge, allowsSelfLoops() && nodeU.equals(nodeV));\n"
    },
    "removed": {
        "79": "  public boolean addEdge(N nodeA, N nodeB, E edge) {\n",
        "81": "    checkNotNull(nodeA, \"nodeA\");\n",
        "82": "    checkNotNull(nodeB, \"nodeB\");\n",
        "85": "      Endpoints<N> existingEndpoints = incidentNodes(edge);\n",
        "86": "      Endpoints<N> newEndpoints = Endpoints.of(this, nodeA, nodeB);\n",
        "87": "      checkArgument(existingEndpoints.equals(newEndpoints),\n",
        "88": "          REUSING_EDGE, edge, existingEndpoints, newEndpoints);\n",
        "91": "    NetworkConnections<N, E> connectionsA = nodeConnections.get(nodeA);\n",
        "93": "      checkArgument(!(connectionsA != null && connectionsA.successors().contains(nodeB)),\n",
        "94": "          PARALLEL_EDGES_NOT_ALLOWED, nodeA, nodeB);\n",
        "96": "    boolean isSelfLoop = nodeA.equals(nodeB);\n",
        "98": "      checkArgument(!isSelfLoop, SELF_LOOPS_NOT_ALLOWED, nodeA);\n",
        "101": "    if (connectionsA == null) {\n",
        "102": "      connectionsA = addNodeInternal(nodeA);\n",
        "104": "    connectionsA.addOutEdge(edge, nodeB);\n",
        "105": "    NetworkConnections<N, E> connectionsB = nodeConnections.get(nodeB);\n",
        "106": "    if (connectionsB == null) {\n",
        "107": "      connectionsB = addNodeInternal(nodeB);\n",
        "109": "    connectionsB.addInEdge(edge, nodeA, isSelfLoop);\n",
        "110": "    edgeToReferenceNode.put(edge, nodeA);\n",
        "138": "    N nodeA = edgeToReferenceNode.get(edge);\n",
        "139": "    if (nodeA == null) {\n",
        "143": "    NetworkConnections<N, E> connectionsA = nodeConnections.get(nodeA);\n",
        "144": "    N nodeB = connectionsA.oppositeNode(edge);\n",
        "145": "    NetworkConnections<N, E> connectionsB = nodeConnections.get(nodeB);\n",
        "146": "    connectionsA.removeOutEdge(edge);\n",
        "147": "    connectionsB.removeInEdge(edge, allowsSelfLoops() && nodeA.equals(nodeB));\n"
    }
}