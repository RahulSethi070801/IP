{"id": "cfe05dfda3ba79aa1bd3acce6b4e766eb7b9bc00", "code": [{"0": "guava-tests/test/com/google/common/graph/AbstractDirectedGraphTest.java", "added": {"1": [" * Abstract base class for testing implementations of {@link Graph} interface.\n", " * <p>This class is responsible for testing that a directed implementation of {@link Graph}\n"]}, "removed": {"1": [" * Abstract base class for testing implementations of {@link BasicGraph} interface.\n", " * <p>This class is responsible for testing that a directed implementation of {@link BasicGraph}\n"]}, "added_lines": {"1": [24, 26]}, "removed_lines": {"1": [24, 26]}}, {"1": "guava-tests/test/com/google/common/graph/AbstractDirectedNetworkTest.java", "added": {"1": ["        EndpointPair<Integer> endpointPair = network.incidentNodes(inEdge);\n", "        assertThat(endpointPair.source()).isEqualTo(endpointPair.adjacentNode(node));\n", "        assertThat(endpointPair.target()).isEqualTo(node);\n", "        EndpointPair<Integer> endpointPair = network.incidentNodes(outEdge);\n", "        assertThat(endpointPair.source()).isEqualTo(node);\n", "        assertThat(endpointPair.target()).isEqualTo(endpointPair.adjacentNode(node));\n"]}, "removed": {"1": ["        Endpoints<Integer> endpoints = network.incidentNodes(inEdge);\n", "        assertThat(endpoints.source()).isEqualTo(endpoints.adjacentNode(node));\n", "        assertThat(endpoints.target()).isEqualTo(node);\n", "        Endpoints<Integer> endpoints = network.incidentNodes(outEdge);\n", "        assertThat(endpoints.source()).isEqualTo(node);\n", "        assertThat(endpoints.target()).isEqualTo(endpoints.adjacentNode(node));\n"]}, "added_lines": {"1": [42, 43, 44, 48, 49, 50]}, "removed_lines": {"1": [42, 43, 44, 48, 49, 50]}}, {"2": "guava-tests/test/com/google/common/graph/AbstractGraphTest.java", "added": {"2": [" * Abstract base class for testing implementations of {@link Graph} interface. Graph\n"], "3": [" * <li>Test cases related to the specific implementation of the {@link Graph} interface.\n", "  MutableGraph<Integer> graph;\n"], "4": ["  public abstract MutableGraph<Integer> createGraph();\n"], "5": ["  static <N> void validateGraph(Graph<N> graph) {\n", "    assertThat(Graphs.equivalent(graph, Graphs.copyOf(graph))).isTrue();\n", "    assertThat(Graphs.equivalent(graph, ImmutableGraph.copyOf(graph))).isTrue();\n"], "6": ["    assertThat(graph.edges()).doesNotContain(EndpointPair.of(graph, new Object(), new Object()));\n", "    Set<EndpointPair<N>> allEndpointPairs = new HashSet<EndpointPair<N>>();\n"], "8": ["        allEndpointPairs.add(EndpointPair.of(graph, node, successor));\n", "    assertThat(graph.edges()).isEqualTo(allEndpointPairs);\n"]}, "removed": {"1": ["import com.google.common.testing.EqualsTester;\n"], "2": [" * Abstract base class for testing implementations of {@link BasicGraph} interface. Graph\n"], "3": [" * <li>Test cases related to the specific implementation of the {@link BasicGraph} interface.\n", "  MutableBasicGraph<Integer> graph;\n"], "4": ["  public abstract MutableBasicGraph<Integer> createGraph();\n"], "5": ["  static <N> void validateGraph(Graph<N, ?> graph) {\n", "    if (graph instanceof BasicGraph) {\n", "      @SuppressWarnings(\"unchecked\")\n", "      BasicGraph<N> basicGraph = (BasicGraph<N>) graph;\n", "      new EqualsTester().addEqualityGroup(\n", "          basicGraph,\n", "          Graphs.copyOf(basicGraph),\n", "          ImmutableBasicGraph.copyOf(basicGraph)).testEquals();\n", "    }\n"], "6": ["    Set<Endpoints<N>> allEndpoints = new HashSet<Endpoints<N>>();\n"], "7": ["      for (N otherNode : graph.nodes()) {\n", "        if (graph.successors(node).contains(otherNode)) {\n", "          assertThat(graph.edgeValue(node, otherNode)).isNotNull();\n", "        } else {\n", "          assertThat(graph.edgeValueOrDefault(node, otherNode, null)).isNull();\n", "        }\n", "      }\n", "\n"], "8": ["        allEndpoints.add(Endpoints.of(graph, node, successor));\n", "    assertThat(graph.edges()).isEqualTo(allEndpoints);\n"]}, "added_lines": {"2": [32], "3": [42, 49], "4": [73], "5": [124, 125, 126], "6": [138, 140], "8": [175, 180]}, "removed_lines": {"1": [24], "2": [33], "3": [43, 50], "4": [74], "5": [125, 126, 127, 128, 129, 130, 131, 132, 133], "6": [146], "7": [168, 169, 170, 171, 172, 173, 174, 175], "8": [189, 194]}}, {"3": "guava-tests/test/com/google/common/graph/AbstractNetworkTest.java", "added": {"2": ["    assertThat(Graphs.equivalent(network, Graphs.copyOf(network))).isTrue();\n", "    assertThat(Graphs.equivalent(network, ImmutableNetwork.copyOf(network))).isTrue();\n"], "3": ["    Graph<N> asGraph = network.asGraph();\n"], "4": ["      EndpointPair<N> endpointPair = network.incidentNodes(edge);\n", "      N nodeU = endpointPair.nodeU();\n", "      N nodeV = endpointPair.nodeV();\n", "      assertThat(asGraph.edges()).contains(EndpointPair.of(network, nodeU, nodeV));\n", "      assertThat(network.edgesConnecting(nodeU, nodeV)).contains(edge);\n", "      assertThat(network.successors(nodeU)).contains(nodeV);\n", "      assertThat(network.adjacentNodes(nodeU)).contains(nodeV);\n", "      assertThat(network.outEdges(nodeU)).contains(edge);\n", "      assertThat(network.incidentEdges(nodeU)).contains(edge);\n", "      assertThat(network.predecessors(nodeV)).contains(nodeU);\n", "      assertThat(network.adjacentNodes(nodeV)).contains(nodeU);\n", "      assertThat(network.inEdges(nodeV)).contains(edge);\n", "      assertThat(network.incidentEdges(nodeV)).contains(edge);\n", "          network.incidentNodes(edge).nodeU(), network.incidentNodes(edge).nodeV())) {\n"], "5": ["          assertThat(network.incidentNodes(edge))\n", "              .isEqualTo(EndpointPair.of(network, node, otherNode));\n"], "6": ["        assertTrue(network.incidentNodes(incidentEdge).nodeU().equals(node)\n", "            || network.incidentNodes(incidentEdge).nodeV().equals(node));\n"], "7": ["        assertThat(network.edgesConnecting(node, successor)).isNotEmpty();\n"], "8": ["    EndpointPair<Integer> unused = network.incidentNodes(E12); // ensure cache (if any) is populated\n"]}, "removed": {"1": ["import com.google.common.testing.EqualsTester;\n"], "2": ["    new EqualsTester().addEqualityGroup(\n", "        network,\n", "        Graphs.copyOf(network),\n", "        ImmutableNetwork.copyOf(network)).testEquals();\n"], "3": ["    Graph<N, Set<E>> asGraph = network.asGraph();\n"], "4": ["      Endpoints<N> endpoints = network.incidentNodes(edge);\n", "      N nodeA = endpoints.nodeA();\n", "      N nodeB = endpoints.nodeB();\n", "      assertThat(asGraph.edges()).contains(Endpoints.of(network, nodeA, nodeB));\n", "      assertThat(network.edgesConnecting(nodeA, nodeB)).contains(edge);\n", "      assertThat(network.successors(nodeA)).contains(nodeB);\n", "      assertThat(network.adjacentNodes(nodeA)).contains(nodeB);\n", "      assertThat(network.outEdges(nodeA)).contains(edge);\n", "      assertThat(network.incidentEdges(nodeA)).contains(edge);\n", "      assertThat(network.predecessors(nodeB)).contains(nodeA);\n", "      assertThat(network.adjacentNodes(nodeB)).contains(nodeA);\n", "      assertThat(network.inEdges(nodeB)).contains(edge);\n", "      assertThat(network.incidentEdges(nodeB)).contains(edge);\n", "          network.incidentNodes(edge).nodeA(), network.incidentNodes(edge).nodeB())) {\n"], "5": ["          assertThat(network.incidentNodes(edge)).isEqualTo(Endpoints.of(network, node, otherNode));\n"], "6": ["        assertTrue(network.incidentNodes(incidentEdge).nodeA().equals(node)\n", "            || network.incidentNodes(incidentEdge).nodeB().equals(node));\n"], "7": ["        Set<E> edgesConnecting = network.edgesConnecting(node, successor);\n", "        assertThat(edgesConnecting).isNotEmpty();\n", "        assertThat(edgesConnecting).isEqualTo(asGraph.edgeValue(node, successor));\n"], "8": ["    Endpoints<Integer> unused = network.incidentNodes(E12); // ensure cache (if any) is populated\n"]}, "added_lines": {"2": [151, 152], "3": [164], "4": [180, 181, 182, 183, 184, 185, 186, 187, 188, 189, 190, 191, 192, 195], "5": [244, 245], "6": [253, 254], "7": [283], "8": [643]}, "removed_lines": {"1": [27], "2": [152, 153, 154, 155], "3": [167], "4": [183, 184, 185, 186, 187, 188, 189, 190, 191, 192, 193, 194, 195, 198], "5": [247], "6": [255, 256], "7": [284, 286, 287], "8": [647]}}, {"4": "guava-tests/test/com/google/common/graph/AbstractUndirectedGraphTest.java", "added": {"1": [" * Abstract base class for testing undirected implementations of the {@link Graph} interface.\n", " * <p>This class is responsible for testing that an undirected implementation of {@link Graph}\n"]}, "removed": {"1": [" * Abstract base class for testing undirected implementations of the {@link BasicGraph} interface.\n", " * <p>This class is responsible for testing that an undirected implementation of {@link BasicGraph}\n"]}, "added_lines": {"1": [26, 28]}, "removed_lines": {"1": [26, 28]}}, {"5": "guava-tests/test/com/google/common/graph/ConfigurableDirectedGraphTest.java", "added": {"1": [" * Tests for a directed {@link ConfigurableMutableGraph} allowing self-loops.\n", "  public MutableGraph<Integer> createGraph() {\n", "    return GraphBuilder.directed().allowsSelfLoops(true).build();\n"]}, "removed": {"1": [" * Tests for a directed {@link ConfigurableMutableBasicGraph} allowing self-loops.\n", "  public MutableBasicGraph<Integer> createGraph() {\n", "    return BasicGraphBuilder.directed().allowsSelfLoops(true).build();\n"]}, "added_lines": {"1": [26, 32, 33]}, "removed_lines": {"1": [26, 32, 33]}}, {"6": "guava-tests/test/com/google/common/graph/ConfigurableSimpleDirectedGraphTest.java", "added": {"1": [" * Tests for a directed {@link ConfigurableMutableGraph}, creating a simple directed graph\n", "  public MutableGraph<Integer> createGraph() {\n", "    return GraphBuilder.directed().allowsSelfLoops(false).build();\n"]}, "removed": {"1": [" * Tests for a directed {@link ConfigurableMutableBasicGraph}, creating a simple directed graph\n", "  public MutableBasicGraph<Integer> createGraph() {\n", "    return BasicGraphBuilder.directed().allowsSelfLoops(false).build();\n"]}, "added_lines": {"1": [29, 36, 37]}, "removed_lines": {"1": [29, 36, 37]}}, {"7": "guava-tests/test/com/google/common/graph/ConfigurableSimpleUndirectedGraphTest.java", "added": {"1": [" * Tests for an undirected {@link ConfigurableMutableGraph}, creating a simple undirected\n", "  public MutableGraph<Integer> createGraph() {\n", "    return GraphBuilder.undirected().allowsSelfLoops(false).build();\n"]}, "removed": {"1": [" * Tests for an undirected {@link ConfigurableMutableBasicGraph}, creating a simple undirected\n", "  public MutableBasicGraph<Integer> createGraph() {\n", "    return BasicGraphBuilder.undirected().allowsSelfLoops(false).build();\n"]}, "added_lines": {"1": [29, 36, 37]}, "removed_lines": {"1": [29, 36, 37]}}, {"8": "guava-tests/test/com/google/common/graph/ConfigurableUndirectedGraphTest.java", "added": {"1": [" * Tests for an undirected {@link ConfigurableMutableGraph} allowing self-loops.\n", "  public MutableGraph<Integer> createGraph() {\n", "    return GraphBuilder.undirected().allowsSelfLoops(true).build();\n"]}, "removed": {"1": [" * Tests for an undirected {@link ConfigurableMutableBasicGraph} allowing self-loops.\n", "  public MutableBasicGraph<Integer> createGraph() {\n", "    return BasicGraphBuilder.undirected().allowsSelfLoops(true).build();\n"]}, "added_lines": {"1": [26, 32, 33]}, "removed_lines": {"1": [26, 32, 33]}}, {"9": "guava-tests/test/com/google/common/graph/ConfigurableUndirectedNetworkTest.java", "added": {"1": ["    assertThat(network.incidentNodes(E11).nodeU()).isEqualTo(N1);\n", "    assertThat(network.incidentNodes(E11).nodeV()).isEqualTo(N1);\n"]}, "removed": {"1": ["    assertThat(network.incidentNodes(E11).nodeA()).isEqualTo(N1);\n", "    assertThat(network.incidentNodes(E11).nodeB()).isEqualTo(N1);\n"]}, "added_lines": {"1": [53, 54]}, "removed_lines": {"1": [53, 54]}}, {"10": "guava-tests/test/com/google/common/graph/ElementOrderTest.java", "added": {"1": ["    MutableGraph<Integer> graph = GraphBuilder\n"], "2": ["    MutableGraph<Integer> graph = GraphBuilder\n"], "3": ["    MutableGraph<Integer> graph = GraphBuilder\n"], "4": ["    MutableGraph<Integer> graph = GraphBuilder\n"], "5": ["    MutableGraph<Integer> graph = GraphBuilder\n"], "6": ["    MutableGraph<NonComparableSuperClass> graph = GraphBuilder\n"], "7": ["    MutableGraph<ComparableSubClass> graph = GraphBuilder\n"], "8": ["  private static void addNodes(MutableGraph<Integer> graph) {\n"]}, "removed": {"1": ["    MutableBasicGraph<Integer> graph = BasicGraphBuilder\n"], "2": ["    MutableBasicGraph<Integer> graph = BasicGraphBuilder\n"], "3": ["    MutableBasicGraph<Integer> graph = BasicGraphBuilder\n"], "4": ["    MutableBasicGraph<Integer> graph = BasicGraphBuilder\n"], "5": ["    MutableBasicGraph<Integer> graph = BasicGraphBuilder\n"], "6": ["    MutableBasicGraph<NonComparableSuperClass> graph = BasicGraphBuilder\n"], "7": ["    MutableBasicGraph<ComparableSubClass> graph = BasicGraphBuilder\n"], "8": ["  private static void addNodes(MutableBasicGraph<Integer> graph) {\n"]}, "added_lines": {"1": [39], "2": [49], "3": [63], "4": [75], "5": [88], "6": [200], "7": [220], "8": [238]}, "removed_lines": {"1": [39], "2": [49], "3": [63], "4": [75], "5": [88], "6": [200], "7": [220], "8": [238]}}, {"11": "guava-tests/test/com/google/common/graph/EndpointPairTest.java", "added": {"1": [" * Tests for {@link EndpointPair} and {@link ValueGraph#edges()}.\n", "public final class EndpointPairTest {\n"], "2": ["  // Test for EndpointPair class\n", "  public void testOrderedEndpointPair() {\n", "    EndpointPair<String> ordered = EndpointPair.ordered(\"source\", \"target\");\n", "    assertThat(ordered.isOrdered()).isTrue();\n", "    assertThat(ordered).containsExactly(\"source\", \"target\").inOrder();\n", "    assertThat(ordered.source()).isEqualTo(\"source\");\n", "    assertThat(ordered.target()).isEqualTo(\"target\");\n", "    assertThat(ordered.nodeU()).isEqualTo(\"source\");\n", "    assertThat(ordered.nodeV()).isEqualTo(\"target\");\n", "    assertThat(ordered.adjacentNode(\"source\")).isEqualTo(\"target\");\n", "    assertThat(ordered.adjacentNode(\"target\")).isEqualTo(\"source\");\n", "    assertThat(ordered.toString()).isEqualTo(\"<source -> target>\");\n", "  public void testUnorderedEndpointPair() {\n", "    EndpointPair<String> unordered = EndpointPair.unordered(\"chicken\", \"egg\");\n", "    assertThat(unordered.isOrdered()).isFalse();\n", "    assertThat(unordered).containsExactly(\"chicken\", \"egg\");\n", "    assertThat(ImmutableSet.of(unordered.nodeU(), unordered.nodeV()))\n", "    assertThat(unordered.adjacentNode(unordered.nodeU())).isEqualTo(unordered.nodeV());\n", "    assertThat(unordered.adjacentNode(unordered.nodeV())).isEqualTo(unordered.nodeU());\n", "    assertThat(unordered.toString()).contains(\"chicken\");\n", "    assertThat(unordered.toString()).contains(\"egg\");\n", "    EndpointPair<String> unordered = EndpointPair.unordered(\"node\", \"node\");\n", "    assertThat(unordered.isOrdered()).isFalse();\n", "    assertThat(unordered).containsExactly(\"node\", \"node\");\n", "    assertThat(unordered.nodeU()).isEqualTo(\"node\");\n", "    assertThat(unordered.nodeV()).isEqualTo(\"node\");\n", "    assertThat(unordered.adjacentNode(\"node\")).isEqualTo(\"node\");\n", "    assertThat(unordered.toString()).isEqualTo(\"[node, node]\");\n"], "3": ["      EndpointPair<Integer> endpointPair = graph.incidentNodes(\"1-2\");\n", "        endpointPair.adjacentNode(3);\n"], "4": ["    EndpointPair<String> ordered = EndpointPair.ordered(\"a\", \"b\");\n", "    EndpointPair<String> orderedMirror = EndpointPair.ordered(\"b\", \"a\");\n", "    EndpointPair<String> unordered = EndpointPair.unordered(\"a\", \"b\");\n", "    EndpointPair<String> unorderedMirror = EndpointPair.unordered(\"b\", \"a\");\n", "        .addEqualityGroup(ordered)\n", "        .addEqualityGroup(orderedMirror)\n", "        .addEqualityGroup(unordered, unorderedMirror)\n"], "5": ["  public void endpointPair_directedGraph() {\n", "    MutableGraph<Integer> directedGraph = GraphBuilder.directed().allowsSelfLoops(true).build();\n"], "6": ["        EndpointPair.ordered(N1, N2),\n", "        EndpointPair.ordered(N2, N1),\n", "        EndpointPair.ordered(N1, N3),\n", "        EndpointPair.ordered(N4, N4));\n", "  public void endpointPair_undirectedGraph() {\n", "    MutableGraph<Integer> undirectedGraph = GraphBuilder.undirected().allowsSelfLoops(true).build();\n"], "7": ["        EndpointPair.unordered(N1, N2),\n", "        EndpointPair.unordered(N1, N3),\n", "        EndpointPair.unordered(N4, N4));\n", "  public void endpointPair_directedNetwork() {\n"], "8": ["        EndpointPair.ordered(N1, N2),\n", "        EndpointPair.ordered(N2, N1),\n", "        EndpointPair.ordered(N1, N3),\n", "        EndpointPair.ordered(N4, N4));\n", "  public void endpointPair_undirectedNetwork() {\n"], "9": ["        EndpointPair.unordered(N1, N2),\n", "        EndpointPair.unordered(N1, N3),\n", "        EndpointPair.unordered(N4, N4));\n", "  public void endpointPair_unmodifiableView() {\n", "    MutableGraph<Integer> directedGraph = GraphBuilder.directed().build();\n", "    Set<EndpointPair<Integer>> edges = directedGraph.edges();\n", "    containsExactlySanityCheck(edges, EndpointPair.ordered(N1, N2));\n", "        EndpointPair.ordered(N1, N2),\n", "        EndpointPair.ordered(N2, N1));\n", "      edges.add(EndpointPair.ordered(N1, N2));\n", "  public void endpointPair_containment() {\n", "    MutableGraph<Integer> undirectedGraph = GraphBuilder.undirected().allowsSelfLoops(true).build();\n", "    Set<EndpointPair<Integer>> edges = undirectedGraph.edges();\n", "    assertThat(edges).contains(EndpointPair.unordered(N1, N1));\n", "    assertThat(edges).contains(EndpointPair.unordered(N1, N2));\n", "    assertThat(edges).contains(EndpointPair.unordered(N2, N1)); // equal to unordered(N1, N2)\n", "    assertThat(edges).doesNotContain(EndpointPair.unordered(N2, N2));\n", "    assertThat(edges).doesNotContain(EndpointPair.ordered(N1, N2)); // graph not directed\n", "    assertThat(edges).doesNotContain(EndpointPair.unordered(N3, N4)); // nodes not in graph\n"]}, "removed": {"1": [" * Tests for {@link Endpoints} and {@link Graph#edges()}.\n", "public final class EndpointsTest {\n"], "2": ["  // Test for Endpoints class\n", "  public void testDirectedEndpoints() {\n", "    Endpoints<String> directed = Endpoints.ofDirected(\"source\", \"target\");\n", "    assertThat(directed).containsExactly(\"source\", \"target\").inOrder();\n", "    assertThat(directed.source()).isEqualTo(\"source\");\n", "    assertThat(directed.target()).isEqualTo(\"target\");\n", "    assertThat(directed.nodeA()).isEqualTo(\"source\");\n", "    assertThat(directed.nodeB()).isEqualTo(\"target\");\n", "    assertThat(directed.adjacentNode(\"source\")).isEqualTo(\"target\");\n", "    assertThat(directed.adjacentNode(\"target\")).isEqualTo(\"source\");\n", "    assertThat(directed.toString()).isEqualTo(\"<source -> target>\");\n", "  public void testUndirectedEndpoints() {\n", "    Endpoints<String> undirected = Endpoints.ofUndirected(\"chicken\", \"egg\");\n", "    assertThat(undirected).containsExactly(\"chicken\", \"egg\");\n", "    assertThat(ImmutableSet.of(undirected.nodeA(), undirected.nodeB()))\n", "    assertThat(undirected.adjacentNode(undirected.nodeA())).isEqualTo(undirected.nodeB());\n", "    assertThat(undirected.adjacentNode(undirected.nodeB())).isEqualTo(undirected.nodeA());\n", "    assertThat(undirected.toString()).contains(\"chicken\");\n", "    assertThat(undirected.toString()).contains(\"egg\");\n", "    Endpoints<String> undirected = Endpoints.ofUndirected(\"node\", \"node\");\n", "    assertThat(undirected).containsExactly(\"node\", \"node\");\n", "    assertThat(undirected.nodeA()).isEqualTo(\"node\");\n", "    assertThat(undirected.nodeB()).isEqualTo(\"node\");\n", "    assertThat(undirected.adjacentNode(\"node\")).isEqualTo(\"node\");\n", "    assertThat(undirected.toString()).isEqualTo(\"[node, node]\");\n"], "3": ["      Endpoints<Integer> endpoints = graph.incidentNodes(\"1-2\");\n", "        endpoints.adjacentNode(3);\n"], "4": ["    Endpoints<String> directed = Endpoints.ofDirected(\"a\", \"b\");\n", "    Endpoints<String> directedMirror = Endpoints.ofDirected(\"b\", \"a\");\n", "    Endpoints<String> undirected = Endpoints.ofUndirected(\"a\", \"b\");\n", "    Endpoints<String> undirectedMirror = Endpoints.ofUndirected(\"b\", \"a\");\n", "        .addEqualityGroup(directed)\n", "        .addEqualityGroup(directedMirror)\n", "        .addEqualityGroup(undirected, undirectedMirror)\n"], "5": ["  public void edges_directedGraph() {\n", "    MutableBasicGraph<Integer> directedGraph =\n", "        BasicGraphBuilder.directed().allowsSelfLoops(true).build();\n"], "6": ["        Endpoints.ofDirected(N1, N2),\n", "        Endpoints.ofDirected(N2, N1),\n", "        Endpoints.ofDirected(N1, N3),\n", "        Endpoints.ofDirected(N4, N4));\n", "  public void edges_undirectedGraph() {\n", "    MutableBasicGraph<Integer> undirectedGraph =\n", "        BasicGraphBuilder.undirected().allowsSelfLoops(true).build();\n"], "7": ["        Endpoints.ofUndirected(N1, N2),\n", "        Endpoints.ofUndirected(N1, N3),\n", "        Endpoints.ofUndirected(N4, N4));\n", "  public void edges_directedNetwork() {\n"], "8": ["        Endpoints.ofDirected(N1, N2),\n", "        Endpoints.ofDirected(N2, N1),\n", "        Endpoints.ofDirected(N1, N3),\n", "        Endpoints.ofDirected(N4, N4));\n", "  public void edges_undirectedNetwork() {\n"], "9": ["        Endpoints.ofUndirected(N1, N2),\n", "        Endpoints.ofUndirected(N1, N3),\n", "        Endpoints.ofUndirected(N4, N4));\n", "  public void edges_unmodifiableView() {\n", "    MutableBasicGraph<Integer> directedGraph = BasicGraphBuilder.directed().build();\n", "    Set<Endpoints<Integer>> edges = directedGraph.edges();\n", "    containsExactlySanityCheck(edges, Endpoints.ofDirected(N1, N2));\n", "        Endpoints.ofDirected(N1, N2),\n", "        Endpoints.ofDirected(N2, N1));\n", "      edges.add(Endpoints.ofDirected(N1, N2));\n", "  public void edges_containment() {\n", "    MutableBasicGraph<Integer> undirectedGraph =\n", "        BasicGraphBuilder.undirected().allowsSelfLoops(true).build();\n", "    Set<Endpoints<Integer>> edges = undirectedGraph.edges();\n", "    assertThat(edges).contains(Endpoints.ofUndirected(N1, N1));\n", "    assertThat(edges).contains(Endpoints.ofUndirected(N1, N2));\n", "    assertThat(edges).contains(Endpoints.ofUndirected(N2, N1)); // equal to ofUndirected(N1, N2)\n", "    assertThat(edges).doesNotContain(Endpoints.ofUndirected(N2, N2));\n", "    assertThat(edges).doesNotContain(Endpoints.ofDirected(N1, N2)); // graph not directed\n", "    assertThat(edges).doesNotContain(Endpoints.ofUndirected(N3, N4)); // nodes not in graph\n"]}, "added_lines": {"1": [33, 36], "2": [48, 51, 52, 53, 54, 55, 56, 57, 58, 59, 60, 61, 65, 66, 67, 68, 69, 71, 72, 73, 74, 79, 80, 81, 82, 83, 84, 85], "3": [95, 97], "4": [106, 107, 108, 109, 112, 113, 114], "5": [122, 123], "6": [131, 132, 133, 134, 138, 139], "7": [147, 148, 149, 153], "8": [163, 164, 165, 166, 170], "9": [180, 181, 182, 186, 187, 188, 191, 196, 197, 204, 211, 212, 215, 218, 219, 220, 222, 223, 224]}, "removed_lines": {"1": [33, 36], "2": [48, 51, 52, 53, 54, 55, 56, 57, 58, 59, 60, 64, 65, 66, 67, 69, 70, 71, 72, 77, 78, 79, 80, 81, 82], "3": [92, 94], "4": [103, 104, 105, 106, 109, 110, 111], "5": [119, 120, 121], "6": [129, 130, 131, 132, 136, 137, 138], "7": [146, 147, 148, 152], "8": [162, 163, 164, 165, 169], "9": [179, 180, 181, 185, 186, 187, 190, 195, 196, 203, 210, 211, 212, 215, 218, 219, 220, 222, 223, 224]}}, {"12": "guava-tests/test/com/google/common/graph/GraphEquivalenceTest.java", "added": {"1": ["import static com.google.common.truth.Truth.assertThat;\n", "\n"], "2": ["public final class GraphEquivalenceTest {\n"], "3": ["  private final MutableGraph<Integer> graph;\n"], "4": ["  public GraphEquivalenceTest(GraphType graphType) {\n", "  private static MutableGraph<Integer> createGraph(GraphType graphType) {\n", "        return GraphBuilder.undirected().allowsSelfLoops(true).build();\n", "        return GraphBuilder.directed().allowsSelfLoops(true).build();\n"], "5": ["  public void equivalent_nodeSetsDiffer() {\n", "    MutableGraph<Integer> g2 = createGraph(graphType);\n", "    assertThat(Graphs.equivalent(graph, g2)).isFalse();\n", "  public void equivalent_directedVsUndirected() {\n", "    MutableGraph<Integer> g2 = createGraph(oppositeType(graphType));\n", "    assertThat(Graphs.equivalent(graph, g2)).isFalse();\n", "  public void equivalent_selfLoop_directedVsUndirected() {\n", "    MutableGraph<Integer> g2 = createGraph(oppositeType(graphType));\n", "    assertThat(Graphs.equivalent(graph, g2)).isFalse();\n", "  // In this case the graphs are considered equivalent; the property differences are irrelevant.\n", "  public void equivalent_propertiesDiffer() {\n", "    MutableGraph<Integer> g2 = GraphBuilder.from(graph)\n", "    assertThat(Graphs.equivalent(graph, g2)).isTrue();\n", "  // In this case the graphs are considered equivalent; the edge add orderings are irrelevant.\n", "  public void equivalent_edgeAddOrdersDiffer() {\n", "    GraphBuilder<Integer> builder = GraphBuilder.from(graph);\n", "    MutableGraph<Integer> g1 = builder.build();\n", "    MutableGraph<Integer> g2 = builder.build();\n"], "6": ["    assertThat(Graphs.equivalent(g1, g2)).isTrue();\n", "  public void equivalent_edgeDirectionsDiffer() {\n", "    MutableGraph<Integer> g2 = createGraph(graphType);\n", "        assertThat(Graphs.equivalent(graph, g2)).isTrue();\n", "        assertThat(Graphs.equivalent(graph, g2)).isFalse();\n"]}, "removed": {"1": ["import com.google.common.testing.EqualsTester;\n"], "2": ["public final class GraphEqualsTest {\n"], "3": ["  private final MutableBasicGraph<Integer> graph;\n"], "4": ["  public GraphEqualsTest(GraphType graphType) {\n", "  private static MutableBasicGraph<Integer> createGraph(GraphType graphType) {\n", "        return BasicGraphBuilder.undirected().allowsSelfLoops(true).build();\n", "        return BasicGraphBuilder.directed().allowsSelfLoops(true).build();\n"], "5": ["  public void equals_nodeSetsDiffer() {\n", "    MutableBasicGraph<Integer> g2 = createGraph(graphType);\n", "    new EqualsTester().addEqualityGroup(graph).addEqualityGroup(g2).testEquals();\n", "  public void equals_directedVsUndirected() {\n", "    MutableBasicGraph<Integer> g2 = createGraph(oppositeType(graphType));\n", "    new EqualsTester().addEqualityGroup(graph).addEqualityGroup(g2).testEquals();\n", "  public void equals_selfLoop_directedVsUndirected() {\n", "    MutableBasicGraph<Integer> g2 = createGraph(oppositeType(graphType));\n", "    new EqualsTester().addEqualityGroup(graph).addEqualityGroup(g2).testEquals();\n", "  // (In this case the graphs are considered equal; the property differences are irrelevant.)\n", "  public void equals_propertiesDiffer() {\n", "    MutableBasicGraph<Integer> g2 = BasicGraphBuilder.from(graph)\n", "    new EqualsTester().addEqualityGroup(graph, g2).testEquals();\n", "  // (In this case the graphs are considered equal; the edge add orderings are irrelevant.)\n", "  public void equals_edgeAddOrdersDiffer() {\n", "    BasicGraphBuilder<Integer> builder = BasicGraphBuilder.from(graph);\n", "    MutableBasicGraph<Integer> g1 = builder.build();\n", "    MutableBasicGraph<Integer> g2 = builder.build();\n"], "6": ["    new EqualsTester().addEqualityGroup(g1, g2).testEquals();\n", "  public void equals_edgeDirectionsDiffer() {\n", "    MutableBasicGraph<Integer> g2 = createGraph(graphType);\n", "        new EqualsTester().addEqualityGroup(graph, g2).testEquals();\n", "        new EqualsTester().addEqualityGroup(graph).addEqualityGroup(g2).testEquals();\n"]}, "added_lines": {"1": [19, 20], "2": [31], "3": [42], "4": [50, 55, 58, 60], "5": [78, 81, 84, 89, 92, 95, 100, 103, 106, 110, 112, 115, 120, 124, 126, 127, 128, 129], "6": [139, 143, 146, 151, 154]}, "removed_lines": {"1": [19], "2": [30], "3": [41], "4": [49, 54, 57, 59], "5": [77, 80, 83, 88, 91, 94, 99, 102, 105, 109, 111, 114, 119, 123, 125, 126, 127, 128], "6": [138, 142, 145, 150, 153]}}, {"13": "guava-tests/test/com/google/common/graph/GraphMutationTest.java", "added": {"1": ["  public void directedGraph() {\n", "    testGraphMutation(GraphBuilder.directed());\n", "  public void undirectedGraph() {\n", "    testGraphMutation(GraphBuilder.undirected());\n", "  private static void testGraphMutation(GraphBuilder<? super Integer> graphBuilder) {\n", "      MutableGraph<Integer> graph = graphBuilder.allowsSelfLoops(true).build();\n"], "2": ["      ArrayList<EndpointPair<Integer>> edgeList =\n", "          new ArrayList<EndpointPair<Integer>>(graph.edges());\n"], "3": ["        EndpointPair<Integer> edge = edgeList.get(i);\n", "        assertThat(graph.removeEdge(edge.nodeU(), edge.nodeV())).isTrue();\n"], "4": ["      for (EndpointPair<Integer> edge : edgeList) {\n", "        assertThat(graph.putEdge(edge.nodeU(), edge.nodeV())).isTrue();\n"]}, "removed": {"1": ["  public void directedBasicGraph() {\n", "    testBasicGraphMutation(BasicGraphBuilder.directed());\n", "  public void undirectedBasicGraph() {\n", "    testBasicGraphMutation(BasicGraphBuilder.undirected());\n", "  private static void testBasicGraphMutation(BasicGraphBuilder<? super Integer> graphBuilder) {\n", "      MutableBasicGraph<Integer> graph = graphBuilder.allowsSelfLoops(true).build();\n"], "2": ["      ArrayList<Endpoints<Integer>> edgeList = new ArrayList<Endpoints<Integer>>(graph.edges());\n"], "3": ["        Endpoints<Integer> edge = edgeList.get(i);\n", "        assertThat(graph.removeEdge(edge.nodeA(), edge.nodeB())).isTrue();\n"], "4": ["      for (Endpoints<Integer> edge : edgeList) {\n", "        assertThat(graph.putEdge(edge.nodeA(), edge.nodeB())).isTrue();\n"]}, "added_lines": {"1": [42, 43, 47, 48, 51, 55], "2": [68, 69], "3": [78, 79], "4": [109, 110]}, "removed_lines": {"1": [42, 43, 47, 48, 51, 55], "2": [68], "3": [77, 78], "4": [108, 109]}}, {"14": "guava-tests/test/com/google/common/graph/GraphPropertiesTest.java", "added": {"1": ["  ImmutableList<MutableGraph<Integer>> graphsToTest;\n", "  Graph<Integer> directedGraph;\n", "  Graph<Integer> undirectedGraph;\n"], "2": ["    MutableGraph<Integer> mutableDirectedGraph =\n", "        GraphBuilder.directed().allowsSelfLoops(true).build();\n", "    MutableGraph<Integer> mutableUndirectedGraph =\n", "        GraphBuilder.undirected().allowsSelfLoops(true).build();\n"], "3": ["    for (MutableGraph<Integer> graph : graphsToTest) {\n"], "4": ["    for (MutableGraph<Integer> graph : graphsToTest) {\n"], "5": ["    for (MutableGraph<Integer> graph : graphsToTest) {\n"], "6": ["    for (MutableGraph<Integer> graph : graphsToTest) {\n"], "7": ["    for (MutableGraph<Integer> graph : graphsToTest) {\n"], "8": ["    for (MutableGraph<Integer> graph : graphsToTest) {\n"], "9": ["    for (MutableGraph<Integer> graph : graphsToTest) {\n"], "10": ["    for (MutableGraph<Integer> graph : graphsToTest) {\n"], "11": ["    for (MutableGraph<Integer> graph : graphsToTest) {\n"]}, "removed": {"1": ["  ImmutableList<MutableBasicGraph<Integer>> graphsToTest;\n", "  BasicGraph<Integer> directedGraph;\n", "  BasicGraph<Integer> undirectedGraph;\n"], "2": ["    MutableBasicGraph<Integer> mutableDirectedGraph =\n", "        BasicGraphBuilder.directed().allowsSelfLoops(true).build();\n", "    MutableBasicGraph<Integer> mutableUndirectedGraph =\n", "        BasicGraphBuilder.undirected().allowsSelfLoops(true).build();\n"], "3": ["    for (MutableBasicGraph<Integer> graph : graphsToTest) {\n"], "4": ["    for (MutableBasicGraph<Integer> graph : graphsToTest) {\n"], "5": ["    for (MutableBasicGraph<Integer> graph : graphsToTest) {\n"], "6": ["    for (MutableBasicGraph<Integer> graph : graphsToTest) {\n"], "7": ["    for (MutableBasicGraph<Integer> graph : graphsToTest) {\n"], "8": ["    for (MutableBasicGraph<Integer> graph : graphsToTest) {\n"], "9": ["    for (MutableBasicGraph<Integer> graph : graphsToTest) {\n"], "10": ["    for (MutableBasicGraph<Integer> graph : graphsToTest) {\n"], "11": ["    for (MutableBasicGraph<Integer> graph : graphsToTest) {\n"]}, "added_lines": {"1": [34, 35, 36], "2": [44, 45, 46, 47], "3": [69], "4": [79], "5": [88], "6": [97], "7": [107], "8": [117], "9": [128], "10": [139], "11": [150]}, "removed_lines": {"1": [34, 35, 36], "2": [44, 45, 46, 47], "3": [69], "4": [79], "5": [88], "6": [97], "7": [107], "8": [117], "9": [128], "10": [139], "11": [150]}}, {"15": "guava-tests/test/com/google/common/graph/GraphsTest.java", "added": {"4": ["    MutableGraph<Integer> directedGraph =\n", "        GraphBuilder.directed().allowsSelfLoops(false).build();\n", "    MutableGraph<Integer> expectedClosure =\n", "        GraphBuilder.directed().allowsSelfLoops(true).build();\n"], "5": ["    MutableGraph<Integer> undirectedGraph =\n", "        GraphBuilder.undirected().allowsSelfLoops(false).build();\n", "    MutableGraph<Integer> expectedClosure =\n", "        GraphBuilder.undirected().allowsSelfLoops(true).build();\n"], "6": ["    MutableGraph<Integer> directedGraph =\n", "        GraphBuilder.directed().allowsSelfLoops(false).build();\n", "    MutableGraph<Integer> expectedClosure =\n", "        GraphBuilder.directed().allowsSelfLoops(true).build();\n"], "7": ["    MutableGraph<Integer> undirectedGraph =\n", "        GraphBuilder.undirected().allowsSelfLoops(false).build();\n", "    MutableGraph<Integer> expectedClosure =\n", "        GraphBuilder.undirected().allowsSelfLoops(true).build();\n"], "8": ["    MutableGraph<Integer> directedGraph =\n", "        GraphBuilder.directed().allowsSelfLoops(false).build();\n", "    MutableGraph<Integer> expectedClosure =\n", "        GraphBuilder.directed().allowsSelfLoops(true).build();\n"], "9": ["    MutableGraph<Integer> undirectedGraph =\n", "        GraphBuilder.undirected().allowsSelfLoops(false).build();\n", "    MutableGraph<Integer> expectedClosure =\n", "        GraphBuilder.undirected().allowsSelfLoops(true).build();\n"], "10": ["  public void transpose_undirectedGraph() {\n", "    MutableGraph<Integer> undirectedGraph = GraphBuilder.undirected().build();\n", "    assertThat(transpose(undirectedGraph)).isSameAs(undirectedGraph);\n", "  public void transpose_directedGraph() {\n", "    MutableGraph<Integer> directedGraph =\n", "        GraphBuilder.directed().allowsSelfLoops(true).build();\n", "    MutableGraph<Integer> expectedTranspose =\n", "        GraphBuilder.directed().allowsSelfLoops(true).build();\n", "    Graph<Integer> transpose = Graphs.transpose(directedGraph);\n", "    assertThat(Graphs.equivalent(transpose, expectedTranspose)).isTrue();\n", "    assertThat(transpose(transpose)).isSameAs(directedGraph);\n"], "11": ["  public void transpose_undirectedValueGraph() {\n", "    MutableValueGraph<Integer, String> undirectedGraph = ValueGraphBuilder.undirected().build();\n", "    assertThat(transpose(undirectedGraph)).isSameAs(undirectedGraph);\n", "  public void transpose_directedValueGraph() {\n", "    MutableValueGraph<Integer, String> directedGraph =\n", "        ValueGraphBuilder.directed().allowsSelfLoops(true).build();\n", "    MutableValueGraph<Integer, String> expectedTranspose =\n", "        ValueGraphBuilder.directed().allowsSelfLoops(true).build();\n", "    ValueGraph<Integer, String> transpose = Graphs.transpose(directedGraph);\n", "    assertThat(Graphs.equivalent(transpose, expectedTranspose)).isTrue();\n", "    assertThat(transpose(transpose)).isSameAs(directedGraph);\n"], "12": ["    assertThat(transpose(undirectedGraph)).isSameAs(undirectedGraph);\n"], "13": ["    assertThat(Graphs.equivalent(transpose, expectedTranspose)).isTrue();\n", "    assertThat(transpose(transpose)).isSameAs(directedGraph);\n"], "14": ["  public void inducedSubgraph_graph() {\n", "    MutableGraph<Integer> directedGraph =\n", "        GraphBuilder.directed().allowsSelfLoops(true).build();\n", "    MutableGraph<Integer> expectedSubgraph =\n", "        GraphBuilder.directed().allowsSelfLoops(true).build();\n", "    assertThat(Graphs.equivalent(inducedSubgraph(directedGraph, nodeSubset), expectedSubgraph))\n", "        .isTrue();\n", "  public void inducedSubgraph_valueGraph() {\n", "    MutableValueGraph<Integer, String> directedGraph =\n", "        ValueGraphBuilder.directed().allowsSelfLoops(true).build();\n", "    MutableValueGraph<Integer, String> expectedSubgraph =\n", "        ValueGraphBuilder.directed().allowsSelfLoops(true).build();\n", "    assertThat(Graphs.equivalent(inducedSubgraph(directedGraph, nodeSubset), expectedSubgraph))\n", "        .isTrue();\n"], "15": ["    assertThat(Graphs.equivalent(inducedSubgraph(directedGraph, nodeSubset), expectedSubgraph))\n", "        .isTrue();\n"], "16": ["      copyOf((Graph<?>) null);\n", "  public void copyOf_directedGraph() {\n", "    Graph<Integer> directedGraph = buildDirectedGraph();\n", "    Graph<Integer> copy = copyOf(directedGraph);\n", "    assertThat(Graphs.equivalent(copy, directedGraph)).isTrue();\n", "  public void copyOf_undirectedGraph() {\n", "    Graph<Integer> undirectedGraph = buildUndirectedGraph();\n", "    Graph<Integer> copy = copyOf(undirectedGraph);\n", "    assertThat(Graphs.equivalent(copy, undirectedGraph)).isTrue();\n", "  public void copyOf_directedValueGraph() {\n", "    ValueGraph<Integer, String> directedGraph = buildDirectedValueGraph();\n", "    ValueGraph<Integer, String> copy = copyOf(directedGraph);\n", "    assertThat(Graphs.equivalent(copy, directedGraph)).isTrue();\n", "  public void copyOf_undirectedValueGraph() {\n", "    ValueGraph<Integer, String> undirectedGraph = buildUndirectedValueGraph();\n", "    ValueGraph<Integer, String> copy = copyOf(undirectedGraph);\n", "    assertThat(Graphs.equivalent(copy, undirectedGraph)).isTrue();\n"], "17": ["    assertThat(Graphs.equivalent(copy, directedGraph)).isTrue();\n"], "18": ["    assertThat(Graphs.equivalent(copy, undirectedGraph)).isTrue();\n"], "19": ["  @Test\n", "  public void defaultImplementations_notValueGraph() {\n", "    assertThat(buildDirectedGraph()).isNotInstanceOf(ValueGraph.class);\n", "    assertThat(buildUndirectedGraph()).isNotInstanceOf(ValueGraph.class);\n", "    assertThat(ImmutableGraph.copyOf(buildDirectedGraph())).isNotInstanceOf(ValueGraph.class);\n", "    assertThat(ImmutableGraph.copyOf(buildUndirectedGraph())).isNotInstanceOf(ValueGraph.class);\n", "  }\n", "\n", "  private static <N> void checkTransitiveClosure(Graph<N> originalGraph, Graph<N> expectedClosure) {\n", "    assertThat(Graphs.equivalent(transitiveClosure(originalGraph), expectedClosure)).isTrue();\n", "  private static MutableGraph<Integer> buildDirectedGraph() {\n", "    MutableGraph<Integer> directedGraph =\n", "        GraphBuilder.directed().allowsSelfLoops(true).build();\n"], "20": ["  private static MutableGraph<Integer> buildUndirectedGraph() {\n", "    MutableGraph<Integer> undirectedGraph =\n", "        GraphBuilder.undirected().allowsSelfLoops(true).build();\n"], "21": ["  private static MutableValueGraph<Integer, String> buildDirectedValueGraph() {\n", "    MutableValueGraph<Integer, String> directedGraph =\n", "        ValueGraphBuilder.directed().allowsSelfLoops(true).build();\n"], "22": ["  private static MutableValueGraph<Integer, String> buildUndirectedValueGraph() {\n", "    MutableValueGraph<Integer, String> undirectedGraph =\n", "        ValueGraphBuilder.undirected().allowsSelfLoops(true).build();\n"]}, "removed": {"1": ["import static com.google.common.graph.Graphs.asBasicGraph;\n"], "2": ["import com.google.common.graph.BasicGraph.Presence;\n"], "3": ["  private static final String E23 = \"2-3\";\n"], "4": ["    MutableBasicGraph<Integer> directedGraph =\n", "        BasicGraphBuilder.directed().allowsSelfLoops(false).build();\n", "    MutableBasicGraph<Integer> expectedClosure =\n", "        BasicGraphBuilder.directed().allowsSelfLoops(true).build();\n"], "5": ["    MutableBasicGraph<Integer> undirectedGraph =\n", "        BasicGraphBuilder.undirected().allowsSelfLoops(false).build();\n", "    MutableBasicGraph<Integer> expectedClosure =\n", "        BasicGraphBuilder.undirected().allowsSelfLoops(true).build();\n"], "6": ["    MutableBasicGraph<Integer> directedGraph =\n", "        BasicGraphBuilder.directed().allowsSelfLoops(false).build();\n", "    MutableBasicGraph<Integer> expectedClosure =\n", "        BasicGraphBuilder.directed().allowsSelfLoops(true).build();\n"], "7": ["    MutableBasicGraph<Integer> undirectedGraph =\n", "        BasicGraphBuilder.undirected().allowsSelfLoops(false).build();\n", "    MutableBasicGraph<Integer> expectedClosure =\n", "        BasicGraphBuilder.undirected().allowsSelfLoops(true).build();\n"], "8": ["    MutableBasicGraph<Integer> directedGraph =\n", "        BasicGraphBuilder.directed().allowsSelfLoops(false).build();\n", "    MutableBasicGraph<Integer> expectedClosure =\n", "        BasicGraphBuilder.directed().allowsSelfLoops(true).build();\n"], "9": ["    MutableBasicGraph<Integer> undirectedGraph =\n", "        BasicGraphBuilder.undirected().allowsSelfLoops(false).build();\n", "    MutableBasicGraph<Integer> expectedClosure =\n", "        BasicGraphBuilder.undirected().allowsSelfLoops(true).build();\n"], "10": ["  @SuppressWarnings(\"deprecation\")\n", "  @Test\n", "  public void asBasicGraph_basicGraphOptimized() {\n", "    BasicGraph<Integer> basicGraph = BasicGraphBuilder.undirected().build();\n", "    assertThat(asBasicGraph(basicGraph)).isSameAs(basicGraph);\n", "    assertThat(asBasicGraph((Graph<Integer, Presence>) basicGraph)).isSameAs(basicGraph);\n", "  }\n", "\n", "  @Test\n", "  public void asBasicGraph_graph() {\n", "    MutableGraph<Integer, String> graph = GraphBuilder.directed().build();\n", "    graph.putEdgeValue(N1, N2, E12);\n", "    graph.putEdgeValue(N1, N3, E13);\n", "\n", "    BasicGraph<Integer> basicGraph = asBasicGraph(graph);\n", "    assertThat(basicGraph.edgeValue(N1, N2)).isEqualTo(Presence.EDGE_EXISTS);\n", "    assertThat(basicGraph.edgeValue(N1, N3)).isEqualTo(Presence.EDGE_EXISTS);\n", "    assertThat(basicGraph.edgeValueOrDefault(N2, N3, null)).isEqualTo(null);\n", "    assertThat(basicGraph.edgeValueOrDefault(N2, N3, Presence.EDGE_EXISTS))\n", "        .isEqualTo(Presence.EDGE_EXISTS);\n", "    try {\n", "      basicGraph.edgeValue(N2, N3);\n", "      fail(\"Should have rejected edgeValue() on non-existent edge\");\n", "    } catch (IllegalArgumentException expected) {\n", "    }\n", "    AbstractGraphTest.validateGraph(basicGraph);\n", "\n", "    graph.putEdgeValue(N2, N3, E23);\n", "    // View should be updated.\n", "    assertThat(basicGraph.edgeValue(N2, N3)).isEqualTo(Presence.EDGE_EXISTS);\n", "    AbstractGraphTest.validateGraph(basicGraph);\n", "  }\n", "\n", "  public void transpose_undirectedBasicGraph() {\n", "    MutableBasicGraph<Integer> undirectedGraph = BasicGraphBuilder.undirected().build();\n", "    assertThat(transpose(undirectedGraph)).isEqualTo(undirectedGraph);\n", "  public void transpose_directedBasicGraph() {\n", "    MutableBasicGraph<Integer> directedGraph =\n", "        BasicGraphBuilder.directed().allowsSelfLoops(true).build();\n", "    MutableBasicGraph<Integer> expectedTranspose =\n", "        BasicGraphBuilder.directed().allowsSelfLoops(true).build();\n", "    BasicGraph<Integer> transpose = Graphs.transpose(directedGraph);\n", "    assertThat(transpose).isEqualTo(expectedTranspose);\n", "    assertThat(transpose(transpose)).isEqualTo(directedGraph);\n"], "11": ["  public void transpose_undirectedGraph() {\n", "    MutableGraph<Integer, String> undirectedGraph = GraphBuilder.undirected().build();\n", "    assertThat(transpose(undirectedGraph)).isEqualTo(undirectedGraph);\n", "  public void transpose_directedGraph() {\n", "    MutableGraph<Integer, String> directedGraph =\n", "        GraphBuilder.directed().allowsSelfLoops(true).build();\n", "    MutableGraph<Integer, String> expectedTranspose =\n", "        GraphBuilder.directed().allowsSelfLoops(true).build();\n", "    Graph<Integer, String> transpose = Graphs.transpose(directedGraph);\n", "    assertThat(transpose).isEqualTo(expectedTranspose);\n", "    assertThat(transpose(transpose)).isEqualTo(directedGraph);\n"], "12": ["    assertThat(transpose(undirectedGraph)).isEqualTo(undirectedGraph);\n"], "13": ["    assertThat(transpose).isEqualTo(expectedTranspose);\n", "    assertThat(transpose(transpose)).isEqualTo(directedGraph);\n"], "14": ["  public void inducedSubgraph_basicGraph() {\n", "    MutableBasicGraph<Integer> directedGraph =\n", "        BasicGraphBuilder.directed().allowsSelfLoops(true).build();\n", "    MutableBasicGraph<Integer> expectedSubgraph =\n", "        BasicGraphBuilder.directed().allowsSelfLoops(true).build();\n", "    assertThat(inducedSubgraph(directedGraph, nodeSubset)).isEqualTo(expectedSubgraph);\n", "  public void inducedSubgraph_graph() {\n", "    MutableGraph<Integer, String> directedGraph =\n", "        GraphBuilder.directed().allowsSelfLoops(true).build();\n", "    MutableGraph<Integer, String> expectedSubgraph =\n", "        GraphBuilder.directed().allowsSelfLoops(true).build();\n", "    assertThat(inducedSubgraph(directedGraph, nodeSubset)).isEqualTo(expectedSubgraph);\n"], "15": ["    assertThat(inducedSubgraph(directedGraph, nodeSubset)).isEqualTo(expectedSubgraph);\n"], "16": ["      copyOf((BasicGraph<?>) null);\n", "  public void copyOf_directedBasicGraph() {\n", "    BasicGraph<Integer> directedGraph = buildDirectedBasicGraph();\n", "    BasicGraph<Integer> copy = copyOf(directedGraph);\n", "    assertThat(copy).isEqualTo(directedGraph);\n", "  public void copyOf_undirectedBasicGraph() {\n", "    BasicGraph<Integer> undirectedGraph = buildUndirectedBasicGraph();\n", "    BasicGraph<Integer> copy = copyOf(undirectedGraph);\n", "    assertThat(copy).isEqualTo(undirectedGraph);\n", "  public void copyOf_directedGraph() {\n", "    Graph<Integer, String> directedGraph = buildDirectedGraph();\n", "    Graph<Integer, String> copy = copyOf(directedGraph);\n", "    assertThat(copy).isEqualTo(directedGraph);\n", "  public void copyOf_undirectedGraph() {\n", "    Graph<Integer, String> undirectedGraph = buildUndirectedGraph();\n", "    Graph<Integer, String> copy = copyOf(undirectedGraph);\n", "    assertThat(copy).isEqualTo(undirectedGraph);\n"], "17": ["    assertThat(copy).isEqualTo(directedGraph);\n"], "18": ["    assertThat(copy).isEqualTo(undirectedGraph);\n"], "19": ["  private static <N> void checkTransitiveClosure(\n", "      BasicGraph<N> originalGraph, BasicGraph<N> expectedClosure) {\n", "    assertThat(transitiveClosure(originalGraph)).isEqualTo(expectedClosure);\n", "  private static MutableBasicGraph<Integer> buildDirectedBasicGraph() {\n", "    MutableBasicGraph<Integer> directedGraph =\n", "        BasicGraphBuilder.directed().allowsSelfLoops(true).build();\n"], "20": ["  private static MutableBasicGraph<Integer> buildUndirectedBasicGraph() {\n", "    MutableBasicGraph<Integer> undirectedGraph =\n", "        BasicGraphBuilder.undirected().allowsSelfLoops(true).build();\n"], "21": ["  private static MutableGraph<Integer, String> buildDirectedGraph() {\n", "    MutableGraph<Integer, String> directedGraph =\n", "        GraphBuilder.directed().allowsSelfLoops(true).build();\n"], "22": ["  private static MutableGraph<Integer, String> buildUndirectedGraph() {\n", "    MutableGraph<Integer, String> undirectedGraph =\n", "        GraphBuilder.undirected().allowsSelfLoops(true).build();\n"]}, "added_lines": {"4": [70, 71, 77, 78], "5": [92, 93, 99, 100], "6": [114, 115, 120, 121], "7": [138, 139, 144, 145], "8": [162, 163, 169, 170], "9": [193, 194, 200, 201], "10": [217, 218, 221, 225, 226, 227, 233, 234, 240, 241, 242], "11": [253, 254, 257, 261, 262, 263, 269, 270, 276, 277, 278], "12": [293], "13": [313, 314], "14": [325, 328, 329, 336, 337, 342, 343, 347, 350, 351, 358, 359, 364, 365], "15": [386, 387], "16": [404, 411, 412, 414, 415, 419, 420, 422, 423, 427, 428, 430, 431, 435, 436, 438, 439], "17": [447], "18": [455], "19": [599, 600, 601, 602, 603, 604, 605, 606, 607, 611, 614, 615, 616], "20": [624, 625, 626], "21": [634, 635, 636], "22": [644, 645, 646]}, "removed_lines": {"1": [19], "2": [29], "3": [51], "4": [73, 74, 80, 81], "5": [95, 96, 102, 103], "6": [117, 118, 123, 124], "7": [141, 142, 147, 148], "8": [165, 166, 172, 173], "9": [196, 197, 203, 204], "10": [219, 220, 221, 222, 223, 224, 225, 226, 227, 228, 229, 230, 231, 232, 233, 234, 235, 236, 237, 238, 239, 240, 241, 242, 243, 244, 245, 246, 247, 248, 249, 250, 251, 253, 254, 257, 261, 262, 263, 269, 270, 276, 277, 278], "11": [289, 290, 293, 297, 298, 299, 305, 306, 312, 313, 314], "12": [329], "13": [349, 350], "14": [361, 364, 365, 372, 373, 378, 382, 385, 386, 393, 394, 399], "15": [420], "16": [437, 444, 445, 447, 448, 452, 453, 455, 456, 460, 461, 463, 464, 468, 469, 471, 472], "17": [480], "18": [488], "19": [632, 633, 637, 640, 641, 642], "20": [650, 651, 652], "21": [660, 661, 662], "22": [670, 671, 672]}}, {"16": "guava-tests/test/com/google/common/graph/ImmutableGraphTest.java", "added": {"1": [" * Tests for {@link ImmutableGraph} and {@link ImmutableValueGraph} .\n", "    MutableGraph<String> mutableGraph = GraphBuilder.directed().build();\n", "    Graph<String> immutableGraph = ImmutableGraph.copyOf(mutableGraph);\n", "    assertThat(Graphs.equivalent(immutableGraph, mutableGraph)).isTrue();\n", "    assertThat(Graphs.equivalent(immutableGraph, mutableGraph)).isFalse();\n", "  public void immutableValueGraph() {\n", "    MutableValueGraph<String, Integer> mutableGraph = ValueGraphBuilder.directed().build();\n", "    ValueGraph<String, Integer> immutableGraph = ImmutableValueGraph.copyOf(mutableGraph);\n", "    assertThat(immutableGraph).isNotInstanceOf(MutableValueGraph.class);\n", "    assertThat(Graphs.equivalent(immutableGraph, mutableGraph)).isTrue();\n", "    assertThat(Graphs.equivalent(immutableGraph, mutableGraph)).isFalse();\n", "    Graph<String> graph1 =\n", "        ImmutableGraph.copyOf(GraphBuilder.directed().<String>build());\n", "    Graph<String> graph2 = ImmutableGraph.copyOf(graph1);\n", "  public void copyOfImmutableValueGraph_optimized() {\n", "    ValueGraph<String, Integer> graph1 =\n", "        ImmutableValueGraph.copyOf(ValueGraphBuilder.directed().<String, Integer>build());\n", "    ValueGraph<String, Integer> graph2 = ImmutableValueGraph.copyOf(graph1);\n"]}, "removed": {"1": [" * Tests for {@link ImmutableGraph} and {@link ImmutableBasicGraph}.\n", "    MutableGraph<String, Integer> mutableGraph = GraphBuilder.directed().build();\n", "    Graph<String, Integer> immutableGraph = ImmutableGraph.copyOf(mutableGraph);\n", "    assertThat(immutableGraph).isEqualTo(mutableGraph);\n", "    assertThat(immutableGraph).isNotEqualTo(mutableGraph);\n", "  public void immutableBasicGraph() {\n", "    MutableBasicGraph<String> mutableGraph = BasicGraphBuilder.directed().build();\n", "    BasicGraph<String> immutableGraph = ImmutableBasicGraph.copyOf(mutableGraph);\n", "    assertThat(immutableGraph).isNotInstanceOf(MutableBasicGraph.class);\n", "    assertThat(immutableGraph).isEqualTo(mutableGraph);\n", "    assertThat(immutableGraph).isNotEqualTo(mutableGraph);\n", "    Graph<String, Integer> graph1 =\n", "        ImmutableGraph.copyOf(GraphBuilder.directed().<String, Integer>build());\n", "    Graph<String, Integer> graph2 = ImmutableBasicGraph.copyOf(graph1);\n", "  public void copyOfImmutableBasicGraph_optimized() {\n", "    BasicGraph<String> graph1 =\n", "        ImmutableBasicGraph.copyOf(BasicGraphBuilder.directed().<String>build());\n", "    BasicGraph<String> graph2 = ImmutableBasicGraph.copyOf(graph1);\n"]}, "added_lines": {"1": [26, 33, 35, 38, 41, 45, 46, 48, 51, 52, 55, 60, 61, 62, 68, 69, 70, 71]}, "removed_lines": {"1": [26, 33, 35, 38, 41, 45, 46, 48, 51, 52, 55, 60, 61, 62, 68, 69, 70, 71]}}, {"17": "guava-tests/test/com/google/common/graph/ImmutableNetworkTest.java", "added": {"1": ["    assertThat(immutableNetwork.asGraph()).isInstanceOf(ImmutableGraph.class);\n", "    assertThat(Graphs.equivalent(immutableNetwork, mutableNetwork)).isTrue();\n", "    assertThat(Graphs.equivalent(immutableNetwork, mutableNetwork)).isFalse();\n"]}, "removed": {"1": ["    assertThat(immutableNetwork).isEqualTo(mutableNetwork);\n", "    assertThat(immutableNetwork).isNotEqualTo(mutableNetwork);\n"]}, "added_lines": {"1": [37, 39, 42]}, "removed_lines": {"1": [38, 41]}}, {"18": "guava-tests/test/com/google/common/graph/NetworkEquivalenceTest.java", "added": {"1": ["import static com.google.common.truth.Truth.assertThat;\n", "\n"], "2": ["public final class NetworkEquivalenceTest {\n"], "3": ["  public NetworkEquivalenceTest(GraphType graphType) {\n"], "4": ["  public void equivalent_nodeSetsDiffer() {\n", "    assertThat(Graphs.equivalent(graph, g2)).isFalse();\n", "  public void equivalent_edgeSetsDiffer() {\n", "    assertThat(Graphs.equivalent(graph, g2)).isFalse();\n", "  public void equivalent_directedVsUndirected() {\n", "    assertThat(Graphs.equivalent(graph, g2)).isFalse();\n", "  public void equivalent_selfLoop_directedVsUndirected() {\n", "    assertThat(Graphs.equivalent(graph, g2)).isFalse();\n", "  public void equivalent_connectionsDiffer() {\n", "    // connect E13 to N1 and N2, and E12 to N1 and N3 => not equivalent\n", "    assertThat(Graphs.equivalent(graph, g2)).isFalse();\n", "  // Node/edge sets and node/edge connections are the same, but network properties differ.\n", "  // (In this case the networks are considered equivalent; the property differences are irrelevant.)\n", "  public void equivalent_propertiesDiffer() {\n"], "5": ["    assertThat(Graphs.equivalent(graph, g2)).isTrue();\n", "  // (In this case the networks are considered equivalent; the edge add orderings are irrelevant.)\n", "  public void equivalent_edgeAddOrdersDiffer() {\n"], "6": ["    assertThat(Graphs.equivalent(g1, g2)).isTrue();\n", "  public void equivalent_edgeDirectionsDiffer() {\n"], "7": ["        assertThat(Graphs.equivalent(graph, g2)).isTrue();\n", "        assertThat(Graphs.equivalent(graph, g2)).isFalse();\n"]}, "removed": {"1": ["import com.google.common.testing.EqualsTester;\n"], "2": ["public final class NetworkEqualsTest {\n"], "3": ["  public NetworkEqualsTest(GraphType graphType) {\n"], "4": ["  public void equals_nodeSetsDiffer() {\n", "    new EqualsTester().addEqualityGroup(graph).addEqualityGroup(g2).testEquals();\n", "  public void equals_edgeSetsDiffer() {\n", "    new EqualsTester().addEqualityGroup(graph).addEqualityGroup(g2).testEquals();\n", "  public void equals_directedVsUndirected() {\n", "    new EqualsTester().addEqualityGroup(graph).addEqualityGroup(g2).testEquals();\n", "  public void equals_selfLoop_directedVsUndirected() {\n", "    new EqualsTester().addEqualityGroup(graph).addEqualityGroup(g2).testEquals();\n", "  public void equals_connectionsDiffer() {\n", "    // connect E13 to N1 and N2, and E12 to N1 and N3 => not equal\n", "    new EqualsTester().addEqualityGroup(graph).addEqualityGroup(g2).testEquals();\n", "  // Node/edge sets and node/edge connections are the same, but graph properties differ.\n", "  // (In this case the graphs are considered equal; the property differences are irrelevant.)\n", "  public void equals_propertiesDiffer() {\n"], "5": ["    new EqualsTester().addEqualityGroup(graph, g2).testEquals();\n", "  // (In this case the graphs are considered equal; the edge add orderings are irrelevant.)\n", "  public void equals_edgeAddOrdersDiffer() {\n"], "6": ["    new EqualsTester().addEqualityGroup(g1, g2).testEquals();\n", "  public void equals_edgeDirectionsDiffer() {\n"], "7": ["        new EqualsTester().addEqualityGroup(graph, g2).testEquals();\n", "        new EqualsTester().addEqualityGroup(graph).addEqualityGroup(g2).testEquals();\n"]}, "added_lines": {"1": [19, 20], "2": [31], "3": [55], "4": [83, 89, 94, 100, 105, 111, 116, 122, 127, 132, 136, 139, 140, 142], "5": [151, 155, 157], "6": [170, 174], "7": [182, 185]}, "removed_lines": {"1": [19], "2": [30], "3": [54], "4": [82, 88, 93, 99, 104, 110, 115, 121, 126, 131, 135, 138, 139, 141], "5": [150, 154, 156], "6": [169, 173], "7": [181, 184]}}, {"19": "guava-tests/test/com/google/common/graph/PackageSanityTests.java", "added": {"1": ["      GraphBuilder.directed().expectedNodeCount(10);\n", "      ValueGraphBuilder.directed().allowsSelfLoops(true).expectedNodeCount(16);\n", "  private static final ImmutableGraph<String> IMMUTABLE_GRAPH_A = graphWithNode(\"A\");\n", "  private static final ImmutableGraph<String> IMMUTABLE_GRAPH_B = graphWithNode(\"B\");\n"], "2": ["    setDistinctValues(Graph.class, IMMUTABLE_GRAPH_A, IMMUTABLE_GRAPH_B);\n"], "3": ["  private static <N> ImmutableGraph<N> graphWithNode(N node) {\n", "    MutableGraph<N> graph = GraphBuilder.directed().build();\n", "    return ImmutableGraph.copyOf(graph);\n"]}, "removed": {"1": ["      BasicGraphBuilder.directed().expectedNodeCount(10);\n", "      GraphBuilder.directed().allowsSelfLoops(true).expectedNodeCount(16);\n", "  private static final ImmutableBasicGraph<String> IMMUTABLE_GRAPH_A = graphWithNode(\"A\");\n", "  private static final ImmutableBasicGraph<String> IMMUTABLE_GRAPH_B = graphWithNode(\"B\");\n"], "2": ["    setDistinctValues(BasicGraph.class, IMMUTABLE_GRAPH_A, IMMUTABLE_GRAPH_B);\n"], "3": ["  private static <N> ImmutableBasicGraph<N> graphWithNode(N node) {\n", "    MutableBasicGraph<N> graph = BasicGraphBuilder.directed().build();\n", "    return ImmutableBasicGraph.copyOf(graph);\n"]}, "added_lines": {"1": [33, 35, 37, 38], "2": [50], "3": [65, 66, 68]}, "removed_lines": {"1": [33, 35, 37, 38], "2": [50], "3": [65, 66, 68]}}, {"20": "guava-tests/test/com/google/common/graph/TestUtil.java", "added": {"1": ["    assertThat(collection).doesNotContain(new Object());\n"]}, "removed": {}, "added_lines": {"1": [40]}, "removed_lines": {}}, {"21": "guava-tests/test/com/google/common/graph/ValueGraphTest.java", "added": {"1": [" * Tests for {@link ConfigurableMutableValueGraph} and related functionality.\n", "public final class ValueGraphTest {\n", "  MutableValueGraph<Integer, String> graph;\n", "    assertThat(Graphs.equivalent(graph, Graphs.copyOf(graph))).isTrue();\n", "    assertThat(Graphs.equivalent(graph, ImmutableValueGraph.copyOf(graph))).isTrue();\n", "\n", "    for (Integer node : graph.nodes()) {\n", "      for (Integer otherNode : graph.nodes()) {\n", "        if (graph.successors(node).contains(otherNode)) {\n", "          assertThat(graph.edgeValue(node, otherNode)).isNotNull();\n", "        } else {\n", "          assertThat(graph.edgeValueOrDefault(node, otherNode, null)).isNull();\n", "        }\n", "      }\n"], "2": ["    graph = ValueGraphBuilder.directed().allowsSelfLoops(true).build();\n"], "3": ["    graph = ValueGraphBuilder.undirected().allowsSelfLoops(true).build();\n"], "4": ["    graph = ValueGraphBuilder.directed().build();\n"], "5": ["    graph = ValueGraphBuilder.undirected().build();\n"], "6": ["    graph = ValueGraphBuilder.directed().build();\n"], "7": ["    graph = ValueGraphBuilder.undirected().build();\n"], "8": ["    graph = ValueGraphBuilder.directed().build();\n"], "9": ["    graph = ValueGraphBuilder.undirected().build();\n"], "10": ["    graph = ValueGraphBuilder.directed().build();\n"], "11": ["\n", "  @Test\n", "  public void equivalence_considersEdgeValue() {\n", "    graph = ValueGraphBuilder.undirected().build();\n", "    graph.putEdgeValue(1, 2, \"valueA\");\n", "\n", "    MutableValueGraph<Integer, String> otherGraph = ValueGraphBuilder.undirected().build();\n", "    otherGraph.putEdgeValue(1, 2, \"valueA\");\n", "\n", "    assertThat(Graphs.equivalent(graph, otherGraph)).isTrue();\n", "    assertThat(Graphs.equivalent((Graph<Integer>) graph, otherGraph)).isTrue();\n", "\n", "    otherGraph.putEdgeValue(1, 2, \"valueB\");\n", "\n", "    assertThat(Graphs.equivalent(graph, otherGraph)).isFalse(); // values differ\n", "    assertThat(Graphs.equivalent((Graph<Integer>) graph, otherGraph)).isTrue();\n", "  }\n"]}, "removed": {"1": ["import com.google.common.testing.EqualsTester;\n", " * Tests for {@link ConfigurableMutableGraph} and related functionality.\n", "public final class GraphTest {\n", "  MutableGraph<Integer, String> graph;\n", "    new EqualsTester().addEqualityGroup(\n", "        graph,\n", "        Graphs.copyOf(graph),\n", "        ImmutableGraph.copyOf(graph)).testEquals();\n", "\n", "    for (Endpoints<Integer> edge : graph.edges()) {\n", "      assertThat(graph.edgeValue(edge.nodeA(), edge.nodeB())).isNotNull();\n"], "2": ["    graph = GraphBuilder.directed().allowsSelfLoops(true).build();\n"], "3": ["    graph = GraphBuilder.undirected().allowsSelfLoops(true).build();\n"], "4": ["    graph = GraphBuilder.directed().build();\n"], "5": ["    graph = GraphBuilder.undirected().build();\n"], "6": ["    graph = GraphBuilder.directed().build();\n"], "7": ["    graph = GraphBuilder.undirected().build();\n"], "8": ["    graph = GraphBuilder.directed().build();\n"], "9": ["    graph = GraphBuilder.undirected().build();\n"], "10": ["    graph = GraphBuilder.directed().build();\n"]}, "added_lines": {"1": [28, 32, 33, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47], "2": [55], "3": [75], "4": [95], "5": [105], "6": [115], "7": [130], "8": [144], "9": [158], "10": [171], "11": [188, 189, 190, 191, 192, 193, 194, 195, 196, 197, 198, 199, 200, 201, 202, 203, 204]}, "removed_lines": {"1": [22, 29, 33, 34, 38, 39, 40, 41, 42, 43, 44], "2": [52], "3": [72], "4": [92], "5": [102], "6": [112], "7": [127], "8": [141], "9": [155], "10": [168]}}, {"22": "guava/src/com/google/common/graph/AbstractGraph.java", "added": {"1": [" * this class rather than implement {@link Graph} directly.\n", "public abstract class AbstractGraph<N> implements Graph<N> {\n"], "2": ["  public Set<EndpointPair<N>> edges() {\n", "    return new AbstractSet<EndpointPair<N>>() {\n", "      public Iterator<EndpointPair<N>> iterator() {\n", "        return EndpointPairIterator.of(AbstractGraph.this);\n"], "3": ["        if (!(obj instanceof EndpointPair)) {\n", "        EndpointPair<?> endpointPair = (EndpointPair<?>) obj;\n", "        return isDirected() == endpointPair.isOrdered()\n", "            && nodes().contains(endpointPair.nodeU())\n", "            && successors(endpointPair.nodeU()).contains(endpointPair.nodeV());\n"], "4": ["    return toString(this);\n", "  }\n", "\n", "  static String toString(Graph<?> graph) {\n", "        \"isDirected: %s, allowsSelfLoops: %s\", graph.isDirected(), graph.allowsSelfLoops());\n", "        graph.nodes(),\n", "        graph.edges());\n"]}, "removed": {"1": ["import com.google.common.base.Function;\n", "import com.google.common.collect.Maps;\n", "import java.util.Map;\n", "import javax.annotation.Nullable;\n", " * this class rather than implement {@link Graph} directly, to ensure consistent {@link\n", " * #equals(Object)} and {@link #hashCode()} results across different graph implementations.\n", " * @param <V> Value parameter type\n", "public abstract class AbstractGraph<N, V> implements Graph<N, V> {\n"], "2": ["  public Set<Endpoints<N>> edges() {\n", "    return new AbstractSet<Endpoints<N>>() {\n", "      public Iterator<Endpoints<N>> iterator() {\n", "        return EndpointsIterator.of(AbstractGraph.this);\n"], "3": ["        if (!(obj instanceof Endpoints)) {\n", "        Endpoints<?> endpoints = (Endpoints<?>) obj;\n", "        return isDirected() == endpoints.isDirected()\n", "            && nodes().contains(endpoints.nodeA())\n", "            && successors(endpoints.nodeA()).contains(endpoints.nodeB());\n"], "4": ["  @Override\n", "  public final boolean equals(@Nullable Object obj) {\n", "    if (obj == this) {\n", "      return true;\n", "    }\n", "    if (!(obj instanceof Graph)) {\n", "      return false;\n", "    }\n", "    Graph<?, ?> other = (Graph<?, ?>) obj;\n", "\n", "    if (isDirected() != other.isDirected()\n", "        || !nodes().equals(other.nodes())\n", "        || !edges().equals(other.edges())) {\n", "      return false;\n", "    }\n", "\n", "    for (Endpoints<N> edge : edges()) {\n", "      if (!edgeValue(edge.nodeA(), edge.nodeB()).equals(\n", "          other.edgeValue(edge.nodeA(), edge.nodeB()))) {\n", "        return false;\n", "      }\n", "    }\n", "\n", "    return true;\n", "  }\n", "\n", "  @Override\n", "  public final int hashCode() {\n", "    return edgeValueMap().hashCode();\n", "  }\n", "\n", "        \"isDirected: %s, allowsSelfLoops: %s\", isDirected(), allowsSelfLoops());\n", "        nodes(),\n", "        edgeValueMap());\n", "  }\n", "\n", "  private Map<Endpoints<N>, V> edgeValueMap() {\n", "    Function<Endpoints<N>, V> edgeToValueFn = new Function<Endpoints<N>, V>() {\n", "      @Override\n", "      public V apply(Endpoints<N> edge) {\n", "        return edgeValue(edge.nodeA(), edge.nodeB());\n", "      }\n", "    };\n", "    return Maps.asMap(edges(), edgeToValueFn);\n"]}, "added_lines": {"1": [31, 38], "2": [60, 61, 63, 64], "3": [74, 77, 78, 79, 80], "4": [111, 112, 113, 114, 116, 119, 120]}, "removed_lines": {"1": [23, 24, 29, 31, 35, 36, 40, 44], "2": [66, 67, 69, 70], "3": [80, 83, 84, 85, 86], "4": [112, 113, 114, 115, 116, 117, 118, 119, 120, 121, 122, 123, 124, 125, 126, 127, 128, 129, 130, 131, 132, 133, 134, 135, 136, 137, 138, 139, 140, 141, 142, 149, 152, 153, 154, 155, 156, 157, 158, 159, 160, 161, 162, 163]}}, {"23": "guava/src/com/google/common/graph/AbstractNetwork.java", "added": {"2": [" * this class rather than implement {@link Network} directly.\n"], "3": ["  public Graph<N> asGraph() {\n", "    return new AbstractGraph<N>() {\n", "      public Set<EndpointPair<N>> edges() {\n", "        // Optimized implementation assumes no parallel edges (1:1 edge to EndpointPair mapping).\n", "        return new AbstractSet<EndpointPair<N>>() {\n", "          public Iterator<EndpointPair<N>> iterator() {\n", "                new Function<E, EndpointPair<N>>() {\n", "                  public EndpointPair<N> apply(E edge) {\n"], "4": ["            if (!(obj instanceof EndpointPair)) {\n", "            EndpointPair<?> endpointPair = (EndpointPair<?>) obj;\n", "            return isDirected() == endpointPair.isOrdered()\n", "                && nodes().contains(endpointPair.nodeU())\n", "                && successors(endpointPair.nodeU()).contains(endpointPair.nodeV());\n"], "5": ["      // DO NOT override the AbstractGraph *degree() implementations.\n"], "6": ["    EndpointPair<?> endpointPair = incidentNodes(edge); // Verifies that edge is in this network.\n", "    Set<E> endpointPairIncidentEdges =\n", "        Sets.union(incidentEdges(endpointPair.nodeU()), incidentEdges(endpointPair.nodeV()));\n", "    return Sets.difference(endpointPairIncidentEdges, ImmutableSet.of(edge));\n"], "7": ["        edgeIncidentNodesMap());\n", "  private Map<E, EndpointPair<N>> edgeIncidentNodesMap() {\n", "    Function<E, EndpointPair<N>> edgeToIncidentNodesFn = new Function<E, EndpointPair<N>>() {\n", "      public EndpointPair<N> apply(E edge) {\n", "    return Maps.asMap(edges(), edgeToIncidentNodesFn);\n"]}, "removed": {"1": ["import static com.google.common.base.Preconditions.checkArgument;\n", "import static com.google.common.graph.GraphConstants.EDGE_CONNECTING_NOT_IN_GRAPH;\n"], "2": ["import javax.annotation.Nullable;\n", " * this class rather than implement {@link Network} directly, to ensure consistent {@link\n", " * #equals(Object)} and {@link #hashCode()} results across different network implementations.\n"], "3": ["  public Graph<N, Set<E>> asGraph() {\n", "    return new AbstractGraph<N, Set<E>>() {\n", "      public Set<Endpoints<N>> edges() {\n", "        // Optimized implementation assumes no parallel edges (1:1 edge to Endpoints mapping).\n", "        return new AbstractSet<Endpoints<N>>() {\n", "          public Iterator<Endpoints<N>> iterator() {\n", "                new Function<E, Endpoints<N>>() {\n", "                  public Endpoints<N> apply(E edge) {\n"], "4": ["            if (!(obj instanceof Endpoints)) {\n", "            Endpoints<?> endpoints = (Endpoints<?>) obj;\n", "            return isDirected() == endpoints.isDirected()\n", "                && !edgesConnecting(endpoints.nodeA(), endpoints.nodeB()).isEmpty();\n"], "5": ["      @Override\n", "      public Set<E> edgeValue(Object nodeA, Object nodeB) {\n", "        Set<E> edges = edgesConnecting(nodeA, nodeB);\n", "        checkArgument(!edges.isEmpty(), EDGE_CONNECTING_NOT_IN_GRAPH, nodeA, nodeB);\n", "        return edges;\n", "      }\n", "\n", "      @Override\n", "      public Set<E> edgeValueOrDefault(Object nodeA, Object nodeB, Set<E> defaultValue) {\n", "        Set<E> edges = edgesConnecting(nodeA, nodeB);\n", "        return edges.isEmpty() ? defaultValue : edges;\n", "      }\n"], "6": ["    Endpoints<?> endpoints = incidentNodes(edge); // Verifies that edge is in this network.\n", "    Set<E> endpointsIncidentEdges =\n", "        Sets.union(incidentEdges(endpoints.nodeA()), incidentEdges(endpoints.nodeB()));\n", "    return Sets.difference(endpointsIncidentEdges, ImmutableSet.of(edge));\n", "  }\n", "\n", "  @Override\n", "  public final boolean equals(@Nullable Object obj) {\n", "    if (obj == this) {\n", "      return true;\n", "    }\n", "    if (!(obj instanceof Network)) {\n", "      return false;\n", "    }\n", "    Network<?, ?> other = (Network<?, ?>) obj;\n", "\n", "    if (isDirected() != other.isDirected()\n", "        || !nodes().equals(other.nodes())\n", "        || !edges().equals(other.edges())) {\n", "      return false;\n", "    }\n", "\n", "    for (E edge : edges()) {\n", "      if (!incidentNodes(edge).equals(other.incidentNodes(edge))) {\n", "        return false;\n", "      }\n", "    }\n", "\n", "    return true;\n", "  }\n", "\n", "  @Override\n", "  public final int hashCode() {\n", "    return edgeEndpointsMap().hashCode();\n"], "7": ["        edgeEndpointsMap());\n", "  private Map<E, Endpoints<N>> edgeEndpointsMap() {\n", "    Function<E, Endpoints<N>> edgeToEndpointsFn = new Function<E, Endpoints<N>>() {\n", "      public Endpoints<N> apply(E edge) {\n", "    return Maps.asMap(edges(), edgeToEndpointsFn);\n"]}, "added_lines": {"2": [35], "3": [46, 47, 54, 59, 60, 62, 65, 67], "4": [80, 83, 84, 85, 86], "5": [121], "6": [146, 147, 148, 149], "7": [163, 166, 167, 169, 173]}, "removed_lines": {"1": [19, 20], "2": [34, 38, 39], "3": [50, 51, 58, 63, 64, 66, 69, 71], "4": [84, 87, 88, 89], "5": [124, 125, 126, 127, 128, 129, 130, 131, 132, 133, 134, 135], "6": [160, 161, 162, 163, 164, 165, 166, 167, 168, 169, 170, 171, 172, 173, 174, 175, 176, 177, 178, 179, 180, 181, 182, 183, 184, 185, 186, 187, 188, 189, 190, 191, 192, 193], "7": [207, 210, 211, 213, 217]}}, {"24": "guava/src/com/google/common/graph/AbstractValueGraph.java", "added": {"1": ["import com.google.common.base.Function;\n", "import com.google.common.collect.Maps;\n", "import java.util.Map;\n", " * This class provides a skeletal implementation of {@link ValueGraph}. It is recommended to extend\n", " * this class rather than implement {@link ValueGraph} directly.\n", " * @param <V> Value parameter type\n", "public abstract class AbstractValueGraph<N, V>\n", "    extends AbstractGraph<N> implements ValueGraph<N, V> {\n", "    return toString(this);\n", "  }\n", "\n", "  static String toString(ValueGraph<?, ?> graph) {\n", "        \"isDirected: %s, allowsSelfLoops: %s\", graph.isDirected(), graph.allowsSelfLoops());\n", "        graph.nodes(),\n", "        edgeValueMap(graph));\n", "  }\n", "\n", "  private static <N, V> Map<EndpointPair<N>, V> edgeValueMap(final ValueGraph<N, V> graph) {\n", "    Function<EndpointPair<N>, V> edgeToValueFn = new Function<EndpointPair<N>, V>() {\n", "      @Override\n", "      public V apply(EndpointPair<N> edge) {\n", "        return graph.edgeValue(edge.nodeU(), edge.nodeV());\n", "      }\n", "    };\n", "    return Maps.asMap(graph.edges(), edgeToValueFn);\n"]}, "removed": {"1": ["import com.google.common.graph.BasicGraph.Presence;\n", " * This class provides a skeletal implementation of {@link BasicGraph}. It is recommended to extend\n", " * this class rather than implement {@link BasicGraph} directly, to ensure consistent {@link\n", " * #equals(Object)} and {@link #hashCode()} results across different graph implementations.\n", "public abstract class AbstractBasicGraph<N>\n", "    extends AbstractGraph<N, Presence> implements BasicGraph<N> {\n", "        \"isDirected: %s, allowsSelfLoops: %s\", isDirected(), allowsSelfLoops());\n", "        nodes(),\n", "        edges());\n"]}, "added_lines": {"1": [22, 23, 24, 27, 28, 32, 36, 37, 44, 45, 46, 47, 49, 52, 53, 54, 55, 56, 57, 58, 59, 60, 61, 62, 63]}, "removed_lines": {"1": [22, 25, 26, 27, 34, 35, 43, 46, 47]}}, {"25": "guava/src/com/google/common/graph/BasicGraph.java", "added": {}, "removed": {"1": ["/*\n", " * Copyright (C) 2014 The Guava Authors\n", " *\n", " * Licensed under the Apache License, Version 2.0 (the \"License\");\n", " * you may not use this file except in compliance with the License.\n", " * You may obtain a copy of the License at\n", " *\n", " * http://www.apache.org/licenses/LICENSE-2.0\n", " *\n", " * Unless required by applicable law or agreed to in writing, software\n", " * distributed under the License is distributed on an \"AS IS\" BASIS,\n", " * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n", " * See the License for the specific language governing permissions and\n", " * limitations under the License.\n", " */\n", "\n", "package com.google.common.graph;\n", "\n", "import com.google.common.annotations.Beta;\n", "import java.util.ConcurrentModificationException;\n", "import java.util.Map;\n", "import java.util.Set;\n", "\n", "/**\n", " * An interface for <a href=\"https://en.wikipedia.org/wiki/Graph_(discrete_mathematics)\">graph</a>\n", " * data structures. A graph is composed of a set of nodes (sometimes called vertices) and a set of\n", " * edges connecting pairs of nodes. Graphs are useful for modeling many kinds of relations. If the\n", " * relation to be modeled is symmetric (such as \"distance between cities\"), that can be represented\n", " * with an undirected graph, where an edge that connects node A to node B also connects node B to\n", " * node A. If the relation to be modeled is asymmetric (such as \"employees managed\"), that can be\n", " * represented with a directed graph, where edges are strictly one-way.\n", " *\n", " * <p>There are three main interfaces provided to represent graphs. In order of increasing\n", " * complexity they are: {@link BasicGraph}, {@link Graph}, and {@link Network}. You should generally\n", " * prefer the simplest interface that satisfies your use case.\n", " *\n", " * <p>To choose the right interface, answer these questions:\n", " *\n", " * <ol>\n", " * <li>Do you have data (objects) that you wish to associate with edges?\n", " *     <p>Yes: Go to question 2. No: Use {@link BasicGraph}.\n", " * <li>Are the objects you wish to associate with edges unique within the scope of a graph? That is,\n", " *     no two objects would be {@link Object#equals(Object) equal} to each other. A common example\n", " *     where this would <i>not</i> be the case is with weighted graphs.\n", " *     <p>Yes: Go to question 3. No: Use {@link Graph}.\n", " * <li>Do you need to be able to query the graph for an edge associated with a particular object?\n", " *     For example, do you need to query what nodes an edge associated with a particular object\n", " *     connects, or whether an edge associated with that object exists in the graph?\n", " *     <p>Yes: Use {@link Network}. No: Go to question 4.\n", " * <li>Do you need explicit support for parallel edges? For example, do you need to remove one edge\n", " *     connecting a pair of nodes while leaving other edges connecting those same nodes intact?\n", " *     <p>Yes: Use {@link Network}. No: Use {@link Graph}.\n", " * </ol>\n", " *\n", " * <p>In all three interfaces, nodes have all the same requirements as keys in a {@link Map}.\n", " *\n", " * <p>All mutation methods live on the subinterface {@link MutableBasicGraph}. If you do not need to\n", " * mutate a graph (e.g. if you write a method than runs a read-only algorithm on the graph), you\n", " * should prefer the non-mutating {@link BasicGraph} interface.\n", " *\n", " * <p>The {@link BasicGraph} interface extends {@link Graph}. When storing references, it is\n", " * preferable to store them as {@link BasicGraph}s so you do not have to worry about the value type.\n", " * However, when writing methods that operate on graphs but do not care about edge values, it is\n", " * preferable to accept {@code Graph<N, ?>} to allow the widest variety of valid input.\n", " *\n", " * <p>We provide an efficient implementation of this interface via {@link BasicGraphBuilder}. When\n", " * using the implementation provided, all {@link Set}-returning methods provide live, unmodifiable\n", " * views of the graph. In other words, you cannot add an element to the {@link Set}, but if an\n", " * element is added to the {@link BasicGraph} that would affect the result of that set, it will be\n", " * updated automatically. This also means that you cannot modify a {@link BasicGraph} in a way that\n", " * would affect a {#link Set} while iterating over that set. For example, you cannot remove the\n", " * nodes from a {@link BasicGraph} while iterating over {@link #nodes} (unless you first make a copy\n", " * of the nodes), just as you could not remove the keys from a {@link Map} while iterating over its\n", " * {@link Map#keySet()}. This will either throw a {@link ConcurrentModificationException} or risk\n", " * undefined behavior.\n", " *\n", " * <p>Example of use:\n", " *\n", " * <pre><code>\n", " * MutableBasicGraph<String> managementGraph = BasicGraphBuilder.directed().build();\n", " * managementGraph.putEdge(\"Big Boss\", \"Middle Manager Jack\");\n", " * managementGraph.putEdge(\"Big Boss\", \"Middle Manager Jill\");\n", " * managementGraph.putEdge(\"Middle Manager Jack\", \"Joe\");\n", " * managementGraph.putEdge(\"Middle Manager Jack\", \"Schmoe\");\n", " * managementGraph.putEdge(\"Middle Manager Jill\", \"Jane\");\n", " * managementGraph.putEdge(\"Middle Manager Jill\", \"Doe\");\n", " * for (String employee : managementGraph.nodes()) {\n", " *   Set<String> reports = managementGraph.successors(employee);\n", " *   if (!reports.isEmpty()) {\n", " *     System.out.format(\"%s has the following direct reports: %s%n\", employee, reports);\n", " *   }\n", " * }\n", " * </code></pre>\n", " *\n", " * @author James Sexton\n", " * @author Joshua O'Madadhain\n", " * @param <N> Node parameter type\n", " * @since 20.0\n", " */\n", "@Beta\n", "public interface BasicGraph<N> extends Graph<N, BasicGraph.Presence> {\n", "\n", "  /**\n", "   * A placeholder for the (generally ignored) value type of a {@link BasicGraph}. Users shouldn't\n", "   * have to reference this enum unless they are implementing the {@link BasicGraph} interface.\n", "   */\n", "  public enum Presence {\n", "    EDGE_EXISTS\n", "  }\n", "}\n"]}, "added_lines": {}, "removed_lines": {"1": [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 58, 59, 60, 61, 62, 63, 64, 65, 66, 67, 68, 69, 70, 71, 72, 73, 74, 75, 76, 77, 78, 79, 80, 81, 82, 83, 84, 85, 86, 87, 88, 89, 90, 91, 92, 93, 94, 95, 96, 97, 98, 99, 100, 101, 102, 103, 104, 105, 106, 107, 108, 109, 110]}}, {"26": "guava/src/com/google/common/graph/ConfigurableMutableBasicGraph.java", "added": {}, "removed": {"1": ["/*\n", " * Copyright (C) 2016 The Guava Authors\n", " *\n", " * Licensed under the Apache License, Version 2.0 (the \"License\");\n", " * you may not use this file except in compliance with the License.\n", " * You may obtain a copy of the License at\n", " *\n", " * http://www.apache.org/licenses/LICENSE-2.0\n", " *\n", " * Unless required by applicable law or agreed to in writing, software\n", " * distributed under the License is distributed on an \"AS IS\" BASIS,\n", " * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n", " * See the License for the specific language governing permissions and\n", " * limitations under the License.\n", " */\n", "\n", "package com.google.common.graph;\n", "\n", "import java.util.Set;\n", "\n", "/**\n", " * Configurable implementation of {@link MutableBasicGraph} that supports both directed and\n", " * undirected graphs. Instances of this class should be constructed with {@link BasicGraphBuilder}.\n", " *\n", " * <p>Time complexities for mutation methods are all O(1) except for {@code removeNode(N node)},\n", " * which is in O(d_node) where d_node is the degree of {@code node}.\n", " *\n", " * @author James Sexton\n", " * @param <N> Node parameter type\n", " */\n", "final class ConfigurableMutableBasicGraph<N>\n", "    extends AbstractBasicGraph<N> implements MutableBasicGraph<N> {\n", "  private final MutableGraph<N, Presence> backingGraph;\n", "\n", "  /**\n", "   * Constructs a {@link MutableBasicGraph} with the properties specified in {@code builder}.\n", "   */\n", "  ConfigurableMutableBasicGraph(AbstractGraphBuilder<? super N> builder) {\n", "    this.backingGraph = new ConfigurableMutableGraph<N, Presence>(builder);\n", "  }\n", "\n", "  @Override\n", "  public Set<N> nodes() {\n", "    return backingGraph.nodes();\n", "  }\n", "\n", "  @Override\n", "  public Set<Endpoints<N>> edges() {\n", "    return backingGraph.edges();\n", "  }\n", "\n", "  @Override\n", "  public boolean isDirected() {\n", "    return backingGraph.isDirected();\n", "  }\n", "\n", "  @Override\n", "  public boolean allowsSelfLoops() {\n", "    return backingGraph.allowsSelfLoops();\n", "  }\n", "\n", "  @Override\n", "  public ElementOrder<N> nodeOrder() {\n", "    return backingGraph.nodeOrder();\n", "  }\n", "\n", "  @Override\n", "  public Set<N> adjacentNodes(Object node) {\n", "    return backingGraph.adjacentNodes(node);\n", "  }\n", "\n", "  @Override\n", "  public Set<N> predecessors(Object node) {\n", "    return backingGraph.predecessors(node);\n", "  }\n", "\n", "  @Override\n", "  public Set<N> successors(Object node) {\n", "    return backingGraph.successors(node);\n", "  }\n", "\n", "  @Override\n", "  public Presence edgeValue(Object nodeA, Object nodeB) {\n", "    return backingGraph.edgeValue(nodeA, nodeB);\n", "  }\n", "\n", "  @Override\n", "  public Presence edgeValueOrDefault(Object nodeA, Object nodeB, Presence defaultValue) {\n", "    return backingGraph.edgeValueOrDefault(nodeA, nodeB, defaultValue);\n", "  }\n", "\n", "  @Override\n", "  public boolean addNode(N node) {\n", "    return backingGraph.addNode(node);\n", "  }\n", "\n", "  @Override\n", "  public boolean putEdge(N nodeA, N nodeB) {\n", "    return backingGraph.putEdgeValue(nodeA, nodeB, Presence.EDGE_EXISTS) == null;\n", "  }\n", "\n", "  @Override\n", "  public boolean removeNode(Object node) {\n", "    return backingGraph.removeNode(node);\n", "  }\n", "\n", "  @Override\n", "  public boolean removeEdge(Object nodeA, Object nodeB) {\n", "    return backingGraph.removeEdge(nodeA, nodeB) != null;\n", "  }\n", "}\n"]}, "added_lines": {}, "removed_lines": {"1": [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 58, 59, 60, 61, 62, 63, 64, 65, 66, 67, 68, 69, 70, 71, 72, 73, 74, 75, 76, 77, 78, 79, 80, 81, 82, 83, 84, 85, 86, 87, 88, 89, 90, 91, 92, 93, 94, 95, 96, 97, 98, 99, 100, 101, 102, 103, 104, 105, 106, 107, 108, 109, 110, 111]}}, {"27": "guava/src/com/google/common/graph/ConfigurableMutableGraph.java", "added": {"1": ["import com.google.common.graph.GraphConstants.Presence;\n", " * Configurable implementation of {@link MutableGraph} that supports both directed and\n", " * undirected graphs. Instances of this class should be constructed with {@link GraphBuilder}.\n", "final class ConfigurableMutableGraph<N>\n", "    extends ForwardingGraph<N> implements MutableGraph<N> {\n", "  private final MutableValueGraph<N, Presence> backingGraph;\n", "   * Constructs a {@link MutableGraph} with the properties specified in {@code builder}.\n", "    this.backingGraph = new ConfigurableMutableValueGraph<N, Presence>(builder);\n", "  protected Graph<N> delegate() {\n", "    return backingGraph;\n", "    return backingGraph.addNode(node);\n", "  public boolean putEdge(N nodeU, N nodeV) {\n", "    return backingGraph.putEdgeValue(nodeU, nodeV, Presence.EDGE_EXISTS) == null;\n", "    return backingGraph.removeNode(node);\n", "  public boolean removeEdge(Object nodeU, Object nodeV) {\n", "    return backingGraph.removeEdge(nodeU, nodeV) != null;\n"]}, "removed": {"1": ["import static com.google.common.base.Preconditions.checkArgument;\n", "import static com.google.common.base.Preconditions.checkNotNull;\n", "import static com.google.common.base.Preconditions.checkState;\n", "import static com.google.common.graph.GraphConstants.SELF_LOOPS_NOT_ALLOWED;\n", "import static com.google.common.graph.Graphs.checkNonNegative;\n", "import static com.google.common.graph.Graphs.checkPositive;\n", "\n", "import com.google.errorprone.annotations.CanIgnoreReturnValue;\n", " * Configurable implementation of {@link MutableGraph} that supports both directed and undirected\n", " * graphs. Instances of this class should be constructed with {@link GraphBuilder}.\n", " * @author Joshua O'Madadhain\n", " * @author Omar Darwish\n", " * @param <V> Value parameter type\n", "final class ConfigurableMutableGraph<N, V>\n", "    extends ConfigurableGraph<N, V> implements MutableGraph<N, V> {\n", "  private long edgeCount = 0L; // must be updated when edges are added or removed\n", "   * Constructs a mutable graph with the properties specified in {@code builder}.\n", "    super(builder);\n", "  protected long edgeCount() {\n", "    return edgeCount;\n", "  @CanIgnoreReturnValue\n", "    checkNotNull(node, \"node\");\n", "\n", "    if (containsNode(node)) {\n", "      return false;\n", "    }\n", "\n", "    addNodeInternal(node);\n", "    return true;\n", "  }\n", "\n", "  /**\n", "   * Adds {@code node} to the graph and returns the associated {@link GraphConnections}.\n", "   *\n", "   * @throws IllegalStateException if {@code node} is already present\n", "   */\n", "  @CanIgnoreReturnValue\n", "  private GraphConnections<N, V> addNodeInternal(N node) {\n", "    GraphConnections<N, V> connections = newConnections();\n", "    checkState(nodeConnections.put(node, connections) == null);\n", "    return connections;\n", "  @CanIgnoreReturnValue\n", "  public V putEdgeValue(N nodeA, N nodeB, V value) {\n", "    checkNotNull(nodeA, \"nodeA\");\n", "    checkNotNull(nodeB, \"nodeB\");\n", "    checkNotNull(value, \"value\");\n", "\n", "    GraphConnections<N, V> connectionsA = nodeConnections.get(nodeA);\n", "    boolean isSelfLoop = nodeA.equals(nodeB);\n", "    if (!allowsSelfLoops()) {\n", "      checkArgument(!isSelfLoop, SELF_LOOPS_NOT_ALLOWED, nodeA);\n", "    }\n", "\n", "    if (connectionsA == null) {\n", "      connectionsA = addNodeInternal(nodeA);\n", "    }\n", "    V previousValue = connectionsA.addSuccessor(nodeB, value);\n", "    GraphConnections<N, V> connectionsB = nodeConnections.get(nodeB);\n", "    if (connectionsB == null) {\n", "      connectionsB = addNodeInternal(nodeB);\n", "    }\n", "    connectionsB.addPredecessor(nodeA, value);\n", "    if (previousValue == null) {\n", "      checkPositive(++edgeCount);\n", "    }\n", "    return previousValue;\n", "  @CanIgnoreReturnValue\n", "    checkNotNull(node, \"node\");\n", "\n", "    GraphConnections<N, V> connections = nodeConnections.get(node);\n", "    if (connections == null) {\n", "      return false;\n", "    }\n", "\n", "    if (allowsSelfLoops()) {\n", "      // Remove self-loop (if any) first, so we don't get CME while removing incident edges.\n", "      if (connections.removeSuccessor(node) != null) {\n", "        connections.removePredecessor(node);\n", "        --edgeCount;\n", "      }\n", "    }\n", "\n", "    for (N successor : connections.successors()) {\n", "      nodeConnections.getWithoutCaching(successor).removePredecessor(node);\n", "      --edgeCount;\n", "    }\n", "    if (isDirected()) { // In undirected graphs, the successor and predecessor sets are equal.\n", "      for (N predecessor : connections.predecessors()) {\n", "        checkState(nodeConnections.getWithoutCaching(predecessor).removeSuccessor(node) != null);\n", "        --edgeCount;\n", "      }\n", "    }\n", "    nodeConnections.remove(node);\n", "    checkNonNegative(edgeCount);\n", "    return true;\n", "  @CanIgnoreReturnValue\n", "  public V removeEdge(Object nodeA, Object nodeB) {\n", "    checkNotNull(nodeA, \"nodeA\");\n", "    checkNotNull(nodeB, \"nodeB\");\n", "\n", "    GraphConnections<N, V> connectionsA = nodeConnections.get(nodeA);\n", "    GraphConnections<N, V> connectionsB = nodeConnections.get(nodeB);\n", "    if (connectionsA == null || connectionsB == null) {\n", "      return null;\n", "    }\n", "\n", "    V previousValue = connectionsA.removeSuccessor(nodeB);\n", "    if (previousValue != null) {\n", "      connectionsB.removePredecessor(nodeA);\n", "      checkNonNegative(--edgeCount);\n", "    }\n", "    return previousValue;\n", "  }\n", "\n", "  private GraphConnections<N, V> newConnections() {\n", "    return isDirected()\n", "        ? DirectedGraphConnections.<N, V>of()\n", "        : UndirectedGraphConnections.<N, V>of();\n"]}, "added_lines": {"1": [19, 22, 23, 31, 32, 33, 36, 39, 43, 44, 49, 53, 54, 59, 63, 64]}, "removed_lines": {"1": [19, 20, 21, 22, 23, 24, 25, 26, 29, 30, 36, 37, 39, 41, 42, 43, 46, 49, 53, 54, 58, 60, 61, 62, 63, 64, 65, 66, 67, 68, 69, 70, 71, 72, 73, 74, 75, 76, 77, 78, 79, 83, 84, 85, 86, 87, 88, 89, 90, 91, 92, 93, 94, 95, 96, 97, 98, 99, 100, 101, 102, 103, 104, 105, 106, 107, 111, 113, 114, 115, 116, 117, 118, 119, 120, 121, 122, 123, 124, 125, 126, 127, 128, 129, 130, 131, 132, 133, 134, 135, 136, 137, 138, 139, 140, 144, 145, 146, 147, 148, 149, 150, 151, 152, 153, 154, 155, 156, 157, 158, 159, 160, 161, 162, 163, 164, 165, 166]}}, {"28": "guava/src/com/google/common/graph/ConfigurableMutableNetwork.java", "added": {"1": ["  public boolean addEdge(N nodeU, N nodeV, E edge) {\n", "    checkNotNull(nodeU, \"nodeU\");\n", "    checkNotNull(nodeV, \"nodeV\");\n", "      EndpointPair<N> existingIncidentNodes = incidentNodes(edge);\n", "      EndpointPair<N> newIncidentNodes = EndpointPair.of(this, nodeU, nodeV);\n", "      checkArgument(existingIncidentNodes.equals(newIncidentNodes),\n", "          REUSING_EDGE, edge, existingIncidentNodes, newIncidentNodes);\n", "    NetworkConnections<N, E> connectionsU = nodeConnections.get(nodeU);\n", "      checkArgument(!(connectionsU != null && connectionsU.successors().contains(nodeV)),\n", "          PARALLEL_EDGES_NOT_ALLOWED, nodeU, nodeV);\n", "    boolean isSelfLoop = nodeU.equals(nodeV);\n", "      checkArgument(!isSelfLoop, SELF_LOOPS_NOT_ALLOWED, nodeU);\n", "    if (connectionsU == null) {\n", "      connectionsU = addNodeInternal(nodeU);\n", "    connectionsU.addOutEdge(edge, nodeV);\n", "    NetworkConnections<N, E> connectionsV = nodeConnections.get(nodeV);\n", "    if (connectionsV == null) {\n", "      connectionsV = addNodeInternal(nodeV);\n", "    connectionsV.addInEdge(edge, nodeU, isSelfLoop);\n", "    edgeToReferenceNode.put(edge, nodeU);\n"], "2": ["    N nodeU = edgeToReferenceNode.get(edge);\n", "    if (nodeU == null) {\n", "    NetworkConnections<N, E> connectionsU = nodeConnections.get(nodeU);\n", "    N nodeV = connectionsU.oppositeNode(edge);\n", "    NetworkConnections<N, E> connectionsV = nodeConnections.get(nodeV);\n", "    connectionsU.removeOutEdge(edge);\n", "    connectionsV.removeInEdge(edge, allowsSelfLoops() && nodeU.equals(nodeV));\n"]}, "removed": {"1": ["  public boolean addEdge(N nodeA, N nodeB, E edge) {\n", "    checkNotNull(nodeA, \"nodeA\");\n", "    checkNotNull(nodeB, \"nodeB\");\n", "      Endpoints<N> existingEndpoints = incidentNodes(edge);\n", "      Endpoints<N> newEndpoints = Endpoints.of(this, nodeA, nodeB);\n", "      checkArgument(existingEndpoints.equals(newEndpoints),\n", "          REUSING_EDGE, edge, existingEndpoints, newEndpoints);\n", "    NetworkConnections<N, E> connectionsA = nodeConnections.get(nodeA);\n", "      checkArgument(!(connectionsA != null && connectionsA.successors().contains(nodeB)),\n", "          PARALLEL_EDGES_NOT_ALLOWED, nodeA, nodeB);\n", "    boolean isSelfLoop = nodeA.equals(nodeB);\n", "      checkArgument(!isSelfLoop, SELF_LOOPS_NOT_ALLOWED, nodeA);\n", "    if (connectionsA == null) {\n", "      connectionsA = addNodeInternal(nodeA);\n", "    connectionsA.addOutEdge(edge, nodeB);\n", "    NetworkConnections<N, E> connectionsB = nodeConnections.get(nodeB);\n", "    if (connectionsB == null) {\n", "      connectionsB = addNodeInternal(nodeB);\n", "    connectionsB.addInEdge(edge, nodeA, isSelfLoop);\n", "    edgeToReferenceNode.put(edge, nodeA);\n"], "2": ["    N nodeA = edgeToReferenceNode.get(edge);\n", "    if (nodeA == null) {\n", "    NetworkConnections<N, E> connectionsA = nodeConnections.get(nodeA);\n", "    N nodeB = connectionsA.oppositeNode(edge);\n", "    NetworkConnections<N, E> connectionsB = nodeConnections.get(nodeB);\n", "    connectionsA.removeOutEdge(edge);\n", "    connectionsB.removeInEdge(edge, allowsSelfLoops() && nodeA.equals(nodeB));\n"]}, "added_lines": {"1": [79, 81, 82, 85, 86, 87, 88, 91, 93, 94, 96, 98, 101, 102, 104, 105, 106, 107, 109, 110], "2": [138, 139, 143, 144, 145, 146, 147]}, "removed_lines": {"1": [79, 81, 82, 85, 86, 87, 88, 91, 93, 94, 96, 98, 101, 102, 104, 105, 106, 107, 109, 110], "2": [138, 139, 143, 144, 145, 146, 147]}}, {"29": "guava/src/com/google/common/graph/ConfigurableMutableValueGraph.java", "added": {"1": ["/*\n", " * Copyright (C) 2016 The Guava Authors\n", " *\n", " * Licensed under the Apache License, Version 2.0 (the \"License\");\n", " * you may not use this file except in compliance with the License.\n", " * You may obtain a copy of the License at\n", " *\n", " * http://www.apache.org/licenses/LICENSE-2.0\n", " *\n", " * Unless required by applicable law or agreed to in writing, software\n", " * distributed under the License is distributed on an \"AS IS\" BASIS,\n", " * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n", " * See the License for the specific language governing permissions and\n", " * limitations under the License.\n", " */\n", "\n", "package com.google.common.graph;\n", "\n", "import static com.google.common.base.Preconditions.checkArgument;\n", "import static com.google.common.base.Preconditions.checkNotNull;\n", "import static com.google.common.base.Preconditions.checkState;\n", "import static com.google.common.graph.GraphConstants.SELF_LOOPS_NOT_ALLOWED;\n", "import static com.google.common.graph.Graphs.checkNonNegative;\n", "import static com.google.common.graph.Graphs.checkPositive;\n", "\n", "import com.google.errorprone.annotations.CanIgnoreReturnValue;\n", "\n", "/**\n", " * Configurable implementation of {@link MutableValueGraph} that supports both directed and\n", " * undirected graphs. Instances of this class should be constructed with {@link ValueGraphBuilder}.\n", " *\n", " * <p>Time complexities for mutation methods are all O(1) except for {@code removeNode(N node)},\n", " * which is in O(d_node) where d_node is the degree of {@code node}.\n", " *\n", " * @author James Sexton\n", " * @author Joshua O'Madadhain\n", " * @author Omar Darwish\n", " * @param <N> Node parameter type\n", " * @param <V> Value parameter type\n", " */\n", "final class ConfigurableMutableValueGraph<N, V>\n", "    extends ConfigurableValueGraph<N, V> implements MutableValueGraph<N, V> {\n", "\n", "  /**\n", "   * Constructs a mutable graph with the properties specified in {@code builder}.\n", "   */\n", "  ConfigurableMutableValueGraph(AbstractGraphBuilder<? super N> builder) {\n", "    super(builder);\n", "  }\n", "\n", "  @Override\n", "  @CanIgnoreReturnValue\n", "  public boolean addNode(N node) {\n", "    checkNotNull(node, \"node\");\n", "\n", "    if (containsNode(node)) {\n", "      return false;\n", "    }\n", "\n", "    addNodeInternal(node);\n", "    return true;\n", "  }\n", "\n", "  /**\n", "   * Adds {@code node} to the graph and returns the associated {@link GraphConnections}.\n", "   *\n", "   * @throws IllegalStateException if {@code node} is already present\n", "   */\n", "  @CanIgnoreReturnValue\n", "  private GraphConnections<N, V> addNodeInternal(N node) {\n", "    GraphConnections<N, V> connections = newConnections();\n", "    checkState(nodeConnections.put(node, connections) == null);\n", "    return connections;\n", "  }\n", "\n", "  @Override\n", "  @CanIgnoreReturnValue\n", "  public V putEdgeValue(N nodeU, N nodeV, V value) {\n", "    checkNotNull(nodeU, \"nodeU\");\n", "    checkNotNull(nodeV, \"nodeV\");\n", "    checkNotNull(value, \"value\");\n", "\n", "    GraphConnections<N, V> connectionsU = nodeConnections.get(nodeU);\n", "    boolean isSelfLoop = nodeU.equals(nodeV);\n", "    if (!allowsSelfLoops()) {\n", "      checkArgument(!isSelfLoop, SELF_LOOPS_NOT_ALLOWED, nodeU);\n", "    }\n", "\n", "    if (connectionsU == null) {\n", "      connectionsU = addNodeInternal(nodeU);\n", "    }\n", "    V previousValue = connectionsU.addSuccessor(nodeV, value);\n", "    GraphConnections<N, V> connectionsV = nodeConnections.get(nodeV);\n", "    if (connectionsV == null) {\n", "      connectionsV = addNodeInternal(nodeV);\n", "    }\n", "    connectionsV.addPredecessor(nodeU, value);\n", "    if (previousValue == null) {\n", "      checkPositive(++edgeCount);\n", "    }\n", "    return previousValue;\n", "  }\n", "\n", "  @Override\n", "  @CanIgnoreReturnValue\n", "  public boolean removeNode(Object node) {\n", "    checkNotNull(node, \"node\");\n", "\n", "    GraphConnections<N, V> connections = nodeConnections.get(node);\n", "    if (connections == null) {\n", "      return false;\n", "    }\n", "\n", "    if (allowsSelfLoops()) {\n", "      // Remove self-loop (if any) first, so we don't get CME while removing incident edges.\n", "      if (connections.removeSuccessor(node) != null) {\n", "        connections.removePredecessor(node);\n", "        --edgeCount;\n", "      }\n", "    }\n", "\n", "    for (N successor : connections.successors()) {\n", "      nodeConnections.getWithoutCaching(successor).removePredecessor(node);\n", "      --edgeCount;\n", "    }\n", "    if (isDirected()) { // In undirected graphs, the successor and predecessor sets are equal.\n", "      for (N predecessor : connections.predecessors()) {\n", "        checkState(nodeConnections.getWithoutCaching(predecessor).removeSuccessor(node) != null);\n", "        --edgeCount;\n", "      }\n", "    }\n", "    nodeConnections.remove(node);\n", "    checkNonNegative(edgeCount);\n", "    return true;\n", "  }\n", "\n", "  @Override\n", "  @CanIgnoreReturnValue\n", "  public V removeEdge(Object nodeU, Object nodeV) {\n", "    checkNotNull(nodeU, \"nodeU\");\n", "    checkNotNull(nodeV, \"nodeV\");\n", "\n", "    GraphConnections<N, V> connectionsU = nodeConnections.get(nodeU);\n", "    GraphConnections<N, V> connectionsV = nodeConnections.get(nodeV);\n", "    if (connectionsU == null || connectionsV == null) {\n", "      return null;\n", "    }\n", "\n", "    V previousValue = connectionsU.removeSuccessor(nodeV);\n", "    if (previousValue != null) {\n", "      connectionsV.removePredecessor(nodeU);\n", "      checkNonNegative(--edgeCount);\n", "    }\n", "    return previousValue;\n", "  }\n", "\n", "  private GraphConnections<N, V> newConnections() {\n", "    return isDirected()\n", "        ? DirectedGraphConnections.<N, V>of()\n", "        : UndirectedGraphConnections.<N, V>of();\n", "  }\n", "}\n"]}, "removed": {}, "added_lines": {"1": [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 58, 59, 60, 61, 62, 63, 64, 65, 66, 67, 68, 69, 70, 71, 72, 73, 74, 75, 76, 77, 78, 79, 80, 81, 82, 83, 84, 85, 86, 87, 88, 89, 90, 91, 92, 93, 94, 95, 96, 97, 98, 99, 100, 101, 102, 103, 104, 105, 106, 107, 108, 109, 110, 111, 112, 113, 114, 115, 116, 117, 118, 119, 120, 121, 122, 123, 124, 125, 126, 127, 128, 129, 130, 131, 132, 133, 134, 135, 136, 137, 138, 139, 140, 141, 142, 143, 144, 145, 146, 147, 148, 149, 150, 151, 152, 153, 154, 155, 156, 157, 158, 159, 160, 161, 162]}, "removed_lines": {}}, {"30": "guava/src/com/google/common/graph/ConfigurableNetwork.java", "added": {"1": ["  // We could make this a Map<E, EndpointPair<N>>. It would make incidentNodes(edge) slightly\n", "  // faster, but also make Networks consume 5 to 20+% (increasing with average degree) more memory.\n"], "2": ["  public EndpointPair<N> incidentNodes(Object edge) {\n", "    N nodeU = checkedReferenceNode(edge);\n", "    N nodeV = nodeConnections.get(nodeU).oppositeNode(edge);\n", "    return EndpointPair.of(this, nodeU, nodeV);\n"], "3": ["  public Set<E> edgesConnecting(Object nodeU, Object nodeV) {\n", "    NetworkConnections<N, E> connectionsU = checkedConnections(nodeU);\n", "    if (!allowsSelfLoops && nodeU.equals(nodeV)) {\n", "    checkArgument(containsNode(nodeV), NODE_NOT_IN_GRAPH, nodeV);\n", "    return connectionsU.edgesConnecting(nodeV);\n"]}, "removed": {"1": ["  // We could make this a Map<E, Endpoints<N>>. It would make incidentNodes(edge) slightly faster,\n", "  // but it would also make Networks consume 5 to 20+% (increasing with average degree) more memory.\n"], "2": ["  public Endpoints<N> incidentNodes(Object edge) {\n", "    N nodeA = checkedReferenceNode(edge);\n", "    N nodeB = nodeConnections.get(nodeA).oppositeNode(edge);\n", "    return Endpoints.of(this, nodeA, nodeB);\n"], "3": ["  public Set<E> edgesConnecting(Object nodeA, Object nodeB) {\n", "    NetworkConnections<N, E> connectionsA = checkedConnections(nodeA);\n", "    if (!allowsSelfLoops && nodeA.equals(nodeB)) {\n", "    checkArgument(containsNode(nodeB), NODE_NOT_IN_GRAPH, nodeB);\n", "    return connectionsA.edgesConnecting(nodeB);\n"]}, "added_lines": {"1": [68, 69], "2": [145, 146, 147, 148], "3": [157, 158, 159, 162, 163]}, "removed_lines": {"1": [68, 69], "2": [145, 146, 147, 148], "3": [157, 158, 159, 162, 163]}}, {"31": "guava/src/com/google/common/graph/ConfigurableValueGraph.java", "added": {"1": ["import static com.google.common.graph.Graphs.checkNonNegative;\n"], "2": [" * Configurable implementation of {@link ValueGraph} that supports the options supplied by\n"], "3": ["class ConfigurableValueGraph<N, V> extends AbstractValueGraph<N, V> {\n", "  protected long edgeCount; // must be updated when edges are added or removed\n", "\n", "  ConfigurableValueGraph(AbstractGraphBuilder<? super N> builder) {\n", "            builder.expectedNodeCount.or(DEFAULT_NODE_COUNT)),\n", "        0L /* edgeCount */);\n", "  ConfigurableValueGraph(AbstractGraphBuilder<? super N> builder,\n", "      Map<N, GraphConnections<N, V>> nodeConnections, long edgeCount) {\n"], "4": ["    this.edgeCount = checkNonNegative(edgeCount);\n"], "5": ["  public V edgeValue(Object nodeU, Object nodeV) {\n", "    V value = edgeValueOrDefault(nodeU, nodeV, null);\n", "    checkArgument(value != null, EDGE_CONNECTING_NOT_IN_GRAPH, nodeU, nodeV);\n", "  public V edgeValueOrDefault(Object nodeU, Object nodeV, @Nullable V defaultValue) {\n", "    V value = checkedConnections(nodeU).value(nodeV);\n", "      checkArgument(containsNode(nodeV), NODE_NOT_IN_GRAPH, nodeV);\n", "  @Override\n", "  protected long edgeCount() {\n", "    return edgeCount;\n", "  }\n", "\n"]}, "removed": {"2": [" * Configurable implementation of {@link Graph} that supports the options supplied by\n"], "3": ["class ConfigurableGraph<N, V> extends AbstractGraph<N, V> {\n", "  ConfigurableGraph(AbstractGraphBuilder<? super N> builder) {\n", "            builder.expectedNodeCount.or(DEFAULT_NODE_COUNT)));\n", "  ConfigurableGraph(AbstractGraphBuilder<? super N> builder,\n", "      Map<N, GraphConnections<N, V>> nodeConnections) {\n"], "5": ["  public V edgeValue(Object nodeA, Object nodeB) {\n", "    V value = edgeValueOrDefault(nodeA, nodeB, null);\n", "    checkArgument(value != null, EDGE_CONNECTING_NOT_IN_GRAPH, nodeA, nodeB);\n", "  public V edgeValueOrDefault(Object nodeA, Object nodeB, @Nullable V defaultValue) {\n", "    V value = checkedConnections(nodeA).value(nodeB);\n", "      checkArgument(containsNode(nodeB), NODE_NOT_IN_GRAPH, nodeB);\n"]}, "added_lines": {"1": [24], "2": [32], "3": [56, 63, 64, 68, 72, 73, 80, 81], "4": [89], "5": [128, 129, 130, 135, 136, 138, 144, 145, 146, 147, 148]}, "removed_lines": {"2": [31], "3": [55, 65, 69, 76, 77], "5": [123, 124, 125, 130, 131, 133]}}, {"32": "guava/src/com/google/common/graph/ElementOrder.java", "added": {"1": [" *   MutableGraph<Integer> graph\n", " *       = GraphBuilder.directed().nodeOrder(ElementOrder.<Integer>natural()).build();\n"]}, "removed": {"1": [" *   MutableBasicGraph<Integer> graph\n", " *       = BasicGraphBuilder.directed().nodeOrder(ElementOrder.<Integer>natural()).build();\n"]}, "added_lines": {"1": [36, 37]}, "removed_lines": {"1": [36, 37]}}, {"33": "guava/src/com/google/common/graph/EndpointPair.java", "added": {"1": ["/*\n", " * Copyright (C) 2016 The Guava Authors\n", " *\n", " * Licensed under the Apache License, Version 2.0 (the \"License\");\n", " * you may not use this file except in compliance with the License.\n", " * You may obtain a copy of the License at\n", " *\n", " * http://www.apache.org/licenses/LICENSE-2.0\n", " *\n", " * Unless required by applicable law or agreed to in writing, software\n", " * distributed under the License is distributed on an \"AS IS\" BASIS,\n", " * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n", " * See the License for the specific language governing permissions and\n", " * limitations under the License.\n", " */\n", "\n", "package com.google.common.graph;\n", "\n", "import static com.google.common.base.Preconditions.checkNotNull;\n", "import static com.google.common.graph.GraphConstants.NOT_AVAILABLE_ON_UNDIRECTED;\n", "\n", "import com.google.common.annotations.Beta;\n", "import com.google.common.base.Objects;\n", "import com.google.common.collect.Iterators;\n", "import com.google.common.collect.UnmodifiableIterator;\n", "\n", "/**\n", " * An immutable pair representing the two (possibly equal, in the case of a self-loop) endpoints of\n", " * an edge in a graph. The {@link EndpointPair} of a directed edge is an ordered pair of nodes\n", " * ({@link #source()} and {@link #source()}). The {@link EndpointPair} of an undirected edge is an\n", " * unordered pair of nodes ({@link #nodeU()} and {@link #nodeV()}).\n", " *\n", " * @author James Sexton\n", " * @since 20.0\n", " */\n", "@Beta\n", "public abstract class EndpointPair<N> implements Iterable<N> {\n", "  private final N nodeU;\n", "  private final N nodeV;\n", "\n", "  private EndpointPair(N nodeU, N nodeV) {\n", "    this.nodeU = checkNotNull(nodeU);\n", "    this.nodeV = checkNotNull(nodeV);\n", "  }\n", "\n", "  // TODO(b/31167164): Decide which of these constructors to make public.\n", "\n", "  /** Returns an {@link EndpointPair} representing the endpoints of an edge in {@code graph}. */\n", "  public static <N> EndpointPair<N> of(Graph<?> graph, N nodeU, N nodeV) {\n", "    return graph.isDirected() ? ordered(nodeU, nodeV) : unordered(nodeU, nodeV);\n", "  }\n", "\n", "  /** Returns an {@link EndpointPair} representing the endpoints of an edge in {@code network}. */\n", "  public static <N> EndpointPair<N> of(Network<?, ?> network, N nodeU, N nodeV) {\n", "    return network.isDirected() ? ordered(nodeU, nodeV) : unordered(nodeU, nodeV);\n", "  }\n", "\n", "  /** Returns an {@link EndpointPair} representing the endpoints of a directed edge. */\n", "  static <N> EndpointPair.Ordered<N> ordered(N source, N target) {\n", "    return new Ordered<N>(source, target);\n", "  }\n", "\n", "  /** Returns an {@link EndpointPair} representing the endpoints of an undirected edge. */\n", "  static <N> EndpointPair.Unordered<N> unordered(N nodeU, N nodeV) {\n", "    return new Unordered<N>(nodeU, nodeV);\n", "  }\n", "\n", "  /**\n", "   * If this {@link EndpointPair} {@link #isOrdered()}, returns the node which is the source.\n", "   *\n", "   * @throws UnsupportedOperationException if this {@link EndpointPair} is not ordered\n", "   */\n", "  public abstract N source();\n", "\n", "  /**\n", "   * If this {@link EndpointPair} {@link #isOrdered()}, returns the node which is the target.\n", "   *\n", "   * @throws UnsupportedOperationException if this {@link EndpointPair} is not ordered\n", "   */\n", "  public abstract N target();\n", "\n", "  /**\n", "   * If this {@link EndpointPair} {@link #isOrdered()} returns the {@link #source()}; otherwise,\n", "   * returns an arbitrary (but consistent) endpoint of the origin edge.\n", "   */\n", "  public final N nodeU() {\n", "    return nodeU;\n", "  }\n", "\n", "  /**\n", "   * Returns the node {@link #adjacentNode(Object) adjacent} to {@link #nodeU()} along the origin\n", "   * edge. If this {@link EndpointPair} {@link #isOrdered()}, this is equal to {@link #target()}.\n", "   */\n", "  public final N nodeV() {\n", "    return nodeV;\n", "  }\n", "\n", "  /**\n", "   * Returns the node that is adjacent to {@code node} along the origin edge.\n", "   *\n", "   * @throws IllegalArgumentException if this {@link EndpointPair} does not contain {@code node}\n", "   */\n", "  public final N adjacentNode(Object node) {\n", "    checkNotNull(node, \"node\");\n", "    if (node.equals(nodeU)) {\n", "      return nodeV;\n", "    } else if (node.equals(nodeV)) {\n", "      return nodeU;\n", "    } else {\n", "      throw new IllegalArgumentException(\n", "          String.format(\"EndpointPair %s does not contain node %s\", this, node));\n", "    }\n", "  }\n", "\n", "  /**\n", "   * Returns {@code true} iff this {@link EndpointPair} is an ordered pair (i.e. represents the\n", "   * endpoints of a directed edge).\n", "   */\n", "  public abstract boolean isOrdered();\n", "\n", "  /** Iterates in the order {@link #nodeU()}, {@link #nodeV()}. */\n", "  @Override\n", "  public final UnmodifiableIterator<N> iterator() {\n", "    return Iterators.forArray(nodeU, nodeV);\n", "  }\n", "\n", "  /**\n", "   * Two ordered {@link EndpointPair}s are equal if their {@link #source()} and {@link #target()}\n", "   * are equal. Two unordered {@link EndpointPair}s are equal if they contain the same nodes. An\n", "   * ordered {@link EndpointPair} is never equal to an unordered {@link EndpointPair}.\n", "   */\n", "  @Override\n", "  public abstract boolean equals(Object obj);\n", "\n", "  /**\n", "   * The hashcode of an ordered {@link EndpointPair} is equal to {@code Objects.hashCode(source(),\n", "   * target())}. The hashcode of an unordered {@link EndpointPair} is equal to {@code\n", "   * nodeU().hashCode() ^ nodeV().hashCode()}.\n", "   */\n", "  @Override\n", "  public abstract int hashCode();\n", "\n", "  private static final class Ordered<N> extends EndpointPair<N> {\n", "    private Ordered(N source, N target) {\n", "      super(source, target);\n", "    }\n", "\n", "    @Override\n", "    public N source() {\n", "      return nodeU();\n", "    }\n", "\n", "    @Override\n", "    public N target() {\n", "      return nodeV();\n", "    }\n", "\n", "    @Override\n", "    public boolean isOrdered() {\n", "      return true;\n", "    }\n", "\n", "    @Override\n", "    public boolean equals(Object obj) {\n", "      if (obj == this) {\n", "        return true;\n", "      }\n", "      if (!(obj instanceof EndpointPair)) {\n", "        return false;\n", "      }\n", "\n", "      EndpointPair<?> other = (EndpointPair<?>) obj;\n", "      if (isOrdered() != other.isOrdered()) {\n", "        return false;\n", "      }\n", "\n", "      return source().equals(other.source()) && target().equals(other.target());\n", "    }\n", "\n", "    @Override\n", "    public int hashCode() {\n", "      return Objects.hashCode(source(), target());\n", "    }\n", "\n", "    @Override\n", "    public String toString() {\n", "      return String.format(\"<%s -> %s>\", source(), target());\n", "    }\n", "  }\n", "\n", "  private static final class Unordered<N> extends EndpointPair<N> {\n", "    private Unordered(N nodeU, N nodeV) {\n", "      super(nodeU, nodeV);\n", "    }\n", "\n", "    @Override\n", "    public N source() {\n", "      throw new UnsupportedOperationException(NOT_AVAILABLE_ON_UNDIRECTED);\n", "    }\n", "\n", "    @Override\n", "    public N target() {\n", "      throw new UnsupportedOperationException(NOT_AVAILABLE_ON_UNDIRECTED);\n", "    }\n", "\n", "    @Override\n", "    public boolean isOrdered() {\n", "      return false;\n", "    }\n", "\n", "    @Override\n", "    public boolean equals(Object obj) {\n", "      if (obj == this) {\n", "        return true;\n", "      }\n", "      if (!(obj instanceof EndpointPair)) {\n", "        return false;\n", "      }\n", "\n", "      EndpointPair<?> other = (EndpointPair<?>) obj;\n", "      if (isOrdered() != other.isOrdered()) {\n", "        return false;\n", "      }\n", "\n", "      // Equivalent to the following simple implementation:\n", "      // boolean condition1 = nodeU().equals(other.nodeU()) && nodeV().equals(other.nodeV());\n", "      // boolean condition2 = nodeU().equals(other.nodeV()) && nodeV().equals(other.nodeU());\n", "      // return condition1 || condition2;\n", "      if (nodeU().equals(other.nodeU())) { // check condition1\n", "        // Here's the tricky bit. We don't have to explicitly check for condition2 in this case.\n", "        // Why? The second half of condition2 requires that nodeV equals other.nodeU.\n", "        // We already know that nodeU equals other.nodeU. Combined with the earlier statement,\n", "        // and the transitive property of equality, this implies that nodeU equals nodeV.\n", "        // If nodeU equals nodeV, condition1 == condition2, so checking condition1 is sufficient.\n", "        return nodeV().equals(other.nodeV());\n", "      }\n", "      return nodeU().equals(other.nodeV()) && nodeV().equals(other.nodeU()); // check condition2\n", "    }\n", "\n", "    @Override\n", "    public int hashCode() {\n", "      return nodeU().hashCode() ^ nodeV().hashCode();\n", "    }\n", "\n", "    @Override\n", "    public String toString() {\n", "      return String.format(\"[%s, %s]\", nodeU(), nodeV());\n", "    }\n", "  }\n", "}\n"]}, "removed": {}, "added_lines": {"1": [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 58, 59, 60, 61, 62, 63, 64, 65, 66, 67, 68, 69, 70, 71, 72, 73, 74, 75, 76, 77, 78, 79, 80, 81, 82, 83, 84, 85, 86, 87, 88, 89, 90, 91, 92, 93, 94, 95, 96, 97, 98, 99, 100, 101, 102, 103, 104, 105, 106, 107, 108, 109, 110, 111, 112, 113, 114, 115, 116, 117, 118, 119, 120, 121, 122, 123, 124, 125, 126, 127, 128, 129, 130, 131, 132, 133, 134, 135, 136, 137, 138, 139, 140, 141, 142, 143, 144, 145, 146, 147, 148, 149, 150, 151, 152, 153, 154, 155, 156, 157, 158, 159, 160, 161, 162, 163, 164, 165, 166, 167, 168, 169, 170, 171, 172, 173, 174, 175, 176, 177, 178, 179, 180, 181, 182, 183, 184, 185, 186, 187, 188, 189, 190, 191, 192, 193, 194, 195, 196, 197, 198, 199, 200, 201, 202, 203, 204, 205, 206, 207, 208, 209, 210, 211, 212, 213, 214, 215, 216, 217, 218, 219, 220, 221, 222, 223, 224, 225, 226, 227, 228, 229, 230, 231, 232, 233, 234, 235, 236, 237, 238, 239, 240, 241, 242, 243, 244, 245, 246, 247, 248, 249, 250]}, "removed_lines": {}}, {"34": "guava/src/com/google/common/graph/EndpointPairIterator.java", "added": {"1": ["abstract class EndpointPairIterator<N> extends AbstractIterator<EndpointPair<N>> {\n", "  private final Graph<N> graph;\n", "  static <N> EndpointPairIterator<N> of(Graph<N> graph) {\n", "  EndpointPairIterator(Graph<N> graph) {\n"], "2": ["  private static final class Directed<N> extends EndpointPairIterator<N> {\n", "    Directed(Graph<N> graph){\n", "    protected EndpointPair<N> computeNext() {\n", "          return EndpointPair.ordered(node, successorIterator.next());\n"], "3": ["   * {@link EndpointPair}, we keep track of the nodes that we have visited. When processing endpoint\n", "   * pairs, we skip if the \"other node\" is in the visited set, as shown below:\n"], "4": ["   * EndpointPair [N1, N2] - return\n", "   * EndpointPair [N1, N3] - return\n", "   * EndpointPair [N2, N1] - skip\n", "   * EndpointPair [N2, N3] - return\n", "   * EndpointPair [N3, N1] - skip\n", "   * EndpointPair [N3, N2] - skip\n", "   * EndpointPair [N4, N4] - return\n", "  private static final class Undirected<N> extends EndpointPairIterator<N> {\n", "    Undirected(Graph<N> graph) {\n", "    protected EndpointPair<N> computeNext() {\n", "            return EndpointPair.unordered(node, otherNode);\n"]}, "removed": {"1": [" * @since 20.0\n", "abstract class EndpointsIterator<N> extends AbstractIterator<Endpoints<N>> {\n", "  private final Graph<N, ?> graph;\n", "  static <N> EndpointsIterator<N> of(Graph<N, ?> graph) {\n", "  EndpointsIterator(Graph<N, ?> graph) {\n"], "2": ["  private static final class Directed<N> extends EndpointsIterator<N> {\n", "    Directed(Graph<N, ?> graph){\n", "    protected Endpoints<N> computeNext() {\n", "          return Endpoints.ofDirected(node, successorIterator.next());\n"], "3": ["   * {@link Endpoints}, we keep track of the nodes that we have visited. When processing node pairs,\n", "   * we skip if the \"other node\" is in the visited set, as shown below:\n"], "4": ["   * Endpoints [N1, N2] - return\n", "   * Endpoints [N1, N3] - return\n", "   * Endpoints [N2, N1] - skip\n", "   * Endpoints [N2, N3] - return\n", "   * Endpoints [N3, N1] - skip\n", "   * Endpoints [N3, N2] - skip\n", "   * Endpoints [N4, N4] - return\n", "  private static final class Undirected<N> extends EndpointsIterator<N> {\n", "    Undirected(Graph<N, ?> graph) {\n", "    protected Endpoints<N> computeNext() {\n", "            return Endpoints.ofUndirected(node, otherNode);\n"]}, "added_lines": {"1": [32, 33, 39, 43], "2": [66, 67, 72, 75], "3": [87, 88], "4": [96, 97, 99, 100, 102, 103, 105, 108, 111, 117, 122]}, "removed_lines": {"1": [31, 33, 34, 40, 44], "2": [67, 68, 73, 76], "3": [88, 89], "4": [97, 98, 100, 101, 103, 104, 106, 109, 112, 118, 123]}}, {"35": "guava/src/com/google/common/graph/Endpoints.java", "added": {}, "removed": {"1": ["/*\n", " * Copyright (C) 2016 The Guava Authors\n", " *\n", " * Licensed under the Apache License, Version 2.0 (the \"License\");\n", " * you may not use this file except in compliance with the License.\n", " * You may obtain a copy of the License at\n", " *\n", " * http://www.apache.org/licenses/LICENSE-2.0\n", " *\n", " * Unless required by applicable law or agreed to in writing, software\n", " * distributed under the License is distributed on an \"AS IS\" BASIS,\n", " * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n", " * See the License for the specific language governing permissions and\n", " * limitations under the License.\n", " */\n", "\n", "package com.google.common.graph;\n", "\n", "import static com.google.common.base.Preconditions.checkNotNull;\n", "import static com.google.common.graph.GraphConstants.NOT_AVAILABLE_ON_UNDIRECTED;\n", "\n", "import com.google.common.annotations.Beta;\n", "import com.google.common.base.Objects;\n", "import com.google.common.collect.Iterators;\n", "import com.google.common.collect.UnmodifiableIterator;\n", "\n", "/**\n", " * An immutable pair representing the two (possibly equal, in the case of a self-loop) endpoints\n", " * of an edge in a graph. The {@link Endpoints} of a directed edge are an ordered pair of nodes\n", " * (source and target). The {@link Endpoints} of an undirected edge are an unordered pair of nodes.\n", " *\n", " * @author James Sexton\n", " * @since 20.0\n", " */\n", "@Beta\n", "public abstract class Endpoints<N> implements Iterable<N> {\n", "  private final N nodeA;\n", "  private final N nodeB;\n", "\n", "  private Endpoints(N nodeA, N nodeB) {\n", "    this.nodeA = checkNotNull(nodeA);\n", "    this.nodeB = checkNotNull(nodeB);\n", "  }\n", "\n", "  /**\n", "   * Returns {@link Endpoints} representing the endpoints of an edge in {@code graph}.\n", "   */\n", "  public static <N> Endpoints<N> of(Graph<?, ?> graph, N nodeA, N nodeB) {\n", "    return graph.isDirected() ? ofDirected(nodeA, nodeB) : ofUndirected(nodeA, nodeB);\n", "  }\n", "\n", "  /**\n", "   * Returns {@link Endpoints} representing the endpoints of an edge in {@code network}.\n", "   */\n", "  public static <N> Endpoints<N> of(Network<?, ?> network, N nodeA, N nodeB) {\n", "    return network.isDirected() ? ofDirected(nodeA, nodeB) : ofUndirected(nodeA, nodeB);\n", "  }\n", "\n", "  /**\n", "   * Returns {@link Endpoints} representing the endpoints of a directed edge.\n", "   */\n", "  static <N> Endpoints.Directed<N> ofDirected(N source, N target) {\n", "    return new Directed<N>(source, target);\n", "  }\n", "\n", "  /**\n", "   * Returns {@link Endpoints} representing the endpoints of an undirected edge.\n", "   */\n", "  static <N> Endpoints.Undirected<N> ofUndirected(N nodeA, N nodeB) {\n", "    return new Undirected<N>(nodeA, nodeB);\n", "  }\n", "\n", "  /**\n", "   * If these are the {@link Endpoints} of a directed edge, returns the node which is the source of\n", "   * that edge.\n", "   *\n", "   * @throws UnsupportedOperationException if these are the {@link Endpoints} of a undirected edge\n", "   */\n", "  public abstract N source();\n", "\n", "  /**\n", "   * If these are the {@link Endpoints} of a directed edge, returns the node which is the target of\n", "   * that edge.\n", "   *\n", "   * @throws UnsupportedOperationException if these are the {@link Endpoints} of a undirected edge\n", "   */\n", "  public abstract N target();\n", "\n", "  /**\n", "   * If these are the {@link Endpoints} of a directed edge, returns the {@link #source()};\n", "   * otherwise, returns an arbitrary (but consistent) endpoint of the origin edge.\n", "   */\n", "  public final N nodeA() {\n", "    return nodeA;\n", "  }\n", "\n", "  /**\n", "   * Returns the node {@link #adjacentNode(Object) adjacent} to {@link #nodeA()} along the origin\n", "   * edge. If these are the {@link Endpoints} of a directed edge, it is equal to {@link #target()}.\n", "   */\n", "  public final N nodeB() {\n", "    return nodeB;\n", "  }\n", "\n", "  /**\n", "   * Returns the node that is adjacent to {@code node} along the origin edge.\n", "   *\n", "   * @throws IllegalArgumentException if this instance does not contain {@code node}, that is, the\n", "   *     origin edge is not incident to {@code}\n", "   */\n", "  public final N adjacentNode(Object node) {\n", "    checkNotNull(node, \"node\");\n", "    if (node.equals(nodeA)) {\n", "      return nodeB;\n", "    } else if (node.equals(nodeB)) {\n", "      return nodeA;\n", "    } else {\n", "      throw new IllegalArgumentException(\n", "          String.format(\"Endpoints %s does not contain node %s\", this, node));\n", "    }\n", "  }\n", "\n", "  abstract boolean isDirected();\n", "\n", "  /**\n", "   * Iterates in the order {@link #nodeA()}, {@link #nodeB()}.\n", "   */\n", "  @Override\n", "  public final UnmodifiableIterator<N> iterator() {\n", "    return Iterators.forArray(nodeA, nodeB);\n", "  }\n", "\n", "  /**\n", "   * The {@link Endpoints} of two directed edges are equal if their {@link #source()} and\n", "   * {@link #target()} are equal. The {@link Endpoints} of two undirected edges are equal if they\n", "   * contain the same nodes. The {@link Endpoints} of a directed edge are never equal to the\n", "   * {@link Endpoints} of an undirected edge.\n", "   */\n", "  @Override\n", "  public abstract boolean equals(Object obj);\n", "\n", "  /**\n", "   * The hashcode of the {@link Endpoints} of a directed edge is equal to\n", "   * {@code Objects.hashCode(source(), target())}. The hashcode of the {@link Endpoints}\n", "   * of an undirected edge is equal to {@code nodeA().hashCode() ^ nodeB().hashCode()}.\n", "   */\n", "  @Override\n", "  public abstract int hashCode();\n", "\n", "  /**\n", "   * The {@link Endpoints} of a directed edge.\n", "   */\n", "  private static final class Directed<N> extends Endpoints<N> {\n", "    private Directed(N source, N target) {\n", "      super(source, target);\n", "    }\n", "\n", "    @Override\n", "    public N source() {\n", "      return nodeA();\n", "    }\n", "\n", "    @Override\n", "    public N target() {\n", "      return nodeB();\n", "    }\n", "\n", "    @Override\n", "    boolean isDirected() {\n", "      return true;\n", "    }\n", "\n", "    @Override\n", "    public boolean equals(Object obj) {\n", "      if (obj == this) {\n", "        return true;\n", "      }\n", "      if (!(obj instanceof Endpoints)) {\n", "        return false;\n", "      }\n", "\n", "      Endpoints<?> other = (Endpoints<?>) obj;\n", "      if (isDirected() != other.isDirected()) {\n", "        return false;\n", "      }\n", "\n", "      return source().equals(other.source()) && target().equals(other.target());\n", "    }\n", "\n", "    @Override\n", "    public int hashCode() {\n", "      return Objects.hashCode(source(), target());\n", "    }\n", "\n", "    @Override\n", "    public String toString() {\n", "      return String.format(\"<%s -> %s>\", source(), target());\n", "    }\n", "  }\n", "\n", "  /**\n", "   * The {@link Endpoints} of an undirected edge.\n", "   */\n", "  private static final class Undirected<N> extends Endpoints<N> {\n", "    private Undirected(N nodeA, N nodeB) {\n", "      super(nodeA, nodeB);\n", "    }\n", "\n", "    @Override\n", "    public N source() {\n", "      throw new UnsupportedOperationException(NOT_AVAILABLE_ON_UNDIRECTED);\n", "    }\n", "\n", "    @Override\n", "    public N target() {\n", "      throw new UnsupportedOperationException(NOT_AVAILABLE_ON_UNDIRECTED);\n", "    }\n", "\n", "    @Override\n", "    boolean isDirected() {\n", "      return false;\n", "    }\n", "\n", "    @Override\n", "    public boolean equals(Object obj) {\n", "      if (obj == this) {\n", "        return true;\n", "      }\n", "      if (!(obj instanceof Endpoints)) {\n", "        return false;\n", "      }\n", "\n", "      Endpoints<?> other = (Endpoints<?>) obj;\n", "      if (isDirected() != other.isDirected()) {\n", "        return false;\n", "      }\n", "\n", "      // Equivalent to the following simple implementation:\n", "      // boolean condition1 = nodeA().equals(other.nodeA()) && nodeB().equals(other.nodeB());\n", "      // boolean condition2 = nodeA().equals(other.nodeB()) && nodeB().equals(other.nodeA());\n", "      // return condition1 || condition2;\n", "      if (nodeA().equals(other.nodeA())) { // check condition1\n", "        // Here's the tricky bit. We don't have to explicitly check for condition2 in this case.\n", "        // Why? The second half of condition2 requires that nodeB equals other.nodeA.\n", "        // We already know that nodeA equals other.nodeA. Combined with the earlier statement,\n", "        // and the transitive property of equality, this implies that nodeA equals nodeB.\n", "        // If nodeA equals nodeB, condition1 == condition2, so checking condition1 is sufficient.\n", "        return nodeB().equals(other.nodeB());\n", "      }\n", "      return nodeA().equals(other.nodeB()) && nodeB().equals(other.nodeA()); // check condition2\n", "    }\n", "\n", "    @Override\n", "    public int hashCode() {\n", "      return nodeA().hashCode() ^ nodeB().hashCode();\n", "    }\n", "\n", "    @Override\n", "    public String toString() {\n", "      return String.format(\"[%s, %s]\", nodeA(), nodeB());\n", "    }\n", "  }\n", "}\n"]}, "added_lines": {}, "removed_lines": {"1": [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 58, 59, 60, 61, 62, 63, 64, 65, 66, 67, 68, 69, 70, 71, 72, 73, 74, 75, 76, 77, 78, 79, 80, 81, 82, 83, 84, 85, 86, 87, 88, 89, 90, 91, 92, 93, 94, 95, 96, 97, 98, 99, 100, 101, 102, 103, 104, 105, 106, 107, 108, 109, 110, 111, 112, 113, 114, 115, 116, 117, 118, 119, 120, 121, 122, 123, 124, 125, 126, 127, 128, 129, 130, 131, 132, 133, 134, 135, 136, 137, 138, 139, 140, 141, 142, 143, 144, 145, 146, 147, 148, 149, 150, 151, 152, 153, 154, 155, 156, 157, 158, 159, 160, 161, 162, 163, 164, 165, 166, 167, 168, 169, 170, 171, 172, 173, 174, 175, 176, 177, 178, 179, 180, 181, 182, 183, 184, 185, 186, 187, 188, 189, 190, 191, 192, 193, 194, 195, 196, 197, 198, 199, 200, 201, 202, 203, 204, 205, 206, 207, 208, 209, 210, 211, 212, 213, 214, 215, 216, 217, 218, 219, 220, 221, 222, 223, 224, 225, 226, 227, 228, 229, 230, 231, 232, 233, 234, 235, 236, 237, 238, 239, 240, 241, 242, 243, 244, 245, 246, 247, 248, 249, 250, 251, 252, 253, 254, 255, 256, 257, 258, 259, 260, 261, 262, 263]}}, {"36": "guava/src/com/google/common/graph/ForwardingGraph.java", "added": {"1": ["/*\n", " * Copyright (C) 2016 The Guava Authors\n", " *\n", " * Licensed under the Apache License, Version 2.0 (the \"License\");\n", " * you may not use this file except in compliance with the License.\n", " * You may obtain a copy of the License at\n", " *\n", " * http://www.apache.org/licenses/LICENSE-2.0\n", " *\n", " * Unless required by applicable law or agreed to in writing, software\n", " * distributed under the License is distributed on an \"AS IS\" BASIS,\n", " * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n", " * See the License for the specific language governing permissions and\n", " * limitations under the License.\n", " */\n", "\n", "package com.google.common.graph;\n", "\n", "import com.google.common.collect.ForwardingObject;\n", "import java.util.Set;\n", "\n", "/**\n", " * A class to allow {@link Graph} implementations to be backed by {@link ValueGraph}s. This is not\n", " * currently planned to be released as a general-purpose forwarding class.\n", " *\n", " * @author James Sexton\n", " */\n", "abstract class ForwardingGraph<N> extends ForwardingObject implements Graph<N> {\n", "\n", "  @Override\n", "  protected abstract Graph<N> delegate();\n", "\n", "  @Override\n", "  public Set<N> nodes() {\n", "    return delegate().nodes();\n", "  }\n", "\n", "  @Override\n", "  public Set<EndpointPair<N>> edges() {\n", "    return delegate().edges();\n", "  }\n", "\n", "  @Override\n", "  public boolean isDirected() {\n", "    return delegate().isDirected();\n", "  }\n", "\n", "  @Override\n", "  public boolean allowsSelfLoops() {\n", "    return delegate().allowsSelfLoops();\n", "  }\n", "\n", "  @Override\n", "  public ElementOrder<N> nodeOrder() {\n", "    return delegate().nodeOrder();\n", "  }\n", "\n", "  @Override\n", "  public Set<N> adjacentNodes(Object node) {\n", "    return delegate().adjacentNodes(node);\n", "  }\n", "\n", "  @Override\n", "  public Set<N> predecessors(Object node) {\n", "    return delegate().predecessors(node);\n", "  }\n", "\n", "  @Override\n", "  public Set<N> successors(Object node) {\n", "    return delegate().successors(node);\n", "  }\n", "\n", "  @Override\n", "  public int degree(Object node) {\n", "    return delegate().degree(node);\n", "  }\n", "\n", "  @Override\n", "  public int inDegree(Object node) {\n", "    return delegate().inDegree(node);\n", "  }\n", "\n", "  @Override\n", "  public int outDegree(Object node) {\n", "    return delegate().outDegree(node);\n", "  }\n", "\n", "  @Override\n", "  public String toString() {\n", "    return AbstractGraph.toString(delegate());\n", "  }\n", "}\n"]}, "removed": {}, "added_lines": {"1": [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 58, 59, 60, 61, 62, 63, 64, 65, 66, 67, 68, 69, 70, 71, 72, 73, 74, 75, 76, 77, 78, 79, 80, 81, 82, 83, 84, 85, 86, 87, 88, 89, 90, 91, 92]}, "removed_lines": {}}, {"37": "guava/src/com/google/common/graph/Graph.java", "added": {"1": [" * Copyright (C) 2014 The Guava Authors\n"], "2": [" * complexity they are: {@link Graph}, {@link ValueGraph}, and {@link Network}. You should generally\n", " *     <p>Yes: Go to question 2. No: Use {@link Graph}.\n", " *     <p>Yes: Go to question 3. No: Use {@link ValueGraph}.\n", " *     <p>Yes: Use {@link Network}. No: Use {@link ValueGraph}.\n", " * <p>Although {@link MutableValueGraph} and {@link MutableNetwork} both require users to provide\n", " * objects to associate with edges when adding them, the differentiating factor is that in {@link\n", " * ValueGraph}s, these objects can be any arbitrary data. Like the values in a {@link Map}, they do\n", " * not have to be unique, and can be mutated while in the graph. In a {@link Network}, these objects\n", " * serve as keys into the data structure. Like the keys in a {@link Map}, they must be unique, and\n", " * cannot be mutated in a way that affects their equals/hashcode or the data structure will become\n", " * corrupted.\n", " * <p>The {@link Graph} interface does not support parallel {@link #edges()}, and forbids\n", " * implementations or extensions with parallel edges. It is possible to encode a notion of edge\n", " * multiplicity into the values of a {@ValueGraph} (e.g. with an integer or a list of values), but\n", " * this will not be reflected in methods such as {@link Graph#degree(Object)}. For that\n", " * functionality, use {@link Network}s.\n", " *\n"], "3": [" * MutableGraph<String> managementGraph = GraphBuilder.directed().build();\n", " * managementGraph.putEdge(\"Big Boss\", \"Middle Manager Jack\");\n", " * managementGraph.putEdge(\"Big Boss\", \"Middle Manager Jill\");\n", " * managementGraph.putEdge(\"Middle Manager Jack\", \"Joe\");\n", " * managementGraph.putEdge(\"Middle Manager Jack\", \"Schmoe\");\n", " * managementGraph.putEdge(\"Middle Manager Jill\", \"Jane\");\n", " * managementGraph.putEdge(\"Middle Manager Jill\", \"Doe\");\n", " * for (String employee : managementGraph.nodes()) {\n", " *   Set<String> reports = managementGraph.successors(employee);\n", " *   if (!reports.isEmpty()) {\n", " *     System.out.format(\"%s has the following direct reports: %s%n\", employee, reports);\n", " * @author Joshua O'Madadhain\n", "public interface Graph<N> {\n"], "4": ["  Set<EndpointPair<N>> edges();\n"], "5": ["   * EndpointPair#source() source node} to a {@link EndpointPair#target() target node}, while\n", "   * undirected edges connect a pair of nodes to each other.\n"], "6": ["   * For the default {@link Graph} implementations, returns true iff {@code this == object} (i.e.\n", "   * reference equality). External implementations are free to define this method as they see fit,\n", "   * as long as they satisfy the {@link Object#equals(Object)} contract.\n", "   * <p>To compare two {@link Graph}s based on their contents rather than their references, see\n", "   * {@link Graphs#equivalent(Graph, Graph)}.\n", "   * For the default {@link Graph} implementations, returns {@code System.identityHashCode(this)}.\n", "   * External implementations are free to define this method as they see fit, as long as they\n", "   * satisfy the {@link Object#hashCode()} contract.\n"]}, "removed": {"1": [" * Copyright (C) 2016 The Guava Authors\n"], "2": [" * complexity they are: {@link BasicGraph}, {@link Graph}, and {@link Network}. You should generally\n", " *     <p>Yes: Go to question 2. No: Use {@link BasicGraph}.\n", " *     <p>Yes: Go to question 3. No: Use {@link Graph}.\n", " *     <p>Yes: Use {@link Network}. No: Use {@link Graph}.\n", " * <p>Although {@link MutableGraph} and {@link MutableNetwork} both require users to provide objects\n", " * to associate with edges when adding them, the differentiating factor is that in {@link Graph}s,\n", " * these objects can be any arbitrary data. Like the values in a {@link Map}, they do not have to be\n", " * unique, and can be mutated while in the graph. In a {@link Network}, these objects serve as keys\n", " * into the data structure. Like the keys in a {@link Map}, they must be unique, and cannot be\n", " * mutated in a way that affects their equals/hashcode or the data structure will become corrupted.\n"], "3": [" * MutableGraph<String, Double> synonymGraph = GraphBuilder.undirected().build();\n", " * synonymGraph.putEdgeValue(\"large\", \"big\", 0.9);\n", " * synonymGraph.putEdgeValue(\"large\", \"huge\", 0.9);\n", " * synonymGraph.putEdgeValue(\"large\", \"grand\", 0.6);\n", " * synonymGraph.putEdgeValue(\"large\", \"cold\", 0.0);\n", " * synonymGraph.putEdgeValue(\"large\", \"small\", -1.0);\n", " * for (String word : synonymGraph.adjacentNodes(\"large\")) {\n", " *   if (synonymGraph.edgeValue(word, \"large\") > 0.5) {\n", " *     System.out.println(word + \" is a synonym for large\");\n", " * @param <V> Value parameter type\n", "public interface Graph<N, V> {\n"], "4": ["  Set<Endpoints<N>> edges();\n"], "5": ["   * Endpoints#source() source node} to a {@link Endpoints#target() target node}, while undirected\n", "   * edges connect a pair of nodes to each other.\n"], "6": ["  /**\n", "   * If there is an edge connecting {@code nodeA} to {@code nodeB}, returns the non-null value\n", "   * associated with that edge.\n", "   *\n", "   * <p>In an undirected graph, this is equal to {@code edgeValue(nodeB, nodeA)}.\n", "   *\n", "   * @throws IllegalArgumentException if there is no edge connecting {@code nodeA} to {@code nodeB}\n", "   */\n", "  V edgeValue(Object nodeA, Object nodeB);\n", "\n", "  /**\n", "   * If there is an edge connecting {@code nodeA} to {@code nodeB}, returns the non-null value\n", "   * associated with that edge; otherwise, returns {@code defaultValue}.\n", "   *\n", "   * <p>In an undirected graph, this is equal to {@code edgeValueOrDefault(nodeB, nodeA,\n", "   * defaultValue)}.\n", "   *\n", "   * @throws IllegalArgumentException if {@code nodeA} or {@code nodeB} is not an element of this\n", "   *     graph\n", "   */\n", "  V edgeValueOrDefault(Object nodeA, Object nodeB, @Nullable V defaultValue);\n", "\n", "   * Returns {@code true} iff {@code object} is a {@link Graph} that has the same elements and the\n", "   * same structural relationships as those in this graph.\n", "   *\n", "   * <p>Thus, two graphs A and B are equal if <b>all</b> of the following are true:\n", "   * <ul>\n", "   * <li>A and B have equal {@link #isDirected() directedness}.\n", "   * <li>A and B have equal {@link #nodes() node sets}.\n", "   * <li>A and B have equal {@link #edges() edge sets}.\n", "   * <li>Every edge in A and B are associated with equal {@link #edgeValue(Object, Object) values}.\n", "   * </ul>\n", "   *\n", "   * <p>Graph properties besides {@link #isDirected() directedness} do <b>not</b> affect equality.\n", "   * For example, two graphs may be considered equal even if one allows self-loops and the other\n", "   * doesn't. Additionally, the order in which nodes or edges are added to the graph, and the order\n", "   * in which they are iterated over, are irrelevant.\n", "   *\n", "   * <p>A reference implementation of this is provided by {@link AbstractGraph#equals(Object)}.\n", "   * Returns the hash code for this graph. The hash code of a graph is defined as the hash code of a\n", "   * map from each of its {@link #edges() edges} to the associated {@link #edgeValue(Object, Object)\n", "   * edge value}.\n", "   *\n", "   * <p>A reference implementation of this is provided by {@link AbstractGraph#hashCode()}.\n"]}, "added_lines": {"1": [2], "2": [35, 42, 46, 53, 56, 57, 58, 59, 60, 61, 62, 66, 67, 68, 69, 70, 71], "3": [90, 91, 92, 93, 94, 95, 96, 97, 98, 99, 100, 106, 111], "4": [120], "5": [128, 129], "6": [217, 218, 219, 221, 222, 228, 229, 230]}, "removed_lines": {"1": [2], "2": [35, 42, 46, 53, 56, 57, 58, 59, 60, 61], "3": [83, 84, 85, 86, 87, 88, 89, 90, 91, 98, 102], "4": [111], "5": [119, 120], "6": [203, 204, 205, 206, 207, 208, 209, 210, 211, 212, 213, 214, 215, 216, 217, 218, 219, 220, 221, 222, 223, 224, 230, 231, 232, 233, 235, 236, 237, 238, 239, 240, 241, 242, 243, 244, 245, 246, 247, 253, 254, 255, 256, 257]}}, {"38": "guava/src/com/google/common/graph/GraphBuilder.java", "added": {"1": [" * MutableGraph<String> graph = GraphBuilder.undirected().allowsSelfLoops(true).build();\n", " * graph.putEdge(\"bread\", \"bread\");\n", " * graph.putEdge(\"chocolate\", \"peanut butter\");\n", " * graph.putEdge(\"peanut butter\", \"jelly\");\n"], "2": ["public final class GraphBuilder<N> extends AbstractGraphBuilder<N> {\n"], "3": ["  public static GraphBuilder<Object> directed() {\n", "    return new GraphBuilder<Object>(true);\n", "  public static GraphBuilder<Object> undirected() {\n", "    return new GraphBuilder<Object>(false);\n"], "4": ["  public static <N> GraphBuilder<N> from(Graph<N> graph) {\n", "    return new GraphBuilder<Object>(graph.isDirected())\n"], "5": ["  public GraphBuilder<N> allowsSelfLoops(boolean allowsSelfLoops) {\n"], "6": ["  public GraphBuilder<N> expectedNodeCount(int expectedNodeCount) {\n"], "7": ["  public <N1 extends N> GraphBuilder<N1> nodeOrder(ElementOrder<N1> nodeOrder) {\n", "    GraphBuilder<N1> newBuilder = cast();\n", "  public <N1 extends N> MutableGraph<N1> build() {\n", "    return new ConfigurableMutableGraph<N1>(this);\n", "  private <N1 extends N> GraphBuilder<N1> cast() {\n", "    return (GraphBuilder<N1>) this;\n"]}, "removed": {"1": [" * MutableGraph<String, Double> graph = GraphBuilder.undirected().allowsSelfLoops(true).build();\n", " * graph.putEdgeValue(\"San Francisco\", \"San Francisco\", 0.0);\n", " * graph.putEdgeValue(\"San Jose\", \"San Jose\", 0.0);\n", " * graph.putEdgeValue(\"San Francisco\", \"San Jose\", 48.4);\n"], "2": ["public final class GraphBuilder<N, V> extends AbstractGraphBuilder<N> {\n"], "3": ["  public static GraphBuilder<Object, Object> directed() {\n", "    return new GraphBuilder<Object, Object>(true);\n", "  public static GraphBuilder<Object, Object> undirected() {\n", "    return new GraphBuilder<Object, Object>(false);\n"], "4": ["  public static <N> GraphBuilder<N, Object> from(Graph<N, ?> graph) {\n", "    return new GraphBuilder<N, Object>(graph.isDirected())\n"], "5": ["  public GraphBuilder<N, V> allowsSelfLoops(boolean allowsSelfLoops) {\n"], "6": ["  public GraphBuilder<N, V> expectedNodeCount(int expectedNodeCount) {\n"], "7": ["  public <N1 extends N> GraphBuilder<N1, V> nodeOrder(ElementOrder<N1> nodeOrder) {\n", "    GraphBuilder<N1, V> newBuilder = cast();\n", "  public <N1 extends N, V1 extends V> MutableGraph<N1, V1> build() {\n", "    return new ConfigurableMutableGraph<N1, V1>(this);\n", "  private <N1 extends N, V1 extends V> GraphBuilder<N1, V1> cast() {\n", "    return (GraphBuilder<N1, V1>) this;\n"]}, "added_lines": {"1": [38, 39, 40, 41], "2": [49], "3": [57, 58, 62, 63], "4": [73, 75], "5": [85], "6": [95], "7": [105, 107, 113, 114, 118, 119]}, "removed_lines": {"1": [38, 39, 40, 41], "2": [49], "3": [57, 58, 62, 63], "4": [73, 75], "5": [85], "6": [95], "7": [105, 107, 113, 114, 118, 119]}}, {"39": "guava/src/com/google/common/graph/GraphConstants.java", "added": {"1": ["      \"Cannot call source()/target() on a EndpointPair from an undirected graph. Consider calling \"\n", "          + \"adjacentNode(node) if you already have a node, or nodeU()/nodeV() if you don't.\";\n", "\n", "  /**\n", "   * Singleton edge value for {@link Graph} implementations backed by {@link ValueGraph}s.\n", "   */\n", "  enum Presence {\n", "    EDGE_EXISTS\n", "  }\n"]}, "removed": {"1": ["      \"Cannot call source()/target() on the endpoints of an undirected edge. Consider calling \"\n", "          + \"adjacentNode(node) if you already have a node, or nodeA()/nodeB() if you don't.\";\n"]}, "added_lines": {"1": [50, 51, 55, 56, 57, 58, 59, 60, 61]}, "removed_lines": {"1": [50, 51]}}, {"40": "guava/src/com/google/common/graph/Graphs.java", "added": {"3": ["  public static boolean hasCycle(Graph<?> graph) {\n"], "4": ["      Graph<?> graph,\n"], "5": ["      Graph<?> graph, Object nextNode, @Nullable Object previousNode) {\n"], "6": ["   * of the transitive closure of {@code graph}. In other words, the returned {@link Graph} will not\n", "   * be updated after modifications to {@code graph}.\n", "  public static <N> Graph<N> transitiveClosure(Graph<N> graph) {\n", "    MutableGraph<N> transitiveClosure = GraphBuilder.from(graph).allowsSelfLoops(true).build();\n"], "7": ["            N nodeU = reachableNodes.get(a);\n", "              N nodeV = reachableNodes.get(b);\n", "              transitiveClosure.putEdge(nodeU, nodeV);\n"], "8": ["  public static <N> Set<N> reachableNodes(Graph<N> graph, Object node) {\n"], "9": ["   * Returns {@code true} iff {@code graphA} and {@code graphB} have the same elements and the same\n", "   * relationships between elements, as exposed via the {@link Graph} interface.\n", "   *\n", "   * <p>Thus, two graphs A and B are equivalent if <b>all</b> of the following are true:\n", "   *\n", "   * <ul>\n", "   * <li>A and B have equal {@link Graph#isDirected() directedness}.\n", "   * <li>A and B have equal {@link Graph#nodes() node sets}.\n", "   * <li>A and B have equal {@link Graph#edges() edge sets}.\n", "   * </ul>\n", "   *\n", "   * <p>Graph properties besides {@link Graph#isDirected() directedness} do <b>not</b> affect\n", "   * equivalence. For example, two graphs may be considered equivalent even if one allows self-loops\n", "   * and the other doesn't. Additionally, the order in which nodes or edges are added to the graph,\n", "   * and the order in which they are iterated over, are irrelevant.\n", "  public static boolean equivalent(@Nullable Graph<?> graphA, @Nullable Graph<?> graphB) {\n", "    if (graphA == graphB) {\n", "      return true;\n", "    }\n", "    if (graphA == null || graphB == null) {\n", "      return false;\n", "    }\n", "    return graphA.isDirected() == graphB.isDirected()\n", "        && graphA.nodes().equals(graphB.nodes())\n", "        && graphA.edges().equals(graphB.edges());\n", "  }\n", "  /**\n", "   * Returns {@code true} iff {@code graphA} and {@code graphB} have the same elements (including\n", "   * edge values) and the same relationships between elements, as exposed via the {@link ValueGraph}\n", "   * interface.\n", "   *\n", "   * <p>Thus, two value graphs A and B are equivalent if <b>all</b> of the following are true:\n", "   *\n", "   * <ul>\n", "   * <li>A and B have equal {@link Graph#isDirected() directedness}.\n", "   * <li>A and B have equal {@link Graph#nodes() node sets}.\n", "   * <li>A and B have equal {@link Graph#edges() edge sets}.\n", "   * <li>Each edge in A has a {@link ValueGraph#edgeValue(Object, Object) value} equal to the\n", "   *     {@link ValueGraph#edgeValue(Object, Object) value} of the corresponding edge in B.\n", "   * </ul>\n", "   *\n", "   * <p>Graph properties besides {@link Graph#isDirected() directedness} do <b>not</b> affect\n", "   * equivalence. For example, two graphs may be considered equivalent even if one allows self-loops\n", "   * and the other doesn't. Additionally, the order in which nodes or edges are added to the graph,\n", "   * and the order in which they are iterated over, are irrelevant.\n", "   */\n", "  public static boolean equivalent(\n", "      @Nullable ValueGraph<?, ?> graphA, @Nullable ValueGraph<?, ?> graphB) {\n", "    if (graphA == graphB) {\n", "      return true;\n", "    }\n", "    if (graphA == null || graphB == null) {\n", "      return false;\n", "    }\n", "    // TODO(b/31166974): If we add a Map of edgeValues, we can check against that for equality.\n", "    if (graphA.isDirected() != graphB.isDirected()\n", "        || !graphA.nodes().equals(graphB.nodes())\n", "        || !graphA.edges().equals(graphB.edges())) {\n", "      return false;\n", "    }\n", "    for (EndpointPair<?> edge : graphA.edges()) {\n", "      if (!graphA.edgeValue(edge.nodeU(), edge.nodeV()).equals(\n", "          graphB.edgeValue(edge.nodeU(), edge.nodeV()))) {\n", "        return false;\n", "    }\n", "    return true;\n", "  }\n", "  /**\n", "   * Returns {@code true} iff {@code networkA} and {@code networkB} have the same elements and the\n", "   * same relationships between elements, as exposed via the {@link Network} interface.\n", "   *\n", "   * <p>Thus, two networks A and B are equivalent if <b>all</b> of the following are true:\n", "   *\n", "   * <ul>\n", "   * <li>A and B have equal {@link Network#isDirected() directedness}.\n", "   * <li>A and B have equal {@link Network#nodes() node sets}.\n", "   * <li>A and B have equal {@link Network#edges() edge sets}.\n", "   * <li>Each edge in A connects the same nodes in the same direction (if any) as the corresponding\n", "   *     edge in B.\n", "   * </ul>\n", "   *\n", "   * <p>Network properties besides {@link Network#isDirected() directedness} do <b>not</b> affect\n", "   * equivalence. For example, two networks may be considered equal even if one allows parallel\n", "   * edges and the other doesn't. Additionally, the order in which nodes or edges are added to the\n", "   * network, and the order in which they are iterated over, are irrelevant.\n", "   */\n", "  public static boolean equivalent(\n", "      @Nullable Network<?, ?> networkA, @Nullable Network<?, ?> networkB) {\n", "    if (networkA == networkB) {\n", "      return true;\n", "    }\n", "    if (networkA == null || networkB == null) {\n", "      return false;\n", "    }\n", "    if (networkA.isDirected() != networkB.isDirected()\n", "        || !networkA.nodes().equals(networkB.nodes())\n", "        || !networkA.edges().equals(networkB.edges())) {\n", "      return false;\n", "    }\n", "    for (Object edge : networkA.edges()) {\n", "      if (!networkA.incidentNodes(edge).equals(networkB.incidentNodes(edge))) {\n", "        return false;\n", "    }\n", "    return true;\n", "  // Graph mutation methods\n", "  // Graph view methods\n", "  public static <N> Graph<N> transpose(Graph<N> graph) {\n", "      return ((TransposedGraph<N>) graph).graph;\n", "    return new TransposedGraph<N>(graph);\n", "  private static class TransposedGraph<N> extends AbstractGraph<N> {\n", "    private final Graph<N> graph;\n", "    TransposedGraph(Graph<N> graph) {\n"], "10": ["    /**\n", "     * Defer to {@link AbstractGraph#edges()} (based on {@link #successors(Object)}) for full\n", "     * edges() implementation.\n", "     */\n", "    @Override\n", "    protected long edgeCount() {\n", "      return graph.edges().size();\n", "    }\n"], "11": ["  }\n", "  /**\n", "   * Returns a view of {@code graph} with the direction (if any) of every edge reversed. All other\n", "   * properties remain intact, and further updates to {@code graph} will be reflected in the view.\n", "   */\n", "  public static <N, V> ValueGraph<N, V> transpose(ValueGraph<N, V> graph) {\n", "    if (!graph.isDirected()) {\n", "      return graph; // the transpose of an undirected graph is an identical graph\n", "    }\n", "\n", "    if (graph instanceof TransposedValueGraph) {\n", "      return ((TransposedValueGraph<N, V>) graph).graph;\n", "    }\n", "\n", "    return new TransposedValueGraph<N, V>(graph);\n", "  }\n", "\n", "  private static class TransposedValueGraph<N, V> extends AbstractValueGraph<N, V> {\n", "    private final ValueGraph<N, V> graph;\n", "\n", "    TransposedValueGraph(ValueGraph<N, V> graph) {\n", "      this.graph = graph;\n", "    public Set<N> nodes() {\n", "      return graph.nodes();\n", "    /**\n", "     * Defer to {@link AbstractGraph#edges()} (based on {@link #successors(Object)}) for full\n", "     * edges() implementation.\n", "     */\n", "\n", "    @Override\n", "    public boolean isDirected() {\n", "      return graph.isDirected();\n", "    }\n", "\n", "    @Override\n", "    public boolean allowsSelfLoops() {\n", "      return graph.allowsSelfLoops();\n", "    }\n", "\n", "    @Override\n", "    public ElementOrder<N> nodeOrder() {\n", "      return graph.nodeOrder();\n", "    }\n", "\n", "    @Override\n", "    public Set<N> adjacentNodes(Object node) {\n", "      return graph.adjacentNodes(node);\n", "    }\n", "\n", "    @Override\n", "    public Set<N> predecessors(Object node) {\n", "      return graph.successors(node); // transpose\n", "    }\n", "\n", "    @Override\n", "    public Set<N> successors(Object node) {\n", "      return graph.predecessors(node); // transpose\n", "    }\n", "\n", "    @Override\n", "    public V edgeValue(Object nodeU, Object nodeV) {\n", "      return graph.edgeValue(nodeV, nodeU); // transpose\n", "    }\n", "\n", "    @Override\n", "    public V edgeValueOrDefault(Object nodeU, Object nodeV, V defaultValue) {\n", "      return graph.edgeValueOrDefault(nodeV, nodeU, defaultValue); // transpose\n", "    }\n"], "12": ["    public EndpointPair<N> incidentNodes(Object edge) {\n", "      EndpointPair<N> endpointPair = network.incidentNodes(edge);\n", "      return EndpointPair.of(network, endpointPair.nodeV(), endpointPair.nodeU()); // transpose\n"], "13": ["    public Set<E> edgesConnecting(Object nodeU, Object nodeV) {\n", "      return network.edgesConnecting(nodeV, nodeU); // transpose\n"], "14": ["  public static <N> MutableGraph<N> inducedSubgraph(Graph<N> graph,\n", "    MutableGraph<N> subgraph = GraphBuilder.from(graph).build();\n"], "15": ["  public static <N, V> MutableValueGraph<N, V> inducedSubgraph(ValueGraph<N, V> graph,\n", "    MutableValueGraph<N, V> subgraph = ValueGraphBuilder.from(graph).build();\n"], "16": ["  public static <N> MutableGraph<N> copyOf(Graph<N> graph) {\n", "    MutableGraph<N> copy = GraphBuilder.from(graph)\n", "    for (EndpointPair<N> edge : graph.edges()) {\n", "      copy.putEdge(edge.nodeU(), edge.nodeV());\n"], "17": ["  public static <N, V> MutableValueGraph<N, V> copyOf(ValueGraph<N, V> graph) {\n", "    MutableValueGraph<N, V> copy = ValueGraphBuilder.from(graph)\n", "    for (EndpointPair<N> edge : graph.edges()) {\n", "      copy.putEdgeValue(edge.nodeU(), edge.nodeV(), graph.edgeValue(edge.nodeU(), edge.nodeV()));\n"], "18": ["      EndpointPair<N> endpointPair = graph.incidentNodes(edge);\n", "      copy.addEdge(endpointPair.nodeU(), endpointPair.nodeV(), edge);\n"]}, "removed": {"1": ["import static com.google.common.base.Preconditions.checkNotNull;\n"], "2": ["import com.google.common.graph.BasicGraph.Presence;\n"], "3": ["  public static boolean hasCycle(Graph<?, ?> graph) {\n"], "4": ["      Graph<?, ?> graph,\n"], "5": ["      Graph<?, ?> graph, Object nextNode, @Nullable Object previousNode) {\n"], "6": ["   * of the transitive closure of {@code graph}. In other words, the returned {@link BasicGraph}\n", "   * will not be updated after modifications to {@code graph}.\n", "  public static <N> BasicGraph<N> transitiveClosure(Graph<N, ?> graph) {\n", "    MutableBasicGraph<N> transitiveClosure =\n", "        BasicGraphBuilder.from(graph).allowsSelfLoops(true).build();\n"], "7": ["            N nodeA = reachableNodes.get(a);\n", "              N nodeB = reachableNodes.get(b);\n", "              transitiveClosure.putEdge(nodeA, nodeB);\n"], "8": ["  public static <N> Set<N> reachableNodes(Graph<N, ?> graph, Object node) {\n"], "9": ["  // Graph mutation methods\n", "\n", "  // Graph view methods\n", "\n", "   * Returns a view of {@code graph} as a {@link BasicGraph}. If {@code graph} is already a basic\n", "   * graph, it will be {@link Graph#equals(Object) equal} to the returned graph.\n", "  public static <N> BasicGraph<N> asBasicGraph(final Graph<N, ?> graph) {\n", "    if (graph instanceof BasicGraph) {\n", "      @SuppressWarnings(\"unchecked\")\n", "      BasicGraph<N> basicGraph = (BasicGraph<N>) graph;\n", "      return basicGraph;\n", "    }\n", "\n", "    checkNotNull(graph);\n", "    return new AbstractBasicGraph<N>() {\n", "      @Override\n", "      public Set<N> nodes() {\n", "        return graph.nodes();\n", "      }\n", "      @Override\n", "      public Set<Endpoints<N>> edges() {\n", "        return graph.edges();\n", "      }\n", "      @Override\n", "      public boolean isDirected() {\n", "        return graph.isDirected();\n", "      }\n", "      @Override\n", "      public boolean allowsSelfLoops() {\n", "        return graph.allowsSelfLoops();\n", "      }\n", "      @Override\n", "      public ElementOrder<N> nodeOrder() {\n", "        return graph.nodeOrder();\n", "      @Override\n", "      public Set<N> adjacentNodes(Object node) {\n", "        return graph.adjacentNodes(node);\n", "      }\n", "      @Override\n", "      public Set<N> predecessors(Object node) {\n", "        return graph.predecessors(node);\n", "      }\n", "      @Override\n", "      public Set<N> successors(Object node) {\n", "        return graph.successors(node);\n", "      }\n", "      @Override\n", "      public Presence edgeValue(Object nodeA, Object nodeB) {\n", "        checkNotNull(graph.edgeValue(nodeA, nodeB));\n", "        return Presence.EDGE_EXISTS;\n", "      @Override\n", "      public Presence edgeValueOrDefault(Object nodeA, Object nodeB, Presence defaultValue) {\n", "        Object value = graph.edgeValueOrDefault(nodeA, nodeB, null);\n", "        return (value == null) ? defaultValue : Presence.EDGE_EXISTS;\n", "      }\n", "    };\n", "  /**\n", "   * Simply returns its argument.\n", "   *\n", "   * @deprecated no need to use this\n", "   */\n", "  @Deprecated\n", "  public static <N> BasicGraph<N> asBasicGraph(BasicGraph<N> graph) {\n", "    return checkNotNull(graph);\n", "  }\n", "  /**\n", "   * Returns a view of {@code graph} with the direction (if any) of every edge reversed. All other\n", "   * properties remain intact, and further updates to {@code graph} will be reflected in the view.\n", "   */\n", "  public static <N> BasicGraph<N> transpose(BasicGraph<N> graph) {\n", "    return asBasicGraph(transpose((Graph<N, Presence>) graph));\n", "  }\n", "  public static <N, V> Graph<N, V> transpose(Graph<N, V> graph) {\n", "      return ((TransposedGraph<N, V>) graph).graph;\n", "    return new TransposedGraph<N, V>(graph);\n", "  private static class TransposedGraph<N, V> extends AbstractGraph<N, V> {\n", "    private final Graph<N, V> graph;\n", "    TransposedGraph(Graph<N, V> graph) {\n"], "10": ["    // Defer to AbstractGraph's implementation of edges(), which is based of successors().\n"], "11": ["    @Override\n", "    public V edgeValue(Object nodeA, Object nodeB) {\n", "      return graph.edgeValue(nodeB, nodeA); // transpose\n", "    public V edgeValueOrDefault(Object nodeA, Object nodeB, V defaultValue) {\n", "      return graph.edgeValueOrDefault(nodeB, nodeA, defaultValue); // transpose\n"], "12": ["    public Endpoints<N> incidentNodes(Object edge) {\n", "      Endpoints<N> endpoints = network.incidentNodes(edge);\n", "      return Endpoints.of(network, endpoints.nodeB(), endpoints.nodeA()); // transpose\n"], "13": ["    public Set<E> edgesConnecting(Object nodeA, Object nodeB) {\n", "      return network.edgesConnecting(nodeB, nodeA); // transpose\n"], "14": ["  public static <N> MutableBasicGraph<N> inducedSubgraph(BasicGraph<N> graph,\n", "    MutableBasicGraph<N> subgraph = BasicGraphBuilder.from(graph).build();\n"], "15": ["  public static <N, V> MutableGraph<N, V> inducedSubgraph(Graph<N, V> graph,\n", "    MutableGraph<N, V> subgraph = GraphBuilder.from(graph).build();\n"], "16": ["  public static <N> MutableBasicGraph<N> copyOf(BasicGraph<N> graph) {\n", "    MutableBasicGraph<N> copy = BasicGraphBuilder.from(graph)\n", "    for (Endpoints<N> endpoints : graph.edges()) {\n", "      copy.putEdge(endpoints.nodeA(), endpoints.nodeB());\n"], "17": ["  public static <N, V> MutableGraph<N, V> copyOf(Graph<N, V> graph) {\n", "    MutableGraph<N, V> copy = GraphBuilder.from(graph)\n", "    for (Endpoints<N> edge : graph.edges()) {\n", "      copy.putEdgeValue(edge.nodeA(), edge.nodeB(), graph.edgeValue(edge.nodeA(), edge.nodeB()));\n"], "18": ["      Endpoints<N> endpoints = graph.incidentNodes(edge);\n", "      copy.addEdge(endpoints.nodeA(), endpoints.nodeB(), edge);\n"]}, "added_lines": {"3": [57], "4": [99], "5": [129], "6": [144, 145, 147, 148], "7": [168, 170, 171], "8": [193], "9": [212, 213, 214, 215, 216, 217, 218, 219, 220, 221, 222, 223, 224, 225, 226, 228, 229, 230, 231, 232, 233, 234, 236, 237, 238, 239, 241, 242, 243, 244, 245, 246, 247, 248, 249, 250, 251, 252, 253, 254, 255, 256, 257, 258, 259, 260, 261, 262, 263, 264, 265, 266, 267, 268, 270, 271, 272, 273, 274, 275, 277, 278, 279, 280, 282, 284, 285, 287, 288, 289, 290, 291, 292, 293, 294, 295, 296, 297, 298, 299, 300, 301, 302, 303, 304, 305, 306, 307, 308, 309, 310, 311, 312, 313, 315, 316, 317, 318, 319, 321, 322, 323, 325, 327, 330, 332, 338, 344, 347, 350, 351, 353], "10": [362, 363, 364, 365, 366, 367, 368, 369], "11": [400, 402, 403, 404, 405, 406, 407, 408, 409, 410, 411, 412, 413, 414, 415, 416, 417, 418, 419, 420, 421, 422, 426, 427, 430, 431, 432, 433, 438, 439, 440, 441, 442, 443, 444, 445, 446, 447, 448, 449, 450, 451, 452, 453, 454, 455, 456, 457, 458, 459, 460, 461, 462, 463, 464, 465, 466, 467, 468, 469, 470, 471, 472, 473, 474, 475, 476, 477], "12": [569, 570, 571], "13": [580, 581], "14": [594, 596], "15": [617, 619], "16": [660, 661, 667, 668], "17": [676, 677, 683, 684], "18": [701, 702]}, "removed_lines": {"1": [20], "2": [28], "3": [59], "4": [101], "5": [131], "6": [146, 147, 149, 150, 151], "7": [171, 173, 174], "8": [196], "9": [214, 215, 216, 217, 219, 220, 222, 223, 224, 225, 226, 227, 228, 229, 230, 231, 232, 233, 234, 236, 237, 238, 239, 241, 242, 243, 244, 246, 247, 248, 249, 251, 252, 253, 256, 257, 258, 259, 261, 262, 263, 264, 266, 267, 268, 269, 271, 272, 273, 274, 277, 278, 279, 280, 281, 282, 285, 286, 287, 288, 289, 290, 291, 292, 293, 295, 296, 297, 298, 299, 300, 301, 307, 313, 316, 319, 320, 322], "10": [331], "11": [363, 364, 365, 369, 370], "12": [468, 469, 470], "13": [479, 480], "14": [493, 495], "15": [516, 518], "16": [559, 560, 566, 567], "17": [575, 576, 582, 583], "18": [600, 601]}}, {"41": "guava/src/com/google/common/graph/ImmutableBasicGraph.java", "added": {}, "removed": {"1": ["/*\n", " * Copyright (C) 2014 The Guava Authors\n", " *\n", " * Licensed under the Apache License, Version 2.0 (the \"License\");\n", " * you may not use this file except in compliance with the License.\n", " * You may obtain a copy of the License at\n", " *\n", " * http://www.apache.org/licenses/LICENSE-2.0\n", " *\n", " * Unless required by applicable law or agreed to in writing, software\n", " * distributed under the License is distributed on an \"AS IS\" BASIS,\n", " * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n", " * See the License for the specific language governing permissions and\n", " * limitations under the License.\n", " */\n", "\n", "package com.google.common.graph;\n", "\n", "import static com.google.common.base.Preconditions.checkNotNull;\n", "\n", "import com.google.common.annotations.Beta;\n", "import com.google.common.collect.ImmutableCollection;\n", "import com.google.common.graph.BasicGraph.Presence;\n", "\n", "/**\n", " * A {@link BasicGraph} whose elements and structural relationships will never change. Instances of\n", " * this class may be obtained with {@link #copyOf(BasicGraph)}.\n", " *\n", " * <p>This class generally provides all of the same guarantees as {@link ImmutableCollection}\n", " * (despite not extending {@link ImmutableCollection} itself), including guaranteed thread-safety.\n", " *\n", " * @author James Sexton\n", " * @author Joshua O'Madadhain\n", " * @author Omar Darwish\n", " * @param <N> Node parameter type\n", " * @since 20.0\n", " */\n", "@Beta\n", "public class ImmutableBasicGraph<N> extends ImmutableGraph<N, Presence> implements BasicGraph<N> {\n", "\n", "  /** To ensure the immutability contract is maintained, there must be no public constructors. */\n", "  private ImmutableBasicGraph(BasicGraph<N> graph) {\n", "    super(graph);\n", "  }\n", "\n", "  /** Returns an immutable copy of {@code graph}. */\n", "  public static <N> ImmutableBasicGraph<N> copyOf(BasicGraph<N> graph) {\n", "    return (graph instanceof ImmutableBasicGraph)\n", "        ? (ImmutableBasicGraph<N>) graph\n", "        : new ImmutableBasicGraph<N>(graph);\n", "  }\n", "\n", "  /**\n", "   * Simply returns its argument.\n", "   *\n", "   * @deprecated no need to use this\n", "   */\n", "  @Deprecated\n", "  public static <N> ImmutableBasicGraph<N> copyOf(ImmutableBasicGraph<N> graph) {\n", "    return checkNotNull(graph);\n", "  }\n", "}\n"]}, "added_lines": {}, "removed_lines": {"1": [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 58, 59, 60, 61, 62]}}, {"42": "guava/src/com/google/common/graph/ImmutableGraph.java", "added": {"1": [" * Copyright (C) 2014 The Guava Authors\n"], "2": ["import com.google.common.base.Functions;\n", "import com.google.common.graph.GraphConstants.Presence;\n"], "3": [" * @author Joshua O'Madadhain\n", " * @author Omar Darwish\n", "public abstract class ImmutableGraph<N> extends ForwardingGraph<N> {\n", "  ImmutableGraph() {}\n", "  public static <N> ImmutableGraph<N> copyOf(Graph<N> graph) {\n", "        ? (ImmutableGraph<N>) graph\n", "        : new ValueBackedImpl<N, Presence>(\n", "            GraphBuilder.from(graph), getNodeConnections(graph), graph.edges().size());\n"], "4": ["  public static <N> ImmutableGraph<N> copyOf(ImmutableGraph<N> graph) {\n", "  private static <N> ImmutableMap<N, GraphConnections<N, Presence>> getNodeConnections(\n", "      Graph<N> graph) {\n", "    ImmutableMap.Builder<N, GraphConnections<N, Presence>> nodeConnections = ImmutableMap.builder();\n", "  private static <N> GraphConnections<N, Presence> connectionsOf(Graph<N> graph, N node) {\n", "    Function<Object, Presence> edgeValueFn = Functions.constant(Presence.EDGE_EXISTS);\n", "            graph.predecessors(node), Maps.asMap(graph.successors(node), edgeValueFn))\n", "            Maps.asMap(graph.adjacentNodes(node), edgeValueFn));\n", "  static class ValueBackedImpl<N, V> extends ImmutableGraph<N> {\n", "    protected final ConfigurableValueGraph<N, V> backingGraph;\n", "\n", "    ValueBackedImpl(\n", "        AbstractGraphBuilder<? super N> builder,\n", "        ImmutableMap<N, GraphConnections<N, V>> nodeConnections,\n", "        long edgeCount) {\n", "      this.backingGraph = new ConfigurableValueGraph<N, V>(builder, nodeConnections, edgeCount);\n", "    }\n", "\n", "    @Override\n", "    protected Graph<N> delegate() {\n", "      return backingGraph;\n", "    }\n"]}, "removed": {"1": [" * Copyright (C) 2016 The Guava Authors\n"], "2": ["import static com.google.common.graph.Graphs.checkNonNegative;\n"], "3": [" * @param <V> Value parameter type\n", "public class ImmutableGraph<N, V> extends ConfigurableGraph<N, V> {\n", "  private final long edgeCount;\n", "  ImmutableGraph(Graph<N, V> graph) {\n", "    super(GraphBuilder.from(graph), getNodeConnections(graph));\n", "    this.edgeCount = checkNonNegative(graph.edges().size());\n", "  }\n", "  public static <N, V> ImmutableGraph<N, V> copyOf(Graph<N, V> graph) {\n", "        ? (ImmutableGraph<N, V>) graph\n", "        : new ImmutableGraph<N, V>(graph);\n"], "4": ["  public static <N, V> ImmutableGraph<N, V> copyOf(ImmutableGraph<N, V> graph) {\n", "  private static <N, V> ImmutableMap<N, GraphConnections<N, V>> getNodeConnections(\n", "      Graph<N, V> graph) {\n", "    ImmutableMap.Builder<N, GraphConnections<N, V>> nodeConnections = ImmutableMap.builder();\n", "  private static <N, V> GraphConnections<N, V> connectionsOf(\n", "      final Graph<N, V> graph, final N node) {\n", "    Function<N, V> successorNodeToValueFn =\n", "        new Function<N, V>() {\n", "          @Override\n", "          public V apply(N successorNode) {\n", "            return graph.edgeValue(node, successorNode);\n", "          }\n", "        };\n", "            graph.predecessors(node), Maps.asMap(graph.successors(node), successorNodeToValueFn))\n", "            Maps.asMap(graph.adjacentNodes(node), successorNodeToValueFn));\n", "  @Override\n", "  protected long edgeCount() {\n", "    return edgeCount;\n"]}, "added_lines": {"1": [2], "2": [23, 27], "3": [37, 38, 43, 46, 49, 51, 52, 53], "4": [62, 66, 67, 71, 78, 79, 82, 84, 87, 88, 89, 90, 91, 92, 93, 94, 95, 96, 97, 98, 99, 100]}, "removed_lines": {"1": [2], "2": [20], "3": [37, 41, 42, 45, 46, 47, 48, 51, 53, 54], "4": [63, 67, 68, 72, 79, 80, 81, 82, 83, 84, 85, 86, 87, 90, 92, 95, 96, 97]}}, {"43": "guava/src/com/google/common/graph/ImmutableNetwork.java", "added": {"1": ["public final class ImmutableNetwork<N, E> extends ConfigurableNetwork<N, E> {\n"], "2": ["  @Override\n", "  public ImmutableGraph<N> asGraph() {\n", "    final Graph<N> asGraph = super.asGraph();\n", "    return new ImmutableGraph<N>() {\n", "      @Override\n", "      protected Graph<N> delegate() {\n", "        return asGraph; // safe because the graph view is effectively immutable\n", "      }\n", "    };\n", "  }\n", "\n"], "3": ["      edgeToReferenceNode.put(edge, graph.incidentNodes(edge).nodeU());\n"]}, "removed": {"1": ["public class ImmutableNetwork<N, E> extends ConfigurableNetwork<N, E> {\n", "  /** To ensure the immutability contract is maintained, there must be no public constructors. */\n"], "3": ["      edgeToReferenceNode.put(edge, graph.incidentNodes(edge).nodeA());\n"]}, "added_lines": {"1": [43], "2": [66, 67, 68, 69, 70, 71, 72, 73, 74, 75, 76], "3": [94]}, "removed_lines": {"1": [43, 45], "3": [84]}}, {"44": "guava/src/com/google/common/graph/ImmutableValueGraph.java", "added": {"1": ["/*\n", " * Copyright (C) 2016 The Guava Authors\n", " *\n", " * Licensed under the Apache License, Version 2.0 (the \"License\");\n", " * you may not use this file except in compliance with the License.\n", " * You may obtain a copy of the License at\n", " *\n", " * http://www.apache.org/licenses/LICENSE-2.0\n", " *\n", " * Unless required by applicable law or agreed to in writing, software\n", " * distributed under the License is distributed on an \"AS IS\" BASIS,\n", " * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n", " * See the License for the specific language governing permissions and\n", " * limitations under the License.\n", " */\n", "\n", "package com.google.common.graph;\n", "\n", "import static com.google.common.base.Preconditions.checkArgument;\n", "import static com.google.common.base.Preconditions.checkNotNull;\n", "import static com.google.common.graph.GraphConstants.EDGE_CONNECTING_NOT_IN_GRAPH;\n", "import static com.google.common.graph.GraphConstants.NODE_NOT_IN_GRAPH;\n", "\n", "import com.google.common.annotations.Beta;\n", "import com.google.common.base.Function;\n", "import com.google.common.collect.ImmutableCollection;\n", "import com.google.common.collect.ImmutableMap;\n", "import com.google.common.collect.Maps;\n", "import javax.annotation.Nullable;\n", "\n", "/**\n", " * A {@link ValueGraph} whose elements and structural relationships will never change. Instances of\n", " * this class may be obtained with {@link #copyOf(ValueGraph)}.\n", " *\n", " * <p>This class generally provides all of the same guarantees as {@link ImmutableCollection}\n", " * (despite not extending {@link ImmutableCollection} itself), including guaranteed thread-safety.\n", " *\n", " * @author James Sexton\n", " * @param <N> Node parameter type\n", " * @param <V> Value parameter type\n", " * @since 20.0\n", " */\n", "@Beta\n", "public final class ImmutableValueGraph<N, V> extends ImmutableGraph.ValueBackedImpl<N, V>\n", "    implements ValueGraph<N, V> {\n", "\n", "  private ImmutableValueGraph(ValueGraph<N, V> graph) {\n", "    super(ValueGraphBuilder.from(graph), getNodeConnections(graph), graph.edges().size());\n", "  }\n", "\n", "  /** Returns an immutable copy of {@code graph}. */\n", "  public static <N, V> ImmutableValueGraph<N, V> copyOf(ValueGraph<N, V> graph) {\n", "    return (graph instanceof ImmutableValueGraph)\n", "        ? (ImmutableValueGraph<N, V>) graph\n", "        : new ImmutableValueGraph<N, V>(graph);\n", "  }\n", "\n", "  /**\n", "   * Simply returns its argument.\n", "   *\n", "   * @deprecated no need to use this\n", "   */\n", "  @Deprecated\n", "  public static <N, V> ImmutableValueGraph<N, V> copyOf(ImmutableValueGraph<N, V> graph) {\n", "    return checkNotNull(graph);\n", "  }\n", "\n", "  private static <N, V> ImmutableMap<N, GraphConnections<N, V>> getNodeConnections(\n", "      ValueGraph<N, V> graph) {\n", "    // ImmutableMap.Builder maintains the order of the elements as inserted, so the map will have\n", "    // whatever ordering the graph's nodes do, so ImmutableSortedMap is unnecessary even if the\n", "    // input nodes are sorted.\n", "    ImmutableMap.Builder<N, GraphConnections<N, V>> nodeConnections = ImmutableMap.builder();\n", "    for (N node : graph.nodes()) {\n", "      nodeConnections.put(node, connectionsOf(graph, node));\n", "    }\n", "    return nodeConnections.build();\n", "  }\n", "\n", "  private static <N, V> GraphConnections<N, V> connectionsOf(\n", "      final ValueGraph<N, V> graph, final N node) {\n", "    Function<N, V> successorNodeToValueFn =\n", "        new Function<N, V>() {\n", "          @Override\n", "          public V apply(N successorNode) {\n", "            return graph.edgeValue(node, successorNode);\n", "          }\n", "        };\n", "    return graph.isDirected()\n", "        ? DirectedGraphConnections.ofImmutable(\n", "            graph.predecessors(node), Maps.asMap(graph.successors(node), successorNodeToValueFn))\n", "        : UndirectedGraphConnections.ofImmutable(\n", "            Maps.asMap(graph.adjacentNodes(node), successorNodeToValueFn));\n", "  }\n", "\n", "  // We can't extend ImmutableGraph AND AbstractValueGraph, so the following code is duplicated ;(\n", "\n", "  @Override\n", "  public V edgeValue(Object nodeU, Object nodeV) {\n", "    V value = edgeValueOrDefault(nodeU, nodeV, null);\n", "    checkArgument(value != null, EDGE_CONNECTING_NOT_IN_GRAPH, nodeU, nodeV);\n", "    return value;\n", "  }\n", "\n", "  @Override\n", "  public V edgeValueOrDefault(Object nodeU, Object nodeV, @Nullable V defaultValue) {\n", "    V value = backingGraph.checkedConnections(nodeU).value(nodeV);\n", "    if (value == null) {\n", "      checkArgument(backingGraph.containsNode(nodeV), NODE_NOT_IN_GRAPH, nodeV);\n", "      return defaultValue;\n", "    }\n", "    return value;\n", "  }\n", "\n", "  @Override\n", "  public String toString() {\n", "    return AbstractValueGraph.toString(this);\n", "  }\n", "}\n"]}, "removed": {}, "added_lines": {"1": [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 58, 59, 60, 61, 62, 63, 64, 65, 66, 67, 68, 69, 70, 71, 72, 73, 74, 75, 76, 77, 78, 79, 80, 81, 82, 83, 84, 85, 86, 87, 88, 89, 90, 91, 92, 93, 94, 95, 96, 97, 98, 99, 100, 101, 102, 103, 104, 105, 106, 107, 108, 109, 110, 111, 112, 113, 114, 115, 116, 117, 118, 119]}, "removed_lines": {}}, {"45": "guava/src/com/google/common/graph/MutableGraph.java", "added": {"1": [" * Copyright (C) 2014 The Guava Authors\n"], "2": [" * @author Joshua O'Madadhain\n", "public interface MutableGraph<N> extends Graph<N> {\n"], "3": ["   * Adds an edge connecting {@code nodeU} to {@code nodeV} if one is not already present. In an\n", "   * undirected graph, the edge will also connect {@code nodeV} to {@code nodeU}.\n", "   * <p>Behavior if {@code nodeU} and {@code nodeV} are not already present in this graph is\n", "   * adding} {@code nodeU} and {@code nodeV} to the graph (this is the behavior of the default\n", "   * @return {@code true} iff the graph was modified as a result of this call\n", "  boolean putEdge(N nodeU, N nodeV);\n"], "4": ["   * Removes the edge connecting {@code nodeU} to {@code nodeV}, if it is present.\n", "   * @return {@code true} iff the graph was modified as a result of this call\n", "  boolean removeEdge(Object nodeU, Object nodeV);\n"]}, "removed": {"1": [" * Copyright (C) 2016 The Guava Authors\n"], "2": [" * @param <V> Value parameter type\n", "public interface MutableGraph<N, V> extends Graph<N, V> {\n"], "3": ["   * Adds an edge connecting {@code nodeA} to {@code nodeB} if one is not already present; associate\n", "   * that edge with {@code value}. In an undirected graph, the edge will also connect {@code nodeB}\n", "   * to {@code nodeA}.\n", "   * <p>Values do not have to be unique. However, values must be non-null.\n", "   *\n", "   * <p>Behavior if {@code nodeA} and {@code nodeB} are not already present in this graph is\n", "   * adding} {@code nodeA} and {@code nodeB} to the graph (this is the behavior of the default\n", "   * @return the value previously associated with the edge connecting {@code nodeA} to {@code\n", "   *     nodeB}, or null if there was no such edge.\n", "  V putEdgeValue(N nodeA, N nodeB, V value);\n"], "4": ["   * Removes the edge connecting {@code nodeA} to {@code nodeB}, if it is present.\n", "   * @return the value previously associated with the edge connecting {@code nodeA} to {@code\n", "   *     nodeB}, or null if there was no such edge.\n", "  V removeEdge(Object nodeA, Object nodeB);\n"]}, "added_lines": {"1": [2], "2": [27, 32], "3": [45, 46, 48, 50, 53, 58], "4": [69, 71, 74]}, "removed_lines": {"1": [2], "2": [28, 32], "3": [45, 46, 47, 49, 50, 51, 53, 56, 57, 62], "4": [73, 75, 76, 79]}}, {"46": "guava/src/com/google/common/graph/MutableNetwork.java", "added": {"1": ["   * Adds {@code edge} connecting {@code nodeU} to {@code nodeV}. In an undirected network, the edge\n", "   * will also connect {@code nodeV} to {@code nodeU}.\n", "   * <p>Behavior if {@code nodeU} and {@code nodeV} are not already present in this network is\n", "   * adding} {@code nodeU} and {@code nodeV} to the network (this is the behavior of the default\n", "   * <p>If {@code edge} already connects {@code nodeU} to {@code nodeV} (in the specified order if\n", "   *     nodeU} to {@code nodeV}, or if the introduction of the edge would violate {@link\n", "  boolean addEdge(N nodeU, N nodeV, E edge);\n"]}, "removed": {"1": ["   * Adds {@code edge} connecting {@code nodeA} to {@code nodeB}. In an undirected network, the edge\n", "   * will also connect {@code nodeB} to {@code nodeA}.\n", "   * <p>Behavior if {@code nodeA} and {@code nodeB} are not already present in this network is\n", "   * adding} {@code nodeA} and {@code nodeB} to the network (this is the behavior of the default\n", "   * <p>If {@code edge} already connects {@code nodeA} to {@code nodeB} (in the specified order if\n", "   *     nodeA} to {@code nodeB}, or if the introduction of the edge would violate {@link\n", "  boolean addEdge(N nodeA, N nodeB, E edge);\n"]}, "added_lines": {"1": [46, 47, 51, 53, 56, 61, 65]}, "removed_lines": {"1": [46, 47, 51, 53, 56, 61, 65]}}, {"47": "guava/src/com/google/common/graph/MutableValueGraph.java", "added": {"1": [" * Copyright (C) 2016 The Guava Authors\n"], "2": [" * A subinterface of {@link ValueGraph} which adds mutation methods. When mutation is not required,\n", " * users should prefer the {@link ValueGraph} interface.\n", " * @param <V> Value parameter type\n", "public interface MutableValueGraph<N, V> extends ValueGraph<N, V> {\n"], "3": ["   * Adds an edge connecting {@code nodeU} to {@code nodeV} if one is not already present; associate\n", "   * that edge with {@code value}. In an undirected graph, the edge will also connect {@code nodeV}\n", "   * to {@code nodeU}.\n", "   * <p>Values do not have to be unique. However, values must be non-null.\n", "   *\n", "   * <p>Behavior if {@code nodeU} and {@code nodeV} are not already present in this graph is\n", "   * adding} {@code nodeU} and {@code nodeV} to the graph (this is the behavior of the default\n", "   * @return the value previously associated with the edge connecting {@code nodeU} to {@code\n", "   *     nodeV}, or null if there was no such edge.\n", "  V putEdgeValue(N nodeU, N nodeV, V value);\n"], "4": ["   * Removes the edge connecting {@code nodeU} to {@code nodeV}, if it is present.\n", "   * @return the value previously associated with the edge connecting {@code nodeU} to {@code\n", "   *     nodeV}, or null if there was no such edge.\n", "  V removeEdge(Object nodeU, Object nodeV);\n"]}, "removed": {"1": [" * Copyright (C) 2014 The Guava Authors\n"], "2": [" * A subinterface of {@link BasicGraph} which adds mutation methods. When mutation is not required,\n", " * users should prefer the {@link BasicGraph} interface.\n", " * @author Joshua O'Madadhain\n", "public interface MutableBasicGraph<N> extends BasicGraph<N> {\n"], "3": ["   * Adds an edge connecting {@code nodeA} to {@code nodeB} if one is not already present. In an\n", "   * undirected graph, the edge will also connect {@code nodeB} to {@code nodeA}.\n", "   * <p>Behavior if {@code nodeA} and {@code nodeB} are not already present in this graph is\n", "   * adding} {@code nodeA} and {@code nodeB} to the graph (this is the behavior of the default\n", "   * @return {@code true} iff the graph was modified as a result of this call\n", "  boolean putEdge(N nodeA, N nodeB);\n"], "4": ["   * Removes the edge connecting {@code nodeA} to {@code nodeB}, if it is present.\n", "   * @return {@code true} iff the graph was modified as a result of this call\n", "  boolean removeEdge(Object nodeA, Object nodeB);\n"]}, "added_lines": {"1": [2], "2": [23, 24, 28, 32], "3": [45, 46, 47, 49, 50, 51, 53, 56, 57, 62], "4": [73, 75, 76, 79]}, "removed_lines": {"1": [2], "2": [23, 24, 27, 32], "3": [45, 46, 48, 50, 53, 58], "4": [69, 71, 74]}}, {"48": "guava/src/com/google/common/graph/Network.java", "added": {"1": [" * complexity they are: {@link Graph}, {@link ValueGraph}, and {@link Network}. You should generally\n", " *     <p>Yes: Go to question 2. No: Use {@link Graph}.\n", " *     <p>Yes: Go to question 3. No: Use {@link ValueGraph}.\n", " *     <p>Yes: Use {@link Network}. No: Use {@link ValueGraph}.\n", " * <p>Although {@link MutableValueGraph} and {@link MutableNetwork} both require users to provide\n", " * objects to associate with edges when adding them, the differentiating factor is that in {@link\n", " * ValueGraph}s, these objects can be any arbitrary data. Like the values in a {@link Map}, they do\n", " * not have to be unique, and can be mutated while in the graph. In a {@link Network}, these objects\n", " * serve as keys into the data structure. Like the keys in a {@link Map}, they must be unique, and\n", " * cannot be mutated in a way that affects their equals/hashcode or the data structure will become\n", " * corrupted.\n"], "2": [" *   EndpointPair<String> cities = roadNetwork.incidentNodes(roadToQuery);\n", " *   System.out.format(\"%s and %s connected via %s\", cities.nodeU(), cities.nodeV(), roadToQuery);\n"], "3": ["  Graph<N> asGraph();\n"], "4": ["   * EndpointPair#source() source node} to a {@link EndpointPair#target() target node}, while\n", "   * undirected edges connect a pair of nodes to each other.\n"], "5": ["  EndpointPair<N> incidentNodes(Object edge);\n"], "6": ["   * Returns the set of edges that connect {@code nodeU} to {@code nodeV}.\n", "   * <p>In an undirected network, this is equal to {@code edgesConnecting(nodeV, nodeU)}.\n", "   * @throws IllegalArgumentException if {@code nodeU} or {@code nodeV} is not an element of this\n", "  Set<E> edgesConnecting(Object nodeU, Object nodeV);\n", "   * For the default {@link Network} implementations, returns true iff {@code this == object} (i.e.\n", "   * reference equality). External implementations are free to define this method as they see fit,\n", "   * as long as they satisfy the {@link Object#equals(Object)} contract.\n", "   * <p>To compare two {@link Network}s based on their contents rather than their references, see\n", "   * {@link Graphs#equivalent(Network, Network)}.\n", "   * For the default {@link Network} implementations, returns {@code System.identityHashCode(this)}.\n", "   * External implementations are free to define this method as they see fit, as long as they\n", "   * satisfy the {@link Object#hashCode()} contract.\n"]}, "removed": {"1": [" * complexity they are: {@link BasicGraph}, {@link Graph}, and {@link Network}. You should generally\n", " *     <p>Yes: Go to question 2. No: Use {@link BasicGraph}.\n", " *     <p>Yes: Go to question 3. No: Use {@link Graph}.\n", " *     <p>Yes: Use {@link Network}. No: Use {@link Graph}.\n", " * <p>Although {@link MutableGraph} and {@link MutableNetwork} both require users to provide objects\n", " * to associate with edges when adding them, the differentiating factor is that in {@link Graph}s,\n", " * these objects can be any arbitrary data. Like the values in a {@link Map}, they do not have to be\n", " * unique, and can be mutated while in the graph. In a {@link Network}, these objects serve as keys\n", " * into the data structure. Like the keys in a {@link Map}, they must be unique, and cannot be\n", " * mutated in a way that affects their equals/hashcode or the data structure will become corrupted.\n"], "2": [" *   Endpoints<String> cities = roadNetwork.incidentNodes(roadToQuery);\n", " *   System.out.format(\"%s and %s connected via %s\", cities.nodeA(), cities.nodeB(), roadToQuery);\n"], "3": ["   * <p>{@link Graph#edgeValue(Object, Object)} will return the set of edges connecting node A to\n", "   * node B if the set is non-empty, otherwise, it will throw {@link IllegalArgumentException}.\n", "   *\n", "  Graph<N, Set<E>> asGraph();\n"], "4": ["   * Endpoints#source() source node} to a {@link Endpoints#target() target node}, while undirected\n", "   * edges connect a pair of nodes to each other.\n"], "5": ["  Endpoints<N> incidentNodes(Object edge);\n"], "6": ["   * Returns the set of edges that connect {@code nodeA} to {@code nodeB}.\n", "   * <p>In an undirected network, this is equal to {@code edgesConnecting(nodeB, nodeA)}.\n", "   * @throws IllegalArgumentException if {@code nodeA} or {@code nodeB} is not an element of this\n", "  Set<E> edgesConnecting(Object nodeA, Object nodeB);\n", "   * Returns {@code true} iff {@code object} is a {@link Network} that has the same elements and the\n", "   * same structural relationships as those in this network.\n", "   *\n", "   * <p>Thus, two networks A and B are equal if <b>all</b> of the following are true:\n", "   *\n", "   * <ul>\n", "   * <li>A and B have equal {@link #isDirected() directedness}.\n", "   * <li>A and B have equal {@link #nodes() node sets}.\n", "   * <li>A and B have equal {@link #edges() edge sets}.\n", "   * <li>Every edge in A and B connects the same nodes in the same direction (if any).\n", "   * </ul>\n", "   * <p>Network properties besides {@link #isDirected() directedness} do <b>not</b> affect equality.\n", "   * For example, two networks may be considered equal even if one allows parallel edges and the\n", "   * other doesn't. Additionally, the order in which nodes or edges are added to the network, and\n", "   * the order in which they are iterated over, are irrelevant.\n", "   *\n", "   * <p>A reference implementation of this is provided by {@link AbstractNetwork#equals(Object)}.\n", "   * Returns the hash code for this network. The hash code of a network is defined as the hash code\n", "   * of a map from each of its {@link #edges() edges} to their {@link #incidentNodes(Object)\n", "   * incident nodes}.\n", "   *\n", "   * <p>A reference implementation of this is provided by {@link AbstractNetwork#hashCode()}.\n"]}, "added_lines": {"1": [35, 40, 44, 51, 54, 55, 56, 57, 58, 59, 60], "2": [88, 89], "3": [119], "4": [127, 128], "5": [253], "6": [264, 266, 268, 271, 278, 279, 280, 282, 283, 289, 290, 291]}, "removed_lines": {"1": [35, 40, 44, 51, 54, 55, 56, 57, 58, 59], "2": [87, 88], "3": [114, 115, 116, 121], "4": [129, 130], "5": [255], "6": [266, 268, 270, 273, 280, 281, 282, 283, 284, 285, 286, 287, 288, 289, 290, 292, 293, 294, 295, 296, 297, 303, 304, 305, 306, 307]}}, {"49": "guava/src/com/google/common/graph/NetworkBuilder.java", "added": {"1": [" * MutableNetwork<String, Integer> flightNetwork =\n", " * flightNetwork.addEdge(\"LAX\", \"ATL\", 3025);\n", " * flightNetwork.addEdge(\"LAX\", \"ATL\", 1598);\n", " * flightNetwork.addEdge(\"ATL\", \"LAX\", 2450);\n"]}, "removed": {"1": [" * MutableNetwork<Integer, String> network =\n", " * network.addEdge(1, 2, \"1->2\");\n", " * network.addEdge(1, 2, \"1->2 other\");\n"]}, "added_lines": {"1": [40, 42, 43, 44]}, "removed_lines": {"1": [40, 42, 43]}}, {"50": "guava/src/com/google/common/graph/ValueGraph.java", "added": {"1": ["/*\n", " * Copyright (C) 2016 The Guava Authors\n", " *\n", " * Licensed under the Apache License, Version 2.0 (the \"License\");\n", " * you may not use this file except in compliance with the License.\n", " * You may obtain a copy of the License at\n", " *\n", " * http://www.apache.org/licenses/LICENSE-2.0\n", " *\n", " * Unless required by applicable law or agreed to in writing, software\n", " * distributed under the License is distributed on an \"AS IS\" BASIS,\n", " * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n", " * See the License for the specific language governing permissions and\n", " * limitations under the License.\n", " */\n", "\n", "package com.google.common.graph;\n", "\n", "import com.google.common.annotations.Beta;\n", "import java.util.ConcurrentModificationException;\n", "import java.util.Map;\n", "import java.util.Set;\n", "import javax.annotation.Nullable;\n", "\n", "/**\n", " * An interface for <a href=\"https://en.wikipedia.org/wiki/Graph_(discrete_mathematics)\">graph</a>\n", " * data structures. A graph is composed of a set of nodes (sometimes called vertices) and a set of\n", " * edges connecting pairs of nodes. Graphs are useful for modeling many kinds of relations. If the\n", " * relation to be modeled is symmetric (such as \"distance between cities\"), that can be represented\n", " * with an undirected graph, where an edge that connects node A to node B also connects node B to\n", " * node A. If the relation to be modeled is asymmetric (such as \"employees managed\"), that can be\n", " * represented with a directed graph, where edges are strictly one-way.\n", " *\n", " * <p>There are three main interfaces provided to represent graphs. In order of increasing\n", " * complexity they are: {@link Graph}, {@link ValueGraph}, and {@link Network}. You should generally\n", " * prefer the simplest interface that satisfies your use case.\n", " *\n", " * <p>To choose the right interface, answer these questions:\n", " *\n", " * <ol>\n", " * <li>Do you have data (objects) that you wish to associate with edges?\n", " *     <p>Yes: Go to question 2. No: Use {@link Graph}.\n", " * <li>Are the objects you wish to associate with edges unique within the scope of a graph? That is,\n", " *     no two objects would be {@link Object#equals(Object) equal} to each other. A common example\n", " *     where this would <i>not</i> be the case is with weighted graphs.\n", " *     <p>Yes: Go to question 3. No: Use {@link ValueGraph}.\n", " * <li>Do you need to be able to query the graph for an edge associated with a particular object?\n", " *     For example, do you need to query what nodes an edge associated with a particular object\n", " *     connects, or whether an edge associated with that object exists in the graph?\n", " *     <p>Yes: Use {@link Network}. No: Go to question 4.\n", " * <li>Do you need explicit support for parallel edges? For example, do you need to remove one edge\n", " *     connecting a pair of nodes while leaving other edges connecting those same nodes intact?\n", " *     <p>Yes: Use {@link Network}. No: Use {@link ValueGraph}.\n", " * </ol>\n", " *\n", " * <p>Although {@link MutableValueGraph} and {@link MutableNetwork} both require users to provide\n", " * objects to associate with edges when adding them, the differentiating factor is that in {@link\n", " * ValueGraph}s, these objects can be any arbitrary data. Like the values in a {@link Map}, they do\n", " * not have to be unique, and can be mutated while in the graph. In a {@link Network}, these objects\n", " * serve as keys into the data structure. Like the keys in a {@link Map}, they must be unique, and\n", " * cannot be mutated in a way that affects their equals/hashcode or the data structure will become\n", " * corrupted.\n", " *\n", " * <p>In all three interfaces, nodes have all the same requirements as keys in a {@link Map}.\n", " *\n", " * <p>The {@link Graph} interface does not support parallel {@link #edges()}, and forbids\n", " * implementations or extensions with parallel edges. It is possible to encode a notion of edge\n", " * multiplicity into the values of a {@ValueGraph} (e.g. with an integer or a list of values), but\n", " * this will not be reflected in methods such as {@link Graph#degree(Object)}. For that\n", " * functionality, use {@link Network}s.\n", " *\n", " * <p>All mutation methods live on the subinterface {@link MutableValueGraph}. If you do not need to\n", " * mutate a graph (e.g. if you write a method than runs a read-only algorithm on the graph), you\n", " * should prefer the non-mutating {@link ValueGraph} interface.\n", " *\n", " * <p>We provide an efficient implementation of this interface via {@link ValueGraphBuilder}. When\n", " * using the implementation provided, all {@link Set}-returning methods provide live, unmodifiable\n", " * views of the graph. In other words, you cannot add an element to the {@link Set}, but if an\n", " * element is added to the {@link ValueGraph} that would affect the result of that set, it will be\n", " * updated automatically. This also means that you cannot modify a {@link ValueGraph} in a way that\n", " * would affect a {#link Set} while iterating over that set. For example, you cannot remove the\n", " * nodes from a {@link ValueGraph} while iterating over {@link #nodes} (unless you first make a copy\n", " * of the nodes), just as you could not remove the keys from a {@link Map} while iterating over its\n", " * {@link Map#keySet()}. This will either throw a {@link ConcurrentModificationException} or risk\n", " * undefined behavior.\n", " *\n", " * <p>Example of use:\n", " *\n", " * <pre><code>\n", " * MutableGraph<String, Double> synonymGraph = GraphBuilder.undirected().build();\n", " * synonymGraph.putEdgeValue(\"large\", \"big\", 0.9);\n", " * synonymGraph.putEdgeValue(\"large\", \"huge\", 0.9);\n", " * synonymGraph.putEdgeValue(\"large\", \"grand\", 0.6);\n", " * synonymGraph.putEdgeValue(\"large\", \"cold\", 0.0);\n", " * synonymGraph.putEdgeValue(\"large\", \"small\", -1.0);\n", " * for (String word : synonymGraph.adjacentNodes(\"large\")) {\n", " *   if (synonymGraph.edgeValue(word, \"large\") > 0.5) {\n", " *     System.out.println(word + \" is a synonym for large\");\n", " *   }\n", " * }\n", " * </code></pre>\n", " *\n", " * @author James Sexton\n", " * @param <N> Node parameter type\n", " * @param <V> Value parameter type\n", " * @since 20.0\n", " */\n", "@Beta\n", "public interface ValueGraph<N, V> extends Graph<N> {\n", "\n", "  /**\n", "   * If there is an edge connecting {@code nodeU} to {@code nodeV}, returns the non-null value\n", "   * associated with that edge.\n", "   *\n", "   * <p>In an undirected graph, this is equal to {@code edgeValue(nodeV, nodeU)}.\n", "   *\n", "   * @throws IllegalArgumentException if there is no edge connecting {@code nodeU} to {@code nodeV},\n", "   *     or if {@code nodeU} or {@code nodeV} is not an element of this graph\n", "   */\n", "  V edgeValue(Object nodeU, Object nodeV);\n", "\n", "  /**\n", "   * If there is an edge connecting {@code nodeU} to {@code nodeV}, returns the non-null value\n", "   * associated with that edge; otherwise, returns {@code defaultValue}.\n", "   *\n", "   * <p>In an undirected graph, this is equal to {@code edgeValueOrDefault(nodeV, nodeU,\n", "   * defaultValue)}.\n", "   *\n", "   * @throws IllegalArgumentException if {@code nodeU} or {@code nodeV} is not an element of this\n", "   *     graph\n", "   */\n", "  V edgeValueOrDefault(Object nodeU, Object nodeV, @Nullable V defaultValue);\n", "\n", "  //\n", "  // ValueGraph identity\n", "  //\n", "\n", "  /**\n", "   * For the default {@link ValueGraph} implementations, returns true iff {@code this == object}\n", "   * (i.e. reference equality). External implementations are free to define this method as they see\n", "   * fit, as long as they satisfy the {@link Object#equals(Object)} contract.\n", "   *\n", "   * <p>To compare two {@link ValueGraph}s based on their contents rather than their references, see\n", "   * {@link Graphs#equivalent(ValueGraph, ValueGraph)}.\n", "   */\n", "  @Override\n", "  boolean equals(@Nullable Object object);\n", "\n", "  /**\n", "   * For the default {@link ValueGraph} implementations, returns {@code\n", "   * System.identityHashCode(this)}. External implementations are free to define this method as they\n", "   * see fit, as long as they satisfy the {@link Object#hashCode()} contract.\n", "   */\n", "  @Override\n", "  int hashCode();\n", "}\n"]}, "removed": {}, "added_lines": {"1": [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 58, 59, 60, 61, 62, 63, 64, 65, 66, 67, 68, 69, 70, 71, 72, 73, 74, 75, 76, 77, 78, 79, 80, 81, 82, 83, 84, 85, 86, 87, 88, 89, 90, 91, 92, 93, 94, 95, 96, 97, 98, 99, 100, 101, 102, 103, 104, 105, 106, 107, 108, 109, 110, 111, 112, 113, 114, 115, 116, 117, 118, 119, 120, 121, 122, 123, 124, 125, 126, 127, 128, 129, 130, 131, 132, 133, 134, 135, 136, 137, 138, 139, 140, 141, 142, 143, 144, 145, 146, 147, 148, 149, 150, 151, 152, 153, 154, 155, 156]}, "removed_lines": {}}, {"51": "guava/src/com/google/common/graph/ValueGraphBuilder.java", "added": {"1": [" * A builder for constructing instances of {@link MutableValueGraph} with user-defined properties.\n"], "2": [" * MutableGraph<String, Double> graph = GraphBuilder.undirected().allowsSelfLoops(true).build();\n", " * graph.putEdgeValue(\"San Francisco\", \"San Francisco\", 0.0);\n", " * graph.putEdgeValue(\"San Jose\", \"San Jose\", 0.0);\n", " * graph.putEdgeValue(\"San Francisco\", \"San Jose\", 48.4);\n"], "3": ["public final class ValueGraphBuilder<N, V> extends AbstractGraphBuilder<N> {\n", "  private ValueGraphBuilder(boolean directed) {\n", "  /** Returns a {@link ValueGraphBuilder} for building directed graphs. */\n", "  public static ValueGraphBuilder<Object, Object> directed() {\n", "    return new ValueGraphBuilder<Object, Object>(true);\n", "  /** Returns a {@link ValueGraphBuilder} for building undirected graphs. */\n", "  public static ValueGraphBuilder<Object, Object> undirected() {\n", "    return new ValueGraphBuilder<Object, Object>(false);\n", "   * Returns a {@link ValueGraphBuilder} initialized with all properties queryable from {@code\n", "  public static <N> ValueGraphBuilder<N, Object> from(Graph<N> graph) {\n", "    return new ValueGraphBuilder<N, Object>(graph.isDirected())\n"], "4": ["  public ValueGraphBuilder<N, V> allowsSelfLoops(boolean allowsSelfLoops) {\n"], "5": ["  public ValueGraphBuilder<N, V> expectedNodeCount(int expectedNodeCount) {\n"], "6": ["  public <N1 extends N> ValueGraphBuilder<N1, V> nodeOrder(ElementOrder<N1> nodeOrder) {\n", "    ValueGraphBuilder<N1, V> newBuilder = cast();\n", "   * Returns an empty {@link MutableValueGraph} with the properties of this {@link\n", "   * ValueGraphBuilder}.\n", "  public <N1 extends N, V1 extends V> MutableValueGraph<N1, V1> build() {\n", "    return new ConfigurableMutableValueGraph<N1, V1>(this);\n", "  private <N1 extends N, V1 extends V> ValueGraphBuilder<N1, V1> cast() {\n", "    return (ValueGraphBuilder<N1, V1>) this;\n"]}, "removed": {"1": [" * A builder for constructing instances of {@link MutableBasicGraph} with user-defined properties.\n"], "2": [" * MutableBasicGraph<String> graph = BasicGraphBuilder.undirected().allowsSelfLoops(true).build();\n", " * graph.putEdge(\"bread\", \"bread\");\n", " * graph.putEdge(\"chocolate\", \"peanut butter\");\n", " * graph.putEdge(\"peanut butter\", \"jelly\");\n"], "3": ["public final class BasicGraphBuilder<N> extends AbstractGraphBuilder<N> {\n", "  private BasicGraphBuilder(boolean directed) {\n", "  /** Returns a {@link BasicGraphBuilder} for building directed graphs. */\n", "  public static BasicGraphBuilder<Object> directed() {\n", "    return new BasicGraphBuilder<Object>(true);\n", "  /** Returns a {@link BasicGraphBuilder} for building undirected graphs. */\n", "  public static BasicGraphBuilder<Object> undirected() {\n", "    return new BasicGraphBuilder<Object>(false);\n", "   * Returns a {@link BasicGraphBuilder} initialized with all properties queryable from {@code\n", "  public static <N> BasicGraphBuilder<N> from(Graph<N, ?> graph) {\n", "    return new BasicGraphBuilder<Object>(graph.isDirected())\n"], "4": ["  public BasicGraphBuilder<N> allowsSelfLoops(boolean allowsSelfLoops) {\n"], "5": ["  public BasicGraphBuilder<N> expectedNodeCount(int expectedNodeCount) {\n"], "6": ["  public <N1 extends N> BasicGraphBuilder<N1> nodeOrder(ElementOrder<N1> nodeOrder) {\n", "    BasicGraphBuilder<N1> newBuilder = cast();\n", "   * Returns an empty {@link MutableBasicGraph} with the properties of this {@link\n", "   * BasicGraphBuilder}.\n", "  public <N1 extends N> MutableBasicGraph<N1> build() {\n", "    return new ConfigurableMutableBasicGraph<N1>(this);\n", "  private <N1 extends N> BasicGraphBuilder<N1> cast() {\n", "    return (BasicGraphBuilder<N1>) this;\n"]}, "added_lines": {"1": [26], "2": [38, 39, 40, 41], "3": [49, 52, 56, 57, 58, 61, 62, 63, 67, 74, 76], "4": [86], "5": [96], "6": [106, 108, 114, 115, 117, 118, 122, 123]}, "removed_lines": {"1": [26], "2": [38, 39, 40, 41], "3": [49, 52, 56, 57, 58, 61, 62, 63, 67, 74, 76], "4": [86], "5": [96], "6": [106, 108, 114, 115, 117, 118, 122, 123]}}]}
