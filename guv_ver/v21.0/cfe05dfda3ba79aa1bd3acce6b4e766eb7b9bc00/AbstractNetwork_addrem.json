{
    "addition": {
        "35": " * this class rather than implement {@link Network} directly.\n",
        "46": "  public Graph<N> asGraph() {\n",
        "47": "    return new AbstractGraph<N>() {\n",
        "54": "      public Set<EndpointPair<N>> edges() {\n",
        "59": "        // Optimized implementation assumes no parallel edges (1:1 edge to EndpointPair mapping).\n",
        "60": "        return new AbstractSet<EndpointPair<N>>() {\n",
        "62": "          public Iterator<EndpointPair<N>> iterator() {\n",
        "65": "                new Function<E, EndpointPair<N>>() {\n",
        "67": "                  public EndpointPair<N> apply(E edge) {\n",
        "80": "            if (!(obj instanceof EndpointPair)) {\n",
        "83": "            EndpointPair<?> endpointPair = (EndpointPair<?>) obj;\n",
        "84": "            return isDirected() == endpointPair.isOrdered()\n",
        "85": "                && nodes().contains(endpointPair.nodeU())\n",
        "86": "                && successors(endpointPair.nodeU()).contains(endpointPair.nodeV());\n",
        "121": "      // DO NOT override the AbstractGraph *degree() implementations.\n",
        "146": "    EndpointPair<?> endpointPair = incidentNodes(edge); // Verifies that edge is in this network.\n",
        "147": "    Set<E> endpointPairIncidentEdges =\n",
        "148": "        Sets.union(incidentEdges(endpointPair.nodeU()), incidentEdges(endpointPair.nodeV()));\n",
        "149": "    return Sets.difference(endpointPairIncidentEdges, ImmutableSet.of(edge));\n",
        "163": "        edgeIncidentNodesMap());\n",
        "166": "  private Map<E, EndpointPair<N>> edgeIncidentNodesMap() {\n",
        "167": "    Function<E, EndpointPair<N>> edgeToIncidentNodesFn = new Function<E, EndpointPair<N>>() {\n",
        "169": "      public EndpointPair<N> apply(E edge) {\n",
        "173": "    return Maps.asMap(edges(), edgeToIncidentNodesFn);\n"
    },
    "removed": {
        "19": "import static com.google.common.base.Preconditions.checkArgument;\n",
        "20": "import static com.google.common.graph.GraphConstants.EDGE_CONNECTING_NOT_IN_GRAPH;\n",
        "34": "import javax.annotation.Nullable;\n",
        "38": " * this class rather than implement {@link Network} directly, to ensure consistent {@link\n",
        "39": " * #equals(Object)} and {@link #hashCode()} results across different network implementations.\n",
        "50": "  public Graph<N, Set<E>> asGraph() {\n",
        "51": "    return new AbstractGraph<N, Set<E>>() {\n",
        "58": "      public Set<Endpoints<N>> edges() {\n",
        "63": "        // Optimized implementation assumes no parallel edges (1:1 edge to Endpoints mapping).\n",
        "64": "        return new AbstractSet<Endpoints<N>>() {\n",
        "66": "          public Iterator<Endpoints<N>> iterator() {\n",
        "69": "                new Function<E, Endpoints<N>>() {\n",
        "71": "                  public Endpoints<N> apply(E edge) {\n",
        "84": "            if (!(obj instanceof Endpoints)) {\n",
        "87": "            Endpoints<?> endpoints = (Endpoints<?>) obj;\n",
        "88": "            return isDirected() == endpoints.isDirected()\n",
        "89": "                && !edgesConnecting(endpoints.nodeA(), endpoints.nodeB()).isEmpty();\n",
        "124": "      @Override\n",
        "125": "      public Set<E> edgeValue(Object nodeA, Object nodeB) {\n",
        "126": "        Set<E> edges = edgesConnecting(nodeA, nodeB);\n",
        "127": "        checkArgument(!edges.isEmpty(), EDGE_CONNECTING_NOT_IN_GRAPH, nodeA, nodeB);\n",
        "128": "        return edges;\n",
        "129": "      }\n",
        "130": "\n",
        "131": "      @Override\n",
        "132": "      public Set<E> edgeValueOrDefault(Object nodeA, Object nodeB, Set<E> defaultValue) {\n",
        "133": "        Set<E> edges = edgesConnecting(nodeA, nodeB);\n",
        "134": "        return edges.isEmpty() ? defaultValue : edges;\n",
        "135": "      }\n",
        "160": "    Endpoints<?> endpoints = incidentNodes(edge); // Verifies that edge is in this network.\n",
        "161": "    Set<E> endpointsIncidentEdges =\n",
        "162": "        Sets.union(incidentEdges(endpoints.nodeA()), incidentEdges(endpoints.nodeB()));\n",
        "163": "    return Sets.difference(endpointsIncidentEdges, ImmutableSet.of(edge));\n",
        "164": "  }\n",
        "165": "\n",
        "166": "  @Override\n",
        "167": "  public final boolean equals(@Nullable Object obj) {\n",
        "168": "    if (obj == this) {\n",
        "169": "      return true;\n",
        "170": "    }\n",
        "171": "    if (!(obj instanceof Network)) {\n",
        "172": "      return false;\n",
        "173": "    }\n",
        "174": "    Network<?, ?> other = (Network<?, ?>) obj;\n",
        "175": "\n",
        "176": "    if (isDirected() != other.isDirected()\n",
        "177": "        || !nodes().equals(other.nodes())\n",
        "178": "        || !edges().equals(other.edges())) {\n",
        "179": "      return false;\n",
        "180": "    }\n",
        "181": "\n",
        "182": "    for (E edge : edges()) {\n",
        "183": "      if (!incidentNodes(edge).equals(other.incidentNodes(edge))) {\n",
        "184": "        return false;\n",
        "185": "      }\n",
        "186": "    }\n",
        "187": "\n",
        "188": "    return true;\n",
        "189": "  }\n",
        "190": "\n",
        "191": "  @Override\n",
        "192": "  public final int hashCode() {\n",
        "193": "    return edgeEndpointsMap().hashCode();\n",
        "207": "        edgeEndpointsMap());\n",
        "210": "  private Map<E, Endpoints<N>> edgeEndpointsMap() {\n",
        "211": "    Function<E, Endpoints<N>> edgeToEndpointsFn = new Function<E, Endpoints<N>>() {\n",
        "213": "      public Endpoints<N> apply(E edge) {\n",
        "217": "    return Maps.asMap(edges(), edgeToEndpointsFn);\n"
    }
}