{
    "addition": {
        "19": "import com.google.common.graph.GraphConstants.Presence;\n",
        "22": " * Configurable implementation of {@link MutableGraph} that supports both directed and\n",
        "23": " * undirected graphs. Instances of this class should be constructed with {@link GraphBuilder}.\n",
        "31": "final class ConfigurableMutableGraph<N>\n",
        "32": "    extends ForwardingGraph<N> implements MutableGraph<N> {\n",
        "33": "  private final MutableValueGraph<N, Presence> backingGraph;\n",
        "36": "   * Constructs a {@link MutableGraph} with the properties specified in {@code builder}.\n",
        "39": "    this.backingGraph = new ConfigurableMutableValueGraph<N, Presence>(builder);\n",
        "43": "  protected Graph<N> delegate() {\n",
        "44": "    return backingGraph;\n",
        "49": "    return backingGraph.addNode(node);\n",
        "53": "  public boolean putEdge(N nodeU, N nodeV) {\n",
        "54": "    return backingGraph.putEdgeValue(nodeU, nodeV, Presence.EDGE_EXISTS) == null;\n",
        "59": "    return backingGraph.removeNode(node);\n",
        "63": "  public boolean removeEdge(Object nodeU, Object nodeV) {\n",
        "64": "    return backingGraph.removeEdge(nodeU, nodeV) != null;\n"
    },
    "removed": {
        "19": "import static com.google.common.base.Preconditions.checkArgument;\n",
        "20": "import static com.google.common.base.Preconditions.checkNotNull;\n",
        "21": "import static com.google.common.base.Preconditions.checkState;\n",
        "22": "import static com.google.common.graph.GraphConstants.SELF_LOOPS_NOT_ALLOWED;\n",
        "23": "import static com.google.common.graph.Graphs.checkNonNegative;\n",
        "24": "import static com.google.common.graph.Graphs.checkPositive;\n",
        "25": "\n",
        "26": "import com.google.errorprone.annotations.CanIgnoreReturnValue;\n",
        "29": " * Configurable implementation of {@link MutableGraph} that supports both directed and undirected\n",
        "30": " * graphs. Instances of this class should be constructed with {@link GraphBuilder}.\n",
        "36": " * @author Joshua O'Madadhain\n",
        "37": " * @author Omar Darwish\n",
        "39": " * @param <V> Value parameter type\n",
        "41": "final class ConfigurableMutableGraph<N, V>\n",
        "42": "    extends ConfigurableGraph<N, V> implements MutableGraph<N, V> {\n",
        "43": "  private long edgeCount = 0L; // must be updated when edges are added or removed\n",
        "46": "   * Constructs a mutable graph with the properties specified in {@code builder}.\n",
        "49": "    super(builder);\n",
        "53": "  protected long edgeCount() {\n",
        "54": "    return edgeCount;\n",
        "58": "  @CanIgnoreReturnValue\n",
        "60": "    checkNotNull(node, \"node\");\n",
        "61": "\n",
        "62": "    if (containsNode(node)) {\n",
        "63": "      return false;\n",
        "64": "    }\n",
        "65": "\n",
        "66": "    addNodeInternal(node);\n",
        "67": "    return true;\n",
        "68": "  }\n",
        "69": "\n",
        "70": "  /**\n",
        "71": "   * Adds {@code node} to the graph and returns the associated {@link GraphConnections}.\n",
        "72": "   *\n",
        "73": "   * @throws IllegalStateException if {@code node} is already present\n",
        "74": "   */\n",
        "75": "  @CanIgnoreReturnValue\n",
        "76": "  private GraphConnections<N, V> addNodeInternal(N node) {\n",
        "77": "    GraphConnections<N, V> connections = newConnections();\n",
        "78": "    checkState(nodeConnections.put(node, connections) == null);\n",
        "79": "    return connections;\n",
        "83": "  @CanIgnoreReturnValue\n",
        "84": "  public V putEdgeValue(N nodeA, N nodeB, V value) {\n",
        "85": "    checkNotNull(nodeA, \"nodeA\");\n",
        "86": "    checkNotNull(nodeB, \"nodeB\");\n",
        "87": "    checkNotNull(value, \"value\");\n",
        "88": "\n",
        "89": "    GraphConnections<N, V> connectionsA = nodeConnections.get(nodeA);\n",
        "90": "    boolean isSelfLoop = nodeA.equals(nodeB);\n",
        "91": "    if (!allowsSelfLoops()) {\n",
        "92": "      checkArgument(!isSelfLoop, SELF_LOOPS_NOT_ALLOWED, nodeA);\n",
        "93": "    }\n",
        "94": "\n",
        "95": "    if (connectionsA == null) {\n",
        "96": "      connectionsA = addNodeInternal(nodeA);\n",
        "97": "    }\n",
        "98": "    V previousValue = connectionsA.addSuccessor(nodeB, value);\n",
        "99": "    GraphConnections<N, V> connectionsB = nodeConnections.get(nodeB);\n",
        "100": "    if (connectionsB == null) {\n",
        "101": "      connectionsB = addNodeInternal(nodeB);\n",
        "102": "    }\n",
        "103": "    connectionsB.addPredecessor(nodeA, value);\n",
        "104": "    if (previousValue == null) {\n",
        "105": "      checkPositive(++edgeCount);\n",
        "106": "    }\n",
        "107": "    return previousValue;\n",
        "111": "  @CanIgnoreReturnValue\n",
        "113": "    checkNotNull(node, \"node\");\n",
        "114": "\n",
        "115": "    GraphConnections<N, V> connections = nodeConnections.get(node);\n",
        "116": "    if (connections == null) {\n",
        "117": "      return false;\n",
        "118": "    }\n",
        "119": "\n",
        "120": "    if (allowsSelfLoops()) {\n",
        "121": "      // Remove self-loop (if any) first, so we don't get CME while removing incident edges.\n",
        "122": "      if (connections.removeSuccessor(node) != null) {\n",
        "123": "        connections.removePredecessor(node);\n",
        "124": "        --edgeCount;\n",
        "125": "      }\n",
        "126": "    }\n",
        "127": "\n",
        "128": "    for (N successor : connections.successors()) {\n",
        "129": "      nodeConnections.getWithoutCaching(successor).removePredecessor(node);\n",
        "130": "      --edgeCount;\n",
        "131": "    }\n",
        "132": "    if (isDirected()) { // In undirected graphs, the successor and predecessor sets are equal.\n",
        "133": "      for (N predecessor : connections.predecessors()) {\n",
        "134": "        checkState(nodeConnections.getWithoutCaching(predecessor).removeSuccessor(node) != null);\n",
        "135": "        --edgeCount;\n",
        "136": "      }\n",
        "137": "    }\n",
        "138": "    nodeConnections.remove(node);\n",
        "139": "    checkNonNegative(edgeCount);\n",
        "140": "    return true;\n",
        "144": "  @CanIgnoreReturnValue\n",
        "145": "  public V removeEdge(Object nodeA, Object nodeB) {\n",
        "146": "    checkNotNull(nodeA, \"nodeA\");\n",
        "147": "    checkNotNull(nodeB, \"nodeB\");\n",
        "148": "\n",
        "149": "    GraphConnections<N, V> connectionsA = nodeConnections.get(nodeA);\n",
        "150": "    GraphConnections<N, V> connectionsB = nodeConnections.get(nodeB);\n",
        "151": "    if (connectionsA == null || connectionsB == null) {\n",
        "152": "      return null;\n",
        "153": "    }\n",
        "154": "\n",
        "155": "    V previousValue = connectionsA.removeSuccessor(nodeB);\n",
        "156": "    if (previousValue != null) {\n",
        "157": "      connectionsB.removePredecessor(nodeA);\n",
        "158": "      checkNonNegative(--edgeCount);\n",
        "159": "    }\n",
        "160": "    return previousValue;\n",
        "161": "  }\n",
        "162": "\n",
        "163": "  private GraphConnections<N, V> newConnections() {\n",
        "164": "    return isDirected()\n",
        "165": "        ? DirectedGraphConnections.<N, V>of()\n",
        "166": "        : UndirectedGraphConnections.<N, V>of();\n"
    }
}