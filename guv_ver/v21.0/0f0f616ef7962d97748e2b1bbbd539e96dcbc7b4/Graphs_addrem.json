{
    "addition": {
        "19": "import static com.google.common.base.Preconditions.checkArgument;\n",
        "24": "import com.google.common.collect.ImmutableList;\n",
        "28": "import java.util.ArrayDeque;\n",
        "30": "import java.util.Collections;\n",
        "31": "import java.util.HashSet;\n",
        "32": "import java.util.Queue;\n",
        "49": "  /**\n",
        "50": "   * Returns the transitive closure of {@code graph}. The transitive closure of a graph is another\n",
        "51": "   * graph with an edge connecting node A to node B iff node B is {@link #reachableNodes(Graph,\n",
        "52": "   * Object) reachable} from node A.\n",
        "53": "   *\n",
        "54": "   * <p>This is a \"snapshot\" based on the current topology of {@code graph}, rather than a live\n",
        "55": "   * view of the transitive closure of {@code graph}. In other words, the returned {@link Graph}\n",
        "56": "   * will not be updated after modifications to {@code graph}.\n",
        "57": "   */\n",
        "58": "  public static <N> Graph<N> transitiveClosure(Graph<N> graph) {\n",
        "59": "    MutableGraph<N> transitiveClosure = GraphBuilder.from(graph).allowsSelfLoops(true).build();\n",
        "60": "    // Every node is, at a minimum, reachable from itself. Since the resulting transitive closure\n",
        "61": "    // will have no isolated nodes, we can skip adding nodes explicitly and let putEdge() do it.\n",
        "62": "\n",
        "63": "    if (graph.isDirected()) {\n",
        "64": "      // Note: works for both directed and undirected graphs, but we only use in the directed case.\n",
        "65": "      for (N node : graph.nodes()) {\n",
        "66": "        for (N reachableNode : reachableNodes(graph, node)) {\n",
        "67": "          transitiveClosure.putEdge(node, reachableNode);\n",
        "68": "        }\n",
        "69": "      }\n",
        "70": "    } else {\n",
        "71": "      // An optimization for the undirected case: for every node B reachable from node A,\n",
        "72": "      // node A and node B have the same reachability set.\n",
        "73": "      Set<N> visitedNodes = new HashSet<N>();\n",
        "74": "      for (N node : graph.nodes()) {\n",
        "75": "        if (!visitedNodes.contains(node)) {\n",
        "76": "          ImmutableList<N> reachableNodes = ImmutableList.copyOf(reachableNodes(graph, node));\n",
        "77": "          visitedNodes.addAll(reachableNodes);\n",
        "78": "          for (int a = 0; a < reachableNodes.size(); ++a) {\n",
        "79": "            N nodeA = reachableNodes.get(a);\n",
        "80": "            for (int b = a; b < reachableNodes.size(); ++b) {\n",
        "81": "              N nodeB = reachableNodes.get(b);\n",
        "82": "              transitiveClosure.putEdge(nodeA, nodeB);\n",
        "83": "            }\n",
        "84": "          }\n",
        "85": "        }\n",
        "86": "      }\n",
        "87": "    }\n",
        "88": "\n",
        "89": "    return transitiveClosure;\n",
        "90": "  }\n",
        "91": "\n",
        "92": "  /**\n",
        "93": "   * Returns the set of nodes that are reachable from {@code node}. Node B is defined as reachable\n",
        "94": "   * from node A if there exists a path (a sequence of adjacent outgoing edges) starting at node A\n",
        "95": "   * and ending at node B. Note that a node is always reachable from itself via a zero-length path.\n",
        "96": "   *\n",
        "97": "   * <p>This is a \"snapshot\" based on the current topology of {@code graph}, rather than a live\n",
        "98": "   * view of the set of nodes reachable from {@code node}. In other words, the returned {@link Set}\n",
        "99": "   * will not be updated after modifications to {@code graph}.\n",
        "100": "   *\n",
        "101": "   * @throws IllegalArgumentException if {@code node} is not present in {@code graph}\n",
        "102": "   */\n",
        "103": "  @SuppressWarnings(\"unchecked\") // Throws an exception if node is not an element of graph.\n",
        "104": "  public static <N> Set<N> reachableNodes(Graph<N> graph, Object node) {\n",
        "105": "    checkArgument(graph.nodes().contains(node));\n",
        "106": "    Set<N> visitedNodes = new HashSet<N>();\n",
        "107": "    Queue<N> queuedNodes = new ArrayDeque<N>();\n",
        "108": "    visitedNodes.add((N) node);\n",
        "109": "    queuedNodes.add((N) node);\n",
        "110": "    // Perform a breadth-first traversal rooted at the input node.\n",
        "111": "    while (!queuedNodes.isEmpty()) {\n",
        "112": "      N currentNode = queuedNodes.remove();\n",
        "113": "      for (N successor : graph.successors(currentNode)) {\n",
        "114": "        if (visitedNodes.add(successor)) {\n",
        "115": "          queuedNodes.add(successor);\n",
        "116": "        }\n",
        "117": "      }\n",
        "118": "    }\n",
        "119": "    return Collections.unmodifiableSet(visitedNodes);\n",
        "120": "  }\n",
        "121": "\n"
    },
    "removed": {}
}