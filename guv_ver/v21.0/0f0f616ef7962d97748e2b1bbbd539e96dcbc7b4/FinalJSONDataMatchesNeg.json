[{"func":{"oldfunccode":"","newfunccode":"0f0f616ef7962d97748e2b1bbbd539e96dcbc7b4/Codes_neg/Match_newfunccode_0f0f616ef7962d97748e2b1bbbd539e96dcbc7b4_1.txt","newdoc":" Every node is, at a minimum, reachable from itself. Since the resulting transitive closure\n will have no isolated nodes, we can skip adding nodes explicitly and let putEdge() do it.\n Note: works for both directed and undirected graphs, but we only use in the directed case.\n An optimization for the undirected case: for every node B reachable from node A,\n node A and node B have the same reachability set.\n","newJdoc":"0f0f616ef7962d97748e2b1bbbd539e96dcbc7b4/Codes_neg/Match_newfuncnewJdoc_0f0f616ef7962d97748e2b1bbbd539e96dcbc7b4_1.txt","olddoc":"","oldJdoc":"","path":"/home/pritish/Documents/IP work/guv_ver/v21.0/0f0f616ef7962d97748e2b1bbbd539e96dcbc7b4/Graphs","pathinproj":"guava/src/com/google/common/graph/Graphs.java","addlines":[65,66,67,68,69,70,73,74,75,76,77,78,79,80,81,82,83,84,85,86,87,88,89,90,58,59,62,63],"dellines":[],"addcode":["  public static <N> Graph<N> transitiveClosure(Graph<N> graph) {\n","    MutableGraph<N> transitiveClosure = GraphBuilder.from(graph).allowsSelfLoops(true).build();\n","\n","    if (graph.isDirected()) {\n","      for (N node : graph.nodes()) {\n","        for (N reachableNode : reachableNodes(graph, node)) {\n","          transitiveClosure.putEdge(node, reachableNode);\n","        }\n","      }\n","    } else {\n","      Set<N> visitedNodes = new HashSet<N>();\n","      for (N node : graph.nodes()) {\n","        if (!visitedNodes.contains(node)) {\n","          ImmutableList<N> reachableNodes = ImmutableList.copyOf(reachableNodes(graph, node));\n","          visitedNodes.addAll(reachableNodes);\n","          for (int a = 0; a < reachableNodes.size(); ++a) {\n","            N nodeA = reachableNodes.get(a);\n","            for (int b = a; b < reachableNodes.size(); ++b) {\n","              N nodeB = reachableNodes.get(b);\n","              transitiveClosure.putEdge(nodeA, nodeB);\n","            }\n","          }\n","        }\n","      }\n","    }\n","\n","    return transitiveClosure;\n","  }\n"],"delcode":[],"methodSig":"public static Graph<N> transitiveClosure(Graph<N> graph)"},"doc":{"oldfunccode":"0f0f616ef7962d97748e2b1bbbd539e96dcbc7b4/Codes_neg/Match_olddocfunccode_0f0f616ef7962d97748e2b1bbbd539e96dcbc7b4_1.txt","newfunccode":"0f0f616ef7962d97748e2b1bbbd539e96dcbc7b4/Codes_neg/Match_newdocfunccode_0f0f616ef7962d97748e2b1bbbd539e96dcbc7b4_1.txt","newdoc":"","newJdoc":"0f0f616ef7962d97748e2b1bbbd539e96dcbc7b4/Codes_neg/Match_newdocnewJdoc_0f0f616ef7962d97748e2b1bbbd539e96dcbc7b4_1.txt","olddoc":"","oldJdoc":"0f0f616ef7962d97748e2b1bbbd539e96dcbc7b4/Codes_neg/Match_olddocJdoc_0f0f616ef7962d97748e2b1bbbd539e96dcbc7b4_1.txt","path":"/home/pritish/Documents/IP work/guv_ver/v21.0/0f0f616ef7962d97748e2b1bbbd539e96dcbc7b4/Graph","pathinproj":"guava/src/com/google/common/graph/Graph.java","addlines":[229,230],"dellines":[229],"addcode":["   * edges\". For that functionality, see {@link Graphs#reachableNodes(Graph, Object)} and\n","   * {@link Graphs#transitiveClosure(Graph)}.\n"],"delcode":["   * edges\" (also known as {@code node}'s transitive closure).\n"],"methodSig":" Set<N> successors(Object node)"},"id":1,"flag":1,"commit":"0f0f616ef7962d97748e2b1bbbd539e96dcbc7b4"}]