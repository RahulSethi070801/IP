{"id": "0f0f616ef7962d97748e2b1bbbd539e96dcbc7b4", "code": [{"0": "guava-tests/test/com/google/common/graph/GraphsTest.java", "added": {"1": ["import static com.google.common.graph.Graphs.reachableNodes;\n", "import static com.google.common.graph.Graphs.transitiveClosure;\n"], "2": ["  @Test\n", "  public void transitiveClosure_directedGraph() {\n", "    MutableGraph<Integer> directedGraph = GraphBuilder.directed().allowsSelfLoops(false).build();\n", "    directedGraph.putEdge(N1, N2);\n", "    directedGraph.putEdge(N1, N3);\n", "    directedGraph.putEdge(N2, N3);\n", "    directedGraph.addNode(N4);\n", "\n", "    MutableGraph<Integer> expectedClosure = GraphBuilder.directed().allowsSelfLoops(true).build();\n", "    expectedClosure.putEdge(N1, N1);\n", "    expectedClosure.putEdge(N1, N2);\n", "    expectedClosure.putEdge(N1, N3);\n", "    expectedClosure.putEdge(N2, N2);\n", "    expectedClosure.putEdge(N2, N3);\n", "    expectedClosure.putEdge(N3, N3);\n", "    expectedClosure.putEdge(N4, N4);\n", "\n", "    checkTransitiveClosure(directedGraph, expectedClosure);\n", "  }\n", "\n", "  @Test\n", "  public void transitiveClosure_undirectedGraph() {\n", "    MutableGraph<Integer> undirectedGraph =\n", "        GraphBuilder.undirected().allowsSelfLoops(false).build();\n", "    undirectedGraph.putEdge(N1, N2);\n", "    undirectedGraph.putEdge(N1, N3);\n", "    undirectedGraph.putEdge(N2, N3);\n", "    undirectedGraph.addNode(N4);\n", "\n", "    MutableGraph<Integer> expectedClosure = GraphBuilder.undirected().allowsSelfLoops(true).build();\n", "    expectedClosure.putEdge(N1, N1);\n", "    expectedClosure.putEdge(N1, N2);\n", "    expectedClosure.putEdge(N1, N3);\n", "    expectedClosure.putEdge(N2, N2);\n", "    expectedClosure.putEdge(N2, N3);\n", "    expectedClosure.putEdge(N3, N3);\n", "    expectedClosure.putEdge(N4, N4);\n", "\n", "    checkTransitiveClosure(undirectedGraph, expectedClosure);\n", "  }\n", "\n", "  @Test\n", "  public void transitiveClosure_directedPathGraph() {\n", "    MutableGraph<Integer> directedGraph = GraphBuilder.directed().allowsSelfLoops(false).build();\n", "    directedGraph.putEdge(N1, N2);\n", "    directedGraph.putEdge(N2, N3);\n", "    directedGraph.putEdge(N3, N4);\n", "\n", "    MutableGraph<Integer> expectedClosure = GraphBuilder.directed().allowsSelfLoops(true).build();\n", "    expectedClosure.putEdge(N1, N1);\n", "    expectedClosure.putEdge(N1, N2);\n", "    expectedClosure.putEdge(N1, N3);\n", "    expectedClosure.putEdge(N1, N4);\n", "    expectedClosure.putEdge(N2, N2);\n", "    expectedClosure.putEdge(N2, N3);\n", "    expectedClosure.putEdge(N2, N4);\n", "    expectedClosure.putEdge(N3, N3);\n", "    expectedClosure.putEdge(N3, N4);\n", "    expectedClosure.putEdge(N4, N4);\n", "\n", "    checkTransitiveClosure(directedGraph, expectedClosure);\n", "  }\n", "\n", "  @Test\n", "  public void transitiveClosure_undirectedPathGraph() {\n", "    MutableGraph<Integer> undirectedGraph =\n", "        GraphBuilder.undirected().allowsSelfLoops(false).build();\n", "    undirectedGraph.putEdge(N1, N2);\n", "    undirectedGraph.putEdge(N2, N3);\n", "    undirectedGraph.putEdge(N3, N4);\n", "\n", "    MutableGraph<Integer> expectedClosure = GraphBuilder.undirected().allowsSelfLoops(true).build();\n", "    expectedClosure.putEdge(N1, N1);\n", "    expectedClosure.putEdge(N1, N2);\n", "    expectedClosure.putEdge(N1, N3);\n", "    expectedClosure.putEdge(N1, N4);\n", "    expectedClosure.putEdge(N2, N2);\n", "    expectedClosure.putEdge(N2, N3);\n", "    expectedClosure.putEdge(N2, N4);\n", "    expectedClosure.putEdge(N3, N3);\n", "    expectedClosure.putEdge(N3, N4);\n", "    expectedClosure.putEdge(N4, N4);\n", "\n", "    checkTransitiveClosure(undirectedGraph, expectedClosure);\n", "  }\n", "\n", "  @Test\n", "  public void transitiveClosure_directedCycleGraph() {\n", "    MutableGraph<Integer> directedGraph = GraphBuilder.directed().allowsSelfLoops(false).build();\n", "    directedGraph.putEdge(N1, N2);\n", "    directedGraph.putEdge(N2, N3);\n", "    directedGraph.putEdge(N3, N4);\n", "    directedGraph.putEdge(N4, N1);\n", "\n", "    MutableGraph<Integer> expectedClosure = GraphBuilder.directed().allowsSelfLoops(true).build();\n", "    expectedClosure.putEdge(N1, N1);\n", "    expectedClosure.putEdge(N1, N2);\n", "    expectedClosure.putEdge(N1, N3);\n", "    expectedClosure.putEdge(N1, N4);\n", "    expectedClosure.putEdge(N2, N1);\n", "    expectedClosure.putEdge(N2, N2);\n", "    expectedClosure.putEdge(N2, N3);\n", "    expectedClosure.putEdge(N2, N4);\n", "    expectedClosure.putEdge(N3, N1);\n", "    expectedClosure.putEdge(N3, N2);\n", "    expectedClosure.putEdge(N3, N3);\n", "    expectedClosure.putEdge(N3, N4);\n", "    expectedClosure.putEdge(N4, N1);\n", "    expectedClosure.putEdge(N4, N2);\n", "    expectedClosure.putEdge(N4, N3);\n", "    expectedClosure.putEdge(N4, N4);\n", "\n", "    checkTransitiveClosure(directedGraph, expectedClosure);\n", "  }\n", "\n", "  @Test\n", "  public void transitiveClosure_undirectedCycleGraph() {\n", "    MutableGraph<Integer> undirectedGraph =\n", "        GraphBuilder.undirected().allowsSelfLoops(false).build();\n", "    undirectedGraph.putEdge(N1, N2);\n", "    undirectedGraph.putEdge(N2, N3);\n", "    undirectedGraph.putEdge(N3, N4);\n", "    undirectedGraph.putEdge(N4, N1);\n", "\n", "    MutableGraph<Integer> expectedClosure = GraphBuilder.undirected().allowsSelfLoops(true).build();\n", "    expectedClosure.putEdge(N1, N1);\n", "    expectedClosure.putEdge(N1, N2);\n", "    expectedClosure.putEdge(N1, N3);\n", "    expectedClosure.putEdge(N1, N4);\n", "    expectedClosure.putEdge(N2, N2);\n", "    expectedClosure.putEdge(N2, N3);\n", "    expectedClosure.putEdge(N2, N4);\n", "    expectedClosure.putEdge(N3, N3);\n", "    expectedClosure.putEdge(N3, N4);\n", "    expectedClosure.putEdge(N4, N4);\n", "\n", "    checkTransitiveClosure(undirectedGraph, expectedClosure);\n", "  }\n", "\n"], "3": ["  private static <N> void checkTransitiveClosure(Graph<N> originalGraph, Graph<N> expectedClosure) {\n", "    for (N node : originalGraph.nodes()) {\n", "      assertThat(reachableNodes(originalGraph, node)).isEqualTo(expectedClosure.successors(node));\n", "    }\n", "    assertThat(transitiveClosure(originalGraph)).isEqualTo(expectedClosure);\n", "  }\n", "\n"]}, "removed": {}, "added_lines": {"1": [23, 24], "2": [89, 90, 91, 92, 93, 94, 95, 96, 97, 98, 99, 100, 101, 102, 103, 104, 105, 106, 107, 108, 109, 110, 111, 112, 113, 114, 115, 116, 117, 118, 119, 120, 121, 122, 123, 124, 125, 126, 127, 128, 129, 130, 131, 132, 133, 134, 135, 136, 137, 138, 139, 140, 141, 142, 143, 144, 145, 146, 147, 148, 149, 150, 151, 152, 153, 154, 155, 156, 157, 158, 159, 160, 161, 162, 163, 164, 165, 166, 167, 168, 169, 170, 171, 172, 173, 174, 175, 176, 177, 178, 179, 180, 181, 182, 183, 184, 185, 186, 187, 188, 189, 190, 191, 192, 193, 194, 195, 196, 197, 198, 199, 200, 201, 202, 203, 204, 205, 206, 207, 208, 209, 210, 211, 212, 213, 214, 215, 216, 217, 218, 219, 220, 221, 222, 223, 224, 225, 226, 227], "3": [579, 580, 581, 582, 583, 584, 585]}, "removed_lines": {}}, {"1": "guava/src/com/google/common/graph/Graph.java", "added": {"1": ["   * edges\". For that functionality, see {@link Graphs#reachableNodes(Graph, Object)} and\n", "   * {@link Graphs#transitiveClosure(Graph)}.\n"]}, "removed": {"1": ["   * edges\" (also known as {@code node}'s transitive closure).\n"]}, "added_lines": {"1": [229, 230]}, "removed_lines": {"1": [229]}}, {"2": "guava/src/com/google/common/graph/Graphs.java", "added": {"1": ["import static com.google.common.base.Preconditions.checkArgument;\n", "import com.google.common.collect.ImmutableList;\n", "import java.util.ArrayDeque;\n", "import java.util.Collections;\n", "import java.util.HashSet;\n", "import java.util.Queue;\n"], "2": ["  /**\n", "   * Returns the transitive closure of {@code graph}. The transitive closure of a graph is another\n", "   * graph with an edge connecting node A to node B iff node B is {@link #reachableNodes(Graph,\n", "   * Object) reachable} from node A.\n", "   *\n", "   * <p>This is a \"snapshot\" based on the current topology of {@code graph}, rather than a live\n", "   * view of the transitive closure of {@code graph}. In other words, the returned {@link Graph}\n", "   * will not be updated after modifications to {@code graph}.\n", "   */\n", "  public static <N> Graph<N> transitiveClosure(Graph<N> graph) {\n", "    MutableGraph<N> transitiveClosure = GraphBuilder.from(graph).allowsSelfLoops(true).build();\n", "    // Every node is, at a minimum, reachable from itself. Since the resulting transitive closure\n", "    // will have no isolated nodes, we can skip adding nodes explicitly and let putEdge() do it.\n", "\n", "    if (graph.isDirected()) {\n", "      // Note: works for both directed and undirected graphs, but we only use in the directed case.\n", "      for (N node : graph.nodes()) {\n", "        for (N reachableNode : reachableNodes(graph, node)) {\n", "          transitiveClosure.putEdge(node, reachableNode);\n", "        }\n", "      }\n", "    } else {\n", "      // An optimization for the undirected case: for every node B reachable from node A,\n", "      // node A and node B have the same reachability set.\n", "      Set<N> visitedNodes = new HashSet<N>();\n", "      for (N node : graph.nodes()) {\n", "        if (!visitedNodes.contains(node)) {\n", "          ImmutableList<N> reachableNodes = ImmutableList.copyOf(reachableNodes(graph, node));\n", "          visitedNodes.addAll(reachableNodes);\n", "          for (int a = 0; a < reachableNodes.size(); ++a) {\n", "            N nodeA = reachableNodes.get(a);\n", "            for (int b = a; b < reachableNodes.size(); ++b) {\n", "              N nodeB = reachableNodes.get(b);\n", "              transitiveClosure.putEdge(nodeA, nodeB);\n", "            }\n", "          }\n", "        }\n", "      }\n", "    }\n", "\n", "    return transitiveClosure;\n", "  }\n", "\n", "  /**\n", "   * Returns the set of nodes that are reachable from {@code node}. Node B is defined as reachable\n", "   * from node A if there exists a path (a sequence of adjacent outgoing edges) starting at node A\n", "   * and ending at node B. Note that a node is always reachable from itself via a zero-length path.\n", "   *\n", "   * <p>This is a \"snapshot\" based on the current topology of {@code graph}, rather than a live\n", "   * view of the set of nodes reachable from {@code node}. In other words, the returned {@link Set}\n", "   * will not be updated after modifications to {@code graph}.\n", "   *\n", "   * @throws IllegalArgumentException if {@code node} is not present in {@code graph}\n", "   */\n", "  @SuppressWarnings(\"unchecked\") // Throws an exception if node is not an element of graph.\n", "  public static <N> Set<N> reachableNodes(Graph<N> graph, Object node) {\n", "    checkArgument(graph.nodes().contains(node));\n", "    Set<N> visitedNodes = new HashSet<N>();\n", "    Queue<N> queuedNodes = new ArrayDeque<N>();\n", "    visitedNodes.add((N) node);\n", "    queuedNodes.add((N) node);\n", "    // Perform a breadth-first traversal rooted at the input node.\n", "    while (!queuedNodes.isEmpty()) {\n", "      N currentNode = queuedNodes.remove();\n", "      for (N successor : graph.successors(currentNode)) {\n", "        if (visitedNodes.add(successor)) {\n", "          queuedNodes.add(successor);\n", "        }\n", "      }\n", "    }\n", "    return Collections.unmodifiableSet(visitedNodes);\n", "  }\n", "\n"]}, "removed": {}, "added_lines": {"1": [19, 24, 28, 30, 31, 32], "2": [49, 50, 51, 52, 53, 54, 55, 56, 57, 58, 59, 60, 61, 62, 63, 64, 65, 66, 67, 68, 69, 70, 71, 72, 73, 74, 75, 76, 77, 78, 79, 80, 81, 82, 83, 84, 85, 86, 87, 88, 89, 90, 91, 92, 93, 94, 95, 96, 97, 98, 99, 100, 101, 102, 103, 104, 105, 106, 107, 108, 109, 110, 111, 112, 113, 114, 115, 116, 117, 118, 119, 120, 121]}, "removed_lines": {}}]}
