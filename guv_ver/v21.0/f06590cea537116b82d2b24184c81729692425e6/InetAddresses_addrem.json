{
    "addition": {
        "4": " * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not use this file except\n",
        "5": " * in compliance with the License. You may obtain a copy of the License at\n",
        "9": " * Unless required by applicable law or agreed to in writing, software distributed under the License\n",
        "10": " * is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express\n",
        "11": " * or implied. See the License for the specific language governing permissions and limitations under\n",
        "12": " * the License.\n",
        "39": " * <p><b>Important note:</b> Unlike {@code InetAddress.getByName()}, the methods of this class never\n",
        "40": " * cause DNS services to be accessed. For this reason, you should prefer these methods as much as\n",
        "41": " * possible over their JDK equivalents whenever you are expecting to handle only IP address string\n",
        "42": " * literals -- there is no blocking DNS penalty for a malformed string.\n",
        "44": " * <p>When dealing with {@link Inet4Address} and {@link Inet6Address} objects as byte arrays (vis.\n",
        "45": " * {@code InetAddress.getAddress()}) they are 4 and 16 bytes in length, respectively, and represent\n",
        "46": " * the address in network byte order.\n",
        "50": " * <dl>\n",
        "51": " * <dt>The IPv4 loopback address, {@code \"127.0.0.1\"}.\n",
        "52": " * <dd>{@code 7f 00 00 01}\n",
        "54": " * <dt>The IPv6 loopback address, {@code \"::1\"}.\n",
        "55": " * <dd>{@code 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 01}\n",
        "57": " * <dt>From the IPv6 reserved documentation prefix ({@code 2001:db8::/32}), {@code \"2001:db8::1\"}.\n",
        "58": " * <dd>{@code 20 01 0d b8 00 00 00 00 00 00 00 00 00 00 00 01}\n",
        "60": " * <dt>An IPv6 \"IPv4 compatible\" (or \"compat\") address, {@code \"::192.168.0.1\"}.\n",
        "61": " * <dd>{@code 00 00 00 00 00 00 00 00 00 00 00 00 c0 a8 00 01}\n",
        "62": " *\n",
        "63": " * <dt>An IPv6 \"IPv4 mapped\" address, {@code \"::ffff:192.168.0.1\"}.\n",
        "64": " * <dd>{@code 00 00 00 00 00 00 00 00 00 00 ff ff c0 a8 00 01}\n",
        "65": " *\n",
        "66": " * </dl>\n",
        "68": " * <p>A few notes about IPv6 \"IPv4 mapped\" addresses and their observed use in Java.\n",
        "70": " * <p>\"IPv4 mapped\" addresses were originally a representation of IPv4 addresses for use on an IPv6\n",
        "71": " * socket that could receive both IPv4 and IPv6 connections (by disabling the {@code IPV6_V6ONLY}\n",
        "72": " * socket option on an IPv6 socket). Yes, it's confusing. Nevertheless, these \"mapped\" addresses\n",
        "73": " * were never supposed to be seen on the wire. That assumption was dropped, some say mistakenly, in\n",
        "74": " * later RFCs with the apparent aim of making IPv4-to-IPv6 transition simpler.\n",
        "76": " * <p>Technically one <i>can</i> create a 128bit IPv6 address with the wire format of a \"mapped\"\n",
        "77": " * address, as shown above, and transmit it in an IPv6 packet header. However, Java's InetAddress\n",
        "78": " * creation methods appear to adhere doggedly to the original intent of the \"mapped\" address: all\n",
        "79": " * \"mapped\" addresses return {@link Inet4Address} objects.\n",
        "80": " *\n",
        "81": " * <p>For added safety, it is common for IPv6 network operators to filter all packets where either\n",
        "82": " * the source or destination address appears to be a \"compat\" or \"mapped\" address. Filtering\n",
        "83": " * suggestions usually recommend discarding any packets with source or destination addresses in the\n",
        "84": " * invalid range {@code ::/3}, which includes both of these bizarre address formats. For more\n",
        "85": " * information on \"bogons\", including lists of IPv6 bogon space, see:\n",
        "88": " * <li><a target=\"_parent\" href=\"http://en.wikipedia.org/wiki/Bogon_filtering\">http://en.wikipedia.\n",
        "89": " * org/wiki/Bogon_filtering</a>\n",
        "90": " * <li><a target=\"_parent\" href=\"http://www.cymru.com/Bogons/ipv6.txt\">http://www.cymru.com/Bogons/\n",
        "91": " * ipv6.txt</a>\n",
        "92": " * <li><a target=\"_parent\" href=\"http://www.cymru.com/Bogons/v6bogon.html\">http://www.cymru.com/\n",
        "93": " * Bogons/v6bogon.html</a>\n",
        "94": " * <li><a target=\"_parent\" href=\"http://www.space.net/~gert/RIPE/ipv6-filters.html\">http://www.\n",
        "95": " * space.net/~gert/RIPE/ipv6-filters.html</a>\n",
        "120": "    Preconditions.checkArgument(\n",
        "121": "        bytes.length == 4,\n",
        "151": "   * Returns {@code true} if the supplied string is a valid IP string literal, {@code false}\n",
        "152": "   * otherwise.\n",
        "171": "          return null; // Colons must not appear after dots.\n",
        "175": "        return null; // Everything else must be a decimal or hex digit.\n",
        "221": "          return null; // Can't have more than one ::\n",
        "227": "    int partsHi; // Number of parts to copy from above/before the \"::\"\n",
        "228": "    int partsLo; // Number of parts to copy from below/after the \"::\"\n",
        "234": "        return null; // ^: requires ^::\n",
        "237": "        return null; // :$ requires ::$\n",
        "240": "      // Otherwise, allocate the entire address to partsHi. The endpoints\n",
        "307": "   * {@link InetAddress#getByAddress} is documented as throwing a checked exception\n",
        "308": "   * \"if IP address is of illegal length.\" We replace it with an unchecked exception, for use by\n",
        "309": "   * callers who already know that addr is an array of length 4 or 16.\n",
        "325": "   * <p>For IPv4 addresses, this is identical to {@link InetAddress#getHostAddress()}, but for IPv6\n",
        "326": "   * addresses, the output follows <a href=\"http://tools.ietf.org/html/rfc5952\">RFC 5952</a> section\n",
        "327": "   * 4. The main difference is that this method uses \"::\" for zero compression, while Java's version\n",
        "328": "   * uses the uncompressed form.\n",
        "330": "   * <p>This method uses hexadecimal for all IPv6 addresses, including IPv4-mapped IPv6 addresses\n",
        "331": "   * such as \"::c000:201\". The output does not include a Scope ID.\n",
        "347": "      hextets[i] = Ints.fromBytes((byte) 0, (byte) 0, bytes[2 * i], bytes[2 * i + 1]);\n",
        "356": "   * <p>Only runs of two or more hextets are considered. In case of a tie, the leftmost run wins. If\n",
        "357": "   * a qualifying run is found, its hextets are replaced by the sentinel value -1.\n",
        "387": "   * <p>In order for \"::\" compression to work, the input should contain negative sentinel values in\n",
        "388": "   * place of the elided zeroes.\n",
        "393": "    // While scanning the array, handle these state transitions:\n",
        "394": "    //   start->num => \"num\"     start->gap => \"::\"\n",
        "395": "    //   num->num   => \":num\"    num->gap   => \"::\"\n",
        "396": "    //   gap->num   => \"num\"     gap->gap   => \"\"\n",
        "417": "   * Returns the string representation of an {@link InetAddress} suitable for inclusion in a URI.\n",
        "419": "   * <p>For IPv4 addresses, this is identical to {@link InetAddress#getHostAddress()}, but for IPv6\n",
        "420": "   * addresses it compresses zeroes and surrounds the text with square brackets; for example\n",
        "424": "   * <a target=\"_parent\" href=\"http://tools.ietf.org/html/rfc3986#section-3.2.2\">RFC 3986</a>, a URI\n",
        "425": "   * containing an IPv6 string literal is of the form\n",
        "428": "   * <p>Use of either {@link InetAddresses#toAddrString}, {@link InetAddress#getHostAddress()}, or\n",
        "429": "   * this method is recommended over {@link InetAddress#toString()} when an IP address string\n",
        "430": "   * literal is desired. This is because {@link InetAddress#toString()} prints the hostname and the\n",
        "431": "   * IP address string joined by a \"/\".\n",
        "444": "   * Returns an InetAddress representing the literal IPv4 or IPv6 host portion of a URL, encoded in\n",
        "445": "   * the format specified by RFC 3986 section 3.2.2.\n",
        "447": "   * <p>This function is similar to {@link InetAddresses#forString(String)}, however, it requires\n",
        "448": "   * that IPv6 addresses are surrounded by square brackets.\n",
        "450": "   * <p>This function is the inverse of {@link InetAddresses#toUriString(java.net.InetAddress)}.\n",
        "454": "   * @throws IllegalArgumentException if {@code hostAddr} is not a valid IPv4 address, or IPv6\n",
        "455": "   *     address surrounded by square brackets\n",
        "481": "   * Returns {@code true} if the supplied string is a valid URI IP string literal, {@code false}\n",
        "482": "   * otherwise.\n",
        "499": "   * <p>An \"IPv4 compatible\", or \"compat\", address is one with 96 leading bits of zero, with the\n",
        "500": "   * remaining 32 bits interpreted as an IPv4 address. These are conventionally represented in\n",
        "501": "   * string literals as {@code \"::192.168.0.1\"}, though {@code \"::c0a8:1\"} is also considered an\n",
        "502": "   * IPv4 compatible address (and equivalent to {@code \"::192.168.0.1\"}).\n",
        "505": "   * <a target=\"_parent\" href=\"http://tools.ietf.org/html/rfc4291#section-2.5.5.1\">RFC 4291</a>.\n",
        "507": "   * <p>NOTE: This method is different from {@link Inet6Address#isIPv4CompatibleAddress} in that it\n",
        "508": "   * more correctly classifies {@code \"::\"} and {@code \"::1\"} as proper IPv6 addresses (which they\n",
        "509": "   * are), NOT IPv4 compatible addresses (which they are generally NOT considered to be).\n",
        "520": "    if ((bytes[12] == 0)\n",
        "521": "        && (bytes[13] == 0)\n",
        "522": "        && (bytes[14] == 0)\n",
        "538": "    Preconditions.checkArgument(\n",
        "539": "        isCompatIPv4Address(ip), \"Address '%s' is not IPv4-compatible.\", toAddrString(ip));\n",
        "547": "   * <p>6to4 addresses begin with the {@code \"2002::/16\"} prefix. The next 32 bits are the IPv4\n",
        "548": "   * address of the host to which IPv6-in-IPv4 tunneled packets should be routed.\n",
        "551": "   * <a target=\"_parent\" href=\"http://tools.ietf.org/html/rfc3056#section-2\">RFC 3056</a>.\n",
        "569": "    Preconditions.checkArgument(\n",
        "570": "        is6to4Address(ip), \"Address '%s' is not a 6to4 address.\", toAddrString(ip));\n",
        "576": "   * A simple immutable data class to encapsulate the information to be found in a Teredo address.\n",
        "578": "   * <p>All of the fields in this class are encoded in various portions of the IPv6 address as part\n",
        "579": "   * of the protocol. More protocols details can be found at:\n",
        "580": "   * <a target=\"_parent\" href=\"http://en.wikipedia.org/wiki/Teredo_tunneling\">http://en.wikipedia.\n",
        "581": "   * org/wiki/Teredo_tunneling</a>.\n",
        "584": "   * <a target=\"_parent\" href=\"http://tools.ietf.org/html/rfc4380\">RFC 4380</a>.\n",
        "598": "     * <p>Both server and client can be {@code null}, in which case the value {@code \"0.0.0.0\"} will\n",
        "599": "     * be assumed.\n",
        "601": "     * @throws IllegalArgumentException if either of the {@code port} or the {@code flags} arguments\n",
        "602": "     *     are out of range of an unsigned short\n",
        "607": "      Preconditions.checkArgument(\n",
        "608": "          (port >= 0) && (port <= 0xffff), \"port '%s' is out of range (0 <= port <= 0xffff)\", port);\n",
        "609": "      Preconditions.checkArgument(\n",
        "610": "          (flags >= 0) && (flags <= 0xffff),\n",
        "611": "          \"flags '%s' is out of range (0 <= flags <= 0xffff)\",\n",
        "612": "          flags);\n",
        "647": "    return (bytes[0] == (byte) 0x20)\n",
        "648": "        && (bytes[1] == (byte) 0x01)\n",
        "649": "        && (bytes[2] == 0)\n",
        "650": "        && (bytes[3] == 0);\n",
        "661": "    Preconditions.checkArgument(\n",
        "662": "        isTeredoAddress(ip), \"Address '%s' is not a Teredo address.\", toAddrString(ip));\n",
        "685": "   * <p>From RFC 5214: \"ISATAP interface identifiers are constructed in Modified EUI-64 format [...]\n",
        "686": "   * by concatenating the 24-bit IANA OUI (00-00-5E), the 8-bit hexadecimal value 0xFE, and a 32-bit\n",
        "687": "   * IPv4 address in network byte order [...]\"\n",
        "690": "   * <a target=\"_parent\" href=\"http://tools.ietf.org/html/rfc5214#section-6.1\">RFC 5214</a>.\n",
        "712": "    return (bytes[9] == (byte) 0x00) && (bytes[10] == (byte) 0x5e) && (bytes[11] == (byte) 0xfe);\n",
        "723": "    Preconditions.checkArgument(\n",
        "724": "        isIsatapAddress(ip), \"Address '%s' is not an ISATAP address.\", toAddrString(ip));\n",
        "730": "   * Examines the Inet6Address to determine if it is an IPv6 address of one of the specified address\n",
        "731": "   * types that contain an embedded IPv4 address.\n",
        "733": "   * <p>NOTE: ISATAP addresses are explicitly excluded from this method due to their trivial\n",
        "734": "   * spoofability. With other transition addresses spoofing involves (at least) infection of one's\n",
        "735": "   * BGP routing table.\n",
        "746": "   * Examines the Inet6Address to extract the embedded IPv4 client address if the InetAddress is an\n",
        "747": "   * IPv6 address of one of the specified address types that contain an embedded IPv4 address.\n",
        "749": "   * <p>NOTE: ISATAP addresses are explicitly excluded from this method due to their trivial\n",
        "750": "   * spoofability. With other transition addresses spoofing involves (at least) infection of one's\n",
        "751": "   * BGP routing table.\n",
        "776": "   * <p>An \"IPv4 mapped\" address is anything in the range ::ffff:0:0/96 (sometimes written as\n",
        "777": "   * ::ffff:0.0.0.0/96), with the last 32 bits interpreted as an IPv4 address.\n",
        "780": "   * <a target=\"_parent\" href=\"http://tools.ietf.org/html/rfc4291#section-2.5.5.2\">RFC 4291</a>.\n",
        "782": "   * <p>Note: This method takes a {@code String} argument because {@link InetAddress} automatically\n",
        "783": "   * collapses mapped addresses to IPv4. (It is actually possible to avoid this using one of the\n",
        "784": "   * obscure {@link Inet6Address} methods, but it would be unwise to depend on such a\n",
        "785": "   * poorly-documented feature.)\n",
        "812": "   * <p>HACK: As long as applications continue to use IPv4 addresses for indexing into tables,\n",
        "813": "   * accounting, et cetera, it may be necessary to <b>coerce</b> IPv6 addresses into IPv4 addresses.\n",
        "814": "   * This function does so by hashing the upper 64 bits into {@code 224.0.0.0/3} (64 bits into 29\n",
        "815": "   * bits).\n",
        "819": "   * <p>NOTE: This function is failsafe for security purposes: ALL IPv6 addresses (except localhost\n",
        "820": "   * (::1)) are hashed to avoid the security risk associated with extracting an embedded IPv4\n",
        "821": "   * address that might permit elevated privileges.\n",
        "842": "      return LOOPBACK4; // ::1\n",
        "844": "      return ANY4; // ::0\n",
        "857": "    // Many strategies for hashing are possible. This might suffice for now.\n",
        "863": "    // Fixup to avoid some \"illegal\" values. Currently the only potential\n",
        "873": "   * Returns an integer representing an IPv4 address regardless of whether the supplied argument is\n",
        "874": "   * an IPv4 address or not.\n",
        "876": "   * <p>IPv6 addresses are <b>coerced</b> to IPv4 addresses before being converted to integers.\n",
        "878": "   * <p>As long as there are applications that assume that all IP addresses are IPv4 addresses and\n",
        "879": "   * can therefore be converted safely to integers (for whatever purpose) this function can be used\n",
        "880": "   * to handle IPv6 addresses as well until the application is suitably fixed.\n",
        "882": "   * <p>NOTE: an IPv6 address coerced to an IPv4 address can only be used for such purposes as\n",
        "883": "   * rudimentary identification or indexing into a collection of real {@link InetAddress}es. They\n",
        "884": "   * cannot be used as real addresses for the purposes of network communication.\n",
        "895": "   * Returns an Inet4Address having the integer value specified by the argument.\n",
        "905": "   * Returns an address from a <b>little-endian ordered</b> byte array (the opposite of what\n",
        "906": "   * {@link InetAddress#getByAddress} expects).\n",
        "908": "   * <p>IPv4 address byte array must be 4 bytes long and IPv6 byte array must be 16 bytes long.\n",
        "923": "   * Returns a new InetAddress that is one less than the passed in address. This method works for\n",
        "924": "   * both IPv4 and IPv6 addresses.\n",
        "946": "   * Returns a new InetAddress that is one more than the passed in address. This method works for\n",
        "947": "   * both IPv4 and IPv6 addresses.\n"
    },
    "removed": {
        "4": " * Licensed under the Apache License, Version 2.0 (the \"License\");\n",
        "5": " * you may not use this file except in compliance with the License.\n",
        "6": " * You may obtain a copy of the License at\n",
        "10": " * Unless required by applicable law or agreed to in writing, software\n",
        "11": " * distributed under the License is distributed on an \"AS IS\" BASIS,\n",
        "12": " * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n",
        "13": " * See the License for the specific language governing permissions and\n",
        "14": " * limitations under the License.\n",
        "41": " * <p><b>Important note:</b> Unlike {@code InetAddress.getByName()}, the\n",
        "42": " * methods of this class never cause DNS services to be accessed. For\n",
        "43": " * this reason, you should prefer these methods as much as possible over\n",
        "44": " * their JDK equivalents whenever you are expecting to handle only\n",
        "45": " * IP address string literals -- there is no blocking DNS penalty for a\n",
        "46": " * malformed string.\n",
        "48": " * <p>When dealing with {@link Inet4Address} and {@link Inet6Address}\n",
        "49": " * objects as byte arrays (vis. {@code InetAddress.getAddress()}) they\n",
        "50": " * are 4 and 16 bytes in length, respectively, and represent the address\n",
        "51": " * in network byte order.\n",
        "54": " * <ul>\n",
        "55": " * <li>The IPv4 loopback address, {@code \"127.0.0.1\"}.<br/>\n",
        "56": " *     {@code 7f 00 00 01}\n",
        "58": " * <li>The IPv6 loopback address, {@code \"::1\"}.<br/>\n",
        "59": " *     {@code 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 01}\n",
        "61": " * <li>From the IPv6 reserved documentation prefix ({@code 2001:db8::/32}),\n",
        "62": " *     {@code \"2001:db8::1\"}.<br/>\n",
        "63": " *     {@code 20 01 0d b8 00 00 00 00 00 00 00 00 00 00 00 01}\n",
        "65": " * <li>An IPv6 \"IPv4 compatible\" (or \"compat\") address,\n",
        "66": " *     {@code \"::192.168.0.1\"}.<br/>\n",
        "67": " *     {@code 00 00 00 00 00 00 00 00 00 00 00 00 c0 a8 00 01}\n",
        "69": " * <li>An IPv6 \"IPv4 mapped\" address, {@code \"::ffff:192.168.0.1\"}.<br/>\n",
        "70": " *     {@code 00 00 00 00 00 00 00 00 00 00 ff ff c0 a8 00 01}\n",
        "71": " * </ul>\n",
        "73": " * <p>A few notes about IPv6 \"IPv4 mapped\" addresses and their observed\n",
        "74": " * use in Java.\n",
        "75": " * <br><br>\n",
        "76": " * \"IPv4 mapped\" addresses were originally a representation of IPv4\n",
        "77": " * addresses for use on an IPv6 socket that could receive both IPv4\n",
        "78": " * and IPv6 connections (by disabling the {@code IPV6_V6ONLY} socket\n",
        "79": " * option on an IPv6 socket).  Yes, it's confusing.  Nevertheless,\n",
        "80": " * these \"mapped\" addresses were never supposed to be seen on the\n",
        "81": " * wire.  That assumption was dropped, some say mistakenly, in later\n",
        "82": " * RFCs with the apparent aim of making IPv4-to-IPv6 transition simpler.\n",
        "84": " * <p>Technically one <i>can</i> create a 128bit IPv6 address with the wire\n",
        "85": " * format of a \"mapped\" address, as shown above, and transmit it in an\n",
        "86": " * IPv6 packet header.  However, Java's InetAddress creation methods\n",
        "87": " * appear to adhere doggedly to the original intent of the \"mapped\"\n",
        "88": " * address: all \"mapped\" addresses return {@link Inet4Address} objects.\n",
        "90": " * <p>For added safety, it is common for IPv6 network operators to filter\n",
        "91": " * all packets where either the source or destination address appears to\n",
        "92": " * be a \"compat\" or \"mapped\" address.  Filtering suggestions usually\n",
        "93": " * recommend discarding any packets with source or destination addresses\n",
        "94": " * in the invalid range {@code ::/3}, which includes both of these bizarre\n",
        "95": " * address formats.  For more information on \"bogons\", including lists\n",
        "96": " * of IPv6 bogon space, see:\n",
        "99": " * <li><a target=\"_parent\"\n",
        "100": " *        href=\"http://en.wikipedia.org/wiki/Bogon_filtering\"\n",
        "101": " *       >http://en.wikipedia.org/wiki/Bogon_filtering</a>\n",
        "102": " * <li><a target=\"_parent\"\n",
        "103": " *        href=\"http://www.cymru.com/Bogons/ipv6.txt\"\n",
        "104": " *       >http://www.cymru.com/Bogons/ipv6.txt</a>\n",
        "105": " * <li><a target=\"_parent\"\n",
        "106": " *        href=\"http://www.cymru.com/Bogons/v6bogon.html\"\n",
        "107": " *       >http://www.cymru.com/Bogons/v6bogon.html</a>\n",
        "108": " * <li><a target=\"_parent\"\n",
        "109": " *        href=\"http://www.space.net/~gert/RIPE/ipv6-filters.html\"\n",
        "110": " *       >http://www.space.net/~gert/RIPE/ipv6-filters.html</a>\n",
        "135": "    Preconditions.checkArgument(bytes.length == 4,\n",
        "165": "   * Returns {@code true} if the supplied string is a valid IP string\n",
        "166": "   * literal, {@code false} otherwise.\n",
        "185": "          return null;  // Colons must not appear after dots.\n",
        "189": "        return null;  // Everything else must be a decimal or hex digit.\n",
        "235": "          return null;  // Can't have more than one ::\n",
        "241": "    int partsHi;  // Number of parts to copy from above/before the \"::\"\n",
        "242": "    int partsLo;  // Number of parts to copy from below/after the \"::\"\n",
        "248": "        return null;  // ^: requires ^::\n",
        "251": "        return null;  // :$ requires ::$\n",
        "254": "      // Otherwise, allocate the entire address to partsHi.  The endpoints\n",
        "321": "   * {@link InetAddress#getByAddress} is documented as throwing a checked\n",
        "322": "   * exception \"if IP address is of illegal length.\"  We replace it with\n",
        "323": "   * an unchecked exception, for use by callers who already know that addr\n",
        "324": "   * is an array of length 4 or 16.\n",
        "340": "   * <p>For IPv4 addresses, this is identical to\n",
        "341": "   * {@link InetAddress#getHostAddress()}, but for IPv6 addresses, the output\n",
        "342": "   * follows <a href=\"http://tools.ietf.org/html/rfc5952\">RFC 5952</a>\n",
        "343": "   * section 4.  The main difference is that this method uses \"::\" for zero\n",
        "344": "   * compression, while Java's version uses the uncompressed form.\n",
        "346": "   * <p>This method uses hexadecimal for all IPv6 addresses, including\n",
        "347": "   * IPv4-mapped IPv6 addresses such as \"::c000:201\".  The output does not\n",
        "348": "   * include a Scope ID.\n",
        "364": "      hextets[i] = Ints.fromBytes(\n",
        "365": "          (byte) 0, (byte) 0, bytes[2 * i], bytes[2 * i + 1]);\n",
        "374": "   * <p>Only runs of two or more hextets are considered.  In case of a tie, the\n",
        "375": "   * leftmost run wins.  If a qualifying run is found, its hextets are replaced\n",
        "376": "   * by the sentinel value -1.\n",
        "406": "   * <p>In order for \"::\" compression to work, the input should contain negative\n",
        "407": "   * sentinel values in place of the elided zeroes.\n",
        "412": "    /*\n",
        "413": "     * While scanning the array, handle these state transitions:\n",
        "414": "     *   start->num => \"num\"     start->gap => \"::\"\n",
        "415": "     *   num->num   => \":num\"    num->gap   => \"::\"\n",
        "416": "     *   gap->num   => \"num\"     gap->gap   => \"\"\n",
        "417": "     */\n",
        "438": "   * Returns the string representation of an {@link InetAddress} suitable\n",
        "439": "   * for inclusion in a URI.\n",
        "441": "   * <p>For IPv4 addresses, this is identical to\n",
        "442": "   * {@link InetAddress#getHostAddress()}, but for IPv6 addresses it\n",
        "443": "   * compresses zeroes and surrounds the text with square brackets; for example\n",
        "447": "   * <a target=\"_parent\"\n",
        "448": "   *    href=\"http://tools.ietf.org/html/rfc3986#section-3.2.2\"\n",
        "449": "   *  >http://tools.ietf.org/html/rfc3986</a>,\n",
        "450": "   * a URI containing an IPv6 string literal is of the form\n",
        "453": "   * <p>Use of either {@link InetAddresses#toAddrString},\n",
        "454": "   * {@link InetAddress#getHostAddress()}, or this method is recommended over\n",
        "455": "   * {@link InetAddress#toString()} when an IP address string literal is\n",
        "456": "   * desired.  This is because {@link InetAddress#toString()} prints the\n",
        "457": "   * hostname and the IP address string joined by a \"/\".\n",
        "470": "   * Returns an InetAddress representing the literal IPv4 or IPv6 host\n",
        "471": "   * portion of a URL, encoded in the format specified by RFC 3986 section 3.2.2.\n",
        "473": "   * <p>This function is similar to {@link InetAddresses#forString(String)},\n",
        "474": "   * however, it requires that IPv6 addresses are surrounded by square brackets.\n",
        "476": "   * <p>This function is the inverse of\n",
        "477": "   * {@link InetAddresses#toUriString(java.net.InetAddress)}.\n",
        "481": "   * @throws IllegalArgumentException if {@code hostAddr} is not a valid\n",
        "482": "   *     IPv4 address, or IPv6 address surrounded by square brackets\n",
        "508": "   * Returns {@code true} if the supplied string is a valid URI IP string\n",
        "509": "   * literal, {@code false} otherwise.\n",
        "526": "   * <p>An \"IPv4 compatible\", or \"compat\", address is one with 96 leading\n",
        "527": "   * bits of zero, with the remaining 32 bits interpreted as an\n",
        "528": "   * IPv4 address.  These are conventionally represented in string\n",
        "529": "   * literals as {@code \"::192.168.0.1\"}, though {@code \"::c0a8:1\"} is\n",
        "530": "   * also considered an IPv4 compatible address (and equivalent to\n",
        "531": "   * {@code \"::192.168.0.1\"}).\n",
        "534": "   * <a target=\"_parent\"\n",
        "535": "   *    href=\"http://tools.ietf.org/html/rfc4291#section-2.5.5.1\"\n",
        "536": "   *    >http://tools.ietf.org/html/rfc4291</a>\n",
        "538": "   * <p>NOTE: This method is different from\n",
        "539": "   * {@link Inet6Address#isIPv4CompatibleAddress} in that it more\n",
        "540": "   * correctly classifies {@code \"::\"} and {@code \"::1\"} as\n",
        "541": "   * proper IPv6 addresses (which they are), NOT IPv4 compatible\n",
        "542": "   * addresses (which they are generally NOT considered to be).\n",
        "553": "    if ((bytes[12] == 0) && (bytes[13] == 0) && (bytes[14] == 0)\n",
        "569": "    Preconditions.checkArgument(isCompatIPv4Address(ip),\n",
        "570": "        \"Address '%s' is not IPv4-compatible.\", toAddrString(ip));\n",
        "578": "   * <p>6to4 addresses begin with the {@code \"2002::/16\"} prefix.\n",
        "579": "   * The next 32 bits are the IPv4 address of the host to which\n",
        "580": "   * IPv6-in-IPv4 tunneled packets should be routed.\n",
        "583": "   * <a target=\"_parent\" href=\"http://tools.ietf.org/html/rfc3056#section-2\"\n",
        "584": "   *    >http://tools.ietf.org/html/rfc3056</a>\n",
        "602": "    Preconditions.checkArgument(is6to4Address(ip),\n",
        "603": "        \"Address '%s' is not a 6to4 address.\", toAddrString(ip));\n",
        "609": "   * A simple immutable data class to encapsulate the information to be found in a\n",
        "610": "   * Teredo address.\n",
        "612": "   * <p>All of the fields in this class are encoded in various portions\n",
        "613": "   * of the IPv6 address as part of the protocol.  More protocols details\n",
        "614": "   * can be found at:\n",
        "615": "   * <a target=\"_parent\" href=\"http://en.wikipedia.org/wiki/Teredo_tunneling\"\n",
        "616": "   *    >http://en.wikipedia.org/wiki/Teredo_tunneling</a>.\n",
        "619": "   * <a target=\"_parent\" href=\"http://tools.ietf.org/html/rfc4380\"\n",
        "620": "   *    >http://tools.ietf.org/html/rfc4380</a>.\n",
        "634": "     * <p>Both server and client can be {@code null}, in which case the\n",
        "635": "     * value {@code \"0.0.0.0\"} will be assumed.\n",
        "637": "     * @throws IllegalArgumentException if either of the {@code port} or the {@code flags}\n",
        "638": "     *     arguments are out of range of an unsigned short\n",
        "643": "      Preconditions.checkArgument((port >= 0) && (port <= 0xffff),\n",
        "644": "          \"port '%s' is out of range (0 <= port <= 0xffff)\", port);\n",
        "645": "      Preconditions.checkArgument((flags >= 0) && (flags <= 0xffff),\n",
        "646": "          \"flags '%s' is out of range (0 <= flags <= 0xffff)\", flags);\n",
        "681": "    return (bytes[0] == (byte) 0x20) && (bytes[1] == (byte) 0x01)\n",
        "682": "           && (bytes[2] == 0) && (bytes[3] == 0);\n",
        "693": "    Preconditions.checkArgument(isTeredoAddress(ip),\n",
        "694": "        \"Address '%s' is not a Teredo address.\", toAddrString(ip));\n",
        "717": "   * <p>From RFC 5214: \"ISATAP interface identifiers are constructed in\n",
        "718": "   * Modified EUI-64 format [...] by concatenating the 24-bit IANA OUI\n",
        "719": "   * (00-00-5E), the 8-bit hexadecimal value 0xFE, and a 32-bit IPv4\n",
        "720": "   * address in network byte order [...]\"\n",
        "723": "   * <a target=\"_parent\" href=\"http://tools.ietf.org/html/rfc5214#section-6.1\"\n",
        "724": "   *    >http://tools.ietf.org/html/rfc5214</a>\n",
        "746": "    return (bytes[9] == (byte) 0x00) && (bytes[10] == (byte) 0x5e)\n",
        "747": "           && (bytes[11] == (byte) 0xfe);\n",
        "758": "    Preconditions.checkArgument(isIsatapAddress(ip),\n",
        "759": "        \"Address '%s' is not an ISATAP address.\", toAddrString(ip));\n",
        "765": "   * Examines the Inet6Address to determine if it is an IPv6 address of one\n",
        "766": "   * of the specified address types that contain an embedded IPv4 address.\n",
        "768": "   * <p>NOTE: ISATAP addresses are explicitly excluded from this method\n",
        "769": "   * due to their trivial spoofability.  With other transition addresses\n",
        "770": "   * spoofing involves (at least) infection of one's BGP routing table.\n",
        "781": "   * Examines the Inet6Address to extract the embedded IPv4 client address\n",
        "782": "   * if the InetAddress is an IPv6 address of one of the specified address\n",
        "783": "   * types that contain an embedded IPv4 address.\n",
        "785": "   * <p>NOTE: ISATAP addresses are explicitly excluded from this method\n",
        "786": "   * due to their trivial spoofability.  With other transition addresses\n",
        "787": "   * spoofing involves (at least) infection of one's BGP routing table.\n",
        "812": "   * <p>An \"IPv4 mapped\" address is anything in the range ::ffff:0:0/96\n",
        "813": "   * (sometimes written as ::ffff:0.0.0.0/96), with the last 32 bits\n",
        "814": "   * interpreted as an IPv4 address.\n",
        "817": "   * <a target=\"_parent\"\n",
        "818": "   *    href=\"http://tools.ietf.org/html/rfc4291#section-2.5.5.2\"\n",
        "819": "   *    >http://tools.ietf.org/html/rfc4291</a>\n",
        "821": "   * <p>Note: This method takes a {@code String} argument because\n",
        "822": "   * {@link InetAddress} automatically collapses mapped addresses to IPv4.\n",
        "823": "   * (It is actually possible to avoid this using one of the obscure\n",
        "824": "   * {@link Inet6Address} methods, but it would be unwise to depend on such\n",
        "825": "   * a poorly-documented feature.)\n",
        "852": "   * <p>HACK: As long as applications continue to use IPv4 addresses for\n",
        "853": "   * indexing into tables, accounting, et cetera, it may be necessary to\n",
        "854": "   * <b>coerce</b> IPv6 addresses into IPv4 addresses. This function does\n",
        "855": "   * so by hashing the upper 64 bits into {@code 224.0.0.0/3}\n",
        "856": "   * (64 bits into 29 bits).\n",
        "860": "   * <p>NOTE: This function is failsafe for security purposes: ALL IPv6\n",
        "861": "   * addresses (except localhost (::1)) are hashed to avoid the security\n",
        "862": "   * risk associated with extracting an embedded IPv4 address that might\n",
        "863": "   * permit elevated privileges.\n",
        "884": "      return LOOPBACK4;  // ::1\n",
        "886": "      return ANY4;  // ::0\n",
        "899": "    // Many strategies for hashing are possible.  This might suffice for now.\n",
        "905": "    // Fixup to avoid some \"illegal\" values.  Currently the only potential\n",
        "915": "   * Returns an integer representing an IPv4 address regardless of\n",
        "916": "   * whether the supplied argument is an IPv4 address or not.\n",
        "918": "   * <p>IPv6 addresses are <b>coerced</b> to IPv4 addresses before being\n",
        "919": "   * converted to integers.\n",
        "921": "   * <p>As long as there are applications that assume that all IP addresses\n",
        "922": "   * are IPv4 addresses and can therefore be converted safely to integers\n",
        "923": "   * (for whatever purpose) this function can be used to handle IPv6\n",
        "924": "   * addresses as well until the application is suitably fixed.\n",
        "926": "   * <p>NOTE: an IPv6 address coerced to an IPv4 address can only be used\n",
        "927": "   * for such purposes as rudimentary identification or indexing into a\n",
        "928": "   * collection of real {@link InetAddress}es.  They cannot be used as\n",
        "929": "   * real addresses for the purposes of network communication.\n",
        "940": "   * Returns an Inet4Address having the integer value specified by\n",
        "941": "   * the argument.\n",
        "951": "   * Returns an address from a <b>little-endian ordered</b> byte array\n",
        "952": "   * (the opposite of what {@link InetAddress#getByAddress} expects).\n",
        "954": "   * <p>IPv4 address byte array must be 4 bytes long and IPv6 byte array\n",
        "955": "   * must be 16 bytes long.\n",
        "970": "   * Returns a new InetAddress that is one less than the passed in address.\n",
        "971": "   * This method works for both IPv4 and IPv6 addresses.\n",
        "993": "   * Returns a new InetAddress that is one more than the passed in address.\n",
        "994": "   * This method works for both IPv4 and IPv6 addresses.\n"
    }
}