{
    "addition": {
        "21": "import static com.google.common.graph.GraphErrorMessageUtils.ENDPOINTS_GRAPH_DIRECTEDNESS;\n",
        "62": "    Endpoints<N> endpoints = graph.incidentNodes(edge);\n",
        "63": "    if (node.equals(endpoints.nodeA())) {\n",
        "64": "      return endpoints.nodeB();\n",
        "66": "      checkArgument(node.equals(endpoints.nodeB()),\n",
        "67": "          \"Edge %s is not incident to node %s\", edge, node);\n",
        "68": "      return endpoints.nodeA();\n",
        "79": "    Endpoints<N> endpoints = graph.incidentNodes(edge); // Verifies that edge is in graph\n",
        "83": "    return Sets.difference(graph.edgesConnecting(endpoints.nodeA(), endpoints.nodeB()),\n",
        "84": "        ImmutableSet.of(edge)); // An edge is not parallel to itself.\n",
        "88": "   * Adds {@code edge} to {@code graph} with the specified {@code endpoints}.\n",
        "91": "  public static <N, E> boolean addEdge(MutableNetwork<N, E> graph, E edge, Endpoints<N> endpoints) {\n",
        "94": "    checkNotNull(endpoints, \"endpoints\");\n",
        "95": "    checkArgument(endpoints.isDirected() == graph.isDirected(),\n",
        "96": "        ENDPOINTS_GRAPH_DIRECTEDNESS, endpoints.isDirected(), graph.isDirected());\n",
        "97": "    return graph.addEdge(edge, endpoints.nodeA(), endpoints.nodeB());\n",
        "116": "    for (N node : Sets.filter(graph.nodes(), nodePredicate)) {\n",
        "117": "      copy.addNode(node);\n",
        "118": "      for (N successor : Sets.filter(graph.successors(node), nodePredicate)) {\n",
        "119": "        copy.addEdge(node, successor);\n",
        "172": "    for (E edge : Sets.filter(graph.edges(), edgePredicate)) {\n",
        "173": "      Endpoints<N> endpoints = graph.incidentNodes(edge);\n",
        "174": "      if (copy.nodes().containsAll(endpoints)) {\n",
        "175": "        addEdge(copy, edge, endpoints);\n",
        "310": "    if (graph instanceof Network) {\n",
        "311": "      return hashCode((Network<?, ?>) graph);\n",
        "312": "    }\n",
        "313": "    return nodeToAdjacentNodes(graph).hashCode();\n",
        "383": "  /**\n",
        "384": "   * Returns a map that is a live view of {@code graph}, with nodes as keys\n",
        "385": "   * and the set of adjacent nodes as values.\n",
        "386": "   */\n",
        "403": "    checkNotNull(graph, \"graph\");\n"
    },
    "removed": {
        "33": "import java.util.Iterator;\n",
        "58": "   * @throws UnsupportedOperationException if {@code graph} is a {@link Hypergraph}\n",
        "62": "    if (graph instanceof Hypergraph) {\n",
        "63": "      throw new UnsupportedOperationException();\n",
        "64": "    }\n",
        "65": "\n",
        "67": "    Iterator<N> incidentNodesIterator = graph.incidentNodes(edge).iterator();\n",
        "68": "    N node1 = incidentNodesIterator.next();\n",
        "69": "    N node2 = incidentNodesIterator.hasNext() ? incidentNodesIterator.next() : node1;\n",
        "70": "    if (node.equals(node1)) {\n",
        "71": "      return node2;\n",
        "73": "      checkArgument(node.equals(node2), \"Edge %s is not incident to node %s\", edge, node);\n",
        "74": "      return node1;\n",
        "82": "   * @throws UnsupportedOperationException if {@code graph} is a {@link Hypergraph}\n",
        "86": "    if (graph instanceof Hypergraph) {\n",
        "87": "      throw new UnsupportedOperationException();\n",
        "88": "    }\n",
        "89": "\n",
        "90": "    Set<N> incidentNodes = graph.incidentNodes(edge); // Verifies that edge is in graph\n",
        "94": "    Iterator<N> incidentNodesIterator = incidentNodes.iterator();\n",
        "95": "    N node1 = incidentNodesIterator.next();\n",
        "96": "    N node2 = incidentNodesIterator.hasNext() ? incidentNodesIterator.next() : node1;\n",
        "97": "    return Sets.difference(graph.edgesConnecting(node1, node2), ImmutableSet.of(edge));\n",
        "101": "   * Adds {@code edge} to {@code graph} with the specified incident {@code nodes}, in the order\n",
        "102": "   * returned by {@code nodes}' iterator.\n",
        "105": "  public static <N, E> boolean addEdge(MutableNetwork<N, E> graph, E edge, Iterable<N> nodes) {\n",
        "108": "    checkNotNull(nodes, \"nodes\");\n",
        "109": "    if (graph instanceof Hypergraph) {\n",
        "110": "      return ((Hypergraph<N, E>) graph).addEdge(edge, nodes);\n",
        "111": "    }\n",
        "112": "\n",
        "113": "    Iterator<N> nodesIterator = nodes.iterator();\n",
        "114": "    checkArgument(nodesIterator.hasNext(),\n",
        "115": "        \"'graph' is not a Hypergraph, and 'nodes' has < 1 elements: %s\", nodes);\n",
        "116": "    N node1 = nodesIterator.next();\n",
        "117": "    N node2 = nodesIterator.hasNext() ? nodesIterator.next() : node1;\n",
        "118": "    checkArgument(!nodesIterator.hasNext(),\n",
        "119": "        \"'graph' is not a Hypergraph, and 'nodes' has > 2 elements: %s\", nodes);\n",
        "120": "    return graph.addEdge(edge, node1, node2);\n",
        "139": "    for (N node : graph.nodes()) {\n",
        "140": "      if (nodePredicate.apply(node)) {\n",
        "141": "        copy.addNode(node);\n",
        "142": "        for (N successor : graph.successors(node)) {\n",
        "143": "          if (nodePredicate.apply(successor)) {\n",
        "144": "            copy.addEdge(node, successor);\n",
        "145": "          }\n",
        "146": "        }\n",
        "199": "    for (E edge : graph.edges()) {\n",
        "200": "      if (edgePredicate.apply(edge)) {\n",
        "201": "        Set<N> incidentNodes = graph.incidentNodes(edge);\n",
        "202": "        if (copy.nodes().containsAll(incidentNodes)) {\n",
        "203": "          addEdge(copy, edge, incidentNodes);\n",
        "204": "        }\n",
        "339": "    return (graph instanceof Network)\n",
        "340": "        ? hashCode((Network<?, ?>) graph)\n",
        "341": "        : nodeToAdjacentNodes(graph).hashCode();\n",
        "427": "    if (graph.isDirected()) {\n",
        "428": "      return new Function<Object, String>() {\n",
        "429": "        @Override\n",
        "430": "        public String apply(Object edge) {\n",
        "431": "          return String.format(\"<%s -> %s>\",\n",
        "432": "              graph.source(edge), graph.target(edge));\n",
        "433": "          }\n",
        "434": "        };\n",
        "435": "    }\n"
    }
}