{"id": "7fbd99f23566e293a6b89db4639b91e31b6053b8", "code": [{"0": "guava-testlib/src/com/google/common/graph/testing/TestGraphBuilder.java", "added": {"1": ["  public TestGraphBuilder<N> addEdge(N nodeA, N nodeB) {\n", "    graph.addEdge(nodeA, nodeB);\n"]}, "removed": {"1": ["  public TestGraphBuilder<N> addEdge(N node1, N node2) {\n", "    graph.addEdge(node1, node2);\n"]}, "added_lines": {"1": [52, 53]}, "removed_lines": {"1": [52, 53]}}, {"1": "guava-testlib/src/com/google/common/graph/testing/TestNetworkBuilder.java", "added": {"1": ["  public TestNetworkBuilder<N, E> addEdge(E edge, N nodeA, N nodeB) {\n", "    graph.addEdge(edge, nodeA, nodeB);\n"]}, "removed": {"1": ["  public TestNetworkBuilder<N, E> addEdge(E edge, N node1, N node2) {\n", "    graph.addEdge(edge, node1, node2);\n"]}, "added_lines": {"1": [52, 53]}, "removed_lines": {"1": [52, 53]}}, {"2": "guava-tests/test/com/google/common/graph/AbstractDirectedNetworkTest.java", "added": {"1": ["        Endpoints<Integer> endpoints = graph.incidentNodes(inEdge);\n", "        assertThat(endpoints.source()).isEqualTo(oppositeNode);\n", "        assertThat(endpoints.target()).isEqualTo(node);\n", "        Endpoints<Integer> endpoints = graph.incidentNodes(outEdge);\n", "        assertThat(endpoints.source()).isEqualTo(node);\n", "        assertThat(endpoints.target()).isEqualTo(oppositeNode);\n"], "2": ["    assertEquals(N1, graph.incidentNodes(E12).source());\n", "      graph.incidentNodes(EDGE_NOT_IN_GRAPH).source();\n"], "3": ["    assertEquals(N2, graph.incidentNodes(E12).target());\n", "      graph.incidentNodes(EDGE_NOT_IN_GRAPH).target();\n"]}, "removed": {"1": ["        assertThat(graph.source(inEdge)).isEqualTo(oppositeNode);\n", "        assertThat(graph.target(inEdge)).isEqualTo(node);\n", "        assertThat(graph.source(outEdge)).isEqualTo(node);\n", "        assertThat(graph.target(outEdge)).isEqualTo(oppositeNode);\n"], "2": ["    assertEquals(N1, graph.source(E12));\n", "      graph.source(EDGE_NOT_IN_GRAPH);\n"], "3": ["    assertEquals(N2, graph.target(E12));\n", "      graph.target(EDGE_NOT_IN_GRAPH);\n"]}, "added_lines": {"1": [48, 49, 50, 55, 56, 57], "2": [135, 141], "3": [151, 157]}, "removed_lines": {"1": [48, 49, 54, 55], "2": [133, 139], "3": [149, 155]}}, {"3": "guava-tests/test/com/google/common/graph/AbstractNetworkTest.java", "added": {"2": ["  static final String ERROR_MODIFIABLE_COLLECTION =\n", "      \"Collection returned is unexpectedly modifiable\";\n"], "3": ["      Endpoints<Integer> endpoints = graph.incidentNodes(edge);\n", "      Integer nodeA = endpoints.nodeA();\n", "      Integer nodeB = endpoints.nodeB();\n", "      assertThat(graph.edgesConnecting(nodeA, nodeB)).contains(edge);\n", "      assertThat(graph.successors(nodeA)).contains(nodeB);\n", "      assertThat(graph.adjacentNodes(nodeA)).contains(nodeB);\n", "      assertThat(graph.outEdges(nodeA)).contains(edge);\n", "      assertThat(graph.incidentEdges(nodeA)).contains(edge);\n", "      assertThat(graph.predecessors(nodeB)).contains(nodeA);\n", "      assertThat(graph.adjacentNodes(nodeB)).contains(nodeA);\n", "      assertThat(graph.inEdges(nodeB)).contains(edge);\n", "      assertThat(graph.incidentEdges(nodeB)).contains(edge);\n"], "4": ["        assertThat(graph.outEdges(Graphs.oppositeNode(graph, inEdge, node))).contains(inEdge);\n", "        assertThat(graph.inEdges(Graphs.oppositeNode(graph, outEdge, node))).contains(outEdge);\n"]}, "removed": {"1": ["import java.util.Iterator;\n", "\n"], "2": ["  static final String ERROR_MODIFIABLE_SET = \"Set returned is unexpectedly modifiable\";\n"], "3": ["      if (!(graph instanceof Hypergraph)) {\n", "        Iterator<Integer> incidentNodesIterator = graph.incidentNodes(edge).iterator();\n", "        Integer node1 = incidentNodesIterator.next();\n", "        Integer node2 = incidentNodesIterator.hasNext() ? incidentNodesIterator.next() : node1;\n", "        assertFalse(incidentNodesIterator.hasNext());\n", "        assertThat(graph.edgesConnecting(node1, node2)).contains(edge);\n", "        assertThat(graph.successors(node1)).contains(node2);\n", "        assertThat(graph.adjacentNodes(node1)).contains(node2);\n", "        assertThat(graph.outEdges(node1)).contains(edge);\n", "        assertThat(graph.incidentEdges(node1)).contains(edge);\n", "        assertThat(graph.predecessors(node2)).contains(node1);\n", "        assertThat(graph.adjacentNodes(node2)).contains(node1);\n", "        assertThat(graph.inEdges(node2)).contains(edge);\n", "        assertThat(graph.incidentEdges(node2)).contains(edge);\n", "      }\n"], "4": ["        if (!(graph instanceof Hypergraph)) {\n", "          assertThat(graph.outEdges(Graphs.oppositeNode(graph, inEdge, node))).contains(inEdge);\n", "        }\n", "        if (!(graph instanceof Hypergraph)) {\n", "          assertThat(graph.inEdges(Graphs.oppositeNode(graph, outEdge, node))).contains(outEdge);\n", "        }\n"]}, "added_lines": {"2": [86, 87], "3": [168, 169, 170, 171, 172, 173, 174, 175, 176, 177, 178, 179], "4": [201, 206]}, "removed_lines": {"1": [33, 34], "2": [88], "3": [169, 170, 171, 172, 173, 174, 175, 176, 177, 178, 179, 180, 181, 182, 183], "4": [205, 206, 207, 212, 213, 214]}}, {"4": "guava-tests/test/com/google/common/graph/ConfigurableDirectedNetworkTest.java", "added": {"1": ["    assertThat(graph.incidentNodes(E11)).containsExactly(N1, N1);\n"], "2": ["    assertEquals(N1, graph.incidentNodes(E11).source());\n", "    assertEquals(N1, graph.incidentNodes(E11).target());\n"]}, "removed": {"1": ["    assertThat(graph.incidentNodes(E11)).containsExactly(N1);\n"], "2": ["    assertEquals(N1, graph.source(E11));\n", "    assertEquals(N1, graph.target(E11));\n"]}, "added_lines": {"1": [57], "2": [144, 150]}, "removed_lines": {"1": [57], "2": [144, 150]}}, {"5": "guava-tests/test/com/google/common/graph/ConfigurableSimpleDirectedNetworkTest.java", "added": {"1": ["      fail(ERROR_MODIFIABLE_COLLECTION);\n"], "2": ["      fail(ERROR_MODIFIABLE_COLLECTION);\n"], "3": ["      fail(ERROR_MODIFIABLE_COLLECTION);\n"], "4": ["    Endpoints<Integer> incidentNodes = graph.incidentNodes(E12);\n", "      fail(ERROR_MODIFIABLE_COLLECTION);\n"], "5": ["      fail(ERROR_MODIFIABLE_COLLECTION);\n"], "6": ["      fail(ERROR_MODIFIABLE_COLLECTION);\n"], "7": ["      fail(ERROR_MODIFIABLE_COLLECTION);\n"], "8": ["      fail(ERROR_MODIFIABLE_COLLECTION);\n"], "9": ["      fail(ERROR_MODIFIABLE_COLLECTION);\n"], "10": ["      fail(ERROR_MODIFIABLE_COLLECTION);\n"], "11": ["      fail(ERROR_MODIFIABLE_COLLECTION);\n"]}, "removed": {"1": ["      fail(ERROR_MODIFIABLE_SET);\n"], "2": ["      fail(ERROR_MODIFIABLE_SET);\n"], "3": ["      fail(ERROR_MODIFIABLE_SET);\n"], "4": ["    Set<Integer> incidentNodes = graph.incidentNodes(E12);\n", "      fail(ERROR_MODIFIABLE_SET);\n"], "5": ["      fail(ERROR_MODIFIABLE_SET);\n"], "6": ["      fail(ERROR_MODIFIABLE_SET);\n"], "7": ["      fail(ERROR_MODIFIABLE_SET);\n"], "8": ["      fail(ERROR_MODIFIABLE_SET);\n"], "9": ["      fail(ERROR_MODIFIABLE_SET);\n"], "10": ["      fail(ERROR_MODIFIABLE_SET);\n"], "11": ["      fail(ERROR_MODIFIABLE_SET);\n"]}, "added_lines": {"1": [47], "2": [60], "3": [74], "4": [85, 88], "5": [100], "6": [114], "7": [129], "8": [143], "9": [157], "10": [171], "11": [185]}, "removed_lines": {"1": [47], "2": [60], "3": [74], "4": [85, 88], "5": [100], "6": [114], "7": [129], "8": [143], "9": [157], "10": [171], "11": [185]}}, {"6": "guava-tests/test/com/google/common/graph/ConfigurableSimpleUndirectedNetworkTest.java", "added": {"1": ["      fail(ERROR_MODIFIABLE_COLLECTION);\n"], "2": ["      fail(ERROR_MODIFIABLE_COLLECTION);\n"], "3": ["      fail(ERROR_MODIFIABLE_COLLECTION);\n"], "4": ["    Endpoints<Integer> incidentNodes = graph.incidentNodes(E12);\n", "      fail(ERROR_MODIFIABLE_COLLECTION);\n"], "5": ["      fail(ERROR_MODIFIABLE_COLLECTION);\n"], "6": ["      fail(ERROR_MODIFIABLE_COLLECTION);\n"], "7": ["      fail(ERROR_MODIFIABLE_COLLECTION);\n"], "8": ["      fail(ERROR_MODIFIABLE_COLLECTION);\n"], "9": ["      fail(ERROR_MODIFIABLE_COLLECTION);\n"], "10": ["      fail(ERROR_MODIFIABLE_COLLECTION);\n"], "11": ["      fail(ERROR_MODIFIABLE_COLLECTION);\n"]}, "removed": {"1": ["      fail(ERROR_MODIFIABLE_SET);\n"], "2": ["      fail(ERROR_MODIFIABLE_SET);\n"], "3": ["      fail(ERROR_MODIFIABLE_SET);\n"], "4": ["    Set<Integer> incidentNodes = graph.incidentNodes(E12);\n", "      fail(ERROR_MODIFIABLE_SET);\n"], "5": ["      fail(ERROR_MODIFIABLE_SET);\n"], "6": ["      fail(ERROR_MODIFIABLE_SET);\n"], "7": ["      fail(ERROR_MODIFIABLE_SET);\n"], "8": ["      fail(ERROR_MODIFIABLE_SET);\n"], "9": ["      fail(ERROR_MODIFIABLE_SET);\n"], "10": ["      fail(ERROR_MODIFIABLE_SET);\n"], "11": ["      fail(ERROR_MODIFIABLE_SET);\n"]}, "added_lines": {"1": [47], "2": [60], "3": [74], "4": [85, 88], "5": [100], "6": [114], "7": [129], "8": [144], "9": [158], "10": [172], "11": [186]}, "removed_lines": {"1": [47], "2": [60], "3": [74], "4": [85, 88], "5": [100], "6": [114], "7": [129], "8": [144], "9": [158], "10": [172], "11": [186]}}, {"7": "guava-tests/test/com/google/common/graph/ConfigurableUndirectedNetworkTest.java", "added": {"1": ["    assertThat(graph.incidentNodes(E11)).containsExactly(N1, N1);\n"]}, "removed": {"1": ["    assertThat(graph.incidentNodes(E11)).containsExactly(N1);\n"]}, "added_lines": {"1": [57]}, "removed_lines": {"1": [57]}}, {"8": "guava-tests/test/com/google/common/graph/EndpointsTest.java", "added": {"1": ["/*\n", " * Copyright (C) 2016 The Guava Authors\n", " *\n", " * Licensed under the Apache License, Version 2.0 (the \"License\");\n", " * you may not use this file except in compliance with the License.\n", " * You may obtain a copy of the License at\n", " *\n", " * http://www.apache.org/licenses/LICENSE-2.0\n", " *\n", " * Unless required by applicable law or agreed to in writing, software\n", " * distributed under the License is distributed on an \"AS IS\" BASIS,\n", " * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n", " * See the License for the specific language governing permissions and\n", " * limitations under the License.\n", " */\n", "\n", "package com.google.common.graph;\n", "\n", "import static com.google.common.truth.Truth.assertThat;\n", "\n", "import org.junit.Test;\n", "import org.junit.runner.RunWith;\n", "import org.junit.runners.JUnit4;\n", "\n", "/**\n", " * Tests for {@link Endpoints}.\n", " */\n", "@RunWith(JUnit4.class)\n", "public final class EndpointsTest {\n", "\n", "  @Test\n", "  public void directedEndpoints() {\n", "    Endpoints<String> directed = Endpoints.ofDirected(\"source\", \"target\");\n", "    assertThat(directed.source()).isEqualTo(\"source\");\n", "    assertThat(directed.target()).isEqualTo(\"target\");\n", "    assertThat(directed).containsExactly(\"source\", \"target\").inOrder();\n", "  }\n", "\n", "  @Test\n", "  public void undirectedEndpoints() {\n", "    Endpoints<String> undirected = Endpoints.ofUndirected(\"chicken\", \"egg\");\n", "    assertThat(undirected).containsExactly(\"chicken\", \"egg\");\n", "  }\n", "\n", "  @Test\n", "  public void selfLoop() {\n", "    Endpoints<String> undirected = Endpoints.ofUndirected(\"node\", \"node\");\n", "    assertThat(undirected).hasSize(2);\n", "  }\n", "\n", "  @Test\n", "  public void testEquals() {\n", "    Endpoints<String> directed = Endpoints.ofDirected(\"a\", \"b\");\n", "    Endpoints<String> directedMirror = Endpoints.ofDirected(\"b\", \"a\");\n", "    Endpoints<String> undirected = Endpoints.ofUndirected(\"a\", \"b\");\n", "    Endpoints<String> undirectedMirror = Endpoints.ofUndirected(\"b\", \"a\");\n", "\n", "    assertThat(directed).isNotEqualTo(undirected);\n", "    assertThat(directed).isNotEqualTo(directedMirror);\n", "    assertThat(undirected).isEqualTo(undirectedMirror);\n", "  }\n", "}\n"]}, "removed": {}, "added_lines": {"1": [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 58, 59, 60, 61, 62]}, "removed_lines": {}}, {"9": "guava-tests/test/com/google/common/graph/GraphsTest.java", "added": {"1": ["   * {@code graph}. A self-loop is defined as an edge whose pair of incident nodes are equal.\n", "   * The predicate's {@code apply} method will throw an {@link IllegalArgumentException} if\n"], "2": ["        Endpoints<?> endpoints = graph.incidentNodes(edge);\n", "        return endpoints.nodeA().equals(endpoints.nodeB());\n"], "3": ["  public void addEdge_mismatchedDirectedness() {\n", "      addEdge(NetworkBuilder.undirected().<Integer, String>build(), E12,\n", "          Endpoints.ofDirected(N1, N2));\n", "      fail(\"Should have rejected adding an edge with directed endpoints to a undirected graph.\");\n", "    MutableNetwork<Integer, String> undirectedGraph = NetworkBuilder.undirected().build();\n", "    assertThat(addEdge(undirectedGraph, E11, Endpoints.ofUndirected(N1, N1))).isTrue();\n", "    assertThat(undirectedGraph.edgesConnecting(N1, N1)).containsExactly(E11);\n", "    assertThat(addEdge(directedGraph, E12, Endpoints.ofDirected(N1, N2))).isTrue();\n", "    assertThat(directedGraph.edgesConnecting(N1, N2)).containsExactly(E12);\n", "    assertThat(directedGraph.edgesConnecting(N2, N1)).isEmpty();\n"]}, "removed": {"1": ["   * {@code graph}. A self-loop is defined as an edge whose set of incident nodes has exactly one\n", "   * element. The predicate's {@code apply} method will throw an {@link IllegalArgumentException} if\n"], "2": ["        return (graph.incidentNodes(edge).size() == 1);\n"], "3": ["  public void addEdge_nullGraph() {\n", "      addEdge(null, E11, ImmutableSet.of(N1));\n", "      fail(\"Should have rejected null graph\");\n", "    } catch (NullPointerException expected) {\n", "    }\n", "  }\n", "\n", "  @Test\n", "  public void addEdge_nullNodes() {\n", "    try {\n", "      addEdge(NetworkBuilder.directed().build(), E11, null);\n", "      fail(\"Should have rejected null nodes\");\n", "    } catch (NullPointerException expected) {\n", "    }\n", "  }\n", "\n", "  @Test\n", "  public void addEdge_tooManyNodes() {\n", "    try {\n", "      addEdge(NetworkBuilder.directed().<Integer, String>build(), E11, ImmutableSet.of(N1, N2, N3));\n", "      fail(\"Should have rejected adding an edge to a Graph with > 2 nodes\");\n", "    } catch (IllegalArgumentException expected) {\n", "    }\n", "  }\n", "\n", "  @Test\n", "  public void addEdge_notEnoughNodes() {\n", "    try {\n", "      addEdge(NetworkBuilder.directed().build(), E11, ImmutableSet.of());\n", "      fail(\"Should have rejected adding an edge to a Graph with < 1 nodes\");\n", "    MutableNetwork<Integer, String> directedGraph = NetworkBuilder.directed().build();\n", "    assertThat(addEdge(directedGraph, E11, ImmutableSet.of(N1))).isTrue();\n", "    assertThat(directedGraph.edges()).containsExactly(E11);\n", "    assertThat(directedGraph.nodes()).containsExactly(N1);\n", "    assertThat(directedGraph.incidentNodes(E11)).containsExactly(N1);\n", "    assertThat(addEdge(directedGraph, E12, ImmutableSet.of(N1, N2))).isTrue();\n", "    assertThat(directedGraph.edges()).containsExactly(E12);\n", "    assertThat(directedGraph.nodes()).containsExactly(N1, N2).inOrder();\n", "    assertThat(directedGraph.incidentNodes(E12)).containsExactly(N1, N2).inOrder();\n"]}, "added_lines": {"1": [76, 77], "2": [85, 86], "3": [356, 358, 359, 360, 367, 368, 369, 375, 376, 377]}, "removed_lines": {"1": [76, 77], "2": [85], "3": [355, 357, 358, 359, 360, 361, 362, 363, 364, 365, 366, 367, 368, 369, 370, 371, 372, 373, 374, 375, 376, 377, 378, 379, 380, 381, 382, 383, 384, 385, 392, 393, 394, 395, 396, 402, 403, 404, 405]}}, {"10": "guava/src/com/google/common/graph/AbstractConfigurableNetwork.java", "added": {"2": ["\n", "  // We could make this a Map<E, Endpoints<N>>. Although it would make incidentNodes(edge)\n", "  // slightly faster, it would also make Networks consume approximately 20% more memory.\n"], "3": ["  public Endpoints<N> incidentNodes(Object edge) {\n", "    N nodeA = checkedReferenceNode(edge);\n", "    N nodeB = nodeConnections.get(nodeA).oppositeNode(edge);\n", "    return isDirected ? Endpoints.ofDirected(nodeA, nodeB) : Endpoints.ofUndirected(nodeA, nodeB);\n"], "4": ["    Endpoints<N> endpoints = incidentNodes(edge);\n", "    Set<E> endpointsIncidentEdges =\n", "        Sets.union(incidentEdges(endpoints.nodeA()), incidentEdges(endpoints.nodeB()));\n", "  public Set<E> edgesConnecting(Object nodeA, Object nodeB) {\n", "    NodeConnections<N, E> connectionsN1 = checkedConnections(nodeA);\n", "    if (!allowsSelfLoops && nodeA.equals(nodeB)) {\n", "    checkArgument(containsNode(nodeB), NODE_NOT_IN_GRAPH, nodeB);\n", "    return connectionsN1.edgesConnecting(nodeB);\n"]}, "removed": {"1": ["import static com.google.common.graph.GraphErrorMessageUtils.NOT_AVAILABLE_ON_UNDIRECTED;\n", "import java.util.Iterator;\n"], "3": ["  public Set<N> incidentNodes(Object edge) {\n", "    N node1 = checkedReferenceNode(edge);\n", "    N node2 = nodeConnections.get(node1).oppositeNode(edge);\n", "    return ImmutableSet.of(node1, node2);\n"], "4": ["    Iterator<N> incidentNodesIterator = incidentNodes(edge).iterator();\n", "    Set<E> endpointsIncidentEdges = incidentEdges(incidentNodesIterator.next());\n", "    while (incidentNodesIterator.hasNext()) {\n", "      endpointsIncidentEdges =\n", "          Sets.union(incidentEdges(incidentNodesIterator.next()), endpointsIncidentEdges);\n", "    }\n", "  public Set<E> edgesConnecting(Object node1, Object node2) {\n", "    NodeConnections<N, E> connectionsN1 = checkedConnections(node1);\n", "    if (!allowsSelfLoops && node1.equals(node2)) {\n", "    checkArgument(containsNode(node2), NODE_NOT_IN_GRAPH, node2);\n", "    return connectionsN1.edgesConnecting(node2);\n"], "5": ["  @Override\n", "  public N source(Object edge) {\n", "    if (!isDirected) {\n", "      throw new UnsupportedOperationException(NOT_AVAILABLE_ON_UNDIRECTED);\n", "    }\n", "    return checkedReferenceNode(edge);\n", "  }\n", "\n", "  @Override\n", "  public N target(Object edge) {\n", "    N source = source(edge);\n", "    return nodeConnections.get(source).oppositeNode(edge);\n", "  }\n", "\n"]}, "added_lines": {"2": [72, 73, 74], "3": [188, 189, 190, 191], "4": [201, 202, 203, 208, 209, 210, 213, 214]}, "removed_lines": {"1": [23, 30], "3": [187, 188, 189, 190], "4": [200, 201, 202, 203, 204, 205, 210, 211, 212, 215, 216], "5": [239, 240, 241, 242, 243, 244, 245, 246, 247, 248, 249, 250, 251, 252]}}, {"11": "guava/src/com/google/common/graph/ConfigurableMutableGraph.java", "added": {"1": ["   * Add an edge between {@code nodeA} and {@code nodeB}; if these nodes are not already\n", "   * Return {@code false} if an edge already exists between {@code nodeA} and {@code nodeB},\n", "   * @throws IllegalArgumentException if self-loops are not allowed, and {@code nodeA} is equal to\n", "   *     {@code nodeB}.\n", "  public boolean addEdge(N nodeA, N nodeB) {\n", "    checkNotNull(nodeA, \"nodeA\");\n", "    checkNotNull(nodeB, \"nodeB\");\n", "    checkArgument(allowsSelfLoops() || !nodeA.equals(nodeB), SELF_LOOPS_NOT_ALLOWED, nodeA);\n", "    boolean containsN1 = containsNode(nodeA);\n", "    boolean containsN2 = containsNode(nodeB);\n", "    if (containsN1 && containsN2 && nodeConnections.get(nodeA).successors().contains(nodeB)) {\n", "      addNode(nodeA);\n", "    NodeAdjacencies<N> connectionsN1 = nodeConnections.get(nodeA);\n", "    connectionsN1.addSuccessor(nodeB);\n", "      addNode(nodeB);\n", "    NodeAdjacencies<N> connectionsN2 = nodeConnections.get(nodeB);\n", "    connectionsN2.addPredecessor(nodeA);\n"], "2": ["  public boolean removeEdge(Object nodeA, Object nodeB) {\n", "    checkNotNull(nodeA, \"nodeA\");\n", "    checkNotNull(nodeB, \"nodeB\");\n", "    NodeAdjacencies<N> connectionsN1 = nodeConnections.get(nodeA);\n", "    if (connectionsN1 == null || !connectionsN1.successors().contains(nodeB)) {\n", "    NodeAdjacencies<N> connectionsN2 = nodeConnections.get(nodeB);\n", "    connectionsN1.removeSuccessor(nodeB);\n", "    connectionsN2.removePredecessor(nodeA);\n"]}, "removed": {"1": ["   * Add an edge between {@code node1} and {@code node2}; if these nodes are not already\n", "   * Return {@code false} if an edge already exists between {@code node1} and {@code node2},\n", "   * @throws IllegalArgumentException if self-loops are not allowed, and {@code node1} is equal to\n", "   *     {@code node2}.\n", "  public boolean addEdge(N node1, N node2) {\n", "    checkNotNull(node1, \"node1\");\n", "    checkNotNull(node2, \"node2\");\n", "    checkArgument(allowsSelfLoops() || !node1.equals(node2), SELF_LOOPS_NOT_ALLOWED, node1);\n", "    boolean containsN1 = containsNode(node1);\n", "    boolean containsN2 = containsNode(node2);\n", "    if (containsN1 && containsN2 && nodeConnections.get(node1).successors().contains(node2)) {\n", "      addNode(node1);\n", "    NodeAdjacencies<N> connectionsN1 = nodeConnections.get(node1);\n", "    connectionsN1.addSuccessor(node2);\n", "      addNode(node2);\n", "    NodeAdjacencies<N> connectionsN2 = nodeConnections.get(node2);\n", "    connectionsN2.addPredecessor(node1);\n"], "2": ["  public boolean removeEdge(Object node1, Object node2) {\n", "    checkNotNull(node1, \"node1\");\n", "    checkNotNull(node2, \"node2\");\n", "    NodeAdjacencies<N> connectionsN1 = nodeConnections.get(node1);\n", "    if (connectionsN1 == null || !connectionsN1.successors().contains(node2)) {\n", "    NodeAdjacencies<N> connectionsN2 = nodeConnections.get(node2);\n", "    connectionsN1.removeSuccessor(node2);\n", "    connectionsN2.removePredecessor(node1);\n"]}, "added_lines": {"1": [59, 61, 64, 65, 69, 70, 71, 72, 73, 74, 76, 80, 82, 83, 85, 87, 88], "2": [115, 116, 117, 118, 119, 122, 123, 124]}, "removed_lines": {"1": [59, 61, 64, 65, 69, 70, 71, 72, 73, 74, 76, 80, 82, 83, 85, 87, 88], "2": [115, 116, 117, 118, 119, 122, 123, 124]}}, {"12": "guava/src/com/google/common/graph/ConfigurableMutableNetwork.java", "added": {"1": ["   * Return {@code false} if {@code edge} already exists between {@code nodeA} and {@code nodeB},\n", "   *         exists from {@code nodeA} to {@code nodeB}, and this is not a multigraph.\n", "   *         Also, if self-loops are not allowed, and {@code nodeA} is equal to {@code nodeB}.\n", "  public boolean addEdge(E edge, N nodeA, N nodeB) {\n", "    checkNotNull(nodeA, \"nodeA\");\n", "    checkNotNull(nodeB, \"nodeB\");\n", "    checkArgument(allowsSelfLoops() || !nodeA.equals(nodeB), SELF_LOOPS_NOT_ALLOWED, nodeA);\n", "    boolean containsN1 = containsNode(nodeA);\n", "    boolean containsN2 = containsNode(nodeB);\n", "      checkArgument(containsN1 && containsN2 && edgesConnecting(nodeA, nodeB).contains(edge),\n", "          REUSING_EDGE, edge, incidentNodes(edge), nodeA, nodeB);\n", "      checkArgument(!(containsN1 && containsN2 && successors(nodeA).contains(nodeB)),\n", "          ADDING_PARALLEL_EDGE, nodeA, nodeB);\n", "      addNode(nodeA);\n", "    NodeConnections<N, E> connectionsN1 = nodeConnections.get(nodeA);\n", "    connectionsN1.addOutEdge(edge, nodeB);\n", "      addNode(nodeB);\n", "    NodeConnections<N, E> connectionsN2 = nodeConnections.get(nodeB);\n", "    connectionsN2.addInEdge(edge, nodeA);\n", "    edgeToReferenceNode.put(edge, nodeA);\n"], "2": ["    N nodeA = edgeToReferenceNode.get(edge);\n", "    if (nodeA == null) {\n", "    N nodeB = nodeConnections.get(nodeA).oppositeNode(edge);\n", "    nodeConnections.get(nodeA).removeOutEdge(edge);\n", "    nodeConnections.get(nodeB).removeInEdge(edge);\n"]}, "removed": {"1": ["   * Return {@code false} if {@code edge} already exists between {@code node1} and {@code node2},\n", "   *         exists from {@code node1} to {@code node2}, and this is not a multigraph.\n", "   *         Also, if self-loops are not allowed, and {@code node1} is equal to {@code node2}.\n", "  public boolean addEdge(E edge, N node1, N node2) {\n", "    checkNotNull(node1, \"node1\");\n", "    checkNotNull(node2, \"node2\");\n", "    checkArgument(allowsSelfLoops() || !node1.equals(node2), SELF_LOOPS_NOT_ALLOWED, node1);\n", "    boolean containsN1 = containsNode(node1);\n", "    boolean containsN2 = containsNode(node2);\n", "      checkArgument(containsN1 && containsN2 && edgesConnecting(node1, node2).contains(edge),\n", "          REUSING_EDGE, edge, incidentNodes(edge), node1, node2);\n", "      checkArgument(!(containsN1 && containsN2 && successors(node1).contains(node2)),\n", "          ADDING_PARALLEL_EDGE, node1, node2);\n", "      addNode(node1);\n", "    NodeConnections<N, E> connectionsN1 = nodeConnections.get(node1);\n", "    connectionsN1.addOutEdge(edge, node2);\n", "      addNode(node2);\n", "    NodeConnections<N, E> connectionsN2 = nodeConnections.get(node2);\n", "    connectionsN2.addInEdge(edge, node1);\n", "    edgeToReferenceNode.put(edge, node1);\n"], "2": ["    N node1 = edgeToReferenceNode.get(edge);\n", "    if (node1 == null) {\n", "    N node2 = nodeConnections.get(node1).oppositeNode(edge);\n", "    nodeConnections.get(node1).removeOutEdge(edge);\n", "    nodeConnections.get(node2).removeInEdge(edge);\n"]}, "added_lines": {"1": [64, 68, 69, 73, 75, 76, 77, 78, 79, 81, 82, 85, 86, 89, 91, 92, 94, 96, 97, 98], "2": [122, 123, 126, 127, 128]}, "removed_lines": {"1": [64, 68, 69, 73, 75, 76, 77, 78, 79, 81, 82, 85, 86, 89, 91, 92, 94, 96, 97, 98], "2": [122, 123, 126, 127, 128]}}, {"13": "guava/src/com/google/common/graph/Endpoints.java", "added": {"1": ["/*\n", " * Copyright (C) 2016 The Guava Authors\n", " *\n", " * Licensed under the Apache License, Version 2.0 (the \"License\");\n", " * you may not use this file except in compliance with the License.\n", " * You may obtain a copy of the License at\n", " *\n", " * http://www.apache.org/licenses/LICENSE-2.0\n", " *\n", " * Unless required by applicable law or agreed to in writing, software\n", " * distributed under the License is distributed on an \"AS IS\" BASIS,\n", " * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n", " * See the License for the specific language governing permissions and\n", " * limitations under the License.\n", " */\n", "\n", "package com.google.common.graph;\n", "\n", "import static com.google.common.base.Preconditions.checkNotNull;\n", "import static com.google.common.graph.GraphErrorMessageUtils.NOT_AVAILABLE_ON_UNDIRECTED;\n", "\n", "import com.google.common.base.Objects;\n", "import com.google.common.collect.ImmutableSet;\n", "import com.google.common.collect.UnmodifiableIterator;\n", "\n", "import java.util.AbstractCollection;\n", "import java.util.Collection;\n", "import java.util.NoSuchElementException;\n", "\n", "/**\n", " * An immutable {@link Collection} to represent the endpoints of an edge in a graph.\n", " * <p>\n", " * If an {@link Endpoints} is directed, it is an ordered pair of nodes (source and target).\n", " * Otherwise, it is an unordered pair of nodes that can be accessed through the iterator.\n", " *\n", " * @author James Sexton\n", " * @since 20.0\n", " */\n", "public abstract class Endpoints<N> extends AbstractCollection<N> {\n", "  private final N nodeA;\n", "  private final N nodeB;\n", "\n", "  private Endpoints(N nodeA, N nodeB) {\n", "    this.nodeA = checkNotNull(nodeA);\n", "    this.nodeB = checkNotNull(nodeB);\n", "  }\n", "\n", "  /**\n", "   * Returns an {@link Endpoints} representing the endpoints of a directed edge.\n", "   */\n", "  public static <N> Endpoints<N> ofDirected(N source, N target) {\n", "    return new Directed<N>(source, target);\n", "  }\n", "\n", "  /**\n", "   * Returns an {@link Endpoints} representing the endpoints of an undirected edge.\n", "   */\n", "  public static <N> Endpoints<N> ofUndirected(N nodeA, N nodeB) {\n", "    return new Undirected<N>(nodeA, nodeB);\n", "  }\n", "\n", "  /**\n", "   * Returns whether the nodes of this {@link Endpoints} are ordered. Generally, this is equal to\n", "   * {@link Graph#isDirected()} of the graph that generated this {@link Endpoints}.\n", "   */\n", "  public abstract boolean isDirected();\n", "\n", "  /**\n", "   * If this {@link Endpoints} is directed, returns the node which is the source.\n", "   *\n", "   * @throws UnsupportedOperationException if this Endpoints is not directed\n", "   */\n", "  public abstract N source();\n", "\n", "  /**\n", "   * If this {@link Endpoints} is directed, returns the node which is the target.\n", "   *\n", "   * @throws UnsupportedOperationException if this Endpoints is not directed\n", "   */\n", "  public abstract N target();\n", "\n", "  /**\n", "   * If this {@link Endpoints} is directed, returns the node which is the source.\n", "   * Otherwise, returns an arbitrary (but consistent) endpoint of the edge.\n", "   */\n", "  N nodeA() {\n", "    return nodeA;\n", "  }\n", "\n", "  /**\n", "   * Returns the node that is opposite {@link #nodeA()}. In the directed case, this is the target.\n", "   */\n", "  N nodeB() {\n", "    return nodeB;\n", "  }\n", "\n", "  @Override\n", "  public UnmodifiableIterator<N> iterator() {\n", "    return new UnmodifiableIterator<N>() {\n", "      private int pos = 0;\n", "\n", "      @Override\n", "      public boolean hasNext() {\n", "        return pos < 2;\n", "      }\n", "\n", "      @Override\n", "      public N next() {\n", "        switch (pos++) {\n", "          case 0:\n", "            return nodeA;\n", "          case 1:\n", "            return nodeB;\n", "          default:\n", "            pos = 2;\n", "            throw new NoSuchElementException();\n", "        }\n", "      }\n", "    };\n", "  }\n", "\n", "  @Override\n", "  public int size() {\n", "    return 2;\n", "  }\n", "\n", "  @Override\n", "  public boolean contains(Object obj) {\n", "    return nodeA.equals(obj) || nodeB.equals(obj);\n", "  }\n", "\n", "  /**\n", "   * If two {@link Endpoints}s are directed, the source and target must be equal to be considered\n", "   * equal. If two {@link Endpoints}s are undirected, the unordered set of nodes must be equal to be\n", "   * considered equal. Directed {@link Endpoints} are never equal to undirected {@link Endpoints}.\n", "   */\n", "  @Override\n", "  public abstract boolean equals(Object obj);\n", "\n", "  @Override\n", "  public abstract int hashCode();\n", "\n", "  private static final class Directed<N> extends Endpoints<N> {\n", "    private Directed(N source, N target) {\n", "      super(source, target);\n", "    }\n", "\n", "    @Override\n", "    public boolean isDirected() {\n", "      return true;\n", "    }\n", "\n", "    @Override\n", "    public N source() {\n", "      return nodeA();\n", "    }\n", "\n", "    @Override\n", "    public N target() {\n", "      return nodeB();\n", "    }\n", "\n", "    @Override\n", "    public boolean equals(Object obj) {\n", "      if (obj == this) {\n", "        return true;\n", "      }\n", "      if (!(obj instanceof Directed)) {\n", "        return false;\n", "      }\n", "      Directed<?> other = (Directed<?>) obj;\n", "      return source().equals(other.source()) && target().equals(other.target());\n", "    }\n", "\n", "    @Override\n", "    public int hashCode() {\n", "      return Objects.hashCode(source(), target());\n", "    }\n", "\n", "    @Override\n", "    public String toString() {\n", "      return String.format(\"<%s -> %s>\", source(), target());\n", "    }\n", "  }\n", "\n", "  private static final class Undirected<N> extends Endpoints<N> {\n", "    private Undirected(N nodeA, N nodeB) {\n", "      super(nodeA, nodeB);\n", "    }\n", "\n", "    @Override\n", "    public boolean isDirected() {\n", "      return false;\n", "    }\n", "\n", "    @Override\n", "    public N source() {\n", "      throw new UnsupportedOperationException(NOT_AVAILABLE_ON_UNDIRECTED);\n", "    }\n", "\n", "    @Override\n", "    public N target() {\n", "      throw new UnsupportedOperationException(NOT_AVAILABLE_ON_UNDIRECTED);\n", "    }\n", "\n", "    @Override\n", "    public boolean equals(Object obj) {\n", "      if (obj == this) {\n", "        return true;\n", "      }\n", "      if (!(obj instanceof Undirected)) {\n", "        return false;\n", "      }\n", "      Undirected<?> other = (Undirected<?>) obj;\n", "      return (nodeA().equals(other.nodeA()) && nodeB().equals(other.nodeB()))\n", "          || (nodeA().equals(other.nodeB()) && nodeB().equals(other.nodeA()));\n", "    }\n", "\n", "    @Override\n", "    public int hashCode() {\n", "      return nodeA().hashCode() ^ nodeB().hashCode();\n", "    }\n", "\n", "    @Override\n", "    public String toString() {\n", "      // TODO(b/29393648): Update tests so we can remove this method (defer to AbstractCollection).\n", "      return ImmutableSet.copyOf(this).toString();\n", "    }\n", "  }\n", "}\n"]}, "removed": {}, "added_lines": {"1": [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 58, 59, 60, 61, 62, 63, 64, 65, 66, 67, 68, 69, 70, 71, 72, 73, 74, 75, 76, 77, 78, 79, 80, 81, 82, 83, 84, 85, 86, 87, 88, 89, 90, 91, 92, 93, 94, 95, 96, 97, 98, 99, 100, 101, 102, 103, 104, 105, 106, 107, 108, 109, 110, 111, 112, 113, 114, 115, 116, 117, 118, 119, 120, 121, 122, 123, 124, 125, 126, 127, 128, 129, 130, 131, 132, 133, 134, 135, 136, 137, 138, 139, 140, 141, 142, 143, 144, 145, 146, 147, 148, 149, 150, 151, 152, 153, 154, 155, 156, 157, 158, 159, 160, 161, 162, 163, 164, 165, 166, 167, 168, 169, 170, 171, 172, 173, 174, 175, 176, 177, 178, 179, 180, 181, 182, 183, 184, 185, 186, 187, 188, 189, 190, 191, 192, 193, 194, 195, 196, 197, 198, 199, 200, 201, 202, 203, 204, 205, 206, 207, 208, 209, 210, 211, 212, 213, 214, 215, 216, 217, 218, 219, 220, 221, 222, 223, 224, 225, 226, 227, 228, 229, 230]}, "removed_lines": {}}, {"14": "guava/src/com/google/common/graph/Graph.java", "added": {"1": [" * <li>{@code nodeA} and {@code nodeB} are mutually <b>adjacent</b> (or <b>connected</b>) in\n", " *       graph.addEdge(nodeA, nodeB);  // after this returns, nodeA and nodeB are adjacent\n", " *   <li>{@code nodeA} is a <b>predecessor</b> of {code nodeB} in {@code graph}\n", " *   <li>{@code nodeB} is a <b>successor</b> of {@code nodeA} in {@code graph}\n", " *   <li>{@code nodeA} has an (implicit) outgoing edge to {@code nodeB} in {@code graph}\n", " *   <li>{@code nodeB} has an (implicit) incoming edge from {@code nodeA} in {@code graph}\n", " *   <li>{@code nodeA} and {@code nodeB} are mutually predecessors and successors\n", " *   <li>{@code nodeA} has an (implicit) edge in {@code graph} that is both outgoing to\n", " *       to {@code nodeB} and incoming from {@code nodeB}, and vice versa.\n"], "2": [" *   <li>They must be unique in a graph: nodes {@code nodeA} and {@code nodeB} are considered\n", " *       different if and only if {@code nodeA.equals(nodeB) == false}.\n"]}, "removed": {"1": [" * <li>{@code node1} and {@code node2} are mutually <b>adjacent</b> (or <b>connected</b>) in\n", " *       graph.addEdge(node1, node2);  // after this returns, node1 and node2 are adjacent\n", " *   <li>{@code node1} is a <b>predecessor</b> of {code node2} in {@code graph}\n", " *   <li>{@code node2} is a <b>successor</b> of {@code node1} in {@code graph}\n", " *   <li>{@code node1} has an (implicit) outgoing edge to {@code node2} in {@code graph}\n", " *   <li>{@code node2} has an (implicit) incoming edge from {@code node1} in {@code graph}\n", " *   <li>{@code node1} and {@code node2} are mutually predecessors and successors\n", " *   <li>{@code node1} has an (implicit) edge in {@code graph} that is both outgoing to\n", " *       to {@code node2} and incoming from {@code node2}, and vice versa.\n"], "2": [" *   <li>They must be unique in a graph: nodes {@code node1} and {@code node2} are considered\n", " *       different if and only if {@code node1.equals(node2) == false}.\n"]}, "added_lines": {"1": [49, 52, 56, 57, 58, 59, 63, 65, 66], "2": [75, 76]}, "removed_lines": {"1": [49, 52, 56, 57, 58, 59, 63, 65, 66], "2": [75, 76]}}, {"15": "guava/src/com/google/common/graph/GraphErrorMessageUtils.java", "added": {"1": ["      \"Cannot add self-loop edge on node %s, as self-loops are not allowed.\";\n", "      \"Cannot call source()/target() on undirected endpoints.\";\n", "  static final String ENDPOINTS_GRAPH_DIRECTEDNESS =\n", "      \"The endpoints' directedness (isDirected = %s) does not match the graph's directedness \"\n", "          + \"(isDirected = %s). A graph cannot have both directed and undirected edges.\";\n"]}, "removed": {"1": ["      \"Can't add self-loop edge on node %s, as self-loops are not allowed.\";\n", "      \"Cannot call source()/target() on an undirected graph. \"\n", "          + \"Consider using incidentNodes() (if you don't know either incident node) \"\n", "          + \"or Graphs.oppositeNode() (if you know one of the incident nodes).\";\n"]}, "added_lines": {"1": [34, 36, 37, 38, 39]}, "removed_lines": {"1": [34, 36, 37, 38]}}, {"16": "guava/src/com/google/common/graph/Graphs.java", "added": {"1": ["import static com.google.common.graph.GraphErrorMessageUtils.ENDPOINTS_GRAPH_DIRECTEDNESS;\n"], "3": ["    Endpoints<N> endpoints = graph.incidentNodes(edge);\n", "    if (node.equals(endpoints.nodeA())) {\n", "      return endpoints.nodeB();\n", "      checkArgument(node.equals(endpoints.nodeB()),\n", "          \"Edge %s is not incident to node %s\", edge, node);\n", "      return endpoints.nodeA();\n"], "4": ["    Endpoints<N> endpoints = graph.incidentNodes(edge); // Verifies that edge is in graph\n", "    return Sets.difference(graph.edgesConnecting(endpoints.nodeA(), endpoints.nodeB()),\n", "        ImmutableSet.of(edge)); // An edge is not parallel to itself.\n", "   * Adds {@code edge} to {@code graph} with the specified {@code endpoints}.\n", "  public static <N, E> boolean addEdge(MutableNetwork<N, E> graph, E edge, Endpoints<N> endpoints) {\n", "    checkNotNull(endpoints, \"endpoints\");\n", "    checkArgument(endpoints.isDirected() == graph.isDirected(),\n", "        ENDPOINTS_GRAPH_DIRECTEDNESS, endpoints.isDirected(), graph.isDirected());\n", "    return graph.addEdge(edge, endpoints.nodeA(), endpoints.nodeB());\n"], "5": ["    for (N node : Sets.filter(graph.nodes(), nodePredicate)) {\n", "      copy.addNode(node);\n", "      for (N successor : Sets.filter(graph.successors(node), nodePredicate)) {\n", "        copy.addEdge(node, successor);\n"], "6": ["    for (E edge : Sets.filter(graph.edges(), edgePredicate)) {\n", "      Endpoints<N> endpoints = graph.incidentNodes(edge);\n", "      if (copy.nodes().containsAll(endpoints)) {\n", "        addEdge(copy, edge, endpoints);\n"], "7": ["    if (graph instanceof Network) {\n", "      return hashCode((Network<?, ?>) graph);\n", "    }\n", "    return nodeToAdjacentNodes(graph).hashCode();\n"], "8": ["  /**\n", "   * Returns a map that is a live view of {@code graph}, with nodes as keys\n", "   * and the set of adjacent nodes as values.\n", "   */\n"], "9": ["    checkNotNull(graph, \"graph\");\n"]}, "removed": {"2": ["import java.util.Iterator;\n"], "3": ["   * @throws UnsupportedOperationException if {@code graph} is a {@link Hypergraph}\n", "    if (graph instanceof Hypergraph) {\n", "      throw new UnsupportedOperationException();\n", "    }\n", "\n", "    Iterator<N> incidentNodesIterator = graph.incidentNodes(edge).iterator();\n", "    N node1 = incidentNodesIterator.next();\n", "    N node2 = incidentNodesIterator.hasNext() ? incidentNodesIterator.next() : node1;\n", "    if (node.equals(node1)) {\n", "      return node2;\n", "      checkArgument(node.equals(node2), \"Edge %s is not incident to node %s\", edge, node);\n", "      return node1;\n"], "4": ["   * @throws UnsupportedOperationException if {@code graph} is a {@link Hypergraph}\n", "    if (graph instanceof Hypergraph) {\n", "      throw new UnsupportedOperationException();\n", "    }\n", "\n", "    Set<N> incidentNodes = graph.incidentNodes(edge); // Verifies that edge is in graph\n", "    Iterator<N> incidentNodesIterator = incidentNodes.iterator();\n", "    N node1 = incidentNodesIterator.next();\n", "    N node2 = incidentNodesIterator.hasNext() ? incidentNodesIterator.next() : node1;\n", "    return Sets.difference(graph.edgesConnecting(node1, node2), ImmutableSet.of(edge));\n", "   * Adds {@code edge} to {@code graph} with the specified incident {@code nodes}, in the order\n", "   * returned by {@code nodes}' iterator.\n", "  public static <N, E> boolean addEdge(MutableNetwork<N, E> graph, E edge, Iterable<N> nodes) {\n", "    checkNotNull(nodes, \"nodes\");\n", "    if (graph instanceof Hypergraph) {\n", "      return ((Hypergraph<N, E>) graph).addEdge(edge, nodes);\n", "    }\n", "\n", "    Iterator<N> nodesIterator = nodes.iterator();\n", "    checkArgument(nodesIterator.hasNext(),\n", "        \"'graph' is not a Hypergraph, and 'nodes' has < 1 elements: %s\", nodes);\n", "    N node1 = nodesIterator.next();\n", "    N node2 = nodesIterator.hasNext() ? nodesIterator.next() : node1;\n", "    checkArgument(!nodesIterator.hasNext(),\n", "        \"'graph' is not a Hypergraph, and 'nodes' has > 2 elements: %s\", nodes);\n", "    return graph.addEdge(edge, node1, node2);\n"], "5": ["    for (N node : graph.nodes()) {\n", "      if (nodePredicate.apply(node)) {\n", "        copy.addNode(node);\n", "        for (N successor : graph.successors(node)) {\n", "          if (nodePredicate.apply(successor)) {\n", "            copy.addEdge(node, successor);\n", "          }\n", "        }\n"], "6": ["    for (E edge : graph.edges()) {\n", "      if (edgePredicate.apply(edge)) {\n", "        Set<N> incidentNodes = graph.incidentNodes(edge);\n", "        if (copy.nodes().containsAll(incidentNodes)) {\n", "          addEdge(copy, edge, incidentNodes);\n", "        }\n"], "7": ["    return (graph instanceof Network)\n", "        ? hashCode((Network<?, ?>) graph)\n", "        : nodeToAdjacentNodes(graph).hashCode();\n"], "9": ["    if (graph.isDirected()) {\n", "      return new Function<Object, String>() {\n", "        @Override\n", "        public String apply(Object edge) {\n", "          return String.format(\"<%s -> %s>\",\n", "              graph.source(edge), graph.target(edge));\n", "          }\n", "        };\n", "    }\n"]}, "added_lines": {"1": [21], "3": [62, 63, 64, 66, 67, 68], "4": [79, 83, 84, 88, 91, 94, 95, 96, 97], "5": [116, 117, 118, 119], "6": [172, 173, 174, 175], "7": [310, 311, 312, 313], "8": [383, 384, 385, 386], "9": [403]}, "removed_lines": {"2": [33], "3": [58, 62, 63, 64, 65, 67, 68, 69, 70, 71, 73, 74], "4": [82, 86, 87, 88, 89, 90, 94, 95, 96, 97, 101, 102, 105, 108, 109, 110, 111, 112, 113, 114, 115, 116, 117, 118, 119, 120], "5": [139, 140, 141, 142, 143, 144, 145, 146], "6": [199, 200, 201, 202, 203, 204], "7": [339, 340, 341], "9": [427, 428, 429, 430, 431, 432, 433, 434, 435]}}, {"17": "guava/src/com/google/common/graph/Hypergraph.java", "added": {}, "removed": {"1": ["  /**\n", "   * Source is not applicable to hypergraphs.\n", "   *\n", "   * @throws UnsupportedOperationException always\n", "   * @deprecated Unsupported operation. Call {@link #incidentNodes(Object)} instead.\n", "   */\n", "  @Deprecated\n", "  @Override\n", "  N source(Object edge);\n", "\n", "  /**\n", "   * Target is not applicable to hypergraphs.\n", "   *\n", "   * @throws UnsupportedOperationException always\n", "   * @deprecated Unsupported operation. Call {@link #incidentNodes(Object)} instead.\n", "   */\n", "  @Deprecated\n", "  @Override\n", "  N target(Object edge);\n", "\n"]}, "added_lines": {}, "removed_lines": {"1": [41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 58, 59, 60]}}, {"18": "guava/src/com/google/common/graph/ImmutableGraph.java", "added": {"1": [" * <p>The time complexity of {@code edgesConnecting(nodeA, nodeB)} is O(min(outD_nodeA, inD_nodeB)).\n"]}, "removed": {"1": [" * <p>The time complexity of {@code edgesConnecting(node1, node2)} is O(min(outD_node1, inD_node2)).\n"]}, "added_lines": {"1": [31]}, "removed_lines": {"1": [31]}}, {"19": "guava/src/com/google/common/graph/ImmutableNetwork.java", "added": {"1": [" * <p>The time complexity of {@code edgesConnecting(nodeA, nodeB)} is O(min(outD_nodeA, inD_nodeB)).\n"], "2": ["  public Set<E> edgesConnecting(Object nodeA, Object nodeB) {\n", "    return ImmutableSet.copyOf(super.edgesConnecting(nodeA, nodeB));\n"], "3": ["      edgeToReferenceNode.put(edge, graph.incidentNodes(edge).nodeA());\n"], "4": ["        return graph.incidentNodes(edge).source();\n"], "5": ["        return graph.incidentNodes(edge).target();\n"]}, "removed": {"1": [" * <p>The time complexity of {@code edgesConnecting(node1, node2)} is O(min(outD_node1, inD_node2)).\n"], "2": ["  public Set<E> edgesConnecting(Object node1, Object node2) {\n", "    return ImmutableSet.copyOf(super.edgesConnecting(node1, node2));\n"], "3": ["      edgeToReferenceNode.put(edge, graph.incidentNodes(edge).iterator().next());\n"], "4": ["        return graph.source(edge);\n"], "5": ["        return graph.target(edge);\n"]}, "added_lines": {"1": [33], "2": [67, 70], "3": [90], "4": [115], "5": [124]}, "removed_lines": {"1": [33], "2": [67, 70], "3": [90], "4": [115], "5": [124]}}, {"20": "guava/src/com/google/common/graph/MutableGraph.java", "added": {"1": ["   * Adds an (implicit) edge to this graph connecting {@code nodeA} to {@code nodeB}\n", "   * <p>Behavior if {@code nodeA} and {@code nodeB} are not already elements of the graph is\n", "   * unspecified. Suggested behaviors include (a) silently adding {@code nodeA} and {@code nodeB}\n", "   * <p>Currently, this type does not support parallel edges.  {@code addEdge(nodeA, nodeB)} will\n", "   * {@code Network.addEdge(e, nodeA, nodeB)}).  A hypothetical instance that supported parallel\n", "   * edges would add a new edge between {@code nodeA} and {@code nodeB} for every call to\n", "   * {@code addEdge(nodeA, nodeB)}, and return {@code true} every time.\n", "  boolean addEdge(N nodeA, N nodeB);\n"], "2": ["   * Removes an edge connecting {@code nodeA} to {@code nodeB} from this graph, if one is present\n"], "3": ["  boolean removeEdge(Object nodeA, Object nodeB);\n"]}, "removed": {"1": ["   * Adds an (implicit) edge to this graph connecting {@code node1} to {@code node2}\n", "   * <p>Behavior if {@code node1} and {@code node2} are not already elements of the graph is\n", "   * unspecified. Suggested behaviors include (a) silently adding {@code node1} and {@code node2}\n", "   * <p>Currently, this type does not support parallel edges.  {@code addEdge(node1, node2)} will\n", "   * {@code Network.addEdge(e, node1, node2)}).  A hypothetical instance that supported parallel\n", "   * edges would add a new edge between {@code node1} and {@code node2} for every call to\n", "   * {@code addEdge(node1, node2)}, and return {@code true} every time.\n", "  boolean addEdge(N node1, N node2);\n"], "2": ["   * Removes an edge connecting {@code node1} to {@code node2} from this graph, if one is present\n"], "3": ["  boolean removeEdge(Object node1, Object node2);\n"]}, "added_lines": {"1": [45, 48, 49, 52, 54, 55, 56, 62], "2": [76], "3": [86]}, "removed_lines": {"1": [45, 48, 49, 52, 54, 55, 56, 62], "2": [76], "3": [86]}}, {"21": "guava/src/com/google/common/graph/MutableNetwork.java", "added": {"1": ["   * Adds {@code edge} to this graph, connecting {@code nodeA} to {@code nodeB}\n", "   * <p>If {@code edge} already connects {@code nodeA} to {@code nodeB} in this graph\n", "   * <p>Behavior if {@code nodeA} and {@code nodeB} are not already elements of the graph is\n", "   * unspecified. Suggested behaviors include (a) silently adding {@code nodeA} and {@code nodeB}\n", "   *     {@code nodeA} and {@code nodeB}, or if the graph is not a multigraph and {@code nodeA} is\n", "   *     already connected to {@code nodeB}\n", "  boolean addEdge(E edge, N nodeA, N nodeB);\n"]}, "removed": {"1": ["   * Adds {@code edge} to this graph, connecting {@code node1} to {@code node2}\n", "   * <p>If {@code edge} already connects {@code node1} to {@code node2} in this graph\n", "   * <p>Behavior if {@code node1} and {@code node2} are not already elements of the graph is\n", "   * unspecified. Suggested behaviors include (a) silently adding {@code node1} and {@code node2}\n", "   *     {@code node1} and {@code node2}, or if the graph is not a multigraph and {@code node1} is\n", "   *     already connected to {@code node2}\n", "  boolean addEdge(E edge, N node1, N node2);\n"]}, "added_lines": {"1": [46, 51, 55, 56, 61, 62, 66]}, "removed_lines": {"1": [46, 51, 55, 56, 61, 62, 66]}}, {"22": "guava/src/com/google/common/graph/Network.java", "added": {"1": [" * <li>{@code nodeA} and {@code nodeB} are mutually <b>adjacent</b> if both are incident\n"], "2": [" *       <br>Thus, in the following example {@code edge1} is an incoming edge of {@code nodeB} and\n", " *       an outgoing edge of {@code nodeA}, while {@code edge2} is both an incoming and an outgoing\n", " *         directedGraph.addEdge(edge1, nodeA, nodeB);\n"], "3": [" *   <li>They must be unique in a graph: nodes {@code nodeA} and {@code nodeB} are considered\n", " *       different if and only if {@code nodeA.equals(nodeB) == false}, and the same for edges.\n"], "4": ["   * {@linkplain Endpoints#source() source}, and an {@linkplain #inEdges(Object) incoming edge}\n", "   * of its {@linkplain Endpoints#target() target}. An undirected edge connects its\n"], "5": ["   * Returns the nodes which are the endpoints of {@code edge} in this graph as {@link Endpoints}.\n", "  Endpoints<N> incidentNodes(Object edge);\n"], "6": ["   * Returns the set of edges that connect {@code nodeA} to {@code nodeB}.\n", "   * <p>This set is the intersection of {@code outEdges(nodeA)} and {@code inEdges(nodeB)}. If\n", "   * {@code nodeA} is equal to {@code nodeB}, then it is the set of self-loop edges for that node.\n", "   * @throws IllegalArgumentException if {@code nodeA} or {@code nodeB} is not an element\n", "  Set<E> edgesConnecting(Object nodeA, Object nodeB);\n"]}, "removed": {"1": [" * <li>{@code node1} and {@code node2} are mutually <b>adjacent</b> if both are incident\n"], "2": [" *       <br>Thus, in the following example {@code edge1} is an incoming edge of {@code node2} and\n", " *       an outgoing edge of {@code node1}, while {@code edge2} is both an incoming and an outgoing\n", " *         directedGraph.addEdge(edge1, node1, node2);\n"], "3": [" *   <li>They must be unique in a graph: nodes {@code node1} and {@code node2} are considered\n", " *       different if and only if {@code node1.equals(node2) == false}, and the same for edges.\n"], "4": ["   * {@linkplain #source(Object) source}, and an {@linkplain #inEdges(Object) incoming edge} of its\n", "   * {@linkplain #target(Object) target}. An undirected edge connects its\n"], "5": ["   * Returns the nodes which are the endpoints of {@code edge} in this graph.\n", "   *\n", "   * <p>For self-loop edges, the returned set's size will be 1. If the graph is\n", "   * {@linkplain #isDirected() directed} and {@code edge} is not a self-loop, the\n", "   * iteration order will be {@code [source(edge), target(edge)]}.\n", "  Set<N> incidentNodes(Object edge);\n"], "6": ["   * Returns the set of edges that connect {@code node1} to {@code node2}.\n", "   * <p>This set is the intersection of {@code outEdges(node1)} and {@code inEdges(node2)}. If\n", "   * {@code node1} is equal to {@code node2}, then it is the set of self-loop edges for that node.\n", "   * @throws IllegalArgumentException if {@code node1} or {@code node2} is not an element\n", "  Set<E> edgesConnecting(Object node1, Object node2);\n"], "7": ["  /**\n", "   * For a directed graph, returns the node for which {@code edge} is an outgoing edge.\n", "   * For an undirected graph, throws an {@link UnsupportedOperationException}.\n", "   */\n", "  N source(Object edge);\n", "\n", "  /**\n", "   * For a directed graph, returns the node for which {@code edge} is an incoming edge.\n", "   * For an undirected graph, throws an {@link UnsupportedOperationException}.\n", "   */\n", "  N target(Object edge);\n", "\n"]}, "added_lines": {"1": [50], "2": [64, 65, 68], "3": [91, 92], "4": [223, 224], "5": [255, 259], "6": [282, 284, 285, 287, 290]}, "removed_lines": {"1": [50], "2": [64, 65, 68], "3": [91, 92], "4": [223, 224], "5": [255, 256, 257, 258, 259, 263], "6": [286, 288, 289, 291, 294], "7": [316, 317, 318, 319, 320, 321, 322, 323, 324, 325, 326, 327]}}]}
