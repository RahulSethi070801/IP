{
    "addition": {
        "50": " * <li>{@code nodeA} and {@code nodeB} are mutually <b>adjacent</b> if both are incident\n",
        "64": " *       <br>Thus, in the following example {@code edge1} is an incoming edge of {@code nodeB} and\n",
        "65": " *       an outgoing edge of {@code nodeA}, while {@code edge2} is both an incoming and an outgoing\n",
        "68": " *         directedGraph.addEdge(edge1, nodeA, nodeB);\n",
        "91": " *   <li>They must be unique in a graph: nodes {@code nodeA} and {@code nodeB} are considered\n",
        "92": " *       different if and only if {@code nodeA.equals(nodeB) == false}, and the same for edges.\n",
        "223": "   * {@linkplain Endpoints#source() source}, and an {@linkplain #inEdges(Object) incoming edge}\n",
        "224": "   * of its {@linkplain Endpoints#target() target}. An undirected edge connects its\n",
        "255": "   * Returns the nodes which are the endpoints of {@code edge} in this graph as {@link Endpoints}.\n",
        "259": "  Endpoints<N> incidentNodes(Object edge);\n",
        "282": "   * Returns the set of edges that connect {@code nodeA} to {@code nodeB}.\n",
        "284": "   * <p>This set is the intersection of {@code outEdges(nodeA)} and {@code inEdges(nodeB)}. If\n",
        "285": "   * {@code nodeA} is equal to {@code nodeB}, then it is the set of self-loop edges for that node.\n",
        "287": "   * @throws IllegalArgumentException if {@code nodeA} or {@code nodeB} is not an element\n",
        "290": "  Set<E> edgesConnecting(Object nodeA, Object nodeB);\n"
    },
    "removed": {
        "50": " * <li>{@code node1} and {@code node2} are mutually <b>adjacent</b> if both are incident\n",
        "64": " *       <br>Thus, in the following example {@code edge1} is an incoming edge of {@code node2} and\n",
        "65": " *       an outgoing edge of {@code node1}, while {@code edge2} is both an incoming and an outgoing\n",
        "68": " *         directedGraph.addEdge(edge1, node1, node2);\n",
        "91": " *   <li>They must be unique in a graph: nodes {@code node1} and {@code node2} are considered\n",
        "92": " *       different if and only if {@code node1.equals(node2) == false}, and the same for edges.\n",
        "223": "   * {@linkplain #source(Object) source}, and an {@linkplain #inEdges(Object) incoming edge} of its\n",
        "224": "   * {@linkplain #target(Object) target}. An undirected edge connects its\n",
        "255": "   * Returns the nodes which are the endpoints of {@code edge} in this graph.\n",
        "256": "   *\n",
        "257": "   * <p>For self-loop edges, the returned set's size will be 1. If the graph is\n",
        "258": "   * {@linkplain #isDirected() directed} and {@code edge} is not a self-loop, the\n",
        "259": "   * iteration order will be {@code [source(edge), target(edge)]}.\n",
        "263": "  Set<N> incidentNodes(Object edge);\n",
        "286": "   * Returns the set of edges that connect {@code node1} to {@code node2}.\n",
        "288": "   * <p>This set is the intersection of {@code outEdges(node1)} and {@code inEdges(node2)}. If\n",
        "289": "   * {@code node1} is equal to {@code node2}, then it is the set of self-loop edges for that node.\n",
        "291": "   * @throws IllegalArgumentException if {@code node1} or {@code node2} is not an element\n",
        "294": "  Set<E> edgesConnecting(Object node1, Object node2);\n",
        "316": "  /**\n",
        "317": "   * For a directed graph, returns the node for which {@code edge} is an outgoing edge.\n",
        "318": "   * For an undirected graph, throws an {@link UnsupportedOperationException}.\n",
        "319": "   */\n",
        "320": "  N source(Object edge);\n",
        "321": "\n",
        "322": "  /**\n",
        "323": "   * For a directed graph, returns the node for which {@code edge} is an incoming edge.\n",
        "324": "   * For an undirected graph, throws an {@link UnsupportedOperationException}.\n",
        "325": "   */\n",
        "326": "  N target(Object edge);\n",
        "327": "\n"
    }
}