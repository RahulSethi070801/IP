{
    "addition": {
        "72": "\n",
        "73": "  // We could make this a Map<E, Endpoints<N>>. Although it would make incidentNodes(edge)\n",
        "74": "  // slightly faster, it would also make Networks consume approximately 20% more memory.\n",
        "188": "  public Endpoints<N> incidentNodes(Object edge) {\n",
        "189": "    N nodeA = checkedReferenceNode(edge);\n",
        "190": "    N nodeB = nodeConnections.get(nodeA).oppositeNode(edge);\n",
        "191": "    return isDirected ? Endpoints.ofDirected(nodeA, nodeB) : Endpoints.ofUndirected(nodeA, nodeB);\n",
        "201": "    Endpoints<N> endpoints = incidentNodes(edge);\n",
        "202": "    Set<E> endpointsIncidentEdges =\n",
        "203": "        Sets.union(incidentEdges(endpoints.nodeA()), incidentEdges(endpoints.nodeB()));\n",
        "208": "  public Set<E> edgesConnecting(Object nodeA, Object nodeB) {\n",
        "209": "    NodeConnections<N, E> connectionsN1 = checkedConnections(nodeA);\n",
        "210": "    if (!allowsSelfLoops && nodeA.equals(nodeB)) {\n",
        "213": "    checkArgument(containsNode(nodeB), NODE_NOT_IN_GRAPH, nodeB);\n",
        "214": "    return connectionsN1.edgesConnecting(nodeB);\n"
    },
    "removed": {
        "23": "import static com.google.common.graph.GraphErrorMessageUtils.NOT_AVAILABLE_ON_UNDIRECTED;\n",
        "30": "import java.util.Iterator;\n",
        "187": "  public Set<N> incidentNodes(Object edge) {\n",
        "188": "    N node1 = checkedReferenceNode(edge);\n",
        "189": "    N node2 = nodeConnections.get(node1).oppositeNode(edge);\n",
        "190": "    return ImmutableSet.of(node1, node2);\n",
        "200": "    Iterator<N> incidentNodesIterator = incidentNodes(edge).iterator();\n",
        "201": "    Set<E> endpointsIncidentEdges = incidentEdges(incidentNodesIterator.next());\n",
        "202": "    while (incidentNodesIterator.hasNext()) {\n",
        "203": "      endpointsIncidentEdges =\n",
        "204": "          Sets.union(incidentEdges(incidentNodesIterator.next()), endpointsIncidentEdges);\n",
        "205": "    }\n",
        "210": "  public Set<E> edgesConnecting(Object node1, Object node2) {\n",
        "211": "    NodeConnections<N, E> connectionsN1 = checkedConnections(node1);\n",
        "212": "    if (!allowsSelfLoops && node1.equals(node2)) {\n",
        "215": "    checkArgument(containsNode(node2), NODE_NOT_IN_GRAPH, node2);\n",
        "216": "    return connectionsN1.edgesConnecting(node2);\n",
        "239": "  @Override\n",
        "240": "  public N source(Object edge) {\n",
        "241": "    if (!isDirected) {\n",
        "242": "      throw new UnsupportedOperationException(NOT_AVAILABLE_ON_UNDIRECTED);\n",
        "243": "    }\n",
        "244": "    return checkedReferenceNode(edge);\n",
        "245": "  }\n",
        "246": "\n",
        "247": "  @Override\n",
        "248": "  public N target(Object edge) {\n",
        "249": "    N source = source(edge);\n",
        "250": "    return nodeConnections.get(source).oppositeNode(edge);\n",
        "251": "  }\n",
        "252": "\n"
    }
}