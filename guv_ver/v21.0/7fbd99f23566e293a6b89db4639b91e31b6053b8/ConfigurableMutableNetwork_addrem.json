{
    "addition": {
        "64": "   * Return {@code false} if {@code edge} already exists between {@code nodeA} and {@code nodeB},\n",
        "68": "   *         exists from {@code nodeA} to {@code nodeB}, and this is not a multigraph.\n",
        "69": "   *         Also, if self-loops are not allowed, and {@code nodeA} is equal to {@code nodeB}.\n",
        "73": "  public boolean addEdge(E edge, N nodeA, N nodeB) {\n",
        "75": "    checkNotNull(nodeA, \"nodeA\");\n",
        "76": "    checkNotNull(nodeB, \"nodeB\");\n",
        "77": "    checkArgument(allowsSelfLoops() || !nodeA.equals(nodeB), SELF_LOOPS_NOT_ALLOWED, nodeA);\n",
        "78": "    boolean containsN1 = containsNode(nodeA);\n",
        "79": "    boolean containsN2 = containsNode(nodeB);\n",
        "81": "      checkArgument(containsN1 && containsN2 && edgesConnecting(nodeA, nodeB).contains(edge),\n",
        "82": "          REUSING_EDGE, edge, incidentNodes(edge), nodeA, nodeB);\n",
        "85": "      checkArgument(!(containsN1 && containsN2 && successors(nodeA).contains(nodeB)),\n",
        "86": "          ADDING_PARALLEL_EDGE, nodeA, nodeB);\n",
        "89": "      addNode(nodeA);\n",
        "91": "    NodeConnections<N, E> connectionsN1 = nodeConnections.get(nodeA);\n",
        "92": "    connectionsN1.addOutEdge(edge, nodeB);\n",
        "94": "      addNode(nodeB);\n",
        "96": "    NodeConnections<N, E> connectionsN2 = nodeConnections.get(nodeB);\n",
        "97": "    connectionsN2.addInEdge(edge, nodeA);\n",
        "98": "    edgeToReferenceNode.put(edge, nodeA);\n",
        "122": "    N nodeA = edgeToReferenceNode.get(edge);\n",
        "123": "    if (nodeA == null) {\n",
        "126": "    N nodeB = nodeConnections.get(nodeA).oppositeNode(edge);\n",
        "127": "    nodeConnections.get(nodeA).removeOutEdge(edge);\n",
        "128": "    nodeConnections.get(nodeB).removeInEdge(edge);\n"
    },
    "removed": {
        "64": "   * Return {@code false} if {@code edge} already exists between {@code node1} and {@code node2},\n",
        "68": "   *         exists from {@code node1} to {@code node2}, and this is not a multigraph.\n",
        "69": "   *         Also, if self-loops are not allowed, and {@code node1} is equal to {@code node2}.\n",
        "73": "  public boolean addEdge(E edge, N node1, N node2) {\n",
        "75": "    checkNotNull(node1, \"node1\");\n",
        "76": "    checkNotNull(node2, \"node2\");\n",
        "77": "    checkArgument(allowsSelfLoops() || !node1.equals(node2), SELF_LOOPS_NOT_ALLOWED, node1);\n",
        "78": "    boolean containsN1 = containsNode(node1);\n",
        "79": "    boolean containsN2 = containsNode(node2);\n",
        "81": "      checkArgument(containsN1 && containsN2 && edgesConnecting(node1, node2).contains(edge),\n",
        "82": "          REUSING_EDGE, edge, incidentNodes(edge), node1, node2);\n",
        "85": "      checkArgument(!(containsN1 && containsN2 && successors(node1).contains(node2)),\n",
        "86": "          ADDING_PARALLEL_EDGE, node1, node2);\n",
        "89": "      addNode(node1);\n",
        "91": "    NodeConnections<N, E> connectionsN1 = nodeConnections.get(node1);\n",
        "92": "    connectionsN1.addOutEdge(edge, node2);\n",
        "94": "      addNode(node2);\n",
        "96": "    NodeConnections<N, E> connectionsN2 = nodeConnections.get(node2);\n",
        "97": "    connectionsN2.addInEdge(edge, node1);\n",
        "98": "    edgeToReferenceNode.put(edge, node1);\n",
        "122": "    N node1 = edgeToReferenceNode.get(edge);\n",
        "123": "    if (node1 == null) {\n",
        "126": "    N node2 = nodeConnections.get(node1).oppositeNode(edge);\n",
        "127": "    nodeConnections.get(node1).removeOutEdge(edge);\n",
        "128": "    nodeConnections.get(node2).removeInEdge(edge);\n"
    }
}