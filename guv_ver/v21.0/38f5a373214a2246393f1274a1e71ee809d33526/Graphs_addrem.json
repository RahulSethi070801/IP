{
    "addition": {
        "51": "   * Returns true iff {@code graph} has at least one cycle. A cycle is defined as a non-empty subset\n",
        "52": "   * of edges in a graph arranged to form a path (a sequence of adjacent outgoing edges) starting\n",
        "53": "   * and ending with the same node.\n",
        "86": "    if (!network.isDirected()\n",
        "87": "        && network.allowsParallelEdges()\n",
        "216": "   * <p>Thus, two graphs A and B are equivalent if both are null or <b>all</b> of the following are\n",
        "217": "   * true:\n",
        "248": "   * <p>Thus, two value graphs A and B are equivalent if both are null or <b>all</b> of the\n",
        "249": "   * following are true:\n",
        "255": "   * <li>Each edge in A has a {@link ValueGraph#edgeValue(Object, Object) value} equal to the {@link\n",
        "256": "   *     ValueGraph#edgeValue(Object, Object) value} of the corresponding edge in B.\n",
        "282": "   * <p>Thus, two networks A and B are equivalent if both are null or <b>all</b> of the following\n",
        "283": "   * are true:\n",
        "577": "   * Returns an induced subgraph of {@code graph}. This subgraph is a new graph that contains all of\n",
        "578": "   * the nodes in {@code nodes}, and all of the {@link Graph#edges() edges} from {@code graph} for\n",
        "579": "   * which both nodes are contained by {@code nodes}.\n",
        "583": "  public static <N> MutableGraph<N> inducedSubgraph(Graph<N> graph, Iterable<? extends N> nodes) {\n",
        "599": "   * Returns an induced subgraph of {@code graph}. This subgraph is a new graph that contains all of\n",
        "600": "   * the nodes in {@code nodes}, and all of the {@link Graph#edges() edges} (and associated edge\n",
        "601": "   * values) from {@code graph} for which both nodes are contained by {@code nodes}.\n",
        "605": "  public static <N, V> MutableValueGraph<N, V> inducedSubgraph(\n",
        "606": "      ValueGraph<N, V> graph, Iterable<? extends N> nodes) {\n",
        "622": "   * Returns an induced subgraph of {@code graph}. This subgraph is a new graph that contains all of\n",
        "623": "   * the nodes in {@code nodes}, and all of the {@link Network#edges() edges} from {@code graph} for\n",
        "624": "   * which the {@link Network#incidentNodes(Object)} are both contained by {@code nodes}.\n",
        "628": "  public static <N, E> MutableNetwork<N, E> inducedSubgraph(\n",
        "629": "      Network<N, E> graph, Iterable<? extends N> nodes) {\n",
        "645": "  /** Creates a mutable copy of {@code graph} with the same nodes and edges. */\n",
        "647": "    MutableGraph<N> copy = GraphBuilder.from(graph).expectedNodeCount(graph.nodes().size()).build();\n",
        "657": "  /** Creates a mutable copy of {@code graph} with the same nodes, edges, and edge values. */\n",
        "659": "    MutableValueGraph<N, V> copy =\n",
        "660": "        ValueGraphBuilder.from(graph).expectedNodeCount(graph.nodes().size()).build();\n",
        "670": "  /** Creates a mutable copy of {@code graph} with the same nodes and edges. */\n",
        "672": "    MutableNetwork<N, E> copy =\n",
        "673": "        NetworkBuilder.from(graph)\n",
        "674": "            .expectedNodeCount(graph.nodes().size())\n",
        "675": "            .expectedEdgeCount(graph.edges().size())\n",
        "676": "            .build();\n",
        "712": "   * An enum representing the state of a node during DFS. {@code PENDING} means that the node is on\n",
        "713": "   * the stack of the DFS, while {@code COMPLETE} means that the node and all its successors have\n",
        "714": "   * been already explored. Any node that has not been explored will not have a state at all.\n"
    },
    "removed": {
        "51": "   * Returns true iff {@code graph} has at least one cycle. A cycle is defined as a non-empty\n",
        "52": "   * subset of edges in a graph arranged to form a path (a sequence of adjacent outgoing edges)\n",
        "53": "   * starting and ending with the same node.\n",
        "86": "    if (!network.isDirected() && network.allowsParallelEdges()\n",
        "215": "   * <p>Thus, two graphs A and B are equivalent if <b>all</b> of the following are true:\n",
        "246": "   * <p>Thus, two value graphs A and B are equivalent if <b>all</b> of the following are true:\n",
        "252": "   * <li>Each edge in A has a {@link ValueGraph#edgeValue(Object, Object) value} equal to the\n",
        "253": "   *     {@link ValueGraph#edgeValue(Object, Object) value} of the corresponding edge in B.\n",
        "279": "   * <p>Thus, two networks A and B are equivalent if <b>all</b> of the following are true:\n",
        "573": "   * Returns an induced subgraph of {@code graph}. This subgraph is a new graph that contains\n",
        "574": "   * all of the nodes in {@code nodes}, and all of the {@link Graph#edges() edges} from {@code\n",
        "575": "   * graph} for which both nodes are contained by {@code nodes}.\n",
        "579": "  public static <N> MutableGraph<N> inducedSubgraph(Graph<N> graph,\n",
        "580": "      Iterable<? extends N> nodes) {\n",
        "596": "   * Returns an induced subgraph of {@code graph}. This subgraph is a new graph that contains\n",
        "597": "   * all of the nodes in {@code nodes}, and all of the {@link Graph#edges() edges} (and associated\n",
        "598": "   * edge values) from {@code graph} for which both nodes are contained by {@code nodes}.\n",
        "602": "  public static <N, V> MutableValueGraph<N, V> inducedSubgraph(ValueGraph<N, V> graph,\n",
        "603": "      Iterable<? extends N> nodes) {\n",
        "619": "   * Returns an induced subgraph of {@code graph}. This subgraph is a new graph that contains\n",
        "620": "   * all of the nodes in {@code nodes}, and all of the {@link Network#edges() edges} from {@code\n",
        "621": "   * graph} for which the {@link Network#incidentNodes(Object)} are both contained by {@code nodes}.\n",
        "625": "  public static <N, E> MutableNetwork<N, E> inducedSubgraph(Network<N, E> graph,\n",
        "626": "      Iterable<? extends N> nodes) {\n",
        "642": "  /**\n",
        "643": "   * Creates a mutable copy of {@code graph} with the same nodes and edges.\n",
        "644": "   */\n",
        "646": "    MutableGraph<N> copy = GraphBuilder.from(graph)\n",
        "647": "        .expectedNodeCount(graph.nodes().size())\n",
        "648": "        .build();\n",
        "658": "  /**\n",
        "659": "   * Creates a mutable copy of {@code graph} with the same nodes, edges, and edge values.\n",
        "660": "   */\n",
        "662": "    MutableValueGraph<N, V> copy = ValueGraphBuilder.from(graph)\n",
        "663": "        .expectedNodeCount(graph.nodes().size())\n",
        "664": "        .build();\n",
        "674": "  /**\n",
        "675": "   * Creates a mutable copy of {@code graph} with the same nodes and edges.\n",
        "676": "   */\n",
        "678": "    MutableNetwork<N, E> copy = NetworkBuilder.from(graph)\n",
        "679": "        .expectedNodeCount(graph.nodes().size())\n",
        "680": "        .expectedEdgeCount(graph.edges().size())\n",
        "681": "        .build();\n",
        "717": "   * An enum representing the state of a node during DFS. {@code PENDING} means that\n",
        "718": "   * the node is on the stack of the DFS, while {@code COMPLETE} means that\n",
        "719": "   * the node and all its successors have been already explored. Any node that\n",
        "720": "   * has not been explored will not have a state at all.\n"
    }
}