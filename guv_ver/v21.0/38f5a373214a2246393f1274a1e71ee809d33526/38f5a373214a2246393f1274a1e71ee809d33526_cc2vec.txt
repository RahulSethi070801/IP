{"id": "38f5a373214a2246393f1274a1e71ee809d33526", "code": [{"0": "guava/src/com/google/common/graph/Graphs.java", "added": {"1": ["   * Returns true iff {@code graph} has at least one cycle. A cycle is defined as a non-empty subset\n", "   * of edges in a graph arranged to form a path (a sequence of adjacent outgoing edges) starting\n", "   * and ending with the same node.\n"], "2": ["    if (!network.isDirected()\n", "        && network.allowsParallelEdges()\n"], "3": ["   * <p>Thus, two graphs A and B are equivalent if both are null or <b>all</b> of the following are\n", "   * true:\n"], "4": ["   * <p>Thus, two value graphs A and B are equivalent if both are null or <b>all</b> of the\n", "   * following are true:\n", "   * <li>Each edge in A has a {@link ValueGraph#edgeValue(Object, Object) value} equal to the {@link\n", "   *     ValueGraph#edgeValue(Object, Object) value} of the corresponding edge in B.\n"], "5": ["   * <p>Thus, two networks A and B are equivalent if both are null or <b>all</b> of the following\n", "   * are true:\n"], "6": ["   * Returns an induced subgraph of {@code graph}. This subgraph is a new graph that contains all of\n", "   * the nodes in {@code nodes}, and all of the {@link Graph#edges() edges} from {@code graph} for\n", "   * which both nodes are contained by {@code nodes}.\n", "  public static <N> MutableGraph<N> inducedSubgraph(Graph<N> graph, Iterable<? extends N> nodes) {\n"], "7": ["   * Returns an induced subgraph of {@code graph}. This subgraph is a new graph that contains all of\n", "   * the nodes in {@code nodes}, and all of the {@link Graph#edges() edges} (and associated edge\n", "   * values) from {@code graph} for which both nodes are contained by {@code nodes}.\n", "  public static <N, V> MutableValueGraph<N, V> inducedSubgraph(\n", "      ValueGraph<N, V> graph, Iterable<? extends N> nodes) {\n"], "8": ["   * Returns an induced subgraph of {@code graph}. This subgraph is a new graph that contains all of\n", "   * the nodes in {@code nodes}, and all of the {@link Network#edges() edges} from {@code graph} for\n", "   * which the {@link Network#incidentNodes(Object)} are both contained by {@code nodes}.\n", "  public static <N, E> MutableNetwork<N, E> inducedSubgraph(\n", "      Network<N, E> graph, Iterable<? extends N> nodes) {\n"], "9": ["  /** Creates a mutable copy of {@code graph} with the same nodes and edges. */\n", "    MutableGraph<N> copy = GraphBuilder.from(graph).expectedNodeCount(graph.nodes().size()).build();\n"], "10": ["  /** Creates a mutable copy of {@code graph} with the same nodes, edges, and edge values. */\n", "    MutableValueGraph<N, V> copy =\n", "        ValueGraphBuilder.from(graph).expectedNodeCount(graph.nodes().size()).build();\n"], "11": ["  /** Creates a mutable copy of {@code graph} with the same nodes and edges. */\n", "    MutableNetwork<N, E> copy =\n", "        NetworkBuilder.from(graph)\n", "            .expectedNodeCount(graph.nodes().size())\n", "            .expectedEdgeCount(graph.edges().size())\n", "            .build();\n"], "12": ["   * An enum representing the state of a node during DFS. {@code PENDING} means that the node is on\n", "   * the stack of the DFS, while {@code COMPLETE} means that the node and all its successors have\n", "   * been already explored. Any node that has not been explored will not have a state at all.\n"]}, "removed": {"1": ["   * Returns true iff {@code graph} has at least one cycle. A cycle is defined as a non-empty\n", "   * subset of edges in a graph arranged to form a path (a sequence of adjacent outgoing edges)\n", "   * starting and ending with the same node.\n"], "2": ["    if (!network.isDirected() && network.allowsParallelEdges()\n"], "3": ["   * <p>Thus, two graphs A and B are equivalent if <b>all</b> of the following are true:\n"], "4": ["   * <p>Thus, two value graphs A and B are equivalent if <b>all</b> of the following are true:\n", "   * <li>Each edge in A has a {@link ValueGraph#edgeValue(Object, Object) value} equal to the\n", "   *     {@link ValueGraph#edgeValue(Object, Object) value} of the corresponding edge in B.\n"], "5": ["   * <p>Thus, two networks A and B are equivalent if <b>all</b> of the following are true:\n"], "6": ["   * Returns an induced subgraph of {@code graph}. This subgraph is a new graph that contains\n", "   * all of the nodes in {@code nodes}, and all of the {@link Graph#edges() edges} from {@code\n", "   * graph} for which both nodes are contained by {@code nodes}.\n", "  public static <N> MutableGraph<N> inducedSubgraph(Graph<N> graph,\n", "      Iterable<? extends N> nodes) {\n"], "7": ["   * Returns an induced subgraph of {@code graph}. This subgraph is a new graph that contains\n", "   * all of the nodes in {@code nodes}, and all of the {@link Graph#edges() edges} (and associated\n", "   * edge values) from {@code graph} for which both nodes are contained by {@code nodes}.\n", "  public static <N, V> MutableValueGraph<N, V> inducedSubgraph(ValueGraph<N, V> graph,\n", "      Iterable<? extends N> nodes) {\n"], "8": ["   * Returns an induced subgraph of {@code graph}. This subgraph is a new graph that contains\n", "   * all of the nodes in {@code nodes}, and all of the {@link Network#edges() edges} from {@code\n", "   * graph} for which the {@link Network#incidentNodes(Object)} are both contained by {@code nodes}.\n", "  public static <N, E> MutableNetwork<N, E> inducedSubgraph(Network<N, E> graph,\n", "      Iterable<? extends N> nodes) {\n"], "9": ["  /**\n", "   * Creates a mutable copy of {@code graph} with the same nodes and edges.\n", "   */\n", "    MutableGraph<N> copy = GraphBuilder.from(graph)\n", "        .expectedNodeCount(graph.nodes().size())\n", "        .build();\n"], "10": ["  /**\n", "   * Creates a mutable copy of {@code graph} with the same nodes, edges, and edge values.\n", "   */\n", "    MutableValueGraph<N, V> copy = ValueGraphBuilder.from(graph)\n", "        .expectedNodeCount(graph.nodes().size())\n", "        .build();\n"], "11": ["  /**\n", "   * Creates a mutable copy of {@code graph} with the same nodes and edges.\n", "   */\n", "    MutableNetwork<N, E> copy = NetworkBuilder.from(graph)\n", "        .expectedNodeCount(graph.nodes().size())\n", "        .expectedEdgeCount(graph.edges().size())\n", "        .build();\n"], "12": ["   * An enum representing the state of a node during DFS. {@code PENDING} means that\n", "   * the node is on the stack of the DFS, while {@code COMPLETE} means that\n", "   * the node and all its successors have been already explored. Any node that\n", "   * has not been explored will not have a state at all.\n"]}, "added_lines": {"1": [51, 52, 53], "2": [86, 87], "3": [216, 217], "4": [248, 249, 255, 256], "5": [282, 283], "6": [577, 578, 579, 583], "7": [599, 600, 601, 605, 606], "8": [622, 623, 624, 628, 629], "9": [645, 647], "10": [657, 659, 660], "11": [670, 672, 673, 674, 675, 676], "12": [712, 713, 714]}, "removed_lines": {"1": [51, 52, 53], "2": [86], "3": [215], "4": [246, 252, 253], "5": [279], "6": [573, 574, 575, 579, 580], "7": [596, 597, 598, 602, 603], "8": [619, 620, 621, 625, 626], "9": [642, 643, 644, 646, 647, 648], "10": [658, 659, 660, 662, 663, 664], "11": [674, 675, 676, 678, 679, 680, 681], "12": [717, 718, 719, 720]}}]}
