{"id": "e719a651ba846fd77d9a132d69f4e79a0ddadccc", "code": [{"0": "guava/src/com/google/common/io/AppendableWriter.java", "added": {"1": [" * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not use this file except\n", " * in compliance with the License. You may obtain a copy of the License at\n", " * Unless required by applicable law or agreed to in writing, software distributed under the License\n", " * is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express\n", " * or implied. See the License for the specific language governing permissions and limitations under\n", " * the License.\n"], "2": [" * Writer that places all output on an {@link Appendable} target. If the target is {@link Flushable}\n", " * or {@link Closeable}, flush()es and close()s will also be delegated to the target.\n"], "3": ["  @Override\n", "  public void write(char cbuf[], int off, int len) throws IOException {\n", "  @Override\n", "  public void flush() throws IOException {\n", "  @Override\n", "  public void close() throws IOException {\n"], "4": ["   * Override a few functions for performance reasons to avoid creating unnecessary strings.\n", "  @Override\n", "  public void write(int c) throws IOException {\n", "  @Override\n", "  public void write(@Nullable String str) throws IOException {\n", "  @Override\n", "  public void write(@Nullable String str, int off, int len) throws IOException {\n", "  @Override\n", "  public Writer append(char c) throws IOException {\n", "  @Override\n", "  public Writer append(@Nullable CharSequence charSeq) throws IOException {\n", "  @Override\n", "  public Writer append(@Nullable CharSequence charSeq, int start, int end) throws IOException {\n"]}, "removed": {"1": [" * Licensed under the Apache License, Version 2.0 (the \"License\");\n", " * you may not use this file except in compliance with the License.\n", " * You may obtain a copy of the License at\n", " * Unless required by applicable law or agreed to in writing, software\n", " * distributed under the License is distributed on an \"AS IS\" BASIS,\n", " * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n", " * See the License for the specific language governing permissions and\n", " * limitations under the License.\n"], "2": [" * Writer that places all output on an {@link Appendable} target. If the target\n", " * is {@link Flushable} or {@link Closeable}, flush()es and close()s will also\n", " * be delegated to the target.\n"], "3": ["  @Override public void write(char cbuf[], int off, int len)\n", "      throws IOException {\n", "  @Override public void flush() throws IOException {\n", "  @Override public void close() throws IOException {\n"], "4": ["   * Override a few functions for performance reasons to avoid creating\n", "   * unnecessary strings.\n", "  @Override public void write(int c) throws IOException {\n", "  @Override public void write(@Nullable String str) throws IOException {\n", "  @Override public void write(@Nullable String str, int off, int len) throws IOException {\n", "  @Override public Writer append(char c) throws IOException {\n", "  @Override public Writer append(@Nullable CharSequence charSeq) throws IOException {\n", "  @Override public Writer append(@Nullable CharSequence charSeq, int start, int end)\n", "      throws IOException {\n"]}, "added_lines": {"1": [4, 5, 9, 10, 11, 12], "2": [29, 30], "3": [54, 55, 62, 63, 70, 71], "4": [79, 82, 83, 88, 89, 94, 95, 101, 102, 108, 109, 115, 116]}, "removed_lines": {"1": [4, 5, 6, 10, 11, 12, 13, 14], "2": [31, 32, 33], "3": [57, 58, 65, 72], "4": [80, 81, 84, 89, 94, 100, 106, 112, 113]}}, {"1": "guava/src/com/google/common/io/BaseEncoding.java", "added": {"1": [" * strings. This class includes several constants for encoding schemes specified by\n", " * <a href=\"http://tools.ietf.org/html/rfc4648\">RFC 4648</a>. For example, the expression:\n"], "2": [" * <p>By default, {@code BaseEncoding}'s behavior is relatively strict and in accordance with RFC\n", " * 4648. Decoding rejects characters in the wrong case, though padding is optional. To modify\n", " * encoding and decoding behavior, use configuration methods to obtain a new encoding with modified\n", " * behavior:\n", " * <p>Warning: BaseEncoding instances are immutable. Invoking a configuration method has no effect\n"], "3": [" * <td>Traditional hexadecimal. Defaults to upper case.\n", " * <td>Human-readable; no possibility of mixing up 0/O or 1/I. Defaults to upper case.\n", " * <td>\"Numerical\" base 32; extended from the traditional hex alphabet. Defaults to upper case.\n"], "4": [" * <p>All instances of this class are immutable, so they may be stored safely as static constants.\n"], "5": ["   * {@code Writer}. When the returned {@code OutputStream} is closed, so is the backing\n"], "6": ["   * Decodes the specified character sequence, and returns the resulting {@code byte[]}. This is the\n", "   * inverse operation to {@link #encode(byte[])}.\n", "   *     encoding.\n"], "7": ["   * Decodes the specified character sequence, and returns the resulting {@code byte[]}. This is the\n", "   * inverse operation to {@link #encode(byte[])}.\n", "   *     encoding.\n"], "8": ["   * {@code Reader}. The returned stream throws a {@link DecodingException} upon decoding-specific\n"], "9": ["   *     separator\n"], "10": ["   *     string, or if {@code n <= 0}\n"], "11": ["   *     lower-case characters\n"], "12": ["   *     lower-case characters\n", "  private static final BaseEncoding BASE64 =\n", "      new Base64Encoding(\n", "          \"base64()\", \"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/\", '=');\n", "   * The \"base64\" base encoding specified by\n", "   * <a href=\"http://tools.ietf.org/html/rfc4648#section-4\">RFC 4648 section 4</a>, Base 64\n", "   * Encoding. (This is the same as the base 64 encoding from\n", "   * <a href=\"http://tools.ietf.org/html/rfc3548#section-3\">RFC 3548</a>.)\n", "   * <p>No line feeds are added by default, as per\n", "   * <a href=\"http://tools.ietf.org/html/rfc4648#section-3.1\">RFC 4648 section 3.1</a>, Line Feeds\n", "   * in Encoded Data. Line feeds may be added using {@link #withSeparator(String, int)}.\n", "  private static final BaseEncoding BASE64_URL =\n", "      new Base64Encoding(\n", "          \"base64Url()\", \"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_\", '=');\n", "   * The \"base64url\" encoding specified by\n", "   * <a href=\"http://tools.ietf.org/html/rfc4648#section-5\">RFC 4648 section 5</a>, Base 64 Encoding\n", "   * with URL and Filename Safe Alphabet, also sometimes referred to as the \"web safe Base64.\" (This\n", "   * is the same as the base 64 encoding with URL and filename safe alphabet from\n", "   * <a href=\"http://tools.ietf.org/html/rfc3548#section-4\">RFC 3548</a>.)\n", "   * <p>No line feeds are added by default, as per\n", "   * <a href=\"http://tools.ietf.org/html/rfc4648#section-3.1\">RFC 4648 section 3.1</a>, Line Feeds\n", "   * in Encoded Data. Line feeds may be added using {@link #withSeparator(String, int)}.\n"], "13": ["   * The \"base32\" encoding specified by <a href=\"http://tools.ietf.org/html/rfc4648#section-6\">RFC\n", "   * 4648 section 6</a>, Base 32 Encoding. (This is the same as the base 32 encoding from\n", "   * <a href=\"http://tools.ietf.org/html/rfc3548#section-5\">RFC 3548</a>.)\n", "   * <p>No line feeds are added by default, as per\n", "   * <a href=\"http://tools.ietf.org/html/rfc4648#section-3.1\">RFC 4648 section 3.1</a>, Line Feeds\n", "   * in Encoded Data. Line feeds may be added using {@link #withSeparator(String, int)}.\n"], "14": ["   * The \"base32hex\" encoding specified by\n", "   * <a href=\"http://tools.ietf.org/html/rfc4648#section-7\">RFC 4648 section 7</a>, Base 32 Encoding\n", "   * with Extended Hex Alphabet. There is no corresponding encoding in RFC 3548.\n", "   * <p>No line feeds are added by default, as per\n", "   * <a href=\"http://tools.ietf.org/html/rfc4648#section-3.1\">RFC 4648 section 3.1</a>, Line Feeds\n", "   * in Encoded Data. Line feeds may be added using {@link #withSeparator(String, int)}.\n"], "15": ["   * The \"base16\" encoding specified by <a href=\"http://tools.ietf.org/html/rfc4648#section-8\">RFC\n", "   * 4648 section 8</a>, Base 16 Encoding. (This is the same as the base 16 encoding from\n", "   * <a href=\"http://tools.ietf.org/html/rfc3548#section-6\">RFC 3548</a>.) This is commonly known as\n", "   * <p>No padding is necessary in base 16, so {@link #withPadChar(char)} and {@link #omitPadding()}\n", "   * have no effect.\n", "   * <p>No line feeds are added by default, as per\n", "   * <a href=\"http://tools.ietf.org/html/rfc4648#section-3.1\">RFC 4648 section 3.1</a>, Line Feeds\n", "   * in Encoded Data. Line feeds may be added using {@link #withSeparator(String, int)}.\n"], "16": ["        throw new DecodingException(\n", "            \"Unrecognized character: \"\n", "                + (CharMatcher.INVISIBLE.matches(ch) ? \"0x\" + Integer.toHexString(ch) : ch));\n"], "17": ["    @Nullable final Character paddingChar;\n"], "18": ["      checkArgument(\n", "          paddingChar == null || !alphabet.matches(paddingChar),\n", "          \"Padding character %s was already in alphabet\",\n", "          paddingChar);\n"], "19": ["            int charIndex = (bitBuffer >> (bitBufferLength - alphabet.bitsPerChar)) & alphabet.mask;\n"], "20": ["            int charIndex = (bitBuffer << (alphabet.bitsPerChar - bitBufferLength)) & alphabet.mask;\n"], "21": ["    void encodeChunkTo(Appendable target, byte[] bytes, int off, int len) throws IOException {\n"], "22": ["      if (8 % alphabet.bitsPerChar == 0\n", "          || (paddingChar != null && paddingChar.charValue() == padChar)) {\n"], "23": ["      checkArgument(\n", "          padding().or(alphabet).matchesNoneOf(separator),\n", "          \"Separator (%s) cannot contain alphabet or padding characters\",\n", "          separator);\n"], "24": ["      for (int i = 0; i < chars.length(); ) {\n"], "25": ["      return unseparatedSize\n", "          + separator.length() * divide(Math.max(0, unseparatedSize - 1), afterEveryChars, FLOOR);\n"], "26": ["      return delegate + \".withSeparator(\\\"\" + separator + \"\\\", \" + afterEveryChars + \")\";\n"]}, "removed": {"1": [" * strings. This class includes several constants for encoding schemes specified by <a\n", " * href=\"http://tools.ietf.org/html/rfc4648\">RFC 4648</a>. For example, the expression:\n"], "2": [" * <p>By default, {@code BaseEncoding}'s behavior is relatively strict and in accordance with\n", " * RFC 4648.  Decoding rejects characters in the wrong case, though padding is optional.\n", " * To modify encoding and decoding behavior, use configuration methods to obtain a new encoding\n", " * with modified behavior:\n", " * <p>Warning: BaseEncoding instances are immutable.  Invoking a configuration method has no effect\n"], "3": [" * <td>Traditional hexadecimal.  Defaults to upper case.\n", " * <td>Human-readable; no possibility of mixing up 0/O or 1/I.  Defaults to upper case.\n", " * <td>\"Numerical\" base 32; extended from the traditional hex alphabet.  Defaults to upper case.\n"], "4": [" * <p>\n", " * All instances of this class are immutable, so they may be stored safely as static constants.\n"], "5": ["   * {@code Writer}.  When the returned {@code OutputStream} is closed, so is the backing\n"], "6": ["   * Decodes the specified character sequence, and returns the resulting {@code byte[]}.\n", "   * This is the inverse operation to {@link #encode(byte[])}.\n", "   *         encoding.\n"], "7": ["   * Decodes the specified character sequence, and returns the resulting {@code byte[]}.\n", "   * This is the inverse operation to {@link #encode(byte[])}.\n", "   *         encoding.\n"], "8": ["   * {@code Reader}.  The returned stream throws a {@link DecodingException} upon decoding-specific\n"], "9": ["   *         separator\n"], "10": ["   *         string, or if {@code n <= 0}\n"], "11": ["   *         lower-case characters\n"], "12": ["   *         lower-case characters\n", "  private static final BaseEncoding BASE64 = new Base64Encoding(\n", "      \"base64()\", \"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/\", '=');\n", "   * The \"base64\" base encoding specified by <a\n", "   * href=\"http://tools.ietf.org/html/rfc4648#section-4\">RFC 4648 section 4</a>, Base 64 Encoding.\n", "   * (This is the same as the base 64 encoding from <a\n", "   * href=\"http://tools.ietf.org/html/rfc3548#section-3\">RFC 3548</a>.)\n", "   * <p>No line feeds are added by default, as per <a\n", "   * href=\"http://tools.ietf.org/html/rfc4648#section-3.1\"> RFC 4648 section 3.1</a>, Line Feeds in\n", "   * Encoded Data. Line feeds may be added using {@link #withSeparator(String, int)}.\n", "  private static final BaseEncoding BASE64_URL = new Base64Encoding(\n", "      \"base64Url()\", \"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_\", '=');\n", "   * The \"base64url\" encoding specified by <a\n", "   * href=\"http://tools.ietf.org/html/rfc4648#section-5\">RFC 4648 section 5</a>, Base 64 Encoding\n", "   * with URL and Filename Safe Alphabet, also sometimes referred to as the \"web safe Base64.\"\n", "   * (This is the same as the base 64 encoding with URL and filename safe alphabet from <a\n", "   * href=\"http://tools.ietf.org/html/rfc3548#section-4\">RFC 3548</a>.)\n", "   * <p>No line feeds are added by default, as per <a\n", "   * href=\"http://tools.ietf.org/html/rfc4648#section-3.1\"> RFC 4648 section 3.1</a>, Line Feeds in\n", "   * Encoded Data. Line feeds may be added using {@link #withSeparator(String, int)}.\n"], "13": ["   * The \"base32\" encoding specified by <a\n", "   * href=\"http://tools.ietf.org/html/rfc4648#section-6\">RFC 4648 section 6</a>, Base 32 Encoding.\n", "   * (This is the same as the base 32 encoding from <a\n", "   * href=\"http://tools.ietf.org/html/rfc3548#section-5\">RFC 3548</a>.)\n", "   * <p>No line feeds are added by default, as per <a\n", "   * href=\"http://tools.ietf.org/html/rfc4648#section-3.1\"> RFC 4648 section 3.1</a>, Line Feeds in\n", "   * Encoded Data. Line feeds may be added using {@link #withSeparator(String, int)}.\n"], "14": ["   * The \"base32hex\" encoding specified by <a\n", "   * href=\"http://tools.ietf.org/html/rfc4648#section-7\">RFC 4648 section 7</a>, Base 32 Encoding\n", "   * with Extended Hex Alphabet.  There is no corresponding encoding in RFC 3548.\n", "   * <p>No line feeds are added by default, as per <a\n", "   * href=\"http://tools.ietf.org/html/rfc4648#section-3.1\"> RFC 4648 section 3.1</a>, Line Feeds in\n", "   * Encoded Data. Line feeds may be added using {@link #withSeparator(String, int)}.\n"], "15": ["   * The \"base16\" encoding specified by <a\n", "   * href=\"http://tools.ietf.org/html/rfc4648#section-8\">RFC 4648 section 8</a>, Base 16 Encoding.\n", "   * (This is the same as the base 16 encoding from <a\n", "   * href=\"http://tools.ietf.org/html/rfc3548#section-6\">RFC 3548</a>.) This is commonly known as\n", "   * <p>No padding is necessary in base 16, so {@link #withPadChar(char)} and\n", "   * {@link #omitPadding()} have no effect.\n", "   * <p>No line feeds are added by default, as per <a\n", "   * href=\"http://tools.ietf.org/html/rfc4648#section-3.1\"> RFC 4648 section 3.1</a>, Line Feeds in\n", "   * Encoded Data. Line feeds may be added using {@link #withSeparator(String, int)}.\n"], "16": ["        throw new DecodingException(\"Unrecognized character: \"\n", "            + (CharMatcher.INVISIBLE.matches(ch) ? \"0x\" + Integer.toHexString(ch) : ch));\n"], "17": ["    @Nullable\n", "    final Character paddingChar;\n"], "18": ["      checkArgument(paddingChar == null || !alphabet.matches(paddingChar),\n", "          \"Padding character %s was already in alphabet\", paddingChar);\n"], "19": ["            int charIndex = (bitBuffer >> (bitBufferLength - alphabet.bitsPerChar))\n", "                & alphabet.mask;\n"], "20": ["            int charIndex = (bitBuffer << (alphabet.bitsPerChar - bitBufferLength))\n", "                & alphabet.mask;\n"], "21": ["    void encodeChunkTo(Appendable target, byte[] bytes, int off, int len)\n", "        throws IOException {\n"], "22": ["      if (8 % alphabet.bitsPerChar == 0 ||\n", "          (paddingChar != null && paddingChar.charValue() == padChar)) {\n"], "23": ["      checkArgument(padding().or(alphabet).matchesNoneOf(separator),\n", "          \"Separator (%s) cannot contain alphabet or padding characters\", separator);\n"], "24": ["      for (int i = 0; i < chars.length();) {\n"], "25": ["      return unseparatedSize + separator.length()\n", "          * divide(Math.max(0, unseparatedSize - 1), afterEveryChars, FLOOR);\n"], "26": ["      return delegate.toString() +\n", "          \".withSeparator(\\\"\" + separator + \"\\\", \" + afterEveryChars + \")\";\n"]}, "added_lines": {"1": [46, 47], "2": [57, 58, 59, 60, 65], "3": [90, 96, 102], "4": [117], "5": [171], "6": [213, 214, 217], "7": [229, 230, 233], "8": [245], "9": [295], "10": [306], "11": [317], "12": [327, 332, 333, 334, 337, 338, 339, 340, 345, 346, 347, 354, 355, 356, 359, 360, 361, 362, 363, 368, 369, 370], "13": [381, 382, 383, 388, 389, 390], "14": [401, 402, 403, 408, 409, 410], "15": [420, 421, 422, 425, 426, 428, 429, 430], "16": [502, 503, 504], "17": [582], "18": [590, 591, 592, 593], "19": [622], "20": [637], "21": [661], "22": [789, 790], "23": [799, 800, 801, 802], "24": [947], "25": [1077, 1078], "26": [1140]}, "removed_lines": {"1": [46, 47], "2": [57, 58, 59, 60, 65], "3": [90, 96, 102], "4": [117, 118], "5": [172], "6": [214, 215, 218], "7": [230, 231, 234], "8": [246], "9": [296], "10": [307], "11": [318], "12": [328, 333, 334, 337, 338, 339, 340, 345, 346, 347, 354, 355, 358, 359, 360, 361, 362, 367, 368, 369], "13": [380, 381, 382, 383, 388, 389, 390], "14": [401, 402, 403, 408, 409, 410], "15": [420, 421, 422, 423, 426, 427, 429, 430, 431], "16": [503, 504], "17": [582, 583], "18": [591, 592], "19": [621, 622], "20": [637, 638], "21": [662, 663], "22": [791, 792], "23": [801, 802], "24": [947], "25": [1077, 1078], "26": [1140, 1141]}}, {"2": "guava/src/com/google/common/io/ByteArrayDataInput.java", "added": {"1": [" * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not use this file except\n", " * in compliance with the License. You may obtain a copy of the License at\n", " * Unless required by applicable law or agreed to in writing, software distributed under the License\n", " * is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express\n", " * or implied. See the License for the specific language governing permissions and limitations under\n", " * the License.\n"], "2": [" * An extension of {@code DataInput} for reading from in-memory byte arrays; its methods offer\n", " * identical functionality but do not throw {@link IOException}.\n", " * <p><b>Warning:</b> The caller is responsible for not attempting to read past the end of the\n", " * array. If any method encounters the end of the array prematurely, it throws\n", " * {@link IllegalStateException} to signify <i>programmer error</i>. This behavior is a technical\n", " * violation of the supertype's contract, which specifies a checked exception.\n", "  @Override\n", "  void readFully(byte b[]);\n", "  @Override\n", "  void readFully(byte b[], int off, int len);\n", "  @Override\n", "  int skipBytes(int n);\n", "  @Override\n", "  boolean readBoolean();\n", "  @Override\n", "  byte readByte();\n", "  @Override\n", "  int readUnsignedByte();\n", "  @Override\n", "  short readShort();\n", "  @Override\n", "  int readUnsignedShort();\n", "  @Override\n", "  char readChar();\n", "  @Override\n", "  int readInt();\n", "  @Override\n", "  long readLong();\n", "  @Override\n", "  float readFloat();\n", "  @Override\n", "  double readDouble();\n", "  @Override\n", "  String readLine();\n", "  @Override\n", "  String readUTF();\n"]}, "removed": {"1": [" * Licensed under the Apache License, Version 2.0 (the \"License\");\n", " * you may not use this file except in compliance with the License.\n", " * You may obtain a copy of the License at\n", " * Unless required by applicable law or agreed to in writing, software\n", " * distributed under the License is distributed on an \"AS IS\" BASIS,\n", " * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n", " * See the License for the specific language governing permissions and\n", " * limitations under the License.\n"], "2": [" * An extension of {@code DataInput} for reading from in-memory byte arrays; its\n", " * methods offer identical functionality but do not throw {@link IOException}.\n", " * <p><b>Warning:</b> The caller is responsible for not attempting to read past\n", " * the end of the array. If any method encounters the end of the array\n", " * prematurely, it throws {@link IllegalStateException} to signify <i>programmer\n", " * error</i>. This behavior is a technical violation of the supertype's\n", " * contract, which specifies a checked exception.\n", "  @Override void readFully(byte b[]);\n", "  @Override void readFully(byte b[], int off, int len);\n", "  @Override int skipBytes(int n);\n", "  @Override boolean readBoolean();\n", "  @Override byte readByte();\n", "  @Override int readUnsignedByte();\n", "  @Override short readShort();\n", "  @Override int readUnsignedShort();\n", "  @Override char readChar();\n", "  @Override int readInt();\n", "  @Override long readLong();\n", "  @Override float readFloat();\n", "  @Override double readDouble();\n", "  @Override String readLine();\n", "  @Override String readUTF();\n"]}, "added_lines": {"1": [4, 5, 9, 10, 11, 12], "2": [23, 24, 26, 27, 28, 29, 36, 37, 39, 40, 42, 43, 45, 46, 48, 49, 51, 52, 54, 55, 57, 58, 60, 61, 63, 64, 66, 67, 69, 70, 72, 73, 75, 76, 78, 79]}, "removed_lines": {"1": [4, 5, 6, 10, 11, 12, 13, 14], "2": [25, 26, 28, 29, 30, 31, 32, 39, 41, 43, 45, 47, 49, 51, 53, 55, 57, 59, 61, 63, 65, 67]}}, {"3": "guava/src/com/google/common/io/ByteArrayDataOutput.java", "added": {"1": [" * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not use this file except\n", " * in compliance with the License. You may obtain a copy of the License at\n", " * Unless required by applicable law or agreed to in writing, software distributed under the License\n", " * is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express\n", " * or implied. See the License for the specific language governing permissions and limitations under\n", " * the License.\n"], "2": [" * An extension of {@code DataOutput} for writing to in-memory byte arrays; its methods offer\n", " * identical functionality but do not throw {@link IOException}.\n", "  @Override\n", "  void write(int b);\n", "\n", "  @Override\n", "  void write(byte b[]);\n", "\n", "  @Override\n", "  void write(byte b[], int off, int len);\n", "\n", "  @Override\n", "  void writeBoolean(boolean v);\n", "\n", "  @Override\n", "  void writeByte(int v);\n", "\n", "  @Override\n", "  void writeShort(int v);\n", "\n", "  @Override\n", "  void writeChar(int v);\n", "\n", "  @Override\n", "  void writeInt(int v);\n", "\n", "  @Override\n", "  void writeLong(long v);\n", "\n", "  @Override\n", "  void writeFloat(float v);\n", "\n", "  @Override\n", "  void writeDouble(double v);\n", "\n", "  @Override\n", "  void writeChars(String s);\n", "\n", "  @Override\n", "  void writeUTF(String s);\n", "   * @deprecated This method is dangerous as it discards the high byte of every character. For\n", "   *     UTF-8, use {@code write(s.getBytes(StandardCharsets.UTF_8))}.\n", "  @Deprecated\n", "  @Override\n", "  void writeBytes(String s);\n", "   * Returns the contents that have been written to this instance, as a byte array.\n"]}, "removed": {"1": [" * Licensed under the Apache License, Version 2.0 (the \"License\");\n", " * you may not use this file except in compliance with the License.\n", " * You may obtain a copy of the License at\n", " * Unless required by applicable law or agreed to in writing, software\n", " * distributed under the License is distributed on an \"AS IS\" BASIS,\n", " * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n", " * See the License for the specific language governing permissions and\n", " * limitations under the License.\n"], "2": [" * An extension of {@code DataOutput} for writing to in-memory byte arrays; its\n", " * methods offer identical functionality but do not throw {@link IOException}.\n", "  @Override void write(int b);\n", "  @Override void write(byte b[]);\n", "  @Override void write(byte b[], int off, int len);\n", "  @Override void writeBoolean(boolean v);\n", "  @Override void writeByte(int v);\n", "  @Override void writeShort(int v);\n", "  @Override void writeChar(int v);\n", "  @Override void writeInt(int v);\n", "  @Override void writeLong(long v);\n", "  @Override void writeFloat(float v);\n", "  @Override void writeDouble(double v);\n", "  @Override void writeChars(String s);\n", "  @Override void writeUTF(String s);\n", "   * @deprecated This method is dangerous as it discards the high byte of\n", "   * every character. For UTF-8, use {@code write(s.getBytes(Charsets.UTF_8))}.\n", "  @Deprecated @Override void writeBytes(String s);\n", "   * Returns the contents that have been written to this instance,\n", "   * as a byte array.\n"]}, "added_lines": {"1": [4, 5, 9, 10, 11, 12], "2": [23, 24, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 58, 59, 60, 61, 62, 63, 64, 65, 66, 67, 68, 71, 72, 74, 75, 76, 79]}, "removed_lines": {"1": [4, 5, 6, 10, 11, 12, 13, 14], "2": [25, 26, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 48, 49, 51, 54, 55]}}, {"4": "guava/src/com/google/common/io/ByteProcessor.java", "added": {"1": [" * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not use this file except\n", " * in compliance with the License. You may obtain a copy of the License at\n", " * Unless required by applicable law or agreed to in writing, software distributed under the License\n", " * is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express\n", " * or implied. See the License for the specific language governing permissions and limitations under\n", " * the License.\n"], "2": [" * <p>{@link #processBytes} will be called for each line that is read, and should return\n", " * {@code false} when you want to stop processing.\n"], "3": ["   * This method will be called for each chunk of bytes in an input stream. The implementation\n", "   * should process the bytes from {@code buf[off]} through {@code buf[off + len - 1]} (inclusive).\n"]}, "removed": {"1": [" * Licensed under the Apache License, Version 2.0 (the \"License\");\n", " * you may not use this file except in compliance with the License.\n", " * You may obtain a copy of the License at\n", " * Unless required by applicable law or agreed to in writing, software\n", " * distributed under the License is distributed on an \"AS IS\" BASIS,\n", " * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n", " * See the License for the specific language governing permissions and\n", " * limitations under the License.\n"], "2": [" * <p>{@link #processBytes} will be called for each line that is read, and\n", " * should return {@code false} when you want to stop processing.\n"], "3": ["   * This method will be called for each chunk of bytes in an\n", "   * input stream. The implementation should process the bytes\n", "   * from {@code buf[off]} through {@code buf[off + len - 1]}\n", "   * (inclusive).\n"]}, "added_lines": {"1": [4, 5, 9, 10, 11, 12], "2": [25, 26], "3": [35, 36]}, "removed_lines": {"1": [4, 5, 6, 10, 11, 12, 13, 14], "2": [27, 28], "3": [37, 38, 39, 40]}}, {"5": "guava/src/com/google/common/io/ByteSink.java", "added": {"1": [" * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not use this file except\n", " * in compliance with the License. You may obtain a copy of the License at\n", " * Unless required by applicable law or agreed to in writing, software distributed under the License\n", " * is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express\n", " * or implied. See the License for the specific language governing permissions and limitations under\n", " * the License.\n"], "2": [" * <li><b>Methods that return a stream:</b> These methods should return a <i>new</i>, independent\n", " *     instance each time they are called. The caller is responsible for ensuring that the returned\n", " *     stream is closed.\n", " * <li><b>Convenience methods:</b> These are implementations of common operations that are typically\n", " *     implemented by opening a stream using one of the methods in the first category, doing\n", " *     something and finally closing the stream or channel that was opened.\n"], "3": ["   * Returns a {@link CharSink} view of this {@code ByteSink} that writes characters to this sink as\n", "   * bytes encoded with the given {@link Charset charset}.\n"], "4": ["   * Opens a new buffered {@link OutputStream} for writing to this sink. The returned stream is not\n", "   * required to be a {@link BufferedOutputStream} in order to allow implementations to simply\n", "   * delegate to {@link #openStream()} when the stream returned by that method does not benefit from\n", "   * additional buffering (for example, a {@code ByteArrayOutputStream}). This method should return\n", "   * a new, independent stream each time it is called.\n"]}, "removed": {"1": [" * Licensed under the Apache License, Version 2.0 (the \"License\");\n", " * you may not use this file except in compliance with the License.\n", " * You may obtain a copy of the License at\n", " * Unless required by applicable law or agreed to in writing, software\n", " * distributed under the License is distributed on an \"AS IS\" BASIS,\n", " * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n", " * See the License for the specific language governing permissions and\n", " * limitations under the License.\n"], "2": [" *   <li><b>Methods that return a stream:</b> These methods should return a <i>new</i>, independent\n", " *   instance each time they are called. The caller is responsible for ensuring that the returned\n", " *   stream is closed.\n", " *   <li><b>Convenience methods:</b> These are implementations of common operations that are\n", " *   typically implemented by opening a stream using one of the methods in the first category, doing\n", " *   something and finally closing the stream or channel that was opened.\n"], "3": ["   * Returns a {@link CharSink} view of this {@code ByteSink} that writes characters to this sink\n", "   * as bytes encoded with the given {@link Charset charset}.\n"], "4": ["   * Opens a new buffered {@link OutputStream} for writing to this sink. The returned stream is\n", "   * not required to be a {@link BufferedOutputStream} in order to allow implementations to simply\n", "   * delegate to {@link #openStream()} when the stream returned by that method does not benefit\n", "   * from additional buffering (for example, a {@code ByteArrayOutputStream}). This method should\n", "   * return a new, independent stream each time it is called.\n"]}, "added_lines": {"1": [4, 5, 9, 10, 11, 12], "2": [36, 37, 38, 39, 40, 41], "3": [56, 57], "4": [74, 75, 76, 77, 78]}, "removed_lines": {"1": [4, 5, 6, 10, 11, 12, 13, 14], "2": [38, 39, 40, 41, 42, 43], "3": [58, 59], "4": [76, 77, 78, 79, 80]}}, {"6": "guava/src/com/google/common/io/ByteSource.java", "added": {"1": [" * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not use this file except\n", " * in compliance with the License. You may obtain a copy of the License at\n", " * Unless required by applicable law or agreed to in writing, software distributed under the License\n", " * is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express\n", " * or implied. See the License for the specific language governing permissions and limitations under\n", " * the License.\n"], "2": [" * A readable source of bytes, such as a file. Unlike an {@link InputStream}, a {@code ByteSource}\n", " * is not an open, stateful stream for input that can be read and closed. Instead, it is an\n", " * immutable <i>supplier</i> of {@code InputStream} instances.\n", " * <li><b>Methods that return a stream:</b> These methods should return a <i>new</i>, independent\n", " *     instance each time they are called. The caller is responsible for ensuring that the returned\n", " *     stream is closed.\n", " * <li><b>Convenience methods:</b> These are implementations of common operations that are typically\n", " *     implemented by opening a stream using one of the methods in the first category, doing\n", " *     something and finally closing the stream that was opened.\n"], "3": ["   * delegate to {@link #openStream()} when the stream returned by that method does not benefit from\n", "   * additional buffering (for example, a {@code ByteArrayInputStream}). This method should return a\n", "   * new, independent stream each time it is called.\n"], "4": ["   * {@link #sizeIfKnown} returns zero, falling back to opening a stream and checking for EOF if the\n", "   * size is not known.\n"], "5": ["   * Returns the size of this source in bytes, if the size can be easily determined without actually\n", "   * opening the data stream.\n"], "6": ["   * Returns the size of this source in bytes, even if doing so requires opening and traversing an\n", "   * entire stream. To avoid a potentially expensive operation, see {@link #sizeIfKnown}.\n", "   * <p>The default implementation calls {@link #sizeIfKnown} and returns the value if present. If\n", "   * absent, it will fall back to a heavyweight operation that will open a stream, read (or\n"], "7": ["   * <p>Note: The input {@code Iterator} will be copied to an {@code ImmutableList} when this method\n", "   * is called. This will fail if the iterator is infinite and may cause problems if the iterator\n", "   * eagerly fetches data for each source when iterated (rather than producing sources that only\n", "   * load data through their streams). Prefer using the {@link #concat(Iterable)} overload if\n", "   * possible.\n"], "8": ["   * A char source that reads bytes from this source and decodes them as characters using a charset.\n"]}, "removed": {"1": [" * Licensed under the Apache License, Version 2.0 (the \"License\");\n", " * you may not use this file except in compliance with the License.\n", " * You may obtain a copy of the License at\n", " * Unless required by applicable law or agreed to in writing, software\n", " * distributed under the License is distributed on an \"AS IS\" BASIS,\n", " * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n", " * See the License for the specific language governing permissions and\n", " * limitations under the License.\n"], "2": [" * A readable source of bytes, such as a file. Unlike an {@link InputStream}, a\n", " * {@code ByteSource} is not an open, stateful stream for input that can be read and closed.\n", " * Instead, it is an immutable <i>supplier</i> of {@code InputStream} instances.\n", " *   <li><b>Methods that return a stream:</b> These methods should return a <i>new</i>, independent\n", " *   instance each time they are called. The caller is responsible for ensuring that the returned\n", " *   stream is closed.\n", " *   <li><b>Convenience methods:</b> These are implementations of common operations that are\n", " *   typically implemented by opening a stream using one of the methods in the first category, doing\n", " *   something and finally closing the stream that was opened.\n"], "3": ["   * delegate to {@link #openStream()} when the stream returned by that method does not benefit\n", "   * from additional buffering (for example, a {@code ByteArrayInputStream}). This method should\n", "   * return a new, independent stream each time it is called.\n"], "4": ["   * {@link #sizeIfKnown} returns zero, falling back to opening a stream and checking for\n", "   * EOF if the size is not known.\n"], "5": ["   * Returns the size of this source in bytes, if the size can be easily determined without\n", "   * actually opening the data stream.\n"], "6": ["   * Returns the size of this source in bytes, even if doing so requires opening and traversing\n", "   * an entire stream. To avoid a potentially expensive operation, see {@link #sizeIfKnown}.\n", "   * <p>The default implementation calls {@link #sizeIfKnown} and returns the value if present.\n", "   * If absent, it will fall back to a heavyweight operation that will open a stream, read (or\n"], "7": ["   * <p>Note: The input {@code Iterator} will be copied to an {@code ImmutableList} when this\n", "   * method is called. This will fail if the iterator is infinite and may cause problems if the\n", "   * iterator eagerly fetches data for each source when iterated (rather than producing sources\n", "   * that only load data through their streams). Prefer using the {@link #concat(Iterable)}\n", "   * overload if possible.\n"], "8": ["   * A char source that reads bytes from this source and decodes them as characters using a\n", "   * charset.\n"]}, "added_lines": {"1": [4, 5, 9, 10, 11, 12], "2": [44, 45, 46, 50, 51, 52, 53, 54, 55], "3": [95, 96, 97], "4": [126, 127], "5": [154, 155], "6": [173, 174, 176, 177], "7": [389, 390, 391, 392, 393], "8": [440]}, "removed_lines": {"1": [4, 5, 6, 10, 11, 12, 13, 14], "2": [46, 47, 48, 52, 53, 54, 55, 56, 57], "3": [97, 98, 99], "4": [128, 129], "5": [156, 157], "6": [175, 176, 178, 179], "7": [391, 392, 393, 394, 395], "8": [442, 443]}}, {"7": "guava/src/com/google/common/io/ByteStreams.java", "added": {"1": [" * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not use this file except\n", " * in compliance with the License. You may obtain a copy of the License at\n", " * Unless required by applicable law or agreed to in writing, software distributed under the License\n", " * is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express\n", " * or implied. See the License for the specific language governing permissions and limitations under\n", " * the License.\n"], "2": ["   * There are three methods to implement\n", "   * {@link FileChannel#transferTo(long, long, WritableByteChannel)}:\n", "   * <li>Use sendfile(2) or equivalent. Requires that both the input channel and the output channel\n", "   *     have their own file descriptors. Generally this only happens when both channels are files\n", "   *     or sockets. This performs zero copies - the bytes never enter userspace.\n", "   * <li>Use mmap(2) or equivalent. Requires that either the input channel or the output channel\n", "   *     have file descriptors. Bytes are copied from the file into a kernel buffer, then directly\n", "   *     into the other buffer (userspace). Note that if the file is very large, a naive\n", "   *     implementation will effectively put the whole file in memory. On many systems with paging\n", "   *     and virtual memory, this is not a problem - because it is mapped read-only, the kernel can\n", "   *     always page it to disk \"for free\". However, on systems where killing processes happens all\n", "   *     the time in normal conditions (i.e., android) the OS must make a tradeoff between paging\n", "   *     memory and killing other processes - so allocating a gigantic buffer and then sequentially\n", "   *     accessing it could result in other processes dying. This is solvable via madvise(2), but\n", "   *     that obviously doesn't exist in java.\n", "   * <li>Ordinary copy. Kernel copies bytes into a kernel buffer, from a kernel buffer into a\n", "   *     userspace buffer (byte[] or ByteBuffer), then copies them from that buffer into the\n", "   *     destination channel.\n"], "3": ["   * Copies all bytes from the input stream to the output stream. Does not close or flush either\n", "   * stream.\n", "  public static long copy(InputStream from, OutputStream to) throws IOException {\n"], "4": ["   * Copies all bytes from the readable channel to the writable channel. Does not close or flush\n", "   * either channel.\n", "  public static long copy(ReadableByteChannel from, WritableByteChannel to) throws IOException {\n"], "5": ["   * Reads all bytes from an input stream into a byte array. Does not close the stream.\n"], "6": ["   * Reads all bytes from an input stream into a byte array. The given expected size is used to\n", "   * create an initial byte array, but if the actual number of bytes read from the stream differs,\n", "   * the correct result will be returned anyway.\n", "  static byte[] toByteArray(InputStream in, int expectedSize) throws IOException {\n"], "7": ["  private static final class FastByteArrayOutputStream extends ByteArrayOutputStream {\n", "     * Writes the contents of the internal buffer to the given array starting at the given offset.\n", "     * Assumes the array has space to hold count bytes.\n"], "8": ["   * Returns a new {@link ByteArrayDataInput} instance to read from the {@code bytes} array from the\n", "   * beginning.\n", "   * Returns a new {@link ByteArrayDataInput} instance to read from the {@code bytes} array,\n", "   * starting at the given position.\n", "   * @throws IndexOutOfBoundsException if {@code start} is negative or greater than the length of\n", "   *     the array\n", "    return newDataInput(new ByteArrayInputStream(bytes, start, bytes.length - start));\n", "   * {@code ByteArrayInputStream}. The given input stream is not reset before being read from by the\n", "   * returned {@code ByteArrayDataInput}.\n", "  public static ByteArrayDataInput newDataInput(ByteArrayInputStream byteArrayInputStream) {\n"], "9": ["    @Override\n", "    public void readFully(byte b[]) {\n"], "10": ["    @Override\n", "    public void readFully(byte b[], int off, int len) {\n"], "11": ["    @Override\n", "    public int skipBytes(int n) {\n"], "12": ["    @Override\n", "    public boolean readBoolean() {\n"], "13": ["    @Override\n", "    public byte readByte() {\n"], "14": ["    @Override\n", "    public int readUnsignedByte() {\n"], "15": ["    @Override\n", "    public short readShort() {\n"], "16": ["    @Override\n", "    public int readUnsignedShort() {\n"], "17": ["    @Override\n", "    public char readChar() {\n"], "18": ["    @Override\n", "    public int readInt() {\n"], "19": ["    @Override\n", "    public long readLong() {\n"], "20": ["    @Override\n", "    public float readFloat() {\n"], "21": ["    @Override\n", "    public double readDouble() {\n"], "22": ["    @Override\n", "    public String readLine() {\n"], "23": ["    @Override\n", "    public String readUTF() {\n"], "24": ["   * Returns a new {@link ByteArrayDataOutput} instance sized to hold {@code size} bytes before\n", "   * resizing.\n"], "25": ["   * Returns a new {@link ByteArrayDataOutput} instance which writes to the given\n", "   * {@code ByteArrayOutputStream}. The given output stream is not reset before being written to by\n", "   * the returned {@code ByteArrayDataOutput} and new data will be appended to any existing content.\n", "   * <p>Note that if the given output stream was not empty or is modified after the\n", "   * {@code ByteArrayDataOutput} is created, the contract for\n", "   * {@link ByteArrayDataOutput#toByteArray} will not be honored (the bytes returned in the byte\n", "   * array may not be exactly what was written via calls to {@code ByteArrayDataOutput}).\n", "  public static ByteArrayDataOutput newDataOutput(ByteArrayOutputStream byteArrayOutputSteam) {\n", "  private static class ByteArrayDataOutputStream implements ByteArrayDataOutput {\n"], "26": ["    @Override\n", "    public void write(int b) {\n"], "27": ["    @Override\n", "    public void write(byte[] b) {\n"], "28": ["    @Override\n", "    public void write(byte[] b, int off, int len) {\n"], "29": ["    @Override\n", "    public void writeBoolean(boolean v) {\n"], "30": ["    @Override\n", "    public void writeByte(int v) {\n"], "31": ["    @Override\n", "    public void writeBytes(String s) {\n"], "32": ["    @Override\n", "    public void writeChar(int v) {\n"], "33": ["    @Override\n", "    public void writeChars(String s) {\n"], "34": ["    @Override\n", "    public void writeDouble(double v) {\n"], "35": ["    @Override\n", "    public void writeFloat(float v) {\n"], "36": ["    @Override\n", "    public void writeInt(int v) {\n"], "37": ["    @Override\n", "    public void writeLong(long v) {\n"], "38": ["    @Override\n", "    public void writeShort(int v) {\n"], "39": ["    @Override\n", "    public void writeUTF(String s) {\n"], "40": ["    @Override\n", "    public byte[] toByteArray() {\n"], "41": ["        @Override\n", "        public void write(int b) {}\n", "\n", "        @Override\n", "        public void write(byte[] b) {\n", "\n", "        @Override\n", "        public void write(byte[] b, int off, int len) {\n"], "42": ["   * Wraps a {@link InputStream}, limiting the number of bytes which can be read.\n"], "43": ["    @Override\n", "    public int available() throws IOException {\n", "    @Override\n", "    public synchronized void mark(int readLimit) {\n", "    @Override\n", "    public int read() throws IOException {\n"], "44": ["    @Override\n", "    public int read(byte[] b, int off, int len) throws IOException {\n"], "45": ["    @Override\n", "    public synchronized void reset() throws IOException {\n"], "46": ["    @Override\n", "    public long skip(long n) throws IOException {\n"], "47": ["   * Attempts to read enough bytes from the stream to fill the given byte array, with the same\n", "   * behavior as {@link DataInput#readFully(byte[])}. Does not close the stream.\n", "   * @throws EOFException if this stream reaches the end before reading all the bytes.\n"], "48": ["   * Attempts to read {@code len} bytes from the stream into the given array starting at\n", "   * {@code off}, with the same behavior as {@link DataInput#readFully(byte[], int, int)}. Does not\n", "   * close the stream.\n", "   * @throws EOFException if this stream reaches the end before reading all the bytes.\n", "  public static void readFully(InputStream in, byte[] b, int off, int len) throws IOException {\n", "      throw new EOFException(\n", "          \"reached end of stream after reading \" + read + \" bytes; \" + len + \" bytes expected\");\n", "   * Discards {@code n} bytes of data from the input stream. This method will block until the full\n", "   * amount has been skipped. Does not close the stream.\n", "   * @throws EOFException if this stream reaches the end before skipping all the bytes\n", "   * @throws IOException if an I/O error occurs, or the stream does not support skipping\n", "      throw new EOFException(\n", "          \"reached end of stream after skipping \" + skipped + \" bytes; \" + n + \" bytes expected\");\n", "   * Discards up to {@code n} bytes of data from the input stream. This method will block until\n", "   * either the full amount has been skipped or until the end of the stream is reached, whichever\n", "   * happens first. Returns the total number of bytes skipped.\n"], "49": ["   * than actually remain in the file, something that it {@linkplain FileInputStream#skip(long)\n", "   * specifies} it can do in its Javadoc despite the fact that it is violating the contract of\n", "   * {@code InputStream.skip()}.\n"], "50": ["  public static <T> T readBytes(InputStream input, ByteProcessor<T> processor) throws IOException {\n"], "51": ["   * Reads some bytes from an input stream and stores them into the buffer array {@code b}. This\n", "   * method blocks until {@code len} bytes of input data have been read into the array, or end of\n", "   * file is detected. The number of bytes read is returned, possibly zero. Does not close the\n", "   * stream.\n", "   * <p>A caller can detect EOF if the number of bytes read is less than {@code len}. All subsequent\n", "   * calls on the same stream will return zero.\n", "   * <p>If {@code b} is null, a {@code NullPointerException} is thrown. If {@code off} is negative,\n", "   * or {@code len} is negative, or {@code off+len} is greater than the length of the array\n", "   * {@code b}, then an {@code IndexOutOfBoundsException} is thrown. If {@code len} is zero, then no\n", "   * bytes are read. Otherwise, the first byte read is stored into element {@code b[off]}, the next\n", "   * one into {@code b[off+1]}, and so on. The number of bytes read is, at most, equal to\n", "   * {@code len}.\n"], "52": ["  public static int read(InputStream in, byte[] b, int off, int len) throws IOException {\n"]}, "removed": {"1": [" * Licensed under the Apache License, Version 2.0 (the \"License\");\n", " * you may not use this file except in compliance with the License.\n", " * You may obtain a copy of the License at\n", " * Unless required by applicable law or agreed to in writing, software\n", " * distributed under the License is distributed on an \"AS IS\" BASIS,\n", " * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n", " * See the License for the specific language governing permissions and\n", " * limitations under the License.\n"], "2": ["   * There are three methods to implement {@link FileChannel#transferTo(long, long,\n", "   *  WritableByteChannel)}:\n", "   * <li> Use sendfile(2) or equivalent. Requires that both the input channel and the output channel\n", "   *    have their own file descriptors. Generally this only happens when both channels are files or\n", "   *    sockets. This performs zero copies - the bytes never enter userspace.</li>\n", "   * <li> Use mmap(2) or equivalent. Requires that either the input channel or the output channel\n", "   *    have file descriptors. Bytes are copied from the file into a kernel buffer, then directly\n", "   *    into the other buffer (userspace). Note that if the file is very large, a naive\n", "   *    implementation will effectively put the whole file in memory. On many systems with paging\n", "   *    and virtual memory, this is not a problem - because it is mapped read-only, the kernel can\n", "   *    always page it to disk \"for free\". However, on systems where killing processes happens all\n", "   *    the time in normal conditions (i.e., android) the OS must make a tradeoff between paging\n", "   *    memory and killing other processes - so allocating a gigantic buffer and then sequentially\n", "   *    accessing it could result in other processes dying. This is solvable via madvise(2), but\n", "   *    that obviously doesn't exist in java.</li>\n", "   * <li> Ordinary copy. Kernel copies bytes into a kernel buffer, from a kernel buffer into a\n", "   *    userspace buffer (byte[] or ByteBuffer), then copies them from that buffer into the\n", "   *    destination channel.</li>\n"], "3": ["   * Copies all bytes from the input stream to the output stream.\n", "   * Does not close or flush either stream.\n", "  public static long copy(InputStream from, OutputStream to)\n", "      throws IOException {\n"], "4": ["   * Copies all bytes from the readable channel to the writable channel.\n", "   * Does not close or flush either channel.\n", "  public static long copy(ReadableByteChannel from,\n", "      WritableByteChannel to) throws IOException {\n"], "5": ["   * Reads all bytes from an input stream into a byte array.\n", "   * Does not close the stream.\n"], "6": ["   * Reads all bytes from an input stream into a byte array. The given\n", "   * expected size is used to create an initial byte array, but if the actual\n", "   * number of bytes read from the stream differs, the correct result will be\n", "   * returned anyway.\n", "  static byte[] toByteArray(\n", "      InputStream in, int expectedSize) throws IOException {\n"], "7": ["  private static final class FastByteArrayOutputStream\n", "      extends ByteArrayOutputStream {\n", "     * Writes the contents of the internal buffer to the given array starting\n", "     * at the given offset. Assumes the array has space to hold count bytes.\n"], "8": ["   * Returns a new {@link ByteArrayDataInput} instance to read from the {@code\n", "   * bytes} array from the beginning.\n", "   * Returns a new {@link ByteArrayDataInput} instance to read from the {@code\n", "   * bytes} array, starting at the given position.\n", "   * @throws IndexOutOfBoundsException if {@code start} is negative or greater\n", "   *     than the length of the array\n", "    return newDataInput(\n", "        new ByteArrayInputStream(bytes, start, bytes.length - start));\n", "   * {@code ByteArrayInputStream}. The given input stream is not reset before\n", "   * being read from by the returned {@code ByteArrayDataInput}.\n", "  public static ByteArrayDataInput newDataInput(\n", "      ByteArrayInputStream byteArrayInputStream) {\n"], "9": ["    @Override public void readFully(byte b[]) {\n"], "10": ["    @Override public void readFully(byte b[], int off, int len) {\n"], "11": ["    @Override public int skipBytes(int n) {\n"], "12": ["    @Override public boolean readBoolean() {\n"], "13": ["    @Override public byte readByte() {\n"], "14": ["    @Override public int readUnsignedByte() {\n"], "15": ["    @Override public short readShort() {\n"], "16": ["    @Override public int readUnsignedShort() {\n"], "17": ["    @Override public char readChar() {\n"], "18": ["    @Override public int readInt() {\n"], "19": ["    @Override public long readLong() {\n"], "20": ["    @Override public float readFloat() {\n"], "21": ["    @Override public double readDouble() {\n"], "22": ["    @Override public String readLine() {\n"], "23": ["    @Override public String readUTF() {\n"], "24": ["   * Returns a new {@link ByteArrayDataOutput} instance sized to hold\n", "   * {@code size} bytes before resizing.\n"], "25": ["   * Returns a new {@link ByteArrayDataOutput} instance which writes to the\n", "   * given {@code ByteArrayOutputStream}. The given output stream is not reset\n", "   * before being written to by the returned {@code ByteArrayDataOutput} and\n", "   * new data will be appended to any existing content.\n", "   * <p>Note that if the given output stream was not empty or is modified after\n", "   * the {@code ByteArrayDataOutput} is created, the contract for\n", "   * {@link ByteArrayDataOutput#toByteArray} will not be honored (the bytes\n", "   * returned in the byte array may not be exactly what was written via calls to\n", "   * {@code ByteArrayDataOutput}).\n", "  public static ByteArrayDataOutput newDataOutput(\n", "      ByteArrayOutputStream byteArrayOutputSteam) {\n", "  private static class ByteArrayDataOutputStream\n", "      implements ByteArrayDataOutput {\n"], "26": ["    @Override public void write(int b) {\n"], "27": ["    @Override public void write(byte[] b) {\n"], "28": ["    @Override public void write(byte[] b, int off, int len) {\n"], "29": ["    @Override public void writeBoolean(boolean v) {\n"], "30": ["    @Override public void writeByte(int v) {\n"], "31": ["    @Override public void writeBytes(String s) {\n"], "32": ["    @Override public void writeChar(int v) {\n"], "33": ["    @Override public void writeChars(String s) {\n"], "34": ["    @Override public void writeDouble(double v) {\n"], "35": ["    @Override public void writeFloat(float v) {\n"], "36": ["    @Override public void writeInt(int v) {\n"], "37": ["    @Override public void writeLong(long v) {\n"], "38": ["    @Override public void writeShort(int v) {\n"], "39": ["    @Override public void writeUTF(String s) {\n"], "40": ["    @Override public byte[] toByteArray() {\n"], "41": ["        @Override public void write(int b) {\n", "        }\n", "        @Override public void write(byte[] b) {\n", "        @Override public void write(byte[] b, int off, int len) {\n"], "42": ["   * Wraps a {@link InputStream}, limiting the number of bytes which can be\n", "   * read.\n"], "43": ["    @Override public int available() throws IOException {\n", "    @Override public synchronized void mark(int readLimit) {\n", "    @Override public int read() throws IOException {\n"], "44": ["    @Override public int read(byte[] b, int off, int len) throws IOException {\n"], "45": ["    @Override public synchronized void reset() throws IOException {\n"], "46": ["    @Override public long skip(long n) throws IOException {\n"], "47": ["   * Attempts to read enough bytes from the stream to fill the given byte array,\n", "   * with the same behavior as {@link DataInput#readFully(byte[])}.\n", "   * Does not close the stream.\n", "   * @throws EOFException if this stream reaches the end before reading all\n", "   *     the bytes.\n"], "48": ["   * Attempts to read {@code len} bytes from the stream into the given array\n", "   * starting at {@code off}, with the same behavior as\n", "   * {@link DataInput#readFully(byte[], int, int)}. Does not close the\n", "   * stream.\n", "   * @throws EOFException if this stream reaches the end before reading all\n", "   *     the bytes.\n", "  public static void readFully(\n", "      InputStream in, byte[] b, int off, int len) throws IOException {\n", "      throw new EOFException(\"reached end of stream after reading \"\n", "          + read + \" bytes; \" + len + \" bytes expected\");\n", "   * Discards {@code n} bytes of data from the input stream. This method\n", "   * will block until the full amount has been skipped. Does not close the\n", "   * stream.\n", "   * @throws EOFException if this stream reaches the end before skipping all\n", "   *     the bytes\n", "   * @throws IOException if an I/O error occurs, or the stream does not\n", "   *     support skipping\n", "      throw new EOFException(\"reached end of stream after skipping \"\n", "          + skipped + \" bytes; \" + n + \" bytes expected\");\n", "   * Discards up to {@code n} bytes of data from the input stream. This method\n", "   * will block until either the full amount has been skipped or until the end\n", "   * of the stream is reached, whichever happens first. Returns the total number\n", "   * of bytes skipped.\n"], "49": ["   * than actually remain in the file, something that it\n", "   * {@linkplain FileInputStream#skip(long) specifies} it can do in its Javadoc despite the fact\n", "   * that it is violating the contract of {@code InputStream.skip()}.\n"], "50": ["  public static <T> T readBytes(\n", "      InputStream input, ByteProcessor<T> processor) throws IOException {\n"], "51": ["   * Reads some bytes from an input stream and stores them into the buffer array\n", "   * {@code b}. This method blocks until {@code len} bytes of input data have\n", "   * been read into the array, or end of file is detected. The number of bytes\n", "   * read is returned, possibly zero. Does not close the stream.\n", "   * <p>A caller can detect EOF if the number of bytes read is less than\n", "   * {@code len}. All subsequent calls on the same stream will return zero.\n", "   * <p>If {@code b} is null, a {@code NullPointerException} is thrown. If\n", "   * {@code off} is negative, or {@code len} is negative, or {@code off+len} is\n", "   * greater than the length of the array {@code b}, then an\n", "   * {@code IndexOutOfBoundsException} is thrown. If {@code len} is zero, then\n", "   * no bytes are read. Otherwise, the first byte read is stored into element\n", "   * {@code b[off]}, the next one into {@code b[off+1]}, and so on. The number\n", "   * of bytes read is, at most, equal to {@code len}.\n"], "52": ["  public static int read(InputStream in, byte[] b, int off, int len)\n", "      throws IOException {\n"]}, "added_lines": {"1": [4, 5, 9, 10, 11, 12], "2": [64, 65, 68, 69, 70, 71, 72, 73, 74, 75, 76, 77, 78, 79, 80, 81, 82, 83], "3": [95, 96, 103], "4": [120, 121, 128], "5": [157], "6": [173, 174, 175, 177], "7": [212, 214, 215], "8": [223, 224, 231, 232, 234, 235, 239, 244, 245, 249], "9": [260, 261], "10": [269, 270], "11": [278, 279], "12": [287, 288], "13": [296, 297], "14": [307, 308], "15": [316, 317], "16": [325, 326], "17": [334, 335], "18": [343, 344], "19": [352, 353], "20": [361, 362], "21": [370, 371], "22": [379, 380], "23": [388, 389], "24": [406, 407], "25": [421, 422, 423, 425, 426, 427, 428, 432, 437], "26": [447, 448], "27": [456, 457], "28": [465, 466], "29": [474, 475], "30": [483, 484], "31": [492, 493], "32": [501, 502], "33": [510, 511], "34": [519, 520], "35": [528, 529], "36": [537, 538], "37": [546, 547], "38": [555, 556], "39": [564, 565], "40": [573, 574], "41": [582, 583, 584, 586, 587, 590, 592, 593], "42": [613], "43": [636, 637, 642, 643, 648, 649], "44": [661, 662], "45": [675, 676], "46": [688, 689], "47": [698, 699, 703], "48": [711, 712, 713, 719, 722, 725, 726, 731, 732, 736, 737, 742, 743, 748, 749, 750], "49": [779, 780, 781], "50": [797], "51": [810, 811, 812, 813, 815, 816, 818, 819, 820, 821, 822, 823], "52": [832]}, "removed_lines": {"1": [4, 5, 6, 10, 11, 12, 13, 14], "2": [66, 67, 70, 71, 72, 73, 74, 75, 76, 77, 78, 79, 80, 81, 82, 83, 84, 85], "3": [97, 98, 105, 106], "4": [123, 124, 131, 132], "5": [161, 162], "6": [178, 179, 180, 181, 183, 184], "7": [219, 220, 222, 223], "8": [231, 232, 239, 240, 242, 243, 247, 248, 253, 254, 258, 259], "9": [270], "10": [278], "11": [286], "12": [294], "13": [302], "14": [312], "15": [320], "16": [328], "17": [336], "18": [344], "19": [352], "20": [360], "21": [368], "22": [376], "23": [384], "24": [401, 402], "25": [416, 417, 418, 419, 421, 422, 423, 424, 425, 429, 430, 435, 436], "26": [446], "27": [454], "28": [462], "29": [470], "30": [478], "31": [486], "32": [494], "33": [502], "34": [510], "35": [518], "36": [526], "37": [534], "38": [542], "39": [550], "40": [558], "41": [566, 567, 569, 573], "42": [593, 594], "43": [617, 622, 627], "44": [639], "45": [652], "46": [664], "47": [673, 674, 675, 679, 680], "48": [688, 689, 690, 691, 697, 698, 701, 702, 705, 706, 711, 712, 713, 717, 718, 719, 720, 725, 726, 731, 732, 733, 734], "49": [763, 764, 765], "50": [781, 782], "51": [795, 796, 797, 798, 800, 801, 803, 804, 805, 806, 807, 808, 809], "52": [818, 819]}}, {"8": "guava/src/com/google/common/io/CharSequenceReader.java", "added": {"1": [" * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not use this file except\n", " * in compliance with the License. You may obtain a copy of the License at\n", " * Unless required by applicable law or agreed to in writing, software distributed under the License\n", " * is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express\n", " * or implied. See the License for the specific language governing permissions and limitations under\n", " * the License.\n"]}, "removed": {"1": [" * Licensed under the Apache License, Version 2.0 (the \"License\");\n", " * you may not use this file except in compliance with the License.\n", " * You may obtain a copy of the License at\n", " * Unless required by applicable law or agreed to in writing, software\n", " * distributed under the License is distributed on an \"AS IS\" BASIS,\n", " * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n", " * See the License for the specific language governing permissions and\n", " * limitations under the License.\n"]}, "added_lines": {"1": [4, 5, 9, 10, 11, 12]}, "removed_lines": {"1": [4, 5, 6, 10, 11, 12, 13, 14]}}, {"9": "guava/src/com/google/common/io/CharSink.java", "added": {"1": [" * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not use this file except\n", " * in compliance with the License. You may obtain a copy of the License at\n", " * Unless required by applicable law or agreed to in writing, software distributed under the License\n", " * is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express\n", " * or implied. See the License for the specific language governing permissions and limitations under\n", " * the License.\n"], "2": [" * <li><b>Methods that return a writer:</b> These methods should return a <i>new</i>, independent\n", " *     instance each time they are called. The caller is responsible for ensuring that the returned\n", " *     writer is closed.\n", " * <li><b>Convenience methods:</b> These are implementations of common operations that are typically\n", " *     implemented by opening a writer using one of the methods in the first category, doing\n", " *     something and finally closing the writer that was opened.\n"], "3": ["   * required to be a {@link BufferedWriter} in order to allow implementations to simply delegate to\n", "   * {@link #openStream()} when the stream returned by that method does not benefit from additional\n", "   * buffering. This method should return a new, independent writer each time it is called.\n"]}, "removed": {"1": [" * Licensed under the Apache License, Version 2.0 (the \"License\");\n", " * you may not use this file except in compliance with the License.\n", " * You may obtain a copy of the License at\n", " * Unless required by applicable law or agreed to in writing, software\n", " * distributed under the License is distributed on an \"AS IS\" BASIS,\n", " * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n", " * See the License for the specific language governing permissions and\n", " * limitations under the License.\n"], "2": [" *   <li><b>Methods that return a writer:</b> These methods should return a <i>new</i>,\n", " *   independent instance each time they are called. The caller is responsible for ensuring that the\n", " *   returned writer is closed.\n", " *   <li><b>Convenience methods:</b> These are implementations of common operations that are\n", " *   typically implemented by opening a writer using one of the methods in the first category,\n", " *   doing something and finally closing the writer that was opened.\n"], "3": ["   * required to be a {@link BufferedWriter} in order to allow implementations to simply delegate\n", "   * to {@link #openStream()} when the stream returned by that method does not benefit from\n", "   * additional buffering. This method should return a new, independent writer each time it is\n", "   * called.\n"]}, "added_lines": {"1": [4, 5, 9, 10, 11, 12], "2": [34, 35, 36, 37, 38, 39], "3": [69, 70, 71]}, "removed_lines": {"1": [4, 5, 6, 10, 11, 12, 13, 14], "2": [36, 37, 38, 39, 40, 41], "3": [71, 72, 73, 74]}}, {"10": "guava/src/com/google/common/io/CharSource.java", "added": {"1": [" * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not use this file except\n", " * in compliance with the License. You may obtain a copy of the License at\n", " * Unless required by applicable law or agreed to in writing, software distributed under the License\n", " * is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express\n", " * or implied. See the License for the specific language governing permissions and limitations under\n", " * the License.\n"], "3": [" * <li><b>Methods that return a reader:</b> These methods should return a <i>new</i>, independent\n", " *     instance each time they are called. The caller is responsible for ensuring that the returned\n", " *     reader is closed.\n", " * <li><b>Convenience methods:</b> These are implementations of common operations that are typically\n", " *     implemented by opening a reader using one of the methods in the first category, doing\n", " *     something and finally closing the reader that was opened.\n", " * <p>Several methods in this class, such as {@link #readLines()}, break the contents of the source\n", " * into lines. Like {@link BufferedReader}, these methods break lines on any of {@code \\n},\n"], "4": ["   * Returns the size of this source in chars, if the size can be easily determined without actually\n", "   * opening the data stream.\n", "   * <i>possible</i> that this method will return a different number of chars than would be returned\n", "   * by reading all of the chars.\n", "   * <p>Additionally, for mutable sources such as {@code StringBuilder}s, a subsequent read may\n", "   * return a different number of chars if the contents are changed.\n"], "5": ["   * Returns the length of this source in chars, even if doing so requires opening and traversing an\n", "   * entire stream. To avoid a potentially expensive operation, see {@link #lengthIfKnown}.\n", "   * <p>The default implementation calls {@link #lengthIfKnown} and returns the value if present. If\n", "   * absent, it will fall back to a heavyweight operation that will open a stream,\n"], "6": ["  @Nullable\n", "  public String readFirstLine() throws IOException {\n"], "7": ["   * {@link #lengthIfKnown} returns zero, falling back to opening a stream and checking for EOF if\n", "   * the length is not known.\n"], "8": ["   * <p>Only one underlying stream will be open at a time. Closing the concatenated stream will\n"], "9": ["   * <p>Note: The input {@code Iterator} will be copied to an {@code ImmutableList} when this method\n", "   * is called. This will fail if the iterator is infinite and may cause problems if the iterator\n", "   * eagerly fetches data for each source when iterated (rather than producing sources that only\n", "   * load data through their streams). Prefer using the {@link #concat(Iterable)} overload if\n", "   * possible.\n"], "10": ["    private static final Splitter LINE_SPLITTER = Splitter.onPattern(\"\\r\\n|\\n|\\r\");\n"], "11": ["     * Returns an iterable over the lines in the string. If the string ends in a newline, a final\n", "     * empty string is not included to match the behavior of BufferedReader/LineReader.readLine().\n"]}, "removed": {"1": [" * Licensed under the Apache License, Version 2.0 (the \"License\");\n", " * you may not use this file except in compliance with the License.\n", " * You may obtain a copy of the License at\n", " * Unless required by applicable law or agreed to in writing, software\n", " * distributed under the License is distributed on an \"AS IS\" BASIS,\n", " * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n", " * See the License for the specific language governing permissions and\n", " * limitations under the License.\n"], "2": ["import java.util.regex.Pattern;\n"], "3": [" *   <li><b>Methods that return a reader:</b> These methods should return a <i>new</i>, independent\n", " *   instance each time they are called. The caller is responsible for ensuring that the returned\n", " *   reader is closed.\n", " *   <li><b>Convenience methods:</b> These are implementations of common operations that are\n", " *   typically implemented by opening a reader using one of the methods in the first category,\n", " *   doing something and finally closing the reader that was opened.\n", " * <p>Several methods in this class, such as {@link #readLines()}, break the contents of the\n", " * source into lines. Like {@link BufferedReader}, these methods break lines on any of {@code \\n},\n"], "4": ["   * Returns the size of this source in chars, if the size can be easily determined without\n", "   * actually opening the data stream.\n", "   * <i>possible</i> that this method will return a different number of chars than would be\n", "   * returned by reading all of the chars.\n", "   * <p>Additionally, for mutable sources such as {@code StringBuilder}s, a subsequent read\n", "   * may return a different number of chars if the contents are changed.\n"], "5": ["   * Returns the length of this source in chars, even if doing so requires opening and traversing\n", "   * an entire stream. To avoid a potentially expensive operation, see {@link #lengthIfKnown}.\n", "   * <p>The default implementation calls {@link #lengthIfKnown} and returns the value if present.\n", "   * If absent, it will fall back to a heavyweight operation that will open a stream,\n"], "6": ["  @Nullable public String readFirstLine() throws IOException {\n"], "7": ["   * {@link #lengthIfKnown} returns zero, falling back to opening a stream and checking\n", "   * for EOF if the length is not known.\n"], "8": ["   * <p>Only one underlying stream will be open at a time. Closing the  concatenated stream will\n"], "9": ["   * <p>Note: The input {@code Iterator} will be copied to an {@code ImmutableList} when this\n", "   * method is called. This will fail if the iterator is infinite and may cause problems if the\n", "   * iterator eagerly fetches data for each source when iterated (rather than producing sources\n", "   * that only load data through their streams). Prefer using the {@link #concat(Iterable)}\n", "   * overload if possible.\n"], "10": ["    private static final Splitter LINE_SPLITTER\n", "        = Splitter.on(Pattern.compile(\"\\r\\n|\\n|\\r\"));\n"], "11": ["     * Returns an iterable over the lines in the string. If the string ends in\n", "     * a newline, a final empty string is not included to match the behavior of\n", "     * BufferedReader/LineReader.readLine().\n"]}, "added_lines": {"1": [4, 5, 9, 10, 11, 12], "3": [46, 47, 48, 49, 50, 51, 54, 55], "4": [115, 116, 120, 121, 123, 124], "5": [134, 135, 137, 138], "6": [247, 248], "7": [318, 319], "8": [348], "9": [366, 367, 368, 369, 370], "10": [449], "11": [483, 484]}, "removed_lines": {"1": [4, 5, 6, 10, 11, 12, 13, 14], "2": [38], "3": [49, 50, 51, 52, 53, 54, 57, 58], "4": [118, 119, 123, 124, 126, 127], "5": [137, 138, 140, 141], "6": [250], "7": [320, 321], "8": [350], "9": [368, 369, 370, 371, 372], "10": [451, 452], "11": [486, 487, 488]}}, {"11": "guava/src/com/google/common/io/CharStreams.java", "added": {"1": [" * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not use this file except\n", " * in compliance with the License. You may obtain a copy of the License at\n", " * Unless required by applicable law or agreed to in writing, software distributed under the License\n", " * is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express\n", " * or implied. See the License for the specific language governing permissions and limitations under\n", " * the License.\n"], "2": [" * {@code Readable & Closeable}. A {@link java.io.Reader} implements both of those interfaces.\n", " * Similarly for {@code Appendable & Closeable} and {@link java.io.Writer}.\n"], "3": ["   * Copies all characters between the {@link Readable} and {@link Appendable} objects. Does not\n", "   * close or flush either object.\n"], "4": ["   * Reads all characters from a {@link Readable} object into a {@link String}. Does not close the\n", "   * {@code Readable}.\n"], "5": ["   * Reads all characters from a {@link Readable} object into a new {@link StringBuilder} instance.\n", "   * Does not close the {@code Readable}.\n"], "6": ["   * Reads all of the lines from a {@link Readable} object. The lines do not include\n", "   * line-termination characters, but do include other leading and trailing whitespace.\n", "   * <p>Does not close the {@code Readable}. If reading files or resources you should use the\n", "   * {@link Files#readLines} and {@link Resources#readLines} methods.\n"], "7": ["   * Streams lines from a {@link Readable} object, stopping when the processor returns {@code false}\n", "   * or all lines have been read and returning the result produced by the processor. Does not close\n", "   * {@code readable}. Note that this method may not fully consume the contents of {@code readable}\n", "   * if the processor stops processing early.\n", "  public static <T> T readLines(Readable readable, LineProcessor<T> processor) throws IOException {\n"], "8": ["   * Discards {@code n} characters of data from the reader. This method will block until the full\n", "   * amount has been skipped. Does not close the reader.\n", "   * @throws EOFException if this stream reaches the end before skipping all the characters\n"], "9": ["    public void write(int c) {}\n"], "10": ["    public void flush() {}\n", "    public void close() {}\n"], "11": ["   * Returns a Writer that sends all output to the given {@link Appendable} target. Closing the\n", "   * writer will close the target if it is {@link Closeable}, and flushing the writer will flush the\n", "   * target if it is {@link java.io.Flushable}.\n", "   * @return a new Writer object, unless target is a Writer, in which case the target is returned\n"]}, "removed": {"1": [" * Licensed under the Apache License, Version 2.0 (the \"License\");\n", " * you may not use this file except in compliance with the License.\n", " * You may obtain a copy of the License at\n", " * Unless required by applicable law or agreed to in writing, software\n", " * distributed under the License is distributed on an \"AS IS\" BASIS,\n", " * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n", " * See the License for the specific language governing permissions and\n", " * limitations under the License.\n"], "2": [" * {@code Readable & Closeable}. A {@link java.io.Reader} implements both of\n", " * those interfaces. Similarly for {@code Appendable & Closeable} and\n", " * {@link java.io.Writer}.\n"], "3": ["   * Copies all characters between the {@link Readable} and {@link Appendable}\n", "   * objects. Does not close or flush either object.\n"], "4": ["   * Reads all characters from a {@link Readable} object into a {@link String}.\n", "   * Does not close the {@code Readable}.\n"], "5": ["   * Reads all characters from a {@link Readable} object into a new\n", "   * {@link StringBuilder} instance. Does not close the {@code Readable}.\n"], "6": ["   * Reads all of the lines from a {@link Readable} object. The lines do\n", "   * not include line-termination characters, but do include other\n", "   * leading and trailing whitespace.\n", "   * <p>Does not close the {@code Readable}. If reading files or resources you\n", "   * should use the {@link Files#readLines} and {@link Resources#readLines}\n", "   * methods.\n"], "7": ["   * Streams lines from a {@link Readable} object, stopping when the processor\n", "   * returns {@code false} or all lines have been read and returning the result\n", "   * produced by the processor. Does not close {@code readable}. Note that this\n", "   * method may not fully consume the contents of {@code readable} if the\n", "   * processor stops processing early.\n", "  public static <T> T readLines(\n", "      Readable readable, LineProcessor<T> processor) throws IOException {\n"], "8": ["   * Discards {@code n} characters of data from the reader. This method\n", "   * will block until the full amount has been skipped. Does not close the\n", "   * reader.\n", "   * @throws EOFException if this stream reaches the end before skipping all\n", "   *     the characters\n"], "9": ["    public void write(int c) {\n", "    }\n"], "10": ["    public void flush() {\n", "    }\n", "    public void close() {\n", "    }\n"], "11": ["   * Returns a Writer that sends all output to the given {@link Appendable}\n", "   * target. Closing the writer will close the target if it is {@link\n", "   * Closeable}, and flushing the writer will flush the target if it is {@link\n", "   * java.io.Flushable}.\n", "   * @return a new Writer object, unless target is a Writer, in which case the\n", "   *     target is returned\n"]}, "added_lines": {"1": [4, 5, 9, 10, 11, 12], "2": [38, 39], "3": [54, 55], "4": [77, 78], "5": [89, 90], "6": [103, 104, 106, 107], "7": [124, 125, 126, 127, 132], "8": [147, 148, 152], "9": [180], "10": [220, 223], "11": [232, 233, 234, 237]}, "removed_lines": {"1": [4, 5, 6, 10, 11, 12, 13, 14], "2": [40, 41, 42], "3": [57, 58], "4": [80, 81], "5": [92, 93], "6": [106, 107, 108, 110, 111, 112], "7": [129, 130, 131, 132, 133, 138, 139], "8": [154, 155, 156, 160, 161], "9": [189, 190], "10": [230, 231, 234, 235], "11": [244, 245, 246, 247, 250, 251]}}, {"12": "guava/src/com/google/common/io/Closeables.java", "added": {"1": [" * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not use this file except\n", " * in compliance with the License. You may obtain a copy of the License at\n", " * Unless required by applicable law or agreed to in writing, software distributed under the License\n", " * is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express\n", " * or implied. See the License for the specific language governing permissions and limitations under\n", " * the License.\n"], "2": ["  @VisibleForTesting static final Logger logger = Logger.getLogger(Closeables.class.getName());\n"], "3": ["  public static void close(@Nullable Closeable closeable, boolean swallowIOException)\n", "      throws IOException {\n"], "4": ["        logger.log(Level.WARNING, \"IOException thrown while closing Closeable.\", e);\n"], "5": ["   * Closes the given {@link InputStream}, logging any {@code IOException} that's thrown rather than\n", "   * propagating it.\n", "   * <p>While it's not safe in the general case to ignore exceptions that are thrown when closing an\n", "   * I/O resource, it should generally be safe in the case of a resource that's being used only for\n", "   * reading, such as an {@code InputStream}. Unlike with writable resources, there's no chance that\n", "   * a failure that occurs when closing the stream indicates a meaningful problem such as a failure\n", "   * to flush all bytes to the underlying resource.\n"], "6": ["   * <p>While it's not safe in the general case to ignore exceptions that are thrown when closing an\n", "   * I/O resource, it should generally be safe in the case of a resource that's being used only for\n", "   * reading, such as a {@code Reader}. Unlike with writable resources, there's no chance that a\n", "   * failure that occurs when closing the reader indicates a meaningful problem such as a failure to\n", "   * flush all bytes to the underlying resource.\n"]}, "removed": {"1": [" * Licensed under the Apache License, Version 2.0 (the \"License\");\n", " * you may not use this file except in compliance with the License.\n", " * You may obtain a copy of the License at\n", " * Unless required by applicable law or agreed to in writing, software\n", " * distributed under the License is distributed on an \"AS IS\" BASIS,\n", " * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n", " * See the License for the specific language governing permissions and\n", " * limitations under the License.\n"], "2": ["  @VisibleForTesting static final Logger logger\n", "      = Logger.getLogger(Closeables.class.getName());\n"], "3": ["  public static void close(@Nullable Closeable closeable,\n", "      boolean swallowIOException) throws IOException {\n"], "4": ["        logger.log(Level.WARNING,\n", "            \"IOException thrown while closing Closeable.\", e);\n"], "5": ["   * Closes the given {@link InputStream}, logging any {@code IOException} that's thrown rather\n", "   * than propagating it.\n", "   * <p>While it's not safe in the general case to ignore exceptions that are thrown when closing\n", "   * an I/O resource, it should generally be safe in the case of a resource that's being used only\n", "   * for reading, such as an {@code InputStream}. Unlike with writable resources, there's no\n", "   * chance that a failure that occurs when closing the stream indicates a meaningful problem such\n", "   * as a failure to flush all bytes to the underlying resource.\n"], "6": ["   * <p>While it's not safe in the general case to ignore exceptions that are thrown when closing\n", "   * an I/O resource, it should generally be safe in the case of a resource that's being used only\n", "   * for reading, such as a {@code Reader}. Unlike with writable resources, there's no chance that\n", "   * a failure that occurs when closing the reader indicates a meaningful problem such as a failure\n", "   * to flush all bytes to the underlying resource.\n"]}, "added_lines": {"1": [4, 5, 9, 10, 11, 12], "2": [39], "3": [72, 73], "4": [81], "5": [89, 90, 92, 93, 94, 95, 96], "6": [114, 115, 116, 117, 118]}, "removed_lines": {"1": [4, 5, 6, 10, 11, 12, 13, 14], "2": [41, 42], "3": [75, 76], "4": [84, 85], "5": [93, 94, 96, 97, 98, 99, 100], "6": [118, 119, 120, 121, 122]}}, {"13": "guava/src/com/google/common/io/Closer.java", "added": {"1": [" * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not use this file except\n", " * in compliance with the License. You may obtain a copy of the License at\n", " * Unless required by applicable law or agreed to in writing, software distributed under the License\n", " * is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express\n", " * or implied. See the License for the specific language governing permissions and limitations under\n", " * the License.\n"], "2": [" * <a href=\"http://docs.oracle.com/javase/tutorial/essential/exceptions/tryResourceClose.html\"\n", " * >try-with-resources</a> statement in JDK6-compatible code. Running on Java 7, code using this\n"], "3": [" * <li>Each {@code Closeable} resource that is successfully registered will be closed later.\n", " * <li>If a {@code Throwable} is thrown in the try block, no exceptions that occur when attempting\n", " *     to close resources will be thrown from the finally block. The throwable from the try block\n", " *     will be thrown.\n", " * <li>If no exceptions or errors were thrown in the try block, the <i>first</i> exception thrown by\n", " *     an attempt to close a resource will be thrown.\n", " * <li>Any exception caught when attempting to close a resource that is <i>not</i> thrown (because\n", " *     another exception is already being thrown) is <i>suppressed</i>.\n", " * <li><b>Java 7+:</b> Exceptions are suppressed by adding them to the exception that <i>will</i> be\n", " *     thrown using {@code Throwable.addSuppressed(Throwable)}.\n", " * <li><b>Java 6:</b> Exceptions are suppressed by logging them instead.\n"], "4": ["  private static final Suppressor SUPPRESSOR =\n", "      SuppressingSuppressor.isAvailable()\n", "          ? SuppressingSuppressor.INSTANCE\n", "          : LoggingSuppressor.INSTANCE;\n"], "5": ["  @VisibleForTesting\n", "  Closer(Suppressor suppressor) {\n"], "6": ["   * <p>This method always throws, and as such should be called as {@code throw closer.rethrow(e);}\n", "   * to ensure the compiler knows that it will throw.\n"], "7": ["  public <X extends Exception> RuntimeException rethrow(Throwable e, Class<X> declaredType)\n", "      throws IOException, X {\n"], "8": ["  @VisibleForTesting\n", "  interface Suppressor {\n"], "9": ["  @VisibleForTesting\n", "  static final class LoggingSuppressor implements Suppressor {\n", "      Closeables.logger.log(\n", "          Level.WARNING, \"Suppressing exception thrown when closing \" + closeable, suppressed);\n"], "10": ["  @VisibleForTesting\n", "  static final class SuppressingSuppressor implements Suppressor {\n"]}, "removed": {"1": [" * Licensed under the Apache License, Version 2.0 (the \"License\");\n", " * you may not use this file except in compliance with the License.\n", " * You may obtain a copy of the License at\n", " * Unless required by applicable law or agreed to in writing, software\n", " * distributed under the License is distributed on an \"AS IS\" BASIS,\n", " * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n", " * See the License for the specific language governing permissions and\n", " * limitations under the License.\n"], "2": [" * <a href=\"http://docs.oracle.com/javase/tutorial/essential/exceptions/tryResourceClose.html\">\n", " * try-with-resources</a> statement in JDK6-compatible code. Running on Java 7, code using this\n"], "3": [" *   <li>Each {@code Closeable} resource that is successfully registered will be closed later.</li>\n", " *   <li>If a {@code Throwable} is thrown in the try block, no exceptions that occur when attempting\n", " *   to close resources will be thrown from the finally block. The throwable from the try block will\n", " *   be thrown.</li>\n", " *   <li>If no exceptions or errors were thrown in the try block, the <i>first</i> exception thrown\n", " *   by an attempt to close a resource will be thrown.</li>\n", " *   <li>Any exception caught when attempting to close a resource that is <i>not</i> thrown\n", " *   (because another exception is already being thrown) is <i>suppressed</i>.</li>\n", " *   <li><b>Java 7+:</b> Exceptions are suppressed by adding them to the exception that <i>will</i>\n", " *   be thrown using {@code Throwable.addSuppressed(Throwable)}.</li>\n", " *   <li><b>Java 6:</b> Exceptions are suppressed by logging them instead.</li>\n"], "4": ["  private static final Suppressor SUPPRESSOR = SuppressingSuppressor.isAvailable()\n", "      ? SuppressingSuppressor.INSTANCE\n", "      : LoggingSuppressor.INSTANCE;\n"], "5": ["  @VisibleForTesting Closer(Suppressor suppressor) {\n"], "6": ["   * <p>This method always throws, and as such should be called as\n", "   * {@code throw closer.rethrow(e);} to ensure the compiler knows that it will throw.\n"], "7": ["  public <X extends Exception> RuntimeException rethrow(Throwable e,\n", "      Class<X> declaredType) throws IOException, X {\n"], "8": ["  @VisibleForTesting interface Suppressor {\n"], "9": ["  @VisibleForTesting static final class LoggingSuppressor implements Suppressor {\n", "      Closeables.logger.log(Level.WARNING,\n", "          \"Suppressing exception thrown when closing \" + closeable, suppressed);\n"], "10": ["  @VisibleForTesting static final class SuppressingSuppressor implements Suppressor {\n"]}, "added_lines": {"1": [4, 5, 9, 10, 11, 12], "2": [36, 37], "3": [66, 67, 68, 69, 70, 71, 72, 73, 80, 81, 82], "4": [96, 97, 98, 99], "5": [114, 115], "6": [141, 142], "7": [168, 169], "8": [235, 236], "9": [248, 249, 256, 257], "10": [265, 266]}, "removed_lines": {"1": [4, 5, 6, 10, 11, 12, 13, 14], "2": [38, 39], "3": [68, 69, 70, 71, 72, 73, 74, 75, 82, 83, 84], "4": [98, 99, 100], "5": [115], "6": [141, 142], "7": [168, 169], "8": [235], "9": [247, 254, 255], "10": [263]}}, {"14": "guava/src/com/google/common/io/CountingInputStream.java", "added": {"1": [" * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not use this file except\n", " * in compliance with the License. You may obtain a copy of the License at\n", " * Unless required by applicable law or agreed to in writing, software distributed under the License\n", " * is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express\n", " * or implied. See the License for the specific language governing permissions and limitations under\n", " * the License.\n"], "2": ["  @Override\n", "  public int read() throws IOException {\n"], "3": ["  @Override\n", "  public int read(byte[] b, int off, int len) throws IOException {\n"], "4": ["  @Override\n", "  public long skip(long n) throws IOException {\n", "  @Override\n", "  public synchronized void mark(int readlimit) {\n", "  @Override\n", "  public synchronized void reset() throws IOException {\n"]}, "removed": {"1": [" * Licensed under the Apache License, Version 2.0 (the \"License\");\n", " * you may not use this file except in compliance with the License.\n", " * You may obtain a copy of the License at\n", " * Unless required by applicable law or agreed to in writing, software\n", " * distributed under the License is distributed on an \"AS IS\" BASIS,\n", " * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n", " * See the License for the specific language governing permissions and\n", " * limitations under the License.\n"], "2": ["  @Override public int read() throws IOException {\n"], "3": ["  @Override public int read(byte[] b, int off, int len) throws IOException {\n"], "4": ["  @Override public long skip(long n) throws IOException {\n", "  @Override public synchronized void mark(int readlimit) {\n", "  @Override public synchronized void reset() throws IOException {\n"]}, "added_lines": {"1": [4, 5, 9, 10, 11, 12], "2": [53, 54], "3": [62, 63], "4": [71, 72, 78, 79, 85, 86]}, "removed_lines": {"1": [4, 5, 6, 10, 11, 12, 13, 14], "2": [55], "3": [63], "4": [71, 77, 83]}}, {"15": "guava/src/com/google/common/io/CountingOutputStream.java", "added": {"1": [" * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not use this file except\n", " * in compliance with the License. You may obtain a copy of the License at\n", " * Unless required by applicable law or agreed to in writing, software distributed under the License\n", " * is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express\n", " * or implied. See the License for the specific language governing permissions and limitations under\n", " * the License.\n"], "2": ["  @Override\n", "  public void write(byte[] b, int off, int len) throws IOException {\n", "  @Override\n", "  public void write(int b) throws IOException {\n"], "3": ["  @Override\n", "  public void close() throws IOException {\n"]}, "removed": {"1": [" * Licensed under the Apache License, Version 2.0 (the \"License\");\n", " * you may not use this file except in compliance with the License.\n", " * You may obtain a copy of the License at\n", " * Unless required by applicable law or agreed to in writing, software\n", " * distributed under the License is distributed on an \"AS IS\" BASIS,\n", " * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n", " * See the License for the specific language governing permissions and\n", " * limitations under the License.\n"], "2": ["  @Override public void write(byte[] b, int off, int len) throws IOException {\n", "  @Override public void write(int b) throws IOException {\n"], "3": ["  @Override public void close() throws IOException {\n"]}, "added_lines": {"1": [4, 5, 9, 10, 11, 12], "2": [52, 53, 58, 59], "3": [67, 68]}, "removed_lines": {"1": [4, 5, 6, 10, 11, 12, 13, 14], "2": [54, 59], "3": [67]}}, {"16": "guava/src/com/google/common/io/FileBackedOutputStream.java", "added": {"1": [" * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not use this file except\n", " * in compliance with the License. You may obtain a copy of the License at\n", " * Unless required by applicable law or agreed to in writing, software distributed under the License\n", " * is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express\n", " * or implied. See the License for the specific language governing permissions and limitations under\n", " * the License.\n"], "2": [" * An {@link OutputStream} that starts buffering to a byte array, but switches to file buffering\n", " * once the data reaches a configurable size.\n"], "3": ["  @VisibleForTesting\n", "  synchronized File getFile() {\n", "   * Creates a new instance that uses the given file threshold, and does not reset the data when the\n", "   * {@link ByteSource} returned by {@link #asByteSource} is finalized.\n", "   * @param fileThreshold the number of bytes before the stream should switch to buffering to a file\n", "   * Creates a new instance that uses the given file threshold, and optionally resets the data when\n", "   * the {@link ByteSource} returned by {@link #asByteSource} is finalized.\n", "   * @param fileThreshold the number of bytes before the stream should switch to buffering to a file\n", "   * @param resetOnFinalize if true, the {@link #reset} method will be called when the\n", "   *     {@link ByteSource} returned by {@link #asByteSource} is finalized\n"], "4": ["      source =\n", "          new ByteSource() {\n", "            @Override\n", "            public InputStream openStream() throws IOException {\n", "              return openInputStream();\n", "            }\n", "\n", "            @Override\n", "            protected void finalize() {\n", "              try {\n", "                reset();\n", "              } catch (Throwable t) {\n", "                t.printStackTrace(System.err);\n", "              }\n", "            }\n", "          };\n", "      source =\n", "          new ByteSource() {\n", "            @Override\n", "            public InputStream openStream() throws IOException {\n", "              return openInputStream();\n", "            }\n", "          };\n", "   * Returns a readable {@link ByteSource} view of the data that has been written to this stream.\n"], "5": ["      return new ByteArrayInputStream(memory.getBuffer(), 0, memory.getCount());\n", "   * Calls {@link #close} if not already closed, and then resets this object back to its initial\n", "   * state, for reuse. If data was buffered to a file, it will be deleted.\n"], "6": ["  @Override\n", "  public synchronized void write(int b) throws IOException {\n", "  @Override\n", "  public synchronized void write(byte[] b) throws IOException {\n", "  @Override\n", "  public synchronized void write(byte[] b, int off, int len) throws IOException {\n", "  @Override\n", "  public synchronized void close() throws IOException {\n", "  @Override\n", "  public synchronized void flush() throws IOException {\n", "   * Checks if writing {@code len} bytes would go over threshold, and switches to file buffering if\n", "   * so.\n"]}, "removed": {"1": [" * Licensed under the Apache License, Version 2.0 (the \"License\");\n", " * you may not use this file except in compliance with the License.\n", " * You may obtain a copy of the License at\n", " * Unless required by applicable law or agreed to in writing, software\n", " * distributed under the License is distributed on an \"AS IS\" BASIS,\n", " * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n", " * See the License for the specific language governing permissions and\n", " * limitations under the License.\n"], "2": [" * An {@link OutputStream} that starts buffering to a byte array, but\n", " * switches to file buffering once the data reaches a configurable size.\n"], "3": ["  @VisibleForTesting synchronized File getFile() {\n", "   * Creates a new instance that uses the given file threshold, and does\n", "   * not reset the data when the {@link ByteSource} returned by\n", "   * {@link #asByteSource} is finalized.\n", "   * @param fileThreshold the number of bytes before the stream should\n", "   *     switch to buffering to a file\n", "   * Creates a new instance that uses the given file threshold, and\n", "   * optionally resets the data when the {@link ByteSource} returned\n", "   * by {@link #asByteSource} is finalized.\n", "   * @param fileThreshold the number of bytes before the stream should\n", "   *     switch to buffering to a file\n", "   * @param resetOnFinalize if true, the {@link #reset} method will\n", "   *     be called when the {@link ByteSource} returned by {@link\n", "   *     #asByteSource} is finalized\n"], "4": ["      source = new ByteSource() {\n", "        @Override\n", "        public InputStream openStream() throws IOException {\n", "          return openInputStream();\n", "        }\n", "\n", "        @Override protected void finalize() {\n", "          try {\n", "            reset();\n", "          } catch (Throwable t) {\n", "            t.printStackTrace(System.err);\n", "          }\n", "        }\n", "      };\n", "      source = new ByteSource() {\n", "        @Override\n", "        public InputStream openStream() throws IOException {\n", "          return openInputStream();\n", "        }\n", "      };\n", "   * Returns a readable {@link ByteSource} view of the data that has been\n", "   * written to this stream.\n"], "5": ["      return new ByteArrayInputStream(\n", "          memory.getBuffer(), 0, memory.getCount());\n", "   * Calls {@link #close} if not already closed, and then resets this\n", "   * object back to its initial state, for reuse. If data was buffered\n", "   * to a file, it will be deleted.\n"], "6": ["  @Override public synchronized void write(int b) throws IOException {\n", "  @Override public synchronized void write(byte[] b) throws IOException {\n", "  @Override public synchronized void write(byte[] b, int off, int len)\n", "      throws IOException {\n", "  @Override public synchronized void close() throws IOException {\n", "  @Override public synchronized void flush() throws IOException {\n", "   * Checks if writing {@code len} bytes would go over threshold, and\n", "   * switches to file buffering if so.\n"]}, "added_lines": {"1": [4, 5, 9, 10, 11, 12], "2": [31, 32], "3": [63, 64, 69, 70, 72, 79, 80, 82, 83, 84], "4": [93, 94, 95, 96, 97, 98, 99, 100, 101, 102, 103, 104, 105, 106, 107, 108, 110, 111, 112, 113, 114, 115, 116, 121], "5": [133, 138, 139], "6": [163, 164, 169, 170, 174, 175, 180, 181, 185, 186, 191, 192]}, "removed_lines": {"1": [4, 5, 6, 10, 11, 12, 13, 14], "2": [33, 34], "3": [65, 70, 71, 72, 74, 75, 82, 83, 84, 86, 87, 88, 89, 90], "4": [99, 100, 101, 102, 103, 104, 105, 106, 107, 108, 109, 110, 111, 112, 114, 115, 116, 117, 118, 119, 124, 125], "5": [137, 138, 143, 144, 145], "6": [169, 174, 178, 179, 184, 188, 193, 194]}}, {"17": "guava/src/com/google/common/io/FileWriteMode.java", "added": {"1": [" * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not use this file except\n", " * in compliance with the License. You may obtain a copy of the License at\n", " * Unless required by applicable law or agreed to in writing, software distributed under the License\n", " * is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express\n", " * or implied. See the License for the specific language governing permissions and limitations under\n", " * the License.\n"], "2": [" * Modes for opening a file for writing. The default when mode when none is specified is to truncate\n", " * the file before writing.\n"]}, "removed": {"1": [" * Licensed under the Apache License, Version 2.0 (the \"License\");\n", " * you may not use this file except in compliance with the License.\n", " * You may obtain a copy of the License at\n", " * Unless required by applicable law or agreed to in writing, software\n", " * distributed under the License is distributed on an \"AS IS\" BASIS,\n", " * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n", " * See the License for the specific language governing permissions and\n", " * limitations under the License.\n"], "2": [" * Modes for opening a file for writing. The default when mode when none is specified is to\n", " * truncate the file before writing.\n"]}, "added_lines": {"1": [4, 5, 9, 10, 11, 12], "2": [20, 21]}, "removed_lines": {"1": [4, 5, 6, 10, 11, 12, 13, 14], "2": [22, 23]}}, {"18": "guava/src/com/google/common/io/Files.java", "added": {"1": [" * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not use this file except\n", " * in compliance with the License. You may obtain a copy of the License at\n", " * Unless required by applicable law or agreed to in writing, software distributed under the License\n", " * is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express\n", " * or implied. See the License for the specific language governing permissions and limitations under\n", " * the License.\n"], "3": ["import java.nio.charset.StandardCharsets;\n"], "4": ["   * Returns a buffered reader that reads from a file using the given character set.\n", "   * @param charset the charset used to decode the input stream; see {@link StandardCharsets} for\n", "   *     helpful predefined constants\n", "  public static BufferedReader newReader(File file, Charset charset) throws FileNotFoundException {\n", "    return new BufferedReader(new InputStreamReader(new FileInputStream(file), charset));\n", "   * Returns a buffered writer that writes to a file using the given character set.\n", "   * @param charset the charset used to encode the output stream; see {@link StandardCharsets} for\n", "   *     helpful predefined constants\n", "  public static BufferedWriter newWriter(File file, Charset charset) throws FileNotFoundException {\n", "    return new BufferedWriter(new OutputStreamWriter(new FileOutputStream(file), charset));\n"], "5": ["   * Reads a file of the given expected size from the given input stream, if it will fit into a byte\n", "   * array. This method handles the case where the file size changes between when the size is read\n", "   * and when the contents are read from the stream.\n", "  static byte[] readFile(InputStream in, long expectedSize) throws IOException {\n", "      throw new OutOfMemoryError(\n", "          \"file is too large to fit in a byte array: \" + expectedSize + \" bytes\");\n"], "6": ["   * Returns a new {@link ByteSink} for writing bytes to the given file. The given {@code modes}\n", "   * control how the file is opened for writing. When no mode is provided, the file will be\n", "   * truncated before writing. When the {@link FileWriteMode#APPEND APPEND} mode is provided, writes\n", "   * will append to the end of the file without truncating it.\n"], "7": ["   * Returns a new {@link CharSource} for reading character data from the given file using the given\n", "   * character set.\n"], "8": ["   * Returns a new {@link CharSink} for writing character data to the given file using the given\n", "   * character set. The given {@code modes} control how the file is opened for writing. When no mode\n", "   * is provided, the file will be truncated before writing. When the {@link FileWriteMode#APPEND\n", "   * APPEND} mode is provided, writes will append to the end of the file without truncating it.\n", "  public static CharSink asCharSink(File file, Charset charset, FileWriteMode... modes) {\n"], "9": ["   * @throws IllegalArgumentException if the file is bigger than the largest possible byte array\n", "   *     (2^31 - 1)\n"], "10": ["   * Reads all characters from a file into a {@link String}, using the given character set.\n", "   * @param charset the charset used to decode the input stream; see {@link StandardCharsets} for\n", "   *     helpful predefined constants\n"], "11": ["   * <p><b>Warning:</b> If {@code to} represents an existing file, that file will be overwritten\n", "   * with the contents of {@code from}. If {@code to} and {@code from} refer to the <i>same</i>\n", "   * file, the contents of that file will be deleted.\n"], "12": ["    checkArgument(!from.equals(to), \"Source %s and destination %s must be different\", from, to);\n", "   * Writes a character sequence (such as a string) to a file using the given character set.\n", "   * @param charset the charset used to encode the output stream; see {@link StandardCharsets} for\n", "   *     helpful predefined constants\n", "  public static void write(CharSequence from, File to, Charset charset) throws IOException {\n", "   * Appends a character sequence (such as a string) to a file using the given character set.\n", "   * @param charset the charset used to encode the output stream; see {@link StandardCharsets} for\n", "   *     helpful predefined constants\n", "  public static void append(CharSequence from, File to, Charset charset) throws IOException {\n", "   * Private helper method. Writes a character sequence to a file, optionally appending.\n", "   * @param charset the charset used to encode the output stream; see {@link StandardCharsets} for\n", "   *     helpful predefined constants\n", "  private static void write(CharSequence from, File to, Charset charset, boolean append)\n", "      throws IOException {\n", "   * Copies all characters from a file to an appendable object, using the given character set.\n", "   * @param charset the charset used to decode the input stream; see {@link StandardCharsets} for\n", "   *     helpful predefined constants\n", "  public static void copy(File from, Charset charset, Appendable to) throws IOException {\n"], "13": ["     * Some operating systems may return zero as the length for files denoting system-dependent\n", "     * entities such as devices or pipes, in which case we must fall back on comparing the bytes\n", "     * directly.\n"], "14": ["   * Atomically creates a new directory somewhere beneath the system's temporary directory (as\n", "   * defined by the {@code java.io.tmpdir} system property), and returns its name.\n", "   * <p>Use this method instead of {@link File#createTempFile(String, String)} when you wish to\n", "   * create a directory, not a regular file. A common pitfall is to call {@code createTempFile},\n", "   * delete the file and create a directory in its place, but this leads a race condition which can\n", "   * be exploited to create security vulnerabilities, especially when executable files are to be\n", "   * written into the directory.\n", "   * <p>This method assumes that the temporary volume is writable, has free inodes and free blocks,\n", "   * and that it will not be called thousands of times per second.\n"], "15": ["    throw new IllegalStateException(\n", "        \"Failed to create directory within \"\n", "            + TEMP_DIR_ATTEMPTS\n", "            + \" attempts (tried \"\n", "            + baseName\n", "            + \"0 to \"\n", "            + baseName\n", "            + (TEMP_DIR_ATTEMPTS - 1)\n", "            + ')');\n", "   * Creates an empty file or updates the last updated timestamp on the same as the unix command of\n", "   * the same name.\n", "    if (!file.createNewFile() && !file.setLastModified(System.currentTimeMillis())) {\n", "   * Creates any necessary but nonexistent parent directories of the specified file. Note that if\n", "   * this operation fails it may have succeeded in creating some (but not all) of the necessary\n", "   * parent directories.\n", "   * @throws IOException if an I/O error occurs, or if any necessary but nonexistent parent\n", "   *     directories of the specified file could not be created.\n"], "16": ["       * The given directory is a filesystem root. All zero of its ancestors exist. This doesn't\n", "       * mean that the root itself exists -- consider x:\\ on a Windows machine without such a drive\n", "       * -- or even that the caller can create it, but this method makes no such guarantees even for\n", "       * non-root files.\n"], "17": ["   * Moves a file from one path to another. This method can rename a file and/or move it to a\n", "   * different directory. In either case {@code to} must be the target path for the file itself; not\n", "   * just the new name for the file or the path to the new parent directory.\n"], "18": ["    checkArgument(!from.equals(to), \"Source %s and destination %s must be different\", from, to);\n"], "19": ["   * Reads the first line from a file. The line does not include line-termination characters, but\n", "   * does include other leading and trailing whitespace.\n", "   * @param charset the charset used to decode the input stream; see {@link StandardCharsets} for\n", "   *     helpful predefined constants\n", "  public static String readFirstLine(File file, Charset charset) throws IOException {\n", "   * Reads all of the lines from a file. The lines do not include line-termination characters, but\n", "   * do include other leading and trailing whitespace.\n", "   * <p>This method returns a mutable {@code List}. For an {@code ImmutableList}, use\n", "   * @param charset the charset used to decode the input stream; see {@link StandardCharsets} for\n", "   *     helpful predefined constants\n", "  public static List<String> readLines(File file, Charset charset) throws IOException {\n", "    return readLines(\n", "        file,\n", "        charset,\n", "        new LineProcessor<List<String>>() {\n", "          final List<String> result = Lists.newArrayList();\n", "          @Override\n", "          public boolean processLine(String line) {\n", "            result.add(line);\n", "            return true;\n", "          }\n", "          @Override\n", "          public List<String> getResult() {\n", "            return result;\n", "          }\n", "        });\n", "   * Streams lines from a {@link File}, stopping when our callback returns false, or we have read\n", "   * all of the lines.\n", "   * @param charset the charset used to decode the input stream; see {@link StandardCharsets} for\n", "   *     helpful predefined constants\n", "  public static <T> T readLines(File file, Charset charset, LineProcessor<T> callback)\n", "      throws IOException {\n", "   * <p>(If this seems too complicated, maybe you're looking for {@link #toByteArray}.)\n", "  public static <T> T readBytes(File file, ByteProcessor<T> processor) throws IOException {\n"], "20": ["  public static HashCode hash(File file, HashFunction hashFunction) throws IOException {\n"], "21": ["   * {@link FileChannel#map(java.nio.channels.FileChannel.MapMode, long, long)} using the requested\n", "   * {@link MapMode}.\n"], "22": ["  public static MappedByteBuffer map(File file, MapMode mode) throws IOException {\n"], "23": ["   * {@link FileChannel#map(java.nio.channels.FileChannel.MapMode, long, long)} using the requested\n", "   * {@link MapMode}.\n", "   * <p>If the mode is {@link MapMode#READ_WRITE} and the file does not exist, it will be created\n", "   * with the requested {@code size}. Thus this method is useful for creating memory mapped files\n", "   * which do not yet exist.\n"], "24": ["      RandomAccessFile raf =\n", "          closer.register(new RandomAccessFile(file, mode == MapMode.READ_ONLY ? \"r\" : \"rw\"));\n"], "25": ["  private static MappedByteBuffer map(RandomAccessFile raf, MapMode mode, long size)\n", "      throws IOException {\n"], "26": ["   * Returns the lexically cleaned form of the path name, <i>usually</i> (but not always) equivalent\n", "   * to the original. The following heuristics are used:\n"], "27": ["   * <p>These heuristics do not always match the behavior of the filesystem. In particular, consider\n", "   * the path {@code a/../b}, which {@code simplifyPath} will change to {@code b}. If {@code a} is a\n", "   * symlink to {@code x}, {@code a/../b} may refer to a sibling of {@code x}, rather than the\n", "   * sibling of {@code a} referred to by {@code b}.\n"], "28": ["    Iterable<String> components = Splitter.on('/').omitEmptyStrings().split(pathname);\n"], "29": ["   * Returns the <a href=\"http://en.wikipedia.org/wiki/Filename_extension\">file extension</a> for\n", "   * the given file name, or the empty string if the file has no extension. The result does not\n", "   * include the '{@code .}'.\n"], "30": ["   * way to ensure that a symbolic link to a directory is not followed when traversing the tree. In\n", "   * this case, iterables created by this traverser could contain files that are outside of the\n"], "31": ["  private static final TreeTraverser<File> FILE_TREE_TRAVERSER =\n", "      new TreeTraverser<File>() {\n", "        @Override\n", "        public Iterable<File> children(File file) {\n", "          // check isDirectory() just because it may be faster than listFiles() on a non-directory\n", "          if (file.isDirectory()) {\n", "            File[] files = file.listFiles();\n", "            if (files != null) {\n", "              return Collections.unmodifiableList(Arrays.asList(files));\n", "            }\n", "          }\n", "          return Collections.emptyList();\n", "        }\n", "        @Override\n", "        public String toString() {\n", "          return \"Files.fileTreeTraverser()\";\n", "        }\n", "      };\n"]}, "removed": {"1": [" * Licensed under the Apache License, Version 2.0 (the \"License\");\n", " * you may not use this file except in compliance with the License.\n", " * You may obtain a copy of the License at\n", " * Unless required by applicable law or agreed to in writing, software\n", " * distributed under the License is distributed on an \"AS IS\" BASIS,\n", " * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n", " * See the License for the specific language governing permissions and\n", " * limitations under the License.\n"], "2": ["import com.google.common.base.Charsets;\n"], "4": ["   * Returns a buffered reader that reads from a file using the given\n", "   * character set.\n", "   * @param charset the charset used to decode the input stream; see {@link\n", "   *     Charsets} for helpful predefined constants\n", "  public static BufferedReader newReader(File file, Charset charset)\n", "      throws FileNotFoundException {\n", "    return new BufferedReader(\n", "        new InputStreamReader(new FileInputStream(file), charset));\n", "   * Returns a buffered writer that writes to a file using the given\n", "   * character set.\n", "   * @param charset the charset used to encode the output stream; see {@link\n", "   *     Charsets} for helpful predefined constants\n", "  public static BufferedWriter newWriter(File file, Charset charset)\n", "      throws FileNotFoundException {\n", "    return new BufferedWriter(\n", "        new OutputStreamWriter(new FileOutputStream(file), charset));\n"], "5": ["   * Reads a file of the given expected size from the given input stream, if\n", "   * it will fit into a byte array. This method handles the case where the file\n", "   * size changes between when the size is read and when the contents are read\n", "   * from the stream.\n", "  static byte[] readFile(\n", "      InputStream in, long expectedSize) throws IOException {\n", "      throw new OutOfMemoryError(\"file is too large to fit in a byte array: \"\n", "          + expectedSize + \" bytes\");\n"], "6": ["   * Returns a new {@link ByteSink} for writing bytes to the given file. The\n", "   * given {@code modes} control how the file is opened for writing. When no\n", "   * mode is provided, the file will be truncated before writing. When the\n", "   * {@link FileWriteMode#APPEND APPEND} mode is provided, writes will\n", "   * append to the end of the file without truncating it.\n"], "7": ["   * Returns a new {@link CharSource} for reading character data from the given\n", "   * file using the given character set.\n"], "8": ["   * Returns a new {@link CharSink} for writing character data to the given\n", "   * file using the given character set. The given {@code modes} control how\n", "   * the file is opened for writing. When no mode is provided, the file\n", "   * will be truncated before writing. When the\n", "   * {@link FileWriteMode#APPEND APPEND} mode is provided, writes will\n", "   * append to the end of the file without truncating it.\n", "  public static CharSink asCharSink(File file, Charset charset,\n", "      FileWriteMode... modes) {\n"], "9": ["   * @throws IllegalArgumentException if the file is bigger than the largest\n", "   *     possible byte array (2^31 - 1)\n"], "10": ["   * Reads all characters from a file into a {@link String}, using the given\n", "   * character set.\n", "   * @param charset the charset used to decode the input stream; see {@link\n", "   *     Charsets} for helpful predefined constants\n"], "11": ["   * <p><b>Warning:</b> If {@code to} represents an existing file, that file\n", "   * will be overwritten with the contents of {@code from}. If {@code to} and\n", "   * {@code from} refer to the <i>same</i> file, the contents of that file\n", "   * will be deleted.\n"], "12": ["    checkArgument(!from.equals(to),\n", "        \"Source %s and destination %s must be different\", from, to);\n", "   * Writes a character sequence (such as a string) to a file using the given\n", "   * character set.\n", "   * @param charset the charset used to encode the output stream; see {@link\n", "   *     Charsets} for helpful predefined constants\n", "  public static void write(CharSequence from, File to, Charset charset)\n", "      throws IOException {\n", "   * Appends a character sequence (such as a string) to a file using the given\n", "   * character set.\n", "   * @param charset the charset used to encode the output stream; see {@link\n", "   *     Charsets} for helpful predefined constants\n", "  public static void append(CharSequence from, File to, Charset charset)\n", "      throws IOException {\n", "   * Private helper method. Writes a character sequence to a file,\n", "   * optionally appending.\n", "   * @param charset the charset used to encode the output stream; see {@link\n", "   *     Charsets} for helpful predefined constants\n", "  private static void write(CharSequence from, File to, Charset charset,\n", "      boolean append) throws IOException {\n", "   * Copies all characters from a file to an appendable object,\n", "   * using the given character set.\n", "   * @param charset the charset used to decode the input stream; see {@link\n", "   *     Charsets} for helpful predefined constants\n", "  public static void copy(File from, Charset charset, Appendable to)\n", "      throws IOException {\n"], "13": ["     * Some operating systems may return zero as the length for files\n", "     * denoting system-dependent entities such as devices or pipes, in\n", "     * which case we must fall back on comparing the bytes directly.\n"], "14": ["   * Atomically creates a new directory somewhere beneath the system's\n", "   * temporary directory (as defined by the {@code java.io.tmpdir} system\n", "   * property), and returns its name.\n", "   * <p>Use this method instead of {@link File#createTempFile(String, String)}\n", "   * when you wish to create a directory, not a regular file.  A common pitfall\n", "   * is to call {@code createTempFile}, delete the file and create a\n", "   * directory in its place, but this leads a race condition which can be\n", "   * exploited to create security vulnerabilities, especially when executable\n", "   * files are to be written into the directory.\n", "   * <p>This method assumes that the temporary volume is writable, has free\n", "   * inodes and free blocks, and that it will not be called thousands of times\n", "   * per second.\n"], "15": ["    throw new IllegalStateException(\"Failed to create directory within \"\n", "        + TEMP_DIR_ATTEMPTS + \" attempts (tried \"\n", "        + baseName + \"0 to \" + baseName + (TEMP_DIR_ATTEMPTS - 1) + ')');\n", "   * Creates an empty file or updates the last updated timestamp on the\n", "   * same as the unix command of the same name.\n", "    if (!file.createNewFile()\n", "        && !file.setLastModified(System.currentTimeMillis())) {\n", "   * Creates any necessary but nonexistent parent directories of the specified\n", "   * file. Note that if this operation fails it may have succeeded in creating\n", "   * some (but not all) of the necessary parent directories.\n", "   * @throws IOException if an I/O error occurs, or if any necessary but\n", "   *     nonexistent parent directories of the specified file could not be\n", "   *     created.\n"], "16": ["       * The given directory is a filesystem root. All zero of its ancestors\n", "       * exist. This doesn't mean that the root itself exists -- consider x:\\ on\n", "       * a Windows machine without such a drive -- or even that the caller can\n", "       * create it, but this method makes no such guarantees even for non-root\n", "       * files.\n"], "17": ["   * Moves a file from one path to another. This method can rename a file\n", "   * and/or move it to a different directory. In either case {@code to} must\n", "   * be the target path for the file itself; not just the new name for the\n", "   * file or the path to the new parent directory.\n"], "18": ["    checkArgument(!from.equals(to),\n", "        \"Source %s and destination %s must be different\", from, to);\n"], "19": ["   * Reads the first line from a file. The line does not include\n", "   * line-termination characters, but does include other leading and\n", "   * trailing whitespace.\n", "   * @param charset the charset used to decode the input stream; see {@link\n", "   *     Charsets} for helpful predefined constants\n", "  public static String readFirstLine(File file, Charset charset)\n", "      throws IOException {\n", "   * Reads all of the lines from a file. The lines do not include\n", "   * line-termination characters, but do include other leading and\n", "   * trailing whitespace.\n", "   * <p>This method returns a mutable {@code List}. For an\n", "   * {@code ImmutableList}, use\n", "   * @param charset the charset used to decode the input stream; see {@link\n", "   *     Charsets} for helpful predefined constants\n", "  public static List<String> readLines(File file, Charset charset)\n", "      throws IOException {\n", "    return readLines(file, charset, new LineProcessor<List<String>>() {\n", "      final List<String> result = Lists.newArrayList();\n", "      @Override\n", "      public boolean processLine(String line) {\n", "        result.add(line);\n", "        return true;\n", "      }\n", "      @Override\n", "      public List<String> getResult() {\n", "        return result;\n", "      }\n", "    });\n", "   * Streams lines from a {@link File}, stopping when our callback returns\n", "   * false, or we have read all of the lines.\n", "   * @param charset the charset used to decode the input stream; see {@link\n", "   *     Charsets} for helpful predefined constants\n", "  public static <T> T readLines(File file, Charset charset,\n", "      LineProcessor<T> callback) throws IOException {\n", "   * <p>(If this seems too complicated, maybe you're looking for\n", "   * {@link #toByteArray}.)\n", "  public static <T> T readBytes(File file, ByteProcessor<T> processor)\n", "      throws IOException {\n"], "20": ["  public static HashCode hash(File file, HashFunction hashFunction)\n", "      throws IOException {\n"], "21": ["   * {@link FileChannel#map(java.nio.channels.FileChannel.MapMode, long, long)}\n", "   * using the requested {@link MapMode}.\n"], "22": ["  public static MappedByteBuffer map(File file, MapMode mode)\n", "      throws IOException {\n"], "23": ["   * {@link FileChannel#map(java.nio.channels.FileChannel.MapMode, long, long)}\n", "   * using the requested {@link MapMode}.\n", "   * <p>If the mode is {@link MapMode#READ_WRITE} and the file does not exist,\n", "   * it will be created with the requested {@code size}. Thus this method is\n", "   * useful for creating memory mapped files which do not yet exist.\n"], "24": ["      RandomAccessFile raf = closer.register(\n", "          new RandomAccessFile(file, mode == MapMode.READ_ONLY ? \"r\" : \"rw\"));\n"], "25": ["  private static MappedByteBuffer map(RandomAccessFile raf, MapMode mode,\n", "      long size) throws IOException {\n"], "26": ["   * Returns the lexically cleaned form of the path name, <i>usually</i> (but\n", "   * not always) equivalent to the original. The following heuristics are used:\n"], "27": ["   * <p>These heuristics do not always match the behavior of the filesystem. In\n", "   * particular, consider the path {@code a/../b}, which {@code simplifyPath}\n", "   * will change to {@code b}. If {@code a} is a symlink to {@code x}, {@code\n", "   * a/../b} may refer to a sibling of {@code x}, rather than the sibling of\n", "   * {@code a} referred to by {@code b}.\n"], "28": ["    Iterable<String> components =\n", "        Splitter.on('/').omitEmptyStrings().split(pathname);\n"], "29": ["   * Returns the <a href=\"http://en.wikipedia.org/wiki/Filename_extension\">file\n", "   * extension</a> for the given file name, or the empty string if the file has\n", "   * no extension.  The result does not include the '{@code .}'.\n"], "30": ["   * way to ensure that a symbolic link to a directory is not followed when traversing the tree.\n", "   * In this case, iterables created by this traverser could contain files that are outside of the\n"], "31": ["  private static final TreeTraverser<File> FILE_TREE_TRAVERSER = new TreeTraverser<File>() {\n", "    @Override\n", "    public Iterable<File> children(File file) {\n", "      // check isDirectory() just because it may be faster than listFiles() on a non-directory\n", "      if (file.isDirectory()) {\n", "        File[] files = file.listFiles();\n", "        if (files != null) {\n", "          return Collections.unmodifiableList(Arrays.asList(files));\n", "        }\n", "      }\n", "      return Collections.emptyList();\n", "    }\n", "    @Override\n", "    public String toString() {\n", "      return \"Files.fileTreeTraverser()\";\n", "    }\n", "  };\n"]}, "added_lines": {"1": [4, 5, 9, 10, 11, 12], "3": [49], "4": [74, 77, 78, 81, 84, 88, 91, 92, 95, 98], "5": [160, 161, 162, 164, 166, 167], "6": [178, 179, 180, 181], "7": [211, 212], "8": [221, 222, 223, 224, 228], "9": [243, 244], "10": [252, 255, 256], "11": [289, 290, 291], "12": [299, 304, 308, 309, 312, 317, 321, 322, 325, 330, 334, 335, 339, 340, 345, 348, 349, 353], "13": [370, 371, 372], "14": [383, 384, 386, 387, 388, 389, 390, 392, 393], "15": [408, 409, 410, 411, 412, 413, 414, 415, 416, 420, 421, 428, 434, 435, 436, 438, 439], "16": [447, 448, 449, 450], "17": [461, 462, 463], "18": [473], "19": [487, 488, 491, 492, 496, 501, 502, 504, 508, 509, 513, 516, 517, 518, 519, 520, 522, 523, 524, 525, 526, 528, 529, 530, 531, 532, 536, 537, 540, 541, 546, 547, 554, 561], "20": [574], "21": [601, 602], "22": [617], "23": [628, 629, 633, 634, 635], "24": [654, 655], "25": [664, 665], "26": [678, 679], "27": [690, 691, 692, 693], "28": [704], "29": [741, 742, 743], "30": [775, 776], "31": [785, 786, 787, 788, 789, 790, 791, 792, 793, 794, 795, 797, 798, 800, 801, 802, 803, 804]}, "removed_lines": {"1": [4, 5, 6, 10, 11, 12, 13, 14], "2": [25], "4": [76, 77, 80, 81, 84, 85, 88, 89, 93, 94, 97, 98, 101, 102, 105, 106], "5": [168, 169, 170, 171, 173, 174, 176, 177], "6": [188, 189, 190, 191, 192], "7": [222, 223], "8": [232, 233, 234, 235, 236, 237, 241, 242], "9": [257, 258], "10": [266, 267, 270, 271], "11": [304, 305, 306, 307], "12": [315, 316, 321, 322, 326, 327, 330, 331, 336, 337, 341, 342, 345, 346, 351, 352, 356, 357, 361, 362, 367, 368, 371, 372, 376, 377], "13": [394, 395, 396], "14": [407, 408, 409, 411, 412, 413, 414, 415, 416, 418, 419, 420], "15": [435, 436, 437, 441, 442, 449, 450, 456, 457, 458, 460, 461, 462], "16": [470, 471, 472, 473, 474], "17": [485, 486, 487, 488], "18": [498, 499], "19": [513, 514, 515, 518, 519, 523, 524, 529, 530, 531, 533, 534, 538, 539, 543, 544, 547, 548, 550, 551, 552, 553, 554, 556, 557, 558, 559, 560, 564, 565, 568, 569, 574, 575, 582, 583, 590, 591], "20": [604, 605], "21": [632, 633], "22": [648, 649], "23": [660, 661, 665, 666, 667], "24": [686, 687], "25": [696, 697], "26": [710, 711], "27": [722, 723, 724, 725, 726], "28": [737, 738], "29": [775, 776, 777], "30": [809, 810], "31": [819, 820, 821, 822, 823, 824, 825, 826, 827, 828, 830, 831, 833, 834, 835, 836, 837]}}, {"19": "guava/src/com/google/common/io/Flushables.java", "added": {"1": [" * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not use this file except\n", " * in compliance with the License. You may obtain a copy of the License at\n", " * Unless required by applicable law or agreed to in writing, software distributed under the License\n", " * is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express\n", " * or implied. See the License for the specific language governing permissions and limitations under\n", " * the License.\n"], "2": ["  private static final Logger logger = Logger.getLogger(Flushables.class.getName());\n", "   * Flush a {@link Flushable}, with control over whether an {@code IOException} may be thrown.\n", "   * <p>If {@code swallowIOException} is true, then we don't rethrow {@code IOException}, but merely\n", "   * log it.\n", "   * @param swallowIOException if true, don't propagate IO exceptions thrown by the {@code flush}\n", "   *     method\n", "   * @throws IOException if {@code swallowIOException} is false and {@link Flushable#flush} throws\n", "   *     an {@code IOException}.\n", "  public static void flush(Flushable flushable, boolean swallowIOException) throws IOException {\n", "        logger.log(Level.WARNING, \"IOException thrown while flushing Flushable.\", e);\n"], "3": ["   * Equivalent to calling {@code flush(flushable, true)}, but with no {@code IOException} in the\n", "   * signature.\n"]}, "removed": {"1": [" * Licensed under the Apache License, Version 2.0 (the \"License\");\n", " * you may not use this file except in compliance with the License.\n", " * You may obtain a copy of the License at\n", " * Unless required by applicable law or agreed to in writing, software\n", " * distributed under the License is distributed on an \"AS IS\" BASIS,\n", " * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n", " * See the License for the specific language governing permissions and\n", " * limitations under the License.\n"], "2": ["  private static final Logger logger\n", "      = Logger.getLogger(Flushables.class.getName());\n", "   * Flush a {@link Flushable}, with control over whether an\n", "   * {@code IOException} may be thrown.\n", "   * <p>If {@code swallowIOException} is true, then we don't rethrow\n", "   * {@code IOException}, but merely log it.\n", "   * @param swallowIOException if true, don't propagate IO exceptions\n", "   *     thrown by the {@code flush} method\n", "   * @throws IOException if {@code swallowIOException} is false and\n", "   *     {@link Flushable#flush} throws an {@code IOException}.\n", "  public static void flush(Flushable flushable, boolean swallowIOException)\n", "      throws IOException {\n", "        logger.log(Level.WARNING,\n", "            \"IOException thrown while flushing Flushable.\", e);\n"], "3": ["   * Equivalent to calling {@code flush(flushable, true)}, but with no\n", "   * {@code IOException} in the signature.\n"]}, "added_lines": {"1": [4, 5, 9, 10, 11, 12], "2": [34, 39, 41, 42, 45, 46, 47, 48, 51, 56], "3": [64, 65]}, "removed_lines": {"1": [4, 5, 6, 10, 11, 12, 13, 14], "2": [36, 37, 42, 43, 45, 46, 49, 50, 51, 52, 55, 56, 61, 62], "3": [70, 71]}}, {"20": "guava/src/com/google/common/io/LineBuffer.java", "added": {"1": [" * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not use this file except\n", " * in compliance with the License. You may obtain a copy of the License at\n", " * Unless required by applicable law or agreed to in writing, software distributed under the License\n", " * is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express\n", " * or implied. See the License for the specific language governing permissions and limitations under\n", " * the License.\n"], "2": [" * Package-protected abstract class that implements the line reading algorithm used by\n", " * {@link LineReader}. Line separators are per {@link java.io.BufferedReader}: line feed, carriage\n", " * return, or carriage return followed immediately by a linefeed.\n", " * <p>Subclasses must implement {@link #handleLine}, call {@link #add} to pass character data, and\n", " * call {@link #finish} at the end of stream.\n"], "3": ["   * Process additional characters from the stream. When a line separator is found the contents of\n", "   * the line and the line separator itself are passed to the abstract {@link #handleLine} method.\n"], "4": ["    String separator = sawReturn\n", "        : (sawNewline ? \"\\n\" : \"\");\n", "    handleLine(line.toString(), separator);\n", "   * Subclasses must call this method after finishing character processing, in order to ensure that\n", "   * any unterminated line in the buffer is passed to {@link #handleLine}.\n"], "5": ["   * Called for each line found in the character data passed to {@link #add}.\n", "   * @param end the line separator; one of {@code \"\\r\"}, {@code \"\\n\"}, {@code \"\\r\\n\"}, or {@code \"\"}\n", "  protected abstract void handleLine(String line, String end) throws IOException;\n"]}, "removed": {"1": [" * Licensed under the Apache License, Version 2.0 (the \"License\");\n", " * you may not use this file except in compliance with the License.\n", " * You may obtain a copy of the License at\n", " * Unless required by applicable law or agreed to in writing, software\n", " * distributed under the License is distributed on an \"AS IS\" BASIS,\n", " * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n", " * See the License for the specific language governing permissions and\n", " * limitations under the License.\n"], "2": [" * Package-protected abstract class that implements the line reading\n", " * algorithm used by {@link LineReader}. Line separators are per {@link\n", " * java.io.BufferedReader}: line feed, carriage return, or carriage\n", " * return followed immediately by a linefeed.\n", " * <p>Subclasses must implement {@link #handleLine}, call {@link #add}\n", " * to pass character data, and call {@link #finish} at the end of stream.\n"], "3": ["   * Process additional characters from the stream. When a line separator\n", "   * is found the contents of the line and the line separator itself\n", "   * are passed to the abstract {@link #handleLine} method.\n"], "4": ["    handleLine(line.toString(), sawReturn\n", "        : (sawNewline ? \"\\n\" : \"\"));\n", "   * Subclasses must call this method after finishing character processing,\n", "   * in order to ensure that any unterminated line in the buffer is\n", "   * passed to {@link #handleLine}.\n"], "5": ["   * Called for each line found in the character data passed to\n", "   * {@link #add}.\n", "   * @param end the line separator; one of {@code \"\\r\"}, {@code \"\\n\"},\n", "   *     {@code \"\\r\\n\"}, or {@code \"\"}\n", "  protected abstract void handleLine(String line, String end)\n", "      throws IOException;\n"]}, "added_lines": {"1": [4, 5, 9, 10, 11, 12], "2": [22, 23, 24, 26, 27], "3": [40, 41], "4": [87, 89, 90, 97, 98], "5": [109, 112, 115]}, "removed_lines": {"1": [4, 5, 6, 10, 11, 12, 13, 14], "2": [24, 25, 26, 27, 29, 30], "3": [43, 44, 45], "4": [91, 93, 100, 101, 102], "5": [113, 114, 117, 118, 121, 122]}}, {"21": "guava/src/com/google/common/io/LineProcessor.java", "added": {"1": [" * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not use this file except\n", " * in compliance with the License. You may obtain a copy of the License at\n", " * Unless required by applicable law or agreed to in writing, software distributed under the License\n", " * is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express\n", " * or implied. See the License for the specific language governing permissions and limitations under\n", " * the License.\n"], "2": [" * <p>{@link #processLine} will be called for each line that is read, and should return\n", " * {@code false} when you want to stop processing.\n"]}, "removed": {"1": [" * Licensed under the Apache License, Version 2.0 (the \"License\");\n", " * you may not use this file except in compliance with the License.\n", " * You may obtain a copy of the License at\n", " * Unless required by applicable law or agreed to in writing, software\n", " * distributed under the License is distributed on an \"AS IS\" BASIS,\n", " * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n", " * See the License for the specific language governing permissions and\n", " * limitations under the License.\n"], "2": [" * <p>{@link #processLine} will be called for each line that is read, and\n", " * should return {@code false} when you want to stop processing.\n"]}, "added_lines": {"1": [4, 5, 9, 10, 11, 12], "2": [25, 26]}, "removed_lines": {"1": [4, 5, 6, 10, 11, 12, 13, 14], "2": [27, 28]}}, {"22": "guava/src/com/google/common/io/LineReader.java", "added": {"1": [" * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not use this file except\n", " * in compliance with the License. You may obtain a copy of the License at\n", " * Unless required by applicable law or agreed to in writing, software distributed under the License\n", " * is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express\n", " * or implied. See the License for the specific language governing permissions and limitations under\n", " * the License.\n"], "2": [" * A class for reading lines of text. Provides the same functionality as\n", " * {@link java.io.BufferedReader#readLine()} but for all {@link Readable} objects, not just\n", " * instances of {@link Reader}.\n"], "3": ["  private final LineBuffer lineBuf =\n", "      new LineBuffer() {\n", "        @Override\n", "        protected void handleLine(String line, String end) {\n", "          lines.add(line);\n", "        }\n", "      };\n", "   * Creates a new instance that will read lines from the given {@code Readable} object.\n"], "4": ["   * Reads a line of text. A line is considered to be terminated by any one of a line feed\n", "   * ({@code '\\n'}), a carriage return ({@code '\\r'}), or a carriage return followed immediately by\n", "   * a linefeed ({@code \"\\r\\n\"}).\n", "   * @return a {@code String} containing the contents of the line, not including any\n", "   *     line-termination characters, or {@code null} if the end of the stream has been reached.\n"]}, "removed": {"1": [" * Licensed under the Apache License, Version 2.0 (the \"License\");\n", " * you may not use this file except in compliance with the License.\n", " * You may obtain a copy of the License at\n", " * Unless required by applicable law or agreed to in writing, software\n", " * distributed under the License is distributed on an \"AS IS\" BASIS,\n", " * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n", " * See the License for the specific language governing permissions and\n", " * limitations under the License.\n"], "2": [" * A class for reading lines of text. Provides the same functionality\n", " * as {@link java.io.BufferedReader#readLine()} but for all {@link Readable}\n", " * objects, not just instances of {@link Reader}.\n"], "3": ["  private final LineBuffer lineBuf = new LineBuffer() {\n", "    @Override protected void handleLine(String line, String end) {\n", "      lines.add(line);\n", "    }\n", "  };\n", "   * Creates a new instance that will read lines from the given\n", "   * {@code Readable} object.\n"], "4": ["   * Reads a line of text. A line is considered to be terminated by any\n", "   * one of a line feed ({@code '\\n'}), a carriage return\n", "   * ({@code '\\r'}), or a carriage return followed immediately by a linefeed\n", "   * ({@code \"\\r\\n\"}).\n", "   * @return a {@code String} containing the contents of the line, not\n", "   *     including any line-termination characters, or {@code null} if the\n", "   *     end of the stream has been reached.\n"]}, "added_lines": {"1": [4, 5, 9, 10, 11, 12], "2": [29, 30, 31], "3": [45, 46, 47, 48, 49, 50, 51, 54], "4": [62, 63, 64, 66, 67]}, "removed_lines": {"1": [4, 5, 6, 10, 11, 12, 13, 14], "2": [31, 32, 33], "3": [47, 48, 49, 50, 51, 54, 55], "4": [63, 64, 65, 66, 68, 69, 70]}}, {"23": "guava/src/com/google/common/io/LittleEndianDataInputStream.java", "added": {"1": [" * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not use this file except\n", " * in compliance with the License. You may obtain a copy of the License at\n", " * Unless required by applicable law or agreed to in writing, software distributed under the License\n", " * is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express\n", " * or implied. See the License for the specific language governing permissions and limitations under\n", " * the License.\n"], "2": [" * An implementation of {@link DataInput} that uses little-endian byte ordering for reading\n", " * {@code short}, {@code int}, {@code float}, {@code double}, and {@code long} values. \n", " *\n", " * <p><b>Note:</b> This class intentionally violates the specification of its supertype\n", " * {@code DataInput}, which explicitly requires big-endian byte order.\n"], "3": ["   * Reads an unsigned {@code short} as specified by {@link DataInputStream#readUnsignedShort()},\n", "   * except using little-endian byte order.\n", "   * @return the next two bytes of the input stream, interpreted as an unsigned 16-bit integer in\n", "   *     little-endian byte order\n"], "4": ["   * Reads an integer as specified by {@link DataInputStream#readInt()}, except using little-endian\n", "   * byte order.\n", "   * @return the next four bytes of the input stream, interpreted as an {@code int} in little-endian\n", "   *     byte order\n"], "5": ["    return Ints.fromBytes(b4, b3, b2, b1);\n", "   * Reads a {@code long} as specified by {@link DataInputStream#readLong()}, except using\n", "   * little-endian byte order.\n", "   * @return the next eight bytes of the input stream, interpreted as a {@code long} in\n", "   *     little-endian byte order\n"], "6": ["   * Reads a {@code float} as specified by {@link DataInputStream#readFloat()}, except using\n", "   * little-endian byte order.\n", "   * @return the next four bytes of the input stream, interpreted as a {@code float} in\n", "   *     little-endian byte order\n"], "7": ["   * Reads a {@code double} as specified by {@link DataInputStream#readDouble()}, except using\n", "   * little-endian byte order.\n", "   * @return the next eight bytes of the input stream, interpreted as a {@code double} in\n", "   *     little-endian byte order\n"], "8": ["   * Reads a {@code short} as specified by {@link DataInputStream#readShort()}, except using\n", "   * little-endian byte order.\n", "   * @return the next two bytes of the input stream, interpreted as a {@code short} in little-endian\n", "   *     byte order.\n"], "9": ["   * Reads a char as specified by {@link DataInputStream#readChar()}, except using little-endian\n", "   * byte order.\n", "   * @return the next two bytes of the input stream, interpreted as a {@code char} in little-endian\n", "   *     byte order\n"], "10": ["   * Reads a byte from the input stream checking that the end of file (EOF) has not been\n", "   * encountered.\n"]}, "removed": {"1": [" * Licensed under the Apache License, Version 2.0 (the \"License\");\n", " * you may not use this file except in compliance with the License.\n", " * You may obtain a copy of the License at\n", " * Unless required by applicable law or agreed to in writing, software\n", " * distributed under the License is distributed on an \"AS IS\" BASIS,\n", " * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n", " * See the License for the specific language governing permissions and\n", " * limitations under the License.\n"], "2": [" * An implementation of {@link DataInput} that uses little-endian byte ordering\n", " * for reading {@code short}, {@code int}, {@code float}, {@code double}, and\n", " * {@code long} values.\n", " * <p>\n", " * <b>Note:</b> This class intentionally violates the specification of its\n", " * supertype {@code DataInput}, which explicitly requires big-endian byte order.\n"], "3": ["   * Reads an unsigned {@code short} as specified by\n", "   * {@link DataInputStream#readUnsignedShort()}, except using little-endian\n", "   * byte order.\n", "   * @return the next two bytes of the input stream, interpreted as an \n", "   *         unsigned 16-bit integer in little-endian byte order\n"], "4": ["   * Reads an integer as specified by {@link DataInputStream#readInt()}, except\n", "   * using little-endian byte order.\n", "   * @return the next four bytes of the input stream, interpreted as an \n", "   *         {@code int} in little-endian byte order\n"], "5": ["    return Ints.fromBytes( b4, b3, b2, b1);\n", "   * Reads a {@code long} as specified by {@link DataInputStream#readLong()},\n", "   * except using little-endian byte order.\n", "   * @return the next eight bytes of the input stream, interpreted as a \n", "   *         {@code long} in little-endian byte order\n"], "6": ["   * Reads a {@code float} as specified by {@link DataInputStream#readFloat()},\n", "   * except using little-endian byte order.\n", "   * @return the next four bytes of the input stream, interpreted as a\n", "   *         {@code float} in little-endian byte order\n"], "7": ["   * Reads a {@code double} as specified by\n", "   * {@link DataInputStream#readDouble()}, except using little-endian byte\n", "   * order.\n", "   * @return the next eight bytes of the input stream, interpreted as a\n", "   *         {@code double} in little-endian byte order\n"], "8": ["   * Reads a {@code short} as specified by {@link DataInputStream#readShort()},\n", "   * except using little-endian byte order.\n", "   * @return the next two bytes of the input stream, interpreted as a\n", "   *         {@code short} in little-endian byte order.\n"], "9": ["   * Reads a char as specified by {@link DataInputStream#readChar()}, except\n", "   * using little-endian byte order.\n", "   * @return the next two bytes of the input stream, interpreted as a \n", "   *         {@code char} in little-endian byte order\n"], "10": ["   * Reads a byte from the input stream checking that the end of file (EOF)\n", "   * has not been encountered.\n"]}, "added_lines": {"1": [4, 5, 9, 10, 11, 12], "2": [31, 32, 33, 34, 35], "3": [88, 89, 91, 92], "4": [104, 105, 107, 108], "5": [118, 122, 123, 125, 126], "6": [144, 145, 147, 148], "7": [157, 158, 160, 161], "8": [175, 176, 178, 179], "9": [188, 189, 191, 192], "10": [211, 212]}, "removed_lines": {"1": [4, 5, 6, 10, 11, 12, 13, 14], "2": [33, 34, 35, 36, 37, 38], "3": [91, 92, 93, 95, 96], "4": [108, 109, 111, 112], "5": [122, 126, 127, 129, 130], "6": [148, 149, 151, 152], "7": [161, 162, 163, 165, 166], "8": [180, 181, 183, 184], "9": [193, 194, 196, 197], "10": [216, 217]}}, {"24": "guava/src/com/google/common/io/LittleEndianDataOutputStream.java", "added": {"1": [" * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not use this file except\n", " * in compliance with the License. You may obtain a copy of the License at\n", " * Unless required by applicable law or agreed to in writing, software distributed under the License\n", " * is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express\n", " * or implied. See the License for the specific language governing permissions and limitations under\n", " * the License.\n"], "2": [" * An implementation of {@link DataOutput} that uses little-endian byte ordering for writing\n", " * {@code char}, {@code short}, {@code int}, {@code float}, {@code double}, and {@code long} values.\n", " *\n", " * <p><b>Note:</b> This class intentionally violates the specification of its supertype\n", " * {@code DataOutput}, which explicitly requires big-endian byte order.\n"], "3": ["  @Override\n", "  public void write(byte[] b, int off, int len) throws IOException {\n", "  @Override\n", "  public void writeBoolean(boolean v) throws IOException {\n", "  @Override\n", "  public void writeByte(int v) throws IOException {\n", "   * @deprecated The semantics of {@code writeBytes(String s)} are considered dangerous. Please use\n", "   *     {@link #writeUTF(String s)}, {@link #writeChars(String s)} or another write method instead.\n", "  @Override\n", "  public void writeBytes(String s) throws IOException {\n", "   * Writes a char as specified by {@link DataOutputStream#writeChar(int)}, except using\n", "   * little-endian byte order.\n", "  @Override\n", "  public void writeChar(int v) throws IOException {\n", "   * Writes a {@code String} as specified by {@link DataOutputStream#writeChars(String)}, except\n", "   * each character is written using little-endian byte order.\n", "  @Override\n", "  public void writeChars(String s) throws IOException {\n", "   * Writes a {@code double} as specified by {@link DataOutputStream#writeDouble(double)}, except\n", "   * using little-endian byte order.\n", "  @Override\n", "  public void writeDouble(double v) throws IOException {\n", "   * Writes a {@code float} as specified by {@link DataOutputStream#writeFloat(float)}, except using\n", "   * little-endian byte order.\n", "  @Override\n", "  public void writeFloat(float v) throws IOException {\n", "   * Writes an {@code int} as specified by {@link DataOutputStream#writeInt(int)}, except using\n", "   * little-endian byte order.\n", "  @Override\n", "  public void writeInt(int v) throws IOException {\n"], "4": ["   * Writes a {@code long} as specified by {@link DataOutputStream#writeLong(long)}, except using\n", "   * little-endian byte order.\n", "  @Override\n", "  public void writeLong(long v) throws IOException {\n", "   * Writes a {@code short} as specified by {@link DataOutputStream#writeShort(int)}, except using\n", "   * little-endian byte order.\n", "  @Override\n", "  public void writeShort(int v) throws IOException {\n", "  @Override\n", "  public void writeUTF(String str) throws IOException {\n", "  @Override\n", "  public void close() throws IOException {\n"]}, "removed": {"1": [" * Licensed under the Apache License, Version 2.0 (the \"License\");\n", " * you may not use this file except in compliance with the License.\n", " * You may obtain a copy of the License at\n", " * Unless required by applicable law or agreed to in writing, software\n", " * distributed under the License is distributed on an \"AS IS\" BASIS,\n", " * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n", " * See the License for the specific language governing permissions and\n", " * limitations under the License.\n"], "2": [" * An implementation of {@link DataOutput} that uses little-endian byte ordering\n", " * for writing {@code char}, {@code short}, {@code int}, {@code float}, {@code\n", " * double}, and {@code long} values.\n", " * <p>\n", " * <b>Note:</b> This class intentionally violates the specification of its\n", " * supertype {@code DataOutput}, which explicitly requires big-endian byte\n", " * order.\n"], "3": ["  @Override public void write(byte[] b, int off, int len) throws IOException {\n", "  @Override public void writeBoolean(boolean v) throws IOException {\n", "  @Override public void writeByte(int v) throws IOException {\n", "   * @deprecated The semantics of {@code writeBytes(String s)} are considered\n", "   *             dangerous. Please use {@link #writeUTF(String s)},\n", "   *             {@link #writeChars(String s)} or another write method instead.\n", "  @Override public void writeBytes(String s) throws IOException {\n", "   * Writes a char as specified by {@link DataOutputStream#writeChar(int)},\n", "   * except using little-endian byte order.\n", "  @Override public void writeChar(int v) throws IOException {\n", "   * Writes a {@code String} as specified by\n", "   * {@link DataOutputStream#writeChars(String)}, except each character is\n", "   * written using little-endian byte order.\n", "  @Override public void writeChars(String s) throws IOException {\n", "   * Writes a {@code double} as specified by\n", "   * {@link DataOutputStream#writeDouble(double)}, except using little-endian\n", "   * byte order.\n", "  @Override public void writeDouble(double v) throws IOException {\n", "   * Writes a {@code float} as specified by\n", "   * {@link DataOutputStream#writeFloat(float)}, except using little-endian byte\n", "   * order.\n", "  @Override public void writeFloat(float v) throws IOException {\n", "   * Writes an {@code int} as specified by\n", "   * {@link DataOutputStream#writeInt(int)}, except using little-endian byte\n", "   * order.\n", "  @Override public void writeInt(int v) throws IOException {\n"], "4": ["   * Writes a {@code long} as specified by\n", "   * {@link DataOutputStream#writeLong(long)}, except using little-endian byte\n", "   * order.\n", "  @Override public void writeLong(long v) throws IOException {\n", "   * Writes a {@code short} as specified by\n", "   * {@link DataOutputStream#writeShort(int)}, except using little-endian byte\n", "   * order.\n", "  @Override public void writeShort(int v) throws IOException {\n", "  @Override public void writeUTF(String str) throws IOException {\n", "  @Override public void close() throws IOException {\n"]}, "added_lines": {"1": [4, 5, 9, 10, 11, 12], "2": [29, 30, 31, 32, 33], "3": [52, 53, 58, 59, 63, 64, 69, 70, 73, 74, 79, 80, 84, 85, 90, 91, 95, 96, 103, 104, 108, 109, 114, 115, 119, 120, 125, 126, 130, 131], "4": [139, 140, 144, 145, 151, 152, 156, 157, 162, 163, 170, 171]}, "removed_lines": {"1": [4, 5, 6, 10, 11, 12, 13, 14], "2": [31, 32, 33, 34, 35, 36, 37], "3": [56, 61, 65, 70, 71, 72, 75, 80, 81, 85, 90, 91, 92, 96, 103, 104, 105, 109, 114, 115, 116, 120, 125, 126, 127, 131], "4": [139, 140, 141, 145, 151, 152, 153, 157, 162, 169]}}, {"25": "guava/src/com/google/common/io/MultiInputStream.java", "added": {"1": [" * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not use this file except\n", " * in compliance with the License. You may obtain a copy of the License at\n", " * Unless required by applicable law or agreed to in writing, software distributed under the License\n", " * is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express\n", " * or implied. See the License for the specific language governing permissions and limitations under\n", " * the License.\n"], "2": [" * An {@link InputStream} that concatenates multiple substreams. At most one stream will be open at\n", " * a time.\n"], "3": ["  public MultiInputStream(Iterator<? extends ByteSource> it) throws IOException {\n", "  @Override\n", "  public void close() throws IOException {\n"], "4": ["  @Override\n", "  public int available() throws IOException {\n", "  @Override\n", "  public boolean markSupported() {\n", "  @Override\n", "  public int read() throws IOException {\n"], "5": ["  @Override\n", "  public int read(@Nullable byte[] b, int off, int len) throws IOException {\n"], "6": ["  @Override\n", "  public long skip(long n) throws IOException {\n"]}, "removed": {"1": [" * Licensed under the Apache License, Version 2.0 (the \"License\");\n", " * you may not use this file except in compliance with the License.\n", " * You may obtain a copy of the License at\n", " * Unless required by applicable law or agreed to in writing, software\n", " * distributed under the License is distributed on an \"AS IS\" BASIS,\n", " * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n", " * See the License for the specific language governing permissions and\n", " * limitations under the License.\n"], "2": [" * An {@link InputStream} that concatenates multiple substreams. At most\n", " * one stream will be open at a time.\n"], "3": ["  public MultiInputStream(\n", "      Iterator<? extends ByteSource> it) throws IOException {\n", "  @Override public void close() throws IOException {\n"], "4": ["  @Override public int available() throws IOException {\n", "  @Override public boolean markSupported() {\n", "  @Override public int read() throws IOException {\n"], "5": ["  @Override public int read(@Nullable byte[] b, int off, int len) throws IOException {\n"], "6": ["  @Override public long skip(long n) throws IOException {\n"]}, "added_lines": {"1": [4, 5, 9, 10, 11, 12], "2": [28, 29], "3": [45, 50, 51], "4": [71, 72, 79, 80, 84, 85], "5": [97, 98], "6": [110, 111]}, "removed_lines": {"1": [4, 5, 6, 10, 11, 12, 13, 14], "2": [30, 31], "3": [47, 48, 53], "4": [73, 80, 84], "5": [96], "6": [108]}}, {"26": "guava/src/com/google/common/io/MultiReader.java", "added": {"1": [" * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not use this file except\n", " * in compliance with the License. You may obtain a copy of the License at\n", " * Unless required by applicable law or agreed to in writing, software distributed under the License\n", " * is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express\n", " * or implied. See the License for the specific language governing permissions and limitations under\n", " * the License.\n"], "2": ["  @Override\n", "  public int read(@Nullable char cbuf[], int off, int len) throws IOException {\n"], "3": ["  @Override\n", "  public long skip(long n) throws IOException {\n"], "4": ["  @Override\n", "  public boolean ready() throws IOException {\n", "  @Override\n", "  public void close() throws IOException {\n"]}, "removed": {"1": [" * Licensed under the Apache License, Version 2.0 (the \"License\");\n", " * you may not use this file except in compliance with the License.\n", " * You may obtain a copy of the License at\n", " * Unless required by applicable law or agreed to in writing, software\n", " * distributed under the License is distributed on an \"AS IS\" BASIS,\n", " * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n", " * See the License for the specific language governing permissions and\n", " * limitations under the License.\n"], "2": ["  @Override public int read(@Nullable char cbuf[], int off, int len) throws IOException {\n"], "3": ["  @Override public long skip(long n) throws IOException {\n"], "4": ["  @Override public boolean ready() throws IOException {\n", "  @Override public void close() throws IOException {\n"]}, "added_lines": {"1": [4, 5, 9, 10, 11, 12], "2": [52, 53], "3": [65, 66], "4": [80, 81, 85, 86]}, "removed_lines": {"1": [4, 5, 6, 10, 11, 12, 13, 14], "2": [54], "3": [66], "4": [80, 84]}}, {"27": "guava/src/com/google/common/io/PatternFilenameFilter.java", "added": {"1": [" * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not use this file except\n", " * in compliance with the License. You may obtain a copy of the License at\n", " * Unless required by applicable law or agreed to in writing, software distributed under the License\n", " * is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express\n", " * or implied. See the License for the specific language governing permissions and limitations under\n", " * the License.\n"], "2": [" * File name filter that only accepts files matching a regular expression. This class is thread-safe\n", " * and immutable.\n"], "3": ["   *\n"], "4": ["   *\n", "  @Override\n", "  public boolean accept(@Nullable File dir, String fileName) {\n"]}, "removed": {"1": [" * Licensed under the Apache License, Version 2.0 (the \"License\");\n", " * you may not use this file except in compliance with the License.\n", " * You may obtain a copy of the License at\n", " * Unless required by applicable law or agreed to in writing, software\n", " * distributed under the License is distributed on an \"AS IS\" BASIS,\n", " * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n", " * See the License for the specific language governing permissions and\n", " * limitations under the License.\n"], "2": [" * File name filter that only accepts files matching a regular expression. This\n", " * class is thread-safe and immutable.\n"], "4": ["  @Override public boolean accept(@Nullable File dir, String fileName) {\n"]}, "added_lines": {"1": [4, 5, 9, 10, 11, 12], "2": [29, 30], "3": [43], "4": [54, 61, 62]}, "removed_lines": {"1": [4, 5, 6, 10, 11, 12, 13, 14], "2": [31, 32], "4": [61]}}, {"28": "guava/src/com/google/common/io/ReaderInputStream.java", "added": {"1": [" * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not use this file except\n", " * in compliance with the License. You may obtain a copy of the License at\n", " * Unless required by applicable law or agreed to in writing, software distributed under the License\n", " * is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express\n", " * or implied. See the License for the specific language governing permissions and limitations under\n", " * the License.\n"], "2": ["    this(\n", "        reader,\n", "        charset\n", "            .newEncoder()\n"], "3": ["  @Override\n", "  public void close() throws IOException {\n", "  @Override\n", "  public int read() throws IOException {\n", "  @Override\n", "  public int read(byte[] b, int off, int len) throws IOException {\n"], "4": ["    DRAINING:\n", "    while (true) {\n", "      // We stay in draining mode until there are no bytes left in the output buffer. Then we go\n"], "5": ["   * Flips the buffer output buffer so we can start reading bytes from it. If we are starting to\n"]}, "removed": {"1": [" * Licensed under the Apache License, Version 2.0 (the \"License\");\n", " * you may not use this file except in compliance with the License.\n", " * You may obtain a copy of the License at\n", " * Unless required by applicable law or agreed to in writing, software\n", " * distributed under the License is distributed on an \"AS IS\" BASIS,\n", " * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n", " * See the License for the specific language governing permissions and\n", " * limitations under the License.\n"], "2": ["    this(reader,\n", "        charset.newEncoder()\n"], "3": ["  @Override public void close() throws IOException {\n", "  @Override public int read() throws IOException {\n", "  @Override public int read(byte[] b, int off, int len) throws IOException {\n"], "4": ["    DRAINING: while (true) {\n", "      // We stay in draining mode until there are no bytes left in the output buffer.  Then we go\n"], "5": ["   * Flips the buffer output buffer so we can start reading bytes from it.  If we are starting to\n"]}, "added_lines": {"1": [4, 5, 9, 10, 11, 12], "2": [83, 84, 85, 86], "3": [113, 114, 118, 119, 125, 126], "4": [137, 138, 139], "5": [234]}, "removed_lines": {"1": [4, 5, 6, 10, 11, 12, 13, 14], "2": [85, 86], "3": [113, 117, 123], "4": [134, 135], "5": [230]}}, {"29": "guava/src/com/google/common/io/Resources.java", "added": {"1": [" * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not use this file except\n", " * in compliance with the License. You may obtain a copy of the License at\n", " * Unless required by applicable law or agreed to in writing, software distributed under the License\n", " * is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express\n", " * or implied. See the License for the specific language governing permissions and limitations under\n", " * the License.\n"], "2": [" * Provides utility methods for working with resources in the classpath. Note that even though these\n", " * methods use {@link URL} parameters, they are usually not appropriate for HTTP or other\n", " * non-classpath resources.\n"], "3": ["   * Returns a {@link CharSource} that reads from the given URL using the given character set.\n"], "4": ["   * Reads all characters from a URL into a {@link String}, using the given character set.\n", "   * @param charset the charset used to decode the input stream; see {@link Charsets} for helpful\n", "   *     predefined constants\n"], "5": ["   * Streams lines from a URL, stopping when our callback returns false, or we have read all of the\n", "   * lines.\n", "   * @param charset the charset used to decode the input stream; see {@link Charsets} for helpful\n", "   *     predefined constants\n", "  public static <T> T readLines(URL url, Charset charset, LineProcessor<T> callback)\n", "      throws IOException {\n", "   * Reads all of the lines from a URL. The lines do not include line-termination characters, but do\n", "   * include other leading and trailing whitespace.\n", "   * <p>This method returns a mutable {@code List}. For an {@code ImmutableList}, use\n", "   * @param charset the charset used to decode the input stream; see {@link Charsets} for helpful\n", "   *     predefined constants\n", "  public static List<String> readLines(URL url, Charset charset) throws IOException {\n", "    return readLines(\n", "        url,\n", "        charset,\n", "        new LineProcessor<List<String>>() {\n", "          final List<String> result = Lists.newArrayList();\n", "\n", "          @Override\n", "          public boolean processLine(String line) {\n", "            result.add(line);\n", "            return true;\n", "          }\n", "\n", "          @Override\n", "          public List<String> getResult() {\n", "            return result;\n", "          }\n", "        });\n"], "6": ["   * Returns a {@code URL} pointing to {@code resourceName} if the resource is found using the\n", "   * {@linkplain Thread#getContextClassLoader() context class loader}. In simple environments, the\n", "   * context class loader will find resources from the class path. In environments where different\n", "   * threads can have different class loaders, for example app servers, the context class loader\n", "   * will typically have been set to an appropriate loader for the current thread.\n", "   * <p>In the unusual case where the context class loader is null, the class loader that loaded\n", "   * this class ({@code Resources}) will be used instead.\n", "    ClassLoader loader =\n", "        MoreObjects.firstNonNull(\n", "            Thread.currentThread().getContextClassLoader(), Resources.class.getClassLoader());\n", "   * Given a {@code resourceName} that is relative to {@code contextClass}, returns a {@code URL}\n", "   * pointing to the named resource.\n", "    checkArgument(\n", "        url != null, \"resource %s relative to %s not found.\", resourceName, contextClass.getName());\n"]}, "removed": {"1": [" * Licensed under the Apache License, Version 2.0 (the \"License\");\n", " * you may not use this file except in compliance with the License.\n", " * You may obtain a copy of the License at\n", " * Unless required by applicable law or agreed to in writing, software\n", " * distributed under the License is distributed on an \"AS IS\" BASIS,\n", " * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n", " * See the License for the specific language governing permissions and\n", " * limitations under the License.\n"], "2": [" * Provides utility methods for working with resources in the classpath.\n", " * Note that even though these methods use {@link URL} parameters, they\n", " * are usually not appropriate for HTTP or other non-classpath resources.\n"], "3": ["   * Returns a {@link CharSource} that reads from the given URL using the given\n", "   * character set.\n"], "4": ["   * Reads all characters from a URL into a {@link String}, using the given\n", "   * character set.\n", "   * @param charset the charset used to decode the input stream; see {@link\n", "   *     Charsets} for helpful predefined constants\n"], "5": ["   * Streams lines from a URL, stopping when our callback returns false, or we\n", "   * have read all of the lines.\n", "   * @param charset the charset used to decode the input stream; see {@link\n", "   *     Charsets} for helpful predefined constants\n", "  public static <T> T readLines(URL url, Charset charset,\n", "      LineProcessor<T> callback) throws IOException {\n", "   * Reads all of the lines from a URL. The lines do not include\n", "   * line-termination characters, but do include other leading and trailing\n", "   * whitespace.\n", "   * <p>This method returns a mutable {@code List}. For an\n", "   * {@code ImmutableList}, use\n", "   * @param charset the charset used to decode the input stream; see {@link\n", "   *     Charsets} for helpful predefined constants\n", "  public static List<String> readLines(URL url, Charset charset)\n", "      throws IOException {\n", "    return readLines(url, charset, new LineProcessor<List<String>>() {\n", "      final List<String> result = Lists.newArrayList();\n", "\n", "      @Override\n", "      public boolean processLine(String line) {\n", "        result.add(line);\n", "        return true;\n", "      }\n", "\n", "      @Override\n", "      public List<String> getResult() {\n", "        return result;\n", "      }\n", "    });\n"], "6": ["   * Returns a {@code URL} pointing to {@code resourceName} if the resource is\n", "   * found using the {@linkplain Thread#getContextClassLoader() context class\n", "   * loader}. In simple environments, the context class loader will find\n", "   * resources from the class path. In environments where different threads can\n", "   * have different class loaders, for example app servers, the context class\n", "   * loader will typically have been set to an appropriate loader for the\n", "   * current thread.\n", "   * <p>In the unusual case where the context class loader is null, the class\n", "   * loader that loaded this class ({@code Resources}) will be used instead.\n", "    ClassLoader loader = MoreObjects.firstNonNull(\n", "        Thread.currentThread().getContextClassLoader(),\n", "        Resources.class.getClassLoader());\n", "   * Given a {@code resourceName} that is relative to {@code contextClass},\n", "   * returns a {@code URL} pointing to the named resource.\n", "    checkArgument(url != null, \"resource %s relative to %s not found.\",\n", "        resourceName, contextClass.getName());\n"]}, "added_lines": {"1": [4, 5, 9, 10, 11, 12], "2": [34, 35, 36], "3": [82], "4": [102, 105, 106], "5": [115, 116, 119, 120, 125, 126, 131, 132, 134, 138, 139, 143, 146, 147, 148, 149, 150, 151, 152, 153, 154, 155, 156, 157, 158, 159, 160, 161, 162], "6": [177, 178, 179, 180, 181, 183, 184, 189, 190, 191, 198, 199, 205, 206]}, "removed_lines": {"1": [4, 5, 6, 10, 11, 12, 13, 14], "2": [36, 37, 38], "3": [84, 85], "4": [105, 106, 109, 110], "5": [119, 120, 123, 124, 129, 130, 135, 136, 137, 139, 140, 144, 145, 149, 150, 153, 154, 155, 156, 157, 158, 159, 160, 161, 162, 163, 164, 165, 166], "6": [181, 182, 183, 184, 185, 186, 187, 189, 190, 195, 196, 197, 204, 205, 211, 212]}}, {"30": "guava/src/com/google/common/io/package-info.java", "added": {"1": [" * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not use this file except\n", " * in compliance with the License. You may obtain a copy of the License at\n", " * Unless required by applicable law or agreed to in writing, software distributed under the License\n", " * is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express\n", " * or implied. See the License for the specific language governing permissions and limitations under\n", " * the License.\n", " * This package contains utility methods and classes for working with Java I/O; for example input\n", " * streams, output streams, readers, writers, and files.\n", " * <p>At the core of this package are the Source/Sink types: {@link com.google.common.io.ByteSource\n", " * ByteSource}, {@link com.google.common.io.CharSource CharSource},\n", " * {@link com.google.common.io.CharSink CharSink}. They are factories for I/O streams that provide\n", " * many convenience methods that handle both opening and closing streams for you.\n", " * <p>This package is a part of the open-source <a href=\"http://github.com/google/guava\">Guava</a>\n", " * library. For more information on Sources and Sinks as well as other features of this package, see\n", " * <a href=\"https://github.com/google/guava/wiki/IOExplained\">I/O Explained</a> on the Guava wiki.\n"]}, "removed": {"1": [" * Licensed under the Apache License, Version 2.0 (the \"License\");\n", " * you may not use this file except in compliance with the License.\n", " * You may obtain a copy of the License at\n", " * Unless required by applicable law or agreed to in writing, software\n", " * distributed under the License is distributed on an \"AS IS\" BASIS,\n", " * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n", " * See the License for the specific language governing permissions and\n", " * limitations under the License.\n", " * This package contains utility methods and classes for working with Java I/O;\n", " * for example input streams, output streams, readers, writers, and files.\n", " * <p>At the core of this package are the Source/Sink types:\n", " * {@link com.google.common.io.ByteSource ByteSource},\n", " * {@link com.google.common.io.CharSource CharSource},\n", " * {@link com.google.common.io.CharSink CharSink}. They are factories for I/O streams that\n", " * provide many convenience methods that handle both opening and closing streams for you.\n", " * <p>This package is a part of the open-source\n", " * <a href=\"http://github.com/google/guava\">Guava</a> library. For more information on\n", " * Sources and Sinks as well as other features of this package, see\n", " * <a href=\"https://github.com/google/guava/wiki/IOExplained\">I/O Explained</a> on the\n", " * Guava wiki.\n"]}, "added_lines": {"1": [4, 5, 9, 10, 11, 12, 16, 17, 19, 20, 22, 23, 25, 26, 27]}, "removed_lines": {"1": [4, 5, 6, 10, 11, 12, 13, 14, 18, 19, 21, 22, 23, 25, 26, 28, 29, 30, 31, 32]}}]}
