{
    "addition": {
        "4": " * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not use this file except\n",
        "5": " * in compliance with the License. You may obtain a copy of the License at\n",
        "9": " * Unless required by applicable law or agreed to in writing, software distributed under the License\n",
        "10": " * is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express\n",
        "11": " * or implied. See the License for the specific language governing permissions and limitations under\n",
        "12": " * the License.\n",
        "64": "   * There are three methods to implement\n",
        "65": "   * {@link FileChannel#transferTo(long, long, WritableByteChannel)}:\n",
        "68": "   * <li>Use sendfile(2) or equivalent. Requires that both the input channel and the output channel\n",
        "69": "   *     have their own file descriptors. Generally this only happens when both channels are files\n",
        "70": "   *     or sockets. This performs zero copies - the bytes never enter userspace.\n",
        "71": "   * <li>Use mmap(2) or equivalent. Requires that either the input channel or the output channel\n",
        "72": "   *     have file descriptors. Bytes are copied from the file into a kernel buffer, then directly\n",
        "73": "   *     into the other buffer (userspace). Note that if the file is very large, a naive\n",
        "74": "   *     implementation will effectively put the whole file in memory. On many systems with paging\n",
        "75": "   *     and virtual memory, this is not a problem - because it is mapped read-only, the kernel can\n",
        "76": "   *     always page it to disk \"for free\". However, on systems where killing processes happens all\n",
        "77": "   *     the time in normal conditions (i.e., android) the OS must make a tradeoff between paging\n",
        "78": "   *     memory and killing other processes - so allocating a gigantic buffer and then sequentially\n",
        "79": "   *     accessing it could result in other processes dying. This is solvable via madvise(2), but\n",
        "80": "   *     that obviously doesn't exist in java.\n",
        "81": "   * <li>Ordinary copy. Kernel copies bytes into a kernel buffer, from a kernel buffer into a\n",
        "82": "   *     userspace buffer (byte[] or ByteBuffer), then copies them from that buffer into the\n",
        "83": "   *     destination channel.\n",
        "95": "   * Copies all bytes from the input stream to the output stream. Does not close or flush either\n",
        "96": "   * stream.\n",
        "103": "  public static long copy(InputStream from, OutputStream to) throws IOException {\n",
        "120": "   * Copies all bytes from the readable channel to the writable channel. Does not close or flush\n",
        "121": "   * either channel.\n",
        "128": "  public static long copy(ReadableByteChannel from, WritableByteChannel to) throws IOException {\n",
        "157": "   * Reads all bytes from an input stream into a byte array. Does not close the stream.\n",
        "173": "   * Reads all bytes from an input stream into a byte array. The given expected size is used to\n",
        "174": "   * create an initial byte array, but if the actual number of bytes read from the stream differs,\n",
        "175": "   * the correct result will be returned anyway.\n",
        "177": "  static byte[] toByteArray(InputStream in, int expectedSize) throws IOException {\n",
        "212": "  private static final class FastByteArrayOutputStream extends ByteArrayOutputStream {\n",
        "214": "     * Writes the contents of the internal buffer to the given array starting at the given offset.\n",
        "215": "     * Assumes the array has space to hold count bytes.\n",
        "223": "   * Returns a new {@link ByteArrayDataInput} instance to read from the {@code bytes} array from the\n",
        "224": "   * beginning.\n",
        "231": "   * Returns a new {@link ByteArrayDataInput} instance to read from the {@code bytes} array,\n",
        "232": "   * starting at the given position.\n",
        "234": "   * @throws IndexOutOfBoundsException if {@code start} is negative or greater than the length of\n",
        "235": "   *     the array\n",
        "239": "    return newDataInput(new ByteArrayInputStream(bytes, start, bytes.length - start));\n",
        "244": "   * {@code ByteArrayInputStream}. The given input stream is not reset before being read from by the\n",
        "245": "   * returned {@code ByteArrayDataInput}.\n",
        "249": "  public static ByteArrayDataInput newDataInput(ByteArrayInputStream byteArrayInputStream) {\n",
        "260": "    @Override\n",
        "261": "    public void readFully(byte b[]) {\n",
        "269": "    @Override\n",
        "270": "    public void readFully(byte b[], int off, int len) {\n",
        "278": "    @Override\n",
        "279": "    public int skipBytes(int n) {\n",
        "287": "    @Override\n",
        "288": "    public boolean readBoolean() {\n",
        "296": "    @Override\n",
        "297": "    public byte readByte() {\n",
        "307": "    @Override\n",
        "308": "    public int readUnsignedByte() {\n",
        "316": "    @Override\n",
        "317": "    public short readShort() {\n",
        "325": "    @Override\n",
        "326": "    public int readUnsignedShort() {\n",
        "334": "    @Override\n",
        "335": "    public char readChar() {\n",
        "343": "    @Override\n",
        "344": "    public int readInt() {\n",
        "352": "    @Override\n",
        "353": "    public long readLong() {\n",
        "361": "    @Override\n",
        "362": "    public float readFloat() {\n",
        "370": "    @Override\n",
        "371": "    public double readDouble() {\n",
        "379": "    @Override\n",
        "380": "    public String readLine() {\n",
        "388": "    @Override\n",
        "389": "    public String readUTF() {\n",
        "406": "   * Returns a new {@link ByteArrayDataOutput} instance sized to hold {@code size} bytes before\n",
        "407": "   * resizing.\n",
        "421": "   * Returns a new {@link ByteArrayDataOutput} instance which writes to the given\n",
        "422": "   * {@code ByteArrayOutputStream}. The given output stream is not reset before being written to by\n",
        "423": "   * the returned {@code ByteArrayDataOutput} and new data will be appended to any existing content.\n",
        "425": "   * <p>Note that if the given output stream was not empty or is modified after the\n",
        "426": "   * {@code ByteArrayDataOutput} is created, the contract for\n",
        "427": "   * {@link ByteArrayDataOutput#toByteArray} will not be honored (the bytes returned in the byte\n",
        "428": "   * array may not be exactly what was written via calls to {@code ByteArrayDataOutput}).\n",
        "432": "  public static ByteArrayDataOutput newDataOutput(ByteArrayOutputStream byteArrayOutputSteam) {\n",
        "437": "  private static class ByteArrayDataOutputStream implements ByteArrayDataOutput {\n",
        "447": "    @Override\n",
        "448": "    public void write(int b) {\n",
        "456": "    @Override\n",
        "457": "    public void write(byte[] b) {\n",
        "465": "    @Override\n",
        "466": "    public void write(byte[] b, int off, int len) {\n",
        "474": "    @Override\n",
        "475": "    public void writeBoolean(boolean v) {\n",
        "483": "    @Override\n",
        "484": "    public void writeByte(int v) {\n",
        "492": "    @Override\n",
        "493": "    public void writeBytes(String s) {\n",
        "501": "    @Override\n",
        "502": "    public void writeChar(int v) {\n",
        "510": "    @Override\n",
        "511": "    public void writeChars(String s) {\n",
        "519": "    @Override\n",
        "520": "    public void writeDouble(double v) {\n",
        "528": "    @Override\n",
        "529": "    public void writeFloat(float v) {\n",
        "537": "    @Override\n",
        "538": "    public void writeInt(int v) {\n",
        "546": "    @Override\n",
        "547": "    public void writeLong(long v) {\n",
        "555": "    @Override\n",
        "556": "    public void writeShort(int v) {\n",
        "564": "    @Override\n",
        "565": "    public void writeUTF(String s) {\n",
        "573": "    @Override\n",
        "574": "    public byte[] toByteArray() {\n",
        "582": "        @Override\n",
        "583": "        public void write(int b) {}\n",
        "584": "\n",
        "586": "        @Override\n",
        "587": "        public void write(byte[] b) {\n",
        "590": "\n",
        "592": "        @Override\n",
        "593": "        public void write(byte[] b, int off, int len) {\n",
        "613": "   * Wraps a {@link InputStream}, limiting the number of bytes which can be read.\n",
        "636": "    @Override\n",
        "637": "    public int available() throws IOException {\n",
        "642": "    @Override\n",
        "643": "    public synchronized void mark(int readLimit) {\n",
        "648": "    @Override\n",
        "649": "    public int read() throws IOException {\n",
        "661": "    @Override\n",
        "662": "    public int read(byte[] b, int off, int len) throws IOException {\n",
        "675": "    @Override\n",
        "676": "    public synchronized void reset() throws IOException {\n",
        "688": "    @Override\n",
        "689": "    public long skip(long n) throws IOException {\n",
        "698": "   * Attempts to read enough bytes from the stream to fill the given byte array, with the same\n",
        "699": "   * behavior as {@link DataInput#readFully(byte[])}. Does not close the stream.\n",
        "703": "   * @throws EOFException if this stream reaches the end before reading all the bytes.\n",
        "711": "   * Attempts to read {@code len} bytes from the stream into the given array starting at\n",
        "712": "   * {@code off}, with the same behavior as {@link DataInput#readFully(byte[], int, int)}. Does not\n",
        "713": "   * close the stream.\n",
        "719": "   * @throws EOFException if this stream reaches the end before reading all the bytes.\n",
        "722": "  public static void readFully(InputStream in, byte[] b, int off, int len) throws IOException {\n",
        "725": "      throw new EOFException(\n",
        "726": "          \"reached end of stream after reading \" + read + \" bytes; \" + len + \" bytes expected\");\n",
        "731": "   * Discards {@code n} bytes of data from the input stream. This method will block until the full\n",
        "732": "   * amount has been skipped. Does not close the stream.\n",
        "736": "   * @throws EOFException if this stream reaches the end before skipping all the bytes\n",
        "737": "   * @throws IOException if an I/O error occurs, or the stream does not support skipping\n",
        "742": "      throw new EOFException(\n",
        "743": "          \"reached end of stream after skipping \" + skipped + \" bytes; \" + n + \" bytes expected\");\n",
        "748": "   * Discards up to {@code n} bytes of data from the input stream. This method will block until\n",
        "749": "   * either the full amount has been skipped or until the end of the stream is reached, whichever\n",
        "750": "   * happens first. Returns the total number of bytes skipped.\n",
        "779": "   * than actually remain in the file, something that it {@linkplain FileInputStream#skip(long)\n",
        "780": "   * specifies} it can do in its Javadoc despite the fact that it is violating the contract of\n",
        "781": "   * {@code InputStream.skip()}.\n",
        "797": "  public static <T> T readBytes(InputStream input, ByteProcessor<T> processor) throws IOException {\n",
        "810": "   * Reads some bytes from an input stream and stores them into the buffer array {@code b}. This\n",
        "811": "   * method blocks until {@code len} bytes of input data have been read into the array, or end of\n",
        "812": "   * file is detected. The number of bytes read is returned, possibly zero. Does not close the\n",
        "813": "   * stream.\n",
        "815": "   * <p>A caller can detect EOF if the number of bytes read is less than {@code len}. All subsequent\n",
        "816": "   * calls on the same stream will return zero.\n",
        "818": "   * <p>If {@code b} is null, a {@code NullPointerException} is thrown. If {@code off} is negative,\n",
        "819": "   * or {@code len} is negative, or {@code off+len} is greater than the length of the array\n",
        "820": "   * {@code b}, then an {@code IndexOutOfBoundsException} is thrown. If {@code len} is zero, then no\n",
        "821": "   * bytes are read. Otherwise, the first byte read is stored into element {@code b[off]}, the next\n",
        "822": "   * one into {@code b[off+1]}, and so on. The number of bytes read is, at most, equal to\n",
        "823": "   * {@code len}.\n",
        "832": "  public static int read(InputStream in, byte[] b, int off, int len) throws IOException {\n"
    },
    "removed": {
        "4": " * Licensed under the Apache License, Version 2.0 (the \"License\");\n",
        "5": " * you may not use this file except in compliance with the License.\n",
        "6": " * You may obtain a copy of the License at\n",
        "10": " * Unless required by applicable law or agreed to in writing, software\n",
        "11": " * distributed under the License is distributed on an \"AS IS\" BASIS,\n",
        "12": " * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n",
        "13": " * See the License for the specific language governing permissions and\n",
        "14": " * limitations under the License.\n",
        "66": "   * There are three methods to implement {@link FileChannel#transferTo(long, long,\n",
        "67": "   *  WritableByteChannel)}:\n",
        "70": "   * <li> Use sendfile(2) or equivalent. Requires that both the input channel and the output channel\n",
        "71": "   *    have their own file descriptors. Generally this only happens when both channels are files or\n",
        "72": "   *    sockets. This performs zero copies - the bytes never enter userspace.</li>\n",
        "73": "   * <li> Use mmap(2) or equivalent. Requires that either the input channel or the output channel\n",
        "74": "   *    have file descriptors. Bytes are copied from the file into a kernel buffer, then directly\n",
        "75": "   *    into the other buffer (userspace). Note that if the file is very large, a naive\n",
        "76": "   *    implementation will effectively put the whole file in memory. On many systems with paging\n",
        "77": "   *    and virtual memory, this is not a problem - because it is mapped read-only, the kernel can\n",
        "78": "   *    always page it to disk \"for free\". However, on systems where killing processes happens all\n",
        "79": "   *    the time in normal conditions (i.e., android) the OS must make a tradeoff between paging\n",
        "80": "   *    memory and killing other processes - so allocating a gigantic buffer and then sequentially\n",
        "81": "   *    accessing it could result in other processes dying. This is solvable via madvise(2), but\n",
        "82": "   *    that obviously doesn't exist in java.</li>\n",
        "83": "   * <li> Ordinary copy. Kernel copies bytes into a kernel buffer, from a kernel buffer into a\n",
        "84": "   *    userspace buffer (byte[] or ByteBuffer), then copies them from that buffer into the\n",
        "85": "   *    destination channel.</li>\n",
        "97": "   * Copies all bytes from the input stream to the output stream.\n",
        "98": "   * Does not close or flush either stream.\n",
        "105": "  public static long copy(InputStream from, OutputStream to)\n",
        "106": "      throws IOException {\n",
        "123": "   * Copies all bytes from the readable channel to the writable channel.\n",
        "124": "   * Does not close or flush either channel.\n",
        "131": "  public static long copy(ReadableByteChannel from,\n",
        "132": "      WritableByteChannel to) throws IOException {\n",
        "161": "   * Reads all bytes from an input stream into a byte array.\n",
        "162": "   * Does not close the stream.\n",
        "178": "   * Reads all bytes from an input stream into a byte array. The given\n",
        "179": "   * expected size is used to create an initial byte array, but if the actual\n",
        "180": "   * number of bytes read from the stream differs, the correct result will be\n",
        "181": "   * returned anyway.\n",
        "183": "  static byte[] toByteArray(\n",
        "184": "      InputStream in, int expectedSize) throws IOException {\n",
        "219": "  private static final class FastByteArrayOutputStream\n",
        "220": "      extends ByteArrayOutputStream {\n",
        "222": "     * Writes the contents of the internal buffer to the given array starting\n",
        "223": "     * at the given offset. Assumes the array has space to hold count bytes.\n",
        "231": "   * Returns a new {@link ByteArrayDataInput} instance to read from the {@code\n",
        "232": "   * bytes} array from the beginning.\n",
        "239": "   * Returns a new {@link ByteArrayDataInput} instance to read from the {@code\n",
        "240": "   * bytes} array, starting at the given position.\n",
        "242": "   * @throws IndexOutOfBoundsException if {@code start} is negative or greater\n",
        "243": "   *     than the length of the array\n",
        "247": "    return newDataInput(\n",
        "248": "        new ByteArrayInputStream(bytes, start, bytes.length - start));\n",
        "253": "   * {@code ByteArrayInputStream}. The given input stream is not reset before\n",
        "254": "   * being read from by the returned {@code ByteArrayDataInput}.\n",
        "258": "  public static ByteArrayDataInput newDataInput(\n",
        "259": "      ByteArrayInputStream byteArrayInputStream) {\n",
        "270": "    @Override public void readFully(byte b[]) {\n",
        "278": "    @Override public void readFully(byte b[], int off, int len) {\n",
        "286": "    @Override public int skipBytes(int n) {\n",
        "294": "    @Override public boolean readBoolean() {\n",
        "302": "    @Override public byte readByte() {\n",
        "312": "    @Override public int readUnsignedByte() {\n",
        "320": "    @Override public short readShort() {\n",
        "328": "    @Override public int readUnsignedShort() {\n",
        "336": "    @Override public char readChar() {\n",
        "344": "    @Override public int readInt() {\n",
        "352": "    @Override public long readLong() {\n",
        "360": "    @Override public float readFloat() {\n",
        "368": "    @Override public double readDouble() {\n",
        "376": "    @Override public String readLine() {\n",
        "384": "    @Override public String readUTF() {\n",
        "401": "   * Returns a new {@link ByteArrayDataOutput} instance sized to hold\n",
        "402": "   * {@code size} bytes before resizing.\n",
        "416": "   * Returns a new {@link ByteArrayDataOutput} instance which writes to the\n",
        "417": "   * given {@code ByteArrayOutputStream}. The given output stream is not reset\n",
        "418": "   * before being written to by the returned {@code ByteArrayDataOutput} and\n",
        "419": "   * new data will be appended to any existing content.\n",
        "421": "   * <p>Note that if the given output stream was not empty or is modified after\n",
        "422": "   * the {@code ByteArrayDataOutput} is created, the contract for\n",
        "423": "   * {@link ByteArrayDataOutput#toByteArray} will not be honored (the bytes\n",
        "424": "   * returned in the byte array may not be exactly what was written via calls to\n",
        "425": "   * {@code ByteArrayDataOutput}).\n",
        "429": "  public static ByteArrayDataOutput newDataOutput(\n",
        "430": "      ByteArrayOutputStream byteArrayOutputSteam) {\n",
        "435": "  private static class ByteArrayDataOutputStream\n",
        "436": "      implements ByteArrayDataOutput {\n",
        "446": "    @Override public void write(int b) {\n",
        "454": "    @Override public void write(byte[] b) {\n",
        "462": "    @Override public void write(byte[] b, int off, int len) {\n",
        "470": "    @Override public void writeBoolean(boolean v) {\n",
        "478": "    @Override public void writeByte(int v) {\n",
        "486": "    @Override public void writeBytes(String s) {\n",
        "494": "    @Override public void writeChar(int v) {\n",
        "502": "    @Override public void writeChars(String s) {\n",
        "510": "    @Override public void writeDouble(double v) {\n",
        "518": "    @Override public void writeFloat(float v) {\n",
        "526": "    @Override public void writeInt(int v) {\n",
        "534": "    @Override public void writeLong(long v) {\n",
        "542": "    @Override public void writeShort(int v) {\n",
        "550": "    @Override public void writeUTF(String s) {\n",
        "558": "    @Override public byte[] toByteArray() {\n",
        "566": "        @Override public void write(int b) {\n",
        "567": "        }\n",
        "569": "        @Override public void write(byte[] b) {\n",
        "573": "        @Override public void write(byte[] b, int off, int len) {\n",
        "593": "   * Wraps a {@link InputStream}, limiting the number of bytes which can be\n",
        "594": "   * read.\n",
        "617": "    @Override public int available() throws IOException {\n",
        "622": "    @Override public synchronized void mark(int readLimit) {\n",
        "627": "    @Override public int read() throws IOException {\n",
        "639": "    @Override public int read(byte[] b, int off, int len) throws IOException {\n",
        "652": "    @Override public synchronized void reset() throws IOException {\n",
        "664": "    @Override public long skip(long n) throws IOException {\n",
        "673": "   * Attempts to read enough bytes from the stream to fill the given byte array,\n",
        "674": "   * with the same behavior as {@link DataInput#readFully(byte[])}.\n",
        "675": "   * Does not close the stream.\n",
        "679": "   * @throws EOFException if this stream reaches the end before reading all\n",
        "680": "   *     the bytes.\n",
        "688": "   * Attempts to read {@code len} bytes from the stream into the given array\n",
        "689": "   * starting at {@code off}, with the same behavior as\n",
        "690": "   * {@link DataInput#readFully(byte[], int, int)}. Does not close the\n",
        "691": "   * stream.\n",
        "697": "   * @throws EOFException if this stream reaches the end before reading all\n",
        "698": "   *     the bytes.\n",
        "701": "  public static void readFully(\n",
        "702": "      InputStream in, byte[] b, int off, int len) throws IOException {\n",
        "705": "      throw new EOFException(\"reached end of stream after reading \"\n",
        "706": "          + read + \" bytes; \" + len + \" bytes expected\");\n",
        "711": "   * Discards {@code n} bytes of data from the input stream. This method\n",
        "712": "   * will block until the full amount has been skipped. Does not close the\n",
        "713": "   * stream.\n",
        "717": "   * @throws EOFException if this stream reaches the end before skipping all\n",
        "718": "   *     the bytes\n",
        "719": "   * @throws IOException if an I/O error occurs, or the stream does not\n",
        "720": "   *     support skipping\n",
        "725": "      throw new EOFException(\"reached end of stream after skipping \"\n",
        "726": "          + skipped + \" bytes; \" + n + \" bytes expected\");\n",
        "731": "   * Discards up to {@code n} bytes of data from the input stream. This method\n",
        "732": "   * will block until either the full amount has been skipped or until the end\n",
        "733": "   * of the stream is reached, whichever happens first. Returns the total number\n",
        "734": "   * of bytes skipped.\n",
        "763": "   * than actually remain in the file, something that it\n",
        "764": "   * {@linkplain FileInputStream#skip(long) specifies} it can do in its Javadoc despite the fact\n",
        "765": "   * that it is violating the contract of {@code InputStream.skip()}.\n",
        "781": "  public static <T> T readBytes(\n",
        "782": "      InputStream input, ByteProcessor<T> processor) throws IOException {\n",
        "795": "   * Reads some bytes from an input stream and stores them into the buffer array\n",
        "796": "   * {@code b}. This method blocks until {@code len} bytes of input data have\n",
        "797": "   * been read into the array, or end of file is detected. The number of bytes\n",
        "798": "   * read is returned, possibly zero. Does not close the stream.\n",
        "800": "   * <p>A caller can detect EOF if the number of bytes read is less than\n",
        "801": "   * {@code len}. All subsequent calls on the same stream will return zero.\n",
        "803": "   * <p>If {@code b} is null, a {@code NullPointerException} is thrown. If\n",
        "804": "   * {@code off} is negative, or {@code len} is negative, or {@code off+len} is\n",
        "805": "   * greater than the length of the array {@code b}, then an\n",
        "806": "   * {@code IndexOutOfBoundsException} is thrown. If {@code len} is zero, then\n",
        "807": "   * no bytes are read. Otherwise, the first byte read is stored into element\n",
        "808": "   * {@code b[off]}, the next one into {@code b[off+1]}, and so on. The number\n",
        "809": "   * of bytes read is, at most, equal to {@code len}.\n",
        "818": "  public static int read(InputStream in, byte[] b, int off, int len)\n",
        "819": "      throws IOException {\n"
    }
}