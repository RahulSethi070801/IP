{"id": "73e382fa877f80994817a136b0adcc4365ccd904", "code": [{"0": "guava-gwt/src-super/com/google/common/collect/super/com/google/common/collect/ImmutableBiMap.java", "added": {"1": ["import com.google.common.annotations.Beta;\n", "import java.util.function.Function;\n", "import java.util.stream.Collector;\n"], "2": ["  @Beta\n", "  public static <T, K, V> Collector<T, ?, ImmutableBiMap<K, V>> toImmutableBiMap(\n", "      Function<? super T, ? extends K> keyFunction,\n", "      Function<? super T, ? extends V> valueFunction) {\n", "    return CollectCollectors.toImmutableBiMap(keyFunction, valueFunction);\n", "  }\n"], "3": ["    Builder<K, V> combine(Builder<K, V> other) {\n", "      super.combine(other);\n", "      return this;\n", "    }\n", "\n"]}, "removed": {}, "added_lines": {"1": [21, 25, 26], "2": [35, 36, 37, 38, 39, 40], "3": [113, 114, 115, 116, 117]}, "removed_lines": {}}, {"1": "guava-gwt/src-super/com/google/common/collect/super/com/google/common/collect/ImmutableCollection.java", "added": {"1": ["import java.util.Spliterator;\n"], "2": ["  static final int SPLITERATOR_CHARACTERISTICS =\n", "      Spliterator.IMMUTABLE | Spliterator.NONNULL | Spliterator.ORDERED;\n"]}, "removed": {}, "added_lines": {"1": [26], "2": [37, 38]}, "removed_lines": {}}, {"2": "guava-gwt/src-super/com/google/common/collect/super/com/google/common/collect/ImmutableList.java", "added": {"1": ["import com.google.common.annotations.Beta;\n"], "2": ["import java.util.stream.Collector;\n"], "3": ["  @Beta\n", "  public static <E> Collector<E, ?, ImmutableList<E>> toImmutableList() {\n", "    return CollectCollectors.toImmutableList();\n", "  }\n", "\n"], "4": ["    @CanIgnoreReturnValue\n", "    Builder<E> combine(Builder<E> builder) {\n", "      checkNotNull(builder);\n", "      contents.addAll(builder.contents);\n", "      return this;\n", "    }\n", "\n"]}, "removed": {"1": ["import com.google.common.collect.Lists;\n"]}, "added_lines": {"1": [22], "2": [32], "3": [48, 49, 50, 51, 52], "4": [337, 338, 339, 340, 341, 342, 343]}, "removed_lines": {"1": [22]}}, {"3": "guava-gwt/src-super/com/google/common/collect/super/com/google/common/collect/ImmutableMap.java", "added": {"1": ["import com.google.common.annotations.Beta;\n", "\n", "import java.util.LinkedHashMap;\n", "import java.util.Spliterator;\n", "import java.util.function.BinaryOperator;\n", "import java.util.function.Function;\n", "import java.util.stream.Collector;\n", "import java.util.stream.Collectors;\n", "\n"], "2": ["  @Beta\n", "  public static <T, K, V> Collector<T, ?, ImmutableMap<K, V>> toImmutableMap(\n", "      Function<? super T, ? extends K> keyFunction,\n", "      Function<? super T, ? extends V> valueFunction) {\n", "    return CollectCollectors.toImmutableMap(keyFunction, valueFunction);\n", "  }\n", "  \n", "  @Beta\n", "  public static <T, K, V> Collector<T, ?, ImmutableMap<K, V>> toImmutableMap(\n", "      Function<? super T, ? extends K> keyFunction,\n", "      Function<? super T, ? extends V> valueFunction,\n", "      BinaryOperator<V> mergeFunction) {\n", "    checkNotNull(keyFunction);\n", "    checkNotNull(valueFunction);\n", "    checkNotNull(mergeFunction);\n", "    return Collectors.collectingAndThen(\n", "        Collectors.toMap(keyFunction, valueFunction, mergeFunction, LinkedHashMap::new),\n", "        ImmutableMap::copyOf);\n", "  }\n", "\n"], "3": ["    Builder<K, V> combine(Builder<K, V> other) {\n", "      checkNotNull(other);\n", "      entries.addAll(other.entries);\n", "      return this;\n", "    }\n", "\n"], "4": ["  Spliterator<K> keySpliterator() {\n", "    return CollectSpliterators.map(entrySet().spliterator(), Entry::getKey);\n", "  }\n", "\n"]}, "removed": {}, "added_lines": {"1": [24, 25, 32, 36, 37, 38, 39, 40, 41], "2": [76, 77, 78, 79, 80, 81, 82, 83, 84, 85, 86, 87, 88, 89, 90, 91, 92, 93, 94, 95], "3": [184, 185, 186, 187, 188, 189], "4": [333, 334, 335, 336]}, "removed_lines": {}}, {"4": "guava-gwt/src-super/com/google/common/collect/super/com/google/common/collect/ImmutableSet.java", "added": {"1": ["import com.google.common.annotations.Beta;\n", "import java.util.stream.Collector;\n"], "2": ["  @Beta\n", "  public static <E> Collector<E, ?, ImmutableSet<E>> toImmutableSet() {\n", "    return CollectCollectors.toImmutableSet();\n", "  }\n", "\n"], "3": ["    Builder<E> combine(Builder<E> builder) {\n", "      contents.addAll(builder.contents);\n", "      return this;\n", "    }\n", "\n"]}, "removed": {}, "added_lines": {"1": [21, 28], "2": [44, 45, 46, 47, 48], "3": [243, 244, 245, 246, 247]}, "removed_lines": {}}, {"5": "guava-gwt/src-super/com/google/common/collect/super/com/google/common/collect/ImmutableSortedMap.java", "added": {"1": ["import com.google.common.annotations.Beta;\n", "import java.util.TreeMap;\n", "import java.util.function.BinaryOperator;\n", "import java.util.function.Function;\n", "import java.util.stream.Collector;\n", "import java.util.stream.Collectors;\n"], "2": ["  @Beta\n", "  public static <T, K, V> Collector<T, ?, ImmutableSortedMap<K, V>> toImmutableSortedMap(\n", "      Comparator<? super K> comparator,\n", "      Function<? super T, ? extends K> keyFunction,\n", "      Function<? super T, ? extends V> valueFunction) {\n", "    return CollectCollectors.toImmutableSortedMap(comparator, keyFunction, valueFunction);\n", "  }\n", "\n", "  @Beta\n", "  public static <T, K, V> Collector<T, ?, ImmutableSortedMap<K, V>> toImmutableSortedMap(\n", "      Comparator<? super K> comparator,\n", "      Function<? super T, ? extends K> keyFunction,\n", "      Function<? super T, ? extends V> valueFunction,\n", "      BinaryOperator<V> mergeFunction) {\n", "    checkNotNull(comparator);\n", "    checkNotNull(keyFunction);\n", "    checkNotNull(valueFunction);\n", "    checkNotNull(mergeFunction);\n", "    return Collectors.collectingAndThen(\n", "        Collectors.toMap(\n", "            keyFunction, valueFunction, mergeFunction, () -> new TreeMap<K, V>(comparator)),\n", "        ImmutableSortedMap::copyOfSorted);\n", "  }\n", "\n"], "3": ["    Builder<K, V> combine(Builder<K, V> other) {\n", "      super.combine(other);\n", "      return this;\n", "    }\n", "\n"]}, "removed": {"1": ["import com.google.common.collect.ImmutableSortedMap.Builder;\n"]}, "added_lines": {"1": [25, 30, 31, 32, 33, 34], "2": [70, 71, 72, 73, 74, 75, 76, 77, 78, 79, 80, 81, 82, 83, 84, 85, 86, 87, 88, 89, 90, 91, 92, 93], "3": [242, 243, 244, 245, 246]}, "removed_lines": {"1": [25]}}, {"6": "guava-gwt/src-super/com/google/common/collect/super/com/google/common/collect/ImmutableSortedSet.java", "added": {"1": ["import com.google.common.annotations.Beta;\n"], "2": ["import java.util.stream.Collector;\n"], "3": ["  @Beta\n", "  public static <E> Collector<E, ?, ImmutableSortedSet<E>> toImmutableSortedSet(\n", "      Comparator<? super E> comparator) {\n", "    return CollectCollectors.toImmutableSortedSet(comparator);\n", "  }\n", "\n"], "4": ["    Builder<E> combine(Builder<E> builder) {\n", "      super.combine(builder);\n", "      return this;\n", "    }\n", "\n"]}, "removed": {}, "added_lines": {"1": [22], "2": [31], "3": [71, 72, 73, 74, 75, 76], "4": [428, 429, 430, 431, 432]}, "removed_lines": {}}, {"7": "guava-gwt/test/com/google/common/base/OptionalTest_gwt.java", "added": {"1": ["public void testFromJavaUtil() throws Exception {\n", "  com.google.common.base.OptionalTest testCase = new com.google.common.base.OptionalTest();\n", "  testCase.testFromJavaUtil();\n", "}\n", "\n"], "2": ["public void testToJavaUtil() throws Exception {\n", "  com.google.common.base.OptionalTest testCase = new com.google.common.base.OptionalTest();\n", "  testCase.testToJavaUtil();\n", "}\n", "\n"]}, "removed": {}, "added_lines": {"1": [56, 57, 58, 59, 60], "2": [196, 197, 198, 199, 200]}, "removed_lines": {}}, {"8": "guava-gwt/test/com/google/common/collect/CollectSpliteratorsTest_gwt.java", "added": {"1": ["/*\n", " * Copyright (C) 2008 The Guava Authors\n", " *\n", " * Licensed under the Apache License, Version 2.0 (the \"License\");\n", " * you may not use this file except in compliance with the License.\n", " * You may obtain a copy of the License at\n", " *\n", " * http://www.apache.org/licenses/LICENSE-2.0\n", " *\n", " * Unless required by applicable law or agreed to in writing, software\n", " * distributed under the License is distributed on an \"AS IS\" BASIS,\n", " * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n", " * See the License for the specific language governing permissions and\n", " * limitations under the License.\n", " */\n", "package com.google.common.collect;\n", "public class CollectSpliteratorsTest_gwt extends com.google.gwt.junit.client.GWTTestCase {\n", "@Override public String getModuleName() {\n", "  return \"com.google.common.collect.testModule\";\n", "}\n", "public void testFlatMap() throws Exception {\n", "  com.google.common.collect.CollectSpliteratorsTest testCase = new com.google.common.collect.CollectSpliteratorsTest();\n", "  testCase.testFlatMap();\n", "}\n", "\n", "public void testMap() throws Exception {\n", "  com.google.common.collect.CollectSpliteratorsTest testCase = new com.google.common.collect.CollectSpliteratorsTest();\n", "  testCase.testMap();\n", "}\n", "\n", "public void testMultisetsSpliterator() throws Exception {\n", "  com.google.common.collect.CollectSpliteratorsTest testCase = new com.google.common.collect.CollectSpliteratorsTest();\n", "  testCase.testMultisetsSpliterator();\n", "}\n", "}\n"]}, "removed": {}, "added_lines": {"1": [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35]}, "removed_lines": {}}, {"9": "guava-gwt/test/com/google/common/collect/ImmutableBiMapTest_gwt.java", "added": {"1": ["public void testToImmutableBiMap__CreationTests() throws Exception {\n", "  com.google.common.collect.ImmutableBiMapTest.CreationTests testCase = new com.google.common.collect.ImmutableBiMapTest.CreationTests();\n", "  testCase.testToImmutableBiMap();\n", "}\n", "\n", "public void testToImmutableBiMap_exceptionOnDuplicateKey__CreationTests() throws Exception {\n", "  com.google.common.collect.ImmutableBiMapTest.CreationTests testCase = new com.google.common.collect.ImmutableBiMapTest.CreationTests();\n", "  testCase.testToImmutableBiMap_exceptionOnDuplicateKey();\n", "}\n", "\n"]}, "removed": {}, "added_lines": {"1": [171, 172, 173, 174, 175, 176, 177, 178, 179, 180]}, "removed_lines": {}}, {"10": "guava-gwt/test/com/google/common/collect/ImmutableListMultimapTest_gwt.java", "added": {"1": ["\n", "public void testToImmutableListMultimap() throws Exception {\n", "  com.google.common.collect.ImmutableListMultimapTest testCase = new com.google.common.collect.ImmutableListMultimapTest();\n", "  testCase.testToImmutableListMultimap();\n", "}\n"]}, "removed": {}, "added_lines": {"1": [165, 166, 167, 168, 169]}, "removed_lines": {}}, {"11": "guava-gwt/test/com/google/common/collect/ImmutableListTest_gwt.java", "added": {"1": ["\n", "public void testToImmutableList__CreationTests() throws Exception {\n", "  com.google.common.collect.ImmutableListTest.CreationTests testCase = new com.google.common.collect.ImmutableListTest.CreationTests();\n", "  testCase.testToImmutableList();\n", "}\n"]}, "removed": {}, "added_lines": {"1": [285, 286, 287, 288, 289]}, "removed_lines": {}}, {"12": "guava-gwt/test/com/google/common/collect/ImmutableMapTest_gwt.java", "added": {"1": ["public void testToImmutableMap__CreationTests() throws Exception {\n", "  com.google.common.collect.ImmutableMapTest.CreationTests testCase = new com.google.common.collect.ImmutableMapTest.CreationTests();\n", "  testCase.testToImmutableMap();\n", "}\n", "\n", "public void testToImmutableMapMerging__CreationTests() throws Exception {\n", "  com.google.common.collect.ImmutableMapTest.CreationTests testCase = new com.google.common.collect.ImmutableMapTest.CreationTests();\n", "  testCase.testToImmutableMapMerging();\n", "}\n", "\n", "public void testToImmutableMap_exceptionOnDuplicateKey__CreationTests() throws Exception {\n", "  com.google.common.collect.ImmutableMapTest.CreationTests testCase = new com.google.common.collect.ImmutableMapTest.CreationTests();\n", "  testCase.testToImmutableMap_exceptionOnDuplicateKey();\n", "}\n", "\n"]}, "removed": {}, "added_lines": {"1": [191, 192, 193, 194, 195, 196, 197, 198, 199, 200, 201, 202, 203, 204, 205]}, "removed_lines": {}}, {"13": "guava-gwt/test/com/google/common/collect/ImmutableMultisetTest_gwt.java", "added": {"1": ["\n", "public void testToImmutableMultiset() throws Exception {\n", "  com.google.common.collect.ImmutableMultisetTest testCase = new com.google.common.collect.ImmutableMultisetTest();\n", "  testCase.testToImmutableMultiset();\n", "}\n", "\n", "public void testToImmutableMultiset_duplicates() throws Exception {\n", "  com.google.common.collect.ImmutableMultisetTest testCase = new com.google.common.collect.ImmutableMultisetTest();\n", "  testCase.testToImmutableMultiset_duplicates();\n", "}\n"]}, "removed": {}, "added_lines": {"1": [245, 246, 247, 248, 249, 250, 251, 252, 253, 254]}, "removed_lines": {}}, {"14": "guava-gwt/test/com/google/common/collect/ImmutableSetMultimapTest_gwt.java", "added": {"1": ["\n", "public void testToImmutableSetMultimap() throws Exception {\n", "  com.google.common.collect.ImmutableSetMultimapTest testCase = new com.google.common.collect.ImmutableSetMultimapTest();\n", "  testCase.testToImmutableSetMultimap();\n", "}\n"]}, "removed": {}, "added_lines": {"1": [165, 166, 167, 168, 169]}, "removed_lines": {}}, {"15": "guava-gwt/test/com/google/common/collect/ImmutableSetTest_gwt.java", "added": {"1": ["public void testToImmutableSet() throws Exception {\n", "  com.google.common.collect.ImmutableSetTest testCase = new com.google.common.collect.ImmutableSetTest();\n", "  testCase.testToImmutableSet();\n", "}\n", "\n", "public void testToImmutableSet_duplicates() throws Exception {\n", "  com.google.common.collect.ImmutableSetTest testCase = new com.google.common.collect.ImmutableSetTest();\n", "  testCase.testToImmutableSet_duplicates();\n", "}\n", "\n"]}, "removed": {}, "added_lines": {"1": [241, 242, 243, 244, 245, 246, 247, 248, 249, 250]}, "removed_lines": {}}, {"16": "guava-gwt/test/com/google/common/collect/ImmutableSortedMapTest_gwt.java", "added": {"1": ["public void testToImmutableSortedMap__CreationTests() throws Exception {\n", "  com.google.common.collect.ImmutableSortedMapTest.CreationTests testCase = new com.google.common.collect.ImmutableSortedMapTest.CreationTests();\n", "  testCase.testToImmutableSortedMap();\n", "}\n", "\n", "public void testToImmutableSortedMapMerging__CreationTests() throws Exception {\n", "  com.google.common.collect.ImmutableSortedMapTest.CreationTests testCase = new com.google.common.collect.ImmutableSortedMapTest.CreationTests();\n", "  testCase.testToImmutableSortedMapMerging();\n", "}\n", "\n", "public void testToImmutableSortedMap_exceptionOnDuplicateKey__CreationTests() throws Exception {\n", "  com.google.common.collect.ImmutableSortedMapTest.CreationTests testCase = new com.google.common.collect.ImmutableSortedMapTest.CreationTests();\n", "  testCase.testToImmutableSortedMap_exceptionOnDuplicateKey();\n", "}\n", "\n"]}, "removed": {}, "added_lines": {"1": [231, 232, 233, 234, 235, 236, 237, 238, 239, 240, 241, 242, 243, 244, 245]}, "removed_lines": {}}, {"17": "guava-gwt/test/com/google/common/collect/ImmutableSortedSetTest_gwt.java", "added": {"1": ["public void testToImmutableSortedSet() throws Exception {\n", "  com.google.common.collect.ImmutableSortedSetTest testCase = new com.google.common.collect.ImmutableSortedSetTest();\n", "  testCase.testToImmutableSortedSet();\n", "}\n", "\n", "public void testToImmutableSortedSet_customComparator() throws Exception {\n", "  com.google.common.collect.ImmutableSortedSetTest testCase = new com.google.common.collect.ImmutableSortedSetTest();\n", "  testCase.testToImmutableSortedSet_customComparator();\n", "}\n", "\n", "public void testToImmutableSortedSet_duplicates() throws Exception {\n", "  com.google.common.collect.ImmutableSortedSetTest testCase = new com.google.common.collect.ImmutableSortedSetTest();\n", "  testCase.testToImmutableSortedSet_duplicates();\n", "}\n", "\n"]}, "removed": {}, "added_lines": {"1": [621, 622, 623, 624, 625, 626, 627, 628, 629, 630, 631, 632, 633, 634, 635]}, "removed_lines": {}}, {"18": "guava-gwt/test/com/google/common/collect/ImmutableTableTest_gwt.java", "added": {"1": ["public void testToImmutableTable() throws Exception {\n", "  com.google.common.collect.ImmutableTableTest testCase = new com.google.common.collect.ImmutableTableTest();\n", "  testCase.setUp();\n", "  testCase.testToImmutableTable();\n", "}\n", "\n"]}, "removed": {}, "added_lines": {"1": [261, 262, 263, 264, 265, 266]}, "removed_lines": {}}, {"19": "guava-gwt/test/com/google/common/collect/LinkedHashMultimapTest_gwt.java", "added": {"1": ["public void testEntriesSpliterator() throws Exception {\n", "  com.google.common.collect.LinkedHashMultimapTest testCase = new com.google.common.collect.LinkedHashMultimapTest();\n", "  testCase.testEntriesSpliterator();\n", "}\n", "\n", "public void testKeysSpliterator() throws Exception {\n", "  com.google.common.collect.LinkedHashMultimapTest testCase = new com.google.common.collect.LinkedHashMultimapTest();\n", "  testCase.testKeysSpliterator();\n", "}\n", "\n"], "2": ["\n", "public void testValuesSpliterator() throws Exception {\n", "  com.google.common.collect.LinkedHashMultimapTest testCase = new com.google.common.collect.LinkedHashMultimapTest();\n", "  testCase.testValuesSpliterator();\n", "}\n"]}, "removed": {}, "added_lines": {"1": [41, 42, 43, 44, 45, 46, 47, 48, 49, 50], "2": [95, 96, 97, 98, 99]}, "removed_lines": {}}, {"20": "guava-gwt/test/com/google/common/collect/MoreCollectorsTest_gwt.java", "added": {"1": ["/*\n", " * Copyright (C) 2008 The Guava Authors\n", " *\n", " * Licensed under the Apache License, Version 2.0 (the \"License\");\n", " * you may not use this file except in compliance with the License.\n", " * You may obtain a copy of the License at\n", " *\n", " * http://www.apache.org/licenses/LICENSE-2.0\n", " *\n", " * Unless required by applicable law or agreed to in writing, software\n", " * distributed under the License is distributed on an \"AS IS\" BASIS,\n", " * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n", " * See the License for the specific language governing permissions and\n", " * limitations under the License.\n", " */\n", "package com.google.common.collect;\n", "public class MoreCollectorsTest_gwt extends com.google.gwt.junit.client.GWTTestCase {\n", "@Override public String getModuleName() {\n", "  return \"com.google.common.collect.testModule\";\n", "}\n", "public void testOnlyElement() throws Exception {\n", "  com.google.common.collect.MoreCollectorsTest testCase = new com.google.common.collect.MoreCollectorsTest();\n", "  testCase.testOnlyElement();\n", "}\n", "\n", "public void testOnlyElementMany() throws Exception {\n", "  com.google.common.collect.MoreCollectorsTest testCase = new com.google.common.collect.MoreCollectorsTest();\n", "  testCase.testOnlyElementMany();\n", "}\n", "\n", "public void testOnlyElementMultiple() throws Exception {\n", "  com.google.common.collect.MoreCollectorsTest testCase = new com.google.common.collect.MoreCollectorsTest();\n", "  testCase.testOnlyElementMultiple();\n", "}\n", "\n", "public void testOnlyElementNull() throws Exception {\n", "  com.google.common.collect.MoreCollectorsTest testCase = new com.google.common.collect.MoreCollectorsTest();\n", "  testCase.testOnlyElementNull();\n", "}\n", "\n", "public void testOnlyElementSingleton() throws Exception {\n", "  com.google.common.collect.MoreCollectorsTest testCase = new com.google.common.collect.MoreCollectorsTest();\n", "  testCase.testOnlyElementSingleton();\n", "}\n", "\n", "public void testToOptionalEmpty() throws Exception {\n", "  com.google.common.collect.MoreCollectorsTest testCase = new com.google.common.collect.MoreCollectorsTest();\n", "  testCase.testToOptionalEmpty();\n", "}\n", "\n", "public void testToOptionalMany() throws Exception {\n", "  com.google.common.collect.MoreCollectorsTest testCase = new com.google.common.collect.MoreCollectorsTest();\n", "  testCase.testToOptionalMany();\n", "}\n", "\n", "public void testToOptionalMultiple() throws Exception {\n", "  com.google.common.collect.MoreCollectorsTest testCase = new com.google.common.collect.MoreCollectorsTest();\n", "  testCase.testToOptionalMultiple();\n", "}\n", "\n", "public void testToOptionalNull() throws Exception {\n", "  com.google.common.collect.MoreCollectorsTest testCase = new com.google.common.collect.MoreCollectorsTest();\n", "  testCase.testToOptionalNull();\n", "}\n", "\n", "public void testToOptionalSingleton() throws Exception {\n", "  com.google.common.collect.MoreCollectorsTest testCase = new com.google.common.collect.MoreCollectorsTest();\n", "  testCase.testToOptionalSingleton();\n", "}\n", "}\n"]}, "removed": {}, "added_lines": {"1": [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 58, 59, 60, 61, 62, 63, 64, 65, 66, 67, 68, 69, 70]}, "removed_lines": {}}, {"21": "guava-gwt/test/com/google/common/collect/testing/Testing.gwt.xml", "added": {"1": ["<?xml version=\"1.0\" encoding=\"utf-8\"?>\n", "   \n", "  <source path=\"\">\n", "     \n", "    <!-- Hack to keep collect from hiding collect.testing supersource: -->\n", "     \n", "    <exclude name=\"**/testing/**\"/>\n", "     \n", "  </source>\n", "    \n", "  <!-- We used to set this only for packages that had manual supersource. That worked everywhere that I know of except for one place: when running the GWT util.concurrent tests under Guava. The problem is that GWT responds poorly to two .gwt.xml files in the same Java package: http://goo.gl/CO7dLB The summary is that it ignores one file in favor of the other. util.concurrent, like nearly all our packages, has two .gwt.xml files: one for prod and one for tests. util.concurrent, unlike our other packages, has, as of this writing, test supersource but no prod supersource. GWT happens to use the prod .gwt.xml, so it looks for no supersource for tests, either. This causes it to fail to find AtomicLongMapTest. Our workaround is to tell GWT that util.concurrent and all other packages have prod supersource, even if they have none. GWT is happy to ignore us when we specify a nonexistent path. (I hope that this workaround does not cause its own problems in the future.) -->\n", "   \n", "  <super-source path=\"super\"/>\n", "   \n", "  <inherits name=\"com.google.gwt.junit.JUnit\"/>\n", "   \n", "  <inherits name=\"com.google.common.annotations.Annotations\"/>\n", "   \n", "  <inherits name=\"com.google.common.base.Base\"/>\n", "   \n", "  <inherits name=\"com.google.common.collect.Collect\"/>\n", "   \n", "  <inherits name=\"com.google.common.primitives.Primitives\"/>\n", "   \n", "  <inherits name=\"com.google.common.testing.Testing\"/>\n", "   \n", "  <inherits name=\"java.lang.Lang\"/>\n", "    \n", "  <inherits name=\"com.google.gwt.core.Core\"/>\n", "   \n"]}, "removed": {"1": ["<source path=\"\">\n", "  <!-- Hack to keep collect from hiding collect.testing supersource: -->\n", "  <exclude name=\"**/testing/**\"/>\n", "</source>\n", "\n", "<!--\n", "     We used to set this only for packages that had manual supersource.\n", "     That worked everywhere that I know of except for one place:\n", "     when running the GWT util.concurrent tests under Guava.\n", "     The problem is that GWT responds poorly to two .gwt.xml files in the same Java package:\n", "     http://goo.gl/CO7dLB\n", "     The summary is that it ignores one file in favor of the other.\n", "     util.concurrent, like nearly all our packages, has two .gwt.xml files: one for prod and one for tests.\n", "     util.concurrent, unlike our other packages, has, as of this writing, test supersource but no prod supersource.\n", "     GWT happens to use the prod .gwt.xml, so it looks for no supersource for tests, either.\n", "     This causes it to fail to find AtomicLongMapTest.\n", "     Our workaround is to tell GWT that util.concurrent and all other packages have prod supersource, even if they have none.\n", "     GWT is happy to ignore us when we specify a nonexistent path.\n", "     (I hope that this workaround does not cause its own problems in the future.)\n", "-->\n", "<super-source path=\"super\"/>\n", "<inherits name=\"com.google.gwt.junit.JUnit\"/>\n", "<inherits name=\"com.google.common.annotations.Annotations\"/>\n", "<inherits name=\"com.google.common.testing.Testing\"/>\n", "<inherits name=\"java.lang.Lang\"/>\n", "<inherits name=\"com.google.gwt.core.Core\"/>\n"]}, "added_lines": {"1": [1, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32]}, "removed_lines": {"1": [3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28]}}, {"22": "guava-testlib/src/com/google/common/collect/testing/AbstractCollectionTestSuiteBuilder.java", "added": {"1": ["import com.google.common.collect.testing.testers.CollectionForEachTester;\n", "import com.google.common.collect.testing.testers.CollectionRemoveIfTester;\n", "import com.google.common.collect.testing.testers.CollectionSpliteratorTester;\n", "import com.google.common.collect.testing.testers.CollectionStreamTester;\n"], "2": ["        CollectionForEachTester.class,\n", "        CollectionRemoveIfTester.class,\n", "        CollectionSpliteratorTester.class,\n", "        CollectionStreamTester.class,\n"]}, "removed": {}, "added_lines": {"1": [27, 31, 36, 37], "2": [65, 69, 74, 75]}, "removed_lines": {}}, {"23": "guava-testlib/src/com/google/common/collect/testing/AbstractIteratorTester.java", "added": {"1": ["  public void testForEachRemaining() {\n", "    for (int i = 0; i < expectedElements.size() - 1; i++) {\n", "      List<E> targetElements = new ArrayList<E>();\n", "      Iterator<E> iterator = newTargetIterator();\n", "      for (int j = 0; j < i; j++) {\n", "        targetElements.add(iterator.next());\n", "      }\n", "      iterator.forEachRemaining(targetElements::add);\n", "      if (knownOrder == KnownOrder.KNOWN_ORDER) {\n", "        assertEquals(expectedElements, targetElements);\n", "      } else {\n", "        Helpers.assertEqualIgnoringOrder(expectedElements, targetElements);\n", "      }\n", "    }\n", "  }\n", "\n"]}, "removed": {}, "added_lines": {"1": [336, 337, 338, 339, 340, 341, 342, 343, 344, 345, 346, 347, 348, 349, 350, 351]}, "removed_lines": {}}, {"24": "guava-testlib/src/com/google/common/collect/testing/ListTestSuiteBuilder.java", "added": {"1": ["import com.google.common.collect.testing.testers.ListReplaceAllTester;\n"], "2": ["    testers.add(ListReplaceAllTester.class);\n"]}, "removed": {}, "added_lines": {"1": [41], "2": [86]}, "removed_lines": {}}, {"25": "guava-testlib/src/com/google/common/collect/testing/MapTestSuiteBuilder.java", "added": {"1": ["import com.google.common.collect.testing.testers.MapComputeIfAbsentTester;\n", "import com.google.common.collect.testing.testers.MapComputeIfPresentTester;\n", "import com.google.common.collect.testing.testers.MapComputeTester;\n", "import com.google.common.collect.testing.testers.MapForEachTester;\n", "import com.google.common.collect.testing.testers.MapGetOrDefaultTester;\n", "import com.google.common.collect.testing.testers.MapMergeTester;\n", "import com.google.common.collect.testing.testers.MapPutIfAbsentTester;\n", "import com.google.common.collect.testing.testers.MapRemoveEntryTester;\n", "import com.google.common.collect.testing.testers.MapReplaceAllTester;\n", "import com.google.common.collect.testing.testers.MapReplaceEntryTester;\n", "import com.google.common.collect.testing.testers.MapReplaceTester;\n"], "2": ["        MapComputeTester.class,\n", "        MapComputeIfAbsentTester.class,\n", "        MapComputeIfPresentTester.class,\n", "        MapForEachTester.class,\n", "        MapGetOrDefaultTester.class,\n", "        MapMergeTester.class,\n", "        MapPutIfAbsentTester.class,\n", "        MapRemoveEntryTester.class,\n", "        MapReplaceTester.class,\n", "        MapReplaceAllTester.class,\n", "        MapReplaceEntryTester.class,\n"]}, "removed": {}, "added_lines": {"1": [29, 30, 31, 37, 38, 42, 44, 46, 48, 49, 50], "2": [81, 82, 83, 89, 91, 94, 97, 99, 100, 101, 102]}, "removed_lines": {}}, {"26": "guava-testlib/src/com/google/common/collect/testing/SpliteratorTester.java", "added": {"1": ["/*\n", " * Copyright (C) 2015 The Guava Authors\n", " *\n", " * Licensed under the Apache License, Version 2.0 (the \"License\");\n", " * you may not use this file except in compliance with the License.\n", " * You may obtain a copy of the License at\n", " *\n", " * http://www.apache.org/licenses/LICENSE-2.0\n", " *\n", " * Unless required by applicable law or agreed to in writing, software\n", " * distributed under the License is distributed on an \"AS IS\" BASIS,\n", " * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n", " * See the License for the specific language governing permissions and\n", " * limitations under the License.\n", " */\n", "\n", "package com.google.common.collect.testing;\n", "\n", "import static com.google.common.base.Preconditions.checkNotNull;\n", "import static com.google.common.collect.testing.Helpers.assertEqualIgnoringOrder;\n", "import static com.google.common.collect.testing.Helpers.assertEqualInOrder;\n", "import static com.google.common.collect.testing.Platform.format;\n", "import static junit.framework.Assert.assertEquals;\n", "import static junit.framework.Assert.assertFalse;\n", "import static junit.framework.Assert.assertTrue;\n", "import static junit.framework.Assert.fail;\n", "\n", "import com.google.common.annotations.GwtCompatible;\n", "import com.google.common.collect.Ordering;\n", "import com.google.common.primitives.Ints;\n", "import java.util.ArrayList;\n", "import java.util.Arrays;\n", "import java.util.Comparator;\n", "import java.util.EnumSet;\n", "import java.util.List;\n", "import java.util.Spliterator;\n", "import java.util.function.Consumer;\n", "import java.util.function.Supplier;\n", "import javax.annotation.Nullable;\n", "\n", "/**\n", " * Tester for {@code Spliterator} implementations.\n", " */\n", "@GwtCompatible\n", "public final class SpliteratorTester<E> {\n", "  /**\n", "   * Return type from \"contains the following elements\" assertions.\n", "   */\n", "  public interface Ordered {\n", "    /**\n", "     * Attests that the expected values must not just be present but must be present in the order\n", "     * they were given.\n", "     */\n", "    void inOrder();\n", "  }\n", "\n", "  /**\n", "   * Different ways of decomposing a Spliterator, all of which must produce the same\n", "   * elements (up to ordering, if Spliterator.ORDERED is not present).\n", "   */\n", "  enum SpliteratorDecompositionStrategy {\n", "    NO_SPLIT_FOR_EACH_REMAINING {\n", "      @Override\n", "      <E> void forEach(Spliterator<E> spliterator, Consumer<? super E> consumer) {\n", "        spliterator.forEachRemaining(consumer);\n", "      }\n", "    },\n", "    NO_SPLIT_TRY_ADVANCE {\n", "      @Override\n", "      <E> void forEach(Spliterator<E> spliterator, Consumer<? super E> consumer) {\n", "        while (spliterator.tryAdvance(consumer)) {\n", "          // do nothing\n", "        }\n", "      }\n", "    },\n", "    MAXIMUM_SPLIT {\n", "      @Override\n", "      <E> void forEach(Spliterator<E> spliterator, Consumer<? super E> consumer) {\n", "        for (Spliterator<E> prefix = trySplitTestingSize(spliterator);\n", "            prefix != null;\n", "            prefix = trySplitTestingSize(spliterator)) {\n", "          forEach(prefix, consumer);\n", "        }\n", "        spliterator.forEachRemaining(consumer);\n", "      }\n", "    },\n", "    ALTERNATE_ADVANCE_AND_SPLIT {\n", "      @Override\n", "      <E> void forEach(Spliterator<E> spliterator, Consumer<? super E> consumer) {\n", "        while (spliterator.tryAdvance(consumer)) {\n", "          Spliterator<E> prefix = trySplitTestingSize(spliterator);\n", "          if (prefix != null) {\n", "            forEach(prefix, consumer);\n", "          }\n", "        }\n", "      }\n", "    };\n", "\n", "    abstract <E> void forEach(Spliterator<E> spliterator, Consumer<? super E> consumer);\n", "  }\n", "\n", "  @Nullable\n", "  private static <E> Spliterator<E> trySplitTestingSize(Spliterator<E> spliterator) {\n", "    boolean subsized = spliterator.hasCharacteristics(Spliterator.SUBSIZED);\n", "    long originalSize = spliterator.estimateSize();\n", "    Spliterator<E> trySplit = spliterator.trySplit();\n", "    if (spliterator.estimateSize() > originalSize) {\n", "      fail(\n", "          format(\n", "              \"estimated size of spliterator after trySplit (%s) is larger than original size (%s)\",\n", "              spliterator.estimateSize(),\n", "              originalSize));\n", "    }\n", "    if (trySplit != null) {\n", "      if (trySplit.estimateSize() > originalSize) {\n", "        fail(\n", "            format(\n", "                \"estimated size of trySplit result (%s) is larger than original size (%s)\",\n", "                trySplit.estimateSize(),\n", "                originalSize));\n", "      }\n", "    }\n", "    if (subsized) {\n", "      if (trySplit != null) {\n", "        assertEquals(\n", "            \"sum of estimated sizes of trySplit and original spliterator after trySplit\",\n", "            originalSize,\n", "            trySplit.estimateSize() + spliterator.estimateSize());\n", "      } else {\n", "        assertEquals(\n", "            \"estimated size of spliterator after failed trySplit\",\n", "            originalSize,\n", "            spliterator.estimateSize());\n", "      }\n", "    }\n", "    return trySplit;\n", "  }\n", "\n", "  public static <E> SpliteratorTester<E> of(Supplier<Spliterator<E>> spliteratorSupplier) {\n", "    return new SpliteratorTester<E>(spliteratorSupplier);\n", "  }\n", "\n", "  private final Supplier<Spliterator<E>> spliteratorSupplier;\n", "\n", "  private SpliteratorTester(Supplier<Spliterator<E>> spliteratorSupplier) {\n", "    this.spliteratorSupplier = checkNotNull(spliteratorSupplier);\n", "  }\n", "\n", "  @SafeVarargs\n", "  public final Ordered expect(Object... elements) {\n", "    return expect(Arrays.asList(elements));\n", "  }\n", "\n", "  public final Ordered expect(Iterable<?> elements) {\n", "    List<List<E>> resultsForAllStrategies = new ArrayList<>();\n", "    Spliterator<E> spliterator = spliteratorSupplier.get();\n", "    int characteristics = spliterator.characteristics();\n", "    long estimatedSize = spliterator.estimateSize();\n", "    for (SpliteratorDecompositionStrategy strategy :\n", "        EnumSet.allOf(SpliteratorDecompositionStrategy.class)) {\n", "      List<E> resultsForStrategy = new ArrayList<E>();\n", "      strategy.forEach(spliteratorSupplier.get(), resultsForStrategy::add);\n", "\n", "      // TODO(cpovirk): better failure messages\n", "      if ((characteristics & Spliterator.NONNULL) != 0) {\n", "        assertFalse(resultsForStrategy.contains(null));\n", "      }\n", "      if ((characteristics & Spliterator.SORTED) != 0) {\n", "        Comparator<? super E> comparator = spliterator.getComparator();\n", "        if (comparator == null) {\n", "          comparator = (Comparator) Comparator.naturalOrder();\n", "        }\n", "        assertTrue(Ordering.from(comparator).isOrdered(resultsForStrategy));\n", "      }\n", "      if ((characteristics & Spliterator.SIZED) != 0) {\n", "        assertEquals(Ints.checkedCast(estimatedSize), resultsForStrategy.size());\n", "      }\n", "\n", "      assertEqualIgnoringOrder(elements, resultsForStrategy);\n", "      resultsForAllStrategies.add(resultsForStrategy);\n", "    }\n", "    return new Ordered() {\n", "      @Override\n", "      public void inOrder() {\n", "        resultsForAllStrategies.forEach(\n", "            resultsForStrategy -> assertEqualInOrder(elements, resultsForStrategy));\n", "      }\n", "    };\n", "  }\n", "}\n"]}, "removed": {}, "added_lines": {"1": [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 58, 59, 60, 61, 62, 63, 64, 65, 66, 67, 68, 69, 70, 71, 72, 73, 74, 75, 76, 77, 78, 79, 80, 81, 82, 83, 84, 85, 86, 87, 88, 89, 90, 91, 92, 93, 94, 95, 96, 97, 98, 99, 100, 101, 102, 103, 104, 105, 106, 107, 108, 109, 110, 111, 112, 113, 114, 115, 116, 117, 118, 119, 120, 121, 122, 123, 124, 125, 126, 127, 128, 129, 130, 131, 132, 133, 134, 135, 136, 137, 138, 139, 140, 141, 142, 143, 144, 145, 146, 147, 148, 149, 150, 151, 152, 153, 154, 155, 156, 157, 158, 159, 160, 161, 162, 163, 164, 165, 166, 167, 168, 169, 170, 171, 172, 173, 174, 175, 176, 177, 178, 179, 180, 181, 182, 183, 184, 185, 186, 187, 188, 189, 190]}, "removed_lines": {}}, {"27": "guava-testlib/src/com/google/common/collect/testing/TestsForListsInJavaUtil.java", "added": {"1": ["import static com.google.common.collect.testing.testers.CollectionSpliteratorTester.getSpliteratorNotImmutableCollectionAllowsAddMethod;\n", "import static com.google.common.collect.testing.testers.CollectionSpliteratorTester.getSpliteratorNotImmutableCollectionAllowsRemoveMethod;\n", "import static java.util.Arrays.asList;\n"], "2": ["    return asList(\n", "        getListIteratorFullyModifiableMethod(),\n", "        getSpliteratorNotImmutableCollectionAllowsAddMethod(),\n", "        getSpliteratorNotImmutableCollectionAllowsRemoveMethod());\n"]}, "removed": {"2": ["    return Arrays.asList(\n", "        getListIteratorFullyModifiableMethod());\n"]}, "added_lines": {"1": [19, 20, 25], "2": [96, 100, 101, 102]}, "removed_lines": {"2": [93, 97]}}, {"28": "guava-testlib/src/com/google/common/collect/testing/TestsForMapsInJavaUtil.java", "added": {"1": ["import java.util.NavigableMap;\n"], "2": ["    suite.addTest(testsForCheckedNavigableMap());\n", "    suite.addTest(testsForEmptyNavigableMap());\n", "    suite.addTest(testsForEmptySortedMap());\n"], "3": ["    suite.addTest(testsForUnmodifiableNavigableMap());\n"], "4": ["  protected Collection<Method> suppressForCheckedNavigableMap() {\n", "    return Collections.emptySet();\n", "  }\n", "\n"], "5": ["  private Collection<Method> suppressForEmptyNavigableMap() {\n", "    return Collections.emptySet();\n", "  }\n", "\n", "  private Collection<Method> suppressForEmptySortedMap() {\n", "    return Collections.emptySet();\n", "  }\n", "\n"], "6": ["  protected Collection<Method> suppressForUnmodifiableNavigableMap() {\n", "    return Collections.emptySet();\n", "  }\n", "\n"], "7": ["  public Test testsForCheckedNavigableMap() {\n", "    return SortedMapTestSuiteBuilder.using(\n", "        new TestStringSortedMapGenerator() {\n", "          @Override\n", "          protected NavigableMap<String, String> create(Entry<String, String>[] entries) {\n", "            NavigableMap<String, String> map = populate(new TreeMap<String, String>(), entries);\n", "            return Collections.checkedNavigableMap(map, String.class, String.class);\n", "          }\n", "        })\n", "        .named(\"checkedNavigableMap/TreeMap, natural\")\n", "        .withFeatures(\n", "            MapFeature.GENERAL_PURPOSE,\n", "            MapFeature.ALLOWS_NULL_VALUES,\n", "            MapFeature.FAILS_FAST_ON_CONCURRENT_MODIFICATION,\n", "            MapFeature.RESTRICTS_KEYS,\n", "            MapFeature.RESTRICTS_VALUES,\n", "            CollectionFeature.KNOWN_ORDER,\n", "            CollectionFeature.SUPPORTS_ITERATOR_REMOVE,\n", "            CollectionFeature.SERIALIZABLE,\n", "            CollectionSize.ANY)\n", "        .suppressing(suppressForCheckedNavigableMap())\n", "        .createTestSuite();\n", "  }\n", "\n"], "8": ["  public Test testsForEmptyNavigableMap() {\n", "    return MapTestSuiteBuilder.using(\n", "        new TestStringSortedMapGenerator() {\n", "          @Override\n", "          protected NavigableMap<String, String> create(Entry<String, String>[] entries) {\n", "            return Collections.emptyNavigableMap();\n", "          }\n", "        })\n", "        .named(\"emptyNavigableMap\")\n", "        .withFeatures(CollectionFeature.SERIALIZABLE, CollectionSize.ZERO)\n", "        .suppressing(suppressForEmptyNavigableMap())\n", "        .createTestSuite();\n", "\n", "  }\n", "\n", "  public Test testsForEmptySortedMap() {\n", "    return MapTestSuiteBuilder.using(\n", "        new TestStringSortedMapGenerator() {\n", "          @Override\n", "          protected SortedMap<String, String> create(Entry<String, String>[] entries) {\n", "            return Collections.emptySortedMap();\n", "          }\n", "        })\n", "        .named(\"emptySortedMap\")\n", "        .withFeatures(CollectionFeature.SERIALIZABLE, CollectionSize.ZERO)\n", "        .suppressing(suppressForEmptySortedMap())\n", "        .createTestSuite();\n", "\n", "  }\n", "\n"], "9": ["  public Test testsForUnmodifiableNavigableMap() {\n", "    return MapTestSuiteBuilder.using(\n", "        new TestStringSortedMapGenerator() {\n", "          @Override\n", "          protected NavigableMap<String, String> create(Entry<String, String>[] entries) {\n", "            return Collections.unmodifiableNavigableMap(populate(new TreeMap<>(), entries));\n", "          }\n", "        })\n", "        .named(\"unmodifiableNavigableMap/TreeMap, natural\")\n", "        .withFeatures(\n", "            MapFeature.ALLOWS_NULL_VALUES,\n", "            CollectionFeature.KNOWN_ORDER,\n", "            CollectionFeature.SERIALIZABLE,\n", "            CollectionSize.ANY)\n", "        .suppressing(suppressForUnmodifiableNavigableMap())\n", "        .createTestSuite();\n", "  }\n", "\n"], "10": ["    return MapTestSuiteBuilder.using(\n"], "11": ["    return NavigableMapTestSuiteBuilder.using(\n"], "12": ["    return NavigableMapTestSuiteBuilder.using(\n"]}, "removed": {"10": ["    return ConcurrentMapTestSuiteBuilder.using(\n"], "11": ["    return ConcurrentNavigableMapTestSuiteBuilder.using(\n"], "12": ["    return ConcurrentNavigableMapTestSuiteBuilder.using(\n"]}, "added_lines": {"1": [37], "2": [62, 65, 66], "3": [74], "4": [87, 88, 89, 90], "5": [99, 100, 101, 102, 103, 104, 105, 106], "6": [135, 136, 137, 138], "7": [180, 181, 182, 183, 184, 185, 186, 187, 188, 189, 190, 191, 192, 193, 194, 195, 196, 197, 198, 199, 200, 201, 202, 203], "8": [242, 243, 244, 245, 246, 247, 248, 249, 250, 251, 252, 253, 254, 255, 256, 257, 258, 259, 260, 261, 262, 263, 264, 265, 266, 267, 268, 269, 270, 271], "9": [428, 429, 430, 431, 432, 433, 434, 435, 436, 437, 438, 439, 440, 441, 442, 443, 444, 445], "10": [487], "11": [505], "12": [524]}, "removed_lines": {"10": [394], "11": [412], "12": [431]}}, {"29": "guava-testlib/src/com/google/common/collect/testing/TestsForQueuesInJavaUtil.java", "added": {"1": ["import java.util.concurrent.ConcurrentLinkedDeque;\n"], "2": ["    suite.addTest(testsForCheckedQueue());\n", "    suite.addTest(testsForConcurrentLinkedDeque());\n"], "3": ["  protected Collection<Method> suppressForCheckedQueue() {\n", "    return Collections.emptySet();\n", "  }\n", "\n"], "4": ["  protected Collection<Method> suppressForConcurrentLinkedDeque() {\n", "    return Collections.emptySet();\n", "  }\n", "\n"], "5": ["  public Test testsForCheckedQueue() {\n", "    return QueueTestSuiteBuilder.using(\n", "        new TestStringQueueGenerator() {\n", "          @Override\n", "          public Queue<String> create(String[] elements) {\n", "            Queue<String> queue = new LinkedList<>(MinimalCollection.of(elements));\n", "            return Collections.checkedQueue(queue, String.class);\n", "          }\n", "        })\n", "        .named(\"checkedQueue/LinkedList\")\n", "        .withFeatures(\n", "            CollectionFeature.GENERAL_PURPOSE,\n", "            CollectionFeature.ALLOWS_NULL_VALUES,\n", "            CollectionFeature.KNOWN_ORDER,\n", "            CollectionFeature.RESTRICTS_ELEMENTS,\n", "            CollectionSize.ANY)\n", "        // don't skip collection tests since checkedQueue() is not tested by TestsForListsInJavaUtil\n", "        .suppressing(suppressForCheckedQueue())\n", "        .createTestSuite();\n", "  }\n", "\n"], "6": ["  public Test testsForConcurrentLinkedDeque() {\n", "    return QueueTestSuiteBuilder.using(\n", "            new TestStringQueueGenerator() {\n", "              @Override\n", "              public Queue<String> create(String[] elements) {\n", "                return new ConcurrentLinkedDeque<String>(MinimalCollection.of(elements));\n", "              }\n", "            })\n", "        .named(\"ConcurrentLinkedDeque\")\n", "        .withFeatures(\n", "            CollectionFeature.GENERAL_PURPOSE, CollectionFeature.KNOWN_ORDER, CollectionSize.ANY)\n", "        .suppressing(suppressForConcurrentLinkedDeque())\n", "        .createTestSuite();\n", "  }\n", "\n"]}, "removed": {}, "added_lines": {"1": [30], "2": [56, 57], "3": [66, 67, 68, 69], "4": [82, 83, 84, 85], "5": [106, 107, 108, 109, 110, 111, 112, 113, 114, 115, 116, 117, 118, 119, 120, 121, 122, 123, 124, 125, 126], "6": [178, 179, 180, 181, 182, 183, 184, 185, 186, 187, 188, 189, 190, 191, 192]}, "removed_lines": {}}, {"30": "guava-testlib/src/com/google/common/collect/testing/TestsForSetsInJavaUtil.java", "added": {"1": ["import static com.google.common.collect.testing.testers.CollectionSpliteratorTester.getSpliteratorNotImmutableCollectionAllowsAddMethod;\n", "import static com.google.common.collect.testing.testers.CollectionSpliteratorTester.getSpliteratorNotImmutableCollectionAllowsRemoveMethod;\n", "import static java.util.Arrays.asList;\n", "\n"], "2": ["import java.util.NavigableSet;\n"], "3": ["    suite.addTest(testsForCheckedNavigableSet());\n", "    suite.addTest(testsForEmptyNavigableSet());\n", "    suite.addTest(testsForEmptySortedSet());\n"], "4": ["    suite.addTest(testsForUnmodifiableNavigableSet());\n"], "5": ["  protected Collection<Method> suppressForCheckedNavigableSet() {\n", "    return Collections.emptySet();\n", "  }\n", "\n", "  protected Collection<Method> suppressForEmptyNavigableSet() {\n", "    return Collections.emptySet();\n", "  }\n", "\n", "  protected Collection<Method> suppressForEmptySortedSet() {\n", "    return Collections.emptySet();\n", "  }\n", "\n"], "6": ["    return asList(\n", "        getSpliteratorNotImmutableCollectionAllowsAddMethod(),\n", "        getSpliteratorNotImmutableCollectionAllowsRemoveMethod());\n", "  protected Collection<Method> suppressForUnmodifiableNavigableSet() {\n", "    return Collections.emptySet();\n", "  }\n", "\n"], "7": ["  public Test testsForCheckedNavigableSet() {\n", "    return SortedSetTestSuiteBuilder.using(\n", "        new TestStringSortedSetGenerator() {\n", "          @Override\n", "          public NavigableSet<String> create(String[] elements) {\n", "            NavigableSet<String> innerSet = new TreeSet<String>();\n", "            Collections.addAll(innerSet, elements);\n", "            return Collections.checkedNavigableSet(innerSet, String.class);\n", "          }\n", "        })\n", "        .named(\"checkedNavigableSet/TreeSet, natural\")\n", "        .withFeatures(\n", "            SetFeature.GENERAL_PURPOSE,\n", "            CollectionFeature.KNOWN_ORDER,\n", "            CollectionFeature.SERIALIZABLE,\n", "            CollectionFeature.FAILS_FAST_ON_CONCURRENT_MODIFICATION,\n", "            CollectionFeature.RESTRICTS_ELEMENTS,\n", "            CollectionSize.ANY)\n", "        .suppressing(suppressForCheckedNavigableSet())\n", "        .createTestSuite();\n", "  }\n", "\n"], "8": ["  public Test testsForEmptyNavigableSet() {\n", "    return SetTestSuiteBuilder.using(\n", "        new TestStringSortedSetGenerator() {\n", "          @Override\n", "          public NavigableSet<String> create(String[] elements) {\n", "            return Collections.emptyNavigableSet();\n", "          }\n", "        })\n", "        .named(\"emptyNavigableSet\")\n", "        .withFeatures(CollectionFeature.SERIALIZABLE, CollectionSize.ZERO)\n", "        .suppressing(suppressForEmptyNavigableSet())\n", "        .createTestSuite();\n", "  }\n", "\n", "  public Test testsForEmptySortedSet() {\n", "    return SetTestSuiteBuilder.using(\n", "        new TestStringSortedSetGenerator() {\n", "          @Override\n", "          public SortedSet<String> create(String[] elements) {\n", "            return Collections.emptySortedSet();\n", "          }\n", "        })\n", "        .named(\"emptySortedSet\")\n", "        .withFeatures(CollectionFeature.SERIALIZABLE, CollectionSize.ZERO)\n", "        .suppressing(suppressForEmptySortedSet())\n", "        .createTestSuite();\n", "  }\n", "\n"], "9": ["  public Test testsForUnmodifiableNavigableSet() {\n", "    return SetTestSuiteBuilder.using(\n", "        new TestStringSortedSetGenerator() {\n", "          @Override\n", "          public NavigableSet<String> create(String[] elements) {\n", "            NavigableSet<String> innerSet = new TreeSet<String>();\n", "            Collections.addAll(innerSet, elements);\n", "            return Collections.unmodifiableNavigableSet(innerSet);\n", "          }\n", "        })\n", "        .named(\"unmodifiableNavigableSet/TreeSet, natural\")\n", "        .withFeatures(\n", "            CollectionFeature.KNOWN_ORDER,\n", "            CollectionFeature.RESTRICTS_ELEMENTS,\n", "            CollectionFeature.SERIALIZABLE,\n", "            CollectionSize.ANY)\n", "        .suppressing(suppressForUnmodifiableNavigableSet())\n", "        .createTestSuite();\n", "  }\n", "\n"]}, "removed": {"6": ["    return Collections.emptySet();\n"]}, "added_lines": {"1": [19, 20, 21, 22], "2": [37], "3": [61, 63, 64], "4": [73], "5": [84, 85, 86, 87, 92, 93, 94, 95, 96, 97, 98, 99], "6": [125, 126, 127, 134, 135, 136, 137], "7": [157, 158, 159, 160, 161, 162, 163, 164, 165, 166, 167, 168, 169, 170, 171, 172, 173, 174, 175, 176, 177, 178], "8": [193, 194, 195, 196, 197, 198, 199, 200, 201, 202, 203, 204, 205, 206, 207, 208, 209, 210, 211, 212, 213, 214, 215, 216, 217, 218, 219, 220], "9": [379, 380, 381, 382, 383, 384, 385, 386, 387, 388, 389, 390, 391, 392, 393, 394, 395, 396, 397, 398]}, "removed_lines": {"6": [104]}}, {"31": "guava-testlib/src/com/google/common/collect/testing/google/MultimapForEachTester.java", "added": {"1": ["/*\n", " * Copyright (C) 2012 The Guava Authors\n", " *\n", " * Licensed under the Apache License, Version 2.0 (the \"License\");\n", " * you may not use this file except in compliance with the License.\n", " * You may obtain a copy of the License at\n", " *\n", " * http://www.apache.org/licenses/LICENSE-2.0\n", " *\n", " * Unless required by applicable law or agreed to in writing, software\n", " * distributed under the License is distributed on an \"AS IS\" BASIS,\n", " * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n", " * See the License for the specific language governing permissions and\n", " * limitations under the License.\n", " */\n", "package com.google.common.collect.testing.google;\n", "\n", "import static com.google.common.collect.testing.Helpers.assertEqualIgnoringOrder;\n", "import static com.google.common.collect.testing.Helpers.mapEntry;\n", "import static com.google.common.collect.testing.features.CollectionFeature.KNOWN_ORDER;\n", "\n", "import com.google.common.annotations.GwtCompatible;\n", "import com.google.common.collect.Multimap;\n", "import com.google.common.collect.testing.features.CollectionFeature;\n", "import java.util.ArrayList;\n", "import java.util.List;\n", "import java.util.Map.Entry;\n", "\n", "/**\n", " * Tests for {@link Multimap#forEach}.\n", " *\n", " * @author Louis Wasserman\n", " */\n", "@GwtCompatible\n", "public class MultimapForEachTester<K, V> extends AbstractMultimapTester<K, V, Multimap<K, V>> {\n", "  public void testForEach() {\n", "    List<Entry<K, V>> entries = new ArrayList<>();\n", "    multimap().forEach((k, v) -> entries.add(mapEntry(k, v)));\n", "    assertEqualIgnoringOrder(getSampleElements(), multimap().entries());\n", "  }\n", "\n", "  @CollectionFeature.Require(KNOWN_ORDER)\n", "  public void testForEachOrder() {\n", "    List<Entry<K, V>> entries = new ArrayList<>();\n", "    multimap().forEach((k, v) -> entries.add(mapEntry(k, v)));\n", "    assertEqualIgnoringOrder(getSampleElements(), multimap().entries());\n", "  }\n", "}\n"]}, "removed": {}, "added_lines": {"1": [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47, 48]}, "removed_lines": {}}, {"32": "guava-testlib/src/com/google/common/collect/testing/google/MultimapTestSuiteBuilder.java", "added": {"1": ["        MultimapForEachTester.class,\n"]}, "removed": {}, "added_lines": {"1": [88]}, "removed_lines": {}}, {"33": "guava-testlib/src/com/google/common/collect/testing/google/MultisetForEachEntryTester.java", "added": {"1": ["/*\n", " * Copyright (C) 2016 The Guava Authors\n", " *\n", " * Licensed under the Apache License, Version 2.0 (the \"License\");\n", " * you may not use this file except in compliance with the License.\n", " * You may obtain a copy of the License at\n", " *\n", " * http://www.apache.org/licenses/LICENSE-2.0\n", " *\n", " * Unless required by applicable law or agreed to in writing, software\n", " * distributed under the License is distributed on an \"AS IS\" BASIS,\n", " * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n", " * See the License for the specific language governing permissions and\n", " * limitations under the License.\n", " */\n", "\n", "package com.google.common.collect.testing.google;\n", "\n", "import static com.google.common.collect.testing.features.CollectionFeature.KNOWN_ORDER;\n", "\n", "import com.google.common.annotations.GwtCompatible;\n", "import com.google.common.collect.Multiset.Entry;\n", "import com.google.common.collect.Multisets;\n", "import com.google.common.collect.testing.Helpers;\n", "import com.google.common.collect.testing.features.CollectionFeature;\n", "import java.util.ArrayList;\n", "import java.util.List;\n", "\n", "/**\n", " * Tests for {@code Multiset#forEachEntry}.\n", " *\n", " * @author Louis Wasserman\n", " */\n", "@GwtCompatible\n", "public class MultisetForEachEntryTester<E> extends AbstractMultisetTester<E> {\n", "  public void testForEachEntry() {\n", "    List<Entry<E>> expected = new ArrayList<>(getMultiset().entrySet());\n", "    List<Entry<E>> actual = new ArrayList<>();\n", "    getMultiset()\n", "        .forEachEntry((element, count) -> actual.add(Multisets.immutableEntry(element, count)));\n", "    Helpers.assertEqualIgnoringOrder(expected, actual);\n", "  }\n", "\n", "  @CollectionFeature.Require(KNOWN_ORDER)\n", "  public void testForEachEntryOrdered() {\n", "    List<Entry<E>> expected = new ArrayList<>(getMultiset().entrySet());\n", "    List<Entry<E>> actual = new ArrayList<>();\n", "    getMultiset()\n", "        .forEachEntry((element, count) -> actual.add(Multisets.immutableEntry(element, count)));\n", "    assertEquals(expected, actual);\n", "  }\n", "}\n"]}, "removed": {}, "added_lines": {"1": [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51, 52]}, "removed_lines": {}}, {"34": "guava-testlib/src/com/google/common/collect/testing/google/MultisetTestSuiteBuilder.java", "added": {"1": ["    testers.add(MultisetForEachEntryTester.class);\n"]}, "removed": {}, "added_lines": {"1": [80]}, "removed_lines": {}}, {"35": "guava-testlib/src/com/google/common/collect/testing/testers/CollectionForEachTester.java", "added": {"1": ["/*\n", " * Copyright (C) 2015 The Guava Authors\n", " *\n", " * Licensed under the Apache License, Version 2.0 (the \"License\");\n", " * you may not use this file except in compliance with the License.\n", " * You may obtain a copy of the License at\n", " *\n", " * http://www.apache.org/licenses/LICENSE-2.0\n", " *\n", " * Unless required by applicable law or agreed to in writing, software\n", " * distributed under the License is distributed on an \"AS IS\" BASIS,\n", " * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n", " * See the License for the specific language governing permissions and\n", " * limitations under the License.\n", " */\n", "\n", "package com.google.common.collect.testing.testers;\n", "\n", "import static com.google.common.collect.testing.features.CollectionFeature.KNOWN_ORDER;\n", "\n", "import com.google.common.annotations.GwtCompatible;\n", "import com.google.common.collect.testing.AbstractCollectionTester;\n", "import com.google.common.collect.testing.Helpers;\n", "import com.google.common.collect.testing.features.CollectionFeature;\n", "import java.util.ArrayList;\n", "import java.util.Arrays;\n", "import java.util.List;\n", "\n", "/**\n", " * A generic JUnit test which tests {@code forEach} operations on a collection.\n", " * Can't be invoked directly; please see\n", " * {@link com.google.common.collect.testing.CollectionTestSuiteBuilder}.\n", " *\n", " * @author Louis Wasserman\n", " */\n", "@GwtCompatible\n", "public class CollectionForEachTester<E> extends AbstractCollectionTester<E> {\n", "  @CollectionFeature.Require(absent = KNOWN_ORDER)\n", "  public void testForEachUnknownOrder() {\n", "    List<E> elements = new ArrayList<E>();\n", "    collection.forEach(elements::add);\n", "    Helpers.assertEqualIgnoringOrder(\n", "        Arrays.asList(createSamplesArray()), elements);\n", "  }\n", "\n", "  @CollectionFeature.Require(KNOWN_ORDER)\n", "  public void testForEachKnownOrder() {\n", "    List<E> elements = new ArrayList<E>();\n", "    collection.forEach(elements::add);\n", "    List<E> expected = Helpers.copyToList(getOrderedElements());\n", "    assertEquals(\"Different ordered iteration\", expected, elements);\n", "  }\n", "}\n"]}, "removed": {}, "added_lines": {"1": [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51, 52, 53]}, "removed_lines": {}}, {"36": "guava-testlib/src/com/google/common/collect/testing/testers/CollectionRemoveIfTester.java", "added": {"1": ["/*\n", " * Copyright (C) 2015 The Guava Authors\n", " *\n", " * Licensed under the Apache License, Version 2.0 (the \"License\");\n", " * you may not use this file except in compliance with the License.\n", " * You may obtain a copy of the License at\n", " *\n", " * http://www.apache.org/licenses/LICENSE-2.0\n", " *\n", " * Unless required by applicable law or agreed to in writing, software\n", " * distributed under the License is distributed on an \"AS IS\" BASIS,\n", " * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n", " * See the License for the specific language governing permissions and\n", " * limitations under the License.\n", " */\n", "\n", "package com.google.common.collect.testing.testers;\n", "\n", "import static com.google.common.collect.testing.features.CollectionFeature.FAILS_FAST_ON_CONCURRENT_MODIFICATION;\n", "import static com.google.common.collect.testing.features.CollectionFeature.SUPPORTS_ITERATOR_REMOVE;\n", "import static com.google.common.collect.testing.features.CollectionFeature.SUPPORTS_REMOVE;\n", "import static com.google.common.collect.testing.features.CollectionSize.SEVERAL;\n", "import static com.google.common.collect.testing.features.CollectionSize.ZERO;\n", "\n", "import com.google.common.annotations.GwtCompatible;\n", "import com.google.common.collect.testing.AbstractCollectionTester;\n", "import com.google.common.collect.testing.features.CollectionFeature;\n", "import com.google.common.collect.testing.features.CollectionSize;\n", "import java.util.Collection;\n", "import java.util.ConcurrentModificationException;\n", "import java.util.Iterator;\n", "import java.util.function.Predicate;\n", "\n", "/**\n", " * A generic JUnit test which tests {@link Collection#removeIf}. Can't be invoked directly;\n", " * please see {@link com.google.common.collect.testing.CollectionTestSuiteBuilder}.\n", " *\n", " * @author Louis Wasserman\n", " */\n", "@GwtCompatible\n", "@SuppressWarnings(\"unchecked\") // too many \"unchecked generic array creations\"\n", "public class CollectionRemoveIfTester<E> extends AbstractCollectionTester<E> {\n", "  @CollectionFeature.Require(SUPPORTS_ITERATOR_REMOVE)\n", "  public void testRemoveIf_alwaysFalse() {\n", "    assertFalse(\"removeIf(x -> false) should return false\", collection.removeIf(x -> false));\n", "    expectUnchanged();\n", "  }\n", "\n", "  @CollectionFeature.Require(SUPPORTS_ITERATOR_REMOVE)\n", "  @CollectionSize.Require(absent = ZERO)\n", "  public void testRemoveIf_sometimesTrue() {\n", "    assertTrue(\"removeIf(isEqual(present)) should return true\",\n", "        collection.removeIf(Predicate.isEqual(samples.e0())));\n", "    expectMissing(samples.e0());\n", "  }\n", "\n", "  @CollectionFeature.Require(SUPPORTS_ITERATOR_REMOVE)\n", "  @CollectionSize.Require(absent = ZERO)\n", "  public void testRemoveIf_allPresent() {\n", "    assertTrue(\"removeIf(x -> true) should return true\", collection.removeIf(x -> true));\n", "    expectContents();\n", "  }\n", "\n", "  @CollectionFeature.Require({SUPPORTS_ITERATOR_REMOVE, FAILS_FAST_ON_CONCURRENT_MODIFICATION})\n", "  @CollectionSize.Require(SEVERAL)\n", "  public void testRemoveIfSomeMatchesConcurrentWithIteration() {\n", "    try {\n", "      Iterator<E> iterator = collection.iterator();\n", "      assertTrue(collection.removeIf(Predicate.isEqual(samples.e0())));\n", "      iterator.next();\n", "      fail(\"Expected ConcurrentModificationException\");\n", "    } catch (ConcurrentModificationException expected) {\n", "      // success\n", "    }\n", "  }\n", "\n", "  @CollectionFeature.Require(absent = SUPPORTS_REMOVE)\n", "  @CollectionSize.Require(ZERO)\n", "  public void testRemoveIf_unsupportedEmptyCollection() {\n", "    try {\n", "      assertFalse(\"removeIf(Predicate) should return false or throw \"\n", "          + \"UnsupportedOperationException\",\n", "        collection.removeIf(x -> {\n", "          throw new AssertionError(\"predicate should never be called\");\n", "        }));\n", "    } catch (UnsupportedOperationException tolerated) {\n", "    }\n", "    expectUnchanged();\n", "  }\n", "\n", "  @CollectionFeature.Require(absent = SUPPORTS_REMOVE)\n", "  @CollectionSize.Require(absent = ZERO)\n", "  public void testRemoveIf_alwaysTrueUnsupported() {\n", "    try {\n", "      collection.removeIf(x -> true);\n", "      fail(\"removeIf(x -> true) should throw \"\n", "          + \"UnsupportedOperationException\");\n", "    } catch (UnsupportedOperationException expected) {\n", "    }\n", "    expectUnchanged();\n", "    assertTrue(collection.contains(samples.e0()));\n", "  }\n", "}\n"]}, "removed": {}, "added_lines": {"1": [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 58, 59, 60, 61, 62, 63, 64, 65, 66, 67, 68, 69, 70, 71, 72, 73, 74, 75, 76, 77, 78, 79, 80, 81, 82, 83, 84, 85, 86, 87, 88, 89, 90, 91, 92, 93, 94, 95, 96, 97, 98, 99, 100, 101, 102, 103]}, "removed_lines": {}}, {"37": "guava-testlib/src/com/google/common/collect/testing/testers/CollectionSpliteratorTester.java", "added": {"1": ["/*\n", " * Copyright (C) 2013 The Guava Authors\n", " *\n", " * Licensed under the Apache License, Version 2.0 (the \"License\");\n", " * you may not use this file except in compliance with the License.\n", " * You may obtain a copy of the License at\n", " *\n", " * http://www.apache.org/licenses/LICENSE-2.0\n", " *\n", " * Unless required by applicable law or agreed to in writing, software\n", " * distributed under the License is distributed on an \"AS IS\" BASIS,\n", " * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n", " * See the License for the specific language governing permissions and\n", " * limitations under the License.\n", " */\n", "\n", "package com.google.common.collect.testing.testers;\n", "\n", "import static com.google.common.collect.testing.features.CollectionFeature.ALLOWS_NULL_VALUES;\n", "import static com.google.common.collect.testing.features.CollectionFeature.KNOWN_ORDER;\n", "import static com.google.common.collect.testing.features.CollectionFeature.SUPPORTS_ADD;\n", "import static com.google.common.collect.testing.features.CollectionFeature.SUPPORTS_REMOVE;\n", "import static com.google.common.collect.testing.features.CollectionSize.ZERO;\n", "\n", "import com.google.common.annotations.GwtCompatible;\n", "import com.google.common.annotations.GwtIncompatible;\n", "import com.google.common.collect.testing.AbstractCollectionTester;\n", "import com.google.common.collect.testing.Helpers;\n", "import com.google.common.collect.testing.SpliteratorTester;\n", "import com.google.common.collect.testing.features.CollectionFeature;\n", "import com.google.common.collect.testing.features.CollectionSize;\n", "import java.lang.reflect.Method;\n", "import java.util.Spliterator;\n", "\n", "/**\n", " * A generic JUnit test which tests {@code spliterator} operations on a collection.\n", " * Can't be invoked directly; please see\n", " * {@link com.google.common.collect.testing.CollectionTestSuiteBuilder}.\n", " *\n", " * @author Louis Wasserman\n", " */\n", "@GwtCompatible(emulated = true)\n", "public class CollectionSpliteratorTester<E> extends AbstractCollectionTester<E> {\n", "\n", "  @CollectionFeature.Require(absent = KNOWN_ORDER)\n", "  public void testSpliteratorUnknownOrder() {\n", "    synchronized (collection) {\n", "      SpliteratorTester.of(collection::spliterator).expect(getSampleElements());\n", "    }\n", "  }\n", "\n", "  @CollectionFeature.Require(KNOWN_ORDER)\n", "  public void testSpliteratorKnownOrder() {\n", "    synchronized (collection) {\n", "      SpliteratorTester.of(collection::spliterator).expect(getOrderedElements()).inOrder();\n", "    }\n", "  }\n", "\n", "  @CollectionFeature.Require(ALLOWS_NULL_VALUES)\n", "  @CollectionSize.Require(absent = ZERO)\n", "  public void testSpliteratorNullable() {\n", "    initCollectionWithNullElement();\n", "    synchronized (collection) { // for Collections.synchronized\n", "      assertFalse(collection.spliterator().hasCharacteristics(Spliterator.NONNULL));\n", "    }\n", "  }\n", "\n", "  @CollectionFeature.Require(SUPPORTS_ADD)\n", "  public void testSpliteratorNotImmutable_CollectionAllowsAdd() {\n", "    // If add is supported, verify that IMMUTABLE is not reported.\n", "    synchronized (collection) { // for Collections.synchronized\n", "      assertFalse(collection.spliterator().hasCharacteristics(Spliterator.IMMUTABLE));\n", "    }\n", "  }\n", "\n", "  @CollectionFeature.Require(SUPPORTS_REMOVE)\n", "  public void testSpliteratorNotImmutable_CollectionAllowsRemove() {\n", "    // If remove is supported, verify that IMMUTABLE is not reported.\n", "    synchronized (collection) { // for Collections.synchronized\n", "      assertFalse(collection.spliterator().hasCharacteristics(Spliterator.IMMUTABLE));\n", "    }\n", "  }\n", "\n", "  @GwtIncompatible // reflection\n", "  public static Method getSpliteratorNotImmutableCollectionAllowsAddMethod() {\n", "    return Helpers.getMethod(\n", "        CollectionSpliteratorTester.class, \"testSpliteratorNotImmutable_CollectionAllowsAdd\");\n", "  }\n", "\n", "  @GwtIncompatible // reflection\n", "  public static Method getSpliteratorNotImmutableCollectionAllowsRemoveMethod() {\n", "    return Helpers.getMethod(\n", "        CollectionSpliteratorTester.class, \"testSpliteratorNotImmutable_CollectionAllowsRemove\");\n", "  }\n", "}\n"]}, "removed": {}, "added_lines": {"1": [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 58, 59, 60, 61, 62, 63, 64, 65, 66, 67, 68, 69, 70, 71, 72, 73, 74, 75, 76, 77, 78, 79, 80, 81, 82, 83, 84, 85, 86, 87, 88, 89, 90, 91, 92, 93, 94, 95]}, "removed_lines": {}}, {"38": "guava-testlib/src/com/google/common/collect/testing/testers/CollectionStreamTester.java", "added": {"1": ["/*\n", " * Copyright (C) 2013 The Guava Authors\n", " *\n", " * Licensed under the Apache License, Version 2.0 (the \"License\");\n", " * you may not use this file except in compliance with the License.\n", " * You may obtain a copy of the License at\n", " *\n", " * http://www.apache.org/licenses/LICENSE-2.0\n", " *\n", " * Unless required by applicable law or agreed to in writing, software\n", " * distributed under the License is distributed on an \"AS IS\" BASIS,\n", " * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n", " * See the License for the specific language governing permissions and\n", " * limitations under the License.\n", " */\n", "\n", "package com.google.common.collect.testing.testers;\n", "\n", "import static com.google.common.collect.testing.features.CollectionFeature.KNOWN_ORDER;\n", "\n", "import com.google.common.annotations.GwtCompatible;\n", "import com.google.common.collect.testing.AbstractCollectionTester;\n", "import com.google.common.collect.testing.Helpers;\n", "import com.google.common.collect.testing.features.CollectionFeature;\n", "import java.util.Arrays;\n", "\n", "/**\n", " * A generic JUnit test which tests {@code stream} operations on a collection.\n", " * Can't be invoked directly; please see\n", " * {@link com.google.common.collect.testing.CollectionTestSuiteBuilder}.\n", " *\n", " * @author Louis Wasserman\n", " */\n", "@GwtCompatible\n", "public class CollectionStreamTester<E> extends AbstractCollectionTester<E> {\n", "  /*\n", "   * We're not really testing the implementation of Stream, only that we're getting a Stream\n", "   * that corresponds to the expected elements.\n", "   */\n", "\n", "  @CollectionFeature.Require(absent = KNOWN_ORDER)\n", "  public void testStreamToArrayUnknownOrder() {\n", "    synchronized (collection) { // to allow Collections.synchronized* tests to pass\n", "      Helpers.assertEqualIgnoringOrder(\n", "          getSampleElements(), Arrays.asList(collection.stream().toArray()));\n", "    }\n", "  }\n", "\n", "  @CollectionFeature.Require(KNOWN_ORDER)\n", "  public void testStreamToArrayKnownOrder() {\n", "    synchronized (collection) { // to allow Collections.synchronized* tests to pass\n", "      assertEquals(getOrderedElements(), Arrays.asList(collection.stream().toArray()));\n", "    }\n", "  }\n", "\n", "  public void testStreamCount() {\n", "    synchronized (collection) { // to allow Collections.synchronized* tests to pass\n", "      assertEquals(getNumElements(), collection.stream().count());\n", "    }\n", "  }\n", "}\n"]}, "removed": {}, "added_lines": {"1": [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 58, 59, 60, 61]}, "removed_lines": {}}, {"39": "guava-testlib/src/com/google/common/collect/testing/testers/ListReplaceAllTester.java", "added": {"1": ["/*\n", " * Copyright (C) 2015 The Guava Authors\n", " *\n", " * Licensed under the Apache License, Version 2.0 (the \"License\");\n", " * you may not use this file except in compliance with the License.\n", " * You may obtain a copy of the License at\n", " *\n", " * http://www.apache.org/licenses/LICENSE-2.0\n", " *\n", " * Unless required by applicable law or agreed to in writing, software\n", " * distributed under the License is distributed on an \"AS IS\" BASIS,\n", " * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n", " * See the License for the specific language governing permissions and\n", " * limitations under the License.\n", " */\n", "\n", "package com.google.common.collect.testing.testers;\n", "\n", "import static com.google.common.collect.testing.features.CollectionSize.ZERO;\n", "import static com.google.common.collect.testing.features.ListFeature.SUPPORTS_SET;\n", "\n", "import com.google.common.annotations.GwtCompatible;\n", "import com.google.common.collect.testing.features.CollectionSize;\n", "import com.google.common.collect.testing.features.ListFeature;\n", "import java.util.Collections;\n", "import java.util.List;\n", "\n", "/**\n", " * A generic JUnit test which tests {@link List#replaceAll}. Can't be\n", " * invoked directly; please see\n", " * {@link com.google.common.collect.testing.ListTestSuiteBuilder}.\n", " *\n", " * @author Louis Wasserman\n", " */\n", "@GwtCompatible\n", "public class ListReplaceAllTester<E> extends AbstractListTester<E> {\n", "  @ListFeature.Require(SUPPORTS_SET)\n", "  public void testReplaceAll() {\n", "    getList().replaceAll(e -> samples.e3());\n", "    expectContents(Collections.nCopies(getNumElements(), samples.e3()));\n", "  }\n", "\n", "  @ListFeature.Require(SUPPORTS_SET)\n", "  public void testReplaceAll_changesSome() {\n", "    getList().replaceAll(e -> (e.equals(samples.e0())) ? samples.e3() : e);\n", "    E[] expected = createSamplesArray();\n", "    for (int i = 0; i < expected.length; i++) {\n", "      if (expected[i].equals(samples.e0())) {\n", "        expected[i] = samples.e3();\n", "      }\n", "    }\n", "    expectContents(expected);\n", "  }\n", "\n", "  @CollectionSize.Require(absent = ZERO)\n", "  @ListFeature.Require(absent = SUPPORTS_SET)\n", "  public void testReplaceAll_unsupported() {\n", "    try {\n", "      getList().replaceAll(e -> e);\n", "      fail(\"replaceAll() should throw UnsupportedOperationException\");\n", "    } catch (UnsupportedOperationException expected) {\n", "    }\n", "    expectUnchanged();\n", "  }\n", "}\n"]}, "removed": {}, "added_lines": {"1": [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 58, 59, 60, 61, 62, 63, 64, 65]}, "removed_lines": {}}, {"40": "guava-testlib/src/com/google/common/collect/testing/testers/MapComputeIfAbsentTester.java", "added": {"1": ["/*\n", " * Copyright (C) 2015 The Guava Authors\n", " *\n", " * Licensed under the Apache License, Version 2.0 (the \"License\");\n", " * you may not use this file except in compliance with the License.\n", " * You may obtain a copy of the License at\n", " *\n", " * http://www.apache.org/licenses/LICENSE-2.0\n", " *\n", " * Unless required by applicable law or agreed to in writing, software\n", " * distributed under the License is distributed on an \"AS IS\" BASIS,\n", " * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n", " * See the License for the specific language governing permissions and\n", " * limitations under the License.\n", " */\n", "\n", "package com.google.common.collect.testing.testers;\n", "\n", "import static com.google.common.collect.testing.features.CollectionSize.ZERO;\n", "import static com.google.common.collect.testing.features.MapFeature.ALLOWS_NULL_KEYS;\n", "import static com.google.common.collect.testing.features.MapFeature.ALLOWS_NULL_VALUES;\n", "import static com.google.common.collect.testing.features.MapFeature.SUPPORTS_PUT;\n", "\n", "import com.google.common.annotations.GwtCompatible;\n", "import com.google.common.collect.testing.AbstractMapTester;\n", "import com.google.common.collect.testing.features.CollectionSize;\n", "import com.google.common.collect.testing.features.MapFeature;\n", "import java.util.Map;\n", "import junit.framework.AssertionFailedError;\n", "\n", "/**\n", " * A generic JUnit test which tests {@link Map#computeIfAbsent}. Can't be\n", " * invoked directly; please see\n", " * {@link com.google.common.collect.testing.MapTestSuiteBuilder}.\n", " * \n", " * @author Louis Wasserman\n", " */\n", "@GwtCompatible\n", "public class MapComputeIfAbsentTester<K, V> extends AbstractMapTester<K, V> {\n", "\n", "  @MapFeature.Require(SUPPORTS_PUT)\n", "  public void testComputeIfAbsent_supportedAbsent() {\n", "    assertEquals(\"computeIfAbsent(notPresent, function) should return new value\",\n", "        v3(),\n", "        getMap().computeIfAbsent(k3(), k -> {\n", "          assertEquals(k3(), k);\n", "          return v3();\n", "        }));\n", "    expectAdded(e3());\n", "  }\n", "  \n", "  @MapFeature.Require(SUPPORTS_PUT)\n", "  @CollectionSize.Require(absent = ZERO)\n", "  public void testComputeIfAbsent_supportedPresent() {\n", "    assertEquals(\"computeIfAbsent(present, function) should return existing value\", \n", "        v0(), getMap().computeIfAbsent(k0(), k -> { throw new AssertionFailedError(); }));\n", "    expectUnchanged();\n", "  }\n", "  \n", "  @MapFeature.Require(SUPPORTS_PUT)\n", "  public void testComputeIfAbsent_functionReturnsNullNotInserted() {\n", "    assertNull(\"computeIfAbsent(absent, returnsNull) should return null\", \n", "        getMap().computeIfAbsent(k3(), k -> { \n", "          assertEquals(k3(), k);\n", "          return null;\n", "        }));\n", "    expectUnchanged();\n", "  }\n", "\n", "  @MapFeature.Require({SUPPORTS_PUT, ALLOWS_NULL_VALUES})\n", "  @CollectionSize.Require(absent = ZERO)\n", "  public void testComputeIfAbsent_nullTreatedAsAbsent() {\n", "    initMapWithNullValue();\n", "    assertEquals(\"computeIfAbsent(presentAssignedToNull, function) should return newValue\",\n", "        getValueForNullKey(),\n", "        getMap().computeIfAbsent(getKeyForNullValue(), k -> {\n", "          assertEquals(getKeyForNullValue(), k);\n", "          return getValueForNullKey();\n", "        }));\n", "    expectReplacement(entry(getKeyForNullValue(), getValueForNullKey()));\n", "  }\n", "\n", "  @MapFeature.Require({SUPPORTS_PUT, ALLOWS_NULL_KEYS})\n", "  public void testComputeIfAbsent_nullKeySupported() {\n", "    getMap().computeIfAbsent(null, k -> {\n", "      assertNull(k);\n", "      return v3();\n", "    });\n", "    expectAdded(entry(null, v3()));\n", "  }\n", "\n", "  static class ExpectedException extends RuntimeException {}\n", "\n", "  @MapFeature.Require(SUPPORTS_PUT)\n", "  public void testComputeIfAbsent_functionThrows() {\n", "    try {\n", "      getMap()\n", "          .computeIfAbsent(\n", "              k3(),\n", "              k -> {\n", "                assertEquals(k3(), k);\n", "                throw new ExpectedException();\n", "              });\n", "      fail(\"Expected ExpectedException\");\n", "    } catch (ExpectedException expected) {\n", "    }\n", "    expectUnchanged();\n", "  }\n", "\n", "  @MapFeature.Require(absent = SUPPORTS_PUT)\n", "  public void testComputeIfAbsent_unsupportedAbsent() {\n", "    try {\n", "      getMap().computeIfAbsent(k3(), k -> {\n", "        // allowed to be called\n", "        assertEquals(k3(), k);\n", "        return v3();\n", "      });\n", "      fail(\"computeIfAbsent(notPresent, function) should throw\");\n", "    } catch (UnsupportedOperationException expected) {}\n", "    expectUnchanged();\n", "  }\n", "\n", "  @MapFeature.Require(absent = SUPPORTS_PUT)\n", "  @CollectionSize.Require(absent = ZERO)\n", "  public void testComputeIfAbsent_unsupportedPresentExistingValue() {\n", "    try {\n", "      assertEquals(\n", "          \"computeIfAbsent(present, returnsCurrentValue) should return present or throw\",\n", "          v0(), \n", "          getMap().computeIfAbsent(k0(), k -> {\n", "            assertEquals(k0(), k);\n", "            return v0();\n", "          }));\n", "    } catch (UnsupportedOperationException tolerated) {}\n", "    expectUnchanged();\n", "  }\n", "\n", "  @MapFeature.Require(absent = SUPPORTS_PUT)\n", "  @CollectionSize.Require(absent = ZERO)\n", "  public void testComputeIfAbsent_unsupportedPresentDifferentValue() {\n", "    try {\n", "      assertEquals(\n", "          \"computeIfAbsent(present, returnsDifferentValue) should return present or throw\",\n", "          v0(), getMap().computeIfAbsent(k0(), k -> {\n", "            assertEquals(k0(), k);\n", "            return v3();\n", "          }));\n", "    } catch (UnsupportedOperationException tolerated) {}\n", "    expectUnchanged();\n", "  }\n", "\n", "  @MapFeature.Require(value = SUPPORTS_PUT, absent = ALLOWS_NULL_KEYS)\n", "  public void testComputeIfAbsent_nullKeyUnsupported() {\n", "    try {\n", "      getMap().computeIfAbsent(null, k -> {\n", "        assertNull(k);\n", "        return v3();\n", "      });\n", "      fail(\"computeIfAbsent(null, function) should throw\");\n", "    } catch (NullPointerException expected) {}\n", "    expectUnchanged();\n", "    expectNullKeyMissingWhenNullKeysUnsupported(\n", "        \"Should not contain null key after unsupported computeIfAbsent(null, function)\");\n", "  }\n", "}\n"]}, "removed": {}, "added_lines": {"1": [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 58, 59, 60, 61, 62, 63, 64, 65, 66, 67, 68, 69, 70, 71, 72, 73, 74, 75, 76, 77, 78, 79, 80, 81, 82, 83, 84, 85, 86, 87, 88, 89, 90, 91, 92, 93, 94, 95, 96, 97, 98, 99, 100, 101, 102, 103, 104, 105, 106, 107, 108, 109, 110, 111, 112, 113, 114, 115, 116, 117, 118, 119, 120, 121, 122, 123, 124, 125, 126, 127, 128, 129, 130, 131, 132, 133, 134, 135, 136, 137, 138, 139, 140, 141, 142, 143, 144, 145, 146, 147, 148, 149, 150, 151, 152, 153, 154, 155, 156, 157, 158, 159, 160, 161, 162, 163, 164, 165]}, "removed_lines": {}}, {"41": "guava-testlib/src/com/google/common/collect/testing/testers/MapComputeIfPresentTester.java", "added": {"1": ["/*\n", " * Copyright (C) 2016 The Guava Authors\n", " *\n", " * Licensed under the Apache License, Version 2.0 (the \"License\");\n", " * you may not use this file except in compliance with the License.\n", " * You may obtain a copy of the License at\n", " *\n", " * http://www.apache.org/licenses/LICENSE-2.0\n", " *\n", " * Unless required by applicable law or agreed to in writing, software\n", " * distributed under the License is distributed on an \"AS IS\" BASIS,\n", " * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n", " * See the License for the specific language governing permissions and\n", " * limitations under the License.\n", " */\n", "\n", "package com.google.common.collect.testing.testers;\n", "\n", "import static com.google.common.collect.testing.features.CollectionSize.ZERO;\n", "import static com.google.common.collect.testing.features.MapFeature.ALLOWS_NULL_KEYS;\n", "import static com.google.common.collect.testing.features.MapFeature.ALLOWS_NULL_VALUES;\n", "import static com.google.common.collect.testing.features.MapFeature.SUPPORTS_PUT;\n", "\n", "import com.google.common.annotations.GwtCompatible;\n", "import com.google.common.collect.testing.AbstractMapTester;\n", "import com.google.common.collect.testing.features.CollectionSize;\n", "import com.google.common.collect.testing.features.MapFeature;\n", "import java.util.Map;\n", "import java.util.Map.Entry;\n", "import junit.framework.AssertionFailedError;\n", "\n", "/**\n", " * A generic JUnit test which tests {@link Map#computeIfPresent}. Can't be\n", " * invoked directly; please see\n", " * {@link com.google.common.collect.testing.MapTestSuiteBuilder}.\n", " *\n", " * @author Louis Wasserman\n", " */\n", "@GwtCompatible\n", "public class MapComputeIfPresentTester<K, V> extends AbstractMapTester<K, V> {\n", "\n", "  @MapFeature.Require(SUPPORTS_PUT)\n", "  public void testComputeIfPresent_supportedAbsent() {\n", "    assertNull(\n", "        \"computeIfPresent(notPresent, function) should return null\",\n", "        getMap()\n", "            .computeIfPresent(\n", "                k3(),\n", "                (k, v) -> {\n", "                  throw new AssertionFailedError();\n", "                }));\n", "    expectUnchanged();\n", "  }\n", "\n", "  @MapFeature.Require(SUPPORTS_PUT)\n", "  @CollectionSize.Require(absent = ZERO)\n", "  public void testComputeIfPresent_supportedPresent() {\n", "    assertEquals(\n", "        \"computeIfPresent(present, function) should return new value\",\n", "        v3(),\n", "        getMap()\n", "            .computeIfPresent(\n", "                k0(),\n", "                (k, v) -> {\n", "                  assertEquals(k0(), k);\n", "                  assertEquals(v0(), v);\n", "                  return v3();\n", "                }));\n", "    expectReplacement(entry(k0(), v3()));\n", "  }\n", "\n", "  @MapFeature.Require(SUPPORTS_PUT)\n", "  @CollectionSize.Require(absent = ZERO)\n", "  public void testComputeIfPresent_functionReturnsNull() {\n", "    assertNull(\n", "        \"computeIfPresent(present, returnsNull) should return null\",\n", "        getMap()\n", "            .computeIfPresent(\n", "                k0(),\n", "                (k, v) -> {\n", "                  assertEquals(k0(), k);\n", "                  assertEquals(v0(), v);\n", "                  return null;\n", "                }));\n", "    expectMissing(e0());\n", "  }\n", "\n", "  @MapFeature.Require({SUPPORTS_PUT, ALLOWS_NULL_VALUES})\n", "  @CollectionSize.Require(absent = ZERO)\n", "  public void testComputeIfPresent_nullTreatedAsAbsent() {\n", "    initMapWithNullValue();\n", "    assertNull(\n", "        \"computeIfPresent(presentAssignedToNull, function) should return null\",\n", "        getMap()\n", "            .computeIfPresent(\n", "                getKeyForNullValue(),\n", "                (k, v) -> {\n", "                  throw new AssertionFailedError();\n", "                }));\n", "    expectReplacement(entry(getKeyForNullValue(), null));\n", "  }\n", "\n", "  static class ExpectedException extends RuntimeException {}\n", "\n", "  @MapFeature.Require(SUPPORTS_PUT)\n", "  @CollectionSize.Require(absent = ZERO)\n", "  public void testComputeIfPresent_functionThrows() {\n", "    try {\n", "      getMap()\n", "          .computeIfPresent(\n", "              k0(),\n", "              (k, v) -> {\n", "                assertEquals(k0(), k);\n", "                assertEquals(v0(), v);\n", "                throw new ExpectedException();\n", "              });\n", "      fail(\"Expected ExpectedException\");\n", "    } catch (ExpectedException expected) {\n", "    }\n", "    expectUnchanged();\n", "  }\n", "\n", "  @MapFeature.Require({SUPPORTS_PUT, ALLOWS_NULL_KEYS})\n", "  @CollectionSize.Require(absent = ZERO)\n", "  public void testComputeIfPresent_nullKeySupportedPresent() {\n", "    initMapWithNullKey();\n", "    assertEquals(\n", "        \"computeIfPresent(null, function) should return new value\",\n", "        v3(),\n", "        getMap()\n", "            .computeIfPresent(\n", "                null,\n", "                (k, v) -> {\n", "                  assertNull(k);\n", "                  assertEquals(getValueForNullKey(), v);\n", "                  return v3();\n", "                }));\n", "\n", "    Entry<K, V>[] expected = createArrayWithNullKey();\n", "    expected[getNullLocation()] = entry(null, v3());\n", "    expectContents(expected);\n", "  }\n", "\n", "  @MapFeature.Require({SUPPORTS_PUT, ALLOWS_NULL_KEYS})\n", "  public void testComputeIfPresent_nullKeySupportedAbsent() {\n", "    assertNull(\n", "        \"computeIfPresent(null, function) should return null\",\n", "        getMap()\n", "            .computeIfPresent(\n", "                null,\n", "                (k, v) -> {\n", "                  throw new AssertionFailedError();\n", "                }));\n", "    expectUnchanged();\n", "  }\n", "\n", "  @MapFeature.Require(absent = SUPPORTS_PUT)\n", "  public void testComputeIfPresent_unsupportedAbsent() {\n", "    try {\n", "      getMap()\n", "          .computeIfPresent(\n", "              k3(),\n", "              (k, v) -> {\n", "                throw new AssertionFailedError();\n", "              });\n", "    } catch (UnsupportedOperationException tolerated) {\n", "    }\n", "    expectUnchanged();\n", "  }\n", "\n", "  @MapFeature.Require(absent = SUPPORTS_PUT)\n", "  @CollectionSize.Require(absent = ZERO)\n", "  public void testComputeIfPresent_unsupportedPresent() {\n", "    try {\n", "      getMap().computeIfPresent(k0(), (k, v) -> v3());\n", "      fail(\"Expected UnsupportedOperationException\");\n", "    } catch (UnsupportedOperationException expected) {\n", "    }\n", "    expectUnchanged();\n", "  }\n", "}\n"]}, "removed": {}, "added_lines": {"1": [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 58, 59, 60, 61, 62, 63, 64, 65, 66, 67, 68, 69, 70, 71, 72, 73, 74, 75, 76, 77, 78, 79, 80, 81, 82, 83, 84, 85, 86, 87, 88, 89, 90, 91, 92, 93, 94, 95, 96, 97, 98, 99, 100, 101, 102, 103, 104, 105, 106, 107, 108, 109, 110, 111, 112, 113, 114, 115, 116, 117, 118, 119, 120, 121, 122, 123, 124, 125, 126, 127, 128, 129, 130, 131, 132, 133, 134, 135, 136, 137, 138, 139, 140, 141, 142, 143, 144, 145, 146, 147, 148, 149, 150, 151, 152, 153, 154, 155, 156, 157, 158, 159, 160, 161, 162, 163, 164, 165, 166, 167, 168, 169, 170, 171, 172, 173, 174, 175, 176, 177, 178, 179, 180, 181]}, "removed_lines": {}}, {"42": "guava-testlib/src/com/google/common/collect/testing/testers/MapComputeTester.java", "added": {"1": ["/*\n", " * Copyright (C) 2015 The Guava Authors\n", " *\n", " * Licensed under the Apache License, Version 2.0 (the \"License\");\n", " * you may not use this file except in compliance with the License.\n", " * You may obtain a copy of the License at\n", " *\n", " * http://www.apache.org/licenses/LICENSE-2.0\n", " *\n", " * Unless required by applicable law or agreed to in writing, software\n", " * distributed under the License is distributed on an \"AS IS\" BASIS,\n", " * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n", " * See the License for the specific language governing permissions and\n", " * limitations under the License.\n", " */\n", "\n", "package com.google.common.collect.testing.testers;\n", "\n", "import static com.google.common.collect.testing.features.CollectionSize.ZERO;\n", "import static com.google.common.collect.testing.features.MapFeature.ALLOWS_NULL_KEYS;\n", "import static com.google.common.collect.testing.features.MapFeature.ALLOWS_NULL_VALUES;\n", "import static com.google.common.collect.testing.features.MapFeature.SUPPORTS_PUT;\n", "import static com.google.common.collect.testing.features.MapFeature.SUPPORTS_REMOVE;\n", "\n", "import com.google.common.annotations.GwtCompatible;\n", "import com.google.common.collect.testing.AbstractMapTester;\n", "import com.google.common.collect.testing.features.CollectionSize;\n", "import com.google.common.collect.testing.features.MapFeature;\n", "import java.util.Map;\n", "\n", "/**\n", " * A generic JUnit test which tests {@link Map#compute}. Can't be\n", " * invoked directly; please see\n", " * {@link com.google.common.collect.testing.MapTestSuiteBuilder}.\n", " *\n", " * @author Louis Wasserman\n", " */\n", "@GwtCompatible\n", "public class MapComputeTester<K, V> extends AbstractMapTester<K, V> {\n", "  @MapFeature.Require({SUPPORTS_PUT, SUPPORTS_REMOVE})\n", "  public void testCompute_absentToPresent() {\n", "    assertEquals(\n", "        \"Map.compute(absent, functionReturningValue) should return value\",\n", "        v3(),\n", "        getMap()\n", "            .compute(\n", "                k3(),\n", "                (k, v)\n", "                    -> {\n", "                      assertEquals(k3(), k);\n", "                      assertNull(v);\n", "                      return v3();\n", "                    }));\n", "    expectAdded(e3());\n", "    assertEquals(getNumElements() + 1, getMap().size());\n", "  }\n", "\n", "  @MapFeature.Require({SUPPORTS_PUT, SUPPORTS_REMOVE})\n", "  public void testCompute_absentToAbsent() {\n", "    assertNull(\n", "        \"Map.compute(absent, functionReturningNull) should return null\",\n", "        getMap()\n", "            .compute(\n", "                k3(),\n", "                (k, v)\n", "                    -> {\n", "                      assertEquals(k3(), k);\n", "                      assertNull(v);\n", "                      return null;\n", "                    }));\n", "    expectUnchanged();\n", "    assertEquals(getNumElements(), getMap().size());\n", "  }\n", "\n", "  @MapFeature.Require({SUPPORTS_PUT, SUPPORTS_REMOVE})\n", "  @CollectionSize.Require(absent = ZERO)\n", "  public void testCompute_presentToPresent() {\n", "    assertEquals(\n", "        \"Map.compute(present, functionReturningValue) should return new value\",\n", "        v3(),\n", "        getMap()\n", "            .compute(\n", "                k0(),\n", "                (k, v)\n", "                    -> {\n", "                      assertEquals(k0(), k);\n", "                      assertEquals(v0(), v);\n", "                      return v3();\n", "                    }));\n", "    expectReplacement(entry(k0(), v3()));\n", "    assertEquals(getNumElements(), getMap().size());\n", "  }\n", "\n", "  @MapFeature.Require({SUPPORTS_PUT, SUPPORTS_REMOVE})\n", "  @CollectionSize.Require(absent = ZERO)\n", "  public void testCompute_presentToAbsent() {\n", "    assertNull(\n", "        \"Map.compute(present, functionReturningNull) should return null\",\n", "        getMap()\n", "            .compute(\n", "                k0(),\n", "                (k, v)\n", "                    -> {\n", "                      assertEquals(k0(), k);\n", "                      assertEquals(v0(), v);\n", "                      return null;\n", "                    }));\n", "    expectMissing(e0());\n", "    expectMissingKeys(k0());\n", "    assertEquals(getNumElements() - 1, getMap().size());\n", "  }\n", "\n", "  @MapFeature.Require({SUPPORTS_PUT, SUPPORTS_REMOVE, ALLOWS_NULL_VALUES})\n", "  @CollectionSize.Require(absent = ZERO)\n", "  public void testCompute_presentNullToPresentNonnull() {\n", "    initMapWithNullValue();\n", "    V value = getValueForNullKey();\n", "    assertEquals(\n", "        \"Map.compute(presentMappedToNull, functionReturningValue) should return new value\",\n", "        value,\n", "        getMap()\n", "            .compute(\n", "                getKeyForNullValue(),\n", "                (k, v)\n", "                    -> {\n", "                      assertEquals(getKeyForNullValue(), k);\n", "                      assertNull(v);\n", "                      return value;\n", "                    }));\n", "    expectReplacement(entry(getKeyForNullValue(), value));\n", "    assertEquals(getNumElements(), getMap().size());\n", "  }\n", "\n", "  @MapFeature.Require({SUPPORTS_PUT, SUPPORTS_REMOVE, ALLOWS_NULL_VALUES})\n", "  @CollectionSize.Require(absent = ZERO)\n", "  public void testCompute_presentNullToNull() {\n", "    // The spec is somewhat ambiguous about this case, but the actual default implementation\n", "    // in Map will remove a present null.\n", "    initMapWithNullValue();\n", "    assertNull(\n", "        \"Map.compute(presentMappedToNull, functionReturningNull) should return null\",\n", "        getMap()\n", "            .compute(\n", "                getKeyForNullValue(),\n", "                (k, v)\n", "                    -> {\n", "                      assertEquals(getKeyForNullValue(), k);\n", "                      assertNull(v);\n", "                      return null;\n", "                    }));\n", "    expectMissingKeys(getKeyForNullValue());\n", "    assertEquals(getNumElements() - 1, getMap().size());\n", "  }\n", "\n", "  @MapFeature.Require({SUPPORTS_PUT, SUPPORTS_REMOVE, ALLOWS_NULL_KEYS})\n", "  @CollectionSize.Require(absent = ZERO)\n", "  public void testCompute_nullKeyPresentToPresent() {\n", "    initMapWithNullKey();\n", "    assertEquals(\n", "        \"Map.compute(present, functionReturningValue) should return new value\",\n", "        v3(),\n", "        getMap()\n", "            .compute(\n", "                null,\n", "                (k, v)\n", "                    -> {\n", "                      assertNull(k);\n", "                      assertEquals(getValueForNullKey(), v);\n", "                      return v3();\n", "                    }));\n", "    assertEquals(getNumElements(), getMap().size());\n", "  }\n", "\n", "  static class ExpectedException extends RuntimeException {}\n", "\n", "  @MapFeature.Require({SUPPORTS_PUT, SUPPORTS_REMOVE})\n", "  @CollectionSize.Require(absent = ZERO)\n", "  public void testCompute_presentFunctionThrows() {\n", "    try {\n", "      getMap()\n", "          .compute(\n", "              k0(),\n", "              (k, v) -> {\n", "                assertEquals(k0(), k);\n", "                assertEquals(v0(), v);\n", "                throw new ExpectedException();\n", "              });\n", "      fail(\"Expected ExpectedException\");\n", "    } catch (ExpectedException expected) {\n", "    }\n", "    expectUnchanged();\n", "  }\n", "\n", "  @MapFeature.Require({SUPPORTS_PUT, SUPPORTS_REMOVE})\n", "  public void testCompute_absentFunctionThrows() {\n", "    try {\n", "      getMap()\n", "          .compute(\n", "              k3(),\n", "              (k, v) -> {\n", "                assertEquals(k3(), k);\n", "                assertNull(v);\n", "                throw new ExpectedException();\n", "              });\n", "      fail(\"Expected ExpectedException\");\n", "    } catch (ExpectedException expected) {\n", "    }\n", "    expectUnchanged();\n", "  }\n", "}\n"]}, "removed": {}, "added_lines": {"1": [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 58, 59, 60, 61, 62, 63, 64, 65, 66, 67, 68, 69, 70, 71, 72, 73, 74, 75, 76, 77, 78, 79, 80, 81, 82, 83, 84, 85, 86, 87, 88, 89, 90, 91, 92, 93, 94, 95, 96, 97, 98, 99, 100, 101, 102, 103, 104, 105, 106, 107, 108, 109, 110, 111, 112, 113, 114, 115, 116, 117, 118, 119, 120, 121, 122, 123, 124, 125, 126, 127, 128, 129, 130, 131, 132, 133, 134, 135, 136, 137, 138, 139, 140, 141, 142, 143, 144, 145, 146, 147, 148, 149, 150, 151, 152, 153, 154, 155, 156, 157, 158, 159, 160, 161, 162, 163, 164, 165, 166, 167, 168, 169, 170, 171, 172, 173, 174, 175, 176, 177, 178, 179, 180, 181, 182, 183, 184, 185, 186, 187, 188, 189, 190, 191, 192, 193, 194, 195, 196, 197, 198, 199, 200, 201, 202, 203, 204, 205, 206, 207, 208, 209, 210]}, "removed_lines": {}}, {"43": "guava-testlib/src/com/google/common/collect/testing/testers/MapForEachTester.java", "added": {"1": ["/*\n", " * Copyright (C) 2015 The Guava Authors\n", " *\n", " * Licensed under the Apache License, Version 2.0 (the \"License\");\n", " * you may not use this file except in compliance with the License.\n", " * You may obtain a copy of the License at\n", " *\n", " * http://www.apache.org/licenses/LICENSE-2.0\n", " *\n", " * Unless required by applicable law or agreed to in writing, software\n", " * distributed under the License is distributed on an \"AS IS\" BASIS,\n", " * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n", " * See the License for the specific language governing permissions and\n", " * limitations under the License.\n", " */\n", "\n", "package com.google.common.collect.testing.testers;\n", "\n", "import static com.google.common.collect.testing.features.CollectionFeature.KNOWN_ORDER;\n", "import static com.google.common.collect.testing.features.CollectionSize.ZERO;\n", "import static com.google.common.collect.testing.features.MapFeature.ALLOWS_NULL_KEYS;\n", "import static com.google.common.collect.testing.features.MapFeature.ALLOWS_NULL_VALUES;\n", "\n", "import com.google.common.annotations.GwtCompatible;\n", "import com.google.common.collect.testing.AbstractMapTester;\n", "import com.google.common.collect.testing.Helpers;\n", "import com.google.common.collect.testing.features.CollectionFeature;\n", "import com.google.common.collect.testing.features.CollectionSize;\n", "import com.google.common.collect.testing.features.MapFeature;\n", "import java.util.ArrayList;\n", "import java.util.Arrays;\n", "import java.util.List;\n", "import java.util.Map;\n", "import java.util.Map.Entry;\n", "\n", "/**\n", " * A generic JUnit test which tests {@link Map#forEach}. Can't be\n", " * invoked directly; please see\n", " * {@link com.google.common.collect.testing.MapTestSuiteBuilder}.\n", " *\n", " * @author Louis Wasserman\n", " */\n", "@GwtCompatible\n", "public class MapForEachTester<K, V> extends AbstractMapTester<K, V> {\n", "  @CollectionFeature.Require(KNOWN_ORDER)\n", "  public void testForEachKnownOrder() {\n", "    List<Entry<K, V>> entries = new ArrayList<>();\n", "    getMap().forEach((k, v) -> entries.add(entry(k, v)));\n", "    assertEquals(getOrderedElements(), entries);\n", "  }\n", "  \n", "  @CollectionFeature.Require(absent = KNOWN_ORDER)\n", "  public void testForEachUnknownOrder() {\n", "    List<Entry<K, V>> entries = new ArrayList<>();\n", "    getMap().forEach((k, v) -> entries.add(entry(k, v)));\n", "    Helpers.assertEqualIgnoringOrder(getSampleEntries(), entries);\n", "  }\n", "  \n", "  @MapFeature.Require(ALLOWS_NULL_KEYS)\n", "  @CollectionSize.Require(absent = ZERO)\n", "  public void testForEach_nullKeys() {\n", "    initMapWithNullKey();\n", "    List<Entry<K, V>> expectedEntries = Arrays.asList(createArrayWithNullKey());\n", "    List<Entry<K, V>> entries = new ArrayList<>();\n", "    getMap().forEach((k, v) -> entries.add(entry(k, v)));\n", "    Helpers.assertEqualIgnoringOrder(expectedEntries, entries);\n", "  }\n", "  \n", "  @MapFeature.Require(ALLOWS_NULL_VALUES)\n", "  @CollectionSize.Require(absent = ZERO)\n", "  public void testForEach_nullValues() {\n", "    initMapWithNullValue();\n", "    List<Entry<K, V>> expectedEntries = Arrays.asList(createArrayWithNullValue());\n", "    List<Entry<K, V>> entries = new ArrayList<>();\n", "    getMap().forEach((k, v) -> entries.add(entry(k, v)));\n", "    Helpers.assertEqualIgnoringOrder(expectedEntries, entries);\n", "  }\n", "}\n", "\n"]}, "removed": {}, "added_lines": {"1": [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 58, 59, 60, 61, 62, 63, 64, 65, 66, 67, 68, 69, 70, 71, 72, 73, 74, 75, 76, 77, 78, 79]}, "removed_lines": {}}, {"44": "guava-testlib/src/com/google/common/collect/testing/testers/MapGetOrDefaultTester.java", "added": {"1": ["/*\n", " * Copyright (C) 2015 The Guava Authors\n", " *\n", " * Licensed under the Apache License, Version 2.0 (the \"License\");\n", " * you may not use this file except in compliance with the License.\n", " * You may obtain a copy of the License at\n", " *\n", " * http://www.apache.org/licenses/LICENSE-2.0\n", " *\n", " * Unless required by applicable law or agreed to in writing, software\n", " * distributed under the License is distributed on an \"AS IS\" BASIS,\n", " * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n", " * See the License for the specific language governing permissions and\n", " * limitations under the License.\n", " */\n", "\n", "package com.google.common.collect.testing.testers;\n", "\n", "import static com.google.common.collect.testing.features.CollectionSize.ZERO;\n", "import static com.google.common.collect.testing.features.MapFeature.ALLOWS_NULL_KEYS;\n", "import static com.google.common.collect.testing.features.MapFeature.ALLOWS_NULL_KEY_QUERIES;\n", "import static com.google.common.collect.testing.features.MapFeature.ALLOWS_NULL_VALUES;\n", "\n", "import com.google.common.annotations.GwtCompatible;\n", "import com.google.common.collect.testing.AbstractMapTester;\n", "import com.google.common.collect.testing.WrongType;\n", "import com.google.common.collect.testing.features.CollectionSize;\n", "import com.google.common.collect.testing.features.MapFeature;\n", "import java.util.Map;\n", "\n", "/**\n", " * A generic JUnit test which tests {@link Map#getOrDefault}. Can't be\n", " * invoked directly; please see\n", " * {@link com.google.common.collect.testing.MapTestSuiteBuilder}.\n", " *\n", " * @author Louis Wasserman\n", " */\n", "@GwtCompatible\n", "public class MapGetOrDefaultTester<K, V> extends AbstractMapTester<K, V> {\n", "  @CollectionSize.Require(absent = ZERO)\n", "  public void testGetOrDefault_present() {\n", "    assertEquals(\"getOrDefault(present, def) should return the associated value\",\n", "        v0(), getMap().getOrDefault(k0(), v3()));\n", "  }\n", "  \n", "  @CollectionSize.Require(absent = ZERO)\n", "  public void testGetOrDefault_presentNullDefault() {\n", "    assertEquals(\"getOrDefault(present, null) should return the associated value\",\n", "        v0(), getMap().getOrDefault(k0(), null));\n", "  }\n", "\n", "  public void testGetOrDefault_absent() {\n", "    assertEquals(\"getOrDefault(absent, def) should return the default value\",\n", "        v3(), getMap().getOrDefault(k3(), v3()));\n", "  }\n", "\n", "  public void testGetOrDefault_absentNullDefault() {\n", "    assertNull(\"getOrDefault(absent, null) should return null\",\n", "        getMap().getOrDefault(k3(), null));\n", "  }\n", "\n", "  @MapFeature.Require(ALLOWS_NULL_KEY_QUERIES)\n", "  public void testGetOrDefault_absentNull() {\n", "    assertEquals(\"getOrDefault(null, def) should return the default value\",\n", "        v3(), getMap().getOrDefault(null, v3()));\n", "  }\n", "\n", "  @MapFeature.Require(absent = ALLOWS_NULL_KEY_QUERIES)\n", "  public void testGetOrDefault_nullAbsentAndUnsupported() {\n", "    try {\n", "      assertEquals(\"getOrDefault(null, def) should return default or throw\",\n", "          v3(), getMap().getOrDefault(null, v3()));\n", "    } catch (NullPointerException tolerated) {\n", "    }\n", "  }\n", "\n", "  @MapFeature.Require(ALLOWS_NULL_KEYS)\n", "  @CollectionSize.Require(absent = ZERO)\n", "  public void testGetOrDefault_nonNullWhenNullContained() {\n", "    initMapWithNullKey();\n", "    assertEquals(\"getOrDefault(absent, default) should return default\", \n", "        v3(), getMap().getOrDefault(k3(), v3()));\n", "  }\n", "\n", "  @MapFeature.Require(ALLOWS_NULL_KEYS)\n", "  @CollectionSize.Require(absent = ZERO)\n", "  public void testGetOrDefault_presentNull() {\n", "    initMapWithNullKey();\n", "    assertEquals(\"getOrDefault(null, default) should return the associated value\",\n", "        getValueForNullKey(), getMap().getOrDefault(null, v3()));\n", "  }\n", "  \n", "  @MapFeature.Require(ALLOWS_NULL_VALUES)\n", "  @CollectionSize.Require(absent = ZERO)\n", "  public void testGetOrDefault_presentMappedToNull() {\n", "    initMapWithNullValue();\n", "    assertNull(\"getOrDefault(mappedToNull, default) should return null\",\n", "        getMap().getOrDefault(getKeyForNullValue(), v3()));\n", "  }\n", "\n", "  public void testGet_wrongType() {\n", "    try {\n", "      assertEquals(\"getOrDefault(wrongType, default) should return default or throw\",\n", "          v3(), getMap().getOrDefault(WrongType.VALUE, v3()));\n", "    } catch (ClassCastException tolerated) {\n", "    }\n", "  }\n", "}\n"]}, "removed": {}, "added_lines": {"1": [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 58, 59, 60, 61, 62, 63, 64, 65, 66, 67, 68, 69, 70, 71, 72, 73, 74, 75, 76, 77, 78, 79, 80, 81, 82, 83, 84, 85, 86, 87, 88, 89, 90, 91, 92, 93, 94, 95, 96, 97, 98, 99, 100, 101, 102, 103, 104, 105, 106, 107, 108]}, "removed_lines": {}}, {"45": "guava-testlib/src/com/google/common/collect/testing/testers/MapMergeTester.java", "added": {"1": ["/*\n", " * Copyright (C) 2016 The Guava Authors\n", " *\n", " * Licensed under the Apache License, Version 2.0 (the \"License\");\n", " * you may not use this file except in compliance with the License.\n", " * You may obtain a copy of the License at\n", " *\n", " * http://www.apache.org/licenses/LICENSE-2.0\n", " *\n", " * Unless required by applicable law or agreed to in writing, software\n", " * distributed under the License is distributed on an \"AS IS\" BASIS,\n", " * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n", " * See the License for the specific language governing permissions and\n", " * limitations under the License.\n", " */\n", "\n", "package com.google.common.collect.testing.testers;\n", "\n", "import static com.google.common.collect.testing.features.CollectionSize.ZERO;\n", "import static com.google.common.collect.testing.features.MapFeature.ALLOWS_NULL_KEYS;\n", "import static com.google.common.collect.testing.features.MapFeature.ALLOWS_NULL_VALUES;\n", "import static com.google.common.collect.testing.features.MapFeature.SUPPORTS_PUT;\n", "import static com.google.common.collect.testing.features.MapFeature.SUPPORTS_REMOVE;\n", "\n", "import com.google.common.annotations.GwtCompatible;\n", "import com.google.common.annotations.GwtIncompatible;\n", "import com.google.common.collect.testing.AbstractMapTester;\n", "import com.google.common.collect.testing.Helpers;\n", "import com.google.common.collect.testing.features.CollectionSize;\n", "import com.google.common.collect.testing.features.MapFeature;\n", "import java.lang.reflect.Method;\n", "import java.util.Map;\n", "import junit.framework.AssertionFailedError;\n", "\n", "/**\n", " * A generic JUnit test which tests {@link Map#merge}. Can't be\n", " * invoked directly; please see\n", " * {@link com.google.common.collect.testing.MapTestSuiteBuilder}.\n", " *\n", " * @author Louis Wasserman\n", " */\n", "@GwtCompatible(emulated = true)\n", "public class MapMergeTester<K, V> extends AbstractMapTester<K, V> {\n", "  @MapFeature.Require(SUPPORTS_PUT)\n", "  public void testAbsent() {\n", "    assertEquals(\n", "        \"Map.merge(absent, value, function) should return value\",\n", "        v3(),\n", "        getMap()\n", "            .merge(\n", "                k3(),\n", "                v3(),\n", "                (oldV, newV) -> {\n", "                  throw new AssertionFailedError(\n", "                      \"Should not call merge function if key was absent\");\n", "                }));\n", "    expectAdded(e3());\n", "  }\n", "\n", "  @MapFeature.Require({SUPPORTS_PUT, ALLOWS_NULL_VALUES})\n", "  @CollectionSize.Require(absent = ZERO)\n", "  public void testMappedToNull() {\n", "    initMapWithNullValue();\n", "    assertEquals(\n", "        \"Map.merge(keyMappedToNull, value, function) should return value\",\n", "        v3(),\n", "        getMap()\n", "            .merge(\n", "                getKeyForNullValue(),\n", "                v3(),\n", "                (oldV, newV) -> {\n", "                  throw new AssertionFailedError(\n", "                      \"Should not call merge function if key was mapped to null\");\n", "                }));\n", "    expectReplacement(entry(getKeyForNullValue(), v3()));\n", "  }\n", "\n", "  @MapFeature.Require({SUPPORTS_PUT, ALLOWS_NULL_KEYS})\n", "  public void testMergeAbsentNullKey() {\n", "    assertEquals(\n", "        \"Map.merge(null, value, function) should return value\",\n", "        v3(),\n", "        getMap()\n", "            .merge(\n", "                null,\n", "                v3(),\n", "                (oldV, newV) -> {\n", "                  throw new AssertionFailedError(\n", "                      \"Should not call merge function if key was absent\");\n", "                }));\n", "    expectAdded(entry(null, v3()));\n", "  }\n", "\n", "  @MapFeature.Require(SUPPORTS_PUT)\n", "  @CollectionSize.Require(absent = ZERO)\n", "  public void testMergePresent() {\n", "    assertEquals(\n", "        \"Map.merge(present, value, function) should return function result\",\n", "        v4(),\n", "        getMap()\n", "            .merge(\n", "                k0(),\n", "                v3(),\n", "                (oldV, newV) -> {\n", "                  assertEquals(v0(), oldV);\n", "                  assertEquals(v3(), newV);\n", "                  return v4();\n", "                }));\n", "    expectReplacement(entry(k0(), v4()));\n", "  }\n", "\n", "  private static class ExpectedException extends RuntimeException {}\n", "\n", "  @MapFeature.Require(SUPPORTS_PUT)\n", "  @CollectionSize.Require(absent = ZERO)\n", "  public void testMergeFunctionThrows() {\n", "    try {\n", "      getMap()\n", "          .merge(\n", "              k0(),\n", "              v3(),\n", "              (oldV, newV) -> {\n", "                assertEquals(v0(), oldV);\n", "                assertEquals(v3(), newV);\n", "                throw new ExpectedException();\n", "              });\n", "      fail(\"Expected ExpectedException\");\n", "    } catch (ExpectedException expected) {\n", "    }\n", "    expectUnchanged();\n", "  }\n", "\n", "  @MapFeature.Require(SUPPORTS_REMOVE)\n", "  @CollectionSize.Require(absent = ZERO)\n", "  public void testMergePresentToNull() {\n", "    assertNull(\n", "        \"Map.merge(present, value, functionReturningNull) should return null\",\n", "        getMap()\n", "            .merge(\n", "                k0(),\n", "                v3(),\n", "                (oldV, newV) -> {\n", "                  assertEquals(v0(), oldV);\n", "                  assertEquals(v3(), newV);\n", "                  return null;\n", "                }));\n", "    expectMissing(e0());\n", "  }\n", "\n", "  public void testMergeNullValue() {\n", "    try {\n", "      getMap()\n", "          .merge(\n", "              k0(),\n", "              null,\n", "              (oldV, newV) -> {\n", "                throw new AssertionFailedError(\"Should not call merge function if value was null\");\n", "              });\n", "      fail(\"Expected NullPointerException or UnsupportedOperationException\");\n", "    } catch (NullPointerException expected) {\n", "    } catch (UnsupportedOperationException expected) {\n", "    }\n", "  }\n", "\n", "  public void testMergeNullFunction() {\n", "    try {\n", "      getMap().merge(k0(), v3(), null);\n", "      fail(\"Expected NullPointerException or UnsupportedOperationException\");\n", "    } catch (NullPointerException expected) {\n", "    } catch (UnsupportedOperationException expected) {\n", "    }\n", "  }\n", "\n", "  @MapFeature.Require(absent = SUPPORTS_PUT)\n", "  public void testMergeUnsupported() {\n", "    try {\n", "      getMap()\n", "          .merge(\n", "              k3(),\n", "              v3(),\n", "              (oldV, newV) -> {\n", "                throw new AssertionFailedError();\n", "              });\n", "      fail(\"Expected UnsupportedOperationException\");\n", "    } catch (UnsupportedOperationException expected) {\n", "    }\n", "  }\n", "\n", "  /**\n", "   * Returns the {@link Method} instance for {@link #testMergeNullValue()} so that tests of {@link\n", "   * Hashtable} can suppress it with {@code FeatureSpecificTestSuiteBuilder.suppressing()}.\n", "   */\n", "  @GwtIncompatible // reflection\n", "  public static Method getMergeNullValueMethod() {\n", "    return Helpers.getMethod(MapMergeTester.class, \"testMergeNullValue\");\n", "  }\n", "}\n"]}, "removed": {}, "added_lines": {"1": [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 58, 59, 60, 61, 62, 63, 64, 65, 66, 67, 68, 69, 70, 71, 72, 73, 74, 75, 76, 77, 78, 79, 80, 81, 82, 83, 84, 85, 86, 87, 88, 89, 90, 91, 92, 93, 94, 95, 96, 97, 98, 99, 100, 101, 102, 103, 104, 105, 106, 107, 108, 109, 110, 111, 112, 113, 114, 115, 116, 117, 118, 119, 120, 121, 122, 123, 124, 125, 126, 127, 128, 129, 130, 131, 132, 133, 134, 135, 136, 137, 138, 139, 140, 141, 142, 143, 144, 145, 146, 147, 148, 149, 150, 151, 152, 153, 154, 155, 156, 157, 158, 159, 160, 161, 162, 163, 164, 165, 166, 167, 168, 169, 170, 171, 172, 173, 174, 175, 176, 177, 178, 179, 180, 181, 182, 183, 184, 185, 186, 187, 188, 189, 190, 191, 192, 193, 194, 195, 196, 197]}, "removed_lines": {}}, {"46": "guava-testlib/src/com/google/common/collect/testing/testers/MapPutIfAbsentTester.java", "added": {"1": ["/*\n", " * Copyright (C) 2015 The Guava Authors\n", " *\n", " * Licensed under the Apache License, Version 2.0 (the \"License\");\n", " * you may not use this file except in compliance with the License.\n", " * You may obtain a copy of the License at\n", " *\n", " * http://www.apache.org/licenses/LICENSE-2.0\n", " *\n", " * Unless required by applicable law or agreed to in writing, software\n", " * distributed under the License is distributed on an \"AS IS\" BASIS,\n", " * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n", " * See the License for the specific language governing permissions and\n", " * limitations under the License.\n", " */\n", "\n", "package com.google.common.collect.testing.testers;\n", "\n", "import static com.google.common.collect.testing.features.CollectionSize.ZERO;\n", "import static com.google.common.collect.testing.features.MapFeature.ALLOWS_NULL_KEYS;\n", "import static com.google.common.collect.testing.features.MapFeature.ALLOWS_NULL_VALUES;\n", "import static com.google.common.collect.testing.features.MapFeature.SUPPORTS_PUT;\n", "\n", "import com.google.common.annotations.GwtCompatible;\n", "import com.google.common.collect.testing.AbstractMapTester;\n", "import com.google.common.collect.testing.features.CollectionSize;\n", "import com.google.common.collect.testing.features.MapFeature;\n", "import java.util.Map;\n", "\n", "/**\n", " * A generic JUnit test which tests {@link Map#putIfAbsent}. Can't be\n", " * invoked directly; please see\n", " * {@link com.google.common.collect.testing.MapTestSuiteBuilder}.\n", " * \n", " * @author Louis Wasserman\n", " */\n", "@GwtCompatible\n", "public class MapPutIfAbsentTester<K, V> extends AbstractMapTester<K, V> {\n", "\n", "  @MapFeature.Require(SUPPORTS_PUT)\n", "  public void testPutIfAbsent_supportedAbsent() {\n", "    assertNull(\"putIfAbsent(notPresent, value) should return null\", \n", "        getMap().putIfAbsent(k3(), v3()));\n", "    expectAdded(e3());\n", "  }\n", "  \n", "  @MapFeature.Require(SUPPORTS_PUT)\n", "  @CollectionSize.Require(absent = ZERO)\n", "  public void testPutIfAbsent_supportedPresent() {\n", "    assertEquals(\"putIfAbsent(present, value) should return existing value\", \n", "        v0(), getMap().putIfAbsent(k0(), v3()));\n", "    expectUnchanged();\n", "  }\n", "\n", "  @MapFeature.Require(absent = SUPPORTS_PUT)\n", "  public void testPutIfAbsent_unsupportedAbsent() {\n", "    try {\n", "      getMap().putIfAbsent(k3(), v3());\n", "      fail(\"putIfAbsent(notPresent, value) should throw\");\n", "    } catch (UnsupportedOperationException expected) {\n", "    }\n", "    expectUnchanged();\n", "    expectMissing(e3());\n", "  }\n", "\n", "  @MapFeature.Require(absent = SUPPORTS_PUT)\n", "  @CollectionSize.Require(absent = ZERO)\n", "  public void testPutIfAbsent_unsupportedPresentExistingValue() {\n", "    try {\n", "      assertEquals(\"putIfAbsent(present, existingValue) should return present or throw\",\n", "          v0(), getMap().putIfAbsent(k0(), v0()));\n", "    } catch (UnsupportedOperationException tolerated) {\n", "    }\n", "    expectUnchanged();\n", "  }\n", "\n", "  @MapFeature.Require(absent = SUPPORTS_PUT)\n", "  @CollectionSize.Require(absent = ZERO)\n", "  public void testPutIfAbsent_unsupportedPresentDifferentValue() {\n", "    try {\n", "      getMap().putIfAbsent(k0(), v3());\n", "    } catch (UnsupportedOperationException tolerated) {\n", "    }\n", "    expectUnchanged();\n", "  }\n", "\n", "  @MapFeature.Require(value = SUPPORTS_PUT, absent = ALLOWS_NULL_KEYS)\n", "  public void testPutIfAbsent_nullKeyUnsupported() {\n", "    try {\n", "      getMap().putIfAbsent(null, v3());\n", "      fail(\"putIfAbsent(null, value) should throw\");\n", "    } catch (NullPointerException expected) {\n", "    }\n", "    expectUnchanged();\n", "    expectNullKeyMissingWhenNullKeysUnsupported(\n", "        \"Should not contain null key after unsupported putIfAbsent(null, value)\");\n", "  }\n", "\n", "  @MapFeature.Require(value = SUPPORTS_PUT, absent = ALLOWS_NULL_VALUES)\n", "  public void testPutIfAbsent_nullValueUnsupported() {\n", "    try {\n", "      getMap().putIfAbsent(k3(), null);\n", "      fail(\"putIfAbsent(key, null) should throw\");\n", "    } catch (NullPointerException expected) {\n", "    }\n", "    expectUnchanged();\n", "    expectNullValueMissingWhenNullValuesUnsupported(\n", "        \"Should not contain null value after unsupported put(key, null)\");\n", "  }\n", "\n", "  @MapFeature.Require(value = SUPPORTS_PUT, absent = ALLOWS_NULL_VALUES)\n", "  @CollectionSize.Require(absent = ZERO)\n", "  public void testPutIfAbsent_putWithNullValueUnsupported() {\n", "    try {\n", "      getMap().putIfAbsent(k0(), null);\n", "    } catch (NullPointerException tolerated) {\n", "    }\n", "    expectUnchanged();\n", "    expectNullValueMissingWhenNullValuesUnsupported(\n", "        \"Should not contain null after unsupported putIfAbsent(present, null)\");\n", "  }\n", "}\n"]}, "removed": {}, "added_lines": {"1": [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 58, 59, 60, 61, 62, 63, 64, 65, 66, 67, 68, 69, 70, 71, 72, 73, 74, 75, 76, 77, 78, 79, 80, 81, 82, 83, 84, 85, 86, 87, 88, 89, 90, 91, 92, 93, 94, 95, 96, 97, 98, 99, 100, 101, 102, 103, 104, 105, 106, 107, 108, 109, 110, 111, 112, 113, 114, 115, 116, 117, 118, 119, 120, 121, 122]}, "removed_lines": {}}, {"47": "guava-testlib/src/com/google/common/collect/testing/testers/MapRemoveEntryTester.java", "added": {"1": ["/*\n", " * Copyright (C) 2015 The Guava Authors\n", " *\n", " * Licensed under the Apache License, Version 2.0 (the \"License\");\n", " * you may not use this file except in compliance with the License.\n", " * You may obtain a copy of the License at\n", " *\n", " * http://www.apache.org/licenses/LICENSE-2.0\n", " *\n", " * Unless required by applicable law or agreed to in writing, software\n", " * distributed under the License is distributed on an \"AS IS\" BASIS,\n", " * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n", " * See the License for the specific language governing permissions and\n", " * limitations under the License.\n", " */\n", "\n", "package com.google.common.collect.testing.testers;\n", "\n", "import static com.google.common.collect.testing.features.CollectionSize.ZERO;\n", "import static com.google.common.collect.testing.features.MapFeature.ALLOWS_NULL_KEY_QUERIES;\n", "import static com.google.common.collect.testing.features.MapFeature.ALLOWS_NULL_VALUE_QUERIES;\n", "import static com.google.common.collect.testing.features.MapFeature.SUPPORTS_REMOVE;\n", "\n", "import com.google.common.annotations.GwtCompatible;\n", "import com.google.common.collect.testing.AbstractMapTester;\n", "import com.google.common.collect.testing.features.CollectionSize;\n", "import com.google.common.collect.testing.features.MapFeature;\n", "import java.util.Map;\n", "\n", "/**\n", " * Tester for {@link Map#remove(Object, Object)}.  Can't be invoked directly; please see \n", " * {@link com.google.common.collect.testing.MapTestSuiteBuilder}. \n", " *\n", " * @author Louis Wasserman\n", " */\n", "@GwtCompatible\n", "public class MapRemoveEntryTester<K, V> extends AbstractMapTester<K, V> {\n", "  @MapFeature.Require(SUPPORTS_REMOVE)\n", "  @CollectionSize.Require(absent = ZERO)\n", "  public void testRemove_supportedPresent() {\n", "    assertTrue(getMap().remove(k0(), v0()));\n", "    expectMissing(e0());\n", "  }\n", "\n", "  @MapFeature.Require(SUPPORTS_REMOVE)\n", "  public void testRemove_supportedPresentKeyWrongValue() {\n", "    assertFalse(getMap().remove(k0(), v3()));\n", "    expectUnchanged();\n", "  }\n", "\n", "  @MapFeature.Require(SUPPORTS_REMOVE)\n", "  public void testRemove_supportedWrongKeyPresentValue() {\n", "    assertFalse(getMap().remove(k3(), v0()));\n", "    expectUnchanged();\n", "  }\n", "\n", "  @MapFeature.Require(SUPPORTS_REMOVE)\n", "  public void testRemove_supportedAbsentKeyAbsentValue() {\n", "    assertFalse(getMap().remove(k3(), v3()));\n", "    expectUnchanged();\n", "  }\n", "  \n", "  @MapFeature.Require(value = SUPPORTS_REMOVE, absent = ALLOWS_NULL_KEY_QUERIES)\n", "  public void testRemove_nullKeyQueriesUnsupported() {\n", "    try {\n", "      assertFalse(getMap().remove(null, v3()));\n", "    } catch (NullPointerException tolerated) {\n", "      // since the operation would be a no-op, the exception is not required\n", "    }\n", "    expectUnchanged();    \n", "  }\n", "  \n", "  @MapFeature.Require(value = SUPPORTS_REMOVE, absent = ALLOWS_NULL_VALUE_QUERIES)\n", "  public void testRemove_nullValueQueriesUnsupported() {\n", "    try {\n", "      assertFalse(getMap().remove(k3(), null));\n", "    } catch (NullPointerException tolerated) {\n", "      // since the operation would be a no-op, the exception is not required\n", "    }\n", "    expectUnchanged();    \n", "  }\n", "  \n", "  @MapFeature.Require(absent = SUPPORTS_REMOVE)\n", "  @CollectionSize.Require(absent = ZERO)\n", "  public void testRemove_unsupportedPresent() {\n", "    try {\n", "      getMap().remove(k0(), v0());\n", "      fail(\"Expected UnsupportedOperationException\");\n", "    } catch (UnsupportedOperationException expected) {}\n", "    expectUnchanged();\n", "  }\n", "  \n", "  @MapFeature.Require(absent = SUPPORTS_REMOVE)\n", "  public void testRemove_unsupportedAbsent() {\n", "    try {\n", "      assertFalse(getMap().remove(k0(), v3()));\n", "    } catch (UnsupportedOperationException tolerated) {\n", "      // since the operation would be a no-op, the exception is not required\n", "    }\n", "    expectUnchanged();\n", "  }\n", "}\n"]}, "removed": {}, "added_lines": {"1": [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 58, 59, 60, 61, 62, 63, 64, 65, 66, 67, 68, 69, 70, 71, 72, 73, 74, 75, 76, 77, 78, 79, 80, 81, 82, 83, 84, 85, 86, 87, 88, 89, 90, 91, 92, 93, 94, 95, 96, 97, 98, 99, 100, 101, 102]}, "removed_lines": {}}, {"48": "guava-testlib/src/com/google/common/collect/testing/testers/MapReplaceAllTester.java", "added": {"1": ["/*\n", " * Copyright (C) 2016 The Guava Authors\n", " *\n", " * Licensed under the Apache License, Version 2.0 (the \"License\");\n", " * you may not use this file except in compliance with the License.\n", " * You may obtain a copy of the License at\n", " *\n", " * http://www.apache.org/licenses/LICENSE-2.0\n", " *\n", " * Unless required by applicable law or agreed to in writing, software\n", " * distributed under the License is distributed on an \"AS IS\" BASIS,\n", " * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n", " * See the License for the specific language governing permissions and\n", " * limitations under the License.\n", " */\n", "\n", "package com.google.common.collect.testing.testers;\n", "\n", "import static com.google.common.collect.testing.features.CollectionFeature.KNOWN_ORDER;\n", "import static com.google.common.collect.testing.features.CollectionSize.ZERO;\n", "import static com.google.common.collect.testing.features.MapFeature.SUPPORTS_PUT;\n", "\n", "import com.google.common.annotations.GwtCompatible;\n", "import com.google.common.collect.testing.AbstractMapTester;\n", "import com.google.common.collect.testing.Helpers;\n", "import com.google.common.collect.testing.SampleElements;\n", "import com.google.common.collect.testing.features.CollectionFeature;\n", "import com.google.common.collect.testing.features.CollectionSize;\n", "import com.google.common.collect.testing.features.MapFeature;\n", "import java.util.ArrayList;\n", "import java.util.List;\n", "import java.util.Map.Entry;\n", "\n", "/**\n", " * A generic JUnit test which tests {@code replaceAll()} operations on a map.\n", " * Can't be invoked directly; please see\n", " * {@link com.google.common.collect.testing.MapTestSuiteBuilder}.\n", " *\n", " * @author Louis Wasserman\n", " */\n", "@GwtCompatible\n", "public class MapReplaceAllTester<K, V> extends AbstractMapTester<K, V> {\n", "  private SampleElements<K> keys() {\n", "    return new SampleElements<K>(k0(), k1(), k2(), k3(), k4());\n", "  }\n", "\n", "  private SampleElements<V> values() {\n", "    return new SampleElements<V>(v0(), v1(), v2(), v3(), v4());\n", "  }\n", "\n", "  @MapFeature.Require(SUPPORTS_PUT)\n", "  public void testReplaceAllRotate() {\n", "    getMap()\n", "        .replaceAll(\n", "            (K k, V v) -> {\n", "              int index = keys().asList().indexOf(k);\n", "              return values().asList().get(index + 1);\n", "            });\n", "    List<Entry<K, V>> expectedEntries = new ArrayList<Entry<K, V>>();\n", "    for (Entry<K, V> entry : getSampleEntries()) {\n", "      int index = keys().asList().indexOf(entry.getKey());\n", "      expectedEntries.add(Helpers.mapEntry(entry.getKey(), values().asList().get(index + 1)));\n", "    }\n", "    expectContents(expectedEntries);\n", "  }\n", "\n", "  @MapFeature.Require(SUPPORTS_PUT)\n", "  @CollectionFeature.Require(KNOWN_ORDER)\n", "  public void testReplaceAllPreservesOrder() {\n", "    getMap()\n", "        .replaceAll(\n", "            (K k, V v) -> {\n", "              int index = keys().asList().indexOf(k);\n", "              return values().asList().get(index + 1);\n", "            });\n", "    List<Entry<K, V>> orderedEntries = getOrderedElements();\n", "    int index = 0;\n", "    for (K key : getMap().keySet()) {\n", "      assertEquals(orderedEntries.get(index).getKey(), key);\n", "      index++;\n", "    }\n", "  }\n", "\n", "  @MapFeature.Require(absent = SUPPORTS_PUT)\n", "  @CollectionSize.Require(absent = ZERO)\n", "  public void testReplaceAll_unsupported() {\n", "    try {\n", "      getMap()\n", "          .replaceAll(\n", "              (K k, V v) -> {\n", "                int index = keys().asList().indexOf(k);\n", "                return values().asList().get(index + 1);\n", "              });\n", "      fail(\n", "          \"replaceAll() should throw UnsupportedOperation if a map does \"\n", "              + \"not support it and is not empty.\");\n", "    } catch (UnsupportedOperationException expected) {\n", "    }\n", "    expectUnchanged();\n", "  }\n", "\n", "  @MapFeature.Require(absent = SUPPORTS_PUT)\n", "  @CollectionSize.Require(ZERO)\n", "  public void testReplaceAll_unsupportedByEmptyCollection() {\n", "    try {\n", "      getMap()\n", "          .replaceAll(\n", "              (K k, V v) -> {\n", "                int index = keys().asList().indexOf(k);\n", "                return values().asList().get(index + 1);\n", "              });\n", "    } catch (UnsupportedOperationException tolerated) {\n", "    }\n", "    expectUnchanged();\n", "  }\n", "\n", "  @MapFeature.Require(absent = SUPPORTS_PUT)\n", "  public void testReplaceAll_unsupportedNoOpFunction() {\n", "    try {\n", "      getMap().replaceAll((K k, V v) -> v);\n", "    } catch (UnsupportedOperationException tolerated) {\n", "    }\n", "    expectUnchanged();\n", "  }\n", "}\n"]}, "removed": {}, "added_lines": {"1": [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 58, 59, 60, 61, 62, 63, 64, 65, 66, 67, 68, 69, 70, 71, 72, 73, 74, 75, 76, 77, 78, 79, 80, 81, 82, 83, 84, 85, 86, 87, 88, 89, 90, 91, 92, 93, 94, 95, 96, 97, 98, 99, 100, 101, 102, 103, 104, 105, 106, 107, 108, 109, 110, 111, 112, 113, 114, 115, 116, 117, 118, 119, 120, 121, 122, 123, 124, 125]}, "removed_lines": {}}, {"49": "guava-testlib/src/com/google/common/collect/testing/testers/MapReplaceEntryTester.java", "added": {"1": ["/*\n", " * Copyright (C) 2015 The Guava Authors\n", " *\n", " * Licensed under the Apache License, Version 2.0 (the \"License\");\n", " * you may not use this file except in compliance with the License.\n", " * You may obtain a copy of the License at\n", " *\n", " * http://www.apache.org/licenses/LICENSE-2.0\n", " *\n", " * Unless required by applicable law or agreed to in writing, software\n", " * distributed under the License is distributed on an \"AS IS\" BASIS,\n", " * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n", " * See the License for the specific language governing permissions and\n", " * limitations under the License.\n", " */\n", "\n", "package com.google.common.collect.testing.testers;\n", "\n", "import static com.google.common.collect.testing.features.CollectionSize.ZERO;\n", "import static com.google.common.collect.testing.features.MapFeature.ALLOWS_NULL_VALUES;\n", "import static com.google.common.collect.testing.features.MapFeature.ALLOWS_NULL_VALUE_QUERIES;\n", "import static com.google.common.collect.testing.features.MapFeature.SUPPORTS_PUT;\n", "\n", "import com.google.common.annotations.GwtCompatible;\n", "import com.google.common.collect.testing.AbstractMapTester;\n", "import com.google.common.collect.testing.features.CollectionSize;\n", "import com.google.common.collect.testing.features.MapFeature;\n", "import java.util.Map;\n", "\n", "/**\n", " * A generic JUnit test which tests {@link Map#replace(Object, Object, Object)}. Can't \n", " * be invoked directly; please see\n", " * {@link com.google.common.collect.testing.MapTestSuiteBuilder}.\n", " * \n", " * @author Louis Wasserman\n", " */\n", "@GwtCompatible\n", "public class MapReplaceEntryTester<K, V> extends AbstractMapTester<K, V> {\n", "  \n", "  @MapFeature.Require(SUPPORTS_PUT)\n", "  @CollectionSize.Require(absent = ZERO)\n", "  public void testReplaceEntry_supportedPresent() {\n", "    try {\n", "      assertTrue(getMap().replace(k0(), v0(), v3()));\n", "      expectReplacement(entry(k0(), v3()));\n", "    } catch (ClassCastException tolerated) { // for ClassToInstanceMap\n", "      expectUnchanged();\n", "    }\n", "  }\n", "  \n", "  @MapFeature.Require(SUPPORTS_PUT)\n", "  @CollectionSize.Require(absent = ZERO)\n", "  public void testReplaceEntry_supportedPresentUnchanged() {\n", "    assertTrue(getMap().replace(k0(), v0(), v0()));\n", "    expectUnchanged();\n", "  }\n", "  \n", "  @MapFeature.Require(SUPPORTS_PUT)\n", "  @CollectionSize.Require(absent = ZERO)\n", "  public void testReplaceEntry_supportedWrongValue() {\n", "    assertFalse(getMap().replace(k0(), v3(), v4()));\n", "    expectUnchanged();\n", "  }\n", "  \n", "  @MapFeature.Require(SUPPORTS_PUT)\n", "  public void testReplaceEntry_supportedAbsentKey() {\n", "    assertFalse(getMap().replace(k3(), v3(), v4()));\n", "    expectUnchanged();\n", "  }\n", "  \n", "  @MapFeature.Require(value = SUPPORTS_PUT, absent = ALLOWS_NULL_VALUES)\n", "  @CollectionSize.Require(absent = ZERO)\n", "  public void testReplaceEntry_presentNullValueUnsupported() {\n", "    try {\n", "      getMap().replace(k0(), v0(), null);\n", "      fail(\"Expected NullPointerException\");\n", "    } catch (NullPointerException expected) {}\n", "    expectUnchanged();\n", "  }\n", "  \n", "  @MapFeature.Require(value = SUPPORTS_PUT, absent = ALLOWS_NULL_VALUE_QUERIES) \n", "  @CollectionSize.Require(absent = ZERO)\n", "  public void testReplaceEntry_wrongValueNullValueUnsupported() {\n", "    try {\n", "      assertFalse(getMap().replace(k0(), v3(), null));\n", "    } catch (NullPointerException tolerated) {\n", "      // the operation would be a no-op, so exceptions are allowed but not required\n", "    }\n", "    expectUnchanged();\n", "  }\n", "  \n", "  @MapFeature.Require(value = SUPPORTS_PUT, absent = ALLOWS_NULL_VALUE_QUERIES) \n", "  public void testReplaceEntry_absentKeyNullValueUnsupported() {\n", "    try {\n", "      assertFalse(getMap().replace(k3(), v3(), null));\n", "    } catch (NullPointerException tolerated) {\n", "      // the operation would be a no-op, so exceptions are allowed but not required\n", "    }\n", "    expectUnchanged();\n", "  }\n", "  \n", "  @MapFeature.Require({SUPPORTS_PUT, ALLOWS_NULL_VALUE_QUERIES})\n", "  public void testReplaceEntry_nullDifferentFromAbsent() {\n", "    assertFalse(getMap().replace(k3(), null, v3()));\n", "    expectUnchanged();\n", "  }\n", "  \n", "  @MapFeature.Require(value = SUPPORTS_PUT, absent = ALLOWS_NULL_VALUE_QUERIES)\n", "  public void testReplaceEntry_expectNullUnsupported() {\n", "    try {\n", "      assertFalse(getMap().replace(k3(), null, v3())); \n", "    } catch (NullPointerException tolerated) {\n", "      // the operation would be a no-op, so exceptions are allowed but not required\n", "    }\n", "    expectUnchanged();\n", "  }\n", "  \n", "  @MapFeature.Require(absent = SUPPORTS_PUT)\n", "  @CollectionSize.Require(absent = ZERO)\n", "  public void testReplaceEntry_unsupportedPresent() {\n", "    try {\n", "      getMap().replace(k0(), v0(), v3());\n", "      fail(\"Expected UnsupportedOperationException\");\n", "    } catch (UnsupportedOperationException expected) {}\n", "    expectUnchanged();\n", "  }\n", "  \n", "  @MapFeature.Require(absent = SUPPORTS_PUT)\n", "  @CollectionSize.Require(absent = ZERO)\n", "  public void testReplaceEntry_unsupportedWrongValue() {\n", "    try {\n", "      getMap().replace(k0(), v3(), v4());\n", "    } catch (UnsupportedOperationException tolerated) {\n", "      // the operation would be a no-op, so exceptions are allowed but not required\n", "    }\n", "    expectUnchanged();\n", "  }\n", "  \n", "  @MapFeature.Require(absent = SUPPORTS_PUT)\n", "  public void testReplaceEntry_unsupportedAbsentKey() {\n", "    try {\n", "      getMap().replace(k3(), v3(), v4());\n", "    } catch (UnsupportedOperationException tolerated) {\n", "      // the operation would be a no-op, so exceptions are allowed but not required\n", "    }\n", "    expectUnchanged();\n", "  }\n", "}\n"]}, "removed": {}, "added_lines": {"1": [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 58, 59, 60, 61, 62, 63, 64, 65, 66, 67, 68, 69, 70, 71, 72, 73, 74, 75, 76, 77, 78, 79, 80, 81, 82, 83, 84, 85, 86, 87, 88, 89, 90, 91, 92, 93, 94, 95, 96, 97, 98, 99, 100, 101, 102, 103, 104, 105, 106, 107, 108, 109, 110, 111, 112, 113, 114, 115, 116, 117, 118, 119, 120, 121, 122, 123, 124, 125, 126, 127, 128, 129, 130, 131, 132, 133, 134, 135, 136, 137, 138, 139, 140, 141, 142, 143, 144, 145, 146, 147, 148]}, "removed_lines": {}}, {"50": "guava-testlib/src/com/google/common/collect/testing/testers/MapReplaceTester.java", "added": {"1": ["/*\n", " * Copyright (C) 2015 The Guava Authors\n", " *\n", " * Licensed under the Apache License, Version 2.0 (the \"License\");\n", " * you may not use this file except in compliance with the License.\n", " * You may obtain a copy of the License at\n", " *\n", " * http://www.apache.org/licenses/LICENSE-2.0\n", " *\n", " * Unless required by applicable law or agreed to in writing, software\n", " * distributed under the License is distributed on an \"AS IS\" BASIS,\n", " * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n", " * See the License for the specific language governing permissions and\n", " * limitations under the License.\n", " */\n", "\n", "package com.google.common.collect.testing.testers;\n", "\n", "import static com.google.common.collect.testing.features.CollectionSize.ZERO;\n", "import static com.google.common.collect.testing.features.MapFeature.ALLOWS_NULL_KEY_QUERIES;\n", "import static com.google.common.collect.testing.features.MapFeature.ALLOWS_NULL_VALUES;\n", "import static com.google.common.collect.testing.features.MapFeature.ALLOWS_NULL_VALUE_QUERIES;\n", "import static com.google.common.collect.testing.features.MapFeature.SUPPORTS_PUT;\n", "\n", "import com.google.common.annotations.GwtCompatible;\n", "import com.google.common.collect.testing.AbstractMapTester;\n", "import com.google.common.collect.testing.features.CollectionSize;\n", "import com.google.common.collect.testing.features.MapFeature;\n", "import java.util.Map;\n", "\n", "/**\n", " * A generic JUnit test which tests {@link Map#replace(Object, Object)}. Can't be\n", " * invoked directly; please see\n", " * {@link com.google.common.collect.testing.ConcurrentMapTestSuiteBuilder}.\n", " * \n", " * @author Louis Wasserman\n", " */\n", "@GwtCompatible\n", "public class MapReplaceTester<K, V> extends AbstractMapTester<K, V> {\n", "\n", "  @MapFeature.Require(SUPPORTS_PUT)\n", "  @CollectionSize.Require(absent = ZERO)\n", "  public void testReplace_supportedPresent() {\n", "    try {\n", "      assertEquals(v0(), getMap().replace(k0(), v3()));\n", "      expectReplacement(entry(k0(), v3()));\n", "    } catch (ClassCastException tolerated) { // for ClassToInstanceMap\n", "      expectUnchanged();\n", "    }\n", "  }\n", "\n", "  @MapFeature.Require(SUPPORTS_PUT)\n", "  @CollectionSize.Require(absent = ZERO)\n", "  public void testReplace_supportedPresentNoChange() {\n", "    assertEquals(v0(), getMap().replace(k0(), v0()));\n", "    expectUnchanged();\n", "  }\n", "\n", "  @MapFeature.Require(SUPPORTS_PUT)\n", "  public void testReplace_supportedAbsent() {\n", "    assertNull(getMap().replace(k3(), v3()));\n", "    expectUnchanged();\n", "  }\n", "  \n", "  @MapFeature.Require(value = SUPPORTS_PUT, absent = ALLOWS_NULL_VALUES)\n", "  @CollectionSize.Require(absent = ZERO)\n", "  public void testReplace_presentNullValueUnsupported() {\n", "    try {\n", "      getMap().replace(k0(), null);\n", "      fail(\"Expected NullPointerException\");\n", "    } catch (NullPointerException expected) {}\n", "    expectUnchanged();\n", "  }\n", "  \n", "  @MapFeature.Require(value = SUPPORTS_PUT, absent = ALLOWS_NULL_VALUE_QUERIES)\n", "  public void testReplace_absentNullValueUnsupported() {\n", "    try {\n", "      getMap().replace(k3(), null);\n", "    } catch (NullPointerException tolerated) {\n", "      // permitted not to throw because it would be a no-op\n", "    }\n", "    expectUnchanged();\n", "  }\n", "  \n", "  @MapFeature.Require(value = SUPPORTS_PUT, absent = ALLOWS_NULL_KEY_QUERIES)\n", "  public void testReplace_absentNullKeyUnsupported() {\n", "    try {\n", "      getMap().replace(null, v3());\n", "    } catch (NullPointerException tolerated) {\n", "      // permitted not to throw because it would be a no-op\n", "    }\n", "    expectUnchanged();\n", "  }\n", "  \n", "  @MapFeature.Require(absent = SUPPORTS_PUT)\n", "  @CollectionSize.Require(absent = ZERO)\n", "  public void testReplace_unsupportedPresent() {\n", "    try {\n", "      getMap().replace(k0(), v3());\n", "      fail(\"Expected UnsupportedOperationException\");\n", "    } catch (UnsupportedOperationException expected) {\n", "    } catch (ClassCastException tolerated) {\n", "      // for ClassToInstanceMap\n", "    }\n", "    \n", "    expectUnchanged();\n", "  }\n", "}\n"]}, "removed": {}, "added_lines": {"1": [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 58, 59, 60, 61, 62, 63, 64, 65, 66, 67, 68, 69, 70, 71, 72, 73, 74, 75, 76, 77, 78, 79, 80, 81, 82, 83, 84, 85, 86, 87, 88, 89, 90, 91, 92, 93, 94, 95, 96, 97, 98, 99, 100, 101, 102, 103, 104, 105, 106, 107, 108]}, "removed_lines": {}}, {"51": "guava-testlib/src/com/google/common/testing/CollectorTester.java", "added": {"1": ["/*\n", " * Copyright (C) 2015 The Guava Authors\n", " *\n", " * Licensed under the Apache License, Version 2.0 (the \"License\");\n", " * you may not use this file except in compliance with the License.\n", " * You may obtain a copy of the License at\n", " *\n", " * http://www.apache.org/licenses/LICENSE-2.0\n", " *\n", " * Unless required by applicable law or agreed to in writing, software\n", " * distributed under the License is distributed on an \"AS IS\" BASIS,\n", " * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n", " * See the License for the specific language governing permissions and\n", " * limitations under the License.\n", " */\n", "\n", "package com.google.common.testing;\n", "\n", "import static com.google.common.base.Preconditions.checkNotNull;\n", "import static junit.framework.Assert.assertTrue;\n", "\n", "import com.google.common.annotations.Beta;\n", "import com.google.common.annotations.GwtCompatible;\n", "import java.util.ArrayList;\n", "import java.util.Arrays;\n", "import java.util.Collections;\n", "import java.util.EnumSet;\n", "import java.util.List;\n", "import java.util.Objects;\n", "import java.util.function.BiPredicate;\n", "import java.util.stream.Collector;\n", "import javax.annotation.Nullable;\n", "\n", "/**\n", " * Tester for {@code Collector} implementations.\n", " *\n", " * <p>Example usage:\n", " * <pre>\n", " * CollectorTester.of(Collectors.summingInt(Integer::parseInt))\n", " *     .expectCollects(3, \"1\", \"2\")\n", " *     .expectCollects(10, \"1\", \"4\", \"3\", \"2\")\n", " *     .expectCollects(5, \"-3\", \"0\", \"8\");\n", " * </pre>\n", " *\n", " * @author Louis Wasserman\n", " * @since 21.0\n", " */\n", "@Beta\n", "@GwtCompatible\n", "public final class CollectorTester<T, A, R> {\n", "  /**\n", "   * Creates a {@code CollectorTester} for the specified {@code Collector}. The result of the {@code\n", "   * Collector} will be compared to the expected value using {@link Object.equals}.\n", "   */\n", "  public static <T, A, R> CollectorTester<T, A, R> of(Collector<T, A, R> collector) {\n", "    return of(collector, Objects::equals);\n", "  }\n", "\n", "  /**\n", "   * Creates a {@code CollectorTester} for the specified {@code Collector}. The result of the {@code\n", "   * Collector} will be compared to the expected value using the specified {@code equivalence}.\n", "   */\n", "  public static <T, A, R> CollectorTester<T, A, R> of(Collector<T, A, R> collector,\n", "      BiPredicate<? super R, ? super R> equivalence) {\n", "    return new CollectorTester<>(collector, equivalence);\n", "  }\n", "\n", "  private final Collector<T, A, R> collector;\n", "  private final BiPredicate<? super R, ? super R> equivalence;\n", "\n", "  private CollectorTester(\n", "      Collector<T, A, R> collector, BiPredicate<? super R, ? super R> equivalence) {\n", "    this.collector = checkNotNull(collector);\n", "    this.equivalence = checkNotNull(equivalence);\n", "  }\n", "\n", "  /**\n", "   * Different orderings for combining the elements of an input array, which must\n", "   * all produce the same result.\n", "   */\n", "  enum CollectStrategy {\n", "    /**\n", "     * Get one accumulator and accumulate the elements into it sequentially.\n", "     */\n", "    SEQUENTIAL {\n", "      @Override\n", "      final <T, A, R> A result(Collector<T, A, R> collector, Iterable<T> inputs) {\n", "        A accum = collector.supplier().get();\n", "        for (T input : inputs) {\n", "          collector.accumulator().accept(accum, input);\n", "        }\n", "        return accum;\n", "      }\n", "    },\n", "    /**\n", "     * Get one accumulator for each element and merge the accumulators\n", "     * left-to-right.\n", "     */\n", "    MERGE_LEFT_ASSOCIATIVE {\n", "      @Override\n", "      final <T, A, R> A result(Collector<T, A, R> collector, Iterable<T> inputs) {\n", "        A accum = collector.supplier().get();\n", "        for (T input : inputs) {\n", "          A newAccum = collector.supplier().get();\n", "          collector.accumulator().accept(newAccum, input);\n", "          accum = collector.combiner().apply(accum, newAccum);\n", "        }\n", "        return accum;\n", "      }\n", "    },\n", "    /**\n", "     * Get one accumulator for each element and merge the accumulators\n", "     * right-to-left.\n", "     */\n", "    MERGE_RIGHT_ASSOCIATIVE {\n", "      @Override\n", "      final <T, A, R> A result(Collector<T, A, R> collector, Iterable<T> inputs) {\n", "        List<A> stack = new ArrayList<>();\n", "        for (T input : inputs) {\n", "          A newAccum = collector.supplier().get();\n", "          collector.accumulator().accept(newAccum, input);\n", "          push(stack, newAccum);\n", "        }\n", "        push(stack, collector.supplier().get());\n", "        while (stack.size() > 1) {\n", "          A right = pop(stack);\n", "          A left = pop(stack);\n", "          push(stack, collector.combiner().apply(left, right));\n", "        }\n", "        return pop(stack);\n", "      }\n", "\n", "      <E> void push(List<E> stack, E value) {\n", "        stack.add(value);\n", "      }\n", "\n", "      <E> E pop(List<E> stack) {\n", "        return stack.remove(stack.size() - 1);\n", "      }\n", "    };\n", "\n", "    abstract <T, A, R> A result(Collector<T, A, R> collector, Iterable<T> inputs);\n", "  }\n", "\n", "  /**\n", "   * Verifies that the specified expected result is always produced by collecting the\n", "   * specified inputs, regardless of how the elements are divided.\n", "   */\n", "  @SafeVarargs\n", "  public final CollectorTester<T, A, R> expectCollects(@Nullable R expectedResult, T... inputs) {\n", "    List<T> list = Arrays.asList(inputs);\n", "    doExpectCollects(expectedResult, list);\n", "    if (collector.characteristics().contains(Collector.Characteristics.UNORDERED)) {\n", "      Collections.reverse(list);\n", "      doExpectCollects(expectedResult, list);\n", "    }\n", "    return this;\n", "  }\n", "\n", "  private void doExpectCollects(@Nullable R expectedResult, List<T> inputs) {\n", "    for (CollectStrategy scheme : EnumSet.allOf(CollectStrategy.class)) {\n", "      A finalAccum = scheme.result(collector, inputs);\n", "      if (collector.characteristics().contains(Collector.Characteristics.IDENTITY_FINISH)) {\n", "        assertEquivalent(expectedResult, (R) finalAccum);\n", "      }\n", "      assertEquivalent(expectedResult, collector.finisher().apply(finalAccum));\n", "    }\n", "  }\n", "\n", "  private void assertEquivalent(@Nullable R expected, @Nullable R actual) {\n", "    assertTrue(\n", "        \"Expected \" + expected + \" got \" + actual + \" modulo equivalence \" + equivalence,\n", "        equivalence.test(expected, actual));\n", "  }\n", "}\n", "\n"]}, "removed": {}, "added_lines": {"1": [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 58, 59, 60, 61, 62, 63, 64, 65, 66, 67, 68, 69, 70, 71, 72, 73, 74, 75, 76, 77, 78, 79, 80, 81, 82, 83, 84, 85, 86, 87, 88, 89, 90, 91, 92, 93, 94, 95, 96, 97, 98, 99, 100, 101, 102, 103, 104, 105, 106, 107, 108, 109, 110, 111, 112, 113, 114, 115, 116, 117, 118, 119, 120, 121, 122, 123, 124, 125, 126, 127, 128, 129, 130, 131, 132, 133, 134, 135, 136, 137, 138, 139, 140, 141, 142, 143, 144, 145, 146, 147, 148, 149, 150, 151, 152, 153, 154, 155, 156, 157, 158, 159, 160, 161, 162, 163, 164, 165, 166, 167, 168, 169, 170, 171, 172, 173, 174, 175, 176]}, "removed_lines": {}}, {"52": "guava-testlib/src/com/google/common/testing/TearDown.java", "added": {"1": ["@FunctionalInterface\n"]}, "removed": {}, "added_lines": {"1": [29]}, "removed_lines": {}}, {"53": "guava-testlib/test/com/google/common/collect/testing/OpenJdk6MapTests.java", "added": {"1": ["import static com.google.common.collect.testing.testers.MapMergeTester.getMergeNullValueMethod;\n"], "2": ["\n", "  @Override\n", "  protected Collection<Method> suppressForHashtable() {\n", "    return Arrays.asList(getMergeNullValueMethod());\n", "  }\n"]}, "removed": {}, "added_lines": {"1": [27], "2": [90, 91, 92, 93, 94]}, "removed_lines": {}}, {"54": "guava-tests/benchmark/com/google/common/collect/IteratorBenchmark.java", "added": {"1": ["  @Benchmark\n", "  int arrayListForWithHolder(int reps) {\n", "    int[] sumHolder = {0};\n", "    for (int i = 0; i < reps; i++) {\n", "      for (Object value : arrayList) {\n", "        sumHolder[0] += value.hashCode();\n", "      }\n", "    }\n", "    return sumHolder[0];\n", "  }\n", "\n", "  @Benchmark\n", "  int arrayListForEachWithHolder(int reps) {\n", "    int[] sumHolder = {0};\n", "    for (int i = 0; i < reps; i++) {\n", "      arrayList.forEach(value -> sumHolder[0] += value.hashCode());\n", "    }\n", "    return sumHolder[0];\n", "  }\n", "\n"], "2": ["  @Benchmark\n", "  int linkedListForEach(int reps) {\n", "    int[] sumHolder = {0};\n", "    for (int i = 0; i < reps; i++) {\n", "      linkedList.forEach(value -> sumHolder[0] += value.hashCode());\n", "    }\n", "    return sumHolder[0];\n", "  }\n", "\n"]}, "removed": {}, "added_lines": {"1": [111, 112, 113, 114, 115, 116, 117, 118, 119, 120, 121, 122, 123, 124, 125, 126, 127, 128, 129, 130], "2": [151, 152, 153, 154, 155, 156, 157, 158, 159]}, "removed_lines": {}}, {"55": "guava-tests/benchmark/com/google/common/collect/StreamsBenchmark.java", "added": {"1": ["/*\n", " * Copyright (C) 2016 The Guava Authors\n", " *\n", " * Licensed under the Apache License, Version 2.0 (the \"License\");\n", " * you may not use this file except in compliance with the License.\n", " * You may obtain a copy of the License at\n", " *\n", " * http://www.apache.org/licenses/LICENSE-2.0\n", " *\n", " * Unless required by applicable law or agreed to in writing, software\n", " * distributed under the License is distributed on an \"AS IS\" BASIS,\n", " * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n", " * See the License for the specific language governing permissions and\n", " * limitations under the License.\n", " */\n", "\n", "package com.google.common.collect;\n", "\n", "import com.google.caliper.BeforeExperiment;\n", "import com.google.caliper.Benchmark;\n", "import com.google.caliper.Param;\n", "import com.google.caliper.api.SkipThisScenarioException;\n", "import java.util.ArrayList;\n", "import java.util.Collection;\n", "import java.util.LinkedList;\n", "import java.util.NoSuchElementException;\n", "import java.util.function.Supplier;\n", "import java.util.stream.Stream;\n", "\n", "/**\n", " * Test stream operation speed.\n", " *\n", " * @author Louis Wasserman\n", " */\n", "public class StreamsBenchmark {\n", "  @Param({\"1\", \"10\", \"100\", \"1000\", \"10000\"})\n", "  private int size;\n", "\n", "  enum CollectionType {\n", "    ARRAY_LIST(ArrayList::new),\n", "    LINKED_LIST(LinkedList::new);\n", "\n", "    final Supplier<Collection<Object>> supplier;\n", "\n", "    private CollectionType(Supplier<Collection<Object>> supplier) {\n", "      this.supplier = supplier;\n", "    }\n", "  }\n", "\n", "  @Param private CollectionType source;\n", "\n", "  enum Operation {\n", "    FIND_FIRST {\n", "      @Override\n", "      Object operate(Stream<?> stream) {\n", "        return stream.findFirst();\n", "      }\n", "    },\n", "    STREAMS_ONLY_ELEMENT {\n", "      @Override\n", "      Object operate(Stream<?> stream) {\n", "        try {\n", "          return stream.collect(MoreCollectors.onlyElement());\n", "        } catch (IllegalArgumentException | NoSuchElementException e) {\n", "          throw new SkipThisScenarioException();\n", "        }\n", "      }\n", "    },\n", "    STREAMS_FIND_LAST {\n", "      @Override\n", "      Object operate(Stream<?> stream) {\n", "        return Streams.findLast(stream);\n", "      }\n", "    },\n", "    REDUCE_LAST {\n", "      @Override\n", "      Object operate(Stream<?> stream) {\n", "        return stream.reduce((a, b) -> b);\n", "      }\n", "    },\n", "    REDUCE_LAST_PARALLEL {\n", "      @Override\n", "      Object operate(Stream<?> stream) {\n", "        return stream.parallel().reduce((a, b) -> b);\n", "      }\n", "    };\n", "\n", "    abstract Object operate(Stream<?> stream);\n", "  }\n", "\n", "  @Param private Operation operation;\n", "\n", "  Collection<Object> collection;\n", "\n", "  @BeforeExperiment\n", "  void setUp() {\n", "    collection = source.supplier.get();\n", "    for (int i = 0; i < size; i++) {\n", "      collection.add(new Object());\n", "    }\n", "  }\n", "\n", "  @Benchmark\n", "  int runOperation(int reps) {\n", "    int result = 0;\n", "    for (int i = 0; i < reps; i++) {\n", "      result += System.identityHashCode(operation.operate(collection.stream()));\n", "    }\n", "    return result;\n", "  }\n", "}\n"]}, "removed": {}, "added_lines": {"1": [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 58, 59, 60, 61, 62, 63, 64, 65, 66, 67, 68, 69, 70, 71, 72, 73, 74, 75, 76, 77, 78, 79, 80, 81, 82, 83, 84, 85, 86, 87, 88, 89, 90, 91, 92, 93, 94, 95, 96, 97, 98, 99, 100, 101, 102, 103, 104, 105, 106, 107, 108, 109, 110, 111]}, "removed_lines": {}}, {"56": "guava-tests/pom.xml", "added": {"1": ["    <dependency>\n", "      <groupId>com.google.truth.extensions</groupId>\n", "      <artifactId>truth-java8-extension</artifactId>\n", "    </dependency>\n", "    <dependency>\n", "      <groupId>com.google.jimfs</groupId>\n", "      <artifactId>jimfs</artifactId>\n", "    </dependency>\n"]}, "removed": {}, "added_lines": {"1": [48, 49, 50, 51, 52, 53, 54, 55]}, "removed_lines": {}}, {"57": "guava-tests/test/com/google/common/base/OptionalTest.java", "added": {"1": ["  public void testToJavaUtil() {\n", "    assertNull(Optional.toJavaUtil(null));\n", "    assertEquals(java.util.Optional.empty(), Optional.toJavaUtil(Optional.absent()));\n", "    assertEquals(java.util.Optional.of(\"abc\"), Optional.toJavaUtil(Optional.of(\"abc\")));\n", "  }\n", "\n", "  public void testFromJavaUtil() {\n", "    assertNull(Optional.fromJavaUtil(null));\n", "    assertEquals(Optional.absent(), Optional.fromJavaUtil(java.util.Optional.empty()));\n", "    assertEquals(Optional.of(\"abc\"), Optional.fromJavaUtil(java.util.Optional.of(\"abc\")));\n", "  }\n", "\n"]}, "removed": {}, "added_lines": {"1": [39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50]}, "removed_lines": {}}, {"58": "guava-tests/test/com/google/common/cache/LocalCacheTest.java", "added": {"1": ["import com.google.common.collect.testing.MapTestSuiteBuilder;\n"], "2": ["    suite.addTest(MapTestSuiteBuilder\n", "    suite.addTest(MapTestSuiteBuilder\n", "    suite.addTest(MapTestSuiteBuilder\n", "    suite.addTest(MapTestSuiteBuilder\n"], "3": ["    suite.addTest(MapTestSuiteBuilder\n", "    suite.addTest(MapTestSuiteBuilder\n", "    suite.addTest(MapTestSuiteBuilder\n", "    suite.addTest(MapTestSuiteBuilder\n", "    suite.addTest(MapTestSuiteBuilder\n", "    suite.addTest(MapTestSuiteBuilder\n"], "4": ["    suite.addTest(MapTestSuiteBuilder\n"], "5": ["  public void testRemoveIfWithConcurrentModification() {\n", "    LocalCache<Integer, Integer> map =\n", "        makeLocalCache(createCacheBuilder().concurrencyLevel(1).initialCapacity(1));\n", "    map.put(1, 1);\n", "    map.put(2, 1);\n", "    map.put(3, 1);\n", "    map.entrySet()\n", "        .removeIf(\n", "            entry -> {\n", "              if (entry.getValue().equals(1)) {\n", "                map.put(entry.getKey(), 2);\n", "                return true;\n", "              } else {\n", "                return false;\n", "              }\n", "            });\n", "    assertEquals(3, map.size());\n", "    assertFalse(map.containsValue(1));\n", "  }\n", "\n", "  public void testRemoveIfWithConcurrentRemoval() {\n", "    LocalCache<Integer, Integer> map =\n", "        makeLocalCache(createCacheBuilder().concurrencyLevel(1).initialCapacity(1));\n", "    map.put(0, 1);\n", "    map.put(1, 1);\n", "    map.put(2, 1);\n", "    map.entrySet()\n", "        .removeIf(\n", "            entry -> {\n", "              assertThat(entry.getValue()).isNotNull();\n", "              map.remove((entry.getKey() + 1) % 3);\n", "              return false;\n", "            });\n", "    assertEquals(1, map.size());\n", "  }\n", "\n"]}, "removed": {"1": ["import com.google.common.collect.testing.ConcurrentMapTestSuiteBuilder;\n"], "2": ["    suite.addTest(ConcurrentMapTestSuiteBuilder\n", "    suite.addTest(ConcurrentMapTestSuiteBuilder\n", "    suite.addTest(ConcurrentMapTestSuiteBuilder\n", "    suite.addTest(ConcurrentMapTestSuiteBuilder\n"], "3": ["    suite.addTest(ConcurrentMapTestSuiteBuilder\n", "    suite.addTest(ConcurrentMapTestSuiteBuilder\n", "    suite.addTest(ConcurrentMapTestSuiteBuilder\n", "    suite.addTest(ConcurrentMapTestSuiteBuilder\n", "    suite.addTest(ConcurrentMapTestSuiteBuilder\n", "    suite.addTest(ConcurrentMapTestSuiteBuilder\n"], "4": ["    suite.addTest(ConcurrentMapTestSuiteBuilder\n"]}, "added_lines": {"1": [53], "2": [105, 111, 118, 125], "3": [134, 141, 148, 155, 162, 169], "4": [177], "5": [1735, 1736, 1737, 1738, 1739, 1740, 1741, 1742, 1743, 1744, 1745, 1746, 1747, 1748, 1749, 1750, 1751, 1752, 1753, 1754, 1755, 1756, 1757, 1758, 1759, 1760, 1761, 1762, 1763, 1764, 1765, 1766, 1767, 1768, 1769, 1770]}, "removed_lines": {"1": [53], "2": [105, 111, 118, 125], "3": [134, 141, 148, 155, 162, 169], "4": [177]}}, {"59": "guava-tests/test/com/google/common/collect/CollectSpliteratorsTest.java", "added": {"1": ["/*\n", " * Copyright (C) 2015 The Guava Authors\n", " *\n", " * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not use this file except\n", " * in compliance with the License. You may obtain a copy of the License at\n", " *\n", " * http://www.apache.org/licenses/LICENSE-2.0\n", " *\n", " * Unless required by applicable law or agreed to in writing, software distributed under the License\n", " * is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express\n", " * or implied. See the License for the specific language governing permissions and limitations under\n", " * the License.\n", " */\n", "\n", "package com.google.common.collect;\n", "\n", "import static com.google.common.truth.Truth.assertThat;\n", "\n", "import com.google.common.annotations.GwtCompatible;\n", "import com.google.common.base.Ascii;\n", "import com.google.common.collect.testing.SpliteratorTester;\n", "import java.util.Arrays;\n", "import java.util.List;\n", "import java.util.Spliterator;\n", "import junit.framework.TestCase;\n", "\n", "/**\n", " * Tests for {@code CollectSpliterators}.\n", " */\n", "@GwtCompatible\n", "public class CollectSpliteratorsTest extends TestCase {\n", "  public void testMap() {\n", "    SpliteratorTester.of(\n", "            ()\n", "                -> CollectSpliterators.map(\n", "                    Arrays.spliterator(new String[] {\"a\", \"b\", \"c\", \"d\", \"e\"}), Ascii::toUpperCase))\n", "        .expect(\"A\", \"B\", \"C\", \"D\", \"E\");\n", "  }\n", "\n", "  public void testFlatMap() {\n", "    SpliteratorTester.of(\n", "            ()\n", "                -> CollectSpliterators.flatMap(\n", "                    Arrays.spliterator(new String[] {\"abc\", \"\", \"de\", \"f\", \"g\", \"\"}),\n", "                    (String str) -> Lists.charactersOf(str).spliterator(),\n", "                    Spliterator.SIZED | Spliterator.DISTINCT | Spliterator.NONNULL,\n", "                    7))\n", "        .expect('a', 'b', 'c', 'd', 'e', 'f', 'g');\n", "  }\n", "\n", "  public void testMultisetsSpliterator() {\n", "    Multiset<String> multiset = TreeMultiset.create();\n", "    multiset.add(\"a\", 3);\n", "    multiset.add(\"b\", 1);\n", "    multiset.add(\"c\", 2);\n", "\n", "    List<String> actualValues = Lists.newArrayList();\n", "    multiset.spliterator().forEachRemaining(actualValues::add);\n", "    assertThat(multiset).containsExactly(\n", "        \"a\",\n", "        \"a\",\n", "        \"a\",\n", "        \"b\",\n", "        \"c\",\n", "        \"c\").inOrder();\n", "  }\n", "}\n"]}, "removed": {}, "added_lines": {"1": [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 58, 59, 60, 61, 62, 63, 64, 65, 66, 67]}, "removed_lines": {}}, {"60": "guava-tests/test/com/google/common/collect/FluentIterableTest.java", "added": {"1": ["import static com.google.common.collect.FluentIterableTest.Help.assertThat;\n"], "2": ["import com.google.common.truth.IterableSubject;\n", "import com.google.common.truth.Truth;\n"], "3": ["import java.util.stream.Stream;\n"], "4": ["  /*\n", "   * Full and proper black-box testing of a Stream-returning method is extremely involved, and is\n", "   * overkill when nearly all Streams are produced using well-tested JDK calls. So, we cheat and\n", "   * just test that the toArray() contents are as expected.\n", "   */\n", "  public void testStream() {\n", "    assertThat(FluentIterable.of().stream()).isEmpty();\n", "    assertThat(FluentIterable.of(\"a\").stream()).containsExactly(\"a\");\n", "    assertThat(FluentIterable.of(1, 2, 3).stream().filter(n -> n > 1)).containsExactly(2, 3);\n", "  }\n", "\n", "  // TODO(kevinb): add assertThat(Stream) to Truth?\n", "  static class Help {\n", "    static IterableSubject assertThat(Stream<?> stream) {\n", "      return Truth.assertThat(stream.toArray()).asList();\n", "    }\n", "  }\n", "\n"]}, "removed": {}, "added_lines": {"1": [19], "2": [34, 35], "3": [44], "4": [922, 923, 924, 925, 926, 927, 928, 929, 930, 931, 932, 933, 934, 935, 936, 937, 938, 939]}, "removed_lines": {}}, {"61": "guava-tests/test/com/google/common/collect/ImmutableBiMapTest.java", "added": {"1": ["import static com.google.common.collect.testing.Helpers.mapEntry;\n", "import com.google.common.base.Equivalence;\n"], "2": ["import com.google.common.testing.CollectorTester;\n", "import java.util.stream.Collector;\n", "import java.util.stream.Stream;\n"], "3": ["\n", "    public void testToImmutableBiMap() {\n", "      Collector<Entry<String, Integer>, ?, ImmutableBiMap<String, Integer>> collector =\n", "          ImmutableBiMap.toImmutableBiMap(Entry::getKey, Entry::getValue);\n", "      Equivalence<ImmutableBiMap<String, Integer>> equivalence =\n", "          Equivalence.equals()\n", "              .<Entry<String, Integer>>pairwise()\n", "              .onResultOf(ImmutableBiMap::entrySet);\n", "      CollectorTester.of(collector, equivalence)\n", "          .expectCollects(\n", "              ImmutableBiMap.of(\"one\", 1, \"two\", 2, \"three\", 3),\n", "              mapEntry(\"one\", 1),\n", "              mapEntry(\"two\", 2),\n", "              mapEntry(\"three\", 3));\n", "    }\n", "\n", "    public void testToImmutableBiMap_exceptionOnDuplicateKey() {\n", "      Collector<Entry<String, Integer>, ?, ImmutableBiMap<String, Integer>> collector =\n", "          ImmutableBiMap.toImmutableBiMap(Entry::getKey, Entry::getValue);\n", "      try {\n", "        Stream.of(mapEntry(\"one\", 1), mapEntry(\"one\", 11)).collect(collector);\n", "        fail(\"Expected IllegalArgumentException\");\n", "      } catch (IllegalArgumentException expected) {\n", "      }\n", "    }\n"]}, "removed": {}, "added_lines": {"1": [19, 24], "2": [36, 43, 44], "3": [484, 485, 486, 487, 488, 489, 490, 491, 492, 493, 494, 495, 496, 497, 498, 499, 500, 501, 502, 503, 504, 505, 506, 507, 508]}, "removed_lines": {}}, {"62": "guava-tests/test/com/google/common/collect/ImmutableListMultimapTest.java", "added": {"1": ["import static com.google.common.collect.testing.Helpers.mapEntry;\n"], "2": ["import com.google.common.base.Equivalence;\n", "import com.google.common.testing.CollectorTester;\n", "import java.util.function.BiPredicate;\n", "import java.util.stream.Collector;\n"], "3": ["  public void testToImmutableListMultimap() {\n", "    Collector<Entry<String, Integer>, ?, ImmutableListMultimap<String, Integer>> collector =\n", "        ImmutableListMultimap.toImmutableListMultimap(Entry::getKey, Entry::getValue);\n", "    BiPredicate<ImmutableListMultimap<?, ?>, ImmutableListMultimap<?, ?>> equivalence =\n", "        Equivalence.equals()\n", "            .onResultOf((ImmutableListMultimap<?, ?> mm) -> mm.asMap().entrySet().asList())\n", "            .and(Equivalence.equals());\n", "    CollectorTester.of(collector, equivalence)\n", "        .expectCollects(ImmutableListMultimap.of())\n", "        .expectCollects(\n", "            ImmutableListMultimap.of(\"a\", 1, \"b\", 2, \"a\", 3, \"c\", 4),\n", "            mapEntry(\"a\", 1),\n", "            mapEntry(\"b\", 2),\n", "            mapEntry(\"a\", 3),\n", "            mapEntry(\"c\", 4));\n", "  }\n", "\n"]}, "removed": {}, "added_lines": {"1": [19], "2": [27, 33, 40, 41], "3": [400, 401, 402, 403, 404, 405, 406, 407, 408, 409, 410, 411, 412, 413, 414, 415, 416]}, "removed_lines": {}}, {"63": "guava-tests/test/com/google/common/collect/ImmutableListTest.java", "added": {"1": ["import com.google.common.testing.CollectorTester;\n"], "2": ["    public void testToImmutableList() {\n", "      CollectorTester.of(ImmutableList.<String>toImmutableList())\n", "          .expectCollects(ImmutableList.of(\"a\", \"b\", \"c\", \"d\"), \"a\", \"b\", \"c\", \"d\");\n", "    }\n"]}, "removed": {}, "added_lines": {"1": [42], "2": [457, 458, 459, 460]}, "removed_lines": {}}, {"64": "guava-tests/test/com/google/common/collect/ImmutableMapTest.java", "added": {"1": ["import static com.google.common.collect.testing.Helpers.mapEntry;\n", "import com.google.common.base.Equivalence;\n"], "2": ["import com.google.common.testing.CollectorTester;\n"], "3": ["import java.util.stream.Collector;\n", "import java.util.stream.Stream;\n"], "4": ["\n", "    public void testToImmutableMap() {\n", "      Collector<Entry<String, Integer>, ?, ImmutableMap<String, Integer>> collector =\n", "          ImmutableMap.toImmutableMap(Entry::getKey, Entry::getValue);\n", "      Equivalence<ImmutableMap<String, Integer>> equivalence =\n", "          Equivalence.equals()\n", "              .<Entry<String, Integer>>pairwise()\n", "              .onResultOf(ImmutableMap::entrySet);\n", "      CollectorTester.of(collector, equivalence)\n", "          .expectCollects(\n", "              ImmutableMap.of(\"one\", 1, \"two\", 2, \"three\", 3),\n", "              mapEntry(\"one\", 1),\n", "              mapEntry(\"two\", 2),\n", "              mapEntry(\"three\", 3));\n", "    }\n", "\n", "    public void testToImmutableMap_exceptionOnDuplicateKey() {\n", "      Collector<Entry<String, Integer>, ?, ImmutableMap<String, Integer>> collector =\n", "          ImmutableMap.toImmutableMap(Entry::getKey, Entry::getValue);\n", "      try {\n", "        Stream.of(mapEntry(\"one\", 1), mapEntry(\"one\", 11)).collect(collector);\n", "        fail(\"Expected IllegalArgumentException\");\n", "      } catch (IllegalArgumentException expected) {\n", "      }\n", "    }\n", "\n", "    public void testToImmutableMapMerging() {\n", "      Collector<Entry<String, Integer>, ?, ImmutableMap<String, Integer>> collector =\n", "          ImmutableMap.toImmutableMap(Entry::getKey, Entry::getValue, Integer::sum);\n", "      Equivalence<ImmutableMap<String, Integer>> equivalence =\n", "          Equivalence.equals()\n", "              .<Entry<String, Integer>>pairwise()\n", "              .onResultOf(ImmutableMap::entrySet);\n", "      CollectorTester.of(collector, equivalence)\n", "          .expectCollects(\n", "              ImmutableMap.of(\"one\", 1, \"two\", 4, \"three\", 3),\n", "              mapEntry(\"one\", 1),\n", "              mapEntry(\"two\", 2),\n", "              mapEntry(\"three\", 3),\n", "              mapEntry(\"two\", 2));\n", "    }\n"]}, "removed": {}, "added_lines": {"1": [19, 24], "2": [47], "3": [58, 59], "4": [608, 609, 610, 611, 612, 613, 614, 615, 616, 617, 618, 619, 620, 621, 622, 623, 624, 625, 626, 627, 628, 629, 630, 631, 632, 633, 634, 635, 636, 637, 638, 639, 640, 641, 642, 643, 644, 645, 646, 647, 648]}, "removed_lines": {}}, {"65": "guava-tests/test/com/google/common/collect/ImmutableMultisetTest.java", "added": {"1": ["import com.google.common.testing.CollectorTester;\n"], "2": ["import java.util.function.BiPredicate;\n", "import java.util.stream.Collector;\n"], "3": ["  public void testToImmutableMultiset() {\n", "    BiPredicate<ImmutableMultiset<String>, ImmutableMultiset<String>> equivalence =\n", "        (ms1, ms2) -> ms1.equals(ms2) && ms1.entrySet().asList().equals(ms2.entrySet().asList());\n", "    CollectorTester.of(ImmutableMultiset.<String>toImmutableMultiset(), equivalence)\n", "        .expectCollects(ImmutableMultiset.of())\n", "        .expectCollects(\n", "            ImmutableMultiset.of(\"a\", \"a\", \"b\", \"c\", \"c\", \"c\"), \"a\", \"a\", \"b\", \"c\", \"c\", \"c\");\n", "  }\n", "\n", "  public void testToImmutableMultiset_duplicates() {\n", "    class TypeWithDuplicates {\n", "      final int a;\n", "      final int b;\n", "\n", "      TypeWithDuplicates(int a, int b) {\n", "        this.a = a;\n", "        this.b = b;\n", "      }\n", "\n", "      @Override\n", "      public int hashCode() {\n", "        return a;\n", "      }\n", "\n", "      @Override\n", "      public boolean equals(Object obj) {\n", "        return obj instanceof TypeWithDuplicates && ((TypeWithDuplicates) obj).a == a;\n", "      }\n", "\n", "      public boolean fullEquals(TypeWithDuplicates other) {\n", "        return other != null && a == other.a && b == other.b;\n", "      }\n", "    }\n", "\n", "    Collector<TypeWithDuplicates, ?, ImmutableMultiset<TypeWithDuplicates>> collector =\n", "        ImmutableMultiset.toImmutableMultiset();\n", "    BiPredicate<ImmutableMultiset<TypeWithDuplicates>, ImmutableMultiset<TypeWithDuplicates>>\n", "        equivalence =\n", "            (ms1, ms2)\n", "                -> {\n", "                  if (!ms1.equals(ms2)) {\n", "                    return false;\n", "                  }\n", "                  List<TypeWithDuplicates> elements1 = ImmutableList.copyOf(ms1.elementSet());\n", "                  List<TypeWithDuplicates> elements2 = ImmutableList.copyOf(ms2.elementSet());\n", "                  for (int i = 0; i < ms1.elementSet().size(); i++) {\n", "                    if (!elements1.get(i).fullEquals(elements2.get(i))) {\n", "                      return false;\n", "                    }\n", "                  }\n", "                  return true;\n", "                };\n", "    TypeWithDuplicates a = new TypeWithDuplicates(1, 1);\n", "    TypeWithDuplicates b1 = new TypeWithDuplicates(2, 1);\n", "    TypeWithDuplicates b2 = new TypeWithDuplicates(2, 2);\n", "    TypeWithDuplicates c = new TypeWithDuplicates(3, 1);\n", "    CollectorTester.of(collector, equivalence)\n", "        .expectCollects(\n", "            ImmutableMultiset.<TypeWithDuplicates>builder()\n", "                .add(a)\n", "                .addCopies(b1, 2)\n", "                .add(c)\n", "                .build(),\n", "            a,\n", "            b1,\n", "            c,\n", "            b2);\n", "  }\n", "\n"]}, "removed": {}, "added_lines": {"1": [35], "2": [45, 46], "3": [287, 288, 289, 290, 291, 292, 293, 294, 295, 296, 297, 298, 299, 300, 301, 302, 303, 304, 305, 306, 307, 308, 309, 310, 311, 312, 313, 314, 315, 316, 317, 318, 319, 320, 321, 322, 323, 324, 325, 326, 327, 328, 329, 330, 331, 332, 333, 334, 335, 336, 337, 338, 339, 340, 341, 342, 343, 344, 345, 346, 347, 348, 349, 350, 351, 352, 353, 354, 355]}, "removed_lines": {}}, {"66": "guava-tests/test/com/google/common/collect/ImmutableSetMultimapTest.java", "added": {"1": ["import static com.google.common.collect.testing.Helpers.mapEntry;\n"], "2": ["import com.google.common.base.Equivalence;\n", "import com.google.common.testing.CollectorTester;\n", "import java.util.function.BiPredicate;\n", "import java.util.stream.Collector;\n"], "3": ["  public void testToImmutableSetMultimap() {\n", "    Collector<Entry<String, Integer>, ?, ImmutableSetMultimap<String, Integer>> collector =\n", "        ImmutableSetMultimap.toImmutableSetMultimap(Entry::getKey, Entry::getValue);\n", "    BiPredicate<ImmutableSetMultimap<?, ?>, ImmutableSetMultimap<?, ?>> equivalence =\n", "        Equivalence.equals()\n", "            .onResultOf(\n", "                (ImmutableSetMultimap<?, ?> mm)\n", "                    -> ImmutableListMultimap.copyOf(mm).asMap().entrySet().asList())\n", "            .and(Equivalence.equals());\n", "    CollectorTester.of(collector, equivalence)\n", "        .expectCollects(ImmutableSetMultimap.of())\n", "        .expectCollects(\n", "            ImmutableSetMultimap.of(\"a\", 1, \"b\", 2, \"a\", 3, \"c\", 4),\n", "            mapEntry(\"a\", 1),\n", "            mapEntry(\"b\", 2),\n", "            mapEntry(\"a\", 3),\n", "            mapEntry(\"c\", 4));\n", "  }\n", "\n"]}, "removed": {}, "added_lines": {"1": [19], "2": [27, 33, 40, 41], "3": [414, 415, 416, 417, 418, 419, 420, 421, 422, 423, 424, 425, 426, 427, 428, 429, 430, 431, 432]}, "removed_lines": {}}, {"67": "guava-tests/test/com/google/common/collect/ImmutableSetTest.java", "added": {"1": ["import com.google.common.base.Equivalence;\n"], "2": ["import com.google.common.testing.CollectorTester;\n", "import java.util.function.BiPredicate;\n", "import java.util.stream.Collector;\n"], "3": ["  public void testToImmutableSet() {\n", "    Collector<String, ?, ImmutableSet<String>> collector = ImmutableSet.toImmutableSet();\n", "    Equivalence<ImmutableSet<String>> equivalence =\n", "        Equivalence.equals().onResultOf(ImmutableSet::asList);\n", "    CollectorTester.of(collector, equivalence)\n", "        .expectCollects(ImmutableSet.of(\"a\", \"b\", \"c\", \"d\"), \"a\", \"b\", \"a\", \"c\", \"b\", \"b\", \"d\");\n", "  }\n", "\n", "  public void testToImmutableSet_duplicates() {\n", "    class TypeWithDuplicates {\n", "      final int a;\n", "      final int b;\n", "\n", "      TypeWithDuplicates(int a, int b) {\n", "        this.a = a;\n", "        this.b = b;\n", "      }\n", "\n", "      @Override\n", "      public int hashCode() {\n", "        return a;\n", "      }\n", "\n", "      @Override\n", "      public boolean equals(Object obj) {\n", "        return obj instanceof TypeWithDuplicates && ((TypeWithDuplicates) obj).a == a;\n", "      }\n", "\n", "      public boolean fullEquals(TypeWithDuplicates other) {\n", "        return other != null && a == other.a && b == other.b;\n", "      }\n", "    }\n", "\n", "    Collector<TypeWithDuplicates, ?, ImmutableSet<TypeWithDuplicates>> collector =\n", "        ImmutableSet.toImmutableSet();\n", "    BiPredicate<ImmutableSet<TypeWithDuplicates>, ImmutableSet<TypeWithDuplicates>> equivalence =\n", "        (set1, set2) -> {\n", "          if (!set1.equals(set2)) {\n", "            return false;\n", "          }\n", "          for (int i = 0; i < set1.size(); i++) {\n", "            if (!set1.asList().get(i).fullEquals(set2.asList().get(i))) {\n", "              return false;\n", "            }\n", "          }\n", "          return true;\n", "        };\n", "    TypeWithDuplicates a = new TypeWithDuplicates(1, 1);\n", "    TypeWithDuplicates b1 = new TypeWithDuplicates(2, 1);\n", "    TypeWithDuplicates b2 = new TypeWithDuplicates(2, 2);\n", "    TypeWithDuplicates c = new TypeWithDuplicates(3, 1);\n", "    CollectorTester.of(collector, equivalence)\n", "        .expectCollects(ImmutableSet.of(a, b1, c), a, b1, c, b2);\n", "  }\n", "\n"]}, "removed": {}, "added_lines": {"1": [23], "2": [33, 39, 40], "3": [215, 216, 217, 218, 219, 220, 221, 222, 223, 224, 225, 226, 227, 228, 229, 230, 231, 232, 233, 234, 235, 236, 237, 238, 239, 240, 241, 242, 243, 244, 245, 246, 247, 248, 249, 250, 251, 252, 253, 254, 255, 256, 257, 258, 259, 260, 261, 262, 263, 264, 265, 266, 267, 268, 269]}, "removed_lines": {}}, {"68": "guava-tests/test/com/google/common/collect/ImmutableSortedMapTest.java", "added": {"1": ["import static com.google.common.collect.testing.Helpers.mapEntry;\n", "import com.google.common.base.Equivalence;\n"], "2": ["import com.google.common.testing.CollectorTester;\n"], "3": ["import java.util.function.BiPredicate;\n", "import java.util.stream.Collector;\n", "import java.util.stream.Stream;\n"], "4": ["\n", "    public void testToImmutableSortedMap() {\n", "      Collector<Entry<String, Integer>, ?, ImmutableSortedMap<String, Integer>> collector =\n", "          ImmutableSortedMap.toImmutableSortedMap(\n", "              String.CASE_INSENSITIVE_ORDER, Entry::getKey, Entry::getValue);\n", "      BiPredicate<ImmutableSortedMap<String, Integer>, ImmutableSortedMap<String, Integer>>\n", "          equivalence =\n", "              Equivalence.equals().onResultOf(ImmutableSortedMap<String, Integer>::comparator)\n", "                  .and(Equivalence.equals().onResultOf(map -> map.entrySet().asList()))\n", "                  .and(Equivalence.equals());\n", "      ImmutableSortedMap<String, Integer> expected =\n", "          ImmutableSortedMap.<String, Integer>orderedBy(String.CASE_INSENSITIVE_ORDER)\n", "              .put(\"one\", 1)\n", "              .put(\"three\", 3)\n", "              .put(\"two\", 2)\n", "              .build();\n", "      CollectorTester.of(collector, equivalence)\n", "          .expectCollects(expected, mapEntry(\"one\", 1), mapEntry(\"two\", 2), mapEntry(\"three\", 3));\n", "    }\n", "\n", "    public void testToImmutableSortedMap_exceptionOnDuplicateKey() {\n", "      Collector<Entry<String, Integer>, ?, ImmutableSortedMap<String, Integer>> collector =\n", "          ImmutableSortedMap.toImmutableSortedMap(\n", "              Ordering.natural(), Entry::getKey, Entry::getValue);\n", "      try {\n", "        Stream.of(mapEntry(\"one\", 1), mapEntry(\"one\", 11)).collect(collector);\n", "        fail(\"Expected IllegalArgumentException\");\n", "      } catch (IllegalArgumentException expected) {\n", "      }\n", "    }\n", "\n", "    public void testToImmutableSortedMapMerging() {\n", "      Collector<Entry<String, Integer>, ?, ImmutableSortedMap<String, Integer>> collector =\n", "          ImmutableSortedMap.toImmutableSortedMap(\n", "              Comparator.naturalOrder(), Entry::getKey, Entry::getValue, Integer::sum);\n", "      Equivalence<ImmutableMap<String, Integer>> equivalence =\n", "          Equivalence.equals()\n", "              .<Entry<String, Integer>>pairwise()\n", "              .onResultOf(ImmutableMap::entrySet);\n", "      CollectorTester.of(collector, equivalence)\n", "          .expectCollects(\n", "              ImmutableSortedMap.of(\"one\", 1, \"three\", 3, \"two\", 4),\n", "              mapEntry(\"one\", 1),\n", "              mapEntry(\"two\", 2),\n", "              mapEntry(\"three\", 3),\n", "              mapEntry(\"two\", 2));\n", "    }\n"]}, "removed": {}, "added_lines": {"1": [19, 24], "2": [39], "3": [49, 50, 51], "4": [662, 663, 664, 665, 666, 667, 668, 669, 670, 671, 672, 673, 674, 675, 676, 677, 678, 679, 680, 681, 682, 683, 684, 685, 686, 687, 688, 689, 690, 691, 692, 693, 694, 695, 696, 697, 698, 699, 700, 701, 702, 703, 704, 705, 706, 707, 708]}, "removed_lines": {}}, {"69": "guava-tests/test/com/google/common/collect/ImmutableSortedMultisetTest.java", "added": {"1": ["import com.google.common.testing.CollectorTester;\n"], "2": ["import java.util.function.BiPredicate;\n"], "3": ["  public void testToImmutableSortedMultiset() {\n", "    BiPredicate<ImmutableSortedMultiset<String>, ImmutableSortedMultiset<String>> equivalence =\n", "        (ms1, ms2)\n", "            -> ms1.equals(ms2)\n", "                && ms1.entrySet().asList().equals(ms2.entrySet().asList())\n", "                && ms1.comparator().equals(ms2.comparator());\n", "    CollectorTester.of(\n", "            ImmutableSortedMultiset.<String>toImmutableSortedMultiset(\n", "                String.CASE_INSENSITIVE_ORDER),\n", "            equivalence)\n", "        .expectCollects(ImmutableSortedMultiset.emptyMultiset(String.CASE_INSENSITIVE_ORDER))\n", "        .expectCollects(\n", "            ImmutableSortedMultiset.orderedBy(String.CASE_INSENSITIVE_ORDER)\n", "                .addCopies(\"a\", 2)\n", "                .addCopies(\"b\", 1)\n", "                .addCopies(\"c\", 3)\n", "                .build(),\n", "            \"a\",\n", "            \"c\",\n", "            \"b\",\n", "            \"c\",\n", "            \"A\",\n", "            \"C\");\n", "  }\n", "\n"]}, "removed": {}, "added_lines": {"1": [33], "2": [44], "3": [413, 414, 415, 416, 417, 418, 419, 420, 421, 422, 423, 424, 425, 426, 427, 428, 429, 430, 431, 432, 433, 434, 435, 436, 437]}, "removed_lines": {}}, {"70": "guava-tests/test/com/google/common/collect/ImmutableSortedSetTest.java", "added": {"1": ["import com.google.common.base.Equivalence;\n"], "2": ["import com.google.common.testing.CollectorTester;\n"], "3": ["import java.util.function.BiPredicate;\n", "import java.util.stream.Collector;\n"], "4": ["  public void testToImmutableSortedSet() {\n", "    Collector<String, ?, ImmutableSortedSet<String>> collector =\n", "        ImmutableSortedSet.toImmutableSortedSet(Ordering.natural());\n", "    BiPredicate<ImmutableSortedSet<String>, ImmutableSortedSet<String>> equivalence =\n", "        Equivalence.equals().onResultOf(ImmutableSortedSet<String>::comparator)\n", "            .and(Equivalence.equals().onResultOf(ImmutableSortedSet::asList))\n", "            .and(Equivalence.equals());\n", "    CollectorTester.of(collector, equivalence)\n", "        .expectCollects(\n", "            ImmutableSortedSet.of(\"a\", \"b\", \"c\", \"d\"), \"a\", \"b\", \"a\", \"c\", \"b\", \"b\", \"d\");\n", "  }\n", "\n", "  public void testToImmutableSortedSet_customComparator() {\n", "    Collector<String, ?, ImmutableSortedSet<String>> collector =\n", "        ImmutableSortedSet.toImmutableSortedSet(String.CASE_INSENSITIVE_ORDER);\n", "    BiPredicate<ImmutableSortedSet<String>, ImmutableSortedSet<String>> equivalence =\n", "        (set1, set2) ->\n", "            set1.equals(set2) && set1.asList().equals(set2.asList())\n", "                && set1.comparator().equals(set2.comparator());\n", "    ImmutableSortedSet<String> expected =\n", "        ImmutableSortedSet.orderedBy(String.CASE_INSENSITIVE_ORDER)\n", "            .add(\"a\", \"B\", \"c\", \"d\")\n", "            .build();\n", "    CollectorTester.of(collector, equivalence)\n", "        .expectCollects(expected, \"a\", \"B\", \"a\", \"c\", \"b\", \"b\", \"d\");\n", "  }\n", "\n", "  public void testToImmutableSortedSet_duplicates() {\n", "    class TypeWithDuplicates implements Comparable<TypeWithDuplicates> {\n", "      final int a;\n", "      final int b;\n", "\n", "      TypeWithDuplicates(int a, int b) {\n", "        this.a = a;\n", "        this.b = b;\n", "      }\n", "\n", "      @Override\n", "      public int compareTo(TypeWithDuplicates o) {\n", "        return Integer.compare(a, o.a);\n", "      }\n", "\n", "      public boolean fullEquals(TypeWithDuplicates other) {\n", "        return other != null && a == other.a && b == other.b;\n", "      }\n", "    }\n", "\n", "    Collector<TypeWithDuplicates, ?, ImmutableSortedSet<TypeWithDuplicates>> collector =\n", "        ImmutableSortedSet.toImmutableSortedSet(Ordering.natural());\n", "    BiPredicate<ImmutableSortedSet<TypeWithDuplicates>, ImmutableSortedSet<TypeWithDuplicates>>\n", "        equivalence = (set1, set2) -> {\n", "            if (!set1.equals(set2)) {\n", "              return false;\n", "            }\n", "            for (int i = 0; i < set1.size(); i++) {\n", "              if (!set1.asList().get(i).fullEquals(set2.asList().get(i))) {\n", "                return false;\n", "              }\n", "            }\n", "            return true;\n", "          };\n", "    TypeWithDuplicates a = new TypeWithDuplicates(1, 1);\n", "    TypeWithDuplicates b1 = new TypeWithDuplicates(2, 1);\n", "    TypeWithDuplicates b2 = new TypeWithDuplicates(2, 2);\n", "    TypeWithDuplicates c = new TypeWithDuplicates(3, 1);\n", "    CollectorTester.of(collector, equivalence)\n", "        .expectCollects(ImmutableSortedSet.of(a, b1, c), a, b1, c, b2);\n", "  }\n", "\n"]}, "removed": {}, "added_lines": {"1": [24], "2": [39], "3": [51, 52], "4": [670, 671, 672, 673, 674, 675, 676, 677, 678, 679, 680, 681, 682, 683, 684, 685, 686, 687, 688, 689, 690, 691, 692, 693, 694, 695, 696, 697, 698, 699, 700, 701, 702, 703, 704, 705, 706, 707, 708, 709, 710, 711, 712, 713, 714, 715, 716, 717, 718, 719, 720, 721, 722, 723, 724, 725, 726, 727, 728, 729, 730, 731, 732, 733, 734, 735, 736, 737, 738]}, "removed_lines": {}}, {"71": "guava-tests/test/com/google/common/collect/ImmutableTableTest.java", "added": {"1": ["import com.google.common.base.Equivalence;\n", "import com.google.common.collect.Table.Cell;\n", "import com.google.common.testing.CollectorTester;\n", "import java.util.stream.Collector;\n"], "2": ["  public void testToImmutableTable() {\n", "    Collector<Cell<String, String, Integer>, ?, ImmutableTable<String, String, Integer>> collector =\n", "        ImmutableTable.toImmutableTable(Cell::getRowKey, Cell::getColumnKey, Cell::getValue);\n", "    Equivalence<ImmutableTable<String, String, Integer>> equivalence =\n", "        Equivalence.equals()\n", "            .<Cell<String, String, Integer>>pairwise()\n", "            .onResultOf(ImmutableTable::cellSet);\n", "    CollectorTester.of(collector, equivalence)\n", "        .expectCollects(\n", "            new ImmutableTable.Builder<String, String, Integer>()\n", "                .put(\"one\", \"uno\", 1)\n", "                .put(\"two\", \"dos\", 2)\n", "                .put(\"three\", \"tres\", 3)\n", "                .build(),\n", "            Tables.immutableCell(\"one\", \"uno\", 1),\n", "            Tables.immutableCell(\"two\", \"dos\", 2),\n", "            Tables.immutableCell(\"three\", \"tres\", 3));\n", "  }\n", "\n"]}, "removed": {}, "added_lines": {"1": [23, 24, 25, 27], "2": [46, 47, 48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 58, 59, 60, 61, 62, 63, 64]}, "removed_lines": {}}, {"72": "guava-tests/test/com/google/common/collect/LinkedHashMultimapTest.java", "added": {"1": ["import java.util.ArrayList;\n"], "2": ["\n", "  public void testKeysSpliterator() {\n", "    List<Entry<String, Integer>> expectedEntries =\n", "        asList(\n", "            Maps.immutableEntry(\"foo\", 2),\n", "            Maps.immutableEntry(\"foo\", 3),\n", "            Maps.immutableEntry(\"bar\", 4),\n", "            Maps.immutableEntry(\"bar\", 5),\n", "            Maps.immutableEntry(\"foo\", 6));\n", "    Multimap<String, Integer> multimap = LinkedHashMultimap.create();\n", "    for (Entry<String, Integer> entry : expectedEntries) {\n", "      multimap.put(entry.getKey(), entry.getValue());\n", "    }\n", "    List<String> actualKeys = new ArrayList<>();\n", "    multimap.keys().spliterator().forEachRemaining(actualKeys::add);\n", "    assertThat(actualKeys)\n", "        .containsExactlyElementsIn(Lists.transform(expectedEntries, Entry::getKey))\n", "        .inOrder();\n", "  }\n", "\n", "  public void testEntriesSpliterator() {\n", "    List<Entry<String, Integer>> expectedEntries =\n", "        asList(\n", "            Maps.immutableEntry(\"foo\", 2),\n", "            Maps.immutableEntry(\"foo\", 3),\n", "            Maps.immutableEntry(\"bar\", 4),\n", "            Maps.immutableEntry(\"bar\", 5),\n", "            Maps.immutableEntry(\"foo\", 6));\n", "    Multimap<String, Integer> multimap = LinkedHashMultimap.create();\n", "    for (Entry<String, Integer> entry : expectedEntries) {\n", "      multimap.put(entry.getKey(), entry.getValue());\n", "    }\n", "    List<Entry<String, Integer>> actualEntries = new ArrayList<>();\n", "    multimap.entries().spliterator().forEachRemaining(actualEntries::add);\n", "    assertThat(actualEntries).containsExactlyElementsIn(expectedEntries).inOrder();\n", "  }\n", "\n", "  public void testValuesSpliterator() {\n", "    List<Entry<String, Integer>> expectedEntries =\n", "        asList(\n", "            Maps.immutableEntry(\"foo\", 2),\n", "            Maps.immutableEntry(\"foo\", 3),\n", "            Maps.immutableEntry(\"bar\", 4),\n", "            Maps.immutableEntry(\"bar\", 5),\n", "            Maps.immutableEntry(\"foo\", 6));\n", "    Multimap<String, Integer> multimap = LinkedHashMultimap.create();\n", "    for (Entry<String, Integer> entry : expectedEntries) {\n", "      multimap.put(entry.getKey(), entry.getValue());\n", "    }\n", "    List<Integer> actualValues = new ArrayList<>();\n", "    multimap.values().spliterator().forEachRemaining(actualValues::add);\n", "    assertThat(actualValues)\n", "        .containsExactlyElementsIn(Lists.transform(expectedEntries, Entry::getValue))\n", "        .inOrder();\n", "  }\n"]}, "removed": {}, "added_lines": {"1": [37], "2": [433, 434, 435, 436, 437, 438, 439, 440, 441, 442, 443, 444, 445, 446, 447, 448, 449, 450, 451, 452, 453, 454, 455, 456, 457, 458, 459, 460, 461, 462, 463, 464, 465, 466, 467, 468, 469, 470, 471, 472, 473, 474, 475, 476, 477, 478, 479, 480, 481, 482, 483, 484, 485, 486, 487]}, "removed_lines": {}}, {"73": "guava-tests/test/com/google/common/collect/MoreCollectorsTest.java", "added": {"1": ["/*\n", " * Copyright (C) 2016 The Guava Authors\n", " *\n", " * Licensed under the Apache License, Version 2.0 (the \"License\");\n", " * you may not use this file except in compliance with the License.\n", " * You may obtain a copy of the License at\n", " *\n", " * http://www.apache.org/licenses/LICENSE-2.0\n", " *\n", " * Unless required by applicable law or agreed to in writing, software\n", " * distributed under the License is distributed on an \"AS IS\" BASIS,\n", " * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n", " * See the License for the specific language governing permissions and\n", " * limitations under the License.\n", " */\n", "\n", "package com.google.common.collect;\n", "\n", "import static com.google.common.truth.Truth.assertThat;\n", "import static com.google.common.truth.Truth8.assertThat;\n", "\n", "import com.google.common.annotations.GwtCompatible;\n", "import java.util.NoSuchElementException;\n", "import java.util.stream.Stream;\n", "import junit.framework.TestCase;\n", "\n", "/**\n", " * Tests for {@code MoreCollectors}.\n", " *\n", " * @author Louis Wasserman\n", " */\n", "@GwtCompatible\n", "public class MoreCollectorsTest extends TestCase {\n", "  public void testToOptionalEmpty() {\n", "    assertThat(Stream.empty().collect(MoreCollectors.toOptional())).isEmpty();\n", "  }\n", "\n", "  public void testToOptionalSingleton() {\n", "    assertThat(Stream.of(1).collect(MoreCollectors.toOptional())).hasValue(1);\n", "  }\n", "\n", "  public void testToOptionalNull() {\n", "    Stream<Object> stream = Stream.of((Object) null);\n", "    try {\n", "      stream.collect(MoreCollectors.toOptional());\n", "      fail(\"Expected NullPointerException\");\n", "    } catch (NullPointerException expected) {\n", "    }\n", "  }\n", "\n", "  public void testToOptionalMultiple() {\n", "    try {\n", "      Stream.of(1, 2).collect(MoreCollectors.toOptional());\n", "      fail(\"Expected IllegalArgumentException\");\n", "    } catch (IllegalArgumentException expected) {\n", "      assertThat(expected.getMessage()).contains(\"1, 2\");\n", "    }\n", "  }\n", "\n", "  public void testToOptionalMany() {\n", "    try {\n", "      Stream.of(1, 2, 3, 4, 5, 6).collect(MoreCollectors.toOptional());\n", "      fail(\"Expected IllegalArgumentException\");\n", "    } catch (IllegalArgumentException expected) {\n", "      assertThat(expected.getMessage()).contains(\"1, 2, 3, 4, 5, ...\");\n", "    }\n", "  }\n", "\n", "  public void testOnlyElement() {\n", "    try {\n", "      Stream.empty().collect(MoreCollectors.onlyElement());\n", "      fail(\"Expected NoSuchElementException\");\n", "    } catch (NoSuchElementException expected) {\n", "    }\n", "  }\n", "\n", "  public void testOnlyElementSingleton() {\n", "    assertThat(Stream.of(1).collect(MoreCollectors.onlyElement())).isEqualTo(1);\n", "  }\n", "\n", "  public void testOnlyElementNull() {\n", "    assertThat(Stream.of((Object) null).collect(MoreCollectors.onlyElement())).isNull();\n", "  }\n", "\n", "  public void testOnlyElementMultiple() {\n", "    try {\n", "      Stream.of(1, 2).collect(MoreCollectors.onlyElement());\n", "      fail(\"Expected IllegalArgumentException\");\n", "    } catch (IllegalArgumentException expected) {\n", "      assertThat(expected.getMessage()).contains(\"1, 2\");\n", "    }\n", "  }\n", "\n", "  public void testOnlyElementMany() {\n", "    try {\n", "      Stream.of(1, 2, 3, 4, 5, 6).collect(MoreCollectors.onlyElement());\n", "      fail(\"Expected IllegalArgumentException\");\n", "    } catch (IllegalArgumentException expected) {\n", "      assertThat(expected.getMessage()).contains(\"1, 2, 3, 4, 5, ...\");\n", "    }\n", "  }\n", "}\n"]}, "removed": {}, "added_lines": {"1": [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 58, 59, 60, 61, 62, 63, 64, 65, 66, 67, 68, 69, 70, 71, 72, 73, 74, 75, 76, 77, 78, 79, 80, 81, 82, 83, 84, 85, 86, 87, 88, 89, 90, 91, 92, 93, 94, 95, 96, 97, 98, 99, 100, 101, 102]}, "removed_lines": {}}, {"74": "guava-tests/test/com/google/common/collect/StreamsTest.java", "added": {"1": ["/*\n", " * Copyright (C) 2016 The Guava Authors\n", " *\n", " * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not use this file except\n", " * in compliance with the License. You may obtain a copy of the License at\n", " *\n", " * http://www.apache.org/licenses/LICENSE-2.0\n", " *\n", " * Unless required by applicable law or agreed to in writing, software distributed under the License\n", " * is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express\n", " * or implied. See the License for the specific language governing permissions and limitations under\n", " * the License.\n", " */\n", "\n", "package com.google.common.collect;\n", "\n", "import static com.google.common.collect.Streams.findLast;\n", "import static com.google.common.collect.Streams.stream;\n", "\n", "import com.google.common.collect.testing.SpliteratorTester;\n", "import com.google.common.primitives.Doubles;\n", "import com.google.common.truth.IterableSubject;\n", "import com.google.common.truth.Truth;\n", "import com.google.common.truth.Truth8;\n", "import java.util.ArrayList;\n", "import java.util.Arrays;\n", "import java.util.Collection;\n", "import java.util.LinkedHashSet;\n", "import java.util.LinkedList;\n", "import java.util.List;\n", "import java.util.OptionalDouble;\n", "import java.util.OptionalInt;\n", "import java.util.OptionalLong;\n", "import java.util.function.Function;\n", "import java.util.stream.Collectors;\n", "import java.util.stream.DoubleStream;\n", "import java.util.stream.IntStream;\n", "import java.util.stream.LongStream;\n", "import java.util.stream.Stream;\n", "import junit.framework.TestCase;\n", "\n", "/**\n", " * Unit test for {@link Streams}.\n", " */\n", "public class StreamsTest extends TestCase {\n", "  /*\n", "   * Full and proper black-box testing of a Stream-returning method is extremely involved, and is\n", "   * overkill when nearly all Streams are produced using well-tested JDK calls. So, we cheat and\n", "   * just test that the toArray() contents are as expected.\n", "   */\n", "  public void testStream_nonCollection() {\n", "    assertThat(stream(FluentIterable.of())).isEmpty();\n", "    assertThat(stream(FluentIterable.of(\"a\"))).containsExactly(\"a\");\n", "    assertThat(stream(FluentIterable.of(1, 2, 3)).filter(n -> n > 1)).containsExactly(2, 3);\n", "  }\n", "\n", "  @SuppressWarnings(\"deprecation\")\n", "  public void testStream_collection() {\n", "    assertThat(stream(Arrays.asList())).isEmpty();\n", "    assertThat(stream(Arrays.asList(\"a\"))).containsExactly(\"a\");\n", "    assertThat(stream(Arrays.asList(1, 2, 3)).filter(n -> n > 1)).containsExactly(2, 3);\n", "  }\n", "\n", "  public void testStream_iterator() {\n", "    assertThat(stream(Arrays.asList().iterator())).isEmpty();\n", "    assertThat(stream(Arrays.asList(\"a\").iterator())).containsExactly(\"a\");\n", "    assertThat(stream(Arrays.asList(1, 2, 3).iterator()).filter(n -> n > 1)).containsExactly(2, 3);\n", "  }\n", "\n", "  public void testStream_googleOptional() {\n", "    assertThat(stream(com.google.common.base.Optional.absent())).isEmpty();\n", "    assertThat(stream(com.google.common.base.Optional.of(\"a\"))).containsExactly(\"a\");\n", "  }\n", "\n", "  public void testStream_javaOptional() {\n", "    assertThat(stream(java.util.Optional.empty())).isEmpty();\n", "    assertThat(stream(java.util.Optional.of(\"a\"))).containsExactly(\"a\");\n", "  }\n", "  \n", "  public void testFindLast_refStream() {\n", "    Truth8.assertThat(findLast(Stream.of())).isEmpty();\n", "    Truth8.assertThat(findLast(Stream.of(\"a\", \"b\", \"c\", \"d\"))).hasValue(\"d\");\n", "\n", "    // test with a large, not-subsized Spliterator\n", "    List<Integer> list =\n", "        IntStream.rangeClosed(0, 10000).boxed().collect(Collectors.toCollection(LinkedList::new));\n", "    Truth8.assertThat(findLast(list.stream())).hasValue(10000);\n", "\n", "    // no way to find out the stream is empty without walking its spliterator\n", "    Truth8.assertThat(findLast(list.stream().filter(i -> i < 0))).isEmpty();\n", "  }\n", "\n", "  public void testFindLast_intStream() {\n", "    Truth.assertThat(findLast(IntStream.of())).isEqualTo(OptionalInt.empty());\n", "    Truth.assertThat(findLast(IntStream.of(1, 2, 3, 4, 5))).isEqualTo(OptionalInt.of(5));\n", "\n", "    // test with a large, not-subsized Spliterator\n", "    List<Integer> list =\n", "        IntStream.rangeClosed(0, 10000).boxed().collect(Collectors.toCollection(LinkedList::new));\n", "    Truth.assertThat(findLast(list.stream().mapToInt(i -> i))).isEqualTo(OptionalInt.of(10000));\n", "\n", "    // no way to find out the stream is empty without walking its spliterator\n", "    Truth.assertThat(findLast(list.stream().mapToInt(i -> i).filter(i -> i < 0)))\n", "        .isEqualTo(OptionalInt.empty());\n", "  }\n", "\n", "  public void testFindLast_longStream() {\n", "    Truth.assertThat(findLast(LongStream.of())).isEqualTo(OptionalLong.empty());\n", "    Truth.assertThat(findLast(LongStream.of(1, 2, 3, 4, 5))).isEqualTo(OptionalLong.of(5));\n", "\n", "    // test with a large, not-subsized Spliterator\n", "    List<Long> list =\n", "        LongStream.rangeClosed(0, 10000).boxed().collect(Collectors.toCollection(LinkedList::new));\n", "    Truth.assertThat(findLast(list.stream().mapToLong(i -> i))).isEqualTo(OptionalLong.of(10000));\n", "\n", "    // no way to find out the stream is empty without walking its spliterator\n", "    Truth.assertThat(findLast(list.stream().mapToLong(i -> i).filter(i -> i < 0)))\n", "        .isEqualTo(OptionalLong.empty());\n", "  }\n", "\n", "  public void testFindLast_doubleStream() {\n", "    Truth.assertThat(findLast(DoubleStream.of())).isEqualTo(OptionalDouble.empty());\n", "    Truth.assertThat(findLast(DoubleStream.of(1, 2, 3, 4, 5))).isEqualTo(OptionalDouble.of(5));\n", "\n", "    // test with a large, not-subsized Spliterator\n", "    List<Long> list =\n", "        LongStream.rangeClosed(0, 10000).boxed().collect(Collectors.toCollection(LinkedList::new));\n", "    Truth.assertThat(findLast(list.stream().mapToDouble(i -> i)))\n", "        .isEqualTo(OptionalDouble.of(10000));\n", "\n", "    // no way to find out the stream is empty without walking its spliterator\n", "    Truth.assertThat(findLast(list.stream().mapToDouble(i -> i).filter(i -> i < 0)))\n", "        .isEqualTo(OptionalDouble.empty());\n", "  }\n", "\n", "  public void testConcat_refStream() {\n", "    assertThat(Streams.concat(Stream.of(\"a\"), Stream.of(\"b\"), Stream.empty(), Stream.of(\"c\", \"d\")))\n", "        .containsExactly(\"a\", \"b\", \"c\", \"d\")\n", "        .inOrder();\n", "  }\n", "\n", "  public void testConcat_intStream() {\n", "    assertThat(\n", "            Streams.concat(IntStream.of(1), IntStream.of(2), IntStream.empty(), IntStream.of(3, 4)))\n", "        .containsExactly(1, 2, 3, 4)\n", "        .inOrder();\n", "  }\n", "\n", "  public void testConcat_longStream() {\n", "    assertThat(\n", "            Streams.concat(\n", "                LongStream.of(1), LongStream.of(2), LongStream.empty(), LongStream.of(3, 4)))\n", "        .containsExactly(1L, 2L, 3L, 4L)\n", "        .inOrder();\n", "  }\n", "\n", "  public void testConcat_doubleStream() {\n", "    assertThat(\n", "            Streams.concat(\n", "                DoubleStream.of(1),\n", "                DoubleStream.of(2),\n", "                DoubleStream.empty(),\n", "                DoubleStream.of(3, 4)))\n", "        .containsExactly(1.0, 2.0, 3.0, 4.0)\n", "        .inOrder();\n", "  }\n", "\n", "  public void testStream_optionalInt() {\n", "    assertThat(stream(java.util.OptionalInt.empty())).isEmpty();\n", "    assertThat(stream(java.util.OptionalInt.of(5))).containsExactly(5);\n", "  }\n", "\n", "  public void testStream_optionalLong() {\n", "    assertThat(stream(java.util.OptionalLong.empty())).isEmpty();\n", "    assertThat(stream(java.util.OptionalLong.of(5L))).containsExactly(5L);\n", "  }\n", "\n", "  public void testStream_optionalDouble() {\n", "    assertThat(stream(java.util.OptionalDouble.empty())).isEmpty();\n", "    assertThat(stream(java.util.OptionalDouble.of(5.0))).containsExactly(5.0);\n", "  }\n", "  \n", "  private void testMapWithIndex(Function<Collection<String>, Stream<String>> collectionImpl) {\n", "    SpliteratorTester.of(\n", "            () ->\n", "                Streams.mapWithIndex(\n", "                        collectionImpl.apply(ImmutableList.of()), (str, i) -> str + \":\" + i)\n", "                    .spliterator())\n", "        .expect(ImmutableList.of());\n", "    SpliteratorTester.of(\n", "            () ->\n", "                Streams.mapWithIndex(\n", "                        collectionImpl.apply(ImmutableList.of(\"a\", \"b\", \"c\", \"d\", \"e\")),\n", "                        (str, i) -> str + \":\" + i)\n", "                    .spliterator())\n", "        .expect(\"a:0\", \"b:1\", \"c:2\", \"d:3\", \"e:4\");\n", "  }\n", "\n", "  public void testMapWithIndex_arrayListSource() {\n", "    testMapWithIndex(elems -> new ArrayList<>(elems).stream());\n", "  }\n", "\n", "  public void testMapWithIndex_linkedHashSetSource() {\n", "    testMapWithIndex(elems -> new LinkedHashSet<>(elems).stream());\n", "  }\n", "\n", "  public void testMapWithIndex_unsizedSource() {\n", "    testMapWithIndex(\n", "        elems -> Stream.of((Object) null).flatMap(unused -> ImmutableList.copyOf(elems).stream()));\n", "  }\n", "\n", "  public void testZip() {\n", "    assertThat(Streams.zip(Stream.of(\"a\", \"b\", \"c\"), Stream.of(1, 2, 3), (a, b) -> a + \":\" + b))\n", "        .containsExactly(\"a:1\", \"b:2\", \"c:3\")\n", "        .inOrder();\n", "  }\n", "\n", "  public void testZipFiniteWithInfinite() {\n", "    assertThat(\n", "            Streams.zip(\n", "                Stream.of(\"a\", \"b\", \"c\"), Stream.iterate(1, i -> i + 1), (a, b) -> a + \":\" + b))\n", "        .containsExactly(\"a:1\", \"b:2\", \"c:3\")\n", "        .inOrder();\n", "  }\n", "\n", "  public void testZipInfiniteWithInfinite() {\n", "    // zip is doing an infinite zip, but we truncate the result so we can actually test it\n", "    // but we want the zip itself to work\n", "    assertThat(\n", "            Streams.zip(\n", "                    Stream.iterate(1, i -> i + 1).map(String::valueOf),\n", "                    Stream.iterate(1, i -> i + 1),\n", "                    (String str, Integer i) -> str.equals(Integer.toString(i)))\n", "                .limit(100))\n", "        .doesNotContain(false);\n", "  }\n", "\n", "  public void testZipDifferingLengths() {\n", "    assertThat(\n", "            Streams.zip(Stream.of(\"a\", \"b\", \"c\", \"d\"), Stream.of(1, 2, 3), (a, b) -> a + \":\" + b))\n", "        .containsExactly(\"a:1\", \"b:2\", \"c:3\")\n", "        .inOrder();\n", "    assertThat(Streams.zip(Stream.of(\"a\", \"b\", \"c\"), Stream.of(1, 2, 3, 4), (a, b) -> a + \":\" + b))\n", "        .containsExactly(\"a:1\", \"b:2\", \"c:3\")\n", "        .inOrder();\n", "  }\n", "\n", "  // TODO(kevinb): switch to importing Truth's assertThat(Stream) if we get that added\n", "  private static IterableSubject assertThat(Stream<?> stream) {\n", "    return Truth.assertThat(stream.toArray()).asList();\n", "  }\n", "  \n", "  private static IterableSubject assertThat(IntStream stream) {\n", "    return Truth.assertThat(stream.toArray()).asList();\n", "  }\n", "\n", "  private static IterableSubject assertThat(LongStream stream) {\n", "    return Truth.assertThat(stream.toArray()).asList();\n", "  }\n", "\n", "  private static IterableSubject assertThat(DoubleStream stream) {\n", "    return Truth.assertThat(Doubles.asList(stream.toArray()));\n", "  }\n", "}\n"]}, "removed": {}, "added_lines": {"1": [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 58, 59, 60, 61, 62, 63, 64, 65, 66, 67, 68, 69, 70, 71, 72, 73, 74, 75, 76, 77, 78, 79, 80, 81, 82, 83, 84, 85, 86, 87, 88, 89, 90, 91, 92, 93, 94, 95, 96, 97, 98, 99, 100, 101, 102, 103, 104, 105, 106, 107, 108, 109, 110, 111, 112, 113, 114, 115, 116, 117, 118, 119, 120, 121, 122, 123, 124, 125, 126, 127, 128, 129, 130, 131, 132, 133, 134, 135, 136, 137, 138, 139, 140, 141, 142, 143, 144, 145, 146, 147, 148, 149, 150, 151, 152, 153, 154, 155, 156, 157, 158, 159, 160, 161, 162, 163, 164, 165, 166, 167, 168, 169, 170, 171, 172, 173, 174, 175, 176, 177, 178, 179, 180, 181, 182, 183, 184, 185, 186, 187, 188, 189, 190, 191, 192, 193, 194, 195, 196, 197, 198, 199, 200, 201, 202, 203, 204, 205, 206, 207, 208, 209, 210, 211, 212, 213, 214, 215, 216, 217, 218, 219, 220, 221, 222, 223, 224, 225, 226, 227, 228, 229, 230, 231, 232, 233, 234, 235, 236, 237, 238, 239, 240, 241, 242, 243, 244, 245, 246, 247, 248, 249, 250, 251, 252, 253, 254, 255, 256, 257, 258, 259, 260, 261, 262, 263, 264]}, "removed_lines": {}}, {"75": "guava-tests/test/com/google/common/collect/SynchronizedBiMapTest.java", "added": {"1": ["import java.util.function.BiFunction;\n"], "2": ["    @Override\n", "    public void replaceAll(BiFunction<? super K, ? super V, ? extends V> function) {\n", "      assertTrue(Thread.holdsLock(mutex));\n", "      delegate.replaceAll(function);\n", "    }\n", "\n"]}, "removed": {}, "added_lines": {"1": [31], "2": [123, 124, 125, 126, 127, 128]}, "removed_lines": {}}, {"76": "guava-tests/test/com/google/common/collect/SynchronizedNavigableSetTest.java", "added": {"1": ["    TestSet<E> inner =\n", "        new TestSet<E>(new TreeSet<E>((Comparator<E>) Ordering.natural().nullsFirst()), null);\n", "    NavigableSet<E> outer = Synchronized.navigableSet(inner, null);\n", "    inner.mutex = outer;\n"], "2": ["        NavigableSetTestSuiteBuilder.using(\n", "                new TestStringSortedSetGenerator() {\n", "\n", "                  @Override\n", "                  protected NavigableSet<String> create(String[] elements) {\n", "                    NavigableSet<String> innermost = new SafeTreeSet<String>();\n", "                    Collections.addAll(innermost, elements);\n", "                    TestSet<String> inner = new TestSet<String>(innermost, null);\n", "                    NavigableSet<String> outer = Synchronized.navigableSet(inner, null);\n", "                    inner.mutex = outer;\n", "                    return outer;\n", "                  }\n", "\n", "                  @Override\n", "                  public List<String> order(List<String> insertionOrder) {\n", "                    return Ordering.natural().sortedCopy(insertionOrder);\n", "                  }\n", "                })\n", "            .named(\"Sets.synchronizedNavigableSet[SafeTreeSet]\")\n", "            .withFeatures(\n", "                CollectionSize.ANY,\n", "                CollectionFeature.KNOWN_ORDER,\n", "                CollectionFeature.GENERAL_PURPOSE,\n", "                CollectionFeature.SERIALIZABLE)\n", "    NavigableSet<String> set = create();\n", "    NavigableSet<String> descendingSet = set.descendingSet();\n", "    assertSame(set, ((SynchronizedNavigableSet<String>) descendingSet).mutex);\n", "    NavigableSet<String> set = create();\n", "    SortedSet<String> headSet = set.headSet(\"a\");\n", "    assertSame(set, ((SynchronizedSortedSet<String>) headSet).mutex);\n", "    NavigableSet<String> set = create();\n", "    NavigableSet<String> headSet = set.headSet(\"a\", true);\n", "    assertSame(set, ((SynchronizedNavigableSet<String>) headSet).mutex);\n", "    NavigableSet<String> set = create();\n", "    SortedSet<String> subSet = set.subSet(\"a\", \"b\");\n", "    assertSame(set, ((SynchronizedSortedSet<String>) subSet).mutex);\n", "    NavigableSet<String> set = create();\n", "    NavigableSet<String> subSet = set.subSet(\"a\", false, \"b\", true);\n", "    assertSame(set, ((SynchronizedNavigableSet<String>) subSet).mutex);\n", "    NavigableSet<String> set = create();\n", "    SortedSet<String> tailSet = set.tailSet(\"a\");\n", "    assertSame(set, ((SynchronizedSortedSet<String>) tailSet).mutex);\n", "    NavigableSet<String> set = create();\n", "    NavigableSet<String> tailSet = set.tailSet(\"a\", true);\n", "    assertSame(set, ((SynchronizedNavigableSet<String>) tailSet).mutex);\n"]}, "removed": {"1": ["  private static final Object MUTEX = new Integer(1); // something Serializable\n", "    TestSet<E> inner = new TestSet<E>(\n", "        new TreeSet<E>((Comparator<E>) Ordering.natural().nullsFirst()), MUTEX);\n", "    NavigableSet<E> outer =\n", "        Synchronized.navigableSet(inner, MUTEX);\n"], "2": ["        NavigableSetTestSuiteBuilder.using(new TestStringSortedSetGenerator() {\n", "\n", "          @Override protected NavigableSet<String> create(String[] elements) {\n", "            NavigableSet<String> innermost = new SafeTreeSet<String>();\n", "            Collections.addAll(innermost, elements);\n", "            TestSet<String> inner = new TestSet<String>(innermost, MUTEX);\n", "            NavigableSet<String> outer =\n", "                Synchronized.navigableSet(inner, MUTEX);\n", "            return outer;\n", "          }\n", "\n", "          @Override public List<String> order(List<String> insertionOrder) {\n", "            return Ordering.natural().sortedCopy(insertionOrder);\n", "          }\n", "        }).named(\"Sets.synchronizedNavigableSet[SafeTreeSet]\")\n", "            .withFeatures(CollectionSize.ANY, CollectionFeature.KNOWN_ORDER,\n", "                CollectionFeature.GENERAL_PURPOSE, CollectionFeature.SERIALIZABLE)\n", "    NavigableSet<String> map = create();\n", "    NavigableSet<String> descendingSet = map.descendingSet();\n", "    assertSame(MUTEX, ((SynchronizedNavigableSet<String>) descendingSet).mutex);\n", "    NavigableSet<String> map = create();\n", "    SortedSet<String> headSet = map.headSet(\"a\");\n", "    assertSame(MUTEX, ((SynchronizedSortedSet<String>) headSet).mutex);\n", "    NavigableSet<String> map = create();\n", "    NavigableSet<String> headSet = map.headSet(\"a\", true);\n", "    assertSame(MUTEX, ((SynchronizedNavigableSet<String>) headSet).mutex);\n", "    NavigableSet<String> map = create();\n", "    SortedSet<String> subSet = map.subSet(\"a\", \"b\");\n", "    assertSame(MUTEX, ((SynchronizedSortedSet<String>) subSet).mutex);\n", "    NavigableSet<String> map = create();\n", "    NavigableSet<String> subSet = map.subSet(\"a\", false, \"b\", true);\n", "    assertSame(MUTEX, ((SynchronizedNavigableSet<String>) subSet).mutex);\n", "    NavigableSet<String> map = create();\n", "    SortedSet<String> tailSet = map.tailSet(\"a\");\n", "    assertSame(MUTEX, ((SynchronizedSortedSet<String>) tailSet).mutex);\n", "    NavigableSet<String> map = create();\n", "    NavigableSet<String> tailSet = map.tailSet(\"a\", true);\n", "    assertSame(MUTEX, ((SynchronizedNavigableSet<String>) tailSet).mutex);\n"]}, "added_lines": {"1": [45, 46, 47, 48], "2": [152, 153, 154, 155, 156, 157, 158, 159, 160, 161, 162, 163, 164, 165, 166, 167, 168, 169, 170, 171, 172, 173, 174, 175, 182, 183, 185, 189, 190, 192, 196, 197, 199, 203, 204, 206, 210, 211, 213, 217, 218, 220, 224, 225, 227]}, "removed_lines": {"1": [42, 46, 47, 48, 49], "2": [153, 154, 155, 156, 157, 158, 159, 160, 161, 162, 163, 164, 165, 166, 167, 168, 169, 176, 177, 179, 183, 184, 186, 190, 191, 193, 197, 198, 200, 204, 205, 207, 211, 212, 214, 218, 219, 221]}}, {"77": "guava-tests/test/com/google/common/collect/SynchronizedQueueTest.java", "added": {"1": ["    Queue<String> outer = Synchronized.queue(inner, null);\n", "    inner.mutex = outer;\n", "    outer.add(\"foo\"); // necessary because we try to remove elements later on\n", "    public Object mutex;\n"]}, "removed": {"1": ["    Queue<String> outer = Synchronized.queue(inner, inner.mutex);\n", "    outer.add(\"foo\");  // necessary because we try to remove elements later on\n", "    public final Object mutex = new Integer(1); // something Serializable\n"]}, "added_lines": {"1": [33, 34, 35, 41]}, "removed_lines": {"1": [33, 34, 40]}}, {"78": "guava-tests/test/com/google/common/collect/SynchronizedSetTest.java", "added": {"2": ["    return SetTestSuiteBuilder.using(\n", "            new TestStringSetGenerator() {\n", "              @Override\n", "              protected Set<String> create(String[] elements) {\n", "                TestSet<String> inner = new TestSet<String>(new HashSet<String>(), null);\n", "                Set<String> outer = Synchronized.set(inner, null);\n", "                inner.mutex = outer;\n", "                Collections.addAll(outer, elements);\n", "                return outer;\n", "              }\n", "            })\n", "        .withFeatures(\n", "            CollectionFeature.GENERAL_PURPOSE,\n"], "3": ["    public Object mutex;\n"]}, "removed": {"1": ["import static com.google.common.base.Preconditions.checkNotNull;\n", "\n"], "2": ["    return SetTestSuiteBuilder.using(new TestStringSetGenerator() {\n", "          @Override\n", "          protected Set<String> create(String[] elements) {\n", "            TestSet<String> inner = new TestSet<String>(new HashSet<String>(), MUTEX);\n", "            Set<String> outer = Synchronized.set(inner, inner.mutex);\n", "            Collections.addAll(outer, elements);\n", "            return outer;\n", "          }\n", "        })\n", "        .withFeatures(CollectionFeature.GENERAL_PURPOSE,\n"], "3": ["    public final Object mutex;\n", "      checkNotNull(mutex);\n"]}, "added_lines": {"2": [42, 43, 44, 45, 46, 47, 48, 49, 50, 51, 52, 54, 55], "3": [64]}, "removed_lines": {"1": [19, 20], "2": [44, 45, 46, 47, 48, 49, 50, 51, 52, 54], "3": [63, 66]}}, {"79": "guava-tests/test/com/google/common/collect/TreeTraverserTest.java", "added": {"1": ["  private static class Node {\n", "\n", "    Node(char value) {\n", "      this.value = value;\n", "    }\n", "  }\n", "\n", "  private static final class Tree extends Node {\n", "      super(value);\n", "  private static final class BinaryTree extends Node {\n", "    @Nullable final BinaryTree left;\n", "      super(value);\n"], "2": ["  static String iterationOrder(Iterable<? extends Node> iterable) {\n", "    for (Node t : iterable) {\n", "    StringBuilder forEachBuilder = new StringBuilder();\n", "    iterable.forEach(t -> forEachBuilder.append(t.value));\n", "    assertTrue(\n", "        \"Iterator content was \" + builder + \" but forEach content was \" + forEachBuilder,\n", "        builder.toString().contentEquals(forEachBuilder));\n", "    assertThat(iterationOrder(BIN_ADAPTER.preOrderTraversal(bd))).isEqualTo(\"dbacefg\");\n", "    assertThat(iterationOrder(BIN_ADAPTER.postOrderTraversal(bd))).isEqualTo(\"acbgfed\");\n", "    assertThat(iterationOrder(BIN_ADAPTER.breadthFirstTraversal(bd))).isEqualTo(\"dbeacfg\");\n", "    assertThat(iterationOrder(BIN_ADAPTER.inOrderTraversal(bd))).isEqualTo(\"abcdegf\");\n"]}, "removed": {"1": ["  private static final class Tree {\n", "      this.value = value;\n", "  private static final class BinaryTree {\n", "    final char value;\n", "    @Nullable\n", "    final BinaryTree left;\n", "      this.value = value;\n"], "2": ["  static String iterationOrder(Iterable<Tree> iterable) {\n", "    StringBuilder builder = new StringBuilder();\n", "    for (Tree t : iterable) {\n", "      builder.append(t.value);\n", "    }\n", "    return builder.toString();\n", "  }\n", "\n", "  static String binaryIterationOrder(Iterable<BinaryTree> iterable) {\n", "    for (BinaryTree t : iterable) {\n", "    assertThat(binaryIterationOrder(BIN_ADAPTER.preOrderTraversal(bd))).isEqualTo(\"dbacefg\");\n", "    assertThat(binaryIterationOrder(BIN_ADAPTER.postOrderTraversal(bd))).isEqualTo(\"acbgfed\");\n", "    assertThat(binaryIterationOrder(BIN_ADAPTER.breadthFirstTraversal(bd))).isEqualTo(\"dbeacfg\");\n", "    assertThat(binaryIterationOrder(BIN_ADAPTER.inOrderTraversal(bd))).isEqualTo(\"abcdegf\");\n"]}, "added_lines": {"1": [36, 38, 39, 40, 41, 42, 43, 44, 48, 53, 54, 59], "2": [126, 128, 131, 132, 133, 134, 135, 141, 146, 151, 155]}, "removed_lines": {"1": [36, 41, 46, 47, 48, 49, 54], "2": [121, 122, 123, 124, 125, 126, 127, 128, 129, 131, 139, 144, 149, 153]}}, {"80": "guava-tests/test/com/google/common/io/MoreFilesTest.java", "added": {"1": ["/*\n", " * Copyright (C) 2013 The Guava Authors\n", " *\n", " * Licensed under the Apache License, Version 2.0 (the \"License\");\n", " * you may not use this file except in compliance with the License.\n", " * You may obtain a copy of the License at\n", " *\n", " * http://www.apache.org/licenses/LICENSE-2.0\n", " *\n", " * Unless required by applicable law or agreed to in writing, software\n", " * distributed under the License is distributed on an \"AS IS\" BASIS,\n", " * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n", " * See the License for the specific language governing permissions and\n", " * limitations under the License.\n", " */\n", "\n", "package com.google.common.io;\n", "\n", "import static com.google.common.io.RecursiveDeleteOption.ALLOW_INSECURE;\n", "import static com.google.common.jimfs.Feature.SECURE_DIRECTORY_STREAM;\n", "import static com.google.common.jimfs.Feature.SYMBOLIC_LINKS;\n", "import static com.google.common.truth.Truth.assertThat;\n", "import static java.nio.file.LinkOption.NOFOLLOW_LINKS;\n", "\n", "import com.google.common.collect.ObjectArrays;\n", "import com.google.common.jimfs.Configuration;\n", "import com.google.common.jimfs.Feature;\n", "import com.google.common.jimfs.Jimfs;\n", "import java.io.IOException;\n", "import java.nio.file.FileAlreadyExistsException;\n", "import java.nio.file.FileSystem;\n", "import java.nio.file.FileSystemException;\n", "import java.nio.file.FileSystems;\n", "import java.nio.file.FileVisitResult;\n", "import java.nio.file.Files;\n", "import java.nio.file.Path;\n", "import java.nio.file.SimpleFileVisitor;\n", "import java.nio.file.attribute.BasicFileAttributes;\n", "import java.nio.file.attribute.FileTime;\n", "import java.util.EnumSet;\n", "import java.util.concurrent.ExecutorService;\n", "import java.util.concurrent.Executors;\n", "import junit.framework.TestCase;\n", "import junit.framework.TestSuite;\n", "\n", "/**\n", " * Tests for {@link MoreFiles}.\n", " *\n", " * @author Colin Decker\n", " */\n", "@AndroidIncompatible\n", "\n", "public class MoreFilesTest extends TestCase {\n", "\n", "  public static TestSuite suite() {\n", "    TestSuite suite = new TestSuite();\n", "    suite.addTest(ByteSourceTester.tests(\"MoreFiles.asByteSource[Path]\",\n", "        SourceSinkFactories.pathByteSourceFactory(), true));\n", "    suite.addTest(ByteSinkTester.tests(\"MoreFiles.asByteSink[Path]\",\n", "        SourceSinkFactories.pathByteSinkFactory()));\n", "    suite.addTest(ByteSinkTester.tests(\"MoreFiles.asByteSink[Path, APPEND]\",\n", "        SourceSinkFactories.appendingPathByteSinkFactory()));\n", "    suite.addTest(CharSourceTester.tests(\"MoreFiles.asCharSource[Path, Charset]\",\n", "        SourceSinkFactories.pathCharSourceFactory(), false));\n", "    suite.addTest(CharSinkTester.tests(\"MoreFiles.asCharSink[Path, Charset]\",\n", "        SourceSinkFactories.pathCharSinkFactory()));\n", "    suite.addTest(CharSinkTester.tests(\"MoreFiles.asCharSink[Path, Charset, APPEND]\",\n", "        SourceSinkFactories.appendingPathCharSinkFactory()));\n", "    suite.addTestSuite(MoreFilesTest.class);\n", "    return suite;\n", "  }\n", "\n", "  private static final FileSystem FS = FileSystems.getDefault();\n", "\n", "  private static Path root() {\n", "    return FS.getRootDirectories().iterator().next();\n", "  }\n", "\n", "  private Path tempDir;\n", "\n", "  @Override\n", "  protected void setUp() throws Exception {\n", "    tempDir = Files.createTempDirectory(\"MoreFilesTest\");\n", "  }\n", "\n", "  @Override\n", "  protected void tearDown() throws Exception {\n", "    if (tempDir != null) {\n", "      // delete tempDir and its contents\n", "      Files.walkFileTree(tempDir, new SimpleFileVisitor<Path>() {\n", "        @Override\n", "        public FileVisitResult visitFile(Path file, BasicFileAttributes attrs) throws IOException {\n", "          Files.deleteIfExists(file);\n", "          return FileVisitResult.CONTINUE;\n", "        }\n", "\n", "        @Override\n", "        public FileVisitResult postVisitDirectory(Path dir, IOException exc) throws IOException {\n", "          if (exc != null) {\n", "            return FileVisitResult.TERMINATE;\n", "          }\n", "          Files.deleteIfExists(dir);\n", "          return FileVisitResult.CONTINUE;\n", "        }\n", "      });\n", "    }\n", "  }\n", "\n", "  private Path createTempFile() throws IOException {\n", "    return Files.createTempFile(tempDir, \"test\", \".test\");\n", "  }\n", "\n", "  public void testByteSource_size_ofDirectory() throws IOException {\n", "    try (FileSystem fs = Jimfs.newFileSystem(Configuration.unix())) {\n", "      Path dir = fs.getPath(\"dir\");\n", "      Files.createDirectory(dir);\n", "\n", "      ByteSource source = MoreFiles.asByteSource(dir);\n", "\n", "      assertThat(source.sizeIfKnown()).isAbsent();\n", "\n", "      try {\n", "        source.size();\n", "        fail();\n", "      } catch (IOException expected) {\n", "      }\n", "    }\n", "  }\n", "\n", "  public void testByteSource_size_ofSymlinkToDirectory() throws IOException {\n", "    try (FileSystem fs = Jimfs.newFileSystem(Configuration.unix())) {\n", "      Path dir = fs.getPath(\"dir\");\n", "      Files.createDirectory(dir);\n", "      Path link = fs.getPath(\"link\");\n", "      Files.createSymbolicLink(link, dir);\n", "\n", "      ByteSource source = MoreFiles.asByteSource(link);\n", "\n", "      assertThat(source.sizeIfKnown()).isAbsent();\n", "\n", "      try {\n", "        source.size();\n", "        fail();\n", "      } catch (IOException expected) {\n", "      }\n", "    }\n", "  }\n", "\n", "  public void testByteSource_size_ofSymlinkToRegularFile() throws IOException {\n", "    try (FileSystem fs = Jimfs.newFileSystem(Configuration.unix())) {\n", "      Path file = fs.getPath(\"file\");\n", "      Files.write(file, new byte[10]);\n", "      Path link = fs.getPath(\"link\");\n", "      Files.createSymbolicLink(link, file);\n", "\n", "      ByteSource source = MoreFiles.asByteSource(link);\n", "\n", "      assertEquals(10L, (long) source.sizeIfKnown().get());\n", "      assertEquals(10L, source.size());\n", "    }\n", "  }\n", "\n", "  public void testByteSource_size_ofSymlinkToRegularFile_nofollowLinks() throws IOException {\n", "    try (FileSystem fs = Jimfs.newFileSystem(Configuration.unix())) {\n", "      Path file = fs.getPath(\"file\");\n", "      Files.write(file, new byte[10]);\n", "      Path link = fs.getPath(\"link\");\n", "      Files.createSymbolicLink(link, file);\n", "\n", "      ByteSource source = MoreFiles.asByteSource(link, NOFOLLOW_LINKS);\n", "\n", "      assertThat(source.sizeIfKnown()).isAbsent();\n", "\n", "      try {\n", "        source.size();\n", "        fail();\n", "      } catch (IOException expected) {\n", "      }\n", "    }\n", "  }\n", "\n", "  public void testTouch() throws IOException {\n", "    Path temp = createTempFile();\n", "    assertTrue(Files.exists(temp));\n", "    Files.delete(temp);\n", "    assertFalse(Files.exists(temp));\n", "    MoreFiles.touch(temp);\n", "    assertTrue(Files.exists(temp));\n", "    MoreFiles.touch(temp);\n", "    assertTrue(Files.exists(temp));\n", "  }\n", "\n", "  public void testTouchTime() throws IOException {\n", "    Path temp = createTempFile();\n", "    assertTrue(Files.exists(temp));\n", "    Files.setLastModifiedTime(temp, FileTime.fromMillis(0));\n", "    assertEquals(0, Files.getLastModifiedTime(temp).toMillis());\n", "    MoreFiles.touch(temp);\n", "    assertThat(Files.getLastModifiedTime(temp).toMillis()).isNotEqualTo(0);\n", "  }\n", "\n", "  public void testCreateParentDirectories_root() throws IOException {\n", "    Path root = root();\n", "    assertNull(root.getParent());\n", "    assertNull(root.toRealPath().getParent());\n", "    MoreFiles.createParentDirectories(root); // test that there's no exception\n", "  }\n", "\n", "  public void testCreateParentDirectories_relativePath() throws IOException {\n", "    Path path = FS.getPath(\"nonexistent.file\");\n", "    assertNull(path.getParent());\n", "    assertNotNull(path.toAbsolutePath().getParent());\n", "    MoreFiles.createParentDirectories(path); // test that there's no exception\n", "  }\n", "\n", "  public void testCreateParentDirectories_noParentsNeeded() throws IOException {\n", "    Path path = tempDir.resolve(\"nonexistent.file\");\n", "    assertTrue(Files.exists(path.getParent()));\n", "    MoreFiles.createParentDirectories(path); // test that there's no exception\n", "  }\n", "\n", "  public void testCreateParentDirectories_oneParentNeeded() throws IOException {\n", "    Path path = tempDir.resolve(\"parent/nonexistent.file\");\n", "    Path parent = path.getParent();\n", "    assertFalse(Files.exists(parent));\n", "    MoreFiles.createParentDirectories(path);\n", "    assertTrue(Files.exists(parent));\n", "  }\n", "\n", "  public void testCreateParentDirectories_multipleParentsNeeded() throws IOException {\n", "    Path path = tempDir.resolve(\"grandparent/parent/nonexistent.file\");\n", "    Path parent = path.getParent();\n", "    Path grandparent = parent.getParent();\n", "    assertFalse(Files.exists(grandparent));\n", "    assertFalse(Files.exists(parent));\n", "\n", "    MoreFiles.createParentDirectories(path);\n", "    assertTrue(Files.exists(parent));\n", "    assertTrue(Files.exists(grandparent));\n", "  }\n", "\n", "  public void testCreateParentDirectories_noPermission() {\n", "    Path file = root().resolve(\"parent/nonexistent.file\");\n", "    Path parent = file.getParent();\n", "    assertFalse(Files.exists(parent));\n", "    try {\n", "      MoreFiles.createParentDirectories(file);\n", "      // Cleanup in case parent creation was [erroneously] successful.\n", "      Files.delete(parent);\n", "      fail(\"expected exception\");\n", "    } catch (IOException expected) {\n", "    }\n", "  }\n", "\n", "  public void testCreateParentDirectories_nonDirectoryParentExists() throws IOException {\n", "    Path parent = createTempFile();\n", "    assertTrue(Files.isRegularFile(parent));\n", "    Path file = parent.resolve(\"foo\");\n", "    try {\n", "      MoreFiles.createParentDirectories(file);\n", "      fail();\n", "    } catch (IOException expected) {\n", "    }\n", "  }\n", "\n", "  public void testCreateParentDirectories_symlinkParentExists() throws IOException {\n", "    Path symlink = tempDir.resolve(\"linkToDir\");\n", "    Files.createSymbolicLink(symlink, root());\n", "    Path file = symlink.resolve(\"foo\");\n", "    MoreFiles.createParentDirectories(file);\n", "  }\n", "\n", "  public void testGetFileExtension() {\n", "    assertEquals(\"txt\", MoreFiles.getFileExtension(FS.getPath(\".txt\")));\n", "    assertEquals(\"txt\", MoreFiles.getFileExtension(FS.getPath(\"blah.txt\")));\n", "    assertEquals(\"txt\", MoreFiles.getFileExtension(FS.getPath(\"blah..txt\")));\n", "    assertEquals(\"txt\", MoreFiles.getFileExtension(FS.getPath(\".blah.txt\")));\n", "    assertEquals(\"txt\", MoreFiles.getFileExtension(root().resolve(\"tmp/blah.txt\")));\n", "    assertEquals(\"gz\", MoreFiles.getFileExtension(FS.getPath(\"blah.tar.gz\")));\n", "    assertEquals(\"\", MoreFiles.getFileExtension(root()));\n", "    assertEquals(\"\", MoreFiles.getFileExtension(FS.getPath(\".\")));\n", "    assertEquals(\"\", MoreFiles.getFileExtension(FS.getPath(\"..\")));\n", "    assertEquals(\"\", MoreFiles.getFileExtension(FS.getPath(\"...\")));\n", "    assertEquals(\"\", MoreFiles.getFileExtension(FS.getPath(\"blah\")));\n", "    assertEquals(\"\", MoreFiles.getFileExtension(FS.getPath(\"blah.\")));\n", "    assertEquals(\"\", MoreFiles.getFileExtension(FS.getPath(\".blah.\")));\n", "    assertEquals(\"\", MoreFiles.getFileExtension(root().resolve(\"foo.bar/blah\")));\n", "    assertEquals(\"\", MoreFiles.getFileExtension(root().resolve(\"foo/.bar/blah\")));\n", "  }\n", "\n", "  public void testGetNameWithoutExtension() {\n", "    assertEquals(\"\", MoreFiles.getNameWithoutExtension(FS.getPath(\".txt\")));\n", "    assertEquals(\"blah\", MoreFiles.getNameWithoutExtension(FS.getPath(\"blah.txt\")));\n", "    assertEquals(\"blah.\", MoreFiles.getNameWithoutExtension(FS.getPath(\"blah..txt\")));\n", "    assertEquals(\".blah\", MoreFiles.getNameWithoutExtension(FS.getPath(\".blah.txt\")));\n", "    assertEquals(\"blah\", MoreFiles.getNameWithoutExtension(root().resolve(\"tmp/blah.txt\")));\n", "    assertEquals(\"blah.tar\", MoreFiles.getNameWithoutExtension(FS.getPath(\"blah.tar.gz\")));\n", "    assertEquals(\"\", MoreFiles.getNameWithoutExtension(root()));\n", "    assertEquals(\"\", MoreFiles.getNameWithoutExtension(FS.getPath(\".\")));\n", "    assertEquals(\".\", MoreFiles.getNameWithoutExtension(FS.getPath(\"..\")));\n", "    assertEquals(\"..\", MoreFiles.getNameWithoutExtension(FS.getPath(\"...\")));\n", "    assertEquals(\"blah\", MoreFiles.getNameWithoutExtension(FS.getPath(\"blah\")));\n", "    assertEquals(\"blah\", MoreFiles.getNameWithoutExtension(FS.getPath(\"blah.\")));\n", "    assertEquals(\".blah\", MoreFiles.getNameWithoutExtension(FS.getPath(\".blah.\")));\n", "    assertEquals(\"blah\", MoreFiles.getNameWithoutExtension(root().resolve(\"foo.bar/blah\")));\n", "    assertEquals(\"blah\", MoreFiles.getNameWithoutExtension(root().resolve(\"foo/.bar/blah\")));\n", "  }\n", "\n", "  public void testPredicates() throws IOException {\n", "    Path file = createTempFile();\n", "    Path dir = tempDir.resolve(\"dir\");\n", "    Files.createDirectory(dir);\n", "\n", "    assertTrue(MoreFiles.isDirectory().apply(dir));\n", "    assertFalse(MoreFiles.isRegularFile().apply(dir));\n", "\n", "    assertFalse(MoreFiles.isDirectory().apply(file));\n", "    assertTrue(MoreFiles.isRegularFile().apply(file));\n", "\n", "    Path symlinkToDir = tempDir.resolve(\"symlinkToDir\");\n", "    Path symlinkToFile = tempDir.resolve(\"symlinkToFile\");\n", "\n", "    Files.createSymbolicLink(symlinkToDir, dir);\n", "    Files.createSymbolicLink(symlinkToFile, file);\n", "\n", "    assertTrue(MoreFiles.isDirectory().apply(symlinkToDir));\n", "    assertFalse(MoreFiles.isRegularFile().apply(symlinkToDir));\n", "\n", "    assertFalse(MoreFiles.isDirectory().apply(symlinkToFile));\n", "    assertTrue(MoreFiles.isRegularFile().apply(symlinkToFile));\n", "\n", "    assertFalse(MoreFiles.isDirectory(NOFOLLOW_LINKS).apply(symlinkToDir));\n", "    assertFalse(MoreFiles.isRegularFile(NOFOLLOW_LINKS).apply(symlinkToFile));\n", "  }\n", "\n", "  /**\n", "   * Creates a new file system for testing that supports the given features in addition to\n", "   * supporting symbolic links. The file system is created initially having the following file\n", "   * structure:\n", "   *\n", "   * <pre>\n", "   *   /\n", "   *      work/\n", "   *         dir/\n", "   *            a\n", "   *            b/\n", "   *               g\n", "   *               h -> ../a\n", "   *               i/\n", "   *                  j/\n", "   *                     k\n", "   *                     l/\n", "   *            c\n", "   *            d -> b/i\n", "   *            e/\n", "   *            f -> /dontdelete\n", "   *      dontdelete/\n", "   *         a\n", "   *         b/\n", "   *         c\n", "   *      symlinktodir -> work/dir\n", "   * </pre>\n", "   */\n", "  static FileSystem newTestFileSystem(Feature... supportedFeatures) throws IOException {\n", "    FileSystem fs = Jimfs.newFileSystem(Configuration.unix().toBuilder()\n", "        .setSupportedFeatures(ObjectArrays.concat(SYMBOLIC_LINKS, supportedFeatures))\n", "        .build());\n", "    Files.createDirectories(fs.getPath(\"dir/b/i/j/l\"));\n", "    Files.createFile(fs.getPath(\"dir/a\"));\n", "    Files.createFile(fs.getPath(\"dir/c\"));\n", "    Files.createSymbolicLink(fs.getPath(\"dir/d\"), fs.getPath(\"b/i\"));\n", "    Files.createDirectory(fs.getPath(\"dir/e\"));\n", "    Files.createSymbolicLink(fs.getPath(\"dir/f\"), fs.getPath(\"/dontdelete\"));\n", "    Files.createFile(fs.getPath(\"dir/b/g\"));\n", "    Files.createSymbolicLink(fs.getPath(\"dir/b/h\"), fs.getPath(\"../a\"));\n", "    Files.createFile(fs.getPath(\"dir/b/i/j/k\"));\n", "    Files.createDirectory(fs.getPath(\"/dontdelete\"));\n", "    Files.createFile(fs.getPath(\"/dontdelete/a\"));\n", "    Files.createDirectory(fs.getPath(\"/dontdelete/b\"));\n", "    Files.createFile(fs.getPath(\"/dontdelete/c\"));\n", "    Files.createSymbolicLink(fs.getPath(\"/symlinktodir\"), fs.getPath(\"work/dir\"));\n", "    return fs;\n", "  }\n", "\n", "  public void testDirectoryDeletion_basic() throws IOException {\n", "    for (DirectoryDeleteMethod method : EnumSet.allOf(DirectoryDeleteMethod.class)) {\n", "      try (FileSystem fs = newTestFileSystem(SECURE_DIRECTORY_STREAM)) {\n", "        Path dir = fs.getPath(\"dir\");\n", "        assertEquals(6, MoreFiles.listFiles(dir).size());\n", "\n", "        method.delete(dir);\n", "        method.assertDeleteSucceeded(dir);\n", "\n", "        assertEquals(\"contents of /dontdelete deleted by delete method \" + method,\n", "            3, MoreFiles.listFiles(fs.getPath(\"/dontdelete\")).size());\n", "      }\n", "    }\n", "  }\n", "\n", "  public void testDirectoryDeletion_emptyDir() throws IOException {\n", "    for (DirectoryDeleteMethod method : EnumSet.allOf(DirectoryDeleteMethod.class)) {\n", "      try (FileSystem fs = newTestFileSystem(SECURE_DIRECTORY_STREAM)) {\n", "        Path emptyDir = fs.getPath(\"dir/e\");\n", "        assertEquals(0, MoreFiles.listFiles(emptyDir).size());\n", "\n", "        method.delete(emptyDir);\n", "        method.assertDeleteSucceeded(emptyDir);\n", "      }\n", "    }\n", "  }\n", "\n", "  public void testDeleteRecursively_symlinkToDir() throws IOException {\n", "    try (FileSystem fs = newTestFileSystem(SECURE_DIRECTORY_STREAM)) {\n", "      Path symlink = fs.getPath(\"/symlinktodir\");\n", "      Path dir = fs.getPath(\"dir\");\n", "\n", "      assertEquals(6, MoreFiles.listFiles(dir).size());\n", "\n", "      MoreFiles.deleteRecursively(symlink);\n", "\n", "      assertFalse(Files.exists(symlink));\n", "      assertTrue(Files.exists(dir));\n", "      assertEquals(6, MoreFiles.listFiles(dir).size());\n", "    }\n", "  }\n", "\n", "  public void testDeleteDirectoryContents_symlinkToDir() throws IOException {\n", "    try (FileSystem fs = newTestFileSystem(SECURE_DIRECTORY_STREAM)) {\n", "      Path symlink = fs.getPath(\"/symlinktodir\");\n", "      Path dir = fs.getPath(\"dir\");\n", "\n", "      assertEquals(6, MoreFiles.listFiles(symlink).size());\n", "\n", "      MoreFiles.deleteDirectoryContents(symlink);\n", "\n", "      assertTrue(Files.exists(symlink, NOFOLLOW_LINKS));\n", "      assertTrue(Files.exists(symlink));\n", "      assertTrue(Files.exists(dir));\n", "      assertEquals(0, MoreFiles.listFiles(symlink).size());\n", "    }\n", "  }\n", "\n", "  public void testDirectoryDeletion_sdsNotSupported_fails() throws IOException {\n", "    for (DirectoryDeleteMethod method : EnumSet.allOf(DirectoryDeleteMethod.class)) {\n", "      try (FileSystem fs = newTestFileSystem()) {\n", "        Path dir = fs.getPath(\"dir\");\n", "        assertEquals(6, MoreFiles.listFiles(dir).size());\n", "\n", "        try {\n", "          method.delete(dir);\n", "          fail(\"expected InsecureRecursiveDeleteException\");\n", "        } catch (InsecureRecursiveDeleteException expected) {\n", "        }\n", "\n", "        assertTrue(Files.exists(dir));\n", "        assertEquals(6, MoreFiles.listFiles(dir).size());\n", "      }\n", "    }\n", "  }\n", "\n", "  public void testDirectoryDeletion_sdsNotSupported_allowInsecure() throws IOException {\n", "    for (DirectoryDeleteMethod method : EnumSet.allOf(DirectoryDeleteMethod.class)) {\n", "      try (FileSystem fs = newTestFileSystem()) {\n", "        Path dir = fs.getPath(\"dir\");\n", "        assertEquals(6, MoreFiles.listFiles(dir).size());\n", "\n", "        method.delete(dir, ALLOW_INSECURE);\n", "        method.assertDeleteSucceeded(dir);\n", "\n", "        assertEquals(\"contents of /dontdelete deleted by delete method \" + method,\n", "            3, MoreFiles.listFiles(fs.getPath(\"/dontdelete\")).size());\n", "      }\n", "    }\n", "  }\n", "\n", "  public void testDeleteRecursively_symlinkToDir_sdsNotSupported_allowInsecure()\n", "      throws IOException {\n", "    try (FileSystem fs = newTestFileSystem()) {\n", "      Path symlink = fs.getPath(\"/symlinktodir\");\n", "      Path dir = fs.getPath(\"dir\");\n", "\n", "      assertEquals(6, MoreFiles.listFiles(dir).size());\n", "\n", "      MoreFiles.deleteRecursively(symlink, ALLOW_INSECURE);\n", "\n", "      assertFalse(Files.exists(symlink));\n", "      assertTrue(Files.exists(dir));\n", "      assertEquals(6, MoreFiles.listFiles(dir).size());\n", "    }\n", "  }\n", "\n", "  public void testDeleteDirectoryContents_symlinkToDir_sdsNotSupported_allowInsecure()\n", "      throws IOException {\n", "    try (FileSystem fs = newTestFileSystem()) {\n", "      Path symlink = fs.getPath(\"/symlinktodir\");\n", "      Path dir = fs.getPath(\"dir\");\n", "\n", "      assertEquals(6, MoreFiles.listFiles(dir).size());\n", "\n", "      MoreFiles.deleteDirectoryContents(symlink, ALLOW_INSECURE);\n", "      assertEquals(0, MoreFiles.listFiles(dir).size());\n", "    }\n", "  }\n", "\n", "  /**\n", "   * This test attempts to create a situation in which one thread is constantly changing a file\n", "   * from being a real directory to being a symlink to another directory. It then calls\n", "   * deleteDirectoryContents thousands of times on a directory whose subtree contains the file\n", "   * that's switching between directory and symlink to try to ensure that under no circumstance\n", "   * does deleteDirectoryContents follow the symlink to the other directory and delete that\n", "   * directory's contents.\n", "   *\n", "   * <p>We can only test this with a file system that supports SecureDirectoryStream, because it's\n", "   * not possible to protect against this if the file system doesn't.\n", "   */\n", "  public void testDirectoryDeletion_directorySymlinkRace() throws IOException {\n", "    for (DirectoryDeleteMethod method : EnumSet.allOf(DirectoryDeleteMethod.class)) {\n", "      try (FileSystem fs = newTestFileSystem(SECURE_DIRECTORY_STREAM)) {\n", "        Path dirToDelete = fs.getPath(\"dir/b/i\");\n", "        Path changingFile = dirToDelete.resolve(\"j/l\");\n", "        Path symlinkTarget = fs.getPath(\"/dontdelete\");\n", "\n", "        ExecutorService executor = Executors.newSingleThreadExecutor();\n", "        startDirectorySymlinkSwitching(changingFile, symlinkTarget, executor);\n", "\n", "        try {\n", "          for (int i = 0; i < 5000; i++) {\n", "            try {\n", "              Files.createDirectories(changingFile);\n", "              Files.createFile(dirToDelete.resolve(\"j/k\"));\n", "            } catch (FileAlreadyExistsException expected) {\n", "              // if a file already exists, that's fine... just continue\n", "            }\n", "\n", "            try {\n", "              method.delete(dirToDelete);\n", "            } catch (FileSystemException expected) {\n", "              // the delete method may or may not throw an exception, but if it does that's fine\n", "              // and expected\n", "            }\n", "\n", "            // this test is mainly checking that the contents of /dontdelete aren't deleted under\n", "            // any circumstances\n", "            assertEquals(3, MoreFiles.listFiles(symlinkTarget).size());\n", "\n", "            Thread.yield();\n", "          }\n", "        } finally {\n", "          executor.shutdownNow();\n", "        }\n", "      }\n", "    }\n", "  }\n", "\n", "  public void testDeleteRecursively_nonDirectoryFile() throws IOException {\n", "    try (FileSystem fs = newTestFileSystem(SECURE_DIRECTORY_STREAM)) {\n", "      Path file = fs.getPath(\"dir/a\");\n", "      assertTrue(Files.isRegularFile(file, NOFOLLOW_LINKS));\n", "\n", "      MoreFiles.deleteRecursively(file);\n", "\n", "      assertFalse(Files.exists(file, NOFOLLOW_LINKS));\n", "\n", "      Path symlink = fs.getPath(\"/symlinktodir\");\n", "      assertTrue(Files.isSymbolicLink(symlink));\n", "\n", "      Path realSymlinkTarget = symlink.toRealPath();\n", "      assertTrue(Files.isDirectory(realSymlinkTarget, NOFOLLOW_LINKS));\n", "\n", "      MoreFiles.deleteRecursively(symlink);\n", "\n", "      assertFalse(Files.exists(symlink, NOFOLLOW_LINKS));\n", "      assertTrue(Files.isDirectory(realSymlinkTarget, NOFOLLOW_LINKS));\n", "    }\n", "  }\n", "\n", "  /**\n", "   * Starts a new task on the given executor that switches (deletes and replaces) a file between\n", "   * being a directory and being a symlink. The given {@code file} is the file that should switch\n", "   * between being a directory and being a symlink, while the given {@code target} is the target\n", "   * the symlink should have.\n", "   */\n", "  private static void startDirectorySymlinkSwitching(\n", "      final Path file, final Path target, ExecutorService executor) {\n", "    executor.submit(new Runnable() {\n", "      @Override\n", "      public void run() {\n", "        boolean createSymlink = false;\n", "        while (!Thread.interrupted()) {\n", "          try {\n", "            // trying to switch between a real directory and a symlink (dir -> /a)\n", "            if (Files.deleteIfExists(file)) {\n", "              if (createSymlink) {\n", "                Files.createSymbolicLink(file, target);\n", "              } else {\n", "                Files.createDirectory(file);\n", "              }\n", "              createSymlink = !createSymlink;\n", "            }\n", "          } catch (IOException tolerated) {\n", "            // it's expected that some of these will fail\n", "          }\n", "\n", "          Thread.yield();\n", "        }\n", "      }\n", "    });\n", "  }\n", "\n", "  /**\n", "   * Enum defining the two MoreFiles methods that delete directory contents.\n", "   */\n", "  private enum DirectoryDeleteMethod {\n", "    DELETE_DIRECTORY_CONTENTS {\n", "      @Override\n", "      public void delete(Path path, RecursiveDeleteOption... options) throws IOException {\n", "        MoreFiles.deleteDirectoryContents(path, options);\n", "      }\n", "\n", "      @Override\n", "      public void assertDeleteSucceeded(Path path) throws IOException {\n", "        assertEquals(\"contents of directory \" + path + \" not deleted with delete method \" + this,\n", "            0, MoreFiles.listFiles(path).size());\n", "      }\n", "    },\n", "    DELETE_RECURSIVELY {\n", "      @Override\n", "      public void delete(Path path, RecursiveDeleteOption... options) throws IOException {\n", "        MoreFiles.deleteRecursively(path, options);\n", "      }\n", "\n", "      @Override\n", "      public void assertDeleteSucceeded(Path path) throws IOException {\n", "        assertFalse(\"file \" + path + \" not deleted with delete method \" + this,\n", "            Files.exists(path));\n", "      }\n", "    };\n", "\n", "    public abstract void delete(Path path, RecursiveDeleteOption... options) throws IOException;\n", "\n", "    public abstract void assertDeleteSucceeded(Path path) throws IOException;\n", "  }\n", "}\n"]}, "removed": {}, "added_lines": {"1": [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 58, 59, 60, 61, 62, 63, 64, 65, 66, 67, 68, 69, 70, 71, 72, 73, 74, 75, 76, 77, 78, 79, 80, 81, 82, 83, 84, 85, 86, 87, 88, 89, 90, 91, 92, 93, 94, 95, 96, 97, 98, 99, 100, 101, 102, 103, 104, 105, 106, 107, 108, 109, 110, 111, 112, 113, 114, 115, 116, 117, 118, 119, 120, 121, 122, 123, 124, 125, 126, 127, 128, 129, 130, 131, 132, 133, 134, 135, 136, 137, 138, 139, 140, 141, 142, 143, 144, 145, 146, 147, 148, 149, 150, 151, 152, 153, 154, 155, 156, 157, 158, 159, 160, 161, 162, 163, 164, 165, 166, 167, 168, 169, 170, 171, 172, 173, 174, 175, 176, 177, 178, 179, 180, 181, 182, 183, 184, 185, 186, 187, 188, 189, 190, 191, 192, 193, 194, 195, 196, 197, 198, 199, 200, 201, 202, 203, 204, 205, 206, 207, 208, 209, 210, 211, 212, 213, 214, 215, 216, 217, 218, 219, 220, 221, 222, 223, 224, 225, 226, 227, 228, 229, 230, 231, 232, 233, 234, 235, 236, 237, 238, 239, 240, 241, 242, 243, 244, 245, 246, 247, 248, 249, 250, 251, 252, 253, 254, 255, 256, 257, 258, 259, 260, 261, 262, 263, 264, 265, 266, 267, 268, 269, 270, 271, 272, 273, 274, 275, 276, 277, 278, 279, 280, 281, 282, 283, 284, 285, 286, 287, 288, 289, 290, 291, 292, 293, 294, 295, 296, 297, 298, 299, 300, 301, 302, 303, 304, 305, 306, 307, 308, 309, 310, 311, 312, 313, 314, 315, 316, 317, 318, 319, 320, 321, 322, 323, 324, 325, 326, 327, 328, 329, 330, 331, 332, 333, 334, 335, 336, 337, 338, 339, 340, 341, 342, 343, 344, 345, 346, 347, 348, 349, 350, 351, 352, 353, 354, 355, 356, 357, 358, 359, 360, 361, 362, 363, 364, 365, 366, 367, 368, 369, 370, 371, 372, 373, 374, 375, 376, 377, 378, 379, 380, 381, 382, 383, 384, 385, 386, 387, 388, 389, 390, 391, 392, 393, 394, 395, 396, 397, 398, 399, 400, 401, 402, 403, 404, 405, 406, 407, 408, 409, 410, 411, 412, 413, 414, 415, 416, 417, 418, 419, 420, 421, 422, 423, 424, 425, 426, 427, 428, 429, 430, 431, 432, 433, 434, 435, 436, 437, 438, 439, 440, 441, 442, 443, 444, 445, 446, 447, 448, 449, 450, 451, 452, 453, 454, 455, 456, 457, 458, 459, 460, 461, 462, 463, 464, 465, 466, 467, 468, 469, 470, 471, 472, 473, 474, 475, 476, 477, 478, 479, 480, 481, 482, 483, 484, 485, 486, 487, 488, 489, 490, 491, 492, 493, 494, 495, 496, 497, 498, 499, 500, 501, 502, 503, 504, 505, 506, 507, 508, 509, 510, 511, 512, 513, 514, 515, 516, 517, 518, 519, 520, 521, 522, 523, 524, 525, 526, 527, 528, 529, 530, 531, 532, 533, 534, 535, 536, 537, 538, 539, 540, 541, 542, 543, 544, 545, 546, 547, 548, 549, 550, 551, 552, 553, 554, 555, 556, 557, 558, 559, 560, 561, 562, 563, 564, 565, 566, 567, 568, 569, 570, 571, 572, 573, 574, 575, 576, 577, 578, 579, 580, 581, 582, 583, 584, 585, 586, 587, 588, 589, 590, 591, 592, 593, 594, 595, 596, 597, 598, 599, 600, 601, 602, 603, 604, 605, 606, 607, 608, 609, 610, 611, 612, 613, 614, 615, 616, 617, 618, 619, 620, 621, 622, 623, 624, 625, 626, 627, 628, 629, 630, 631, 632, 633, 634, 635, 636, 637, 638, 639, 640, 641, 642, 643]}, "removed_lines": {}}, {"81": "guava-tests/test/com/google/common/io/SourceSinkFactories.java", "added": {"1": ["import java.nio.file.Path;\n", "import java.nio.file.StandardOpenOption;\n", "import java.util.logging.Level;\n"], "2": ["  @AndroidIncompatible\n", "  public static ByteSourceFactory pathByteSourceFactory() {\n", "    return new PathByteSourceFactory();\n", "  }\n", "\n", "  @AndroidIncompatible\n", "  public static ByteSinkFactory pathByteSinkFactory() {\n", "    return new PathByteSinkFactory(null);\n", "  }\n", "\n", "  @AndroidIncompatible\n", "  public static ByteSinkFactory appendingPathByteSinkFactory() {\n", "    String initialString = IoTestCase.ASCII + IoTestCase.I18N;\n", "    return new PathByteSinkFactory(initialString.getBytes(Charsets.UTF_8));\n", "  }\n", "\n", "  @AndroidIncompatible\n", "  public static CharSourceFactory pathCharSourceFactory() {\n", "    return new PathCharSourceFactory();\n", "  }\n", "\n", "  @AndroidIncompatible\n", "  public static CharSinkFactory pathCharSinkFactory() {\n", "    return new PathCharSinkFactory(null);\n", "  }\n", "\n", "  @AndroidIncompatible\n", "  public static CharSinkFactory appendingPathCharSinkFactory() {\n", "    String initialString = IoTestCase.ASCII + IoTestCase.I18N;\n", "    return new PathCharSinkFactory(initialString);\n", "  }\n", "\n"], "3": ["\n", "  @AndroidIncompatible\n", "  private abstract static class Jdk7FileFactory {\n", "\n", "    private static final Logger logger = Logger.getLogger(Jdk7FileFactory.class.getName());\n", "\n", "    private final ThreadLocal<Path> fileThreadLocal = new ThreadLocal<>();\n", "\n", "    protected Path createFile() throws IOException {\n", "      Path file = java.nio.file.Files.createTempFile(\"SinkSourceFile\", \"txt\");\n", "      fileThreadLocal.set(file);\n", "      return file;\n", "    }\n", "\n", "    protected Path getPath() {\n", "      return fileThreadLocal.get();\n", "    }\n", "\n", "    public final void tearDown() throws IOException {\n", "      try {\n", "        java.nio.file.Files.delete(fileThreadLocal.get());\n", "      } catch (IOException e) {\n", "        logger.log(Level.WARNING, \"Unable to delete file: \" + fileThreadLocal.get(), e);\n", "      }\n", "      fileThreadLocal.remove();\n", "    }\n", "  }\n", "\n", "  @AndroidIncompatible\n", "  private static class PathByteSourceFactory extends Jdk7FileFactory implements ByteSourceFactory {\n", "\n", "    @Override\n", "    public ByteSource createSource(byte[] bytes) throws IOException {\n", "      checkNotNull(bytes);\n", "      Path file = createFile();\n", "\n", "      java.nio.file.Files.write(file, bytes);\n", "      return MoreFiles.asByteSource(file);\n", "    }\n", "\n", "    @Override\n", "    public byte[] getExpected(byte[] bytes) {\n", "      return checkNotNull(bytes);\n", "    }\n", "  }\n", "\n", "  @AndroidIncompatible\n", "  private static class PathByteSinkFactory extends Jdk7FileFactory implements ByteSinkFactory {\n", "\n", "    private final byte[] initialBytes;\n", "\n", "    private PathByteSinkFactory(@Nullable byte[] initialBytes) {\n", "      this.initialBytes = initialBytes;\n", "    }\n", "\n", "    @Override\n", "    public ByteSink createSink() throws IOException {\n", "      Path file = createFile();\n", "      if (initialBytes != null) {\n", "        java.nio.file.Files.write(file, initialBytes);\n", "        return MoreFiles.asByteSink(file, StandardOpenOption.APPEND);\n", "      }\n", "      return MoreFiles.asByteSink(file);\n", "    }\n", "\n", "    @Override\n", "    public byte[] getExpected(byte[] bytes) {\n", "      if (initialBytes == null) {\n", "        return checkNotNull(bytes);\n", "      } else {\n", "        byte[] result = new byte[initialBytes.length + bytes.length];\n", "        System.arraycopy(initialBytes, 0, result, 0, initialBytes.length);\n", "        System.arraycopy(bytes, 0, result, initialBytes.length, bytes.length);\n", "        return result;\n", "      }\n", "    }\n", "\n", "    @Override\n", "    public byte[] getSinkContents() throws IOException {\n", "      Path file = getPath();\n", "      return java.nio.file.Files.readAllBytes(file);\n", "    }\n", "  }\n", "\n", "  @AndroidIncompatible\n", "  private static class PathCharSourceFactory extends Jdk7FileFactory implements CharSourceFactory {\n", "\n", "    @Override\n", "    public CharSource createSource(String string) throws IOException {\n", "      checkNotNull(string);\n", "      Path file = createFile();\n", "      try (Writer writer = java.nio.file.Files.newBufferedWriter(file, Charsets.UTF_8)) {\n", "        writer.write(string);\n", "      }\n", "      return MoreFiles.asCharSource(file, Charsets.UTF_8);\n", "    }\n", "\n", "    @Override\n", "    public String getExpected(String string) {\n", "      return checkNotNull(string);\n", "    }\n", "  }\n", "\n", "  @AndroidIncompatible\n", "  private static class PathCharSinkFactory extends Jdk7FileFactory implements CharSinkFactory {\n", "\n", "    private final String initialString;\n", "\n", "    private PathCharSinkFactory(@Nullable String initialString) {\n", "      this.initialString = initialString;\n", "    }\n", "\n", "    @Override\n", "    public CharSink createSink() throws IOException {\n", "      Path file = createFile();\n", "      if (initialString != null) {\n", "        try (Writer writer = java.nio.file.Files.newBufferedWriter(file, Charsets.UTF_8)) {\n", "          writer.write(initialString);\n", "        }\n", "        return MoreFiles.asCharSink(file, Charsets.UTF_8, StandardOpenOption.APPEND);\n", "      }\n", "      return MoreFiles.asCharSink(file, Charsets.UTF_8);\n", "    }\n", "\n", "    @Override\n", "    public String getExpected(String string) {\n", "      checkNotNull(string);\n", "      return initialString == null\n", "          ? string\n", "          : initialString + string;\n", "    }\n", "\n", "    @Override\n", "    public String getSinkContents() throws IOException {\n", "      Path file = getPath();\n", "      try (Reader reader = java.nio.file.Files.newBufferedReader(file, Charsets.UTF_8)) {\n", "        StringBuilder builder = new StringBuilder();\n", "        for (int c = reader.read(); c != -1; c = reader.read()) {\n", "          builder.append((char) c);\n", "        }\n", "        return builder.toString();\n", "      }\n", "    }\n", "  }\n"]}, "removed": {}, "added_lines": {"1": [38, 39, 41], "2": [104, 105, 106, 107, 108, 109, 110, 111, 112, 113, 114, 115, 116, 117, 118, 119, 120, 121, 122, 123, 124, 125, 126, 127, 128, 129, 130, 131, 132, 133, 134, 135], "3": [480, 481, 482, 483, 484, 485, 486, 487, 488, 489, 490, 491, 492, 493, 494, 495, 496, 497, 498, 499, 500, 501, 502, 503, 504, 505, 506, 507, 508, 509, 510, 511, 512, 513, 514, 515, 516, 517, 518, 519, 520, 521, 522, 523, 524, 525, 526, 527, 528, 529, 530, 531, 532, 533, 534, 535, 536, 537, 538, 539, 540, 541, 542, 543, 544, 545, 546, 547, 548, 549, 550, 551, 552, 553, 554, 555, 556, 557, 558, 559, 560, 561, 562, 563, 564, 565, 566, 567, 568, 569, 570, 571, 572, 573, 574, 575, 576, 577, 578, 579, 580, 581, 582, 583, 584, 585, 586, 587, 588, 589, 590, 591, 592, 593, 594, 595, 596, 597, 598, 599, 600, 601, 602, 603, 604, 605, 606, 607, 608, 609, 610, 611, 612, 613, 614, 615, 616, 617, 618, 619, 620, 621, 622, 623]}, "removed_lines": {}}, {"82": "guava-tests/test/com/google/common/math/StatsTest.java", "added": {"1": ["import static java.util.Arrays.stream;\n"], "2": ["import java.util.DoubleSummaryStatistics;\n"], "3": ["\n", "  public void testEquivalentStreams() {\n", "    // For datasets of many double values created from an array, we test many combinations of finite\n", "    // and non-finite values:\n", "    for (ManyValues values : ALL_MANY_VALUES) {\n", "      double[] array = values.asArray();\n", "      Stats stats = Stats.of(array);\n", "      // instance methods on Stats vs on instance methods on DoubleStream\n", "      assertThat(stats.count()).isEqualTo(stream(array).count());\n", "      assertEquivalent(stats.mean(), stream(array).average().getAsDouble());\n", "      assertEquivalent(stats.sum(), stream(array).sum());\n", "      assertEquivalent(stats.max(), stream(array).max().getAsDouble());\n", "      assertEquivalent(stats.min(), stream(array).min().getAsDouble());\n", "      // static method on Stats vs on instance method on DoubleStream\n", "      assertEquivalent(Stats.meanOf(array), stream(array).average().getAsDouble());\n", "      // instance methods on Stats vs instance methods on DoubleSummaryStatistics\n", "      DoubleSummaryStatistics streamStats = stream(array).summaryStatistics();\n", "      assertThat(stats.count()).isEqualTo(streamStats.getCount());\n", "      assertEquivalent(stats.mean(), streamStats.getAverage());\n", "      assertEquivalent(stats.sum(), streamStats.getSum());\n", "      assertEquivalent(stats.max(), streamStats.getMax());\n", "      assertEquivalent(stats.min(), streamStats.getMin());\n", "    }\n", "  }\n", "\n", "  private static void assertEquivalent(double actual, double expected) {\n", "    if (expected == POSITIVE_INFINITY) {\n", "      assertThat(actual).isPositiveInfinity();\n", "    } else if (expected == NEGATIVE_INFINITY) {\n", "      assertThat(actual).isNegativeInfinity();\n", "    } else if (Double.isNaN(expected)) {\n", "      assertThat(actual).isNaN();\n", "    } else {\n", "      assertThat(actual).isWithin(ALLOWED_ERROR).of(expected);\n", "    }\n", "  }\n"]}, "removed": {}, "added_lines": {"1": [71], "2": [81], "3": [612, 613, 614, 615, 616, 617, 618, 619, 620, 621, 622, 623, 624, 625, 626, 627, 628, 629, 630, 631, 632, 633, 634, 635, 636, 637, 638, 639, 640, 641, 642, 643, 644, 645, 646, 647]}, "removed_lines": {}}, {"83": "guava-tests/test/com/google/common/util/concurrent/MonitorTestCase.java", "added": {"1": ["    // same as above but with the new syntax\n", "    thread1.callAndAssertReturns(enterWhen(), monitor.newGuard(() -> true));\n"]}, "removed": {}, "added_lines": {"1": [142, 143]}, "removed_lines": {}}, {"84": "guava/pom.xml", "added": {"1": ["            <link>http://docs.oracle.com/javase/8/docs/api/</link>\n", "            <link>http://javadoc.io/doc/com.google.code.findbugs/jsr305/3.0.1/</link>\n", "            <link>http://errorprone.info/api/latest/</link>\n", "            <link>http://javadoc.io/doc/com.google.j2objc/j2objc-annotations/1.1/</link>\n"]}, "removed": {"1": ["            <link>http://jsr-305.googlecode.com/svn/trunk/javadoc</link>\n", "            <link>http://docs.oracle.com/javase/7/docs/api/</link>\n"]}, "added_lines": {"1": [111, 112, 113, 114]}, "removed_lines": {"1": [111, 112]}}, {"85": "guava/src/com/google/common/base/Equivalence.java", "added": {"1": ["import java.util.function.BiPredicate;\n"], "2": ["public abstract class Equivalence<T> implements BiPredicate<T, T> {\n"], "3": ["  /**\n", "   * @deprecated Provided only to satisfy the {@link BiPredicate} interface; use\n", "   *     {@link #equivalent} instead.\n", "   * @since 21.0\n", "   */\n", "  @Deprecated\n", "  @Override\n", "  public final boolean test(@Nullable T t, @Nullable T u) {\n", "    return equivalent(t, u);\n", "  }\n", "\n"]}, "removed": {"2": ["public abstract class Equivalence<T> {\n"]}, "added_lines": {"1": [21], "2": [42], "3": [76, 77, 78, 79, 80, 81, 82, 83, 84, 85, 86]}, "removed_lines": {"2": [41]}}, {"86": "guava/src/com/google/common/base/Function.java", "added": {"1": [" * Legacy version of {@link java.util.function.Function}.\n", " * <p>As this interface extends {@link java.util.function.Function}, an instance of this type\n", " * can be used as a {@code java.util.function.Function} directly.  To use a\n", " * {@code java.util.function.Function} in a context where a\n", " * {@code com.google.common.base.Function} is needed, use {@code function::apply}.\n", " * <p>See the Guava User Guide article on\n", " * <a href=\"https://github.com/google/guava/wiki/FunctionalExplained\">the use of {@code\n", " * Function}</a>.\n", "@FunctionalInterface\n", "public interface Function<F, T> extends java.util.function.Function<F, T> {\n", "  @Override\n"]}, "removed": {"1": [" * Determines an output value based on an input value; a pre-Java-8 version of {@code\n", " * java.util.function.Function}.\n", " * <p>See the Guava User Guide article on\n", " * <a href=\"https://github.com/google/guava/wiki/FunctionalExplained\">the use of {@code\n", " * Function}</a>.\n", " *\n", " * <h3>For Java 8+ users</h3>\n", " * <p>To use an existing function (say, named {@code function}) in a context where the <i>other\n", " * type</i> of function is expected, use the method reference {@code function::apply}. A future\n", " * version of {@code com.google.common.base.Function} will be made to <i>extend</i> {@code\n", " * java.util.function.Function}, making conversion code necessary only in one direction. At that\n", " * time, this interface will be officially discouraged.\n", "public interface Function<F, T> {\n", "  /**\n", "   * Returns the result of applying this function to {@code input}. This method is <i>generally\n", "   * expected</i>, but not absolutely required, to have the following properties:\n", "   *\n", "   * <ul>\n", "   * <li>Its execution does not cause any observable side effects.\n", "   * <li>The computation is <i>consistent with equals</i>; that is, {@link Objects#equal\n", "   *     Objects.equal}{@code (a, b)} implies that {@code Objects.equal(function.apply(a),\n", "   *     function.apply(b))}.\n", "   * </ul>\n", "   *\n", "   * @throws NullPointerException if {@code input} is null and this function does not accept null\n", "   *     arguments\n", "   */\n"]}, "added_lines": {"1": [22, 26, 27, 28, 29, 36, 37, 38, 44, 45, 46]}, "removed_lines": {"1": [22, 23, 27, 28, 29, 30, 31, 38, 39, 40, 41, 42, 48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 58, 59, 60, 61, 62]}}, {"87": "guava/src/com/google/common/base/Optional.java", "added": {"1": ["  /**\n", "   * Returns the equivalent {@code com.google.common.base.Optional} value to the given {@code\n", "   * java.util.Optional}, or {@code null} if the argument is null.\n", "   */\n", "  @Nullable\n", "  public static <T> Optional<T> fromJavaUtil(@Nullable java.util.Optional<T> javaUtilOptional) {\n", "    return (javaUtilOptional == null) ? null : fromNullable(javaUtilOptional.orElse(null));\n", "  }\n", "\n", "  /**\n", "   * Returns the equivalent {@code java.util.Optional} value to the given {@code\n", "   * com.google.common.base.Optional}, or {@code null} if the argument is null.\n", "   */\n", "  @Nullable\n", "  public static <T> java.util.Optional<T> toJavaUtil(@Nullable Optional<T> googleOptional) {\n", "    return (googleOptional == null)\n", "        ? null\n", "        : java.util.Optional.ofNullable(googleOptional.orNull());\n", "  }\n", "\n"]}, "removed": {}, "added_lines": {"1": [121, 122, 123, 124, 125, 126, 127, 128, 129, 130, 131, 132, 133, 134, 135, 136, 137, 138, 139, 140]}, "removed_lines": {}}, {"88": "guava/src/com/google/common/base/Platform.java", "added": {"1": ["import java.util.Iterator;\n", "import java.util.ServiceLoader;\n"], "2": ["    ServiceLoader<PatternCompiler> loader = ServiceLoader.load(PatternCompiler.class);\n", "    // Returns the first PatternCompiler that loads successfully.\n", "    try {\n", "      for (Iterator<PatternCompiler> it = loader.iterator(); it.hasNext();) {\n", "        try {\n", "          return it.next();\n", "        } catch (ServiceConfigurationError e) {\n", "          logPatternCompilerError(e);\n", "        }\n", "      }\n", "    } catch (ServiceConfigurationError e) { // from hasNext()\n", "      logPatternCompilerError(e);\n", "    }\n", "    // Fall back to the JDK regex library.\n"]}, "removed": {"2": ["    /*\n", "     * We'd normally use ServiceLoader here, but it hurts Android startup performance. To avoid\n", "     * that, we hardcode the JDK Pattern compiler on Android (and, inadvertently, on App Engine and\n", "     * in Guava, at least for now).\n", "     */\n"]}, "added_lines": {"1": [19, 22], "2": [74, 75, 76, 77, 78, 79, 80, 81, 82, 83, 84, 85, 86, 87]}, "removed_lines": {"2": [72, 73, 74, 75, 76]}}, {"89": "guava/src/com/google/common/base/Predicate.java", "added": {"1": [" * Legacy version of {@link java.util.function.Predicate}.  Determines a true or false value for a\n", " * given input.\n", " * <p>As this interface extends {@code java.util.function.Predicate}, an instance of this type may\n", " * be used as a {@code Predicate} directly.  To use a {@code java.util.function.Predicate} where a\n", " * {@code com.google.common.base.Predicate} is expected, use the method reference {@code\n", " * predicate::test}.\n", " * <p>The {@link Predicates} class provides common predicates and related utilities.\n", " *\n", " * <p>See the Guava User Guide article on\n", " * <a href=\"https://github.com/google/guava/wiki/FunctionalExplained\">the use of {@code\n", " * Predicate}</a>.\n", "@FunctionalInterface\n", "public interface Predicate<T> extends java.util.function.Predicate<T> {\n"], "2": ["\n", "  @Override\n", "  default boolean test(@Nullable T input) {\n", "    return apply(input);\n", "  }\n"]}, "removed": {"1": [" * Determines a true or false value for a given input; a pre-Java-8 version of {@code\n", " * java.util.function.Predicate}.\n", " *\n", " * <p>The {@link Predicates} class provides common predicates and related utilities.\n", " *\n", " * <p>See the Guava User Guide article on\n", " * <a href=\"https://github.com/google/guava/wiki/FunctionalExplained\">the use of {@code\n", " * Predicate}</a>.\n", " * <h3>For Java 8+ users</h3>\n", " * <p>To use a reference of this type (say, named {@code guavaPredicate}) in a context where {@code\n", " * java.util.function.Predicate} is expected, use the method reference {@code\n", " * guavaPredicate::apply}. For the other direction, use {@code javaUtilPredicate::test}. A future\n", " * version of this interface will be made to <i>extend</i> {@code java.util.function.Predicate}, so\n", " * that conversion will be necessary in only one direction. At that time, this interface will be\n", " * officially discouraged.\n", "public interface Predicate<T> {\n"]}, "added_lines": {"1": [22, 23, 25, 26, 27, 28, 35, 36, 37, 38, 39, 44, 46], "2": [77, 78, 79, 80, 81]}, "removed_lines": {"1": [23, 24, 25, 26, 27, 28, 29, 30, 32, 39, 40, 41, 42, 43, 44, 50]}}, {"90": "guava/src/com/google/common/base/Supplier.java", "added": {"1": [" * Legacy version of {@code java.util.function.Supplier}. Semantically, this could be a factory,\n", " * generator, builder, closure, or something else entirely. No guarantees are implied by this\n", " * interface.\n", " * <p>As this interface extends {@link java.util.function.Supplier}, an instance of this type\n", " * can be used as a {@code java.util.function.Supplier} directly.  To use a\n", " * {@code java.util.function.Supplier} in a context where a\n", " * {@code com.google.common.base.Supplier} is needed, use {@code supplier::get}.\n", " * <p>See the Guava User Guide article on\n", " * <a href=\"https://github.com/google/guava/wiki/FunctionalExplained\">the use of {@code\n", " * Function}</a>.\n", "@FunctionalInterface\n", "public interface Supplier<T> extends java.util.function.Supplier<T> {\n"]}, "removed": {"1": [" * A class that can supply objects of a single type; a pre-Java-8 version of {@code\n", " * java.util.function.Supplier}. Semantically, this could be a factory, generator, builder,\n", " * closure, or something else entirely. No guarantees are implied by this interface.\n", " * <p>See the Guava User Guide article on <a href=\n", " * \"https://github.com/google/guava/wiki/FunctionalExplained\">the use of functional types</a>.\n", " * <h3>For Java 8+ users</h3>\n", " *\n", " * <p>This interface is now a legacy type. Use {@code java.util.function.Supplier} (or the\n", " * appropriate primitive specialization such as {@code IntSupplier}) instead whenever possible.\n", " * Otherwise, at least reduce <i>explicit</i> dependencies on this type by using lambda expressions\n", " * or method references instead of classes, leaving your code easier to migrate in the future.\n", " *\n", " * <p>To use an existing supplier instance (say, named {@code supplier}) in a context where the\n", " * <i>other type</i> of supplier is expected, use the method reference {@code supplier::get}. A\n", " * future version of {@code com.google.common.base.Supplier} will be made to <i>extend</i> {@code\n", " * java.util.function.Supplier}, making conversion code necessary only in one direction. At that\n", " * time, this interface will be officially discouraged.\n", "public interface Supplier<T> {\n"]}, "added_lines": {"1": [21, 22, 23, 27, 28, 29, 30, 32, 33, 34, 40, 41]}, "removed_lines": {"1": [21, 22, 23, 27, 28, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 47]}}, {"91": "guava/src/com/google/common/cache/LocalCache.java", "added": {"2": ["import com.google.common.cache.LocalCache.AbstractCacheSet;\n"], "3": ["import java.util.Map.Entry;\n"], "4": ["import java.util.function.BiFunction;\n", "import java.util.function.BiPredicate;\n", "import java.util.function.Function;\n", "import java.util.function.Predicate;\n"], "5": ["    V compute(K key, int hash, BiFunction<? super K, ? super V, ? extends V> function) {\n", "      ReferenceEntry<K, V> e;\n", "      ValueReference<K, V> valueReference = null;\n", "      LoadingValueReference<K, V> loadingValueReference = null;\n", "      boolean createNewEntry = true;\n", "\n", "      lock();\n", "      try {\n", "        // re-read ticker once inside the lock\n", "        long now = map.ticker.read();\n", "        preWriteCleanup(now);\n", "\n", "        AtomicReferenceArray<ReferenceEntry<K, V>> table = this.table;\n", "        int index = hash & (table.length() - 1);\n", "        ReferenceEntry<K, V> first = table.get(index);\n", "\n", "        for (e = first; e != null; e = e.getNext()) {\n", "          K entryKey = e.getKey();\n", "          if (e.getHash() == hash\n", "              && entryKey != null\n", "              && map.keyEquivalence.equivalent(key, entryKey)) {\n", "            valueReference = e.getValueReference();\n", "            if (map.isExpired(e, now)) {\n", "              // This is a duplicate check, as preWriteCleanup already purged expired\n", "              // entries, but let's accomodate an incorrect expiration queue.\n", "              enqueueNotification(\n", "                  entryKey,\n", "                  hash,\n", "                  valueReference.get(),\n", "                  valueReference.getWeight(),\n", "                  RemovalCause.EXPIRED);\n", "            }\n", "\n", "            // immediately reuse invalid entries\n", "            writeQueue.remove(e);\n", "            accessQueue.remove(e);\n", "            createNewEntry = false;\n", "            break;\n", "          }\n", "        }\n", "\n", "        // note valueReference can be an existing value or even itself another loading value if\n", "        // the value for the key is already being computed.\n", "        loadingValueReference = new LoadingValueReference<K, V>(valueReference);\n", "\n", "        if (e == null) {\n", "          createNewEntry = true;\n", "          e = newEntry(key, hash, first);\n", "          e.setValueReference(loadingValueReference);\n", "          table.set(index, e);\n", "        } else {\n", "          e.setValueReference(loadingValueReference);\n", "        }\n", "      } finally {\n", "        unlock();\n", "        postWriteCleanup();\n", "      }\n", "\n", "      // Synchronizes on the entry to allow failing fast when a recursive load is\n", "      // detected. This may be circumvented when an entry is copied, but will fail fast most\n", "      // of the time.\n", "      synchronized (e) {\n", "        V newValue = loadingValueReference.compute(key, function);\n", "        if (newValue != null) {\n", "          try {\n", "            return getAndRecordStats(\n", "                key, hash, loadingValueReference, Futures.immediateFuture(newValue));\n", "          } catch (ExecutionException exception) {\n", "            throw new AssertionError(\"impossible; Futures.immediateFuture can't throw\");\n", "          }\n", "        } else if (createNewEntry) {\n", "          removeLoadingValue(key, hash, loadingValueReference);\n", "          return null;\n", "        } else {\n", "          lock();\n", "          try {\n", "            removeEntry(e, hash, RemovalCause.EXPLICIT);\n", "          } finally {\n", "            unlock();\n", "          }\n", "          return null;\n", "        }\n", "      }\n", "    }\n", "\n"], "6": ["      this(null);\n", "      this.oldValue = (oldValue == null) ? LocalCache.<K, V>unset() : oldValue;\n"], "7": ["            new com.google.common.base.Function<V, V>() {\n"], "8": ["    public V compute(K key, BiFunction<? super K, ? super V, ? extends V> function) {\n", "      stopwatch.start();\n", "      V previousValue;\n", "      try {\n", "        previousValue = oldValue.waitForValue();\n", "      } catch (ExecutionException e) {\n", "        previousValue = null;\n", "      }\n", "      V newValue = function.apply(key, previousValue);\n", "      this.set(newValue);\n", "      return newValue;\n", "    }\n", "\n"], "9": ["  @Override\n", "  public V compute(K key, BiFunction<? super K, ? super V, ? extends V> function) {\n", "    checkNotNull(key);\n", "    checkNotNull(function);\n", "    int hash = hash(key);\n", "    return segmentFor(hash).compute(key, hash, function);\n", "  }\n", "\n", "  @Override\n", "  public V computeIfAbsent(K key, Function<? super K, ? extends V> function) {\n", "    checkNotNull(key);\n", "    checkNotNull(function);\n", "    return compute(key, (k, oldValue) -> (oldValue == null) ? function.apply(key) : oldValue);\n", "  }\n", "\n", "  @Override\n", "  public V computeIfPresent(K key, BiFunction<? super K, ? super V, ? extends V> function) {\n", "    checkNotNull(key);\n", "    checkNotNull(function);\n", "    return compute(key, (k, oldValue) -> (oldValue == null) ? null : function.apply(k, oldValue));\n", "  }\n", "\n", "  @Override\n", "  public V merge(K key, V newValue, BiFunction<? super V, ? super V, ? extends V> function) {\n", "    checkNotNull(key);\n", "    checkNotNull(newValue);\n", "    checkNotNull(function);\n", "    return compute(\n", "        key, (k, oldValue) -> (oldValue == null) ? newValue : function.apply(oldValue, newValue));\n", "  }\n", "\n"], "10": ["  boolean removeIf(BiPredicate<? super K, ? super V> filter) {\n", "    checkNotNull(filter);\n", "    boolean changed = false;\n", "    for (K key : keySet()) {\n", "      while (true) {\n", "        V value = get(key);\n", "        if (value == null || !filter.test(key, value)) {\n", "          break;\n", "        } else if (LocalCache.this.remove(key, value)) {\n", "          changed = true;\n", "          break;\n", "        }\n", "      }\n", "    }\n", "    return changed;\n", "  }\n", "\n"], "11": ["    @Override\n", "    public boolean removeIf(Predicate<? super V> filter) {\n", "      checkNotNull(filter);\n", "      return LocalCache.this.removeIf((k, v) -> filter.test(v));\n", "    }\n", "\n"], "12": ["    @Override\n", "    public boolean removeIf(Predicate<? super Entry<K, V>> filter) {\n", "      checkNotNull(filter);\n", "      return LocalCache.this.removeIf((k, v) -> filter.test(Maps.immutableEntry(k, v)));\n", "    }\n", "\n"]}, "removed": {"1": ["import com.google.common.base.Function;\n"], "4": ["\n"], "6": ["      this(LocalCache.<K, V>unset());\n", "      this.oldValue = oldValue;\n"], "7": ["            new Function<V, V>() {\n"]}, "added_lines": {"2": [37], "3": [68], "4": [80, 81, 82, 83], "5": [2331, 2332, 2333, 2334, 2335, 2336, 2337, 2338, 2339, 2340, 2341, 2342, 2343, 2344, 2345, 2346, 2347, 2348, 2349, 2350, 2351, 2352, 2353, 2354, 2355, 2356, 2357, 2358, 2359, 2360, 2361, 2362, 2363, 2364, 2365, 2366, 2367, 2368, 2369, 2370, 2371, 2372, 2373, 2374, 2375, 2376, 2377, 2378, 2379, 2380, 2381, 2382, 2383, 2384, 2385, 2386, 2387, 2388, 2389, 2390, 2391, 2392, 2393, 2394, 2395, 2396, 2397, 2398, 2399, 2400, 2401, 2402, 2403, 2404, 2405, 2406, 2407, 2408, 2409, 2410, 2411, 2412, 2413, 2414, 2415], "6": [3663, 3667], "7": [3727], "8": [3743, 3744, 3745, 3746, 3747, 3748, 3749, 3750, 3751, 3752, 3753, 3754, 3755], "9": [4376, 4377, 4378, 4379, 4380, 4381, 4382, 4383, 4384, 4385, 4386, 4387, 4388, 4389, 4390, 4391, 4392, 4393, 4394, 4395, 4396, 4397, 4398, 4399, 4400, 4401, 4402, 4403, 4404, 4405, 4406], "10": [4727, 4728, 4729, 4730, 4731, 4732, 4733, 4734, 4735, 4736, 4737, 4738, 4739, 4740, 4741, 4742, 4743], "11": [4795, 4796, 4797, 4798, 4799, 4800], "12": [4832, 4833, 4834, 4835, 4836, 4837]}, "removed_lines": {"1": [29], "4": [82], "6": [3575, 3579], "7": [3639]}}, {"92": "guava/src/com/google/common/collect/AbstractBiMap.java", "added": {"1": ["import java.util.function.BiFunction;\n"], "2": ["  @Override\n", "  public void replaceAll(BiFunction<? super K, ? super V, ? extends V> function) {\n", "    this.delegate.replaceAll(function);\n", "    inverse.delegate.clear();\n", "    Entry<K, V> broken = null;\n", "    Iterator<Entry<K, V>> itr = this.delegate.entrySet().iterator();\n", "    while (itr.hasNext()) {\n", "      Entry<K, V> entry = itr.next();\n", "      K k = entry.getKey();\n", "      V v = entry.getValue();\n", "      K conflict = inverse.delegate.putIfAbsent(v, k);\n", "      if (conflict != null) {\n", "        broken = entry;\n", "        // We're definitely going to throw, but we'll try to keep the BiMap in an internally\n", "        // consistent state by removing the bad entry.\n", "        itr.remove();\n", "      }\n", "    }\n", "    if (broken != null) {\n", "      throw new IllegalArgumentException(\"value already present: \" + broken.getValue());\n", "    }\n", "  }\n", "\n"]}, "removed": {}, "added_lines": {"1": [37], "2": [183, 184, 185, 186, 187, 188, 189, 190, 191, 192, 193, 194, 195, 196, 197, 198, 199, 200, 201, 202, 203, 204, 205]}, "removed_lines": {}}, {"93": "guava/src/com/google/common/collect/AbstractMapBasedMultimap.java", "added": {"1": ["import com.google.common.collect.Maps.EntrySet;\n", "import com.google.common.collect.Maps.KeySet;\n"], "2": ["import java.util.Spliterator;\n", "import java.util.function.BiConsumer;\n"], "3": ["    @Override\n", "    public Spliterator<K> spliterator() {\n", "      return map().keySet().spliterator();\n", "    }\n", "\n"], "4": ["  @Override\n", "  Spliterator<V> valueSpliterator() {\n", "    return CollectSpliterators.flatMap(\n", "        map.values().spliterator(), Collection::spliterator, Spliterator.SIZED, size());\n", "  }\n", "\n"], "5": ["  @Override\n", "  Spliterator<Entry<K, V>> entrySpliterator() {\n", "    return CollectSpliterators.flatMap(\n", "        map.entrySet().spliterator(),\n", "        keyToValueCollectionEntry -> {\n", "          K key = keyToValueCollectionEntry.getKey();\n", "          Collection<V> valueCollection = keyToValueCollectionEntry.getValue();\n", "          return CollectSpliterators.map(\n", "              valueCollection.spliterator(), (V value) -> Maps.immutableEntry(key, value));\n", "        },\n", "        Spliterator.SIZED,\n", "        size());\n", "  }\n", "\n", "  @Override\n", "  public void forEach(BiConsumer<? super K, ? super V> action) {\n", "    checkNotNull(action);\n", "    map.forEach(\n", "        (key, valueCollection) -> valueCollection.forEach(value -> action.accept(key, value)));\n", "  }\n", "\n"], "6": ["      @Override\n", "      public Spliterator<Entry<K, Collection<V>>> spliterator() {\n", "        return CollectSpliterators.map(submap.entrySet().spliterator(), AsMap.this::wrapEntry);\n", "      }\n", "\n"]}, "removed": {}, "added_lines": {"1": [25, 26], "2": [46, 47], "3": [973, 974, 975, 976, 977], "4": [1213, 1214, 1215, 1216, 1217, 1218], "5": [1258, 1259, 1260, 1261, 1262, 1263, 1264, 1265, 1266, 1267, 1268, 1269, 1270, 1271, 1272, 1273, 1274, 1275, 1276, 1277, 1278], "6": [1388, 1389, 1390, 1391, 1392]}, "removed_lines": {}}, {"94": "guava/src/com/google/common/collect/AbstractMapBasedMultiset.java", "added": {"1": ["import java.util.function.ObjIntConsumer;\n"], "2": ["  // TODO(lowasser): consider overhauling this back to Map<E, Integer>\n"], "3": ["  @Override public void forEachEntry(ObjIntConsumer<? super E> action) {\n", "    checkNotNull(action);\n", "    backingMap.forEach((element, count) -> action.accept(element, count.get()));\n", "  }\n", "\n"]}, "removed": {"2": ["\n"]}, "added_lines": {"1": [35], "2": [49], "3": [129, 130, 131, 132, 133]}, "removed_lines": {"2": [48]}}, {"95": "guava/src/com/google/common/collect/AbstractMultimap.java", "added": {"1": ["import java.util.Spliterator;\n", "import java.util.Spliterators;\n"], "2": ["\n", "    @Override\n", "    public Spliterator<Entry<K, V>> spliterator() {\n", "      return entrySpliterator();\n", "    }\n"], "3": ["  Spliterator<Entry<K, V>> entrySpliterator() {\n", "    return Spliterators.spliterator(\n", "        entryIterator(), size(), (this instanceof SetMultimap) ? Spliterator.DISTINCT : 0);\n", "  }\n", "\n"], "4": ["    @Override\n", "    public Spliterator<V> spliterator() {\n", "      return valueSpliterator();\n", "    }\n", "\n"], "5": ["  Spliterator<V> valueSpliterator() {\n", "    return Spliterators.spliterator(valueIterator(), size(), 0);\n", "  }\n", "\n"]}, "removed": {}, "added_lines": {"1": [30, 31], "2": [137, 138, 139, 140, 141], "3": [159, 160, 161, 162, 163], "4": [207, 208, 209, 210, 211], "5": [232, 233, 234, 235]}, "removed_lines": {}}, {"96": "guava/src/com/google/common/collect/AbstractRangeSet.java", "added": {}, "removed": {"1": ["  @Override\n", "  public boolean enclosesAll(Iterable<Range<C>> ranges) {\n", "    for (Range<C> range : ranges) {\n", "      if (!encloses(range)) {\n", "        return false;\n", "      }\n", "    }\n", "    return true;\n", "  }\n", "\n", "  @Override\n", "  public void addAll(Iterable<Range<C>> ranges) {\n", "    for (Range<C> range : ranges) {\n", "      add(range);\n", "    }\n", "  }\n", "\n", "  @Override\n", "  public void removeAll(Iterable<Range<C>> ranges) {\n", "    for (Range<C> range : ranges) {\n", "      remove(range);\n", "    }\n", "  }\n", "\n"]}, "added_lines": {}, "removed_lines": {"1": [62, 63, 64, 65, 66, 67, 68, 69, 70, 71, 77, 78, 79, 80, 81, 82, 83, 89, 90, 91, 92, 93, 94, 95]}}, {"97": "guava/src/com/google/common/collect/AbstractTable.java", "added": {"1": ["import com.google.common.collect.Table.Cell;\n"], "2": ["import java.util.Spliterator;\n"], "3": ["  abstract Spliterator<Table.Cell<R, C, V>> cellSpliterator();\n", "\n"], "4": ["    @Override\n", "    public Spliterator<Cell<R, C, V>> spliterator() {\n", "      return cellSpliterator();\n", "    }\n", "\n"], "5": ["  Spliterator<V> valuesSpliterator() {\n", "    return CollectSpliterators.map(cellSpliterator(), Table.Cell::getValue);\n", "  }\n", "\n"]}, "removed": {}, "added_lines": {"1": [18], "2": [27], "3": [124, 125], "4": [162, 163, 164, 165, 166], "5": [194, 195, 196, 197]}, "removed_lines": {}}, {"98": "guava/src/com/google/common/collect/ArrayTable.java", "added": {"1": ["import java.util.Spliterator;\n"], "2": ["    @Override\n", "    Spliterator<Entry<K, V>> entrySpliterator() {\n", "      return CollectSpliterators.indexed(size(), Spliterator.ORDERED, this::getEntry);\n", "    }\n", "\n"], "3": ["  @Override\n", "  Spliterator<Cell<R, C, V>> cellSpliterator() {\n", "    return CollectSpliterators.indexed(\n", "        size(), Spliterator.ORDERED | Spliterator.NONNULL | Spliterator.DISTINCT, this::getCell);\n", "  }\n", "\n"], "4": ["  @Override\n", "  Spliterator<V> valuesSpliterator() {\n", "    return CollectSpliterators.indexed(size(), Spliterator.ORDERED, this::getValue);\n", "  }\n", "\n"]}, "removed": {"1": ["\n"]}, "added_lines": {"1": [37], "2": [250, 251, 252, 253, 254], "3": [561, 562, 563, 564, 565, 566], "4": [798, 799, 800, 801, 802]}, "removed_lines": {"1": [37]}}, {"99": "guava/src/com/google/common/collect/BinaryTreeTraverser.java", "added": {"1": ["import java.util.function.Consumer;\n"], "2": ["\n", "      @Override\n", "      public void forEach(Consumer<? super T> action) {\n", "        acceptIfPresent(action, leftChild(root));\n", "        acceptIfPresent(action, rightChild(root));\n", "      }\n"], "3": ["\n", "      @Override\n", "      public void forEach(Consumer<? super T> action) {\n", "        checkNotNull(action);\n", "        new Consumer<T>() {\n", "          @Override\n", "          public void accept(T t) {\n", "            acceptIfPresent(this, leftChild(t));\n", "            action.accept(t);\n", "            acceptIfPresent(this, rightChild(t));\n", "          }\n", "        }.accept(root);\n", "      }\n"], "4": ["\n", "  private static <T> void acceptIfPresent(Consumer<? super T> action, Optional<T> node) {\n", "    if (node.isPresent()) {\n", "      action.accept(node.get());\n", "    }\n", "  }\n"]}, "removed": {}, "added_lines": {"1": [28], "2": [86, 87, 88, 89, 90, 91], "3": [181, 182, 183, 184, 185, 186, 187, 188, 189, 190, 191, 192, 193], "4": [230, 231, 232, 233, 234, 235]}, "removed_lines": {}}, {"100": "guava/src/com/google/common/collect/CollectCollectors.java", "added": {"1": ["/*\n", " * Copyright (C) 2016 The Guava Authors\n", " *\n", " * Licensed under the Apache License, Version 2.0 (the \"License\");\n", " * you may not use this file except in compliance with the License.\n", " * You may obtain a copy of the License at\n", " *\n", " * http://www.apache.org/licenses/LICENSE-2.0\n", " *\n", " * Unless required by applicable law or agreed to in writing, software\n", " * distributed under the License is distributed on an \"AS IS\" BASIS,\n", " * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n", " * See the License for the specific language governing permissions and\n", " * limitations under the License.\n", " */\n", "\n", "package com.google.common.collect;\n", "\n", "import static com.google.common.base.Preconditions.checkNotNull;\n", "\n", "import com.google.common.annotations.GwtCompatible;\n", "import java.util.Comparator;\n", "import java.util.function.Function;\n", "import java.util.stream.Collector;\n", "\n", "/**\n", " * Collectors utilities for {@code common.collect} internals.\n", " */\n", "@GwtCompatible\n", "final class CollectCollectors {\n", "  static <T, K, V> Collector<T, ?, ImmutableBiMap<K, V>> toImmutableBiMap(\n", "      Function<? super T, ? extends K> keyFunction,\n", "      Function<? super T, ? extends V> valueFunction) {\n", "    checkNotNull(keyFunction);\n", "    checkNotNull(valueFunction);\n", "    return Collector.of(\n", "        ImmutableBiMap.Builder<K, V>::new,\n", "        (builder, input) -> builder.put(keyFunction.apply(input), valueFunction.apply(input)),\n", "        ImmutableBiMap.Builder::combine,\n", "        ImmutableBiMap.Builder::build,\n", "        new Collector.Characteristics[0]);\n", "  }\n", "\n", "  static <E> Collector<E, ?, ImmutableList<E>> toImmutableList() {\n", "    return Collector.of(\n", "        ImmutableList::<E>builder,\n", "        ImmutableList.Builder::add,\n", "        ImmutableList.Builder::combine,\n", "        ImmutableList.Builder::build);\n", "  }\n", "\n", "  static <T, K, V> Collector<T, ?, ImmutableMap<K, V>> toImmutableMap(\n", "      Function<? super T, ? extends K> keyFunction,\n", "      Function<? super T, ? extends V> valueFunction) {\n", "    checkNotNull(keyFunction);\n", "    checkNotNull(valueFunction);\n", "    return Collector.of(\n", "        ImmutableMap.Builder<K, V>::new,\n", "        (builder, input) -> builder.put(keyFunction.apply(input), valueFunction.apply(input)),\n", "        ImmutableMap.Builder::combine,\n", "        ImmutableMap.Builder::build);\n", "  }\n", "\n", "  static <E> Collector<E, ?, ImmutableSet<E>> toImmutableSet() {\n", "    return Collector.of(\n", "        ImmutableSet::<E>builder,\n", "        ImmutableSet.Builder::add,\n", "        ImmutableSet.Builder::combine,\n", "        ImmutableSet.Builder::build);\n", "  }\n", "\n", "  static <T, K, V> Collector<T, ?, ImmutableSortedMap<K, V>> toImmutableSortedMap(\n", "      Comparator<? super K> comparator,\n", "      Function<? super T, ? extends K> keyFunction,\n", "      Function<? super T, ? extends V> valueFunction) {\n", "    checkNotNull(comparator);\n", "    checkNotNull(keyFunction);\n", "    checkNotNull(valueFunction);\n", "    /*\n", "     * We will always fail if there are duplicate keys, and the keys are always sorted by\n", "     * the Comparator, so the entries can come in in arbitrary order -- so we report UNORDERED.\n", "     */\n", "    return Collector.of(\n", "        () -> new ImmutableSortedMap.Builder<K, V>(comparator),\n", "        (builder, input) -> builder.put(keyFunction.apply(input), valueFunction.apply(input)),\n", "        ImmutableSortedMap.Builder::combine,\n", "        ImmutableSortedMap.Builder::build,\n", "        Collector.Characteristics.UNORDERED);\n", "  }\n", "\n", "  static <E> Collector<E, ?, ImmutableSortedSet<E>> toImmutableSortedSet(\n", "      Comparator<? super E> comparator) {\n", "    checkNotNull(comparator);\n", "    return Collector.of(\n", "        () -> new ImmutableSortedSet.Builder<E>(comparator),\n", "        ImmutableSortedSet.Builder::add,\n", "        ImmutableSortedSet.Builder::combine,\n", "        ImmutableSortedSet.Builder::build);\n", "  }\n", "}\n", "\n"]}, "removed": {}, "added_lines": {"1": [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 58, 59, 60, 61, 62, 63, 64, 65, 66, 67, 68, 69, 70, 71, 72, 73, 74, 75, 76, 77, 78, 79, 80, 81, 82, 83, 84, 85, 86, 87, 88, 89, 90, 91, 92, 93, 94, 95, 96, 97, 98, 99, 100, 101]}, "removed_lines": {}}, {"101": "guava/src/com/google/common/collect/CollectSpliterators.java", "added": {"1": ["/*\n", " * Copyright (C) 2015 The Guava Authors\n", " *\n", " * Licensed under the Apache License, Version 2.0 (the \"License\");\n", " * you may not use this file except in compliance with the License.\n", " * You may obtain a copy of the License at\n", " *\n", " * http://www.apache.org/licenses/LICENSE-2.0\n", " *\n", " * Unless required by applicable law or agreed to in writing, software\n", " * distributed under the License is distributed on an \"AS IS\" BASIS,\n", " * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n", " * See the License for the specific language governing permissions and\n", " * limitations under the License.\n", " */\n", "\n", "package com.google.common.collect;\n", "\n", "import static com.google.common.base.Preconditions.checkArgument;\n", "import static com.google.common.base.Preconditions.checkNotNull;\n", "\n", "import com.google.common.annotations.GwtCompatible;\n", "import java.util.Comparator;\n", "import java.util.Spliterator;\n", "import java.util.function.Consumer;\n", "import java.util.function.Function;\n", "import java.util.function.IntFunction;\n", "import java.util.function.Predicate;\n", "import java.util.stream.IntStream;\n", "import javax.annotation.Nullable;\n", "\n", "/**\n", " * Spliterator utilities for {@code common.collect} internals.\n", " */\n", "@GwtCompatible\n", "final class CollectSpliterators {\n", "  private CollectSpliterators() {}\n", "\n", "  static <T> Spliterator<T> indexed(int size, int extraCharacteristics, IntFunction<T> function) {\n", "    return indexed(size, extraCharacteristics, function, null);\n", "  }\n", "\n", "  static <T> Spliterator<T> indexed(\n", "      int size,\n", "      int extraCharacteristics,\n", "      IntFunction<T> function,\n", "      Comparator<? super T> comparator) {\n", "    if (comparator != null) {\n", "      checkArgument((extraCharacteristics & (Spliterator.SORTED)) != 0);\n", "    }\n", "    class WithCharacteristics implements Spliterator<T> {\n", "      private final Spliterator<T> delegate;\n", "\n", "      WithCharacteristics(Spliterator<T> delegate) {\n", "        this.delegate = delegate;\n", "      }\n", "\n", "      @Override\n", "      public boolean tryAdvance(Consumer<? super T> action) {\n", "        return delegate.tryAdvance(action);\n", "      }\n", "\n", "      @Override\n", "      public void forEachRemaining(Consumer<? super T> action) {\n", "        delegate.forEachRemaining(action);\n", "      }\n", "\n", "      @Override\n", "      @Nullable\n", "      public Spliterator<T> trySplit() {\n", "        Spliterator<T> split = delegate.trySplit();\n", "        return (split == null) ? null : new WithCharacteristics(split);\n", "      }\n", "\n", "      @Override\n", "      public long estimateSize() {\n", "        return delegate.estimateSize();\n", "      }\n", "\n", "      @Override\n", "      public int characteristics() {\n", "        return delegate.characteristics() | extraCharacteristics;\n", "      }\n", "\n", "      @Override\n", "      public Comparator<? super T> getComparator() {\n", "        if (hasCharacteristics(Spliterator.SORTED)) {\n", "          return comparator;\n", "        } else {\n", "          throw new IllegalStateException();\n", "        }\n", "      }\n", "    }\n", "    return new WithCharacteristics(IntStream.range(0, size).mapToObj(function).spliterator());\n", "  }\n", "  \n", "  /**\n", "   * Returns a {@code Spliterator} over the elements of {@code fromSpliterator} mapped by {@code\n", "   * function}.\n", "   */\n", "  static <F, T> Spliterator<T> map(\n", "      Spliterator<F> fromSpliterator, Function<? super F, ? extends T> function) {\n", "    checkNotNull(fromSpliterator);\n", "    checkNotNull(function);\n", "    return new Spliterator<T>() {\n", "\n", "      @Override\n", "      public boolean tryAdvance(Consumer<? super T> action) {\n", "        return fromSpliterator.tryAdvance(\n", "            fromElement -> action.accept(function.apply(fromElement)));\n", "      }\n", "\n", "      @Override\n", "      public void forEachRemaining(Consumer<? super T> action) {\n", "        fromSpliterator.forEachRemaining(fromElement -> action.accept(function.apply(fromElement)));\n", "      }\n", "\n", "      @Override\n", "      public Spliterator<T> trySplit() {\n", "        Spliterator<F> fromSplit = fromSpliterator.trySplit();\n", "        return (fromSplit != null) ? map(fromSplit, function) : null;\n", "      }\n", "\n", "      @Override\n", "      public long estimateSize() {\n", "        return fromSpliterator.estimateSize();\n", "      }\n", "\n", "      @Override\n", "      public int characteristics() {\n", "        return fromSpliterator.characteristics()\n", "            & ~(Spliterator.DISTINCT | Spliterator.NONNULL | Spliterator.SORTED);\n", "      }\n", "    };\n", "  }\n", "  \n", "  /** Returns a {@code Spliterator} filtered by the specified predicate. */\n", "  static <T> Spliterator<T> filter(Spliterator<T> fromSpliterator, Predicate<? super T> predicate) {\n", "    checkNotNull(fromSpliterator);\n", "    checkNotNull(predicate);\n", "    class Splitr implements Spliterator<T>, Consumer<T> {\n", "      T holder = null;\n", "\n", "      @Override\n", "      public void accept(T t) {\n", "        this.holder = t;\n", "      }\n", "\n", "      @Override\n", "      public boolean tryAdvance(Consumer<? super T> action) {\n", "        while (fromSpliterator.tryAdvance(this)) {\n", "          try {\n", "            if (predicate.test(holder)) {\n", "              action.accept(holder);\n", "              return true;\n", "            }\n", "          } finally {\n", "            holder = null;\n", "          }\n", "        }\n", "        return false;\n", "      }\n", "\n", "      @Override\n", "      public Spliterator<T> trySplit() {\n", "        Spliterator<T> fromSplit = fromSpliterator.trySplit();\n", "        return (fromSplit == null) ? null : filter(fromSplit, predicate);\n", "      }\n", "\n", "      @Override\n", "      public long estimateSize() {\n", "        return fromSpliterator.estimateSize() / 2;\n", "      }\n", "\n", "      @Override\n", "      public Comparator<? super T> getComparator() {\n", "        return fromSpliterator.getComparator();\n", "      }\n", "\n", "      @Override\n", "      public int characteristics() {\n", "        return fromSpliterator.characteristics()\n", "            & (Spliterator.DISTINCT\n", "                | Spliterator.NONNULL\n", "                | Spliterator.ORDERED\n", "                | Spliterator.SORTED);\n", "      }\n", "    }\n", "    return new Splitr();\n", "  }\n", "\n", "  /**\n", "   * Returns a {@code Spliterator} that iterates over the elements of the spliterators generated by\n", "   * applying {@code function} to the elements of {@code fromSpliterator}.\n", "   */\n", "  static <F, T> Spliterator<T> flatMap(\n", "      Spliterator<F> fromSpliterator,\n", "      Function<? super F, Spliterator<T>> function,\n", "      int topCharacteristics,\n", "      long topSize) {\n", "    checkArgument(\n", "        (topCharacteristics & Spliterator.SUBSIZED) == 0,\n", "        \"flatMap does not support SUBSIZED characteristic\");\n", "    checkArgument(\n", "        (topCharacteristics & Spliterator.SORTED) == 0,\n", "        \"flatMap does not support SORTED characteristic\");\n", "    checkNotNull(fromSpliterator);\n", "    checkNotNull(function);\n", "    class FlatMapSpliterator implements Spliterator<T> {\n", "      @Nullable Spliterator<T> prefix;\n", "      final Spliterator<F> from;\n", "      final int characteristics;\n", "      long estimatedSize;\n", "\n", "      FlatMapSpliterator(\n", "          Spliterator<T> prefix, Spliterator<F> from, int characteristics, long estimatedSize) {\n", "        this.prefix = prefix;\n", "        this.from = from;\n", "        this.characteristics = characteristics;\n", "        this.estimatedSize = estimatedSize;\n", "      }\n", "\n", "      @Override\n", "      public boolean tryAdvance(Consumer<? super T> action) {\n", "        while (true) {\n", "          if (prefix != null && prefix.tryAdvance(action)) {\n", "            if (estimatedSize != Long.MAX_VALUE) {\n", "              estimatedSize--;\n", "            }\n", "            return true;\n", "          } else {\n", "            prefix = null;\n", "          }\n", "          if (!from.tryAdvance(fromElement -> prefix = function.apply(fromElement))) {\n", "            return false;\n", "          }\n", "        }\n", "      }\n", "\n", "      @Override\n", "      public void forEachRemaining(Consumer<? super T> action) {\n", "        if (prefix != null) {\n", "          prefix.forEachRemaining(action);\n", "          prefix = null;\n", "        }\n", "        from.forEachRemaining(fromElement -> function.apply(fromElement).forEachRemaining(action));\n", "        estimatedSize = 0;\n", "      }\n", "\n", "      @Override\n", "      public Spliterator<T> trySplit() {\n", "        Spliterator<F> fromSplit = from.trySplit();\n", "        if (fromSplit != null) {\n", "          int splitCharacteristics = characteristics & ~Spliterator.SIZED;\n", "          long estSplitSize = estimateSize();\n", "          if (estSplitSize < Long.MAX_VALUE) {\n", "            estSplitSize /= 2;\n", "            this.estimatedSize -= estSplitSize;\n", "          }\n", "          Spliterator<T> result =\n", "              new FlatMapSpliterator(this.prefix, fromSplit, splitCharacteristics, estSplitSize);\n", "          this.prefix = null;\n", "          return result;\n", "        } else if (prefix != null) {\n", "          Spliterator<T> result = prefix;\n", "          this.prefix = null;\n", "          return result;\n", "        } else {\n", "          return null;\n", "        }\n", "      }\n", "\n", "      @Override\n", "      public long estimateSize() {\n", "        if (prefix != null) {\n", "          estimatedSize = Math.max(estimatedSize, prefix.estimateSize());\n", "        }\n", "        return Math.max(estimatedSize, 0);\n", "      }\n", "\n", "      @Override\n", "      public int characteristics() {\n", "        return characteristics;\n", "      }\n", "    }\n", "    return new FlatMapSpliterator(null, fromSpliterator, topCharacteristics, topSize);\n", "  }\n", "}\n"]}, "removed": {}, "added_lines": {"1": [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 58, 59, 60, 61, 62, 63, 64, 65, 66, 67, 68, 69, 70, 71, 72, 73, 74, 75, 76, 77, 78, 79, 80, 81, 82, 83, 84, 85, 86, 87, 88, 89, 90, 91, 92, 93, 94, 95, 96, 97, 98, 99, 100, 101, 102, 103, 104, 105, 106, 107, 108, 109, 110, 111, 112, 113, 114, 115, 116, 117, 118, 119, 120, 121, 122, 123, 124, 125, 126, 127, 128, 129, 130, 131, 132, 133, 134, 135, 136, 137, 138, 139, 140, 141, 142, 143, 144, 145, 146, 147, 148, 149, 150, 151, 152, 153, 154, 155, 156, 157, 158, 159, 160, 161, 162, 163, 164, 165, 166, 167, 168, 169, 170, 171, 172, 173, 174, 175, 176, 177, 178, 179, 180, 181, 182, 183, 184, 185, 186, 187, 188, 189, 190, 191, 192, 193, 194, 195, 196, 197, 198, 199, 200, 201, 202, 203, 204, 205, 206, 207, 208, 209, 210, 211, 212, 213, 214, 215, 216, 217, 218, 219, 220, 221, 222, 223, 224, 225, 226, 227, 228, 229, 230, 231, 232, 233, 234, 235, 236, 237, 238, 239, 240, 241, 242, 243, 244, 245, 246, 247, 248, 249, 250, 251, 252, 253, 254, 255, 256, 257, 258, 259, 260, 261, 262, 263, 264, 265, 266, 267, 268, 269, 270, 271, 272, 273, 274, 275, 276, 277, 278, 279, 280, 281, 282, 283, 284, 285, 286, 287, 288]}, "removed_lines": {}}, {"102": "guava/src/com/google/common/collect/Collections2.java", "added": {"2": ["import java.util.Spliterator;\n", "import java.util.function.Consumer;\n"], "3": ["    @Override\n", "    public Spliterator<E> spliterator() {\n", "      return CollectSpliterators.filter(unfiltered.spliterator(), predicate);\n", "    }\n", "\n", "    @Override\n", "    public void forEach(Consumer<? super E> action) {\n", "      checkNotNull(action);\n", "      unfiltered.forEach(\n", "          (E e) -> {\n", "            if (predicate.test(e)) {\n", "              action.accept(e);\n", "            }\n", "          });\n", "    }\n", "\n"], "4": ["      return removeIf(collection::contains);\n", "      return removeIf(element -> !collection.contains(element));\n", "    }\n", "\n", "    @Override\n", "    public boolean removeIf(java.util.function.Predicate<? super E> filter) {\n", "      checkNotNull(filter);\n", "      return unfiltered.removeIf(element -> predicate.apply(element) && filter.test(element));\n"], "5": ["    @Override\n", "    public Spliterator<T> spliterator() {\n", "      return CollectSpliterators.map(fromCollection.spliterator(), function);\n", "    }\n", "\n", "    @Override\n", "    public void forEach(Consumer<? super T> action) {\n", "      checkNotNull(action);\n", "      fromCollection.forEach((F f) -> action.accept(function.apply(f)));\n", "    }\n", "\n", "    @Override\n", "    public boolean removeIf(java.util.function.Predicate<? super T> filter) {\n", "      checkNotNull(filter);\n", "      return fromCollection.removeIf(element -> filter.test(function.apply(element)));\n", "    }\n", "\n"]}, "removed": {"1": ["import static com.google.common.base.Predicates.and;\n", "import static com.google.common.base.Predicates.not;\n"], "4": ["      return Iterables.removeIf(unfiltered, and(predicate, Predicates.<Object>in(collection)));\n", "      return Iterables.removeIf(unfiltered, and(predicate, not(Predicates.<Object>in(collection))));\n"]}, "added_lines": {"2": [40, 41], "3": [186, 187, 188, 189, 190, 191, 192, 193, 194, 195, 196, 197, 198, 199, 200, 201], "4": [209, 214, 215, 216, 217, 218, 219, 220], "5": [288, 289, 290, 291, 292, 293, 294, 295, 296, 297, 298, 299, 300, 301, 302, 303, 304]}, "removed_lines": {"1": [21, 22], "4": [193, 198]}}, {"103": "guava/src/com/google/common/collect/FluentIterable.java", "added": {"1": ["import java.util.stream.Stream;\n", " * A discouraged (but not deprecated) precursor to Java's superior {@link Stream} library.\n"], "2": [" * <p>{@link Stream} is similar to this class, but generally more powerful, and certainly more\n", " * standard. Key differences include:\n"], "3": [" * <li>Streams are standard Java, not requiring a third-party dependency.\n"], "4": ["   * <p><b>{@code Stream} equivalent:</b> {@link Collection#stream} if {@code iterable} is a\n", "   * {@link Collection}; {@link Streams#stream(Iterable)} otherwise.\n"], "5": ["   * Stream.of(stream1, stream2, ...).flatMap(s -> s)}. If the sources are iterables, use {@code\n", "   * Stream.of(iter1, iter2, ...).flatMap(Streams::stream)}.\n"], "6": ["   * <p><b>{@code Stream} equivalent:</b> {@link Stream#empty}.\n"], "7": ["   * <p><b>{@code Stream} equivalent:</b> {@link Stream#count}.\n"], "8": ["   * <p><b>{@code Stream} equivalent:</b> pass {@link ImmutableList#toImmutableList} to {@code\n"], "9": ["   * <p><b>{@code Stream} equivalent:</b> pass {@link ImmutableList#toImmutableList} to {@code\n"], "10": ["   * <p><b>{@code Stream} equivalent:</b> pass {@link ImmutableSet#toImmutableSet} to {@code\n"], "11": ["   * <p><b>{@code Stream} equivalent:</b> pass {@link\n"], "12": ["   * <p><b>{@code Stream} equivalent:</b> pass {@link ImmutableMultiset#toImmutableMultiset} to\n", "   * {@code\n"], "13": ["   * <p><b>{@code Stream} equivalent:</b> {@code\n", "   * stream.collect(ImmutableMap.toImmutableMap(k -> k, valueFunction))}.\n"], "14": ["   * <p><b>{@code Stream} equivalent:</b> {@code\n", "   * stream.collect(ImmutableMap.toImmutableMap(keyFunction, v -> v))}.\n"], "15": ["  /**\n", "   * Returns a stream of this fluent iterable's contents (similar to calling {@link\n", "   * Collection#stream} on a collecion).\n", "   *\n", "   * <p><b>Note:</b> the earlier in the chain you can switch to {@code Stream} usage (ideally not\n", "   * going through {@code FluentIterable} at all), the more performant and idiomatic your code will\n", "   * be. This method is a transitional aid, to be used only when really necessary.\n", "   *\n", "   * @since 21.0\n", "   */\n", "  public final Stream<E> stream() {\n", "    return Streams.stream(getDelegate());\n", "  }\n", "\n"]}, "removed": {"1": [" * An expanded {@code Iterable} API, providing functionality similar to Java 8's powerful <a href=\n", " * \"https://docs.oracle.com/javase/8/docs/api/java/util/stream/package-summary.html#package.description\"\n", " * >streams library</a> in a slightly different way.\n"], "2": [" * <p>Starting with Java 8, the core Java class libraries provide a new \"Streams\" library (in {@code\n", " * java.util.stream}), which is similar to {@code FluentIterable} but generally more powerful. Key\n", " * differences include:\n"], "3": [" * <li>Streams are standard Java, not requiring a third-party dependency (but do render your code\n", " *     incompatible with Java 7 and earlier).\n"], "4": ["   * <p><b>{@code Stream} equivalent:</b> {@code iterable.stream()} if {@code iterable} is a\n", "   * {@link Collection}; {@code StreamSupport.stream(iterable.spliterator(), false)} otherwise.\n"], "5": ["   * Stream.of(stream1, stream2, ...).flatMap(s -> s)}. If the sources are iterables, after the next\n", "   * release of Guava you can use {@code Stream.of(iter1, iter2, ...).flatMap(Streams::stream)}.\n"], "6": ["   * <p><b>{@code Stream} equivalent:</b> {@code Stream.empty()}.\n"], "7": ["   * <p><b>{@code Stream} equivalent:</b> {@code stream.count()}.\n"], "8": ["   * <p><b>{@code Stream} equivalent:</b> {@code ImmutableList.copyOf(stream.iterator())}, or after\n", "   * the next release of Guava, pass {@link ImmutableList#toImmutableList} to {@code\n"], "9": ["   * <p><b>{@code Stream} equivalent:</b> {@code\n", "   * ImmutableList.copyOf(stream.sorted(comparator).iterator())}, or after the next release of\n", "   * Guava, pass {@link ImmutableList#toImmutableList} to {@code\n"], "10": ["   * <p><b>{@code Stream} equivalent:</b> {@code ImmutableSet.copyOf(stream.iterator())}, or after\n", "   * the next release of Guava, pass {@link ImmutableSet#toImmutableSet} to {@code\n"], "11": ["   * <p><b>{@code Stream} equivalent:</b> {@code ImmutableSortedSet.copyOf(comparator,\n", "   * stream.iterator())}, or after the next release of Guava, pass {@link\n"], "12": ["   * <p><b>{@code Stream} equivalent:</b> {@code ImmutableMultiset.copyOf(stream.iterator())}, or\n", "   * after the next release of Guava, pass {@link ImmutableMultiset#toImmutableMultiset} to {@code\n"], "13": ["   * <p><b>{@code Stream} equivalent:</b> after the next release of Guava, use {@code\n", "   * stream.collect(ImmutableMap.toImmutableMap(k -> k, valueFunction))}. Before then you can use\n", "   * {@code ImmutableMap.copyOf(stream.collect(Collectors.toMap(k -> k, valueFunction)))}, but be\n", "   * aware that this may not preserve the order of entries.\n"], "14": ["   * <p><b>{@code Stream} equivalent:</b> after the next release of Guava, use {@code\n", "   * stream.collect(ImmutableMap.toImmutableMap(keyFunction, v -> v))}. Before then you can use\n", "   * {@code ImmutableMap.copyOf(stream.collect(Collectors.toMap(keyFunction, v -> v)))}, but be\n", "   * aware that this may not preserve the order of entries.\n"]}, "added_lines": {"1": [33, 37], "2": [58, 59], "3": [74], "4": [134, 135], "5": [243, 244], "6": [283], "7": [336], "8": [603], "9": [617], "10": [632], "11": [647], "12": [661, 662], "13": [680, 681], "14": [736, 737], "15": [826, 827, 828, 829, 830, 831, 832, 833, 834, 835, 836, 837, 838, 839]}, "removed_lines": {"1": [36, 37, 38], "2": [59, 60, 61], "3": [76, 77], "4": [137, 138], "5": [246, 247], "6": [286], "7": [339], "8": [606, 607], "9": [621, 622, 623], "10": [638, 639], "11": [654, 655], "12": [669, 670], "13": [688, 689, 690, 691], "14": [746, 747, 748, 749]}}, {"104": "guava/src/com/google/common/collect/ForwardingNavigableMap.java", "added": {"1": ["import java.util.function.BiFunction;\n"], "2": ["    @Override\n", "    public void replaceAll(BiFunction<? super K, ? super V, ? extends V> function) {\n", "      forward().replaceAll(function);\n", "    }\n", "\n"]}, "removed": {}, "added_lines": {"1": [29], "2": [289, 290, 291, 292, 293]}, "removed_lines": {}}, {"105": "guava/src/com/google/common/collect/HashBiMap.java", "added": {"1": ["import static com.google.common.base.Preconditions.checkNotNull;\n"], "2": ["import java.util.function.BiConsumer;\n", "import java.util.function.BiFunction;\n"], "3": ["  @Override\n", "  public void forEach(BiConsumer<? super K, ? super V> action) {\n", "    checkNotNull(action);\n", "    for (BiEntry<K, V> entry = firstInKeyInsertionOrder;\n", "        entry != null;\n", "        entry = entry.nextInKeyInsertionOrder) {\n", "      action.accept(entry.key, entry.value);\n", "    }\n", "  }\n", "\n", "  @Override\n", "  public void replaceAll(BiFunction<? super K, ? super V, ? extends V> function) {\n", "    checkNotNull(function);\n", "    BiEntry<K, V> oldFirst = firstInKeyInsertionOrder;\n", "    clear();\n", "    for (BiEntry<K, V> entry = oldFirst; entry != null; entry = entry.nextInKeyInsertionOrder) {\n", "      put(entry.key, function.apply(entry.key, entry.value));\n", "    }\n", "  }\n", "\n"], "4": ["  private final class Inverse extends IteratorBasedAbstractMap<V, K>\n", "      implements BiMap<V, K>, Serializable {\n"], "5": ["    @CanIgnoreReturnValue\n"], "6": ["    Iterator<Entry<V, K>> entryIterator() {\n", "      return new Itr<Entry<V, K>>() {\n", "        Entry<V, K> output(BiEntry<K, V> entry) {\n", "          return new InverseEntry(entry);\n", "        class InverseEntry extends AbstractMapEntry<V, K> {\n", "          BiEntry<K, V> delegate;\n", "          InverseEntry(BiEntry<K, V> entry) {\n", "            this.delegate = entry;\n", "          }\n", "\n", "          @Override\n", "          public V getKey() {\n", "            return delegate.value;\n", "          }\n", "\n", "          @Override\n", "          public K getValue() {\n", "            return delegate.key;\n", "          }\n", "\n", "          @Override\n", "          public K setValue(K key) {\n", "            K oldKey = delegate.key;\n", "            int keyHash = smearedHash(key);\n", "            if (keyHash == delegate.keyHash && Objects.equal(key, oldKey)) {\n", "              return key;\n", "            checkArgument(seekByKey(key, keyHash) == null, \"value already present: %s\", key);\n", "            delete(delegate);\n", "            BiEntry<K, V> newEntry =\n", "                new BiEntry<K, V>(key, keyHash, delegate.value, delegate.valueHash);\n", "            delegate = newEntry;\n", "            insert(newEntry, null);\n", "            expectedModCount = modCount;\n", "            // This is safe because entries can only get bumped up to earlier in the iteration,\n", "            // so they can't get revisited.\n", "            return oldKey;\n", "          }\n", "    @Override\n", "    public void forEach(BiConsumer<? super V, ? super K> action) {\n", "      checkNotNull(action);\n", "      HashBiMap.this.forEach((k, v) -> action.accept(v, k));\n", "    }\n", "\n", "    @Override\n", "    public void replaceAll(BiFunction<? super V, ? super K, ? extends K> function) {\n", "      checkNotNull(function);\n", "      BiEntry<K, V> oldFirst = firstInKeyInsertionOrder;\n", "      clear();\n", "      for (BiEntry<K, V> entry = oldFirst; entry != null; entry = entry.nextInKeyInsertionOrder) {\n", "        put(entry.value, function.apply(entry.value, entry.key));\n", "      }\n", "    }\n", "\n"]}, "removed": {"2": ["import java.util.AbstractMap;\n"], "4": ["  private final class Inverse extends AbstractMap<V, K> implements BiMap<V, K>, Serializable {\n"], "6": ["    public Set<Entry<V, K>> entrySet() {\n", "      return new Maps.EntrySet<V, K>() {\n", "\n", "        Map<V, K> map() {\n", "          return Inverse.this;\n", "        @Override\n", "        public Iterator<Entry<V, K>> iterator() {\n", "          return new Itr<Entry<V, K>>() {\n", "            @Override\n", "            Entry<V, K> output(BiEntry<K, V> entry) {\n", "              return new InverseEntry(entry);\n", "            }\n", "            class InverseEntry extends AbstractMapEntry<V, K> {\n", "              BiEntry<K, V> delegate;\n", "\n", "              InverseEntry(BiEntry<K, V> entry) {\n", "                this.delegate = entry;\n", "              }\n", "\n", "              @Override\n", "              public V getKey() {\n", "                return delegate.value;\n", "              }\n", "\n", "              @Override\n", "              public K getValue() {\n", "                return delegate.key;\n", "              }\n", "\n", "              @Override\n", "              public K setValue(K key) {\n", "                K oldKey = delegate.key;\n", "                int keyHash = smearedHash(key);\n", "                if (keyHash == delegate.keyHash && Objects.equal(key, oldKey)) {\n", "                  return key;\n", "                }\n", "                checkArgument(seekByKey(key, keyHash) == null, \"value already present: %s\", key);\n", "                delete(delegate);\n", "                BiEntry<K, V> newEntry =\n", "                    new BiEntry<K, V>(key, keyHash, delegate.value, delegate.valueHash);\n", "                delegate = newEntry;\n", "                insert(newEntry, null);\n", "                expectedModCount = modCount;\n", "                // This is safe because entries can only get bumped up to earlier in the iteration,\n", "                // so they can't get revisited.\n", "                return oldKey;\n", "              }\n", "          };\n"]}, "added_lines": {"1": [18], "2": [40, 41], "3": [522, 523, 524, 525, 526, 527, 528, 529, 530, 531, 532, 533, 534, 535, 536, 537, 538, 539, 540, 541], "4": [550, 551], "5": [576], "6": [644, 645, 647, 648, 651, 652, 654, 655, 656, 657, 658, 659, 660, 661, 662, 663, 664, 665, 666, 667, 668, 669, 670, 671, 672, 673, 675, 676, 677, 678, 679, 680, 681, 682, 683, 684, 685, 690, 691, 692, 693, 694, 695, 696, 697, 698, 699, 700, 701, 702, 703, 704, 705]}, "removed_lines": {"2": [33], "4": [528], "6": [620, 621, 622, 624, 625, 628, 629, 630, 631, 632, 633, 634, 636, 637, 638, 639, 640, 641, 642, 643, 644, 645, 646, 647, 648, 649, 650, 651, 652, 653, 654, 655, 656, 657, 658, 659, 660, 661, 662, 663, 664, 665, 666, 667, 668, 669, 670, 672]}}, {"106": "guava/src/com/google/common/collect/ImmutableBiMap.java", "added": {"1": ["import java.util.function.Function;\n", "import java.util.stream.Collector;\n", "import java.util.stream.Collectors;\n"], "2": ["public abstract class ImmutableBiMap<K, V> extends ImmutableBiMapFauxverideShim<K, V>\n", "    implements BiMap<K, V> {\n", "\n", "  /**\n", "   * Returns a {@link Collector} that accumulates elements into an {@code ImmutableBiMap} whose\n", "   * keys and values are the result of applying the provided mapping functions to the input\n", "   * elements. Entries appear in the result {@code ImmutableBiMap} in encounter order.\n", "   *\n", "   * <p>If the mapped keys or values contain duplicates\n", "   * (according to {@link Object#equals(Object)}, an {@code IllegalArgumentException} is thrown\n", "   * when the collection operation is performed. (This differs from the {@code Collector} returned\n", "   * by {@link Collectors#toMap(Function, Function)}, which throws an\n", "   * {@code IllegalStateException}.)\n", "   *\n", "   * @since 21.0\n", "   */\n", "  @Beta\n", "  public static <T, K, V> Collector<T, ?, ImmutableBiMap<K, V>> toImmutableBiMap(\n", "      Function<? super T, ? extends K> keyFunction,\n", "      Function<? super T, ? extends V> valueFunction) {\n", "    return CollectCollectors.toImmutableBiMap(keyFunction, valueFunction);\n", "  }\n"], "3": ["    @CanIgnoreReturnValue\n", "    Builder<K, V> combine(ImmutableMap.Builder<K, V> builder) {\n", "      super.combine(builder);\n", "      return this;\n", "    }\n", "\n"]}, "removed": {"2": ["public abstract class ImmutableBiMap<K, V> extends ImmutableMap<K, V> implements BiMap<K, V> {\n"]}, "added_lines": {"1": [25, 26, 27], "2": [37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 58], "3": [229, 230, 231, 232, 233, 234]}, "removed_lines": {"2": [34]}}, {"107": "guava/src/com/google/common/collect/ImmutableBiMapFauxverideShim.java", "added": {"1": ["/*\n", " * Copyright (C) 2015 The Guava Authors\n", " *\n", " * Licensed under the Apache License, Version 2.0 (the \"License\");\n", " * you may not use this file except in compliance with the License.\n", " * You may obtain a copy of the License at\n", " *\n", " * http://www.apache.org/licenses/LICENSE-2.0\n", " *\n", " * Unless required by applicable law or agreed to in writing, software\n", " * distributed under the License is distributed on an \"AS IS\" BASIS,\n", " * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n", " * See the License for the specific language governing permissions and\n", " * limitations under the License.\n", " */\n", "\n", "package com.google.common.collect;\n", "\n", "import com.google.common.annotations.GwtIncompatible;\n", "import java.util.function.BinaryOperator;\n", "import java.util.function.Function;\n", "import java.util.stream.Collector;\n", "\n", "/**\n", " * \"Overrides\" the {@link ImmutableMap} static methods that lack\n", " * {@link ImmutableBiMap} equivalents with deprecated, exception-throwing\n", " * versions. See {@link ImmutableSortedSetFauxverideShim} for details.\n", " *\n", " * @author Louis Wasserman\n", " */\n", "@GwtIncompatible\n", "abstract class ImmutableBiMapFauxverideShim<K, V> extends ImmutableMap<K, V> {\n", "  /**\n", "   * Not supported. Use {@link ImmutableBiMap#toImmutableBiMap} instead. This method exists only to\n", "   * hide {@link ImmutableMap#toImmutableMap(Function, Function)} from consumers of {@code\n", "   * ImmutableBiMap}.\n", "   *\n", "   * @throws UnsupportedOperationException always\n", "   * @deprecated Use {@link ImmutableBiMap#toImmutableBiMap}.\n", "   */\n", "  @Deprecated\n", "  public static <T, K, V> Collector<T, ?, ImmutableMap<K, V>> toImmutableMap(\n", "      Function<? super T, ? extends K> keyFunction,\n", "      Function<? super T, ? extends V> valueFunction) {\n", "    throw new UnsupportedOperationException();\n", "  }\n", "  \n", "  /**\n", "   * Not supported. This method does not make sense for {@code BiMap}. This method exists only to\n", "   * hide {@link ImmutableMap#toImmutableMap(Function, Function, BinaryOperator)} from consumers of\n", "   * {@code ImmutableBiMap}.\n", "   *\n", "   * @throws UnsupportedOperationException always\n", "   * @deprecated\n", "   */\n", "  @Deprecated\n", "  public static <T, K, V> Collector<T, ?, ImmutableMap<K, V>> toImmutableMap(\n", "      Function<? super T, ? extends K> keyFunction,\n", "      Function<? super T, ? extends V> valueFunction,\n", "      BinaryOperator<V> mergeFunction) {\n", "    throw new UnsupportedOperationException();\n", "  }\n", "}\n"]}, "removed": {}, "added_lines": {"1": [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 58, 59, 60, 61, 62, 63]}, "removed_lines": {}}, {"108": "guava/src/com/google/common/collect/ImmutableCollection.java", "added": {"1": ["import java.util.Spliterator;\n", "import java.util.Spliterators;\n", "import java.util.function.Predicate;\n"], "2": ["  /*\n", "   * We expect SIZED (and SUBSIZED, if applicable) to be added by the spliterator factory methods.\n", "   * These are properties of the collection as a whole; SIZED and SUBSIZED are more properties of\n", "   * the spliterator implementation.\n", "   */\n", "  static final int SPLITERATOR_CHARACTERISTICS =\n", "      Spliterator.IMMUTABLE | Spliterator.NONNULL | Spliterator.ORDERED;\n"], "3": ["  @Override\n", "  public Spliterator<E> spliterator() {\n", "    return Spliterators.spliterator(this, SPLITERATOR_CHARACTERISTICS);\n", "  }\n", "\n"], "4": ["  public final boolean removeIf(Predicate<? super E> filter) {\n", "    throw new UnsupportedOperationException();\n", "  }\n", "\n", "  /**\n", "   * Guaranteed to throw an exception and leave the collection unmodified.\n", "   *\n", "   * @throws UnsupportedOperationException always\n", "   * @deprecated Unsupported operation.\n", "   */\n", "  @Deprecated\n", "  @Override\n"], "5": ["\n", "    @CanIgnoreReturnValue\n", "    ArrayBasedBuilder<E> combine(ArrayBasedBuilder<E> builder) {\n", "      checkNotNull(builder);\n", "      ensureCapacity(size + builder.size);\n", "      System.arraycopy(builder.contents, 0, this.contents, size, builder.size);\n", "      size += builder.size;\n", "      return this;\n", "    }\n"]}, "removed": {}, "added_lines": {"1": [32, 33, 34], "2": [158, 159, 160, 161, 162, 163, 164], "3": [174, 175, 176, 177, 178], "4": [268, 269, 270, 271, 272, 273, 274, 275, 276, 277, 278, 279], "5": [502, 503, 504, 505, 506, 507, 508, 509, 510]}, "removed_lines": {}}, {"109": "guava/src/com/google/common/collect/ImmutableEnumMap.java", "added": {"1": ["import java.util.Spliterator;\n", "import java.util.function.BiConsumer;\n"], "2": ["  @Override\n", "  Spliterator<K> keySpliterator() {\n", "    return delegate.keySet().spliterator();\n", "  }\n", "\n"], "3": ["  @Override\n", "  Spliterator<Entry<K, V>> entrySpliterator() {\n", "    return CollectSpliterators.map(delegate.entrySet().spliterator(), Maps::unmodifiableEntry);\n", "  }\n", "  \n", "  @Override public void forEach(BiConsumer<? super K, ? super V> action) {\n", "    delegate.forEach(action);\n", "  }\n", "\n"]}, "removed": {}, "added_lines": {"1": [24, 25], "2": [61, 62, 63, 64, 65], "3": [97, 98, 99, 100, 101, 102, 103, 104, 105]}, "removed_lines": {}}, {"110": "guava/src/com/google/common/collect/ImmutableEnumSet.java", "added": {"1": ["import java.util.Spliterator;\n", "import java.util.function.Consumer;\n"], "2": ["  @Override\n", "  public Spliterator<E> spliterator() {\n", "    return delegate.spliterator();\n", "  }\n", "\n", "  @Override\n", "  public void forEach(Consumer<? super E> action) {\n", "    delegate.forEach(action);\n", "  }\n", "\n"]}, "removed": {}, "added_lines": {"1": [24, 25], "2": [72, 73, 74, 75, 76, 77, 78, 79, 80, 81]}, "removed_lines": {}}, {"111": "guava/src/com/google/common/collect/ImmutableList.java", "added": {"1": ["import com.google.common.annotations.Beta;\n"], "2": ["import java.util.Spliterator;\n", "import java.util.function.Consumer;\n", "import java.util.function.UnaryOperator;\n", "import java.util.stream.Collector;\n"], "3": ["\n", "  /**\n", "   * Returns a {@code Collector} that accumulates the input elements into a new\n", "   * {@code ImmutableList}, in encounter order.\n", "   *\n", "   * @since 21.0\n", "   */\n", "  @Beta\n", "  public static <E> Collector<E, ?, ImmutableList<E>> toImmutableList() {\n", "    return CollectCollectors.toImmutableList();\n", "  }\n", "\n"], "4": ["  @Override\n", "  public void forEach(Consumer<? super E> consumer) {\n", "    checkNotNull(consumer);\n", "    int n = size();\n", "    for (int i = 0; i < n; i++) {\n", "      consumer.accept(get(i));\n", "    }\n", "  }\n", "\n"], "5": ["  /**\n", "   * Guaranteed to throw an exception and leave the list unmodified.\n", "   *\n", "   * @throws UnsupportedOperationException always\n", "   * @deprecated Unsupported operation.\n", "   */\n", "  @Deprecated\n", "  @Override\n", "  public final void replaceAll(UnaryOperator<E> operator) {\n", "    throw new UnsupportedOperationException();\n", "  }\n", "\n", "  /**\n", "   * Guaranteed to throw an exception and leave the list unmodified.\n", "   *\n", "   * @throws UnsupportedOperationException always\n", "   * @deprecated Unsupported operation.\n", "   */\n", "  @Deprecated\n", "  @Override\n", "  public final void sort(Comparator<? super E> c) {\n", "    throw new UnsupportedOperationException();\n", "  }\n", "\n"], "6": ["  @Override\n", "  public Spliterator<E> spliterator() {\n", "    return CollectSpliterators.indexed(size(), SPLITERATOR_CHARACTERISTICS, this::get);\n", "  }\n", "\n"], "7": ["    @CanIgnoreReturnValue\n", "    @Override\n", "    Builder<E> combine(ArrayBasedBuilder<E> builder) {\n", "      super.combine(builder);\n", "      return this;\n", "    }\n", "\n"]}, "removed": {}, "added_lines": {"1": [26], "2": [39, 40, 41, 42], "3": [62, 63, 64, 65, 66, 67, 68, 69, 70, 71, 72, 73], "4": [404, 405, 406, 407, 408, 409, 410, 411, 412], "5": [545, 546, 547, 548, 549, 550, 551, 552, 553, 554, 555, 556, 557, 558, 559, 560, 561, 562, 563, 564, 565, 566, 567, 568], "6": [579, 580, 581, 582, 583], "7": [808, 809, 810, 811, 812, 813, 814]}, "removed_lines": {}}, {"112": "guava/src/com/google/common/collect/ImmutableListMultimap.java", "added": {"1": ["import static com.google.common.base.Preconditions.checkNotNull;\n", "\n"], "2": ["import java.util.function.Function;\n", "import java.util.stream.Collector;\n"], "3": ["  /**\n", "   * Returns a {@link Collector} that accumulates elements into an {@code ImmutableListMultimap}\n", "   * whose keys and values are the result of applying the provided mapping functions to the input\n", "   * elements.\n", "   *\n", "   * <p>For streams with {@linkplain java.util.stream#Ordering defined encounter order}, that order\n", "   * is preserved, but entries are {@linkplain ImmutableMultimap#iteration grouped by key}.\n", "   *\n", "   * Example:\n", "   * <pre>   {@code\n", "   *\n", "   *   static final Multimap<Character, String> FIRST_LETTER_MULTIMAP =\n", "   *       Stream.of(\"banana\", \"apple\", \"carrot\", \"asparagus\", \"cherry\")\n", "   *           .collect(toImmutableListMultimap(str -> str.charAt(0), str -> str.substring(1)));\n", "   *\n", "   *   // is equivalent to\n", "   *\n", "   *   static final Multimap<Character, String> FIRST_LETTER_MULTIMAP =\n", "   *       new ImmutableListMultimap.Builder<Character, String>()\n", "   *           .put('b', \"anana\")\n", "   *           .putAll('a', \"pple\", \"sparagus\")\n", "   *           .putAll('c', \"arrot\", \"herry\")\n", "   *           .build();}</pre>\n", "   *\n", "   * @since 21.0\n", "   */\n", "  @Beta\n", "  public static <T, K, V> Collector<T, ?, ImmutableListMultimap<K, V>> toImmutableListMultimap(\n", "      Function<? super T, ? extends K> keyFunction,\n", "      Function<? super T, ? extends V> valueFunction) {\n", "    checkNotNull(keyFunction, \"keyFunction\");\n", "    checkNotNull(valueFunction, \"valueFunction\");\n", "    return Collector.of(\n", "        ImmutableListMultimap::<K, V>builder,\n", "        (builder, t) -> builder.put(keyFunction.apply(t), valueFunction.apply(t)),\n", "        ImmutableListMultimap.Builder::combine,\n", "        ImmutableListMultimap.Builder::build);\n", "  }\n"], "4": ["    @CanIgnoreReturnValue\n", "    @Override\n", "    Builder<K, V> combine(ImmutableMultimap.Builder<K, V> other) {\n", "      super.combine(other);\n", "      return this;\n", "    }\n", "\n"]}, "removed": {}, "added_lines": {"1": [19, 20], "2": [34, 35], "3": [52, 53, 54, 55, 56, 57, 58, 59, 60, 61, 62, 63, 64, 65, 66, 67, 68, 69, 70, 71, 72, 73, 74, 75, 76, 77, 78, 79, 80, 81, 82, 83, 84, 85, 86, 87, 88, 89], "4": [243, 244, 245, 246, 247, 248, 249]}, "removed_lines": {}}, {"113": "guava/src/com/google/common/collect/ImmutableMap.java", "added": {"1": ["import java.util.LinkedHashMap;\n", "import java.util.Spliterator;\n", "import java.util.Spliterators;\n", "import java.util.function.BiFunction;\n", "import java.util.function.BinaryOperator;\n", "import java.util.function.Function;\n", "import java.util.stream.Collector;\n", "import java.util.stream.Collectors;\n"], "2": ["  /**\n", "   * Returns a {@link Collector} that accumulates elements into an {@code ImmutableMap} whose keys\n", "   * and values are the result of applying the provided mapping functions to the input elements.\n", "   * Entries appear in the result {@code ImmutableMap} in encounter order.\n", "   *\n", "   * <p>If the mapped keys contain duplicates (according to {@link Object#equals(Object)}, an\n", "   * {@code IllegalArgumentException} is thrown when the collection operation is performed.\n", "   * (This differs from the {@code Collector} returned by\n", "   * {@link Collectors#toMap(Function, Function)}, which throws an {@code IllegalStateException}.)\n", "   *\n", "   * @since 21.0\n", "   */\n", "  @Beta\n", "  public static <T, K, V> Collector<T, ?, ImmutableMap<K, V>> toImmutableMap(\n", "      Function<? super T, ? extends K> keyFunction,\n", "      Function<? super T, ? extends V> valueFunction) {\n", "    return CollectCollectors.toImmutableMap(keyFunction, valueFunction);\n", "  }\n", "  \n", "  /**\n", "   * Returns a {@link Collector} that accumulates elements into an {@code ImmutableMap} whose keys\n", "   * and values are the result of applying the provided mapping functions to the input elements.\n", "   *\n", "   * <p>If the mapped keys contain duplicates (according to {@link Object#equals(Object)}), the\n", "   * values are merged using the specified merging function. Entries will appear in the encounter\n", "   * order of the first occurrence of the key.\n", "   *\n", "   * @since 21.0\n", "   */\n", "  @Beta\n", "  public static <T, K, V> Collector<T, ?, ImmutableMap<K, V>> toImmutableMap(\n", "      Function<? super T, ? extends K> keyFunction,\n", "      Function<? super T, ? extends V> valueFunction,\n", "      BinaryOperator<V> mergeFunction) {\n", "    checkNotNull(keyFunction);\n", "    checkNotNull(valueFunction);\n", "    checkNotNull(mergeFunction);\n", "    return Collectors.collectingAndThen(\n", "        Collectors.toMap(keyFunction, valueFunction, mergeFunction, LinkedHashMap::new),\n", "        ImmutableMap::copyOf);\n", "  }\n", "\n"], "3": ["    @CanIgnoreReturnValue\n", "    Builder<K, V> combine(Builder<K, V> other) {\n", "      checkNotNull(other);\n", "      ensureCapacity(this.size + other.size);\n", "      System.arraycopy(other.entries, 0, this.entries, this.size, other.size);\n", "      this.size += other.size;\n", "      return this;\n", "    }\n", "\n"], "4": ["    Spliterator<Entry<K, V>> entrySpliterator() {\n", "      return Spliterators.spliterator(\n", "          entryIterator(),\n", "          size(),\n", "          Spliterator.DISTINCT | Spliterator.NONNULL | Spliterator.IMMUTABLE | Spliterator.ORDERED);\n", "    }\n", "\n"], "5": ["  public final V putIfAbsent(K key, V value) {\n", "    throw new UnsupportedOperationException();\n", "  }\n", "\n", "  /**\n", "   * Guaranteed to throw an exception and leave the map unmodified.\n", "   *\n", "   * @throws UnsupportedOperationException always\n", "   * @deprecated Unsupported operation.\n", "   */\n", "  @Deprecated\n", "  @Override\n", "  public final boolean replace(K key, V oldValue, V newValue) {\n", "    throw new UnsupportedOperationException();\n", "  }\n", "\n", "  /**\n", "   * Guaranteed to throw an exception and leave the map unmodified.\n", "   *\n", "   * @throws UnsupportedOperationException always\n", "   * @deprecated Unsupported operation.\n", "   */\n", "  @Deprecated\n", "  @Override\n", "  public final V replace(K key, V value) {\n", "    throw new UnsupportedOperationException();\n", "  }\n", "\n", "  /**\n", "   * Guaranteed to throw an exception and leave the map unmodified.\n", "   *\n", "   * @throws UnsupportedOperationException always\n", "   * @deprecated Unsupported operation.\n", "   */\n", "  @Deprecated\n", "  @Override\n", "  public final V computeIfAbsent(K key, Function<? super K, ? extends V> mappingFunction) {\n", "    throw new UnsupportedOperationException();\n", "  }\n", "\n", "  /**\n", "   * Guaranteed to throw an exception and leave the map unmodified.\n", "   *\n", "   * @throws UnsupportedOperationException always\n", "   * @deprecated Unsupported operation.\n", "   */\n", "  @Deprecated\n", "  @Override\n", "  public final V computeIfPresent(\n", "      K key, BiFunction<? super K, ? super V, ? extends V> remappingFunction) {\n", "    throw new UnsupportedOperationException();\n", "  }\n", "\n", "  /**\n", "   * Guaranteed to throw an exception and leave the map unmodified.\n", "   *\n", "   * @throws UnsupportedOperationException always\n", "   * @deprecated Unsupported operation.\n", "   */\n", "  @Deprecated\n", "  @Override\n", "  public final V compute(K key, BiFunction<? super K, ? super V, ? extends V> remappingFunction) {\n", "    throw new UnsupportedOperationException();\n", "  }\n", "\n", "  /**\n", "   * Guaranteed to throw an exception and leave the map unmodified.\n", "   *\n", "   * @throws UnsupportedOperationException always\n", "   * @deprecated Unsupported operation.\n", "   */\n", "  @Deprecated\n", "  @Override\n", "  public final V merge(\n", "      K key, V value, BiFunction<? super V, ? super V, ? extends V> remappingFunction) {\n"], "6": ["  /**\n", "   * Guaranteed to throw an exception and leave the map unmodified.\n", "   *\n", "   * @throws UnsupportedOperationException always\n", "   * @deprecated Unsupported operation.\n", "   */\n", "  @Deprecated\n", "  @Override\n", "  public final void replaceAll(BiFunction<? super K, ? super V, ? extends V> function) {\n", "    throw new UnsupportedOperationException();\n", "  }\n", "\n", "  /**\n", "   * Guaranteed to throw an exception and leave the map unmodified.\n", "   *\n", "   * @throws UnsupportedOperationException always\n", "   * @deprecated Unsupported operation.\n", "   */\n", "  @Deprecated\n", "  @Override\n", "  public final V remove(Object o) {\n", "    throw new UnsupportedOperationException();\n", "  }\n", "\n", "  /**\n", "   * Guaranteed to throw an exception and leave the map unmodified.\n", "   *\n", "   * @throws UnsupportedOperationException always\n", "   * @deprecated Unsupported operation.\n", "   */\n", "  @Deprecated\n", "  @Override\n", "  public final boolean remove(Object key, Object value) {\n", "    throw new UnsupportedOperationException();\n", "  }\n", "\n"], "7": ["  @Override\n", "  public final V getOrDefault(@Nullable Object key, @Nullable V defaultValue) {\n", "    V result = get(key);\n", "    return (result != null) ? result : defaultValue;\n", "  }\n", "\n"], "8": ["  Spliterator<K> keySpliterator() {\n", "    return CollectSpliterators.map(entrySet().spliterator(), Entry::getKey);\n", "  }\n", "\n"]}, "removed": {"5": ["  public final V remove(Object o) {\n"]}, "added_lines": {"1": [35, 37, 38, 39, 40, 41, 42, 43], "2": [62, 63, 64, 65, 66, 67, 68, 69, 70, 71, 72, 73, 74, 75, 76, 77, 78, 79, 80, 81, 82, 83, 84, 85, 86, 87, 88, 89, 90, 91, 92, 93, 94, 95, 96, 97, 98, 99, 100, 101, 102, 103], "3": [315, 316, 317, 318, 319, 320, 321, 322, 323], "4": [436, 437, 438, 439, 440, 441, 442], "5": [485, 486, 487, 488, 489, 490, 491, 492, 493, 494, 495, 496, 497, 498, 499, 500, 501, 502, 503, 504, 505, 506, 507, 508, 509, 510, 511, 512, 513, 514, 515, 516, 517, 518, 519, 520, 521, 522, 523, 524, 525, 526, 527, 528, 529, 530, 531, 532, 533, 534, 535, 536, 537, 538, 539, 540, 541, 542, 543, 544, 545, 546, 547, 548, 549, 550, 551, 552, 553, 554, 555, 556, 557, 558, 559], "6": [575, 576, 577, 578, 579, 580, 581, 582, 583, 584, 585, 586, 587, 588, 589, 590, 591, 592, 593, 594, 595, 596, 597, 598, 599, 600, 601, 602, 603, 604, 605, 606, 607, 608, 609, 610], "7": [642, 643, 644, 645, 646, 647], "8": [695, 696, 697, 698]}, "removed_lines": {"5": [419]}}, {"114": "guava/src/com/google/common/collect/ImmutableMapEntrySet.java", "added": {"1": ["import static com.google.common.base.Preconditions.checkNotNull;\n", "\n", "import java.util.Spliterator;\n", "import java.util.Spliterators;\n", "import java.util.function.Consumer;\n"], "2": ["    @Override\n", "    public Spliterator<Entry<K, V>> spliterator() {\n", "      return Spliterators.spliterator(entries, ImmutableSet.SPLITERATOR_CHARACTERISTICS);\n", "    }\n", "\n", "    @Override\n", "    public void forEach(Consumer<? super Entry<K, V>> action) {\n", "      checkNotNull(action);\n", "      for (Entry<K, V> entry : entries) {\n", "        action.accept(entry);\n", "      }\n", "    }\n", "\n"]}, "removed": {}, "added_lines": {"1": [19, 20, 26, 27, 28], "2": [58, 59, 60, 61, 62, 63, 64, 65, 66, 67, 68, 69, 70]}, "removed_lines": {}}, {"115": "guava/src/com/google/common/collect/ImmutableMapKeySet.java", "added": {"1": ["import static com.google.common.base.Preconditions.checkNotNull;\n", "\n", "import com.google.common.collect.ImmutableSet.Indexed;\n", "import java.util.Spliterator;\n", "import java.util.function.Consumer;\n"], "2": ["  @Override\n", "  public Spliterator<K> spliterator() {\n", "    return map.keySpliterator();\n", "  }\n", "\n"], "3": ["  @Override\n", "  public void forEach(Consumer<? super K> action) {\n", "    checkNotNull(action);\n", "    map.forEach((k, v) -> action.accept(k));\n", "  }\n", "\n"]}, "removed": {}, "added_lines": {"1": [19, 20, 23, 26, 27], "2": [54, 55, 56, 57, 58], "3": [69, 70, 71, 72, 73, 74]}, "removed_lines": {}}, {"116": "guava/src/com/google/common/collect/ImmutableMapValues.java", "added": {"1": ["import static com.google.common.base.Preconditions.checkNotNull;\n", "\n", "import java.util.Spliterator;\n", "import java.util.function.Consumer;\n"], "2": ["  @Override public Spliterator<V> spliterator() {\n", "    return CollectSpliterators.map(map.entrySet().spliterator(), Entry::getValue);\n", "  }\n", "\n"], "3": ["  @GwtIncompatible // serialization\n", "  @Override\n", "  public void forEach(Consumer<? super V> action) {\n", "    checkNotNull(action);\n", "    map.forEach((k, v) -> action.accept(v));\n", "  }\n", "\n"]}, "removed": {}, "added_lines": {"1": [19, 20, 26, 27], "2": [66, 67, 68, 69], "3": [96, 97, 98, 99, 100, 101, 102]}, "removed_lines": {}}, {"117": "guava/src/com/google/common/collect/ImmutableMultimap.java", "added": {"1": ["import java.util.Spliterator;\n", "import java.util.function.BiConsumer;\n"], "2": ["    @CanIgnoreReturnValue\n", "    Builder<K, V> combine(Builder<K, V> other) {\n", "      putAll(other.builderMultimap);\n", "      return this;\n", "    }\n", "\n"], "3": ["          list.sort(valueComparator);\n"], "4": ["  @Override\n", "  Spliterator<Entry<K, V>> entrySpliterator() {\n", "    return CollectSpliterators.flatMap(\n", "        asMap().entrySet().spliterator(),\n", "        keyToValueCollectionEntry -> {\n", "          K key = keyToValueCollectionEntry.getKey();\n", "          Collection<V> valueCollection = keyToValueCollectionEntry.getValue();\n", "          return CollectSpliterators.map(\n", "              valueCollection.spliterator(), (V value) -> Maps.immutableEntry(key, value));\n", "        },\n", "        Spliterator.SIZED | (this instanceof SetMultimap ? Spliterator.DISTINCT : 0),\n", "        size());\n", "  }\n", "  \n", "  @Override\n", "  public void forEach(BiConsumer<? super K, ? super V> action) {\n", "    checkNotNull(action);\n", "    asMap()\n", "        .forEach(\n", "            (key, valueCollection) -> valueCollection.forEach(value -> action.accept(key, value)));\n", "  }\n", "\n"]}, "removed": {"1": ["import java.util.Collections;\n", "\n"], "3": ["          Collections.sort(list, valueComparator);\n"]}, "added_lines": {"1": [37, 38], "2": [268, 269, 270, 271, 272, 273], "3": [281], "4": [603, 604, 605, 606, 607, 608, 609, 610, 611, 612, 613, 614, 615, 616, 617, 618, 619, 620, 621, 622, 623, 624]}, "removed_lines": {"1": [32, 39], "3": [276]}}, {"118": "guava/src/com/google/common/collect/ImmutableMultiset.java", "added": {"1": ["import com.google.common.annotations.Beta;\n"], "2": ["import java.util.function.Function;\n", "import java.util.function.ToIntFunction;\n", "import java.util.stream.Collector;\n"], "3": ["\n", "  /**\n", "   * Returns a {@code Collector} that accumulates the input elements into a new\n", "   * {@code ImmutableMultiset}.  Elements iterate in order by the <i>first</i> appearance of that\n", "   * element in encounter order.\n", "   *\n", "   * @since 21.0\n", "   */\n", "  @Beta\n", "  public static <E> Collector<E, ?, ImmutableMultiset<E>> toImmutableMultiset() {\n", "    return toImmutableMultiset(Function.identity(), e -> 1);\n", "  }\n", "\n", "  /**\n", "   * Returns a {@code Collector} that accumulates elements into an {@code ImmutableMultiset}\n", "   * whose elements are the result of applying {@code elementFunction} to the inputs,\n", "   * with counts equal to the result of applying {@code countFunction} to the inputs.\n", "   *\n", "   * <p>If the mapped elements contain duplicates (according to {@link Object#equals}),\n", "   * the first occurrence in encounter order appears in the resulting multiset, with count\n", "   * equal to the sum of the outputs of {@code countFunction.applyAsInt(t)} for each {@code t}\n", "   * mapped to that element.\n", "   */\n", "  private static <T, E> Collector<T, ?, ImmutableMultiset<E>> toImmutableMultiset(\n", "      Function<? super T, ? extends E> elementFunction, ToIntFunction<? super T> countFunction) {\n", "    // TODO(lowasser): consider exposing this\n", "    checkNotNull(elementFunction);\n", "    checkNotNull(countFunction);\n", "    return Collector.of(\n", "        LinkedHashMultiset::create,\n", "        (multiset, t) -> multiset.add(elementFunction.apply(t), countFunction.applyAsInt(t)),\n", "        (multiset1, multiset2) -> {\n", "          multiset1.addAll(multiset2);\n", "          return multiset1;\n", "        },\n", "        (Multiset<E> multiset) -> copyFromEntries(multiset.entrySet()));\n", "  }\n", "\n"]}, "removed": {"1": ["import com.google.common.collect.Multiset.Entry;\n"]}, "added_lines": {"1": [21], "2": [32, 33, 34], "3": [57, 58, 59, 60, 61, 62, 63, 64, 65, 66, 67, 68, 69, 70, 71, 72, 73, 74, 75, 76, 77, 78, 79, 80, 81, 82, 83, 84, 85, 86, 87, 88, 89, 90, 91, 92, 93, 94]}, "removed_lines": {"1": [23]}}, {"119": "guava/src/com/google/common/collect/ImmutableSet.java", "added": {"1": ["import static com.google.common.base.Preconditions.checkNotNull;\n", "import com.google.common.annotations.Beta;\n"], "2": ["import java.util.Spliterator;\n", "import java.util.function.Consumer;\n", "import java.util.stream.Collector;\n"], "3": ["  static final int SPLITERATOR_CHARACTERISTICS =\n", "      ImmutableCollection.SPLITERATOR_CHARACTERISTICS | Spliterator.DISTINCT;\n", "\n", "  /**\n", "   * Returns a {@code Collector} that accumulates the input elements into a new\n", "   * {@code ImmutableSet}.  Elements are added in encounter order; if the\n", "   * elements contain duplicates (according to {@link Object#equals(Object)}),\n", "   * only the first duplicate in encounter order will appear in the result.\n", "   *\n", "   * @since 21.0\n", "   */\n", "  @Beta\n", "  public static <E> Collector<E, ?, ImmutableSet<E>> toImmutableSet() {\n", "    return CollectCollectors.toImmutableSet();\n", "  }\n", "\n"], "4": ["    @Override\n", "    public Spliterator<E> spliterator() {\n", "      return CollectSpliterators.indexed(size(), SPLITERATOR_CHARACTERISTICS, this::get);\n", "    }\n", "\n", "    @Override\n", "    public void forEach(Consumer<? super E> consumer) {\n", "      checkNotNull(consumer);\n", "      int n = size();\n", "      for (int i = 0; i < n; i++) {\n", "        consumer.accept(get(i));\n", "      }\n", "    }\n", "\n"], "5": ["    @CanIgnoreReturnValue\n", "    @Override\n", "    Builder<E> combine(ArrayBasedBuilder<E> builder) {\n", "      super.combine(builder);\n", "      return this;\n", "    }\n", "\n"]}, "removed": {}, "added_lines": {"1": [20, 23], "2": [36, 37, 38], "3": [50, 51, 52, 53, 54, 55, 56, 57, 58, 59, 60, 61, 62, 63, 64, 65], "4": [380, 381, 382, 383, 384, 385, 386, 387, 388, 389, 390, 391, 392, 393], "5": [536, 537, 538, 539, 540, 541, 542]}, "removed_lines": {}}, {"120": "guava/src/com/google/common/collect/ImmutableSetMultimap.java", "added": {"1": ["import java.util.function.Function;\n", "import java.util.stream.Collector;\n"], "2": ["  /**\n", "   * Returns a {@link Collector} that accumulates elements into an {@code ImmutableSetMultimap}\n", "   * whose keys and values are the result of applying the provided mapping functions to the input\n", "   * elements.\n", "   *\n", "   * <p>For streams with {@linkplain java.util.stream#Ordering defined encounter order}, that order\n", "   * is preserved, but entries are {@linkplain ImmutableMultimap#iteration grouped by key}.\n", "   *\n", "   * Example:\n", "   * <pre>   {@code\n", "   *\n", "   *   static final Multimap<Character, String> FIRST_LETTER_MULTIMAP =\n", "   *       Stream.of(\"banana\", \"apple\", \"carrot\", \"asparagus\", \"cherry\")\n", "   *           .collect(toImmutableSetMultimap(str -> str.charAt(0), str -> str.substring(1)));\n", "   *\n", "   *   // is equivalent to\n", "   *\n", "   *   static final Multimap<Character, String> FIRST_LETTER_MULTIMAP =\n", "   *       new ImmutableSetMultimap.Builder<Character, String>()\n", "   *           .put('b', \"anana\")\n", "   *           .putAll('a', \"pple\", \"sparagus\")\n", "   *           .putAll('c', \"arrot\", \"herry\")\n", "   *           .build();}</pre>\n", "   * @since 21.0\n", "   */\n", "  @Beta\n", "  public static <T, K, V> Collector<T, ?, ImmutableSetMultimap<K, V>> toImmutableSetMultimap(\n", "      Function<? super T, ? extends K> keyFunction,\n", "      Function<? super T, ? extends V> valueFunction) {\n", "    checkNotNull(keyFunction, \"keyFunction\");\n", "    checkNotNull(valueFunction, \"valueFunction\");\n", "    return Collector.of(\n", "        ImmutableSetMultimap::<K, V>builder,\n", "        (builder, t) -> builder.put(keyFunction.apply(t), valueFunction.apply(t)),\n", "        ImmutableSetMultimap.Builder::combine,\n", "        ImmutableSetMultimap.Builder::build);\n", "  }\n"], "3": ["    @CanIgnoreReturnValue\n", "    @Override\n", "    Builder<K, V> combine(ImmutableMultimap.Builder<K, V> other) {\n", "      super.combine(other);\n", "      return this;\n", "    }\n", "\n"]}, "removed": {}, "added_lines": {"1": [39, 40], "2": [57, 58, 59, 60, 61, 62, 63, 64, 65, 66, 67, 68, 69, 70, 71, 72, 73, 74, 75, 76, 77, 78, 79, 80, 81, 82, 83, 84, 85, 86, 87, 88, 89, 90, 91, 92, 93], "3": [265, 266, 267, 268, 269, 270, 271]}, "removed_lines": {}}, {"121": "guava/src/com/google/common/collect/ImmutableSortedAsList.java", "added": {"1": ["import java.util.Spliterator;\n"], "2": ["\n", "  @Override\n", "  public Spliterator<E> spliterator() {\n", "    return CollectSpliterators.indexed(\n", "        size(), \n", "        ImmutableList.SPLITERATOR_CHARACTERISTICS | Spliterator.SORTED | Spliterator.DISTINCT,\n", "        delegateList()::get,\n", "        comparator());\n", "  }\n"]}, "removed": {}, "added_lines": {"1": [20], "2": [86, 87, 88, 89, 90, 91, 92, 93, 94]}, "removed_lines": {}}, {"122": "guava/src/com/google/common/collect/ImmutableSortedMap.java", "added": {"1": ["import java.util.Map.Entry;\n", "import java.util.Spliterator;\n", "import java.util.function.BiConsumer;\n", "import java.util.function.BinaryOperator;\n", "import java.util.function.Consumer;\n", "import java.util.function.Function;\n", "import java.util.stream.Collector;\n", "import java.util.stream.Collectors;\n"], "2": ["  /**\n", "   * Returns a {@link Collector} that accumulates elements into an {@code ImmutableSortedMap}\n", "   * whose keys and values are the result of applying the provided mapping functions to the input\n", "   * elements.  The generated map is sorted by the specified comparator.\n", "   *\n", "   * <p>If the mapped keys contain duplicates (according to the specified comparator), an\n", "   * {@code IllegalArgumentException} is thrown when the collection operation is performed.\n", "   * (This differs from the {@code Collector} returned by\n", "   * {@link Collectors#toMap(Function, Function)}, which throws an {@code IllegalStateException}.)\n", "   *\n", "   * @since 21.0\n", "   */\n", "  @Beta\n", "  public static <T, K, V> Collector<T, ?, ImmutableSortedMap<K, V>> toImmutableSortedMap(\n", "      Comparator<? super K> comparator,\n", "      Function<? super T, ? extends K> keyFunction,\n", "      Function<? super T, ? extends V> valueFunction) {\n", "    return CollectCollectors.toImmutableSortedMap(comparator, keyFunction, valueFunction);\n", "  }\n", "  \n", "  /**\n", "   * Returns a {@link Collector} that accumulates elements into an {@code ImmutableSortedMap} whose\n", "   * keys and values are the result of applying the provided mapping functions to the input\n", "   * elements.\n", "   *\n", "   * <p>If the mapped keys contain duplicates (according to the comparator), the the values are\n", "   * merged using the specified merging function. Entries will appear in the encounter order of the\n", "   * first occurrence of the key.\n", "   *\n", "   * @since 21.0\n", "   */\n", "  @Beta\n", "  public static <T, K, V> Collector<T, ?, ImmutableSortedMap<K, V>> toImmutableSortedMap(\n", "      Comparator<? super K> comparator,\n", "      Function<? super T, ? extends K> keyFunction,\n", "      Function<? super T, ? extends V> valueFunction,\n", "      BinaryOperator<V> mergeFunction) {\n", "    checkNotNull(comparator);\n", "    checkNotNull(keyFunction);\n", "    checkNotNull(valueFunction);\n", "    checkNotNull(mergeFunction);\n", "    return Collectors.collectingAndThen(\n", "        Collectors.toMap(\n", "            keyFunction, valueFunction, mergeFunction, () -> new TreeMap<K, V>(comparator)),\n", "        ImmutableSortedMap::copyOfSorted);\n", "  }\n"], "3": ["    @Override\n", "    Builder<K, V> combine(ImmutableMap.Builder<K, V> other) {\n", "      super.combine(other);\n", "      return this;\n", "    }\n", "\n"], "4": ["  @Override\n", "  public void forEach(BiConsumer<? super K, ? super V> action) {\n", "    checkNotNull(action);\n", "    ImmutableList<K> keyList = keySet.asList();\n", "    for (int i = 0; i < size(); i++) {\n", "      action.accept(keyList.get(i), valueList.get(i));\n", "    }\n", "  }\n", "\n"], "5": ["      @Override\n", "      public Spliterator<Entry<K, V>> spliterator() {\n", "        return asList().spliterator();\n", "      }\n", "\n", "      @Override\n", "      public void forEach(Consumer<? super Entry<K, V>> action) {\n", "        asList().forEach(action);\n", "      }\n", "\n"], "6": ["          @Override\n", "          public Spliterator<Entry<K, V>> spliterator() {\n", "            return CollectSpliterators.indexed(\n", "                size(), ImmutableSet.SPLITERATOR_CHARACTERISTICS, this::get);\n", "          }\n", "\n"]}, "removed": {}, "added_lines": {"1": [31, 34, 36, 37, 38, 39, 40, 41], "2": [65, 66, 67, 68, 69, 70, 71, 72, 73, 74, 75, 76, 77, 78, 79, 80, 81, 82, 83, 84, 85, 86, 87, 88, 89, 90, 91, 92, 93, 94, 95, 96, 97, 98, 99, 100, 101, 102, 103, 104, 105, 106, 107, 108, 109, 110], "3": [543, 544, 545, 546, 547, 548], "4": [590, 591, 592, 593, 594, 595, 596, 597, 598], "5": [628, 629, 630, 631, 632, 633, 634, 635, 636, 637], "6": [646, 647, 648, 649, 650, 651]}, "removed_lines": {}}, {"123": "guava/src/com/google/common/collect/ImmutableSortedMapFauxverideShim.java", "added": {"1": ["import java.util.function.BinaryOperator;\n", "import java.util.function.Function;\n", "import java.util.stream.Collector;\n"], "2": ["  /**\n", "   * Not supported. Use {@link ImmutableSortedMap#toImmutableSortedMap}, which offers\n", "   * better type-safety, instead. This method exists only to hide\n", "   * {@link ImmutableMap#toImmutableMap} from consumers of {@code ImmutableSortedMap}.\n", "   *\n", "   * @throws UnsupportedOperationException always\n", "   * @deprecated Use {@link ImmutableSortedMap#toImmutableSortedMap}.\n", "   */\n", "  @Deprecated\n", "  public static <T, K, V> Collector<T, ?, ImmutableMap<K, V>> toImmutableMap(\n", "      Function<? super T, ? extends K> keyFunction,\n", "      Function<? super T, ? extends V> valueFunction) {\n", "    throw new UnsupportedOperationException();\n", "  }\n", "  \n", "  /**\n", "   * Not supported. Use {@link ImmutableSortedMap#toImmutableSortedMap}, which offers better\n", "   * type-safety, instead. This method exists only to hide {@link ImmutableMap#toImmutableMap} from\n", "   * consumers of {@code ImmutableSortedMap}.\n", "   *\n", "   * @throws UnsupportedOperationException always\n", "   * @deprecated Use {@link ImmutableSortedMap#toImmutableSortedMap}.\n", "   */\n", "  @Deprecated\n", "  public static <T, K, V> Collector<T, ?, ImmutableMap<K, V>> toImmutableMap(\n", "      Function<? super T, ? extends K> keyFunction,\n", "      Function<? super T, ? extends V> valueFunction,\n", "      BinaryOperator<V> mergeFunction) {\n", "    throw new UnsupportedOperationException();\n", "  }\n", "\n"]}, "removed": {}, "added_lines": {"1": [20, 21, 22], "2": [33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 58, 59, 60, 61, 62, 63]}, "removed_lines": {}}, {"124": "guava/src/com/google/common/collect/ImmutableSortedMultiset.java", "added": {"1": ["import java.util.function.Function;\n", "import java.util.function.ToIntFunction;\n", "import java.util.stream.Collector;\n"], "2": ["  /**\n", "   * Returns a {@code Collector} that accumulates the input elements into a new\n", "   * {@code ImmutableMultiset}.  Elements are sorted by the specified comparator.\n", "   *\n", "   * <p><b>Warning:</b> {@code comparator} should be <i>consistent with {@code\n", "   * equals}</i> as explained in the {@link Comparator} documentation.\n", "   *\n", "   * @since 21.0\n", "   */\n", "  @Beta\n", "  public static <E> Collector<E, ?, ImmutableSortedMultiset<E>> toImmutableSortedMultiset(\n", "      Comparator<? super E> comparator) {\n", "    return toImmutableSortedMultiset(comparator, Function.identity(), e -> 1);\n", "  }\n", "\n", "  /**\n", "   * Returns a {@code Collector} that accumulates elements into an {@code ImmutableSortedMultiset}\n", "   * whose elements are the result of applying {@code elementFunction} to the inputs,\n", "   * with counts equal to the result of applying {@code countFunction} to the inputs.\n", "   *\n", "   * <p>If the mapped elements contain duplicates (according to {@code comparator}),\n", "   * the first occurrence in encounter order appears in the resulting multiset, with count\n", "   * equal to the sum of the outputs of {@code countFunction.applyAsInt(t)} for each {@code t}\n", "   * mapped to that element.\n", "   */\n", "  private static <T, E> Collector<T, ?, ImmutableSortedMultiset<E>> toImmutableSortedMultiset(\n", "      Comparator<? super E> comparator,\n", "      Function<? super T, ? extends E> elementFunction,\n", "      ToIntFunction<? super T> countFunction) {\n", "    // TODO(lowasser): consider exposing this\n", "    checkNotNull(comparator);\n", "    checkNotNull(elementFunction);\n", "    checkNotNull(countFunction);\n", "    return Collector.of(\n", "        () -> TreeMultiset.create(comparator),\n", "        (multiset, t) -> multiset.add(elementFunction.apply(t), countFunction.applyAsInt(t)),\n", "        (multiset1, multiset2) -> {\n", "          multiset1.addAll(multiset2);\n", "          return multiset1;\n", "        },\n", "        (Multiset<E> multiset) -> copyOfSortedEntries(comparator, multiset.entrySet()));\n", "  }\n", "\n"]}, "removed": {}, "added_lines": {"1": [31, 32, 33], "2": [57, 58, 59, 60, 61, 62, 63, 64, 65, 66, 67, 68, 69, 70, 71, 72, 73, 74, 75, 76, 77, 78, 79, 80, 81, 82, 83, 84, 85, 86, 87, 88, 89, 90, 91, 92, 93, 94, 95, 96, 97, 98, 99]}, "removed_lines": {}}, {"125": "guava/src/com/google/common/collect/ImmutableSortedMultisetFauxverideShim.java", "added": {"1": ["import java.util.stream.Collector;\n"], "2": ["  /**\n", "   * Not supported. Use {@link ImmutableSortedMultiset#toImmutableSortedMultiset} instead.\n", "   * This method exists only to hide {@link ImmutableMultiset#toImmutableMultiset} from\n", "   * consumers of {@code ImmutableSortedMultiset}.\n", "   *\n", "   * @throws UnsupportedOperationException always\n", "   * @deprecated Use {@link ImmutableSortedMultiset#toImmutableSortedMultiset}.\n", "   * @since 21.0\n", "   */\n", "  @Deprecated\n", "  public static <E> Collector<E, ?, ImmutableMultiset<E>> toImmutableMultiset() {\n", "    throw new UnsupportedOperationException();\n", "  }\n", "\n"]}, "removed": {}, "added_lines": {"1": [18], "2": [39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51, 52]}, "removed_lines": {}}, {"126": "guava/src/com/google/common/collect/ImmutableSortedSet.java", "added": {"1": ["import com.google.common.annotations.Beta;\n"], "2": ["import java.util.Spliterator;\n", "import java.util.Spliterators;\n", "import java.util.function.Consumer;\n", "import java.util.stream.Collector;\n"], "3": ["  static final int SPLITERATOR_CHARACTERISTICS =\n", "      ImmutableSet.SPLITERATOR_CHARACTERISTICS | Spliterator.SORTED;\n", "\n", "  /**\n", "   * Returns a {@code Collector} that accumulates the input elements into a new\n", "   * {@code ImmutableSortedSet}, ordered by the specified comparator.\n", "   *\n", "   * <p>If the elements contain duplicates (according to the comparator),\n", "   * only the first duplicate in encounter order will appear in the result.\n", "   *\n", "   * @since 21.0\n", "   */\n", "  @Beta\n", "  public static <E> Collector<E, ?, ImmutableSortedSet<E>> toImmutableSortedSet(\n", "      Comparator<? super E> comparator) {\n", "    return CollectCollectors.toImmutableSortedSet(comparator);\n", "  }\n", "\n"], "4": ["    @CanIgnoreReturnValue\n", "    @Override\n", "    Builder<E> combine(ArrayBasedBuilder<E> builder) {\n", "      super.combine(builder);\n", "      return this;\n", "    }\n", "\n"], "5": ["  @Override\n", "  public Spliterator<E> spliterator() {\n", "    return new Spliterators.AbstractSpliterator<E>(\n", "        size(), SPLITERATOR_CHARACTERISTICS | Spliterator.SIZED) {\n", "      final UnmodifiableIterator<E> iterator = iterator();\n", "\n", "      @Override\n", "      public boolean tryAdvance(Consumer<? super E> action) {\n", "        if (iterator.hasNext()) {\n", "          action.accept(iterator.next());\n", "          return true;\n", "        } else {\n", "          return false;\n", "        }\n", "      }\n", "\n", "      @Override\n", "      public Comparator<? super E> getComparator() {\n", "        return comparator;\n", "      }\n", "    };\n", "  }\n", "\n"]}, "removed": {}, "added_lines": {"1": [23], "2": [37, 38, 39, 40], "3": [66, 67, 68, 69, 70, 71, 72, 73, 74, 75, 76, 77, 78, 79, 80, 81, 82, 83], "4": [527, 528, 529, 530, 531, 532, 533], "5": [774, 775, 776, 777, 778, 779, 780, 781, 782, 783, 784, 785, 786, 787, 788, 789, 790, 791, 792, 793, 794, 795, 796]}, "removed_lines": {}}, {"127": "guava/src/com/google/common/collect/ImmutableSortedSetFauxverideShim.java", "added": {"1": ["import java.util.stream.Collector;\n"], "2": ["  /**\n", "   * Not supported. Use {@link ImmutableSortedSet#toImmutableSortedSet} instead.\n", "   * This method exists only to hide {@link ImmutableSet#toImmutableSet} from\n", "   * consumers of {@code ImmutableSortedSet}.\n", "   *\n", "   * @throws UnsupportedOperationException always\n", "   * @deprecated Use {@link ImmutableSortedSet#toImmutableSortedSet}.\n", "   * @since 21.0\n", "   */\n", "  @Deprecated\n", "  public static <E> Collector<E, ?, ImmutableSet<E>> toImmutableSet() {\n", "    throw new UnsupportedOperationException();\n", "  }\n", "\n"]}, "removed": {}, "added_lines": {"1": [20], "2": [40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51, 52, 53]}, "removed_lines": {}}, {"128": "guava/src/com/google/common/collect/ImmutableTable.java", "added": {"1": ["import com.google.common.collect.Table.Cell;\n", "import java.util.Spliterator;\n", "import java.util.function.Function;\n", "import java.util.stream.Collector;\n"], "2": ["\n", "  /**\n", "   * Returns a {@code Collector} that accumulates elements into an {@code ImmutableTable}. Each\n", "   * input element is mapped to one cell in the returned table, with the rows, columns, and values\n", "   * generated by applying the specified functions.\n", "   *\n", "   * @since 21.0\n", "   */\n", "  public static <T, R, C, V> Collector<T, ?, ImmutableTable<R, C, V>> toImmutableTable(\n", "      Function<? super T, ? extends R> rowFunction,\n", "      Function<? super T, ? extends C> columnFunction,\n", "      Function<? super T, ? extends V> valueFunction) {\n", "    checkNotNull(rowFunction);\n", "    checkNotNull(columnFunction);\n", "    checkNotNull(valueFunction);\n", "    return Collector.of(\n", "        Builder<R, C, V>::new,\n", "        (builder, t) ->\n", "            builder.put(rowFunction.apply(t), columnFunction.apply(t), valueFunction.apply(t)),\n", "        Builder::combine,\n", "        Builder::build);\n", "  }\n", "\n"], "3": ["    Builder<R, C, V> combine(Builder<R, C, V> other) {\n", "      this.cells.addAll(other.cells);\n", "      return this;\n", "    }\n", "\n"], "4": ["  @Override\n", "  final Spliterator<Cell<R, C, V>> cellSpliterator() {\n", "    throw new AssertionError(\"should never be called\");\n", "  }\n", "\n"]}, "removed": {}, "added_lines": {"1": [23, 30, 31, 32], "2": [49, 50, 51, 52, 53, 54, 55, 56, 57, 58, 59, 60, 61, 62, 63, 64, 65, 66, 67, 68, 69, 70, 71], "3": [246, 247, 248, 249, 250], "4": [284, 285, 286, 287, 288]}, "removed_lines": {}}, {"129": "guava/src/com/google/common/collect/Iterables.java", "added": {"1": ["import java.util.Spliterator;\n", "import java.util.function.Consumer;\n", "import java.util.stream.Stream;\n"], "2": ["    @Override\n", "    public void forEach(Consumer<? super T> action) {\n", "      iterable.forEach(action);\n", "    }\n", "\n", "    @SuppressWarnings(\"unchecked\") // safe upcast, assuming no one has a crazy Spliterator subclass\n", "    @Override\n", "    public Spliterator<T> spliterator() {\n", "      return (Spliterator<T>) iterable.spliterator();\n", "    }\n", "\n"], "3": ["   * <p><b>Java 8 users:</b> if {@code removeFrom} is a {@link Collection},\n", "   * use {@code removeFrom.removeIf(predicate)} instead.\n", "   *\n"], "4": ["    if (removeFrom instanceof Collection) {\n", "      return ((Collection<T>) removeFrom).removeIf(predicate);\n"], "5": ["      @Override\n", "      public Spliterator<T> spliterator() {\n", "        return Stream.generate(() -> iterable).flatMap(Streams::stream).spliterator();\n", "      }\n", "\n"], "6": ["\n", "      @Override\n", "      public void forEach(Consumer<? super T> action) {\n", "        checkNotNull(action);\n", "        unfiltered.forEach(\n", "            (T a) -> {\n", "              if (retainIfTrue.test(a)) {\n", "                action.accept(a);\n", "              }\n", "            });\n", "      }\n", "\n", "      @Override\n", "      public Spliterator<T> spliterator() {\n", "        return CollectSpliterators.filter(unfiltered.spliterator(), retainIfTrue);\n", "      }\n"], "7": ["\n", "      @SuppressWarnings(\"unchecked\")\n", "      @Override\n", "      public void forEach(Consumer<? super T> action) {\n", "        checkNotNull(action);\n", "        unfiltered.forEach(\n", "            (Object o) -> {\n", "              if (desiredType.isInstance(o)) {\n", "                action.accept(desiredType.cast(o));\n", "              }\n", "            });\n", "      }\n", "\n", "      @SuppressWarnings(\"unchecked\")\n", "      @Override\n", "      public Spliterator<T> spliterator() {\n", "        return (Spliterator<T>)\n", "            CollectSpliterators.filter(unfiltered.spliterator(), desiredType::isInstance);\n", "      }\n"], "8": ["\n", "      @Override\n", "      public void forEach(Consumer<? super T> action) {\n", "        checkNotNull(action);\n", "        fromIterable.forEach((F f) -> action.accept(function.apply(f)));\n", "      }\n", "\n", "      @Override\n", "      public Spliterator<T> spliterator() {\n", "        return CollectSpliterators.map(fromIterable.spliterator(), function);\n", "      }\n"], "9": ["\n", "      @Override\n", "      public Spliterator<T> spliterator() {\n", "        return Streams.stream(iterable).skip(numberToSkip).spliterator();\n", "      }\n"], "10": ["\n", "      @Override\n", "      public Spliterator<T> spliterator() {\n", "        return Streams.stream(iterable).limit(limitSize).spliterator();\n", "      }\n"]}, "removed": {"4": ["    if (removeFrom instanceof RandomAccess && removeFrom instanceof List) {\n", "      return removeIfFromRandomAccessList((List<T>) removeFrom, checkNotNull(predicate));\n", "  private static <T> boolean removeIfFromRandomAccessList(\n", "      List<T> list, Predicate<? super T> predicate) {\n", "    // Note: Not all random access lists support set(). Additionally, it's possible\n", "    // for a list to reject setting an element, such as when the list does not permit\n", "    // duplicate elements. For both of those cases,  we need to fall back to a slower\n", "    // implementation.\n", "    int from = 0;\n", "    int to = 0;\n", "\n", "    for (; from < list.size(); from++) {\n", "      T element = list.get(from);\n", "      if (!predicate.apply(element)) {\n", "        if (from > to) {\n", "          try {\n", "            list.set(to, element);\n", "          } catch (UnsupportedOperationException e) {\n", "            slowRemoveIfForRemainingElements(list, predicate, to, from);\n", "            return true;\n", "          } catch (IllegalArgumentException e) {\n", "            slowRemoveIfForRemainingElements(list, predicate, to, from);\n", "            return true;\n", "          }\n", "        }\n", "        to++;\n", "      }\n", "    }\n", "\n", "    // Clear the tail of any remaining items\n", "    list.subList(to, list.size()).clear();\n", "    return from != to;\n", "  }\n", "\n", "  private static <T> void slowRemoveIfForRemainingElements(\n", "      List<T> list, Predicate<? super T> predicate, int to, int from) {\n", "    // Here we know that:\n", "    // * (to < from) and that both are valid indices.\n", "    // * Everything with (index < to) should be kept.\n", "    // * Everything with (to <= index < from) should be removed.\n", "    // * The element with (index == from) should be kept.\n", "    // * Everything with (index > from) has not been checked yet.\n", "\n", "    // Check from the end of the list backwards (minimize expected cost of\n", "    // moving elements when remove() is called). Stop before 'from' because\n", "    // we already know that should be kept.\n", "    for (int n = list.size() - 1; n > from; n--) {\n", "      if (predicate.apply(list.get(n))) {\n", "        list.remove(n);\n", "      }\n", "    }\n", "    // And now remove everything in the range [to, from) (going backwards).\n", "    for (int n = from - 1; n >= to; n--) {\n", "      list.remove(n);\n", "    }\n", "  }\n", "\n"]}, "added_lines": {"1": [38, 39, 40], "2": [103, 104, 105, 106, 107, 108, 109, 110, 111, 112, 113], "3": [186, 187, 188], "4": [200, 201], "5": [380, 381, 382, 383, 384], "6": [574, 575, 576, 577, 578, 579, 580, 581, 582, 583, 584, 585, 586, 587, 588, 589], "7": [616, 617, 618, 619, 620, 621, 622, 623, 624, 625, 626, 627, 628, 629, 630, 631, 632, 633, 634], "8": [734, 735, 736, 737, 738, 739, 740, 741, 742, 743, 744], "9": [927, 928, 929, 930, 931], "10": [955, 956, 957, 958, 959]}, "removed_lines": {"4": [183, 184, 189, 190, 191, 192, 193, 194, 195, 196, 197, 198, 199, 200, 201, 202, 203, 204, 205, 206, 207, 208, 209, 210, 211, 212, 213, 214, 215, 216, 217, 218, 219, 220, 221, 222, 223, 224, 225, 226, 227, 228, 229, 230, 231, 232, 233, 234, 235, 236, 237, 238, 239, 240, 241, 242, 243]}}, {"130": "guava/src/com/google/common/collect/LinkedHashMultimap.java", "added": {"1": ["import static com.google.common.base.Preconditions.checkNotNull;\n"], "2": ["import java.util.Map.Entry;\n", "import java.util.Spliterator;\n", "import java.util.Spliterators;\n", "import java.util.function.Consumer;\n"], "3": ["    @Override\n", "    public void forEach(Consumer<? super V> action) {\n", "      checkNotNull(action);\n", "      for (ValueSetLink<K, V> entry = firstEntry;\n", "          entry != ValueSet.this;\n", "          entry = entry.getSuccessorInValueSet()) {\n", "        action.accept(((ValueEntry<K, V>) entry).getValue());\n", "      }\n", "    }\n", "\n"], "4": ["  @Override\n", "  Spliterator<Entry<K, V>> entrySpliterator() {\n", "    return Spliterators.spliterator(entries(), Spliterator.DISTINCT | Spliterator.ORDERED);\n", "  }\n", "\n", "  @Override\n", "  Spliterator<V> valueSpliterator() {\n", "    return CollectSpliterators.map(entrySpliterator(), Entry::getValue);\n", "  }\n", "\n"]}, "removed": {}, "added_lines": {"1": [19], "2": [39, 42, 43, 44], "3": [423, 424, 425, 426, 427, 428, 429, 430, 431, 432], "4": [563, 564, 565, 566, 567, 573, 574, 575, 576, 577]}, "removed_lines": {}}, {"131": "guava/src/com/google/common/collect/LinkedListMultimap.java", "added": {"1": ["import static com.google.common.base.Preconditions.checkNotNull;\n"], "2": ["import java.util.function.Consumer;\n"], "3": ["\n", "      @Override\n", "      public void forEach(Consumer<? super Entry<K, V>> action) {\n", "        checkNotNull(action);\n", "        for (Node<K, V> node = head; node != null; node = node.next) {\n", "          action.accept(node);\n", "        }\n", "      }\n"]}, "removed": {}, "added_lines": {"1": [19], "2": [44], "3": [813, 814, 815, 816, 817, 818, 819, 820]}, "removed_lines": {}}, {"132": "guava/src/com/google/common/collect/Lists.java", "added": {"1": ["import java.util.function.Predicate;\n"], "2": ["    @Override\n", "    public boolean removeIf(Predicate<? super T> filter) {\n", "      checkNotNull(filter);\n", "      return fromList.removeIf(element -> filter.test(function.apply(element)));\n", "    }\n", "\n"], "3": ["    @Override\n", "    public boolean removeIf(Predicate<? super T> filter) {\n", "      checkNotNull(filter);\n", "      return fromList.removeIf(element -> filter.test(function.apply(element)));\n", "    }\n", "\n"]}, "removed": {}, "added_lines": {"1": [52], "2": [600, 601, 602, 603, 604, 605], "3": [657, 658, 659, 660, 661, 662]}, "removed_lines": {}}, {"133": "guava/src/com/google/common/collect/Maps.java", "added": {"1": ["import com.google.common.collect.Maps.IteratorBasedAbstractMap;\n", "import com.google.common.collect.Maps.ViewCachingAbstractMap;\n", "import com.google.common.collect.Sets.ImprovedAbstractSet;\n"], "2": ["import java.util.Spliterator;\n", "import java.util.Spliterators;\n", "import java.util.function.BiConsumer;\n", "import java.util.function.BiFunction;\n", "import java.util.function.Consumer;\n"], "3": ["      return getOrDefault(key, null);\n", "    }\n", "\n", "    @Override\n", "    public V getOrDefault(@Nullable Object key, @Nullable V defaultValue) {\n", "        return defaultValue;\n"], "4": ["\n", "    @Override\n", "    public void forEach(BiConsumer<? super K, ? super V> action) {\n", "      checkNotNull(action);\n", "      // avoids allocation of entries\n", "      backingSet().forEach(k -> action.accept(k, function.apply(k)));\n", "    }\n"], "5": ["      return getOrDefault(key, null);\n", "    }\n", "\n", "    @Override\n", "    @Nullable\n", "    public V getOrDefault(@Nullable Object key, @Nullable V defaultValue) {\n", "        return defaultValue;\n"], "6": ["    @Override\n", "    Spliterator<Entry<K, V>> entrySpliterator() {\n", "      return CollectSpliterators.map(set.spliterator(), e -> immutableEntry(e, function.apply(e)));\n", "    }\n", "\n", "    @Override\n", "    public void forEach(BiConsumer<? super K, ? super V> action) {\n", "      set.forEach(k -> action.accept(k, function.apply(k)));\n", "    }\n", "\n"], "7": ["      final NavigableMap<K, V1> fromMap, EntryTransformer<? super K, ? super V1, V2> transformer) {\n"], "8": ["  @FunctionalInterface\n"], "9": ["    @Override\n", "    @Nullable\n", "    public V2 get(@Nullable Object key) {\n", "      return getOrDefault(key, null);\n", "    }\n", "\n", "    @Nullable\n", "    public V2 getOrDefault(@Nullable Object key, @Nullable V2 defaultValue) {\n", "          : defaultValue;\n"], "10": ["    @Override\n", "    Spliterator<Entry<K, V2>> entrySpliterator() {\n", "      return CollectSpliterators.map(\n", "          fromMap.entrySet().spliterator(), Maps.<K, V1, V2>asEntryToEntryFunction(transformer));\n", "    }\n", "\n", "    @Override\n", "    public void forEach(BiConsumer<? super K, ? super V2> action) {\n", "      checkNotNull(action);\n", "      // avoids creating new Entry<K, V2> objects\n", "      fromMap.forEach((k, v1) -> action.accept(k, transformer.transformEntry(k, v1)));\n", "    }\n", "\n"], "11": ["    @Override\n", "    public void replaceAll(BiFunction<? super K, ? super V, ? extends V> function) {\n", "      unfiltered()\n", "          .replaceAll(\n", "              (key, value) ->\n", "                  predicate.apply(Maps.immutableEntry(key, value))\n", "                      ? function.apply(key, value)\n", "                      : value);\n", "    }\n", "\n"], "12": ["    Spliterator<Entry<K, V>> entrySpliterator() {\n", "      return Spliterators.spliterator(\n", "          entryIterator(), size(), Spliterator.SIZED | Spliterator.DISTINCT);\n", "    }\n", "\n"], "13": ["\n", "        @Override\n", "        public Spliterator<Entry<K, V>> spliterator() {\n", "          return entrySpliterator();\n", "        }\n", "\n", "        @Override\n", "        public void forEach(Consumer<? super Entry<K, V>> action) {\n", "          forEachEntry(action);\n", "        }\n", "    void forEachEntry(Consumer<? super Entry<K, V>> action) {\n", "      entryIterator().forEachRemaining(action);\n", "    }\n", "\n"], "14": ["    @Override\n", "    public void forEach(Consumer<? super K> action) {\n", "      checkNotNull(action);\n", "      // avoids entry allocation for those maps that allocate entries on iteration\n", "      map.forEach((k, v) -> action.accept(k));\n", "    }\n", "\n"], "15": ["    @Override\n", "    public void forEach(Consumer<? super V> action) {\n", "      checkNotNull(action);\n", "      // avoids allocation of entries for those maps that generate fresh entries on iteration\n", "      map.forEach((k, v) -> action.accept(v));\n", "    }\n", "\n"]}, "removed": {"3": ["        return null;\n"], "5": ["        return null;\n"], "7": ["      NavigableMap<K, V1> fromMap, EntryTransformer<? super K, ? super V1, V2> transformer) {\n"], "9": ["    public V2 get(Object key) {\n", "          : null;\n"]}, "added_lines": {"1": [39, 40, 41], "2": [67, 68, 71, 72, 73], "3": [843, 844, 845, 846, 847, 853], "4": [889, 890, 891, 892, 893, 894, 895], "5": [994, 995, 996, 997, 998, 999, 1005], "6": [1019, 1020, 1021, 1022, 1023, 1024, 1025, 1026, 1027, 1028], "7": [1886], "8": [1900], "9": [2015, 2016, 2017, 2018, 2019, 2020, 2024, 2025, 2029], "10": [2057, 2058, 2059, 2060, 2061, 2062, 2063, 2064, 2065, 2066, 2067, 2068, 2069], "11": [3231, 3232, 3233, 3234, 3235, 3236, 3237, 3238, 3239, 3240], "12": [3532, 3533, 3534, 3535, 3536], "13": [3549, 3550, 3551, 3552, 3553, 3554, 3555, 3556, 3557, 3558, 3562, 3563, 3564, 3565], "14": [3720, 3721, 3722, 3723, 3724, 3725, 3726], "15": [3907, 3908, 3909, 3910, 3911, 3912, 3913]}, "removed_lines": {"3": [840], "5": [979], "7": [1850], "9": [1981, 1985]}}, {"134": "guava/src/com/google/common/collect/MoreCollectors.java", "added": {"1": ["/*\n", " * Copyright (C) 2016 The Guava Authors\n", " *\n", " * Licensed under the Apache License, Version 2.0 (the \"License\");\n", " * you may not use this file except in compliance with the License.\n", " * You may obtain a copy of the License at\n", " *\n", " * http://www.apache.org/licenses/LICENSE-2.0\n", " *\n", " * Unless required by applicable law or agreed to in writing, software\n", " * distributed under the License is distributed on an \"AS IS\" BASIS,\n", " * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n", " * See the License for the specific language governing permissions and\n", " * limitations under the License.\n", " */\n", "\n", "package com.google.common.collect;\n", "\n", "import static com.google.common.base.Preconditions.checkNotNull;\n", "\n", "import com.google.common.annotations.Beta;\n", "import com.google.common.annotations.GwtCompatible;\n", "import java.util.ArrayList;\n", "import java.util.List;\n", "import java.util.NoSuchElementException;\n", "import java.util.Optional;\n", "import java.util.stream.Collector;\n", "import javax.annotation.Nullable;\n", "\n", "/**\n", " * Collectors not present in {@code java.util.stream.Collectors} that are not otherwise associated\n", " * with a {@code com.google.common} type.\n", " *\n", " * @author Louis Wasserman\n", " * @since 21.0\n", " */\n", "@Beta\n", "@GwtCompatible\n", "public final class MoreCollectors {\n", "\n", "  /*\n", "   * TODO(lowasser): figure out if we can convert this to a concurrent AtomicReference-based\n", "   * collector without breaking j2cl?\n", "   */\n", "  private static final Collector<Object, ?, Optional<Object>> TO_OPTIONAL =\n", "      Collector.of(\n", "          ToOptionalState::new,\n", "          ToOptionalState::add,\n", "          ToOptionalState::combine,\n", "          ToOptionalState::getOptional,\n", "          Collector.Characteristics.UNORDERED);\n", "\n", "  /**\n", "   * A collector that converts a stream of zero or one elements to an {@code Optional}. The returned\n", "   * collector throws an {@code IllegalArgumentException} if the stream consists of two or more\n", "   * elements, and a {@code NullPointerException} if the stream consists of exactly one element,\n", "   * which is null.\n", "   */\n", "  @SuppressWarnings(\"unchecked\")\n", "  public static <T> Collector<T, ?, Optional<T>> toOptional() {\n", "    return (Collector) TO_OPTIONAL;\n", "  }\n", "  \n", "  private static final Object NULL_PLACEHOLDER = new Object();\n", "\n", "  private static final Collector<Object, ?, Object> ONLY_ELEMENT =\n", "      Collector.of(\n", "          ToOptionalState::new,\n", "          (state, o) -> state.add((o == null) ? NULL_PLACEHOLDER : o),\n", "          ToOptionalState::combine,\n", "          state -> {\n", "            Object result = state.getElement();\n", "            return (result == NULL_PLACEHOLDER) ? null : result;\n", "          },\n", "          Collector.Characteristics.UNORDERED);\n", "\n", "  /**\n", "   * A collector that takes a stream containing exactly one element and returns that element. The\n", "   * returned collector throws an {@code IllegalArgumentException} if the stream consists of two or\n", "   * more elements, and a {@code NoSuchElementException} if the stream is empty.\n", "   */\n", "  @SuppressWarnings(\"unchecked\")\n", "  public static <T> Collector<T, ?, T> onlyElement() {\n", "    return (Collector) ONLY_ELEMENT;\n", "  }\n", "\n", "  /**\n", "   * This atrocity is here to let us report several of the elements in the stream if there were more\n", "   * than one, not just two.\n", "   */\n", "  private static final class ToOptionalState {\n", "    static final int MAX_EXTRAS = 4;\n", "\n", "    @Nullable Object element;\n", "    @Nullable List<Object> extras;\n", "\n", "    ToOptionalState() {\n", "      element = null;\n", "      extras = null;\n", "    }\n", "\n", "    IllegalArgumentException multiples(boolean overflow) {\n", "      StringBuilder sb =\n", "          new StringBuilder().append(\"expected one element but was: <\").append(element);\n", "      for (Object o : extras) {\n", "        sb.append(\", \").append(o);\n", "      }\n", "      if (overflow) {\n", "        sb.append(\", ...\");\n", "      }\n", "      sb.append('>');\n", "      throw new IllegalArgumentException(sb.toString());\n", "    }\n", "\n", "    void add(Object o) {\n", "      checkNotNull(o);\n", "      if (element == null) {\n", "        this.element = o;\n", "      } else if (extras == null) {\n", "        extras = new ArrayList<>(MAX_EXTRAS);\n", "        extras.add(o);\n", "      } else if (extras.size() < MAX_EXTRAS) {\n", "        extras.add(o);\n", "      } else {\n", "        throw multiples(true);\n", "      }\n", "    }\n", "\n", "    ToOptionalState combine(ToOptionalState other) {\n", "      if (element == null) {\n", "        return other;\n", "      } else if (other.element == null) {\n", "        return this;\n", "      } else {\n", "        if (extras == null) {\n", "          extras = new ArrayList<>();\n", "        }\n", "        extras.add(other.element);\n", "        if (other.extras != null) {\n", "          this.extras.addAll(other.extras);\n", "        }\n", "        if (extras.size() > MAX_EXTRAS) {\n", "          extras.subList(MAX_EXTRAS, extras.size()).clear();\n", "          throw multiples(true);\n", "        }\n", "        return this;\n", "      }\n", "    }\n", "\n", "    Optional<Object> getOptional() {\n", "      if (extras == null) {\n", "        return Optional.ofNullable(element);\n", "      } else {\n", "        throw multiples(false);\n", "      }\n", "    }\n", "\n", "    Object getElement() {\n", "      if (element == null) {\n", "        throw new NoSuchElementException();\n", "      } else if (extras == null) {\n", "        return element;\n", "      } else {\n", "        throw multiples(false);\n", "      }\n", "    }\n", "  }\n", "\n", "  private MoreCollectors() {}\n", "}\n"]}, "removed": {}, "added_lines": {"1": [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 58, 59, 60, 61, 62, 63, 64, 65, 66, 67, 68, 69, 70, 71, 72, 73, 74, 75, 76, 77, 78, 79, 80, 81, 82, 83, 84, 85, 86, 87, 88, 89, 90, 91, 92, 93, 94, 95, 96, 97, 98, 99, 100, 101, 102, 103, 104, 105, 106, 107, 108, 109, 110, 111, 112, 113, 114, 115, 116, 117, 118, 119, 120, 121, 122, 123, 124, 125, 126, 127, 128, 129, 130, 131, 132, 133, 134, 135, 136, 137, 138, 139, 140, 141, 142, 143, 144, 145, 146, 147, 148, 149, 150, 151, 152, 153, 154, 155, 156, 157, 158, 159, 160, 161, 162, 163, 164, 165, 166, 167, 168, 169, 170]}, "removed_lines": {}}, {"135": "guava/src/com/google/common/collect/Multimap.java", "added": {"1": ["import static com.google.common.base.Preconditions.checkNotNull;\n", "\n", "import java.util.function.BiConsumer;\n"], "2": ["  /**\n", "   * Performs the given action for all key-value pairs contained in this multimap. If an ordering is\n", "   * specified by the {@code Multimap} implementation, actions will be performed in the order of\n", "   * iteration of {@link #entries()}. Exceptions thrown by the action are relayed to the caller.\n", "   *\n", "   * <p>To loop over all keys and their associated value collections, write\n", "   * {@code Multimaps.asMap(multimap).forEach((key, valueCollection) -> action())}.\n", "   *\n", "   * @since 21.0\n", "   */\n", "  default void forEach(BiConsumer<? super K, ? super V> action) {\n", "    checkNotNull(action);\n", "    entries().forEach(entry -> action.accept(entry.getKey(), entry.getValue()));\n", "  }\n", "\n"]}, "removed": {}, "added_lines": {"1": [19, 20, 27], "2": [348, 349, 350, 351, 352, 353, 354, 355, 356, 357, 358, 359, 360, 361, 362]}, "removed_lines": {}}, {"136": "guava/src/com/google/common/collect/Multimaps.java", "added": {"1": ["import java.util.Spliterator;\n", "import java.util.function.Consumer;\n"], "2": ["    @Override\n", "    public Spliterator<K> spliterator() {\n", "      return CollectSpliterators.map(multimap.entries().spliterator(), Map.Entry::getKey);\n", "    }\n", "\n", "    @Override\n", "    public void forEach(Consumer<? super K> consumer) {\n", "      checkNotNull(consumer);\n", "      multimap.entries().forEach(entry -> consumer.accept(entry.getKey()));\n", "    }\n", "\n"]}, "removed": {}, "added_lines": {"1": [50, 51], "2": [1584, 1585, 1586, 1587, 1588, 1589, 1590, 1591, 1592, 1593, 1594]}, "removed_lines": {}}, {"137": "guava/src/com/google/common/collect/Multiset.java", "added": {"1": ["import static com.google.common.base.Preconditions.checkNotNull;\n", "\n", "import com.google.common.annotations.Beta;\n"], "2": ["import java.util.Spliterator;\n", "import java.util.function.Consumer;\n", "import java.util.function.ObjIntConsumer;\n"], "3": ["  /**\n", "   * Runs the specified action for each distinct element in this multiset, and the number of\n", "   * occurrences of that element. For some {@code Multiset} implementations, this may be more\n", "   * efficient than iterating over the {@link #entrySet()} either explicitly or with {@code\n", "   * entrySet().forEach(action)}.\n", "   *\n", "   * @since 21.0\n", "   */\n", "  @Beta\n", "  default void forEachEntry(ObjIntConsumer<? super E> action) {\n", "    checkNotNull(action);\n", "    entrySet().forEach(entry -> action.accept(entry.getElement(), entry.getCount()));\n", "  }\n", "\n", "   * Compares the specified object with this multiset for equality. Returns {@code true} if the\n", "   * given object is also a multiset and contains equal elements with equal counts, regardless of\n", "   * order.\n"], "4": ["\n", "  /**\n", "   * {@inheritDoc}\n", "   *\n", "   * <p>Elements that occur multiple times in the multiset will be passed to the {@code Consumer}\n", "   * correspondingly many times, though not necessarily sequentially.\n", "   */\n", "  @Override\n", "  default void forEach(Consumer<? super E> action) {\n", "    checkNotNull(action);\n", "    entrySet()\n", "        .forEach(\n", "            entry -> {\n", "              E elem = entry.getElement();\n", "              int count = entry.getCount();\n", "              for (int i = 0; i < count; i++) {\n", "                action.accept(elem);\n", "              }\n", "            });\n", "  }\n", "\n", "  @Override\n", "  default Spliterator<E> spliterator() {\n", "    return Multisets.spliteratorImpl(this);\n", "  }\n"]}, "removed": {"3": ["   * Compares the specified object with this multiset for equality. Returns\n", "   * {@code true} if the given object is also a multiset and contains equal\n", "   * elements with equal counts, regardless of order.\n"]}, "added_lines": {"1": [19, 20, 21], "2": [29, 30, 31], "3": [302, 303, 304, 305, 306, 307, 308, 309, 310, 311, 312, 313, 314, 315, 319, 320, 321], "4": [473, 474, 475, 476, 477, 478, 479, 480, 481, 482, 483, 484, 485, 486, 487, 488, 489, 490, 491, 492, 493, 494, 495, 496, 497]}, "removed_lines": {"3": [299, 300, 301]}}, {"138": "guava/src/com/google/common/collect/Multisets.java", "added": {"1": ["import java.util.Spliterator;\n"], "2": ["  static <E> Spliterator<E> spliteratorImpl(Multiset<E> multiset) {\n", "    Spliterator<Entry<E>> entrySpliterator = multiset.entrySet().spliterator();\n", "    return CollectSpliterators.flatMap(\n", "        entrySpliterator,\n", "        entry -> Collections.nCopies(entry.getCount(), entry.getElement()).spliterator(),\n", "        Spliterator.SIZED\n", "            | (entrySpliterator.characteristics()\n", "                & (Spliterator.ORDERED | Spliterator.NONNULL | Spliterator.IMMUTABLE)),\n", "        multiset.size());\n", "  }\n", "\n"]}, "removed": {}, "added_lines": {"1": [40], "2": [1090, 1091, 1092, 1093, 1094, 1095, 1096, 1097, 1098, 1099, 1100]}, "removed_lines": {}}, {"139": "guava/src/com/google/common/collect/MutableClassToInstanceMap.java", "added": {"1": ["import java.util.Spliterator;\n"], "2": ["  /**\n", "   * Wraps the {@code setValue} implementation of an {@code Entry} to enforce the class constraint.\n", "   */\n", "  private static <B> Entry<Class<? extends B>, B> checkedEntry(\n", "      final Entry<Class<? extends B>, B> entry) {\n"], "3": ["      @Override\n", "      public Spliterator<Entry<Class<? extends B>, B>> spliterator() {\n", "        return CollectSpliterators.map(\n", "            delegate().spliterator(), MutableClassToInstanceMap::checkedEntry);\n", "      }\n", "\n"]}, "removed": {"2": ["  static <B> Entry<Class<? extends B>, B> checkedEntry(final Entry<Class<? extends B>, B> entry) {\n"]}, "added_lines": {"1": [30], "2": [76, 77, 78, 79, 80], "3": [103, 104, 105, 106, 107, 108]}, "removed_lines": {"2": [75]}}, {"140": "guava/src/com/google/common/collect/Ordering.java", "added": {"1": ["   * <p><b>Java 8 users:</b> Use {@code Streams.stream(iterable).collect(Comparators.least(k,\n", "   * thisComparator))} instead.\n"], "2": ["      list.sort(this);\n"], "3": ["   * <p><b>Java 8 users:</b> Use {@code Streams.stream(iterable).collect(Comparators.greatest(k,\n", "   * thisComparator))} instead.\n"]}, "removed": {"1": ["   * <p><b>Java 8 users:</b> Continue to use this method for now. After the next release of Guava,\n", "   * use {@code Streams.stream(iterable).collect(Comparators.least(k, thisComparator))} instead.\n"], "2": ["      Collections.sort(list, this);\n"], "3": ["   * <p><b>Java 8 users:</b> Continue to use this method for now. After the next release of Guava,\n", "   * use {@code Streams.stream(iterable).collect(Comparators.greatest(k, thisComparator))} instead.\n"]}, "added_lines": {"1": [727, 728], "2": [780], "3": [801, 802]}, "removed_lines": {"1": [727, 728], "2": [780], "3": [801, 802]}}, {"141": "guava/src/com/google/common/collect/RangeSet.java", "added": {"1": ["  // TODO(lowasser): consider adding default implementations of some of these methods\n"], "2": ["  default boolean enclosesAll(Iterable<Range<C>> other) {\n", "    for (Range<C> range : other) {\n", "      if (!encloses(range)) {\n", "        return false;\n", "      }\n", "    }\n", "    return true;\n", "  }\n"], "3": ["  default void addAll(Iterable<Range<C>> ranges) {\n", "    for (Range<C> range : ranges) {\n", "      add(range);\n", "    }\n", "  }\n"], "4": ["  default void removeAll(Iterable<Range<C>> ranges) {\n", "    for (Range<C> range : ranges) {\n", "      remove(range);\n", "    }\n", "  }\n"]}, "removed": {"2": ["  boolean enclosesAll(Iterable<Range<C>> other);\n"], "3": ["  void addAll(Iterable<Range<C>> ranges);\n"], "4": ["  void removeAll(Iterable<Range<C>> ranges);\n"]}, "added_lines": {"1": [53], "2": [102, 103, 104, 105, 106, 107, 108, 109], "3": [223, 224, 225, 226, 227], "4": [252, 253, 254, 255, 256]}, "removed_lines": {"2": [101], "3": [215], "4": [240]}}, {"142": "guava/src/com/google/common/collect/RegularImmutableAsList.java", "added": {"1": ["import java.util.function.Consumer;\n"], "2": ["  @GwtIncompatible // not present in emulated superclass\n", "  @Override\n", "  public void forEach(Consumer<? super E> action) {\n", "    delegateList.forEach(action);\n", "  }\n", "\n"]}, "removed": {}, "added_lines": {"1": [21], "2": [59, 60, 61, 62, 63, 64]}, "removed_lines": {}}, {"143": "guava/src/com/google/common/collect/RegularImmutableBiMap.java", "added": {"1": ["import static com.google.common.base.Preconditions.checkNotNull;\n"], "2": ["import java.util.Map.Entry;\n", "import java.util.function.BiConsumer;\n", "import java.util.function.Consumer;\n"], "3": ["  @Override\n", "  public void forEach(BiConsumer<? super K, ? super V> action) {\n", "    checkNotNull(action);\n", "    for (Entry<K, V> entry : entries) {\n", "      action.accept(entry.getKey(), entry.getValue());\n", "    }\n", "  }\n", "\n"], "4": ["    @Override\n", "    public void forEach(BiConsumer<? super V, ? super K> action) {\n", "      checkNotNull(action);\n", "      RegularImmutableBiMap.this.forEach((k, v) -> action.accept(v, k));\n", "    }\n", "\n"], "5": ["      @Override\n", "      public void forEach(Consumer<? super Entry<V, K>> action) {\n", "        asList().forEach(action);\n", "      }\n", "\n"]}, "removed": {}, "added_lines": {"1": [19], "2": [31, 32, 33], "3": [149, 150, 151, 152, 153, 154, 155, 156], "4": [202, 203, 204, 205, 206, 207], "5": [251, 252, 253, 254, 255]}, "removed_lines": {}}, {"144": "guava/src/com/google/common/collect/RegularImmutableList.java", "added": {"1": ["import java.util.Spliterator;\n", "import java.util.Spliterators;\n"], "2": ["  @Override\n", "  public Spliterator<E> spliterator() {\n", "    return Spliterators.spliterator(array, SPLITERATOR_CHARACTERISTICS);\n", "  }\n", "\n"]}, "removed": {}, "added_lines": {"1": [20, 21], "2": [71, 72, 73, 74, 75]}, "removed_lines": {}}, {"145": "guava/src/com/google/common/collect/RegularImmutableMap.java", "added": {"1": ["import static com.google.common.base.Preconditions.checkNotNull;\n"], "2": ["import java.util.function.BiConsumer;\n"], "3": ["  @Override\n", "  public void forEach(BiConsumer<? super K, ? super V> action) {\n", "    checkNotNull(action);\n", "    for (Entry<K, V> entry : entries) {\n", "      action.accept(entry.getKey(), entry.getValue());\n", "    }\n", "  }\n", "\n"]}, "removed": {}, "added_lines": {"1": [19], "2": [29], "3": [142, 143, 144, 145, 146, 147, 148, 149]}, "removed_lines": {}}, {"146": "guava/src/com/google/common/collect/RegularImmutableSet.java", "added": {"1": ["import java.util.Spliterator;\n", "import java.util.Spliterators;\n"], "2": ["  @Override\n", "  public Spliterator<E> spliterator() {\n", "    return Spliterators.spliterator(elements, SPLITERATOR_CHARACTERISTICS);\n", "  }\n", "\n"]}, "removed": {}, "added_lines": {"1": [21, 22], "2": [76, 77, 78, 79, 80]}, "removed_lines": {}}, {"147": "guava/src/com/google/common/collect/RegularImmutableSortedMultiset.java", "added": {"1": ["import java.util.function.ObjIntConsumer;\n"], "2": ["  @Override\n", "  public void forEachEntry(ObjIntConsumer<? super E> action) {\n", "    checkNotNull(action);\n", "    for (int i = 0; i < size(); i++) {\n", "      action.accept(elementSet.asList().get(i), getCount(i));\n", "    }\n", "  }\n", "\n"]}, "removed": {}, "added_lines": {"1": [24], "2": [69, 70, 71, 72, 73, 74, 75, 76]}, "removed_lines": {}}, {"148": "guava/src/com/google/common/collect/RegularImmutableSortedSet.java", "added": {"1": ["import java.util.Spliterator;\n", "import java.util.function.Consumer;\n"], "2": ["  @Override\n", "  public Spliterator<E> spliterator() {\n", "    return asList().spliterator();\n", "  }\n", "\n", "  @Override\n", "  public void forEach(Consumer<? super E> action) {\n", "    elements.forEach(action);\n", "  }\n", "\n"]}, "removed": {}, "added_lines": {"1": [34, 35], "2": [69, 70, 71, 72, 73, 74, 75, 76, 77, 78]}, "removed_lines": {}}, {"149": "guava/src/com/google/common/collect/RegularImmutableTable.java", "added": {"2": ["      cells.sort(comparator);\n"]}, "removed": {"1": ["\n", "import java.util.Collections;\n"], "2": ["      Collections.sort(cells, comparator);\n"]}, "added_lines": {"2": [127]}, "removed_lines": {"1": [22, 23], "2": [130]}}, {"150": "guava/src/com/google/common/collect/Sets.java", "added": {"1": ["import java.util.stream.Stream;\n"], "2": ["      @Override\n", "      public Stream<E> stream() {\n", "        return Stream.concat(set1.stream(), set2minus1.stream());\n", "      }\n", "\n", "      @Override\n", "      public Stream<E> parallelStream() {\n", "        return Stream.concat(set1.parallelStream(), set2minus1.parallelStream());\n", "      }\n", "\n"], "3": ["      @Override\n", "      public Stream<E> stream() {\n", "        return set1.stream().filter(inSet2);\n", "      }\n", "\n", "      @Override\n", "      public Stream<E> parallelStream() {\n", "        return set1.parallelStream().filter(inSet2);\n", "      }\n", "\n"], "4": ["      @Override\n", "      public Stream<E> stream() {\n", "        return set1.stream().filter(notInSet2);\n", "      }\n", "\n", "      @Override\n", "      public Stream<E> parallelStream() {\n", "        return set1.parallelStream().filter(notInSet2);\n", "      }\n", "\n"]}, "removed": {}, "added_lines": {"1": [49], "2": [620, 621, 622, 623, 624, 625, 626, 627, 628, 629], "3": [686, 687, 688, 689, 690, 691, 692, 693, 694, 695], "4": [740, 741, 742, 743, 744, 745, 746, 747, 748, 749]}, "removed_lines": {}}, {"151": "guava/src/com/google/common/collect/SingletonImmutableBiMap.java", "added": {"1": ["import static com.google.common.base.Preconditions.checkNotNull;\n", "import java.util.function.BiConsumer;\n"], "2": ["  @Override\n", "  public void forEach(BiConsumer<? super K, ? super V> action) {\n", "    checkNotNull(action).accept(singleKey, singleValue);\n", "  }\n", "\n"]}, "removed": {}, "added_lines": {"1": [19, 25], "2": [63, 64, 65, 66, 67]}, "removed_lines": {}}, {"152": "guava/src/com/google/common/collect/SingletonImmutableList.java", "added": {"1": ["import java.util.Collections;\n", "import java.util.Spliterator;\n"], "2": ["  @Override\n", "  public Spliterator<E> spliterator() {\n", "    return Collections.singleton(element).spliterator();\n", "  }\n", "\n"]}, "removed": {}, "added_lines": {"1": [23, 24], "2": [52, 53, 54, 55, 56]}, "removed_lines": {}}, {"153": "guava/src/com/google/common/collect/SingletonImmutableSet.java", "added": {"1": ["import static com.google.common.base.Preconditions.checkNotNull;\n", "\n"]}, "removed": {}, "added_lines": {"1": [19, 20]}, "removed_lines": {}}, {"154": "guava/src/com/google/common/collect/StandardTable.java", "added": {"1": ["import com.google.common.collect.Table.Cell;\n"], "2": ["import java.util.Spliterator;\n", "import java.util.Spliterators;\n"], "3": ["  @Override\n", "  Spliterator<Cell<R, C, V>> cellSpliterator() {\n", "    return CollectSpliterators.flatMap(\n", "        backingMap.entrySet().spliterator(),\n", "        (Map.Entry<R, Map<C, V>> rowEntry) ->\n", "            CollectSpliterators.map(\n", "                rowEntry.getValue().entrySet().spliterator(),\n", "                (Map.Entry<C, V> columnEntry) ->\n", "                    Tables.immutableCell(\n", "                        rowEntry.getKey(), columnEntry.getKey(), columnEntry.getValue())),\n", "        Spliterator.DISTINCT | Spliterator.SIZED,\n", "        size());\n", "  }\n", "\n"], "4": ["    @Override\n", "    Spliterator<Entry<C, V>> entrySpliterator() {\n", "      Map<C, V> map = backingRowMap();\n", "      if (map == null) {\n", "        return Spliterators.emptySpliterator();\n", "      }\n", "      return CollectSpliterators.map(map.entrySet().spliterator(), this::wrapEntry);\n", "    }\n", "\n"]}, "removed": {"2": ["\n"]}, "added_lines": {"1": [34], "2": [44, 45], "3": [269, 270, 271, 272, 273, 274, 275, 276, 277, 278, 279, 280, 281, 282], "4": [389, 390, 391, 392, 393, 394, 395, 396, 397]}, "removed_lines": {"2": [43]}}, {"155": "guava/src/com/google/common/collect/Streams.java", "added": {"1": ["/*\n", " * Copyright (C) 2015 The Guava Authors\n", " *\n", " * Licensed under the Apache License, Version 2.0 (the \"License\"); you\n", " * may not use this file except in compliance with the License.  You may\n", " * obtain a copy of the License at\n", " *\n", " * http://www.apache.org/licenses/LICENSE-2.0\n", " *\n", " * Unless required by applicable law or agreed to in writing, software\n", " * distributed under the License is distributed on an \"AS IS\" BASIS,\n", " * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or\n", " * implied.  See the License for the specific language governing\n", " * permissions and limitations under the License.\n", " */\n", "\n", "package com.google.common.collect;\n", "\n", "import static com.google.common.base.Preconditions.checkNotNull;\n", "import static com.google.common.base.Preconditions.checkState;\n", "\n", "import com.google.common.annotations.Beta;\n", "import com.google.common.annotations.GwtCompatible;\n", "import com.google.common.math.LongMath;\n", "import java.util.ArrayDeque;\n", "import java.util.Collection;\n", "import java.util.Deque;\n", "import java.util.Iterator;\n", "import java.util.OptionalDouble;\n", "import java.util.OptionalInt;\n", "import java.util.OptionalLong;\n", "import java.util.Spliterator;\n", "import java.util.Spliterators;\n", "import java.util.Spliterators.AbstractSpliterator;\n", "import java.util.function.BiFunction;\n", "import java.util.function.Consumer;\n", "import java.util.stream.DoubleStream;\n", "import java.util.stream.IntStream;\n", "import java.util.stream.LongStream;\n", "import java.util.stream.Stream;\n", "import java.util.stream.StreamSupport;\n", "import javax.annotation.Nullable;\n", "\n", "/**\n", " * Static utility methods related to {@code Stream} instances.\n", " *\n", " * @since 21.0\n", " */\n", "@Beta\n", "@GwtCompatible\n", "public final class Streams {\n", "  /**\n", "   * Returns a sequential {@link Stream} of the contents of {@code iterable}, delegating to {@link\n", "   * Collection#stream} if possible.\n", "   */\n", "  public static <T> Stream<T> stream(Iterable<T> iterable) {\n", "    return (iterable instanceof Collection)\n", "        ? ((Collection<T>) iterable).stream()\n", "        : StreamSupport.stream(iterable.spliterator(), false);\n", "  }\n", "\n", "  /**\n", "   * Returns {@link Collection#stream}.\n", "   *\n", "   * @deprecated There is no reason to use this; just invoke {@code collection.stream()} directly.\n", "   */\n", "  @Deprecated\n", "  public static <T> Stream<T> stream(Collection<T> collection) {\n", "    return collection.stream();\n", "  }\n", "\n", "  /**\n", "   * Returns a sequential {@link Stream} of the remaining contents of {@code iterator}. Do not use\n", "   * {@code iterator} directly after passing it to this method.\n", "   */\n", "  public static <T> Stream<T> stream(Iterator<T> iterator) {\n", "    return StreamSupport.stream(Spliterators.spliteratorUnknownSize(iterator, 0), false);\n", "  }\n", "\n", "  /**\n", "   * If a value is present in {@code optional}, returns a stream containing only that element,\n", "   * otherwise returns an empty stream.\n", "   */\n", "  public static <T> Stream<T> stream(com.google.common.base.Optional<T> optional) {\n", "    return optional.isPresent() ? Stream.of(optional.get()) : Stream.of();\n", "  }\n", "\n", "  /**\n", "   * If a value is present in {@code optional}, returns a stream containing only that element,\n", "   * otherwise returns an empty stream.\n", "   *\n", "   * <p><b>Java 9 users:</b> use {@code optional.stream()} instead.\n", "   */\n", "  public static <T> Stream<T> stream(java.util.Optional<T> optional) {\n", "    return optional.isPresent() ? Stream.of(optional.get()) : Stream.of();\n", "  }\n", "\n", "  /**\n", "   * Returns a {@link Stream} containing the elements of the first stream, followed by the elements\n", "   * of the second stream, and so on.\n", "   *\n", "   * <p>This is equivalent to {@code Stream.of(streams).flatMap(stream -> stream)}, but the returned\n", "   * stream may perform better.\n", "   *\n", "   * @see Stream#concat(Stream, Stream)\n", "   */\n", "  @SafeVarargs\n", "  public static <T> Stream<T> concat(Stream<? extends T>... streams) {\n", "    // TODO(lowasser): consider an implementation that can support SUBSIZED\n", "    boolean isParallel = false;\n", "    int characteristics = Spliterator.ORDERED | Spliterator.SIZED | Spliterator.NONNULL;\n", "    long estimatedSize = 0L;\n", "    ImmutableList.Builder<Spliterator<? extends T>> splitrsBuilder =\n", "        new ImmutableList.Builder<>(streams.length);\n", "    for (Stream<? extends T> stream : streams) {\n", "      isParallel |= stream.isParallel();\n", "      Spliterator<? extends T> splitr = stream.spliterator();\n", "      splitrsBuilder.add(splitr);\n", "      characteristics &= splitr.characteristics();\n", "      estimatedSize = LongMath.saturatedAdd(estimatedSize, splitr.estimateSize());\n", "    }\n", "    return StreamSupport.stream(\n", "        CollectSpliterators.flatMap(\n", "            splitrsBuilder.build().spliterator(),\n", "            splitr -> (Spliterator<T>) splitr,\n", "            characteristics,\n", "            estimatedSize),\n", "        isParallel);\n", "  }\n", "\n", "  /**\n", "   * Returns an {@link IntStream} containing the elements of the first stream, followed by the\n", "   * elements of the second stream, and so on.\n", "   *\n", "   * <p>This is equivalent to {@code Stream.of(streams).flatMapToInt(stream -> stream)}, but the\n", "   * returned stream may perform better.\n", "   *\n", "   * @see IntStream#concat(IntStream, IntStream)\n", "   */\n", "  public static IntStream concat(IntStream... streams) {\n", "    // TODO(lowasser): optimize this later\n", "    return Stream.of(streams).flatMapToInt(stream -> stream);\n", "  }\n", "\n", "  /**\n", "   * Returns a {@link LongStream} containing the elements of the first stream, followed by the\n", "   * elements of the second stream, and so on.\n", "   *\n", "   * <p>This is equivalent to {@code Stream.of(streams).flatMapToLong(stream -> stream)}, but the\n", "   * returned stream may perform better.\n", "   *\n", "   * @see LongStream#concat(LongStream, LongStream)\n", "   */\n", "  public static LongStream concat(LongStream... streams) {\n", "    // TODO(lowasser): optimize this later\n", "    return Stream.of(streams).flatMapToLong(stream -> stream);\n", "  }\n", "\n", "  /**\n", "   * Returns a {@link DoubleStream} containing the elements of the first stream, followed by the\n", "   * elements of the second stream, and so on.\n", "   *\n", "   * <p>This is equivalent to {@code Stream.of(streams).flatMapToDouble(stream -> stream)}, but the\n", "   * returned stream may perform better.\n", "   *\n", "   * @see DoubleStream#concat(DoubleStream, DoubleStream)\n", "   */\n", "  public static DoubleStream concat(DoubleStream... streams) {\n", "    // TODO(lowasser): optimize this later\n", "    return Stream.of(streams).flatMapToDouble(stream -> stream);\n", "  }\n", "\n", "  /**\n", "   * If a value is present in {@code optional}, returns a stream containing only that element,\n", "   * otherwise returns an empty stream.\n", "   *\n", "   * <p><b>Java 9 users:</b> use {@code optional.stream()} instead.\n", "   */\n", "  public static IntStream stream(OptionalInt optional) {\n", "    return optional.isPresent() ? IntStream.of(optional.getAsInt()) : IntStream.empty();\n", "  }\n", "\n", "  /**\n", "   * If a value is present in {@code optional}, returns a stream containing only that element,\n", "   * otherwise returns an empty stream.\n", "   *\n", "   * <p><b>Java 9 users:</b> use {@code optional.stream()} instead.\n", "   */\n", "  public static LongStream stream(OptionalLong optional) {\n", "    return optional.isPresent() ? LongStream.of(optional.getAsLong()) : LongStream.empty();\n", "  }\n", "\n", "  /**\n", "   * If a value is present in {@code optional}, returns a stream containing only that element,\n", "   * otherwise returns an empty stream.\n", "   *\n", "   * <p><b>Java 9 users:</b> use {@code optional.stream()} instead.\n", "   */\n", "  public static DoubleStream stream(OptionalDouble optional) {\n", "    return optional.isPresent() ? DoubleStream.of(optional.getAsDouble()) : DoubleStream.empty();\n", "  }\n", "\n", "  /**\n", "   * Returns the last element of the specified stream, or {@link java.util.Optional#empty} if the\n", "   * stream is empty.\n", "   *\n", "   * <p>Equivalent to {@code stream.reduce((a, b) -> b)}, but may perform significantly better. This\n", "   * method's runtime will be between O(log n) and O(n), performing better on <a\n", "   * href=\"http://gee.cs.oswego.edu/dl/html/StreamParallelGuidance.html\">efficiently splittable</a>\n", "   * streams.\n", "   *\n", "   * <p>If the stream has nondeterministic order, this has equivalent semantics to {@link\n", "   * Stream#findAny} (which you might as well use).\n", "   *\n", "   * @see Stream#findFirst()\n", "   * @throws NullPointerException if the last element of the stream is null\n", "   */\n", "  public static <T> java.util.Optional<T> findLast(Stream<T> stream) {\n", "    class OptionalState<T> {\n", "      boolean set = false;\n", "      T value = null;\n", "\n", "      void set(@Nullable T value) {\n", "        this.set = true;\n", "        this.value = value;\n", "      }\n", "\n", "      T get() {\n", "        checkState(set);\n", "        return value;\n", "      }\n", "    }\n", "    OptionalState<T> state = new OptionalState<>();\n", "\n", "    Deque<Spliterator<T>> splits = new ArrayDeque<>();\n", "    splits.addLast(stream.spliterator());\n", "\n", "    while (!splits.isEmpty()) {\n", "      Spliterator<T> spliterator = splits.removeLast();\n", "\n", "      if (spliterator.getExactSizeIfKnown() == 0) {\n", "        continue; // drop this split\n", "      }\n", "\n", "      // Many spliterators will have trySplits that are SUBSIZED even if they are not themselves\n", "      // SUBSIZED.\n", "      if (spliterator.hasCharacteristics(Spliterator.SUBSIZED)) {\n", "        // we can drill down to exactly the smallest nonempty spliterator\n", "        while (true) {\n", "          Spliterator<T> prefix = spliterator.trySplit();\n", "          if (prefix == null || prefix.getExactSizeIfKnown() == 0) {\n", "            break;\n", "          } else if (spliterator.getExactSizeIfKnown() == 0) {\n", "            spliterator = prefix;\n", "            break;\n", "          }\n", "        }\n", "\n", "        // spliterator is known to be nonempty now\n", "        spliterator.forEachRemaining(state::set);\n", "        return java.util.Optional.of(state.get());\n", "      }\n", "\n", "      Spliterator<T> prefix = spliterator.trySplit();\n", "      if (prefix == null || prefix.getExactSizeIfKnown() == 0) {\n", "        // we can't split this any further\n", "        spliterator.forEachRemaining(state::set);\n", "        if (state.set) {\n", "          return java.util.Optional.of(state.get());\n", "        }\n", "        // fall back to the last split\n", "        continue;\n", "      }\n", "      splits.addLast(prefix);\n", "      splits.addLast(spliterator);\n", "    }\n", "    return java.util.Optional.empty();\n", "  }\n", "\n", "  /**\n", "   * Returns the last element of the specified stream, or {@link OptionalInt#empty} if the stream is\n", "   * empty.\n", "   *\n", "   * <p>Equivalent to {@code stream.reduce((a, b) -> b)}, but may perform significantly better. This\n", "   * method's runtime will be between O(log n) and O(n), performing better on <a\n", "   * href=\"http://gee.cs.oswego.edu/dl/html/StreamParallelGuidance.html\">efficiently splittable</a>\n", "   * streams.\n", "   *\n", "   * @see IntStream#findFirst()\n", "   * @throws NullPointerException if the last element of the stream is null\n", "   */\n", "  public static OptionalInt findLast(IntStream stream) {\n", "    // findLast(Stream) does some allocation, so we might as well box some more\n", "    java.util.Optional<Integer> boxedLast = findLast(stream.boxed());\n", "    return boxedLast.isPresent() ? OptionalInt.of(boxedLast.get()) : OptionalInt.empty();\n", "  }\n", "\n", "  /**\n", "   * Returns the last element of the specified stream, or {@link OptionalLong#empty} if the stream\n", "   * is empty.\n", "   *\n", "   * <p>Equivalent to {@code stream.reduce((a, b) -> b)}, but may perform significantly better. This\n", "   * method's runtime will be between O(log n) and O(n), performing better on <a\n", "   * href=\"http://gee.cs.oswego.edu/dl/html/StreamParallelGuidance.html\">efficiently splittable</a>\n", "   * streams.\n", "   *\n", "   * @see LongStream#findFirst()\n", "   * @throws NullPointerException if the last element of the stream is null\n", "   */\n", "  public static OptionalLong findLast(LongStream stream) {\n", "    // findLast(Stream) does some allocation, so we might as well box some more\n", "    java.util.Optional<Long> boxedLast = findLast(stream.boxed());\n", "    return boxedLast.isPresent() ? OptionalLong.of(boxedLast.get()) : OptionalLong.empty();\n", "  }\n", "\n", "  /**\n", "   * Returns the last element of the specified stream, or {@link OptionalDouble#empty} if the stream\n", "   * is empty.\n", "   *\n", "   * <p>Equivalent to {@code stream.reduce((a, b) -> b)}, but may perform significantly better. This\n", "   * method's runtime will be between O(log n) and O(n), performing better on <a\n", "   * href=\"http://gee.cs.oswego.edu/dl/html/StreamParallelGuidance.html\">efficiently splittable</a>\n", "   * streams.\n", "   *\n", "   * @see DoubleStream#findFirst()\n", "   * @throws NullPointerException if the last element of the stream is null\n", "   */\n", "  public static OptionalDouble findLast(DoubleStream stream) {\n", "    // findLast(Stream) does some allocation, so we might as well box some more\n", "    java.util.Optional<Double> boxedLast = findLast(stream.boxed());\n", "    return boxedLast.isPresent() ? OptionalDouble.of(boxedLast.get()) : OptionalDouble.empty();\n", "  }\n", "\n", "  /**\n", "   * Returns a stream in which each element is the result of passing the corresponding element of\n", "   * each of {@code streamA} and {@code streamB} to {@code function}.\n", "   *\n", "   * <p>For example:\n", "   *\n", "   * <pre>{@code\n", "   * Streams.zip(\n", "   *   Stream.of(\"foo1\", \"foo2\", \"foo3\"),\n", "   *   Stream.of(\"bar1\", \"bar2\"),\n", "   *   (arg1, arg2) -> arg1 + \":\" + arg2)\n", "   * }</pre>\n", "   *\n", "   * <p>will return {@code Stream.of(\"foo1:bar1\", \"foo2:bar2\")}.\n", "   *\n", "   * <p>The resulting stream will only be as long as the shorter of the two input streams; if one\n", "   * stream is longer, its extra elements will be ignored.\n", "   *\n", "   * <p>The resulting stream is not <a\n", "   * href=\"http://gee.cs.oswego.edu/dl/html/StreamParallelGuidance.html\">efficiently splittable</a>.\n", "   * This may harm parallel performance.\n", "   */\n", "  public static <A, B, R> Stream<R> zip(\n", "      Stream<A> streamA, Stream<B> streamB, BiFunction<? super A, ? super B, R> function) {\n", "    checkNotNull(streamA);\n", "    checkNotNull(streamB);\n", "    checkNotNull(function);\n", "    boolean isParallel = streamA.isParallel() || streamB.isParallel(); // same as Stream.concat\n", "    Spliterator<A> splitrA = streamA.spliterator();\n", "    Spliterator<B> splitrB = streamB.spliterator();\n", "    int characteristics =\n", "        splitrA.characteristics()\n", "            & splitrB.characteristics()\n", "            & (Spliterator.SIZED | Spliterator.ORDERED);\n", "    Iterator<A> itrA = Spliterators.iterator(splitrA);\n", "    Iterator<B> itrB = Spliterators.iterator(splitrB);\n", "    return StreamSupport.stream(\n", "        new AbstractSpliterator<R>(\n", "            Math.min(splitrA.estimateSize(), splitrB.estimateSize()), characteristics) {\n", "          @Override\n", "          public boolean tryAdvance(Consumer<? super R> action) {\n", "            if (itrA.hasNext() && itrB.hasNext()) {\n", "              action.accept(function.apply(itrA.next(), itrB.next()));\n", "              return true;\n", "            }\n", "            return false;\n", "          }\n", "        },\n", "        isParallel);\n", "  }\n", "  /**\n", "   * An analogue of {@link java.util.function.Function} also accepting an index.\n", "   *\n", "   * <p>This interface is only intended for use by callers of {@link #mapWithIndex}.\n", "   */\n", "  public interface FunctionWithIndex<T, R> {\n", "    /** Applies this function to the given argument and its index within a stream. */\n", "    R apply(T from, long index);\n", "  }\n", "\n", "  /**\n", "   * Returns a stream consisting of the results of applying the given function to the elements of\n", "   * {@code stream} and their indices in the stream. For example,\n", "   *\n", "   * <pre>{@code\n", "   * mapWithIndex(\n", "   *     Stream.of(\"a\", \"b\", \"c\"),\n", "   *     (str, index) -> str + \":\" + index)\n", "   * }</pre>\n", "   *\n", "   * <p>would return {@code Stream.of(\"a:0\", \"b:1\", \"c:2\")}.\n", "   *\n", "   * <p>The resulting stream is <a\n", "   * href=\"http://gee.cs.oswego.edu/dl/html/StreamParallelGuidance.html\">efficiently splittable</a>\n", "   * if and only if {@code stream} was efficiently splittable and its underlying spliterator\n", "   * reported {@link Spliterator#SUBSIZED}. This is generally the case if the underlying stream\n", "   * comes from a data structure supporting efficient indexed random access, typically an array or\n", "   * list.\n", "   *\n", "   * <p>The order of the resulting stream is defined if and only if the order of the original stream\n", "   * was defined.\n", "   */\n", "  public static <T, R> Stream<R> mapWithIndex(\n", "      Stream<T> stream, FunctionWithIndex<? super T, ? extends R> function) {\n", "    checkNotNull(stream);\n", "    checkNotNull(function);\n", "    boolean isParallel = stream.isParallel();\n", "    Spliterator<T> fromSpliterator = stream.spliterator();\n", "\n", "    if (!fromSpliterator.hasCharacteristics(Spliterator.SUBSIZED)) {\n", "      Iterator<T> fromIterator = Spliterators.iterator(fromSpliterator);\n", "      return StreamSupport.stream(\n", "          new AbstractSpliterator<R>(\n", "              fromSpliterator.estimateSize(),\n", "              fromSpliterator.characteristics() & (Spliterator.ORDERED | Spliterator.SIZED)) {\n", "            long index = 0;\n", "\n", "            @Override\n", "            public boolean tryAdvance(Consumer<? super R> action) {\n", "              if (fromIterator.hasNext()) {\n", "                action.accept(function.apply(fromIterator.next(), index++));\n", "                return true;\n", "              }\n", "              return false;\n", "            }\n", "          },\n", "          isParallel);\n", "    }\n", "    class Splitr implements Spliterator<R>, Consumer<T> {\n", "      final Spliterator<T> splitr;\n", "      long index;\n", "      T holder = null;\n", "\n", "      Splitr(Spliterator<T> splitr, long index) {\n", "        this.splitr = splitr;\n", "        this.index = index;\n", "      }\n", "\n", "      @Override\n", "      public void accept(@Nullable T t) {\n", "        this.holder = t;\n", "      }\n", "\n", "      @Override\n", "      public boolean tryAdvance(Consumer<? super R> action) {\n", "        if (splitr.tryAdvance(this)) {\n", "          try {\n", "            action.accept(function.apply(holder, index++));\n", "            return true;\n", "          } finally {\n", "            holder = null;\n", "          }\n", "        }\n", "        return false;\n", "      }\n", "\n", "      @Override\n", "      public Spliterator<R> trySplit() {\n", "        Spliterator<T> split = splitr.trySplit();\n", "        if (split == null) {\n", "          return null;\n", "        }\n", "        Spliterator<R> result = new Splitr(split, index);\n", "        this.index += split.getExactSizeIfKnown();\n", "        return result;\n", "      }\n", "\n", "      @Override\n", "      public long estimateSize() {\n", "        return splitr.estimateSize();\n", "      }\n", "\n", "      @Override\n", "      public int characteristics() {\n", "        return splitr.characteristics()\n", "            & (Spliterator.ORDERED | Spliterator.SIZED | Spliterator.SUBSIZED);\n", "      }\n", "    }\n", "    return StreamSupport.stream(new Splitr(fromSpliterator, 0), isParallel);\n", "  }\n", "\n", "  private Streams() {}\n", "}\n"]}, "removed": {}, "added_lines": {"1": [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 58, 59, 60, 61, 62, 63, 64, 65, 66, 67, 68, 69, 70, 71, 72, 73, 74, 75, 76, 77, 78, 79, 80, 81, 82, 83, 84, 85, 86, 87, 88, 89, 90, 91, 92, 93, 94, 95, 96, 97, 98, 99, 100, 101, 102, 103, 104, 105, 106, 107, 108, 109, 110, 111, 112, 113, 114, 115, 116, 117, 118, 119, 120, 121, 122, 123, 124, 125, 126, 127, 128, 129, 130, 131, 132, 133, 134, 135, 136, 137, 138, 139, 140, 141, 142, 143, 144, 145, 146, 147, 148, 149, 150, 151, 152, 153, 154, 155, 156, 157, 158, 159, 160, 161, 162, 163, 164, 165, 166, 167, 168, 169, 170, 171, 172, 173, 174, 175, 176, 177, 178, 179, 180, 181, 182, 183, 184, 185, 186, 187, 188, 189, 190, 191, 192, 193, 194, 195, 196, 197, 198, 199, 200, 201, 202, 203, 204, 205, 206, 207, 208, 209, 210, 211, 212, 213, 214, 215, 216, 217, 218, 219, 220, 221, 222, 223, 224, 225, 226, 227, 228, 229, 230, 231, 232, 233, 234, 235, 236, 237, 238, 239, 240, 241, 242, 243, 244, 245, 246, 247, 248, 249, 250, 251, 252, 253, 254, 255, 256, 257, 258, 259, 260, 261, 262, 263, 264, 265, 266, 267, 268, 269, 270, 271, 272, 273, 274, 275, 276, 277, 278, 279, 280, 281, 282, 283, 284, 285, 286, 287, 288, 289, 290, 291, 292, 293, 294, 295, 296, 297, 298, 299, 300, 301, 302, 303, 304, 305, 306, 307, 308, 309, 310, 311, 312, 313, 314, 315, 316, 317, 318, 319, 320, 321, 322, 323, 324, 325, 326, 327, 328, 329, 330, 331, 332, 333, 334, 335, 336, 337, 338, 339, 340, 341, 342, 343, 344, 345, 346, 347, 348, 349, 350, 351, 352, 353, 354, 355, 356, 357, 358, 359, 360, 361, 362, 363, 364, 365, 366, 367, 368, 369, 370, 371, 372, 373, 374, 375, 376, 377, 378, 379, 380, 381, 382, 383, 384, 385, 386, 387, 388, 389, 390, 391, 392, 393, 394, 395, 396, 397, 398, 399, 400, 401, 402, 403, 404, 405, 406, 407, 408, 409, 410, 411, 412, 413, 414, 415, 416, 417, 418, 419, 420, 421, 422, 423, 424, 425, 426, 427, 428, 429, 430, 431, 432, 433, 434, 435, 436, 437, 438, 439, 440, 441, 442, 443, 444, 445, 446, 447, 448, 449, 450, 451, 452, 453, 454, 455, 456, 457, 458, 459, 460, 461, 462, 463, 464, 465, 466, 467, 468, 469, 470, 471, 472, 473, 474, 475, 476, 477, 478, 479, 480, 481, 482, 483, 484, 485, 486, 487, 488, 489, 490, 491, 492, 493, 494, 495, 496]}, "removed_lines": {}}, {"156": "guava/src/com/google/common/collect/Synchronized.java", "added": {"1": ["import java.util.Spliterator;\n", "import java.util.function.BiConsumer;\n", "import java.util.function.BiFunction;\n", "import java.util.function.Consumer;\n", "import java.util.function.Function;\n", "import java.util.function.Predicate;\n", "import java.util.function.UnaryOperator;\n", "import java.util.stream.Stream;\n"], "2": ["    @Override\n", "    public Spliterator<E> spliterator() {\n", "      synchronized (mutex) {\n", "        return delegate().spliterator();\n", "      }\n", "    }\n", "\n", "    @Override\n", "    public Stream<E> stream() {\n", "      synchronized (mutex) {\n", "        return delegate().stream();\n", "      }\n", "    }\n", "\n", "    @Override\n", "    public Stream<E> parallelStream() {\n", "      synchronized (mutex) {\n", "        return delegate().parallelStream();\n", "      }\n", "    }\n", "\n", "    @Override\n", "    public void forEach(Consumer<? super E> action) {\n", "      synchronized (mutex) {\n", "        delegate().forEach(action);\n", "      }\n", "    }\n", "\n"], "3": ["    @Override\n", "    public boolean removeIf(Predicate<? super E> filter) {\n", "      synchronized (mutex) {\n", "        return delegate().removeIf(filter);\n", "      }\n", "    }\n", "\n"], "4": ["    @Override\n", "    public void replaceAll(UnaryOperator<E> operator) {\n", "      synchronized (mutex) {\n", "        delegate().replaceAll(operator);\n", "      }\n", "    }\n", "\n", "    @Override\n", "    public void sort(Comparator<? super E> c) {\n", "      synchronized (mutex) {\n", "        delegate().sort(c);\n", "      }\n", "    }\n", "\n"], "5": ["    @Override\n", "    public void forEach(BiConsumer<? super K, ? super V> action) {\n", "      synchronized (mutex) {\n", "        delegate().forEach(action);\n", "      }\n", "    }\n", "\n"], "6": ["    @Override\n", "    public void forEach(BiConsumer<? super K, ? super V> action) {\n", "      synchronized (mutex) {\n", "        delegate().forEach(action);\n", "      }\n", "    }\n", "\n"], "7": ["    @Override\n", "    public V getOrDefault(Object key, V defaultValue) {\n", "      synchronized (mutex) {\n", "        return delegate().getOrDefault(key, defaultValue);\n", "      }\n", "    }\n", "\n"], "8": ["    @Override\n", "    public V putIfAbsent(K key, V value) {\n", "      synchronized (mutex) {\n", "        return delegate().putIfAbsent(key, value);\n", "      }\n", "    }\n", "\n", "    @Override\n", "    public boolean replace(K key, V oldValue, V newValue) {\n", "      synchronized (mutex) {\n", "        return delegate().replace(key, oldValue, newValue);\n", "      }\n", "    }\n", "\n", "    @Override\n", "    public V replace(K key, V value) {\n", "      synchronized (mutex) {\n", "        return delegate().replace(key, value);\n", "      }\n", "    }\n", "\n", "    @Override\n", "    public V computeIfAbsent(K key, Function<? super K, ? extends V> mappingFunction) {\n", "      synchronized (mutex) {\n", "        return delegate().computeIfAbsent(key, mappingFunction);\n", "      }\n", "    }\n", "\n", "    @Override\n", "    public V computeIfPresent(\n", "        K key, BiFunction<? super K, ? super V, ? extends V> remappingFunction) {\n", "      synchronized (mutex) {\n", "        return delegate().computeIfPresent(key, remappingFunction);\n", "      }\n", "    }\n", "\n", "    @Override\n", "    public V compute(K key, BiFunction<? super K, ? super V, ? extends V> remappingFunction) {\n", "      synchronized (mutex) {\n", "        return delegate().compute(key, remappingFunction);\n", "      }\n", "    }\n", "\n", "    @Override\n", "    public V merge(\n", "        K key, V value, BiFunction<? super V, ? super V, ? extends V> remappingFunction) {\n", "      synchronized (mutex) {\n", "        return delegate().merge(key, value, remappingFunction);\n", "      }\n", "    }\n", "\n"], "9": ["    @Override\n", "    public void replaceAll(BiFunction<? super K, ? super V, ? extends V> function) {\n", "      synchronized (mutex) {\n", "        delegate().replaceAll(function);\n", "      }\n", "    }\n", "\n"], "10": ["    @Override\n", "    public boolean remove(Object key, Object value) {\n", "      synchronized (mutex) {\n", "        return delegate().remove(key, value);\n", "      }\n", "    }\n", "\n"]}, "removed": {}, "added_lines": {"1": [43, 44, 45, 46, 47, 48, 49, 50], "2": [171, 172, 173, 174, 175, 176, 177, 178, 179, 180, 181, 182, 183, 184, 185, 186, 187, 188, 189, 190, 191, 192, 193, 194, 195, 196, 197, 198], "3": [220, 221, 222, 223, 224, 225, 226], "4": [421, 422, 423, 424, 425, 426, 427, 428, 429, 430, 431, 432, 433, 434], "5": [713, 714, 715, 716, 717, 718, 719], "6": [1072, 1073, 1074, 1075, 1076, 1077, 1078], "7": [1086, 1087, 1088, 1089, 1090, 1091, 1092], "8": [1117, 1118, 1119, 1120, 1121, 1122, 1123, 1124, 1125, 1126, 1127, 1128, 1129, 1130, 1131, 1132, 1133, 1134, 1135, 1136, 1137, 1138, 1139, 1140, 1141, 1142, 1143, 1144, 1145, 1146, 1147, 1148, 1149, 1150, 1151, 1152, 1153, 1154, 1155, 1156, 1157, 1158, 1159, 1160, 1161, 1162, 1163, 1164, 1165, 1166, 1167], "9": [1175, 1176, 1177, 1178, 1179, 1180, 1181], "10": [1189, 1190, 1191, 1192, 1193, 1194, 1195]}, "removed_lines": {}}, {"157": "guava/src/com/google/common/collect/Tables.java", "added": {"1": ["import java.util.Spliterator;\n"], "2": ["\n", "    @SuppressWarnings(\"unchecked\")\n", "    @Override\n", "    Spliterator<Cell<C, R, V>> cellSpliterator() {\n", "      return CollectSpliterators.map(original.cellSet().spliterator(), (Function) TRANSPOSE_CELL);\n", "    }\n"], "3": ["    @Override\n", "    Spliterator<Cell<R, C, V2>> cellSpliterator() {\n", "      return CollectSpliterators.map(fromTable.cellSet().spliterator(), cellFunction());\n", "    }\n", "\n"]}, "removed": {}, "added_lines": {"1": [36], "2": [253, 254, 255, 256, 257, 258], "3": [416, 417, 418, 419, 420]}, "removed_lines": {}}, {"158": "guava/src/com/google/common/collect/TopKSelector.java", "added": {"1": ["  TopKSelector<T> combine(TopKSelector<T> other) {\n", "    for (int i = 0; i < other.bufferSize; i++) {\n", "      this.offer(other.buffer[i]);\n", "    }\n", "    return this;\n", "  }\n", "\n"]}, "removed": {}, "added_lines": {"1": [220, 221, 222, 223, 224, 225, 226]}, "removed_lines": {}}, {"159": "guava/src/com/google/common/collect/TreeTraverser.java", "added": {"1": ["import java.util.function.Consumer;\n"], "2": ["\n", "      @Override\n", "      public void forEach(Consumer<? super T> action) {\n", "        checkNotNull(action);\n", "        new Consumer<T>() {\n", "          @Override\n", "          public void accept(T t) {\n", "            action.accept(t);\n", "            children(t).forEach(this);\n", "          }\n", "        }.accept(root);\n", "      }\n"], "3": ["\n", "      @Override\n", "      public void forEach(Consumer<? super T> action) {\n", "        checkNotNull(action);\n", "        new Consumer<T>() {\n", "          @Override\n", "          public void accept(T t) {\n", "            children(t).forEach(this);\n", "            action.accept(t);\n", "          }\n", "        }.accept(root);\n", "      }\n"]}, "removed": {}, "added_lines": {"1": [28], "2": [110, 111, 112, 113, 114, 115, 116, 117, 118, 119, 120, 121], "3": [172, 173, 174, 175, 176, 177, 178, 179, 180, 181, 182, 183]}, "removed_lines": {}}, {"160": "guava/src/com/google/common/io/AndroidIncompatible.java", "added": {"1": ["import com.google.common.annotations.GwtIncompatible;\n", " * Signifies that the annotated element should not be included for use on Android.\n", "@GwtIncompatible // nothing that uses it is GwtCompatible\n"]}, "removed": {"1": ["import com.google.common.annotations.GwtCompatible;\n", " * Signifies that a test should not be run under Android. This annotation is respected only by our\n", " * Google-internal Android suite generators. Note that those generators also suppress any test\n", " * annotated with MediumTest or LargeTest.\n", " *\n", " * <p>For more discussion, see {@linkplain com.google.common.base.AndroidIncompatible the\n", " * documentation on another copy of this annotation}.\n", "@GwtCompatible\n"]}, "added_lines": {"1": [26, 31, 35]}, "removed_lines": {"1": [26, 31, 32, 33, 34, 35, 36, 40]}}, {"161": "guava/src/com/google/common/io/InsecureRecursiveDeleteException.java", "added": {"1": ["/*\n", " * Copyright (C) 2014 The Guava Authors\n", " *\n", " * Licensed under the Apache License, Version 2.0 (the \"License\");\n", " * you may not use this file except in compliance with the License.\n", " * You may obtain a copy of the License at\n", " *\n", " * http://www.apache.org/licenses/LICENSE-2.0\n", " *\n", " * Unless required by applicable law or agreed to in writing, software\n", " * distributed under the License is distributed on an \"AS IS\" BASIS,\n", " * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n", " * See the License for the specific language governing permissions and\n", " * limitations under the License.\n", " */\n", "\n", "package com.google.common.io;\n", "\n", "import com.google.common.annotations.Beta;\n", "import com.google.common.annotations.GwtIncompatible;\n", "import com.google.j2objc.annotations.J2ObjCIncompatible;\n", "import java.nio.file.FileSystemException;\n", "import java.nio.file.SecureDirectoryStream;\n", "import javax.annotation.Nullable;\n", "\n", "/**\n", " * Exception indicating that a recursive delete can't be performed because the file system does not\n", " * have the support necessary to guarantee that it is not vulnerable to race conditions that would\n", " * allow it to delete files and directories outside of the directory being deleted (i.e.,\n", " * {@link SecureDirectoryStream} is not supported).\n", " *\n", " * <p>{@link RecursiveDeleteOption#ALLOW_INSECURE} can be used to force the recursive delete method\n", " * to proceed anyway.\n", " *\n", " * @since 21.0\n", " * @author Colin Decker\n", " */\n", "@Beta\n", "@AndroidIncompatible\n", "@GwtIncompatible\n", "@J2ObjCIncompatible // java.nio.file\n", "public final class InsecureRecursiveDeleteException extends FileSystemException {\n", "\n", "  public InsecureRecursiveDeleteException(@Nullable String file) {\n", "    super(file, null, \"unable to guarantee security of recursive delete\");\n", "  }\n", "}\n"]}, "removed": {}, "added_lines": {"1": [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47]}, "removed_lines": {}}, {"162": "guava/src/com/google/common/io/MoreFiles.java", "added": {"1": ["/*\n", " * Copyright (C) 2013 The Guava Authors\n", " *\n", " * Licensed under the Apache License, Version 2.0 (the \"License\");\n", " * you may not use this file except in compliance with the License.\n", " * You may obtain a copy of the License at\n", " *\n", " * http://www.apache.org/licenses/LICENSE-2.0\n", " *\n", " * Unless required by applicable law or agreed to in writing, software\n", " * distributed under the License is distributed on an \"AS IS\" BASIS,\n", " * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n", " * See the License for the specific language governing permissions and\n", " * limitations under the License.\n", " */\n", "\n", "package com.google.common.io;\n", "\n", "import static com.google.common.base.Preconditions.checkNotNull;\n", "import static java.nio.file.LinkOption.NOFOLLOW_LINKS;\n", "\n", "import com.google.common.annotations.Beta;\n", "import com.google.common.annotations.GwtIncompatible;\n", "import com.google.common.base.Optional;\n", "import com.google.common.base.Predicate;\n", "import com.google.common.collect.ImmutableList;\n", "import com.google.common.collect.TreeTraverser;\n", "import com.google.j2objc.annotations.J2ObjCIncompatible;\n", "import java.io.IOException;\n", "import java.io.InputStream;\n", "import java.io.OutputStream;\n", "import java.nio.channels.Channels;\n", "import java.nio.channels.SeekableByteChannel;\n", "import java.nio.charset.Charset;\n", "import java.nio.file.DirectoryIteratorException;\n", "import java.nio.file.DirectoryStream;\n", "import java.nio.file.FileAlreadyExistsException;\n", "import java.nio.file.FileSystemException;\n", "import java.nio.file.Files;\n", "import java.nio.file.LinkOption;\n", "import java.nio.file.NoSuchFileException;\n", "import java.nio.file.NotDirectoryException;\n", "import java.nio.file.OpenOption;\n", "import java.nio.file.Path;\n", "import java.nio.file.SecureDirectoryStream;\n", "import java.nio.file.StandardOpenOption;\n", "import java.nio.file.attribute.BasicFileAttributeView;\n", "import java.nio.file.attribute.BasicFileAttributes;\n", "import java.nio.file.attribute.FileAttribute;\n", "import java.nio.file.attribute.FileTime;\n", "import java.util.ArrayList;\n", "import java.util.Arrays;\n", "import java.util.Collection;\n", "import javax.annotation.Nullable;\n", "\n", "/**\n", " * Static utilities for use with {@link Path} instances, intended to complement {@link Files}.\n", " *\n", " * @since 21.0\n", " * @author Colin Decker\n", " */\n", "@Beta\n", "@AndroidIncompatible\n", "@GwtIncompatible\n", "@J2ObjCIncompatible // java.nio.file\n", "public final class MoreFiles {\n", "\n", "  private MoreFiles() {}\n", "\n", "  /**\n", "   * Returns a view of the given {@code path} as a {@link ByteSource}.\n", "   *\n", "   * <p>Any {@linkplain OpenOption open options} provided are used when opening streams to the file\n", "   * and may affect the behavior of the returned source and the streams it provides. See {@link\n", "   * StandardOpenOption} for the standard options that may be provided. Providing no options is\n", "   * equivalent to providing the {@link StandardOpenOption#READ READ} option.\n", "   */\n", "  public static ByteSource asByteSource(Path path, OpenOption... options) {\n", "    return new PathByteSource(path, options);\n", "  }\n", "\n", "  private static final class PathByteSource extends ByteSource {\n", "\n", "    private static final LinkOption[] FOLLOW_LINKS = {};\n", "\n", "    private final Path path;\n", "    private final OpenOption[] options;\n", "    private final boolean followLinks;\n", "\n", "    private PathByteSource(Path path, OpenOption... options) {\n", "      this.path = checkNotNull(path);\n", "      this.options = options.clone();\n", "      this.followLinks = followLinks(this.options);\n", "      // TODO(cgdecker): validate the provided options... for example, just WRITE seems wrong\n", "    }\n", "\n", "    private static boolean followLinks(OpenOption[] options) {\n", "      for (OpenOption option : options) {\n", "        if (option == NOFOLLOW_LINKS) {\n", "          return false;\n", "        }\n", "      }\n", "      return true;\n", "    }\n", "\n", "    @Override\n", "    public InputStream openStream() throws IOException {\n", "      return Files.newInputStream(path, options);\n", "    }\n", "\n", "    private BasicFileAttributes readAttributes() throws IOException {\n", "      return Files.readAttributes(\n", "          path, BasicFileAttributes.class,\n", "          followLinks ? FOLLOW_LINKS : new LinkOption[] { NOFOLLOW_LINKS });\n", "    }\n", "\n", "    @Override\n", "    public Optional<Long> sizeIfKnown() {\n", "      BasicFileAttributes attrs;\n", "      try {\n", "        attrs = readAttributes();\n", "      } catch (IOException e) {\n", "        // Failed to get attributes; we don't know the size.\n", "        return Optional.absent();\n", "      }\n", "\n", "      // Don't return a size for directories or symbolic links; their sizes are implementation\n", "      // specific and they can't be read as bytes using the read methods anyway.\n", "      if (attrs.isDirectory() || attrs.isSymbolicLink()) {\n", "        return Optional.absent();\n", "      }\n", "\n", "      return Optional.of(attrs.size());\n", "    }\n", "\n", "    @Override\n", "    public long size() throws IOException {\n", "      BasicFileAttributes attrs = readAttributes();\n", "\n", "      // Don't return a size for directories or symbolic links; their sizes are implementation\n", "      // specific and they can't be read as bytes using the read methods anyway.\n", "      if (attrs.isDirectory()) {\n", "        throw new IOException(\"can't read: is a directory\");\n", "      } else if (attrs.isSymbolicLink()) {\n", "        throw new IOException(\"can't read: is a symbolic link\");\n", "      }\n", "\n", "      return attrs.size();\n", "    }\n", "\n", "    @Override\n", "    public byte[] read() throws IOException {\n", "      try (SeekableByteChannel channel = Files.newByteChannel(path, options)) {\n", "        return com.google.common.io.Files.readFile(\n", "            Channels.newInputStream(channel), channel.size());\n", "      }\n", "    }\n", "\n", "    @Override\n", "    public String toString() {\n", "      return \"MoreFiles.asByteSource(\" + path + \", \" + Arrays.toString(options) + \")\";\n", "    }\n", "  }\n", "\n", "  /**\n", "   * Returns a view of the given {@code path} as a {@link ByteSink}.\n", "   *\n", "   * <p>Any {@linkplain OpenOption open options} provided are used when opening streams to the file\n", "   * and may affect the behavior of the returned sink and the streams it provides. See {@link\n", "   * StandardOpenOption} for the standard options that may be provided. Providing no options is\n", "   * equivalent to providing the {@link StandardOpenOption#CREATE CREATE}, {@link\n", "   * StandardOpenOption#TRUNCATE_EXISTING TRUNCATE_EXISTING} and {@link StandardOpenOption#WRITE\n", "   * WRITE} options.\n", "   */\n", "  public static ByteSink asByteSink(Path path, OpenOption... options) {\n", "    return new PathByteSink(path, options);\n", "  }\n", "\n", "  private static final class PathByteSink extends ByteSink {\n", "\n", "    private final Path path;\n", "    private final OpenOption[] options;\n", "\n", "    private PathByteSink(Path path, OpenOption... options) {\n", "      this.path = checkNotNull(path);\n", "      this.options = options.clone();\n", "      // TODO(cgdecker): validate the provided options... for example, just READ seems wrong\n", "    }\n", "\n", "    @Override\n", "    public OutputStream openStream() throws IOException {\n", "      return Files.newOutputStream(path, options);\n", "    }\n", "\n", "    @Override\n", "    public String toString() {\n", "      return \"MoreFiles.asByteSink(\" + path + \", \" + Arrays.toString(options) + \")\";\n", "    }\n", "  }\n", "\n", "  /**\n", "   * Returns a view of the given {@code path} as a {@link CharSource} using the given {@code\n", "   * charset}.\n", "   *\n", "   * <p>Any {@linkplain OpenOption open options} provided are used when opening streams to the file\n", "   * and may affect the behavior of the returned source and the streams it provides. See {@link\n", "   * StandardOpenOption} for the standard options that may be provided. Providing no options is\n", "   * equivalent to providing the {@link StandardOpenOption#READ READ} option.\n", "   */\n", "  public static CharSource asCharSource(Path path, Charset charset, OpenOption... options) {\n", "    return asByteSource(path, options).asCharSource(charset);\n", "  }\n", "\n", "  /**\n", "   * Returns a view of the given {@code path} as a {@link CharSink} using the given {@code\n", "   * charset}.\n", "   *\n", "   * <p>Any {@linkplain OpenOption open options} provided are used when opening streams to the file\n", "   * and may affect the behavior of the returned sink and the streams it provides. See {@link\n", "   * StandardOpenOption} for the standard options that may be provided. Providing no options is\n", "   * equivalent to providing the {@link StandardOpenOption#CREATE CREATE}, {@link\n", "   * StandardOpenOption#TRUNCATE_EXISTING TRUNCATE_EXISTING} and {@link StandardOpenOption#WRITE\n", "   * WRITE} options.\n", "   */\n", "  public static CharSink asCharSink(Path path, Charset charset, OpenOption... options) {\n", "    return asByteSink(path, options).asCharSink(charset);\n", "  }\n", "\n", "  /**\n", "   * Returns an immutable list of paths to the files contained in the given directory.\n", "   *\n", "   * @throws NoSuchFileException if the file does not exist <i>(optional specific exception)</i>\n", "   * @throws NotDirectoryException if the file could not be opened because it is not a directory\n", "   *     <i>(optional specific exception)</i>\n", "   * @throws IOException if an I/O error occurs\n", "   */\n", "  public static ImmutableList<Path> listFiles(Path dir) throws IOException {\n", "    try (DirectoryStream<Path> stream = Files.newDirectoryStream(dir)) {\n", "      return ImmutableList.copyOf(stream);\n", "    } catch (DirectoryIteratorException e) {\n", "      throw e.getCause();\n", "    }\n", "  }\n", "\n", "  /**\n", "   * Returns a {@link TreeTraverser} for traversing a directory tree. The returned traverser\n", "   * attempts to avoid following symbolic links to directories. However, the traverser cannot\n", "   * guarantee that it will not follow symbolic links to directories as it is possible for a\n", "   * directory to be replaced with a symbolic link between checking if the file is a directory and\n", "   * actually reading the contents of that directory.\n", "   *\n", "   * <p>Note that if the {@link Path} passed to one of the traversal methods does not exist, no\n", "   * exception will be thrown and the returned {@link Iterable} will contain a single element: that\n", "   * path.\n", "   *\n", "   * <p>{@link DirectoryIteratorException}  may be thrown when iterating {@link Iterable} instances\n", "   * created by this traverser if an {@link IOException} is thrown by a call to\n", "   * {@link #listFiles(Path)}.\n", "   */\n", "  public static TreeTraverser<Path> directoryTreeTraverser() {\n", "    return DirectoryTreeTraverser.INSTANCE;\n", "  }\n", "\n", "  private static final class DirectoryTreeTraverser extends TreeTraverser<Path> {\n", "\n", "    private static final DirectoryTreeTraverser INSTANCE = new DirectoryTreeTraverser();\n", "\n", "    @Override\n", "    public Iterable<Path> children(Path dir) {\n", "      if (Files.isDirectory(dir, NOFOLLOW_LINKS)) {\n", "        try {\n", "          return listFiles(dir);\n", "        } catch (IOException e) {\n", "          // the exception thrown when iterating a DirectoryStream if an I/O exception occurs\n", "          throw new DirectoryIteratorException(e);\n", "        }\n", "      }\n", "      return ImmutableList.of();\n", "    }\n", "  }\n", "\n", "  /**\n", "   * Returns a predicate that returns the result of {@link Files#isDirectory(Path, LinkOption...)}\n", "   * on input paths with the given link options.\n", "   */\n", "  public static Predicate<Path> isDirectory(LinkOption... options) {\n", "    final LinkOption[] optionsCopy = options.clone();\n", "    return new Predicate<Path>() {\n", "      @Override\n", "      public boolean apply(Path input) {\n", "        return Files.isDirectory(input, optionsCopy);\n", "      }\n", "\n", "      @Override\n", "      public String toString() {\n", "        return \"MoreFiles.isDirectory(\" + Arrays.toString(optionsCopy) + \")\";\n", "      }\n", "    };\n", "  }\n", "\n", "  /**\n", "   * Returns a predicate that returns the result of\n", "   * {@link Files#isRegularFile(Path, LinkOption...)} on input paths with the given link options.\n", "   */\n", "  public static Predicate<Path> isRegularFile(LinkOption... options) {\n", "    final LinkOption[] optionsCopy = options.clone();\n", "    return new Predicate<Path>() {\n", "      @Override\n", "      public boolean apply(Path input) {\n", "        return Files.isRegularFile(input, optionsCopy);\n", "      }\n", "\n", "      @Override\n", "      public String toString() {\n", "        return \"MoreFiles.isRegularFile(\" + Arrays.toString(optionsCopy) + \")\";\n", "      }\n", "    };\n", "  }\n", "\n", "  /**\n", "   * Like the unix command of the same name, creates an empty file or updates the last modified\n", "   * timestamp of the existing file at the given path to the current system time.\n", "   */\n", "  public static void touch(Path path) throws IOException {\n", "    checkNotNull(path);\n", "\n", "    try {\n", "      Files.setLastModifiedTime(path, FileTime.fromMillis(System.currentTimeMillis()));\n", "    } catch (NoSuchFileException e) {\n", "      try {\n", "        Files.createFile(path);\n", "      } catch (FileAlreadyExistsException ignore) {\n", "        // The file didn't exist when we called setLastModifiedTime, but it did when we called\n", "        // createFile, so something else created the file in between. The end result is\n", "        // what we wanted: a new file that probably has its last modified time set to approximately\n", "        // now. Or it could have an arbitrary last modified time set by the creator, but that's no\n", "        // different than if another process set its last modified time to something else after we\n", "        // created it here.\n", "      }\n", "    }\n", "  }\n", "\n", "  /**\n", "   * Creates any necessary but nonexistent parent directories of the specified path. Note that if\n", "   * this operation fails, it may have succeeded in creating some (but not all) of the necessary\n", "   * parent directories. The parent directory is created with the given {@code attrs}.\n", "   *\n", "   * @throws IOException if an I/O error occurs, or if any necessary but nonexistent parent\n", "   *                     directories of the specified file could not be created.\n", "   */\n", "  public static void createParentDirectories(\n", "      Path path, FileAttribute<?>... attrs) throws IOException {\n", "    // Interestingly, unlike File.getCanonicalFile(), Path/Files provides no way of getting the\n", "    // canonical (absolute, normalized, symlinks resolved, etc.) form of a path to a nonexistent\n", "    // file. getCanonicalFile() can at least get the canonical form of the part of the path which\n", "    // actually exists and then append the normalized remainder of the path to that.\n", "    Path normalizedAbsolutePath = path.toAbsolutePath().normalize();\n", "    Path parent = normalizedAbsolutePath.getParent();\n", "    if (parent == null) {\n", "       // The given directory is a filesystem root. All zero of its ancestors exist. This doesn't\n", "       // mean that the root itself exists -- consider x:\\ on a Windows machine without such a\n", "       // drive -- or even that the caller can create it, but this method makes no such guarantees\n", "       // even for non-root files.\n", "      return;\n", "    }\n", "\n", "    // Check if the parent is a directory first because createDirectories will fail if the parent\n", "    // exists and is a symlink to a directory... we'd like for this to succeed in that case.\n", "    // (I'm kind of surprised that createDirectories would fail in that case; doesn't seem like\n", "    // what you'd want to happen.)\n", "    if (!Files.isDirectory(parent)) {\n", "      Files.createDirectories(parent, attrs);\n", "      if (!Files.isDirectory(parent)) {\n", "        throw new IOException(\"Unable to create parent directories of \" + path);\n", "      }\n", "    }\n", "  }\n", "\n", "  /**\n", "   * Returns the <a href=\"http://en.wikipedia.org/wiki/Filename_extension\">file extension</a> for\n", "   * the file at the given path, or the empty string if the file has no extension. The result does\n", "   * not include the '{@code .}'.\n", "   */\n", "  public static String getFileExtension(Path path) {\n", "    Path name = path.getFileName();\n", "\n", "    // null for empty paths and root-only paths\n", "    if (name == null) {\n", "      return \"\";\n", "    }\n", "\n", "    String fileName = name.toString();\n", "    int dotIndex = fileName.lastIndexOf('.');\n", "    return dotIndex == -1 ? \"\" : fileName.substring(dotIndex + 1);\n", "  }\n", "\n", "  /**\n", "   * Returns the file name without its\n", "   * <a href=\"http://en.wikipedia.org/wiki/Filename_extension\">file extension</a> or path. This is\n", "   * similar to the {@code basename} unix command. The result does not include the '{@code .}'.\n", "   */\n", "  public static String getNameWithoutExtension(Path path) {\n", "    Path name = path.getFileName();\n", "\n", "    // null for empty paths and root-only paths\n", "    if (name == null) {\n", "      return \"\";\n", "    }\n", "\n", "    String fileName = name.toString();\n", "    int dotIndex = fileName.lastIndexOf('.');\n", "    return dotIndex == -1 ? fileName : fileName.substring(0, dotIndex);\n", "  }\n", "\n", "  /**\n", "   * Deletes the file or directory at the given {@code path} recursively. Deletes symbolic links,\n", "   * not their targets (subject to the caveat below).\n", "   *\n", "   * <p>If an I/O exception occurs attempting to read, open or delete any file under the given\n", "   * directory, this method skips that file and continues. All such exceptions are collected and,\n", "   * after attempting to delete all files, an {@code IOException} is thrown containing those\n", "   * exceptions as {@linkplain Throwable#getSuppressed() suppressed exceptions}.\n", "   *\n", "   * <h2>Warning: Security of recursive deletes</h2>\n", "   *\n", "   * <p>On a file system that supports symbolic links and does <i>not</i> support\n", "   * {@link SecureDirectoryStream}, it is possible for a recursive delete to delete files and\n", "   * directories that are <i>outside</i> the directory being deleted. This can happen if, after\n", "   * checking that a file is a directory (and not a symbolic link), that directory is replaced by a\n", "   * symbolic link to an outside directory before the call that opens the directory to read its\n", "   * entries.\n", "   *\n", "   * <p>By default, this method throws {@link InsecureRecursiveDeleteException} if it can't\n", "   * guarantee the security of recursive deletes. If you wish to allow the recursive deletes\n", "   * anyway, pass {@link RecursiveDeleteOption#ALLOW_INSECURE} to this method to override that\n", "   * behavior.\n", "   *\n", "   * @throws NoSuchFileException if {@code path} does not exist <i>(optional specific\n", "   *     exception)</i>\n", "   * @throws InsecureRecursiveDeleteException if the security of recursive deletes can't be\n", "   *     guaranteed for the file system and {@link RecursiveDeleteOption#ALLOW_INSECURE} was not\n", "   *     specified\n", "   * @throws IOException if {@code path} or any file in the subtree rooted at it can't be deleted\n", "   *     for any reason\n", "   */\n", "  public static void deleteRecursively(\n", "      Path path, RecursiveDeleteOption... options) throws IOException {\n", "    Path parentPath = getParentPath(path);\n", "    if (parentPath == null) {\n", "      throw new FileSystemException(path.toString(), null, \"can't delete recursively\");\n", "    }\n", "\n", "    Collection<IOException> exceptions = null; // created lazily if needed\n", "    try {\n", "      boolean sdsSupported = false;\n", "      try (DirectoryStream<Path> parent = Files.newDirectoryStream(parentPath)) {\n", "        if (parent instanceof SecureDirectoryStream) {\n", "          sdsSupported = true;\n", "          exceptions = deleteRecursivelySecure(\n", "              (SecureDirectoryStream<Path>) parent, path.getFileName());\n", "        }\n", "      }\n", "\n", "      if (!sdsSupported) {\n", "        checkAllowsInsecure(path, options);\n", "        exceptions = deleteRecursivelyInsecure(path);\n", "      }\n", "    } catch (IOException e) {\n", "      if (exceptions == null) {\n", "        throw e;\n", "      } else {\n", "        exceptions.add(e);\n", "      }\n", "    }\n", "\n", "    if (exceptions != null) {\n", "      throwDeleteFailed(path, exceptions);\n", "    }\n", "  }\n", "\n", "  /**\n", "   * Deletes all files within the directory at the given {@code path}\n", "   * {@linkplain #deleteRecursively recursively}. Does not delete the directory itself. Deletes\n", "   * symbolic links, not their targets (subject to the caveat below). If {@code path} itself is\n", "   * a symbolic link to a directory, that link is followed and the contents of the directory it\n", "   * targets are deleted.\n", "   *\n", "   * <p>If an I/O exception occurs attempting to read, open or delete any file under the given\n", "   * directory, this method skips that file and continues. All such exceptions are collected and,\n", "   * after attempting to delete all files, an {@code IOException} is thrown containing those\n", "   * exceptions as {@linkplain Throwable#getSuppressed() suppressed exceptions}.\n", "   *\n", "   * <h2>Warning: Security of recursive deletes</h2>\n", "   *\n", "   * <p>On a file system that supports symbolic links and does <i>not</i> support\n", "   * {@link SecureDirectoryStream}, it is possible for a recursive delete to delete files and\n", "   * directories that are <i>outside</i> the directory being deleted. This can happen if, after\n", "   * checking that a file is a directory (and not a symbolic link), that directory is replaced by a\n", "   * symbolic link to an outside directory before the call that opens the directory to read its\n", "   * entries.\n", "   *\n", "   * <p>By default, this method throws {@link InsecureRecursiveDeleteException} if it can't\n", "   * guarantee the security of recursive deletes. If you wish to allow the recursive deletes\n", "   * anyway, pass {@link RecursiveDeleteOption#ALLOW_INSECURE} to this method to override that\n", "   * behavior.\n", "   *\n", "   * @throws NoSuchFileException if {@code path} does not exist <i>(optional specific\n", "   *     exception)</i>\n", "   * @throws NotDirectoryException if the file at {@code path} is not a directory <i>(optional\n", "   *     specific exception)</i>\n", "   * @throws InsecureRecursiveDeleteException if the security of recursive deletes can't be\n", "   *     guaranteed for the file system and {@link RecursiveDeleteOption#ALLOW_INSECURE} was not\n", "   *     specified\n", "   * @throws IOException if one or more files can't be deleted for any reason\n", "   */\n", "  public static void deleteDirectoryContents(\n", "      Path path, RecursiveDeleteOption... options) throws IOException {\n", "    Collection<IOException> exceptions = null; // created lazily if needed\n", "    try (DirectoryStream<Path> stream = Files.newDirectoryStream(path)) {\n", "      if (stream instanceof SecureDirectoryStream) {\n", "        SecureDirectoryStream<Path> sds = (SecureDirectoryStream<Path>) stream;\n", "        exceptions = deleteDirectoryContentsSecure(sds);\n", "      } else {\n", "        checkAllowsInsecure(path, options);\n", "        exceptions = deleteDirectoryContentsInsecure(stream);\n", "      }\n", "    } catch (IOException e) {\n", "      if (exceptions == null) {\n", "        throw e;\n", "      } else {\n", "        exceptions.add(e);\n", "      }\n", "    }\n", "\n", "    if (exceptions != null) {\n", "      throwDeleteFailed(path, exceptions);\n", "    }\n", "  }\n", "\n", "  /**\n", "   * Secure recursive delete using {@code SecureDirectoryStream}. Returns a collection of\n", "   * exceptions that occurred or null if no exceptions were thrown.\n", "   */\n", "  @Nullable\n", "  private static Collection<IOException> deleteRecursivelySecure(\n", "      SecureDirectoryStream<Path> dir, Path path) {\n", "    Collection<IOException> exceptions = null;\n", "    try {\n", "      if (isDirectory(dir, path, NOFOLLOW_LINKS)) {\n", "        try (SecureDirectoryStream<Path> childDir = dir.newDirectoryStream(path, NOFOLLOW_LINKS)) {\n", "          exceptions = deleteDirectoryContentsSecure(childDir);\n", "        }\n", "\n", "        // If exceptions is not null, something went wrong trying to delete the contents of the\n", "        // directory, so we shouldn't try to delete the directory as it will probably fail.\n", "        if (exceptions == null) {\n", "          dir.deleteDirectory(path);\n", "        }\n", "      } else {\n", "        dir.deleteFile(path);\n", "      }\n", "\n", "      return exceptions;\n", "    } catch (IOException e) {\n", "      return addException(exceptions, e);\n", "    }\n", "  }\n", "\n", "  /**\n", "   * Secure method for deleting the contents of a directory using {@code SecureDirectoryStream}.\n", "   * Returns a collection of exceptions that occurred or null if no exceptions were thrown.\n", "   */\n", "  @Nullable\n", "  private static Collection<IOException> deleteDirectoryContentsSecure(\n", "      SecureDirectoryStream<Path> dir) {\n", "    Collection<IOException> exceptions = null;\n", "    try {\n", "      for (Path path : dir) {\n", "        exceptions = concat(exceptions, deleteRecursivelySecure(dir, path.getFileName()));\n", "      }\n", "\n", "      return exceptions;\n", "    } catch (DirectoryIteratorException e) {\n", "      return addException(exceptions, e.getCause());\n", "    }\n", "  }\n", "\n", "  /**\n", "   * Insecure recursive delete for file systems that don't support {@code SecureDirectoryStream}.\n", "   * Returns a collection of exceptions that occurred or null if no exceptions were thrown.\n", "   */\n", "  @Nullable\n", "  private static Collection<IOException> deleteRecursivelyInsecure(Path path) {\n", "    Collection<IOException> exceptions = null;\n", "    try {\n", "      if (Files.isDirectory(path, NOFOLLOW_LINKS)) {\n", "        try (DirectoryStream<Path> stream = Files.newDirectoryStream(path)) {\n", "          exceptions = deleteDirectoryContentsInsecure(stream);\n", "        }\n", "      }\n", "\n", "      // If exceptions is not null, something went wrong trying to delete the contents of the\n", "      // directory, so we shouldn't try to delete the directory as it will probably fail.\n", "      if (exceptions == null) {\n", "        Files.delete(path);\n", "      }\n", "\n", "      return exceptions;\n", "    } catch (IOException e) {\n", "      return addException(exceptions, e);\n", "    }\n", "  }\n", "\n", "  /**\n", "   * Simple, insecure method for deleting the contents of a directory for file systems that don't\n", "   * support {@code SecureDirectoryStream}. Returns a collection of exceptions that occurred or\n", "   * null if no exceptions were thrown.\n", "   */\n", "  @Nullable\n", "  private static Collection<IOException> deleteDirectoryContentsInsecure(\n", "      DirectoryStream<Path> dir) {\n", "    Collection<IOException> exceptions = null;\n", "    try {\n", "      for (Path entry : dir) {\n", "        exceptions = concat(exceptions, deleteRecursivelyInsecure(entry));\n", "      }\n", "\n", "      return exceptions;\n", "    } catch (DirectoryIteratorException e) {\n", "      return addException(exceptions, e.getCause());\n", "    }\n", "  }\n", "\n", "  /**\n", "   * Returns a path to the parent directory of the given path. If the path actually has a parent\n", "   * path, this is simple. Otherwise, we need to do some trickier things. Returns null if the path\n", "   * is a root or is the empty path.\n", "   */\n", "  @Nullable\n", "  private static Path getParentPath(Path path) throws IOException {\n", "    Path parent = path.getParent();\n", "\n", "    // Paths that have a parent:\n", "    if (parent != null) {\n", "      // \"/foo\" (\"/\")\n", "      // \"foo/bar\" (\"foo\")\n", "      // \"C:\\foo\" (\"C:\\\")\n", "      // \"\\foo\" (\"\\\" - current drive for process on Windows)\n", "      // \"C:foo\" (\"C:\" - working dir of drive C on Windows)\n", "      return parent;\n", "    }\n", "\n", "    // Paths that don't have a parent:\n", "    if (path.getNameCount() == 0) {\n", "      // \"/\", \"C:\\\", \"\\\" (no parent)\n", "      // \"\" (undefined, though typically parent of working dir)\n", "      // \"C:\" (parent of working dir of drive C on Windows)\n", "      //\n", "      // For working dir paths (\"\" and \"C:\"), return null because:\n", "      //   A) it's not specified that \"\" is the path to the working directory.\n", "      //   B) if we're getting this path for recursive delete, it's typically not possible to\n", "      //      delete the working dir with a relative path anyway, so it's ok to fail.\n", "      //   C) if we're getting it for opening a new SecureDirectoryStream, there's no need to get\n", "      //      the parent path anyway since we can safely open a DirectoryStream to the path without\n", "      //      worrying about a symlink.\n", "      return null;\n", "    } else {\n", "      // \"foo\" (working dir)\n", "      return path.getFileSystem().getPath(\".\");\n", "    }\n", "  }\n", "\n", "  /**\n", "   * Checks that the given options allow an insecure delete, throwing an exception if not.\n", "   */\n", "  private static void checkAllowsInsecure(\n", "      Path path, RecursiveDeleteOption[] options) throws InsecureRecursiveDeleteException {\n", "    if (!Arrays.asList(options).contains(RecursiveDeleteOption.ALLOW_INSECURE)) {\n", "      throw new InsecureRecursiveDeleteException(path.toString());\n", "    }\n", "  }\n", "\n", "  /**\n", "   * Returns whether or not the file with the given name in the given dir is a directory.\n", "   */\n", "  private static boolean isDirectory(\n", "      SecureDirectoryStream<Path> dir, Path name, LinkOption... options) throws IOException {\n", "    return dir.getFileAttributeView(name, BasicFileAttributeView.class, options)\n", "        .readAttributes()\n", "        .isDirectory();\n", "  }\n", "\n", "  /**\n", "   * Adds the given exception to the given collection, creating the collection if it's null.\n", "   * Returns the collection.\n", "   */\n", "  private static Collection<IOException> addException(\n", "      @Nullable Collection<IOException> exceptions, IOException e) {\n", "    if (exceptions == null) {\n", "      exceptions = new ArrayList<>(); // don't need Set semantics\n", "    }\n", "    exceptions.add(e);\n", "    return exceptions;\n", "  }\n", "\n", "  /**\n", "   * Concatenates the contents of the two given collections of exceptions. If either collection is\n", "   * null, the other collection is returned. Otherwise, the elements of {@code other} are added to\n", "   * {@code exceptions} and {@code exceptions} is returned.\n", "   */\n", "  @Nullable\n", "  private static Collection<IOException> concat(\n", "      @Nullable Collection<IOException> exceptions, @Nullable Collection<IOException> other) {\n", "    if (exceptions == null) {\n", "      return other;\n", "    } else if (other != null) {\n", "      exceptions.addAll(other);\n", "    }\n", "    return exceptions;\n", "  }\n", "\n", "  /**\n", "   * Throws an exception indicating that one or more files couldn't be deleted. The thrown\n", "   * exception contains all the exceptions in the given collection as suppressed exceptions.\n", "   */\n", "  private static void throwDeleteFailed(\n", "      Path path, Collection<IOException> exceptions) throws FileSystemException {\n", "    // TODO(cgdecker): Should there be a custom exception type for this?\n", "    // Also, should we try to include the Path of each file we may have failed to delete rather\n", "    // than just the exceptions that occurred?\n", "    FileSystemException deleteFailed = new FileSystemException(path.toString(), null,\n", "        \"failed to delete one or more files; see suppressed exceptions for details\");\n", "    for (IOException e : exceptions) {\n", "      deleteFailed.addSuppressed(e);\n", "    }\n", "    throw deleteFailed;\n", "  }\n", "}\n"]}, "removed": {}, "added_lines": {"1": [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 58, 59, 60, 61, 62, 63, 64, 65, 66, 67, 68, 69, 70, 71, 72, 73, 74, 75, 76, 77, 78, 79, 80, 81, 82, 83, 84, 85, 86, 87, 88, 89, 90, 91, 92, 93, 94, 95, 96, 97, 98, 99, 100, 101, 102, 103, 104, 105, 106, 107, 108, 109, 110, 111, 112, 113, 114, 115, 116, 117, 118, 119, 120, 121, 122, 123, 124, 125, 126, 127, 128, 129, 130, 131, 132, 133, 134, 135, 136, 137, 138, 139, 140, 141, 142, 143, 144, 145, 146, 147, 148, 149, 150, 151, 152, 153, 154, 155, 156, 157, 158, 159, 160, 161, 162, 163, 164, 165, 166, 167, 168, 169, 170, 171, 172, 173, 174, 175, 176, 177, 178, 179, 180, 181, 182, 183, 184, 185, 186, 187, 188, 189, 190, 191, 192, 193, 194, 195, 196, 197, 198, 199, 200, 201, 202, 203, 204, 205, 206, 207, 208, 209, 210, 211, 212, 213, 214, 215, 216, 217, 218, 219, 220, 221, 222, 223, 224, 225, 226, 227, 228, 229, 230, 231, 232, 233, 234, 235, 236, 237, 238, 239, 240, 241, 242, 243, 244, 245, 246, 247, 248, 249, 250, 251, 252, 253, 254, 255, 256, 257, 258, 259, 260, 261, 262, 263, 264, 265, 266, 267, 268, 269, 270, 271, 272, 273, 274, 275, 276, 277, 278, 279, 280, 281, 282, 283, 284, 285, 286, 287, 288, 289, 290, 291, 292, 293, 294, 295, 296, 297, 298, 299, 300, 301, 302, 303, 304, 305, 306, 307, 308, 309, 310, 311, 312, 313, 314, 315, 316, 317, 318, 319, 320, 321, 322, 323, 324, 325, 326, 327, 328, 329, 330, 331, 332, 333, 334, 335, 336, 337, 338, 339, 340, 341, 342, 343, 344, 345, 346, 347, 348, 349, 350, 351, 352, 353, 354, 355, 356, 357, 358, 359, 360, 361, 362, 363, 364, 365, 366, 367, 368, 369, 370, 371, 372, 373, 374, 375, 376, 377, 378, 379, 380, 381, 382, 383, 384, 385, 386, 387, 388, 389, 390, 391, 392, 393, 394, 395, 396, 397, 398, 399, 400, 401, 402, 403, 404, 405, 406, 407, 408, 409, 410, 411, 412, 413, 414, 415, 416, 417, 418, 419, 420, 421, 422, 423, 424, 425, 426, 427, 428, 429, 430, 431, 432, 433, 434, 435, 436, 437, 438, 439, 440, 441, 442, 443, 444, 445, 446, 447, 448, 449, 450, 451, 452, 453, 454, 455, 456, 457, 458, 459, 460, 461, 462, 463, 464, 465, 466, 467, 468, 469, 470, 471, 472, 473, 474, 475, 476, 477, 478, 479, 480, 481, 482, 483, 484, 485, 486, 487, 488, 489, 490, 491, 492, 493, 494, 495, 496, 497, 498, 499, 500, 501, 502, 503, 504, 505, 506, 507, 508, 509, 510, 511, 512, 513, 514, 515, 516, 517, 518, 519, 520, 521, 522, 523, 524, 525, 526, 527, 528, 529, 530, 531, 532, 533, 534, 535, 536, 537, 538, 539, 540, 541, 542, 543, 544, 545, 546, 547, 548, 549, 550, 551, 552, 553, 554, 555, 556, 557, 558, 559, 560, 561, 562, 563, 564, 565, 566, 567, 568, 569, 570, 571, 572, 573, 574, 575, 576, 577, 578, 579, 580, 581, 582, 583, 584, 585, 586, 587, 588, 589, 590, 591, 592, 593, 594, 595, 596, 597, 598, 599, 600, 601, 602, 603, 604, 605, 606, 607, 608, 609, 610, 611, 612, 613, 614, 615, 616, 617, 618, 619, 620, 621, 622, 623, 624, 625, 626, 627, 628, 629, 630, 631, 632, 633, 634, 635, 636, 637, 638, 639, 640, 641, 642, 643, 644, 645, 646, 647, 648, 649, 650, 651, 652, 653, 654, 655, 656, 657, 658, 659, 660, 661, 662, 663, 664, 665, 666, 667, 668, 669, 670, 671, 672, 673, 674, 675, 676, 677, 678, 679, 680, 681, 682, 683, 684, 685, 686, 687, 688, 689, 690, 691, 692, 693, 694, 695, 696, 697, 698, 699, 700, 701, 702, 703, 704, 705, 706, 707, 708, 709, 710, 711, 712, 713, 714, 715, 716, 717, 718, 719, 720, 721, 722, 723, 724, 725, 726, 727, 728, 729, 730, 731, 732, 733, 734, 735, 736, 737, 738]}, "removed_lines": {}}, {"163": "guava/src/com/google/common/io/RecursiveDeleteOption.java", "added": {"1": ["/*\n", " * Copyright (C) 2014 The Guava Authors\n", " *\n", " * Licensed under the Apache License, Version 2.0 (the \"License\");\n", " * you may not use this file except in compliance with the License.\n", " * You may obtain a copy of the License at\n", " *\n", " * http://www.apache.org/licenses/LICENSE-2.0\n", " *\n", " * Unless required by applicable law or agreed to in writing, software\n", " * distributed under the License is distributed on an \"AS IS\" BASIS,\n", " * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n", " * See the License for the specific language governing permissions and\n", " * limitations under the License.\n", " */\n", "\n", "package com.google.common.io;\n", "\n", "import com.google.common.annotations.Beta;\n", "import com.google.common.annotations.GwtIncompatible;\n", "import com.google.j2objc.annotations.J2ObjCIncompatible;\n", "import java.nio.file.SecureDirectoryStream;\n", "\n", "/**\n", " * Options for use with recursive delete methods ({@link MoreFiles#deleteRecursively} and\n", " * {@link MoreFiles#deleteDirectoryContents}).\n", " *\n", " * @since 21.0\n", " * @author Colin Decker\n", " */\n", "@Beta\n", "@AndroidIncompatible\n", "@GwtIncompatible\n", "@J2ObjCIncompatible // java.nio.file\n", "public enum RecursiveDeleteOption {\n", "  /**\n", "   * Specifies that the recursive delete should not throw an exception when it can't be guaranteed\n", "   * that it can be done securely, without vulnerability to race conditions (i.e. when the file\n", "   * system does not support {@link SecureDirectoryStream}).\n", "   *\n", "   * <p><b>Warning:</b> On a file system that supports symbolic links, it is possible for an\n", "   * insecure recursive delete to delete files and directories that are <i>outside</i> the\n", "   * directory being deleted. This can happen if, after checking that a file is a directory (and\n", "   * not a symbolic link), that directory is deleted and replaced by a symbolic link to an outside\n", "   * directory before the call that opens the directory to read its entries. File systems that\n", "   * support {@code SecureDirectoryStream} do not have this vulnerability.\n", "   */\n", "  ALLOW_INSECURE\n", "}\n"]}, "removed": {}, "added_lines": {"1": [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 49]}, "removed_lines": {}}, {"164": "guava/src/com/google/common/util/concurrent/AsyncFunction.java", "added": {"1": ["@FunctionalInterface\n"]}, "removed": {}, "added_lines": {"1": [29]}, "removed_lines": {}}, {"165": "guava/src/com/google/common/util/concurrent/AtomicLongMap.java", "added": {"1": [" * Licensed under the Apache License, Version 2.0 (the \"License\");\n", " * you may not use this file except in compliance with the License.\n", " * You may obtain a copy of the License at\n", " * Unless required by applicable law or agreed to in writing, software\n", " * distributed under the License is distributed on an \"AS IS\" BASIS,\n", " * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n", " * See the License for the specific language governing permissions and\n", " * limitations under the License.\n"], "2": ["import java.util.concurrent.atomic.AtomicBoolean;\n", "import java.util.function.LongBinaryOperator;\n", "import java.util.function.LongUnaryOperator;\n"], "3": [" * documented. Exceptions to this are {@link #containsKey}, {@link #size}, {@link #isEmpty},\n", " * {@link #asMap}, and {@link #toString}.\n", " * {@link com.google.common.collect.Multiset} such as\n", " * {@link com.google.common.collect.ConcurrentHashMultiset} instead.\n"], "4": ["  private final ConcurrentHashMap<K, Long> map;\n", "  private AtomicLongMap(ConcurrentHashMap<K, Long> map) {\n"], "5": ["    return new AtomicLongMap<K>(new ConcurrentHashMap<>());\n"], "6": ["    return map.getOrDefault(key, 0L);\n"], "7": ["    return accumulateAndGet(key, delta, Long::sum);\n"], "8": ["    return getAndAccumulate(key, delta, Long::sum);\n", "  }\n", "\n", "  /**\n", "   * Updates the value currently associated with {@code key} with the specified function,\n", "   * and returns the new value.  If there is not currently a value associated with {@code key},\n", "   * the function is applied to {@code 0L}.\n", "   *\n", "   * @since 21.0\n", "   */\n", "  @CanIgnoreReturnValue\n", "  public long updateAndGet(K key, LongUnaryOperator updaterFunction) {\n", "    checkNotNull(updaterFunction);\n", "    return map.compute(\n", "        key, (k, value) -> updaterFunction.applyAsLong((value == null) ? 0L : value.longValue()));\n", "  }\n", "\n", "  /**\n", "   * Updates the value currently associated with {@code key} with the specified function,\n", "   * and returns the old value.  If there is not currently a value associated with {@code key},\n", "   * the function is applied to {@code 0L}.\n", "   *\n", "   * @since 21.0\n", "   */\n", "  @CanIgnoreReturnValue\n", "  public long getAndUpdate(K key, LongUnaryOperator updaterFunction) {\n", "    checkNotNull(updaterFunction);\n", "    AtomicLong holder = new AtomicLong();\n", "    map.compute(\n", "        key,\n", "        (k, value) -> {\n", "          long oldValue = (value == null) ? 0L : value.longValue();\n", "          holder.set(oldValue);\n", "          return updaterFunction.applyAsLong(oldValue);\n", "        });\n", "    return holder.get();\n", "  }\n", "\n", "  /**\n", "   * Updates the value currently associated with {@code key} by combining it with {@code x}\n", "   * via the specified accumulator function, returning the new value.  The previous value\n", "   * associated with {@code key} (or zero, if there is none) is passed as the first argument\n", "   * to {@code accumulatorFunction}, and {@code x} is passed as the second argument.\n", "   *\n", "   * @since 21.0\n", "   */\n", "  @CanIgnoreReturnValue\n", "  public long accumulateAndGet(K key, long x, LongBinaryOperator accumulatorFunction) {\n", "    checkNotNull(accumulatorFunction);\n", "    return updateAndGet(key, oldValue -> accumulatorFunction.applyAsLong(oldValue, x));\n", "  }\n", "\n", "  /**\n", "   * Updates the value currently associated with {@code key} by combining it with {@code x}\n", "   * via the specified accumulator function, returning the old value.  The previous value\n", "   * associated with {@code key} (or zero, if there is none) is passed as the first argument\n", "   * to {@code accumulatorFunction}, and {@code x} is passed as the second argument.\n", "   *\n", "   * @since 21.0\n", "   */\n", "  @CanIgnoreReturnValue\n", "  public long getAndAccumulate(K key, long x, LongBinaryOperator accumulatorFunction) {\n", "    checkNotNull(accumulatorFunction);\n", "    return getAndUpdate(key, oldValue -> accumulatorFunction.applyAsLong(oldValue, x));\n"], "9": ["    return getAndUpdate(key, x -> newValue);\n"], "10": ["    m.forEach(this::put);\n", "   * Removes and returns the value associated with {@code key}. If {@code key} is not\n", "   * in the map, this method has no effect and returns zero.\n", "    Long result = map.remove(key);\n", "    return (result == null) ? 0L : result.longValue();\n"], "11": ["   * <p>This method is not atomic: the map may be visible in intermediate states, where some\n", "   * of the zero values have been removed and others have not.\n", "    map.values().removeIf(x -> x == 0);\n"], "12": ["    return map.values().stream().mapToLong(Long::longValue).sum();\n"], "13": ["    return Collections.unmodifiableMap(map);\n"], "14": ["   * Returns the number of key-value mappings in this map. If the map contains more than\n", "   * {@code Integer.MAX_VALUE} elements, returns {@code Integer.MAX_VALUE}.\n"], "15": ["   * zero, associate it with {@code newValue}. Returns the previous value associated with\n", "   * {@code key}, or zero if there was no mapping for {@code key}.\n", "    AtomicBoolean noValue = new AtomicBoolean(false);\n", "    Long result =\n", "        map.compute(\n", "            key,\n", "            (k, oldValue) -> {\n", "              if (oldValue == null || oldValue == 0) {\n", "                noValue.set(true);\n", "                return newValue;\n", "              } else {\n", "                return oldValue;\n", "              }\n", "            });\n", "    return noValue.get() ? 0L : result.longValue();\n", "   * If {@code (key, expectedOldValue)} is currently in the map, this method replaces\n", "   * {@code expectedOldValue} with {@code newValue} and returns true; otherwise, this method\n", "   * returns false.\n", "   * <p>If {@code expectedOldValue} is zero, this method will succeed if {@code (key, zero)}\n", "   * is currently in the map, or if {@code key} is not in the map at all.\n", "      return map.replace(key, expectedOldValue, newValue);\n", "   * If {@code (key, value)} is currently in the map, this method removes it and returns\n", "   * true; otherwise, this method returns false.\n", "    return map.remove(key, value);\n"]}, "removed": {"1": [" * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not use this file except\n", " * in compliance with the License. You may obtain a copy of the License at\n", " * Unless required by applicable law or agreed to in writing, software distributed under the License\n", " * is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express\n", " * or implied. See the License for the specific language governing permissions and limitations under\n", " * the License.\n"], "2": ["import com.google.common.base.Function;\n", "import com.google.common.collect.Maps;\n", "import java.util.Iterator;\n"], "3": [" * documented. Exceptions to this are {@link #containsKey}, {@link #size}, {@link #isEmpty}, {@link\n", " * #asMap}, and {@link #toString}.\n", " * {@link com.google.common.collect.Multiset} such as {@link\n", " * com.google.common.collect.ConcurrentHashMultiset} instead.\n"], "4": ["  private final ConcurrentHashMap<K, AtomicLong> map;\n", "  private AtomicLongMap(ConcurrentHashMap<K, AtomicLong> map) {\n"], "5": ["    return new AtomicLongMap<K>(new ConcurrentHashMap<K, AtomicLong>());\n"], "6": ["    AtomicLong atomic = map.get(key);\n", "    return atomic == null ? 0L : atomic.get();\n"], "7": ["    outer:\n", "    while (true) {\n", "      AtomicLong atomic = map.get(key);\n", "      if (atomic == null) {\n", "        atomic = map.putIfAbsent(key, new AtomicLong(delta));\n", "        if (atomic == null) {\n", "          return delta;\n", "        }\n", "        // atomic is now non-null; fall through\n", "      }\n", "\n", "      while (true) {\n", "        long oldValue = atomic.get();\n", "        if (oldValue == 0L) {\n", "          // don't compareAndSet a zero\n", "          if (map.replace(key, atomic, new AtomicLong(delta))) {\n", "            return delta;\n", "          }\n", "          // atomic replaced\n", "          continue outer;\n", "        }\n", "\n", "        long newValue = oldValue + delta;\n", "        if (atomic.compareAndSet(oldValue, newValue)) {\n", "          return newValue;\n", "        }\n", "        // value changed\n", "      }\n", "    }\n"], "8": ["    outer:\n", "    while (true) {\n", "      AtomicLong atomic = map.get(key);\n", "      if (atomic == null) {\n", "        atomic = map.putIfAbsent(key, new AtomicLong(delta));\n", "        if (atomic == null) {\n", "          return 0L;\n", "        }\n", "        // atomic is now non-null; fall through\n", "      }\n", "\n", "      while (true) {\n", "        long oldValue = atomic.get();\n", "        if (oldValue == 0L) {\n", "          // don't compareAndSet a zero\n", "          if (map.replace(key, atomic, new AtomicLong(delta))) {\n", "            return 0L;\n", "          }\n", "          // atomic replaced\n", "          continue outer;\n", "        }\n", "\n", "        long newValue = oldValue + delta;\n", "        if (atomic.compareAndSet(oldValue, newValue)) {\n", "          return oldValue;\n", "        }\n", "        // value changed\n", "      }\n", "    }\n"], "9": ["    outer:\n", "    while (true) {\n", "      AtomicLong atomic = map.get(key);\n", "      if (atomic == null) {\n", "        atomic = map.putIfAbsent(key, new AtomicLong(newValue));\n", "        if (atomic == null) {\n", "          return 0L;\n", "        }\n", "        // atomic is now non-null; fall through\n", "      }\n", "\n", "      while (true) {\n", "        long oldValue = atomic.get();\n", "        if (oldValue == 0L) {\n", "          // don't compareAndSet a zero\n", "          if (map.replace(key, atomic, new AtomicLong(newValue))) {\n", "            return 0L;\n", "          }\n", "          // atomic replaced\n", "          continue outer;\n", "        }\n", "\n", "        if (atomic.compareAndSet(oldValue, newValue)) {\n", "          return oldValue;\n", "        }\n", "        // value changed\n", "      }\n", "    }\n"], "10": ["    for (Map.Entry<? extends K, ? extends Long> entry : m.entrySet()) {\n", "      put(entry.getKey(), entry.getValue());\n", "    }\n", "   * Removes and returns the value associated with {@code key}. If {@code key} is not in the map,\n", "   * this method has no effect and returns zero.\n", "    AtomicLong atomic = map.get(key);\n", "    if (atomic == null) {\n", "      return 0L;\n", "    }\n", "\n", "    while (true) {\n", "      long oldValue = atomic.get();\n", "      if (oldValue == 0L || atomic.compareAndSet(oldValue, 0L)) {\n", "        // only remove after setting to zero, to avoid concurrent updates\n", "        map.remove(key, atomic);\n", "        // succeed even if the remove fails, since the value was already adjusted\n", "        return oldValue;\n", "      }\n", "    }\n"], "11": ["   * <p>This method is not atomic: the map may be visible in intermediate states, where some of the\n", "   * zero values have been removed and others have not.\n", "    Iterator<Map.Entry<K, AtomicLong>> entryIterator = map.entrySet().iterator();\n", "    while (entryIterator.hasNext()) {\n", "      Map.Entry<K, AtomicLong> entry = entryIterator.next();\n", "      AtomicLong atomic = entry.getValue();\n", "      if (atomic != null && atomic.get() == 0L) {\n", "        entryIterator.remove();\n", "      }\n", "    }\n"], "12": ["    long sum = 0L;\n", "    for (AtomicLong value : map.values()) {\n", "      sum = sum + value.get();\n", "    }\n", "    return sum;\n"], "13": ["    return Collections.unmodifiableMap(\n", "        Maps.transformValues(\n", "            map,\n", "            new Function<AtomicLong, Long>() {\n", "              @Override\n", "              public Long apply(AtomicLong atomic) {\n", "                return atomic.get();\n", "              }\n", "            }));\n"], "14": ["   * Returns the number of key-value mappings in this map. If the map contains more than {@code\n", "   * Integer.MAX_VALUE} elements, returns {@code Integer.MAX_VALUE}.\n"], "15": ["  /*\n", "   * ConcurrentMap operations which we may eventually add.\n", "   *\n", "   * The problem with these is that remove(K, long) has to be done in two phases by definition ---\n", "   * first decrementing to zero, and then removing. putIfAbsent or replace could observe the\n", "   * intermediate zero-state. Ways we could deal with this are:\n", "   *\n", "   * - Don't define any of the ConcurrentMap operations. This is the current state of affairs.\n", "   *\n", "   * - Define putIfAbsent and replace as treating zero and absent identically (as currently\n", "   *   implemented below). This is a bit surprising with putIfAbsent, which really becomes\n", "   *   putIfZero.\n", "   *\n", "   * - Allow putIfAbsent and replace to distinguish between zero and absent, but don't implement\n", "   *   remove(K, long). Without any two-phase operations it becomes feasible for all remaining\n", "   *   operations to distinguish between zero and absent. If we do this, then perhaps we should add\n", "   *   replace(key, long).\n", "   *\n", "   * - Introduce a special-value private static final AtomicLong that would have the meaning of\n", "   *   removal-in-progress, and rework all operations to properly distinguish between zero and\n", "   *   absent.\n", "   */\n", "\n", "   * zero, associate it with {@code newValue}. Returns the previous value associated with {@code\n", "   * key}, or zero if there was no mapping for {@code key}.\n", "    while (true) {\n", "      AtomicLong atomic = map.get(key);\n", "      if (atomic == null) {\n", "        atomic = map.putIfAbsent(key, new AtomicLong(newValue));\n", "        if (atomic == null) {\n", "          return 0L;\n", "        }\n", "        // atomic is now non-null; fall through\n", "      }\n", "\n", "      long oldValue = atomic.get();\n", "      if (oldValue == 0L) {\n", "        // don't compareAndSet a zero\n", "        if (map.replace(key, atomic, new AtomicLong(newValue))) {\n", "          return 0L;\n", "        }\n", "        // atomic replaced\n", "        continue;\n", "      }\n", "\n", "      return oldValue;\n", "    }\n", "   * If {@code (key, expectedOldValue)} is currently in the map, this method replaces {@code\n", "   * expectedOldValue} with {@code newValue} and returns true; otherwise, this method returns false.\n", "   * <p>If {@code expectedOldValue} is zero, this method will succeed if {@code (key, zero)} is\n", "   * currently in the map, or if {@code key} is not in the map at all.\n", "      AtomicLong atomic = map.get(key);\n", "      return (atomic == null) ? false : atomic.compareAndSet(expectedOldValue, newValue);\n", "   * If {@code (key, value)} is currently in the map, this method removes it and returns true;\n", "   * otherwise, this method returns false.\n", "    AtomicLong atomic = map.get(key);\n", "    if (atomic == null) {\n", "      return false;\n", "    }\n", "\n", "    long oldValue = atomic.get();\n", "    if (oldValue != value) {\n", "      return false;\n", "    }\n", "\n", "    if (oldValue == 0L || atomic.compareAndSet(oldValue, 0L)) {\n", "      // only remove after setting to zero, to avoid concurrent updates\n", "      map.remove(key, atomic);\n", "      // succeed even if the remove fails, since the value was already adjusted\n", "      return true;\n", "    }\n", "\n", "    // value changed\n", "    return false;\n"]}, "added_lines": {"1": [4, 5, 6, 10, 11, 12, 13, 14], "2": [28, 30, 31], "3": [40, 41, 47, 48], "4": [58, 60], "5": [68], "6": [85], "7": [110], "8": [135, 136, 137, 138, 139, 140, 141, 142, 143, 144, 145, 146, 147, 148, 149, 150, 151, 152, 153, 154, 155, 156, 157, 158, 159, 160, 161, 162, 163, 164, 165, 166, 167, 168, 169, 170, 171, 172, 173, 174, 175, 176, 177, 178, 179, 180, 181, 182, 183, 184, 185, 186, 187, 188, 189, 190, 191, 192, 193, 194, 195, 196, 197, 198], "9": [207], "10": [217, 221, 222, 226, 227], "11": [244, 245, 248], "12": [257], "13": [271], "14": [282, 283], "15": [313, 314, 317, 318, 319, 320, 321, 322, 323, 324, 325, 326, 327, 328, 329, 333, 334, 335, 337, 338, 344, 349, 350, 353]}, "removed_lines": {"1": [4, 5, 9, 10, 11, 12], "2": [21, 22, 26], "3": [38, 39, 45, 46], "4": [56, 58], "5": [66], "6": [83, 84], "7": [109, 110, 111, 112, 113, 114, 115, 116, 117, 118, 119, 120, 121, 122, 123, 124, 125, 126, 127, 128, 129, 130, 131, 132, 133, 134, 135, 136, 137], "8": [162, 163, 164, 165, 166, 167, 168, 169, 170, 171, 172, 173, 174, 175, 176, 177, 178, 179, 180, 181, 182, 183, 184, 185, 186, 187, 188, 189, 190], "9": [199, 200, 201, 202, 203, 204, 205, 206, 207, 208, 209, 210, 211, 212, 213, 214, 215, 216, 217, 218, 219, 220, 221, 222, 223, 224, 225, 226], "10": [236, 237, 238, 242, 243, 247, 248, 249, 250, 251, 252, 253, 254, 255, 256, 257, 258, 259, 260], "11": [277, 278, 281, 282, 283, 284, 285, 286, 287, 288], "12": [297, 298, 299, 300, 301], "13": [315, 316, 317, 318, 319, 320, 321, 322, 323], "14": [334, 335], "15": [363, 364, 365, 366, 367, 368, 369, 370, 371, 372, 373, 374, 375, 376, 377, 378, 379, 380, 381, 382, 383, 384, 385, 388, 389, 392, 393, 394, 395, 396, 397, 398, 399, 400, 401, 402, 403, 404, 405, 406, 407, 408, 409, 410, 411, 412, 413, 417, 418, 420, 421, 427, 428, 433, 434, 437, 438, 439, 440, 441, 442, 443, 444, 445, 446, 447, 448, 449, 450, 451, 452, 453, 454, 455]}}, {"166": "guava/src/com/google/common/util/concurrent/Monitor.java", "added": {"1": ["import java.util.function.BooleanSupplier;\n"], "2": ["  /**\n", "   * Creates a new {@link Guard} for {@code this} monitor.\n", "   *\n", "   * @Param isSatisfied The guards boolean condition.  See {@link Guard#isSatisfied}.\n", "   */\n", "  public Guard newGuard(final BooleanSupplier isSatisfied) {\n", "    checkNotNull(isSatisfied, \"isSatisfied\");\n", "    return new Guard(this) {\n", "      @Override\n", "      public boolean isSatisfied() {\n", "        return isSatisfied.getAsBoolean();\n", "      }\n", "    };\n", "  }\n", "\n"]}, "removed": {}, "added_lines": {"1": [26], "2": [363, 364, 365, 366, 367, 368, 369, 370, 371, 372, 373, 374, 375, 376, 377]}, "removed_lines": {}}, {"167": "guava/src/com/google/common/util/concurrent/SmoothRateLimiter.java", "added": {"1": ["                + permitsToTime(availablePermitsAboveThreshold - permitsAboveThresholdToTake);\n"]}, "removed": {"1": ["            + permitsToTime(availablePermitsAboveThreshold - permitsAboveThresholdToTake);\n"]}, "added_lines": {"1": [251]}, "removed_lines": {"1": [251]}}, {"168": "pom.xml", "added": {"1": ["    <truth.version>0.30</truth.version>\n"], "2": ["            <source>1.8</source>\n", "            <target>1.8</target>\n"], "3": ["              <artifactId>java18</artifactId>\n", "              <version>1.0</version>\n"], "4": ["      <dependency>\n", "        <groupId>com.google.jimfs</groupId>\n", "        <artifactId>jimfs</artifactId>\n", "        <version>1.1</version>\n", "        <scope>test</scope>\n", "      </dependency>\n"], "5": ["      <dependency>\n", "        <groupId>com.google.truth.extensions</groupId>\n", "        <artifactId>truth-java8-extension</artifactId>\n", "        <version>${truth.version}</version>\n", "        <scope>test</scope>\n", "        <exclusions>\n", "          <exclusion>\n", "            <!-- use the guava we're building. -->\n", "            <groupId>com.google.guava</groupId>\n", "            <artifactId>guava</artifactId>\n", "          </exclusion>\n", "        </exclusions>\n", "      </dependency>\n"]}, "removed": {"1": ["    <truth.version>0.28</truth.version>\n"], "2": ["            <source>1.6</source>\n", "            <target>1.6</target>\n"], "3": ["              <artifactId>java16-sun</artifactId>\n", "              <version>1.10</version>\n"], "6": ["    <profile>\n", "      <id>jdk7</id>\n", "      <activation>\n", "        <jdk>1.7</jdk>\n", "      </activation>\n", "      <!-- Set custom stylesheet under JDK7 -->\n", "      <reporting>\n", "        <plugins>\n", "          <plugin>\n", "            <groupId>org.apache.maven.plugins</groupId>\n", "            <artifactId>maven-javadoc-plugin</artifactId>\n", "            <configuration>\n", "              <stylesheetfile>javadoc-stylesheet.css</stylesheetfile>\n", "            </configuration>\n", "          </plugin>\n", "        </plugins>\n", "      </reporting>\n", "      <build>\n", "        <plugins>\n", "          <plugin>\n", "            <groupId>org.apache.maven.plugins</groupId>\n", "            <artifactId>maven-javadoc-plugin</artifactId>\n", "            <configuration>\n", "              <stylesheetfile>javadoc-stylesheet.css</stylesheetfile>\n", "            </configuration>\n", "          </plugin>\n", "        </plugins>\n", "      </build>\n", "    </profile>\n"]}, "added_lines": {"1": [22], "2": [109, 110], "3": [145, 146], "4": [235, 236, 237, 238, 239, 240], "5": [254, 255, 256, 257, 258, 259, 260, 261, 262, 263, 264, 265, 266]}, "removed_lines": {"1": [22], "2": [109, 110], "3": [145, 146], "6": [264, 265, 266, 267, 268, 269, 270, 271, 272, 273, 274, 275, 276, 277, 278, 279, 280, 281, 282, 283, 284, 285, 286, 287, 288, 289, 290, 291, 292]}}]}
