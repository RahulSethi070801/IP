{
    "addition": {
        "1": "/*\n",
        "2": " * Copyright (C) 2013 The Guava Authors\n",
        "3": " *\n",
        "4": " * Licensed under the Apache License, Version 2.0 (the \"License\");\n",
        "5": " * you may not use this file except in compliance with the License.\n",
        "6": " * You may obtain a copy of the License at\n",
        "7": " *\n",
        "8": " * http://www.apache.org/licenses/LICENSE-2.0\n",
        "9": " *\n",
        "10": " * Unless required by applicable law or agreed to in writing, software\n",
        "11": " * distributed under the License is distributed on an \"AS IS\" BASIS,\n",
        "12": " * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n",
        "13": " * See the License for the specific language governing permissions and\n",
        "14": " * limitations under the License.\n",
        "15": " */\n",
        "16": "\n",
        "17": "package com.google.common.io;\n",
        "18": "\n",
        "19": "import static com.google.common.io.RecursiveDeleteOption.ALLOW_INSECURE;\n",
        "20": "import static com.google.common.jimfs.Feature.SECURE_DIRECTORY_STREAM;\n",
        "21": "import static com.google.common.jimfs.Feature.SYMBOLIC_LINKS;\n",
        "22": "import static com.google.common.truth.Truth.assertThat;\n",
        "23": "import static java.nio.file.LinkOption.NOFOLLOW_LINKS;\n",
        "24": "\n",
        "25": "import com.google.common.collect.ObjectArrays;\n",
        "26": "import com.google.common.jimfs.Configuration;\n",
        "27": "import com.google.common.jimfs.Feature;\n",
        "28": "import com.google.common.jimfs.Jimfs;\n",
        "29": "import java.io.IOException;\n",
        "30": "import java.nio.file.FileAlreadyExistsException;\n",
        "31": "import java.nio.file.FileSystem;\n",
        "32": "import java.nio.file.FileSystemException;\n",
        "33": "import java.nio.file.FileSystems;\n",
        "34": "import java.nio.file.FileVisitResult;\n",
        "35": "import java.nio.file.Files;\n",
        "36": "import java.nio.file.Path;\n",
        "37": "import java.nio.file.SimpleFileVisitor;\n",
        "38": "import java.nio.file.attribute.BasicFileAttributes;\n",
        "39": "import java.nio.file.attribute.FileTime;\n",
        "40": "import java.util.EnumSet;\n",
        "41": "import java.util.concurrent.ExecutorService;\n",
        "42": "import java.util.concurrent.Executors;\n",
        "43": "import junit.framework.TestCase;\n",
        "44": "import junit.framework.TestSuite;\n",
        "45": "\n",
        "46": "/**\n",
        "47": " * Tests for {@link MoreFiles}.\n",
        "48": " *\n",
        "49": " * @author Colin Decker\n",
        "50": " */\n",
        "51": "@AndroidIncompatible\n",
        "52": "\n",
        "53": "public class MoreFilesTest extends TestCase {\n",
        "54": "\n",
        "55": "  public static TestSuite suite() {\n",
        "56": "    TestSuite suite = new TestSuite();\n",
        "57": "    suite.addTest(ByteSourceTester.tests(\"MoreFiles.asByteSource[Path]\",\n",
        "58": "        SourceSinkFactories.pathByteSourceFactory(), true));\n",
        "59": "    suite.addTest(ByteSinkTester.tests(\"MoreFiles.asByteSink[Path]\",\n",
        "60": "        SourceSinkFactories.pathByteSinkFactory()));\n",
        "61": "    suite.addTest(ByteSinkTester.tests(\"MoreFiles.asByteSink[Path, APPEND]\",\n",
        "62": "        SourceSinkFactories.appendingPathByteSinkFactory()));\n",
        "63": "    suite.addTest(CharSourceTester.tests(\"MoreFiles.asCharSource[Path, Charset]\",\n",
        "64": "        SourceSinkFactories.pathCharSourceFactory(), false));\n",
        "65": "    suite.addTest(CharSinkTester.tests(\"MoreFiles.asCharSink[Path, Charset]\",\n",
        "66": "        SourceSinkFactories.pathCharSinkFactory()));\n",
        "67": "    suite.addTest(CharSinkTester.tests(\"MoreFiles.asCharSink[Path, Charset, APPEND]\",\n",
        "68": "        SourceSinkFactories.appendingPathCharSinkFactory()));\n",
        "69": "    suite.addTestSuite(MoreFilesTest.class);\n",
        "70": "    return suite;\n",
        "71": "  }\n",
        "72": "\n",
        "73": "  private static final FileSystem FS = FileSystems.getDefault();\n",
        "74": "\n",
        "75": "  private static Path root() {\n",
        "76": "    return FS.getRootDirectories().iterator().next();\n",
        "77": "  }\n",
        "78": "\n",
        "79": "  private Path tempDir;\n",
        "80": "\n",
        "81": "  @Override\n",
        "82": "  protected void setUp() throws Exception {\n",
        "83": "    tempDir = Files.createTempDirectory(\"MoreFilesTest\");\n",
        "84": "  }\n",
        "85": "\n",
        "86": "  @Override\n",
        "87": "  protected void tearDown() throws Exception {\n",
        "88": "    if (tempDir != null) {\n",
        "89": "      // delete tempDir and its contents\n",
        "90": "      Files.walkFileTree(tempDir, new SimpleFileVisitor<Path>() {\n",
        "91": "        @Override\n",
        "92": "        public FileVisitResult visitFile(Path file, BasicFileAttributes attrs) throws IOException {\n",
        "93": "          Files.deleteIfExists(file);\n",
        "94": "          return FileVisitResult.CONTINUE;\n",
        "95": "        }\n",
        "96": "\n",
        "97": "        @Override\n",
        "98": "        public FileVisitResult postVisitDirectory(Path dir, IOException exc) throws IOException {\n",
        "99": "          if (exc != null) {\n",
        "100": "            return FileVisitResult.TERMINATE;\n",
        "101": "          }\n",
        "102": "          Files.deleteIfExists(dir);\n",
        "103": "          return FileVisitResult.CONTINUE;\n",
        "104": "        }\n",
        "105": "      });\n",
        "106": "    }\n",
        "107": "  }\n",
        "108": "\n",
        "109": "  private Path createTempFile() throws IOException {\n",
        "110": "    return Files.createTempFile(tempDir, \"test\", \".test\");\n",
        "111": "  }\n",
        "112": "\n",
        "113": "  public void testByteSource_size_ofDirectory() throws IOException {\n",
        "114": "    try (FileSystem fs = Jimfs.newFileSystem(Configuration.unix())) {\n",
        "115": "      Path dir = fs.getPath(\"dir\");\n",
        "116": "      Files.createDirectory(dir);\n",
        "117": "\n",
        "118": "      ByteSource source = MoreFiles.asByteSource(dir);\n",
        "119": "\n",
        "120": "      assertThat(source.sizeIfKnown()).isAbsent();\n",
        "121": "\n",
        "122": "      try {\n",
        "123": "        source.size();\n",
        "124": "        fail();\n",
        "125": "      } catch (IOException expected) {\n",
        "126": "      }\n",
        "127": "    }\n",
        "128": "  }\n",
        "129": "\n",
        "130": "  public void testByteSource_size_ofSymlinkToDirectory() throws IOException {\n",
        "131": "    try (FileSystem fs = Jimfs.newFileSystem(Configuration.unix())) {\n",
        "132": "      Path dir = fs.getPath(\"dir\");\n",
        "133": "      Files.createDirectory(dir);\n",
        "134": "      Path link = fs.getPath(\"link\");\n",
        "135": "      Files.createSymbolicLink(link, dir);\n",
        "136": "\n",
        "137": "      ByteSource source = MoreFiles.asByteSource(link);\n",
        "138": "\n",
        "139": "      assertThat(source.sizeIfKnown()).isAbsent();\n",
        "140": "\n",
        "141": "      try {\n",
        "142": "        source.size();\n",
        "143": "        fail();\n",
        "144": "      } catch (IOException expected) {\n",
        "145": "      }\n",
        "146": "    }\n",
        "147": "  }\n",
        "148": "\n",
        "149": "  public void testByteSource_size_ofSymlinkToRegularFile() throws IOException {\n",
        "150": "    try (FileSystem fs = Jimfs.newFileSystem(Configuration.unix())) {\n",
        "151": "      Path file = fs.getPath(\"file\");\n",
        "152": "      Files.write(file, new byte[10]);\n",
        "153": "      Path link = fs.getPath(\"link\");\n",
        "154": "      Files.createSymbolicLink(link, file);\n",
        "155": "\n",
        "156": "      ByteSource source = MoreFiles.asByteSource(link);\n",
        "157": "\n",
        "158": "      assertEquals(10L, (long) source.sizeIfKnown().get());\n",
        "159": "      assertEquals(10L, source.size());\n",
        "160": "    }\n",
        "161": "  }\n",
        "162": "\n",
        "163": "  public void testByteSource_size_ofSymlinkToRegularFile_nofollowLinks() throws IOException {\n",
        "164": "    try (FileSystem fs = Jimfs.newFileSystem(Configuration.unix())) {\n",
        "165": "      Path file = fs.getPath(\"file\");\n",
        "166": "      Files.write(file, new byte[10]);\n",
        "167": "      Path link = fs.getPath(\"link\");\n",
        "168": "      Files.createSymbolicLink(link, file);\n",
        "169": "\n",
        "170": "      ByteSource source = MoreFiles.asByteSource(link, NOFOLLOW_LINKS);\n",
        "171": "\n",
        "172": "      assertThat(source.sizeIfKnown()).isAbsent();\n",
        "173": "\n",
        "174": "      try {\n",
        "175": "        source.size();\n",
        "176": "        fail();\n",
        "177": "      } catch (IOException expected) {\n",
        "178": "      }\n",
        "179": "    }\n",
        "180": "  }\n",
        "181": "\n",
        "182": "  public void testTouch() throws IOException {\n",
        "183": "    Path temp = createTempFile();\n",
        "184": "    assertTrue(Files.exists(temp));\n",
        "185": "    Files.delete(temp);\n",
        "186": "    assertFalse(Files.exists(temp));\n",
        "187": "    MoreFiles.touch(temp);\n",
        "188": "    assertTrue(Files.exists(temp));\n",
        "189": "    MoreFiles.touch(temp);\n",
        "190": "    assertTrue(Files.exists(temp));\n",
        "191": "  }\n",
        "192": "\n",
        "193": "  public void testTouchTime() throws IOException {\n",
        "194": "    Path temp = createTempFile();\n",
        "195": "    assertTrue(Files.exists(temp));\n",
        "196": "    Files.setLastModifiedTime(temp, FileTime.fromMillis(0));\n",
        "197": "    assertEquals(0, Files.getLastModifiedTime(temp).toMillis());\n",
        "198": "    MoreFiles.touch(temp);\n",
        "199": "    assertThat(Files.getLastModifiedTime(temp).toMillis()).isNotEqualTo(0);\n",
        "200": "  }\n",
        "201": "\n",
        "202": "  public void testCreateParentDirectories_root() throws IOException {\n",
        "203": "    Path root = root();\n",
        "204": "    assertNull(root.getParent());\n",
        "205": "    assertNull(root.toRealPath().getParent());\n",
        "206": "    MoreFiles.createParentDirectories(root); // test that there's no exception\n",
        "207": "  }\n",
        "208": "\n",
        "209": "  public void testCreateParentDirectories_relativePath() throws IOException {\n",
        "210": "    Path path = FS.getPath(\"nonexistent.file\");\n",
        "211": "    assertNull(path.getParent());\n",
        "212": "    assertNotNull(path.toAbsolutePath().getParent());\n",
        "213": "    MoreFiles.createParentDirectories(path); // test that there's no exception\n",
        "214": "  }\n",
        "215": "\n",
        "216": "  public void testCreateParentDirectories_noParentsNeeded() throws IOException {\n",
        "217": "    Path path = tempDir.resolve(\"nonexistent.file\");\n",
        "218": "    assertTrue(Files.exists(path.getParent()));\n",
        "219": "    MoreFiles.createParentDirectories(path); // test that there's no exception\n",
        "220": "  }\n",
        "221": "\n",
        "222": "  public void testCreateParentDirectories_oneParentNeeded() throws IOException {\n",
        "223": "    Path path = tempDir.resolve(\"parent/nonexistent.file\");\n",
        "224": "    Path parent = path.getParent();\n",
        "225": "    assertFalse(Files.exists(parent));\n",
        "226": "    MoreFiles.createParentDirectories(path);\n",
        "227": "    assertTrue(Files.exists(parent));\n",
        "228": "  }\n",
        "229": "\n",
        "230": "  public void testCreateParentDirectories_multipleParentsNeeded() throws IOException {\n",
        "231": "    Path path = tempDir.resolve(\"grandparent/parent/nonexistent.file\");\n",
        "232": "    Path parent = path.getParent();\n",
        "233": "    Path grandparent = parent.getParent();\n",
        "234": "    assertFalse(Files.exists(grandparent));\n",
        "235": "    assertFalse(Files.exists(parent));\n",
        "236": "\n",
        "237": "    MoreFiles.createParentDirectories(path);\n",
        "238": "    assertTrue(Files.exists(parent));\n",
        "239": "    assertTrue(Files.exists(grandparent));\n",
        "240": "  }\n",
        "241": "\n",
        "242": "  public void testCreateParentDirectories_noPermission() {\n",
        "243": "    Path file = root().resolve(\"parent/nonexistent.file\");\n",
        "244": "    Path parent = file.getParent();\n",
        "245": "    assertFalse(Files.exists(parent));\n",
        "246": "    try {\n",
        "247": "      MoreFiles.createParentDirectories(file);\n",
        "248": "      // Cleanup in case parent creation was [erroneously] successful.\n",
        "249": "      Files.delete(parent);\n",
        "250": "      fail(\"expected exception\");\n",
        "251": "    } catch (IOException expected) {\n",
        "252": "    }\n",
        "253": "  }\n",
        "254": "\n",
        "255": "  public void testCreateParentDirectories_nonDirectoryParentExists() throws IOException {\n",
        "256": "    Path parent = createTempFile();\n",
        "257": "    assertTrue(Files.isRegularFile(parent));\n",
        "258": "    Path file = parent.resolve(\"foo\");\n",
        "259": "    try {\n",
        "260": "      MoreFiles.createParentDirectories(file);\n",
        "261": "      fail();\n",
        "262": "    } catch (IOException expected) {\n",
        "263": "    }\n",
        "264": "  }\n",
        "265": "\n",
        "266": "  public void testCreateParentDirectories_symlinkParentExists() throws IOException {\n",
        "267": "    Path symlink = tempDir.resolve(\"linkToDir\");\n",
        "268": "    Files.createSymbolicLink(symlink, root());\n",
        "269": "    Path file = symlink.resolve(\"foo\");\n",
        "270": "    MoreFiles.createParentDirectories(file);\n",
        "271": "  }\n",
        "272": "\n",
        "273": "  public void testGetFileExtension() {\n",
        "274": "    assertEquals(\"txt\", MoreFiles.getFileExtension(FS.getPath(\".txt\")));\n",
        "275": "    assertEquals(\"txt\", MoreFiles.getFileExtension(FS.getPath(\"blah.txt\")));\n",
        "276": "    assertEquals(\"txt\", MoreFiles.getFileExtension(FS.getPath(\"blah..txt\")));\n",
        "277": "    assertEquals(\"txt\", MoreFiles.getFileExtension(FS.getPath(\".blah.txt\")));\n",
        "278": "    assertEquals(\"txt\", MoreFiles.getFileExtension(root().resolve(\"tmp/blah.txt\")));\n",
        "279": "    assertEquals(\"gz\", MoreFiles.getFileExtension(FS.getPath(\"blah.tar.gz\")));\n",
        "280": "    assertEquals(\"\", MoreFiles.getFileExtension(root()));\n",
        "281": "    assertEquals(\"\", MoreFiles.getFileExtension(FS.getPath(\".\")));\n",
        "282": "    assertEquals(\"\", MoreFiles.getFileExtension(FS.getPath(\"..\")));\n",
        "283": "    assertEquals(\"\", MoreFiles.getFileExtension(FS.getPath(\"...\")));\n",
        "284": "    assertEquals(\"\", MoreFiles.getFileExtension(FS.getPath(\"blah\")));\n",
        "285": "    assertEquals(\"\", MoreFiles.getFileExtension(FS.getPath(\"blah.\")));\n",
        "286": "    assertEquals(\"\", MoreFiles.getFileExtension(FS.getPath(\".blah.\")));\n",
        "287": "    assertEquals(\"\", MoreFiles.getFileExtension(root().resolve(\"foo.bar/blah\")));\n",
        "288": "    assertEquals(\"\", MoreFiles.getFileExtension(root().resolve(\"foo/.bar/blah\")));\n",
        "289": "  }\n",
        "290": "\n",
        "291": "  public void testGetNameWithoutExtension() {\n",
        "292": "    assertEquals(\"\", MoreFiles.getNameWithoutExtension(FS.getPath(\".txt\")));\n",
        "293": "    assertEquals(\"blah\", MoreFiles.getNameWithoutExtension(FS.getPath(\"blah.txt\")));\n",
        "294": "    assertEquals(\"blah.\", MoreFiles.getNameWithoutExtension(FS.getPath(\"blah..txt\")));\n",
        "295": "    assertEquals(\".blah\", MoreFiles.getNameWithoutExtension(FS.getPath(\".blah.txt\")));\n",
        "296": "    assertEquals(\"blah\", MoreFiles.getNameWithoutExtension(root().resolve(\"tmp/blah.txt\")));\n",
        "297": "    assertEquals(\"blah.tar\", MoreFiles.getNameWithoutExtension(FS.getPath(\"blah.tar.gz\")));\n",
        "298": "    assertEquals(\"\", MoreFiles.getNameWithoutExtension(root()));\n",
        "299": "    assertEquals(\"\", MoreFiles.getNameWithoutExtension(FS.getPath(\".\")));\n",
        "300": "    assertEquals(\".\", MoreFiles.getNameWithoutExtension(FS.getPath(\"..\")));\n",
        "301": "    assertEquals(\"..\", MoreFiles.getNameWithoutExtension(FS.getPath(\"...\")));\n",
        "302": "    assertEquals(\"blah\", MoreFiles.getNameWithoutExtension(FS.getPath(\"blah\")));\n",
        "303": "    assertEquals(\"blah\", MoreFiles.getNameWithoutExtension(FS.getPath(\"blah.\")));\n",
        "304": "    assertEquals(\".blah\", MoreFiles.getNameWithoutExtension(FS.getPath(\".blah.\")));\n",
        "305": "    assertEquals(\"blah\", MoreFiles.getNameWithoutExtension(root().resolve(\"foo.bar/blah\")));\n",
        "306": "    assertEquals(\"blah\", MoreFiles.getNameWithoutExtension(root().resolve(\"foo/.bar/blah\")));\n",
        "307": "  }\n",
        "308": "\n",
        "309": "  public void testPredicates() throws IOException {\n",
        "310": "    Path file = createTempFile();\n",
        "311": "    Path dir = tempDir.resolve(\"dir\");\n",
        "312": "    Files.createDirectory(dir);\n",
        "313": "\n",
        "314": "    assertTrue(MoreFiles.isDirectory().apply(dir));\n",
        "315": "    assertFalse(MoreFiles.isRegularFile().apply(dir));\n",
        "316": "\n",
        "317": "    assertFalse(MoreFiles.isDirectory().apply(file));\n",
        "318": "    assertTrue(MoreFiles.isRegularFile().apply(file));\n",
        "319": "\n",
        "320": "    Path symlinkToDir = tempDir.resolve(\"symlinkToDir\");\n",
        "321": "    Path symlinkToFile = tempDir.resolve(\"symlinkToFile\");\n",
        "322": "\n",
        "323": "    Files.createSymbolicLink(symlinkToDir, dir);\n",
        "324": "    Files.createSymbolicLink(symlinkToFile, file);\n",
        "325": "\n",
        "326": "    assertTrue(MoreFiles.isDirectory().apply(symlinkToDir));\n",
        "327": "    assertFalse(MoreFiles.isRegularFile().apply(symlinkToDir));\n",
        "328": "\n",
        "329": "    assertFalse(MoreFiles.isDirectory().apply(symlinkToFile));\n",
        "330": "    assertTrue(MoreFiles.isRegularFile().apply(symlinkToFile));\n",
        "331": "\n",
        "332": "    assertFalse(MoreFiles.isDirectory(NOFOLLOW_LINKS).apply(symlinkToDir));\n",
        "333": "    assertFalse(MoreFiles.isRegularFile(NOFOLLOW_LINKS).apply(symlinkToFile));\n",
        "334": "  }\n",
        "335": "\n",
        "336": "  /**\n",
        "337": "   * Creates a new file system for testing that supports the given features in addition to\n",
        "338": "   * supporting symbolic links. The file system is created initially having the following file\n",
        "339": "   * structure:\n",
        "340": "   *\n",
        "341": "   * <pre>\n",
        "342": "   *   /\n",
        "343": "   *      work/\n",
        "344": "   *         dir/\n",
        "345": "   *            a\n",
        "346": "   *            b/\n",
        "347": "   *               g\n",
        "348": "   *               h -> ../a\n",
        "349": "   *               i/\n",
        "350": "   *                  j/\n",
        "351": "   *                     k\n",
        "352": "   *                     l/\n",
        "353": "   *            c\n",
        "354": "   *            d -> b/i\n",
        "355": "   *            e/\n",
        "356": "   *            f -> /dontdelete\n",
        "357": "   *      dontdelete/\n",
        "358": "   *         a\n",
        "359": "   *         b/\n",
        "360": "   *         c\n",
        "361": "   *      symlinktodir -> work/dir\n",
        "362": "   * </pre>\n",
        "363": "   */\n",
        "364": "  static FileSystem newTestFileSystem(Feature... supportedFeatures) throws IOException {\n",
        "365": "    FileSystem fs = Jimfs.newFileSystem(Configuration.unix().toBuilder()\n",
        "366": "        .setSupportedFeatures(ObjectArrays.concat(SYMBOLIC_LINKS, supportedFeatures))\n",
        "367": "        .build());\n",
        "368": "    Files.createDirectories(fs.getPath(\"dir/b/i/j/l\"));\n",
        "369": "    Files.createFile(fs.getPath(\"dir/a\"));\n",
        "370": "    Files.createFile(fs.getPath(\"dir/c\"));\n",
        "371": "    Files.createSymbolicLink(fs.getPath(\"dir/d\"), fs.getPath(\"b/i\"));\n",
        "372": "    Files.createDirectory(fs.getPath(\"dir/e\"));\n",
        "373": "    Files.createSymbolicLink(fs.getPath(\"dir/f\"), fs.getPath(\"/dontdelete\"));\n",
        "374": "    Files.createFile(fs.getPath(\"dir/b/g\"));\n",
        "375": "    Files.createSymbolicLink(fs.getPath(\"dir/b/h\"), fs.getPath(\"../a\"));\n",
        "376": "    Files.createFile(fs.getPath(\"dir/b/i/j/k\"));\n",
        "377": "    Files.createDirectory(fs.getPath(\"/dontdelete\"));\n",
        "378": "    Files.createFile(fs.getPath(\"/dontdelete/a\"));\n",
        "379": "    Files.createDirectory(fs.getPath(\"/dontdelete/b\"));\n",
        "380": "    Files.createFile(fs.getPath(\"/dontdelete/c\"));\n",
        "381": "    Files.createSymbolicLink(fs.getPath(\"/symlinktodir\"), fs.getPath(\"work/dir\"));\n",
        "382": "    return fs;\n",
        "383": "  }\n",
        "384": "\n",
        "385": "  public void testDirectoryDeletion_basic() throws IOException {\n",
        "386": "    for (DirectoryDeleteMethod method : EnumSet.allOf(DirectoryDeleteMethod.class)) {\n",
        "387": "      try (FileSystem fs = newTestFileSystem(SECURE_DIRECTORY_STREAM)) {\n",
        "388": "        Path dir = fs.getPath(\"dir\");\n",
        "389": "        assertEquals(6, MoreFiles.listFiles(dir).size());\n",
        "390": "\n",
        "391": "        method.delete(dir);\n",
        "392": "        method.assertDeleteSucceeded(dir);\n",
        "393": "\n",
        "394": "        assertEquals(\"contents of /dontdelete deleted by delete method \" + method,\n",
        "395": "            3, MoreFiles.listFiles(fs.getPath(\"/dontdelete\")).size());\n",
        "396": "      }\n",
        "397": "    }\n",
        "398": "  }\n",
        "399": "\n",
        "400": "  public void testDirectoryDeletion_emptyDir() throws IOException {\n",
        "401": "    for (DirectoryDeleteMethod method : EnumSet.allOf(DirectoryDeleteMethod.class)) {\n",
        "402": "      try (FileSystem fs = newTestFileSystem(SECURE_DIRECTORY_STREAM)) {\n",
        "403": "        Path emptyDir = fs.getPath(\"dir/e\");\n",
        "404": "        assertEquals(0, MoreFiles.listFiles(emptyDir).size());\n",
        "405": "\n",
        "406": "        method.delete(emptyDir);\n",
        "407": "        method.assertDeleteSucceeded(emptyDir);\n",
        "408": "      }\n",
        "409": "    }\n",
        "410": "  }\n",
        "411": "\n",
        "412": "  public void testDeleteRecursively_symlinkToDir() throws IOException {\n",
        "413": "    try (FileSystem fs = newTestFileSystem(SECURE_DIRECTORY_STREAM)) {\n",
        "414": "      Path symlink = fs.getPath(\"/symlinktodir\");\n",
        "415": "      Path dir = fs.getPath(\"dir\");\n",
        "416": "\n",
        "417": "      assertEquals(6, MoreFiles.listFiles(dir).size());\n",
        "418": "\n",
        "419": "      MoreFiles.deleteRecursively(symlink);\n",
        "420": "\n",
        "421": "      assertFalse(Files.exists(symlink));\n",
        "422": "      assertTrue(Files.exists(dir));\n",
        "423": "      assertEquals(6, MoreFiles.listFiles(dir).size());\n",
        "424": "    }\n",
        "425": "  }\n",
        "426": "\n",
        "427": "  public void testDeleteDirectoryContents_symlinkToDir() throws IOException {\n",
        "428": "    try (FileSystem fs = newTestFileSystem(SECURE_DIRECTORY_STREAM)) {\n",
        "429": "      Path symlink = fs.getPath(\"/symlinktodir\");\n",
        "430": "      Path dir = fs.getPath(\"dir\");\n",
        "431": "\n",
        "432": "      assertEquals(6, MoreFiles.listFiles(symlink).size());\n",
        "433": "\n",
        "434": "      MoreFiles.deleteDirectoryContents(symlink);\n",
        "435": "\n",
        "436": "      assertTrue(Files.exists(symlink, NOFOLLOW_LINKS));\n",
        "437": "      assertTrue(Files.exists(symlink));\n",
        "438": "      assertTrue(Files.exists(dir));\n",
        "439": "      assertEquals(0, MoreFiles.listFiles(symlink).size());\n",
        "440": "    }\n",
        "441": "  }\n",
        "442": "\n",
        "443": "  public void testDirectoryDeletion_sdsNotSupported_fails() throws IOException {\n",
        "444": "    for (DirectoryDeleteMethod method : EnumSet.allOf(DirectoryDeleteMethod.class)) {\n",
        "445": "      try (FileSystem fs = newTestFileSystem()) {\n",
        "446": "        Path dir = fs.getPath(\"dir\");\n",
        "447": "        assertEquals(6, MoreFiles.listFiles(dir).size());\n",
        "448": "\n",
        "449": "        try {\n",
        "450": "          method.delete(dir);\n",
        "451": "          fail(\"expected InsecureRecursiveDeleteException\");\n",
        "452": "        } catch (InsecureRecursiveDeleteException expected) {\n",
        "453": "        }\n",
        "454": "\n",
        "455": "        assertTrue(Files.exists(dir));\n",
        "456": "        assertEquals(6, MoreFiles.listFiles(dir).size());\n",
        "457": "      }\n",
        "458": "    }\n",
        "459": "  }\n",
        "460": "\n",
        "461": "  public void testDirectoryDeletion_sdsNotSupported_allowInsecure() throws IOException {\n",
        "462": "    for (DirectoryDeleteMethod method : EnumSet.allOf(DirectoryDeleteMethod.class)) {\n",
        "463": "      try (FileSystem fs = newTestFileSystem()) {\n",
        "464": "        Path dir = fs.getPath(\"dir\");\n",
        "465": "        assertEquals(6, MoreFiles.listFiles(dir).size());\n",
        "466": "\n",
        "467": "        method.delete(dir, ALLOW_INSECURE);\n",
        "468": "        method.assertDeleteSucceeded(dir);\n",
        "469": "\n",
        "470": "        assertEquals(\"contents of /dontdelete deleted by delete method \" + method,\n",
        "471": "            3, MoreFiles.listFiles(fs.getPath(\"/dontdelete\")).size());\n",
        "472": "      }\n",
        "473": "    }\n",
        "474": "  }\n",
        "475": "\n",
        "476": "  public void testDeleteRecursively_symlinkToDir_sdsNotSupported_allowInsecure()\n",
        "477": "      throws IOException {\n",
        "478": "    try (FileSystem fs = newTestFileSystem()) {\n",
        "479": "      Path symlink = fs.getPath(\"/symlinktodir\");\n",
        "480": "      Path dir = fs.getPath(\"dir\");\n",
        "481": "\n",
        "482": "      assertEquals(6, MoreFiles.listFiles(dir).size());\n",
        "483": "\n",
        "484": "      MoreFiles.deleteRecursively(symlink, ALLOW_INSECURE);\n",
        "485": "\n",
        "486": "      assertFalse(Files.exists(symlink));\n",
        "487": "      assertTrue(Files.exists(dir));\n",
        "488": "      assertEquals(6, MoreFiles.listFiles(dir).size());\n",
        "489": "    }\n",
        "490": "  }\n",
        "491": "\n",
        "492": "  public void testDeleteDirectoryContents_symlinkToDir_sdsNotSupported_allowInsecure()\n",
        "493": "      throws IOException {\n",
        "494": "    try (FileSystem fs = newTestFileSystem()) {\n",
        "495": "      Path symlink = fs.getPath(\"/symlinktodir\");\n",
        "496": "      Path dir = fs.getPath(\"dir\");\n",
        "497": "\n",
        "498": "      assertEquals(6, MoreFiles.listFiles(dir).size());\n",
        "499": "\n",
        "500": "      MoreFiles.deleteDirectoryContents(symlink, ALLOW_INSECURE);\n",
        "501": "      assertEquals(0, MoreFiles.listFiles(dir).size());\n",
        "502": "    }\n",
        "503": "  }\n",
        "504": "\n",
        "505": "  /**\n",
        "506": "   * This test attempts to create a situation in which one thread is constantly changing a file\n",
        "507": "   * from being a real directory to being a symlink to another directory. It then calls\n",
        "508": "   * deleteDirectoryContents thousands of times on a directory whose subtree contains the file\n",
        "509": "   * that's switching between directory and symlink to try to ensure that under no circumstance\n",
        "510": "   * does deleteDirectoryContents follow the symlink to the other directory and delete that\n",
        "511": "   * directory's contents.\n",
        "512": "   *\n",
        "513": "   * <p>We can only test this with a file system that supports SecureDirectoryStream, because it's\n",
        "514": "   * not possible to protect against this if the file system doesn't.\n",
        "515": "   */\n",
        "516": "  public void testDirectoryDeletion_directorySymlinkRace() throws IOException {\n",
        "517": "    for (DirectoryDeleteMethod method : EnumSet.allOf(DirectoryDeleteMethod.class)) {\n",
        "518": "      try (FileSystem fs = newTestFileSystem(SECURE_DIRECTORY_STREAM)) {\n",
        "519": "        Path dirToDelete = fs.getPath(\"dir/b/i\");\n",
        "520": "        Path changingFile = dirToDelete.resolve(\"j/l\");\n",
        "521": "        Path symlinkTarget = fs.getPath(\"/dontdelete\");\n",
        "522": "\n",
        "523": "        ExecutorService executor = Executors.newSingleThreadExecutor();\n",
        "524": "        startDirectorySymlinkSwitching(changingFile, symlinkTarget, executor);\n",
        "525": "\n",
        "526": "        try {\n",
        "527": "          for (int i = 0; i < 5000; i++) {\n",
        "528": "            try {\n",
        "529": "              Files.createDirectories(changingFile);\n",
        "530": "              Files.createFile(dirToDelete.resolve(\"j/k\"));\n",
        "531": "            } catch (FileAlreadyExistsException expected) {\n",
        "532": "              // if a file already exists, that's fine... just continue\n",
        "533": "            }\n",
        "534": "\n",
        "535": "            try {\n",
        "536": "              method.delete(dirToDelete);\n",
        "537": "            } catch (FileSystemException expected) {\n",
        "538": "              // the delete method may or may not throw an exception, but if it does that's fine\n",
        "539": "              // and expected\n",
        "540": "            }\n",
        "541": "\n",
        "542": "            // this test is mainly checking that the contents of /dontdelete aren't deleted under\n",
        "543": "            // any circumstances\n",
        "544": "            assertEquals(3, MoreFiles.listFiles(symlinkTarget).size());\n",
        "545": "\n",
        "546": "            Thread.yield();\n",
        "547": "          }\n",
        "548": "        } finally {\n",
        "549": "          executor.shutdownNow();\n",
        "550": "        }\n",
        "551": "      }\n",
        "552": "    }\n",
        "553": "  }\n",
        "554": "\n",
        "555": "  public void testDeleteRecursively_nonDirectoryFile() throws IOException {\n",
        "556": "    try (FileSystem fs = newTestFileSystem(SECURE_DIRECTORY_STREAM)) {\n",
        "557": "      Path file = fs.getPath(\"dir/a\");\n",
        "558": "      assertTrue(Files.isRegularFile(file, NOFOLLOW_LINKS));\n",
        "559": "\n",
        "560": "      MoreFiles.deleteRecursively(file);\n",
        "561": "\n",
        "562": "      assertFalse(Files.exists(file, NOFOLLOW_LINKS));\n",
        "563": "\n",
        "564": "      Path symlink = fs.getPath(\"/symlinktodir\");\n",
        "565": "      assertTrue(Files.isSymbolicLink(symlink));\n",
        "566": "\n",
        "567": "      Path realSymlinkTarget = symlink.toRealPath();\n",
        "568": "      assertTrue(Files.isDirectory(realSymlinkTarget, NOFOLLOW_LINKS));\n",
        "569": "\n",
        "570": "      MoreFiles.deleteRecursively(symlink);\n",
        "571": "\n",
        "572": "      assertFalse(Files.exists(symlink, NOFOLLOW_LINKS));\n",
        "573": "      assertTrue(Files.isDirectory(realSymlinkTarget, NOFOLLOW_LINKS));\n",
        "574": "    }\n",
        "575": "  }\n",
        "576": "\n",
        "577": "  /**\n",
        "578": "   * Starts a new task on the given executor that switches (deletes and replaces) a file between\n",
        "579": "   * being a directory and being a symlink. The given {@code file} is the file that should switch\n",
        "580": "   * between being a directory and being a symlink, while the given {@code target} is the target\n",
        "581": "   * the symlink should have.\n",
        "582": "   */\n",
        "583": "  private static void startDirectorySymlinkSwitching(\n",
        "584": "      final Path file, final Path target, ExecutorService executor) {\n",
        "585": "    executor.submit(new Runnable() {\n",
        "586": "      @Override\n",
        "587": "      public void run() {\n",
        "588": "        boolean createSymlink = false;\n",
        "589": "        while (!Thread.interrupted()) {\n",
        "590": "          try {\n",
        "591": "            // trying to switch between a real directory and a symlink (dir -> /a)\n",
        "592": "            if (Files.deleteIfExists(file)) {\n",
        "593": "              if (createSymlink) {\n",
        "594": "                Files.createSymbolicLink(file, target);\n",
        "595": "              } else {\n",
        "596": "                Files.createDirectory(file);\n",
        "597": "              }\n",
        "598": "              createSymlink = !createSymlink;\n",
        "599": "            }\n",
        "600": "          } catch (IOException tolerated) {\n",
        "601": "            // it's expected that some of these will fail\n",
        "602": "          }\n",
        "603": "\n",
        "604": "          Thread.yield();\n",
        "605": "        }\n",
        "606": "      }\n",
        "607": "    });\n",
        "608": "  }\n",
        "609": "\n",
        "610": "  /**\n",
        "611": "   * Enum defining the two MoreFiles methods that delete directory contents.\n",
        "612": "   */\n",
        "613": "  private enum DirectoryDeleteMethod {\n",
        "614": "    DELETE_DIRECTORY_CONTENTS {\n",
        "615": "      @Override\n",
        "616": "      public void delete(Path path, RecursiveDeleteOption... options) throws IOException {\n",
        "617": "        MoreFiles.deleteDirectoryContents(path, options);\n",
        "618": "      }\n",
        "619": "\n",
        "620": "      @Override\n",
        "621": "      public void assertDeleteSucceeded(Path path) throws IOException {\n",
        "622": "        assertEquals(\"contents of directory \" + path + \" not deleted with delete method \" + this,\n",
        "623": "            0, MoreFiles.listFiles(path).size());\n",
        "624": "      }\n",
        "625": "    },\n",
        "626": "    DELETE_RECURSIVELY {\n",
        "627": "      @Override\n",
        "628": "      public void delete(Path path, RecursiveDeleteOption... options) throws IOException {\n",
        "629": "        MoreFiles.deleteRecursively(path, options);\n",
        "630": "      }\n",
        "631": "\n",
        "632": "      @Override\n",
        "633": "      public void assertDeleteSucceeded(Path path) throws IOException {\n",
        "634": "        assertFalse(\"file \" + path + \" not deleted with delete method \" + this,\n",
        "635": "            Files.exists(path));\n",
        "636": "      }\n",
        "637": "    };\n",
        "638": "\n",
        "639": "    public abstract void delete(Path path, RecursiveDeleteOption... options) throws IOException;\n",
        "640": "\n",
        "641": "    public abstract void assertDeleteSucceeded(Path path) throws IOException;\n",
        "642": "  }\n",
        "643": "}\n"
    },
    "removed": {}
}