{
    "addition": {
        "4": " * Licensed under the Apache License, Version 2.0 (the \"License\");\n",
        "5": " * you may not use this file except in compliance with the License.\n",
        "6": " * You may obtain a copy of the License at\n",
        "10": " * Unless required by applicable law or agreed to in writing, software\n",
        "11": " * distributed under the License is distributed on an \"AS IS\" BASIS,\n",
        "12": " * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n",
        "13": " * See the License for the specific language governing permissions and\n",
        "14": " * limitations under the License.\n",
        "28": "import java.util.concurrent.atomic.AtomicBoolean;\n",
        "30": "import java.util.function.LongBinaryOperator;\n",
        "31": "import java.util.function.LongUnaryOperator;\n",
        "40": " * documented. Exceptions to this are {@link #containsKey}, {@link #size}, {@link #isEmpty},\n",
        "41": " * {@link #asMap}, and {@link #toString}.\n",
        "47": " * {@link com.google.common.collect.Multiset} such as\n",
        "48": " * {@link com.google.common.collect.ConcurrentHashMultiset} instead.\n",
        "58": "  private final ConcurrentHashMap<K, Long> map;\n",
        "60": "  private AtomicLongMap(ConcurrentHashMap<K, Long> map) {\n",
        "68": "    return new AtomicLongMap<K>(new ConcurrentHashMap<>());\n",
        "85": "    return map.getOrDefault(key, 0L);\n",
        "110": "    return accumulateAndGet(key, delta, Long::sum);\n",
        "135": "    return getAndAccumulate(key, delta, Long::sum);\n",
        "136": "  }\n",
        "137": "\n",
        "138": "  /**\n",
        "139": "   * Updates the value currently associated with {@code key} with the specified function,\n",
        "140": "   * and returns the new value.  If there is not currently a value associated with {@code key},\n",
        "141": "   * the function is applied to {@code 0L}.\n",
        "142": "   *\n",
        "143": "   * @since 21.0\n",
        "144": "   */\n",
        "145": "  @CanIgnoreReturnValue\n",
        "146": "  public long updateAndGet(K key, LongUnaryOperator updaterFunction) {\n",
        "147": "    checkNotNull(updaterFunction);\n",
        "148": "    return map.compute(\n",
        "149": "        key, (k, value) -> updaterFunction.applyAsLong((value == null) ? 0L : value.longValue()));\n",
        "150": "  }\n",
        "151": "\n",
        "152": "  /**\n",
        "153": "   * Updates the value currently associated with {@code key} with the specified function,\n",
        "154": "   * and returns the old value.  If there is not currently a value associated with {@code key},\n",
        "155": "   * the function is applied to {@code 0L}.\n",
        "156": "   *\n",
        "157": "   * @since 21.0\n",
        "158": "   */\n",
        "159": "  @CanIgnoreReturnValue\n",
        "160": "  public long getAndUpdate(K key, LongUnaryOperator updaterFunction) {\n",
        "161": "    checkNotNull(updaterFunction);\n",
        "162": "    AtomicLong holder = new AtomicLong();\n",
        "163": "    map.compute(\n",
        "164": "        key,\n",
        "165": "        (k, value) -> {\n",
        "166": "          long oldValue = (value == null) ? 0L : value.longValue();\n",
        "167": "          holder.set(oldValue);\n",
        "168": "          return updaterFunction.applyAsLong(oldValue);\n",
        "169": "        });\n",
        "170": "    return holder.get();\n",
        "171": "  }\n",
        "172": "\n",
        "173": "  /**\n",
        "174": "   * Updates the value currently associated with {@code key} by combining it with {@code x}\n",
        "175": "   * via the specified accumulator function, returning the new value.  The previous value\n",
        "176": "   * associated with {@code key} (or zero, if there is none) is passed as the first argument\n",
        "177": "   * to {@code accumulatorFunction}, and {@code x} is passed as the second argument.\n",
        "178": "   *\n",
        "179": "   * @since 21.0\n",
        "180": "   */\n",
        "181": "  @CanIgnoreReturnValue\n",
        "182": "  public long accumulateAndGet(K key, long x, LongBinaryOperator accumulatorFunction) {\n",
        "183": "    checkNotNull(accumulatorFunction);\n",
        "184": "    return updateAndGet(key, oldValue -> accumulatorFunction.applyAsLong(oldValue, x));\n",
        "185": "  }\n",
        "186": "\n",
        "187": "  /**\n",
        "188": "   * Updates the value currently associated with {@code key} by combining it with {@code x}\n",
        "189": "   * via the specified accumulator function, returning the old value.  The previous value\n",
        "190": "   * associated with {@code key} (or zero, if there is none) is passed as the first argument\n",
        "191": "   * to {@code accumulatorFunction}, and {@code x} is passed as the second argument.\n",
        "192": "   *\n",
        "193": "   * @since 21.0\n",
        "194": "   */\n",
        "195": "  @CanIgnoreReturnValue\n",
        "196": "  public long getAndAccumulate(K key, long x, LongBinaryOperator accumulatorFunction) {\n",
        "197": "    checkNotNull(accumulatorFunction);\n",
        "198": "    return getAndUpdate(key, oldValue -> accumulatorFunction.applyAsLong(oldValue, x));\n",
        "207": "    return getAndUpdate(key, x -> newValue);\n",
        "217": "    m.forEach(this::put);\n",
        "221": "   * Removes and returns the value associated with {@code key}. If {@code key} is not\n",
        "222": "   * in the map, this method has no effect and returns zero.\n",
        "226": "    Long result = map.remove(key);\n",
        "227": "    return (result == null) ? 0L : result.longValue();\n",
        "244": "   * <p>This method is not atomic: the map may be visible in intermediate states, where some\n",
        "245": "   * of the zero values have been removed and others have not.\n",
        "248": "    map.values().removeIf(x -> x == 0);\n",
        "257": "    return map.values().stream().mapToLong(Long::longValue).sum();\n",
        "271": "    return Collections.unmodifiableMap(map);\n",
        "282": "   * Returns the number of key-value mappings in this map. If the map contains more than\n",
        "283": "   * {@code Integer.MAX_VALUE} elements, returns {@code Integer.MAX_VALUE}.\n",
        "313": "   * zero, associate it with {@code newValue}. Returns the previous value associated with\n",
        "314": "   * {@code key}, or zero if there was no mapping for {@code key}.\n",
        "317": "    AtomicBoolean noValue = new AtomicBoolean(false);\n",
        "318": "    Long result =\n",
        "319": "        map.compute(\n",
        "320": "            key,\n",
        "321": "            (k, oldValue) -> {\n",
        "322": "              if (oldValue == null || oldValue == 0) {\n",
        "323": "                noValue.set(true);\n",
        "324": "                return newValue;\n",
        "325": "              } else {\n",
        "326": "                return oldValue;\n",
        "327": "              }\n",
        "328": "            });\n",
        "329": "    return noValue.get() ? 0L : result.longValue();\n",
        "333": "   * If {@code (key, expectedOldValue)} is currently in the map, this method replaces\n",
        "334": "   * {@code expectedOldValue} with {@code newValue} and returns true; otherwise, this method\n",
        "335": "   * returns false.\n",
        "337": "   * <p>If {@code expectedOldValue} is zero, this method will succeed if {@code (key, zero)}\n",
        "338": "   * is currently in the map, or if {@code key} is not in the map at all.\n",
        "344": "      return map.replace(key, expectedOldValue, newValue);\n",
        "349": "   * If {@code (key, value)} is currently in the map, this method removes it and returns\n",
        "350": "   * true; otherwise, this method returns false.\n",
        "353": "    return map.remove(key, value);\n"
    },
    "removed": {
        "4": " * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not use this file except\n",
        "5": " * in compliance with the License. You may obtain a copy of the License at\n",
        "9": " * Unless required by applicable law or agreed to in writing, software distributed under the License\n",
        "10": " * is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express\n",
        "11": " * or implied. See the License for the specific language governing permissions and limitations under\n",
        "12": " * the License.\n",
        "21": "import com.google.common.base.Function;\n",
        "22": "import com.google.common.collect.Maps;\n",
        "26": "import java.util.Iterator;\n",
        "38": " * documented. Exceptions to this are {@link #containsKey}, {@link #size}, {@link #isEmpty}, {@link\n",
        "39": " * #asMap}, and {@link #toString}.\n",
        "45": " * {@link com.google.common.collect.Multiset} such as {@link\n",
        "46": " * com.google.common.collect.ConcurrentHashMultiset} instead.\n",
        "56": "  private final ConcurrentHashMap<K, AtomicLong> map;\n",
        "58": "  private AtomicLongMap(ConcurrentHashMap<K, AtomicLong> map) {\n",
        "66": "    return new AtomicLongMap<K>(new ConcurrentHashMap<K, AtomicLong>());\n",
        "83": "    AtomicLong atomic = map.get(key);\n",
        "84": "    return atomic == null ? 0L : atomic.get();\n",
        "109": "    outer:\n",
        "110": "    while (true) {\n",
        "111": "      AtomicLong atomic = map.get(key);\n",
        "112": "      if (atomic == null) {\n",
        "113": "        atomic = map.putIfAbsent(key, new AtomicLong(delta));\n",
        "114": "        if (atomic == null) {\n",
        "115": "          return delta;\n",
        "116": "        }\n",
        "117": "        // atomic is now non-null; fall through\n",
        "118": "      }\n",
        "119": "\n",
        "120": "      while (true) {\n",
        "121": "        long oldValue = atomic.get();\n",
        "122": "        if (oldValue == 0L) {\n",
        "123": "          // don't compareAndSet a zero\n",
        "124": "          if (map.replace(key, atomic, new AtomicLong(delta))) {\n",
        "125": "            return delta;\n",
        "126": "          }\n",
        "127": "          // atomic replaced\n",
        "128": "          continue outer;\n",
        "129": "        }\n",
        "130": "\n",
        "131": "        long newValue = oldValue + delta;\n",
        "132": "        if (atomic.compareAndSet(oldValue, newValue)) {\n",
        "133": "          return newValue;\n",
        "134": "        }\n",
        "135": "        // value changed\n",
        "136": "      }\n",
        "137": "    }\n",
        "162": "    outer:\n",
        "163": "    while (true) {\n",
        "164": "      AtomicLong atomic = map.get(key);\n",
        "165": "      if (atomic == null) {\n",
        "166": "        atomic = map.putIfAbsent(key, new AtomicLong(delta));\n",
        "167": "        if (atomic == null) {\n",
        "168": "          return 0L;\n",
        "169": "        }\n",
        "170": "        // atomic is now non-null; fall through\n",
        "171": "      }\n",
        "172": "\n",
        "173": "      while (true) {\n",
        "174": "        long oldValue = atomic.get();\n",
        "175": "        if (oldValue == 0L) {\n",
        "176": "          // don't compareAndSet a zero\n",
        "177": "          if (map.replace(key, atomic, new AtomicLong(delta))) {\n",
        "178": "            return 0L;\n",
        "179": "          }\n",
        "180": "          // atomic replaced\n",
        "181": "          continue outer;\n",
        "182": "        }\n",
        "183": "\n",
        "184": "        long newValue = oldValue + delta;\n",
        "185": "        if (atomic.compareAndSet(oldValue, newValue)) {\n",
        "186": "          return oldValue;\n",
        "187": "        }\n",
        "188": "        // value changed\n",
        "189": "      }\n",
        "190": "    }\n",
        "199": "    outer:\n",
        "200": "    while (true) {\n",
        "201": "      AtomicLong atomic = map.get(key);\n",
        "202": "      if (atomic == null) {\n",
        "203": "        atomic = map.putIfAbsent(key, new AtomicLong(newValue));\n",
        "204": "        if (atomic == null) {\n",
        "205": "          return 0L;\n",
        "206": "        }\n",
        "207": "        // atomic is now non-null; fall through\n",
        "208": "      }\n",
        "209": "\n",
        "210": "      while (true) {\n",
        "211": "        long oldValue = atomic.get();\n",
        "212": "        if (oldValue == 0L) {\n",
        "213": "          // don't compareAndSet a zero\n",
        "214": "          if (map.replace(key, atomic, new AtomicLong(newValue))) {\n",
        "215": "            return 0L;\n",
        "216": "          }\n",
        "217": "          // atomic replaced\n",
        "218": "          continue outer;\n",
        "219": "        }\n",
        "220": "\n",
        "221": "        if (atomic.compareAndSet(oldValue, newValue)) {\n",
        "222": "          return oldValue;\n",
        "223": "        }\n",
        "224": "        // value changed\n",
        "225": "      }\n",
        "226": "    }\n",
        "236": "    for (Map.Entry<? extends K, ? extends Long> entry : m.entrySet()) {\n",
        "237": "      put(entry.getKey(), entry.getValue());\n",
        "238": "    }\n",
        "242": "   * Removes and returns the value associated with {@code key}. If {@code key} is not in the map,\n",
        "243": "   * this method has no effect and returns zero.\n",
        "247": "    AtomicLong atomic = map.get(key);\n",
        "248": "    if (atomic == null) {\n",
        "249": "      return 0L;\n",
        "250": "    }\n",
        "251": "\n",
        "252": "    while (true) {\n",
        "253": "      long oldValue = atomic.get();\n",
        "254": "      if (oldValue == 0L || atomic.compareAndSet(oldValue, 0L)) {\n",
        "255": "        // only remove after setting to zero, to avoid concurrent updates\n",
        "256": "        map.remove(key, atomic);\n",
        "257": "        // succeed even if the remove fails, since the value was already adjusted\n",
        "258": "        return oldValue;\n",
        "259": "      }\n",
        "260": "    }\n",
        "277": "   * <p>This method is not atomic: the map may be visible in intermediate states, where some of the\n",
        "278": "   * zero values have been removed and others have not.\n",
        "281": "    Iterator<Map.Entry<K, AtomicLong>> entryIterator = map.entrySet().iterator();\n",
        "282": "    while (entryIterator.hasNext()) {\n",
        "283": "      Map.Entry<K, AtomicLong> entry = entryIterator.next();\n",
        "284": "      AtomicLong atomic = entry.getValue();\n",
        "285": "      if (atomic != null && atomic.get() == 0L) {\n",
        "286": "        entryIterator.remove();\n",
        "287": "      }\n",
        "288": "    }\n",
        "297": "    long sum = 0L;\n",
        "298": "    for (AtomicLong value : map.values()) {\n",
        "299": "      sum = sum + value.get();\n",
        "300": "    }\n",
        "301": "    return sum;\n",
        "315": "    return Collections.unmodifiableMap(\n",
        "316": "        Maps.transformValues(\n",
        "317": "            map,\n",
        "318": "            new Function<AtomicLong, Long>() {\n",
        "319": "              @Override\n",
        "320": "              public Long apply(AtomicLong atomic) {\n",
        "321": "                return atomic.get();\n",
        "322": "              }\n",
        "323": "            }));\n",
        "334": "   * Returns the number of key-value mappings in this map. If the map contains more than {@code\n",
        "335": "   * Integer.MAX_VALUE} elements, returns {@code Integer.MAX_VALUE}.\n",
        "363": "  /*\n",
        "364": "   * ConcurrentMap operations which we may eventually add.\n",
        "365": "   *\n",
        "366": "   * The problem with these is that remove(K, long) has to be done in two phases by definition ---\n",
        "367": "   * first decrementing to zero, and then removing. putIfAbsent or replace could observe the\n",
        "368": "   * intermediate zero-state. Ways we could deal with this are:\n",
        "369": "   *\n",
        "370": "   * - Don't define any of the ConcurrentMap operations. This is the current state of affairs.\n",
        "371": "   *\n",
        "372": "   * - Define putIfAbsent and replace as treating zero and absent identically (as currently\n",
        "373": "   *   implemented below). This is a bit surprising with putIfAbsent, which really becomes\n",
        "374": "   *   putIfZero.\n",
        "375": "   *\n",
        "376": "   * - Allow putIfAbsent and replace to distinguish between zero and absent, but don't implement\n",
        "377": "   *   remove(K, long). Without any two-phase operations it becomes feasible for all remaining\n",
        "378": "   *   operations to distinguish between zero and absent. If we do this, then perhaps we should add\n",
        "379": "   *   replace(key, long).\n",
        "380": "   *\n",
        "381": "   * - Introduce a special-value private static final AtomicLong that would have the meaning of\n",
        "382": "   *   removal-in-progress, and rework all operations to properly distinguish between zero and\n",
        "383": "   *   absent.\n",
        "384": "   */\n",
        "385": "\n",
        "388": "   * zero, associate it with {@code newValue}. Returns the previous value associated with {@code\n",
        "389": "   * key}, or zero if there was no mapping for {@code key}.\n",
        "392": "    while (true) {\n",
        "393": "      AtomicLong atomic = map.get(key);\n",
        "394": "      if (atomic == null) {\n",
        "395": "        atomic = map.putIfAbsent(key, new AtomicLong(newValue));\n",
        "396": "        if (atomic == null) {\n",
        "397": "          return 0L;\n",
        "398": "        }\n",
        "399": "        // atomic is now non-null; fall through\n",
        "400": "      }\n",
        "401": "\n",
        "402": "      long oldValue = atomic.get();\n",
        "403": "      if (oldValue == 0L) {\n",
        "404": "        // don't compareAndSet a zero\n",
        "405": "        if (map.replace(key, atomic, new AtomicLong(newValue))) {\n",
        "406": "          return 0L;\n",
        "407": "        }\n",
        "408": "        // atomic replaced\n",
        "409": "        continue;\n",
        "410": "      }\n",
        "411": "\n",
        "412": "      return oldValue;\n",
        "413": "    }\n",
        "417": "   * If {@code (key, expectedOldValue)} is currently in the map, this method replaces {@code\n",
        "418": "   * expectedOldValue} with {@code newValue} and returns true; otherwise, this method returns false.\n",
        "420": "   * <p>If {@code expectedOldValue} is zero, this method will succeed if {@code (key, zero)} is\n",
        "421": "   * currently in the map, or if {@code key} is not in the map at all.\n",
        "427": "      AtomicLong atomic = map.get(key);\n",
        "428": "      return (atomic == null) ? false : atomic.compareAndSet(expectedOldValue, newValue);\n",
        "433": "   * If {@code (key, value)} is currently in the map, this method removes it and returns true;\n",
        "434": "   * otherwise, this method returns false.\n",
        "437": "    AtomicLong atomic = map.get(key);\n",
        "438": "    if (atomic == null) {\n",
        "439": "      return false;\n",
        "440": "    }\n",
        "441": "\n",
        "442": "    long oldValue = atomic.get();\n",
        "443": "    if (oldValue != value) {\n",
        "444": "      return false;\n",
        "445": "    }\n",
        "446": "\n",
        "447": "    if (oldValue == 0L || atomic.compareAndSet(oldValue, 0L)) {\n",
        "448": "      // only remove after setting to zero, to avoid concurrent updates\n",
        "449": "      map.remove(key, atomic);\n",
        "450": "      // succeed even if the remove fails, since the value was already adjusted\n",
        "451": "      return true;\n",
        "452": "    }\n",
        "453": "\n",
        "454": "    // value changed\n",
        "455": "    return false;\n"
    }
}