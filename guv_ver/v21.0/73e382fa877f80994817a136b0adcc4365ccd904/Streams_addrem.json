{
    "addition": {
        "1": "/*\n",
        "2": " * Copyright (C) 2015 The Guava Authors\n",
        "3": " *\n",
        "4": " * Licensed under the Apache License, Version 2.0 (the \"License\"); you\n",
        "5": " * may not use this file except in compliance with the License.  You may\n",
        "6": " * obtain a copy of the License at\n",
        "7": " *\n",
        "8": " * http://www.apache.org/licenses/LICENSE-2.0\n",
        "9": " *\n",
        "10": " * Unless required by applicable law or agreed to in writing, software\n",
        "11": " * distributed under the License is distributed on an \"AS IS\" BASIS,\n",
        "12": " * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or\n",
        "13": " * implied.  See the License for the specific language governing\n",
        "14": " * permissions and limitations under the License.\n",
        "15": " */\n",
        "16": "\n",
        "17": "package com.google.common.collect;\n",
        "18": "\n",
        "19": "import static com.google.common.base.Preconditions.checkNotNull;\n",
        "20": "import static com.google.common.base.Preconditions.checkState;\n",
        "21": "\n",
        "22": "import com.google.common.annotations.Beta;\n",
        "23": "import com.google.common.annotations.GwtCompatible;\n",
        "24": "import com.google.common.math.LongMath;\n",
        "25": "import java.util.ArrayDeque;\n",
        "26": "import java.util.Collection;\n",
        "27": "import java.util.Deque;\n",
        "28": "import java.util.Iterator;\n",
        "29": "import java.util.OptionalDouble;\n",
        "30": "import java.util.OptionalInt;\n",
        "31": "import java.util.OptionalLong;\n",
        "32": "import java.util.Spliterator;\n",
        "33": "import java.util.Spliterators;\n",
        "34": "import java.util.Spliterators.AbstractSpliterator;\n",
        "35": "import java.util.function.BiFunction;\n",
        "36": "import java.util.function.Consumer;\n",
        "37": "import java.util.stream.DoubleStream;\n",
        "38": "import java.util.stream.IntStream;\n",
        "39": "import java.util.stream.LongStream;\n",
        "40": "import java.util.stream.Stream;\n",
        "41": "import java.util.stream.StreamSupport;\n",
        "42": "import javax.annotation.Nullable;\n",
        "43": "\n",
        "44": "/**\n",
        "45": " * Static utility methods related to {@code Stream} instances.\n",
        "46": " *\n",
        "47": " * @since 21.0\n",
        "48": " */\n",
        "49": "@Beta\n",
        "50": "@GwtCompatible\n",
        "51": "public final class Streams {\n",
        "52": "  /**\n",
        "53": "   * Returns a sequential {@link Stream} of the contents of {@code iterable}, delegating to {@link\n",
        "54": "   * Collection#stream} if possible.\n",
        "55": "   */\n",
        "56": "  public static <T> Stream<T> stream(Iterable<T> iterable) {\n",
        "57": "    return (iterable instanceof Collection)\n",
        "58": "        ? ((Collection<T>) iterable).stream()\n",
        "59": "        : StreamSupport.stream(iterable.spliterator(), false);\n",
        "60": "  }\n",
        "61": "\n",
        "62": "  /**\n",
        "63": "   * Returns {@link Collection#stream}.\n",
        "64": "   *\n",
        "65": "   * @deprecated There is no reason to use this; just invoke {@code collection.stream()} directly.\n",
        "66": "   */\n",
        "67": "  @Deprecated\n",
        "68": "  public static <T> Stream<T> stream(Collection<T> collection) {\n",
        "69": "    return collection.stream();\n",
        "70": "  }\n",
        "71": "\n",
        "72": "  /**\n",
        "73": "   * Returns a sequential {@link Stream} of the remaining contents of {@code iterator}. Do not use\n",
        "74": "   * {@code iterator} directly after passing it to this method.\n",
        "75": "   */\n",
        "76": "  public static <T> Stream<T> stream(Iterator<T> iterator) {\n",
        "77": "    return StreamSupport.stream(Spliterators.spliteratorUnknownSize(iterator, 0), false);\n",
        "78": "  }\n",
        "79": "\n",
        "80": "  /**\n",
        "81": "   * If a value is present in {@code optional}, returns a stream containing only that element,\n",
        "82": "   * otherwise returns an empty stream.\n",
        "83": "   */\n",
        "84": "  public static <T> Stream<T> stream(com.google.common.base.Optional<T> optional) {\n",
        "85": "    return optional.isPresent() ? Stream.of(optional.get()) : Stream.of();\n",
        "86": "  }\n",
        "87": "\n",
        "88": "  /**\n",
        "89": "   * If a value is present in {@code optional}, returns a stream containing only that element,\n",
        "90": "   * otherwise returns an empty stream.\n",
        "91": "   *\n",
        "92": "   * <p><b>Java 9 users:</b> use {@code optional.stream()} instead.\n",
        "93": "   */\n",
        "94": "  public static <T> Stream<T> stream(java.util.Optional<T> optional) {\n",
        "95": "    return optional.isPresent() ? Stream.of(optional.get()) : Stream.of();\n",
        "96": "  }\n",
        "97": "\n",
        "98": "  /**\n",
        "99": "   * Returns a {@link Stream} containing the elements of the first stream, followed by the elements\n",
        "100": "   * of the second stream, and so on.\n",
        "101": "   *\n",
        "102": "   * <p>This is equivalent to {@code Stream.of(streams).flatMap(stream -> stream)}, but the returned\n",
        "103": "   * stream may perform better.\n",
        "104": "   *\n",
        "105": "   * @see Stream#concat(Stream, Stream)\n",
        "106": "   */\n",
        "107": "  @SafeVarargs\n",
        "108": "  public static <T> Stream<T> concat(Stream<? extends T>... streams) {\n",
        "109": "    // TODO(lowasser): consider an implementation that can support SUBSIZED\n",
        "110": "    boolean isParallel = false;\n",
        "111": "    int characteristics = Spliterator.ORDERED | Spliterator.SIZED | Spliterator.NONNULL;\n",
        "112": "    long estimatedSize = 0L;\n",
        "113": "    ImmutableList.Builder<Spliterator<? extends T>> splitrsBuilder =\n",
        "114": "        new ImmutableList.Builder<>(streams.length);\n",
        "115": "    for (Stream<? extends T> stream : streams) {\n",
        "116": "      isParallel |= stream.isParallel();\n",
        "117": "      Spliterator<? extends T> splitr = stream.spliterator();\n",
        "118": "      splitrsBuilder.add(splitr);\n",
        "119": "      characteristics &= splitr.characteristics();\n",
        "120": "      estimatedSize = LongMath.saturatedAdd(estimatedSize, splitr.estimateSize());\n",
        "121": "    }\n",
        "122": "    return StreamSupport.stream(\n",
        "123": "        CollectSpliterators.flatMap(\n",
        "124": "            splitrsBuilder.build().spliterator(),\n",
        "125": "            splitr -> (Spliterator<T>) splitr,\n",
        "126": "            characteristics,\n",
        "127": "            estimatedSize),\n",
        "128": "        isParallel);\n",
        "129": "  }\n",
        "130": "\n",
        "131": "  /**\n",
        "132": "   * Returns an {@link IntStream} containing the elements of the first stream, followed by the\n",
        "133": "   * elements of the second stream, and so on.\n",
        "134": "   *\n",
        "135": "   * <p>This is equivalent to {@code Stream.of(streams).flatMapToInt(stream -> stream)}, but the\n",
        "136": "   * returned stream may perform better.\n",
        "137": "   *\n",
        "138": "   * @see IntStream#concat(IntStream, IntStream)\n",
        "139": "   */\n",
        "140": "  public static IntStream concat(IntStream... streams) {\n",
        "141": "    // TODO(lowasser): optimize this later\n",
        "142": "    return Stream.of(streams).flatMapToInt(stream -> stream);\n",
        "143": "  }\n",
        "144": "\n",
        "145": "  /**\n",
        "146": "   * Returns a {@link LongStream} containing the elements of the first stream, followed by the\n",
        "147": "   * elements of the second stream, and so on.\n",
        "148": "   *\n",
        "149": "   * <p>This is equivalent to {@code Stream.of(streams).flatMapToLong(stream -> stream)}, but the\n",
        "150": "   * returned stream may perform better.\n",
        "151": "   *\n",
        "152": "   * @see LongStream#concat(LongStream, LongStream)\n",
        "153": "   */\n",
        "154": "  public static LongStream concat(LongStream... streams) {\n",
        "155": "    // TODO(lowasser): optimize this later\n",
        "156": "    return Stream.of(streams).flatMapToLong(stream -> stream);\n",
        "157": "  }\n",
        "158": "\n",
        "159": "  /**\n",
        "160": "   * Returns a {@link DoubleStream} containing the elements of the first stream, followed by the\n",
        "161": "   * elements of the second stream, and so on.\n",
        "162": "   *\n",
        "163": "   * <p>This is equivalent to {@code Stream.of(streams).flatMapToDouble(stream -> stream)}, but the\n",
        "164": "   * returned stream may perform better.\n",
        "165": "   *\n",
        "166": "   * @see DoubleStream#concat(DoubleStream, DoubleStream)\n",
        "167": "   */\n",
        "168": "  public static DoubleStream concat(DoubleStream... streams) {\n",
        "169": "    // TODO(lowasser): optimize this later\n",
        "170": "    return Stream.of(streams).flatMapToDouble(stream -> stream);\n",
        "171": "  }\n",
        "172": "\n",
        "173": "  /**\n",
        "174": "   * If a value is present in {@code optional}, returns a stream containing only that element,\n",
        "175": "   * otherwise returns an empty stream.\n",
        "176": "   *\n",
        "177": "   * <p><b>Java 9 users:</b> use {@code optional.stream()} instead.\n",
        "178": "   */\n",
        "179": "  public static IntStream stream(OptionalInt optional) {\n",
        "180": "    return optional.isPresent() ? IntStream.of(optional.getAsInt()) : IntStream.empty();\n",
        "181": "  }\n",
        "182": "\n",
        "183": "  /**\n",
        "184": "   * If a value is present in {@code optional}, returns a stream containing only that element,\n",
        "185": "   * otherwise returns an empty stream.\n",
        "186": "   *\n",
        "187": "   * <p><b>Java 9 users:</b> use {@code optional.stream()} instead.\n",
        "188": "   */\n",
        "189": "  public static LongStream stream(OptionalLong optional) {\n",
        "190": "    return optional.isPresent() ? LongStream.of(optional.getAsLong()) : LongStream.empty();\n",
        "191": "  }\n",
        "192": "\n",
        "193": "  /**\n",
        "194": "   * If a value is present in {@code optional}, returns a stream containing only that element,\n",
        "195": "   * otherwise returns an empty stream.\n",
        "196": "   *\n",
        "197": "   * <p><b>Java 9 users:</b> use {@code optional.stream()} instead.\n",
        "198": "   */\n",
        "199": "  public static DoubleStream stream(OptionalDouble optional) {\n",
        "200": "    return optional.isPresent() ? DoubleStream.of(optional.getAsDouble()) : DoubleStream.empty();\n",
        "201": "  }\n",
        "202": "\n",
        "203": "  /**\n",
        "204": "   * Returns the last element of the specified stream, or {@link java.util.Optional#empty} if the\n",
        "205": "   * stream is empty.\n",
        "206": "   *\n",
        "207": "   * <p>Equivalent to {@code stream.reduce((a, b) -> b)}, but may perform significantly better. This\n",
        "208": "   * method's runtime will be between O(log n) and O(n), performing better on <a\n",
        "209": "   * href=\"http://gee.cs.oswego.edu/dl/html/StreamParallelGuidance.html\">efficiently splittable</a>\n",
        "210": "   * streams.\n",
        "211": "   *\n",
        "212": "   * <p>If the stream has nondeterministic order, this has equivalent semantics to {@link\n",
        "213": "   * Stream#findAny} (which you might as well use).\n",
        "214": "   *\n",
        "215": "   * @see Stream#findFirst()\n",
        "216": "   * @throws NullPointerException if the last element of the stream is null\n",
        "217": "   */\n",
        "218": "  public static <T> java.util.Optional<T> findLast(Stream<T> stream) {\n",
        "219": "    class OptionalState<T> {\n",
        "220": "      boolean set = false;\n",
        "221": "      T value = null;\n",
        "222": "\n",
        "223": "      void set(@Nullable T value) {\n",
        "224": "        this.set = true;\n",
        "225": "        this.value = value;\n",
        "226": "      }\n",
        "227": "\n",
        "228": "      T get() {\n",
        "229": "        checkState(set);\n",
        "230": "        return value;\n",
        "231": "      }\n",
        "232": "    }\n",
        "233": "    OptionalState<T> state = new OptionalState<>();\n",
        "234": "\n",
        "235": "    Deque<Spliterator<T>> splits = new ArrayDeque<>();\n",
        "236": "    splits.addLast(stream.spliterator());\n",
        "237": "\n",
        "238": "    while (!splits.isEmpty()) {\n",
        "239": "      Spliterator<T> spliterator = splits.removeLast();\n",
        "240": "\n",
        "241": "      if (spliterator.getExactSizeIfKnown() == 0) {\n",
        "242": "        continue; // drop this split\n",
        "243": "      }\n",
        "244": "\n",
        "245": "      // Many spliterators will have trySplits that are SUBSIZED even if they are not themselves\n",
        "246": "      // SUBSIZED.\n",
        "247": "      if (spliterator.hasCharacteristics(Spliterator.SUBSIZED)) {\n",
        "248": "        // we can drill down to exactly the smallest nonempty spliterator\n",
        "249": "        while (true) {\n",
        "250": "          Spliterator<T> prefix = spliterator.trySplit();\n",
        "251": "          if (prefix == null || prefix.getExactSizeIfKnown() == 0) {\n",
        "252": "            break;\n",
        "253": "          } else if (spliterator.getExactSizeIfKnown() == 0) {\n",
        "254": "            spliterator = prefix;\n",
        "255": "            break;\n",
        "256": "          }\n",
        "257": "        }\n",
        "258": "\n",
        "259": "        // spliterator is known to be nonempty now\n",
        "260": "        spliterator.forEachRemaining(state::set);\n",
        "261": "        return java.util.Optional.of(state.get());\n",
        "262": "      }\n",
        "263": "\n",
        "264": "      Spliterator<T> prefix = spliterator.trySplit();\n",
        "265": "      if (prefix == null || prefix.getExactSizeIfKnown() == 0) {\n",
        "266": "        // we can't split this any further\n",
        "267": "        spliterator.forEachRemaining(state::set);\n",
        "268": "        if (state.set) {\n",
        "269": "          return java.util.Optional.of(state.get());\n",
        "270": "        }\n",
        "271": "        // fall back to the last split\n",
        "272": "        continue;\n",
        "273": "      }\n",
        "274": "      splits.addLast(prefix);\n",
        "275": "      splits.addLast(spliterator);\n",
        "276": "    }\n",
        "277": "    return java.util.Optional.empty();\n",
        "278": "  }\n",
        "279": "\n",
        "280": "  /**\n",
        "281": "   * Returns the last element of the specified stream, or {@link OptionalInt#empty} if the stream is\n",
        "282": "   * empty.\n",
        "283": "   *\n",
        "284": "   * <p>Equivalent to {@code stream.reduce((a, b) -> b)}, but may perform significantly better. This\n",
        "285": "   * method's runtime will be between O(log n) and O(n), performing better on <a\n",
        "286": "   * href=\"http://gee.cs.oswego.edu/dl/html/StreamParallelGuidance.html\">efficiently splittable</a>\n",
        "287": "   * streams.\n",
        "288": "   *\n",
        "289": "   * @see IntStream#findFirst()\n",
        "290": "   * @throws NullPointerException if the last element of the stream is null\n",
        "291": "   */\n",
        "292": "  public static OptionalInt findLast(IntStream stream) {\n",
        "293": "    // findLast(Stream) does some allocation, so we might as well box some more\n",
        "294": "    java.util.Optional<Integer> boxedLast = findLast(stream.boxed());\n",
        "295": "    return boxedLast.isPresent() ? OptionalInt.of(boxedLast.get()) : OptionalInt.empty();\n",
        "296": "  }\n",
        "297": "\n",
        "298": "  /**\n",
        "299": "   * Returns the last element of the specified stream, or {@link OptionalLong#empty} if the stream\n",
        "300": "   * is empty.\n",
        "301": "   *\n",
        "302": "   * <p>Equivalent to {@code stream.reduce((a, b) -> b)}, but may perform significantly better. This\n",
        "303": "   * method's runtime will be between O(log n) and O(n), performing better on <a\n",
        "304": "   * href=\"http://gee.cs.oswego.edu/dl/html/StreamParallelGuidance.html\">efficiently splittable</a>\n",
        "305": "   * streams.\n",
        "306": "   *\n",
        "307": "   * @see LongStream#findFirst()\n",
        "308": "   * @throws NullPointerException if the last element of the stream is null\n",
        "309": "   */\n",
        "310": "  public static OptionalLong findLast(LongStream stream) {\n",
        "311": "    // findLast(Stream) does some allocation, so we might as well box some more\n",
        "312": "    java.util.Optional<Long> boxedLast = findLast(stream.boxed());\n",
        "313": "    return boxedLast.isPresent() ? OptionalLong.of(boxedLast.get()) : OptionalLong.empty();\n",
        "314": "  }\n",
        "315": "\n",
        "316": "  /**\n",
        "317": "   * Returns the last element of the specified stream, or {@link OptionalDouble#empty} if the stream\n",
        "318": "   * is empty.\n",
        "319": "   *\n",
        "320": "   * <p>Equivalent to {@code stream.reduce((a, b) -> b)}, but may perform significantly better. This\n",
        "321": "   * method's runtime will be between O(log n) and O(n), performing better on <a\n",
        "322": "   * href=\"http://gee.cs.oswego.edu/dl/html/StreamParallelGuidance.html\">efficiently splittable</a>\n",
        "323": "   * streams.\n",
        "324": "   *\n",
        "325": "   * @see DoubleStream#findFirst()\n",
        "326": "   * @throws NullPointerException if the last element of the stream is null\n",
        "327": "   */\n",
        "328": "  public static OptionalDouble findLast(DoubleStream stream) {\n",
        "329": "    // findLast(Stream) does some allocation, so we might as well box some more\n",
        "330": "    java.util.Optional<Double> boxedLast = findLast(stream.boxed());\n",
        "331": "    return boxedLast.isPresent() ? OptionalDouble.of(boxedLast.get()) : OptionalDouble.empty();\n",
        "332": "  }\n",
        "333": "\n",
        "334": "  /**\n",
        "335": "   * Returns a stream in which each element is the result of passing the corresponding element of\n",
        "336": "   * each of {@code streamA} and {@code streamB} to {@code function}.\n",
        "337": "   *\n",
        "338": "   * <p>For example:\n",
        "339": "   *\n",
        "340": "   * <pre>{@code\n",
        "341": "   * Streams.zip(\n",
        "342": "   *   Stream.of(\"foo1\", \"foo2\", \"foo3\"),\n",
        "343": "   *   Stream.of(\"bar1\", \"bar2\"),\n",
        "344": "   *   (arg1, arg2) -> arg1 + \":\" + arg2)\n",
        "345": "   * }</pre>\n",
        "346": "   *\n",
        "347": "   * <p>will return {@code Stream.of(\"foo1:bar1\", \"foo2:bar2\")}.\n",
        "348": "   *\n",
        "349": "   * <p>The resulting stream will only be as long as the shorter of the two input streams; if one\n",
        "350": "   * stream is longer, its extra elements will be ignored.\n",
        "351": "   *\n",
        "352": "   * <p>The resulting stream is not <a\n",
        "353": "   * href=\"http://gee.cs.oswego.edu/dl/html/StreamParallelGuidance.html\">efficiently splittable</a>.\n",
        "354": "   * This may harm parallel performance.\n",
        "355": "   */\n",
        "356": "  public static <A, B, R> Stream<R> zip(\n",
        "357": "      Stream<A> streamA, Stream<B> streamB, BiFunction<? super A, ? super B, R> function) {\n",
        "358": "    checkNotNull(streamA);\n",
        "359": "    checkNotNull(streamB);\n",
        "360": "    checkNotNull(function);\n",
        "361": "    boolean isParallel = streamA.isParallel() || streamB.isParallel(); // same as Stream.concat\n",
        "362": "    Spliterator<A> splitrA = streamA.spliterator();\n",
        "363": "    Spliterator<B> splitrB = streamB.spliterator();\n",
        "364": "    int characteristics =\n",
        "365": "        splitrA.characteristics()\n",
        "366": "            & splitrB.characteristics()\n",
        "367": "            & (Spliterator.SIZED | Spliterator.ORDERED);\n",
        "368": "    Iterator<A> itrA = Spliterators.iterator(splitrA);\n",
        "369": "    Iterator<B> itrB = Spliterators.iterator(splitrB);\n",
        "370": "    return StreamSupport.stream(\n",
        "371": "        new AbstractSpliterator<R>(\n",
        "372": "            Math.min(splitrA.estimateSize(), splitrB.estimateSize()), characteristics) {\n",
        "373": "          @Override\n",
        "374": "          public boolean tryAdvance(Consumer<? super R> action) {\n",
        "375": "            if (itrA.hasNext() && itrB.hasNext()) {\n",
        "376": "              action.accept(function.apply(itrA.next(), itrB.next()));\n",
        "377": "              return true;\n",
        "378": "            }\n",
        "379": "            return false;\n",
        "380": "          }\n",
        "381": "        },\n",
        "382": "        isParallel);\n",
        "383": "  }\n",
        "384": "  /**\n",
        "385": "   * An analogue of {@link java.util.function.Function} also accepting an index.\n",
        "386": "   *\n",
        "387": "   * <p>This interface is only intended for use by callers of {@link #mapWithIndex}.\n",
        "388": "   */\n",
        "389": "  public interface FunctionWithIndex<T, R> {\n",
        "390": "    /** Applies this function to the given argument and its index within a stream. */\n",
        "391": "    R apply(T from, long index);\n",
        "392": "  }\n",
        "393": "\n",
        "394": "  /**\n",
        "395": "   * Returns a stream consisting of the results of applying the given function to the elements of\n",
        "396": "   * {@code stream} and their indices in the stream. For example,\n",
        "397": "   *\n",
        "398": "   * <pre>{@code\n",
        "399": "   * mapWithIndex(\n",
        "400": "   *     Stream.of(\"a\", \"b\", \"c\"),\n",
        "401": "   *     (str, index) -> str + \":\" + index)\n",
        "402": "   * }</pre>\n",
        "403": "   *\n",
        "404": "   * <p>would return {@code Stream.of(\"a:0\", \"b:1\", \"c:2\")}.\n",
        "405": "   *\n",
        "406": "   * <p>The resulting stream is <a\n",
        "407": "   * href=\"http://gee.cs.oswego.edu/dl/html/StreamParallelGuidance.html\">efficiently splittable</a>\n",
        "408": "   * if and only if {@code stream} was efficiently splittable and its underlying spliterator\n",
        "409": "   * reported {@link Spliterator#SUBSIZED}. This is generally the case if the underlying stream\n",
        "410": "   * comes from a data structure supporting efficient indexed random access, typically an array or\n",
        "411": "   * list.\n",
        "412": "   *\n",
        "413": "   * <p>The order of the resulting stream is defined if and only if the order of the original stream\n",
        "414": "   * was defined.\n",
        "415": "   */\n",
        "416": "  public static <T, R> Stream<R> mapWithIndex(\n",
        "417": "      Stream<T> stream, FunctionWithIndex<? super T, ? extends R> function) {\n",
        "418": "    checkNotNull(stream);\n",
        "419": "    checkNotNull(function);\n",
        "420": "    boolean isParallel = stream.isParallel();\n",
        "421": "    Spliterator<T> fromSpliterator = stream.spliterator();\n",
        "422": "\n",
        "423": "    if (!fromSpliterator.hasCharacteristics(Spliterator.SUBSIZED)) {\n",
        "424": "      Iterator<T> fromIterator = Spliterators.iterator(fromSpliterator);\n",
        "425": "      return StreamSupport.stream(\n",
        "426": "          new AbstractSpliterator<R>(\n",
        "427": "              fromSpliterator.estimateSize(),\n",
        "428": "              fromSpliterator.characteristics() & (Spliterator.ORDERED | Spliterator.SIZED)) {\n",
        "429": "            long index = 0;\n",
        "430": "\n",
        "431": "            @Override\n",
        "432": "            public boolean tryAdvance(Consumer<? super R> action) {\n",
        "433": "              if (fromIterator.hasNext()) {\n",
        "434": "                action.accept(function.apply(fromIterator.next(), index++));\n",
        "435": "                return true;\n",
        "436": "              }\n",
        "437": "              return false;\n",
        "438": "            }\n",
        "439": "          },\n",
        "440": "          isParallel);\n",
        "441": "    }\n",
        "442": "    class Splitr implements Spliterator<R>, Consumer<T> {\n",
        "443": "      final Spliterator<T> splitr;\n",
        "444": "      long index;\n",
        "445": "      T holder = null;\n",
        "446": "\n",
        "447": "      Splitr(Spliterator<T> splitr, long index) {\n",
        "448": "        this.splitr = splitr;\n",
        "449": "        this.index = index;\n",
        "450": "      }\n",
        "451": "\n",
        "452": "      @Override\n",
        "453": "      public void accept(@Nullable T t) {\n",
        "454": "        this.holder = t;\n",
        "455": "      }\n",
        "456": "\n",
        "457": "      @Override\n",
        "458": "      public boolean tryAdvance(Consumer<? super R> action) {\n",
        "459": "        if (splitr.tryAdvance(this)) {\n",
        "460": "          try {\n",
        "461": "            action.accept(function.apply(holder, index++));\n",
        "462": "            return true;\n",
        "463": "          } finally {\n",
        "464": "            holder = null;\n",
        "465": "          }\n",
        "466": "        }\n",
        "467": "        return false;\n",
        "468": "      }\n",
        "469": "\n",
        "470": "      @Override\n",
        "471": "      public Spliterator<R> trySplit() {\n",
        "472": "        Spliterator<T> split = splitr.trySplit();\n",
        "473": "        if (split == null) {\n",
        "474": "          return null;\n",
        "475": "        }\n",
        "476": "        Spliterator<R> result = new Splitr(split, index);\n",
        "477": "        this.index += split.getExactSizeIfKnown();\n",
        "478": "        return result;\n",
        "479": "      }\n",
        "480": "\n",
        "481": "      @Override\n",
        "482": "      public long estimateSize() {\n",
        "483": "        return splitr.estimateSize();\n",
        "484": "      }\n",
        "485": "\n",
        "486": "      @Override\n",
        "487": "      public int characteristics() {\n",
        "488": "        return splitr.characteristics()\n",
        "489": "            & (Spliterator.ORDERED | Spliterator.SIZED | Spliterator.SUBSIZED);\n",
        "490": "      }\n",
        "491": "    }\n",
        "492": "    return StreamSupport.stream(new Splitr(fromSpliterator, 0), isParallel);\n",
        "493": "  }\n",
        "494": "\n",
        "495": "  private Streams() {}\n",
        "496": "}\n"
    },
    "removed": {}
}