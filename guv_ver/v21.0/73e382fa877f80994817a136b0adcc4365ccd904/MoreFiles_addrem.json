{
    "addition": {
        "1": "/*\n",
        "2": " * Copyright (C) 2013 The Guava Authors\n",
        "3": " *\n",
        "4": " * Licensed under the Apache License, Version 2.0 (the \"License\");\n",
        "5": " * you may not use this file except in compliance with the License.\n",
        "6": " * You may obtain a copy of the License at\n",
        "7": " *\n",
        "8": " * http://www.apache.org/licenses/LICENSE-2.0\n",
        "9": " *\n",
        "10": " * Unless required by applicable law or agreed to in writing, software\n",
        "11": " * distributed under the License is distributed on an \"AS IS\" BASIS,\n",
        "12": " * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n",
        "13": " * See the License for the specific language governing permissions and\n",
        "14": " * limitations under the License.\n",
        "15": " */\n",
        "16": "\n",
        "17": "package com.google.common.io;\n",
        "18": "\n",
        "19": "import static com.google.common.base.Preconditions.checkNotNull;\n",
        "20": "import static java.nio.file.LinkOption.NOFOLLOW_LINKS;\n",
        "21": "\n",
        "22": "import com.google.common.annotations.Beta;\n",
        "23": "import com.google.common.annotations.GwtIncompatible;\n",
        "24": "import com.google.common.base.Optional;\n",
        "25": "import com.google.common.base.Predicate;\n",
        "26": "import com.google.common.collect.ImmutableList;\n",
        "27": "import com.google.common.collect.TreeTraverser;\n",
        "28": "import com.google.j2objc.annotations.J2ObjCIncompatible;\n",
        "29": "import java.io.IOException;\n",
        "30": "import java.io.InputStream;\n",
        "31": "import java.io.OutputStream;\n",
        "32": "import java.nio.channels.Channels;\n",
        "33": "import java.nio.channels.SeekableByteChannel;\n",
        "34": "import java.nio.charset.Charset;\n",
        "35": "import java.nio.file.DirectoryIteratorException;\n",
        "36": "import java.nio.file.DirectoryStream;\n",
        "37": "import java.nio.file.FileAlreadyExistsException;\n",
        "38": "import java.nio.file.FileSystemException;\n",
        "39": "import java.nio.file.Files;\n",
        "40": "import java.nio.file.LinkOption;\n",
        "41": "import java.nio.file.NoSuchFileException;\n",
        "42": "import java.nio.file.NotDirectoryException;\n",
        "43": "import java.nio.file.OpenOption;\n",
        "44": "import java.nio.file.Path;\n",
        "45": "import java.nio.file.SecureDirectoryStream;\n",
        "46": "import java.nio.file.StandardOpenOption;\n",
        "47": "import java.nio.file.attribute.BasicFileAttributeView;\n",
        "48": "import java.nio.file.attribute.BasicFileAttributes;\n",
        "49": "import java.nio.file.attribute.FileAttribute;\n",
        "50": "import java.nio.file.attribute.FileTime;\n",
        "51": "import java.util.ArrayList;\n",
        "52": "import java.util.Arrays;\n",
        "53": "import java.util.Collection;\n",
        "54": "import javax.annotation.Nullable;\n",
        "55": "\n",
        "56": "/**\n",
        "57": " * Static utilities for use with {@link Path} instances, intended to complement {@link Files}.\n",
        "58": " *\n",
        "59": " * @since 21.0\n",
        "60": " * @author Colin Decker\n",
        "61": " */\n",
        "62": "@Beta\n",
        "63": "@AndroidIncompatible\n",
        "64": "@GwtIncompatible\n",
        "65": "@J2ObjCIncompatible // java.nio.file\n",
        "66": "public final class MoreFiles {\n",
        "67": "\n",
        "68": "  private MoreFiles() {}\n",
        "69": "\n",
        "70": "  /**\n",
        "71": "   * Returns a view of the given {@code path} as a {@link ByteSource}.\n",
        "72": "   *\n",
        "73": "   * <p>Any {@linkplain OpenOption open options} provided are used when opening streams to the file\n",
        "74": "   * and may affect the behavior of the returned source and the streams it provides. See {@link\n",
        "75": "   * StandardOpenOption} for the standard options that may be provided. Providing no options is\n",
        "76": "   * equivalent to providing the {@link StandardOpenOption#READ READ} option.\n",
        "77": "   */\n",
        "78": "  public static ByteSource asByteSource(Path path, OpenOption... options) {\n",
        "79": "    return new PathByteSource(path, options);\n",
        "80": "  }\n",
        "81": "\n",
        "82": "  private static final class PathByteSource extends ByteSource {\n",
        "83": "\n",
        "84": "    private static final LinkOption[] FOLLOW_LINKS = {};\n",
        "85": "\n",
        "86": "    private final Path path;\n",
        "87": "    private final OpenOption[] options;\n",
        "88": "    private final boolean followLinks;\n",
        "89": "\n",
        "90": "    private PathByteSource(Path path, OpenOption... options) {\n",
        "91": "      this.path = checkNotNull(path);\n",
        "92": "      this.options = options.clone();\n",
        "93": "      this.followLinks = followLinks(this.options);\n",
        "94": "      // TODO(cgdecker): validate the provided options... for example, just WRITE seems wrong\n",
        "95": "    }\n",
        "96": "\n",
        "97": "    private static boolean followLinks(OpenOption[] options) {\n",
        "98": "      for (OpenOption option : options) {\n",
        "99": "        if (option == NOFOLLOW_LINKS) {\n",
        "100": "          return false;\n",
        "101": "        }\n",
        "102": "      }\n",
        "103": "      return true;\n",
        "104": "    }\n",
        "105": "\n",
        "106": "    @Override\n",
        "107": "    public InputStream openStream() throws IOException {\n",
        "108": "      return Files.newInputStream(path, options);\n",
        "109": "    }\n",
        "110": "\n",
        "111": "    private BasicFileAttributes readAttributes() throws IOException {\n",
        "112": "      return Files.readAttributes(\n",
        "113": "          path, BasicFileAttributes.class,\n",
        "114": "          followLinks ? FOLLOW_LINKS : new LinkOption[] { NOFOLLOW_LINKS });\n",
        "115": "    }\n",
        "116": "\n",
        "117": "    @Override\n",
        "118": "    public Optional<Long> sizeIfKnown() {\n",
        "119": "      BasicFileAttributes attrs;\n",
        "120": "      try {\n",
        "121": "        attrs = readAttributes();\n",
        "122": "      } catch (IOException e) {\n",
        "123": "        // Failed to get attributes; we don't know the size.\n",
        "124": "        return Optional.absent();\n",
        "125": "      }\n",
        "126": "\n",
        "127": "      // Don't return a size for directories or symbolic links; their sizes are implementation\n",
        "128": "      // specific and they can't be read as bytes using the read methods anyway.\n",
        "129": "      if (attrs.isDirectory() || attrs.isSymbolicLink()) {\n",
        "130": "        return Optional.absent();\n",
        "131": "      }\n",
        "132": "\n",
        "133": "      return Optional.of(attrs.size());\n",
        "134": "    }\n",
        "135": "\n",
        "136": "    @Override\n",
        "137": "    public long size() throws IOException {\n",
        "138": "      BasicFileAttributes attrs = readAttributes();\n",
        "139": "\n",
        "140": "      // Don't return a size for directories or symbolic links; their sizes are implementation\n",
        "141": "      // specific and they can't be read as bytes using the read methods anyway.\n",
        "142": "      if (attrs.isDirectory()) {\n",
        "143": "        throw new IOException(\"can't read: is a directory\");\n",
        "144": "      } else if (attrs.isSymbolicLink()) {\n",
        "145": "        throw new IOException(\"can't read: is a symbolic link\");\n",
        "146": "      }\n",
        "147": "\n",
        "148": "      return attrs.size();\n",
        "149": "    }\n",
        "150": "\n",
        "151": "    @Override\n",
        "152": "    public byte[] read() throws IOException {\n",
        "153": "      try (SeekableByteChannel channel = Files.newByteChannel(path, options)) {\n",
        "154": "        return com.google.common.io.Files.readFile(\n",
        "155": "            Channels.newInputStream(channel), channel.size());\n",
        "156": "      }\n",
        "157": "    }\n",
        "158": "\n",
        "159": "    @Override\n",
        "160": "    public String toString() {\n",
        "161": "      return \"MoreFiles.asByteSource(\" + path + \", \" + Arrays.toString(options) + \")\";\n",
        "162": "    }\n",
        "163": "  }\n",
        "164": "\n",
        "165": "  /**\n",
        "166": "   * Returns a view of the given {@code path} as a {@link ByteSink}.\n",
        "167": "   *\n",
        "168": "   * <p>Any {@linkplain OpenOption open options} provided are used when opening streams to the file\n",
        "169": "   * and may affect the behavior of the returned sink and the streams it provides. See {@link\n",
        "170": "   * StandardOpenOption} for the standard options that may be provided. Providing no options is\n",
        "171": "   * equivalent to providing the {@link StandardOpenOption#CREATE CREATE}, {@link\n",
        "172": "   * StandardOpenOption#TRUNCATE_EXISTING TRUNCATE_EXISTING} and {@link StandardOpenOption#WRITE\n",
        "173": "   * WRITE} options.\n",
        "174": "   */\n",
        "175": "  public static ByteSink asByteSink(Path path, OpenOption... options) {\n",
        "176": "    return new PathByteSink(path, options);\n",
        "177": "  }\n",
        "178": "\n",
        "179": "  private static final class PathByteSink extends ByteSink {\n",
        "180": "\n",
        "181": "    private final Path path;\n",
        "182": "    private final OpenOption[] options;\n",
        "183": "\n",
        "184": "    private PathByteSink(Path path, OpenOption... options) {\n",
        "185": "      this.path = checkNotNull(path);\n",
        "186": "      this.options = options.clone();\n",
        "187": "      // TODO(cgdecker): validate the provided options... for example, just READ seems wrong\n",
        "188": "    }\n",
        "189": "\n",
        "190": "    @Override\n",
        "191": "    public OutputStream openStream() throws IOException {\n",
        "192": "      return Files.newOutputStream(path, options);\n",
        "193": "    }\n",
        "194": "\n",
        "195": "    @Override\n",
        "196": "    public String toString() {\n",
        "197": "      return \"MoreFiles.asByteSink(\" + path + \", \" + Arrays.toString(options) + \")\";\n",
        "198": "    }\n",
        "199": "  }\n",
        "200": "\n",
        "201": "  /**\n",
        "202": "   * Returns a view of the given {@code path} as a {@link CharSource} using the given {@code\n",
        "203": "   * charset}.\n",
        "204": "   *\n",
        "205": "   * <p>Any {@linkplain OpenOption open options} provided are used when opening streams to the file\n",
        "206": "   * and may affect the behavior of the returned source and the streams it provides. See {@link\n",
        "207": "   * StandardOpenOption} for the standard options that may be provided. Providing no options is\n",
        "208": "   * equivalent to providing the {@link StandardOpenOption#READ READ} option.\n",
        "209": "   */\n",
        "210": "  public static CharSource asCharSource(Path path, Charset charset, OpenOption... options) {\n",
        "211": "    return asByteSource(path, options).asCharSource(charset);\n",
        "212": "  }\n",
        "213": "\n",
        "214": "  /**\n",
        "215": "   * Returns a view of the given {@code path} as a {@link CharSink} using the given {@code\n",
        "216": "   * charset}.\n",
        "217": "   *\n",
        "218": "   * <p>Any {@linkplain OpenOption open options} provided are used when opening streams to the file\n",
        "219": "   * and may affect the behavior of the returned sink and the streams it provides. See {@link\n",
        "220": "   * StandardOpenOption} for the standard options that may be provided. Providing no options is\n",
        "221": "   * equivalent to providing the {@link StandardOpenOption#CREATE CREATE}, {@link\n",
        "222": "   * StandardOpenOption#TRUNCATE_EXISTING TRUNCATE_EXISTING} and {@link StandardOpenOption#WRITE\n",
        "223": "   * WRITE} options.\n",
        "224": "   */\n",
        "225": "  public static CharSink asCharSink(Path path, Charset charset, OpenOption... options) {\n",
        "226": "    return asByteSink(path, options).asCharSink(charset);\n",
        "227": "  }\n",
        "228": "\n",
        "229": "  /**\n",
        "230": "   * Returns an immutable list of paths to the files contained in the given directory.\n",
        "231": "   *\n",
        "232": "   * @throws NoSuchFileException if the file does not exist <i>(optional specific exception)</i>\n",
        "233": "   * @throws NotDirectoryException if the file could not be opened because it is not a directory\n",
        "234": "   *     <i>(optional specific exception)</i>\n",
        "235": "   * @throws IOException if an I/O error occurs\n",
        "236": "   */\n",
        "237": "  public static ImmutableList<Path> listFiles(Path dir) throws IOException {\n",
        "238": "    try (DirectoryStream<Path> stream = Files.newDirectoryStream(dir)) {\n",
        "239": "      return ImmutableList.copyOf(stream);\n",
        "240": "    } catch (DirectoryIteratorException e) {\n",
        "241": "      throw e.getCause();\n",
        "242": "    }\n",
        "243": "  }\n",
        "244": "\n",
        "245": "  /**\n",
        "246": "   * Returns a {@link TreeTraverser} for traversing a directory tree. The returned traverser\n",
        "247": "   * attempts to avoid following symbolic links to directories. However, the traverser cannot\n",
        "248": "   * guarantee that it will not follow symbolic links to directories as it is possible for a\n",
        "249": "   * directory to be replaced with a symbolic link between checking if the file is a directory and\n",
        "250": "   * actually reading the contents of that directory.\n",
        "251": "   *\n",
        "252": "   * <p>Note that if the {@link Path} passed to one of the traversal methods does not exist, no\n",
        "253": "   * exception will be thrown and the returned {@link Iterable} will contain a single element: that\n",
        "254": "   * path.\n",
        "255": "   *\n",
        "256": "   * <p>{@link DirectoryIteratorException}  may be thrown when iterating {@link Iterable} instances\n",
        "257": "   * created by this traverser if an {@link IOException} is thrown by a call to\n",
        "258": "   * {@link #listFiles(Path)}.\n",
        "259": "   */\n",
        "260": "  public static TreeTraverser<Path> directoryTreeTraverser() {\n",
        "261": "    return DirectoryTreeTraverser.INSTANCE;\n",
        "262": "  }\n",
        "263": "\n",
        "264": "  private static final class DirectoryTreeTraverser extends TreeTraverser<Path> {\n",
        "265": "\n",
        "266": "    private static final DirectoryTreeTraverser INSTANCE = new DirectoryTreeTraverser();\n",
        "267": "\n",
        "268": "    @Override\n",
        "269": "    public Iterable<Path> children(Path dir) {\n",
        "270": "      if (Files.isDirectory(dir, NOFOLLOW_LINKS)) {\n",
        "271": "        try {\n",
        "272": "          return listFiles(dir);\n",
        "273": "        } catch (IOException e) {\n",
        "274": "          // the exception thrown when iterating a DirectoryStream if an I/O exception occurs\n",
        "275": "          throw new DirectoryIteratorException(e);\n",
        "276": "        }\n",
        "277": "      }\n",
        "278": "      return ImmutableList.of();\n",
        "279": "    }\n",
        "280": "  }\n",
        "281": "\n",
        "282": "  /**\n",
        "283": "   * Returns a predicate that returns the result of {@link Files#isDirectory(Path, LinkOption...)}\n",
        "284": "   * on input paths with the given link options.\n",
        "285": "   */\n",
        "286": "  public static Predicate<Path> isDirectory(LinkOption... options) {\n",
        "287": "    final LinkOption[] optionsCopy = options.clone();\n",
        "288": "    return new Predicate<Path>() {\n",
        "289": "      @Override\n",
        "290": "      public boolean apply(Path input) {\n",
        "291": "        return Files.isDirectory(input, optionsCopy);\n",
        "292": "      }\n",
        "293": "\n",
        "294": "      @Override\n",
        "295": "      public String toString() {\n",
        "296": "        return \"MoreFiles.isDirectory(\" + Arrays.toString(optionsCopy) + \")\";\n",
        "297": "      }\n",
        "298": "    };\n",
        "299": "  }\n",
        "300": "\n",
        "301": "  /**\n",
        "302": "   * Returns a predicate that returns the result of\n",
        "303": "   * {@link Files#isRegularFile(Path, LinkOption...)} on input paths with the given link options.\n",
        "304": "   */\n",
        "305": "  public static Predicate<Path> isRegularFile(LinkOption... options) {\n",
        "306": "    final LinkOption[] optionsCopy = options.clone();\n",
        "307": "    return new Predicate<Path>() {\n",
        "308": "      @Override\n",
        "309": "      public boolean apply(Path input) {\n",
        "310": "        return Files.isRegularFile(input, optionsCopy);\n",
        "311": "      }\n",
        "312": "\n",
        "313": "      @Override\n",
        "314": "      public String toString() {\n",
        "315": "        return \"MoreFiles.isRegularFile(\" + Arrays.toString(optionsCopy) + \")\";\n",
        "316": "      }\n",
        "317": "    };\n",
        "318": "  }\n",
        "319": "\n",
        "320": "  /**\n",
        "321": "   * Like the unix command of the same name, creates an empty file or updates the last modified\n",
        "322": "   * timestamp of the existing file at the given path to the current system time.\n",
        "323": "   */\n",
        "324": "  public static void touch(Path path) throws IOException {\n",
        "325": "    checkNotNull(path);\n",
        "326": "\n",
        "327": "    try {\n",
        "328": "      Files.setLastModifiedTime(path, FileTime.fromMillis(System.currentTimeMillis()));\n",
        "329": "    } catch (NoSuchFileException e) {\n",
        "330": "      try {\n",
        "331": "        Files.createFile(path);\n",
        "332": "      } catch (FileAlreadyExistsException ignore) {\n",
        "333": "        // The file didn't exist when we called setLastModifiedTime, but it did when we called\n",
        "334": "        // createFile, so something else created the file in between. The end result is\n",
        "335": "        // what we wanted: a new file that probably has its last modified time set to approximately\n",
        "336": "        // now. Or it could have an arbitrary last modified time set by the creator, but that's no\n",
        "337": "        // different than if another process set its last modified time to something else after we\n",
        "338": "        // created it here.\n",
        "339": "      }\n",
        "340": "    }\n",
        "341": "  }\n",
        "342": "\n",
        "343": "  /**\n",
        "344": "   * Creates any necessary but nonexistent parent directories of the specified path. Note that if\n",
        "345": "   * this operation fails, it may have succeeded in creating some (but not all) of the necessary\n",
        "346": "   * parent directories. The parent directory is created with the given {@code attrs}.\n",
        "347": "   *\n",
        "348": "   * @throws IOException if an I/O error occurs, or if any necessary but nonexistent parent\n",
        "349": "   *                     directories of the specified file could not be created.\n",
        "350": "   */\n",
        "351": "  public static void createParentDirectories(\n",
        "352": "      Path path, FileAttribute<?>... attrs) throws IOException {\n",
        "353": "    // Interestingly, unlike File.getCanonicalFile(), Path/Files provides no way of getting the\n",
        "354": "    // canonical (absolute, normalized, symlinks resolved, etc.) form of a path to a nonexistent\n",
        "355": "    // file. getCanonicalFile() can at least get the canonical form of the part of the path which\n",
        "356": "    // actually exists and then append the normalized remainder of the path to that.\n",
        "357": "    Path normalizedAbsolutePath = path.toAbsolutePath().normalize();\n",
        "358": "    Path parent = normalizedAbsolutePath.getParent();\n",
        "359": "    if (parent == null) {\n",
        "360": "       // The given directory is a filesystem root. All zero of its ancestors exist. This doesn't\n",
        "361": "       // mean that the root itself exists -- consider x:\\ on a Windows machine without such a\n",
        "362": "       // drive -- or even that the caller can create it, but this method makes no such guarantees\n",
        "363": "       // even for non-root files.\n",
        "364": "      return;\n",
        "365": "    }\n",
        "366": "\n",
        "367": "    // Check if the parent is a directory first because createDirectories will fail if the parent\n",
        "368": "    // exists and is a symlink to a directory... we'd like for this to succeed in that case.\n",
        "369": "    // (I'm kind of surprised that createDirectories would fail in that case; doesn't seem like\n",
        "370": "    // what you'd want to happen.)\n",
        "371": "    if (!Files.isDirectory(parent)) {\n",
        "372": "      Files.createDirectories(parent, attrs);\n",
        "373": "      if (!Files.isDirectory(parent)) {\n",
        "374": "        throw new IOException(\"Unable to create parent directories of \" + path);\n",
        "375": "      }\n",
        "376": "    }\n",
        "377": "  }\n",
        "378": "\n",
        "379": "  /**\n",
        "380": "   * Returns the <a href=\"http://en.wikipedia.org/wiki/Filename_extension\">file extension</a> for\n",
        "381": "   * the file at the given path, or the empty string if the file has no extension. The result does\n",
        "382": "   * not include the '{@code .}'.\n",
        "383": "   */\n",
        "384": "  public static String getFileExtension(Path path) {\n",
        "385": "    Path name = path.getFileName();\n",
        "386": "\n",
        "387": "    // null for empty paths and root-only paths\n",
        "388": "    if (name == null) {\n",
        "389": "      return \"\";\n",
        "390": "    }\n",
        "391": "\n",
        "392": "    String fileName = name.toString();\n",
        "393": "    int dotIndex = fileName.lastIndexOf('.');\n",
        "394": "    return dotIndex == -1 ? \"\" : fileName.substring(dotIndex + 1);\n",
        "395": "  }\n",
        "396": "\n",
        "397": "  /**\n",
        "398": "   * Returns the file name without its\n",
        "399": "   * <a href=\"http://en.wikipedia.org/wiki/Filename_extension\">file extension</a> or path. This is\n",
        "400": "   * similar to the {@code basename} unix command. The result does not include the '{@code .}'.\n",
        "401": "   */\n",
        "402": "  public static String getNameWithoutExtension(Path path) {\n",
        "403": "    Path name = path.getFileName();\n",
        "404": "\n",
        "405": "    // null for empty paths and root-only paths\n",
        "406": "    if (name == null) {\n",
        "407": "      return \"\";\n",
        "408": "    }\n",
        "409": "\n",
        "410": "    String fileName = name.toString();\n",
        "411": "    int dotIndex = fileName.lastIndexOf('.');\n",
        "412": "    return dotIndex == -1 ? fileName : fileName.substring(0, dotIndex);\n",
        "413": "  }\n",
        "414": "\n",
        "415": "  /**\n",
        "416": "   * Deletes the file or directory at the given {@code path} recursively. Deletes symbolic links,\n",
        "417": "   * not their targets (subject to the caveat below).\n",
        "418": "   *\n",
        "419": "   * <p>If an I/O exception occurs attempting to read, open or delete any file under the given\n",
        "420": "   * directory, this method skips that file and continues. All such exceptions are collected and,\n",
        "421": "   * after attempting to delete all files, an {@code IOException} is thrown containing those\n",
        "422": "   * exceptions as {@linkplain Throwable#getSuppressed() suppressed exceptions}.\n",
        "423": "   *\n",
        "424": "   * <h2>Warning: Security of recursive deletes</h2>\n",
        "425": "   *\n",
        "426": "   * <p>On a file system that supports symbolic links and does <i>not</i> support\n",
        "427": "   * {@link SecureDirectoryStream}, it is possible for a recursive delete to delete files and\n",
        "428": "   * directories that are <i>outside</i> the directory being deleted. This can happen if, after\n",
        "429": "   * checking that a file is a directory (and not a symbolic link), that directory is replaced by a\n",
        "430": "   * symbolic link to an outside directory before the call that opens the directory to read its\n",
        "431": "   * entries.\n",
        "432": "   *\n",
        "433": "   * <p>By default, this method throws {@link InsecureRecursiveDeleteException} if it can't\n",
        "434": "   * guarantee the security of recursive deletes. If you wish to allow the recursive deletes\n",
        "435": "   * anyway, pass {@link RecursiveDeleteOption#ALLOW_INSECURE} to this method to override that\n",
        "436": "   * behavior.\n",
        "437": "   *\n",
        "438": "   * @throws NoSuchFileException if {@code path} does not exist <i>(optional specific\n",
        "439": "   *     exception)</i>\n",
        "440": "   * @throws InsecureRecursiveDeleteException if the security of recursive deletes can't be\n",
        "441": "   *     guaranteed for the file system and {@link RecursiveDeleteOption#ALLOW_INSECURE} was not\n",
        "442": "   *     specified\n",
        "443": "   * @throws IOException if {@code path} or any file in the subtree rooted at it can't be deleted\n",
        "444": "   *     for any reason\n",
        "445": "   */\n",
        "446": "  public static void deleteRecursively(\n",
        "447": "      Path path, RecursiveDeleteOption... options) throws IOException {\n",
        "448": "    Path parentPath = getParentPath(path);\n",
        "449": "    if (parentPath == null) {\n",
        "450": "      throw new FileSystemException(path.toString(), null, \"can't delete recursively\");\n",
        "451": "    }\n",
        "452": "\n",
        "453": "    Collection<IOException> exceptions = null; // created lazily if needed\n",
        "454": "    try {\n",
        "455": "      boolean sdsSupported = false;\n",
        "456": "      try (DirectoryStream<Path> parent = Files.newDirectoryStream(parentPath)) {\n",
        "457": "        if (parent instanceof SecureDirectoryStream) {\n",
        "458": "          sdsSupported = true;\n",
        "459": "          exceptions = deleteRecursivelySecure(\n",
        "460": "              (SecureDirectoryStream<Path>) parent, path.getFileName());\n",
        "461": "        }\n",
        "462": "      }\n",
        "463": "\n",
        "464": "      if (!sdsSupported) {\n",
        "465": "        checkAllowsInsecure(path, options);\n",
        "466": "        exceptions = deleteRecursivelyInsecure(path);\n",
        "467": "      }\n",
        "468": "    } catch (IOException e) {\n",
        "469": "      if (exceptions == null) {\n",
        "470": "        throw e;\n",
        "471": "      } else {\n",
        "472": "        exceptions.add(e);\n",
        "473": "      }\n",
        "474": "    }\n",
        "475": "\n",
        "476": "    if (exceptions != null) {\n",
        "477": "      throwDeleteFailed(path, exceptions);\n",
        "478": "    }\n",
        "479": "  }\n",
        "480": "\n",
        "481": "  /**\n",
        "482": "   * Deletes all files within the directory at the given {@code path}\n",
        "483": "   * {@linkplain #deleteRecursively recursively}. Does not delete the directory itself. Deletes\n",
        "484": "   * symbolic links, not their targets (subject to the caveat below). If {@code path} itself is\n",
        "485": "   * a symbolic link to a directory, that link is followed and the contents of the directory it\n",
        "486": "   * targets are deleted.\n",
        "487": "   *\n",
        "488": "   * <p>If an I/O exception occurs attempting to read, open or delete any file under the given\n",
        "489": "   * directory, this method skips that file and continues. All such exceptions are collected and,\n",
        "490": "   * after attempting to delete all files, an {@code IOException} is thrown containing those\n",
        "491": "   * exceptions as {@linkplain Throwable#getSuppressed() suppressed exceptions}.\n",
        "492": "   *\n",
        "493": "   * <h2>Warning: Security of recursive deletes</h2>\n",
        "494": "   *\n",
        "495": "   * <p>On a file system that supports symbolic links and does <i>not</i> support\n",
        "496": "   * {@link SecureDirectoryStream}, it is possible for a recursive delete to delete files and\n",
        "497": "   * directories that are <i>outside</i> the directory being deleted. This can happen if, after\n",
        "498": "   * checking that a file is a directory (and not a symbolic link), that directory is replaced by a\n",
        "499": "   * symbolic link to an outside directory before the call that opens the directory to read its\n",
        "500": "   * entries.\n",
        "501": "   *\n",
        "502": "   * <p>By default, this method throws {@link InsecureRecursiveDeleteException} if it can't\n",
        "503": "   * guarantee the security of recursive deletes. If you wish to allow the recursive deletes\n",
        "504": "   * anyway, pass {@link RecursiveDeleteOption#ALLOW_INSECURE} to this method to override that\n",
        "505": "   * behavior.\n",
        "506": "   *\n",
        "507": "   * @throws NoSuchFileException if {@code path} does not exist <i>(optional specific\n",
        "508": "   *     exception)</i>\n",
        "509": "   * @throws NotDirectoryException if the file at {@code path} is not a directory <i>(optional\n",
        "510": "   *     specific exception)</i>\n",
        "511": "   * @throws InsecureRecursiveDeleteException if the security of recursive deletes can't be\n",
        "512": "   *     guaranteed for the file system and {@link RecursiveDeleteOption#ALLOW_INSECURE} was not\n",
        "513": "   *     specified\n",
        "514": "   * @throws IOException if one or more files can't be deleted for any reason\n",
        "515": "   */\n",
        "516": "  public static void deleteDirectoryContents(\n",
        "517": "      Path path, RecursiveDeleteOption... options) throws IOException {\n",
        "518": "    Collection<IOException> exceptions = null; // created lazily if needed\n",
        "519": "    try (DirectoryStream<Path> stream = Files.newDirectoryStream(path)) {\n",
        "520": "      if (stream instanceof SecureDirectoryStream) {\n",
        "521": "        SecureDirectoryStream<Path> sds = (SecureDirectoryStream<Path>) stream;\n",
        "522": "        exceptions = deleteDirectoryContentsSecure(sds);\n",
        "523": "      } else {\n",
        "524": "        checkAllowsInsecure(path, options);\n",
        "525": "        exceptions = deleteDirectoryContentsInsecure(stream);\n",
        "526": "      }\n",
        "527": "    } catch (IOException e) {\n",
        "528": "      if (exceptions == null) {\n",
        "529": "        throw e;\n",
        "530": "      } else {\n",
        "531": "        exceptions.add(e);\n",
        "532": "      }\n",
        "533": "    }\n",
        "534": "\n",
        "535": "    if (exceptions != null) {\n",
        "536": "      throwDeleteFailed(path, exceptions);\n",
        "537": "    }\n",
        "538": "  }\n",
        "539": "\n",
        "540": "  /**\n",
        "541": "   * Secure recursive delete using {@code SecureDirectoryStream}. Returns a collection of\n",
        "542": "   * exceptions that occurred or null if no exceptions were thrown.\n",
        "543": "   */\n",
        "544": "  @Nullable\n",
        "545": "  private static Collection<IOException> deleteRecursivelySecure(\n",
        "546": "      SecureDirectoryStream<Path> dir, Path path) {\n",
        "547": "    Collection<IOException> exceptions = null;\n",
        "548": "    try {\n",
        "549": "      if (isDirectory(dir, path, NOFOLLOW_LINKS)) {\n",
        "550": "        try (SecureDirectoryStream<Path> childDir = dir.newDirectoryStream(path, NOFOLLOW_LINKS)) {\n",
        "551": "          exceptions = deleteDirectoryContentsSecure(childDir);\n",
        "552": "        }\n",
        "553": "\n",
        "554": "        // If exceptions is not null, something went wrong trying to delete the contents of the\n",
        "555": "        // directory, so we shouldn't try to delete the directory as it will probably fail.\n",
        "556": "        if (exceptions == null) {\n",
        "557": "          dir.deleteDirectory(path);\n",
        "558": "        }\n",
        "559": "      } else {\n",
        "560": "        dir.deleteFile(path);\n",
        "561": "      }\n",
        "562": "\n",
        "563": "      return exceptions;\n",
        "564": "    } catch (IOException e) {\n",
        "565": "      return addException(exceptions, e);\n",
        "566": "    }\n",
        "567": "  }\n",
        "568": "\n",
        "569": "  /**\n",
        "570": "   * Secure method for deleting the contents of a directory using {@code SecureDirectoryStream}.\n",
        "571": "   * Returns a collection of exceptions that occurred or null if no exceptions were thrown.\n",
        "572": "   */\n",
        "573": "  @Nullable\n",
        "574": "  private static Collection<IOException> deleteDirectoryContentsSecure(\n",
        "575": "      SecureDirectoryStream<Path> dir) {\n",
        "576": "    Collection<IOException> exceptions = null;\n",
        "577": "    try {\n",
        "578": "      for (Path path : dir) {\n",
        "579": "        exceptions = concat(exceptions, deleteRecursivelySecure(dir, path.getFileName()));\n",
        "580": "      }\n",
        "581": "\n",
        "582": "      return exceptions;\n",
        "583": "    } catch (DirectoryIteratorException e) {\n",
        "584": "      return addException(exceptions, e.getCause());\n",
        "585": "    }\n",
        "586": "  }\n",
        "587": "\n",
        "588": "  /**\n",
        "589": "   * Insecure recursive delete for file systems that don't support {@code SecureDirectoryStream}.\n",
        "590": "   * Returns a collection of exceptions that occurred or null if no exceptions were thrown.\n",
        "591": "   */\n",
        "592": "  @Nullable\n",
        "593": "  private static Collection<IOException> deleteRecursivelyInsecure(Path path) {\n",
        "594": "    Collection<IOException> exceptions = null;\n",
        "595": "    try {\n",
        "596": "      if (Files.isDirectory(path, NOFOLLOW_LINKS)) {\n",
        "597": "        try (DirectoryStream<Path> stream = Files.newDirectoryStream(path)) {\n",
        "598": "          exceptions = deleteDirectoryContentsInsecure(stream);\n",
        "599": "        }\n",
        "600": "      }\n",
        "601": "\n",
        "602": "      // If exceptions is not null, something went wrong trying to delete the contents of the\n",
        "603": "      // directory, so we shouldn't try to delete the directory as it will probably fail.\n",
        "604": "      if (exceptions == null) {\n",
        "605": "        Files.delete(path);\n",
        "606": "      }\n",
        "607": "\n",
        "608": "      return exceptions;\n",
        "609": "    } catch (IOException e) {\n",
        "610": "      return addException(exceptions, e);\n",
        "611": "    }\n",
        "612": "  }\n",
        "613": "\n",
        "614": "  /**\n",
        "615": "   * Simple, insecure method for deleting the contents of a directory for file systems that don't\n",
        "616": "   * support {@code SecureDirectoryStream}. Returns a collection of exceptions that occurred or\n",
        "617": "   * null if no exceptions were thrown.\n",
        "618": "   */\n",
        "619": "  @Nullable\n",
        "620": "  private static Collection<IOException> deleteDirectoryContentsInsecure(\n",
        "621": "      DirectoryStream<Path> dir) {\n",
        "622": "    Collection<IOException> exceptions = null;\n",
        "623": "    try {\n",
        "624": "      for (Path entry : dir) {\n",
        "625": "        exceptions = concat(exceptions, deleteRecursivelyInsecure(entry));\n",
        "626": "      }\n",
        "627": "\n",
        "628": "      return exceptions;\n",
        "629": "    } catch (DirectoryIteratorException e) {\n",
        "630": "      return addException(exceptions, e.getCause());\n",
        "631": "    }\n",
        "632": "  }\n",
        "633": "\n",
        "634": "  /**\n",
        "635": "   * Returns a path to the parent directory of the given path. If the path actually has a parent\n",
        "636": "   * path, this is simple. Otherwise, we need to do some trickier things. Returns null if the path\n",
        "637": "   * is a root or is the empty path.\n",
        "638": "   */\n",
        "639": "  @Nullable\n",
        "640": "  private static Path getParentPath(Path path) throws IOException {\n",
        "641": "    Path parent = path.getParent();\n",
        "642": "\n",
        "643": "    // Paths that have a parent:\n",
        "644": "    if (parent != null) {\n",
        "645": "      // \"/foo\" (\"/\")\n",
        "646": "      // \"foo/bar\" (\"foo\")\n",
        "647": "      // \"C:\\foo\" (\"C:\\\")\n",
        "648": "      // \"\\foo\" (\"\\\" - current drive for process on Windows)\n",
        "649": "      // \"C:foo\" (\"C:\" - working dir of drive C on Windows)\n",
        "650": "      return parent;\n",
        "651": "    }\n",
        "652": "\n",
        "653": "    // Paths that don't have a parent:\n",
        "654": "    if (path.getNameCount() == 0) {\n",
        "655": "      // \"/\", \"C:\\\", \"\\\" (no parent)\n",
        "656": "      // \"\" (undefined, though typically parent of working dir)\n",
        "657": "      // \"C:\" (parent of working dir of drive C on Windows)\n",
        "658": "      //\n",
        "659": "      // For working dir paths (\"\" and \"C:\"), return null because:\n",
        "660": "      //   A) it's not specified that \"\" is the path to the working directory.\n",
        "661": "      //   B) if we're getting this path for recursive delete, it's typically not possible to\n",
        "662": "      //      delete the working dir with a relative path anyway, so it's ok to fail.\n",
        "663": "      //   C) if we're getting it for opening a new SecureDirectoryStream, there's no need to get\n",
        "664": "      //      the parent path anyway since we can safely open a DirectoryStream to the path without\n",
        "665": "      //      worrying about a symlink.\n",
        "666": "      return null;\n",
        "667": "    } else {\n",
        "668": "      // \"foo\" (working dir)\n",
        "669": "      return path.getFileSystem().getPath(\".\");\n",
        "670": "    }\n",
        "671": "  }\n",
        "672": "\n",
        "673": "  /**\n",
        "674": "   * Checks that the given options allow an insecure delete, throwing an exception if not.\n",
        "675": "   */\n",
        "676": "  private static void checkAllowsInsecure(\n",
        "677": "      Path path, RecursiveDeleteOption[] options) throws InsecureRecursiveDeleteException {\n",
        "678": "    if (!Arrays.asList(options).contains(RecursiveDeleteOption.ALLOW_INSECURE)) {\n",
        "679": "      throw new InsecureRecursiveDeleteException(path.toString());\n",
        "680": "    }\n",
        "681": "  }\n",
        "682": "\n",
        "683": "  /**\n",
        "684": "   * Returns whether or not the file with the given name in the given dir is a directory.\n",
        "685": "   */\n",
        "686": "  private static boolean isDirectory(\n",
        "687": "      SecureDirectoryStream<Path> dir, Path name, LinkOption... options) throws IOException {\n",
        "688": "    return dir.getFileAttributeView(name, BasicFileAttributeView.class, options)\n",
        "689": "        .readAttributes()\n",
        "690": "        .isDirectory();\n",
        "691": "  }\n",
        "692": "\n",
        "693": "  /**\n",
        "694": "   * Adds the given exception to the given collection, creating the collection if it's null.\n",
        "695": "   * Returns the collection.\n",
        "696": "   */\n",
        "697": "  private static Collection<IOException> addException(\n",
        "698": "      @Nullable Collection<IOException> exceptions, IOException e) {\n",
        "699": "    if (exceptions == null) {\n",
        "700": "      exceptions = new ArrayList<>(); // don't need Set semantics\n",
        "701": "    }\n",
        "702": "    exceptions.add(e);\n",
        "703": "    return exceptions;\n",
        "704": "  }\n",
        "705": "\n",
        "706": "  /**\n",
        "707": "   * Concatenates the contents of the two given collections of exceptions. If either collection is\n",
        "708": "   * null, the other collection is returned. Otherwise, the elements of {@code other} are added to\n",
        "709": "   * {@code exceptions} and {@code exceptions} is returned.\n",
        "710": "   */\n",
        "711": "  @Nullable\n",
        "712": "  private static Collection<IOException> concat(\n",
        "713": "      @Nullable Collection<IOException> exceptions, @Nullable Collection<IOException> other) {\n",
        "714": "    if (exceptions == null) {\n",
        "715": "      return other;\n",
        "716": "    } else if (other != null) {\n",
        "717": "      exceptions.addAll(other);\n",
        "718": "    }\n",
        "719": "    return exceptions;\n",
        "720": "  }\n",
        "721": "\n",
        "722": "  /**\n",
        "723": "   * Throws an exception indicating that one or more files couldn't be deleted. The thrown\n",
        "724": "   * exception contains all the exceptions in the given collection as suppressed exceptions.\n",
        "725": "   */\n",
        "726": "  private static void throwDeleteFailed(\n",
        "727": "      Path path, Collection<IOException> exceptions) throws FileSystemException {\n",
        "728": "    // TODO(cgdecker): Should there be a custom exception type for this?\n",
        "729": "    // Also, should we try to include the Path of each file we may have failed to delete rather\n",
        "730": "    // than just the exceptions that occurred?\n",
        "731": "    FileSystemException deleteFailed = new FileSystemException(path.toString(), null,\n",
        "732": "        \"failed to delete one or more files; see suppressed exceptions for details\");\n",
        "733": "    for (IOException e : exceptions) {\n",
        "734": "      deleteFailed.addSuppressed(e);\n",
        "735": "    }\n",
        "736": "    throw deleteFailed;\n",
        "737": "  }\n",
        "738": "}\n"
    },
    "removed": {}
}