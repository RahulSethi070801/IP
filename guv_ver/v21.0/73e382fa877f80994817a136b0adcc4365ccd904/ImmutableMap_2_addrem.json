{
    "addition": {
        "35": "import java.util.LinkedHashMap;\n",
        "37": "import java.util.Spliterator;\n",
        "38": "import java.util.Spliterators;\n",
        "39": "import java.util.function.BiFunction;\n",
        "40": "import java.util.function.BinaryOperator;\n",
        "41": "import java.util.function.Function;\n",
        "42": "import java.util.stream.Collector;\n",
        "43": "import java.util.stream.Collectors;\n",
        "62": "  /**\n",
        "63": "   * Returns a {@link Collector} that accumulates elements into an {@code ImmutableMap} whose keys\n",
        "64": "   * and values are the result of applying the provided mapping functions to the input elements.\n",
        "65": "   * Entries appear in the result {@code ImmutableMap} in encounter order.\n",
        "66": "   *\n",
        "67": "   * <p>If the mapped keys contain duplicates (according to {@link Object#equals(Object)}, an\n",
        "68": "   * {@code IllegalArgumentException} is thrown when the collection operation is performed.\n",
        "69": "   * (This differs from the {@code Collector} returned by\n",
        "70": "   * {@link Collectors#toMap(Function, Function)}, which throws an {@code IllegalStateException}.)\n",
        "71": "   *\n",
        "72": "   * @since 21.0\n",
        "73": "   */\n",
        "74": "  @Beta\n",
        "75": "  public static <T, K, V> Collector<T, ?, ImmutableMap<K, V>> toImmutableMap(\n",
        "76": "      Function<? super T, ? extends K> keyFunction,\n",
        "77": "      Function<? super T, ? extends V> valueFunction) {\n",
        "78": "    return CollectCollectors.toImmutableMap(keyFunction, valueFunction);\n",
        "79": "  }\n",
        "80": "  \n",
        "81": "  /**\n",
        "82": "   * Returns a {@link Collector} that accumulates elements into an {@code ImmutableMap} whose keys\n",
        "83": "   * and values are the result of applying the provided mapping functions to the input elements.\n",
        "84": "   *\n",
        "85": "   * <p>If the mapped keys contain duplicates (according to {@link Object#equals(Object)}), the\n",
        "86": "   * values are merged using the specified merging function. Entries will appear in the encounter\n",
        "87": "   * order of the first occurrence of the key.\n",
        "88": "   *\n",
        "89": "   * @since 21.0\n",
        "90": "   */\n",
        "91": "  @Beta\n",
        "92": "  public static <T, K, V> Collector<T, ?, ImmutableMap<K, V>> toImmutableMap(\n",
        "93": "      Function<? super T, ? extends K> keyFunction,\n",
        "94": "      Function<? super T, ? extends V> valueFunction,\n",
        "95": "      BinaryOperator<V> mergeFunction) {\n",
        "96": "    checkNotNull(keyFunction);\n",
        "97": "    checkNotNull(valueFunction);\n",
        "98": "    checkNotNull(mergeFunction);\n",
        "99": "    return Collectors.collectingAndThen(\n",
        "100": "        Collectors.toMap(keyFunction, valueFunction, mergeFunction, LinkedHashMap::new),\n",
        "101": "        ImmutableMap::copyOf);\n",
        "102": "  }\n",
        "103": "\n",
        "315": "    @CanIgnoreReturnValue\n",
        "316": "    Builder<K, V> combine(Builder<K, V> other) {\n",
        "317": "      checkNotNull(other);\n",
        "318": "      ensureCapacity(this.size + other.size);\n",
        "319": "      System.arraycopy(other.entries, 0, this.entries, this.size, other.size);\n",
        "320": "      this.size += other.size;\n",
        "321": "      return this;\n",
        "322": "    }\n",
        "323": "\n",
        "436": "    Spliterator<Entry<K, V>> entrySpliterator() {\n",
        "437": "      return Spliterators.spliterator(\n",
        "438": "          entryIterator(),\n",
        "439": "          size(),\n",
        "440": "          Spliterator.DISTINCT | Spliterator.NONNULL | Spliterator.IMMUTABLE | Spliterator.ORDERED);\n",
        "441": "    }\n",
        "442": "\n",
        "485": "  public final V putIfAbsent(K key, V value) {\n",
        "486": "    throw new UnsupportedOperationException();\n",
        "487": "  }\n",
        "488": "\n",
        "489": "  /**\n",
        "490": "   * Guaranteed to throw an exception and leave the map unmodified.\n",
        "491": "   *\n",
        "492": "   * @throws UnsupportedOperationException always\n",
        "493": "   * @deprecated Unsupported operation.\n",
        "494": "   */\n",
        "495": "  @Deprecated\n",
        "496": "  @Override\n",
        "497": "  public final boolean replace(K key, V oldValue, V newValue) {\n",
        "498": "    throw new UnsupportedOperationException();\n",
        "499": "  }\n",
        "500": "\n",
        "501": "  /**\n",
        "502": "   * Guaranteed to throw an exception and leave the map unmodified.\n",
        "503": "   *\n",
        "504": "   * @throws UnsupportedOperationException always\n",
        "505": "   * @deprecated Unsupported operation.\n",
        "506": "   */\n",
        "507": "  @Deprecated\n",
        "508": "  @Override\n",
        "509": "  public final V replace(K key, V value) {\n",
        "510": "    throw new UnsupportedOperationException();\n",
        "511": "  }\n",
        "512": "\n",
        "513": "  /**\n",
        "514": "   * Guaranteed to throw an exception and leave the map unmodified.\n",
        "515": "   *\n",
        "516": "   * @throws UnsupportedOperationException always\n",
        "517": "   * @deprecated Unsupported operation.\n",
        "518": "   */\n",
        "519": "  @Deprecated\n",
        "520": "  @Override\n",
        "521": "  public final V computeIfAbsent(K key, Function<? super K, ? extends V> mappingFunction) {\n",
        "522": "    throw new UnsupportedOperationException();\n",
        "523": "  }\n",
        "524": "\n",
        "525": "  /**\n",
        "526": "   * Guaranteed to throw an exception and leave the map unmodified.\n",
        "527": "   *\n",
        "528": "   * @throws UnsupportedOperationException always\n",
        "529": "   * @deprecated Unsupported operation.\n",
        "530": "   */\n",
        "531": "  @Deprecated\n",
        "532": "  @Override\n",
        "533": "  public final V computeIfPresent(\n",
        "534": "      K key, BiFunction<? super K, ? super V, ? extends V> remappingFunction) {\n",
        "535": "    throw new UnsupportedOperationException();\n",
        "536": "  }\n",
        "537": "\n",
        "538": "  /**\n",
        "539": "   * Guaranteed to throw an exception and leave the map unmodified.\n",
        "540": "   *\n",
        "541": "   * @throws UnsupportedOperationException always\n",
        "542": "   * @deprecated Unsupported operation.\n",
        "543": "   */\n",
        "544": "  @Deprecated\n",
        "545": "  @Override\n",
        "546": "  public final V compute(K key, BiFunction<? super K, ? super V, ? extends V> remappingFunction) {\n",
        "547": "    throw new UnsupportedOperationException();\n",
        "548": "  }\n",
        "549": "\n",
        "550": "  /**\n",
        "551": "   * Guaranteed to throw an exception and leave the map unmodified.\n",
        "552": "   *\n",
        "553": "   * @throws UnsupportedOperationException always\n",
        "554": "   * @deprecated Unsupported operation.\n",
        "555": "   */\n",
        "556": "  @Deprecated\n",
        "557": "  @Override\n",
        "558": "  public final V merge(\n",
        "559": "      K key, V value, BiFunction<? super V, ? super V, ? extends V> remappingFunction) {\n",
        "575": "  /**\n",
        "576": "   * Guaranteed to throw an exception and leave the map unmodified.\n",
        "577": "   *\n",
        "578": "   * @throws UnsupportedOperationException always\n",
        "579": "   * @deprecated Unsupported operation.\n",
        "580": "   */\n",
        "581": "  @Deprecated\n",
        "582": "  @Override\n",
        "583": "  public final void replaceAll(BiFunction<? super K, ? super V, ? extends V> function) {\n",
        "584": "    throw new UnsupportedOperationException();\n",
        "585": "  }\n",
        "586": "\n",
        "587": "  /**\n",
        "588": "   * Guaranteed to throw an exception and leave the map unmodified.\n",
        "589": "   *\n",
        "590": "   * @throws UnsupportedOperationException always\n",
        "591": "   * @deprecated Unsupported operation.\n",
        "592": "   */\n",
        "593": "  @Deprecated\n",
        "594": "  @Override\n",
        "595": "  public final V remove(Object o) {\n",
        "596": "    throw new UnsupportedOperationException();\n",
        "597": "  }\n",
        "598": "\n",
        "599": "  /**\n",
        "600": "   * Guaranteed to throw an exception and leave the map unmodified.\n",
        "601": "   *\n",
        "602": "   * @throws UnsupportedOperationException always\n",
        "603": "   * @deprecated Unsupported operation.\n",
        "604": "   */\n",
        "605": "  @Deprecated\n",
        "606": "  @Override\n",
        "607": "  public final boolean remove(Object key, Object value) {\n",
        "608": "    throw new UnsupportedOperationException();\n",
        "609": "  }\n",
        "610": "\n",
        "642": "  @Override\n",
        "643": "  public final V getOrDefault(@Nullable Object key, @Nullable V defaultValue) {\n",
        "644": "    V result = get(key);\n",
        "645": "    return (result != null) ? result : defaultValue;\n",
        "646": "  }\n",
        "647": "\n",
        "695": "  Spliterator<K> keySpliterator() {\n",
        "696": "    return CollectSpliterators.map(entrySet().spliterator(), Entry::getKey);\n",
        "697": "  }\n",
        "698": "\n"
    },
    "removed": {
        "419": "  public final V remove(Object o) {\n"
    }
}