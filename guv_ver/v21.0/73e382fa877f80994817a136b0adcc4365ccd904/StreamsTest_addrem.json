{
    "addition": {
        "1": "/*\n",
        "2": " * Copyright (C) 2016 The Guava Authors\n",
        "3": " *\n",
        "4": " * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not use this file except\n",
        "5": " * in compliance with the License. You may obtain a copy of the License at\n",
        "6": " *\n",
        "7": " * http://www.apache.org/licenses/LICENSE-2.0\n",
        "8": " *\n",
        "9": " * Unless required by applicable law or agreed to in writing, software distributed under the License\n",
        "10": " * is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express\n",
        "11": " * or implied. See the License for the specific language governing permissions and limitations under\n",
        "12": " * the License.\n",
        "13": " */\n",
        "14": "\n",
        "15": "package com.google.common.collect;\n",
        "16": "\n",
        "17": "import static com.google.common.collect.Streams.findLast;\n",
        "18": "import static com.google.common.collect.Streams.stream;\n",
        "19": "\n",
        "20": "import com.google.common.collect.testing.SpliteratorTester;\n",
        "21": "import com.google.common.primitives.Doubles;\n",
        "22": "import com.google.common.truth.IterableSubject;\n",
        "23": "import com.google.common.truth.Truth;\n",
        "24": "import com.google.common.truth.Truth8;\n",
        "25": "import java.util.ArrayList;\n",
        "26": "import java.util.Arrays;\n",
        "27": "import java.util.Collection;\n",
        "28": "import java.util.LinkedHashSet;\n",
        "29": "import java.util.LinkedList;\n",
        "30": "import java.util.List;\n",
        "31": "import java.util.OptionalDouble;\n",
        "32": "import java.util.OptionalInt;\n",
        "33": "import java.util.OptionalLong;\n",
        "34": "import java.util.function.Function;\n",
        "35": "import java.util.stream.Collectors;\n",
        "36": "import java.util.stream.DoubleStream;\n",
        "37": "import java.util.stream.IntStream;\n",
        "38": "import java.util.stream.LongStream;\n",
        "39": "import java.util.stream.Stream;\n",
        "40": "import junit.framework.TestCase;\n",
        "41": "\n",
        "42": "/**\n",
        "43": " * Unit test for {@link Streams}.\n",
        "44": " */\n",
        "45": "public class StreamsTest extends TestCase {\n",
        "46": "  /*\n",
        "47": "   * Full and proper black-box testing of a Stream-returning method is extremely involved, and is\n",
        "48": "   * overkill when nearly all Streams are produced using well-tested JDK calls. So, we cheat and\n",
        "49": "   * just test that the toArray() contents are as expected.\n",
        "50": "   */\n",
        "51": "  public void testStream_nonCollection() {\n",
        "52": "    assertThat(stream(FluentIterable.of())).isEmpty();\n",
        "53": "    assertThat(stream(FluentIterable.of(\"a\"))).containsExactly(\"a\");\n",
        "54": "    assertThat(stream(FluentIterable.of(1, 2, 3)).filter(n -> n > 1)).containsExactly(2, 3);\n",
        "55": "  }\n",
        "56": "\n",
        "57": "  @SuppressWarnings(\"deprecation\")\n",
        "58": "  public void testStream_collection() {\n",
        "59": "    assertThat(stream(Arrays.asList())).isEmpty();\n",
        "60": "    assertThat(stream(Arrays.asList(\"a\"))).containsExactly(\"a\");\n",
        "61": "    assertThat(stream(Arrays.asList(1, 2, 3)).filter(n -> n > 1)).containsExactly(2, 3);\n",
        "62": "  }\n",
        "63": "\n",
        "64": "  public void testStream_iterator() {\n",
        "65": "    assertThat(stream(Arrays.asList().iterator())).isEmpty();\n",
        "66": "    assertThat(stream(Arrays.asList(\"a\").iterator())).containsExactly(\"a\");\n",
        "67": "    assertThat(stream(Arrays.asList(1, 2, 3).iterator()).filter(n -> n > 1)).containsExactly(2, 3);\n",
        "68": "  }\n",
        "69": "\n",
        "70": "  public void testStream_googleOptional() {\n",
        "71": "    assertThat(stream(com.google.common.base.Optional.absent())).isEmpty();\n",
        "72": "    assertThat(stream(com.google.common.base.Optional.of(\"a\"))).containsExactly(\"a\");\n",
        "73": "  }\n",
        "74": "\n",
        "75": "  public void testStream_javaOptional() {\n",
        "76": "    assertThat(stream(java.util.Optional.empty())).isEmpty();\n",
        "77": "    assertThat(stream(java.util.Optional.of(\"a\"))).containsExactly(\"a\");\n",
        "78": "  }\n",
        "79": "  \n",
        "80": "  public void testFindLast_refStream() {\n",
        "81": "    Truth8.assertThat(findLast(Stream.of())).isEmpty();\n",
        "82": "    Truth8.assertThat(findLast(Stream.of(\"a\", \"b\", \"c\", \"d\"))).hasValue(\"d\");\n",
        "83": "\n",
        "84": "    // test with a large, not-subsized Spliterator\n",
        "85": "    List<Integer> list =\n",
        "86": "        IntStream.rangeClosed(0, 10000).boxed().collect(Collectors.toCollection(LinkedList::new));\n",
        "87": "    Truth8.assertThat(findLast(list.stream())).hasValue(10000);\n",
        "88": "\n",
        "89": "    // no way to find out the stream is empty without walking its spliterator\n",
        "90": "    Truth8.assertThat(findLast(list.stream().filter(i -> i < 0))).isEmpty();\n",
        "91": "  }\n",
        "92": "\n",
        "93": "  public void testFindLast_intStream() {\n",
        "94": "    Truth.assertThat(findLast(IntStream.of())).isEqualTo(OptionalInt.empty());\n",
        "95": "    Truth.assertThat(findLast(IntStream.of(1, 2, 3, 4, 5))).isEqualTo(OptionalInt.of(5));\n",
        "96": "\n",
        "97": "    // test with a large, not-subsized Spliterator\n",
        "98": "    List<Integer> list =\n",
        "99": "        IntStream.rangeClosed(0, 10000).boxed().collect(Collectors.toCollection(LinkedList::new));\n",
        "100": "    Truth.assertThat(findLast(list.stream().mapToInt(i -> i))).isEqualTo(OptionalInt.of(10000));\n",
        "101": "\n",
        "102": "    // no way to find out the stream is empty without walking its spliterator\n",
        "103": "    Truth.assertThat(findLast(list.stream().mapToInt(i -> i).filter(i -> i < 0)))\n",
        "104": "        .isEqualTo(OptionalInt.empty());\n",
        "105": "  }\n",
        "106": "\n",
        "107": "  public void testFindLast_longStream() {\n",
        "108": "    Truth.assertThat(findLast(LongStream.of())).isEqualTo(OptionalLong.empty());\n",
        "109": "    Truth.assertThat(findLast(LongStream.of(1, 2, 3, 4, 5))).isEqualTo(OptionalLong.of(5));\n",
        "110": "\n",
        "111": "    // test with a large, not-subsized Spliterator\n",
        "112": "    List<Long> list =\n",
        "113": "        LongStream.rangeClosed(0, 10000).boxed().collect(Collectors.toCollection(LinkedList::new));\n",
        "114": "    Truth.assertThat(findLast(list.stream().mapToLong(i -> i))).isEqualTo(OptionalLong.of(10000));\n",
        "115": "\n",
        "116": "    // no way to find out the stream is empty without walking its spliterator\n",
        "117": "    Truth.assertThat(findLast(list.stream().mapToLong(i -> i).filter(i -> i < 0)))\n",
        "118": "        .isEqualTo(OptionalLong.empty());\n",
        "119": "  }\n",
        "120": "\n",
        "121": "  public void testFindLast_doubleStream() {\n",
        "122": "    Truth.assertThat(findLast(DoubleStream.of())).isEqualTo(OptionalDouble.empty());\n",
        "123": "    Truth.assertThat(findLast(DoubleStream.of(1, 2, 3, 4, 5))).isEqualTo(OptionalDouble.of(5));\n",
        "124": "\n",
        "125": "    // test with a large, not-subsized Spliterator\n",
        "126": "    List<Long> list =\n",
        "127": "        LongStream.rangeClosed(0, 10000).boxed().collect(Collectors.toCollection(LinkedList::new));\n",
        "128": "    Truth.assertThat(findLast(list.stream().mapToDouble(i -> i)))\n",
        "129": "        .isEqualTo(OptionalDouble.of(10000));\n",
        "130": "\n",
        "131": "    // no way to find out the stream is empty without walking its spliterator\n",
        "132": "    Truth.assertThat(findLast(list.stream().mapToDouble(i -> i).filter(i -> i < 0)))\n",
        "133": "        .isEqualTo(OptionalDouble.empty());\n",
        "134": "  }\n",
        "135": "\n",
        "136": "  public void testConcat_refStream() {\n",
        "137": "    assertThat(Streams.concat(Stream.of(\"a\"), Stream.of(\"b\"), Stream.empty(), Stream.of(\"c\", \"d\")))\n",
        "138": "        .containsExactly(\"a\", \"b\", \"c\", \"d\")\n",
        "139": "        .inOrder();\n",
        "140": "  }\n",
        "141": "\n",
        "142": "  public void testConcat_intStream() {\n",
        "143": "    assertThat(\n",
        "144": "            Streams.concat(IntStream.of(1), IntStream.of(2), IntStream.empty(), IntStream.of(3, 4)))\n",
        "145": "        .containsExactly(1, 2, 3, 4)\n",
        "146": "        .inOrder();\n",
        "147": "  }\n",
        "148": "\n",
        "149": "  public void testConcat_longStream() {\n",
        "150": "    assertThat(\n",
        "151": "            Streams.concat(\n",
        "152": "                LongStream.of(1), LongStream.of(2), LongStream.empty(), LongStream.of(3, 4)))\n",
        "153": "        .containsExactly(1L, 2L, 3L, 4L)\n",
        "154": "        .inOrder();\n",
        "155": "  }\n",
        "156": "\n",
        "157": "  public void testConcat_doubleStream() {\n",
        "158": "    assertThat(\n",
        "159": "            Streams.concat(\n",
        "160": "                DoubleStream.of(1),\n",
        "161": "                DoubleStream.of(2),\n",
        "162": "                DoubleStream.empty(),\n",
        "163": "                DoubleStream.of(3, 4)))\n",
        "164": "        .containsExactly(1.0, 2.0, 3.0, 4.0)\n",
        "165": "        .inOrder();\n",
        "166": "  }\n",
        "167": "\n",
        "168": "  public void testStream_optionalInt() {\n",
        "169": "    assertThat(stream(java.util.OptionalInt.empty())).isEmpty();\n",
        "170": "    assertThat(stream(java.util.OptionalInt.of(5))).containsExactly(5);\n",
        "171": "  }\n",
        "172": "\n",
        "173": "  public void testStream_optionalLong() {\n",
        "174": "    assertThat(stream(java.util.OptionalLong.empty())).isEmpty();\n",
        "175": "    assertThat(stream(java.util.OptionalLong.of(5L))).containsExactly(5L);\n",
        "176": "  }\n",
        "177": "\n",
        "178": "  public void testStream_optionalDouble() {\n",
        "179": "    assertThat(stream(java.util.OptionalDouble.empty())).isEmpty();\n",
        "180": "    assertThat(stream(java.util.OptionalDouble.of(5.0))).containsExactly(5.0);\n",
        "181": "  }\n",
        "182": "  \n",
        "183": "  private void testMapWithIndex(Function<Collection<String>, Stream<String>> collectionImpl) {\n",
        "184": "    SpliteratorTester.of(\n",
        "185": "            () ->\n",
        "186": "                Streams.mapWithIndex(\n",
        "187": "                        collectionImpl.apply(ImmutableList.of()), (str, i) -> str + \":\" + i)\n",
        "188": "                    .spliterator())\n",
        "189": "        .expect(ImmutableList.of());\n",
        "190": "    SpliteratorTester.of(\n",
        "191": "            () ->\n",
        "192": "                Streams.mapWithIndex(\n",
        "193": "                        collectionImpl.apply(ImmutableList.of(\"a\", \"b\", \"c\", \"d\", \"e\")),\n",
        "194": "                        (str, i) -> str + \":\" + i)\n",
        "195": "                    .spliterator())\n",
        "196": "        .expect(\"a:0\", \"b:1\", \"c:2\", \"d:3\", \"e:4\");\n",
        "197": "  }\n",
        "198": "\n",
        "199": "  public void testMapWithIndex_arrayListSource() {\n",
        "200": "    testMapWithIndex(elems -> new ArrayList<>(elems).stream());\n",
        "201": "  }\n",
        "202": "\n",
        "203": "  public void testMapWithIndex_linkedHashSetSource() {\n",
        "204": "    testMapWithIndex(elems -> new LinkedHashSet<>(elems).stream());\n",
        "205": "  }\n",
        "206": "\n",
        "207": "  public void testMapWithIndex_unsizedSource() {\n",
        "208": "    testMapWithIndex(\n",
        "209": "        elems -> Stream.of((Object) null).flatMap(unused -> ImmutableList.copyOf(elems).stream()));\n",
        "210": "  }\n",
        "211": "\n",
        "212": "  public void testZip() {\n",
        "213": "    assertThat(Streams.zip(Stream.of(\"a\", \"b\", \"c\"), Stream.of(1, 2, 3), (a, b) -> a + \":\" + b))\n",
        "214": "        .containsExactly(\"a:1\", \"b:2\", \"c:3\")\n",
        "215": "        .inOrder();\n",
        "216": "  }\n",
        "217": "\n",
        "218": "  public void testZipFiniteWithInfinite() {\n",
        "219": "    assertThat(\n",
        "220": "            Streams.zip(\n",
        "221": "                Stream.of(\"a\", \"b\", \"c\"), Stream.iterate(1, i -> i + 1), (a, b) -> a + \":\" + b))\n",
        "222": "        .containsExactly(\"a:1\", \"b:2\", \"c:3\")\n",
        "223": "        .inOrder();\n",
        "224": "  }\n",
        "225": "\n",
        "226": "  public void testZipInfiniteWithInfinite() {\n",
        "227": "    // zip is doing an infinite zip, but we truncate the result so we can actually test it\n",
        "228": "    // but we want the zip itself to work\n",
        "229": "    assertThat(\n",
        "230": "            Streams.zip(\n",
        "231": "                    Stream.iterate(1, i -> i + 1).map(String::valueOf),\n",
        "232": "                    Stream.iterate(1, i -> i + 1),\n",
        "233": "                    (String str, Integer i) -> str.equals(Integer.toString(i)))\n",
        "234": "                .limit(100))\n",
        "235": "        .doesNotContain(false);\n",
        "236": "  }\n",
        "237": "\n",
        "238": "  public void testZipDifferingLengths() {\n",
        "239": "    assertThat(\n",
        "240": "            Streams.zip(Stream.of(\"a\", \"b\", \"c\", \"d\"), Stream.of(1, 2, 3), (a, b) -> a + \":\" + b))\n",
        "241": "        .containsExactly(\"a:1\", \"b:2\", \"c:3\")\n",
        "242": "        .inOrder();\n",
        "243": "    assertThat(Streams.zip(Stream.of(\"a\", \"b\", \"c\"), Stream.of(1, 2, 3, 4), (a, b) -> a + \":\" + b))\n",
        "244": "        .containsExactly(\"a:1\", \"b:2\", \"c:3\")\n",
        "245": "        .inOrder();\n",
        "246": "  }\n",
        "247": "\n",
        "248": "  // TODO(kevinb): switch to importing Truth's assertThat(Stream) if we get that added\n",
        "249": "  private static IterableSubject assertThat(Stream<?> stream) {\n",
        "250": "    return Truth.assertThat(stream.toArray()).asList();\n",
        "251": "  }\n",
        "252": "  \n",
        "253": "  private static IterableSubject assertThat(IntStream stream) {\n",
        "254": "    return Truth.assertThat(stream.toArray()).asList();\n",
        "255": "  }\n",
        "256": "\n",
        "257": "  private static IterableSubject assertThat(LongStream stream) {\n",
        "258": "    return Truth.assertThat(stream.toArray()).asList();\n",
        "259": "  }\n",
        "260": "\n",
        "261": "  private static IterableSubject assertThat(DoubleStream stream) {\n",
        "262": "    return Truth.assertThat(Doubles.asList(stream.toArray()));\n",
        "263": "  }\n",
        "264": "}\n"
    },
    "removed": {}
}