{
    "addition": {
        "39": "import com.google.common.collect.Maps.IteratorBasedAbstractMap;\n",
        "40": "import com.google.common.collect.Maps.ViewCachingAbstractMap;\n",
        "41": "import com.google.common.collect.Sets.ImprovedAbstractSet;\n",
        "67": "import java.util.Spliterator;\n",
        "68": "import java.util.Spliterators;\n",
        "71": "import java.util.function.BiConsumer;\n",
        "72": "import java.util.function.BiFunction;\n",
        "73": "import java.util.function.Consumer;\n",
        "843": "      return getOrDefault(key, null);\n",
        "844": "    }\n",
        "845": "\n",
        "846": "    @Override\n",
        "847": "    public V getOrDefault(@Nullable Object key, @Nullable V defaultValue) {\n",
        "853": "        return defaultValue;\n",
        "889": "\n",
        "890": "    @Override\n",
        "891": "    public void forEach(BiConsumer<? super K, ? super V> action) {\n",
        "892": "      checkNotNull(action);\n",
        "893": "      // avoids allocation of entries\n",
        "894": "      backingSet().forEach(k -> action.accept(k, function.apply(k)));\n",
        "895": "    }\n",
        "994": "      return getOrDefault(key, null);\n",
        "995": "    }\n",
        "996": "\n",
        "997": "    @Override\n",
        "998": "    @Nullable\n",
        "999": "    public V getOrDefault(@Nullable Object key, @Nullable V defaultValue) {\n",
        "1005": "        return defaultValue;\n",
        "1019": "    @Override\n",
        "1020": "    Spliterator<Entry<K, V>> entrySpliterator() {\n",
        "1021": "      return CollectSpliterators.map(set.spliterator(), e -> immutableEntry(e, function.apply(e)));\n",
        "1022": "    }\n",
        "1023": "\n",
        "1024": "    @Override\n",
        "1025": "    public void forEach(BiConsumer<? super K, ? super V> action) {\n",
        "1026": "      set.forEach(k -> action.accept(k, function.apply(k)));\n",
        "1027": "    }\n",
        "1028": "\n",
        "1886": "      final NavigableMap<K, V1> fromMap, EntryTransformer<? super K, ? super V1, V2> transformer) {\n",
        "1900": "  @FunctionalInterface\n",
        "2015": "    @Override\n",
        "2016": "    @Nullable\n",
        "2017": "    public V2 get(@Nullable Object key) {\n",
        "2018": "      return getOrDefault(key, null);\n",
        "2019": "    }\n",
        "2020": "\n",
        "2024": "    @Nullable\n",
        "2025": "    public V2 getOrDefault(@Nullable Object key, @Nullable V2 defaultValue) {\n",
        "2029": "          : defaultValue;\n",
        "2057": "    @Override\n",
        "2058": "    Spliterator<Entry<K, V2>> entrySpliterator() {\n",
        "2059": "      return CollectSpliterators.map(\n",
        "2060": "          fromMap.entrySet().spliterator(), Maps.<K, V1, V2>asEntryToEntryFunction(transformer));\n",
        "2061": "    }\n",
        "2062": "\n",
        "2063": "    @Override\n",
        "2064": "    public void forEach(BiConsumer<? super K, ? super V2> action) {\n",
        "2065": "      checkNotNull(action);\n",
        "2066": "      // avoids creating new Entry<K, V2> objects\n",
        "2067": "      fromMap.forEach((k, v1) -> action.accept(k, transformer.transformEntry(k, v1)));\n",
        "2068": "    }\n",
        "2069": "\n",
        "3231": "    @Override\n",
        "3232": "    public void replaceAll(BiFunction<? super K, ? super V, ? extends V> function) {\n",
        "3233": "      unfiltered()\n",
        "3234": "          .replaceAll(\n",
        "3235": "              (key, value) ->\n",
        "3236": "                  predicate.apply(Maps.immutableEntry(key, value))\n",
        "3237": "                      ? function.apply(key, value)\n",
        "3238": "                      : value);\n",
        "3239": "    }\n",
        "3240": "\n",
        "3532": "    Spliterator<Entry<K, V>> entrySpliterator() {\n",
        "3533": "      return Spliterators.spliterator(\n",
        "3534": "          entryIterator(), size(), Spliterator.SIZED | Spliterator.DISTINCT);\n",
        "3535": "    }\n",
        "3536": "\n",
        "3549": "\n",
        "3550": "        @Override\n",
        "3551": "        public Spliterator<Entry<K, V>> spliterator() {\n",
        "3552": "          return entrySpliterator();\n",
        "3553": "        }\n",
        "3554": "\n",
        "3555": "        @Override\n",
        "3556": "        public void forEach(Consumer<? super Entry<K, V>> action) {\n",
        "3557": "          forEachEntry(action);\n",
        "3558": "        }\n",
        "3562": "    void forEachEntry(Consumer<? super Entry<K, V>> action) {\n",
        "3563": "      entryIterator().forEachRemaining(action);\n",
        "3564": "    }\n",
        "3565": "\n",
        "3720": "    @Override\n",
        "3721": "    public void forEach(Consumer<? super K> action) {\n",
        "3722": "      checkNotNull(action);\n",
        "3723": "      // avoids entry allocation for those maps that allocate entries on iteration\n",
        "3724": "      map.forEach((k, v) -> action.accept(k));\n",
        "3725": "    }\n",
        "3726": "\n",
        "3907": "    @Override\n",
        "3908": "    public void forEach(Consumer<? super V> action) {\n",
        "3909": "      checkNotNull(action);\n",
        "3910": "      // avoids allocation of entries for those maps that generate fresh entries on iteration\n",
        "3911": "      map.forEach((k, v) -> action.accept(v));\n",
        "3912": "    }\n",
        "3913": "\n"
    },
    "removed": {
        "840": "        return null;\n",
        "979": "        return null;\n",
        "1850": "      NavigableMap<K, V1> fromMap, EntryTransformer<? super K, ? super V1, V2> transformer) {\n",
        "1981": "    public V2 get(Object key) {\n",
        "1985": "          : null;\n"
    }
}