{
    "addition": {
        "37": "import com.google.common.cache.LocalCache.AbstractCacheSet;\n",
        "68": "import java.util.Map.Entry;\n",
        "80": "import java.util.function.BiFunction;\n",
        "81": "import java.util.function.BiPredicate;\n",
        "82": "import java.util.function.Function;\n",
        "83": "import java.util.function.Predicate;\n",
        "2331": "    V compute(K key, int hash, BiFunction<? super K, ? super V, ? extends V> function) {\n",
        "2332": "      ReferenceEntry<K, V> e;\n",
        "2333": "      ValueReference<K, V> valueReference = null;\n",
        "2334": "      LoadingValueReference<K, V> loadingValueReference = null;\n",
        "2335": "      boolean createNewEntry = true;\n",
        "2336": "\n",
        "2337": "      lock();\n",
        "2338": "      try {\n",
        "2339": "        // re-read ticker once inside the lock\n",
        "2340": "        long now = map.ticker.read();\n",
        "2341": "        preWriteCleanup(now);\n",
        "2342": "\n",
        "2343": "        AtomicReferenceArray<ReferenceEntry<K, V>> table = this.table;\n",
        "2344": "        int index = hash & (table.length() - 1);\n",
        "2345": "        ReferenceEntry<K, V> first = table.get(index);\n",
        "2346": "\n",
        "2347": "        for (e = first; e != null; e = e.getNext()) {\n",
        "2348": "          K entryKey = e.getKey();\n",
        "2349": "          if (e.getHash() == hash\n",
        "2350": "              && entryKey != null\n",
        "2351": "              && map.keyEquivalence.equivalent(key, entryKey)) {\n",
        "2352": "            valueReference = e.getValueReference();\n",
        "2353": "            if (map.isExpired(e, now)) {\n",
        "2354": "              // This is a duplicate check, as preWriteCleanup already purged expired\n",
        "2355": "              // entries, but let's accomodate an incorrect expiration queue.\n",
        "2356": "              enqueueNotification(\n",
        "2357": "                  entryKey,\n",
        "2358": "                  hash,\n",
        "2359": "                  valueReference.get(),\n",
        "2360": "                  valueReference.getWeight(),\n",
        "2361": "                  RemovalCause.EXPIRED);\n",
        "2362": "            }\n",
        "2363": "\n",
        "2364": "            // immediately reuse invalid entries\n",
        "2365": "            writeQueue.remove(e);\n",
        "2366": "            accessQueue.remove(e);\n",
        "2367": "            createNewEntry = false;\n",
        "2368": "            break;\n",
        "2369": "          }\n",
        "2370": "        }\n",
        "2371": "\n",
        "2372": "        // note valueReference can be an existing value or even itself another loading value if\n",
        "2373": "        // the value for the key is already being computed.\n",
        "2374": "        loadingValueReference = new LoadingValueReference<K, V>(valueReference);\n",
        "2375": "\n",
        "2376": "        if (e == null) {\n",
        "2377": "          createNewEntry = true;\n",
        "2378": "          e = newEntry(key, hash, first);\n",
        "2379": "          e.setValueReference(loadingValueReference);\n",
        "2380": "          table.set(index, e);\n",
        "2381": "        } else {\n",
        "2382": "          e.setValueReference(loadingValueReference);\n",
        "2383": "        }\n",
        "2384": "      } finally {\n",
        "2385": "        unlock();\n",
        "2386": "        postWriteCleanup();\n",
        "2387": "      }\n",
        "2388": "\n",
        "2389": "      // Synchronizes on the entry to allow failing fast when a recursive load is\n",
        "2390": "      // detected. This may be circumvented when an entry is copied, but will fail fast most\n",
        "2391": "      // of the time.\n",
        "2392": "      synchronized (e) {\n",
        "2393": "        V newValue = loadingValueReference.compute(key, function);\n",
        "2394": "        if (newValue != null) {\n",
        "2395": "          try {\n",
        "2396": "            return getAndRecordStats(\n",
        "2397": "                key, hash, loadingValueReference, Futures.immediateFuture(newValue));\n",
        "2398": "          } catch (ExecutionException exception) {\n",
        "2399": "            throw new AssertionError(\"impossible; Futures.immediateFuture can't throw\");\n",
        "2400": "          }\n",
        "2401": "        } else if (createNewEntry) {\n",
        "2402": "          removeLoadingValue(key, hash, loadingValueReference);\n",
        "2403": "          return null;\n",
        "2404": "        } else {\n",
        "2405": "          lock();\n",
        "2406": "          try {\n",
        "2407": "            removeEntry(e, hash, RemovalCause.EXPLICIT);\n",
        "2408": "          } finally {\n",
        "2409": "            unlock();\n",
        "2410": "          }\n",
        "2411": "          return null;\n",
        "2412": "        }\n",
        "2413": "      }\n",
        "2414": "    }\n",
        "2415": "\n",
        "3663": "      this(null);\n",
        "3667": "      this.oldValue = (oldValue == null) ? LocalCache.<K, V>unset() : oldValue;\n",
        "3727": "            new com.google.common.base.Function<V, V>() {\n",
        "3743": "    public V compute(K key, BiFunction<? super K, ? super V, ? extends V> function) {\n",
        "3744": "      stopwatch.start();\n",
        "3745": "      V previousValue;\n",
        "3746": "      try {\n",
        "3747": "        previousValue = oldValue.waitForValue();\n",
        "3748": "      } catch (ExecutionException e) {\n",
        "3749": "        previousValue = null;\n",
        "3750": "      }\n",
        "3751": "      V newValue = function.apply(key, previousValue);\n",
        "3752": "      this.set(newValue);\n",
        "3753": "      return newValue;\n",
        "3754": "    }\n",
        "3755": "\n",
        "4376": "  @Override\n",
        "4377": "  public V compute(K key, BiFunction<? super K, ? super V, ? extends V> function) {\n",
        "4378": "    checkNotNull(key);\n",
        "4379": "    checkNotNull(function);\n",
        "4380": "    int hash = hash(key);\n",
        "4381": "    return segmentFor(hash).compute(key, hash, function);\n",
        "4382": "  }\n",
        "4383": "\n",
        "4384": "  @Override\n",
        "4385": "  public V computeIfAbsent(K key, Function<? super K, ? extends V> function) {\n",
        "4386": "    checkNotNull(key);\n",
        "4387": "    checkNotNull(function);\n",
        "4388": "    return compute(key, (k, oldValue) -> (oldValue == null) ? function.apply(key) : oldValue);\n",
        "4389": "  }\n",
        "4390": "\n",
        "4391": "  @Override\n",
        "4392": "  public V computeIfPresent(K key, BiFunction<? super K, ? super V, ? extends V> function) {\n",
        "4393": "    checkNotNull(key);\n",
        "4394": "    checkNotNull(function);\n",
        "4395": "    return compute(key, (k, oldValue) -> (oldValue == null) ? null : function.apply(k, oldValue));\n",
        "4396": "  }\n",
        "4397": "\n",
        "4398": "  @Override\n",
        "4399": "  public V merge(K key, V newValue, BiFunction<? super V, ? super V, ? extends V> function) {\n",
        "4400": "    checkNotNull(key);\n",
        "4401": "    checkNotNull(newValue);\n",
        "4402": "    checkNotNull(function);\n",
        "4403": "    return compute(\n",
        "4404": "        key, (k, oldValue) -> (oldValue == null) ? newValue : function.apply(oldValue, newValue));\n",
        "4405": "  }\n",
        "4406": "\n",
        "4727": "  boolean removeIf(BiPredicate<? super K, ? super V> filter) {\n",
        "4728": "    checkNotNull(filter);\n",
        "4729": "    boolean changed = false;\n",
        "4730": "    for (K key : keySet()) {\n",
        "4731": "      while (true) {\n",
        "4732": "        V value = get(key);\n",
        "4733": "        if (value == null || !filter.test(key, value)) {\n",
        "4734": "          break;\n",
        "4735": "        } else if (LocalCache.this.remove(key, value)) {\n",
        "4736": "          changed = true;\n",
        "4737": "          break;\n",
        "4738": "        }\n",
        "4739": "      }\n",
        "4740": "    }\n",
        "4741": "    return changed;\n",
        "4742": "  }\n",
        "4743": "\n",
        "4795": "    @Override\n",
        "4796": "    public boolean removeIf(Predicate<? super V> filter) {\n",
        "4797": "      checkNotNull(filter);\n",
        "4798": "      return LocalCache.this.removeIf((k, v) -> filter.test(v));\n",
        "4799": "    }\n",
        "4800": "\n",
        "4832": "    @Override\n",
        "4833": "    public boolean removeIf(Predicate<? super Entry<K, V>> filter) {\n",
        "4834": "      checkNotNull(filter);\n",
        "4835": "      return LocalCache.this.removeIf((k, v) -> filter.test(Maps.immutableEntry(k, v)));\n",
        "4836": "    }\n",
        "4837": "\n"
    },
    "removed": {
        "29": "import com.google.common.base.Function;\n",
        "82": "\n",
        "3575": "      this(LocalCache.<K, V>unset());\n",
        "3579": "      this.oldValue = oldValue;\n",
        "3639": "            new Function<V, V>() {\n"
    }
}