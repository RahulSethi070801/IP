{
    "addition": {
        "38": "import java.util.Spliterator;\n",
        "39": "import java.util.function.Consumer;\n",
        "40": "import java.util.stream.Stream;\n",
        "103": "    @Override\n",
        "104": "    public void forEach(Consumer<? super T> action) {\n",
        "105": "      iterable.forEach(action);\n",
        "106": "    }\n",
        "107": "\n",
        "108": "    @SuppressWarnings(\"unchecked\") // safe upcast, assuming no one has a crazy Spliterator subclass\n",
        "109": "    @Override\n",
        "110": "    public Spliterator<T> spliterator() {\n",
        "111": "      return (Spliterator<T>) iterable.spliterator();\n",
        "112": "    }\n",
        "113": "\n",
        "186": "   * <p><b>Java 8 users:</b> if {@code removeFrom} is a {@link Collection},\n",
        "187": "   * use {@code removeFrom.removeIf(predicate)} instead.\n",
        "188": "   *\n",
        "200": "    if (removeFrom instanceof Collection) {\n",
        "201": "      return ((Collection<T>) removeFrom).removeIf(predicate);\n",
        "380": "      @Override\n",
        "381": "      public Spliterator<T> spliterator() {\n",
        "382": "        return Stream.generate(() -> iterable).flatMap(Streams::stream).spliterator();\n",
        "383": "      }\n",
        "384": "\n",
        "574": "\n",
        "575": "      @Override\n",
        "576": "      public void forEach(Consumer<? super T> action) {\n",
        "577": "        checkNotNull(action);\n",
        "578": "        unfiltered.forEach(\n",
        "579": "            (T a) -> {\n",
        "580": "              if (retainIfTrue.test(a)) {\n",
        "581": "                action.accept(a);\n",
        "582": "              }\n",
        "583": "            });\n",
        "584": "      }\n",
        "585": "\n",
        "586": "      @Override\n",
        "587": "      public Spliterator<T> spliterator() {\n",
        "588": "        return CollectSpliterators.filter(unfiltered.spliterator(), retainIfTrue);\n",
        "589": "      }\n",
        "616": "\n",
        "617": "      @SuppressWarnings(\"unchecked\")\n",
        "618": "      @Override\n",
        "619": "      public void forEach(Consumer<? super T> action) {\n",
        "620": "        checkNotNull(action);\n",
        "621": "        unfiltered.forEach(\n",
        "622": "            (Object o) -> {\n",
        "623": "              if (desiredType.isInstance(o)) {\n",
        "624": "                action.accept(desiredType.cast(o));\n",
        "625": "              }\n",
        "626": "            });\n",
        "627": "      }\n",
        "628": "\n",
        "629": "      @SuppressWarnings(\"unchecked\")\n",
        "630": "      @Override\n",
        "631": "      public Spliterator<T> spliterator() {\n",
        "632": "        return (Spliterator<T>)\n",
        "633": "            CollectSpliterators.filter(unfiltered.spliterator(), desiredType::isInstance);\n",
        "634": "      }\n",
        "734": "\n",
        "735": "      @Override\n",
        "736": "      public void forEach(Consumer<? super T> action) {\n",
        "737": "        checkNotNull(action);\n",
        "738": "        fromIterable.forEach((F f) -> action.accept(function.apply(f)));\n",
        "739": "      }\n",
        "740": "\n",
        "741": "      @Override\n",
        "742": "      public Spliterator<T> spliterator() {\n",
        "743": "        return CollectSpliterators.map(fromIterable.spliterator(), function);\n",
        "744": "      }\n",
        "927": "\n",
        "928": "      @Override\n",
        "929": "      public Spliterator<T> spliterator() {\n",
        "930": "        return Streams.stream(iterable).skip(numberToSkip).spliterator();\n",
        "931": "      }\n",
        "955": "\n",
        "956": "      @Override\n",
        "957": "      public Spliterator<T> spliterator() {\n",
        "958": "        return Streams.stream(iterable).limit(limitSize).spliterator();\n",
        "959": "      }\n"
    },
    "removed": {
        "183": "    if (removeFrom instanceof RandomAccess && removeFrom instanceof List) {\n",
        "184": "      return removeIfFromRandomAccessList((List<T>) removeFrom, checkNotNull(predicate));\n",
        "189": "  private static <T> boolean removeIfFromRandomAccessList(\n",
        "190": "      List<T> list, Predicate<? super T> predicate) {\n",
        "191": "    // Note: Not all random access lists support set(). Additionally, it's possible\n",
        "192": "    // for a list to reject setting an element, such as when the list does not permit\n",
        "193": "    // duplicate elements. For both of those cases,  we need to fall back to a slower\n",
        "194": "    // implementation.\n",
        "195": "    int from = 0;\n",
        "196": "    int to = 0;\n",
        "197": "\n",
        "198": "    for (; from < list.size(); from++) {\n",
        "199": "      T element = list.get(from);\n",
        "200": "      if (!predicate.apply(element)) {\n",
        "201": "        if (from > to) {\n",
        "202": "          try {\n",
        "203": "            list.set(to, element);\n",
        "204": "          } catch (UnsupportedOperationException e) {\n",
        "205": "            slowRemoveIfForRemainingElements(list, predicate, to, from);\n",
        "206": "            return true;\n",
        "207": "          } catch (IllegalArgumentException e) {\n",
        "208": "            slowRemoveIfForRemainingElements(list, predicate, to, from);\n",
        "209": "            return true;\n",
        "210": "          }\n",
        "211": "        }\n",
        "212": "        to++;\n",
        "213": "      }\n",
        "214": "    }\n",
        "215": "\n",
        "216": "    // Clear the tail of any remaining items\n",
        "217": "    list.subList(to, list.size()).clear();\n",
        "218": "    return from != to;\n",
        "219": "  }\n",
        "220": "\n",
        "221": "  private static <T> void slowRemoveIfForRemainingElements(\n",
        "222": "      List<T> list, Predicate<? super T> predicate, int to, int from) {\n",
        "223": "    // Here we know that:\n",
        "224": "    // * (to < from) and that both are valid indices.\n",
        "225": "    // * Everything with (index < to) should be kept.\n",
        "226": "    // * Everything with (to <= index < from) should be removed.\n",
        "227": "    // * The element with (index == from) should be kept.\n",
        "228": "    // * Everything with (index > from) has not been checked yet.\n",
        "229": "\n",
        "230": "    // Check from the end of the list backwards (minimize expected cost of\n",
        "231": "    // moving elements when remove() is called). Stop before 'from' because\n",
        "232": "    // we already know that should be kept.\n",
        "233": "    for (int n = list.size() - 1; n > from; n--) {\n",
        "234": "      if (predicate.apply(list.get(n))) {\n",
        "235": "        list.remove(n);\n",
        "236": "      }\n",
        "237": "    }\n",
        "238": "    // And now remove everything in the range [to, from) (going backwards).\n",
        "239": "    for (int n = from - 1; n >= to; n--) {\n",
        "240": "      list.remove(n);\n",
        "241": "    }\n",
        "242": "  }\n",
        "243": "\n"
    }
}