{
    "addition": {
        "18": "import static com.google.common.base.Preconditions.checkNotNull;\n",
        "40": "import java.util.function.BiConsumer;\n",
        "41": "import java.util.function.BiFunction;\n",
        "522": "  @Override\n",
        "523": "  public void forEach(BiConsumer<? super K, ? super V> action) {\n",
        "524": "    checkNotNull(action);\n",
        "525": "    for (BiEntry<K, V> entry = firstInKeyInsertionOrder;\n",
        "526": "        entry != null;\n",
        "527": "        entry = entry.nextInKeyInsertionOrder) {\n",
        "528": "      action.accept(entry.key, entry.value);\n",
        "529": "    }\n",
        "530": "  }\n",
        "531": "\n",
        "532": "  @Override\n",
        "533": "  public void replaceAll(BiFunction<? super K, ? super V, ? extends V> function) {\n",
        "534": "    checkNotNull(function);\n",
        "535": "    BiEntry<K, V> oldFirst = firstInKeyInsertionOrder;\n",
        "536": "    clear();\n",
        "537": "    for (BiEntry<K, V> entry = oldFirst; entry != null; entry = entry.nextInKeyInsertionOrder) {\n",
        "538": "      put(entry.key, function.apply(entry.key, entry.value));\n",
        "539": "    }\n",
        "540": "  }\n",
        "541": "\n",
        "550": "  private final class Inverse extends IteratorBasedAbstractMap<V, K>\n",
        "551": "      implements BiMap<V, K>, Serializable {\n",
        "576": "    @CanIgnoreReturnValue\n",
        "644": "    Iterator<Entry<V, K>> entryIterator() {\n",
        "645": "      return new Itr<Entry<V, K>>() {\n",
        "647": "        Entry<V, K> output(BiEntry<K, V> entry) {\n",
        "648": "          return new InverseEntry(entry);\n",
        "651": "        class InverseEntry extends AbstractMapEntry<V, K> {\n",
        "652": "          BiEntry<K, V> delegate;\n",
        "654": "          InverseEntry(BiEntry<K, V> entry) {\n",
        "655": "            this.delegate = entry;\n",
        "656": "          }\n",
        "657": "\n",
        "658": "          @Override\n",
        "659": "          public V getKey() {\n",
        "660": "            return delegate.value;\n",
        "661": "          }\n",
        "662": "\n",
        "663": "          @Override\n",
        "664": "          public K getValue() {\n",
        "665": "            return delegate.key;\n",
        "666": "          }\n",
        "667": "\n",
        "668": "          @Override\n",
        "669": "          public K setValue(K key) {\n",
        "670": "            K oldKey = delegate.key;\n",
        "671": "            int keyHash = smearedHash(key);\n",
        "672": "            if (keyHash == delegate.keyHash && Objects.equal(key, oldKey)) {\n",
        "673": "              return key;\n",
        "675": "            checkArgument(seekByKey(key, keyHash) == null, \"value already present: %s\", key);\n",
        "676": "            delete(delegate);\n",
        "677": "            BiEntry<K, V> newEntry =\n",
        "678": "                new BiEntry<K, V>(key, keyHash, delegate.value, delegate.valueHash);\n",
        "679": "            delegate = newEntry;\n",
        "680": "            insert(newEntry, null);\n",
        "681": "            expectedModCount = modCount;\n",
        "682": "            // This is safe because entries can only get bumped up to earlier in the iteration,\n",
        "683": "            // so they can't get revisited.\n",
        "684": "            return oldKey;\n",
        "685": "          }\n",
        "690": "    @Override\n",
        "691": "    public void forEach(BiConsumer<? super V, ? super K> action) {\n",
        "692": "      checkNotNull(action);\n",
        "693": "      HashBiMap.this.forEach((k, v) -> action.accept(v, k));\n",
        "694": "    }\n",
        "695": "\n",
        "696": "    @Override\n",
        "697": "    public void replaceAll(BiFunction<? super V, ? super K, ? extends K> function) {\n",
        "698": "      checkNotNull(function);\n",
        "699": "      BiEntry<K, V> oldFirst = firstInKeyInsertionOrder;\n",
        "700": "      clear();\n",
        "701": "      for (BiEntry<K, V> entry = oldFirst; entry != null; entry = entry.nextInKeyInsertionOrder) {\n",
        "702": "        put(entry.value, function.apply(entry.value, entry.key));\n",
        "703": "      }\n",
        "704": "    }\n",
        "705": "\n"
    },
    "removed": {
        "33": "import java.util.AbstractMap;\n",
        "528": "  private final class Inverse extends AbstractMap<V, K> implements BiMap<V, K>, Serializable {\n",
        "620": "    public Set<Entry<V, K>> entrySet() {\n",
        "621": "      return new Maps.EntrySet<V, K>() {\n",
        "622": "\n",
        "624": "        Map<V, K> map() {\n",
        "625": "          return Inverse.this;\n",
        "628": "        @Override\n",
        "629": "        public Iterator<Entry<V, K>> iterator() {\n",
        "630": "          return new Itr<Entry<V, K>>() {\n",
        "631": "            @Override\n",
        "632": "            Entry<V, K> output(BiEntry<K, V> entry) {\n",
        "633": "              return new InverseEntry(entry);\n",
        "634": "            }\n",
        "636": "            class InverseEntry extends AbstractMapEntry<V, K> {\n",
        "637": "              BiEntry<K, V> delegate;\n",
        "638": "\n",
        "639": "              InverseEntry(BiEntry<K, V> entry) {\n",
        "640": "                this.delegate = entry;\n",
        "641": "              }\n",
        "642": "\n",
        "643": "              @Override\n",
        "644": "              public V getKey() {\n",
        "645": "                return delegate.value;\n",
        "646": "              }\n",
        "647": "\n",
        "648": "              @Override\n",
        "649": "              public K getValue() {\n",
        "650": "                return delegate.key;\n",
        "651": "              }\n",
        "652": "\n",
        "653": "              @Override\n",
        "654": "              public K setValue(K key) {\n",
        "655": "                K oldKey = delegate.key;\n",
        "656": "                int keyHash = smearedHash(key);\n",
        "657": "                if (keyHash == delegate.keyHash && Objects.equal(key, oldKey)) {\n",
        "658": "                  return key;\n",
        "659": "                }\n",
        "660": "                checkArgument(seekByKey(key, keyHash) == null, \"value already present: %s\", key);\n",
        "661": "                delete(delegate);\n",
        "662": "                BiEntry<K, V> newEntry =\n",
        "663": "                    new BiEntry<K, V>(key, keyHash, delegate.value, delegate.valueHash);\n",
        "664": "                delegate = newEntry;\n",
        "665": "                insert(newEntry, null);\n",
        "666": "                expectedModCount = modCount;\n",
        "667": "                // This is safe because entries can only get bumped up to earlier in the iteration,\n",
        "668": "                // so they can't get revisited.\n",
        "669": "                return oldKey;\n",
        "670": "              }\n",
        "672": "          };\n"
    }
}