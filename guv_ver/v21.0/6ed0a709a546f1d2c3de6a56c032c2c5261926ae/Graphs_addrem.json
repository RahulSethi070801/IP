{
    "addition": {
        "256": "   * Returns true iff {@code graph1} and {@code graph2} are equal as defined by\n",
        "257": "   * {@link Graph#equals(Object)}.\n",
        "278": "    if (graph1.isDirected() != graph2.isDirected()) {\n",
        "279": "      return false;\n",
        "280": "    }\n",
        "281": "\n",
        "296": "   * Returns true iff {@code graph1} and {@code graph2} are equal as defined by\n",
        "297": "   * {@link Network#equals(Object)}.\n",
        "308": "    if (graph1.isDirected() != graph2.isDirected()) {\n",
        "312": "    if (!graph1.nodes().equals(graph2.nodes()) || !graph1.edges().equals(graph2.edges())) {\n",
        "316": "    for (Object edge : graph1.edges()) {\n",
        "317": "      if (!graph1.incidentNodes(edge).equals(graph2.incidentNodes(edge))) {\n",
        "326": "   * Returns the hash code of {@code graph} as defined by {@link Graph#hashCode()}.\n",
        "332": "    return nodeToSuccessorNodes(graph).hashCode();\n",
        "336": "   * Returns the hash code of {@code graph} as defined by {@link Network#hashCode()}.\n",
        "339": "    return nodeToOutEdges(graph).hashCode();\n",
        "377": "   * and the set of outgoing edges as values.\n",
        "379": "  private static <N, E> Map<N, Set<E>> nodeToOutEdges(final Network<N, E> graph) {\n",
        "384": "        return graph.outEdges(node);\n",
        "391": "   * and the set of successor nodes as values.\n",
        "393": "  private static <N> Map<N, Set<N>> nodeToSuccessorNodes(final Graph<N> graph) {\n",
        "398": "        return graph.successors(node);\n"
    },
    "removed": {
        "256": "   * Returns true iff {@code graph1} and {@code graph2} have the same node connections.\n",
        "257": "   *\n",
        "258": "   * <p>Note: {@link Network} instances can only be equal to other {@link Network} instances.\n",
        "259": "   * In particular, {@link Graph}s that are not also {@link Network}s cannot be equal\n",
        "260": "   * to {@link Network}s.\n",
        "261": "   *\n",
        "262": "   * @see Graph#equals(Object)\n",
        "291": "      boolean bothUndirected = !graph1.isDirected() && !graph2.isDirected();\n",
        "292": "      if (!bothUndirected && !graph1.predecessors(node).equals(graph2.predecessors(node))) {\n",
        "293": "        return false;\n",
        "294": "      }\n",
        "301": "   * Returns true iff {@code graph1} and {@code graph2} have the same node/edge relationships.\n",
        "302": "   *\n",
        "303": "   * @see Network#equals(Object)\n",
        "314": "    if (graph1.edges().size() != graph2.edges().size()) {\n",
        "318": "    if (!graph1.nodes().equals(graph2.nodes())) {\n",
        "322": "    for (Object node : graph1.nodes()) {\n",
        "323": "      if (!graph1.inEdges(node).equals(graph2.inEdges(node))) {\n",
        "324": "        return false;\n",
        "325": "      }\n",
        "326": "      boolean bothUndirected = !graph1.isDirected() && !graph2.isDirected();\n",
        "327": "      if (!bothUndirected && !graph1.outEdges(node).equals(graph2.outEdges(node))) {\n",
        "336": "   * Returns the hash code of {@code graph}.\n",
        "337": "   *\n",
        "338": "   * @see Graph#hashCode()\n",
        "344": "    return nodeToAdjacentNodes(graph).hashCode();\n",
        "348": "   * Returns the hash code of {@code graph}.\n",
        "349": "   *\n",
        "350": "   * @see Network#hashCode()\n",
        "353": "    return nodeToIncidentEdges(graph).hashCode();\n",
        "391": "   * and the set of incident edges as values.\n",
        "393": "  private static <N, E> Map<N, Set<E>> nodeToIncidentEdges(final Network<N, E> graph) {\n",
        "398": "        return graph.incidentEdges(node);\n",
        "405": "   * and the set of adjacent nodes as values.\n",
        "407": "  private static <N> Map<N, Set<N>> nodeToAdjacentNodes(final Graph<N> graph) {\n",
        "412": "        return graph.adjacentNodes(node);\n"
    }
}