{
    "addition": {
        "27": "import com.google.common.base.Objects;\n",
        "28": "import com.google.common.collect.ImmutableList;\n",
        "81": " * are returning views.\n",
        "88": " * <li>{@code addEdge(E edge, N node1, N node2)}: O(1).\n",
        "89": " * <li>{@code removeNode(node)}: O(d_node).\n",
        "90": " * <li>{@code removeEdge}: O(1), unless this graph is a multigraph (supports parallel edges),\n",
        "91": " *     then this method is O(min(d_edgeNode1, d_edgeNode2)).\n",
        "92": " *\n",
        "94": " * where d_node is the degree of node.\n",
        "106": "  private final Map<N, NodeConnections<N, E>> nodeConnections;\n",
        "113": "    this.nodeConnections =\n",
        "122": "    return Collections.unmodifiableSet(nodeConnections.keySet());\n",
        "137": "    return checkedConnections(node).incidentEdges();\n",
        "149": "  public Set<N> adjacentNodes(Object node) {\n",
        "150": "    return checkedConnections(node).adjacentNodes();\n",
        "155": "    Iterator<N> incidentNodesIterator = incidentNodes(edge).iterator();\n",
        "158": "      endpointsIncidentEdges =\n",
        "159": "          Sets.union(incidentEdges(incidentNodesIterator.next()), endpointsIncidentEdges);\n",
        "165": "   * If {@code node1} is equal to {@code node2}, the set of self-loop edges is returned.\n",
        "166": "   * Otherwise, returns the intersection of these two sets, using {@link Sets#intersection}:\n",
        "173": "  public Set<E> edgesConnecting(Object node1, Object node2) {\n",
        "174": "    Set<E> incidentEdgesN1 = incidentEdges(node1);\n",
        "179": "      Set<E> selfLoopEdges = Sets.filter(incidentEdgesN1, Graphs.selfLoopPredicate(this));\n",
        "180": "      return Collections.unmodifiableSet(selfLoopEdges);\n",
        "182": "    Set<E> incidentEdgesN2 = incidentEdges(node2);\n",
        "183": "    return (incidentEdgesN1.size() <= incidentEdgesN2.size())\n",
        "210": "    return incidentEdges(node).size();\n",
        "229": "    if (nodes().contains(node)) {\n",
        "232": "    nodeConnections.put(node, UndirectedNodeConnections.<N, E>of());\n",
        "263": "    } else if (!config.isMultigraph()) {\n",
        "264": "      checkArgument(!(nodes().contains(node1) && successors(node1).contains(node2)),\n",
        "265": "          ADDING_PARALLEL_EDGE, node1, node2);\n",
        "267": "    addNode(node1);\n",
        "268": "    NodeConnections<N, E> connectionsN1 = nodeConnections.get(node1);\n",
        "269": "    connectionsN1.addSuccessor(node2, edge);\n",
        "270": "    if (!incidentNodes.isSelfLoop()) {\n",
        "271": "      addNode(node2);\n",
        "272": "      NodeConnections<N, E> connectionsN2 = nodeConnections.get(node2);\n",
        "273": "      connectionsN2.addPredecessor(node1, edge);\n",
        "284": "    NodeConnections<N, E> connections = nodeConnections.get(node);\n",
        "285": "    if (connections == null) {\n",
        "288": "    // Since views are returned, we need to copy the edges that will be removed.\n",
        "289": "    // Thus we avoid modifying the underlying view while iterating over it.\n",
        "290": "    for (E edge : ImmutableList.copyOf(incidentEdges(node))) {\n",
        "293": "    nodeConnections.remove(node);\n",
        "306": "    N node1 = Iterables.get(incidentNodes, 0);\n",
        "307": "    N node2 = Iterables.get(incidentNodes, 1, node1);\n",
        "308": "    NodeConnections<N, E> node1Connections = nodeConnections.get(node1);\n",
        "309": "    NodeConnections<N, E> node2Connections = nodeConnections.get(node2);\n",
        "310": "    if (!config.isMultigraph() || edgesConnecting(node1, node2).size() <= 1) {\n",
        "311": "      // If this is the last connecting edge between node1 and node2, they are no longer adjacent.\n",
        "312": "      node1Connections.removeSuccessor(node2);\n",
        "313": "      node2Connections.removePredecessor(node1);\n",
        "315": "    node1Connections.removeOutEdge(edge);\n",
        "316": "    node2Connections.removeInEdge(edge);\n",
        "323": "    return (object instanceof UndirectedGraph)\n",
        "324": "        && Graphs.equal(this, (UndirectedGraph<?, ?>) object);\n",
        "329": "    // The node set is included in the hash to differentiate between graphs with isolated nodes.\n",
        "330": "    return Objects.hashCode(nodes(), edgeToIncidentNodes);\n",
        "337": "        nodes(),\n",
        "341": "  private NodeConnections<N, E> checkedConnections(Object node) {\n",
        "342": "    checkNotNull(node, \"node\");\n",
        "343": "    NodeConnections<N, E> connections = nodeConnections.get(node);\n",
        "344": "    checkArgument(connections != null, NODE_NOT_IN_GRAPH, node);\n",
        "345": "    return connections;\n"
    },
    "removed": {
        "26": "import static com.google.common.graph.Graphs.oppositeNode;\n",
        "36": "import java.util.LinkedHashSet;\n",
        "81": " * are returning views. It should be noted that for the following methods:\n",
        "82": " * <ul>\n",
        "83": " * <li>Methods that ask for adjacent nodes (e.g. {@code adjacentNodes}).\n",
        "84": " * <li>{@code adjacentEdges}.\n",
        "85": " * <li>{@code edgesConnecting}.\n",
        "86": " * </ul>\n",
        "87": " * the view is calculated lazily and the backing set is <b>not</b> cached, so every time the user\n",
        "88": " * accesses the returned view, the backing set will be reconstructed again. If the user wants\n",
        "89": " * to avoid this, they should either use {@code ImmutableUndirectedGraph}\n",
        "90": " * (if their input is not changing) or make a copy of the return value.\n",
        "97": " * <li>{@code removeEdge}: O(1).\n",
        "98": " * <li>{@code addEdge(E edge, N node1, N node2)}: O(1), unless this graph is not a multigraph\n",
        "99": " * (does not support parallel edges). In such case, this method may call\n",
        "100": " * {@code edgesConnecting(node1, node2)}.\n",
        "101": " * <li>{@code removeNode(node)} O(d), where d is the degree of {@code node}.\n",
        "114": "  private final Map<N, Set<E>> nodeToIncidentEdges;\n",
        "121": "    this.nodeToIncidentEdges =\n",
        "130": "    return Collections.unmodifiableSet(nodeToIncidentEdges.keySet());\n",
        "145": "    checkNotNull(node, \"node\");\n",
        "146": "    Set<E> incidentEdges = nodeToIncidentEdges.get(node);\n",
        "147": "    checkArgument(incidentEdges != null, NODE_NOT_IN_GRAPH, node);\n",
        "148": "    return Collections.unmodifiableSet(incidentEdges);\n",
        "160": "  public Set<N> adjacentNodes(final Object node) {\n",
        "161": "    checkNotNull(node, \"node\");\n",
        "162": "    final Set<E> incidentEdges = nodeToIncidentEdges.get(node);\n",
        "163": "    checkArgument(incidentEdges != null, NODE_NOT_IN_GRAPH, node);\n",
        "164": "    return new SetView<N>() {\n",
        "165": "      @Override\n",
        "166": "      public boolean isEmpty() {\n",
        "167": "        return incidentEdges.isEmpty();\n",
        "168": "      }\n",
        "169": "\n",
        "170": "      @Override\n",
        "171": "      Set<N> elements() {\n",
        "172": "        Set<N> nodes = Sets.newLinkedHashSetWithExpectedSize(incidentEdges.size());\n",
        "173": "        for (E edge : incidentEdges) {\n",
        "174": "          nodes.add(oppositeNode(IncidenceSetUndirectedGraph.this, edge, node));\n",
        "175": "        }\n",
        "176": "        return nodes;\n",
        "177": "      }\n",
        "178": "    };\n",
        "183": "    checkNotNull(edge, \"edge\");\n",
        "184": "    UndirectedIncidentNodes<N> incidentNodes = edgeToIncidentNodes.get(edge);\n",
        "185": "    checkArgument(incidentNodes != null, EDGE_NOT_IN_GRAPH, edge);\n",
        "186": "    Iterator<N> incidentNodesIterator = incidentNodes.iterator();\n",
        "189": "      endpointsIncidentEdges = Sets.union(incidentEdges(incidentNodesIterator.next()),\n",
        "190": "          endpointsIncidentEdges);\n",
        "196": "   * If {@code node1} is equal to {@code node2} and self-loops are allowed (if self-loops\n",
        "197": "   * are not allowed, this would be a trivial case and an empty set is returned),\n",
        "198": "   * a {@code SetView} instance is returned, calculating the set of self-loop edges.\n",
        "199": "   * Otherwise, this method returns the intersection of these two sets,\n",
        "200": "   * using {@code Sets.intersection}:\n",
        "205": "   * The first argument passed to {@code Sets.intersection} is the smaller of\n",
        "206": "   * the two sets.\n",
        "207": "   *\n",
        "208": "   * @see Sets#intersection\n",
        "211": "  public Set<E> edgesConnecting(final Object node1, Object node2) {\n",
        "212": "    checkNotNull(node1, \"node1\");\n",
        "213": "    checkNotNull(node2, \"node2\");\n",
        "214": "    final Set<E> incidentEdgesN1 = nodeToIncidentEdges.get(node1);\n",
        "215": "    checkArgument(incidentEdgesN1 != null, NODE_NOT_IN_GRAPH, node1);\n",
        "220": "      return new SetView<E>() {\n",
        "221": "        @Override\n",
        "222": "        Set<E> elements() {\n",
        "223": "          Set<E> selfLoopEdges = Sets.newLinkedHashSet();\n",
        "224": "          for (E edge : incidentEdgesN1) {\n",
        "225": "            if (edgeToIncidentNodes.get(edge).isSelfLoop()) {\n",
        "226": "              selfLoopEdges.add(edge);\n",
        "227": "            }\n",
        "228": "          }\n",
        "229": "          return selfLoopEdges;\n",
        "230": "        }\n",
        "231": "      };\n",
        "233": "    final Set<E> incidentEdgesN2 = nodeToIncidentEdges.get(node2);\n",
        "234": "    checkArgument(incidentEdgesN2 != null, NODE_NOT_IN_GRAPH, node2);\n",
        "235": "    return incidentEdgesN1.size() <= incidentEdgesN2.size()\n",
        "262": "    checkNotNull(node, \"node\");\n",
        "263": "    Set<E> incidentEdges = nodeToIncidentEdges.get(node);\n",
        "264": "    checkArgument(incidentEdges != null, NODE_NOT_IN_GRAPH, node);\n",
        "265": "    return incidentEdges.size();\n",
        "284": "    if (containsNode(node)) {\n",
        "287": "    // TODO(user): Enable users to specify expected number of neighbors for\n",
        "288": "    // a node.\n",
        "289": "    nodeToIncidentEdges.put(node, new LinkedHashSet<E>());\n",
        "320": "    } else if (!config.isMultigraph() && containsNode(node1) && containsNode(node2)) {\n",
        "321": "      E edgeConnecting = Iterables.getOnlyElement(edgesConnecting(node1, node2), null);\n",
        "322": "      checkArgument(edgeConnecting == null, ADDING_PARALLEL_EDGE, node1, node2, edgeConnecting);\n",
        "324": "    for (N node : incidentNodes) {\n",
        "325": "      addNode(node);\n",
        "326": "      nodeToIncidentEdges.get(node).add(edge);\n",
        "337": "    Set<E> incidentEdges = nodeToIncidentEdges.get(node);\n",
        "338": "    if (incidentEdges == null) {\n",
        "341": "    // Since views are returned, we need to copy the set of incident edges\n",
        "342": "    // to an equivalent collection to avoid removing the edges we are looping on.\n",
        "343": "    for (Object edge : incidentEdges.toArray()) {\n",
        "346": "    nodeToIncidentEdges.remove(node);\n",
        "359": "    for (N node : incidentNodes) {\n",
        "360": "      nodeToIncidentEdges.get(node).remove(edge);\n",
        "368": "    return (object instanceof UndirectedGraph) && Graphs.equal(this, (UndirectedGraph) object);\n",
        "373": "    // This map encapsulates all of the structural relationships of this graph, so its hash code\n",
        "374": "    // is consistent with the above definition of equals().\n",
        "375": "    return nodeToIncidentEdges.hashCode();\n",
        "382": "        nodeToIncidentEdges.keySet(),\n",
        "386": "  private boolean containsNode(Object node) {\n",
        "387": "    return nodeToIncidentEdges.containsKey(node);\n"
    }
}