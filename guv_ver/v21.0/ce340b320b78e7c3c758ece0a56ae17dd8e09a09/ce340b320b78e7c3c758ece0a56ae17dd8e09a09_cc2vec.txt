{"id": "ce340b320b78e7c3c758ece0a56ae17dd8e09a09", "code": [{"0": "guava-tests/test/com/google/common/graph/ElementOrderTest.java", "added": {"1": ["/*\n", " * Copyright (C) 2016 The Guava Authors\n", " *\n", " * Licensed under the Apache License, Version 2.0 (the \"License\");\n", " * you may not use this file except in compliance with the License.\n", " * You may obtain a copy of the License at\n", " *\n", " * http://www.apache.org/licenses/LICENSE-2.0\n", " *\n", " * Unless required by applicable law or agreed to in writing, software\n", " * distributed under the License is distributed on an \"AS IS\" BASIS,\n", " * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n", " * See the License for the specific language governing permissions and\n", " * limitations under the License.\n", " */\n", "\n", "package com.google.common.graph;\n", "\n", "import static com.google.common.graph.ElementOrder.insertion;\n", "import static com.google.common.graph.ElementOrder.unordered;\n", "import static com.google.common.truth.Truth.assertThat;\n", "\n", "import com.google.common.collect.Ordering;\n", "\n", "import org.junit.Test;\n", "import org.junit.runner.RunWith;\n", "import org.junit.runners.JUnit4;\n", "\n", "/**\n", " * Tests for ordering the elements of graphs.\n", " */\n", "@RunWith(JUnit4.class)\n", "public final class ElementOrderTest {\n", "  // Node order tests\n", "\n", "  @Test\n", "  public void orderNodes_none() throws Exception {\n", "    MutableGraph<Integer> graph = GraphBuilder\n", "        .directed()\n", "        .orderNodes(unordered())\n", "        .build();\n", "\n", "    assertThat(graph.nodeOrder()).isEqualTo(unordered());\n", "  }\n", "\n", "  @Test\n", "  public void orderNodes_insertion() throws Exception {\n", "    MutableGraph<Integer> graph = GraphBuilder\n", "        .directed()\n", "        .orderNodes(insertion())\n", "        .build();\n", "\n", "    addNodes(graph);\n", "\n", "    assertThat(graph.nodeOrder()).isEqualTo(insertion());\n", "    assertThat(graph.nodes()).containsExactly(3, 1, 4).inOrder();\n", "  }\n", "\n", "  // The default ordering is INSERTION unless otherwise specified.\n", "  @Test\n", "  public void orderNodes_default() throws Exception {\n", "    MutableGraph<Integer> graph = GraphBuilder\n", "        .directed()\n", "        .build();\n", "\n", "    addNodes(graph);\n", "\n", "    assertThat(graph.nodeOrder()).isEqualTo(insertion());\n", "    assertThat(graph.nodes()).containsExactly(3, 1, 4).inOrder();\n", "  }\n", "\n", "  @Test\n", "  public void orderNodes_natural() throws Exception {\n", "    MutableGraph<Integer> graph = GraphBuilder\n", "        .directed()\n", "        .orderNodes(ElementOrder.<Integer>natural())\n", "        .build();\n", "\n", "    addNodes(graph);\n", "\n", "    assertThat(graph.nodeOrder()).isEqualTo(ElementOrder.sorted(Ordering.<Integer>natural()));\n", "    assertThat(graph.nodes()).containsExactly(1, 3, 4).inOrder();\n", "  }\n", "\n", "  @Test\n", "  public void orderNodes_sorted() throws Exception {\n", "    MutableGraph<Integer> graph = GraphBuilder\n", "        .directed()\n", "        .orderNodes(ElementOrder.sorted(Ordering.<Integer>natural().reverse()))\n", "        .build();\n", "\n", "    addNodes(graph);\n", "\n", "    assertThat(graph.nodeOrder()).isEqualTo(\n", "        ElementOrder.sorted(Ordering.<Integer>natural().reverse()));\n", "    assertThat(graph.nodes()).containsExactly(4, 3, 1).inOrder();\n", "  }\n", "\n", "  // Edge order tests\n", "\n", "  @Test\n", "  public void orderEdges_none() throws Exception {\n", "    MutableNetwork<Integer, String> graph = NetworkBuilder\n", "        .directed()\n", "        .orderEdges(unordered())\n", "        .build();\n", "\n", "    assertThat(graph.edgeOrder()).isEqualTo(unordered());\n", "    assertThat(graph.nodeOrder()).isEqualTo(insertion()); // default\n", "  }\n", "\n", "  @Test\n", "  public void orderEdges_insertion() throws Exception {\n", "    MutableNetwork<Integer, String> graph = NetworkBuilder\n", "        .directed()\n", "        .orderEdges(insertion())\n", "        .build();\n", "\n", "    addEdges(graph);\n", "\n", "    assertThat(graph.edgeOrder()).isEqualTo(ElementOrder.insertion());\n", "    assertThat(graph.edges()).containsExactly(\"i\", \"e\", \"p\").inOrder();\n", "    assertThat(graph.nodeOrder()).isEqualTo(ElementOrder.insertion()); // default\n", "  }\n", "\n", "  // The default ordering is INSERTION unless otherwise specified.\n", "  @Test\n", "  public void orderEdges_default() throws Exception {\n", "    MutableNetwork<Integer, String> graph = NetworkBuilder\n", "        .directed()\n", "        .build();\n", "\n", "    addEdges(graph);\n", "\n", "    assertThat(graph.edgeOrder()).isEqualTo(ElementOrder.insertion());\n", "    assertThat(graph.edges()).containsExactly(\"i\", \"e\", \"p\").inOrder();\n", "    assertThat(graph.nodeOrder()).isEqualTo(ElementOrder.insertion()); // default\n", "  }\n", "\n", "  @Test\n", "  public void orderEdges_natural() throws Exception {\n", "    MutableNetwork<Integer, String> graph = NetworkBuilder\n", "        .directed()\n", "        .orderEdges(ElementOrder.<String>natural())\n", "        .build();\n", "\n", "    addEdges(graph);\n", "\n", "    assertThat(graph.edgeOrder()).isEqualTo(ElementOrder.sorted(Ordering.<String>natural()));\n", "    assertThat(graph.edges()).containsExactly(\"e\", \"i\", \"p\").inOrder();\n", "    assertThat(graph.nodeOrder()).isEqualTo(insertion()); // default\n", "  }\n", "\n", "  @Test\n", "  public void orderEdges_sorted() throws Exception {\n", "    MutableNetwork<Integer, String> graph = NetworkBuilder\n", "        .directed()\n", "        .orderEdges(ElementOrder.sorted(Ordering.<String>natural().reverse()))\n", "        .build();\n", "\n", "    addEdges(graph);\n", "\n", "    assertThat(graph.edgeOrder()).isEqualTo(\n", "        ElementOrder.sorted(Ordering.<String>natural().reverse()));\n", "    assertThat(graph.edges()).containsExactly(\"p\", \"i\", \"e\").inOrder();\n", "    assertThat(graph.nodeOrder()).isEqualTo(ElementOrder.insertion()); // default\n", "  }\n", "\n", "  // Combined node and edge order tests\n", "  @Test\n", "  public void orderNodesUnorderedandEdgesSorted() throws Exception {\n", "    MutableNetwork<Integer, String> graph = NetworkBuilder\n", "        .directed()\n", "        .orderNodes(unordered())\n", "        .orderEdges(ElementOrder.sorted(Ordering.<String>natural().reverse()))\n", "        .build();\n", "\n", "    addEdges(graph);\n", "\n", "    assertThat(graph.edgeOrder()).isEqualTo(\n", "        ElementOrder.sorted(Ordering.<String>natural().reverse()));\n", "    assertThat(graph.edges()).containsExactly(\"p\", \"i\", \"e\").inOrder();\n", "    assertThat(graph.nodeOrder()).isEqualTo(unordered());\n", "    assertThat(graph.nodes()).containsExactly(4, 1, 3);\n", "  }\n", "\n", "  private static void addNodes(MutableGraph<Integer> graph) {\n", "    graph.addNode(3);\n", "    graph.addNode(1);\n", "    graph.addNode(4);\n", "  }\n", "\n", "  private static void addEdges(MutableNetwork<Integer, String> graph) {\n", "    graph.addEdge(\"i\", 3, 1);\n", "    graph.addEdge(\"e\", 1, 4);\n", "    graph.addEdge(\"p\", 4, 3);\n", "  }\n", "}\n"]}, "removed": {}, "added_lines": {"1": [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 58, 59, 60, 61, 62, 63, 64, 65, 66, 67, 68, 69, 70, 71, 72, 73, 74, 75, 76, 77, 78, 79, 80, 81, 82, 83, 84, 85, 86, 87, 88, 89, 90, 91, 92, 93, 94, 95, 96, 97, 98, 99, 100, 101, 102, 103, 104, 105, 106, 107, 108, 109, 110, 111, 112, 113, 114, 115, 116, 117, 118, 119, 120, 121, 122, 123, 124, 125, 126, 127, 128, 129, 130, 131, 132, 133, 134, 135, 136, 137, 138, 139, 140, 141, 142, 143, 144, 145, 146, 147, 148, 149, 150, 151, 152, 153, 154, 155, 156, 157, 158, 159, 160, 161, 162, 163, 164, 165, 166, 167, 168, 169, 170, 171, 172, 173, 174, 175, 176, 177, 178, 179, 180, 181, 182, 183, 184, 185, 186, 187, 188, 189, 190, 191, 192, 193, 194, 195, 196, 197, 198]}, "removed_lines": {}}, {"1": "guava/src/com/google/common/graph/AbstractConfigurableGraph.java", "added": {"1": ["  private final ElementOrder<? super N> nodeOrder;\n"], "2": ["    this(builder, AbstractConfigurableGraph.<N>getNodeMapforBuilder(builder));\n", "  }\n", "\n", "  private static <S> Map<S, NodeAdjacencies<S>> getNodeMapforBuilder(\n", "      GraphBuilder<? super S> builder) {\n", "    int expectedNodeSize = builder.expectedNodeCount.or(DEFAULT_MAP_SIZE);\n", "    switch (builder.nodeOrder.type()) {\n", "        case UNORDERED:\n", "          return Maps.newHashMapWithExpectedSize(expectedNodeSize);\n", "        case INSERTION:\n", "          return Maps.newLinkedHashMapWithExpectedSize(expectedNodeSize);\n", "        case SORTED:\n", "          return Maps.newTreeMap(builder.nodeOrder.comparator());\n", "        default:\n", "          throw new IllegalArgumentException(\"Unrecognized node ElementOrder type\");\n", "    }\n"], "3": ["    this.nodeOrder = builder.nodeOrder;\n", "  /**\n", "   * {@inheritDoc}\n", "   * <p>The order of iteration for this set is determined by the {@code ElementOrder<N>} provided\n", "   * to the {@code GraphBuilder} that was used to create this instance.\n", "   * By default, that order is the order in which the nodes were added to the graph.\n", "   */\n"], "4": ["  @Override\n", "  public ElementOrder<? super N> nodeOrder() {\n", "    return nodeOrder;\n", "  }\n", "\n"]}, "removed": {"1": ["// TODO(b/24620028): Enable this class to support sorted nodes/edges.\n"], "2": ["    this(\n", "        builder,\n", "        Maps.<N, NodeAdjacencies<N>>newLinkedHashMapWithExpectedSize(\n", "            builder.expectedNodeCount.or(DEFAULT_MAP_SIZE)));\n"]}, "added_lines": {"1": [61], "2": [69, 70, 71, 72, 73, 74, 75, 76, 77, 78, 79, 80, 81, 82, 83, 84], "3": [95, 99, 100, 101, 102, 103, 104], "4": [120, 121, 122, 123, 124]}, "removed_lines": {"1": [55], "2": [69, 70, 71, 72]}}, {"2": "guava/src/com/google/common/graph/AbstractConfigurableNetwork.java", "added": {"2": ["  private final ElementOrder<? super N> nodeOrder;\n", "  private final ElementOrder<? super E> edgeOrder;\n"], "3": ["        AbstractConfigurableNetwork.<N, E>getNodeMapForBuilder(builder),\n", "        AbstractConfigurableNetwork.<N, E>getEdgeMapForBuilder(builder));\n", "  }\n", "\n", "  private static <S, T> Map<S, NodeConnections<S, T>> getNodeMapForBuilder(\n", "      NetworkBuilder<? super S, ? super T> builder) {\n", "    int expectedNodeSize = builder.expectedNodeCount.or(DEFAULT_MAP_SIZE);\n", "    switch (builder.nodeOrder.type()) {\n", "        case UNORDERED:\n", "          return Maps.newHashMapWithExpectedSize(expectedNodeSize);\n", "        case INSERTION:\n", "          return Maps.newLinkedHashMapWithExpectedSize(expectedNodeSize);\n", "        case SORTED:\n", "          return Maps.newTreeMap(builder.nodeOrder.comparator());\n", "        default:\n", "          throw new IllegalArgumentException(\"Unrecognized node ElementOrder type\");\n", "    }\n", "  }\n", "\n", "  private static <S, T> Map<T, S> getEdgeMapForBuilder(\n", "      NetworkBuilder<? super S, ? super T> builder) {\n", "    int expectedEdgeSize = builder.expectedEdgeCount.or(DEFAULT_MAP_SIZE);\n", "    switch (builder.edgeOrder.type()) {\n", "        case UNORDERED:\n", "          return Maps.newHashMapWithExpectedSize(expectedEdgeSize);\n", "        case INSERTION:\n", "          return Maps.newLinkedHashMapWithExpectedSize(expectedEdgeSize);\n", "        case SORTED:\n", "          return Maps.newTreeMap(builder.edgeOrder.comparator());\n", "        default:\n", "          throw new IllegalArgumentException(\"Unrecognized edge ElementOrder type\");\n", "    }\n"], "4": ["    this.nodeOrder = builder.nodeOrder;\n", "    this.edgeOrder = builder.edgeOrder;\n", "  /**\n", "   * {@inheritDoc}\n", "   *\n", "   * <p>The order of iteration for this set is determined by the {@code ElementOrder<N>} provided\n", "   * to the {@code GraphBuilder} that was used to create this instance.\n", "   * By default, that order is the order in which the nodes were added to the graph.\n", "   */\n", "  /**\n", "   * {@inheritDoc}\n", "   *\n", "   * <p>The order of iteration for this set is determined by the {@code ElementOrder<E>} provided\n", "   * to the {@code GraphBuilder} that was used to create this instance.\n", "   * By default, that order is the order in which the edges were added to the graph.\n", "   */\n"], "5": ["  @Override\n", "  public ElementOrder<? super N> nodeOrder() {\n", "    return nodeOrder;\n", "  }\n", "\n", "  @Override\n", "  public ElementOrder<? super E> edgeOrder() {\n", "    return edgeOrder;\n", "  }\n", "\n"]}, "removed": {"1": ["// TODO(b/24620028): Enable this class to support sorted nodes/edges.\n"], "3": ["        Maps.<N, NodeConnections<N, E>>newLinkedHashMapWithExpectedSize(\n", "            builder.expectedNodeCount.or(DEFAULT_MAP_SIZE)),\n", "        Maps.<E, N>newLinkedHashMapWithExpectedSize(\n", "            builder.expectedEdgeCount.or(DEFAULT_MAP_SIZE)));\n"]}, "added_lines": {"2": [70, 71], "3": [82, 83, 84, 85, 86, 87, 88, 89, 90, 91, 92, 93, 94, 95, 96, 97, 98, 99, 100, 101, 102, 103, 104, 105, 106, 107, 108, 109, 110, 111, 112, 113], "4": [126, 127, 132, 133, 134, 135, 136, 137, 138, 144, 145, 146, 147, 148, 149, 150], "5": [171, 172, 173, 174, 175, 176, 177, 178, 179, 180]}, "removed_lines": {"1": [63], "3": [81, 82, 83, 84]}}, {"3": "guava/src/com/google/common/graph/ConfigurableMutableGraph.java", "added": {}, "removed": {"1": ["// TODO(b/24620028): Enable this class to support sorted nodes/edges.\n"]}, "added_lines": {}, "removed_lines": {"1": [37]}}, {"4": "guava/src/com/google/common/graph/ConfigurableMutableNetwork.java", "added": {}, "removed": {"1": ["// TODO(b/24620028): Enable this class to support sorted nodes/edges.\n"]}, "added_lines": {}, "removed_lines": {"1": [41]}}, {"5": "guava/src/com/google/common/graph/ElementOrder.java", "added": {"1": ["/*\n", " * Copyright (C) 2016 The Guava Authors\n", " *\n", " * Licensed under the Apache License, Version 2.0 (the \"License\");\n", " * you may not use this file except in compliance with the License.\n", " * You may obtain a copy of the License at\n", " *\n", " * http://www.apache.org/licenses/LICENSE-2.0\n", " *\n", " * Unless required by applicable law or agreed to in writing, software\n", " * distributed under the License is distributed on an \"AS IS\" BASIS,\n", " * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n", " * See the License for the specific language governing permissions and\n", " * limitations under the License.\n", " */\n", "\n", "package com.google.common.graph;\n", "\n", "import com.google.common.base.MoreObjects;\n", "import com.google.common.base.MoreObjects.ToStringHelper;\n", "import com.google.common.base.Objects;\n", "import com.google.common.base.Preconditions;\n", "import com.google.common.collect.Ordering;\n", "\n", "import java.util.Comparator;\n", "\n", "import javax.annotation.Nullable;\n", "\n", "/**\n", " * Used to represent the order of elements in a data structure that supports different options\n", " * for iteration order guarantees.\n", " *\n", " * <p>Example usage:\n", " * <pre><code>\n", " *   MutableGraph<Integer> graph\n", " *       = GraphBuilder.directed().orderNodes(ElementOrder.natural()).build();\n", " * </code></pre>\n", " */\n", "public class ElementOrder<T> {\n", "  private final Type type;\n", "  @Nullable private final Comparator<T> comparator;\n", "\n", "  /**\n", "   * The type of ordering that this object specifies.\n", "   * <ul>\n", "   * <li>UNORDERED: no order is guaranteed.\n", "   * <li>INSERTION: insertion ordering is guaranteed.\n", "   * <li>SORTED: ordering according to a supplied comparator is guaranteed.\n", "   * </ul>\n", "   */\n", "  public enum Type {\n", "    UNORDERED,\n", "    INSERTION,\n", "    SORTED\n", "  }\n", "\n", "  private ElementOrder(Type type, @Nullable Comparator<T> comparator) {\n", "    this.type = Preconditions.checkNotNull(type);\n", "    Preconditions.checkArgument((type == Type.SORTED) == (comparator != null),\n", "        \"if the type is SORTED, the comparator should be non-null; otherwise, it should be null\");\n", "    this.comparator = comparator;\n", "  }\n", "\n", "  /**\n", "   * Returns the type of ordering used.\n", "   */\n", "  public Type type() {\n", "    return type;\n", "  }\n", "\n", "  /**\n", "   * Returns the {@link Comparator} used.\n", "   *\n", "   * @throws IllegalStateException if no comparator is defined\n", "   */\n", "  public Comparator<T> comparator() {\n", "    if (comparator != null) {\n", "      return comparator;\n", "    }\n", "    throw new IllegalStateException(\"This ordering does not define a comparator\");\n", "  }\n", "\n", "  @Override\n", "  public boolean equals(Object o) {\n", "    if (!(o instanceof ElementOrder)) {\n", "      return false;\n", "    }\n", "\n", "    ElementOrder<?> other = (ElementOrder<?>) o;\n", "    return other.type == this.type\n", "        && Objects.equal(other.comparator, this.comparator);\n", "  }\n", "\n", "  @Override\n", "  public int hashCode() {\n", "    return Objects.hashCode(this.type, this.comparator);\n", "  }\n", "\n", "  @Override\n", "  public String toString() {\n", "    ToStringHelper helper = MoreObjects.toStringHelper(this)\n", "        .add(\"type\", this.type);\n", "    if (this.comparator != null) {\n", "      helper.add(\"comparator\", this.comparator);\n", "    }\n", "    return helper.toString();\n", "  }\n", "\n", "  /**\n", "   * Returns an instance which specifies that no ordering is guaranteed.\n", "   */\n", "  public static final <S> ElementOrder<S> unordered() {\n", "    return new ElementOrder<S>(Type.UNORDERED, null);\n", "  }\n", "\n", "  /**\n", "   * Returns an instance which specifies that insertion ordering is guaranteed.\n", "   */\n", "  public static final <S> ElementOrder<S> insertion() {\n", "    return new ElementOrder<S>(Type.INSERTION, null);\n", "  }\n", "\n", "  /**\n", "   * Returns an instance which specifies that the natural ordering of the elements is guaranteed.\n", "   */\n", "  public static final <S extends Comparable<S>> ElementOrder<S> natural() {\n", "    return new ElementOrder<S>(Type.SORTED, Ordering.<S>natural());\n", "  }\n", "\n", "  /**\n", "   * Returns an instance which specifies that the ordering of the elements is guaranteed to be\n", "   * determined by {@code comparator}.\n", "   */\n", "  public static final <S extends Comparable<S>> ElementOrder<S> sorted(Comparator<S> comparator) {\n", "    return new ElementOrder<S>(Type.SORTED, comparator);\n", "  }\n", "}\n"]}, "removed": {}, "added_lines": {"1": [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 58, 59, 60, 61, 62, 63, 64, 65, 66, 67, 68, 69, 70, 71, 72, 73, 74, 75, 76, 77, 78, 79, 80, 81, 82, 83, 84, 85, 86, 87, 88, 89, 90, 91, 92, 93, 94, 95, 96, 97, 98, 99, 100, 101, 102, 103, 104, 105, 106, 107, 108, 109, 110, 111, 112, 113, 114, 115, 116, 117, 118, 119, 120, 121, 122, 123, 124, 125, 126, 127, 128, 129, 130, 131, 132, 133, 134, 135, 136, 137]}, "removed_lines": {}}, {"6": "guava/src/com/google/common/graph/Graph.java", "added": {"1": ["  /**\n", "   * Returns all nodes in this graph, in the order specified by {@link #nodeOrder()}.\n", "   */\n"], "2": ["  /**\n", "   * Returns the order of iteration for the elements of {@link #nodes()}.\n", "   */\n", "  ElementOrder<? super N> nodeOrder();\n", "\n"], "3": ["   * direction will have the same hash code (but can still be differentiated by\n", "   * {@link #equals(Object)}.\n"]}, "removed": {"1": ["  /** Returns all nodes in this graph. */\n"], "3": ["   * direction will have the same hash code (but can still be differentiated by {@link #equals}.\n"]}, "added_lines": {"1": [172, 173, 174], "2": [193, 194, 195, 196, 197], "3": [288, 289]}, "removed_lines": {"1": [172], "3": [281]}}, {"7": "guava/src/com/google/common/graph/GraphBuilder.java", "added": {"1": ["import static com.google.common.base.Preconditions.checkNotNull;\n"], "2": [" * <li>orders {@code nodes()} in the order in which the elements were added\n", "  ElementOrder<N> nodeOrder = ElementOrder.insertion();\n"], "3": ["    checkNotNull(graph);\n", "    return new GraphBuilder<Object>(graph.isDirected())\n", "        .allowsSelfLoops(graph.allowsSelfLoops())\n", "        .orderNodes(graph.nodeOrder())\n", "        .cast();\n"], "4": ["  /**\n", "   * Specifies the order of iteration for the elements of {@link Network#nodes()}.\n", "   */\n", "  public <N1 extends N> GraphBuilder<N1> orderNodes(ElementOrder<N1> nodeOrder) {\n", "    checkNotNull(nodeOrder);\n", "    GraphBuilder<N1> newBuilder = cast();\n", "    newBuilder.nodeOrder = nodeOrder;\n", "    return newBuilder;\n", "  }\n", "\n", "\n", "  @SuppressWarnings(\"unchecked\")\n", "  private <N1 extends N> GraphBuilder<N1> cast() {\n", "    return (GraphBuilder<N1>) this;\n", "  }\n"]}, "removed": {"1": ["import java.util.Comparator;\n", "\n"], "2": ["// TODO(b/24620028): Add support for sorted nodes/edges. Use the same pattern as CacheBuilder\n", "// to narrow the generic type when Comparators are provided.\n", "  Comparator<N> nodeComparator = null;\n"], "3": ["    return new GraphBuilder<N>(graph.isDirected())\n", "        .allowsSelfLoops(graph.allowsSelfLoops());\n"]}, "added_lines": {"1": [20], "2": [32, 43], "3": [78, 80, 81, 82, 83], "4": [108, 109, 110, 111, 112, 113, 114, 115, 116, 117, 124, 125, 126, 127, 128]}, "removed_lines": {"1": [24, 25], "2": [39, 40, 45], "3": [81, 82]}}, {"8": "guava/src/com/google/common/graph/ImmutableGraph.java", "added": {"1": ["    // ImmutableMap.Builder maintains the order of the elements as inserted, so the map will\n", "    // have whatever ordering the graph's edges do, so ImmutableSortedMap is unnecessary even if the\n", "    // input edges are sorted.\n"]}, "removed": {}, "added_lines": {"1": [66, 67, 68]}, "removed_lines": {}}, {"9": "guava/src/com/google/common/graph/ImmutableNetwork.java", "added": {"1": ["    // ImmutableMap.Builder maintains the order of the elements as inserted, so the map will\n", "    // have whatever ordering the graph's nodes do, so ImmutableSortedMap is unnecessary even if the\n", "    // input nodes are sorted.\n"], "2": ["    // ImmutableMap.Builder maintains the order of the elements as inserted, so the map will\n", "    // have whatever ordering the graph's edges do, so ImmutableSortedMap is unnecessary even if the\n", "    // input edges are sorted.\n"]}, "removed": {}, "added_lines": {"1": [74, 75, 76], "2": [85, 86, 87]}, "removed_lines": {}}, {"10": "guava/src/com/google/common/graph/Network.java", "added": {"1": [" *     ensure that the implementations of {@link #equals(Object)} and\n", " *     {@link #hashCode()} are mutually consistent, and consistent across\n", " *     implementations.\n"], "2": ["  /**\n", "   * Returns all edges in this network, in the order specified by {@link #edgeOrder()}.\n", "   */\n"], "3": ["  /**\n", "   * Returns the order of iteration for the elements of {@link #edges()}.\n", "   */\n", "  ElementOrder<? super E> edgeOrder();\n", "\n"], "4": ["   * <p>A reference implementation of this is provided by\n", "   * {@link Graphs#equal(Network, Network)}.\n"], "5": ["   * direction will have the same hash code (but can still be differentiated by\n", "   * {@link #equals(Object)}).\n"]}, "removed": {"1": [" *     ensure consistent {@link #equals(Object)} and {@link #hashCode()} across implementations.\n"], "2": ["  /** Returns all edges in this network. */\n"], "4": ["   * <p>A reference implementation of this is provided by {@link Graphs#equal(Graph, Graph)}.\n"], "5": ["   * direction will have the same hash code (but can still be differentiated by {@link #equals}.\n"]}, "added_lines": {"1": [160, 161, 162], "2": [210, 211, 212], "3": [238, 239, 240, 241, 242], "4": [378, 379], "5": [391, 392]}, "removed_lines": {"1": [160], "2": [208], "4": [369], "5": [381]}}, {"11": "guava/src/com/google/common/graph/NetworkBuilder.java", "added": {"1": ["import static com.google.common.base.Preconditions.checkNotNull;\n"], "2": [" * <li>orders {@code nodes()} and {@code edges()} in the order in which the elements were added\n", "  ElementOrder<? super N> nodeOrder = ElementOrder.insertion();\n", "  ElementOrder<? super E> edgeOrder = ElementOrder.insertion();\n"], "3": ["    checkNotNull(graph);\n", "    return new NetworkBuilder<Object, Object>(graph.isDirected())\n", "        .allowsSelfLoops(graph.allowsSelfLoops())\n", "        .orderNodes(graph.nodeOrder())\n", "        .orderEdges(graph.edgeOrder())\n", "        .cast();\n"], "4": ["  /**\n", "   * Specifies the order of iteration for the elements of {@link Network#nodes()}.\n", "   */\n", "  public <N1 extends N> NetworkBuilder<N1, E> orderNodes(ElementOrder<N1> nodeOrder) {\n", "    checkNotNull(nodeOrder);\n", "    NetworkBuilder<N1, E> newBuilder = cast();\n", "    newBuilder.nodeOrder = nodeOrder;\n", "    return newBuilder;\n", "  }\n", "\n", "  /**\n", "   * Specifies the order of iteration for the elements of {@link Network#edges()}.\n", "   */\n", "  public <E1 extends E> NetworkBuilder<N, E1> orderEdges(ElementOrder<E1> edgeOrder) {\n", "    checkNotNull(edgeOrder);\n", "    NetworkBuilder<N, E1> newBuilder = cast();\n", "    newBuilder.edgeOrder = edgeOrder;\n", "    return newBuilder;\n", "  }\n", "\n", "\n", "  @SuppressWarnings(\"unchecked\")\n", "  private <N1 extends N, E1 extends E> NetworkBuilder<N1, E1> cast() {\n", "    return (NetworkBuilder<N1, E1>) this;\n", "  }\n"]}, "removed": {"1": ["import java.util.Comparator;\n", "\n"], "2": ["// TODO(b/24620028): Add support for sorted nodes/edges. Use the same pattern as CacheBuilder\n", "// to narrow the generic <N, E> type when Comparators are provided.\n", "  Comparator<N> nodeComparator = null;\n", "  Comparator<E> edgeComparator = null;\n"], "3": ["    return new NetworkBuilder<N, E>(graph.isDirected())\n", "        .allowsSelfLoops(graph.allowsSelfLoops());\n"]}, "added_lines": {"1": [20], "2": [32, 45, 46], "3": [82, 83, 85, 86, 87, 88], "4": [134, 135, 136, 137, 138, 139, 140, 141, 142, 143, 144, 145, 146, 147, 148, 149, 150, 151, 152, 153, 160, 161, 162, 163, 164]}, "removed_lines": {"1": [24, 25], "2": [39, 40, 47, 48], "3": [84, 86]}}]}
