{
    "addition": {
        "33": "import java.util.List;\n",
        "667": "    private final List<Range<C>> ranges;\n",
        "670": "      this.ranges = Lists.newArrayList();\n",
        "676": "     * Add the specified range to this builder. Adjacent ranges are permitted and will be merged,\n",
        "677": "     * but overlapping ranges will cause an exception when {@link #build()} is called.\n",
        "679": "     * @throws IllegalArgumentException if {@code range} is empty\n",
        "683": "      checkArgument(!range.isEmpty(), \"range must not be empty, but was %s\", range);\n",
        "684": "      ranges.add(range);\n",
        "689": "     * Add all ranges from the specified range set to this builder. Adjacent ranges are permitted\n",
        "690": "     * and will be merged, but overlapping ranges will cause an exception when {@link #build()} is\n",
        "691": "     * called.\n",
        "699": "     * Add all of the specified ranges to this builder. Adjacent ranges are permitted and will be\n",
        "700": "     * merged, but overlapping ranges will cause an exception when {@link #build()} is called.\n",
        "702": "     * @throws IllegalArgumentException if any inserted ranges are empty\n",
        "715": "     *\n",
        "716": "     * @throws IllegalArgumentException if any input ranges have nonempty overlap\n",
        "719": "      ImmutableList.Builder<Range<C>> mergedRangesBuilder =\n",
        "720": "          new ImmutableList.Builder<Range<C>>(ranges.size());\n",
        "721": "      Collections.sort(ranges, Range.RANGE_LEX_ORDERING);\n",
        "722": "      PeekingIterator<Range<C>> peekingItr = Iterators.peekingIterator(ranges.iterator());\n",
        "723": "      while (peekingItr.hasNext()) {\n",
        "724": "        Range<C> range = peekingItr.next();\n",
        "725": "        while (peekingItr.hasNext()) {\n",
        "726": "          Range<C> nextRange = peekingItr.peek();\n",
        "727": "          if (range.isConnected(nextRange)) {\n",
        "728": "            checkArgument(\n",
        "729": "                range.intersection(nextRange).isEmpty(),\n",
        "730": "                \"Overlapping ranges not permitted but found %s overlapping %s\",\n",
        "731": "                range,\n",
        "732": "                nextRange);\n",
        "733": "            range = range.span(peekingItr.next());\n",
        "734": "          } else {\n",
        "735": "            break;\n",
        "736": "          }\n",
        "737": "        }\n",
        "738": "        mergedRangesBuilder.add(range);\n",
        "739": "      }\n",
        "740": "      ImmutableList<Range<C>> mergedRanges = mergedRangesBuilder.build();\n",
        "741": "      if (mergedRanges.isEmpty()) {\n",
        "742": "        return of();\n",
        "743": "      } else if (mergedRanges.size() == 1\n",
        "744": "          && Iterables.getOnlyElement(mergedRanges).equals(Range.all())) {\n",
        "745": "        return all();\n",
        "746": "      } else {\n",
        "747": "        return new ImmutableRangeSet<C>(mergedRanges);\n",
        "748": "      }\n"
    },
    "removed": {
        "666": "    private final RangeSet<C> rangeSet;\n",
        "669": "      this.rangeSet = TreeRangeSet.create();\n",
        "675": "     * Add the specified range to this builder. Adjacent/abutting ranges are permitted, but empty\n",
        "676": "     * ranges, or ranges with nonempty overlap, are forbidden.\n",
        "678": "     * @throws IllegalArgumentException if {@code range} is empty or has nonempty intersection with\n",
        "679": "     *     any ranges already added to the builder\n",
        "683": "      if (range.isEmpty()) {\n",
        "684": "        throw new IllegalArgumentException(\"range must not be empty, but was \" + range);\n",
        "685": "      } else if (!rangeSet.complement().encloses(range)) {\n",
        "686": "        for (Range<C> currentRange : rangeSet.asRanges()) {\n",
        "687": "          checkArgument(\n",
        "688": "              !currentRange.isConnected(range) || currentRange.intersection(range).isEmpty(),\n",
        "689": "              \"Ranges may not overlap, but received %s and %s\",\n",
        "690": "              currentRange,\n",
        "691": "              range);\n",
        "692": "        }\n",
        "693": "        throw new AssertionError(\"should have thrown an IAE above\");\n",
        "694": "      }\n",
        "695": "      rangeSet.add(range);\n",
        "700": "     * Add all ranges from the specified range set to this builder. Duplicate or connected ranges\n",
        "701": "     * are permitted, and will be merged in the resulting immutable range set.\n",
        "709": "     * Add all of the specified ranges to this builder. Duplicate or connected ranges are permitted,\n",
        "710": "     * and will be merged in the resulting immutable range set.\n",
        "726": "      return copyOf(rangeSet);\n"
    }
}