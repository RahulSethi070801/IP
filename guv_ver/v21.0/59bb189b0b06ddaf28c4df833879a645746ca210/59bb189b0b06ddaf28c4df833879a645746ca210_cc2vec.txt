{"id": "59bb189b0b06ddaf28c4df833879a645746ca210", "code": [{"0": "guava-tests/test/com/google/common/collect/ImmutableRangeMapTest.java", "added": {"1": ["        builder.put(range1, 1).put(range2, 2);\n", "          ImmutableRangeMap<Integer, Integer> unused = builder.build();\n"]}, "removed": {"1": ["        builder.put(range1, 1);\n", "          builder.put(range2, 2);\n"]}, "added_lines": {"1": [88, 90]}, "removed_lines": {"1": [88, 90]}}, {"1": "guava-tests/test/com/google/common/collect/ImmutableRangeSetTest.java", "added": {"1": ["    subsets: for (Set<Range<Integer>> subset : Sets.powerSet(ranges)) {\n"], "2": ["          ImmutableRangeSet<Integer> unused = builder.add(range).build();\n", "          continue subsets;\n"]}, "removed": {"1": ["    for (Set<Range<Integer>> subset : Sets.powerSet(ranges)) {\n"], "2": ["          builder.add(range);\n"]}, "added_lines": {"1": [375], "2": [393, 398]}, "removed_lines": {"1": [375], "2": [393]}}, {"2": "guava/src/com/google/common/collect/ImmutableRangeMap.java", "added": {"1": ["import java.util.Collections;\n", "import java.util.List;\n"], "2": ["    private final List<Map.Entry<Range<K>, V>> entries;\n", "      this.entries = Lists.newArrayList();\n", "     * @throws IllegalArgumentException if {@code range} is empty\n", "      entries.add(Maps.immutableEntry(range, value));\n"], "3": ["     *\n", "     * @throws IllegalArgumentException if any two ranges inserted into this builder overlap\n", "      Collections.sort(entries, Range.RANGE_LEX_ORDERING.onKeys());\n", "          new ImmutableList.Builder<Range<K>>(entries.size());\n", "      ImmutableList.Builder<V> valuesBuilder = new ImmutableList.Builder<V>(entries.size());\n", "      for (int i = 0; i < entries.size(); i++) {\n", "        Range<K> range = entries.get(i).getKey();\n", "        if (i > 0) {\n", "          Range<K> prevRange = entries.get(i - 1).getKey();\n", "          if (range.isConnected(prevRange) && !range.intersection(prevRange).isEmpty()) {\n", "            throw new IllegalArgumentException(\n", "                \"Overlapping ranges: range \" + prevRange + \" overlaps with entry \" + range);\n", "          }\n", "        }\n", "        rangesBuilder.add(range);\n", "        valuesBuilder.add(entries.get(i).getValue());\n"]}, "removed": {"2": ["    private final RangeSet<K> keyRanges;\n", "    private final RangeMap<K, V> rangeMap;\n", "      this.keyRanges = TreeRangeSet.create();\n", "      this.rangeMap = TreeRangeMap.create();\n", "     * @throws IllegalArgumentException if {@code range} overlaps with any other ranges inserted\n", "     *         into this builder, or if {@code range} is empty\n", "      if (!keyRanges.complement().encloses(range)) {\n", "        // it's an error case; we can afford an expensive lookup\n", "        for (Entry<Range<K>, V> entry : rangeMap.asMapOfRanges().entrySet()) {\n", "          Range<K> key = entry.getKey();\n", "          if (key.isConnected(range) && !key.intersection(range).isEmpty()) {\n", "            throw new IllegalArgumentException(\n", "                \"Overlapping ranges: range \" + range + \" overlaps with entry \" + entry);\n", "          }\n", "        }\n", "      }\n", "      keyRanges.add(range);\n", "      rangeMap.put(range, value);\n", "     *\n", "     * @throws IllegalArgumentException if any of the ranges in {@code rangeMap} overlap with ranges\n", "     *         already in this builder\n"], "3": ["      Map<Range<K>, V> map = rangeMap.asMapOfRanges();\n", "          new ImmutableList.Builder<Range<K>>(map.size());\n", "      ImmutableList.Builder<V> valuesBuilder = new ImmutableList.Builder<V>(map.size());\n", "      for (Entry<Range<K>, V> entry : map.entrySet()) {\n", "        rangesBuilder.add(entry.getKey());\n", "        valuesBuilder.add(entry.getValue());\n"]}, "added_lines": {"1": [27, 28], "2": [92, 95, 101, 108], "3": [126, 127, 130, 132, 133, 134, 135, 136, 137, 138, 139, 140, 141, 142, 143, 144]}, "removed_lines": {"2": [89, 90, 93, 94, 100, 101, 108, 109, 110, 111, 112, 113, 114, 115, 116, 117, 118, 119, 125, 126, 127], "3": [142, 144, 145, 146, 147, 148]}}, {"3": "guava/src/com/google/common/collect/ImmutableRangeSet.java", "added": {"1": ["import java.util.List;\n"], "2": ["    private final List<Range<C>> ranges;\n", "      this.ranges = Lists.newArrayList();\n", "     * Add the specified range to this builder. Adjacent ranges are permitted and will be merged,\n", "     * but overlapping ranges will cause an exception when {@link #build()} is called.\n", "     * @throws IllegalArgumentException if {@code range} is empty\n", "      checkArgument(!range.isEmpty(), \"range must not be empty, but was %s\", range);\n", "      ranges.add(range);\n", "     * Add all ranges from the specified range set to this builder. Adjacent ranges are permitted\n", "     * and will be merged, but overlapping ranges will cause an exception when {@link #build()} is\n", "     * called.\n"], "3": ["     * Add all of the specified ranges to this builder. Adjacent ranges are permitted and will be\n", "     * merged, but overlapping ranges will cause an exception when {@link #build()} is called.\n", "     * @throws IllegalArgumentException if any inserted ranges are empty\n"], "4": ["     *\n", "     * @throws IllegalArgumentException if any input ranges have nonempty overlap\n", "      ImmutableList.Builder<Range<C>> mergedRangesBuilder =\n", "          new ImmutableList.Builder<Range<C>>(ranges.size());\n", "      Collections.sort(ranges, Range.RANGE_LEX_ORDERING);\n", "      PeekingIterator<Range<C>> peekingItr = Iterators.peekingIterator(ranges.iterator());\n", "      while (peekingItr.hasNext()) {\n", "        Range<C> range = peekingItr.next();\n", "        while (peekingItr.hasNext()) {\n", "          Range<C> nextRange = peekingItr.peek();\n", "          if (range.isConnected(nextRange)) {\n", "            checkArgument(\n", "                range.intersection(nextRange).isEmpty(),\n", "                \"Overlapping ranges not permitted but found %s overlapping %s\",\n", "                range,\n", "                nextRange);\n", "            range = range.span(peekingItr.next());\n", "          } else {\n", "            break;\n", "          }\n", "        }\n", "        mergedRangesBuilder.add(range);\n", "      }\n", "      ImmutableList<Range<C>> mergedRanges = mergedRangesBuilder.build();\n", "      if (mergedRanges.isEmpty()) {\n", "        return of();\n", "      } else if (mergedRanges.size() == 1\n", "          && Iterables.getOnlyElement(mergedRanges).equals(Range.all())) {\n", "        return all();\n", "      } else {\n", "        return new ImmutableRangeSet<C>(mergedRanges);\n", "      }\n"]}, "removed": {"2": ["    private final RangeSet<C> rangeSet;\n", "      this.rangeSet = TreeRangeSet.create();\n", "     * Add the specified range to this builder. Adjacent/abutting ranges are permitted, but empty\n", "     * ranges, or ranges with nonempty overlap, are forbidden.\n", "     * @throws IllegalArgumentException if {@code range} is empty or has nonempty intersection with\n", "     *     any ranges already added to the builder\n", "      if (range.isEmpty()) {\n", "        throw new IllegalArgumentException(\"range must not be empty, but was \" + range);\n", "      } else if (!rangeSet.complement().encloses(range)) {\n", "        for (Range<C> currentRange : rangeSet.asRanges()) {\n", "          checkArgument(\n", "              !currentRange.isConnected(range) || currentRange.intersection(range).isEmpty(),\n", "              \"Ranges may not overlap, but received %s and %s\",\n", "              currentRange,\n", "              range);\n", "        }\n", "        throw new AssertionError(\"should have thrown an IAE above\");\n", "      }\n", "      rangeSet.add(range);\n", "     * Add all ranges from the specified range set to this builder. Duplicate or connected ranges\n", "     * are permitted, and will be merged in the resulting immutable range set.\n"], "3": ["     * Add all of the specified ranges to this builder. Duplicate or connected ranges are permitted,\n", "     * and will be merged in the resulting immutable range set.\n"], "4": ["      return copyOf(rangeSet);\n"]}, "added_lines": {"1": [33], "2": [667, 670, 676, 677, 679, 683, 684, 689, 690, 691], "3": [699, 700, 702], "4": [715, 716, 719, 720, 721, 722, 723, 724, 725, 726, 727, 728, 729, 730, 731, 732, 733, 734, 735, 736, 737, 738, 739, 740, 741, 742, 743, 744, 745, 746, 747, 748]}, "removed_lines": {"2": [666, 669, 675, 676, 678, 679, 683, 684, 685, 686, 687, 688, 689, 690, 691, 692, 693, 694, 695, 700, 701], "3": [709, 710], "4": [726]}}]}
