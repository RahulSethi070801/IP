{
    "addition": {
        "93": " * <li>{@code removeEdge}: O(1), unless this graph is a multigraph (supports parallel edges);\n",
        "94": " *     in that case this method is O(min(outD_edgeSource, inD_edgeTarget)).\n",
        "110": "  private final Map<E, IncidentNodes<N>> edgeToIncidentNodes;\n",
        "144": "    return checkedIncidentNodes(edge);\n",
        "219": "    return checkedIncidentNodes(edge).node1();\n",
        "224": "    return checkedIncidentNodes(edge).node2();\n",
        "259": "    IncidentNodes<N> incidentNodes = IncidentNodes.of(node1, node2);\n",
        "260": "    checkArgument(config.isSelfLoopsAllowed() || !incidentNodes.isSelfLoop(),\n",
        "262": "    boolean containsN1 = nodes().contains(node1);\n",
        "263": "    boolean containsN2 = nodes().contains(node2);\n",
        "264": "    if (edges().contains(edge)) {\n",
        "265": "      checkArgument(containsN1 && containsN2 && edgesConnecting(node1, node2).contains(edge),\n",
        "266": "          REUSING_EDGE, edge, incidentNodes(edge), incidentNodes);\n",
        "269": "      checkArgument(!(containsN1 && containsN2 && successors(node1).contains(node2)),\n",
        "272": "    if (!containsN1) {\n",
        "273": "      addNode(node1);\n",
        "274": "    }\n",
        "277": "    if (!containsN2) {\n",
        "278": "      addNode(node2);\n",
        "279": "    }\n",
        "282": "    edgeToIncidentNodes.put(edge, incidentNodes);\n",
        "298": "      N predecessor = Graphs.oppositeNode(this, inEdge, node);\n",
        "305": "      N successor = Graphs.oppositeNode(this, outEdge, node);\n",
        "320": "    IncidentNodes<N> incidentNodes = edgeToIncidentNodes.get(edge);\n",
        "321": "    if (incidentNodes == null) {\n",
        "324": "    N node1 = incidentNodes.node1();\n",
        "325": "    N node2 = incidentNodes.node2();\n",
        "326": "    NodeConnections<N, E> connectionsN1 = nodeConnections.get(node1);\n",
        "327": "    NodeConnections<N, E> connectionsN2 = nodeConnections.get(node2);\n",
        "328": "    if (!config.isMultigraph() || edgesConnecting(node1, node2).size() <= 1) {\n",
        "329": "      // If this is the last connecting edge between node1 and node2, they are no longer adjacent.\n",
        "330": "      connectionsN1.removeSuccessor(node2);\n",
        "331": "      connectionsN2.removePredecessor(node1);\n",
        "333": "    connectionsN1.removeOutEdge(edge);\n",
        "334": "    connectionsN2.removeInEdge(edge);\n",
        "362": "  private IncidentNodes<N> checkedIncidentNodes(Object edge) {\n",
        "364": "    IncidentNodes<N> incidentNodes = edgeToIncidentNodes.get(edge);\n",
        "365": "    checkArgument(incidentNodes != null, EDGE_NOT_IN_GRAPH, edge);\n",
        "366": "    return incidentNodes;\n"
    },
    "removed": {
        "93": " * <li>{@code removeEdge}: O(1), unless this graph is a multigraph (supports parallel edges),\n",
        "94": " *     then this method is O(min(outD_edgeSource, inD_edgeTarget)).\n",
        "110": "  private final Map<E, DirectedIncidentNodes<N>> edgeToIncidentNodes;\n",
        "144": "    // Returning an immutable set here as the edge's endpoints will not change anyway.\n",
        "145": "    return checkedEndpoints(edge).asImmutableSet();\n",
        "220": "    return checkedEndpoints(edge).source();\n",
        "225": "    return checkedEndpoints(edge).target();\n",
        "260": "    DirectedIncidentNodes<N> endpoints = DirectedIncidentNodes.of(node1, node2);\n",
        "261": "    checkArgument(config.isSelfLoopsAllowed() || !endpoints.isSelfLoop(),\n",
        "263": "    DirectedIncidentNodes<N> previousEndpoints = edgeToIncidentNodes.get(edge);\n",
        "264": "    if (previousEndpoints != null) {\n",
        "265": "      checkArgument(previousEndpoints.equals(endpoints),\n",
        "266": "          REUSING_EDGE, edge, previousEndpoints, endpoints);\n",
        "269": "      checkArgument(!(nodes().contains(node1) && successors(node1).contains(node2)),\n",
        "272": "    addNode(node1);\n",
        "275": "    addNode(node2);\n",
        "278": "    edgeToIncidentNodes.put(edge, endpoints);\n",
        "294": "      DirectedIncidentNodes<N> endpoints = edgeToIncidentNodes.get(inEdge);\n",
        "295": "      N predecessor = endpoints.source();\n",
        "302": "      DirectedIncidentNodes<N> endpoints = edgeToIncidentNodes.get(outEdge);\n",
        "303": "      N successor = endpoints.target();\n",
        "318": "    DirectedIncidentNodes<N> endpoints = edgeToIncidentNodes.get(edge);\n",
        "319": "    if (endpoints == null) {\n",
        "322": "    N source = endpoints.source();\n",
        "323": "    N target = endpoints.target();\n",
        "324": "    NodeConnections<N, E> sourceConnections = nodeConnections.get(source);\n",
        "325": "    NodeConnections<N, E> targetConnections = nodeConnections.get(target);\n",
        "326": "    if (!config.isMultigraph() || edgesConnecting(source, target).size() <= 1) {\n",
        "327": "      // If this is the last connecting edge between source and target, they are no longer adjacent.\n",
        "328": "      sourceConnections.removeSuccessor(target);\n",
        "329": "      targetConnections.removePredecessor(source);\n",
        "331": "    sourceConnections.removeOutEdge(edge);\n",
        "332": "    targetConnections.removeInEdge(edge);\n",
        "360": "  private DirectedIncidentNodes<N> checkedEndpoints(Object edge) {\n",
        "362": "    DirectedIncidentNodes<N> endpoints = edgeToIncidentNodes.get(edge);\n",
        "363": "    checkArgument(endpoints != null, EDGE_NOT_IN_GRAPH, edge);\n",
        "364": "    return endpoints;\n"
    }
}