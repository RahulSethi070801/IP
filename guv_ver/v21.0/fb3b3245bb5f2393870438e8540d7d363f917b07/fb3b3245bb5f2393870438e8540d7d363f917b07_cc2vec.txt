{"id": "fb3b3245bb5f2393870438e8540d7d363f917b07", "code": [{"0": "guava-tests/test/com/google/common/graph/DirectedIncidentNodesTest.java", "added": {}, "removed": {"1": ["/*\n", " * Copyright (C) 2015 The Guava Authors\n", " *\n", " * Licensed under the Apache License, Version 2.0 (the \"License\");\n", " * you may not use this file except in compliance with the License.\n", " * You may obtain a copy of the License at\n", " *\n", " * http://www.apache.org/licenses/LICENSE-2.0\n", " *\n", " * Unless required by applicable law or agreed to in writing, software\n", " * distributed under the License is distributed on an \"AS IS\" BASIS,\n", " * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n", " * See the License for the specific language governing permissions and\n", " * limitations under the License.\n", " */\n", "\n", "package com.google.common.graph;\n", "\n", "import com.google.common.testing.EqualsTester;\n", "\n", "import org.junit.Test;\n", "import org.junit.runner.RunWith;\n", "import org.junit.runners.JUnit4;\n", "\n", "@RunWith(JUnit4.class)\n", "public final class DirectedIncidentNodesTest {\n", "\n", "  @Test\n", "  public void testEquals() {\n", "    new EqualsTester()\n", "        .addEqualityGroup(DirectedIncidentNodes.of(\"foo\", \"bar\"))\n", "        .addEqualityGroup(DirectedIncidentNodes.of(\"bar\", \"foo\"))\n", "        .addEqualityGroup(DirectedIncidentNodes.of(\"test\", \"test\"))\n", "        .testEquals();\n", "  }\n", "}\n"]}, "added_lines": {}, "removed_lines": {"1": [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36]}}, {"1": "guava-tests/test/com/google/common/graph/IncidentNodesTest.java", "added": {"1": ["/*\n", " * Copyright (C) 2015 The Guava Authors\n", " *\n", " * Licensed under the Apache License, Version 2.0 (the \"License\");\n", " * you may not use this file except in compliance with the License.\n", " * You may obtain a copy of the License at\n", " *\n", " * http://www.apache.org/licenses/LICENSE-2.0\n", " *\n", " * Unless required by applicable law or agreed to in writing, software\n", " * distributed under the License is distributed on an \"AS IS\" BASIS,\n", " * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n", " * See the License for the specific language governing permissions and\n", " * limitations under the License.\n", " */\n", "\n", "package com.google.common.graph;\n", "\n", "import static com.google.common.truth.Truth.assertThat;\n", "\n", "import com.google.common.collect.ImmutableSet;\n", "import com.google.common.testing.EqualsTester;\n", "\n", "import org.junit.Test;\n", "import org.junit.runner.RunWith;\n", "import org.junit.runners.JUnit4;\n", "\n", "/**\n", " * Tests for {@link IncidentNodes}.\n", " */\n", "@RunWith(JUnit4.class)\n", "public final class IncidentNodesTest {\n", "\n", "  @Test\n", "  public void testEquals() {\n", "    new EqualsTester()\n", "        .addEqualityGroup(\n", "            IncidentNodes.of(\"foo\", \"bar\"),\n", "            IncidentNodes.of(\"bar\", \"foo\"),\n", "            IncidentNodes.of(ImmutableSet.of(\"foo\", \"bar\")),\n", "            IncidentNodes.of(ImmutableSet.of(\"bar\", \"foo\")))\n", "        .addEqualityGroup(\n", "            IncidentNodes.of(\"test\", \"test\"),\n", "            IncidentNodes.of(ImmutableSet.of(\"test\")))\n", "        .testEquals();\n", "  }\n", "\n", "  @Test\n", "  public void testNodes_basic() {\n", "    IncidentNodes<String> incidentNodes = IncidentNodes.of(\"foo\", \"bar\");\n", "    assertThat(incidentNodes.node1()).isEqualTo(\"foo\");\n", "    assertThat(incidentNodes.node2()).isEqualTo(\"bar\");\n", "  }\n", "\n", "  @Test\n", "  public void testNodes_orderedSet() {\n", "    IncidentNodes<String> incidentNodes = IncidentNodes.of(ImmutableSet.of(\"foo\", \"bar\"));\n", "    // An ImmutableSet preserves order, so we should see that order in node1 and node2.\n", "    assertThat(incidentNodes.node1()).isEqualTo(\"foo\");\n", "    assertThat(incidentNodes.node2()).isEqualTo(\"bar\");\n", "  }\n", "\n", "  @Test\n", "  public void testNodes_selfLoop() {\n", "    IncidentNodes<String> incidentNodes = IncidentNodes.of(ImmutableSet.of(\"test\"));\n", "    assertThat(incidentNodes.node1()).isEqualTo(\"test\");\n", "    assertThat(incidentNodes.node2()).isEqualTo(\"test\");\n", "  }\n", "}\n"]}, "removed": {}, "added_lines": {"1": [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 58, 59, 60, 61, 62, 63, 64, 65, 66, 67, 68, 69]}, "removed_lines": {}}, {"2": "guava-tests/test/com/google/common/graph/UndirectedIncidentNodesTest.java", "added": {}, "removed": {"1": ["/*\n", " * Copyright (C) 2015 The Guava Authors\n", " *\n", " * Licensed under the Apache License, Version 2.0 (the \"License\");\n", " * you may not use this file except in compliance with the License.\n", " * You may obtain a copy of the License at\n", " *\n", " * http://www.apache.org/licenses/LICENSE-2.0\n", " *\n", " * Unless required by applicable law or agreed to in writing, software\n", " * distributed under the License is distributed on an \"AS IS\" BASIS,\n", " * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n", " * See the License for the specific language governing permissions and\n", " * limitations under the License.\n", " */\n", "\n", "package com.google.common.graph;\n", "\n", "import com.google.common.collect.ImmutableSet;\n", "import com.google.common.testing.EqualsTester;\n", "\n", "import org.junit.Test;\n", "import org.junit.runner.RunWith;\n", "import org.junit.runners.JUnit4;\n", "\n", "@RunWith(JUnit4.class)\n", "public final class UndirectedIncidentNodesTest {\n", "\n", "  @Test\n", "  public void testEquals() {\n", "    new EqualsTester()\n", "        .addEqualityGroup(\n", "            UndirectedIncidentNodes.of(\"foo\", \"bar\"),\n", "            UndirectedIncidentNodes.of(\"bar\", \"foo\"),\n", "            UndirectedIncidentNodes.of(ImmutableSet.of(\"foo\", \"bar\")))\n", "        .addEqualityGroup(\n", "            UndirectedIncidentNodes.of(\"test\", \"test\"),\n", "            UndirectedIncidentNodes.of(ImmutableSet.of(\"test\")))\n", "        .testEquals();\n", "  }\n", "}\n"]}, "added_lines": {}, "removed_lines": {"1": [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41]}}, {"3": "guava/src/com/google/common/graph/DirectedIncidentNodes.java", "added": {}, "removed": {"1": ["/*\n", " * Copyright (C) 2014 The Guava Authors\n", " *\n", " * Licensed under the Apache License, Version 2.0 (the \"License\");\n", " * you may not use this file except in compliance with the License.\n", " * You may obtain a copy of the License at\n", " *\n", " * http://www.apache.org/licenses/LICENSE-2.0\n", " *\n", " * Unless required by applicable law or agreed to in writing, software\n", " * distributed under the License is distributed on an \"AS IS\" BASIS,\n", " * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n", " * See the License for the specific language governing permissions and\n", " * limitations under the License.\n", " */\n", "\n", "package com.google.common.graph;\n", "\n", "import static com.google.common.base.Preconditions.checkNotNull;\n", "\n", "import com.google.common.base.Objects;\n", "import com.google.common.collect.ImmutableSet;\n", "\n", "import javax.annotation.Nullable;\n", "\n", "/**\n", " * An immutable pair representing the incident nodes (source and target) on a directed edge.\n", " *\n", " * @author Joshua O'Madadhain\n", " * @param <N> Node parameter type\n", " */\n", "final class DirectedIncidentNodes<N> {\n", "\n", "  private final N source;\n", "  private final N target;\n", "\n", "  private DirectedIncidentNodes(N source, N target) {\n", "    this.source = checkNotNull(source, \"source\");\n", "    this.target = checkNotNull(target, \"target\");\n", "  }\n", "\n", "  static <N> DirectedIncidentNodes<N> of(N source, N target) {\n", "    return new DirectedIncidentNodes<N>(source, target);\n", "  }\n", "\n", "  N source() {\n", "    return source;\n", "  }\n", "\n", "  N target() {\n", "    return target;\n", "  }\n", "\n", "  boolean isSelfLoop() {\n", "    return source.equals(target);\n", "  }\n", "\n", "  ImmutableSet<N> asImmutableSet() {\n", "    return ImmutableSet.of(source, target);\n", "  }\n", "\n", "  @Override\n", "  public int hashCode() {\n", "    return Objects.hashCode(source, target);\n", "  }\n", "\n", "  @Override\n", "  public boolean equals(@Nullable Object object) {\n", "    if (object instanceof DirectedIncidentNodes<?>) {\n", "      DirectedIncidentNodes<?> that = (DirectedIncidentNodes<?>) object;\n", "      return this.source.equals(that.source)\n", "          && this.target.equals(that.target);\n", "    }\n", "    return false;\n", "  }\n", "\n", "  @Override\n", "  public String toString() {\n", "    return String.format(\"<%s -> %s>\", source, target);\n", "  }\n", "}\n"]}, "added_lines": {}, "removed_lines": {"1": [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 58, 59, 60, 61, 62, 63, 64, 65, 66, 67, 68, 69, 70, 71, 72, 73, 74, 75, 76, 77, 78, 79, 80, 81]}}, {"4": "guava/src/com/google/common/graph/ImmutableDirectedGraph.java", "added": {"1": ["  private final ImmutableMap<E, IncidentNodes<N>> edgeToIncidentNodes;\n"], "2": ["    ImmutableMap.Builder<E, IncidentNodes<N>> edgeToIncidentNodesBuilder = ImmutableMap.builder();\n", "      IncidentNodes<N> incidentNodes = IncidentNodes.of(\n"], "3": ["    return checkedIncidentNodes(edge);\n"], "4": ["    return checkedIncidentNodes(edge).node1();\n", "    return checkedIncidentNodes(edge).node2();\n"], "5": ["  private IncidentNodes<N> checkedIncidentNodes(Object edge) {\n", "    IncidentNodes<N> incidentNodes = edgeToIncidentNodes.get(edge);\n", "    checkArgument(incidentNodes != null, EDGE_NOT_IN_GRAPH, edge);\n", "    return incidentNodes;\n"], "6": ["     * @see Graph#addEdge\n"]}, "removed": {"1": ["  private final ImmutableMap<E, DirectedIncidentNodes<N>> edgeToIncidentNodes;\n"], "2": ["    ImmutableMap.Builder<E, DirectedIncidentNodes<N>> edgeToIncidentNodesBuilder =\n", "        ImmutableMap.builder();\n", "      DirectedIncidentNodes<N> incidentNodes = DirectedIncidentNodes.of(\n"], "3": ["    return checkedEndpoints(edge).asImmutableSet();\n"], "4": ["    return checkedEndpoints(edge).source();\n", "    return checkedEndpoints(edge).target();\n"], "5": ["  private DirectedIncidentNodes<N> checkedEndpoints(Object edge) {\n", "    DirectedIncidentNodes<N> endpoints = edgeToIncidentNodes.get(edge);\n", "    checkArgument(endpoints != null, EDGE_NOT_IN_GRAPH, edge);\n", "    return endpoints;\n"], "6": ["     * @see Graph#addEdge(e, n1, n2)\n"]}, "added_lines": {"1": [80], "2": [94, 96], "3": [126], "4": [203, 208], "5": [234, 236, 237, 238], "6": [326]}, "removed_lines": {"1": [80], "2": [94, 95, 97], "3": [127], "4": [204, 209], "5": [235, 237, 238, 239], "6": [327]}}, {"5": "guava/src/com/google/common/graph/ImmutableUndirectedGraph.java", "added": {"1": ["  private final ImmutableMap<E, IncidentNodes<N>> edgeToIncidentNodes;\n", "    ImmutableMap.Builder<N, NodeConnections<N, E>> nodeConnectionsBuilder = ImmutableMap.builder();\n", "    ImmutableMap.Builder<E, IncidentNodes<N>> edgeToNodesBuilder = ImmutableMap.builder();\n", "      edgeToNodesBuilder.put(edge, IncidentNodes.of(undirectedGraph.incidentNodes(edge)));\n"], "2": ["    return checkedIncidentNodes(edge);\n"], "3": ["  private IncidentNodes<N> checkedIncidentNodes(Object edge) {\n", "    checkNotNull(edge, \"edge\");\n", "    IncidentNodes<N> incidentNodes = edgeToIncidentNodes.get(edge);\n", "    checkArgument(incidentNodes != null, EDGE_NOT_IN_GRAPH, edge);\n", "    return incidentNodes;\n", "  }\n", "\n"]}, "removed": {"1": ["  private final ImmutableMap<E, UndirectedIncidentNodes<N>> edgeToIncidentNodes;\n", "    ImmutableMap.Builder<N, NodeConnections<N, E>> nodeConnectionsBuilder =\n", "        ImmutableMap.builder();\n", "    ImmutableMap.Builder<E, UndirectedIncidentNodes<N>> edgeToNodesBuilder = ImmutableMap.builder();\n", "      edgeToNodesBuilder.put(edge, UndirectedIncidentNodes.of(undirectedGraph.incidentNodes(edge)));\n"], "2": ["    checkNotNull(edge, \"edge\");\n", "    UndirectedIncidentNodes<N> incidentNodes = edgeToIncidentNodes.get(edge);\n", "    checkArgument(incidentNodes != null, EDGE_NOT_IN_GRAPH, edge);\n", "    return incidentNodes;\n"]}, "added_lines": {"1": [76, 81, 87, 89], "2": [117], "3": [220, 221, 222, 223, 224, 225, 226]}, "removed_lines": {"1": [76, 81, 82, 88, 90], "2": [118, 119, 120, 121]}}, {"6": "guava/src/com/google/common/graph/IncidenceSetDirectedGraph.java", "added": {"1": [" * <li>{@code removeEdge}: O(1), unless this graph is a multigraph (supports parallel edges);\n", " *     in that case this method is O(min(outD_edgeSource, inD_edgeTarget)).\n"], "2": ["  private final Map<E, IncidentNodes<N>> edgeToIncidentNodes;\n"], "3": ["    return checkedIncidentNodes(edge);\n"], "4": ["    return checkedIncidentNodes(edge).node1();\n", "    return checkedIncidentNodes(edge).node2();\n"], "5": ["    IncidentNodes<N> incidentNodes = IncidentNodes.of(node1, node2);\n", "    checkArgument(config.isSelfLoopsAllowed() || !incidentNodes.isSelfLoop(),\n", "    boolean containsN1 = nodes().contains(node1);\n", "    boolean containsN2 = nodes().contains(node2);\n", "    if (edges().contains(edge)) {\n", "      checkArgument(containsN1 && containsN2 && edgesConnecting(node1, node2).contains(edge),\n", "          REUSING_EDGE, edge, incidentNodes(edge), incidentNodes);\n", "      checkArgument(!(containsN1 && containsN2 && successors(node1).contains(node2)),\n", "    if (!containsN1) {\n", "      addNode(node1);\n", "    }\n", "    if (!containsN2) {\n", "      addNode(node2);\n", "    }\n", "    edgeToIncidentNodes.put(edge, incidentNodes);\n"], "6": ["      N predecessor = Graphs.oppositeNode(this, inEdge, node);\n", "      N successor = Graphs.oppositeNode(this, outEdge, node);\n"], "7": ["    IncidentNodes<N> incidentNodes = edgeToIncidentNodes.get(edge);\n", "    if (incidentNodes == null) {\n", "    N node1 = incidentNodes.node1();\n", "    N node2 = incidentNodes.node2();\n", "    NodeConnections<N, E> connectionsN1 = nodeConnections.get(node1);\n", "    NodeConnections<N, E> connectionsN2 = nodeConnections.get(node2);\n", "    if (!config.isMultigraph() || edgesConnecting(node1, node2).size() <= 1) {\n", "      // If this is the last connecting edge between node1 and node2, they are no longer adjacent.\n", "      connectionsN1.removeSuccessor(node2);\n", "      connectionsN2.removePredecessor(node1);\n", "    connectionsN1.removeOutEdge(edge);\n", "    connectionsN2.removeInEdge(edge);\n"], "8": ["  private IncidentNodes<N> checkedIncidentNodes(Object edge) {\n", "    IncidentNodes<N> incidentNodes = edgeToIncidentNodes.get(edge);\n", "    checkArgument(incidentNodes != null, EDGE_NOT_IN_GRAPH, edge);\n", "    return incidentNodes;\n"]}, "removed": {"1": [" * <li>{@code removeEdge}: O(1), unless this graph is a multigraph (supports parallel edges),\n", " *     then this method is O(min(outD_edgeSource, inD_edgeTarget)).\n"], "2": ["  private final Map<E, DirectedIncidentNodes<N>> edgeToIncidentNodes;\n"], "3": ["    // Returning an immutable set here as the edge's endpoints will not change anyway.\n", "    return checkedEndpoints(edge).asImmutableSet();\n"], "4": ["    return checkedEndpoints(edge).source();\n", "    return checkedEndpoints(edge).target();\n"], "5": ["    DirectedIncidentNodes<N> endpoints = DirectedIncidentNodes.of(node1, node2);\n", "    checkArgument(config.isSelfLoopsAllowed() || !endpoints.isSelfLoop(),\n", "    DirectedIncidentNodes<N> previousEndpoints = edgeToIncidentNodes.get(edge);\n", "    if (previousEndpoints != null) {\n", "      checkArgument(previousEndpoints.equals(endpoints),\n", "          REUSING_EDGE, edge, previousEndpoints, endpoints);\n", "      checkArgument(!(nodes().contains(node1) && successors(node1).contains(node2)),\n", "    addNode(node1);\n", "    addNode(node2);\n", "    edgeToIncidentNodes.put(edge, endpoints);\n"], "6": ["      DirectedIncidentNodes<N> endpoints = edgeToIncidentNodes.get(inEdge);\n", "      N predecessor = endpoints.source();\n", "      DirectedIncidentNodes<N> endpoints = edgeToIncidentNodes.get(outEdge);\n", "      N successor = endpoints.target();\n"], "7": ["    DirectedIncidentNodes<N> endpoints = edgeToIncidentNodes.get(edge);\n", "    if (endpoints == null) {\n", "    N source = endpoints.source();\n", "    N target = endpoints.target();\n", "    NodeConnections<N, E> sourceConnections = nodeConnections.get(source);\n", "    NodeConnections<N, E> targetConnections = nodeConnections.get(target);\n", "    if (!config.isMultigraph() || edgesConnecting(source, target).size() <= 1) {\n", "      // If this is the last connecting edge between source and target, they are no longer adjacent.\n", "      sourceConnections.removeSuccessor(target);\n", "      targetConnections.removePredecessor(source);\n", "    sourceConnections.removeOutEdge(edge);\n", "    targetConnections.removeInEdge(edge);\n"], "8": ["  private DirectedIncidentNodes<N> checkedEndpoints(Object edge) {\n", "    DirectedIncidentNodes<N> endpoints = edgeToIncidentNodes.get(edge);\n", "    checkArgument(endpoints != null, EDGE_NOT_IN_GRAPH, edge);\n", "    return endpoints;\n"]}, "added_lines": {"1": [93, 94], "2": [110], "3": [144], "4": [219, 224], "5": [259, 260, 262, 263, 264, 265, 266, 269, 272, 273, 274, 277, 278, 279, 282], "6": [298, 305], "7": [320, 321, 324, 325, 326, 327, 328, 329, 330, 331, 333, 334], "8": [362, 364, 365, 366]}, "removed_lines": {"1": [93, 94], "2": [110], "3": [144, 145], "4": [220, 225], "5": [260, 261, 263, 264, 265, 266, 269, 272, 275, 278], "6": [294, 295, 302, 303], "7": [318, 319, 322, 323, 324, 325, 326, 327, 328, 329, 331, 332], "8": [360, 362, 363, 364]}}, {"7": "guava/src/com/google/common/graph/IncidenceSetUndirectedGraph.java", "added": {"2": [" * <li>{@code removeEdge}: O(1), unless this graph is a multigraph (supports parallel edges);\n", " *     in that case this method is O(min(d_edgeNode1, d_edgeNode2)).\n"], "3": ["  private final Map<E, IncidentNodes<N>> edgeToIncidentNodes;\n"], "4": ["    return checkedIncidentNodes(edge);\n"], "5": ["    IncidentNodes<N> incidentNodes = IncidentNodes.of(node1, node2);\n", "    IncidentNodes<N> previousIncidentNodes = edgeToIncidentNodes.get(edge);\n"], "6": ["    IncidentNodes<N> incidentNodes = edgeToIncidentNodes.get(edge);\n", "    N node1 = incidentNodes.node1();\n", "    N node2 = incidentNodes.node2();\n"], "7": ["\n", "  private IncidentNodes<N> checkedIncidentNodes(Object edge) {\n", "    checkNotNull(edge, \"edge\");\n", "    IncidentNodes<N> incidentNodes = edgeToIncidentNodes.get(edge);\n", "    checkArgument(incidentNodes != null, EDGE_NOT_IN_GRAPH, edge);\n", "    return incidentNodes;\n", "  }\n"]}, "removed": {"1": ["import com.google.common.collect.Iterables;\n"], "2": [" * <li>{@code removeEdge}: O(1), unless this graph is a multigraph (supports parallel edges),\n", " *     then this method is O(min(d_edgeNode1, d_edgeNode2)).\n"], "3": ["  private final Map<E, UndirectedIncidentNodes<N>> edgeToIncidentNodes;\n"], "4": ["    checkNotNull(edge, \"edge\");\n", "    UndirectedIncidentNodes<N> incidentNodes = edgeToIncidentNodes.get(edge);\n", "    checkArgument(incidentNodes != null, EDGE_NOT_IN_GRAPH, edge);\n", "    return incidentNodes;\n"], "5": ["    UndirectedIncidentNodes<N> incidentNodes = UndirectedIncidentNodes.of(node1, node2);\n", "    UndirectedIncidentNodes<N> previousIncidentNodes = edgeToIncidentNodes.get(edge);\n"], "6": ["    UndirectedIncidentNodes<N> incidentNodes = edgeToIncidentNodes.get(edge);\n", "    N node1 = Iterables.get(incidentNodes, 0);\n", "    N node2 = Iterables.get(incidentNodes, 1, node1);\n"]}, "added_lines": {"2": [89, 90], "3": [107], "4": [141], "5": [251, 254], "6": [298, 302, 303], "7": [340, 341, 342, 343, 344, 345, 346]}, "removed_lines": {"1": [30], "2": [90, 91], "3": [108], "4": [142, 143, 144, 145], "5": [255, 258], "6": [302, 306, 307]}}, {"8": "guava/src/com/google/common/graph/IncidentNodes.java", "added": {"1": [" * An immutable set representing the nodes incident to an origin edge in a graph.\n", "abstract class IncidentNodes<N> extends AbstractSet<N> {\n", "  static <N> IncidentNodes<N> of(N node1, N node2) {\n"], "2": ["  static <N> IncidentNodes<N> of(Set<N> nodes) {\n"], "3": ["        throw new IllegalArgumentException(\"Hypergraphs are not currently supported. An edge in a\"\n", "            + \" non-hypergraph cannot be incident to \" + nodes.size() + \" nodes: \" + nodes);\n"], "4": ["  /**\n", "   * In the case of a directed graph, returns the source node of the origin edge. In the case of\n", "   * an undirected graph, returns an arbitrary (but consistent) endpoint of the origin edge.\n", "   */\n", "  abstract N node1();\n", "  /**\n", "   * Returns the node opposite to {@link #node1} along the origin edge. In the case of a directed\n", "   * graph, this will always be the target node of the origin edge.\n", "   */\n", "  abstract N node2();\n", "\n", "  private static final class OneNode<N> extends IncidentNodes<N> {\n"], "5": ["    @Override\n", "    N node1() {\n", "      return node;\n", "    }\n", "\n", "    @Override\n", "    N node2() {\n", "      return node;\n", "    }\n", "  }\n", "  private static final class TwoNodes<N> extends IncidentNodes<N> {\n"], "6": ["\n", "    @Override\n", "    N node1() {\n", "      return node1;\n", "    }\n", "\n", "    @Override\n", "    N node2() {\n", "      return node2;\n", "    }\n"]}, "removed": {"1": [" * An immutable set representing the nodes incident to an undirected edge.\n", "abstract class UndirectedIncidentNodes<N> extends AbstractSet<N> {\n", "  static <N> UndirectedIncidentNodes<N> of(N node1, N node2) {\n"], "2": ["  static <N> UndirectedIncidentNodes<N> of(Set<N> nodes) {\n"], "3": ["        throw new IllegalArgumentException(\"An edge in an undirected graph cannot be incident to \"\n", "            + nodes.size() + \" nodes: \" + nodes);\n"], "4": ["  private static final class OneNode<N> extends UndirectedIncidentNodes<N> {\n"], "5": ["  }\n", "  private static final class TwoNodes<N> extends UndirectedIncidentNodes<N> {\n"]}, "added_lines": {"1": [29, 34, 36], "2": [44], "3": [52, 53], "4": [61, 62, 63, 64, 65, 67, 68, 69, 70, 71, 72, 73], "5": [90, 91, 92, 93, 94, 95, 96, 97, 98, 99, 101], "6": [120, 121, 122, 123, 124, 125, 126, 127, 128, 129]}, "removed_lines": {"1": [29, 34, 36], "2": [44], "3": [52, 53], "4": [61], "5": [78, 80]}}]}
