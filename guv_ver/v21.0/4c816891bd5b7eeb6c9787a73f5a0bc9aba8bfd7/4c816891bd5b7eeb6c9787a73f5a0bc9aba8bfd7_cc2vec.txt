{"id": "4c816891bd5b7eeb6c9787a73f5a0bc9aba8bfd7", "code": [{"0": "guava/src/com/google/common/graph/AbstractDirectedNodeConnections.java", "added": {"1": ["    N previousNode = inEdgeMap.remove(edge);\n", "    return checkNotNull(previousNode);\n", "    N previousNode = outEdgeMap.remove(edge);\n", "    return checkNotNull(previousNode);\n", "  public void addInEdge(E edge, N node, boolean isSelfLoop) {\n"], "2": ["    checkState(previousNode == null);\n", "  public void addOutEdge(E edge, N node) {\n", "    checkState(previousNode == null);\n"]}, "removed": {"1": ["    return inEdgeMap.remove(edge);\n", "    return outEdgeMap.remove(edge);\n", "  public boolean addInEdge(E edge, N node, boolean isSelfLoop) {\n"], "2": ["    if (previousNode != null) {\n", "      checkState(node.equals(previousNode));\n", "      return false;\n", "    }\n", "    return true;\n", "  public boolean addOutEdge(E edge, N node) {\n", "    if (previousNode != null) {\n", "      checkState(node.equals(previousNode));\n", "      return false;\n", "    }\n", "    return true;\n"]}, "added_lines": {"1": [110, 111, 117, 118, 122], "2": [130, 134, 138]}, "removed_lines": {"1": [110, 116, 120], "2": [128, 129, 130, 131, 132, 136, 140, 141, 142, 143, 144]}}, {"1": "guava/src/com/google/common/graph/AbstractUndirectedNodeConnections.java", "added": {"1": ["import static com.google.common.base.Preconditions.checkState;\n"], "2": ["    if (!isSelfLoop) {\n", "      return removeOutEdge(edge);\n", "    return null;\n", "    N previousNode = incidentEdgeMap.remove(edge);\n", "    return checkNotNull(previousNode);\n", "  public void addInEdge(E edge, N node, boolean isSelfLoop) {\n", "    if (!isSelfLoop) {\n", "      addOutEdge(edge, node);\n", "  public void addOutEdge(E edge, N node) {\n", "    checkState(previousNode == null);\n"]}, "removed": {"1": ["import static com.google.common.base.Preconditions.checkArgument;\n"], "2": ["    if (isSelfLoop) {\n", "      return null;\n", "    return removeOutEdge(edge);\n", "    return incidentEdgeMap.remove(edge);\n", "  public boolean addInEdge(E edge, N node, boolean isSelfLoop) {\n", "    if (isSelfLoop) {\n", "      return false;\n", "    return addOutEdge(edge, node);\n", "  public boolean addOutEdge(E edge, N node) {\n", "    if (previousNode != null) {\n", "      checkArgument(node.equals(previousNode));\n", "      return false;\n", "    }\n", "    return true;\n"]}, "added_lines": {"1": [20], "2": [75, 76, 78, 84, 85, 89, 90, 91, 96, 100]}, "removed_lines": {"1": [19], "2": [75, 76, 78, 84, 88, 89, 90, 92, 96, 100, 101, 102, 103, 104]}}, {"2": "guava/src/com/google/common/graph/DirectedMultiNodeConnections.java", "added": {"1": ["import static com.google.common.base.Preconditions.checkNotNull;\n"], "2": ["    N node = checkNotNull(super.removeInEdge(edge, isSelfLoop));\n", "    Multiset<N> predecessors = getReference(predecessorsReference);\n", "    if (predecessors != null) {\n", "      checkState(predecessors.remove(node));\n", "    N node = checkNotNull(super.removeOutEdge(edge));\n", "    Multiset<N> successors = getReference(successorsReference);\n", "    if (successors != null) {\n", "      checkState(successors.remove(node));\n", "  public void addInEdge(E edge, N node, boolean isSelfLoop) {\n", "    super.addInEdge(edge, node, isSelfLoop);\n", "    Multiset<N> predecessors = getReference(predecessorsReference);\n", "    if (predecessors != null) {\n", "      checkState(predecessors.add(node));\n", "  public void addOutEdge(E edge, N node) {\n", "    super.addOutEdge(edge, node);\n", "    Multiset<N> successors = getReference(successorsReference);\n", "    if (successors != null) {\n", "      checkState(successors.add(node));\n"]}, "removed": {"2": ["    N node = super.removeInEdge(edge, isSelfLoop);\n", "    if (node != null) {\n", "      Multiset<N> predecessors = getReference(predecessorsReference);\n", "      if (predecessors != null) {\n", "        checkState(predecessors.remove(node));\n", "      }\n", "    N node = super.removeOutEdge(edge);\n", "    if (node != null) {\n", "      Multiset<N> successors = getReference(successorsReference);\n", "      if (successors != null) {\n", "        checkState(successors.remove(node));\n", "      }\n", "  public boolean addInEdge(E edge, N node, boolean isSelfLoop) {\n", "    if (super.addInEdge(edge, node, isSelfLoop)) {\n", "      Multiset<N> predecessors = getReference(predecessorsReference);\n", "      if (predecessors != null) {\n", "        checkState(predecessors.add(node));\n", "      }\n", "      return true;\n", "    return false;\n", "  public boolean addOutEdge(E edge, N node) {\n", "    if (super.addOutEdge(edge, node)) {\n", "      Multiset<N> successors = getReference(successorsReference);\n", "      if (successors != null) {\n", "        checkState(successors.add(node));\n", "      }\n", "      return true;\n", "    return false;\n"]}, "added_lines": {"1": [19], "2": [101, 102, 103, 104, 111, 112, 113, 114, 120, 121, 122, 123, 124, 129, 130, 131, 132, 133]}, "removed_lines": {"2": [100, 101, 102, 103, 104, 105, 112, 113, 114, 115, 116, 117, 123, 124, 125, 126, 127, 128, 129, 131, 135, 136, 137, 138, 139, 140, 141, 143]}}, {"3": "guava/src/com/google/common/graph/NodeConnections.java", "added": {"1": ["   *\n", "   * <p>In the directed case, {@code edge} is assumed to be an outgoing edge.\n"], "2": ["   * Remove {@code edge} from the set of incoming edges. Returns the former predecessor node.\n", "   *\n", "   * <p>In the undirected case, returns {@code null} if {@code isSelfLoop} is true.\n", "   * Remove {@code edge} from the set of outgoing edges. Returns the former successor node.\n", "  void addInEdge(E edge, N node, boolean isSelfLoop);\n", "  void addOutEdge(E edge, N node);\n"]}, "removed": {"1": ["   * In the directed case, {@code edge} is assumed to be an outgoing edge.\n"], "2": ["   * Remove {@code edge} from the set of incoming edges. Returns the former predecessor node,\n", "   * or null if the edge did not exist.\n", "   * Remove {@code edge} from the set of outgoing edges. Returns the former successor node,\n", "   * or null if the edge did not exist.\n", "   * Returns false if the edge already existed.\n", "  @CanIgnoreReturnValue\n", "  boolean addInEdge(E edge, N node, boolean isSelfLoop);\n", "   * Returns false if the edge already existed.\n", "  @CanIgnoreReturnValue\n", "  boolean addOutEdge(E edge, N node);\n"]}, "added_lines": {"1": [46, 47], "2": [58, 59, 60, 66, 74, 79]}, "removed_lines": {"1": [46], "2": [57, 58, 64, 65, 72, 74, 75, 79, 81, 82]}}, {"4": "guava/src/com/google/common/graph/UndirectedMultiNodeConnections.java", "added": {"1": ["import static com.google.common.base.Preconditions.checkNotNull;\n"], "2": ["    if (!isSelfLoop) {\n", "      return removeOutEdge(edge);\n", "    return null;\n", "    N node = checkNotNull(super.removeOutEdge(edge));\n", "    Multiset<N> adjacentNodes = getReference(adjacentNodesReference);\n", "    if (adjacentNodes != null) {\n", "      checkState(adjacentNodes.remove(node));\n", "  public void addInEdge(E edge, N node, boolean isSelfLoop) {\n", "    if (!isSelfLoop) {\n", "      addOutEdge(edge, node);\n", "  public void addOutEdge(E edge, N node) {\n", "    super.addOutEdge(edge, node);\n", "    Multiset<N> adjacentNodes = getReference(adjacentNodesReference);\n", "    if (adjacentNodes != null) {\n", "      checkState(adjacentNodes.add(node));\n"]}, "removed": {"2": ["    if (isSelfLoop) {\n", "      return null;\n", "    return removeOutEdge(edge);\n", "    N node = super.removeOutEdge(edge);\n", "    if (node != null) {\n", "      Multiset<N> adjacentNodes = getReference(adjacentNodesReference);\n", "      if (adjacentNodes != null) {\n", "        checkState(adjacentNodes.remove(node));\n", "      }\n", "  public boolean addInEdge(E edge, N node, boolean isSelfLoop) {\n", "    if (isSelfLoop) {\n", "      return false;\n", "    return addOutEdge(edge, node);\n", "  public boolean addOutEdge(E edge, N node) {\n", "    if (super.addOutEdge(edge, node)) {\n", "      Multiset<N> adjacentNodes = getReference(adjacentNodesReference);\n", "      if (adjacentNodes != null) {\n", "        checkState(adjacentNodes.add(node));\n", "      }\n", "      return true;\n", "    return false;\n"]}, "added_lines": {"1": [19], "2": [85, 86, 88, 93, 94, 95, 96, 102, 103, 104, 109, 110, 111, 112, 113]}, "removed_lines": {"2": [84, 85, 87, 92, 93, 94, 95, 96, 97, 103, 104, 105, 107, 111, 112, 113, 114, 115, 116, 117, 119]}}]}
