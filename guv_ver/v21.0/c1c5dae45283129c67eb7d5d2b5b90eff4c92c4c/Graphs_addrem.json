{
    "addition": {
        "24": "import com.google.common.base.Joiner;\n",
        "32": "import java.util.ArrayList;\n",
        "34": "import java.util.List;\n",
        "49": "  private static final String GRAPH_FORMAT = \"%s, nodes: %s, edges: %s\";\n",
        "50": "  private static final String DIRECTED_FORMAT = \"<%s -> %s>\";\n",
        "51": "  private static final String UNDIRECTED_FORMAT = \"[%s, %s]\";\n",
        "52": "\n",
        "61": "  public static <N> N oppositeNode(Network<N, ?> graph, Object edge, Object node) {\n",
        "85": "  public static <N, E> Set<E> parallelEdges(Network<N, E> graph, Object edge) {\n",
        "105": "  public static <N, E> boolean addEdge(MutableNetwork<N, E> graph, E edge, Iterable<N> nodes) {\n",
        "123": "  /**\n",
        "124": "   * Creates a mutable copy of {@code graph}, using the same nodes.\n",
        "125": "   */\n",
        "126": "  public static <N> MutableGraph<N> copyOf(Graph<N> graph) {\n",
        "127": "    return copyOf(graph, Predicates.alwaysTrue());\n",
        "128": "  }\n",
        "129": "\n",
        "130": "  /**\n",
        "131": "   * Creates a mutable copy of {@code graph}, using all of its elements that satisfy\n",
        "132": "   * {@code nodePredicate} and {@code edgePredicate}.\n",
        "133": "   */\n",
        "134": "  public static <N> MutableGraph<N> copyOf(Graph<N> graph, Predicate<? super N> nodePredicate) {\n",
        "135": "    checkNotNull(graph, \"graph\");\n",
        "136": "    checkNotNull(nodePredicate, \"nodePredicate\");\n",
        "137": "    MutableGraph<N> copy = GraphBuilder.from(graph).expectedNodeCount(graph.nodes().size()).build();\n",
        "138": "\n",
        "139": "    for (N node : graph.nodes()) {\n",
        "140": "      if (nodePredicate.apply(node)) {\n",
        "141": "        copy.addNode(node);\n",
        "142": "        for (N successor : graph.successors(node)) {\n",
        "143": "          if (nodePredicate.apply(successor)) {\n",
        "144": "            copy.addEdge(node, successor);\n",
        "145": "          }\n",
        "146": "        }\n",
        "147": "      }\n",
        "148": "      // TODO(b/28087289): update this when parallel edges are permitted to ensure that the correct\n",
        "149": "      // multiplicity is preserved.\n",
        "150": "    }\n",
        "151": "\n",
        "152": "    return copy;\n",
        "153": "  }\n",
        "154": "\n",
        "155": "  /**\n",
        "156": "   * Copies all nodes from {@code original} into {@code copy}.\n",
        "157": "   */\n",
        "158": "  public static <N> void mergeNodesFrom(Graph<N> original, MutableGraph<N> copy) {\n",
        "159": "    mergeNodesFrom(original, copy, Predicates.alwaysTrue());\n",
        "160": "  }\n",
        "161": "\n",
        "162": "  /**\n",
        "163": "   * Copies all nodes from {@code original} into {@code copy} that satisfy {@code nodePredicate}.\n",
        "164": "   */\n",
        "165": "  public static <N, E> void mergeNodesFrom(\n",
        "166": "      Graph<N> original, MutableGraph<N> copy, Predicate<? super N> nodePredicate) {\n",
        "167": "    checkNotNull(original, \"original\");\n",
        "168": "    checkNotNull(copy, \"copy\");\n",
        "169": "    checkNotNull(nodePredicate, \"nodePredicate\");\n",
        "170": "    for (N node : Sets.filter(original.nodes(), nodePredicate)) {\n",
        "171": "      copy.addNode(node);\n",
        "172": "    }\n",
        "173": "  }\n",
        "174": "\n",
        "178": "  public static <N, E> MutableNetwork<N, E> copyOf(Network<N, E> graph) {\n",
        "186": "  public static <N, E> MutableNetwork<N, E> copyOf(\n",
        "187": "      Network<N, E> graph,\n",
        "193": "    MutableNetwork<N, E> copy = NetworkBuilder.from(graph)\n",
        "214": "  public static <N> void mergeNodesFrom(Graph<N> original, MutableNetwork<N, ?> copy) {\n",
        "222": "      Graph<N> original, MutableNetwork<N, ?> copy, Predicate<? super N> nodePredicate) {\n",
        "235": "  public static <N, E> void mergeEdgesFrom(Network<N, E> original, MutableNetwork<N, E> copy) {\n",
        "244": "      Network<N, E> original, MutableNetwork<N, E> copy, Predicate<? super E> edgePredicate) {\n",
        "253": "  /**\n",
        "254": "   * Returns true iff {@code graph1} and {@code graph2} have the same node connections.\n",
        "255": "   *\n",
        "256": "   * <p>Note: {@link Network} instances can only be equal to other {@link Network} instances.\n",
        "257": "   * In particular, {@link Graph}s that are not also {@link Network}s cannot be equal\n",
        "258": "   * to {@link Network}s.\n",
        "259": "   *\n",
        "260": "   * @see Network#equals(Object)\n",
        "261": "   */\n",
        "262": "  public static boolean equal(@Nullable Graph<?> graph1, @Nullable Graph<?> graph2) {\n",
        "263": "    // If both graphs are Network instances, use equal(Network, Network) instead\n",
        "264": "    if (graph1 instanceof Network && graph2 instanceof Network) {\n",
        "265": "      return equal((Network<?, ?>) graph1, (Network<?, ?>) graph2);\n",
        "266": "    }\n",
        "267": "\n",
        "268": "    // Otherwise, if either graph is a Network (but not both), they can't be equal.\n",
        "269": "    if (graph1 instanceof Network || graph2 instanceof Network) {\n",
        "270": "      return false;\n",
        "271": "    }\n",
        "272": "\n",
        "273": "    if (graph1 == graph2) {\n",
        "274": "      return true;\n",
        "275": "    }\n",
        "276": "\n",
        "277": "    if (graph1 == null || graph2 == null) {\n",
        "278": "      return false;\n",
        "279": "    }\n",
        "280": "\n",
        "281": "    if (!graph1.nodes().equals(graph2.nodes())) {\n",
        "282": "      return false;\n",
        "283": "    }\n",
        "284": "\n",
        "285": "    for (Object node : graph1.nodes()) {\n",
        "286": "      if (!graph1.successors(node).equals(graph2.successors(node))) {\n",
        "287": "        return false;\n",
        "288": "      }\n",
        "289": "      boolean bothUndirected = !graph1.isDirected() && !graph2.isDirected();\n",
        "290": "      if (!bothUndirected && !graph1.predecessors(node).equals(graph2.predecessors(node))) {\n",
        "291": "        return false;\n",
        "292": "      }\n",
        "293": "    }\n",
        "294": "\n",
        "295": "    return true;\n",
        "296": "  }\n",
        "297": "\n",
        "301": "   * @see Network#equals(Object)\n",
        "303": "  public static boolean equal(@Nullable Network<?, ?> graph1, @Nullable Network<?, ?> graph2) {\n",
        "338": "  public static int hashCode(Graph<?> graph) {\n",
        "339": "    return (graph instanceof Network)\n",
        "340": "        ? hashCode((Network<?, ?>) graph)\n",
        "341": "        : nodeToAdjacentNodes(graph).hashCode();\n",
        "342": "  }\n",
        "343": "\n",
        "344": "  /**\n",
        "345": "   * Returns the hash code of {@code graph}.\n",
        "346": "   *\n",
        "347": "   * @see Network#hashCode()\n",
        "348": "   */\n",
        "349": "  public static int hashCode(Network<?, ?> graph) {\n",
        "357": "  public static String toString(Graph<?> graph) {\n",
        "358": "    if (graph instanceof Network) {\n",
        "359": "      return toString((Network<?, ?>) graph);\n",
        "360": "    }\n",
        "361": "    return String.format(GRAPH_FORMAT,\n",
        "362": "        getPropertiesString(graph),\n",
        "363": "        graph.nodes(),\n",
        "364": "        adjacentNodesString(graph));\n",
        "365": "  }\n",
        "366": "\n",
        "367": "  /**\n",
        "368": "   * Returns a string representation of {@code graph}. Encodes edge direction if {@code graph}\n",
        "369": "   * is directed.\n",
        "370": "   */\n",
        "371": "  public static String toString(Network<?, ?> graph) {\n",
        "372": "    return String.format(GRAPH_FORMAT,\n",
        "384": "  public static <E> Predicate<E> selfLoopPredicate(final Network<?, E> graph) {\n",
        "394": "  /**\n",
        "395": "   * Returns a String of the adjacent node relationships for {@code graph}.\n",
        "396": "   */\n",
        "397": "  private static <N> String adjacentNodesString(final Graph<N> graph) {\n",
        "398": "    checkNotNull(graph, \"graph\");\n",
        "399": "    List<String> adjacencies = new ArrayList<String>();\n",
        "400": "    // This will list each undirected edge twice (once as [n1, n2] and once as [n2, n1]); this is OK\n",
        "401": "    for (N node : graph.nodes()) {\n",
        "402": "      for (N successor : graph.successors(node)) {\n",
        "403": "        adjacencies.add(\n",
        "404": "            String.format(\n",
        "405": "                graph.isDirected() ? DIRECTED_FORMAT : UNDIRECTED_FORMAT,\n",
        "406": "                node, successor));\n",
        "407": "      }\n",
        "408": "    }\n",
        "409": "\n",
        "410": "    return String.format(\"{%s}\", Joiner.on(\", \").join(adjacencies));\n",
        "411": "  }\n",
        "412": "\n",
        "417": "  private static <N, E> Map<N, Set<E>> nodeToIncidentEdges(final Network<N, E> graph) {\n",
        "427": "  private static <N> Map<N, Set<N>> nodeToAdjacentNodes(final Graph<N> graph) {\n",
        "428": "    checkNotNull(graph, \"graph\");\n",
        "429": "    return Maps.asMap(graph.nodes(), new Function<N, Set<N>>() {\n",
        "430": "      @Override\n",
        "431": "      public Set<N> apply(N node) {\n",
        "432": "        return graph.adjacentNodes(node);\n",
        "433": "      }\n",
        "434": "    });\n",
        "435": "  }\n",
        "436": "\n",
        "442": "  private static Function<Object, String> edgeToIncidentNodesString(final Network<?, ?> graph) {\n",
        "458": " }\n",
        "459": "\n",
        "460": "  /**\n",
        "461": "   * Returns a string representation of the properties of {@code graph}.\n",
        "462": "   */\n",
        "463": "  // TODO(b/28087289): add allowsParallelEdges() once that's supported\n",
        "464": "  private static String getPropertiesString(Graph<?> graph) {\n",
        "465": "    if (graph instanceof Network) {\n",
        "466": "      return getPropertiesString((Network<?, ?>) graph);\n",
        "467": "    }\n",
        "468": "    return String.format(\"isDirected: %s, allowsSelfLoops: %s\",\n",
        "469": "        graph.isDirected(), graph.allowsSelfLoops());\n",
        "475": "  private static String getPropertiesString(Network<?, ?> graph) {\n"
    },
    "removed": {
        "54": "  public static <N> N oppositeNode(Graph<N, ?> graph, Object edge, Object node) {\n",
        "78": "  public static <N, E> Set<E> parallelEdges(Graph<N, E> graph, Object edge) {\n",
        "98": "  public static <N, E> boolean addEdge(Graph<N, E> graph, E edge, Iterable<N> nodes) {\n",
        "119": "  public static <N, E> Graph<N, E> copyOf(Graph<N, E> graph) {\n",
        "127": "  public static <N, E> Graph<N, E> copyOf(\n",
        "128": "      Graph<N, E> graph,\n",
        "134": "    Graph<N, E> copy = GraphBuilder.from(graph)\n",
        "155": "  public static <N, E> void mergeNodesFrom(Graph<N, E> original, Graph<N, E> copy) {\n",
        "163": "      Graph<N, E> original, Graph<N, E> copy, Predicate<? super N> nodePredicate) {\n",
        "176": "  public static <N, E> void mergeEdgesFrom(Graph<N, E> original, Graph<N, E> copy) {\n",
        "185": "      Graph<N, E> original, Graph<N, E> copy, Predicate<? super E> edgePredicate) {\n",
        "197": "   * @see Graph#equals(Object)\n",
        "199": "  public static boolean equal(@Nullable Graph<?, ?> graph1, @Nullable Graph<?, ?> graph2) {\n",
        "234": "  public static int hashCode(Graph<?, ?> graph) {\n",
        "242": "  public static String toString(Graph<?, ?> graph) {\n",
        "243": "    return String.format(\"%s, nodes: %s, edges: %s\",\n",
        "255": "  public static <E> Predicate<E> selfLoopPredicate(final Graph<?, E> graph) {\n",
        "269": "  private static <N, E> Map<N, Set<E>> nodeToIncidentEdges(final Graph<N, E> graph) {\n",
        "284": "  private static Function<Object, String> edgeToIncidentNodesString(final Graph<?, ?> graph) {\n",
        "305": "  private static String getPropertiesString(Graph<?, ?> graph) {\n"
    }
}