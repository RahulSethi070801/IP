{"id": "c1c5dae45283129c67eb7d5d2b5b90eff4c92c4c", "code": [{"0": "guava-testlib/src/com/google/common/graph/testing/TestGraphBuilder.java", "added": {"1": ["import com.google.common.graph.MutableGraph;\n", " * private static final ImmutableGraph<String> GRAPH =\n", " *     TestGraphBuilder.<String>init(GraphBuilder.directed())\n", " *         .addEdge(\"B\", \"C\")\n", "public final class TestGraphBuilder<N> {\n", "  private final MutableGraph<N> graph;\n", "  private TestGraphBuilder(MutableGraph<N> graph) {\n", "  public static <N> TestGraphBuilder<N> init(GraphBuilder<? super N> builder) {\n", "    return new TestGraphBuilder<N>(builder.<N>build());\n", "  public TestGraphBuilder<N> addNode(N node) {\n", "  public TestGraphBuilder<N> addEdge(N node1, N node2) {\n", "    graph.addEdge(node1, node2);\n", "  public ImmutableGraph<N> toImmutableGraph() {\n"]}, "removed": {"1": ["import com.google.common.graph.Graph;\n", " * private static final ImmutableGraph<String, String> GRAPH =\n", " *     TestGraphBuilder.<String, String>init(GraphBuilder.directed())\n", " *         .addEdge(\"B->C\", \"B\", \"C\")\n", "public final class TestGraphBuilder<N, E> {\n", "  private final Graph<N, E> graph;\n", "  private TestGraphBuilder(Graph<N, E> graph) {\n", "  public static <N, E> TestGraphBuilder<N, E> init(GraphBuilder<? super N, ? super E> builder) {\n", "    return new TestGraphBuilder<N, E>(builder.<N, E>build());\n", "  public TestGraphBuilder<N, E> addNode(N node) {\n", "  public TestGraphBuilder<N, E> addEdge(E edge, N node1, N node2) {\n", "    graph.addEdge(edge, node1, node2);\n", "  public ImmutableGraph<N, E> toImmutableGraph() {\n"]}, "added_lines": {"1": [21, 27, 28, 32, 36, 37, 39, 43, 44, 47, 52, 53, 57]}, "removed_lines": {"1": [19, 27, 28, 32, 36, 37, 39, 43, 44, 47, 52, 53, 57]}}, {"1": "guava-testlib/src/com/google/common/graph/testing/TestNetworkBuilder.java", "added": {"1": ["/*\n", " * Copyright (C) 2016 The Guava Authors\n", " *\n", " * Licensed under the Apache License, Version 2.0 (the \"License\");\n", " * you may not use this file except in compliance with the License.\n", " * You may obtain a copy of the License at\n", " *\n", " * http://www.apache.org/licenses/LICENSE-2.0\n", " *\n", " * Unless required by applicable law or agreed to in writing, software\n", " * distributed under the License is distributed on an \"AS IS\" BASIS,\n", " * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n", " * See the License for the specific language governing permissions and\n", " * limitations under the License.\n", " */\n", "\n", "package com.google.common.graph.testing;\n", "\n", "import com.google.common.graph.ImmutableNetwork;\n", "import com.google.common.graph.MutableNetwork;\n", "import com.google.common.graph.NetworkBuilder;\n", "\n", "/**\n", " * This class is useful for fluently building an immutable graph in tests. Example usage:\n", " * <pre><code>\n", " * // Constructs the following graph: (A)    (B)--->(C)\n", " * private static final ImmutableNetwork<String, String> GRAPH =\n", " *     TestNetworkBuilder.<String, String>init(NetworkBuilder.directed())\n", " *         .addNode(\"A\")\n", " *         .addNode(\"B\")\n", " *         .addNode(\"C\")\n", " *         .addEdge(\"B->C\", \"B\", \"C\")\n", " *         .toImmutableNetwork();\n", " * </code></pre>\n", " */\n", "public final class TestNetworkBuilder<N, E> {\n", "  private final MutableNetwork<N, E> graph;\n", "\n", "  private TestNetworkBuilder(MutableNetwork<N, E> graph) {\n", "    this.graph = graph;\n", "  }\n", "\n", "  public static <N, E> TestNetworkBuilder<N, E> init(NetworkBuilder<? super N, ? super E> builder) {\n", "    return new TestNetworkBuilder<N, E>(builder.<N, E>build());\n", "  }\n", "\n", "  public TestNetworkBuilder<N, E> addNode(N node) {\n", "    graph.addNode(node);\n", "    return this;\n", "  }\n", "\n", "  public TestNetworkBuilder<N, E> addEdge(E edge, N node1, N node2) {\n", "    graph.addEdge(edge, node1, node2);\n", "    return this;\n", "  }\n", "\n", "  public ImmutableNetwork<N, E> toImmutableNetwork() {\n", "    return ImmutableNetwork.copyOf(graph);\n", "  }\n", "}\n"]}, "removed": {}, "added_lines": {"1": [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 58, 59, 60]}, "removed_lines": {}}, {"2": "guava-tests/test/com/google/common/graph/AbstractDirectedGraphTest.java", "added": {"2": ["    addEdge(N1, N2);\n"], "3": ["    addEdge(N1, N2);\n"], "4": ["    addEdge(N1, N2);\n"], "5": ["    addEdge(N1, N2);\n"], "6": ["    assertTrue(addEdge(N1, N2));\n", "    addEdge(N1, N2);\n", "    assertFalse(addEdge(N1, N2));\n", "    addEdge(N1, N2);\n", "    assertThat(graph.successors(N1)).containsExactly(N2);\n", "    assertThat(graph.predecessors(N2)).containsExactly(N1);\n", "    assertTrue(graph.removeEdge(N1, N2));\n", "    assertThat(graph.successors(N1)).isEmpty();\n", "    assertThat(graph.predecessors(N2)).isEmpty();\n"]}, "removed": {"1": ["import static org.junit.Assert.fail;\n", "import com.google.common.collect.ImmutableSet;\n", "\n", "import org.junit.After;\n", "import java.util.Collections;\n", "import java.util.Set;\n", "\n"], "2": ["\n", "  @After\n", "  public void validateSourceAndTarget() {\n", "    for (Integer node : graph.nodes()) {\n", "      for (String inEdge : graph.inEdges(node)) {\n", "        Integer oppositeNode = Graphs.oppositeNode(graph, inEdge, node);\n", "        assertThat(graph.source(inEdge)).isEqualTo(oppositeNode);\n", "        assertThat(graph.target(inEdge)).isEqualTo(node);\n", "      }\n", "\n", "      for (String outEdge : graph.outEdges(node)) {\n", "        Integer oppositeNode = Graphs.oppositeNode(graph, outEdge, node);\n", "        assertThat(graph.source(outEdge)).isEqualTo(node);\n", "        assertThat(graph.target(outEdge)).isEqualTo(oppositeNode);\n", "      }\n", "\n", "      for (Integer adjacentNode : graph.adjacentNodes(node)) {\n", "        Set<String> edges = graph.edgesConnecting(node, adjacentNode);\n", "        Set<String> antiParallelEdges = graph.edgesConnecting(adjacentNode, node);\n", "        assertTrue(node.equals(adjacentNode) || Collections.disjoint(edges, antiParallelEdges));\n", "      }\n", "    }\n", "  }\n", "\n", "  @Override\n", "  @Test\n", "  public void incidentNodes_oneEdge() {\n", "    addEdge(E12, N1, N2);\n", "    assertThat(graph.incidentNodes(E12)).containsExactly(N1, N2).inOrder();\n", "  }\n", "\n", "  @Test\n", "  public void edgesConnecting_oneEdge() {\n", "    addEdge(E12, N1, N2);\n", "    assertThat(graph.edgesConnecting(N1, N2)).containsExactly(E12);\n", "    // Passed nodes should be in the correct edge direction, first is the\n", "    // source node and the second is the target node\n", "    assertThat(graph.edgesConnecting(N2, N1)).isEmpty();\n", "  }\n", "\n", "  @Test\n", "  public void inEdges_oneEdge() {\n", "    addEdge(E12, N1, N2);\n", "    assertThat(graph.inEdges(N2)).containsExactly(E12);\n", "    // Edge direction handled correctly\n", "    assertThat(graph.inEdges(N1)).isEmpty();\n", "  }\n", "\n", "  @Test\n", "  public void outEdges_oneEdge() {\n", "    addEdge(E12, N1, N2);\n", "    assertThat(graph.outEdges(N1)).containsExactly(E12);\n", "    // Edge direction handled correctly\n", "    assertThat(graph.outEdges(N2)).isEmpty();\n", "  }\n", "\n", "    addEdge(E12, N1, N2);\n"], "3": ["    addEdge(E12, N1, N2);\n"], "4": ["    addEdge(E12, N1, N2);\n"], "5": ["    addEdge(E12, N1, N2);\n", "  @Test\n", "  public void source_oneEdge() {\n", "    addEdge(E12, N1, N2);\n", "    assertEquals(N1, graph.source(E12));\n", "  }\n", "\n", "  @Test\n", "  public void source_edgeNotInGraph() {\n", "    try {\n", "      graph.source(EDGE_NOT_IN_GRAPH);\n", "      fail(ERROR_EDGE_NOT_IN_GRAPH);\n", "    } catch (IllegalArgumentException e) {\n", "      assertEdgeNotInGraphErrorMessage(e);\n", "    }\n", "  }\n", "\n", "  @Test\n", "  public void target_oneEdge() {\n", "    addEdge(E12, N1, N2);\n", "    assertEquals(N2, graph.target(E12));\n", "  }\n", "\n", "  @Test\n", "  public void target_edgeNotInGraph() {\n", "    try {\n", "      graph.target(EDGE_NOT_IN_GRAPH);\n", "      fail(ERROR_EDGE_NOT_IN_GRAPH);\n", "    } catch (IllegalArgumentException e) {\n", "      assertEdgeNotInGraphErrorMessage(e);\n", "    }\n", "  }\n", "\n"], "6": ["    assertTrue(addEdge(E12, N1, N2));\n", "    assertThat(graph.edges()).contains(E12);\n", "    assertThat(graph.edgesConnecting(N1, N2)).containsExactly(E12);\n", "    // Direction of the added edge is correctly handled\n", "    assertThat(graph.edgesConnecting(N2, N1)).isEmpty();\n", "    addEdge(E12, N1, N2);\n", "    ImmutableSet<String> edges = ImmutableSet.copyOf(graph.edges());\n", "    assertFalse(addEdge(E12, N1, N2));\n", "    assertThat(graph.edges()).containsExactlyElementsIn(edges);\n", "  }\n", "\n", "  @Test\n", "  public void addEdge_existingEdgeBetweenDifferentNodes() {\n", "    addEdge(E12, N1, N2);\n", "    try {\n", "      // Edge between totally different nodes\n", "      addEdge(E12, N4, N5);\n", "      fail(ERROR_ADDED_EXISTING_EDGE);\n", "    } catch (IllegalArgumentException e) {\n", "      assertThat(e.getMessage()).contains(ERROR_REUSE_EDGE);\n", "    }\n", "    try {\n", "      // Edge between same nodes but in reverse direction\n", "      addEdge(E12, N2, N1);\n", "      fail(ERROR_ADDED_EXISTING_EDGE);\n", "    } catch (IllegalArgumentException e) {\n", "      assertThat(e.getMessage()).contains(ERROR_REUSE_EDGE);\n", "    }\n", "  }\n", "\n", "  @Test\n", "  public void addEdge_parallelEdge() {\n", "    addEdge(E12, N1, N2);\n", "    try {\n", "      addEdge(EDGE_NOT_IN_GRAPH, N1, N2);\n", "      fail(ERROR_ADDED_PARALLEL_EDGE);\n", "    } catch (IllegalArgumentException e) {\n", "      assertThat(e.getMessage()).contains(ERROR_PARALLEL_EDGE);\n", "    }\n", "    addEdge(E12, N1, N2);\n", "    assertTrue(graph.removeEdge(E12));\n", "    assertThat(graph.edges()).doesNotContain(E12);\n", "    assertThat(graph.edgesConnecting(N1, N2)).isEmpty();\n"]}, "added_lines": {"2": [37], "3": [45], "4": [53], "5": [61], "6": [75, 80, 81, 86, 87, 88, 89, 90, 91]}, "removed_lines": {"1": [23, 25, 26, 27, 30, 31, 32], "2": [42, 43, 44, 45, 46, 47, 48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 58, 59, 60, 61, 62, 63, 64, 65, 66, 67, 68, 69, 70, 71, 72, 73, 74, 75, 76, 77, 78, 79, 80, 81, 82, 83, 84, 85, 86, 87, 88, 89, 90, 91, 92, 93, 94, 95, 96, 97, 100], "3": [108], "4": [116], "5": [124, 130, 131, 132, 133, 134, 135, 136, 137, 138, 139, 140, 141, 142, 143, 144, 145, 146, 147, 148, 149, 150, 151, 152, 153, 154, 155, 156, 157, 158, 159, 160, 161], "6": [170, 171, 172, 173, 174, 179, 180, 181, 182, 183, 184, 185, 186, 187, 188, 189, 190, 191, 192, 193, 194, 195, 196, 197, 198, 199, 200, 201, 202, 203, 204, 205, 206, 207, 208, 209, 210, 211, 212, 217, 218, 219, 220]}}, {"3": "guava-tests/test/com/google/common/graph/AbstractDirectedNetworkTest.java", "added": {"1": ["/*\n", " * Copyright (C) 2014 The Guava Authors\n", " *\n", " * Licensed under the Apache License, Version 2.0 (the \"License\");\n", " * you may not use this file except in compliance with the License.\n", " * You may obtain a copy of the License at\n", " *\n", " * http://www.apache.org/licenses/LICENSE-2.0\n", " *\n", " * Unless required by applicable law or agreed to in writing, software\n", " * distributed under the License is distributed on an \"AS IS\" BASIS,\n", " * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n", " * See the License for the specific language governing permissions and\n", " * limitations under the License.\n", " */\n", "\n", "package com.google.common.graph;\n", "\n", "import static com.google.common.truth.Truth.assertThat;\n", "import static org.junit.Assert.assertEquals;\n", "import static org.junit.Assert.assertFalse;\n", "import static org.junit.Assert.assertTrue;\n", "import static org.junit.Assert.fail;\n", "\n", "import com.google.common.collect.ImmutableSet;\n", "\n", "import org.junit.After;\n", "import org.junit.Test;\n", "\n", "import java.util.Collections;\n", "import java.util.Set;\n", "\n", "/**\n", " * Abstract base class for testing implementations of {@link Network} interface.\n", " *\n", " * <p>This class is responsible for testing that a directed implementation of {@link Network}\n", " * is correctly handling directed edges. Implementation-dependent test cases are left to\n", " * subclasses. Test cases that do not require the graph to be directed are found in superclasses.\n", " *\n", " */\n", "public abstract class AbstractDirectedNetworkTest extends AbstractNetworkTest {\n", "\n", "  @After\n", "  public void validateSourceAndTarget() {\n", "    for (Integer node : graph.nodes()) {\n", "      for (String inEdge : graph.inEdges(node)) {\n", "        Integer oppositeNode = Graphs.oppositeNode(graph, inEdge, node);\n", "        assertThat(graph.source(inEdge)).isEqualTo(oppositeNode);\n", "        assertThat(graph.target(inEdge)).isEqualTo(node);\n", "      }\n", "\n", "      for (String outEdge : graph.outEdges(node)) {\n", "        Integer oppositeNode = Graphs.oppositeNode(graph, outEdge, node);\n", "        assertThat(graph.source(outEdge)).isEqualTo(node);\n", "        assertThat(graph.target(outEdge)).isEqualTo(oppositeNode);\n", "      }\n", "\n", "      for (Integer adjacentNode : graph.adjacentNodes(node)) {\n", "        Set<String> edges = graph.edgesConnecting(node, adjacentNode);\n", "        Set<String> antiParallelEdges = graph.edgesConnecting(adjacentNode, node);\n", "        assertTrue(node.equals(adjacentNode) || Collections.disjoint(edges, antiParallelEdges));\n", "      }\n", "    }\n", "  }\n", "\n", "  @Override\n", "  @Test\n", "  public void incidentNodes_oneEdge() {\n", "    addEdge(E12, N1, N2);\n", "    assertThat(graph.incidentNodes(E12)).containsExactly(N1, N2).inOrder();\n", "  }\n", "\n", "  @Test\n", "  public void edgesConnecting_oneEdge() {\n", "    addEdge(E12, N1, N2);\n", "    assertThat(graph.edgesConnecting(N1, N2)).containsExactly(E12);\n", "    // Passed nodes should be in the correct edge direction, first is the\n", "    // source node and the second is the target node\n", "    assertThat(graph.edgesConnecting(N2, N1)).isEmpty();\n", "  }\n", "\n", "  @Test\n", "  public void inEdges_oneEdge() {\n", "    addEdge(E12, N1, N2);\n", "    assertThat(graph.inEdges(N2)).containsExactly(E12);\n", "    // Edge direction handled correctly\n", "    assertThat(graph.inEdges(N1)).isEmpty();\n", "  }\n", "\n", "  @Test\n", "  public void outEdges_oneEdge() {\n", "    addEdge(E12, N1, N2);\n", "    assertThat(graph.outEdges(N1)).containsExactly(E12);\n", "    // Edge direction handled correctly\n", "    assertThat(graph.outEdges(N2)).isEmpty();\n", "  }\n", "\n", "  @Test\n", "  public void predecessors_oneEdge() {\n", "    addEdge(E12, N1, N2);\n", "    assertThat(graph.predecessors(N2)).containsExactly(N1);\n", "    // Edge direction handled correctly\n", "    assertThat(graph.predecessors(N1)).isEmpty();\n", "  }\n", "\n", "  @Test\n", "  public void successors_oneEdge() {\n", "    addEdge(E12, N1, N2);\n", "    assertThat(graph.successors(N1)).containsExactly(N2);\n", "    // Edge direction handled correctly\n", "    assertThat(graph.successors(N2)).isEmpty();\n", "  }\n", "\n", "  @Test\n", "  public void inDegree_oneEdge() {\n", "    addEdge(E12, N1, N2);\n", "    assertEquals(1, graph.inDegree(N2));\n", "    // Edge direction handled correctly\n", "    assertEquals(0, graph.inDegree(N1));\n", "  }\n", "\n", "  @Test\n", "  public void outDegree_oneEdge() {\n", "    addEdge(E12, N1, N2);\n", "    assertEquals(1, graph.outDegree(N1));\n", "    // Edge direction handled correctly\n", "    assertEquals(0, graph.outDegree(N2));\n", "  }\n", "\n", "  @Test\n", "  public void source_oneEdge() {\n", "    addEdge(E12, N1, N2);\n", "    assertEquals(N1, graph.source(E12));\n", "  }\n", "\n", "  @Test\n", "  public void source_edgeNotInGraph() {\n", "    try {\n", "      graph.source(EDGE_NOT_IN_GRAPH);\n", "      fail(ERROR_EDGE_NOT_IN_GRAPH);\n", "    } catch (IllegalArgumentException e) {\n", "      assertEdgeNotInGraphErrorMessage(e);\n", "    }\n", "  }\n", "\n", "  @Test\n", "  public void target_oneEdge() {\n", "    addEdge(E12, N1, N2);\n", "    assertEquals(N2, graph.target(E12));\n", "  }\n", "\n", "  @Test\n", "  public void target_edgeNotInGraph() {\n", "    try {\n", "      graph.target(EDGE_NOT_IN_GRAPH);\n", "      fail(ERROR_EDGE_NOT_IN_GRAPH);\n", "    } catch (IllegalArgumentException e) {\n", "      assertEdgeNotInGraphErrorMessage(e);\n", "    }\n", "  }\n", "\n", "  // Element Mutation\n", "\n", "  @Test\n", "  public void addEdge_existingNodes() {\n", "    // Adding nodes initially for safety (insulating from possible future\n", "    // modifications to proxy methods)\n", "    addNode(N1);\n", "    addNode(N2);\n", "    assertTrue(addEdge(E12, N1, N2));\n", "    assertThat(graph.edges()).contains(E12);\n", "    assertThat(graph.edgesConnecting(N1, N2)).containsExactly(E12);\n", "    // Direction of the added edge is correctly handled\n", "    assertThat(graph.edgesConnecting(N2, N1)).isEmpty();\n", "  }\n", "\n", "  @Test\n", "  public void addEdge_existingEdgeBetweenSameNodes() {\n", "    addEdge(E12, N1, N2);\n", "    ImmutableSet<String> edges = ImmutableSet.copyOf(graph.edges());\n", "    assertFalse(addEdge(E12, N1, N2));\n", "    assertThat(graph.edges()).containsExactlyElementsIn(edges);\n", "  }\n", "\n", "  @Test\n", "  public void addEdge_existingEdgeBetweenDifferentNodes() {\n", "    addEdge(E12, N1, N2);\n", "    try {\n", "      // Edge between totally different nodes\n", "      addEdge(E12, N4, N5);\n", "      fail(ERROR_ADDED_EXISTING_EDGE);\n", "    } catch (IllegalArgumentException e) {\n", "      assertThat(e.getMessage()).contains(ERROR_REUSE_EDGE);\n", "    }\n", "    try {\n", "      // Edge between same nodes but in reverse direction\n", "      addEdge(E12, N2, N1);\n", "      fail(ERROR_ADDED_EXISTING_EDGE);\n", "    } catch (IllegalArgumentException e) {\n", "      assertThat(e.getMessage()).contains(ERROR_REUSE_EDGE);\n", "    }\n", "  }\n", "\n", "  @Test\n", "  public void addEdge_parallelEdge() {\n", "    addEdge(E12, N1, N2);\n", "    try {\n", "      addEdge(EDGE_NOT_IN_GRAPH, N1, N2);\n", "      fail(ERROR_ADDED_PARALLEL_EDGE);\n", "    } catch (IllegalArgumentException e) {\n", "      assertThat(e.getMessage()).contains(ERROR_PARALLEL_EDGE);\n", "    }\n", "  }\n", "\n", "  @Test\n", "  public void removeEdge_existingEdge() {\n", "    addEdge(E12, N1, N2);\n", "    assertTrue(graph.removeEdge(E12));\n", "    assertThat(graph.edges()).doesNotContain(E12);\n", "    assertThat(graph.edgesConnecting(N1, N2)).isEmpty();\n", "  }\n", "}\n"]}, "removed": {}, "added_lines": {"1": [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 58, 59, 60, 61, 62, 63, 64, 65, 66, 67, 68, 69, 70, 71, 72, 73, 74, 75, 76, 77, 78, 79, 80, 81, 82, 83, 84, 85, 86, 87, 88, 89, 90, 91, 92, 93, 94, 95, 96, 97, 98, 99, 100, 101, 102, 103, 104, 105, 106, 107, 108, 109, 110, 111, 112, 113, 114, 115, 116, 117, 118, 119, 120, 121, 122, 123, 124, 125, 126, 127, 128, 129, 130, 131, 132, 133, 134, 135, 136, 137, 138, 139, 140, 141, 142, 143, 144, 145, 146, 147, 148, 149, 150, 151, 152, 153, 154, 155, 156, 157, 158, 159, 160, 161, 162, 163, 164, 165, 166, 167, 168, 169, 170, 171, 172, 173, 174, 175, 176, 177, 178, 179, 180, 181, 182, 183, 184, 185, 186, 187, 188, 189, 190, 191, 192, 193, 194, 195, 196, 197, 198, 199, 200, 201, 202, 203, 204, 205, 206, 207, 208, 209, 210, 211, 212, 213, 214, 215, 216, 217, 218, 219, 220, 221, 222]}, "removed_lines": {}}, {"4": "guava-tests/test/com/google/common/graph/AbstractGraphTest.java", "added": {"2": ["  MutableGraph<Integer> graph;\n"], "4": ["  public abstract MutableGraph<Integer> createGraph();\n"], "5": ["  boolean addEdge(Integer n1, Integer n2) {\n", "    return graph.addEdge(n1, n2);\n"], "6": ["    new EqualsTester().addEqualityGroup(\n", "        graph,\n", "        Graphs.copyOf(graph),\n", "        ImmutableGraph.copyOf(graph)).testEquals();\n", "    // TODO(b/28087289): add test for allowsParallelEdges when supported\n"], "9": ["    addEdge(N1, N2);\n"], "11": ["    addEdge(N1, N2);\n"], "12": ["    addEdge(N1, N2);\n", "    addEdge(N4, N1);\n", "    assertThat(graph.adjacentNodes(N2)).isEmpty();\n", "    assertThat(graph.adjacentNodes(N4)).isEmpty();\n"], "13": ["    addEdge(N1, N2);\n", "    addEdge(N1, N3);\n", "    addEdge(N1, N4);\n", "    assertTrue(graph.removeEdge(N1, N3));\n", "    assertThat(graph.adjacentNodes(N1)).containsExactly(N2, N4);\n"]}, "removed": {"1": ["import java.util.Iterator;\n", "\n"], "2": ["  Graph<Integer, String> graph;\n"], "3": ["  static final String E11 = \"1-1\";\n", "  static final String E11_A = \"1-1a\";\n", "  static final String E12 = \"1-2\";\n", "  static final String E12_A = \"1-2a\";\n", "  static final String E21 = \"2-1\";\n", "  static final String E13 = \"1-3\";\n", "  static final String E14 = \"1-4\";\n", "  static final String E23 = \"2-3\";\n", "  static final String E41 = \"4-1\";\n", "  static final String E15 = \"1-5\";\n", "  static final String EDGE_NOT_IN_GRAPH = \"edgeNotInGraph\";\n", "\n"], "4": ["  static final String ERROR_PARALLEL_EDGE = \"connected by a different edge\";\n", "  static final String ERROR_REUSE_EDGE = \"it can't be reused to connect\";\n", "  static final String ERROR_EDGE_NOT_IN_GRAPH =\n", "      \"Should not be allowed to pass an edge that is not an element of the graph.\";\n", "  static final String ERROR_ADDED_EXISTING_EDGE =\n", "      \"Reusing an existing edge to connect different nodes succeeded\";\n", "  public abstract Graph<Integer, String> createGraph();\n"], "5": ["  boolean addEdge(String e, Integer n1, Integer n2) {\n", "    return graph.addEdge(e, n1, n2);\n"], "6": ["    new EqualsTester().addEqualityGroup(graph, ImmutableGraph.copyOf(graph)).testEquals();\n", "    assertThat(graphString).contains(\"allowsParallelEdges: \" + graph.allowsParallelEdges());\n", "    String edgeString = graphString.substring(edgeStart);\n", "\n", "    for (String edge : graph.edges()) {\n", "      // TODO(b/27817069): Consider verifying the edge's incident nodes in the string.\n", "      assertThat(edgeString).contains(edge);\n", "\n", "      if (!(graph instanceof Hypergraph)) {\n", "        Iterator<Integer> incidentNodesIterator = graph.incidentNodes(edge).iterator();\n", "        Integer node1 = incidentNodesIterator.next();\n", "        Integer node2 = incidentNodesIterator.hasNext() ? incidentNodesIterator.next() : node1;\n", "        assertFalse(incidentNodesIterator.hasNext());\n", "        assertThat(graph.edgesConnecting(node1, node2)).contains(edge);\n", "        assertThat(graph.successors(node1)).contains(node2);\n", "        assertThat(graph.adjacentNodes(node1)).contains(node2);\n", "        assertThat(graph.outEdges(node1)).contains(edge);\n", "        assertThat(graph.incidentEdges(node1)).contains(edge);\n", "        assertThat(graph.predecessors(node2)).contains(node1);\n", "        assertThat(graph.adjacentNodes(node2)).contains(node1);\n", "        assertThat(graph.inEdges(node2)).contains(edge);\n", "        assertThat(graph.incidentEdges(node2)).contains(edge);\n", "      }\n", "\n", "      for (Integer incidentNode : graph.incidentNodes(edge)) {\n", "        assertThat(graph.nodes()).contains(incidentNode);\n", "        for (String adjacentEdge : graph.incidentEdges(incidentNode)) {\n", "          assertTrue(edge.equals(adjacentEdge) || graph.adjacentEdges(edge).contains(adjacentEdge));\n", "        }\n", "      }\n", "    }\n", "      for (String incidentEdge : graph.incidentEdges(node)) {\n", "        assertTrue(graph.inEdges(node).contains(incidentEdge)\n", "            || graph.outEdges(node).contains(incidentEdge));\n", "        assertThat(graph.edges()).contains(incidentEdge);\n", "        assertThat(graph.incidentNodes(incidentEdge)).contains(node);\n", "      }\n", "\n", "      for (String inEdge : graph.inEdges(node)) {\n", "        assertThat(graph.incidentEdges(node)).contains(inEdge);\n", "        if (!(graph instanceof Hypergraph)) {\n", "          assertThat(graph.outEdges(Graphs.oppositeNode(graph, inEdge, node))).contains(inEdge);\n", "        }\n", "      }\n", "\n", "      for (String outEdge : graph.outEdges(node)) {\n", "        assertThat(graph.incidentEdges(node)).contains(outEdge);\n", "        if (!(graph instanceof Hypergraph)) {\n", "          assertThat(graph.inEdges(Graphs.oppositeNode(graph, outEdge, node))).contains(outEdge);\n", "        }\n", "      }\n", "\n", "        assertTrue(!graph.edgesConnecting(node, adjacentNode).isEmpty()\n", "            || !graph.edgesConnecting(adjacentNode, node).isEmpty());\n", "        assertThat(graph.incidentEdges(node)).isNotEmpty();\n", "        assertThat(graph.incidentEdges(node)).hasSize(graph.degree(node));\n", "        assertThat(graph.edgesConnecting(predecessor, node)).isNotEmpty();\n", "        assertThat(graph.inEdges(node)).isNotEmpty();\n", "        assertThat(graph.inEdges(node)).hasSize(graph.inDegree(node));\n", "        assertThat(graph.edgesConnecting(node, successor)).isNotEmpty();\n", "        assertThat(graph.outEdges(node)).isNotEmpty();\n", "        assertThat(graph.outEdges(node)).hasSize(graph.outDegree(node));\n"], "7": ["  /**\n", "   * Verifies that the {@code Set} returned by {@code edges} has the expected mutability property\n", "   * (see the {@code Graph} documentation for more information).\n", "   */\n", "  @Test\n", "  public abstract void edges_checkReturnedSetMutability();\n", "\n", "  /**\n", "   * Verifies that the {@code Set} returned by {@code incidentEdges} has the expected\n", "   * mutability property (see the {@code Graph} documentation for more information).\n", "   */\n", "  @Test\n", "  public abstract void incidentEdges_checkReturnedSetMutability();\n", "\n", "  /**\n", "   * Verifies that the {@code Set} returned by {@code incidentNodes} has the expected\n", "   * mutability property (see the {@code Graph} documentation for more information).\n", "   */\n", "  @Test\n", "  public abstract void incidentNodes_checkReturnedSetMutability();\n", "\n"], "8": ["  /**\n", "   * Verifies that the {@code Set} returned by {@code adjacentEdges} has the expected\n", "   * mutability property (see the {@code Graph} documentation for more information).\n", "   */\n", "  @Test\n", "  public abstract void adjacentEdges_checkReturnedSetMutability();\n", "\n", "  /**\n", "   * Verifies that the {@code Set} returned by {@code edgesConnecting} has the expected\n", "   * mutability property (see the {@code Graph} documentation for more information).\n", "   */\n", "  @Test\n", "  public abstract void edgesConnecting_checkReturnedSetMutability();\n", "\n", "  /**\n", "   * Verifies that the {@code Set} returned by {@code inEdges} has the expected\n", "   * mutability property (see the {@code Graph} documentation for more information).\n", "   */\n", "  @Test\n", "  public abstract void inEdges_checkReturnedSetMutability();\n", "\n", "  /**\n", "   * Verifies that the {@code Set} returned by {@code outEdges} has the expected\n", "   * mutability property (see the {@code Graph} documentation for more information).\n", "   */\n", "  @Test\n", "  public abstract void outEdges_checkReturnedSetMutability();\n", "\n"], "9": ["  @Test\n", "  public void edges_oneEdge() {\n", "    addEdge(E12, N1, N2);\n", "    assertThat(graph.edges()).containsExactly(E12);\n", "  }\n", "\n", "  @Test\n", "  public void edges_noEdges() {\n", "    assertThat(graph.edges()).isEmpty();\n", "    // Graph with no edges, given disconnected nodes\n", "    addNode(N1);\n", "    addNode(N2);\n", "    assertThat(graph.edges()).isEmpty();\n", "  }\n", "\n", "  @Test\n", "  public void incidentEdges_oneEdge() {\n", "    addEdge(E12, N1, N2);\n", "    assertThat(graph.incidentEdges(N2)).containsExactly(E12);\n", "    assertThat(graph.incidentEdges(N1)).containsExactly(E12);\n", "  }\n", "\n", "  @Test\n", "  public void incidentEdges_isolatedNode() {\n", "    addNode(N1);\n", "    assertThat(graph.incidentEdges(N1)).isEmpty();\n", "  }\n", "\n", "  @Test\n", "  public void incidentEdges_nodeNotInGraph() {\n", "    try {\n", "      graph.incidentEdges(NODE_NOT_IN_GRAPH);\n", "      fail(ERROR_NODE_NOT_IN_GRAPH);\n", "    } catch (IllegalArgumentException e) {\n", "      assertNodeNotInGraphErrorMessage(e);\n", "    }\n", "  }\n", "\n", "  @Test\n", "  public void incidentNodes_oneEdge() {\n", "    addEdge(E12, N1, N2);\n", "    assertThat(graph.incidentNodes(E12)).containsExactly(N1, N2);\n", "  }\n", "\n", "  @Test\n", "  public void incidentNodes_edgeNotInGraph() {\n", "    try {\n", "      graph.incidentNodes(EDGE_NOT_IN_GRAPH);\n", "      fail(ERROR_EDGE_NOT_IN_GRAPH);\n", "    } catch (IllegalArgumentException e) {\n", "      assertEdgeNotInGraphErrorMessage(e);\n", "    }\n", "  }\n", "\n", "    addEdge(E12, N1, N2);\n"], "10": ["  @Test\n", "  public void adjacentEdges_addEdges() {\n", "    addEdge(E12, N1, N2);\n", "    addEdge(E13, N1, N3);\n", "    addEdge(E23, N2, N3);\n", "    assertThat(graph.adjacentEdges(E12)).containsExactly(E13, E23);\n", "  }\n", "\n", "  @Test\n", "  public void adjacentEdges_noAdjacentEdges() {\n", "    addEdge(E12, N1, N2);\n", "    assertThat(graph.adjacentEdges(E12)).isEmpty();\n", "  }\n", "\n", "  @Test\n", "  public void adjacentEdges_nodeNotInGraph() {\n", "    try {\n", "      graph.adjacentEdges(EDGE_NOT_IN_GRAPH);\n", "      fail(ERROR_EDGE_NOT_IN_GRAPH);\n", "    } catch (IllegalArgumentException e) {\n", "      assertEdgeNotInGraphErrorMessage(e);\n", "    }\n", "  }\n", "\n", "  @Test\n", "  public void edgesConnecting_disconnectedNodes() {\n", "    addNode(N1);\n", "    addNode(N2);\n", "    assertThat(graph.edgesConnecting(N1, N2)).isEmpty();\n", "  }\n", "\n", "  @Test\n", "  public void edgesConnecting_nodesNotInGraph() {\n", "    addNode(N1);\n", "    addNode(N2);\n", "    try {\n", "      graph.edgesConnecting(N1, NODE_NOT_IN_GRAPH);\n", "      fail(ERROR_NODE_NOT_IN_GRAPH);\n", "    } catch (IllegalArgumentException e) {\n", "      assertNodeNotInGraphErrorMessage(e);\n", "    }\n", "    try {\n", "      graph.edgesConnecting(NODE_NOT_IN_GRAPH, N2);\n", "      fail(ERROR_NODE_NOT_IN_GRAPH);\n", "    } catch (IllegalArgumentException e) {\n", "      assertNodeNotInGraphErrorMessage(e);\n", "    }\n", "    try {\n", "      graph.edgesConnecting(NODE_NOT_IN_GRAPH, NODE_NOT_IN_GRAPH);\n", "      fail(ERROR_NODE_NOT_IN_GRAPH);\n", "    } catch (IllegalArgumentException e) {\n", "      assertNodeNotInGraphErrorMessage(e);\n", "    }\n", "  }\n", "\n", "  @Test\n", "  public void inEdges_noInEdges() {\n", "    addNode(N1);\n", "    assertThat(graph.inEdges(N1)).isEmpty();\n", "  }\n", "\n", "  @Test\n", "  public void inEdges_nodeNotInGraph() {\n", "    try {\n", "      graph.inEdges(NODE_NOT_IN_GRAPH);\n", "      fail(ERROR_NODE_NOT_IN_GRAPH);\n", "    } catch (IllegalArgumentException e) {\n", "      assertNodeNotInGraphErrorMessage(e);\n", "    }\n", "  }\n", "\n", "  @Test\n", "  public void outEdges_noOutEdges() {\n", "    addNode(N1);\n", "    assertThat(graph.outEdges(N1)).isEmpty();\n", "  }\n", "\n", "  @Test\n", "  public void outEdges_nodeNotInGraph() {\n", "    try {\n", "      graph.outEdges(NODE_NOT_IN_GRAPH);\n", "      fail(ERROR_NODE_NOT_IN_GRAPH);\n", "    } catch (IllegalArgumentException e) {\n", "      assertNodeNotInGraphErrorMessage(e);\n", "    }\n", "  }\n", "\n"], "11": ["    addEdge(E12, N1, N2);\n"], "12": ["    addEdge(E12, N1, N2);\n", "    addEdge(E41, N4, N1);\n", "    assertThat(graph.edges()).doesNotContain(E12);\n", "    assertThat(graph.edges()).doesNotContain(E41);\n"], "13": ["    addEdge(E12, N1, N2);\n", "    addEdge(E13, N1, N3);\n", "    addEdge(E14, N1, N4);\n", "    assertThat(graph.edges()).containsExactly(E12, E13, E14);\n", "    assertTrue(graph.removeEdge(E13));\n", "    assertThat(graph.edges()).containsExactly(E12, E14);\n", "  }\n", "\n", "  @Test\n", "  public void removeEdge_invalidArgument() {\n", "    ImmutableSet<String> edges = ImmutableSet.copyOf(graph.edges());\n", "    assertFalse(graph.removeEdge(EDGE_NOT_IN_GRAPH));\n", "    assertThat(graph.edges()).containsExactlyElementsIn(edges);\n"]}, "added_lines": {"2": [56], "4": [82], "5": [117, 120], "6": [130, 131, 132, 133, 137], "9": [203], "11": [258], "12": [327, 328, 331, 332], "13": [344, 345, 346, 347, 348]}, "removed_lines": {"1": [33, 34], "2": [58], "3": [66, 67, 68, 69, 70, 71, 72, 73, 74, 75, 76, 77], "4": [86, 87, 92, 93, 96, 97, 102], "5": [137, 140], "6": [150, 154, 160, 161, 162, 163, 164, 165, 166, 167, 168, 169, 170, 171, 172, 173, 174, 175, 176, 177, 178, 179, 180, 181, 182, 183, 184, 185, 186, 187, 188, 193, 194, 195, 196, 197, 198, 199, 200, 201, 202, 203, 204, 205, 206, 207, 208, 209, 210, 211, 212, 213, 217, 218, 219, 220, 225, 226, 227, 232, 233, 234], "7": [246, 247, 248, 249, 250, 251, 252, 253, 254, 255, 256, 257, 258, 259, 260, 261, 262, 263, 264, 265, 266], "8": [274, 275, 276, 277, 278, 279, 280, 281, 282, 283, 284, 285, 286, 287, 288, 289, 290, 291, 292, 293, 294, 295, 296, 297, 298, 299, 300, 301], "9": [327, 328, 329, 330, 331, 332, 333, 334, 335, 336, 337, 338, 339, 340, 341, 342, 343, 344, 345, 346, 347, 348, 349, 350, 351, 352, 353, 354, 355, 356, 357, 358, 359, 360, 361, 362, 363, 364, 365, 366, 367, 368, 369, 370, 371, 372, 373, 374, 375, 376, 377, 378, 379, 380, 383], "10": [404, 405, 406, 407, 408, 409, 410, 411, 412, 413, 414, 415, 416, 417, 418, 419, 420, 421, 422, 423, 424, 425, 426, 427, 428, 429, 430, 431, 432, 433, 434, 435, 436, 437, 438, 439, 440, 441, 442, 443, 444, 445, 446, 447, 448, 449, 450, 451, 452, 453, 454, 455, 456, 457, 458, 459, 460, 461, 462, 463, 464, 465, 466, 467, 468, 469, 470, 471, 472, 473, 474, 475, 476, 477, 478, 479, 480, 481, 482, 483, 484, 485, 486, 487, 488, 489, 490], "11": [525], "12": [594, 595, 598, 599], "13": [611, 612, 613, 614, 615, 616, 617, 618, 619, 620, 621, 622, 623]}}, {"5": "guava-tests/test/com/google/common/graph/AbstractNetworkTest.java", "added": {"1": ["/*\n", " * Copyright (C) 2014 The Guava Authors\n", " *\n", " * Licensed under the Apache License, Version 2.0 (the \"License\");\n", " * you may not use this file except in compliance with the License.\n", " * You may obtain a copy of the License at\n", " *\n", " * http://www.apache.org/licenses/LICENSE-2.0\n", " *\n", " * Unless required by applicable law or agreed to in writing, software\n", " * distributed under the License is distributed on an \"AS IS\" BASIS,\n", " * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n", " * See the License for the specific language governing permissions and\n", " * limitations under the License.\n", " */\n", "\n", "package com.google.common.graph;\n", "\n", "import static com.google.common.truth.Truth.assertThat;\n", "import static org.junit.Assert.assertEquals;\n", "import static org.junit.Assert.assertFalse;\n", "import static org.junit.Assert.assertTrue;\n", "import static org.junit.Assert.fail;\n", "\n", "import com.google.common.collect.ImmutableSet;\n", "import com.google.common.testing.EqualsTester;\n", "import com.google.errorprone.annotations.CanIgnoreReturnValue;\n", "\n", "import org.junit.After;\n", "import org.junit.Before;\n", "import org.junit.Test;\n", "\n", "import java.util.Iterator;\n", "\n", "/**\n", " * Abstract base class for testing implementations of {@link Network} interface. Network\n", " * instances created for testing should have Integer node and String edge objects.\n", " *\n", " * <p>Tests assume the following about the graph implementation:\n", " * <ul>\n", " * <li>Parallel edges are not allowed.\n", " * </ul>\n", " *\n", " * <p>Test cases that should be handled similarly in any graph implementation are\n", " * included in this class. For example, testing that {@code nodes()} method returns\n", " * the set of the nodes in the graph. The following test cases are left for the subclasses\n", " * to handle:\n", " * <ul>\n", " * <li>Test cases related to whether the graph is directed, undirected, mutable,\n", " *     or immutable.\n", " * <li>Test cases related to the specific implementation of the {@link Network} interface.\n", " * </ul>\n", " *\n", " * TODO(user): Make this class generic (using <N, E>) for all node and edge types.\n", " * TODO(user): Differentiate between directed and undirected edge strings.\n", " */\n", "public abstract class AbstractNetworkTest {\n", "  MutableNetwork<Integer, String> graph;\n", "  static final Integer N1 = 1;\n", "  static final Integer N2 = 2;\n", "  static final Integer N3 = 3;\n", "  static final Integer N4 = 4;\n", "  static final Integer N5 = 5;\n", "  static final Integer NODE_NOT_IN_GRAPH = 1000;\n", "\n", "  static final String E11 = \"1-1\";\n", "  static final String E11_A = \"1-1a\";\n", "  static final String E12 = \"1-2\";\n", "  static final String E12_A = \"1-2a\";\n", "  static final String E21 = \"2-1\";\n", "  static final String E13 = \"1-3\";\n", "  static final String E14 = \"1-4\";\n", "  static final String E23 = \"2-3\";\n", "  static final String E41 = \"4-1\";\n", "  static final String E15 = \"1-5\";\n", "  static final String EDGE_NOT_IN_GRAPH = \"edgeNotInGraph\";\n", "\n", "  // TODO(user): Consider separating Strings that we've defined here to capture\n", "  // identifiable substrings of expected error messages, from Strings that we've defined\n", "  // here to provide error messages.\n", "  // TODO(user): Some Strings used in the subclasses can be added as static Strings\n", "  // here too.\n", "  static final String ERROR_ELEMENT_NOT_IN_GRAPH = \"not an element of this graph\";\n", "  static final String NODE_STRING = \"Node\";\n", "  static final String EDGE_STRING = \"Edge\";\n", "  static final String ERROR_PARALLEL_EDGE = \"connected by a different edge\";\n", "  static final String ERROR_REUSE_EDGE = \"it can't be reused to connect\";\n", "  static final String ERROR_MODIFIABLE_SET = \"Set returned is unexpectedly modifiable\";\n", "  static final String ERROR_SELF_LOOP = \"self-loops are not allowed\";\n", "  static final String ERROR_NODE_NOT_IN_GRAPH =\n", "      \"Should not be allowed to pass a node that is not an element of the graph.\";\n", "  static final String ERROR_EDGE_NOT_IN_GRAPH =\n", "      \"Should not be allowed to pass an edge that is not an element of the graph.\";\n", "  static final String ERROR_ADDED_SELF_LOOP = \"Should not be allowed to add a self-loop edge.\";\n", "  static final String ERROR_ADDED_PARALLEL_EDGE = \"Should not be allowed to add a parallel edge.\";\n", "  static final String ERROR_ADDED_EXISTING_EDGE =\n", "      \"Reusing an existing edge to connect different nodes succeeded\";\n", "\n", "  /**\n", "   * Creates and returns an instance of the graph to be tested.\n", "   */\n", "  public abstract MutableNetwork<Integer, String> createGraph();\n", "\n", "  /**\n", "   * A proxy method that adds the node {@code n} to the graph being tested.\n", "   * In case of Immutable graph implementations, this method should add {@code n} to the graph\n", "   * builder and build a new graph with the current builder state.\n", "   *\n", "   * @return {@code true} iff the graph was modified as a result of this call\n", "   * TODO(user): Consider changing access modifier to be protected.\n", "   */\n", "  @CanIgnoreReturnValue\n", "  boolean addNode(Integer n) {\n", "    return graph.addNode(n);\n", "  }\n", "\n", "  /**\n", "   * A proxy method that adds the edge {@code e} to the graph\n", "   * being tested. In case of Immutable graph implementations, this method\n", "   * should add {@code e} to the graph builder and build a new graph with the current\n", "   * builder state.\n", "   *\n", "   * <p>This method should be used in tests of specific implementations if you want to\n", "   * ensure uniform behavior (including side effects) with how edges are added elsewhere\n", "   * in the tests.  For example, the existing implementations of this method explicitly\n", "   * add the supplied nodes to the graph, and then call {@code graph.addEdge()} to connect\n", "   * the edge to the nodes; this is not part of the contract of {@code graph.addEdge()}\n", "   * and is done for convenience.  In cases where you want to avoid such side effects\n", "   * (e.g., if you're testing what happens in your implementation if you add an edge\n", "   * whose end-points don't already exist in the graph), you should <b>not</b> use this\n", "   * method.\n", "   *\n", "   * @return {@code true} iff the graph was modified as a result of this call\n", "   * TODO(user): Consider changing access modifier to be protected.\n", "   */\n", "  @CanIgnoreReturnValue\n", "  boolean addEdge(String e, Integer n1, Integer n2) {\n", "    graph.addNode(n1);\n", "    graph.addNode(n2);\n", "    return graph.addEdge(e, n1, n2);\n", "  }\n", "\n", "  @Before\n", "  public void init() {\n", "    graph = createGraph();\n", "  }\n", "\n", "  @After\n", "  public void validateGraphState() {\n", "    new EqualsTester().addEqualityGroup(\n", "        graph,\n", "        Graphs.copyOf(graph),\n", "        ImmutableNetwork.copyOf(graph)).testEquals();\n", "\n", "    String graphString = graph.toString();\n", "    assertThat(graphString).contains(\"isDirected: \" + graph.isDirected());\n", "    assertThat(graphString).contains(\"allowsParallelEdges: \" + graph.allowsParallelEdges());\n", "    assertThat(graphString).contains(\"allowsSelfLoops: \" + graph.allowsSelfLoops());\n", "\n", "    int nodeStart = graphString.indexOf(\"nodes:\");\n", "    int edgeStart = graphString.indexOf(\"edges:\");\n", "    String nodeString = graphString.substring(nodeStart, edgeStart);\n", "    String edgeString = graphString.substring(edgeStart);\n", "\n", "    for (String edge : graph.edges()) {\n", "      // TODO(b/27817069): Consider verifying the edge's incident nodes in the string.\n", "      assertThat(edgeString).contains(edge);\n", "\n", "      if (!(graph instanceof Hypergraph)) {\n", "        Iterator<Integer> incidentNodesIterator = graph.incidentNodes(edge).iterator();\n", "        Integer node1 = incidentNodesIterator.next();\n", "        Integer node2 = incidentNodesIterator.hasNext() ? incidentNodesIterator.next() : node1;\n", "        assertFalse(incidentNodesIterator.hasNext());\n", "        assertThat(graph.edgesConnecting(node1, node2)).contains(edge);\n", "        assertThat(graph.successors(node1)).contains(node2);\n", "        assertThat(graph.adjacentNodes(node1)).contains(node2);\n", "        assertThat(graph.outEdges(node1)).contains(edge);\n", "        assertThat(graph.incidentEdges(node1)).contains(edge);\n", "        assertThat(graph.predecessors(node2)).contains(node1);\n", "        assertThat(graph.adjacentNodes(node2)).contains(node1);\n", "        assertThat(graph.inEdges(node2)).contains(edge);\n", "        assertThat(graph.incidentEdges(node2)).contains(edge);\n", "      }\n", "\n", "      for (Integer incidentNode : graph.incidentNodes(edge)) {\n", "        assertThat(graph.nodes()).contains(incidentNode);\n", "        for (String adjacentEdge : graph.incidentEdges(incidentNode)) {\n", "          assertTrue(edge.equals(adjacentEdge) || graph.adjacentEdges(edge).contains(adjacentEdge));\n", "        }\n", "      }\n", "    }\n", "\n", "    for (Integer node : graph.nodes()) {\n", "      assertThat(nodeString).contains(node.toString());\n", "\n", "      for (String incidentEdge : graph.incidentEdges(node)) {\n", "        assertTrue(graph.inEdges(node).contains(incidentEdge)\n", "            || graph.outEdges(node).contains(incidentEdge));\n", "        assertThat(graph.edges()).contains(incidentEdge);\n", "        assertThat(graph.incidentNodes(incidentEdge)).contains(node);\n", "      }\n", "\n", "      for (String inEdge : graph.inEdges(node)) {\n", "        assertThat(graph.incidentEdges(node)).contains(inEdge);\n", "        if (!(graph instanceof Hypergraph)) {\n", "          assertThat(graph.outEdges(Graphs.oppositeNode(graph, inEdge, node))).contains(inEdge);\n", "        }\n", "      }\n", "\n", "      for (String outEdge : graph.outEdges(node)) {\n", "        assertThat(graph.incidentEdges(node)).contains(outEdge);\n", "        if (!(graph instanceof Hypergraph)) {\n", "          assertThat(graph.inEdges(Graphs.oppositeNode(graph, outEdge, node))).contains(outEdge);\n", "        }\n", "      }\n", "\n", "      for (Integer adjacentNode : graph.adjacentNodes(node)) {\n", "        assertTrue(graph.predecessors(node).contains(adjacentNode)\n", "            || graph.successors(node).contains(adjacentNode));\n", "        assertTrue(!graph.edgesConnecting(node, adjacentNode).isEmpty()\n", "            || !graph.edgesConnecting(adjacentNode, node).isEmpty());\n", "        assertThat(graph.incidentEdges(node)).isNotEmpty();\n", "        assertThat(graph.incidentEdges(node)).hasSize(graph.degree(node));\n", "      }\n", "\n", "      for (Integer predecessor : graph.predecessors(node)) {\n", "        assertThat(graph.successors(predecessor)).contains(node);\n", "        assertThat(graph.edgesConnecting(predecessor, node)).isNotEmpty();\n", "        assertThat(graph.inEdges(node)).isNotEmpty();\n", "        assertThat(graph.inEdges(node)).hasSize(graph.inDegree(node));\n", "      }\n", "\n", "      for (Integer successor : graph.successors(node)) {\n", "        assertThat(graph.predecessors(successor)).contains(node);\n", "        assertThat(graph.edgesConnecting(node, successor)).isNotEmpty();\n", "        assertThat(graph.outEdges(node)).isNotEmpty();\n", "        assertThat(graph.outEdges(node)).hasSize(graph.outDegree(node));\n", "      }\n", "    }\n", "  }\n", "\n", "  /**\n", "   * Verifies that the {@code Set} returned by {@code nodes} has the expected mutability property\n", "   * (see the {@code Network} documentation for more information).\n", "   */\n", "  @Test\n", "  public abstract void nodes_checkReturnedSetMutability();\n", "\n", "  /**\n", "   * Verifies that the {@code Set} returned by {@code edges} has the expected mutability property\n", "   * (see the {@code Network} documentation for more information).\n", "   */\n", "  @Test\n", "  public abstract void edges_checkReturnedSetMutability();\n", "\n", "  /**\n", "   * Verifies that the {@code Set} returned by {@code incidentEdges} has the expected\n", "   * mutability property (see the {@code Network} documentation for more information).\n", "   */\n", "  @Test\n", "  public abstract void incidentEdges_checkReturnedSetMutability();\n", "\n", "  /**\n", "   * Verifies that the {@code Set} returned by {@code incidentNodes} has the expected\n", "   * mutability property (see the {@code Network} documentation for more information).\n", "   */\n", "  @Test\n", "  public abstract void incidentNodes_checkReturnedSetMutability();\n", "\n", "  /**\n", "   * Verifies that the {@code Set} returned by {@code adjacentNodes} has the expected\n", "   * mutability property (see the {@code Network} documentation for more information).\n", "   */\n", "  @Test\n", "  public abstract void adjacentNodes_checkReturnedSetMutability();\n", "\n", "  /**\n", "   * Verifies that the {@code Set} returned by {@code adjacentEdges} has the expected\n", "   * mutability property (see the {@code Network} documentation for more information).\n", "   */\n", "  @Test\n", "  public abstract void adjacentEdges_checkReturnedSetMutability();\n", "\n", "  /**\n", "   * Verifies that the {@code Set} returned by {@code edgesConnecting} has the expected\n", "   * mutability property (see the {@code Network} documentation for more information).\n", "   */\n", "  @Test\n", "  public abstract void edgesConnecting_checkReturnedSetMutability();\n", "\n", "  /**\n", "   * Verifies that the {@code Set} returned by {@code inEdges} has the expected\n", "   * mutability property (see the {@code Network} documentation for more information).\n", "   */\n", "  @Test\n", "  public abstract void inEdges_checkReturnedSetMutability();\n", "\n", "  /**\n", "   * Verifies that the {@code Set} returned by {@code outEdges} has the expected\n", "   * mutability property (see the {@code Network} documentation for more information).\n", "   */\n", "  @Test\n", "  public abstract void outEdges_checkReturnedSetMutability();\n", "\n", "  /**\n", "   * Verifies that the {@code Set} returned by {@code predecessors} has the expected\n", "   * mutability property (see the {@code Network} documentation for more information).\n", "   */\n", "  @Test\n", "  public abstract void predecessors_checkReturnedSetMutability();\n", "\n", "  /**\n", "   * Verifies that the {@code Set} returned by {@code successors} has the expected\n", "   * mutability property (see the {@code Network} documentation for more information).\n", "   */\n", "  @Test\n", "  public abstract void successors_checkReturnedSetMutability();\n", "\n", "  @Test\n", "  public void nodes_oneNode() {\n", "    addNode(N1);\n", "    assertThat(graph.nodes()).containsExactly(N1);\n", "  }\n", "\n", "  @Test\n", "  public void nodes_noNodes() {\n", "    assertThat(graph.nodes()).isEmpty();\n", "  }\n", "\n", "  @Test\n", "  public void edges_oneEdge() {\n", "    addEdge(E12, N1, N2);\n", "    assertThat(graph.edges()).containsExactly(E12);\n", "  }\n", "\n", "  @Test\n", "  public void edges_noEdges() {\n", "    assertThat(graph.edges()).isEmpty();\n", "    // Network with no edges, given disconnected nodes\n", "    addNode(N1);\n", "    addNode(N2);\n", "    assertThat(graph.edges()).isEmpty();\n", "  }\n", "\n", "  @Test\n", "  public void incidentEdges_oneEdge() {\n", "    addEdge(E12, N1, N2);\n", "    assertThat(graph.incidentEdges(N2)).containsExactly(E12);\n", "    assertThat(graph.incidentEdges(N1)).containsExactly(E12);\n", "  }\n", "\n", "  @Test\n", "  public void incidentEdges_isolatedNode() {\n", "    addNode(N1);\n", "    assertThat(graph.incidentEdges(N1)).isEmpty();\n", "  }\n", "\n", "  @Test\n", "  public void incidentEdges_nodeNotInGraph() {\n", "    try {\n", "      graph.incidentEdges(NODE_NOT_IN_GRAPH);\n", "      fail(ERROR_NODE_NOT_IN_GRAPH);\n", "    } catch (IllegalArgumentException e) {\n", "      assertNodeNotInGraphErrorMessage(e);\n", "    }\n", "  }\n", "\n", "  @Test\n", "  public void incidentNodes_oneEdge() {\n", "    addEdge(E12, N1, N2);\n", "    assertThat(graph.incidentNodes(E12)).containsExactly(N1, N2);\n", "  }\n", "\n", "  @Test\n", "  public void incidentNodes_edgeNotInGraph() {\n", "    try {\n", "      graph.incidentNodes(EDGE_NOT_IN_GRAPH);\n", "      fail(ERROR_EDGE_NOT_IN_GRAPH);\n", "    } catch (IllegalArgumentException e) {\n", "      assertEdgeNotInGraphErrorMessage(e);\n", "    }\n", "  }\n", "\n", "  @Test\n", "  public void adjacentNodes_oneEdge() {\n", "    addEdge(E12, N1, N2);\n", "    assertThat(graph.adjacentNodes(N1)).containsExactly(N2);\n", "    assertThat(graph.adjacentNodes(N2)).containsExactly(N1);\n", "  }\n", "\n", "  @Test\n", "  public void adjacentNodes_noAdjacentNodes() {\n", "    addNode(N1);\n", "    assertThat(graph.adjacentNodes(N1)).isEmpty();\n", "  }\n", "\n", "  @Test\n", "  public void adjacentNodes_nodeNotInGraph() {\n", "    try {\n", "      graph.adjacentNodes(NODE_NOT_IN_GRAPH);\n", "      fail(ERROR_NODE_NOT_IN_GRAPH);\n", "    } catch (IllegalArgumentException e) {\n", "      assertNodeNotInGraphErrorMessage(e);\n", "    }\n", "  }\n", "\n", "  @Test\n", "  public void adjacentEdges_addEdges() {\n", "    addEdge(E12, N1, N2);\n", "    addEdge(E13, N1, N3);\n", "    addEdge(E23, N2, N3);\n", "    assertThat(graph.adjacentEdges(E12)).containsExactly(E13, E23);\n", "  }\n", "\n", "  @Test\n", "  public void adjacentEdges_noAdjacentEdges() {\n", "    addEdge(E12, N1, N2);\n", "    assertThat(graph.adjacentEdges(E12)).isEmpty();\n", "  }\n", "\n", "  @Test\n", "  public void adjacentEdges_nodeNotInGraph() {\n", "    try {\n", "      graph.adjacentEdges(EDGE_NOT_IN_GRAPH);\n", "      fail(ERROR_EDGE_NOT_IN_GRAPH);\n", "    } catch (IllegalArgumentException e) {\n", "      assertEdgeNotInGraphErrorMessage(e);\n", "    }\n", "  }\n", "\n", "  @Test\n", "  public void edgesConnecting_disconnectedNodes() {\n", "    addNode(N1);\n", "    addNode(N2);\n", "    assertThat(graph.edgesConnecting(N1, N2)).isEmpty();\n", "  }\n", "\n", "  @Test\n", "  public void edgesConnecting_nodesNotInGraph() {\n", "    addNode(N1);\n", "    addNode(N2);\n", "    try {\n", "      graph.edgesConnecting(N1, NODE_NOT_IN_GRAPH);\n", "      fail(ERROR_NODE_NOT_IN_GRAPH);\n", "    } catch (IllegalArgumentException e) {\n", "      assertNodeNotInGraphErrorMessage(e);\n", "    }\n", "    try {\n", "      graph.edgesConnecting(NODE_NOT_IN_GRAPH, N2);\n", "      fail(ERROR_NODE_NOT_IN_GRAPH);\n", "    } catch (IllegalArgumentException e) {\n", "      assertNodeNotInGraphErrorMessage(e);\n", "    }\n", "    try {\n", "      graph.edgesConnecting(NODE_NOT_IN_GRAPH, NODE_NOT_IN_GRAPH);\n", "      fail(ERROR_NODE_NOT_IN_GRAPH);\n", "    } catch (IllegalArgumentException e) {\n", "      assertNodeNotInGraphErrorMessage(e);\n", "    }\n", "  }\n", "\n", "  @Test\n", "  public void inEdges_noInEdges() {\n", "    addNode(N1);\n", "    assertThat(graph.inEdges(N1)).isEmpty();\n", "  }\n", "\n", "  @Test\n", "  public void inEdges_nodeNotInGraph() {\n", "    try {\n", "      graph.inEdges(NODE_NOT_IN_GRAPH);\n", "      fail(ERROR_NODE_NOT_IN_GRAPH);\n", "    } catch (IllegalArgumentException e) {\n", "      assertNodeNotInGraphErrorMessage(e);\n", "    }\n", "  }\n", "\n", "  @Test\n", "  public void outEdges_noOutEdges() {\n", "    addNode(N1);\n", "    assertThat(graph.outEdges(N1)).isEmpty();\n", "  }\n", "\n", "  @Test\n", "  public void outEdges_nodeNotInGraph() {\n", "    try {\n", "      graph.outEdges(NODE_NOT_IN_GRAPH);\n", "      fail(ERROR_NODE_NOT_IN_GRAPH);\n", "    } catch (IllegalArgumentException e) {\n", "      assertNodeNotInGraphErrorMessage(e);\n", "    }\n", "  }\n", "\n", "  @Test\n", "  public void predecessors_noPredecessors() {\n", "    addNode(N1);\n", "    assertThat(graph.predecessors(N1)).isEmpty();\n", "  }\n", "\n", "  @Test\n", "  public void predecessors_nodeNotInGraph() {\n", "    try {\n", "      graph.predecessors(NODE_NOT_IN_GRAPH);\n", "      fail(ERROR_NODE_NOT_IN_GRAPH);\n", "    } catch (IllegalArgumentException e) {\n", "      assertNodeNotInGraphErrorMessage(e);\n", "    }\n", "  }\n", "\n", "  @Test\n", "  public void successors_noSuccessors() {\n", "    addNode(N1);\n", "    assertThat(graph.successors(N1)).isEmpty();\n", "  }\n", "\n", "  @Test\n", "  public void successors_nodeNotInGraph() {\n", "    try {\n", "      graph.successors(NODE_NOT_IN_GRAPH);\n", "      fail(ERROR_NODE_NOT_IN_GRAPH);\n", "    } catch (IllegalArgumentException e) {\n", "      assertNodeNotInGraphErrorMessage(e);\n", "    }\n", "  }\n", "\n", "  @Test\n", "  public void degree_oneEdge() {\n", "    addEdge(E12, N1, N2);\n", "    assertEquals(1, graph.degree(N1));\n", "    assertEquals(1, graph.degree(N2));\n", "  }\n", "\n", "  @Test\n", "  public void degree_isolatedNode() {\n", "    addNode(N1);\n", "    assertEquals(0, graph.degree(N1));\n", "  }\n", "\n", "  @Test\n", "  public void degree_nodeNotInGraph() {\n", "    try {\n", "      graph.degree(NODE_NOT_IN_GRAPH);\n", "      fail(ERROR_NODE_NOT_IN_GRAPH);\n", "    } catch (IllegalArgumentException e) {\n", "      assertNodeNotInGraphErrorMessage(e);\n", "    }\n", "  }\n", "\n", "  @Test\n", "  public void inDegree_isolatedNode() {\n", "    addNode(N1);\n", "    assertEquals(0, graph.inDegree(N1));\n", "  }\n", "\n", "  @Test\n", "  public void inDegree_nodeNotInGraph() {\n", "    try {\n", "      graph.inDegree(NODE_NOT_IN_GRAPH);\n", "      fail(ERROR_NODE_NOT_IN_GRAPH);\n", "    } catch (IllegalArgumentException e) {\n", "      assertNodeNotInGraphErrorMessage(e);\n", "    }\n", "  }\n", "\n", "  @Test\n", "  public void outDegree_isolatedNode() {\n", "    addNode(N1);\n", "    assertEquals(0, graph.outDegree(N1));\n", "  }\n", "\n", "  @Test\n", "  public void outDegree_nodeNotInGraph() {\n", "    try {\n", "      graph.outDegree(NODE_NOT_IN_GRAPH);\n", "      fail(ERROR_NODE_NOT_IN_GRAPH);\n", "    } catch (IllegalArgumentException e) {\n", "      assertNodeNotInGraphErrorMessage(e);\n", "    }\n", "  }\n", "\n", "  @Test\n", "  public void addNode_newNode() {\n", "    assertTrue(addNode(N1));\n", "    assertThat(graph.nodes()).contains(N1);\n", "  }\n", "\n", "  @Test\n", "  public void addNode_existingNode() {\n", "    addNode(N1);\n", "    ImmutableSet<Integer> nodes = ImmutableSet.copyOf(graph.nodes());\n", "    assertFalse(addNode(N1));\n", "    assertThat(graph.nodes()).containsExactlyElementsIn(nodes);\n", "  }\n", "\n", "  @Test\n", "  public void removeNode_existingNode() {\n", "    addEdge(E12, N1, N2);\n", "    addEdge(E41, N4, N1);\n", "    assertTrue(graph.removeNode(N1));\n", "    assertThat(graph.nodes()).containsExactly(N2, N4);\n", "    assertThat(graph.edges()).doesNotContain(E12);\n", "    assertThat(graph.edges()).doesNotContain(E41);\n", "  }\n", "\n", "  @Test\n", "  public void removeNode_invalidArgument() {\n", "    ImmutableSet<Integer> nodes = ImmutableSet.copyOf(graph.nodes());\n", "    assertFalse(graph.removeNode(NODE_NOT_IN_GRAPH));\n", "    assertThat(graph.nodes()).containsExactlyElementsIn(nodes);\n", "  }\n", "\n", "  @Test\n", "  public void removeEdge_oneOfMany() {\n", "    addEdge(E12, N1, N2);\n", "    addEdge(E13, N1, N3);\n", "    addEdge(E14, N1, N4);\n", "    assertThat(graph.edges()).containsExactly(E12, E13, E14);\n", "    assertTrue(graph.removeEdge(E13));\n", "    assertThat(graph.edges()).containsExactly(E12, E14);\n", "  }\n", "\n", "  @Test\n", "  public void removeEdge_invalidArgument() {\n", "    ImmutableSet<String> edges = ImmutableSet.copyOf(graph.edges());\n", "    assertFalse(graph.removeEdge(EDGE_NOT_IN_GRAPH));\n", "    assertThat(graph.edges()).containsExactlyElementsIn(edges);\n", "  }\n", "\n", "  static void assertNodeNotInGraphErrorMessage(Throwable throwable) {\n", "    assertThat(throwable.getMessage()).startsWith(NODE_STRING);\n", "    assertThat(throwable.getMessage()).contains(ERROR_ELEMENT_NOT_IN_GRAPH);\n", "  }\n", "\n", "  static void assertEdgeNotInGraphErrorMessage(Throwable throwable) {\n", "    assertThat(throwable.getMessage()).startsWith(EDGE_STRING);\n", "    assertThat(throwable.getMessage()).contains(ERROR_ELEMENT_NOT_IN_GRAPH);\n", "  }\n", "}\n"]}, "removed": {}, "added_lines": {"1": [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 58, 59, 60, 61, 62, 63, 64, 65, 66, 67, 68, 69, 70, 71, 72, 73, 74, 75, 76, 77, 78, 79, 80, 81, 82, 83, 84, 85, 86, 87, 88, 89, 90, 91, 92, 93, 94, 95, 96, 97, 98, 99, 100, 101, 102, 103, 104, 105, 106, 107, 108, 109, 110, 111, 112, 113, 114, 115, 116, 117, 118, 119, 120, 121, 122, 123, 124, 125, 126, 127, 128, 129, 130, 131, 132, 133, 134, 135, 136, 137, 138, 139, 140, 141, 142, 143, 144, 145, 146, 147, 148, 149, 150, 151, 152, 153, 154, 155, 156, 157, 158, 159, 160, 161, 162, 163, 164, 165, 166, 167, 168, 169, 170, 171, 172, 173, 174, 175, 176, 177, 178, 179, 180, 181, 182, 183, 184, 185, 186, 187, 188, 189, 190, 191, 192, 193, 194, 195, 196, 197, 198, 199, 200, 201, 202, 203, 204, 205, 206, 207, 208, 209, 210, 211, 212, 213, 214, 215, 216, 217, 218, 219, 220, 221, 222, 223, 224, 225, 226, 227, 228, 229, 230, 231, 232, 233, 234, 235, 236, 237, 238, 239, 240, 241, 242, 243, 244, 245, 246, 247, 248, 249, 250, 251, 252, 253, 254, 255, 256, 257, 258, 259, 260, 261, 262, 263, 264, 265, 266, 267, 268, 269, 270, 271, 272, 273, 274, 275, 276, 277, 278, 279, 280, 281, 282, 283, 284, 285, 286, 287, 288, 289, 290, 291, 292, 293, 294, 295, 296, 297, 298, 299, 300, 301, 302, 303, 304, 305, 306, 307, 308, 309, 310, 311, 312, 313, 314, 315, 316, 317, 318, 319, 320, 321, 322, 323, 324, 325, 326, 327, 328, 329, 330, 331, 332, 333, 334, 335, 336, 337, 338, 339, 340, 341, 342, 343, 344, 345, 346, 347, 348, 349, 350, 351, 352, 353, 354, 355, 356, 357, 358, 359, 360, 361, 362, 363, 364, 365, 366, 367, 368, 369, 370, 371, 372, 373, 374, 375, 376, 377, 378, 379, 380, 381, 382, 383, 384, 385, 386, 387, 388, 389, 390, 391, 392, 393, 394, 395, 396, 397, 398, 399, 400, 401, 402, 403, 404, 405, 406, 407, 408, 409, 410, 411, 412, 413, 414, 415, 416, 417, 418, 419, 420, 421, 422, 423, 424, 425, 426, 427, 428, 429, 430, 431, 432, 433, 434, 435, 436, 437, 438, 439, 440, 441, 442, 443, 444, 445, 446, 447, 448, 449, 450, 451, 452, 453, 454, 455, 456, 457, 458, 459, 460, 461, 462, 463, 464, 465, 466, 467, 468, 469, 470, 471, 472, 473, 474, 475, 476, 477, 478, 479, 480, 481, 482, 483, 484, 485, 486, 487, 488, 489, 490, 491, 492, 493, 494, 495, 496, 497, 498, 499, 500, 501, 502, 503, 504, 505, 506, 507, 508, 509, 510, 511, 512, 513, 514, 515, 516, 517, 518, 519, 520, 521, 522, 523, 524, 525, 526, 527, 528, 529, 530, 531, 532, 533, 534, 535, 536, 537, 538, 539, 540, 541, 542, 543, 544, 545, 546, 547, 548, 549, 550, 551, 552, 553, 554, 555, 556, 557, 558, 559, 560, 561, 562, 563, 564, 565, 566, 567, 568, 569, 570, 571, 572, 573, 574, 575, 576, 577, 578, 579, 580, 581, 582, 583, 584, 585, 586, 587, 588, 589, 590, 591, 592, 593, 594, 595, 596, 597, 598, 599, 600, 601, 602, 603, 604, 605, 606, 607, 608, 609, 610, 611, 612, 613, 614, 615, 616, 617, 618, 619, 620, 621, 622, 623, 624, 625, 626, 627, 628, 629, 630, 631, 632, 633, 634, 635, 636, 637, 638]}, "removed_lines": {}}, {"6": "guava-tests/test/com/google/common/graph/AbstractUndirectedGraphTest.java", "added": {"2": ["    addEdge(N1, N2);\n", "    addEdge(N1, N2);\n", "    addEdge(N1, N2);\n", "    addEdge(N1, N2);\n"], "3": ["    assertTrue(addEdge(N1, N2));\n", "    addEdge(N1, N2);\n", "    assertFalse(addEdge(N2, N1));\n", "    addEdge(N1, N2);\n", "    assertThat(graph.successors(N1)).containsExactly(N2);\n", "    assertThat(graph.predecessors(N2)).containsExactly(N1);\n", "    assertTrue(graph.removeEdge(N1, N2));\n", "    assertThat(graph.successors(N1)).isEmpty();\n", "    assertThat(graph.predecessors(N2)).isEmpty();\n"]}, "removed": {"1": ["import static org.junit.Assert.fail;\n", "import com.google.common.collect.ImmutableSet;\n"], "2": ["      new EqualsTester()\n", "          .addEqualityGroup(graph.inEdges(node), graph.outEdges(node), graph.incidentEdges(node))\n", "          .testEquals();\n", "\n", "      for (Integer adjacentNode : graph.adjacentNodes(node)) {\n", "        assertThat(graph.edgesConnecting(node, adjacentNode))\n", "            .containsExactlyElementsIn(graph.edgesConnecting(adjacentNode, node));\n", "      }\n", "  @Test\n", "  public void edgesConnecting_oneEdge() {\n", "    addEdge(E12, N1, N2);\n", "    assertThat(graph.edgesConnecting(N1, N2)).containsExactly(E12);\n", "    assertThat(graph.edgesConnecting(N2, N1)).containsExactly(E12);\n", "  }\n", "\n", "  @Test\n", "  public void inEdges_oneEdge() {\n", "    addEdge(E12, N1, N2);\n", "    assertThat(graph.inEdges(N2)).containsExactly(E12);\n", "    assertThat(graph.inEdges(N1)).containsExactly(E12);\n", "  }\n", "\n", "  @Test\n", "  public void outEdges_oneEdge() {\n", "    addEdge(E12, N1, N2);\n", "    assertThat(graph.outEdges(N2)).containsExactly(E12);\n", "    assertThat(graph.outEdges(N1)).containsExactly(E12);\n", "  }\n", "\n", "    addEdge(E12, N1, N2);\n", "    addEdge(E12, N1, N2);\n", "    addEdge(E12, N1, N2);\n", "    addEdge(E12, N1, N2);\n"], "3": ["    assertTrue(addEdge(E12, N1, N2));\n", "    assertThat(graph.edges()).contains(E12);\n", "    assertThat(graph.edgesConnecting(N1, N2)).containsExactly(E12);\n", "    assertThat(graph.edgesConnecting(N2, N1)).containsExactly(E12);\n", "    addEdge(E12, N1, N2);\n", "    ImmutableSet<String> edges = ImmutableSet.copyOf(graph.edges());\n", "    assertFalse(addEdge(E12, N1, N2));\n", "    assertThat(graph.edges()).containsExactlyElementsIn(edges);\n", "    assertFalse(addEdge(E12, N2, N1));\n", "    assertThat(graph.edges()).containsExactlyElementsIn(edges);\n", "  }\n", "\n", "  @Test\n", "  public void addEdge_existingEdgeBetweenDifferentNodes() {\n", "    addEdge(E12, N1, N2);\n", "    try {\n", "      // Edge between totally different nodes\n", "      addEdge(E12, N4, N5);\n", "      fail(ERROR_ADDED_EXISTING_EDGE);\n", "    } catch (IllegalArgumentException e) {\n", "      assertThat(e.getMessage()).contains(ERROR_REUSE_EDGE);\n", "    }\n", "  }\n", "\n", "  @Test\n", "  public void addEdge_parallelEdge() {\n", "    addEdge(E12, N1, N2);\n", "    try {\n", "      addEdge(EDGE_NOT_IN_GRAPH, N1, N2);\n", "      fail(ERROR_ADDED_PARALLEL_EDGE);\n", "    } catch (IllegalArgumentException e) {\n", "      assertThat(e.getMessage()).contains(ERROR_PARALLEL_EDGE);\n", "    }\n", "    try {\n", "      addEdge(EDGE_NOT_IN_GRAPH, N2, N1);\n", "      fail(ERROR_ADDED_PARALLEL_EDGE);\n", "    } catch (IllegalArgumentException e) {\n", "      assertThat(e.getMessage()).contains(ERROR_PARALLEL_EDGE);\n", "    }\n", "    addEdge(E12, N1, N2);\n", "    assertTrue(graph.removeEdge(E12));\n", "    assertThat(graph.edges()).doesNotContain(E12);\n", "    assertThat(graph.edgesConnecting(N1, N2)).isEmpty();\n", "    assertThat(graph.edgesConnecting(N2, N1)).isEmpty();\n"]}, "added_lines": {"2": [50, 57, 64, 71], "3": [84, 89, 90, 95, 96, 97, 98, 99, 100]}, "removed_lines": {"1": [23, 25], "2": [43, 44, 45, 50, 51, 52, 53, 54, 58, 59, 60, 61, 62, 63, 64, 65, 66, 67, 68, 69, 70, 71, 72, 73, 74, 75, 76, 77, 78, 81, 88, 95, 102], "3": [115, 116, 117, 118, 123, 124, 125, 126, 127, 128, 129, 130, 131, 132, 133, 134, 135, 136, 137, 138, 139, 140, 141, 142, 143, 144, 145, 146, 147, 148, 149, 150, 151, 152, 153, 154, 155, 156, 157, 162, 163, 164, 165, 166]}}, {"7": "guava-tests/test/com/google/common/graph/AbstractUndirectedNetworkTest.java", "added": {"1": ["/*\n", " * Copyright (C) 2014 The Guava Authors\n", " *\n", " * Licensed under the Apache License, Version 2.0 (the \"License\");\n", " * you may not use this file except in compliance with the License.\n", " * You may obtain a copy of the License at\n", " *\n", " * http://www.apache.org/licenses/LICENSE-2.0\n", " *\n", " * Unless required by applicable law or agreed to in writing, software\n", " * distributed under the License is distributed on an \"AS IS\" BASIS,\n", " * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n", " * See the License for the specific language governing permissions and\n", " * limitations under the License.\n", " */\n", "\n", "package com.google.common.graph;\n", "\n", "import static com.google.common.truth.Truth.assertThat;\n", "import static org.junit.Assert.assertEquals;\n", "import static org.junit.Assert.assertFalse;\n", "import static org.junit.Assert.assertTrue;\n", "import static org.junit.Assert.fail;\n", "\n", "import com.google.common.collect.ImmutableSet;\n", "import com.google.common.testing.EqualsTester;\n", "\n", "import org.junit.After;\n", "import org.junit.Test;\n", "\n", "/**\n", " * Abstract base class for testing undirected implementations of the {@link Network} interface.\n", " *\n", " * <p>This class is responsible for testing that an undirected implementation of {@link Network}\n", " * is correctly handling undirected edges.  Implementation-dependent test cases are left to\n", " * subclasses. Test cases that do not require the graph to be undirected are found in superclasses.\n", " */\n", "public abstract class AbstractUndirectedNetworkTest extends AbstractNetworkTest {\n", "\n", "  @After\n", "  public void validateUndirectedEdges() {\n", "    for (Integer node : graph.nodes()) {\n", "      new EqualsTester()\n", "          .addEqualityGroup(graph.inEdges(node), graph.outEdges(node), graph.incidentEdges(node))\n", "          .testEquals();\n", "      new EqualsTester()\n", "          .addEqualityGroup(graph.predecessors(node), graph.successors(node),\n", "              graph.adjacentNodes(node))\n", "          .testEquals();\n", "\n", "      for (Integer adjacentNode : graph.adjacentNodes(node)) {\n", "        assertThat(graph.edgesConnecting(node, adjacentNode))\n", "            .containsExactlyElementsIn(graph.edgesConnecting(adjacentNode, node));\n", "      }\n", "    }\n", "  }\n", "\n", "  @Test\n", "  public void edgesConnecting_oneEdge() {\n", "    addEdge(E12, N1, N2);\n", "    assertThat(graph.edgesConnecting(N1, N2)).containsExactly(E12);\n", "    assertThat(graph.edgesConnecting(N2, N1)).containsExactly(E12);\n", "  }\n", "\n", "  @Test\n", "  public void inEdges_oneEdge() {\n", "    addEdge(E12, N1, N2);\n", "    assertThat(graph.inEdges(N2)).containsExactly(E12);\n", "    assertThat(graph.inEdges(N1)).containsExactly(E12);\n", "  }\n", "\n", "  @Test\n", "  public void outEdges_oneEdge() {\n", "    addEdge(E12, N1, N2);\n", "    assertThat(graph.outEdges(N2)).containsExactly(E12);\n", "    assertThat(graph.outEdges(N1)).containsExactly(E12);\n", "  }\n", "\n", "  @Test\n", "  public void predecessors_oneEdge() {\n", "    addEdge(E12, N1, N2);\n", "    assertThat(graph.predecessors(N2)).containsExactly(N1);\n", "    assertThat(graph.predecessors(N1)).containsExactly(N2);\n", "  }\n", "\n", "  @Test\n", "  public void successors_oneEdge() {\n", "    addEdge(E12, N1, N2);\n", "    assertThat(graph.successors(N1)).containsExactly(N2);\n", "    assertThat(graph.successors(N2)).containsExactly(N1);\n", "  }\n", "\n", "  @Test\n", "  public void inDegree_oneEdge() {\n", "    addEdge(E12, N1, N2);\n", "    assertEquals(1, graph.inDegree(N2));\n", "    assertEquals(1, graph.inDegree(N1));\n", "  }\n", "\n", "  @Test\n", "  public void outDegree_oneEdge() {\n", "    addEdge(E12, N1, N2);\n", "    assertEquals(1, graph.outDegree(N1));\n", "    assertEquals(1, graph.outDegree(N2));\n", "  }\n", "\n", "  // Element Mutation\n", "\n", "  @Test\n", "  public void addEdge_existingNodes() {\n", "    // Adding nodes initially for safety (insulating from possible future\n", "    // modifications to proxy methods)\n", "    addNode(N1);\n", "    addNode(N2);\n", "    assertTrue(addEdge(E12, N1, N2));\n", "    assertThat(graph.edges()).contains(E12);\n", "    assertThat(graph.edgesConnecting(N1, N2)).containsExactly(E12);\n", "    assertThat(graph.edgesConnecting(N2, N1)).containsExactly(E12);\n", "  }\n", "\n", "  @Test\n", "  public void addEdge_existingEdgeBetweenSameNodes() {\n", "    addEdge(E12, N1, N2);\n", "    ImmutableSet<String> edges = ImmutableSet.copyOf(graph.edges());\n", "    assertFalse(addEdge(E12, N1, N2));\n", "    assertThat(graph.edges()).containsExactlyElementsIn(edges);\n", "    assertFalse(addEdge(E12, N2, N1));\n", "    assertThat(graph.edges()).containsExactlyElementsIn(edges);\n", "  }\n", "\n", "  @Test\n", "  public void addEdge_existingEdgeBetweenDifferentNodes() {\n", "    addEdge(E12, N1, N2);\n", "    try {\n", "      // Edge between totally different nodes\n", "      addEdge(E12, N4, N5);\n", "      fail(ERROR_ADDED_EXISTING_EDGE);\n", "    } catch (IllegalArgumentException e) {\n", "      assertThat(e.getMessage()).contains(ERROR_REUSE_EDGE);\n", "    }\n", "  }\n", "\n", "  @Test\n", "  public void addEdge_parallelEdge() {\n", "    addEdge(E12, N1, N2);\n", "    try {\n", "      addEdge(EDGE_NOT_IN_GRAPH, N1, N2);\n", "      fail(ERROR_ADDED_PARALLEL_EDGE);\n", "    } catch (IllegalArgumentException e) {\n", "      assertThat(e.getMessage()).contains(ERROR_PARALLEL_EDGE);\n", "    }\n", "    try {\n", "      addEdge(EDGE_NOT_IN_GRAPH, N2, N1);\n", "      fail(ERROR_ADDED_PARALLEL_EDGE);\n", "    } catch (IllegalArgumentException e) {\n", "      assertThat(e.getMessage()).contains(ERROR_PARALLEL_EDGE);\n", "    }\n", "  }\n", "\n", "  @Test\n", "  public void removeEdge_existingEdge() {\n", "    addEdge(E12, N1, N2);\n", "    assertTrue(graph.removeEdge(E12));\n", "    assertThat(graph.edges()).doesNotContain(E12);\n", "    assertThat(graph.edgesConnecting(N1, N2)).isEmpty();\n", "    assertThat(graph.edgesConnecting(N2, N1)).isEmpty();\n", "  }\n", "}\n"]}, "removed": {}, "added_lines": {"1": [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 58, 59, 60, 61, 62, 63, 64, 65, 66, 67, 68, 69, 70, 71, 72, 73, 74, 75, 76, 77, 78, 79, 80, 81, 82, 83, 84, 85, 86, 87, 88, 89, 90, 91, 92, 93, 94, 95, 96, 97, 98, 99, 100, 101, 102, 103, 104, 105, 106, 107, 108, 109, 110, 111, 112, 113, 114, 115, 116, 117, 118, 119, 120, 121, 122, 123, 124, 125, 126, 127, 128, 129, 130, 131, 132, 133, 134, 135, 136, 137, 138, 139, 140, 141, 142, 143, 144, 145, 146, 147, 148, 149, 150, 151, 152, 153, 154, 155, 156, 157, 158, 159, 160, 161, 162, 163, 164, 165, 166, 167, 168]}, "removed_lines": {}}, {"8": "guava-tests/test/com/google/common/graph/ConfigurableDirectedGraphTest.java", "added": {"2": ["  public MutableGraph<Integer> createGraph() {\n", "    addEdge(N1, N1);\n", "    addEdge(N1, N2);\n", "    addEdge(N1, N1);\n", "    addEdge(N4, N1);\n", "    addEdge(N1, N1);\n", "    addEdge(N1, N2);\n", "    addEdge(N1, N1);\n", "    addEdge(N1, N2);\n", "    addEdge(N1, N1);\n", "    addEdge(N4, N1);\n", "    addEdge(N1, N1);\n", "    addEdge(N1, N2);\n", "    assertTrue(addEdge(N1, N1));\n", "    assertThat(graph.successors(N1)).containsExactly(N1);\n", "    assertThat(graph.predecessors(N1)).containsExactly(N1);\n", "    addEdge(N1, N1);\n", "    assertFalse(addEdge(N1, N1));\n", "    addEdge(N1, N1);\n", "    addEdge(N1, N1);\n", "    assertTrue(graph.removeEdge(N1, N1));\n", "    assertThat(graph.nodes()).containsExactly(N1);\n", "    assertThat(graph.successors(N1)).isEmpty();\n", "    MutableGraph<Integer> graphA = createGraph();\n", "    MutableGraph<Integer> graphB = createGraph();\n"]}, "removed": {"1": ["import static org.junit.Assert.fail;\n", "import com.google.common.collect.ImmutableSet;\n"], "2": ["  public Graph<Integer, String> createGraph() {\n", "  @Test\n", "  public void edges_selfLoop() {\n", "    addEdge(E11, N1, N1);\n", "    assertThat(graph.edges()).containsExactly(E11);\n", "  }\n", "\n", "  @Test\n", "  public void incidentEdges_selfLoop() {\n", "    addEdge(E11, N1, N1);\n", "    assertThat(graph.incidentEdges(N1)).containsExactly(E11);\n", "  }\n", "\n", "  @Test\n", "  public void incidentNodes_selfLoop() {\n", "    addEdge(E11, N1, N1);\n", "    assertThat(graph.incidentNodes(E11)).containsExactly(N1);\n", "  }\n", "\n", "    addEdge(E11, N1, N1);\n", "    addEdge(E12, N1, N2);\n", "  @Test\n", "  public void adjacentEdges_selfLoop() {\n", "    // An edge is never adjacent to itself\n", "    addEdge(E11, N1, N1);\n", "    assertThat(graph.adjacentEdges(E11)).isEmpty();\n", "    addEdge(E12, N1, N2);\n", "    assertThat(graph.adjacentEdges(E11)).containsExactly(E12);\n", "  }\n", "\n", "  @Test\n", "  public void edgesConnecting_selfLoop() {\n", "    addEdge(E11, N1, N1);\n", "    assertThat(graph.edgesConnecting(N1, N1)).containsExactly(E11);\n", "    addEdge(E12, N1, N2);\n", "    assertThat(graph.edgesConnecting(N1, N2)).containsExactly(E12);\n", "    assertThat(graph.edgesConnecting(N1, N1)).containsExactly(E11);\n", "  }\n", "\n", "  @Test\n", "  public void inEdges_selfLoop() {\n", "    addEdge(E11, N1, N1);\n", "    assertThat(graph.inEdges(N1)).containsExactly(E11);\n", "    addEdge(E41, N4, N1);\n", "    assertThat(graph.inEdges(N1)).containsExactly(E11, E41);\n", "  }\n", "\n", "  @Test\n", "  public void outEdges_selfLoop() {\n", "    addEdge(E11, N1, N1);\n", "    assertThat(graph.outEdges(N1)).containsExactly(E11);\n", "    addEdge(E12, N1, N2);\n", "    assertThat(graph.outEdges(N1)).containsExactly(E11, E12);\n", "  }\n", "\n", "    addEdge(E11, N1, N1);\n", "    addEdge(E41, N4, N1);\n", "    addEdge(E11, N1, N1);\n", "    addEdge(E12, N1, N2);\n", "    addEdge(E11, N1, N1);\n", "    addEdge(E12, N1, N2);\n", "    addEdge(E11, N1, N1);\n", "    addEdge(E41, N4, N1);\n", "    addEdge(E11, N1, N1);\n", "    addEdge(E12, N1, N2);\n", "  @Test\n", "  public void source_selfLoop() {\n", "    addEdge(E11, N1, N1);\n", "    assertEquals(N1, graph.source(E11));\n", "  }\n", "\n", "  @Test\n", "  public void target_selfLoop() {\n", "    addEdge(E11, N1, N1);\n", "    assertEquals(N1, graph.target(E11));\n", "  }\n", "\n", "    assertTrue(addEdge(E11, N1, N1));\n", "    assertThat(graph.edges()).contains(E11);\n", "    assertThat(graph.edgesConnecting(N1, N1)).containsExactly(E11);\n", "    addEdge(E11, N1, N1);\n", "    ImmutableSet<String> edges = ImmutableSet.copyOf(graph.edges());\n", "    assertFalse(addEdge(E11, N1, N1));\n", "    assertThat(graph.edges()).containsExactlyElementsIn(edges);\n", "  }\n", "\n", "  @Test\n", "  public void addEdge_existingEdgeBetweenDifferentNodes_selfLoops() {\n", "    addEdge(E11, N1, N1);\n", "    try {\n", "      addEdge(E11, N1, N2);\n", "      fail(\"Reusing an existing self-loop edge to connect different nodes succeeded\");\n", "    } catch (IllegalArgumentException e) {\n", "      assertThat(e.getMessage()).contains(ERROR_REUSE_EDGE);\n", "    }\n", "    try {\n", "      addEdge(E11, N2, N2);\n", "      fail(\"Reusing an existing self-loop edge to make a different self-loop edge succeeded\");\n", "    } catch (IllegalArgumentException e) {\n", "      assertThat(e.getMessage()).contains(ERROR_REUSE_EDGE);\n", "    }\n", "    addEdge(E12, N1, N2);\n", "    try {\n", "      addEdge(E12, N1, N1);\n", "      fail(\"Reusing an existing edge to add a self-loop edge between different nodes succeeded\");\n", "    } catch (IllegalArgumentException e) {\n", "      assertThat(e.getMessage()).contains(ERROR_REUSE_EDGE);\n", "    }\n", "  }\n", "\n", "  @Test\n", "  public void addEdge_parallelSelfLoopEdge() {\n", "    addEdge(E11, N1, N1);\n", "    try {\n", "      addEdge(EDGE_NOT_IN_GRAPH, N1, N1);\n", "      fail(\"Adding a parallel self-loop edge succeeded\");\n", "    } catch (IllegalArgumentException e) {\n", "      assertThat(e.getMessage()).contains(ERROR_PARALLEL_EDGE);\n", "    }\n", "    addEdge(E11, N1, N1);\n", "    assertThat(graph.edges()).doesNotContain(E11);\n", "    addEdge(E11, N1, N1);\n", "    assertTrue(graph.removeEdge(E11));\n", "    assertThat(graph.edges()).doesNotContain(E11);\n", "    assertThat(graph.edgesConnecting(N1, N1)).isEmpty();\n", "    Graph<Integer, String> graphA = createGraph();\n", "    Graph<Integer, String> graphB = createGraph();\n"]}, "added_lines": {"2": [37, 43, 44, 50, 52, 58, 60, 66, 68, 74, 76, 82, 84, 91, 92, 93, 98, 99, 105, 112, 113, 114, 115, 121, 123]}, "removed_lines": {"1": [23, 25], "2": [39, 43, 44, 45, 46, 47, 48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 58, 59, 60, 63, 64, 68, 69, 70, 71, 72, 73, 74, 75, 76, 77, 78, 79, 80, 81, 82, 83, 84, 85, 86, 87, 88, 89, 90, 91, 92, 93, 94, 95, 96, 97, 98, 99, 100, 101, 104, 106, 112, 114, 120, 122, 128, 130, 136, 138, 142, 143, 144, 145, 146, 147, 148, 149, 150, 151, 152, 153, 157, 158, 159, 164, 165, 166, 167, 168, 169, 170, 171, 172, 173, 174, 175, 176, 177, 178, 179, 180, 181, 182, 183, 184, 185, 186, 187, 188, 189, 190, 191, 192, 193, 194, 195, 196, 197, 198, 199, 200, 201, 202, 208, 211, 216, 217, 218, 219, 225, 227]}}, {"9": "guava-tests/test/com/google/common/graph/ConfigurableDirectedMultiNetworkTest.java", "added": {"1": [" * Tests for a directed {@link ConfigurableNetwork} allowing parallel edges.\n", "public class ConfigurableDirectedMultiNetworkTest extends ConfigurableDirectedNetworkTest {\n", "  public MutableNetwork<Integer, String> createGraph() {\n", "    return NetworkBuilder.directed().allowsParallelEdges(true).build();\n"]}, "removed": {"1": [" * Tests for a directed {@link ConfigurableGraph} allowing parallel edges.\n", "public class ConfigurableDirectedMultigraphTest extends ConfigurableDirectedGraphTest {\n", "  public Graph<Integer, String> createGraph() {\n", "    return GraphBuilder.directed().allowsParallelEdges(true).build();\n"]}, "added_lines": {"1": [27, 30, 32, 33]}, "removed_lines": {"1": [27, 30, 32, 33]}}, {"10": "guava-tests/test/com/google/common/graph/ConfigurableDirectedNetworkTest.java", "added": {"1": ["/*\n", " * Copyright (C) 2014 The Guava Authors\n", " *\n", " * Licensed under the Apache License, Version 2.0 (the \"License\");\n", " * you may not use this file except in compliance with the License.\n", " * You may obtain a copy of the License at\n", " *\n", " * http://www.apache.org/licenses/LICENSE-2.0\n", " *\n", " * Unless required by applicable law or agreed to in writing, software\n", " * distributed under the License is distributed on an \"AS IS\" BASIS,\n", " * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n", " * See the License for the specific language governing permissions and\n", " * limitations under the License.\n", " */\n", "\n", "package com.google.common.graph;\n", "\n", "import static com.google.common.truth.Truth.assertThat;\n", "import static org.junit.Assert.assertEquals;\n", "import static org.junit.Assert.assertFalse;\n", "import static org.junit.Assert.assertTrue;\n", "import static org.junit.Assert.fail;\n", "\n", "import com.google.common.collect.ImmutableSet;\n", "import com.google.common.testing.EqualsTester;\n", "\n", "import org.junit.Test;\n", "import org.junit.runner.RunWith;\n", "import org.junit.runners.JUnit4;\n", "\n", "/**\n", " * Tests for a directed {@link ConfigurableNetwork} with default graph properties.\n", " */\n", "@RunWith(JUnit4.class)\n", "public class ConfigurableDirectedNetworkTest extends ConfigurableSimpleDirectedNetworkTest {\n", "\n", "  @Override\n", "  public MutableNetwork<Integer, String> createGraph() {\n", "    return NetworkBuilder.directed().build();\n", "  }\n", "\n", "  @Test\n", "  public void edges_selfLoop() {\n", "    addEdge(E11, N1, N1);\n", "    assertThat(graph.edges()).containsExactly(E11);\n", "  }\n", "\n", "  @Test\n", "  public void incidentEdges_selfLoop() {\n", "    addEdge(E11, N1, N1);\n", "    assertThat(graph.incidentEdges(N1)).containsExactly(E11);\n", "  }\n", "\n", "  @Test\n", "  public void incidentNodes_selfLoop() {\n", "    addEdge(E11, N1, N1);\n", "    assertThat(graph.incidentNodes(E11)).containsExactly(N1);\n", "  }\n", "\n", "  @Test\n", "  public void adjacentNodes_selfLoop() {\n", "    addEdge(E11, N1, N1);\n", "    addEdge(E12, N1, N2);\n", "    assertThat(graph.adjacentNodes(N1)).containsExactly(N1, N2);\n", "  }\n", "\n", "  @Test\n", "  public void adjacentEdges_selfLoop() {\n", "    // An edge is never adjacent to itself\n", "    addEdge(E11, N1, N1);\n", "    assertThat(graph.adjacentEdges(E11)).isEmpty();\n", "    addEdge(E12, N1, N2);\n", "    assertThat(graph.adjacentEdges(E11)).containsExactly(E12);\n", "  }\n", "\n", "  @Test\n", "  public void edgesConnecting_selfLoop() {\n", "    addEdge(E11, N1, N1);\n", "    assertThat(graph.edgesConnecting(N1, N1)).containsExactly(E11);\n", "    addEdge(E12, N1, N2);\n", "    assertThat(graph.edgesConnecting(N1, N2)).containsExactly(E12);\n", "    assertThat(graph.edgesConnecting(N1, N1)).containsExactly(E11);\n", "  }\n", "\n", "  @Test\n", "  public void inEdges_selfLoop() {\n", "    addEdge(E11, N1, N1);\n", "    assertThat(graph.inEdges(N1)).containsExactly(E11);\n", "    addEdge(E41, N4, N1);\n", "    assertThat(graph.inEdges(N1)).containsExactly(E11, E41);\n", "  }\n", "\n", "  @Test\n", "  public void outEdges_selfLoop() {\n", "    addEdge(E11, N1, N1);\n", "    assertThat(graph.outEdges(N1)).containsExactly(E11);\n", "    addEdge(E12, N1, N2);\n", "    assertThat(graph.outEdges(N1)).containsExactly(E11, E12);\n", "  }\n", "\n", "  @Test\n", "  public void predecessors_selfLoop() {\n", "    addEdge(E11, N1, N1);\n", "    assertThat(graph.predecessors(N1)).containsExactly(N1);\n", "    addEdge(E41, N4, N1);\n", "    assertThat(graph.predecessors(N1)).containsExactly(N1, N4);\n", "  }\n", "\n", "  @Test\n", "  public void successors_selfLoop() {\n", "    addEdge(E11, N1, N1);\n", "    assertThat(graph.successors(N1)).containsExactly(N1);\n", "    addEdge(E12, N1, N2);\n", "    assertThat(graph.successors(N1)).containsExactly(N1, N2);\n", "  }\n", "\n", "  @Test\n", "  public void degree_selfLoop() {\n", "    addEdge(E11, N1, N1);\n", "    assertEquals(1, graph.degree(N1));\n", "    addEdge(E12, N1, N2);\n", "    assertEquals(2, graph.degree(N1));\n", "  }\n", "\n", "  @Test\n", "  public void inDegree_selfLoop() {\n", "    addEdge(E11, N1, N1);\n", "    assertEquals(1, graph.inDegree(N1));\n", "    addEdge(E41, N4, N1);\n", "    assertEquals(2, graph.inDegree(N1));\n", "  }\n", "\n", "  @Test\n", "  public void outDegree_selfLoop() {\n", "    addEdge(E11, N1, N1);\n", "    assertEquals(1, graph.outDegree(N1));\n", "    addEdge(E12, N1, N2);\n", "    assertEquals(2, graph.outDegree(N1));\n", "  }\n", "\n", "  @Test\n", "  public void source_selfLoop() {\n", "    addEdge(E11, N1, N1);\n", "    assertEquals(N1, graph.source(E11));\n", "  }\n", "\n", "  @Test\n", "  public void target_selfLoop() {\n", "    addEdge(E11, N1, N1);\n", "    assertEquals(N1, graph.target(E11));\n", "  }\n", "\n", "  @Override\n", "  @Test\n", "  public void addEdge_selfLoop() {\n", "    assertTrue(addEdge(E11, N1, N1));\n", "    assertThat(graph.edges()).contains(E11);\n", "    assertThat(graph.edgesConnecting(N1, N1)).containsExactly(E11);\n", "  }\n", "\n", "  @Test\n", "  public void addEdge_existingSelfLoopEdgeBetweenSameNodes() {\n", "    addEdge(E11, N1, N1);\n", "    ImmutableSet<String> edges = ImmutableSet.copyOf(graph.edges());\n", "    assertFalse(addEdge(E11, N1, N1));\n", "    assertThat(graph.edges()).containsExactlyElementsIn(edges);\n", "  }\n", "\n", "  @Test\n", "  public void addEdge_existingEdgeBetweenDifferentNodes_selfLoops() {\n", "    addEdge(E11, N1, N1);\n", "    try {\n", "      addEdge(E11, N1, N2);\n", "      fail(\"Reusing an existing self-loop edge to connect different nodes succeeded\");\n", "    } catch (IllegalArgumentException e) {\n", "      assertThat(e.getMessage()).contains(ERROR_REUSE_EDGE);\n", "    }\n", "    try {\n", "      addEdge(E11, N2, N2);\n", "      fail(\"Reusing an existing self-loop edge to make a different self-loop edge succeeded\");\n", "    } catch (IllegalArgumentException e) {\n", "      assertThat(e.getMessage()).contains(ERROR_REUSE_EDGE);\n", "    }\n", "    addEdge(E12, N1, N2);\n", "    try {\n", "      addEdge(E12, N1, N1);\n", "      fail(\"Reusing an existing edge to add a self-loop edge between different nodes succeeded\");\n", "    } catch (IllegalArgumentException e) {\n", "      assertThat(e.getMessage()).contains(ERROR_REUSE_EDGE);\n", "    }\n", "  }\n", "\n", "  @Test\n", "  public void addEdge_parallelSelfLoopEdge() {\n", "    addEdge(E11, N1, N1);\n", "    try {\n", "      addEdge(EDGE_NOT_IN_GRAPH, N1, N1);\n", "      fail(\"Adding a parallel self-loop edge succeeded\");\n", "    } catch (IllegalArgumentException e) {\n", "      assertThat(e.getMessage()).contains(ERROR_PARALLEL_EDGE);\n", "    }\n", "  }\n", "\n", "  @Test\n", "  public void removeNode_existingNodeWithSelfLoopEdge() {\n", "    addNode(N1);\n", "    addEdge(E11, N1, N1);\n", "    assertTrue(graph.removeNode(N1));\n", "    assertThat(graph.nodes()).isEmpty();\n", "    assertThat(graph.edges()).doesNotContain(E11);\n", "  }\n", "\n", "  @Test\n", "  public void removeEdge_existingSelfLoopEdge() {\n", "    addEdge(E11, N1, N1);\n", "    assertTrue(graph.removeEdge(E11));\n", "    assertThat(graph.edges()).doesNotContain(E11);\n", "    assertThat(graph.edgesConnecting(N1, N1)).isEmpty();\n", "  }\n", "\n", "  // TODO(kak): Can't we ditch this and just use PackageSanityTests?\n", "  @Test\n", "  public void testEquals() {\n", "    MutableNetwork<Integer, String> graphA = createGraph();\n", "    graphA.addNode(N1);\n", "    MutableNetwork<Integer, String> graphB = createGraph();\n", "    graphA.addNode(N2);\n", "\n", "    new EqualsTester()\n", "        .addEqualityGroup(graphA)\n", "        .addEqualityGroup(graphB)\n", "        .testEquals();\n", "  }\n", "}\n"]}, "removed": {}, "added_lines": {"1": [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 58, 59, 60, 61, 62, 63, 64, 65, 66, 67, 68, 69, 70, 71, 72, 73, 74, 75, 76, 77, 78, 79, 80, 81, 82, 83, 84, 85, 86, 87, 88, 89, 90, 91, 92, 93, 94, 95, 96, 97, 98, 99, 100, 101, 102, 103, 104, 105, 106, 107, 108, 109, 110, 111, 112, 113, 114, 115, 116, 117, 118, 119, 120, 121, 122, 123, 124, 125, 126, 127, 128, 129, 130, 131, 132, 133, 134, 135, 136, 137, 138, 139, 140, 141, 142, 143, 144, 145, 146, 147, 148, 149, 150, 151, 152, 153, 154, 155, 156, 157, 158, 159, 160, 161, 162, 163, 164, 165, 166, 167, 168, 169, 170, 171, 172, 173, 174, 175, 176, 177, 178, 179, 180, 181, 182, 183, 184, 185, 186, 187, 188, 189, 190, 191, 192, 193, 194, 195, 196, 197, 198, 199, 200, 201, 202, 203, 204, 205, 206, 207, 208, 209, 210, 211, 212, 213, 214, 215, 216, 217, 218, 219, 220, 221, 222, 223, 224, 225, 226, 227, 228, 229, 230, 231, 232, 233, 234, 235]}, "removed_lines": {}}, {"11": "guava-tests/test/com/google/common/graph/ConfigurableSimpleDirectedGraphTest.java", "added": {"1": ["  public MutableGraph<Integer> createGraph() {\n"], "3": ["      addEdge(N1, N2);\n"], "4": ["      addEdge(N1, N2);\n"], "5": ["      addEdge(N1, N2);\n"], "6": ["      addEdge(N1, N1);\n"], "7": ["    assertTrue(graph.addEdge(N1, N5));\n", "    assertTrue(graph.addEdge(N4, N1));\n", "    assertTrue(graph.addEdge(N2, N3));\n", "    assertThat(graph.successors(N1)).containsExactly(N5);\n", "    assertThat(graph.successors(N2)).containsExactly(N3);\n", "    assertThat(graph.successors(N3)).isEmpty();\n", "    assertThat(graph.successors(N4)).containsExactly(N1);\n", "    assertThat(graph.successors(N5)).isEmpty();\n"]}, "removed": {"1": ["  public Graph<Integer, String> createGraph() {\n"], "2": ["  @Override\n", "  @Test\n", "  public void edges_checkReturnedSetMutability() {\n", "    Set<String> edges = graph.edges();\n", "    try {\n", "      edges.add(E12);\n", "      fail(ERROR_MODIFIABLE_SET);\n", "    } catch (UnsupportedOperationException e) {\n", "      addEdge(E12, N1, N2);\n", "      assertThat(graph.edges()).containsExactlyElementsIn(edges);\n", "    }\n", "  }\n", "\n", "  @Override\n", "  @Test\n", "  public void incidentEdges_checkReturnedSetMutability() {\n", "    addNode(N1);\n", "    Set<String> incidentEdges = graph.incidentEdges(N1);\n", "    try {\n", "      incidentEdges.add(E12);\n", "      fail(ERROR_MODIFIABLE_SET);\n", "    } catch (UnsupportedOperationException e) {\n", "      addEdge(E12, N1, N2);\n", "      assertThat(graph.incidentEdges(N1)).containsExactlyElementsIn(incidentEdges);\n", "    }\n", "  }\n", "\n", "  @Override\n", "  @Test\n", "  public void incidentNodes_checkReturnedSetMutability() {\n", "    addEdge(E12, N1, N2);\n", "    Set<Integer> incidentNodes = graph.incidentNodes(E12);\n", "    try {\n", "      incidentNodes.add(N3);\n", "      fail(ERROR_MODIFIABLE_SET);\n", "    } catch (UnsupportedOperationException expected) {\n", "    }\n", "  }\n", "\n"], "3": ["      addEdge(E12, N1, N2);\n", "  @Override\n", "  @Test\n", "  public void adjacentEdges_checkReturnedSetMutability() {\n", "    addEdge(E12, N1, N2);\n", "    Set<String> adjacentEdges = graph.adjacentEdges(E12);\n", "    try {\n", "      adjacentEdges.add(E23);\n", "      fail(ERROR_MODIFIABLE_SET);\n", "    } catch (UnsupportedOperationException e) {\n", "      addEdge(E23, N2, N3);\n", "      assertThat(graph.adjacentEdges(E12)).containsExactlyElementsIn(adjacentEdges);\n", "    }\n", "  }\n", "\n", "  @Override\n", "  @Test\n", "  public void edgesConnecting_checkReturnedSetMutability() {\n", "    addNode(N1);\n", "    addNode(N2);\n", "    Set<String> edgesConnecting = graph.edgesConnecting(N1, N2);\n", "    try {\n", "      edgesConnecting.add(E23);\n", "      fail(ERROR_MODIFIABLE_SET);\n", "    } catch (UnsupportedOperationException e) {\n", "      addEdge(E12, N1, N2);\n", "      assertThat(graph.edgesConnecting(N1, N2)).containsExactlyElementsIn(edgesConnecting);\n", "    }\n", "  }\n", "\n", "  @Override\n", "  @Test\n", "  public void inEdges_checkReturnedSetMutability() {\n", "    addNode(N2);\n", "    Set<String> inEdges = graph.inEdges(N2);\n", "    try {\n", "      inEdges.add(E12);\n", "      fail(ERROR_MODIFIABLE_SET);\n", "    } catch (UnsupportedOperationException e) {\n", "      addEdge(E12, N1, N2);\n", "      assertThat(graph.inEdges(N2)).containsExactlyElementsIn(inEdges);\n", "    }\n", "  }\n", "\n", "  @Override\n", "  @Test\n", "  public void outEdges_checkReturnedSetMutability() {\n", "    addNode(N1);\n", "    Set<String> outEdges = graph.outEdges(N1);\n", "    try {\n", "      outEdges.add(E12);\n", "      fail(ERROR_MODIFIABLE_SET);\n", "    } catch (UnsupportedOperationException e) {\n", "      addEdge(E12, N1, N2);\n", "      assertThat(graph.outEdges(N1)).containsExactlyElementsIn(outEdges);\n", "    }\n", "  }\n", "\n"], "4": ["      addEdge(E12, N1, N2);\n"], "5": ["      addEdge(E12, N1, N2);\n"], "6": ["      addEdge(E11, N1, N1);\n"], "7": ["    assertTrue(graph.addEdge(E15, N1, N5));\n", "    assertTrue(graph.addEdge(E41, N4, N1));\n", "    assertTrue(graph.addEdge(E23, N2, N3));\n", "    assertThat(graph.edges()).containsExactly(E15, E41, E23).inOrder();\n", "    assertThat(graph.edgesConnecting(N1, N5)).containsExactly(E15);\n", "    assertThat(graph.edgesConnecting(N4, N1)).containsExactly(E41);\n", "    assertThat(graph.edgesConnecting(N2, N3)).containsExactly(E23);\n", "    // Direction of the added edge is correctly handled\n", "    assertThat(graph.edgesConnecting(N3, N2)).isEmpty();\n"]}, "added_lines": {"1": [37], "3": [63], "4": [77], "5": [91], "6": [101], "7": [118, 119, 120, 122, 123, 124, 125, 126]}, "removed_lines": {"1": [37], "2": [54, 55, 56, 57, 58, 59, 60, 61, 62, 63, 64, 65, 66, 67, 68, 69, 70, 71, 72, 73, 74, 75, 76, 77, 78, 79, 80, 81, 82, 83, 84, 85, 86, 87, 88, 89, 90, 91, 92], "3": [102, 107, 108, 109, 110, 111, 112, 113, 114, 115, 116, 117, 118, 119, 120, 121, 122, 123, 124, 125, 126, 127, 128, 129, 130, 131, 132, 133, 134, 135, 136, 137, 138, 139, 140, 141, 142, 143, 144, 145, 146, 147, 148, 149, 150, 151, 152, 153, 154, 155, 156, 157, 158, 159, 160, 161, 162, 163], "4": [173], "5": [187], "6": [197], "7": [214, 215, 216, 218, 219, 220, 221, 222, 223]}}, {"12": "guava-tests/test/com/google/common/graph/ConfigurableSimpleDirectedNetworkTest.java", "added": {"1": ["/*\n", " * Copyright (C) 2014 The Guava Authors\n", " *\n", " * Licensed under the Apache License, Version 2.0 (the \"License\");\n", " * you may not use this file except in compliance with the License.\n", " * You may obtain a copy of the License at\n", " *\n", " * http://www.apache.org/licenses/LICENSE-2.0\n", " *\n", " * Unless required by applicable law or agreed to in writing, software\n", " * distributed under the License is distributed on an \"AS IS\" BASIS,\n", " * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n", " * See the License for the specific language governing permissions and\n", " * limitations under the License.\n", " */\n", "\n", "package com.google.common.graph;\n", "\n", "import static com.google.common.truth.Truth.assertThat;\n", "import static org.junit.Assert.assertTrue;\n", "import static org.junit.Assert.fail;\n", "\n", "import org.junit.Test;\n", "import org.junit.runner.RunWith;\n", "import org.junit.runners.JUnit4;\n", "\n", "import java.util.Set;\n", "\n", "/**\n", " * Tests for a directed {@link ConfigurableNetwork}, creating a simple directed graph (parallel\n", " * and self-loop edges are not allowed).\n", " */\n", "@RunWith(JUnit4.class)\n", "public class ConfigurableSimpleDirectedNetworkTest extends AbstractDirectedNetworkTest {\n", "\n", "  @Override\n", "  public MutableNetwork<Integer, String> createGraph() {\n", "    return NetworkBuilder.directed().allowsSelfLoops(false).build();\n", "  }\n", "\n", "  @Override\n", "  @Test\n", "  public void nodes_checkReturnedSetMutability() {\n", "    Set<Integer> nodes = graph.nodes();\n", "    try {\n", "      nodes.add(N2);\n", "      fail(ERROR_MODIFIABLE_SET);\n", "    } catch (UnsupportedOperationException e) {\n", "      addNode(N1);\n", "      assertThat(graph.nodes()).containsExactlyElementsIn(nodes);\n", "    }\n", "  }\n", "\n", "  @Override\n", "  @Test\n", "  public void edges_checkReturnedSetMutability() {\n", "    Set<String> edges = graph.edges();\n", "    try {\n", "      edges.add(E12);\n", "      fail(ERROR_MODIFIABLE_SET);\n", "    } catch (UnsupportedOperationException e) {\n", "      addEdge(E12, N1, N2);\n", "      assertThat(graph.edges()).containsExactlyElementsIn(edges);\n", "    }\n", "  }\n", "\n", "  @Override\n", "  @Test\n", "  public void incidentEdges_checkReturnedSetMutability() {\n", "    addNode(N1);\n", "    Set<String> incidentEdges = graph.incidentEdges(N1);\n", "    try {\n", "      incidentEdges.add(E12);\n", "      fail(ERROR_MODIFIABLE_SET);\n", "    } catch (UnsupportedOperationException e) {\n", "      addEdge(E12, N1, N2);\n", "      assertThat(graph.incidentEdges(N1)).containsExactlyElementsIn(incidentEdges);\n", "    }\n", "  }\n", "\n", "  @Override\n", "  @Test\n", "  public void incidentNodes_checkReturnedSetMutability() {\n", "    addEdge(E12, N1, N2);\n", "    Set<Integer> incidentNodes = graph.incidentNodes(E12);\n", "    try {\n", "      incidentNodes.add(N3);\n", "      fail(ERROR_MODIFIABLE_SET);\n", "    } catch (UnsupportedOperationException expected) {\n", "    }\n", "  }\n", "\n", "  @Override\n", "  @Test\n", "  public void adjacentNodes_checkReturnedSetMutability() {\n", "    addNode(N1);\n", "    Set<Integer> adjacentNodes = graph.adjacentNodes(N1);\n", "    try {\n", "      adjacentNodes.add(N2);\n", "      fail(ERROR_MODIFIABLE_SET);\n", "    } catch (UnsupportedOperationException e) {\n", "      addEdge(E12, N1, N2);\n", "      assertThat(graph.adjacentNodes(N1)).containsExactlyElementsIn(adjacentNodes);\n", "    }\n", "  }\n", "\n", "  @Override\n", "  @Test\n", "  public void adjacentEdges_checkReturnedSetMutability() {\n", "    addEdge(E12, N1, N2);\n", "    Set<String> adjacentEdges = graph.adjacentEdges(E12);\n", "    try {\n", "      adjacentEdges.add(E23);\n", "      fail(ERROR_MODIFIABLE_SET);\n", "    } catch (UnsupportedOperationException e) {\n", "      addEdge(E23, N2, N3);\n", "      assertThat(graph.adjacentEdges(E12)).containsExactlyElementsIn(adjacentEdges);\n", "    }\n", "  }\n", "\n", "  @Override\n", "  @Test\n", "  public void edgesConnecting_checkReturnedSetMutability() {\n", "    addNode(N1);\n", "    addNode(N2);\n", "    Set<String> edgesConnecting = graph.edgesConnecting(N1, N2);\n", "    try {\n", "      edgesConnecting.add(E23);\n", "      fail(ERROR_MODIFIABLE_SET);\n", "    } catch (UnsupportedOperationException e) {\n", "      addEdge(E12, N1, N2);\n", "      assertThat(graph.edgesConnecting(N1, N2)).containsExactlyElementsIn(edgesConnecting);\n", "    }\n", "  }\n", "\n", "  @Override\n", "  @Test\n", "  public void inEdges_checkReturnedSetMutability() {\n", "    addNode(N2);\n", "    Set<String> inEdges = graph.inEdges(N2);\n", "    try {\n", "      inEdges.add(E12);\n", "      fail(ERROR_MODIFIABLE_SET);\n", "    } catch (UnsupportedOperationException e) {\n", "      addEdge(E12, N1, N2);\n", "      assertThat(graph.inEdges(N2)).containsExactlyElementsIn(inEdges);\n", "    }\n", "  }\n", "\n", "  @Override\n", "  @Test\n", "  public void outEdges_checkReturnedSetMutability() {\n", "    addNode(N1);\n", "    Set<String> outEdges = graph.outEdges(N1);\n", "    try {\n", "      outEdges.add(E12);\n", "      fail(ERROR_MODIFIABLE_SET);\n", "    } catch (UnsupportedOperationException e) {\n", "      addEdge(E12, N1, N2);\n", "      assertThat(graph.outEdges(N1)).containsExactlyElementsIn(outEdges);\n", "    }\n", "  }\n", "\n", "  @Override\n", "  @Test\n", "  public void predecessors_checkReturnedSetMutability() {\n", "    addNode(N2);\n", "    Set<Integer> predecessors = graph.predecessors(N2);\n", "    try {\n", "      predecessors.add(N1);\n", "      fail(ERROR_MODIFIABLE_SET);\n", "    } catch (UnsupportedOperationException e) {\n", "      addEdge(E12, N1, N2);\n", "      assertThat(graph.predecessors(N2)).containsExactlyElementsIn(predecessors);\n", "    }\n", "  }\n", "\n", "  @Override\n", "  @Test\n", "  public void successors_checkReturnedSetMutability() {\n", "    addNode(N1);\n", "    Set<Integer> successors = graph.successors(N1);\n", "    try {\n", "      successors.add(N2);\n", "      fail(ERROR_MODIFIABLE_SET);\n", "    } catch (UnsupportedOperationException e) {\n", "      addEdge(E12, N1, N2);\n", "      assertThat(successors).containsExactlyElementsIn(graph.successors(N1));\n", "    }\n", "  }\n", "\n", "  // Element Mutation\n", "\n", "  @Test\n", "  public void addEdge_selfLoop() {\n", "    try {\n", "      addEdge(E11, N1, N1);\n", "      fail(ERROR_ADDED_SELF_LOOP);\n", "    } catch (IllegalArgumentException e) {\n", "      assertThat(e.getMessage()).contains(ERROR_SELF_LOOP);\n", "    }\n", "  }\n", "\n", "  /**\n", "   * This test checks an implementation dependent feature. It tests that\n", "   * the method {@code addEdge} will silently add the missing nodes to the graph,\n", "   * then add the edge connecting them. We are not using the proxy methods here\n", "   * as we want to test {@code addEdge} when the end-points are not elements\n", "   * of the graph.\n", "   */\n", "  @Test\n", "  public void addEdge_nodesNotInGraph() {\n", "    graph.addNode(N1);\n", "    assertTrue(graph.addEdge(E15, N1, N5));\n", "    assertTrue(graph.addEdge(E41, N4, N1));\n", "    assertTrue(graph.addEdge(E23, N2, N3));\n", "    assertThat(graph.nodes()).containsExactly(N1, N5, N4, N2, N3).inOrder();\n", "    assertThat(graph.edges()).containsExactly(E15, E41, E23).inOrder();\n", "    assertThat(graph.edgesConnecting(N1, N5)).containsExactly(E15);\n", "    assertThat(graph.edgesConnecting(N4, N1)).containsExactly(E41);\n", "    assertThat(graph.edgesConnecting(N2, N3)).containsExactly(E23);\n", "    // Direction of the added edge is correctly handled\n", "    assertThat(graph.edgesConnecting(N3, N2)).isEmpty();\n", "  }\n", "}\n"]}, "removed": {}, "added_lines": {"1": [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 58, 59, 60, 61, 62, 63, 64, 65, 66, 67, 68, 69, 70, 71, 72, 73, 74, 75, 76, 77, 78, 79, 80, 81, 82, 83, 84, 85, 86, 87, 88, 89, 90, 91, 92, 93, 94, 95, 96, 97, 98, 99, 100, 101, 102, 103, 104, 105, 106, 107, 108, 109, 110, 111, 112, 113, 114, 115, 116, 117, 118, 119, 120, 121, 122, 123, 124, 125, 126, 127, 128, 129, 130, 131, 132, 133, 134, 135, 136, 137, 138, 139, 140, 141, 142, 143, 144, 145, 146, 147, 148, 149, 150, 151, 152, 153, 154, 155, 156, 157, 158, 159, 160, 161, 162, 163, 164, 165, 166, 167, 168, 169, 170, 171, 172, 173, 174, 175, 176, 177, 178, 179, 180, 181, 182, 183, 184, 185, 186, 187, 188, 189, 190, 191, 192, 193, 194, 195, 196, 197, 198, 199, 200, 201, 202, 203, 204, 205, 206, 207, 208, 209, 210, 211, 212, 213, 214, 215, 216, 217, 218, 219, 220, 221, 222, 223, 224, 225]}, "removed_lines": {}}, {"13": "guava-tests/test/com/google/common/graph/ConfigurableSimpleUndirectedGraphTest.java", "added": {"1": ["  public MutableGraph<Integer> createGraph() {\n"], "3": ["      addEdge(N1, N2);\n"], "4": ["      addEdge(N1, N2);\n"], "5": ["      addEdge(N1, N2);\n"], "6": ["      addEdge(N1, N1);\n"], "7": ["    assertTrue(graph.addEdge(N1, N5));\n", "    assertTrue(graph.addEdge(N4, N1));\n", "    assertTrue(graph.addEdge(N2, N3));\n", "    assertThat(graph.adjacentNodes(N1)).containsExactly(N4, N5);\n", "    assertThat(graph.adjacentNodes(N2)).containsExactly(N3);\n", "    assertThat(graph.adjacentNodes(N3)).containsExactly(N2);\n", "    assertThat(graph.adjacentNodes(N4)).containsExactly(N1);\n", "    assertThat(graph.adjacentNodes(N5)).containsExactly(N1);\n"]}, "removed": {"1": ["  public Graph<Integer, String> createGraph() {\n"], "2": ["  @Override\n", "  @Test\n", "  public void edges_checkReturnedSetMutability() {\n", "    Set<String> edges = graph.edges();\n", "    try {\n", "      edges.add(E12);\n", "      fail(ERROR_MODIFIABLE_SET);\n", "    } catch (UnsupportedOperationException e) {\n", "      addEdge(E12, N1, N2);\n", "      assertThat(graph.edges()).containsExactlyElementsIn(edges);\n", "    }\n", "  }\n", "\n", "  @Override\n", "  @Test\n", "  public void incidentEdges_checkReturnedSetMutability() {\n", "    addNode(N1);\n", "    Set<String> incidentEdges = graph.incidentEdges(N1);\n", "    try {\n", "      incidentEdges.add(E12);\n", "      fail(ERROR_MODIFIABLE_SET);\n", "    } catch (UnsupportedOperationException e) {\n", "      addEdge(E12, N1, N2);\n", "      assertThat(graph.incidentEdges(N1)).containsExactlyElementsIn(incidentEdges);\n", "    }\n", "  }\n", "\n", "  @Override\n", "  @Test\n", "  public void incidentNodes_checkReturnedSetMutability() {\n", "    addEdge(E12, N1, N2);\n", "    Set<Integer> incidentNodes = graph.incidentNodes(E12);\n", "    try {\n", "      incidentNodes.add(N3);\n", "      fail(ERROR_MODIFIABLE_SET);\n", "    } catch (UnsupportedOperationException expected) {\n", "    }\n", "  }\n", "\n"], "3": ["      addEdge(E12, N1, N2);\n", "  @Override\n", "  @Test\n", "  public void adjacentEdges_checkReturnedSetMutability() {\n", "    addEdge(E12, N1, N2);\n", "    Set<String> adjacentEdges = graph.adjacentEdges(E12);\n", "    try {\n", "      adjacentEdges.add(E23);\n", "      fail(ERROR_MODIFIABLE_SET);\n", "    } catch (UnsupportedOperationException e) {\n", "      addEdge(E23, N2, N3);\n", "      assertThat(graph.adjacentEdges(E12)).containsExactlyElementsIn(adjacentEdges);\n", "    }\n", "  }\n", "\n", "  @Override\n", "  @Test\n", "  public void edgesConnecting_checkReturnedSetMutability() {\n", "    addNode(N1);\n", "    addNode(N2);\n", "    Set<String> edgesConnecting = graph.edgesConnecting(N1, N2);\n", "    try {\n", "      edgesConnecting.add(E23);\n", "      fail(ERROR_MODIFIABLE_SET);\n", "    } catch (UnsupportedOperationException e) {\n", "      addEdge(E12, N1, N2);\n", "      assertThat(graph.edgesConnecting(N1, N2))\n", "          .containsExactlyElementsIn(edgesConnecting);\n", "    }\n", "  }\n", "\n", "  @Override\n", "  @Test\n", "  public void inEdges_checkReturnedSetMutability() {\n", "    addNode(N2);\n", "    Set<String> inEdges = graph.inEdges(N2);\n", "    try {\n", "      inEdges.add(E12);\n", "      fail(ERROR_MODIFIABLE_SET);\n", "    } catch (UnsupportedOperationException e) {\n", "      addEdge(E12, N1, N2);\n", "      assertThat(graph.inEdges(N2)).containsExactlyElementsIn(inEdges);\n", "    }\n", "  }\n", "\n", "  @Override\n", "  @Test\n", "  public void outEdges_checkReturnedSetMutability() {\n", "    addNode(N1);\n", "    Set<String> outEdges = graph.outEdges(N1);\n", "    try {\n", "      outEdges.add(E12);\n", "      fail(ERROR_MODIFIABLE_SET);\n", "    } catch (UnsupportedOperationException e) {\n", "      addEdge(E12, N1, N2);\n", "      assertThat(graph.outEdges(N1)).containsExactlyElementsIn(outEdges);\n", "    }\n", "  }\n", "\n"], "4": ["      addEdge(E12, N1, N2);\n"], "5": ["      addEdge(E12, N1, N2);\n"], "6": ["      addEdge(E11, N1, N1);\n"], "7": ["    assertTrue(graph.addEdge(E15, N1, N5));\n", "    assertTrue(graph.addEdge(E41, N4, N1));\n", "    assertTrue(graph.addEdge(E23, N2, N3));\n", "    assertThat(graph.edges()).containsExactly(E15, E41, E23).inOrder();\n", "    assertThat(graph.edgesConnecting(N1, N5)).containsExactly(E15);\n", "    assertThat(graph.edgesConnecting(N4, N1)).containsExactly(E41);\n", "    assertThat(graph.edgesConnecting(N2, N3)).containsExactly(E23);\n", "    assertThat(graph.edgesConnecting(N3, N2)).containsExactly(E23);\n"]}, "added_lines": {"1": [37], "3": [63], "4": [77], "5": [91], "6": [101], "7": [118, 119, 120, 122, 123, 124, 125, 126]}, "removed_lines": {"1": [37], "2": [54, 55, 56, 57, 58, 59, 60, 61, 62, 63, 64, 65, 66, 67, 68, 69, 70, 71, 72, 73, 74, 75, 76, 77, 78, 79, 80, 81, 82, 83, 84, 85, 86, 87, 88, 89, 90, 91, 92], "3": [102, 107, 108, 109, 110, 111, 112, 113, 114, 115, 116, 117, 118, 119, 120, 121, 122, 123, 124, 125, 126, 127, 128, 129, 130, 131, 132, 133, 134, 135, 136, 137, 138, 139, 140, 141, 142, 143, 144, 145, 146, 147, 148, 149, 150, 151, 152, 153, 154, 155, 156, 157, 158, 159, 160, 161, 162, 163, 164], "4": [174], "5": [188], "6": [198], "7": [215, 216, 217, 219, 220, 221, 222, 223]}}, {"14": "guava-tests/test/com/google/common/graph/ConfigurableSimpleUndirectedNetworkTest.java", "added": {"1": ["/*\n", " * Copyright (C) 2014 The Guava Authors\n", " *\n", " * Licensed under the Apache License, Version 2.0 (the \"License\");\n", " * you may not use this file except in compliance with the License.\n", " * You may obtain a copy of the License at\n", " *\n", " * http://www.apache.org/licenses/LICENSE-2.0\n", " *\n", " * Unless required by applicable law or agreed to in writing, software\n", " * distributed under the License is distributed on an \"AS IS\" BASIS,\n", " * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n", " * See the License for the specific language governing permissions and\n", " * limitations under the License.\n", " */\n", "\n", "package com.google.common.graph;\n", "\n", "import static com.google.common.truth.Truth.assertThat;\n", "import static org.junit.Assert.assertTrue;\n", "import static org.junit.Assert.fail;\n", "\n", "import org.junit.Test;\n", "import org.junit.runner.RunWith;\n", "import org.junit.runners.JUnit4;\n", "\n", "import java.util.Set;\n", "\n", "/**\n", " * Tests for an undirected {@link ConfigurableNetwork}, creating a simple undirected graph (parallel\n", " * and self-loop edges are not allowed).\n", " */\n", "@RunWith(JUnit4.class)\n", "public class ConfigurableSimpleUndirectedNetworkTest extends AbstractUndirectedNetworkTest {\n", "\n", "  @Override\n", "  public MutableNetwork<Integer, String> createGraph() {\n", "    return NetworkBuilder.undirected().allowsSelfLoops(false).build();\n", "  }\n", "\n", "  @Override\n", "  @Test\n", "  public void nodes_checkReturnedSetMutability() {\n", "    Set<Integer> nodes = graph.nodes();\n", "    try {\n", "      nodes.add(N2);\n", "      fail(ERROR_MODIFIABLE_SET);\n", "    } catch (UnsupportedOperationException e) {\n", "      addNode(N1);\n", "      assertThat(graph.nodes()).containsExactlyElementsIn(nodes);\n", "    }\n", "  }\n", "\n", "  @Override\n", "  @Test\n", "  public void edges_checkReturnedSetMutability() {\n", "    Set<String> edges = graph.edges();\n", "    try {\n", "      edges.add(E12);\n", "      fail(ERROR_MODIFIABLE_SET);\n", "    } catch (UnsupportedOperationException e) {\n", "      addEdge(E12, N1, N2);\n", "      assertThat(graph.edges()).containsExactlyElementsIn(edges);\n", "    }\n", "  }\n", "\n", "  @Override\n", "  @Test\n", "  public void incidentEdges_checkReturnedSetMutability() {\n", "    addNode(N1);\n", "    Set<String> incidentEdges = graph.incidentEdges(N1);\n", "    try {\n", "      incidentEdges.add(E12);\n", "      fail(ERROR_MODIFIABLE_SET);\n", "    } catch (UnsupportedOperationException e) {\n", "      addEdge(E12, N1, N2);\n", "      assertThat(graph.incidentEdges(N1)).containsExactlyElementsIn(incidentEdges);\n", "    }\n", "  }\n", "\n", "  @Override\n", "  @Test\n", "  public void incidentNodes_checkReturnedSetMutability() {\n", "    addEdge(E12, N1, N2);\n", "    Set<Integer> incidentNodes = graph.incidentNodes(E12);\n", "    try {\n", "      incidentNodes.add(N3);\n", "      fail(ERROR_MODIFIABLE_SET);\n", "    } catch (UnsupportedOperationException expected) {\n", "    }\n", "  }\n", "\n", "  @Override\n", "  @Test\n", "  public void adjacentNodes_checkReturnedSetMutability() {\n", "    addNode(N1);\n", "    Set<Integer> adjacentNodes = graph.adjacentNodes(N1);\n", "    try {\n", "      adjacentNodes.add(N2);\n", "      fail(ERROR_MODIFIABLE_SET);\n", "    } catch (UnsupportedOperationException e) {\n", "      addEdge(E12, N1, N2);\n", "      assertThat(graph.adjacentNodes(N1)).containsExactlyElementsIn(adjacentNodes);\n", "    }\n", "  }\n", "\n", "  @Override\n", "  @Test\n", "  public void adjacentEdges_checkReturnedSetMutability() {\n", "    addEdge(E12, N1, N2);\n", "    Set<String> adjacentEdges = graph.adjacentEdges(E12);\n", "    try {\n", "      adjacentEdges.add(E23);\n", "      fail(ERROR_MODIFIABLE_SET);\n", "    } catch (UnsupportedOperationException e) {\n", "      addEdge(E23, N2, N3);\n", "      assertThat(graph.adjacentEdges(E12)).containsExactlyElementsIn(adjacentEdges);\n", "    }\n", "  }\n", "\n", "  @Override\n", "  @Test\n", "  public void edgesConnecting_checkReturnedSetMutability() {\n", "    addNode(N1);\n", "    addNode(N2);\n", "    Set<String> edgesConnecting = graph.edgesConnecting(N1, N2);\n", "    try {\n", "      edgesConnecting.add(E23);\n", "      fail(ERROR_MODIFIABLE_SET);\n", "    } catch (UnsupportedOperationException e) {\n", "      addEdge(E12, N1, N2);\n", "      assertThat(graph.edgesConnecting(N1, N2))\n", "          .containsExactlyElementsIn(edgesConnecting);\n", "    }\n", "  }\n", "\n", "  @Override\n", "  @Test\n", "  public void inEdges_checkReturnedSetMutability() {\n", "    addNode(N2);\n", "    Set<String> inEdges = graph.inEdges(N2);\n", "    try {\n", "      inEdges.add(E12);\n", "      fail(ERROR_MODIFIABLE_SET);\n", "    } catch (UnsupportedOperationException e) {\n", "      addEdge(E12, N1, N2);\n", "      assertThat(graph.inEdges(N2)).containsExactlyElementsIn(inEdges);\n", "    }\n", "  }\n", "\n", "  @Override\n", "  @Test\n", "  public void outEdges_checkReturnedSetMutability() {\n", "    addNode(N1);\n", "    Set<String> outEdges = graph.outEdges(N1);\n", "    try {\n", "      outEdges.add(E12);\n", "      fail(ERROR_MODIFIABLE_SET);\n", "    } catch (UnsupportedOperationException e) {\n", "      addEdge(E12, N1, N2);\n", "      assertThat(graph.outEdges(N1)).containsExactlyElementsIn(outEdges);\n", "    }\n", "  }\n", "\n", "  @Override\n", "  @Test\n", "  public void predecessors_checkReturnedSetMutability() {\n", "    addNode(N2);\n", "    Set<Integer> predecessors = graph.predecessors(N2);\n", "    try {\n", "      predecessors.add(N1);\n", "      fail(ERROR_MODIFIABLE_SET);\n", "    } catch (UnsupportedOperationException e) {\n", "      addEdge(E12, N1, N2);\n", "      assertThat(graph.predecessors(N2)).containsExactlyElementsIn(predecessors);\n", "    }\n", "  }\n", "\n", "  @Override\n", "  @Test\n", "  public void successors_checkReturnedSetMutability() {\n", "    addNode(N1);\n", "    Set<Integer> successors = graph.successors(N1);\n", "    try {\n", "      successors.add(N2);\n", "      fail(ERROR_MODIFIABLE_SET);\n", "    } catch (UnsupportedOperationException e) {\n", "      addEdge(E12, N1, N2);\n", "      assertThat(graph.successors(N1)).containsExactlyElementsIn(successors);\n", "    }\n", "  }\n", "\n", "  // Element Mutation\n", "\n", "  @Test\n", "  public void addEdge_selfLoop() {\n", "    try {\n", "      addEdge(E11, N1, N1);\n", "      fail(ERROR_ADDED_SELF_LOOP);\n", "    } catch (IllegalArgumentException e) {\n", "      assertThat(e.getMessage()).contains(ERROR_SELF_LOOP);\n", "    }\n", "  }\n", "\n", "  /**\n", "   * This test checks an implementation dependent feature. It tests that\n", "   * the method {@code addEdge} will silently add the missing nodes to the graph,\n", "   * then add the edge connecting them. We are not using the proxy methods here\n", "   * as we want to test {@code addEdge} when the end-points are not elements\n", "   * of the graph.\n", "   */\n", "  @Test\n", "  public void addEdge_nodesNotInGraph() {\n", "    graph.addNode(N1);\n", "    assertTrue(graph.addEdge(E15, N1, N5));\n", "    assertTrue(graph.addEdge(E41, N4, N1));\n", "    assertTrue(graph.addEdge(E23, N2, N3));\n", "    assertThat(graph.nodes()).containsExactly(N1, N5, N4, N2, N3).inOrder();\n", "    assertThat(graph.edges()).containsExactly(E15, E41, E23).inOrder();\n", "    assertThat(graph.edgesConnecting(N1, N5)).containsExactly(E15);\n", "    assertThat(graph.edgesConnecting(N4, N1)).containsExactly(E41);\n", "    assertThat(graph.edgesConnecting(N2, N3)).containsExactly(E23);\n", "    assertThat(graph.edgesConnecting(N3, N2)).containsExactly(E23);\n", "  }\n", "}\n"]}, "removed": {}, "added_lines": {"1": [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 58, 59, 60, 61, 62, 63, 64, 65, 66, 67, 68, 69, 70, 71, 72, 73, 74, 75, 76, 77, 78, 79, 80, 81, 82, 83, 84, 85, 86, 87, 88, 89, 90, 91, 92, 93, 94, 95, 96, 97, 98, 99, 100, 101, 102, 103, 104, 105, 106, 107, 108, 109, 110, 111, 112, 113, 114, 115, 116, 117, 118, 119, 120, 121, 122, 123, 124, 125, 126, 127, 128, 129, 130, 131, 132, 133, 134, 135, 136, 137, 138, 139, 140, 141, 142, 143, 144, 145, 146, 147, 148, 149, 150, 151, 152, 153, 154, 155, 156, 157, 158, 159, 160, 161, 162, 163, 164, 165, 166, 167, 168, 169, 170, 171, 172, 173, 174, 175, 176, 177, 178, 179, 180, 181, 182, 183, 184, 185, 186, 187, 188, 189, 190, 191, 192, 193, 194, 195, 196, 197, 198, 199, 200, 201, 202, 203, 204, 205, 206, 207, 208, 209, 210, 211, 212, 213, 214, 215, 216, 217, 218, 219, 220, 221, 222, 223, 224, 225]}, "removed_lines": {}}, {"15": "guava-tests/test/com/google/common/graph/ConfigurableUndirectedGraphTest.java", "added": {"2": ["  public MutableGraph<Integer> createGraph() {\n", "    addEdge(N1, N1);\n", "    addEdge(N1, N2);\n", "    addEdge(N1, N1);\n", "    addEdge(N1, N2);\n", "    addEdge(N1, N1);\n", "    addEdge(N2, N1);\n", "    addEdge(N1, N1);\n", "    addEdge(N1, N2);\n", "    addEdge(N1, N1);\n", "    addEdge(N1, N2);\n", "    addEdge(N1, N1);\n", "    addEdge(N2, N1);\n", "    assertTrue(addEdge(N1, N1));\n", "    assertThat(graph.adjacentNodes(N1)).containsExactly(N1);\n", "    addEdge(N1, N1);\n", "    assertFalse(addEdge(N1, N1));\n", "    addEdge(N1, N1);\n", "    addEdge(N1, N1);\n", "    assertTrue(graph.removeEdge(N1, N1));\n", "    assertThat(graph.nodes()).containsExactly(N1);\n", "    assertThat(graph.adjacentNodes(N1)).isEmpty();\n", "    MutableGraph<Integer> graphA = createGraph();\n", "    MutableGraph<Integer> graphB = createGraph();\n"]}, "removed": {"1": ["import static org.junit.Assert.fail;\n", "import com.google.common.collect.ImmutableSet;\n"], "2": ["  public Graph<Integer, String> createGraph() {\n", "  @Test\n", "  public void edges_selfLoop() {\n", "    addEdge(E11, N1, N1);\n", "    assertThat(graph.edges()).containsExactly(E11);\n", "  }\n", "\n", "  @Test\n", "  public void incidentEdges_selfLoop() {\n", "    addEdge(E11, N1, N1);\n", "    assertThat(graph.incidentEdges(N1)).containsExactly(E11);\n", "  }\n", "\n", "  @Test\n", "  public void incidentNodes_selfLoop() {\n", "    addEdge(E11, N1, N1);\n", "    assertThat(graph.incidentNodes(E11)).containsExactly(N1);\n", "  }\n", "\n", "    addEdge(E11, N1, N1);\n", "    addEdge(E12, N1, N2);\n", "  @Test\n", "  public void adjacentEdges_selfLoop() {\n", "    // An edge is never adjacent to itself\n", "    addEdge(E11, N1, N1);\n", "    assertThat(graph.adjacentEdges(E11)).isEmpty();\n", "    addEdge(E12, N1, N2);\n", "    assertThat(graph.adjacentEdges(E11)).containsExactly(E12);\n", "  }\n", "\n", "  @Test\n", "  public void edgesConnecting_selfLoop() {\n", "    addEdge(E11, N1, N1);\n", "    assertThat(graph.edgesConnecting(N1, N1)).containsExactly(E11);\n", "    addEdge(E12, N1, N2);\n", "    assertThat(graph.edgesConnecting(N1, N2)).containsExactly(E12);\n", "    assertThat(graph.edgesConnecting(N2, N1)).containsExactly(E12);\n", "    assertThat(graph.edgesConnecting(N1, N1)).containsExactly(E11);\n", "  }\n", "\n", "  @Test\n", "  public void inEdges_selfLoop() {\n", "    addEdge(E11, N1, N1);\n", "    assertThat(graph.inEdges(N1)).containsExactly(E11);\n", "    addEdge(E12, N1, N2);\n", "    assertThat(graph.inEdges(N1)).containsExactly(E11, E12);\n", "  }\n", "\n", "  @Test\n", "  public void outEdges_selfLoop() {\n", "    addEdge(E11, N1, N1);\n", "    assertThat(graph.outEdges(N1)).containsExactly(E11);\n", "    addEdge(E12, N2, N1);\n", "    assertThat(graph.outEdges(N1)).containsExactly(E11, E12);\n", "  }\n", "\n", "    addEdge(E11, N1, N1);\n", "    addEdge(E12, N1, N2);\n", "    addEdge(E11, N1, N1);\n", "    addEdge(E12, N2, N1);\n", "    addEdge(E11, N1, N1);\n", "    addEdge(E12, N1, N2);\n", "    addEdge(E11, N1, N1);\n", "    addEdge(E12, N1, N2);\n", "    addEdge(E11, N1, N1);\n", "    addEdge(E12, N2, N1);\n", "    assertTrue(addEdge(E11, N1, N1));\n", "    assertThat(graph.edges()).contains(E11);\n", "    assertThat(graph.edgesConnecting(N1, N1)).containsExactly(E11);\n", "    addEdge(E11, N1, N1);\n", "    ImmutableSet<String> edges = ImmutableSet.copyOf(graph.edges());\n", "    assertFalse(addEdge(E11, N1, N1));\n", "    assertThat(graph.edges()).containsExactlyElementsIn(edges);\n", "  }\n", "\n", "  @Test\n", "  public void addEdge_existingEdgeBetweenDifferentNodes_selfLoops() {\n", "    addEdge(E11, N1, N1);\n", "    try {\n", "      addEdge(E11, N1, N2);\n", "      fail(\"Reusing an existing self-loop edge to connect different nodes succeeded\");\n", "    } catch (IllegalArgumentException e) {\n", "      assertThat(e.getMessage()).contains(ERROR_REUSE_EDGE);\n", "    }\n", "    try {\n", "      addEdge(E11, N2, N2);\n", "      fail(\"Reusing an existing self-loop edge to make a different self-loop edge succeeded\");\n", "    } catch (IllegalArgumentException e) {\n", "      assertThat(e.getMessage()).contains(ERROR_REUSE_EDGE);\n", "    }\n", "    addEdge(E12, N1, N2);\n", "    try {\n", "      addEdge(E12, N1, N1);\n", "      fail(\"Reusing an existing edge to add a self-loop edge between different nodes succeeded\");\n", "    } catch (IllegalArgumentException e) {\n", "      assertThat(e.getMessage()).contains(ERROR_REUSE_EDGE);\n", "    }\n", "  }\n", "\n", "  @Test\n", "  public void addEdge_parallelSelfLoopEdge() {\n", "    addEdge(E11, N1, N1);\n", "    try {\n", "      addEdge(EDGE_NOT_IN_GRAPH, N1, N1);\n", "      fail(\"Adding a parallel self-loop edge succeeded\");\n", "    } catch (IllegalArgumentException e) {\n", "      assertThat(e.getMessage()).contains(ERROR_PARALLEL_EDGE);\n", "    }\n", "    addEdge(E11, N1, N1);\n", "    assertThat(graph.edges()).doesNotContain(E11);\n", "    addEdge(E11, N1, N1);\n", "    assertTrue(graph.removeEdge(E11));\n", "    assertThat(graph.edges()).doesNotContain(E11);\n", "    assertThat(graph.edgesConnecting(N1, N1)).isEmpty();\n", "    Graph<Integer, String> graphA = createGraph();\n", "    Graph<Integer, String> graphB = createGraph();\n"]}, "added_lines": {"2": [37, 43, 44, 50, 52, 58, 60, 66, 68, 74, 76, 82, 84, 91, 92, 97, 98, 104, 111, 112, 113, 114, 120, 122]}, "removed_lines": {"1": [23, 25], "2": [39, 43, 44, 45, 46, 47, 48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 58, 59, 60, 63, 64, 68, 69, 70, 71, 72, 73, 74, 75, 76, 77, 78, 79, 80, 81, 82, 83, 84, 85, 86, 87, 88, 89, 90, 91, 92, 93, 94, 95, 96, 97, 98, 99, 100, 101, 102, 105, 107, 113, 115, 121, 123, 129, 131, 137, 139, 146, 147, 148, 153, 154, 155, 156, 157, 158, 159, 160, 161, 162, 163, 164, 165, 166, 167, 168, 169, 170, 171, 172, 173, 174, 175, 176, 177, 178, 179, 180, 181, 182, 183, 184, 185, 186, 187, 188, 189, 190, 191, 197, 200, 205, 206, 207, 208, 214, 216]}}, {"16": "guava-tests/test/com/google/common/graph/ConfigurableUndirectedMultiNetworkTest.java", "added": {"1": [" * Tests for an undirected {@link ConfigurableNetwork} allowing parallel edges.\n", "public class ConfigurableUndirectedMultiNetworkTest extends ConfigurableUndirectedNetworkTest {\n", "  public MutableNetwork<Integer, String> createGraph() {\n", "    return NetworkBuilder.undirected().allowsParallelEdges(true).build();\n"]}, "removed": {"1": [" * Tests for an undirected {@link ConfigurableGraph} allowing parallel edges.\n", "public class ConfigurableUndirectedMultigraphTest extends ConfigurableUndirectedGraphTest {\n", "  public Graph<Integer, String> createGraph() {\n", "    return GraphBuilder.undirected().allowsParallelEdges(true).build();\n"]}, "added_lines": {"1": [27, 30, 32, 33]}, "removed_lines": {"1": [27, 30, 32, 33]}}, {"17": "guava-tests/test/com/google/common/graph/ConfigurableUndirectedNetworkTest.java", "added": {"1": ["/*\n", " * Copyright (C) 2014 The Guava Authors\n", " *\n", " * Licensed under the Apache License, Version 2.0 (the \"License\");\n", " * you may not use this file except in compliance with the License.\n", " * You may obtain a copy of the License at\n", " *\n", " * http://www.apache.org/licenses/LICENSE-2.0\n", " *\n", " * Unless required by applicable law or agreed to in writing, software\n", " * distributed under the License is distributed on an \"AS IS\" BASIS,\n", " * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n", " * See the License for the specific language governing permissions and\n", " * limitations under the License.\n", " */\n", "\n", "package com.google.common.graph;\n", "\n", "import static com.google.common.truth.Truth.assertThat;\n", "import static org.junit.Assert.assertEquals;\n", "import static org.junit.Assert.assertFalse;\n", "import static org.junit.Assert.assertTrue;\n", "import static org.junit.Assert.fail;\n", "\n", "import com.google.common.collect.ImmutableSet;\n", "import com.google.common.testing.EqualsTester;\n", "\n", "import org.junit.Test;\n", "import org.junit.runner.RunWith;\n", "import org.junit.runners.JUnit4;\n", "\n", "/**\n", " * Tests for an undirected {@link ConfigurableNetwork} with default graph properties.\n", " */\n", "@RunWith(JUnit4.class)\n", "public class ConfigurableUndirectedNetworkTest extends ConfigurableSimpleUndirectedNetworkTest {\n", "\n", "  @Override\n", "  public MutableNetwork<Integer, String> createGraph() {\n", "    return NetworkBuilder.undirected().build();\n", "  }\n", "\n", "  @Test\n", "  public void edges_selfLoop() {\n", "    addEdge(E11, N1, N1);\n", "    assertThat(graph.edges()).containsExactly(E11);\n", "  }\n", "\n", "  @Test\n", "  public void incidentEdges_selfLoop() {\n", "    addEdge(E11, N1, N1);\n", "    assertThat(graph.incidentEdges(N1)).containsExactly(E11);\n", "  }\n", "\n", "  @Test\n", "  public void incidentNodes_selfLoop() {\n", "    addEdge(E11, N1, N1);\n", "    assertThat(graph.incidentNodes(E11)).containsExactly(N1);\n", "  }\n", "\n", "  @Test\n", "  public void adjacentNodes_selfLoop() {\n", "    addEdge(E11, N1, N1);\n", "    addEdge(E12, N1, N2);\n", "    assertThat(graph.adjacentNodes(N1)).containsExactly(N1, N2);\n", "  }\n", "\n", "  @Test\n", "  public void adjacentEdges_selfLoop() {\n", "    // An edge is never adjacent to itself\n", "    addEdge(E11, N1, N1);\n", "    assertThat(graph.adjacentEdges(E11)).isEmpty();\n", "    addEdge(E12, N1, N2);\n", "    assertThat(graph.adjacentEdges(E11)).containsExactly(E12);\n", "  }\n", "\n", "  @Test\n", "  public void edgesConnecting_selfLoop() {\n", "    addEdge(E11, N1, N1);\n", "    assertThat(graph.edgesConnecting(N1, N1)).containsExactly(E11);\n", "    addEdge(E12, N1, N2);\n", "    assertThat(graph.edgesConnecting(N1, N2)).containsExactly(E12);\n", "    assertThat(graph.edgesConnecting(N2, N1)).containsExactly(E12);\n", "    assertThat(graph.edgesConnecting(N1, N1)).containsExactly(E11);\n", "  }\n", "\n", "  @Test\n", "  public void inEdges_selfLoop() {\n", "    addEdge(E11, N1, N1);\n", "    assertThat(graph.inEdges(N1)).containsExactly(E11);\n", "    addEdge(E12, N1, N2);\n", "    assertThat(graph.inEdges(N1)).containsExactly(E11, E12);\n", "  }\n", "\n", "  @Test\n", "  public void outEdges_selfLoop() {\n", "    addEdge(E11, N1, N1);\n", "    assertThat(graph.outEdges(N1)).containsExactly(E11);\n", "    addEdge(E12, N2, N1);\n", "    assertThat(graph.outEdges(N1)).containsExactly(E11, E12);\n", "  }\n", "\n", "  @Test\n", "  public void predecessors_selfLoop() {\n", "    addEdge(E11, N1, N1);\n", "    assertThat(graph.predecessors(N1)).containsExactly(N1);\n", "    addEdge(E12, N1, N2);\n", "    assertThat(graph.predecessors(N1)).containsExactly(N1, N2);\n", "  }\n", "\n", "  @Test\n", "  public void successors_selfLoop() {\n", "    addEdge(E11, N1, N1);\n", "    assertThat(graph.successors(N1)).containsExactly(N1);\n", "    addEdge(E12, N2, N1);\n", "    assertThat(graph.successors(N1)).containsExactly(N1, N2);\n", "  }\n", "\n", "  @Test\n", "  public void degree_selfLoop() {\n", "    addEdge(E11, N1, N1);\n", "    assertEquals(1, graph.degree(N1));\n", "    addEdge(E12, N1, N2);\n", "    assertEquals(2, graph.degree(N1));\n", "  }\n", "\n", "  @Test\n", "  public void inDegree_selfLoop() {\n", "    addEdge(E11, N1, N1);\n", "    assertEquals(1, graph.inDegree(N1));\n", "    addEdge(E12, N1, N2);\n", "    assertEquals(2, graph.inDegree(N1));\n", "  }\n", "\n", "  @Test\n", "  public void outDegree_selfLoop() {\n", "    addEdge(E11, N1, N1);\n", "    assertEquals(1, graph.outDegree(N1));\n", "    addEdge(E12, N2, N1);\n", "    assertEquals(2, graph.outDegree(N1));\n", "  }\n", "\n", "  @Override\n", "  @Test\n", "  public void addEdge_selfLoop() {\n", "    assertTrue(addEdge(E11, N1, N1));\n", "    assertThat(graph.edges()).contains(E11);\n", "    assertThat(graph.edgesConnecting(N1, N1)).containsExactly(E11);\n", "  }\n", "\n", "  @Test\n", "  public void addEdge_existingSelfLoopEdgeBetweenSameNodes() {\n", "    addEdge(E11, N1, N1);\n", "    ImmutableSet<String> edges = ImmutableSet.copyOf(graph.edges());\n", "    assertFalse(addEdge(E11, N1, N1));\n", "    assertThat(graph.edges()).containsExactlyElementsIn(edges);\n", "  }\n", "\n", "  @Test\n", "  public void addEdge_existingEdgeBetweenDifferentNodes_selfLoops() {\n", "    addEdge(E11, N1, N1);\n", "    try {\n", "      addEdge(E11, N1, N2);\n", "      fail(\"Reusing an existing self-loop edge to connect different nodes succeeded\");\n", "    } catch (IllegalArgumentException e) {\n", "      assertThat(e.getMessage()).contains(ERROR_REUSE_EDGE);\n", "    }\n", "    try {\n", "      addEdge(E11, N2, N2);\n", "      fail(\"Reusing an existing self-loop edge to make a different self-loop edge succeeded\");\n", "    } catch (IllegalArgumentException e) {\n", "      assertThat(e.getMessage()).contains(ERROR_REUSE_EDGE);\n", "    }\n", "    addEdge(E12, N1, N2);\n", "    try {\n", "      addEdge(E12, N1, N1);\n", "      fail(\"Reusing an existing edge to add a self-loop edge between different nodes succeeded\");\n", "    } catch (IllegalArgumentException e) {\n", "      assertThat(e.getMessage()).contains(ERROR_REUSE_EDGE);\n", "    }\n", "  }\n", "\n", "  @Test\n", "  public void addEdge_parallelSelfLoopEdge() {\n", "    addEdge(E11, N1, N1);\n", "    try {\n", "      addEdge(EDGE_NOT_IN_GRAPH, N1, N1);\n", "      fail(\"Adding a parallel self-loop edge succeeded\");\n", "    } catch (IllegalArgumentException e) {\n", "      assertThat(e.getMessage()).contains(ERROR_PARALLEL_EDGE);\n", "    }\n", "  }\n", "\n", "  @Test\n", "  public void removeNode_existingNodeWithSelfLoopEdge() {\n", "    addNode(N1);\n", "    addEdge(E11, N1, N1);\n", "    assertTrue(graph.removeNode(N1));\n", "    assertThat(graph.nodes()).isEmpty();\n", "    assertThat(graph.edges()).doesNotContain(E11);\n", "  }\n", "\n", "  @Test\n", "  public void removeEdge_existingSelfLoopEdge() {\n", "    addEdge(E11, N1, N1);\n", "    assertTrue(graph.removeEdge(E11));\n", "    assertThat(graph.edges()).doesNotContain(E11);\n", "    assertThat(graph.edgesConnecting(N1, N1)).isEmpty();\n", "  }\n", "\n", "  // TODO(kak): Can't we ditch this and just use PackageSanityTests?\n", "  @Test\n", "  public void testEquals() {\n", "    MutableNetwork<Integer, String> graphA = createGraph();\n", "    graphA.addNode(N1);\n", "    MutableNetwork<Integer, String> graphB = createGraph();\n", "    graphA.addNode(N2);\n", "\n", "    new EqualsTester()\n", "        .addEqualityGroup(graphA)\n", "        .addEqualityGroup(graphB)\n", "        .testEquals();\n", "  }\n", "}\n"]}, "removed": {}, "added_lines": {"1": [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 58, 59, 60, 61, 62, 63, 64, 65, 66, 67, 68, 69, 70, 71, 72, 73, 74, 75, 76, 77, 78, 79, 80, 81, 82, 83, 84, 85, 86, 87, 88, 89, 90, 91, 92, 93, 94, 95, 96, 97, 98, 99, 100, 101, 102, 103, 104, 105, 106, 107, 108, 109, 110, 111, 112, 113, 114, 115, 116, 117, 118, 119, 120, 121, 122, 123, 124, 125, 126, 127, 128, 129, 130, 131, 132, 133, 134, 135, 136, 137, 138, 139, 140, 141, 142, 143, 144, 145, 146, 147, 148, 149, 150, 151, 152, 153, 154, 155, 156, 157, 158, 159, 160, 161, 162, 163, 164, 165, 166, 167, 168, 169, 170, 171, 172, 173, 174, 175, 176, 177, 178, 179, 180, 181, 182, 183, 184, 185, 186, 187, 188, 189, 190, 191, 192, 193, 194, 195, 196, 197, 198, 199, 200, 201, 202, 203, 204, 205, 206, 207, 208, 209, 210, 211, 212, 213, 214, 215, 216, 217, 218, 219, 220, 221, 222, 223, 224]}, "removed_lines": {}}, {"18": "guava-tests/test/com/google/common/graph/GraphEqualsTest.java", "added": {"2": ["  private final MutableGraph<Integer> graph;\n"], "3": ["  private static MutableGraph<Integer> createGraph(GraphType graphType) {\n"], "4": ["    MutableGraph<Integer> g2 = createGraph(graphType);\n", "    graph.addEdge(N1, N2);\n", "    MutableGraph<Integer> g2 = createGraph(oppositeType(graphType));\n", "    g2.addEdge(N1, N2);\n"], "5": ["    graph.addEdge(N1, N1);\n", "    MutableGraph<Integer> g2 = createGraph(oppositeType(graphType));\n", "    g2.addEdge(N1, N1);\n", "    graph.addEdge(N1, N2);\n", "    MutableGraph<Integer> g2 = GraphBuilder.from(graph)\n", "    g2.addEdge(N1, N2);\n"], "6": ["    GraphBuilder<Integer> builder = GraphBuilder.from(graph);\n", "    MutableGraph<Integer> g1 = builder.build();\n", "    MutableGraph<Integer> g2 = builder.build();\n", "    // for g1, add 1->2 first, then 3->1\n", "    g1.addEdge(N1, N2);\n", "    g1.addEdge(N3, N1);\n", "    // for g2, add 3->1 first, then 1->2\n", "    g2.addEdge(N3, N1);\n", "    g2.addEdge(N1, N2);\n", "    graph.addEdge(N1, N2);\n", "    MutableGraph<Integer> g2 = createGraph(graphType);\n", "    g2.addEdge(N2, N1);\n"]}, "removed": {"1": ["  private static final String E11 = \"1-1\";\n", "  private static final String E12 = \"1-2\";\n", "  private static final String E12_A = \"1-2a\";\n", "  private static final String E13 = \"1-3\";\n", "\n"], "2": ["  private final Graph<Integer, String> graph;\n"], "3": ["  private static Graph<Integer, String> createGraph(GraphType graphType) {\n"], "4": ["    Graph<Integer, String> g2 = createGraph(graphType);\n", "  // Node sets are the same, but edge sets differ.\n", "  @Test\n", "  public void equals_edgeSetsDiffer() {\n", "    graph.addEdge(E12, N1, N2);\n", "\n", "    Graph<Integer, String> g2 = createGraph(graphType);\n", "    g2.addEdge(E13, N1, N2);\n", "\n", "    new EqualsTester().addEqualityGroup(graph).addEqualityGroup(g2).testEquals();\n", "  }\n", "\n", "    graph.addEdge(E12, N1, N2);\n", "    Graph<Integer, String> g2 = createGraph(oppositeType(graphType));\n", "    g2.addEdge(E12, N1, N2);\n"], "5": ["    graph.addEdge(E11, N1, N1);\n", "    Graph<Integer, String> g2 = createGraph(oppositeType(graphType));\n", "    g2.addEdge(E11, N1, N1);\n", "  // Node/edge sets are the same, but node/edge connections differ.\n", "  @Test\n", "  public void equals_connectionsDiffer() {\n", "    graph.addEdge(E12, N1, N2);\n", "    graph.addEdge(E13, N1, N3);\n", "\n", "    Graph<Integer, String> g2 = createGraph(graphType);\n", "    // connect E13 to N1 and N2, and E12 to N1 and N3 => not equal\n", "    g2.addEdge(E13, N1, N2);\n", "    g2.addEdge(E12, N1, N3);\n", "\n", "    new EqualsTester().addEqualityGroup(graph).addEqualityGroup(g2).testEquals();\n", "  }\n", "\n", "    graph.addEdge(E12, N1, N2);\n", "    Graph<Integer, String> g2 = GraphBuilder.from(graph)\n", "        .allowsParallelEdges(!graph.allowsParallelEdges())\n", "    g2.addEdge(E12, N1, N2);\n"], "6": ["    GraphBuilder<Integer, String> builder = GraphBuilder.from(graph).allowsParallelEdges(true);\n", "    Graph<Integer, String> g1 = builder.build();\n", "    Graph<Integer, String> g2 = builder.build();\n", "    // for ug1, add e12 first, then e12_a\n", "    g1.addEdge(E12, N1, N2);\n", "    g1.addEdge(E12_A, N1, N2);\n", "    // for ug2, add e12_a first, then e12\n", "    g2.addEdge(E12_A, N1, N2);\n", "    g2.addEdge(E12, N1, N2);\n", "    graph.addEdge(E12, N1, N2);\n", "    Graph<Integer, String> g2 = createGraph(graphType);\n", "    g2.addEdge(E12, N2, N1);\n"]}, "added_lines": {"2": [44], "3": [57], "4": [83, 92, 94, 95], "5": [104, 106, 107, 116, 118, 121], "6": [130, 131, 132, 134, 135, 136, 138, 139, 140, 147, 149, 150]}, "removed_lines": {"1": [37, 38, 39, 40, 41], "2": [49], "3": [62], "4": [88, 94, 95, 96, 97, 98, 99, 100, 101, 102, 103, 104, 108, 110, 111], "5": [120, 122, 123, 128, 129, 130, 131, 132, 133, 134, 135, 136, 137, 138, 139, 140, 141, 146, 148, 149, 152], "6": [161, 162, 163, 165, 166, 167, 169, 170, 171, 178, 180, 181]}}, {"19": "guava-tests/test/com/google/common/graph/GraphPropertiesTest.java", "added": {"1": ["    Network<Integer, String> directedGraph = NetworkBuilder.directed().build();\n", "    MutableNetwork<Integer, String> directedGraph = NetworkBuilder.directed().build();\n"], "2": ["    MutableNetwork<Integer, String> directedGraph = NetworkBuilder.directed().build();\n", "    MutableNetwork<Integer, String> directedGraph = NetworkBuilder.directed().build();\n", "    MutableNetwork<Integer, String> directedGraph =\n", "        NetworkBuilder.directed().allowsParallelEdges(true).build();\n"], "3": ["    MutableNetwork<Integer, String> directedGraph = NetworkBuilder.directed().build();\n"], "4": ["    MutableNetwork<Integer, String> directedGraph = NetworkBuilder.directed().build();\n"], "5": ["    MutableNetwork<Integer, String> directedGraph = NetworkBuilder.directed().build();\n"], "6": ["    MutableNetwork<Integer, String> directedGraph = NetworkBuilder.directed().build();\n"], "7": ["    MutableNetwork<Integer, String> directedGraph = NetworkBuilder.directed().build();\n"], "8": ["    MutableNetwork<Integer, String> directedGraph =\n", "        NetworkBuilder.directed().allowsParallelEdges(true).build();\n"], "9": ["    MutableNetwork<Integer, String> directedGraph =\n", "        NetworkBuilder.directed().allowsParallelEdges(true).build();\n"], "10": ["    Network<Integer, String> directedGraph = NetworkBuilder.directed().build();\n", "    MutableNetwork<Integer, String> directedGraph = NetworkBuilder.directed().build();\n", "    MutableNetwork<Integer, String> directedGraph = NetworkBuilder.directed().build();\n"], "11": ["    MutableNetwork<Integer, String> directedGraph = NetworkBuilder.directed().build();\n"], "12": ["    MutableNetwork<Integer, String> directedGraph = NetworkBuilder.directed().build();\n"], "13": ["    MutableNetwork<Integer, String> directedGraph = NetworkBuilder.directed().build();\n"]}, "removed": {"1": ["    Graph<Integer, String> directedGraph = GraphBuilder.directed().build();\n", "    Graph<Integer, String> directedGraph = GraphBuilder.directed().build();\n"], "2": ["    Graph<Integer, String> directedGraph = GraphBuilder.directed().build();\n", "    Graph<Integer, String> directedGraph = GraphBuilder.directed().build();\n", "    Graph<Integer, String> directedGraph =\n", "        GraphBuilder.directed().allowsParallelEdges(true).build();\n"], "3": ["    Graph<Integer, String> directedGraph = GraphBuilder.directed().build();\n"], "4": ["    Graph<Integer, String> directedGraph = GraphBuilder.directed().build();\n"], "5": ["    Graph<Integer, String> directedGraph = GraphBuilder.directed().build();\n"], "6": ["    Graph<Integer, String> directedGraph = GraphBuilder.directed().build();\n"], "7": ["    Graph<Integer, String> directedGraph = GraphBuilder.directed().build();\n"], "8": ["    Graph<Integer, String> directedGraph =\n", "        GraphBuilder.directed().allowsParallelEdges(true).build();\n"], "9": ["    Graph<Integer, String> directedGraph =\n", "        GraphBuilder.directed().allowsParallelEdges(true).build();\n"], "10": ["    Graph<Integer, String> directedGraph = GraphBuilder.directed().build();\n", "    Graph<Integer, String> directedGraph = GraphBuilder.directed().build();\n", "    Graph<Integer, String> directedGraph = GraphBuilder.directed().build();\n"], "11": ["    Graph<Integer, String> directedGraph = GraphBuilder.directed().build();\n"], "12": ["    Graph<Integer, String> directedGraph = GraphBuilder.directed().build();\n"], "13": ["    Graph<Integer, String> directedGraph = GraphBuilder.directed().build();\n"]}, "added_lines": {"1": [47, 53], "2": [62, 69, 76, 77], "3": [85], "4": [93], "5": [101], "6": [110], "7": [119], "8": [128, 129], "9": [139, 140], "10": [150, 156, 163], "11": [171], "12": [179], "13": [187]}, "removed_lines": {"1": [47, 53], "2": [62, 69, 76, 77], "3": [85], "4": [93], "5": [101], "6": [110], "7": [119], "8": [128, 129], "9": [139, 140], "10": [150, 156, 163], "11": [171], "12": [179], "13": [187]}}, {"20": "guava-tests/test/com/google/common/graph/GraphsTest.java", "added": {"2": ["  // TODO(user): Consider adding both error messages from here and {@link AbstractNetworkTest}\n"], "3": ["    List<MutableNetwork<Integer, String>> testNetworks = ImmutableList.of(\n", "        NetworkBuilder.directed().<Integer, String>build(),\n", "        NetworkBuilder.undirected().<Integer, String>build());\n", "    for (MutableNetwork<Integer, String> graph : testNetworks) {\n"], "4": ["    List<MutableNetwork<Integer, String>> testNetworks = ImmutableList.of(\n", "        NetworkBuilder.directed().allowsParallelEdges(true).<Integer, String>build(),\n", "        NetworkBuilder.undirected().allowsParallelEdges(true).<Integer, String>build());\n", "    for (MutableNetwork<Integer, String> graph : testNetworks) {\n"], "5": ["    List<MutableNetwork<Integer, String>> testNetworks = ImmutableList.of(\n", "        NetworkBuilder.directed().<Integer, String>build(),\n", "        NetworkBuilder.undirected().<Integer, String>build());\n", "    for (MutableNetwork<Integer, String> graph : testNetworks) {\n"], "6": ["    List<MutableNetwork<Integer, String>> testNetworks = ImmutableList.of(\n", "        NetworkBuilder.directed().<Integer, String>build(),\n", "        NetworkBuilder.undirected().<Integer, String>build());\n", "    for (MutableNetwork<Integer, String> graph : testNetworks) {\n"], "7": ["    MutableNetwork<Integer, String> directedGraph =\n", "        NetworkBuilder.directed().allowsParallelEdges(true).build();\n"], "8": ["    MutableNetwork<Integer, String> directedGraph =\n", "        NetworkBuilder.directed().allowsParallelEdges(true).build();\n"], "9": ["    MutableNetwork<Integer, String> undirectedGraph =\n", "        NetworkBuilder.undirected().allowsParallelEdges(true).build();\n"], "10": ["    MutableNetwork<Integer, String> undirectedGraph =\n", "        NetworkBuilder.undirected().allowsParallelEdges(true).build();\n"], "11": ["    MutableNetwork<Integer, String> undirectedGraph =\n", "        NetworkBuilder.undirected().allowsParallelEdges(true).build();\n"], "12": ["    MutableNetwork<Integer, String> directedGraph = NetworkBuilder.directed().build();\n"], "13": ["    MutableNetwork<Integer, String> undirectedGraph = NetworkBuilder.undirected().build();\n"], "14": ["    MutableNetwork<Integer, String> directedMultigraph =\n", "        NetworkBuilder.directed().allowsParallelEdges(true).build();\n"], "15": ["    MutableNetwork<Integer, String> undirectedMultigraph =\n", "        NetworkBuilder.undirected().allowsParallelEdges(true).build();\n"], "16": ["    MutableNetwork<Integer, String> directedGraph = NetworkBuilder.directed()\n"], "17": ["    MutableNetwork<Integer, String> undirectedGraph = NetworkBuilder.undirected()\n"], "18": ["      NetworkBuilder.directed().expectedNodeCount(-1);\n"], "19": ["    MutableNetwork<Integer, String> directedGraph = NetworkBuilder.directed()\n"], "20": ["    MutableNetwork<Integer, String> undirectedGraph = NetworkBuilder.undirected()\n"], "21": ["      NetworkBuilder.directed().expectedEdgeCount(-1);\n"], "22": ["    MutableNetwork<Integer, String> directedGraph\n", "        = NetworkBuilder.directed().allowsSelfLoops(false).build();\n"], "23": ["    MutableNetwork<Integer, String> undirectedGraph =\n", "        NetworkBuilder.undirected().allowsSelfLoops(false).build();\n"], "24": ["      addEdge(NetworkBuilder.directed().build(), E11, null);\n"], "25": ["      addEdge(NetworkBuilder.directed().<Integer, String>build(), E11, ImmutableSet.of(N1, N2, N3));\n"], "26": ["      addEdge(NetworkBuilder.directed().build(), E11, ImmutableSet.of());\n"], "27": ["    MutableNetwork<Integer, String> directedGraph = NetworkBuilder.directed().build();\n"], "28": ["    MutableNetwork<Integer, String> directedGraph = NetworkBuilder.directed().build();\n"], "29": ["    Graph<Integer> directedGraph = buildDirectedTestGraph();\n", "    Graph<Integer> copy = copyOf(directedGraph);\n", "    Graph<Integer> undirectedGraph = buildUndirectedTestGraph();\n", "    Graph<Integer> copy = copyOf(undirectedGraph);\n", "  @Test\n", "  public void copyOf_filtered_undirectedGraph() {\n", "    MutableGraph<Integer> undirectedGraph = buildUndirectedTestGraph();\n", "    undirectedGraph.addEdge(N3, N1);\n", "    Predicate<Integer> nodePredicate = Predicates.in(ImmutableSet.of(N1, N2));\n", "\n", "    Graph<Integer> filteredCopy = copyOf(undirectedGraph, nodePredicate);\n", "\n", "    MutableGraph<Integer> expectedGraph = GraphBuilder.undirected().build();\n", "    expectedGraph.addEdge(N1, N1);\n", "    expectedGraph.addEdge(N1, N2);\n", "    expectedGraph.addEdge(N2, N1);\n", "\n", "    assertThat(filteredCopy).isEqualTo(expectedGraph);\n", "  }\n", "\n", "  @Test\n", "  public void copyOf_filtered_directedGraph() {\n", "    MutableGraph<Integer> directedGraph = buildDirectedTestGraph();\n", "    directedGraph.addEdge(N3, N1);\n", "    Predicate<Integer> nodePredicate = Predicates.in(ImmutableSet.of(N1, N2));\n", "\n", "    Graph<Integer> filteredCopy = copyOf(directedGraph, nodePredicate);\n", "\n", "    MutableGraph<Integer> expectedGraph = GraphBuilder.directed().build();\n", "    expectedGraph.addEdge(N1, N1);\n", "    expectedGraph.addEdge(N1, N2);\n", "    expectedGraph.addEdge(N2, N1);\n", "\n", "    assertThat(filteredCopy).isEqualTo(expectedGraph);\n", "  }\n", "\n", "  @Test\n", "  public void mergeNodesFrom_directedGraph() {\n", "    MutableGraph<Integer> directedGraph = buildDirectedTestGraph();\n", "    directedGraph.addNode(N3);\n", "\n", "    MutableGraph<Integer> actualGraph = GraphBuilder.directed().build();\n", "    // prepopulate actualGraph to make sure that existing elements don't interfere with the merging\n", "    actualGraph.addNode(N4);\n", "    actualGraph.addNode(N2);\n", "\n", "    mergeNodesFrom(directedGraph, actualGraph);\n", "\n", "    MutableGraph<Integer> expectedGraph = GraphBuilder.directed().build();\n", "    expectedGraph.addNode(N1);\n", "    expectedGraph.addNode(N2);\n", "    expectedGraph.addNode(N3);\n", "    expectedGraph.addNode(N4);\n", "\n", "    assertThat(actualGraph).isEqualTo(expectedGraph);\n", "  }\n", "\n", "  @Test\n", "  public void mergeNodesFrom_filtered_directedGraph() {\n", "    MutableGraph<Integer> directedGraph = buildDirectedTestGraph();\n", "    directedGraph.addEdge(N3, N1);\n", "    Predicate<Integer> nodePredicate = Predicates.in(ImmutableSet.of(N1, N2));\n", "\n", "    MutableGraph<Integer> actualGraph = GraphBuilder.directed().build();\n", "    // prepopulate actualGraph to make sure that existing elements don't interfere with the merging\n", "    actualGraph.addNode(N4); // ensure that we don't remove nodes that don't pass the predicate\n", "    actualGraph.addNode(N2); // ensure that a pre-existing node is not affected by the merging\n", "\n", "    mergeNodesFrom(directedGraph, actualGraph, nodePredicate);\n", "\n", "    MutableGraph<Integer> expectedGraph = GraphBuilder.directed().build();\n", "    expectedGraph.addNode(N1);\n", "    expectedGraph.addNode(N2);\n", "    // N3 is not expected because it's not in {N1, N2}\n", "    expectedGraph.addNode(N4);\n", "\n", "    assertThat(actualGraph).isEqualTo(expectedGraph);\n", "  }\n", "  public void mergeNodesFrom_undirectedGraph() {\n", "    MutableGraph<Integer> undirectedGraph = buildUndirectedTestGraph();\n", "\n", "    MutableGraph<Integer> actualGraph = GraphBuilder.undirected().build();\n", "    // prepopulate actualGraph to make sure that existing elements don't interfere with the merging\n", "    actualGraph.addNode(N4);\n", "    actualGraph.addNode(N2);\n", "\n", "    mergeNodesFrom(undirectedGraph, actualGraph);\n", "\n", "    MutableGraph<Integer> expectedGraph = GraphBuilder.undirected().build();\n", "    expectedGraph.addNode(N1);\n", "    expectedGraph.addNode(N2);\n", "    expectedGraph.addNode(N3);\n", "    expectedGraph.addNode(N4);\n", "\n", "    assertThat(actualGraph).isEqualTo(expectedGraph);\n", "  }\n", "\n", "  @Test\n", "  public void mergeNodesFrom_filtered_undirectedGraph() {\n", "    MutableGraph<Integer> undirectedGraph = buildUndirectedTestGraph();\n", "    undirectedGraph.addEdge(N3, N1);\n", "    Predicate<Integer> nodePredicate = Predicates.in(ImmutableSet.of(N1, N2));\n", "\n", "    MutableGraph<Integer> actualGraph = GraphBuilder.undirected().build();\n", "    // prepopulate actualGraph to make sure that existing elements don't interfere with the merging\n", "    actualGraph.addNode(N4); // ensure that we don't remove nodes that don't pass the predicate\n", "    actualGraph.addNode(N2); // ensure that a pre-existing node is not affected by the merging\n", "\n", "    mergeNodesFrom(undirectedGraph, actualGraph, nodePredicate);\n", "\n", "    MutableGraph<Integer> expectedGraph = GraphBuilder.undirected().build();\n", "    expectedGraph.addNode(N1);\n", "    expectedGraph.addNode(N2);\n", "    // N3 is not expected because it's not in {N1, N2}\n", "    expectedGraph.addNode(N4);\n", "\n", "    assertThat(actualGraph).isEqualTo(expectedGraph);\n", "  }\n", "\n", "  @Test\n", "  public void copyOf_directedNetwork() {\n", "    Network<Integer, String> directedGraph = buildDirectedTestNetwork();\n", "\n", "    Network<Integer, String> copy = copyOf(directedGraph);\n", "    assertThat(copy).isEqualTo(directedGraph);\n", "  }\n", "\n", "  @Test\n", "  public void copyOf_undirectedNetwork() {\n", "    Network<Integer, String> undirectedGraph = buildUndirectedTestNetwork();\n", "\n", "    Network<Integer, String> copy = copyOf(undirectedGraph);\n", "    assertThat(copy).isEqualTo(undirectedGraph);\n", "  }\n", "\n", "  // TODO: add a test for copyOf_hypergraph() once we have a Hypergraph implementation\n", "\n", "  @Test\n", "  public void copyOf_filtered_undirectedNetwork() {\n", "    MutableNetwork<Integer, String> undirectedGraph = buildUndirectedTestNetwork();\n", "    undirectedGraph.addEdge(E13, N1, N3);\n", "    Predicate<Integer> nodePredicate = Predicates.in(ImmutableSet.of(N1, N2));\n", "    Network<Integer, String> filteredCopy =\n", "    MutableNetwork<Integer, String> expectedGraph =\n", "        NetworkBuilder.undirected().allowsParallelEdges(true).build();\n"], "30": ["  public void copyOf_filtered_directedNetwork() {\n", "    MutableNetwork<Integer, String> directedGraph = buildDirectedTestNetwork();\n", "    directedGraph.addEdge(E13, N1, N3);\n", "    Predicate<Integer> nodePredicate = Predicates.in(ImmutableSet.of(N1, N2));\n", "    Network<Integer, String> filteredCopy =\n", "    MutableNetwork<Integer, String> expectedGraph =\n", "        NetworkBuilder.directed().allowsParallelEdges(true).build();\n"], "31": ["  public void mergeNodesFrom_directedNetwork() {\n", "    MutableNetwork<Integer, String> directedGraph = buildDirectedTestNetwork();\n", "    MutableNetwork<Integer, String> actualGraph = NetworkBuilder.directed().build();\n", "    MutableNetwork<Integer, String> expectedGraph = NetworkBuilder.directed().build();\n"], "32": ["  public void mergeNodesFrom_filtered_directedNetwork() {\n", "    MutableNetwork<Integer, String> directedGraph = buildDirectedTestNetwork();\n", "    directedGraph.addEdge(E13, N1, N3);\n", "    Predicate<Integer> nodePredicate = Predicates.in(ImmutableSet.of(N1, N2));\n", "    MutableNetwork<Integer, String> actualGraph = NetworkBuilder.directed().build();\n", "    MutableNetwork<Integer, String> expectedGraph = NetworkBuilder.directed().build();\n", "    // N3 is not expected because it's not in {N1, N2}\n", "  public void mergeEdgesFrom_directedNetwork() {\n", "    Network<Integer, String> directedGraph = buildDirectedTestNetwork();\n", "    MutableNetwork<Integer, String> actualGraph\n", "        = NetworkBuilder.directed().allowsParallelEdges(true).build();\n", "    MutableNetwork<Integer, String> expectedGraph = buildDirectedTestNetwork();\n", "  public void mergeEdgesFrom_filtered_directedNetwork() {\n", "    MutableNetwork<Integer, String> directedGraph = buildDirectedTestNetwork();\n", "    MutableNetwork<Integer, String> actualGraph\n", "        = NetworkBuilder.directed().allowsParallelEdges(true).build();\n"], "33": ["    MutableNetwork<Integer, String> expectedGraph =\n", "        NetworkBuilder.directed().allowsParallelEdges(true).build();\n"], "34": ["  public void mergeNodesFrom_undirectedNetwork() {\n", "    MutableNetwork<Integer, String> undirectedGraph = buildUndirectedTestNetwork();\n", "    MutableNetwork<Integer, String> actualGraph = NetworkBuilder.undirected().build();\n", "    MutableNetwork<Integer, String> expectedGraph = NetworkBuilder.undirected().build();\n"], "35": ["  public void mergeNodesFrom_filtered_undirectedNetwork() {\n", "    MutableNetwork<Integer, String> undirectedGraph = buildUndirectedTestNetwork();\n", "    undirectedGraph.addEdge(E13, N1, N3);\n", "    Predicate<Integer> nodePredicate = Predicates.in(ImmutableSet.of(N1, N2));\n", "    MutableNetwork<Integer, String> actualGraph = NetworkBuilder.undirected().build();\n", "    MutableNetwork<Integer, String> expectedGraph = NetworkBuilder.undirected().build();\n", "    // N3 is not expected because it's not in {N1, N2}\n", "  public void mergeEdgesFrom_undirectedNetwork() {\n", "    Network<Integer, String> undirectedGraph = buildUndirectedTestNetwork();\n", "    MutableNetwork<Integer, String> actualGraph =\n", "        NetworkBuilder.undirected().allowsParallelEdges(true).build();\n", "    MutableNetwork<Integer, String> expectedGraph = buildUndirectedTestNetwork();\n", "  public void mergeEdgesFrom_filtered_undirectedNetwork() {\n", "    MutableNetwork<Integer, String> undirectedGraph = buildUndirectedTestNetwork();\n", "    MutableNetwork<Integer, String> actualGraph =\n", "        NetworkBuilder.undirected().allowsParallelEdges(true).build();\n"], "36": ["    MutableNetwork<Integer, String> expectedGraph =\n", "        NetworkBuilder.undirected().allowsParallelEdges(true).build();\n"], "37": ["  private static MutableGraph<Integer> buildDirectedTestGraph() {\n", "    MutableGraph<Integer> directedGraph = GraphBuilder.directed().build();\n", "    directedGraph.addEdge(N1, N1);\n", "    directedGraph.addEdge(N1, N2);\n", "    // TODO(b/28087289): add parallel edges to test\n", "    directedGraph.addEdge(N2, N1);\n", "\n", "    return directedGraph;\n", "  }\n", "\n", "  private static MutableGraph<Integer> buildUndirectedTestGraph() {\n", "    MutableGraph<Integer> undirectedGraph = GraphBuilder.undirected().build();\n", "    undirectedGraph.addEdge(N1, N1);\n", "    undirectedGraph.addEdge(N1, N2);\n", "    // TODO(b/28087289): add parallel edges to test\n", "    undirectedGraph.addEdge(N2, N1);\n", "\n", "    return undirectedGraph;\n", "  }\n", "\n", "  private static MutableNetwork<Integer, String> buildDirectedTestNetwork() {\n", "    MutableNetwork<Integer, String> directedGraph =\n", "        NetworkBuilder.directed().allowsParallelEdges(true).build();\n"], "38": ["  private static MutableNetwork<Integer, String> buildUndirectedTestNetwork() {\n", "    MutableNetwork<Integer, String> undirectedGraph =\n", "        NetworkBuilder.undirected().allowsParallelEdges(true).build();\n"]}, "removed": {"1": ["import static com.google.common.base.Preconditions.checkNotNull;\n"], "2": ["  // TODO(user): Consider adding both error messages from here and {@link AbstractGraphTest}\n"], "3": ["    List<Graph<Integer, String>> testGraphs = ImmutableList.of(\n", "        GraphBuilder.directed().<Integer, String>build(),\n", "        GraphBuilder.undirected().<Integer, String>build());\n", "    for (Graph<Integer, String> graph : testGraphs) {\n"], "4": ["    List<Graph<Integer, String>> testGraphs = ImmutableList.of(\n", "        GraphBuilder.directed().allowsParallelEdges(true).<Integer, String>build(),\n", "        GraphBuilder.undirected().allowsParallelEdges(true).<Integer, String>build());\n", "    for (Graph<Integer, String> graph : testGraphs) {\n"], "5": ["    List<Graph<Integer, String>> testGraphs = ImmutableList.of(\n", "        GraphBuilder.directed().<Integer, String>build(),\n", "        GraphBuilder.undirected().<Integer, String>build());\n", "    for (Graph<Integer, String> graph : testGraphs) {\n"], "6": ["    List<Graph<Integer, String>> testGraphs = ImmutableList.of(\n", "        GraphBuilder.directed().<Integer, String>build(),\n", "        GraphBuilder.undirected().<Integer, String>build());\n", "    for (Graph<Integer, String> graph : testGraphs) {\n"], "7": ["    Graph<Integer, String> directedGraph =\n", "        GraphBuilder.directed().allowsParallelEdges(true).build();\n"], "8": ["    Graph<Integer, String> directedGraph =\n", "        GraphBuilder.directed().allowsParallelEdges(true).build();\n"], "9": ["    Graph<Integer, String> undirectedGraph =\n", "        GraphBuilder.undirected().allowsParallelEdges(true).build();\n"], "10": ["    Graph<Integer, String> undirectedGraph =\n", "        GraphBuilder.undirected().allowsParallelEdges(true).build();\n"], "11": ["    Graph<Integer, String> undirectedGraph =\n", "        GraphBuilder.undirected().allowsParallelEdges(true).build();\n"], "12": ["    Graph<Integer, String> directedGraph = GraphBuilder.directed().build();\n"], "13": ["    Graph<Integer, String> undirectedGraph = GraphBuilder.undirected().build();\n"], "14": ["    Graph<Integer, String> directedMultigraph =\n", "        GraphBuilder.directed().allowsParallelEdges(true).build();\n"], "15": ["    Graph<Integer, String> undirectedMultigraph =\n", "        GraphBuilder.undirected().allowsParallelEdges(true).build();\n"], "16": ["    Graph<Integer, String> directedGraph = GraphBuilder.directed()\n"], "17": ["    Graph<Integer, String> undirectedGraph = GraphBuilder.undirected()\n"], "18": ["      GraphBuilder.directed().expectedNodeCount(-1);\n"], "19": ["    Graph<Integer, String> directedGraph = GraphBuilder.directed()\n"], "20": ["    Graph<Integer, String> undirectedGraph = GraphBuilder.undirected()\n"], "21": ["      GraphBuilder.directed().expectedEdgeCount(-1);\n"], "22": ["    Graph<Integer, String> directedGraph = GraphBuilder.directed().allowsSelfLoops(false).build();\n"], "23": ["    Graph<Integer, String> undirectedGraph =\n", "        GraphBuilder.undirected().allowsSelfLoops(false).build();\n"], "24": ["      addEdge(GraphBuilder.directed().build(), E11, null);\n"], "25": ["      addEdge(GraphBuilder.directed().<Integer, String>build(), E11, ImmutableSet.of(N1, N2, N3));\n"], "26": ["      addEdge(GraphBuilder.directed().build(), E11, ImmutableSet.of());\n"], "27": ["    Graph<Integer, String> directedGraph = GraphBuilder.directed().build();\n"], "28": ["    Graph<Integer, String> directedGraph = GraphBuilder.directed().build();\n"], "29": ["    Graph<Integer, String> directedGraph = buildDirectedTestGraph();\n", "    Graph<Integer, String> copy = copyOf(directedGraph);\n", "    Graph<Integer, String> undirectedGraph = buildUndirectedTestGraph();\n", "    Graph<Integer, String> copy = copyOf(undirectedGraph);\n", "  // TODO: add a test for copyOf_hypergraph() once we have a Hypergraph implementation\n", "  public void copyOf_filtered_undirected() {\n", "    Graph<Integer, String> undirectedGraph = buildUndirectedTestGraph();\n", "    Predicate<Integer> nodePredicate = connectedNodePredicate(undirectedGraph);\n", "    Graph<Integer, String> filteredCopy =\n", "    Graph<Integer, String> expectedGraph =\n", "        GraphBuilder.undirected().allowsParallelEdges(true).build();\n"], "30": ["  public void copyOf_filtered_directed() {\n", "    Graph<Integer, String> directedGraph = buildDirectedTestGraph();\n", "    directedGraph.addNode(N3);\n", "    Predicate<Integer> nodePredicate = connectedNodePredicate(directedGraph);\n", "    Graph<Integer, String> filteredCopy =\n", "    Graph<Integer, String> expectedGraph =\n", "        GraphBuilder.directed().allowsParallelEdges(true).build();\n"], "31": ["  public void mergeNodesFrom_directed() {\n", "    Graph<Integer, String> directedGraph = buildDirectedTestGraph();\n", "    Graph<Integer, String> actualGraph = GraphBuilder.directed().build();\n", "    Graph<Integer, String> expectedGraph = GraphBuilder.directed().build();\n"], "32": ["  public void mergeNodesFrom_filtered_directed() {\n", "    Graph<Integer, String> directedGraph = buildDirectedTestGraph();\n", "    directedGraph.addNode(N3);\n", "    Predicate<Integer> nodePredicate = connectedNodePredicate(directedGraph);\n", "    Graph<Integer, String> actualGraph = GraphBuilder.directed().build();\n", "    Graph<Integer, String> expectedGraph = GraphBuilder.directed().build();\n", "    // N3 is not expected because it's not connected\n", "  public void mergeEdgesFrom_directed() {\n", "    Graph<Integer, String> directedGraph = buildDirectedTestGraph();\n", "    Graph<Integer, String> actualGraph = GraphBuilder.directed().allowsParallelEdges(true).build();\n", "    Graph<Integer, String> expectedGraph = buildDirectedTestGraph();\n", "  public void mergeEdgesFrom_filtered_directed() {\n", "    Graph<Integer, String> directedGraph = buildDirectedTestGraph();\n", "    Graph<Integer, String> actualGraph = GraphBuilder.directed().allowsParallelEdges(true).build();\n"], "33": ["    Graph<Integer, String> expectedGraph =\n", "        GraphBuilder.directed().allowsParallelEdges(true).build();\n"], "34": ["  public void mergeNodesFrom_undirected() {\n", "    Graph<Integer, String> undirectedGraph = buildUndirectedTestGraph();\n", "    Graph<Integer, String> actualGraph = GraphBuilder.undirected().build();\n", "    Graph<Integer, String> expectedGraph = GraphBuilder.undirected().build();\n"], "35": ["  public void mergeNodesFrom_filtered_undirected() {\n", "    Graph<Integer, String> undirectedGraph = buildUndirectedTestGraph();\n", "    undirectedGraph.addNode(N3);\n", "    Predicate<Integer> nodePredicate = connectedNodePredicate(undirectedGraph);\n", "    Graph<Integer, String> actualGraph = GraphBuilder.undirected().build();\n", "    Graph<Integer, String> expectedGraph = GraphBuilder.undirected().build();\n", "    // N3 is not expected because it's not connected\n", "  public void mergeEdgesFrom_undirected() {\n", "    Graph<Integer, String> undirectedGraph = buildUndirectedTestGraph();\n", "    Graph<Integer, String> actualGraph =\n", "        GraphBuilder.undirected().allowsParallelEdges(true).build();\n", "    Graph<Integer, String> expectedGraph = buildUndirectedTestGraph();\n", "  public void mergeEdgesFrom_filtered_undirected() {\n", "    Graph<Integer, String> undirectedGraph = buildUndirectedTestGraph();\n", "    Graph<Integer, String> actualGraph =\n", "        GraphBuilder.undirected().allowsParallelEdges(true).build();\n"], "36": ["    Graph<Integer, String> expectedGraph =\n", "        GraphBuilder.undirected().allowsParallelEdges(true).build();\n"], "37": ["  private static Graph<Integer, String> buildDirectedTestGraph() {\n", "    Graph<Integer, String> directedGraph =\n", "        GraphBuilder.directed().allowsParallelEdges(true).build();\n"], "38": ["  private static Graph<Integer, String> buildUndirectedTestGraph() {\n", "    Graph<Integer, String> undirectedGraph =\n", "        GraphBuilder.undirected().allowsParallelEdges(true).build();\n"], "39": ["\n", "  private static <N> Predicate<N> connectedNodePredicate(final Graph<N, ?> graph) {\n", "    checkNotNull(graph, \"graph\");\n", "    return new Predicate<N>() {\n", "      @Override\n", "      public boolean apply(N node) {\n", "        return graph.degree(node) > 0;\n", "      }\n", "    };\n", "  }\n"]}, "added_lines": {"2": [61], "3": [76, 77, 78, 79], "4": [88, 89, 90, 91], "5": [103, 104, 105, 106], "6": [114, 115, 116, 117], "7": [130, 131], "8": [142, 143], "9": [152, 153], "10": [164, 165], "11": [174, 175], "12": [191], "13": [210], "14": [235, 236], "15": [245, 246], "16": [256], "17": [266], "18": [277], "19": [286], "20": [296], "21": [307], "22": [316, 317], "23": [328, 329], "24": [350], "25": [359], "26": [368], "27": [376], "28": [385], "29": [403, 405, 411, 413, 417, 418, 419, 420, 421, 422, 423, 424, 425, 426, 427, 428, 429, 430, 431, 432, 433, 434, 435, 436, 437, 438, 439, 440, 441, 442, 443, 444, 445, 446, 447, 448, 449, 450, 451, 452, 453, 454, 455, 456, 457, 458, 459, 460, 461, 462, 463, 464, 465, 466, 467, 468, 469, 470, 471, 472, 473, 474, 475, 476, 477, 478, 479, 480, 481, 482, 483, 484, 485, 486, 487, 488, 489, 490, 493, 494, 496, 497, 498, 499, 500, 501, 502, 503, 504, 505, 506, 507, 508, 509, 510, 511, 512, 513, 514, 515, 516, 517, 518, 519, 520, 521, 522, 523, 524, 525, 526, 527, 528, 529, 530, 531, 532, 533, 534, 535, 536, 537, 538, 539, 540, 541, 542, 543, 544, 545, 546, 547, 548, 549, 550, 551, 552, 553, 554, 555, 556, 557, 560, 563, 564], "30": [573, 574, 575, 576, 579, 582, 583], "31": [592, 593, 596, 603], "32": [613, 614, 615, 616, 618, 625, 628, 635, 636, 638, 639, 646, 653, 654, 658, 659], "33": [668, 669], "34": [683, 684, 687, 694], "35": [704, 705, 706, 707, 709, 716, 719, 726, 727, 729, 730, 737, 744, 745, 749, 750], "36": [759, 760], "37": [773, 774, 775, 776, 777, 778, 779, 780, 781, 782, 783, 784, 785, 786, 787, 788, 789, 790, 791, 792, 793, 794, 795], "38": [805, 806, 807]}, "removed_lines": {"1": [19], "2": [62], "3": [77, 78, 79, 80], "4": [89, 90, 91, 92], "5": [104, 105, 106, 107], "6": [115, 116, 117, 118], "7": [131, 132], "8": [143, 144], "9": [153, 154], "10": [165, 166], "11": [175, 176], "12": [192], "13": [211], "14": [236, 237], "15": [246, 247], "16": [257], "17": [267], "18": [278], "19": [287], "20": [297], "21": [308], "22": [317], "23": [328, 329], "24": [350], "25": [359], "26": [368], "27": [376], "28": [385], "29": [403, 405, 411, 413, 417, 420, 421, 423, 426, 429, 430], "30": [439, 440, 441, 442, 445, 448, 449], "31": [458, 459, 462, 469], "32": [479, 480, 481, 482, 484, 491, 494, 501, 502, 504, 511, 518, 519, 523], "33": [532, 533], "34": [547, 548, 551, 558], "35": [568, 569, 570, 571, 573, 580, 583, 590, 591, 593, 594, 601, 608, 609, 613, 614], "36": [623, 624], "37": [637, 638, 639], "38": [649, 650, 651], "39": [660, 661, 662, 663, 664, 665, 666, 667, 668, 669]}}, {"21": "guava-tests/test/com/google/common/graph/ImmutableGraphTest.java", "added": {"2": ["    Graph<String> graph1 = ImmutableGraph.copyOf(GraphBuilder.directed().<String>build());\n", "    Graph<String> graph2 = ImmutableGraph.copyOf(graph1);\n"]}, "removed": {"1": ["import static org.junit.Assert.fail;\n", "\n", "import com.google.common.graph.testing.TestGraphBuilder;\n"], "2": ["  @Test\n", "  public void addNode_immutable() {\n", "    Graph<String, String> graph = TestGraphBuilder.<String, String>init(GraphBuilder.directed())\n", "        .toImmutableGraph();\n", "    try {\n", "      graph.addNode(\"node\");\n", "      fail(\"Expected UnsupportedOperationException\");\n", "    } catch (UnsupportedOperationException expected) {\n", "    }\n", "    assertThat(graph.nodes()).isEmpty();\n", "  }\n", "\n", "  @Test\n", "  public void addEdge_immutable() {\n", "    Graph<String, String> graph = TestGraphBuilder.<String, String>init(GraphBuilder.directed())\n", "        .toImmutableGraph();\n", "    try {\n", "      graph.addEdge(\"edge\", \"node1\", \"node2\");\n", "      fail(\"Expected UnsupportedOperationException\");\n", "    } catch (UnsupportedOperationException expected) {\n", "    }\n", "    assertThat(graph.edges()).isEmpty();\n", "  }\n", "\n", "  @Test\n", "  public void removeNode_immutable() {\n", "    Graph<String, String> graph = TestGraphBuilder.<String, String>init(GraphBuilder.directed())\n", "        .addNode(\"node\")\n", "        .toImmutableGraph();\n", "    try {\n", "      graph.removeNode(\"node\");\n", "      fail(\"Expected UnsupportedOperationException\");\n", "    } catch (UnsupportedOperationException expected) {\n", "    }\n", "    assertThat(graph.nodes()).containsExactly(\"node\");\n", "  }\n", "\n", "  @Test\n", "  public void removeEdge_immutable() {\n", "    Graph<String, String> graph = TestGraphBuilder.<String, String>init(GraphBuilder.directed())\n", "        .addEdge(\"edge\", \"node1\", \"node2\")\n", "        .toImmutableGraph();\n", "    try {\n", "      graph.removeEdge(\"edge\");\n", "      fail(\"Expected UnsupportedOperationException\");\n", "    } catch (UnsupportedOperationException expected) {\n", "    }\n", "    assertThat(graph.edges()).containsExactly(\"edge\");\n", "  }\n", "\n", "    Graph<String, String> graph1 = ImmutableGraph.copyOf(\n", "        GraphBuilder.directed().<String, String>build());\n", "    Graph<String, String> graph2 = ImmutableGraph.copyOf(graph1);\n", "\n", "  @Test\n", "  public void edgesConnecting_directed() {\n", "    Graph<String, String> mutableGraph = GraphBuilder.directed().build();\n", "    mutableGraph.addEdge(\"AA\", \"A\", \"A\");\n", "    mutableGraph.addEdge(\"AB\", \"A\", \"B\");\n", "    Graph<String, String> graph = ImmutableGraph.copyOf(mutableGraph);\n", "\n", "    assertThat(graph.edgesConnecting(\"A\", \"A\")).containsExactly(\"AA\");\n", "    assertThat(graph.edgesConnecting(\"A\", \"B\")).containsExactly(\"AB\");\n", "    assertThat(graph.edgesConnecting(\"B\", \"A\")).isEmpty();\n", "  }\n", "\n", "  @Test\n", "  public void edgesConnecting_undirected() {\n", "    Graph<String, String> mutableGraph = GraphBuilder.undirected().build();\n", "    mutableGraph.addEdge(\"AA\", \"A\", \"A\");\n", "    mutableGraph.addEdge(\"AB\", \"A\", \"B\");\n", "    Graph<String, String> graph = ImmutableGraph.copyOf(mutableGraph);\n", "\n", "    assertThat(graph.edgesConnecting(\"A\", \"A\")).containsExactly(\"AA\");\n", "    assertThat(graph.edgesConnecting(\"A\", \"B\")).containsExactly(\"AB\");\n", "    assertThat(graph.edgesConnecting(\"B\", \"A\")).containsExactly(\"AB\");\n", "  }\n"]}, "added_lines": {"2": [33, 34]}, "removed_lines": {"1": [20, 21, 22], "2": [34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 58, 59, 60, 61, 62, 63, 64, 65, 66, 67, 68, 69, 70, 71, 72, 73, 74, 75, 76, 77, 78, 79, 80, 81, 82, 83, 86, 87, 88, 92, 93, 94, 95, 96, 97, 98, 99, 100, 101, 102, 103, 104, 105, 106, 107, 108, 109, 110, 111, 112, 113, 114, 115]}}, {"22": "guava-tests/test/com/google/common/graph/ImmutableNetworkTest.java", "added": {"1": ["/*\n", " * Copyright (C) 2014 The Guava Authors\n", " *\n", " * Licensed under the Apache License, Version 2.0 (the \"License\");\n", " * you may not use this file except in compliance with the License.\n", " * You may obtain a copy of the License at\n", " *\n", " * http://www.apache.org/licenses/LICENSE-2.0\n", " *\n", " * Unless required by applicable law or agreed to in writing, software\n", " * distributed under the License is distributed on an \"AS IS\" BASIS,\n", " * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n", " * See the License for the specific language governing permissions and\n", " * limitations under the License.\n", " */\n", "\n", "package com.google.common.graph;\n", "\n", "import static com.google.common.truth.Truth.assertThat;\n", "\n", "import org.junit.Test;\n", "import org.junit.runner.RunWith;\n", "import org.junit.runners.JUnit4;\n", "\n", "/**\n", " * Tests for {@link ImmutableNetwork}.\n", " */\n", "@RunWith(JUnit4.class)\n", "public class ImmutableNetworkTest {\n", "\n", "  @Test\n", "  public void copyOfImmutableNetwork_optimized() {\n", "    Network<String, String> graph1 = ImmutableNetwork.copyOf(\n", "        NetworkBuilder.directed().<String, String>build());\n", "    Network<String, String> graph2 = ImmutableNetwork.copyOf(graph1);\n", "\n", "    assertThat(graph2).isSameAs(graph1);\n", "  }\n", "\n", "  @Test\n", "  public void edgesConnecting_directed() {\n", "    MutableNetwork<String, String> mutableGraph = NetworkBuilder.directed().build();\n", "    mutableGraph.addEdge(\"AA\", \"A\", \"A\");\n", "    mutableGraph.addEdge(\"AB\", \"A\", \"B\");\n", "    Network<String, String> graph = ImmutableNetwork.copyOf(mutableGraph);\n", "\n", "    assertThat(graph.edgesConnecting(\"A\", \"A\")).containsExactly(\"AA\");\n", "    assertThat(graph.edgesConnecting(\"A\", \"B\")).containsExactly(\"AB\");\n", "    assertThat(graph.edgesConnecting(\"B\", \"A\")).isEmpty();\n", "  }\n", "\n", "  @Test\n", "  public void edgesConnecting_undirected() {\n", "    MutableNetwork<String, String> mutableGraph = NetworkBuilder.undirected().build();\n", "    mutableGraph.addEdge(\"AA\", \"A\", \"A\");\n", "    mutableGraph.addEdge(\"AB\", \"A\", \"B\");\n", "    Network<String, String> graph = ImmutableNetwork.copyOf(mutableGraph);\n", "\n", "    assertThat(graph.edgesConnecting(\"A\", \"A\")).containsExactly(\"AA\");\n", "    assertThat(graph.edgesConnecting(\"A\", \"B\")).containsExactly(\"AB\");\n", "    assertThat(graph.edgesConnecting(\"B\", \"A\")).containsExactly(\"AB\");\n", "  }\n", "}\n"]}, "removed": {}, "added_lines": {"1": [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 58, 59, 60, 61, 62, 63]}, "removed_lines": {}}, {"23": "guava-tests/test/com/google/common/graph/NetworkEqualsTest.java", "added": {"1": ["/*\n", " * Copyright (C) 2014 The Guava Authors\n", " *\n", " * Licensed under the Apache License, Version 2.0 (the \"License\");\n", " * you may not use this file except in compliance with the License.\n", " * You may obtain a copy of the License at\n", " *\n", " * http://www.apache.org/licenses/LICENSE-2.0\n", " *\n", " * Unless required by applicable law or agreed to in writing, software\n", " * distributed under the License is distributed on an \"AS IS\" BASIS,\n", " * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n", " * See the License for the specific language governing permissions and\n", " * limitations under the License.\n", " */\n", "\n", "package com.google.common.graph;\n", "\n", "import com.google.common.testing.EqualsTester;\n", "\n", "import org.junit.Test;\n", "import org.junit.runner.RunWith;\n", "import org.junit.runners.Parameterized;\n", "import org.junit.runners.Parameterized.Parameters;\n", "\n", "import java.util.Arrays;\n", "import java.util.Collection;\n", "\n", "@AndroidIncompatible\n", "// TODO(cpovirk): Figure out Android JUnit 4 support. Does it work with Gingerbread? @RunWith?\n", "@RunWith(Parameterized.class)\n", "public final class NetworkEqualsTest {\n", "  private static final Integer N1 = 1;\n", "  private static final Integer N2 = 2;\n", "  private static final Integer N3 = 3;\n", "\n", "  private static final String E11 = \"1-1\";\n", "  private static final String E12 = \"1-2\";\n", "  private static final String E12_A = \"1-2a\";\n", "  private static final String E13 = \"1-3\";\n", "\n", "  enum GraphType {\n", "    UNDIRECTED,\n", "    DIRECTED,\n", "    HYPER // not yet used because we don't yet have a Hypergraph implementation\n", "  }\n", "\n", "  private final GraphType graphType;\n", "  private final MutableNetwork<Integer, String> graph;\n", "\n", "  // add parameters: directed/undirected\n", "  @Parameters\n", "  public static Collection<Object[]> parameters() {\n", "    return Arrays.asList(new Object[][] {{GraphType.UNDIRECTED}, {GraphType.DIRECTED}});\n", "  }\n", "\n", "  public NetworkEqualsTest(GraphType graphType) {\n", "    this.graphType = graphType;\n", "    this.graph = createGraph(graphType);\n", "  }\n", "\n", "  private static MutableNetwork<Integer, String> createGraph(GraphType graphType) {\n", "    switch (graphType) {\n", "      case UNDIRECTED:\n", "        return NetworkBuilder.undirected().build();\n", "      case DIRECTED:\n", "        return NetworkBuilder.directed().build();\n", "      default:\n", "        throw new IllegalStateException(\"Unexpected graph type: \" + graphType);\n", "    }\n", "  }\n", "\n", "  private static GraphType oppositeType(GraphType graphType) {\n", "    switch (graphType) {\n", "      case UNDIRECTED:\n", "        return GraphType.DIRECTED;\n", "      case DIRECTED:\n", "        return GraphType.UNDIRECTED;\n", "      default:\n", "        throw new IllegalStateException(\"Unexpected graph type: \" + graphType);\n", "    }\n", "  }\n", "\n", "  @Test\n", "  public void equals_nodeSetsDiffer() {\n", "    graph.addNode(N1);\n", "\n", "    MutableNetwork<Integer, String> g2 = createGraph(graphType);\n", "    g2.addNode(N2);\n", "\n", "    new EqualsTester().addEqualityGroup(graph).addEqualityGroup(g2).testEquals();\n", "  }\n", "\n", "  // Node sets are the same, but edge sets differ.\n", "  @Test\n", "  public void equals_edgeSetsDiffer() {\n", "    graph.addEdge(E12, N1, N2);\n", "\n", "    MutableNetwork<Integer, String> g2 = createGraph(graphType);\n", "    g2.addEdge(E13, N1, N2);\n", "\n", "    new EqualsTester().addEqualityGroup(graph).addEqualityGroup(g2).testEquals();\n", "  }\n", "\n", "  // Node/edge sets are the same, but node/edge connections differ due to graph type.\n", "  @Test\n", "  public void equals_directedVsUndirected() {\n", "    graph.addEdge(E12, N1, N2);\n", "\n", "    MutableNetwork<Integer, String> g2 = createGraph(oppositeType(graphType));\n", "    g2.addEdge(E12, N1, N2);\n", "\n", "    new EqualsTester().addEqualityGroup(graph).addEqualityGroup(g2).testEquals();\n", "  }\n", "\n", "  // Node/edge sets and node/edge connections are the same, but types differ.\n", "  // (In this case the graphs are considered equal; the type differences are irrelevant.)\n", "  @Test\n", "  public void equals_selfLoop_directedVsUndirected() {\n", "    graph.addEdge(E11, N1, N1);\n", "\n", "    MutableNetwork<Integer, String> g2 = createGraph(oppositeType(graphType));\n", "    g2.addEdge(E11, N1, N1);\n", "\n", "    new EqualsTester().addEqualityGroup(graph, g2).testEquals();\n", "  }\n", "\n", "  // Node/edge sets are the same, but node/edge connections differ.\n", "  @Test\n", "  public void equals_connectionsDiffer() {\n", "    graph.addEdge(E12, N1, N2);\n", "    graph.addEdge(E13, N1, N3);\n", "\n", "    MutableNetwork<Integer, String> g2 = createGraph(graphType);\n", "    // connect E13 to N1 and N2, and E12 to N1 and N3 => not equal\n", "    g2.addEdge(E13, N1, N2);\n", "    g2.addEdge(E12, N1, N3);\n", "\n", "    new EqualsTester().addEqualityGroup(graph).addEqualityGroup(g2).testEquals();\n", "  }\n", "\n", "  // Node/edge sets and node/edge connections are the same, but graph properties differ.\n", "  // (In this case the graphs are considered equal; the property differences are irrelevant.)\n", "  @Test\n", "  public void equals_propertiesDiffer() {\n", "    graph.addEdge(E12, N1, N2);\n", "\n", "    MutableNetwork<Integer, String> g2 = NetworkBuilder.from(graph)\n", "        .allowsParallelEdges(!graph.allowsParallelEdges())\n", "        .allowsSelfLoops(!graph.allowsSelfLoops())\n", "        .build();\n", "    g2.addEdge(E12, N1, N2);\n", "\n", "    new EqualsTester().addEqualityGroup(graph, g2).testEquals();\n", "  }\n", "\n", "  // Node/edge sets and node/edge connections are the same, but edge order differs.\n", "  // (In this case the graphs are considered equal; the edge add orderings are irrelevant.)\n", "  @Test\n", "  public void equals_edgeAddOrdersDiffer() {\n", "    NetworkBuilder<Integer, String> builder = NetworkBuilder.from(graph).allowsParallelEdges(true);\n", "    MutableNetwork<Integer, String> g1 = builder.build();\n", "    MutableNetwork<Integer, String> g2 = builder.build();\n", "\n", "    // for ug1, add e12 first, then e12_a\n", "    g1.addEdge(E12, N1, N2);\n", "    g1.addEdge(E12_A, N1, N2);\n", "\n", "    // for ug2, add e12_a first, then e12\n", "    g2.addEdge(E12_A, N1, N2);\n", "    g2.addEdge(E12, N1, N2);\n", "\n", "    new EqualsTester().addEqualityGroup(g1, g2).testEquals();\n", "  }\n", "\n", "  @Test\n", "  public void equals_edgeDirectionsDiffer() {\n", "    graph.addEdge(E12, N1, N2);\n", "\n", "    MutableNetwork<Integer, String> g2 = createGraph(graphType);\n", "    g2.addEdge(E12, N2, N1);\n", "\n", "    switch (graphType) {\n", "      case UNDIRECTED:\n", "        new EqualsTester().addEqualityGroup(graph, g2).testEquals();\n", "        break;\n", "      case DIRECTED:\n", "        new EqualsTester().addEqualityGroup(graph).addEqualityGroup(g2).testEquals();\n", "        break;\n", "      default:\n", "        throw new IllegalStateException(\"Unexpected graph type: \" + graphType);\n", "    }\n", "  }\n", "}\n"]}, "removed": {}, "added_lines": {"1": [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 58, 59, 60, 61, 62, 63, 64, 65, 66, 67, 68, 69, 70, 71, 72, 73, 74, 75, 76, 77, 78, 79, 80, 81, 82, 83, 84, 85, 86, 87, 88, 89, 90, 91, 92, 93, 94, 95, 96, 97, 98, 99, 100, 101, 102, 103, 104, 105, 106, 107, 108, 109, 110, 111, 112, 113, 114, 115, 116, 117, 118, 119, 120, 121, 122, 123, 124, 125, 126, 127, 128, 129, 130, 131, 132, 133, 134, 135, 136, 137, 138, 139, 140, 141, 142, 143, 144, 145, 146, 147, 148, 149, 150, 151, 152, 153, 154, 155, 156, 157, 158, 159, 160, 161, 162, 163, 164, 165, 166, 167, 168, 169, 170, 171, 172, 173, 174, 175, 176, 177, 178, 179, 180, 181, 182, 183, 184, 185, 186, 187, 188, 189, 190, 191, 192, 193, 194]}, "removed_lines": {}}, {"24": "guava-tests/test/com/google/common/graph/PackageSanityTests.java", "added": {"1": ["import com.google.common.graph.testing.TestNetworkBuilder;\n"], "2": ["  private static final GraphBuilder<?> GRAPH_BUILDER_A =\n", "      GraphBuilder.directed().expectedNodeCount(10);\n", "  private static final GraphBuilder<?> GRAPH_BUILDER_B =\n", "  private static final ImmutableGraph<String> IMMUTABLE_GRAPH_A =\n", "      TestGraphBuilder.<String>init(GraphBuilder.directed())\n", "  private static final ImmutableGraph<String> IMMUTABLE_GRAPH_B =\n", "      TestGraphBuilder.<String>init(GraphBuilder.directed())\n", "  private static final NetworkBuilder<?, ?> NETWORK_BUILDER_A =\n", "      NetworkBuilder.directed().allowsParallelEdges(true).expectedNodeCount(10);\n", "  private static final NetworkBuilder<?, ?> NETWORK_BUILDER_B =\n", "      NetworkBuilder.directed().allowsSelfLoops(false).expectedNodeCount(16);\n", "\n", "  private static final ImmutableNetwork<String, String> IMMUTABLE_NETWORK_A =\n", "      TestNetworkBuilder.<String, String>init(NetworkBuilder.directed())\n", "          .addNode(\"A\")\n", "          .toImmutableNetwork();\n", "  private static final ImmutableNetwork<String, String> IMMUTABLE_NETWORK_B =\n", "      TestNetworkBuilder.<String, String>init(NetworkBuilder.directed())\n", "          .addNode(\"B\")\n", "          .toImmutableNetwork();\n", "\n", "    setDistinctValues(GraphBuilder.class, GRAPH_BUILDER_A, GRAPH_BUILDER_B);\n", "    setDistinctValues(NetworkBuilder.class, NETWORK_BUILDER_A, NETWORK_BUILDER_B);\n", "    setDistinctValues(Network.class, IMMUTABLE_NETWORK_A, IMMUTABLE_NETWORK_B);\n", "    // TODO(b/28091268): the below comment is obsolete now that GraphConfig no longer exists;\n", "    // what updating of this test do we need to do?\n", "    // testEquals() in ConfigurableUndirectedNetworkTest and ConfigurableDirectedNetworkTest.\n", "    // graphs by passing different instances of NetworkBuilder into their constructors. However,\n", "    // the NetworkBuilder instances are *not* used to determine equality for mutable graphs.\n"], "3": ["      assertThat(e.getCause().getMessage()).contains(\n", "          AbstractNetworkTest.ERROR_ELEMENT_NOT_IN_GRAPH);\n"]}, "removed": {"2": ["  private static final GraphBuilder<?, ?> BUILDER_A =\n", "      GraphBuilder.directed().allowsParallelEdges(true).expectedNodeCount(10);\n", "  private static final GraphBuilder<?, ?> BUILDER_B =\n", "  private static final ImmutableGraph<String, String> IMMUTABLE_GRAPH_A =\n", "      TestGraphBuilder.<String, String>init(GraphBuilder.directed())\n", "  private static final ImmutableGraph<String, String> IMMUTABLE_GRAPH_B =\n", "      TestGraphBuilder.<String, String>init(GraphBuilder.directed())\n", "    setDistinctValues(GraphBuilder.class, BUILDER_A, BUILDER_B);\n", "    // testEquals() methods in ConfigurableUndirectedGraphTest and ConfigurableDirectedGraphTest.\n", "    // graphs by passing different instances of GraphBuilder into their constructors. However,\n", "    // the GraphBuilder instances are *not* used to determine equality for mutable graphs.\n"], "3": ["      assertThat(e.getCause().getMessage()).contains(AbstractGraphTest.ERROR_ELEMENT_NOT_IN_GRAPH);\n"]}, "added_lines": {"1": [22], "2": [35, 36, 37, 40, 41, 44, 45, 49, 50, 51, 52, 53, 54, 55, 56, 57, 58, 59, 60, 61, 62, 64, 66, 67, 69, 70, 72, 74, 75], "3": [85, 86]}, "removed_lines": {"2": [34, 35, 36, 39, 40, 43, 44, 49, 53, 55, 56], "3": [66]}}, {"25": "guava/src/com/google/common/graph/AbstractConfigurableGraph.java", "added": {"1": ["/*\n", " * Copyright (C) 2016 The Guava Authors\n", " *\n", " * Licensed under the Apache License, Version 2.0 (the \"License\");\n", " * you may not use this file except in compliance with the License.\n", " * You may obtain a copy of the License at\n", " *\n", " * http://www.apache.org/licenses/LICENSE-2.0\n", " *\n", " * Unless required by applicable law or agreed to in writing, software\n", " * distributed under the License is distributed on an \"AS IS\" BASIS,\n", " * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n", " * See the License for the specific language governing permissions and\n", " * limitations under the License.\n", " */\n", "\n", "package com.google.common.graph;\n", "\n", "import static com.google.common.base.Preconditions.checkArgument;\n", "import static com.google.common.base.Preconditions.checkNotNull;\n", "import static com.google.common.graph.GraphErrorMessageUtils.NODE_NOT_IN_GRAPH;\n", "\n", "import com.google.common.collect.Maps;\n", "\n", "import java.util.Collections;\n", "import java.util.Map;\n", "import java.util.Set;\n", "\n", "/**\n", " * Abstract configurable implementation of {@link Graph} that supports the options supplied\n", " * by {@link GraphBuilder}.\n", " *\n", " * <p>This class maintains a map of {@link NodeAdjacencies} for every node.\n", " *\n", " * <p>{@code Set}-returning accessors return unmodifiable views: the view returned will reflect\n", " * changes to the graph (if the graph is mutable) but may not be modified by the user.\n", " * The behavior of the returned view is undefined in the following cases:\n", " * <ul>\n", " * <li>Removing the element on which the accessor is called (e.g.:\n", " *     <pre>{@code\n", " *     Set<N> adjacentNodes = adjacentNodes(node);\n", " *     graph.removeNode(node);}</pre>\n", " *     At this point, the contents of {@code adjacentNodes} are undefined.\n", " * </ul>\n", " *\n", " * <p>The time complexity of all {@code Set}-returning accessors is O(1), since views are returned.\n", " *\n", " * @author James Sexton\n", " * @author Joshua O'Madadhain\n", " * @author Omar Darwish\n", " * @param <N> Node parameter type\n", " */\n", "// TODO(b/24620028): Enable this class to support sorted nodes/edges.\n", "class AbstractConfigurableGraph<N> extends AbstractGraph<N> {\n", "  // The default of 11 is rather arbitrary, but roughly matches the sizing of just new HashMap()\n", "  private static final int DEFAULT_MAP_SIZE = 11;\n", "\n", "  private final boolean isDirected;\n", "  private final boolean allowsSelfLoops;\n", "\n", "  protected final Map<N, NodeAdjacencies<N>> nodeConnections;\n", "\n", "  /**\n", "   * Constructs a mutable graph with the properties specified in {@code builder}.\n", "   */\n", "  AbstractConfigurableGraph(GraphBuilder<? super N> builder) {\n", "    this(\n", "        builder,\n", "        Maps.<N, NodeAdjacencies<N>>newLinkedHashMapWithExpectedSize(\n", "            builder.expectedNodeCount.or(DEFAULT_MAP_SIZE)));\n", "  }\n", "\n", "  /**\n", "   * Constructs a graph with the properties specified in {@code builder}, initialized with\n", "   * the given node and edge maps. May be used for either mutable or immutable graphs.\n", "   */\n", "  AbstractConfigurableGraph(GraphBuilder<? super N> builder,\n", "      Map<N, NodeAdjacencies<N>> nodeConnections) {\n", "    this.isDirected = builder.directed;\n", "    this.allowsSelfLoops = builder.allowsSelfLoops;\n", "    this.nodeConnections = checkNotNull(nodeConnections);\n", "  }\n", "\n", "  @Override\n", "  public Set<N> nodes() {\n", "    return Collections.unmodifiableSet(nodeConnections.keySet());\n", "  }\n", "\n", "  @Override\n", "  public boolean isDirected() {\n", "    return isDirected;\n", "  }\n", "\n", "  @Override\n", "  public boolean allowsSelfLoops() {\n", "    return allowsSelfLoops;\n", "  }\n", "\n", "  @Override\n", "  public Set<N> adjacentNodes(Object node) {\n", "    return checkedConnections(node).adjacentNodes();\n", "  }\n", "\n", "  @Override\n", "  public Set<N> predecessors(Object node) {\n", "    return checkedConnections(node).predecessors();\n", "  }\n", "\n", "  @Override\n", "  public Set<N> successors(Object node) {\n", "    return checkedConnections(node).successors();\n", "  }\n", "\n", "  protected NodeAdjacencies<N> checkedConnections(Object node) {\n", "    checkNotNull(node, \"node\");\n", "    NodeAdjacencies<N> connections = nodeConnections.get(node);\n", "    checkArgument(connections != null, NODE_NOT_IN_GRAPH, node);\n", "    return connections;\n", "  }\n", "}\n"]}, "removed": {}, "added_lines": {"1": [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 58, 59, 60, 61, 62, 63, 64, 65, 66, 67, 68, 69, 70, 71, 72, 73, 74, 75, 76, 77, 78, 79, 80, 81, 82, 83, 84, 85, 86, 87, 88, 89, 90, 91, 92, 93, 94, 95, 96, 97, 98, 99, 100, 101, 102, 103, 104, 105, 106, 107, 108, 109, 110, 111, 112, 113, 114, 115, 116, 117, 118, 119, 120]}, "removed_lines": {}}, {"26": "guava/src/com/google/common/graph/AbstractConfigurableNetwork.java", "added": {"1": ["/*\n", " * Copyright (C) 2016 The Guava Authors\n", " *\n", " * Licensed under the Apache License, Version 2.0 (the \"License\");\n", " * you may not use this file except in compliance with the License.\n", " * You may obtain a copy of the License at\n", " *\n", " * http://www.apache.org/licenses/LICENSE-2.0\n", " *\n", " * Unless required by applicable law or agreed to in writing, software\n", " * distributed under the License is distributed on an \"AS IS\" BASIS,\n", " * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n", " * See the License for the specific language governing permissions and\n", " * limitations under the License.\n", " */\n", "\n", "package com.google.common.graph;\n", "\n", "import static com.google.common.base.Preconditions.checkArgument;\n", "import static com.google.common.base.Preconditions.checkNotNull;\n", "import static com.google.common.graph.GraphErrorMessageUtils.EDGE_NOT_IN_GRAPH;\n", "import static com.google.common.graph.GraphErrorMessageUtils.NODE_NOT_IN_GRAPH;\n", "import static com.google.common.graph.GraphErrorMessageUtils.NOT_AVAILABLE_ON_UNDIRECTED;\n", "\n", "import com.google.common.collect.ImmutableSet;\n", "import com.google.common.collect.Maps;\n", "import com.google.common.collect.Sets;\n", "\n", "import java.util.Collections;\n", "import java.util.Iterator;\n", "import java.util.Map;\n", "import java.util.Set;\n", "\n", "/**\n", " * Abstract configurable implementation of {@link Network} that supports the options supplied\n", " * by {@link NetworkBuilder}.\n", " *\n", " * <p>This class maintains a map of {@link NodeConnections} for every node\n", " * and {@link IncidentNodes} for every edge.\n", " *\n", " * <p>{@code Set}-returning accessors return unmodifiable views: the view returned will reflect\n", " * changes to the graph (if the graph is mutable) but may not be modified by the user.\n", " * The behavior of the returned view is undefined in the following cases:\n", " * <ul>\n", " * <li>Removing the element on which the accessor is called (e.g.:\n", " *     <pre>{@code\n", " *     Set<N> adjacentNodes = adjacentNodes(node);\n", " *     graph.removeNode(node);}</pre>\n", " *     At this point, the contents of {@code adjacentNodes} are undefined.\n", " * </ul>\n", " *\n", " * <p>The time complexity of all {@code Set}-returning accessors is O(1), since views are returned.\n", " *\n", " * @author James Sexton\n", " * @author Joshua O'Madadhain\n", " * @author Omar Darwish\n", " * @param <N> Node parameter type\n", " * @param <E> Edge parameter type\n", " */\n", "// TODO(b/24620028): Enable this class to support sorted nodes/edges.\n", "class AbstractConfigurableNetwork<N, E> extends AbstractNetwork<N, E> {\n", "  // The default of 11 is rather arbitrary, but roughly matches the sizing of just new HashMap()\n", "  private static final int DEFAULT_MAP_SIZE = 11;\n", "\n", "  private final boolean isDirected;\n", "  private final boolean allowsParallelEdges;\n", "  private final boolean allowsSelfLoops;\n", "\n", "  protected final Map<N, NodeConnections<N, E>> nodeConnections;\n", "  protected final Map<E, IncidentNodes<N>> edgeToIncidentNodes;\n", "\n", "  /**\n", "   * Constructs a mutable graph with the properties specified in {@code builder}.\n", "   */\n", "  AbstractConfigurableNetwork(NetworkBuilder<? super N, ? super E> builder) {\n", "    this(\n", "        builder,\n", "        Maps.<N, NodeConnections<N, E>>newLinkedHashMapWithExpectedSize(\n", "            builder.expectedNodeCount.or(DEFAULT_MAP_SIZE)),\n", "        Maps.<E, IncidentNodes<N>>newLinkedHashMapWithExpectedSize(\n", "            builder.expectedEdgeCount.or(DEFAULT_MAP_SIZE)));\n", "  }\n", "\n", "  /**\n", "   * Constructs a graph with the properties specified in {@code builder}, initialized with\n", "   * the given node and edge maps. May be used for either mutable or immutable graphs.\n", "   */\n", "  AbstractConfigurableNetwork(NetworkBuilder<? super N, ? super E> builder,\n", "      Map<N, NodeConnections<N, E>> nodeConnections,\n", "      Map<E, IncidentNodes<N>> edgeToIncidentNodes) {\n", "    this.isDirected = builder.directed;\n", "    this.allowsParallelEdges = builder.allowsParallelEdges;\n", "    this.allowsSelfLoops = builder.allowsSelfLoops;\n", "    this.nodeConnections = checkNotNull(nodeConnections);\n", "    this.edgeToIncidentNodes = checkNotNull(edgeToIncidentNodes);\n", "  }\n", "\n", "  @Override\n", "  public Set<N> nodes() {\n", "    return Collections.unmodifiableSet(nodeConnections.keySet());\n", "  }\n", "\n", "  @Override\n", "  public Set<E> edges() {\n", "    return Collections.unmodifiableSet(edgeToIncidentNodes.keySet());\n", "  }\n", "\n", "  @Override\n", "  public boolean isDirected() {\n", "    return isDirected;\n", "  }\n", "\n", "  @Override\n", "  public boolean allowsParallelEdges() {\n", "    return allowsParallelEdges;\n", "  }\n", "\n", "  @Override\n", "  public boolean allowsSelfLoops() {\n", "    return allowsSelfLoops;\n", "  }\n", "\n", "  @Override\n", "  public Set<E> incidentEdges(Object node) {\n", "    return checkedConnections(node).incidentEdges();\n", "  }\n", "\n", "  @Override\n", "  public Set<N> incidentNodes(Object edge) {\n", "    return checkedIncidentNodes(edge);\n", "  }\n", "\n", "  @Override\n", "  public Set<N> adjacentNodes(Object node) {\n", "    return checkedConnections(node).adjacentNodes();\n", "  }\n", "\n", "  @Override\n", "  public Set<E> adjacentEdges(Object edge) {\n", "    Iterator<N> incidentNodesIterator = incidentNodes(edge).iterator();\n", "    Set<E> endpointsIncidentEdges = incidentEdges(incidentNodesIterator.next());\n", "    while (incidentNodesIterator.hasNext()) {\n", "      endpointsIncidentEdges =\n", "          Sets.union(incidentEdges(incidentNodesIterator.next()), endpointsIncidentEdges);\n", "    }\n", "    return Sets.difference(endpointsIncidentEdges, ImmutableSet.of(edge));\n", "  }\n", "\n", "  /**\n", "   * If {@code node1} is equal to {@code node2}, the set of self-loop edges is returned.\n", "   * Otherwise, returns the intersection of these two sets, using {@link Sets#intersection}:\n", "   * <ol>\n", "   * <li>Outgoing edges of {@code node1}.\n", "   * <li>Incoming edges of {@code node2}.\n", "   * </ol>\n", "   */\n", "  @Override\n", "  public Set<E> edgesConnecting(Object node1, Object node2) {\n", "    Set<E> outEdgesN1 = outEdges(node1); // Verifies that node1 is in graph\n", "    if (node1.equals(node2)) {\n", "      if (!allowsSelfLoops) {\n", "        return ImmutableSet.of();\n", "      }\n", "      Set<E> selfLoopEdges = Sets.filter(outEdgesN1, Graphs.selfLoopPredicate(this));\n", "      return Collections.unmodifiableSet(selfLoopEdges);\n", "    }\n", "    Set<E> inEdgesN2 = inEdges(node2);\n", "    return (outEdgesN1.size() <= inEdgesN2.size())\n", "        ? Sets.intersection(outEdgesN1, inEdgesN2)\n", "        : Sets.intersection(inEdgesN2, outEdgesN1);\n", "  }\n", "\n", "  @Override\n", "  public Set<E> inEdges(Object node) {\n", "    return checkedConnections(node).inEdges();\n", "  }\n", "\n", "  @Override\n", "  public Set<E> outEdges(Object node) {\n", "    return checkedConnections(node).outEdges();\n", "  }\n", "\n", "  @Override\n", "  public Set<N> predecessors(Object node) {\n", "    return checkedConnections(node).predecessors();\n", "  }\n", "\n", "  @Override\n", "  public Set<N> successors(Object node) {\n", "    return checkedConnections(node).successors();\n", "  }\n", "\n", "  @Override\n", "  public N source(Object edge) {\n", "    if (!isDirected) {\n", "      throw new UnsupportedOperationException(NOT_AVAILABLE_ON_UNDIRECTED);\n", "    }\n", "    return checkedIncidentNodes(edge).node1();\n", "  }\n", "\n", "  @Override\n", "  public N target(Object edge) {\n", "    if (!isDirected) {\n", "      throw new UnsupportedOperationException(NOT_AVAILABLE_ON_UNDIRECTED);\n", "    }\n", "    return checkedIncidentNodes(edge).node2();\n", "  }\n", "\n", "  protected NodeConnections<N, E> checkedConnections(Object node) {\n", "    checkNotNull(node, \"node\");\n", "    NodeConnections<N, E> connections = nodeConnections.get(node);\n", "    checkArgument(connections != null, NODE_NOT_IN_GRAPH, node);\n", "    return connections;\n", "  }\n", "\n", "  protected IncidentNodes<N> checkedIncidentNodes(Object edge) {\n", "    checkNotNull(edge, \"edge\");\n", "    IncidentNodes<N> incidentNodes = edgeToIncidentNodes.get(edge);\n", "    checkArgument(incidentNodes != null, EDGE_NOT_IN_GRAPH, edge);\n", "    return incidentNodes;\n", "  }\n", "}\n"]}, "removed": {}, "added_lines": {"1": [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 58, 59, 60, 61, 62, 63, 64, 65, 66, 67, 68, 69, 70, 71, 72, 73, 74, 75, 76, 77, 78, 79, 80, 81, 82, 83, 84, 85, 86, 87, 88, 89, 90, 91, 92, 93, 94, 95, 96, 97, 98, 99, 100, 101, 102, 103, 104, 105, 106, 107, 108, 109, 110, 111, 112, 113, 114, 115, 116, 117, 118, 119, 120, 121, 122, 123, 124, 125, 126, 127, 128, 129, 130, 131, 132, 133, 134, 135, 136, 137, 138, 139, 140, 141, 142, 143, 144, 145, 146, 147, 148, 149, 150, 151, 152, 153, 154, 155, 156, 157, 158, 159, 160, 161, 162, 163, 164, 165, 166, 167, 168, 169, 170, 171, 172, 173, 174, 175, 176, 177, 178, 179, 180, 181, 182, 183, 184, 185, 186, 187, 188, 189, 190, 191, 192, 193, 194, 195, 196, 197, 198, 199, 200, 201, 202, 203, 204, 205, 206, 207, 208, 209, 210, 211, 212, 213, 214, 215, 216, 217, 218, 219, 220, 221, 222]}, "removed_lines": {}}, {"27": "guava/src/com/google/common/graph/AbstractGraph.java", "added": {"1": ["public abstract class AbstractGraph<N> implements Graph<N> {\n", "    // only works for non-multigraphs; multigraphs not yet supported\n", "    return adjacentNodes(node).size();\n", "    // only works for non-multigraphs; multigraphs not yet supported\n", "    return predecessors(node).size();\n", "    // only works for non-multigraphs; multigraphs not yet supported\n", "    return successors(node).size();\n"], "2": ["    return Graphs.equal(this, (Graph<?>) object);\n"]}, "removed": {"1": [" * @param <E> Edge parameter type\n", "public abstract class AbstractGraph<N, E> implements Graph<N, E> {\n", "    return incidentEdges(node).size();\n", "    return inEdges(node).size();\n", "    return outEdges(node).size();\n"], "2": ["    return Graphs.equal(this, (Graph<?, ?>) object);\n"]}, "added_lines": {"1": [29, 33, 34, 39, 40, 45, 46], "2": [54]}, "removed_lines": {"1": [28, 30, 34, 39, 44], "2": [52]}}, {"28": "guava/src/com/google/common/graph/AbstractNetwork.java", "added": {"1": ["/*\n", " * Copyright (C) 2016 The Guava Authors\n", " *\n", " * Licensed under the Apache License, Version 2.0 (the \"License\");\n", " * you may not use this file except in compliance with the License.\n", " * You may obtain a copy of the License at\n", " *\n", " * http://www.apache.org/licenses/LICENSE-2.0\n", " *\n", " * Unless required by applicable law or agreed to in writing, software\n", " * distributed under the License is distributed on an \"AS IS\" BASIS,\n", " * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n", " * See the License for the specific language governing permissions and\n", " * limitations under the License.\n", " */\n", "\n", "package com.google.common.graph;\n", "\n", "import javax.annotation.Nullable;\n", "\n", "/**\n", " * This class provides a skeletal implementation of {@link Graph}. It is recommended to extend this\n", " * class rather than implement {@link Graph} directly, to ensure consistent {@link #equals(Object)}\n", " * and {@link #hashCode()} results across different graph implementations.\n", " *\n", " * @author James Sexton\n", " * @param <N> Node parameter type\n", " * @param <E> Edge parameter type\n", " */\n", "public abstract class AbstractNetwork<N, E> implements Network<N, E> {\n", "\n", "  @Override\n", "  public int degree(Object node) {\n", "    return incidentEdges(node).size();\n", "  }\n", "\n", "  @Override\n", "  public int inDegree(Object node) {\n", "    return inEdges(node).size();\n", "  }\n", "\n", "  @Override\n", "  public int outDegree(Object node) {\n", "    return outEdges(node).size();\n", "  }\n", "\n", "  @Override\n", "  public boolean equals(@Nullable Object object) {\n", "    if (!(object instanceof Network)) {\n", "      return false;\n", "    }\n", "    return Graphs.equal(this, (Network<?, ?>) object);\n", "  }\n", "\n", "  @Override\n", "  public int hashCode() {\n", "    return Graphs.hashCode(this);\n", "  }\n", "\n", "  @Override\n", "  public String toString() {\n", "    return Graphs.toString(this);\n", "  }\n", "}\n"]}, "removed": {}, "added_lines": {"1": [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 58, 59, 60, 61, 62, 63, 64]}, "removed_lines": {}}, {"29": "guava/src/com/google/common/graph/ConfigurableGraph.java", "added": {"1": [" * <p>Time complexities for mutation methods are all O(1) except for {@code removeNode(N node)},\n", " * which is in O(d_node) where d_node is the degree of {@code node}.\n", "class ConfigurableGraph<N> extends AbstractConfigurableGraph<N> implements MutableGraph<N> {\n", "  ConfigurableGraph(GraphBuilder<? super N> builder) {\n", "    super(builder);\n", "   * the given node maps. May be used for either mutable or immutable graphs.\n", "  ConfigurableGraph(GraphBuilder<? super N> builder,\n", "      Map<N, NodeAdjacencies<N>> nodeConnections) {\n", "    super(builder, nodeConnections);\n"], "2": ["   * Add an edge between {@code node1} and {@code node2}; if these nodes are not already\n", "   * present in this graph, then add them.\n", "   * Return {@code false} if an edge already exists between {@code node1} and {@code node2},\n", "   * @throws IllegalArgumentException if self-loops are not allowed, and {@code node1} is equal to\n", "   *     {@code node2}.\n", "  public boolean addEdge(N node1, N node2) {\n", "    checkArgument(allowsSelfLoops() || !node1.equals(node2), SELF_LOOPS_NOT_ALLOWED, node1);\n", "    // TODO(user): does not support parallel edges\n", "    if (containsN1 && containsN2 && nodeConnections.get(node1).successors().contains(node2)) {\n", "    NodeAdjacencies<N> connectionsN1 = nodeConnections.get(node1);\n", "    connectionsN1.addSuccessor(node2);\n", "    NodeAdjacencies<N> connectionsN2 = nodeConnections.get(node2);\n", "    connectionsN2.addPredecessor(node1);\n"], "3": ["    for (N successor : nodeConnections.get(node).successors()) {\n", "      if (!node.equals(successor)) {\n", "        // don't remove the successor if it's the input node (=> CME); will be removed below\n", "        nodeConnections.get(successor).removePredecessor(node);\n", "      }\n", "    }\n", "    for (N predecessor : nodeConnections.get(node).predecessors()) {\n", "      nodeConnections.get(predecessor).removeSuccessor(node);\n"], "4": ["  public boolean removeEdge(Object node1, Object node2) {\n", "    checkNotNull(node1, \"node1\");\n", "    checkNotNull(node2, \"node2\");\n", "    NodeAdjacencies<N> connectionsN1 = nodeConnections.get(node1);\n", "    NodeAdjacencies<N> connectionsN2 = nodeConnections.get(node2);\n", "    if (connectionsN1 == null || connectionsN2 == null) {\n", "    boolean result = connectionsN1.removeSuccessor(node2);\n", "    connectionsN2.removePredecessor(node1);\n", "    return result;\n", "  private NodeAdjacencies<N> newNodeConnections() {\n", "    return isDirected()\n", "        ? DirectedNodeAdjacencies.<N>of()\n", "        : UndirectedNodeAdjacencies.<N>of();\n"]}, "removed": {"1": ["import static com.google.common.graph.GraphErrorMessageUtils.ADDING_PARALLEL_EDGE;\n", "import static com.google.common.graph.GraphErrorMessageUtils.EDGE_NOT_IN_GRAPH;\n", "import static com.google.common.graph.GraphErrorMessageUtils.NODE_NOT_IN_GRAPH;\n", "import static com.google.common.graph.GraphErrorMessageUtils.NOT_AVAILABLE_ON_UNDIRECTED;\n", "import static com.google.common.graph.GraphErrorMessageUtils.REUSING_EDGE;\n", "import com.google.common.collect.ImmutableList;\n", "import com.google.common.collect.ImmutableSet;\n", "import com.google.common.collect.Maps;\n", "import com.google.common.collect.Sets;\n", "import java.util.Collections;\n", "import java.util.Iterator;\n", "import java.util.Set;\n", " * <p>This class maintains a map of {@link NodeConnections} for every node\n", " * and {@link IncidentNodes} for every edge.\n", " *\n", " * <p>{@code Set}-returning accessors return unmodifiable views: the view returned will reflect\n", " * changes to the graph (if the graph is mutable) but may not be modified by the user.\n", " * The behavior of the returned view is undefined in the following cases:\n", " * <ul>\n", " * <li>Removing the element on which the accessor is called (e.g.:\n", " *     <pre>{@code\n", " *     Set<N> adjacentNodes = adjacentNodes(node);\n", " *     graph.removeNode(node);}</pre>\n", " *     At this point, the contents of {@code adjacentNodes} are undefined.\n", " * </ul>\n", " *\n", " * <p>The time complexity of all {@code Set}-returning accessors is O(1), since views are returned.\n", " *\n", " * <p>Time complexities for mutation methods:\n", " * <ul>\n", " * <li>{@code addNode(N node)}: O(1).\n", " * <li>{@code addEdge(E edge, N node1, N node2)}: O(1).\n", " * <li>{@code removeNode(N node)}: O(d_node).\n", " * <li>{@code removeEdge(E edge)}: O(1), unless this graph allows parallel edges;\n", " *     in that case this method is O(min(outD_edgeSource, inD_edgeTarget)).\n", " * </ul>\n", " * where d_node is the degree of node, inD_node is the in-degree of node, and outD_node is the\n", " * out-degree of node.\n", " * @param <E> Edge parameter type\n", "class ConfigurableGraph<N, E> extends AbstractGraph<N, E> {\n", "  // The default of 11 is rather arbitrary, but roughly matches the sizing of just new HashMap()\n", "  private static final int DEFAULT_MAP_SIZE = 11;\n", "\n", "  private final boolean isDirected;\n", "  private final boolean allowsParallelEdges;\n", "  private final boolean allowsSelfLoops;\n", "\n", "  private final Map<N, NodeConnections<N, E>> nodeConnections;\n", "  private final Map<E, IncidentNodes<N>> edgeToIncidentNodes;\n", "\n", "  ConfigurableGraph(GraphBuilder<? super N, ? super E> builder) {\n", "    this(\n", "        builder,\n", "        Maps.<N, NodeConnections<N, E>>newLinkedHashMapWithExpectedSize(\n", "            builder.expectedNodeCount.or(DEFAULT_MAP_SIZE)),\n", "        Maps.<E, IncidentNodes<N>>newLinkedHashMapWithExpectedSize(\n", "            builder.expectedEdgeCount.or(DEFAULT_MAP_SIZE)));\n", "   * the given node and edge maps. May be used for either mutable or immutable graphs.\n", "  ConfigurableGraph(GraphBuilder<? super N, ? super E> builder,\n", "      Map<N, NodeConnections<N, E>> nodeConnections,\n", "      Map<E, IncidentNodes<N>> edgeToIncidentNodes) {\n", "    this.isDirected = builder.directed;\n", "    this.allowsParallelEdges = builder.allowsParallelEdges;\n", "    this.allowsSelfLoops = builder.allowsSelfLoops;\n", "    this.nodeConnections = checkNotNull(nodeConnections);\n", "    this.edgeToIncidentNodes = checkNotNull(edgeToIncidentNodes);\n", "  }\n", "\n", "  @Override\n", "  public Set<N> nodes() {\n", "    return Collections.unmodifiableSet(nodeConnections.keySet());\n", "  }\n", "\n", "  @Override\n", "  public Set<E> edges() {\n", "    return Collections.unmodifiableSet(edgeToIncidentNodes.keySet());\n", "  }\n", "\n", "  @Override\n", "  public boolean isDirected() {\n", "    return isDirected;\n", "  }\n", "\n", "  @Override\n", "  public boolean allowsParallelEdges() {\n", "    return allowsParallelEdges;\n", "  }\n", "\n", "  @Override\n", "  public boolean allowsSelfLoops() {\n", "    return allowsSelfLoops;\n", "  }\n", "\n", "  @Override\n", "  public Set<E> incidentEdges(Object node) {\n", "    return checkedConnections(node).incidentEdges();\n", "  }\n", "\n", "  @Override\n", "  public Set<N> incidentNodes(Object edge) {\n", "    return checkedIncidentNodes(edge);\n", "  }\n", "\n", "  @Override\n", "  public Set<N> adjacentNodes(Object node) {\n", "    return checkedConnections(node).adjacentNodes();\n", "  @Override\n", "  public Set<E> adjacentEdges(Object edge) {\n", "    Iterator<N> incidentNodesIterator = incidentNodes(edge).iterator();\n", "    Set<E> endpointsIncidentEdges = incidentEdges(incidentNodesIterator.next());\n", "    while (incidentNodesIterator.hasNext()) {\n", "      endpointsIncidentEdges =\n", "          Sets.union(incidentEdges(incidentNodesIterator.next()), endpointsIncidentEdges);\n", "    }\n", "    return Sets.difference(endpointsIncidentEdges, ImmutableSet.of(edge));\n", "  }\n", "\n", "  /**\n", "   * If {@code node1} is equal to {@code node2}, the set of self-loop edges is returned.\n", "   * Otherwise, returns the intersection of these two sets, using {@link Sets#intersection}:\n", "   * <ol>\n", "   * <li>Outgoing edges of {@code node1}.\n", "   * <li>Incoming edges of {@code node2}.\n", "   * </ol>\n", "   */\n", "  @Override\n", "  public Set<E> edgesConnecting(Object node1, Object node2) {\n", "    Set<E> outEdgesN1 = outEdges(node1); // Verifies that node1 is in graph\n", "    if (node1.equals(node2)) {\n", "      if (!allowsSelfLoops) {\n", "        return ImmutableSet.of();\n", "      }\n", "      Set<E> selfLoopEdges = Sets.filter(outEdgesN1, Graphs.selfLoopPredicate(this));\n", "      return Collections.unmodifiableSet(selfLoopEdges);\n", "    }\n", "    Set<E> inEdgesN2 = inEdges(node2);\n", "    return (outEdgesN1.size() <= inEdgesN2.size())\n", "        ? Sets.intersection(outEdgesN1, inEdgesN2)\n", "        : Sets.intersection(inEdgesN2, outEdgesN1);\n", "  }\n", "\n", "  @Override\n", "  public Set<E> inEdges(Object node) {\n", "    return checkedConnections(node).inEdges();\n", "  }\n", "\n", "  @Override\n", "  public Set<E> outEdges(Object node) {\n", "    return checkedConnections(node).outEdges();\n", "  }\n", "\n", "  @Override\n", "  public Set<N> predecessors(Object node) {\n", "    return checkedConnections(node).predecessors();\n", "  }\n", "\n", "  @Override\n", "  public Set<N> successors(Object node) {\n", "    return checkedConnections(node).successors();\n", "  }\n", "\n", "  @Override\n", "  public N source(Object edge) {\n", "    if (!isDirected) {\n", "      throw new UnsupportedOperationException(NOT_AVAILABLE_ON_UNDIRECTED);\n", "    }\n", "    return checkedIncidentNodes(edge).node1();\n", "  }\n", "\n", "  @Override\n", "  public N target(Object edge) {\n", "    if (!isDirected) {\n", "      throw new UnsupportedOperationException(NOT_AVAILABLE_ON_UNDIRECTED);\n", "    }\n", "    return checkedIncidentNodes(edge).node2();\n", "  }\n", "\n", "  // Element Mutation\n", "\n"], "2": ["   * Add nodes that are not elements of the graph, then add {@code edge} between them.\n", "   * Return {@code false} if {@code edge} already exists between {@code node1} and {@code node2},\n", "   * @throws IllegalArgumentException if an edge (other than {@code edge}) already\n", "   *         exists from {@code node1} to {@code node2}, and this is not a multigraph.\n", "   *         Also, if self-loops are not allowed, and {@code node1} is equal to {@code node2}.\n", "  public boolean addEdge(E edge, N node1, N node2) {\n", "    checkNotNull(edge, \"edge\");\n", "    IncidentNodes<N> incidentNodes = IncidentNodes.of(node1, node2);\n", "    checkArgument(allowsSelfLoops || !incidentNodes.isSelfLoop(), SELF_LOOPS_NOT_ALLOWED, node1);\n", "    if (edges().contains(edge)) {\n", "      checkArgument(containsN1 && containsN2 && edgesConnecting(node1, node2).contains(edge),\n", "          REUSING_EDGE, edge, incidentNodes(edge), incidentNodes);\n", "    } else if (!allowsParallelEdges) {\n", "      checkArgument(!(containsN1 && containsN2 && successors(node1).contains(node2)),\n", "          ADDING_PARALLEL_EDGE, node1, node2);\n", "    NodeConnections<N, E> connectionsN1 = nodeConnections.get(node1);\n", "    connectionsN1.addSuccessor(node2, edge);\n", "    NodeConnections<N, E> connectionsN2 = nodeConnections.get(node2);\n", "    connectionsN2.addPredecessor(node1, edge);\n", "    edgeToIncidentNodes.put(edge, incidentNodes);\n"], "3": ["    // Since views are returned, we need to copy the edges that will be removed.\n", "    // Thus we avoid modifying the underlying view while iterating over it.\n", "    for (E edge : ImmutableList.copyOf(incidentEdges(node))) {\n", "      // Simply calling removeEdge(edge) would result in O(degree^2) behavior. However, we know that\n", "      // after all incident edges are removed, the input node will be disconnected from all others.\n", "      removeEdgeAndUpdateConnections(edge, true);\n"], "4": ["  public boolean removeEdge(Object edge) {\n", "    checkNotNull(edge, \"edge\");\n", "    if (!edges().contains(edge)) {\n", "    // If there are no parallel edges, the removal of this edge will disconnect the incident nodes.\n", "    removeEdgeAndUpdateConnections(edge, Graphs.parallelEdges(this, edge).isEmpty());\n", "    return true;\n", "  }\n", "\n", "  /**\n", "   * If {@code disconnectIncidentNodes} is true, disconnects the nodes formerly connected\n", "   * by {@code edge}. This should be set when all parallel edges are or will be removed.\n", "   *\n", "   * <p>Unlike {@link #removeEdge(Object)}, this method is guaranteed to run in O(1) time.\n", "   *\n", "   * @throws IllegalArgumentException if {@code edge} is not present in the graph.\n", "   */\n", "  private void removeEdgeAndUpdateConnections(Object edge, boolean disconnectIncidentNodes) {\n", "    IncidentNodes<N> incidentNodes = checkedIncidentNodes(edge);\n", "    N node1 = incidentNodes.node1();\n", "    N node2 = incidentNodes.node2();\n", "    NodeConnections<N, E> connectionsN1 = nodeConnections.get(node1);\n", "    NodeConnections<N, E> connectionsN2 = nodeConnections.get(node2);\n", "    if (disconnectIncidentNodes) {\n", "      connectionsN1.removeSuccessor(node2);\n", "      connectionsN2.removePredecessor(node1);\n", "    }\n", "    connectionsN1.removeOutEdge(edge);\n", "    connectionsN2.removeInEdge(edge);\n", "    edgeToIncidentNodes.remove(edge);\n", "  }\n", "\n", "  private NodeConnections<N, E> newNodeConnections() {\n", "    return isDirected\n", "        ? DirectedNodeConnections.<N, E>of()\n", "        : UndirectedNodeConnections.<N, E>of();\n", "  }\n", "\n", "  private NodeConnections<N, E> checkedConnections(Object node) {\n", "    checkNotNull(node, \"node\");\n", "    NodeConnections<N, E> connections = nodeConnections.get(node);\n", "    checkArgument(connections != null, NODE_NOT_IN_GRAPH, node);\n", "    return connections;\n", "  private IncidentNodes<N> checkedIncidentNodes(Object edge) {\n", "    checkNotNull(edge, \"edge\");\n", "    IncidentNodes<N> incidentNodes = edgeToIncidentNodes.get(edge);\n", "    checkArgument(incidentNodes != null, EDGE_NOT_IN_GRAPH, edge);\n", "    return incidentNodes;\n"]}, "added_lines": {"1": [31, 32, 40, 44, 45, 50, 52, 53, 54], "2": [69, 70, 71, 74, 75, 79, 82, 85, 86, 92, 93, 97, 98], "3": [109, 110, 111, 112, 113, 114, 115, 116], "4": [124, 125, 126, 127, 128, 129, 132, 133, 134, 137, 138, 139, 140]}, "removed_lines": {"1": [21, 22, 23, 24, 25, 28, 29, 30, 31, 34, 35, 37, 43, 44, 45, 46, 47, 48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 58, 59, 60, 61, 62, 63, 64, 65, 66, 67, 68, 74, 77, 78, 79, 80, 81, 82, 83, 84, 85, 86, 87, 91, 92, 93, 94, 95, 96, 97, 102, 104, 105, 106, 107, 108, 109, 110, 111, 112, 113, 114, 115, 116, 117, 118, 119, 120, 121, 122, 123, 124, 125, 126, 127, 128, 129, 130, 131, 132, 133, 134, 135, 136, 137, 138, 139, 140, 141, 142, 143, 144, 145, 146, 147, 148, 149, 150, 151, 154, 155, 156, 157, 158, 159, 160, 161, 162, 163, 164, 165, 166, 167, 168, 169, 170, 171, 172, 173, 174, 175, 176, 177, 178, 179, 180, 181, 182, 183, 184, 185, 186, 187, 188, 189, 190, 191, 192, 193, 194, 195, 196, 197, 198, 199, 200, 201, 202, 203, 204, 205, 206, 207, 208, 209, 210, 211, 212, 213, 214, 215, 216, 217, 218, 219, 220, 221, 222, 223, 224, 225, 226], "2": [239, 240, 243, 244, 245, 249, 250, 253, 254, 257, 258, 259, 261, 262, 263, 268, 269, 273, 274, 275], "3": [286, 287, 288, 289, 290, 291], "4": [299, 300, 301, 304, 305, 306, 307, 308, 309, 310, 311, 312, 313, 314, 315, 316, 317, 318, 319, 320, 321, 322, 323, 324, 325, 326, 327, 328, 329, 330, 331, 332, 333, 334, 335, 336, 337, 338, 339, 340, 341, 342, 345, 346, 347, 348, 349]}}, {"30": "guava/src/com/google/common/graph/ConfigurableNetwork.java", "added": {"1": ["/*\n", " * Copyright (C) 2016 The Guava Authors\n", " *\n", " * Licensed under the Apache License, Version 2.0 (the \"License\");\n", " * you may not use this file except in compliance with the License.\n", " * You may obtain a copy of the License at\n", " *\n", " * http://www.apache.org/licenses/LICENSE-2.0\n", " *\n", " * Unless required by applicable law or agreed to in writing, software\n", " * distributed under the License is distributed on an \"AS IS\" BASIS,\n", " * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n", " * See the License for the specific language governing permissions and\n", " * limitations under the License.\n", " */\n", "\n", "package com.google.common.graph;\n", "\n", "import static com.google.common.base.Preconditions.checkArgument;\n", "import static com.google.common.base.Preconditions.checkNotNull;\n", "import static com.google.common.graph.GraphErrorMessageUtils.ADDING_PARALLEL_EDGE;\n", "import static com.google.common.graph.GraphErrorMessageUtils.REUSING_EDGE;\n", "import static com.google.common.graph.GraphErrorMessageUtils.SELF_LOOPS_NOT_ALLOWED;\n", "\n", "import com.google.common.collect.ImmutableList;\n", "import com.google.errorprone.annotations.CanIgnoreReturnValue;\n", "\n", "import java.util.Map;\n", "\n", "/**\n", " * Configurable implementation of {@link Network} that supports both directed and undirected graphs.\n", " * Instances of this class should be constructed with {@link NetworkBuilder}.\n", " *\n", "  * <p>Time complexities for mutation methods:\n", " * <ul>\n", " * <li>{@code addNode(N node)}: O(1).\n", " * <li>{@code addEdge(E edge, N node1, N node2)}: O(1).\n", " * <li>{@code removeNode(N node)}: O(d_node).\n", " * <li>{@code removeEdge(E edge)}: O(1), unless this graph allows parallel edges;\n", " *     in that case this method is O(min(outD_edgeSource, inD_edgeTarget)).\n", " * </ul>\n", " * where d_node is the degree of node, inD_node is the in-degree of node, and outD_node is the\n", " * out-degree of node.\n", " *\n", " * @author James Sexton\n", " * @author Joshua O'Madadhain\n", " * @author Omar Darwish\n", " * @param <N> Node parameter type\n", " * @param <E> Edge parameter type\n", " */\n", "// TODO(b/24620028): Enable this class to support sorted nodes/edges.\n", "class ConfigurableNetwork<N, E>\n", "    extends AbstractConfigurableNetwork<N, E>\n", "    implements MutableNetwork<N, E> {\n", "\n", "  /**\n", "   * Constructs a mutable graph with the properties specified in {@code builder}.\n", "   */\n", "  ConfigurableNetwork(NetworkBuilder<? super N, ? super E> builder) {\n", "    super(builder);\n", "  }\n", "\n", "  /**\n", "   * Constructs a graph with the properties specified in {@code builder}, initialized with\n", "   * the given node and edge maps. May be used for either mutable or immutable graphs.\n", "   */\n", "  ConfigurableNetwork(NetworkBuilder<? super N, ? super E> builder,\n", "      Map<N, NodeConnections<N, E>> nodeConnections,\n", "      Map<E, IncidentNodes<N>> edgeToIncidentNodes) {\n", "    super(builder, nodeConnections, edgeToIncidentNodes);\n", "  }\n", "\n", "  @Override\n", "  @CanIgnoreReturnValue\n", "  public boolean addNode(N node) {\n", "    checkNotNull(node, \"node\");\n", "    if (nodes().contains(node)) {\n", "      return false;\n", "    }\n", "    nodeConnections.put(node, newNodeConnections(isDirected()));\n", "    return true;\n", "  }\n", "\n", "  /**\n", "   * Add nodes that are not elements of the graph, then add {@code edge} between them.\n", "   * Return {@code false} if {@code edge} already exists between {@code node1} and {@code node2},\n", "   * and in the same direction.\n", "   *\n", "   * @throws IllegalArgumentException if an edge (other than {@code edge}) already\n", "   *         exists from {@code node1} to {@code node2}, and this is not a multigraph.\n", "   *         Also, if self-loops are not allowed, and {@code node1} is equal to {@code node2}.\n", "   */\n", "  @Override\n", "  @CanIgnoreReturnValue\n", "  public boolean addEdge(E edge, N node1, N node2) {\n", "    checkNotNull(edge, \"edge\");\n", "    checkNotNull(node1, \"node1\");\n", "    checkNotNull(node2, \"node2\");\n", "    IncidentNodes<N> incidentNodes = IncidentNodes.of(node1, node2);\n", "    checkArgument(allowsSelfLoops() || !incidentNodes.isSelfLoop(), SELF_LOOPS_NOT_ALLOWED, node1);\n", "    boolean containsN1 = nodes().contains(node1);\n", "    boolean containsN2 = nodes().contains(node2);\n", "    if (edges().contains(edge)) {\n", "      checkArgument(containsN1 && containsN2 && edgesConnecting(node1, node2).contains(edge),\n", "          REUSING_EDGE, edge, incidentNodes(edge), incidentNodes);\n", "      return false;\n", "    } else if (!allowsParallelEdges()) {\n", "      checkArgument(!(containsN1 && containsN2 && successors(node1).contains(node2)),\n", "          ADDING_PARALLEL_EDGE, node1, node2);\n", "    }\n", "    if (!containsN1) {\n", "      addNode(node1);\n", "    }\n", "    NodeConnections<N, E> connectionsN1 = nodeConnections.get(node1);\n", "    connectionsN1.addSuccessor(node2, edge);\n", "    if (!containsN2) {\n", "      addNode(node2);\n", "    }\n", "    NodeConnections<N, E> connectionsN2 = nodeConnections.get(node2);\n", "    connectionsN2.addPredecessor(node1, edge);\n", "    edgeToIncidentNodes.put(edge, incidentNodes);\n", "    return true;\n", "  }\n", "\n", "  @Override\n", "  @CanIgnoreReturnValue\n", "  public boolean removeNode(Object node) {\n", "    checkNotNull(node, \"node\");\n", "    if (!nodes().contains(node)) {\n", "      return false;\n", "    }\n", "    // Since views are returned, we need to copy the edges that will be removed.\n", "    // Thus we avoid modifying the underlying view while iterating over it.\n", "    for (E edge : ImmutableList.copyOf(incidentEdges(node))) {\n", "      // Simply calling removeEdge(edge) would result in O(degree^2) behavior. However, we know that\n", "      // after all incident edges are removed, the input node will be disconnected from all others.\n", "      removeEdgeAndUpdateConnections(edge, true);\n", "    }\n", "    nodeConnections.remove(node);\n", "    return true;\n", "  }\n", "\n", "  @Override\n", "  @CanIgnoreReturnValue\n", "  public boolean removeEdge(Object edge) {\n", "    checkNotNull(edge, \"edge\");\n", "    if (!edges().contains(edge)) {\n", "      return false;\n", "    }\n", "    // If there are no parallel edges, the removal of this edge will disconnect the incident nodes.\n", "    removeEdgeAndUpdateConnections(edge, Graphs.parallelEdges(this, edge).isEmpty());\n", "    return true;\n", "  }\n", "\n", "  /**\n", "   * If {@code disconnectIncidentNodes} is true, disconnects the nodes formerly connected\n", "   * by {@code edge}. This should be set when all parallel edges are or will be removed.\n", "   *\n", "   * <p>Unlike {@link #removeEdge(Object)}, this method is guaranteed to run in O(1) time.\n", "   *\n", "   * @throws IllegalArgumentException if {@code edge} is not present in the graph.\n", "   */\n", "  private void removeEdgeAndUpdateConnections(Object edge, boolean disconnectIncidentNodes) {\n", "    IncidentNodes<N> incidentNodes = checkedIncidentNodes(edge);\n", "    N node1 = incidentNodes.node1();\n", "    N node2 = incidentNodes.node2();\n", "    NodeConnections<N, E> connectionsN1 = nodeConnections.get(node1);\n", "    NodeConnections<N, E> connectionsN2 = nodeConnections.get(node2);\n", "    if (disconnectIncidentNodes) {\n", "      connectionsN1.removeSuccessor(node2);\n", "      connectionsN2.removePredecessor(node1);\n", "    }\n", "    connectionsN1.removeOutEdge(edge);\n", "    connectionsN2.removeInEdge(edge);\n", "    edgeToIncidentNodes.remove(edge);\n", "  }\n", "\n", "  private NodeConnections<N, E> newNodeConnections(boolean isDirected) {\n", "    return isDirected\n", "        ? DirectedNodeConnections.<N, E>of()\n", "        : UndirectedNodeConnections.<N, E>of();\n", "  }\n", "}\n"]}, "removed": {}, "added_lines": {"1": [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 58, 59, 60, 61, 62, 63, 64, 65, 66, 67, 68, 69, 70, 71, 72, 73, 74, 75, 76, 77, 78, 79, 80, 81, 82, 83, 84, 85, 86, 87, 88, 89, 90, 91, 92, 93, 94, 95, 96, 97, 98, 99, 100, 101, 102, 103, 104, 105, 106, 107, 108, 109, 110, 111, 112, 113, 114, 115, 116, 117, 118, 119, 120, 121, 122, 123, 124, 125, 126, 127, 128, 129, 130, 131, 132, 133, 134, 135, 136, 137, 138, 139, 140, 141, 142, 143, 144, 145, 146, 147, 148, 149, 150, 151, 152, 153, 154, 155, 156, 157, 158, 159, 160, 161, 162, 163, 164, 165, 166, 167, 168, 169, 170, 171, 172, 173, 174, 175, 176, 177, 178, 179, 180, 181, 182, 183]}, "removed_lines": {}}, {"31": "guava/src/com/google/common/graph/DirectedNodeAdjacencies.java", "added": {"1": ["/*\n", " * Copyright (C) 2016 The Guava Authors\n", " *\n", " * Licensed under the Apache License, Version 2.0 (the \"License\");\n", " * you may not use this file except in compliance with the License.\n", " * You may obtain a copy of the License at\n", " *\n", " * http://www.apache.org/licenses/LICENSE-2.0\n", " *\n", " * Unless required by applicable law or agreed to in writing, software\n", " * distributed under the License is distributed on an \"AS IS\" BASIS,\n", " * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n", " * See the License for the specific language governing permissions and\n", " * limitations under the License.\n", " */\n", "\n", "package com.google.common.graph;\n", "\n", "import static com.google.common.base.Preconditions.checkNotNull;\n", "\n", "import com.google.common.base.MoreObjects;\n", "import com.google.common.base.Objects;\n", "import com.google.common.collect.ImmutableSet;\n", "import com.google.common.collect.Sets;\n", "\n", "import java.util.Collections;\n", "import java.util.Set;\n", "\n", "import javax.annotation.Nullable;\n", "\n", "/**\n", " * A class representing an origin node's adjacent nodes in a directed graph.\n", " *\n", " * @author James Sexton\n", " * @param <N> Node parameter type\n", " */\n", "final class DirectedNodeAdjacencies<N> implements NodeAdjacencies<N> {\n", "  private final Set<N> predecessors;\n", "  private final Set<N> successors;\n", "\n", "  private DirectedNodeAdjacencies(Set<N> predecessors, Set<N> successors) {\n", "    this.predecessors = checkNotNull(predecessors, \"predecessors\");\n", "    this.successors = checkNotNull(successors, \"successors\");\n", "  }\n", "\n", "  static <N> DirectedNodeAdjacencies<N> of() {\n", "    // TODO(user): Enable users to specify the expected number of neighbors of a new node.\n", "    return new DirectedNodeAdjacencies<N>(Sets.<N>newHashSet(), Sets.<N>newHashSet());\n", "  }\n", "\n", "  static <N> DirectedNodeAdjacencies<N> ofImmutable(Set<N> predecessors, Set<N> successors) {\n", "    return new DirectedNodeAdjacencies<N>(\n", "        ImmutableSet.copyOf(predecessors), ImmutableSet.copyOf(successors));\n", "  }\n", "\n", "  @Override\n", "  public Set<N> adjacentNodes() {\n", "    return Sets.union(predecessors(), successors());\n", "  }\n", "\n", "  @Override\n", "  public Set<N> predecessors() {\n", "    return Collections.unmodifiableSet(predecessors);\n", "  }\n", "\n", "  @Override\n", "  public Set<N> successors() {\n", "    return Collections.unmodifiableSet(successors);\n", "  }\n", "\n", "  @Override\n", "  public boolean removePredecessor(Object node) {\n", "    checkNotNull(node, \"node\");\n", "    return predecessors.remove(node);\n", "  }\n", "\n", "  @Override\n", "  public boolean removeSuccessor(Object node) {\n", "    checkNotNull(node, \"node\");\n", "    return successors.remove(node);\n", "  }\n", "\n", "  @Override\n", "  public boolean addPredecessor(N node) {\n", "    checkNotNull(node, \"node\");\n", "    return predecessors.add(node);\n", "  }\n", "\n", "  @Override\n", "  public boolean addSuccessor(N node) {\n", "    checkNotNull(node, \"node\");\n", "    return successors.add(node);\n", "  }\n", "\n", "  // For now, hashCode() and equals() are unused by any graph implementation.\n", "  @Override\n", "  public int hashCode() {\n", "    return Objects.hashCode(predecessors, successors);\n", "  }\n", "\n", "  @Override\n", "  public boolean equals(@Nullable Object object) {\n", "    if (object instanceof DirectedNodeAdjacencies) {\n", "      DirectedNodeAdjacencies<?> that = (DirectedNodeAdjacencies<?>) object;\n", "      return this.predecessors.equals(that.predecessors)\n", "          && this.successors.equals(that.successors);\n", "    }\n", "    return false;\n", "  }\n", "\n", "  @Override\n", "  public String toString() {\n", "    return MoreObjects.toStringHelper(this)\n", "        .add(\"predecessors\", predecessors)\n", "        .add(\"successors\", successors)\n", "        .toString();\n", "  }\n", "}\n"]}, "removed": {}, "added_lines": {"1": [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 58, 59, 60, 61, 62, 63, 64, 65, 66, 67, 68, 69, 70, 71, 72, 73, 74, 75, 76, 77, 78, 79, 80, 81, 82, 83, 84, 85, 86, 87, 88, 89, 90, 91, 92, 93, 94, 95, 96, 97, 98, 99, 100, 101, 102, 103, 104, 105, 106, 107, 108, 109, 110, 111, 112, 113, 114, 115, 116, 117, 118]}, "removed_lines": {}}, {"32": "guava/src/com/google/common/graph/DirectedNodeConnections.java", "added": {"1": ["  // For now, hashCode() and equals() are unused by any implementation.\n"]}, "removed": {"1": ["  // For now, hashCode() and equals() are unused by any graph implementation.\n"]}, "added_lines": {"1": [135]}, "removed_lines": {"1": [135]}}, {"33": "guava/src/com/google/common/graph/Graph.java", "added": {"1": [" * A graph consisting of a set of nodes of type N and a set of (implicit) edges.\n", " * Users that want edges to be first-class objects should use the subtype {@link Network} instead.\n", " *\n", " * <p>For convenience, we may use the term 'graph' to refer to any subtype of {@link Graph},\n", " * including {@link Network} and {@link Hypergraph}.\n", " *\n", " * <p>Users that wish to modify a {@code Graph} must work with its subinterface,\n", " * {@link MutableNetwork}.\n"], "3": [" * <li>{@code node1} and {@code node2} are mutually <b>adjacent</b> (or <b>connected</b> in\n", " *     {@code graph} if an edge has been added between them:\n", " *     <br><pre><code>\n", " *       graph.addEdge(node1, node2);  // after this returns, node1 and node2 are adjacent\n", " *     </pre></code>\n", " *   In this example, if {@code graph} is <b>directed</b>, then:\n", " *   <li>{@code node1} is a <b>predecessor</b> of {code node2} in {@code graph}\n", " *   <li>{@code node2} is a <b>successor</b> of {@code node1} in {@code graph}\n", " *   <li>{@code node1} has an (implicit) outgoing edge to {@code node2} in {@code graph}\n", " *   <li>{@code node2} has an (implicit) incoming edge from {@code node1} in {@code graph}\n", " *   If {@code graph} is <b>undirected</b>, then:\n", " *   <li>{@code node1} and {@code node2} are mutually predecessors and successors\n", " *       in {@code graph}\n", " *   <li>{@code node1} has an (implicit) edge in {@code graph} that is both outgoing to\n", " *       to {@code node2} and incoming from {@code node2}, and vice versa.\n", " * <li>A self-loop is an edge that connects a node to itself.\n", " * <li><b>Nodes must be useable as {@code Map} keys</b>:\n", " *       different if and only if {@code node1.equals(node2) == false}.\n", " *   <li>If graph elements have mutable state:\n", " *         interchangeable.  In particular, when adding such elements to a graph, you should\n", " *         create them once and store the reference if you will need to refer to those elements\n", " *         more than once during creation (rather than passing {@code new MyMutableNode(id)}\n", " *         to each {@code add*()} call).\n", " *   <br>Generally speaking, your design may be more robust if you use immutable nodes and\n", " * <li>There are no Node classes built in.  So you can have a {@code Graph<Integer>}\n", " *     or a {@code Graph<Author>} or a {@code Graph<Webpage>}.\n", " * <li>This framework supports multiple mechanisms for storing the topology of a graph,\n", " *      including:\n", " *   <li>the Graph implementation stores the topology (for example, by storing a\n", " *       {@code Map<N, N>} that maps nodes onto their adjacent nodes); this implies that the nodes\n", " *   <li>the nodes store the topology (for example, by storing a {@code List<E>} of adjacent nodes);\n"], "4": [" * <li>Accessors will throw {@code IllegalArgumentException} if passed an element\n", " * <li>Accessors take Object parameters rather than generic type specifiers to match the pattern\n"], "5": ["public interface Graph<N> {\n"], "7": ["   * Returns the nodes which have an incident edge in common with {@code node} in this graph.\n", "   * {@code node}'s incoming edges <i>against</i> the direction (if any) of the edge.\n"], "8": ["   * {@code node}'s outgoing edges in the direction (if any) of the edge.\n"], "9": ["   * Returns the number of edges incident in this graph to {@code node}.  If this node has more than\n", "   * {@code Integer.MAX_VALUE} incident edges in this graph, returns {@code Integer.MAX_VALUE}.\n"], "10": ["   * Returns the number of incoming edges in this graph of {@code node}.  If this node has more than\n", "   * {@code Integer.MAX_VALUE} incoming edges in this graph, returns {@code Integer.MAX_VALUE}.\n", "   * Returns the number of outgoing edges in this graph of {@code node}.  If this node has more than\n", "   * {@code Integer.MAX_VALUE} outgoing edges in this graph, returns {@code Integer.MAX_VALUE}.\n", "   * Returns {@code true} iff {@code object} is a graph that has the same node relationships\n", "   * <li>A and B have the same adjacency relationships, e.g., for each {@code node} the sets of\n", "   *     successor and predecessor nodes are the same in both graphs.\n", "   *     <br>This implies that every edge in A and B connects the same nodes in the same\n", "   *     direction (if any).\n", "   * <p>Graph properties are <b>not</b> respected by this method. For example, two relations may\n", "   * be considered equal even if one allows self-loops and the other doesn't. Additionally, the\n", "   * order in which edges or nodes are added to the graph, and the order in which they are\n", "   * iterated over, are irrelevant.\n"], "11": ["   * of a map from each of the graph's nodes to their adjacent nodes.\n"]}, "removed": {"1": ["import com.google.errorprone.annotations.CanIgnoreReturnValue;\n", " * A graph consisting of a set of nodes of type N and a set of edges of type E.\n"], "2": [" * <li>parallel edges (multiple edges which connect a single set of vertices)\n"], "3": [" * <li>{@code edge} and {@code node} are <b>incident</b> to each other if the set of\n", " *     {@code edge}'s endpoints includes {@code node}.\n", " * <li>{@code node1} and {@code node2} are mutually <b>adjacent</b> if both are incident\n", " *     to a common {@code edge}.\n", " *     <br>Similarly, {@code edge1} and {@code edge2} are mutually adjacent if both are\n", " *     incident to a common {@code node}.\n", " * <li>Elements are <b>connected</b> if they are either incident or adjacent.\n", " * <li>{@code edge} is an <b>incoming edge</b> of a {@code node} if it can be traversed (in\n", " *     the direction, if any, of {@code edge}) from a node adjacent to {@code node}.\n", " * <li>{@code edge} is an <b>outgoing edge</b> of {@code node} if it can be traversed (in\n", " *     the direction, if any, of {@code edge}) from {@code node} to reach a node adjacent to\n", " *     {@code node}.\n", " *   <li>Note: <b>undirected</b> edges are both incoming and outgoing edges of a {@code node},\n", " *       while <b>directed</b> edges are either incoming or outgoing edges of {@code node}\n", " *       (and not both, unless the edge is a self-loop).\n", " *       <br>Thus, in the following example {@code edge1} is an incoming edge of {@code node2} and\n", " *       an outgoing edge of {@code node1}, while {@code edge2} is both an incoming and an outgoing\n", " *       edge of both {@code node3} and {@code node4}:\n", " *       <br><pre><code>\n", " *         directedGraph.addEdge(edge1, node1, node2);\n", " *         undirectedGraph.addEdge(edge2, node3, node4);\n", " *       </pre></code>\n", " * <li>A node {@code pred} is a <b>predecessor</b> of {@code node} if it is incident to an incoming\n", " *     {@code edge} of {@code node} (and is not itself {@code node} unless {@code edge} is\n", " *     a self-loop).\n", " * <li>A node {@code succ} is a <b>successor</b> of {@code node} if it is incident to an outgoing\n", " *     {@code edge} of {@code node} (and is not itself {@code node} unless {@code edge} is\n", " *     a self-loop).\n", " * <li>Directed edges only:\n", " *   <li>{@code node} is a <b>source</b> of {@code edge} if {@code edge} is an outgoing edge\n", " *       of {@code node}.\n", " *   <li>{@code node} is a <b>target</b> of {@code edge} if {@code edge} is an incoming edge\n", " *       of {@code node}.\n", " * <li><b>Nodes/edges must be useable as {@code Map} keys</b>:\n", " *       different if and only if {@code node1.equals(node2) == false}, and the same for edges.\n", " *   <li>If you would otherwise have duplicate edges (e.g. weighted edges represented by a Double),\n", " *       you can instead wrap the edges in a custom class that defers to {@link Object} for its\n", " *       {@code equals()} and {@code hashCode()} implementations.\n", " *   <li>If graph elements have mutable state, both of the following must be true:\n", " *         interchangeable.  In particular, when adding such elements to a graph, you should create\n", " *         them once and store the reference if you will need to refer to those elements more than\n", " *         once during creation (rather than passing {@code new MyMutableNode(id)} to each\n", " *         {@code add*()} call).\n", " *   <br>Generally speaking, your design may be more robust if you use immutable nodes/edges and\n", " * <li>There are no Node or Edge classes built in.  So you can have a {@code Graph<Integer, String>}\n", " *     or a {@code Graph<Author,Publication>} or a {@code Graph<Webpage,Link>}.\n", " * <li>This framework supports multiple mechanisms for storing the topology of a graph, including:\n", " *   <li>the Graph implementation stores the topology (for example, by storing a {@code Map<N, E>}\n", " *       that maps nodes onto their incident edges); this implies that the nodes and edges\n", " *   <li>the nodes store the topology (for example, by storing a {@code List<E>} of incident edges);\n", " * <li>Users that are not interested in edges as first-class objects have a couple of options:\n", " *   <ul>\n", " *   <li>pass in arbitrary Objects as edges: {@code addEdge(new Object(), n1, n2)}\n", " *   <li>create an implementation of (or subinterface of, or class delegating to) Graph\n", " *       that only exposes node-related methods.\n", " *   </ul>\n"], "4": [" * <li>Accessors will throw {@code IllegalArgumentException} if passed a node/edge\n", " * <li>Accessors take Object parameters rather than N/E generic type specifiers to match the pattern\n"], "5": [" * <li>Traversing a directed graph edge-wise:\n", " * <pre><code>\n", " *   // Update the shortest-path distances of the successors to {@code node}\n", " *   // in a directed graph (inner loop of Dijkstra's algorithm):\n", " *   void updateDistances(N node) {\n", " *     nodeDistance = distances.get(node);\n", " *     for (E outEdge : graph.outEdges(node)) {\n", " *       N target = graph.target(outEdge);\n", " *       double targetDistance = nodeDistance + outEdge.getWeight();\n", " *       if (targetDistance < distances.get(target)) {\n", " *         distances.put(target, targetDistance);\n", " *       }\n", " *     }\n", " *   }\n", " * </code></pre>\n", " * @param <E> Edge parameter type\n", "public interface Graph<N, E> {\n", "  /** Returns all edges in this graph. */\n", "  Set<E> edges();\n", "\n"], "6": ["  /**\n", "   * Returns true if this graph allows parallel edges. Attempting to add a parallel edge to a graph\n", "   * that does not allow them will throw an {@link UnsupportedOperationException}.\n", "   */\n", "  boolean allowsParallelEdges();\n", "\n"], "7": ["   * Returns the edges whose endpoints in this graph include {@code node}.\n", "   *\n", "   * @throws IllegalArgumentException if {@code node} is not an element of this graph\n", "   */\n", "  Set<E> incidentEdges(Object node);\n", "\n", "  /**\n", "   * Returns the nodes which are the endpoints of {@code edge} in this graph.\n", "   *\n", "   * <p>For self-loop edges, the returned set's size will be 1. If the graph is\n", "   * {@linkplain #isDirected() directed} and {@code edge} is not a self-loop, the\n", "   * iteration order will be {@code [source(edge), target(edge)]}.\n", "   *\n", "   * @throws IllegalArgumentException if {@code edge} is not an element of this graph\n", "   */\n", "  Set<N> incidentNodes(Object edge);\n", "\n", "  /**\n", "   * Returns the nodes which have an {@linkplain #incidentEdges(Object) incident edge}\n", "   * in common with {@code node} in this graph.\n", "  /**\n", "   * Returns the edges which have an {@linkplain #incidentNodes(Object) incident node}\n", "   * in common with {@code edge} in this graph.\n", "   *\n", "   * <p>Whether an edge is considered adjacent to itself is not defined by this interface, but\n", "   * generally for non-hypergraphs, edges are not considered to be self-adjacent.\n", "   *\n", "   * @throws IllegalArgumentException if {@code edge} is not an element of this graph\n", "   */\n", "  Set<E> adjacentEdges(Object edge);\n", "\n", "  /**\n", "   * Returns the set of edges that connect {@code node1} to {@code node2}.\n", "   *\n", "   * <p>This set is the intersection of {@code outEdges(node1)} and {@code inEdges(node2)}. If\n", "   * {@code node1} is equal to {@code node2}, then it is the set of self-loop edges for that node.\n", "   *\n", "   * @throws IllegalArgumentException if {@code node1} or {@code node2} is not an element\n", "   *     of this graph\n", "   */\n", "  Set<E> edgesConnecting(Object node1, Object node2);\n", "\n", "  /**\n", "   * Returns all edges in this graph which can be traversed in the direction (if any) of the edge\n", "   * to end at {@code node}.\n", "   *\n", "   * @throws IllegalArgumentException if {@code node} is not an element of this graph\n", "   */\n", "  Set<E> inEdges(Object node);\n", "\n", "  /**\n", "   * Returns all edges in this graph which can be traversed in the direction (if any) of the edge\n", "   * starting from {@code node}.\n", "   *\n", "   * @throws IllegalArgumentException if {@code node} is not an element of this graph\n", "   */\n", "  Set<E> outEdges(Object node);\n", "\n", "   * {@code node}'s {@linkplain #inEdges(Object) incoming edges} <i>against</i> the direction\n", "   * (if any) of the edge.\n"], "8": ["   * {@code node}'s {@linkplain #outEdges(Object) outgoing edges} in the direction (if any) of the\n", "   * edge.\n"], "9": ["   * For a directed graph, returns the node for which {@code edge} is an outgoing edge.\n", "   * For an undirected graph, throws an {@link UnsupportedOperationException}.\n", "   */\n", "  N source(Object edge);\n", "\n", "  /**\n", "   * For a directed graph, returns the node for which {@code edge} is an incoming edge.\n", "   * For an undirected graph, throws an {@link UnsupportedOperationException}.\n", "   */\n", "  N target(Object edge);\n", "\n", "  /**\n", "   * Returns the number of edges {@linkplain #incidentEdges(Object) incident} in this graph\n", "   * to {@code node}.  If this node has more than {@code Integer.MAX_VALUE} incident edges\n", "   * in this graph, returns {@code Integer.MAX_VALUE}.\n", "   *\n", "   * <p>Equivalent to {@code incidentEdges(node).size()}.\n"], "10": ["   * Returns the number of {@linkplain #inEdges(Object) incoming edges} in this graph\n", "   * of {@code node}.  If this node has more than {@code Integer.MAX_VALUE} incoming edges\n", "   * in this graph, returns {@code Integer.MAX_VALUE}.\n", "   *\n", "   * <p>Equivalent to {@code inEdges(node).size()}.\n", "   * Returns the number of {@linkplain #outEdges(Object) outgoing edges} in this graph\n", "   * of {@code node}.  If this node has more than {@code Integer.MAX_VALUE} outgoing edges\n", "   * in this graph, returns {@code Integer.MAX_VALUE}.\n", "   *\n", "   * <p>Equivalent to {@code outEdges(node).size()}.\n", "  //\n", "  // Element mutations\n", "  //\n", "\n", "  /**\n", "   * Adds {@code node} to this graph (optional operation).\n", "   *\n", "   * <p><b>Nodes must be unique</b>, just as {@code Map} keys must be; they must also be non-null.\n", "   *\n", "   * @return {@code true} iff the graph was modified as a result of this call\n", "   * @throws UnsupportedOperationException if the add operation is not supported by this graph\n", "   */\n", "  @CanIgnoreReturnValue\n", "  boolean addNode(N node);\n", "\n", "  /**\n", "   * Adds {@code edge} to this graph, connecting {@code node1} to {@code node2}\n", "   * (optional operation).\n", "   *\n", "   * <p><b>Edges must be unique</b>, just as {@code Map} keys must be; they must also be non-null.\n", "   *\n", "   * <p>If {@code edge} already connects {@code node1} to {@code node2} in this graph\n", "   * (in the specified order if order is significant, as for directed graphs, else in any order),\n", "   * then this method will have no effect and will return {@code false}.\n", "   *\n", "   * <p>Behavior if {@code node1} and {@code node2} are not already elements of the graph is\n", "   * unspecified. Suggested behaviors include (a) silently adding {@code node1} and {@code node2}\n", "   * to the graph or (b) throwing {@code IllegalArgumentException}.\n", "   *\n", "   * @return {@code true} iff the graph was modified as a result of this call\n", "   * @throws IllegalArgumentException if {@code edge} already exists and connects nodes other than\n", "   *     {@code node1} and {@code node2}, or if the graph is not a multigraph and {@code node1} is\n", "   *     already connected to {@code node2}\n", "   * @throws UnsupportedOperationException if the add operation is not supported by this graph\n", "   */\n", "  @CanIgnoreReturnValue\n", "  boolean addEdge(E edge, N node1, N node2);\n", "\n", "  /**\n", "   * Removes {@code node} from this graph, if it is present (optional operation).\n", "   * In general, all edges incident to {@code node} in this graph will also be removed.\n", "   * (This is not true for hyperedges.)\n", "   *\n", "   * @return {@code true} iff the graph was modified as a result of this call\n", "   * @throws UnsupportedOperationException if the remove operation is not supported by this graph\n", "   */\n", "  @CanIgnoreReturnValue\n", "  boolean removeNode(Object node);\n", "\n", "  /**\n", "   * Removes {@code edge} from this graph, if it is present (optional operation).\n", "   * In general, nodes incident to {@code edge} are unaffected (although implementations may choose\n", "   * to disallow certain configurations, e.g., isolated nodes).\n", "   *\n", "   * @return {@code true} iff the graph was modified as a result of this call\n", "   * @throws UnsupportedOperationException if the remove operation is not supported by this graph\n", "   */\n", "  @CanIgnoreReturnValue\n", "  boolean removeEdge(Object edge);\n", "\n", "   * Returns {@code true} iff {@code object} is a graph that has the same node/edge relationships\n", "   * <li>A and B have the same edge set\n", "   * <li>A and B have the same incidence relationships, e.g., for each node/edge in A and in B\n", "   *     its incident edge/node set in A is the same as its incident edge/node set in B.\n", "   *     <br>Thus, every edge in A and B connect the same nodes in the same direction (if any).\n", "   * <p>Graph properties are <b>not</b> respected by this method. For example, two graphs may be\n", "   * considered equal even if one allows parallel edges and the other doesn't. Additionally, the\n", "   * order in which edges or nodes are added to the graph, and the order in which they are iterated\n", "   * over, are irrelevant.\n"], "11": ["   * of a map from each of the graph's nodes to their incident edges.\n"]}, "added_lines": {"1": [26, 27, 28, 29, 30, 31, 32, 33], "3": [49, 50, 51, 52, 53, 54, 56, 57, 58, 59, 61, 63, 64, 65, 66, 68, 73, 76, 77, 82, 83, 84, 85, 88, 90, 91, 92, 93, 95, 96, 98], "4": [112, 114], "5": [171], "7": [203, 211], "8": [219], "9": [233, 234], "10": [244, 245, 252, 253, 260, 266, 267, 268, 269, 272, 273, 274, 275], "11": [284]}, "removed_lines": {"1": [20, 27], "2": [35], "3": [44, 45, 46, 47, 48, 49, 50, 51, 52, 53, 54, 55, 57, 58, 59, 60, 61, 62, 63, 64, 65, 66, 68, 69, 70, 71, 72, 73, 74, 76, 77, 78, 79, 85, 88, 89, 90, 91, 92, 97, 98, 99, 100, 103, 105, 106, 107, 109, 110, 112, 116, 117, 118, 119, 120, 121], "4": [132, 134], "5": [184, 185, 186, 187, 188, 189, 190, 191, 192, 193, 194, 195, 196, 197, 198, 203, 207, 211, 212, 213], "6": [230, 231, 232, 233, 234, 235], "7": [248, 249, 250, 251, 252, 253, 254, 255, 256, 257, 258, 259, 260, 261, 262, 263, 264, 265, 266, 267, 273, 274, 275, 276, 277, 278, 279, 280, 281, 282, 283, 284, 285, 286, 287, 288, 289, 290, 291, 292, 293, 294, 295, 296, 297, 298, 299, 300, 301, 302, 303, 304, 305, 306, 307, 308, 309, 310, 313, 314], "8": [322, 323], "9": [337, 338, 339, 340, 341, 342, 343, 344, 345, 346, 347, 348, 349, 350, 351, 352, 353], "10": [363, 364, 365, 366, 367, 374, 375, 376, 377, 378, 384, 385, 386, 387, 388, 389, 390, 391, 392, 393, 394, 395, 396, 397, 398, 399, 400, 401, 402, 403, 404, 405, 406, 407, 408, 409, 410, 411, 412, 413, 414, 415, 416, 417, 418, 419, 420, 421, 422, 423, 424, 425, 426, 427, 428, 429, 430, 431, 432, 433, 434, 435, 436, 437, 438, 439, 440, 441, 442, 443, 445, 451, 452, 453, 454, 457, 458, 459, 460], "11": [469]}}, {"34": "guava/src/com/google/common/graph/GraphBuilder.java", "added": {"1": ["// to narrow the generic type when Comparators are provided.\n", "public final class GraphBuilder<N> {\n", "  final boolean directed;\n", "  /**\n", "   * Creates a new instance with the specified edge directionality.\n", "   *\n", "   * @param directed if true, creates an instance for graphs whose edges are each directed;\n", "   *      if false, creates an instance for graphs whose edges are each undirected.\n", "   */\n", "  private GraphBuilder(boolean directed) {\n", "    this.directed = directed;\n", "  }\n", "  public static GraphBuilder<Object> directed() {\n", "    return new GraphBuilder<Object>(true);\n", "  public static GraphBuilder<Object> undirected() {\n", "    return new GraphBuilder<Object>(false);\n"], "2": ["  public static <N> GraphBuilder<N> from(Graph<N> graph) {\n", "    // TODO(b/28087289): add allowsParallelEdges() once we support them\n", "    return new GraphBuilder<N>(graph.isDirected())\n", "  public GraphBuilder<N> allowsSelfLoops(boolean allowsSelfLoops) {\n"], "3": ["  public GraphBuilder<N> expectedNodeCount(int expectedNodeCount) {\n", "  public <N1 extends N> MutableGraph<N1> build() {\n", "    return new ConfigurableGraph<N1>(this);\n"]}, "removed": {"1": ["// to narrow the generic <N, E> type when Comparators are provided.\n", "public final class GraphBuilder<N, E> {\n", "  Boolean directed = null; // No default value to enforce that this is set before building\n", "  boolean allowsParallelEdges = false;\n", "  Comparator<E> edgeComparator = null;\n", "  Optional<Integer> expectedEdgeCount = Optional.absent();\n", "  private GraphBuilder() {}\n", "  public static GraphBuilder<Object, Object> directed() {\n", "    return new GraphBuilder<Object, Object>().directed(true);\n", "  public static GraphBuilder<Object, Object> undirected() {\n", "    return new GraphBuilder<Object, Object>().directed(false);\n"], "2": ["  public static <N, E> GraphBuilder<N, E> from(Graph<N, E> graph) {\n", "    return new GraphBuilder<N, E>()\n", "        .directed(graph.isDirected())\n", "        .allowsParallelEdges(graph.allowsParallelEdges())\n", "  /**\n", "   * This value should be set by {@link #directed()}, {@link #undirected()},\n", "   * or {@link #from(Graph)}.\n", "   */\n", "  private GraphBuilder<N, E> directed(boolean directed) {\n", "    this.directed = directed;\n", "    return this;\n", "  }\n", "\n", "  /**\n", "   * Specifies whether the graph will allow parallel edges. Attempting to add a parallel edge to\n", "   * a graph that does not allow them will throw an {@link UnsupportedOperationException}.\n", "   */\n", "  public GraphBuilder<N, E> allowsParallelEdges(boolean allowsParallelEdges) {\n", "    this.allowsParallelEdges = allowsParallelEdges;\n", "    return this;\n", "  }\n", "\n", "  public GraphBuilder<N, E> allowsSelfLoops(boolean allowsSelfLoops) {\n"], "3": ["  public GraphBuilder<N, E> expectedNodeCount(int expectedNodeCount) {\n", "  /**\n", "   * Specifies the expected number of edges in the graph.\n", "   *\n", "   * @throws IllegalArgumentException if {@code expectedEdgeCount} is negative\n", "   */\n", "  public GraphBuilder<N, E> expectedEdgeCount(int expectedEdgeCount) {\n", "    checkArgument(expectedEdgeCount >= 0, \"The expected number of edges can't be negative: %s\",\n", "        expectedEdgeCount);\n", "    this.expectedEdgeCount = Optional.of(expectedEdgeCount);\n", "    return this;\n", "  }\n", "\n", "  public <N1 extends N, E1 extends E> Graph<N1, E1> build() {\n", "    return new ConfigurableGraph<N1, E1>(this);\n"]}, "added_lines": {"1": [39, 40, 41, 46, 47, 48, 49, 50, 51, 52, 53, 54, 59, 60, 66, 67], "2": [77, 78, 79, 88], "3": [98, 108, 109]}, "removed_lines": {"1": [39, 40, 41, 42, 45, 47, 49, 54, 55, 61, 62], "2": [72, 73, 74, 75, 79, 80, 81, 82, 83, 84, 85, 86, 87, 88, 89, 90, 91, 92, 93, 94, 95, 96, 102], "3": [112, 119, 120, 121, 122, 123, 124, 125, 126, 127, 128, 129, 130, 134, 135]}}, {"35": "guava/src/com/google/common/graph/GraphProperties.java", "added": {"1": ["  public static boolean isCyclic(Graph<?> graph) {\n"], "2": ["      Graph<?> graph, Map<Object, NodeVisitState> nodeToVisitState, Object node) {\n"], "3": ["  public static <N> ImmutableSet<N> roots(Graph<N> graph) {\n"]}, "removed": {"1": ["  public static boolean isCyclic(Graph<?, ?> graph) {\n"], "2": ["      Graph<?, ?> graph, Map<Object, NodeVisitState> nodeToVisitState, Object node) {\n"], "3": ["  public static <N> ImmutableSet<N> roots(Graph<N, ?> graph) {\n"]}, "added_lines": {"1": [43], "2": [66], "3": [98]}, "removed_lines": {"1": [43], "2": [66], "3": [98]}}, {"36": "guava/src/com/google/common/graph/Graphs.java", "added": {"1": ["import com.google.common.base.Joiner;\n"], "2": ["import java.util.ArrayList;\n", "import java.util.List;\n"], "3": ["  private static final String GRAPH_FORMAT = \"%s, nodes: %s, edges: %s\";\n", "  private static final String DIRECTED_FORMAT = \"<%s -> %s>\";\n", "  private static final String UNDIRECTED_FORMAT = \"[%s, %s]\";\n", "\n"], "4": ["  public static <N> N oppositeNode(Network<N, ?> graph, Object edge, Object node) {\n"], "5": ["  public static <N, E> Set<E> parallelEdges(Network<N, E> graph, Object edge) {\n"], "6": ["  public static <N, E> boolean addEdge(MutableNetwork<N, E> graph, E edge, Iterable<N> nodes) {\n"], "7": ["  /**\n", "   * Creates a mutable copy of {@code graph}, using the same nodes.\n", "   */\n", "  public static <N> MutableGraph<N> copyOf(Graph<N> graph) {\n", "    return copyOf(graph, Predicates.alwaysTrue());\n", "  }\n", "\n", "  /**\n", "   * Creates a mutable copy of {@code graph}, using all of its elements that satisfy\n", "   * {@code nodePredicate} and {@code edgePredicate}.\n", "   */\n", "  public static <N> MutableGraph<N> copyOf(Graph<N> graph, Predicate<? super N> nodePredicate) {\n", "    checkNotNull(graph, \"graph\");\n", "    checkNotNull(nodePredicate, \"nodePredicate\");\n", "    MutableGraph<N> copy = GraphBuilder.from(graph).expectedNodeCount(graph.nodes().size()).build();\n", "\n", "    for (N node : graph.nodes()) {\n", "      if (nodePredicate.apply(node)) {\n", "        copy.addNode(node);\n", "        for (N successor : graph.successors(node)) {\n", "          if (nodePredicate.apply(successor)) {\n", "            copy.addEdge(node, successor);\n", "          }\n", "        }\n", "      }\n", "      // TODO(b/28087289): update this when parallel edges are permitted to ensure that the correct\n", "      // multiplicity is preserved.\n", "    }\n", "\n", "    return copy;\n", "  }\n", "\n", "  /**\n", "   * Copies all nodes from {@code original} into {@code copy}.\n", "   */\n", "  public static <N> void mergeNodesFrom(Graph<N> original, MutableGraph<N> copy) {\n", "    mergeNodesFrom(original, copy, Predicates.alwaysTrue());\n", "  }\n", "\n", "  /**\n", "   * Copies all nodes from {@code original} into {@code copy} that satisfy {@code nodePredicate}.\n", "   */\n", "  public static <N, E> void mergeNodesFrom(\n", "      Graph<N> original, MutableGraph<N> copy, Predicate<? super N> nodePredicate) {\n", "    checkNotNull(original, \"original\");\n", "    checkNotNull(copy, \"copy\");\n", "    checkNotNull(nodePredicate, \"nodePredicate\");\n", "    for (N node : Sets.filter(original.nodes(), nodePredicate)) {\n", "      copy.addNode(node);\n", "    }\n", "  }\n", "\n", "  public static <N, E> MutableNetwork<N, E> copyOf(Network<N, E> graph) {\n"], "8": ["  public static <N, E> MutableNetwork<N, E> copyOf(\n", "      Network<N, E> graph,\n", "    MutableNetwork<N, E> copy = NetworkBuilder.from(graph)\n"], "9": ["  public static <N> void mergeNodesFrom(Graph<N> original, MutableNetwork<N, ?> copy) {\n"], "10": ["      Graph<N> original, MutableNetwork<N, ?> copy, Predicate<? super N> nodePredicate) {\n"], "11": ["  public static <N, E> void mergeEdgesFrom(Network<N, E> original, MutableNetwork<N, E> copy) {\n"], "12": ["      Network<N, E> original, MutableNetwork<N, E> copy, Predicate<? super E> edgePredicate) {\n"], "13": ["  /**\n", "   * Returns true iff {@code graph1} and {@code graph2} have the same node connections.\n", "   *\n", "   * <p>Note: {@link Network} instances can only be equal to other {@link Network} instances.\n", "   * In particular, {@link Graph}s that are not also {@link Network}s cannot be equal\n", "   * to {@link Network}s.\n", "   *\n", "   * @see Network#equals(Object)\n", "   */\n", "  public static boolean equal(@Nullable Graph<?> graph1, @Nullable Graph<?> graph2) {\n", "    // If both graphs are Network instances, use equal(Network, Network) instead\n", "    if (graph1 instanceof Network && graph2 instanceof Network) {\n", "      return equal((Network<?, ?>) graph1, (Network<?, ?>) graph2);\n", "    }\n", "\n", "    // Otherwise, if either graph is a Network (but not both), they can't be equal.\n", "    if (graph1 instanceof Network || graph2 instanceof Network) {\n", "      return false;\n", "    }\n", "\n", "    if (graph1 == graph2) {\n", "      return true;\n", "    }\n", "\n", "    if (graph1 == null || graph2 == null) {\n", "      return false;\n", "    }\n", "\n", "    if (!graph1.nodes().equals(graph2.nodes())) {\n", "      return false;\n", "    }\n", "\n", "    for (Object node : graph1.nodes()) {\n", "      if (!graph1.successors(node).equals(graph2.successors(node))) {\n", "        return false;\n", "      }\n", "      boolean bothUndirected = !graph1.isDirected() && !graph2.isDirected();\n", "      if (!bothUndirected && !graph1.predecessors(node).equals(graph2.predecessors(node))) {\n", "        return false;\n", "      }\n", "    }\n", "\n", "    return true;\n", "  }\n", "\n", "   * @see Network#equals(Object)\n", "  public static boolean equal(@Nullable Network<?, ?> graph1, @Nullable Network<?, ?> graph2) {\n"], "14": ["  public static int hashCode(Graph<?> graph) {\n", "    return (graph instanceof Network)\n", "        ? hashCode((Network<?, ?>) graph)\n", "        : nodeToAdjacentNodes(graph).hashCode();\n", "  }\n", "\n", "  /**\n", "   * Returns the hash code of {@code graph}.\n", "   *\n", "   * @see Network#hashCode()\n", "   */\n", "  public static int hashCode(Network<?, ?> graph) {\n"], "15": ["  public static String toString(Graph<?> graph) {\n", "    if (graph instanceof Network) {\n", "      return toString((Network<?, ?>) graph);\n", "    }\n", "    return String.format(GRAPH_FORMAT,\n", "        getPropertiesString(graph),\n", "        graph.nodes(),\n", "        adjacentNodesString(graph));\n", "  }\n", "\n", "  /**\n", "   * Returns a string representation of {@code graph}. Encodes edge direction if {@code graph}\n", "   * is directed.\n", "   */\n", "  public static String toString(Network<?, ?> graph) {\n", "    return String.format(GRAPH_FORMAT,\n"], "16": ["  public static <E> Predicate<E> selfLoopPredicate(final Network<?, E> graph) {\n"], "17": ["  /**\n", "   * Returns a String of the adjacent node relationships for {@code graph}.\n", "   */\n", "  private static <N> String adjacentNodesString(final Graph<N> graph) {\n", "    checkNotNull(graph, \"graph\");\n", "    List<String> adjacencies = new ArrayList<String>();\n", "    // This will list each undirected edge twice (once as [n1, n2] and once as [n2, n1]); this is OK\n", "    for (N node : graph.nodes()) {\n", "      for (N successor : graph.successors(node)) {\n", "        adjacencies.add(\n", "            String.format(\n", "                graph.isDirected() ? DIRECTED_FORMAT : UNDIRECTED_FORMAT,\n", "                node, successor));\n", "      }\n", "    }\n", "\n", "    return String.format(\"{%s}\", Joiner.on(\", \").join(adjacencies));\n", "  }\n", "\n", "  private static <N, E> Map<N, Set<E>> nodeToIncidentEdges(final Network<N, E> graph) {\n"], "18": ["  private static <N> Map<N, Set<N>> nodeToAdjacentNodes(final Graph<N> graph) {\n", "    checkNotNull(graph, \"graph\");\n", "    return Maps.asMap(graph.nodes(), new Function<N, Set<N>>() {\n", "      @Override\n", "      public Set<N> apply(N node) {\n", "        return graph.adjacentNodes(node);\n", "      }\n", "    });\n", "  }\n", "\n", "  private static Function<Object, String> edgeToIncidentNodesString(final Network<?, ?> graph) {\n"], "19": [" }\n", "\n", "  /**\n", "   * Returns a string representation of the properties of {@code graph}.\n", "   */\n", "  // TODO(b/28087289): add allowsParallelEdges() once that's supported\n", "  private static String getPropertiesString(Graph<?> graph) {\n", "    if (graph instanceof Network) {\n", "      return getPropertiesString((Network<?, ?>) graph);\n", "    }\n", "    return String.format(\"isDirected: %s, allowsSelfLoops: %s\",\n", "        graph.isDirected(), graph.allowsSelfLoops());\n", "  private static String getPropertiesString(Network<?, ?> graph) {\n"]}, "removed": {"4": ["  public static <N> N oppositeNode(Graph<N, ?> graph, Object edge, Object node) {\n"], "5": ["  public static <N, E> Set<E> parallelEdges(Graph<N, E> graph, Object edge) {\n"], "6": ["  public static <N, E> boolean addEdge(Graph<N, E> graph, E edge, Iterable<N> nodes) {\n"], "7": ["  public static <N, E> Graph<N, E> copyOf(Graph<N, E> graph) {\n"], "8": ["  public static <N, E> Graph<N, E> copyOf(\n", "      Graph<N, E> graph,\n", "    Graph<N, E> copy = GraphBuilder.from(graph)\n"], "9": ["  public static <N, E> void mergeNodesFrom(Graph<N, E> original, Graph<N, E> copy) {\n"], "10": ["      Graph<N, E> original, Graph<N, E> copy, Predicate<? super N> nodePredicate) {\n"], "11": ["  public static <N, E> void mergeEdgesFrom(Graph<N, E> original, Graph<N, E> copy) {\n"], "12": ["      Graph<N, E> original, Graph<N, E> copy, Predicate<? super E> edgePredicate) {\n"], "13": ["   * @see Graph#equals(Object)\n", "  public static boolean equal(@Nullable Graph<?, ?> graph1, @Nullable Graph<?, ?> graph2) {\n"], "14": ["  public static int hashCode(Graph<?, ?> graph) {\n"], "15": ["  public static String toString(Graph<?, ?> graph) {\n", "    return String.format(\"%s, nodes: %s, edges: %s\",\n"], "16": ["  public static <E> Predicate<E> selfLoopPredicate(final Graph<?, E> graph) {\n"], "17": ["  private static <N, E> Map<N, Set<E>> nodeToIncidentEdges(final Graph<N, E> graph) {\n"], "18": ["  private static Function<Object, String> edgeToIncidentNodesString(final Graph<?, ?> graph) {\n"], "19": ["  private static String getPropertiesString(Graph<?, ?> graph) {\n"]}, "added_lines": {"1": [24], "2": [32, 34], "3": [49, 50, 51, 52], "4": [61], "5": [85], "6": [105], "7": [123, 124, 125, 126, 127, 128, 129, 130, 131, 132, 133, 134, 135, 136, 137, 138, 139, 140, 141, 142, 143, 144, 145, 146, 147, 148, 149, 150, 151, 152, 153, 154, 155, 156, 157, 158, 159, 160, 161, 162, 163, 164, 165, 166, 167, 168, 169, 170, 171, 172, 173, 174, 178], "8": [186, 187, 193], "9": [214], "10": [222], "11": [235], "12": [244], "13": [253, 254, 255, 256, 257, 258, 259, 260, 261, 262, 263, 264, 265, 266, 267, 268, 269, 270, 271, 272, 273, 274, 275, 276, 277, 278, 279, 280, 281, 282, 283, 284, 285, 286, 287, 288, 289, 290, 291, 292, 293, 294, 295, 296, 297, 301, 303], "14": [338, 339, 340, 341, 342, 343, 344, 345, 346, 347, 348, 349], "15": [357, 358, 359, 360, 361, 362, 363, 364, 365, 366, 367, 368, 369, 370, 371, 372], "16": [384], "17": [394, 395, 396, 397, 398, 399, 400, 401, 402, 403, 404, 405, 406, 407, 408, 409, 410, 411, 412, 417], "18": [427, 428, 429, 430, 431, 432, 433, 434, 435, 436, 442], "19": [458, 459, 460, 461, 462, 463, 464, 465, 466, 467, 468, 469, 475]}, "removed_lines": {"4": [54], "5": [78], "6": [98], "7": [119], "8": [127, 128, 134], "9": [155], "10": [163], "11": [176], "12": [185], "13": [197, 199], "14": [234], "15": [242, 243], "16": [255], "17": [269], "18": [284], "19": [305]}}, {"37": "guava/src/com/google/common/graph/Hypergraph.java", "added": {"1": [" * A subinterface of {@link Network} which specifies that all edges are hyperedges, that is,\n"], "2": ["public interface Hypergraph<N, E> extends Network<N, E> {\n"]}, "removed": {"1": [" * A subinterface of {@code Graph} which specifies that all edges are hyperedges, that is,\n"], "2": ["public interface Hypergraph<N, E> extends Graph<N, E> {\n"]}, "added_lines": {"1": [23], "2": [40]}, "removed_lines": {"1": [23], "2": [40]}}, {"38": "guava/src/com/google/common/graph/ImmutableGraph.java", "added": {"1": ["import static com.google.common.base.Preconditions.checkArgument;\n", " * A {@link Graph} whose relationships are constant. Instances of this class may be obtained\n"], "2": ["public final class ImmutableGraph<N> extends AbstractConfigurableGraph<N> {\n", "  private ImmutableGraph(Graph<N> graph) {\n", "    super(GraphBuilder.from(graph), getNodeConnections(graph));\n", "  public static <N> ImmutableGraph<N> copyOf(Graph<N> graph) {\n", "    // TODO(b/28087289): we can remove this restriction when Graph supports parallel edges\n", "    checkArgument(!(graph instanceof Network), \"Input must not implement common.graph.Network\");\n", "        ? (ImmutableGraph<N>) graph\n", "        : new ImmutableGraph<N>(graph);\n"], "3": ["  public static <N> ImmutableGraph<N> copyOf(ImmutableGraph<N> graph) {\n", "  private static <N> Map<N, NodeAdjacencies<N>> getNodeConnections(Graph<N> graph) {\n", "    ImmutableMap.Builder<N, NodeAdjacencies<N>> nodeConnections = ImmutableMap.builder();\n", "  private static <N> NodeAdjacencies<N> nodeConnectionsOf(Graph<N> graph, N node) {\n", "        ? DirectedNodeAdjacencies.ofImmutable(graph.predecessors(node), graph.successors(node))\n", "        : UndirectedNodeAdjacencies.ofImmutable(graph.adjacentNodes(node));\n"]}, "removed": {"1": ["import com.google.common.collect.ImmutableSet;\n", "import com.google.errorprone.annotations.CanIgnoreReturnValue;\n", "import java.util.Set;\n", " * A {@link Graph} whose contents will never change. Instances of this class should be obtained\n"], "2": [" * @param <E> Edge parameter type\n", "public final class ImmutableGraph<N, E> extends ConfigurableGraph<N, E> {\n", "  private ImmutableGraph(Graph<N, E> graph) {\n", "    super(GraphBuilder.from(graph), getNodeConnections(graph), getEdgeToIncidentNodes(graph));\n", "  public static <N, E> ImmutableGraph<N, E> copyOf(Graph<N, E> graph) {\n", "        ? (ImmutableGraph<N, E>) graph\n", "        : new ImmutableGraph<N, E>(graph);\n"], "3": ["  public static <N, E> ImmutableGraph<N, E> copyOf(ImmutableGraph<N, E> graph) {\n", "  /**\n", "   * Guaranteed to throw an exception and leave the graph unmodified.\n", "   *\n", "   * @throws UnsupportedOperationException always\n", "   * @deprecated Unsupported operation.\n", "   */\n", "  @CanIgnoreReturnValue\n", "  @Deprecated\n", "  @Override\n", "  public final boolean addNode(N node) {\n", "    throw new UnsupportedOperationException();\n", "  }\n", "\n", "  /**\n", "   * Guaranteed to throw an exception and leave the graph unmodified.\n", "   *\n", "   * @throws UnsupportedOperationException always\n", "   * @deprecated Unsupported operation.\n", "   */\n", "  @CanIgnoreReturnValue\n", "  @Deprecated\n", "  @Override\n", "  public final boolean addEdge(E edge, N node1, N node2) {\n", "    throw new UnsupportedOperationException();\n", "  }\n", "\n", "  /**\n", "   * Guaranteed to throw an exception and leave the graph unmodified.\n", "   *\n", "   * @throws UnsupportedOperationException always\n", "   * @deprecated Unsupported operation.\n", "   */\n", "  @CanIgnoreReturnValue\n", "  @Deprecated\n", "  @Override\n", "  public final boolean removeNode(Object node) {\n", "    throw new UnsupportedOperationException();\n", "  }\n", "\n", "  /**\n", "   * Guaranteed to throw an exception and leave the graph unmodified.\n", "   *\n", "   * @throws UnsupportedOperationException always\n", "   * @deprecated Unsupported operation.\n", "   */\n", "  @CanIgnoreReturnValue\n", "  @Deprecated\n", "  @Override\n", "  public final boolean removeEdge(Object edge) {\n", "    throw new UnsupportedOperationException();\n", "  }\n", "\n", "  @Override\n", "  public Set<E> edgesConnecting(Object node1, Object node2) {\n", "    // This set is calculated as the intersection of two sets, and is likely to be small.\n", "    // As an optimization, copy it to an ImmutableSet so re-iterating is fast.\n", "    return ImmutableSet.copyOf(super.edgesConnecting(node1, node2));\n", "  }\n", "\n", "  private static <N, E> Map<N, NodeConnections<N, E>> getNodeConnections(Graph<N, E> graph) {\n", "    ImmutableMap.Builder<N, NodeConnections<N, E>> nodeConnections = ImmutableMap.builder();\n", "  private static <N, E> Map<E, IncidentNodes<N>> getEdgeToIncidentNodes(Graph<N, E> graph) {\n", "    ImmutableMap.Builder<E, IncidentNodes<N>> edgeToIncidentNodes = ImmutableMap.builder();\n", "    for (E edge : graph.edges()) {\n", "      edgeToIncidentNodes.put(edge, IncidentNodes.of(graph.incidentNodes(edge)));\n", "    }\n", "    return edgeToIncidentNodes.build();\n", "  }\n", "\n", "  private static <N, E> NodeConnections<N, E> nodeConnectionsOf(Graph<N, E> graph, N node) {\n", "        ? DirectedNodeConnections.ofImmutable(\n", "            graph.predecessors(node), graph.successors(node),\n", "            graph.inEdges(node), graph.outEdges(node))\n", "        : UndirectedNodeConnections.ofImmutable(\n", "            graph.adjacentNodes(node), graph.incidentEdges(node));\n"]}, "added_lines": {"1": [19, 27], "2": [37, 39, 40, 46, 47, 48, 50, 51], "3": [60, 64, 65, 72, 74, 75]}, "removed_lines": {"1": [22, 23, 26, 29], "2": [38, 40, 42, 43, 49, 51, 52], "3": [61, 65, 66, 67, 68, 69, 70, 71, 72, 73, 74, 75, 76, 77, 78, 79, 80, 81, 82, 83, 84, 85, 86, 87, 88, 89, 90, 91, 92, 93, 94, 95, 96, 97, 98, 99, 100, 101, 102, 103, 104, 105, 106, 107, 108, 109, 110, 111, 112, 113, 114, 115, 116, 117, 118, 119, 120, 121, 122, 123, 124, 125, 132, 133, 134, 135, 136, 137, 138, 139, 140, 142, 143, 144, 145, 146]}}, {"39": "guava/src/com/google/common/graph/ImmutableNetwork.java", "added": {"1": ["/*\n", " * Copyright (C) 2014 The Guava Authors\n", " *\n", " * Licensed under the Apache License, Version 2.0 (the \"License\");\n", " * you may not use this file except in compliance with the License.\n", " * You may obtain a copy of the License at\n", " *\n", " * http://www.apache.org/licenses/LICENSE-2.0\n", " *\n", " * Unless required by applicable law or agreed to in writing, software\n", " * distributed under the License is distributed on an \"AS IS\" BASIS,\n", " * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n", " * See the License for the specific language governing permissions and\n", " * limitations under the License.\n", " */\n", "\n", "package com.google.common.graph;\n", "\n", "import static com.google.common.base.Preconditions.checkNotNull;\n", "\n", "import com.google.common.collect.ImmutableMap;\n", "import com.google.common.collect.ImmutableSet;\n", "\n", "import java.util.Map;\n", "import java.util.Set;\n", "\n", "/**\n", " * A {@link Network} whose relationships are constant. Instances of this class may be obtained\n", " * with {@link #copyOf(Network)}.\n", " *\n", " * <p>The time complexity of {@code edgesConnecting(node1, node2)} is O(min(outD_node1, inD_node2)).\n", " *\n", " * @author James Sexton\n", " * @author Joshua O'Madadhain\n", " * @author Omar Darwish\n", " * @param <N> Node parameter type\n", " * @param <E> Edge parameter type\n", " */\n", "public final class ImmutableNetwork<N, E> extends AbstractConfigurableNetwork<N, E> {\n", "\n", "  private ImmutableNetwork(Network<N, E> graph) {\n", "    super(NetworkBuilder.from(graph), getNodeConnections(graph), getEdgeToIncidentNodes(graph));\n", "  }\n", "\n", "  /**\n", "   * Returns an immutable copy of {@code graph}.\n", "   */\n", "  public static <N, E> ImmutableNetwork<N, E> copyOf(Network<N, E> graph) {\n", "    return (graph instanceof ImmutableNetwork)\n", "        ? (ImmutableNetwork<N, E>) graph\n", "        : new ImmutableNetwork<N, E>(graph);\n", "  }\n", "\n", "  /**\n", "   * Simply returns its argument.\n", "   *\n", "   * @deprecated no need to use this\n", "   */\n", "  @Deprecated\n", "  public static <N, E> ImmutableNetwork<N, E> copyOf(ImmutableNetwork<N, E> graph) {\n", "    return checkNotNull(graph);\n", "  }\n", "\n", "  @Override\n", "  public Set<E> edgesConnecting(Object node1, Object node2) {\n", "    // This set is calculated as the intersection of two sets, and is likely to be small.\n", "    // As an optimization, copy it to an ImmutableSet so re-iterating is fast.\n", "    return ImmutableSet.copyOf(super.edgesConnecting(node1, node2));\n", "  }\n", "\n", "  private static <N, E> Map<N, NodeConnections<N, E>> getNodeConnections(Network<N, E> graph) {\n", "    ImmutableMap.Builder<N, NodeConnections<N, E>> nodeConnections = ImmutableMap.builder();\n", "    for (N node : graph.nodes()) {\n", "      nodeConnections.put(node, nodeConnectionsOf(graph, node));\n", "    }\n", "    return nodeConnections.build();\n", "  }\n", "\n", "  private static <N, E> Map<E, IncidentNodes<N>> getEdgeToIncidentNodes(Network<N, E> graph) {\n", "    ImmutableMap.Builder<E, IncidentNodes<N>> edgeToIncidentNodes = ImmutableMap.builder();\n", "    for (E edge : graph.edges()) {\n", "      edgeToIncidentNodes.put(edge, IncidentNodes.of(graph.incidentNodes(edge)));\n", "    }\n", "    return edgeToIncidentNodes.build();\n", "  }\n", "\n", "  private static <N, E> NodeConnections<N, E> nodeConnectionsOf(Network<N, E> graph, N node) {\n", "    return graph.isDirected()\n", "        ? DirectedNodeConnections.ofImmutable(\n", "            graph.predecessors(node), graph.successors(node),\n", "            graph.inEdges(node), graph.outEdges(node))\n", "        : UndirectedNodeConnections.ofImmutable(\n", "            graph.adjacentNodes(node), graph.incidentEdges(node));\n", "  }\n", "}\n"]}, "removed": {}, "added_lines": {"1": [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 58, 59, 60, 61, 62, 63, 64, 65, 66, 67, 68, 69, 70, 71, 72, 73, 74, 75, 76, 77, 78, 79, 80, 81, 82, 83, 84, 85, 86, 87, 88, 89, 90, 91, 92, 93, 94, 95]}, "removed_lines": {}}, {"40": "guava/src/com/google/common/graph/MutableGraph.java", "added": {"1": ["/*\n", " * Copyright (C) 2014 The Guava Authors\n", " *\n", " * Licensed under the Apache License, Version 2.0 (the \"License\");\n", " * you may not use this file except in compliance with the License.\n", " * You may obtain a copy of the License at\n", " *\n", " * http://www.apache.org/licenses/LICENSE-2.0\n", " *\n", " * Unless required by applicable law or agreed to in writing, software\n", " * distributed under the License is distributed on an \"AS IS\" BASIS,\n", " * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n", " * See the License for the specific language governing permissions and\n", " * limitations under the License.\n", " */\n", "\n", "package com.google.common.graph;\n", "\n", "import com.google.common.annotations.Beta;\n", "import com.google.errorprone.annotations.CanIgnoreReturnValue;\n", "\n", "/**\n", " * A subtype of {@link Graph} which permits mutations.\n", " * Users should generally use the {@link Graph} interface where possible.\n", " *\n", " * @author Joshua O'Madadhain\n", " * @param <N> Node parameter type\n", " * @since 20.0\n", " */\n", "@Beta\n", "public interface MutableGraph<N> extends Graph<N> {\n", "\n", "  /**\n", "   * Adds {@code node} to this graph (optional operation).\n", "   *\n", "   * <p><b>Nodes must be unique</b>, just as {@code Map} keys must be; they must also be non-null.\n", "   *\n", "   * @return {@code true} iff the graph was modified as a result of this call\n", "   * @throws UnsupportedOperationException if the add operation is not supported by this graph\n", "   */\n", "  @CanIgnoreReturnValue\n", "  boolean addNode(N node);\n", "\n", "  /**\n", "   * Adds an (implicit) edge to this graph connecting {@code node1} to {@code node2}\n", "   * (optional operation).\n", "   *\n", "   * <p>Behavior if {@code node1} and {@code node2} are not already elements of the graph is\n", "   * unspecified. Suggested behaviors include (a) silently adding {@code node1} and {@code node2}\n", "   * to the graph or (b) throwing {@code IllegalArgumentException}.\n", "   *\n", "   * <p>Currently, this type does not support parallel edges.  {@code addEdge(node1, node2)} will\n", "   * simply return false on any future calls with the same arguments (analogous to the behavior of\n", "   * {@code Network.addEdge(e, node1, node2)}).  A hypothetical instance that supported parallel\n", "   * edges would add a new edge between {@code node1} and {@code node2} for every call to\n", "   * {@code addEdge(node1, node2)}, and return {@code true} every time.\n", "   *\n", "   * @return {@code true} iff the graph was modified as a result of this call\n", "   * @throws UnsupportedOperationException if the add operation is not supported by this graph\n", "   */\n", "  @CanIgnoreReturnValue\n", "  boolean addEdge(N node1, N node2);\n", "\n", "  /**\n", "   * Removes {@code node} from this graph, if it is present (optional operation).\n", "   * In general, all edges incident to {@code node} in this graph will also be removed.\n", "   * (This is not true for hyperedges.)\n", "   *\n", "   * @return {@code true} iff the graph was modified as a result of this call\n", "   * @throws UnsupportedOperationException if the remove operation is not supported by this graph\n", "   */\n", "  @CanIgnoreReturnValue\n", "  boolean removeNode(Object node);\n", "\n", "  /**\n", "   * Removes an edge connecting {@code node1} to {@code node2} from this graph, if one is present\n", "   * (optional operation).\n", "   *\n", "   * <p>In general, the input nodes are unaffected (although implementations may choose\n", "   * to disallow certain configurations, e.g., isolated nodes).\n", "   *\n", "   * @return {@code true} iff the graph was modified as a result of this call\n", "   * @throws UnsupportedOperationException if the remove operation is not supported by this graph\n", "   */\n", "  @CanIgnoreReturnValue\n", "  boolean removeEdge(Object node1, Object node2);\n", "}\n"]}, "removed": {}, "added_lines": {"1": [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 58, 59, 60, 61, 62, 63, 64, 65, 66, 67, 68, 69, 70, 71, 72, 73, 74, 75, 76, 77, 78, 79, 80, 81, 82, 83, 84, 85, 86, 87]}, "removed_lines": {}}, {"41": "guava/src/com/google/common/graph/MutableNetwork.java", "added": {"1": ["/*\n", " * Copyright (C) 2014 The Guava Authors\n", " *\n", " * Licensed under the Apache License, Version 2.0 (the \"License\");\n", " * you may not use this file except in compliance with the License.\n", " * You may obtain a copy of the License at\n", " *\n", " * http://www.apache.org/licenses/LICENSE-2.0\n", " *\n", " * Unless required by applicable law or agreed to in writing, software\n", " * distributed under the License is distributed on an \"AS IS\" BASIS,\n", " * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n", " * See the License for the specific language governing permissions and\n", " * limitations under the License.\n", " */\n", "\n", "package com.google.common.graph;\n", "\n", "import com.google.common.annotations.Beta;\n", "import com.google.errorprone.annotations.CanIgnoreReturnValue;\n", "\n", "/**\n", " * A subtype of {@link Network} which permits mutations.\n", " * Users should generally use the {@link Network} interface where possible.\n", " *\n", " * @author Joshua O'Madadhain\n", " * @param <N> Node parameter type\n", " * @param <E> Edge parameter type\n", " * @since 20.0\n", " */\n", "@Beta\n", "public interface MutableNetwork<N, E> extends Network<N, E> {\n", "\n", "  /**\n", "   * Adds {@code node} to this graph (optional operation).\n", "   *\n", "   * <p><b>Nodes must be unique</b>, just as {@code Map} keys must be; they must also be non-null.\n", "   *\n", "   * @return {@code true} iff the graph was modified as a result of this call\n", "   * @throws UnsupportedOperationException if the add operation is not supported by this graph\n", "   */\n", "  @CanIgnoreReturnValue\n", "  boolean addNode(N node);\n", "\n", "  /**\n", "   * Adds {@code edge} to this graph, connecting {@code node1} to {@code node2}\n", "   * (optional operation).\n", "   *\n", "   * <p><b>Edges must be unique</b>, just as {@code Map} keys must be; they must also be non-null.\n", "   *\n", "   * <p>If {@code edge} already connects {@code node1} to {@code node2} in this graph\n", "   * (in the specified order if order is significant, as for directed graphs, else in any order),\n", "   * then this method will have no effect and will return {@code false}.\n", "   *\n", "   * <p>Behavior if {@code node1} and {@code node2} are not already elements of the graph is\n", "   * unspecified. Suggested behaviors include (a) silently adding {@code node1} and {@code node2}\n", "   * to the graph or (b) throwing {@code IllegalArgumentException}.\n", "   *\n", "   * @return {@code true} iff the graph was modified as a result of this call\n", "   * @throws IllegalArgumentException if {@code edge} already exists and connects nodes other than\n", "   *     {@code node1} and {@code node2}, or if the graph is not a multigraph and {@code node1} is\n", "   *     already connected to {@code node2}\n", "   * @throws UnsupportedOperationException if the add operation is not supported by this graph\n", "   */\n", "  @CanIgnoreReturnValue\n", "  boolean addEdge(E edge, N node1, N node2);\n", "\n", "  /**\n", "   * Removes {@code node} from this graph, if it is present (optional operation).\n", "   * In general, all edges incident to {@code node} in this graph will also be removed.\n", "   * (This is not true for hyperedges.)\n", "   *\n", "   * @return {@code true} iff the graph was modified as a result of this call\n", "   * @throws UnsupportedOperationException if the remove operation is not supported by this graph\n", "   */\n", "  @CanIgnoreReturnValue\n", "  boolean removeNode(Object node);\n", "\n", "  /**\n", "   * Removes {@code edge} from this graph, if it is present (optional operation).\n", "   * In general, nodes incident to {@code edge} are unaffected (although implementations may choose\n", "   * to disallow certain configurations, e.g., isolated nodes).\n", "   *\n", "   * @return {@code true} iff the graph was modified as a result of this call\n", "   * @throws UnsupportedOperationException if the remove operation is not supported by this graph\n", "   */\n", "  @CanIgnoreReturnValue\n", "  boolean removeEdge(Object edge);\n", "}\n"]}, "removed": {}, "added_lines": {"1": [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 58, 59, 60, 61, 62, 63, 64, 65, 66, 67, 68, 69, 70, 71, 72, 73, 74, 75, 76, 77, 78, 79, 80, 81, 82, 83, 84, 85, 86, 87, 88, 89]}, "removed_lines": {}}, {"42": "guava/src/com/google/common/graph/Network.java", "added": {"1": ["/*\n", " * Copyright (C) 2014 The Guava Authors\n", " *\n", " * Licensed under the Apache License, Version 2.0 (the \"License\");\n", " * you may not use this file except in compliance with the License.\n", " * You may obtain a copy of the License at\n", " *\n", " * http://www.apache.org/licenses/LICENSE-2.0\n", " *\n", " * Unless required by applicable law or agreed to in writing, software\n", " * distributed under the License is distributed on an \"AS IS\" BASIS,\n", " * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n", " * See the License for the specific language governing permissions and\n", " * limitations under the License.\n", " */\n", "\n", "package com.google.common.graph;\n", "\n", "import com.google.common.annotations.Beta;\n", "\n", "import java.util.Set;\n", "\n", "import javax.annotation.Nullable;\n", "\n", "/**\n", " * A network consisting of a set of nodes of type N and a set of edges of type E.\n", " * That is, a subtype of {@link Graph} that represents edges as explicit first-class objects.\n", " * Users that are not interested in edges as first-class objects should use a {@link Graph}\n", " * instead.\n", " *\n", " * <p>Users that wish to modify a {@code Network} must work with its subinterface,\n", " * {@code MutableNetwork}.\n", " *\n", " * <p>This interface permits, but does not enforce, any of the following variations of graphs:\n", " * <ul>\n", " * <li>directed and undirected edges\n", " * <li>hyperedges (edges which are incident to arbitrary sets of nodes)\n", " * <li>nodes and edges with attributes (for example, weighted edges)\n", " * <li>nodes and edges of different types (for example, bipartite or multimodal graphs)\n", " * <li>parallel edges (multiple edges which connect a single set of nodes)\n", " * </ul>\n", " *\n", " * <p>Extensions or implementations of this interface may enforce or disallow any or all\n", " * of these variations.\n", " *\n", " * <p>Definitions:\n", " * <ul>\n", " * <li>{@code edge} and {@code node} are <b>incident</b> to each other if the set of\n", " *     {@code edge}'s endpoints includes {@code node}.\n", " * <li>{@code node1} and {@code node2} are mutually <b>adjacent</b> if both are incident\n", " *     to a common {@code edge}.\n", " *     <br>Similarly, {@code edge1} and {@code edge2} are mutually adjacent if both are\n", " *     incident to a common {@code node}.\n", " * <li>Elements are <b>connected</b> if they are either incident or adjacent.\n", " * <li>{@code edge} is an <b>incoming edge</b> of a {@code node} if it can be traversed (in\n", " *     the direction, if any, of {@code edge}) from a node adjacent to {@code node}.\n", " * <li>{@code edge} is an <b>outgoing edge</b> of {@code node} if it can be traversed (in\n", " *     the direction, if any, of {@code edge}) from {@code node} to reach a node adjacent to\n", " *     {@code node}.\n", " *   <ul>\n", " *   <li>Note: <b>undirected</b> edges are both incoming and outgoing edges of a {@code node},\n", " *       while <b>directed</b> edges are either incoming or outgoing edges of {@code node}\n", " *       (and not both, unless the edge is a self-loop).\n", " *       <br>Thus, in the following example {@code edge1} is an incoming edge of {@code node2} and\n", " *       an outgoing edge of {@code node1}, while {@code edge2} is both an incoming and an outgoing\n", " *       edge of both {@code node3} and {@code node4}:\n", " *       <br><pre><code>\n", " *         directedGraph.addEdge(edge1, node1, node2);\n", " *         undirectedGraph.addEdge(edge2, node3, node4);\n", " *       </pre></code>\n", " *   </ul>\n", " * <li>A node {@code pred} is a <b>predecessor</b> of {@code node} if it is incident to an incoming\n", " *     {@code edge} of {@code node} (and is not itself {@code node} unless {@code edge} is\n", " *     a self-loop).\n", " * <li>A node {@code succ} is a <b>successor</b> of {@code node} if it is incident to an outgoing\n", " *     {@code edge} of {@code node} (and is not itself {@code node} unless {@code edge} is\n", " *     a self-loop).\n", " * <li>Directed edges only:\n", " *   <ul>\n", " *   <li>{@code node} is a <b>source</b> of {@code edge} if {@code edge} is an outgoing edge\n", " *       of {@code node}.\n", " *   <li>{@code node} is a <b>target</b> of {@code edge} if {@code edge} is an incoming edge\n", " *       of {@code node}.\n", " *   </ul>\n", " * </ul>\n", " *\n", " * <p>General notes:\n", " * <ul>\n", " * <li><b>Nodes/edges must be useable as {@code Map} keys</b>:\n", " *   <ul>\n", " *   <li>They must be unique in a graph: nodes {@code node1} and {@code node2} are considered\n", " *       different if and only if {@code node1.equals(node2) == false}, and the same for edges.\n", " *   <li>If you would otherwise have duplicate edges (e.g. weighted edges represented by a Double),\n", " *       you can instead wrap the edges in a custom class that defers to {@link Object} for its\n", " *       {@code equals()} and {@code hashCode()} implementations.\n", " *   <li>If graph elements have mutable state:\n", " *     <ul>\n", " *     <li>the mutable state must not be reflected in the {@code equals/hashCode} methods\n", " *         (this is discussed in the {@code Map} documentation in detail)\n", " *     <li>don't construct multiple elements that are equal to each other and expect them to be\n", " *         interchangeable.  In particular, when adding such elements to a graph, you should create\n", " *         them once and store the reference if you will need to refer to those elements more than\n", " *         once during creation (rather than passing {@code new MyMutableNode(id)} to each\n", " *         {@code add*()} call).\n", " *     </ul>\n", " *   </ul>\n", " *   <br>Generally speaking, your design may be more robust if you use immutable nodes/edges and\n", " * store mutable per-element state in a separate data structure (e.g. an element-to-state map).\n", " * <li>There are no Node or Edge classes built in.  So you can have a {@code Graph<Integer, String>}\n", " *     or a {@code Graph<Author,Publication>} or a {@code Graph<Webpage,Link>}.\n", " * <li>This framework supports multiple mechanisms for storing the topology of a graph, including:\n", " *   <ul>\n", " *   <li>the Graph implementation stores the topology (for example, by storing a {@code Map<N, E>}\n", " *       that maps nodes onto their incident edges); this implies that the nodes and edges\n", " *       are just keys, and can be shared among graphs\n", " *   <li>the nodes store the topology (for example, by storing a {@code List<E>} of incident edges);\n", " *       this (usually) implies that nodes are graph-specific\n", " *   <li>a separate data repository (for example, a database) stores the topology\n", " *   </ul>\n", " * </ul>\n", " *\n", " * <p>Notes on accessors:\n", " * <ul>\n", " * <li>Accessors which return collections may return views of the Graph. Modifications to the graph\n", " *     which affect a view (e.g. calling {@code addNode(n)} or {@code removeNode(n)} while iterating\n", " *     through {@code nodes()}) are not supported and may result in ConcurrentModificationException.\n", " * <li>Accessors which return collections will return empty collections if their inputs are valid\n", " *     but no elements satisfy the request (for example: {@code adjacentNodes(node)} will return an\n", " *     empty collection if {@code node} has no adjacent nodes).\n", " * <li>Accessors will throw {@code IllegalArgumentException} if passed a node/edge\n", " *     that is not in the graph.\n", " * <li>Accessors take Object parameters rather than N/E generic type specifiers to match the pattern\n", " *     set by the Java Collections Framework.\n", " * </ul>\n", " *\n", " * <p>Notes for implementors:\n", " * <ul>\n", " * <li>Implementations have numerous options for internal representations: matrices, adjacency\n", " *     lists, adjacency maps, etc.\n", " * <li>For accessors that return a {@code Set}, there are several options for the set behavior,\n", " *     including:\n", " *     <ol>\n", " *     <li>Set is an immutable copy (e.g. {@code ImmutableSet}): attempts to modify the set in any\n", " *         way will throw an exception, and modifications to the graph will <b>not</b> be reflected\n", " *         in the set.\n", " *     <li>Set is an unmodifiable view (e.g. {@code Collections.unmodifiableSet()}): attempts to\n", " *         modify the set in any way will throw an exception, and modifications to the graph will be\n", " *         reflected in the set.\n", " *     <li>Set is a mutable copy: it may be modified, but modifications to the graph will <b>not</b>\n", " *         be reflected in the set, and vice versa.\n", " *     <li>Set is a modifiable view: it may be modified, and modifications to the graph will be\n", " *         reflected in the set (but modifications to the set will <b>not</b> be reflected in the\n", " *         graph).\n", " *     <li>Set exposes the internal data directly: it may be modified, and modifications to the\n", " *         graph will be reflected in the set, and vice versa.\n", " *     </ol>\n", " *     Note that (1) and (2) are generally preferred. (5) is generally a hazardous design choice\n", " *     and should be avoided, because keeping the internal data structures consistent can be tricky.\n", " * <li>Prefer extending {@link AbstractGraph} over implementing {@link Graph} directly. This will\n", " *     ensure consistent {@link #equals(Object)} and {@link #hashCode()} across implementations.\n", " * <li>{@code Multimap}s are not sufficient internal data structures for Graph implementations\n", " *     that support isolated nodes (nodes that have no incident edges), due to their restriction\n", " *     that a key either maps to at least one value, or is not present in the {@code Multimap}.\n", " * </ul>\n", " *\n", " * <p>Examples of use:\n", " * <ul>\n", " * <li>Is {@code node} in the graph?\n", " * <pre><code>\n", " *   graph.nodes().contains(node)\n", " * </code></pre>\n", " * <li>Traversing an undirected graph node-wise:\n", " * <pre><code>\n", " *   // Visit nodes reachable from {@code node}.\n", " *   void depthFirstTraverse(N node) {\n", " *     for (N neighbor : graph.adjacentNodes(node)) {\n", " *       if (!isVisited(neighbor)) {\n", " *         visit(neighbor);\n", " *         depthFirstTraverse(neighbor);\n", " *       }\n", " *     }\n", " *   }\n", " * </code></pre>\n", " * <li>Traversing a directed graph edge-wise:\n", " * <pre><code>\n", " *   // Update the shortest-path distances of the successors to {@code node}\n", " *   // in a directed graph (inner loop of Dijkstra's algorithm):\n", " *   void updateDistances(N node) {\n", " *     nodeDistance = distances.get(node);\n", " *     for (E outEdge : graph.outEdges(node)) {\n", " *       N target = graph.target(outEdge);\n", " *       double targetDistance = nodeDistance + outEdge.getWeight();\n", " *       if (targetDistance < distances.get(target)) {\n", " *         distances.put(target, targetDistance);\n", " *       }\n", " *     }\n", " *   }\n", " * </code></pre>\n", " * </ul>\n", " *\n", " * @author Joshua O'Madadhain\n", " * @param <N> Node parameter type\n", " * @param <E> Edge parameter type\n", " * @since 20.0\n", " */\n", "@Beta\n", "public interface Network<N, E> extends Graph<N> {\n", "  /** Returns all edges in this network. */\n", "  Set<E> edges();\n", "\n", "  //\n", "  // Graph properties\n", "  //\n", "\n", "  /**\n", "   * Returns true if each edge in this graph is directed.\n", "   *\n", "   * <p>A directed edge is an {@linkplain #outEdges(Object) outgoing edge} of its\n", "   * {@linkplain #source(Object) source}, and an {@linkplain #inEdges(Object) incoming edge} of its\n", "   * {@linkplain #target(Object) target}. An undirected edge connects its\n", "   * {@linkplain #incidentNodes(Object) incident nodes} to each other, and is both an\n", "   * {@linkplain #outEdges(Object) outgoing edge} and {@linkplain #inEdges(Object) incoming edge}\n", "   * of each incident node.\n", "   */\n", "  @Override\n", "  boolean isDirected();\n", "\n", "  /**\n", "   * Returns true if this graph allows parallel edges. Attempting to add a parallel edge to a graph\n", "   * that does not allow them will throw an {@link UnsupportedOperationException}.\n", "   */\n", "  boolean allowsParallelEdges();\n", "\n", "  //\n", "  // Element-level accessors\n", "  //\n", "\n", "  /**\n", "   * Returns the edges whose endpoints in this graph include {@code node}.\n", "   *\n", "   * @throws IllegalArgumentException if {@code node} is not an element of this graph\n", "   */\n", "  Set<E> incidentEdges(Object node);\n", "\n", "  /**\n", "   * Returns the nodes which are the endpoints of {@code edge} in this graph.\n", "   *\n", "   * <p>For self-loop edges, the returned set's size will be 1. If the graph is\n", "   * {@linkplain #isDirected() directed} and {@code edge} is not a self-loop, the\n", "   * iteration order will be {@code [source(edge), target(edge)]}.\n", "   *\n", "   * @throws IllegalArgumentException if {@code edge} is not an element of this graph\n", "   */\n", "  Set<N> incidentNodes(Object edge);\n", "\n", "  /**\n", "   * Returns the nodes which have an {@linkplain #incidentEdges(Object) incident edge}\n", "   * in common with {@code node} in this graph.\n", "   *\n", "   * @throws IllegalArgumentException if {@code node} is not an element of this graph\n", "   */\n", "  @Override\n", "  Set<N> adjacentNodes(Object node);\n", "\n", "  /**\n", "   * Returns the edges which have an {@linkplain #incidentNodes(Object) incident node}\n", "   * in common with {@code edge} in this graph.\n", "   *\n", "   * <p>Whether an edge is considered adjacent to itself is not defined by this interface, but\n", "   * generally for non-hypergraphs, edges are not considered to be self-adjacent.\n", "   *\n", "   * @throws IllegalArgumentException if {@code edge} is not an element of this graph\n", "   */\n", "  Set<E> adjacentEdges(Object edge);\n", "\n", "  /**\n", "   * Returns the set of edges that connect {@code node1} to {@code node2}.\n", "   *\n", "   * <p>This set is the intersection of {@code outEdges(node1)} and {@code inEdges(node2)}. If\n", "   * {@code node1} is equal to {@code node2}, then it is the set of self-loop edges for that node.\n", "   *\n", "   * @throws IllegalArgumentException if {@code node1} or {@code node2} is not an element\n", "   *     of this graph\n", "   */\n", "  Set<E> edgesConnecting(Object node1, Object node2);\n", "\n", "  /**\n", "   * Returns all edges in this graph which can be traversed in the direction (if any) of the edge\n", "   * to end at {@code node}.\n", "   *\n", "   * @throws IllegalArgumentException if {@code node} is not an element of this graph\n", "   */\n", "  Set<E> inEdges(Object node);\n", "\n", "  /**\n", "   * Returns all edges in this graph which can be traversed in the direction (if any) of the edge\n", "   * starting from {@code node}.\n", "   *\n", "   * @throws IllegalArgumentException if {@code node} is not an element of this graph\n", "   */\n", "  Set<E> outEdges(Object node);\n", "\n", "  /**\n", "   * Returns all nodes in this graph adjacent to {@code node} which can be reached by traversing\n", "   * {@code node}'s {@linkplain #inEdges(Object) incoming edges} <i>against</i> the direction\n", "   * (if any) of the edge.\n", "   *\n", "   * @throws IllegalArgumentException if {@code node} is not an element of this graph\n", "   */\n", "  @Override\n", "  Set<N> predecessors(Object node);\n", "\n", "  /**\n", "   * Returns all nodes in this graph adjacent to {@code node} which can be reached by traversing\n", "   * {@code node}'s {@linkplain #outEdges(Object) outgoing edges} in the direction (if any) of the\n", "   * edge.\n", "   *\n", "   * <p>This is <i>not</i> the same as \"all nodes reachable from {@code node} by following outgoing\n", "   * edges\" (also known as {@code node}'s transitive closure).\n", "   *\n", "   * @throws IllegalArgumentException if {@code node} is not an element of this graph\n", "   */\n", "  @Override\n", "  Set<N> successors(Object node);\n", "\n", "  //\n", "  // Element-level queries\n", "  //\n", "\n", "  /**\n", "   * For a directed graph, returns the node for which {@code edge} is an outgoing edge.\n", "   * For an undirected graph, throws an {@link UnsupportedOperationException}.\n", "   */\n", "  N source(Object edge);\n", "\n", "  /**\n", "   * For a directed graph, returns the node for which {@code edge} is an incoming edge.\n", "   * For an undirected graph, throws an {@link UnsupportedOperationException}.\n", "   */\n", "  N target(Object edge);\n", "\n", "  /**\n", "   * Returns the number of edges {@linkplain #incidentEdges(Object) incident} in this graph\n", "   * to {@code node}.  If this node has more than {@code Integer.MAX_VALUE} incident edges\n", "   * in this graph, returns {@code Integer.MAX_VALUE}.\n", "   *\n", "   * <p>Equivalent to {@code incidentEdges(node).size()}.\n", "   *\n", "   * <p>Note that self-loops only count once towards a node's degree.\n", "   * This is consistent with the definition of {@link #incidentEdges(Object)}.\n", "   *\n", "   * @throws IllegalArgumentException if {@code node} is not an element of this graph\n", "   */\n", "  @Override\n", "  int degree(Object node);\n", "\n", "  /**\n", "   * Returns the number of {@linkplain #inEdges(Object) incoming edges} in this graph\n", "   * of {@code node}.  If this node has more than {@code Integer.MAX_VALUE} incoming edges\n", "   * in this graph, returns {@code Integer.MAX_VALUE}.\n", "   *\n", "   * <p>Equivalent to {@code inEdges(node).size()}.\n", "   *\n", "   * @throws IllegalArgumentException if {@code node} is not an element of this graph\n", "   */\n", "  @Override\n", "  int inDegree(Object node);\n", "\n", "  /**\n", "   * Returns the number of {@linkplain #outEdges(Object) outgoing edges} in this graph\n", "   * of {@code node}.  If this node has more than {@code Integer.MAX_VALUE} outgoing edges\n", "   * in this graph, returns {@code Integer.MAX_VALUE}.\n", "   *\n", "   * <p>Equivalent to {@code outEdges(node).size()}.\n", "   *\n", "   * @throws IllegalArgumentException if {@code node} is not an element of this graph\n", "   */\n", "  @Override\n", "  int outDegree(Object node);\n", "\n", "  /**\n", "   * Returns {@code true} iff {@code object} is a graph that has the same node/edge relationships\n", "   * as those in this graph.\n", "   *\n", "   * <p>Thus, two graphs A and B are equal if <b>all</b> of the following are true:\n", "   * <ul>\n", "   * <li>A and B have the same node set\n", "   * <li>A and B have the same edge set\n", "   * <li>A and B have the same incidence relationships, e.g., for each node/edge in A and in B\n", "   *     its incident edge/node set in A is the same as its incident edge/node set in B.\n", "   *     <br>Thus, every edge in A and B connect the same nodes in the same direction (if any).\n", "   * </ul>\n", "   *\n", "   * <p>Graph properties are <b>not</b> respected by this method. For example, two graphs may be\n", "   * considered equal even if one allows parallel edges and the other doesn't. Additionally, the\n", "   * order in which edges or nodes are added to the graph, and the order in which they are iterated\n", "   * over, are irrelevant.\n", "   *\n", "   * <p>A reference implementation of this is provided by {@link Graphs#equal(Graph, Graph)}.\n", "   */\n", "  @Override\n", "  boolean equals(@Nullable Object object);\n", "\n", "  /**\n", "   * Returns the hash code for this graph. The hash code of a graph is defined as the hash code\n", "   * of a map from each of the graph's nodes to their incident edges.\n", "   *\n", "   * <p>A reference implementation of this is provided by {@link Graphs#hashCode(Graph)}.\n", "   *\n", "   * <p>Note that by this definition, two graphs that are equal in every aspect except edge\n", "   * direction will have the same hash code (but can still be differentiated by {@link #equals}.\n", "   */\n", "  @Override\n", "  int hashCode();\n", "}\n"]}, "removed": {}, "added_lines": {"1": [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 58, 59, 60, 61, 62, 63, 64, 65, 66, 67, 68, 69, 70, 71, 72, 73, 74, 75, 76, 77, 78, 79, 80, 81, 82, 83, 84, 85, 86, 87, 88, 89, 90, 91, 92, 93, 94, 95, 96, 97, 98, 99, 100, 101, 102, 103, 104, 105, 106, 107, 108, 109, 110, 111, 112, 113, 114, 115, 116, 117, 118, 119, 120, 121, 122, 123, 124, 125, 126, 127, 128, 129, 130, 131, 132, 133, 134, 135, 136, 137, 138, 139, 140, 141, 142, 143, 144, 145, 146, 147, 148, 149, 150, 151, 152, 153, 154, 155, 156, 157, 158, 159, 160, 161, 162, 163, 164, 165, 166, 167, 168, 169, 170, 171, 172, 173, 174, 175, 176, 177, 178, 179, 180, 181, 182, 183, 184, 185, 186, 187, 188, 189, 190, 191, 192, 193, 194, 195, 196, 197, 198, 199, 200, 201, 202, 203, 204, 205, 206, 207, 208, 209, 210, 211, 212, 213, 214, 215, 216, 217, 218, 219, 220, 221, 222, 223, 224, 225, 226, 227, 228, 229, 230, 231, 232, 233, 234, 235, 236, 237, 238, 239, 240, 241, 242, 243, 244, 245, 246, 247, 248, 249, 250, 251, 252, 253, 254, 255, 256, 257, 258, 259, 260, 261, 262, 263, 264, 265, 266, 267, 268, 269, 270, 271, 272, 273, 274, 275, 276, 277, 278, 279, 280, 281, 282, 283, 284, 285, 286, 287, 288, 289, 290, 291, 292, 293, 294, 295, 296, 297, 298, 299, 300, 301, 302, 303, 304, 305, 306, 307, 308, 309, 310, 311, 312, 313, 314, 315, 316, 317, 318, 319, 320, 321, 322, 323, 324, 325, 326, 327, 328, 329, 330, 331, 332, 333, 334, 335, 336, 337, 338, 339, 340, 341, 342, 343, 344, 345, 346, 347, 348, 349, 350, 351, 352, 353, 354, 355, 356, 357, 358, 359, 360, 361, 362, 363, 364, 365, 366, 367, 368, 369, 370, 371, 372, 373, 374, 375, 376, 377, 378, 379, 380, 381, 382, 383, 384, 385, 386, 387, 388, 389, 390, 391, 392, 393, 394, 395, 396, 397, 398, 399, 400, 401, 402, 403, 404, 405, 406, 407, 408, 409, 410, 411, 412, 413, 414, 415]}, "removed_lines": {}}, {"43": "guava/src/com/google/common/graph/NetworkBuilder.java", "added": {"1": ["/*\n", " * Copyright (C) 2016 The Guava Authors\n", " *\n", " * Licensed under the Apache License, Version 2.0 (the \"License\");\n", " * you may not use this file except in compliance with the License.\n", " * You may obtain a copy of the License at\n", " *\n", " * http://www.apache.org/licenses/LICENSE-2.0\n", " *\n", " * Unless required by applicable law or agreed to in writing, software\n", " * distributed under the License is distributed on an \"AS IS\" BASIS,\n", " * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n", " * See the License for the specific language governing permissions and\n", " * limitations under the License.\n", " */\n", "\n", "package com.google.common.graph;\n", "\n", "import static com.google.common.base.Preconditions.checkArgument;\n", "\n", "import com.google.common.base.Optional;\n", "\n", "import java.util.Comparator;\n", "\n", "/**\n", " * A builder for constructing instances of {@link Network} with user-defined properties.\n", " *\n", " * <p>A graph built by this class will have the following properties by default:\n", " * <ul>\n", " * <li>does not allow parallel edges\n", " * <li>allows self-loops\n", " * </ul>\n", " *\n", " * @author James Sexton\n", " * @author Joshua O'Madadhain\n", " * @since 20.0\n", " */\n", "// TODO(b/24620028): Add support for sorted nodes/edges. Use the same pattern as CacheBuilder\n", "// to narrow the generic <N, E> type when Comparators are provided.\n", "// TODO(user): try creating an abstract superclass that this and GraphBuilder could derive from.\n", "public final class NetworkBuilder<N, E> {\n", "  final boolean directed;\n", "  boolean allowsParallelEdges = false;\n", "  boolean allowsSelfLoops = true;\n", "  Comparator<N> nodeComparator = null;\n", "  Comparator<E> edgeComparator = null;\n", "  Optional<Integer> expectedNodeCount = Optional.absent();\n", "  Optional<Integer> expectedEdgeCount = Optional.absent();\n", "\n", "  /**\n", "   * Creates a new instance with the specified edge directionality.\n", "   *\n", "   * @param directed if true, creates an instance for graphs whose edges are each directed;\n", "   *      if false, creates an instance for graphs whose edges are each undirected.\n", "   */\n", "  private NetworkBuilder(boolean directed) {\n", "    this.directed = directed;\n", "  }\n", "\n", "  /**\n", "   * Returns a {@link NetworkBuilder} for building directed graphs.\n", "   */\n", "  public static NetworkBuilder<Object, Object> directed() {\n", "    return new NetworkBuilder<Object, Object>(true);\n", "  }\n", "\n", "  /**\n", "   * Returns a {@link NetworkBuilder} for building undirected graphs.\n", "   */\n", "  public static NetworkBuilder<Object, Object> undirected() {\n", "    return new NetworkBuilder<Object, Object>(false);\n", "  }\n", "\n", "  /**\n", "   * Returns a {@link NetworkBuilder} initialized with all properties queryable from {@code graph}.\n", "   *\n", "   * <p>The \"queryable\" properties are those that are exposed through the {@link Network} interface,\n", "   * such as {@link Network#isDirected()}. Other properties, such as\n", "   * {@link #expectedNodeCount(int)}, are not set in the new builder.\n", "   */\n", "  public static <N, E> NetworkBuilder<N, E> from(Network<N, E> graph) {\n", "    return new NetworkBuilder<N, E>(graph.isDirected())\n", "        .allowsParallelEdges(graph.allowsParallelEdges())\n", "        .allowsSelfLoops(graph.allowsSelfLoops());\n", "  }\n", "\n", "  /**\n", "   * Specifies whether the graph will allow parallel edges. Attempting to add a parallel edge to\n", "   * a graph that does not allow them will throw an {@link UnsupportedOperationException}.\n", "   */\n", "  public NetworkBuilder<N, E> allowsParallelEdges(boolean allowsParallelEdges) {\n", "    this.allowsParallelEdges = allowsParallelEdges;\n", "    return this;\n", "  }\n", "\n", "  /**\n", "   * Specifies whether the graph will allow self-loops (edges that connect a node to itself).\n", "   * Attempting to add a self-loop to a graph that does not allow them will throw an\n", "   * {@link UnsupportedOperationException}.\n", "   */\n", "  public NetworkBuilder<N, E> allowsSelfLoops(boolean allowsSelfLoops) {\n", "    this.allowsSelfLoops = allowsSelfLoops;\n", "    return this;\n", "  }\n", "\n", "  /**\n", "   * Specifies the expected number of nodes in the graph.\n", "   *\n", "   * @throws IllegalArgumentException if {@code expectedNodeCount} is negative\n", "   */\n", "  public NetworkBuilder<N, E> expectedNodeCount(int expectedNodeCount) {\n", "    checkArgument(expectedNodeCount >= 0, \"The expected number of nodes can't be negative: %s\",\n", "        expectedNodeCount);\n", "    this.expectedNodeCount = Optional.of(expectedNodeCount);\n", "    return this;\n", "  }\n", "\n", "  /**\n", "   * Specifies the expected number of edges in the graph.\n", "   *\n", "   * @throws IllegalArgumentException if {@code expectedEdgeCount} is negative\n", "   */\n", "  public NetworkBuilder<N, E> expectedEdgeCount(int expectedEdgeCount) {\n", "    checkArgument(expectedEdgeCount >= 0, \"The expected number of edges can't be negative: %s\",\n", "        expectedEdgeCount);\n", "    this.expectedEdgeCount = Optional.of(expectedEdgeCount);\n", "    return this;\n", "  }\n", "\n", "  /**\n", "   * Returns an empty mutable {@link Network} with the properties of this {@link NetworkBuilder}.\n", "   */\n", "  public <N1 extends N, E1 extends E> MutableNetwork<N1, E1> build() {\n", "    return new ConfigurableNetwork<N1, E1>(this);\n", "  }\n", "}\n"]}, "removed": {}, "added_lines": {"1": [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 58, 59, 60, 61, 62, 63, 64, 65, 66, 67, 68, 69, 70, 71, 72, 73, 74, 75, 76, 77, 78, 79, 80, 81, 82, 83, 84, 85, 86, 87, 88, 89, 90, 91, 92, 93, 94, 95, 96, 97, 98, 99, 100, 101, 102, 103, 104, 105, 106, 107, 108, 109, 110, 111, 112, 113, 114, 115, 116, 117, 118, 119, 120, 121, 122, 123, 124, 125, 126, 127, 128, 129, 130, 131, 132, 133, 134, 135, 136]}, "removed_lines": {}}, {"44": "guava/src/com/google/common/graph/NodeAdjacencies.java", "added": {"1": ["/*\n", " * Copyright (C) 2016 The Guava Authors\n", " *\n", " * Licensed under the Apache License, Version 2.0 (the \"License\");\n", " * you may not use this file except in compliance with the License.\n", " * You may obtain a copy of the License at\n", " *\n", " * http://www.apache.org/licenses/LICENSE-2.0\n", " *\n", " * Unless required by applicable law or agreed to in writing, software\n", " * distributed under the License is distributed on an \"AS IS\" BASIS,\n", " * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n", " * See the License for the specific language governing permissions and\n", " * limitations under the License.\n", " */\n", "\n", "package com.google.common.graph;\n", "\n", "import com.google.errorprone.annotations.CanIgnoreReturnValue;\n", "\n", "import java.util.Set;\n", "/**\n", " * An interface for representing an origin node's adjacent nodes in a network.\n", " *\n", " * @author James Sexton\n", " * @param <N> Node parameter type\n", " */\n", "interface NodeAdjacencies<N> {\n", "\n", "  Set<N> adjacentNodes();\n", "\n", "  Set<N> predecessors();\n", "\n", "  Set<N> successors();\n", "\n", "  /**\n", "   * Remove {@code node} from the set of predecessors.\n", "   *\n", "   * @return true iff the adjacency relationships changed\n", "   */\n", "  @CanIgnoreReturnValue\n", "  boolean removePredecessor(Object node);\n", "\n", "  /**\n", "   * Remove {@code node} from the set of successors.\n", "   *\n", "   * @return true iff the adjacency relationships changed\n", "   */\n", "  @CanIgnoreReturnValue\n", "  boolean removeSuccessor(Object node);\n", "\n", "  /**\n", "   * Add {@code node} as a predecessor to the origin node.\n", "   * In the case of an undirected graph, it also becomes a successor.\n", "   *\n", "   * @return true iff the adjacency relationships changed\n", "   */\n", "  @CanIgnoreReturnValue\n", "  boolean addPredecessor(N node);\n", "\n", "  /**\n", "   * Add {@code node} as a successor to the origin node.\n", "   * In the case of an undirected graph, it also becomes a predecessor.\n", "   *\n", "   * @return true iff the adjacency relationships changed\n", "   */\n", "  @CanIgnoreReturnValue\n", "  boolean addSuccessor(N node);\n", "}\n"]}, "removed": {}, "added_lines": {"1": [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 58, 59, 60, 61, 62, 63, 64, 65, 66, 67, 68, 69]}, "removed_lines": {}}, {"45": "guava/src/com/google/common/graph/NodeConnections.java", "added": {"1": [" * An interface for representing an origin node's adjacent nodes and incident edges in a network.\n"], "2": ["   * between two (formerly) connected nodes, {@link #removePredecessor} must also be called.\n", "   * between two (formerly) connected nodes, {@link #removeSuccessor} must also be called.\n"]}, "removed": {"1": [" * An interface for representing an origin node's adjacent nodes and incident edges in a graph.\n"], "2": ["   * between two (formally) connected nodes, {@link #removePredecessor} must also be called.\n", "   * between two (formally) connected nodes, {@link #removeSuccessor} must also be called.\n"]}, "added_lines": {"1": [22], "2": [44, 50]}, "removed_lines": {"1": [22], "2": [44, 50]}}, {"46": "guava/src/com/google/common/graph/UndirectedNodeAdjacencies.java", "added": {"1": ["/*\n", " * Copyright (C) 2016 The Guava Authors\n", " *\n", " * Licensed under the Apache License, Version 2.0 (the \"License\");\n", " * you may not use this file except in compliance with the License.\n", " * You may obtain a copy of the License at\n", " *\n", " * http://www.apache.org/licenses/LICENSE-2.0\n", " *\n", " * Unless required by applicable law or agreed to in writing, software\n", " * distributed under the License is distributed on an \"AS IS\" BASIS,\n", " * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n", " * See the License for the specific language governing permissions and\n", " * limitations under the License.\n", " */\n", "\n", "package com.google.common.graph;\n", "\n", "import static com.google.common.base.Preconditions.checkNotNull;\n", "\n", "import com.google.common.base.MoreObjects;\n", "import com.google.common.base.Objects;\n", "import com.google.common.collect.ImmutableSet;\n", "import com.google.common.collect.Sets;\n", "\n", "import java.util.Collections;\n", "import java.util.Set;\n", "\n", "import javax.annotation.Nullable;\n", "\n", "/**\n", " * A class representing an origin node's adjacent nodes in an undirected graph.\n", " *\n", " * @author James Sexton\n", " * @param <N> Node parameter type\n", " */\n", "final class UndirectedNodeAdjacencies<N> implements NodeAdjacencies<N> {\n", "  private final Set<N> adjacentNodes;\n", "\n", "  private UndirectedNodeAdjacencies(Set<N> adjacentNodes) {\n", "    this.adjacentNodes = checkNotNull(adjacentNodes, \"adjacentNodes\");\n", "  }\n", "\n", "  static <N> UndirectedNodeAdjacencies<N> of() {\n", "    // TODO(user): Enable users to specify the expected number of neighbors of a new node.\n", "    return new UndirectedNodeAdjacencies<N>(Sets.<N>newHashSet());\n", "  }\n", "\n", "  static <N> UndirectedNodeAdjacencies<N> ofImmutable(Set<N> adjacentNodes) {\n", "    return new UndirectedNodeAdjacencies<N>(ImmutableSet.copyOf(adjacentNodes));\n", "  }\n", "\n", "  @Override\n", "  public Set<N> adjacentNodes() {\n", "    return Collections.unmodifiableSet(adjacentNodes);\n", "  }\n", "\n", "  @Override\n", "  public Set<N> predecessors() {\n", "    return adjacentNodes();\n", "  }\n", "\n", "  @Override\n", "  public Set<N> successors() {\n", "    return adjacentNodes();\n", "  }\n", "\n", "  @Override\n", "  public boolean removePredecessor(Object node) {\n", "    return removeSuccessor(node);\n", "  }\n", "\n", "  @Override\n", "  public boolean removeSuccessor(Object node) {\n", "    checkNotNull(node, \"node\");\n", "    return adjacentNodes.remove(node);\n", "  }\n", "\n", "  @Override\n", "  public boolean addPredecessor(N node) {\n", "    return addSuccessor(node);\n", "  }\n", "\n", "  @Override\n", "  public boolean addSuccessor(N node) {\n", "    checkNotNull(node, \"node\");\n", "    return adjacentNodes.add(node);\n", "  }\n", "\n", "  @Override\n", "  public int hashCode() {\n", "    return Objects.hashCode(adjacentNodes);\n", "  }\n", "\n", "  @Override\n", "  public boolean equals(@Nullable Object object) {\n", "    if (object instanceof UndirectedNodeAdjacencies) {\n", "      UndirectedNodeAdjacencies<?> that = (UndirectedNodeAdjacencies<?>) object;\n", "      return this.adjacentNodes.equals(that.adjacentNodes);\n", "    }\n", "    return false;\n", "  }\n", "\n", "  @Override\n", "  public String toString() {\n", "    return MoreObjects.toStringHelper(this)\n", "        .add(\"adjacentNodes\", adjacentNodes)\n", "        .toString();\n", "  }\n", "}\n"]}, "removed": {}, "added_lines": {"1": [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 58, 59, 60, 61, 62, 63, 64, 65, 66, 67, 68, 69, 70, 71, 72, 73, 74, 75, 76, 77, 78, 79, 80, 81, 82, 83, 84, 85, 86, 87, 88, 89, 90, 91, 92, 93, 94, 95, 96, 97, 98, 99, 100, 101, 102, 103, 104, 105, 106, 107, 108, 109, 110]}, "removed_lines": {}}, {"47": "guava/src/com/google/common/graph/UndirectedNodeConnections.java", "added": {"1": [" * A class representing an origin node's adjacent nodes and incident edges in an undirected network.\n"]}, "removed": {"1": [" * A class representing an origin node's adjacent nodes and incident edges in an undirected graph.\n"]}, "added_lines": {"1": [32]}, "removed_lines": {"1": [32]}}]}
