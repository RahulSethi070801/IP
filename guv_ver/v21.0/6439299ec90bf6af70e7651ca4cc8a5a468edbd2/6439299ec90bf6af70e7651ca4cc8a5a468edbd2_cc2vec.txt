{"id": "6439299ec90bf6af70e7651ca4cc8a5a468edbd2", "code": [{"0": "guava-tests/test/com/google/common/graph/GraphsTest.java", "added": {}, "removed": {"1": ["import static com.google.common.graph.Graphs.addEdge;\n"], "2": ["  @Test\n", "  public void addEdge_mismatchedDirectedness() {\n", "    try {\n", "      addEdge(NetworkBuilder.undirected().<Integer, String>build(), E12,\n", "          Endpoints.ofDirected(N1, N2));\n", "      fail(\"Should have rejected adding an edge with directed endpoints to a undirected graph.\");\n", "    } catch (IllegalArgumentException expected) {\n", "    }\n", "  }\n", "\n", "  @Test\n", "  public void addEdge_selfLoop() {\n", "    MutableNetwork<Integer, String> undirectedGraph = NetworkBuilder.undirected().build();\n", "    assertThat(addEdge(undirectedGraph, E11, Endpoints.ofUndirected(N1, N1))).isTrue();\n", "    assertThat(undirectedGraph.edgesConnecting(N1, N1)).containsExactly(E11);\n", "  }\n", "\n", "  @Test\n", "  public void addEdge_basic() {\n", "    MutableNetwork<Integer, String> directedGraph = NetworkBuilder.directed().build();\n", "    assertThat(addEdge(directedGraph, E12, Endpoints.ofDirected(N1, N2))).isTrue();\n", "    assertThat(directedGraph.edgesConnecting(N1, N2)).containsExactly(E12);\n", "    assertThat(directedGraph.edgesConnecting(N2, N1)).isEmpty();\n", "  }\n", "\n"]}, "added_lines": {}, "removed_lines": {"1": [20], "2": [148, 149, 150, 151, 152, 153, 154, 155, 156, 157, 158, 159, 160, 161, 162, 163, 164, 165, 166, 167, 168, 169, 170, 171, 172]}}, {"1": "guava/src/com/google/common/graph/AbstractConfigurableNetwork.java", "added": {"1": ["    return Endpoints.of(this, nodeA, nodeB);\n"]}, "removed": {"1": ["    return Endpoints.of(nodeA, nodeB, isDirected);\n"]}, "added_lines": {"1": [194]}, "removed_lines": {"1": [194]}}, {"2": "guava/src/com/google/common/graph/ConfigurableMutableNetwork.java", "added": {"1": ["      Endpoints<N> newEndpoints = Endpoints.of(this, nodeA, nodeB);\n"]}, "removed": {"1": ["      Endpoints<N> newEndpoints = Endpoints.of(nodeA, nodeB, isDirected());\n"]}, "added_lines": {"1": [95]}, "removed_lines": {"1": [95]}}, {"3": "guava/src/com/google/common/graph/Endpoints.java", "added": {"1": [" * <p>The {@link Endpoints} of a directed edge are an ordered pair of nodes (source and target).\n", " * The {@link Endpoints} of an undirected edge are an unordered pair of nodes. The nodes can be\n", " * accessed through the {@link #iterator()}, and in the directed case, will iterate in the order\n", " * {@link #source()}, {@link #target()}.\n"], "2": ["  /**\n", "   * Returns {@link Endpoints} representing the endpoints of an edge in {@code graph}.\n", "   */\n", "  public static <N> Endpoints<N> of(Graph<?> graph, N nodeA, N nodeB) {\n", "    return graph.isDirected() ? ofDirected(nodeA, nodeB) : ofUndirected(nodeA, nodeB);\n", "   * Returns {@link Endpoints} representing the endpoints of a directed edge.\n", "   * Returns {@link Endpoints} representing the endpoints of an undirected edge.\n", "   * If these are the {@link Endpoints} of a directed edge, returns the node which is the source of\n", "   * that edge.\n", "   * @throws UnsupportedOperationException if these are the {@link Endpoints} of a undirected edge\n", "   * If these are the {@link Endpoints} of a directed edge, returns the node which is the target of\n", "   * that edge.\n", "   * @throws UnsupportedOperationException if these are the {@link Endpoints} of a undirected edge\n", "   * If these are the {@link Endpoints} of a directed edge, returns the {@link #source()};\n"], "3": ["   * If these are the {@link Endpoints} of a directed edge, it is equal to the {@link #target()}.\n"], "4": ["   * The {@link Endpoints} of two directed edges are equal if their {@link #source()} and\n", "   * {@link #target()} are equal. The {@link Endpoints} of two undirected edges are equal if they\n", "   * contain the same nodes. The {@link Endpoints} of a directed edge are never equal to the\n", "   * {@link Endpoints} of an undirected edge.\n"], "5": ["  /**\n", "   * The {@link Endpoints} of a directed edge. It is guaranteed that all {@link Endpoints} of\n", "   * directed edges will be an instance of this class.\n", "   */\n", "  static final class Directed<N> extends Endpoints<N> {\n"], "6": ["  /**\n", "   * The {@link Endpoints} of an undirected edge. It is guaranteed that all {@link Endpoints} of\n", "   * undirected edges will be an instance of this class.\n", "   */\n", "  static final class Undirected<N> extends Endpoints<N> {\n"]}, "removed": {"1": [" * <p>If an {@link Endpoints} is directed, it is an ordered pair of nodes (source and target).\n", " * Otherwise, it is an unordered pair of nodes that can be accessed through the iterator.\n"], "2": ["  static <N> Endpoints<N> of(N nodeA, N nodeB, boolean isDirected) {\n", "    return isDirected ? ofDirected(nodeA, nodeB) : ofUndirected(nodeA, nodeB);\n", "   * Returns an {@link Endpoints} representing the endpoints of a directed edge.\n", "   * Returns an {@link Endpoints} representing the endpoints of an undirected edge.\n", "   * Returns whether the nodes of this {@link Endpoints} are ordered. Generally, this is equal to\n", "   * {@link Graph#isDirected()} of the graph that generated this {@link Endpoints}.\n", "   */\n", "  public abstract boolean isDirected();\n", "\n", "  /**\n", "   * If this {@link Endpoints} is directed, returns the node which is the source of the origin edge.\n", "   * @throws UnsupportedOperationException if this Endpoints is not directed\n", "   * If this {@link Endpoints} is directed, returns the node which is the target of the origin edge.\n", "   * @throws UnsupportedOperationException if this Endpoints is not directed\n", "   * If this {@link Endpoints} is directed, returns the {@link #source()};\n"], "3": ["   * If this {@link Endpoints} is directed, this is equal to the {@link #target()}.\n"], "4": ["   * If two {@link Endpoints}s are directed, the source and target must be equal to be considered\n", "   * equal. If two {@link Endpoints}s are undirected, the unordered set of nodes must be equal to be\n", "   * considered equal. Directed {@link Endpoints} are never equal to undirected {@link Endpoints}.\n"], "5": ["  private static final class Directed<N> extends Endpoints<N> {\n", "    @Override\n", "    public boolean isDirected() {\n", "      return true;\n", "    }\n", "\n"], "6": ["  private static final class Undirected<N> extends Endpoints<N> {\n", "    @Override\n", "    public boolean isDirected() {\n", "      return false;\n", "    }\n", "\n"]}, "added_lines": {"1": [34, 35, 36, 37], "2": [52, 53, 54, 55, 56, 60, 67, 74, 75, 77, 82, 83, 85, 90], "3": [99], "4": [158, 159, 160, 161], "5": [169, 170, 171, 172, 173], "6": [212, 213, 214, 215, 216]}, "removed_lines": {"1": [34, 35], "2": [50, 51, 55, 62, 69, 70, 71, 72, 73, 74, 75, 77, 82, 84, 89], "3": [98], "4": [157, 158, 159], "5": [167, 172, 173, 174, 175, 176], "6": [211, 216, 217, 218, 219, 220]}}, {"4": "guava/src/com/google/common/graph/GraphConstants.java", "added": {"1": ["      \"Cannot call source()/target() on the endpoints of an undirected edge. Consider calling \"\n", "          + \"otherNode() to get a single node or using the endpoints' iterator to get both nodes.\";\n"]}, "removed": {"1": ["      \"Cannot call source()/target() on undirected endpoints. Consider calling otherNode() to get \"\n", "          + \"a single node or using the endpoints' iterator to get both nodes.\";\n", "  static final String ENDPOINTS_GRAPH_DIRECTEDNESS =\n", "      \"The endpoints' directedness (isDirected = %s) does not match the graph's directedness \"\n", "          + \"(isDirected = %s). A graph cannot have both directed and undirected edges.\";\n"]}, "added_lines": {"1": [53, 54]}, "removed_lines": {"1": [53, 54, 55, 56, 57]}}, {"5": "guava/src/com/google/common/graph/Graphs.java", "added": {"3": ["    return graph.isDirected() == (endpoints instanceof Endpoints.Directed)\n"], "5": ["      Endpoints<N> endpoints = graph.incidentNodes(edge);\n", "      checkState(copy.addEdge(edge, endpoints.nodeA(), endpoints.nodeB()));\n"]}, "removed": {"1": ["import static com.google.common.graph.GraphConstants.ENDPOINTS_GRAPH_DIRECTEDNESS;\n"], "2": ["import com.google.errorprone.annotations.CanIgnoreReturnValue;\n"], "3": ["    return graph.isDirected() == endpoints.isDirected()\n"], "4": ["  /**\n", "   * Adds {@code edge} to {@code graph} with the specified {@code endpoints}.\n", "   */\n", "  @CanIgnoreReturnValue\n", "  public static <N, E> boolean addEdge(MutableNetwork<N, E> graph, E edge, Endpoints<N> endpoints) {\n", "    checkNotNull(graph, \"graph\");\n", "    checkNotNull(edge, \"edge\");\n", "    checkNotNull(endpoints, \"endpoints\");\n", "    checkArgument(endpoints.isDirected() == graph.isDirected(),\n", "        ENDPOINTS_GRAPH_DIRECTEDNESS, endpoints.isDirected(), graph.isDirected());\n", "    return graph.addEdge(edge, endpoints.nodeA(), endpoints.nodeB());\n", "  }\n", "\n"], "5": ["      checkState(addEdge(copy, edge, graph.incidentNodes(edge)));\n"]}, "added_lines": {"3": [132], "5": [219, 220]}, "removed_lines": {"1": [22], "2": [34], "3": [134], "4": [156, 157, 158, 159, 160, 161, 162, 163, 164, 165, 166, 167, 168], "5": [234]}}]}
