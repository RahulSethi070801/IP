{"id": "8b0ec570c69b969b47262eff5935ddc7a80ced50", "code": [{"0": "guava-tests/test/com/google/common/graph/GraphsTest.java", "added": {"1": ["import static com.google.common.graph.Graphs.selfLoopPredicate;\n", "import com.google.common.base.Predicates;\n"], "2": ["    Predicate<String> edgePredicate = Predicates.not(selfLoopPredicate(undirectedGraph));\n"], "3": ["    Predicate<String> edgePredicate = Predicates.not(selfLoopPredicate(directedGraph));\n"], "4": ["    Predicate<String> edgePredicate = Predicates.not(selfLoopPredicate(directedGraph));\n"], "5": ["    Predicate<String> edgePredicate = Predicates.not(selfLoopPredicate(undirectedGraph));\n"]}, "removed": {"1": ["import static com.google.common.graph.Graphs.noSelfLoopPredicate;\n"], "2": ["    Predicate<String> edgePredicate = noSelfLoopPredicate(undirectedGraph);\n"], "3": ["    Predicate<String> edgePredicate = noSelfLoopPredicate(directedGraph);\n"], "4": ["    Predicate<String> edgePredicate = noSelfLoopPredicate(directedGraph);\n"], "5": ["    Predicate<String> edgePredicate = noSelfLoopPredicate(undirectedGraph);\n"]}, "added_lines": {"1": [26, 31], "2": [336], "3": [354], "4": [431], "5": [519]}, "removed_lines": {"1": [26], "2": [335], "3": [353], "4": [430], "5": [518]}}, {"1": "guava-tests/test/com/google/common/graph/PackageSanityTests.java", "added": {"1": ["import static com.google.common.truth.Truth.assertThat;\n", "\n", "import junit.framework.AssertionFailedError;\n", "\n"], "2": ["\n", "  @Override\n", "  public void testNulls() throws Exception {\n", "    try {\n", "      super.testNulls();\n", "    } catch (AssertionFailedError e) {\n", "      assertThat(e.getCause().getMessage()).contains(AbstractGraphTest.ERROR_ELEMENT_NOT_IN_GRAPH);\n", "    }\n", "  }\n"]}, "removed": {}, "added_lines": {"1": [19, 20, 23, 24], "2": [60, 61, 62, 63, 64, 65, 66, 67, 68]}, "removed_lines": {}}, {"2": "guava/src/com/google/common/graph/AbstractImmutableGraph.java", "added": {"1": ["     * @see Graph#addEdge\n"]}, "removed": {"1": ["     * @see Graph#addEdge(E, N, N)\n"]}, "added_lines": {"1": [76]}, "removed_lines": {"1": [76]}}, {"3": "guava/src/com/google/common/graph/DirectedIncidentEdges.java", "added": {}, "removed": {"1": ["/*\n", " * Copyright (C) 2014 The Guava Authors\n", " *\n", " * Licensed under the Apache License, Version 2.0 (the \"License\");\n", " * you may not use this file except in compliance with the License.\n", " * You may obtain a copy of the License at\n", " *\n", " * http://www.apache.org/licenses/LICENSE-2.0\n", " *\n", " * Unless required by applicable law or agreed to in writing, software\n", " * distributed under the License is distributed on an \"AS IS\" BASIS,\n", " * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n", " * See the License for the specific language governing permissions and\n", " * limitations under the License.\n", " */\n", "\n", "package com.google.common.graph;\n", "\n", "import static com.google.common.base.Preconditions.checkNotNull;\n", "\n", "import com.google.common.base.MoreObjects;\n", "import com.google.common.base.Objects;\n", "import com.google.common.collect.ImmutableSet;\n", "\n", "import java.util.LinkedHashSet;\n", "import java.util.Set;\n", "\n", "import javax.annotation.Nullable;\n", "\n", "/**\n", " * A class representing the edges incident to a node in a directed graph.\n", " *\n", " * @author Joshua O'Madadhain\n", " * @param <E> Edge parameter type\n", " */\n", "final class DirectedIncidentEdges<E> {\n", "\n", "  private final Set<E> inEdges;\n", "  private final Set<E> outEdges;\n", "\n", "  private DirectedIncidentEdges(Set<E> inEdges, Set<E> outEdges) {\n", "    this.inEdges = checkNotNull(inEdges, \"inEdges\");\n", "    this.outEdges = checkNotNull(outEdges, \"outEdges\");\n", "  }\n", "\n", "  static <E> DirectedIncidentEdges<E> of() {\n", "    return new DirectedIncidentEdges<E>(new LinkedHashSet<E>(), new LinkedHashSet<E>());\n", "  }\n", "\n", "  static <E> DirectedIncidentEdges<E> ofImmutable(Set<E> inEdges, Set<E> outEdges) {\n", "    return new DirectedIncidentEdges<E>(ImmutableSet.copyOf(inEdges),\n", "        ImmutableSet.copyOf(outEdges));\n", "  }\n", "\n", "  Set<E> inEdges() {\n", "    return inEdges;\n", "  }\n", "\n", "  Set<E> outEdges() {\n", "    return outEdges;\n", "  }\n", "\n", "  @Override\n", "  public int hashCode() {\n", "    return Objects.hashCode(inEdges, outEdges);\n", "  }\n", "\n", "  @Override\n", "  public boolean equals(@Nullable Object object) {\n", "    if (object instanceof DirectedIncidentEdges) {\n", "      DirectedIncidentEdges<?> that = (DirectedIncidentEdges<?>) object;\n", "      return this.inEdges.equals(that.inEdges)\n", "          && this.outEdges.equals(that.outEdges);\n", "    }\n", "    return false;\n", "  }\n", "\n", "  @Override\n", "  public String toString() {\n", "    return MoreObjects.toStringHelper(this)\n", "        .add(\"inEdges\", inEdges)\n", "        .add(\"outEdges\", outEdges)\n", "        .toString();\n", "  }\n", "}\n"]}, "added_lines": {}, "removed_lines": {"1": [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 58, 59, 60, 61, 62, 63, 64, 65, 66, 67, 68, 69, 70, 71, 72, 73, 74, 75, 76, 77, 78, 79, 80, 81, 82, 83, 84, 85]}}, {"4": "guava/src/com/google/common/graph/DirectedNodeConnections.java", "added": {"1": ["/*\n", " * Copyright (C) 2016 The Guava Authors\n", " *\n", " * Licensed under the Apache License, Version 2.0 (the \"License\");\n", " * you may not use this file except in compliance with the License.\n", " * You may obtain a copy of the License at\n", " *\n", " * http://www.apache.org/licenses/LICENSE-2.0\n", " *\n", " * Unless required by applicable law or agreed to in writing, software\n", " * distributed under the License is distributed on an \"AS IS\" BASIS,\n", " * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n", " * See the License for the specific language governing permissions and\n", " * limitations under the License.\n", " */\n", "\n", "package com.google.common.graph;\n", "\n", "import static com.google.common.base.Preconditions.checkNotNull;\n", "\n", "import com.google.common.base.MoreObjects;\n", "import com.google.common.base.Objects;\n", "import com.google.common.collect.ImmutableSet;\n", "import com.google.common.collect.Sets;\n", "\n", "import java.util.Collections;\n", "import java.util.Set;\n", "\n", "import javax.annotation.Nullable;\n", "\n", "/**\n", " * A class representing an origin node's adjacent nodes and incident edges in a directed graph.\n", " *\n", " * @author James Sexton\n", " * @param <N> Node parameter type\n", " * @param <E> Edge parameter type\n", " */\n", "final class DirectedNodeConnections<N, E> implements NodeConnections<N, E> {\n", "  private final Set<N> predecessors;\n", "  private final Set<N> successors;\n", "  private final Set<E> inEdges;\n", "  private final Set<E> outEdges;\n", "\n", "  private DirectedNodeConnections(Set<N> predecessors, Set<N> successors,\n", "      Set<E> inEdges, Set<E> outEdges) {\n", "    this.predecessors = checkNotNull(predecessors, \"predecessors\");\n", "    this.successors = checkNotNull(successors, \"successors\");\n", "    this.inEdges = checkNotNull(inEdges, \"inEdges\");\n", "    this.outEdges = checkNotNull(outEdges, \"outEdges\");\n", "  }\n", "\n", "  static <N, E> DirectedNodeConnections<N, E> of() {\n", "    // TODO(user): Enable users to specify the expected number of neighbors of a new node.\n", "    return new DirectedNodeConnections<N, E>(\n", "        Sets.<N>newLinkedHashSet(), Sets.<N>newLinkedHashSet(),\n", "        Sets.<E>newLinkedHashSet(), Sets.<E>newLinkedHashSet());\n", "  }\n", "\n", "  static <N, E> DirectedNodeConnections<N, E> ofImmutable(Set<N> predecessors, Set<N> successors,\n", "      Set<E> inEdges, Set<E> outEdges) {\n", "    return new DirectedNodeConnections<N, E>(\n", "        ImmutableSet.copyOf(predecessors), ImmutableSet.copyOf(successors),\n", "        ImmutableSet.copyOf(inEdges), ImmutableSet.copyOf(outEdges));\n", "  }\n", "\n", "  @Override\n", "  public Set<N> adjacentNodes() {\n", "    return Sets.union(predecessors(), successors());\n", "  }\n", "\n", "  @Override\n", "  public Set<N> predecessors() {\n", "    return Collections.unmodifiableSet(predecessors);\n", "  }\n", "\n", "  @Override\n", "  public Set<N> successors() {\n", "    return Collections.unmodifiableSet(successors);\n", "  }\n", "\n", "  @Override\n", "  public Set<E> incidentEdges() {\n", "    return Sets.union(inEdges(), outEdges());\n", "  }\n", "\n", "  @Override\n", "  public Set<E> inEdges() {\n", "    return Collections.unmodifiableSet(inEdges);\n", "  }\n", "\n", "  @Override\n", "  public Set<E> outEdges() {\n", "    return Collections.unmodifiableSet(outEdges);\n", "  }\n", "\n", "  @Override\n", "  public void removeNode(Object node) {\n", "    checkNotNull(node, \"node\");\n", "    predecessors.remove(node);\n", "    successors.remove(node);\n", "  }\n", "\n", "  @Override\n", "  public void removeEdge(Object edge) {\n", "    checkNotNull(edge, \"edge\");\n", "    inEdges.remove(edge);\n", "    outEdges.remove(edge);\n", "  }\n", "\n", "  @Override\n", "  public void addPredecessor(N node, E edge) {\n", "    checkNotNull(node, \"node\");\n", "    checkNotNull(edge, \"edge\");\n", "    predecessors.add(node);\n", "    inEdges.add(edge);\n", "  }\n", "\n", "  @Override\n", "  public void addSuccessor(N node, E edge) {\n", "    checkNotNull(node, \"node\");\n", "    checkNotNull(edge, \"edge\");\n", "    successors.add(node);\n", "    outEdges.add(edge);\n", "  }\n", "\n", "  // For now, hashCode() and equals() are unused by any graph implementation.\n", "  // If needed, there may be room for optimization (e.g. only considering the edges).\n", "  @Override\n", "  public int hashCode() {\n", "    return Objects.hashCode(predecessors, successors, inEdges, outEdges);\n", "  }\n", "\n", "  @Override\n", "  public boolean equals(@Nullable Object object) {\n", "    if (object instanceof DirectedNodeConnections) {\n", "      DirectedNodeConnections<?, ?> that = (DirectedNodeConnections<?, ?>) object;\n", "      return this.predecessors.equals(that.predecessors)\n", "          && this.successors.equals(that.successors)\n", "          && this.inEdges.equals(that.inEdges)\n", "          && this.outEdges.equals(that.outEdges);\n", "    }\n", "    return false;\n", "  }\n", "\n", "  @Override\n", "  public String toString() {\n", "    return MoreObjects.toStringHelper(this)\n", "        .add(\"predecessors\", predecessors)\n", "        .add(\"successors\", successors)\n", "        .add(\"inEdges\", inEdges)\n", "        .add(\"outEdges\", outEdges)\n", "        .toString();\n", "  }\n", "}\n"]}, "removed": {}, "added_lines": {"1": [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 58, 59, 60, 61, 62, 63, 64, 65, 66, 67, 68, 69, 70, 71, 72, 73, 74, 75, 76, 77, 78, 79, 80, 81, 82, 83, 84, 85, 86, 87, 88, 89, 90, 91, 92, 93, 94, 95, 96, 97, 98, 99, 100, 101, 102, 103, 104, 105, 106, 107, 108, 109, 110, 111, 112, 113, 114, 115, 116, 117, 118, 119, 120, 121, 122, 123, 124, 125, 126, 127, 128, 129, 130, 131, 132, 133, 134, 135, 136, 137, 138, 139, 140, 141, 142, 143, 144, 145, 146, 147, 148, 149, 150, 151, 152, 153, 154]}, "removed_lines": {}}, {"5": "guava/src/com/google/common/graph/Graph.java", "added": {"1": ["   * <p>If the graph is directed, the {@linkplain DirectedGraph#source(Object) source} and\n"]}, "removed": {"1": ["   * <p>If the graph is directed, the {@linkplain #source(Object) source} and\n"]}, "added_lines": {"1": [253]}, "removed_lines": {"1": [253]}}, {"6": "guava/src/com/google/common/graph/Graphs.java", "added": {"2": ["   * Returns a {@link Predicate} that returns {@code true} if the input edge is a self-loop in\n", "   * element. The predicate's {@code apply} method will throw an {@link IllegalArgumentException} if\n", "  public static <E> Predicate<E> selfLoopPredicate(final Graph<?, E> graph) {\n", "        return (graph.incidentNodes(edge).size() == 1);\n"]}, "removed": {"1": ["import static com.google.common.base.Preconditions.checkState;\n"], "2": ["   * Returns a {@link Predicate} that returns {@code true} if the input edge is not a self-loop in\n", "   * element. The predicate's {@code apply} method will throw a {@link IllegalStateException} if\n", "  public static <E> Predicate<E> noSelfLoopPredicate(final Graph<?, E> graph) {\n", "        checkState(graph.edges().contains(edge), \"Graph does not contain edge %s\", edge);\n", "        return graph.incidentNodes(edge).size() != 1;\n"]}, "added_lines": {"2": [412, 414, 417, 422]}, "removed_lines": {"1": [21], "2": [413, 415, 418, 423, 424]}}, {"7": "guava/src/com/google/common/graph/ImmutableDirectedGraph.java", "added": {"1": ["import com.google.common.base.Objects;\n"], "2": [" * <p>The time complexity of all {@code Set}-returning accessors is O(1), since we\n", " * are returning views. An exception to this is {@code edgesConnecting(node1, node2)},\n", " * which is O(min(outD_node1, inD_node2)).\n", " * <p>All other accessors have a time complexity of O(1), except for {@code degree(node)},\n", " * whose time complexity is O(outD_node).\n"], "3": ["  private final ImmutableMap<N, NodeConnections<N, E>> nodeConnections;\n", "    ImmutableMap.Builder<N, NodeConnections<N, E>> nodeConnectionsBuilder =\n", "      NodeConnections<N, E> connections = DirectedNodeConnections.ofImmutable(\n", "          directedGraph.predecessors(node), directedGraph.successors(node),\n", "      nodeConnectionsBuilder.put(node, connections);\n", "    this.nodeConnections = nodeConnectionsBuilder.build();\n"], "4": ["    this.edgeToIncidentNodes = edgeToIncidentNodesBuilder.build();\n", "    return nodeConnections.keySet();\n"], "5": ["    return Sets.union(inEdges(node), outEdges(node));\n", "    return checkedEndpoints(edge).asImmutableSet();\n", "    return Sets.union(predecessors(node), successors(node));\n", "    for (N node : incidentNodes(edge)) {\n"], "6": ["   * Returns the intersection of these two sets, using {@link Sets#intersection}:\n", "    Set<E> sourceOutEdges = outEdges(node1); // Verifies that node1 is in graph\n", "    if (!config.isSelfLoopsAllowed() && node1.equals(node2)) {\n", "      return ImmutableSet.of();\n", "    }\n", "    return (sourceOutEdges.size() <= targetInEdges.size())\n", "    return checkedConnections(node).inEdges();\n", "    return checkedConnections(node).outEdges();\n", "    return checkedConnections(node).predecessors();\n", "    return checkedConnections(node).successors();\n", "    return incidentEdges(node).size();\n"], "7": ["    return checkedEndpoints(edge).source();\n", "    return checkedEndpoints(edge).target();\n", "    return (object instanceof DirectedGraph) && Graphs.equal(this, (DirectedGraph<?, ?>) object);\n", "    // The node set is included in the hash to differentiate between graphs with isolated nodes.\n", "    return Objects.hashCode(nodes(), edgeToIncidentNodes);\n", "  }\n", "\n", "  @Override\n", "  public String toString() {\n", "    return String.format(\"config: %s, nodes: %s, edges: %s\",\n", "        config,\n", "        nodes(),\n", "        edgeToIncidentNodes);\n", "  }\n", "\n", "  private NodeConnections<N, E> checkedConnections(Object node) {\n", "    checkNotNull(node, \"node\");\n", "    NodeConnections<N, E> connections = nodeConnections.get(node);\n", "    checkArgument(connections != null, NODE_NOT_IN_GRAPH, node);\n", "    return connections;\n", "  }\n", "\n", "  private DirectedIncidentNodes<N> checkedEndpoints(Object edge) {\n", "    checkNotNull(edge, \"edge\");\n", "    DirectedIncidentNodes<N> endpoints = edgeToIncidentNodes.get(edge);\n", "    checkArgument(endpoints != null, EDGE_NOT_IN_GRAPH, edge);\n", "    return endpoints;\n"]}, "removed": {"2": [" * <p>Most of the {@code Set}-returning accessors return an immutable set which is an internal\n", " * data structure, hence they have a time complexity of O(1). The rest of these accessors build\n", " * and return an immutable set that is <b>derived</b> from the internal data structures, hence\n", " * they have the following time complexities:\n", " * <ul>\n", " * <li>{@code incidentEdges(node)}: O(d_node).\n", " * <li>Methods that ask for adjacent nodes:\n", " *     <ul>\n", " *     <li>{@code adjacentNodes(node)}: O(d_node).\n", " *     <li>{@code predecessors(node)}: O(inD_node).\n", " *     <li>{@code successors(node)}: O(outD_node).\n", " *     </ul>\n", " * <li>{@code adjacentEdges(edge)}: O(d_node1 + d_node2), where node1 and node2 are\n", " *     {@code edge}'s incident nodes.\n", " * <li>{@code edgesConnecting(node1, node2)}: O(min(outD_node1, inD_node2)).\n", " * </ul>\n", " * where d_node is the degree of node, inD_node is the in-degree of node, and outD_node is the\n", " * out-degree of node. The set returned by these methods is <b>not</b> cached, so every time the\n", " * user calls the method, the same set will be reconstructed again.\n", " * <p>All other accessors have a time complexity of O(1), except for\n", " * {@code degree(node)}, whose time complexity is linear in the minimum of\n", " * the out-degree and in-degree of {@code node}. This is due to a call to {@code edgesConnecting}.\n"], "3": ["  private final ImmutableMap<N, DirectedIncidentEdges<E>> nodeToIncidentEdges;\n", "    ImmutableMap.Builder<N, DirectedIncidentEdges<E>> nodeToIncidentEdgesBuilder =\n", "      DirectedIncidentEdges<E> incidentEdges = DirectedIncidentEdges.ofImmutable(\n", "      nodeToIncidentEdgesBuilder.put(node, incidentEdges);\n", "    nodeToIncidentEdges = nodeToIncidentEdgesBuilder.build();\n"], "4": ["    edgeToIncidentNodes = edgeToIncidentNodesBuilder.build();\n", "    return nodeToIncidentEdges.keySet();\n"], "5": ["    return Sets.union(inEdges(node), outEdges(node)).immutableCopy();\n", "    checkNotNull(edge, \"edge\");\n", "    DirectedIncidentNodes<N> endpoints = edgeToIncidentNodes.get(edge);\n", "    checkArgument(endpoints != null, EDGE_NOT_IN_GRAPH, edge);\n", "    return endpoints.asImmutableSet();\n", "    return Sets.union(predecessors(node), successors(node)).immutableCopy();\n", "    checkNotNull(edge, \"edge\");\n", "    DirectedIncidentNodes<N> endpoints = edgeToIncidentNodes.get(edge);\n", "    checkArgument(endpoints != null, EDGE_NOT_IN_GRAPH, edge);\n", "    for (N node : endpoints.asImmutableSet()) {\n"], "6": ["   * Returns the intersection of these two sets, using {@code Sets.intersection}:\n", "   * The first argument passed to {@code Sets.intersection} is the smaller of the two sets.\n", "   *\n", "   * @see Sets#intersection\n", "    checkNotNull(node1, \"node1\");\n", "    checkNotNull(node2, \"node2\");\n", "    Set<E> sourceOutEdges = outEdges(node1);\n", "    return sourceOutEdges.size() <= targetInEdges.size()\n", "    checkNotNull(node, \"node\");\n", "    DirectedIncidentEdges<E> incidentEdges = nodeToIncidentEdges.get(node);\n", "    checkArgument(incidentEdges != null, NODE_NOT_IN_GRAPH, node);\n", "    return incidentEdges.inEdges();\n", "    checkNotNull(node, \"node\");\n", "    DirectedIncidentEdges<E> incidentEdges = nodeToIncidentEdges.get(node);\n", "    checkArgument(incidentEdges != null, NODE_NOT_IN_GRAPH, node);\n", "    return incidentEdges.outEdges();\n", "    ImmutableSet.Builder<N> predecessorsBuilder = ImmutableSet.builder();\n", "    for (E edge : inEdges(node)) {\n", "      predecessorsBuilder.add(source(edge));\n", "    }\n", "    return predecessorsBuilder.build();\n", "    ImmutableSet.Builder<N> successorsBuilder = ImmutableSet.builder();\n", "    for (E edge : outEdges(node)) {\n", "      successorsBuilder.add(target(edge));\n", "    }\n", "    return successorsBuilder.build();\n", "    return inDegree(node) + outDegree(node) - edgesConnecting(node, node).size();\n"], "7": ["    checkNotNull(edge, \"edge\");\n", "    DirectedIncidentNodes<N> endpoints = edgeToIncidentNodes.get(edge);\n", "    checkArgument(endpoints != null, EDGE_NOT_IN_GRAPH, edge);\n", "    return endpoints.source();\n", "    checkNotNull(edge, \"edge\");\n", "    DirectedIncidentNodes<N> endpoints = edgeToIncidentNodes.get(edge);\n", "    checkArgument(endpoints != null, EDGE_NOT_IN_GRAPH, edge);\n", "    return endpoints.target();\n", "    return (object instanceof DirectedGraph) && Graphs.equal(this, (DirectedGraph) object);\n", "    // This map encapsulates all of the structural relationships of this graph, so its hash code\n", "    // is consistent with the above definition of equals().\n", "    return nodeToIncidentEdges.hashCode();\n"], "8": ["  @Override\n", "  public String toString() {\n", "    return String.format(\"config: %s, nodes: %s, edges: %s\",\n", "        config,\n", "        nodeToIncidentEdges.keySet(),\n", "        edgeToIncidentNodes);\n", "  }\n", "\n"]}, "added_lines": {"1": [25], "2": [60, 61, 62, 64, 65], "3": [79, 86, 89, 90, 92, 94], "4": [102, 108], "5": [123, 128, 133, 139], "6": [148, 156, 157, 158, 159, 161, 168, 173, 178, 183, 188], "7": [203, 208, 213, 218, 219, 220, 221, 222, 223, 224, 225, 226, 227, 228, 229, 230, 231, 232, 233, 234, 235, 236, 237, 238, 239, 240, 241]}, "removed_lines": {"2": [59, 60, 61, 62, 63, 64, 65, 66, 67, 68, 69, 70, 71, 72, 73, 74, 75, 76, 77, 79, 80, 81], "3": [95, 102, 105, 107, 109], "4": [117, 123], "5": [138, 143, 144, 145, 146, 151, 156, 157, 158, 160], "6": [169, 174, 175, 176, 180, 181, 182, 184, 191, 192, 193, 194, 199, 200, 201, 202, 207, 208, 209, 210, 211, 216, 217, 218, 219, 220, 225], "7": [240, 241, 242, 243, 248, 249, 250, 251, 256, 261, 262, 263], "8": [292, 293, 294, 295, 296, 297, 298, 299]}}, {"8": "guava/src/com/google/common/graph/ImmutableUndirectedGraph.java", "added": {"1": ["import com.google.common.base.Objects;\n", "import com.google.common.collect.Iterables;\n"], "2": [" * <p>The time complexity of all {@code Set}-returning accessors is O(1), since we\n", " * are returning views. An exception to this is {@code edgesConnecting(node1, node2)},\n", " * which is O(min(d_node1, d_node2)).\n"], "3": ["  private final ImmutableMap<N, NodeConnections<N, E>> nodeConnections;\n", "    ImmutableMap.Builder<N, NodeConnections<N, E>> nodeConnectionsBuilder =\n", "        ImmutableMap.builder();\n", "      nodeConnectionsBuilder.put(node, UndirectedNodeConnections.ofImmutable(\n", "          undirectedGraph.adjacentNodes(node), undirectedGraph.incidentEdges(node)));\n", "    this.nodeConnections = nodeConnectionsBuilder.build();\n", "    this.edgeToIncidentNodes = edgeToNodesBuilder.build();\n", "    this.config = undirectedGraph.config();\n", "    return nodeConnections.keySet();\n"], "4": ["    return checkedConnections(node).incidentEdges();\n"], "5": ["    return checkedConnections(node).adjacentNodes();\n"], "6": ["   * If {@code node1} is equal to {@code node2}, the set of self-loop edges is returned.\n", "   * Otherwise, returns the intersection of these two sets, using {@link Sets#intersection}:\n", "   * <li>Incident edges of {@code node1}.\n", "   * <li>Incident edges of {@code node2}.\n", "      if (!config.isSelfLoopsAllowed()) {\n", "        return ImmutableSet.of();\n", "      return ImmutableSet.copyOf(Iterables.filter(incidentEdgesN1, Graphs.selfLoopPredicate(this)));\n", "    return (incidentEdgesN1.size() <= incidentEdgesN2.size())\n"], "7": ["    return (object instanceof UndirectedGraph)\n", "        && Graphs.equal(this, (UndirectedGraph<?, ?>) object);\n", "    // The node set is included in the hash to differentiate between graphs with isolated nodes.\n", "    return Objects.hashCode(nodes(), edgeToIncidentNodes);\n", "  }\n", "\n", "  @Override\n", "  public String toString() {\n", "    return String.format(\"config: %s, nodes: %s, edges: %s\",\n", "        config,\n", "        nodes(),\n", "        edgeToIncidentNodes);\n", "  }\n", "\n", "  private NodeConnections<N, E> checkedConnections(Object node) {\n", "    checkNotNull(node, \"node\");\n", "    NodeConnections<N, E> connections = nodeConnections.get(node);\n", "    checkArgument(connections != null, NODE_NOT_IN_GRAPH, node);\n", "    return connections;\n"], "9": ["     * @see Graph#addEdge\n"]}, "removed": {"1": ["import static com.google.common.graph.Graphs.oppositeNode;\n"], "2": [" * <p>Most of the {@code Set}-returning accessors return an immutable set which is an internal\n", " * data structure, hence they have a time complexity of O(1). The rest of these accessors build\n", " * and return an immutable set that is <b>derived</b> from the internal data structures, hence\n", " * they have the following time complexities:\n", " * <ul>\n", " * <li>Methods that ask for adjacent nodes (e.g. {@code adjacentNodes}): O(d_node), where\n", " *     node is the node on which the method is called.\n", " * <li>{@code adjacentEdges(edge)}: O(d_node1 + d_node2), where node1 and node2 are {@code edge}'s\n", " *     incident nodes.\n", " * <li>{@code edgesConnecting(node1, node2)}: O(min(d_node1, d_node2)).\n", " * </ul>\n", " * where d_node is the degree of node. The set returned by these methods is <b>not</b> cached,\n", " * so every time the user calls the method, the same set will be reconstructed again.\n"], "3": ["  private final ImmutableMap<N, ImmutableSet<E>> nodeToIncidentEdges;\n", "    ImmutableMap.Builder<N, ImmutableSet<E>> nodeToEdgesBuilder = ImmutableMap.builder();\n", "      nodeToEdgesBuilder.put(node, ImmutableSet.copyOf(undirectedGraph.incidentEdges(node)));\n", "    nodeToIncidentEdges = nodeToEdgesBuilder.build();\n", "    edgeToIncidentNodes = edgeToNodesBuilder.build();\n", "    config = undirectedGraph.config();\n", "    return nodeToIncidentEdges.keySet();\n"], "4": ["    checkNotNull(node, \"node\");\n", "    ImmutableSet<E> incidentEdges = nodeToIncidentEdges.get(node);\n", "    checkArgument(incidentEdges != null, NODE_NOT_IN_GRAPH, node);\n", "    return incidentEdges;\n"], "5": ["    ImmutableSet.Builder<N> adjacentNodesBuilder = ImmutableSet.builder();\n", "    for (E edge : incidentEdges(node)) {\n", "      adjacentNodesBuilder.add(oppositeNode(this, edge, node));\n", "    }\n", "    return adjacentNodesBuilder.build();\n"], "6": ["   * If {@code node1} is equal to {@code node2}, a {@code Set} instance is returned,\n", "   * calculating the set of self-loop edges. Otherwise, this method returns the\n", "   * intersection of these two sets, using {@code Sets.intersection}:\n", "   * <li>{@code node1}'s incident edges.\n", "   * <li>{@code node2}'s incident edges.\n", "   * The first argument passed to {@code Sets.intersection} is the smaller of\n", "   * the two sets.\n", "   *\n", "   * @see Sets#intersection\n", "    checkNotNull(node1, \"node1\");\n", "    checkNotNull(node2, \"node2\");\n", "      Set<E> returnSet = Sets.newLinkedHashSet();\n", "      for (E edge : incidentEdgesN1) {\n", "        if (edgeToIncidentNodes.get(edge).isSelfLoop()) {\n", "          returnSet.add(edge);\n", "        }\n", "      return Collections.unmodifiableSet(returnSet);\n", "    return incidentEdgesN1.size() <= incidentEdgesN2.size()\n"], "7": ["    return (object instanceof UndirectedGraph) && Graphs.equal(this, (UndirectedGraph) object);\n", "    // This map encapsulates all of the structural relationships of this graph, so its hash code\n", "    // is consistent with the above definition of equals().\n", "    return nodeToIncidentEdges.hashCode();\n"], "8": ["  @Override\n", "  public String toString() {\n", "    return String.format(\"config: %s, nodes: %s, edges: %s\",\n", "        config,\n", "        nodeToIncidentEdges.keySet(),\n", "        edgeToIncidentNodes);\n", "  }\n", "\n"], "9": ["     * @see Graph#addEdge(e, n1, n2)\n"]}, "added_lines": {"1": [25, 28], "2": [58, 59, 60], "3": [75, 82, 83, 85, 86, 88, 93, 94, 99], "4": [114], "5": [127], "6": [142, 143, 145, 146, 153, 154, 156, 159], "7": [201, 202, 207, 208, 209, 210, 211, 212, 213, 214, 215, 216, 217, 218, 219, 220, 221, 222, 223], "9": [311]}, "removed_lines": {"1": [23], "2": [57, 58, 59, 60, 61, 62, 63, 64, 65, 66, 67, 68, 69], "3": [84, 91, 93, 95, 100, 101, 106], "4": [121, 122, 123, 124], "5": [137, 138, 139, 140, 141], "6": [156, 157, 158, 160, 161, 163, 164, 165, 166, 170, 171, 174, 175, 176, 177, 178, 180, 183], "7": [225, 230, 231, 232], "8": [261, 262, 263, 264, 265, 266, 267, 268], "9": [328]}}, {"9": "guava/src/com/google/common/graph/IncidenceSetDirectedGraph.java", "added": {"1": ["import com.google.common.base.Objects;\n", "import com.google.common.collect.ImmutableList;\n"], "2": ["import java.util.Iterator;\n"], "3": [" *     Set<N> preds = predecessors(node);\n", " *     graph.removeNode(node);}</pre>\n", " * are returning views.\n", " * <p>All other accessors have a time complexity of O(1), except for {@code degree(node)},\n", " * whose time complexity is O(outD_node).\n", " * <li>{@code addEdge(E edge, N node1, N node2)}: O(1), unless this graph is not a multigraph\n", " *     (does not support parallel edges), then this method is O(min(outD_node1, inD_node2)).\n", " * <li>{@code removeNode(node)}: O(d_node).\n", " * where d_node is the degree of node, inD_node is the in-degree of node, and outD_node is the\n", " * out-degree of node.\n"], "4": ["  // TODO(b/24620028): Enable this class to support sorted nodes/edges.\n", "  private final Map<N, NodeConnections<N, E>> nodeConnections;\n", "    this.nodeConnections =\n"], "5": ["    return Collections.unmodifiableSet(nodeConnections.keySet());\n"], "6": ["    return Sets.union(inEdges(node), outEdges(node));\n", "  public Set<N> incidentNodes(Object edge) {\n", "    return checkedEndpoints(edge).asImmutableSet();\n"], "7": ["    Iterator<N> incidentNodesIterator = incidentNodes(edge).iterator();\n", "    Set<E> endpointsIncidentEdges = incidentEdges(incidentNodesIterator.next());\n", "    while (incidentNodesIterator.hasNext()) {\n", "      endpointsIncidentEdges =\n", "          Sets.union(incidentEdges(incidentNodesIterator.next()), endpointsIncidentEdges);\n", "    }\n", "    return Sets.difference(endpointsIncidentEdges, ImmutableSet.of(edge));\n", "   * Returns the intersection of these two sets, using {@link Sets#intersection}:\n", "    Set<E> sourceOutEdges = outEdges(node1); // Verifies that node1 is in graph\n", "    if (!config.isSelfLoopsAllowed() && node1.equals(node2)) {\n", "      return ImmutableSet.of();\n", "    }\n", "    Set<E> targetInEdges = inEdges(node2);\n", "    return (sourceOutEdges.size() <= targetInEdges.size())\n", "        ? Sets.intersection(sourceOutEdges, targetInEdges)\n", "        : Sets.intersection(targetInEdges, sourceOutEdges);\n", "    return checkedConnections(node).inEdges();\n", "    return checkedConnections(node).outEdges();\n", "    return checkedConnections(node).predecessors();\n", "    return checkedConnections(node).successors();\n", "    return incidentEdges(node).size();\n", "    return inEdges(node).size();\n", "    return outEdges(node).size();\n", "    return checkedEndpoints(edge).source();\n", "    return checkedEndpoints(edge).target();\n"], "8": ["    if (nodes().contains(node)) {\n", "    nodeConnections.put(node, DirectedNodeConnections.<N, E>of());\n"], "9": ["    } else if (!config.isMultigraph() && nodes().contains(node1) && nodes().contains(node2)) {\n", "    NodeConnections<N, E> connectionsN1 = nodeConnections.get(node1);\n", "    connectionsN1.addSuccessor(node2, edge);\n", "    NodeConnections<N, E> connectionsN2 = nodeConnections.get(node2);\n", "    connectionsN2.addPredecessor(node1, edge);\n"], "10": ["    NodeConnections<N, E> connections = nodeConnections.get(node);\n", "    if (connections == null) {\n", "    // Since views are returned, we need to copy the nodes and edges that will be removed.\n", "    // Thus we avoid modifying the underlying views while iterating over them.\n", "    for (E edge : ImmutableList.copyOf(incidentEdges(node))) {\n", "    for (N adjacentNode : ImmutableList.copyOf(connections.adjacentNodes())) {\n", "      nodeConnections.get(adjacentNode).removeNode(node);\n", "    }\n", "    nodeConnections.remove(node);\n"], "11": ["    nodeConnections.get(endpoints.source()).removeEdge(edge);\n", "    nodeConnections.get(endpoints.target()).removeEdge(edge);\n", "    return (other instanceof DirectedGraph) && Graphs.equal(this, (DirectedGraph<?, ?>) other);\n", "    // The node set is included in the hash to differentiate between graphs with isolated nodes.\n", "    return Objects.hashCode(nodes(), edgeToIncidentNodes);\n", "        nodes(),\n", "  private NodeConnections<N, E> checkedConnections(Object node) {\n", "    checkNotNull(node, \"node\");\n", "    NodeConnections<N, E> connections = nodeConnections.get(node);\n", "    checkArgument(connections != null, NODE_NOT_IN_GRAPH, node);\n", "    return connections;\n", "  }\n", "\n", "  private DirectedIncidentNodes<N> checkedEndpoints(Object edge) {\n", "    checkNotNull(edge, \"edge\");\n", "    DirectedIncidentNodes<N> endpoints = edgeToIncidentNodes.get(edge);\n", "    checkArgument(endpoints != null, EDGE_NOT_IN_GRAPH, edge);\n", "    return endpoints;\n"]}, "removed": {"3": [" *     Set<N> preds = predecessors(n);\n", " *     graph.removeNode(n);}</pre>\n", " * are returning views. It should be noted that for the following methods:\n", " * <ul>\n", " * <li>{@code incidentEdges}.\n", " * <li>Methods that ask for adjacent nodes (e.g. {@code predecessors}).\n", " * <li>{@code adjacentEdges}.\n", " * <li>{@code edgesConnecting}.\n", " * </ul>\n", " * the view is calculated lazily and the backing set is <b>not</b> cached, so every time the user\n", " * accesses the returned view, the backing set will be reconstructed again. If the user wants\n", " * to avoid this, they should either use {@code ImmutableDirectedGraph}\n", " * (if their input is not changing) or make a copy of the return value.\n", " * <p>All other accessors have a time complexity of O(1), except for\n", " * {@code degree(n)}, whose time complexity is linear in the minimum of\n", " * the out-degree and in-degree of {@code n}, in case of allowing self-loop edges.\n", " * This is due to a call to {@code edgesConnecting}.\n", " * <li>{@code addEdge(E e, N n1, N n2)}: O(1), unless this graph is not a multigraph\n", " * (does not support parallel edges). In such case, this method may call\n", " * {@code edgesConnecting(n1, n2)}.\n", " * <li>{@code removeNode(n)}: O(d), where d is the degree of the node {@code n}.\n"], "4": [" // TODO(b/24620028): Enable this class to support sorted nodes/edges.\n", "  private final Map<N, DirectedIncidentEdges<E>> nodeToIncidentEdges;\n", "    this.nodeToIncidentEdges =\n"], "5": ["    return Collections.unmodifiableSet(nodeToIncidentEdges.keySet());\n"], "6": ["    checkNotNull(node, \"node\");\n", "    DirectedIncidentEdges<E> incidentEdges = nodeToIncidentEdges.get(node);\n", "    checkArgument(incidentEdges != null, NODE_NOT_IN_GRAPH, node);\n", "    return Sets.union(incidentEdges.inEdges(), incidentEdges.outEdges());\n", "  public Set<N> incidentNodes(final Object edge) {\n", "    checkNotNull(edge, \"edge\");\n", "    DirectedIncidentNodes<N> endpoints = edgeToIncidentNodes.get(edge);\n", "    checkArgument(endpoints != null, EDGE_NOT_IN_GRAPH, edge);\n", "    return endpoints.asImmutableSet();\n"], "7": ["    checkNotNull(edge, \"edge\");\n", "    DirectedIncidentNodes<N> endpoints = edgeToIncidentNodes.get(edge);\n", "    checkArgument(endpoints != null, EDGE_NOT_IN_GRAPH, edge);\n", "    return Sets.difference(\n", "        Sets.union(incidentEdges(endpoints.target()), incidentEdges(endpoints.source())),\n", "        ImmutableSet.of(edge));\n", "   * Returns the intersection of these two sets, using {@code Sets.intersection}:\n", "   * The first argument passed to {@code Sets.intersection} is the smaller of\n", "   * the two sets.\n", "   *\n", "   * @see Sets#intersection\n", "    checkNotNull(node1, \"node1\");\n", "    checkNotNull(node2, \"node2\");\n", "    DirectedIncidentEdges<E> incidentEdgesN1 = nodeToIncidentEdges.get(node1);\n", "    checkArgument(incidentEdgesN1 != null, NODE_NOT_IN_GRAPH, node1);\n", "    DirectedIncidentEdges<E> incidentEdgesN2 = nodeToIncidentEdges.get(node2);\n", "    checkArgument(incidentEdgesN2 != null, NODE_NOT_IN_GRAPH, node2);\n", "    Set<E> outEdges = incidentEdgesN1.outEdges();\n", "    Set<E> inEdges = incidentEdgesN2.inEdges();\n", "    return outEdges.size() <= inEdges.size()\n", "        ? Sets.intersection(outEdges, inEdges)\n", "        : Sets.intersection(inEdges, outEdges);\n", "    checkNotNull(node, \"node\");\n", "    DirectedIncidentEdges<E> incidentEdges = nodeToIncidentEdges.get(node);\n", "    checkArgument(incidentEdges != null, NODE_NOT_IN_GRAPH, node);\n", "    return Collections.unmodifiableSet(incidentEdges.inEdges());\n", "    checkNotNull(node, \"node\");\n", "    DirectedIncidentEdges<E> incidentEdges = nodeToIncidentEdges.get(node);\n", "    checkArgument(incidentEdges != null, NODE_NOT_IN_GRAPH, node);\n", "    return Collections.unmodifiableSet(incidentEdges.outEdges());\n", "    checkNotNull(node, \"node\");\n", "    DirectedIncidentEdges<E> incidentEdges = nodeToIncidentEdges.get(node);\n", "    checkArgument(incidentEdges != null, NODE_NOT_IN_GRAPH, node);\n", "    final Set<E> inEdges = incidentEdges.inEdges();\n", "    return new SetView<N>() {\n", "      @Override\n", "      public boolean isEmpty() {\n", "        return inEdges.isEmpty();\n", "      }\n", "\n", "      @Override\n", "      Set<N> elements() {\n", "        Set<N> nodes = Sets.newLinkedHashSet();\n", "        for (E edge : inEdges) {\n", "          nodes.add(source(edge));\n", "        }\n", "        return nodes;\n", "      }\n", "    };\n", "    checkNotNull(node, \"node\");\n", "    DirectedIncidentEdges<E> incidentEdges = nodeToIncidentEdges.get(node);\n", "    checkArgument(incidentEdges != null, NODE_NOT_IN_GRAPH, node);\n", "    final Set<E> outEdges = incidentEdges.outEdges();\n", "    return new SetView<N>() {\n", "      @Override\n", "      public boolean isEmpty() {\n", "        return outEdges.isEmpty();\n", "      }\n", "\n", "      @Override\n", "      Set<N> elements() {\n", "        Set<N> nodes = Sets.newLinkedHashSet();\n", "        for (E edge : outEdges) {\n", "          nodes.add(target(edge));\n", "        }\n", "        return nodes;\n", "      }\n", "    };\n", "    checkNotNull(node, \"node\");\n", "    return config.isSelfLoopsAllowed()\n", "        ? inDegree(node) + outDegree(node) - edgesConnecting(node, node).size()\n", "        : inDegree(node) + outDegree(node);\n", "    checkNotNull(node, \"node\");\n", "    DirectedIncidentEdges<E> incidentEdges = nodeToIncidentEdges.get(node);\n", "    checkArgument(incidentEdges != null, NODE_NOT_IN_GRAPH, node);\n", "    return incidentEdges.inEdges().size();\n", "    checkNotNull(node, \"node\");\n", "    DirectedIncidentEdges<E> incidentEdges = nodeToIncidentEdges.get(node);\n", "    checkArgument(incidentEdges != null, NODE_NOT_IN_GRAPH, node);\n", "    return incidentEdges.outEdges().size();\n", "    checkNotNull(edge, \"edge\");\n", "    DirectedIncidentNodes<N> endpoints = edgeToIncidentNodes.get(edge);\n", "    checkArgument(endpoints != null, EDGE_NOT_IN_GRAPH, edge);\n", "    return endpoints.source();\n", "    checkNotNull(edge, \"edge\");\n", "    DirectedIncidentNodes<N> endpoints = edgeToIncidentNodes.get(edge);\n", "    checkArgument(endpoints != null, EDGE_NOT_IN_GRAPH, edge);\n", "    return endpoints.target();\n"], "8": ["    if (containsNode(node)) {\n", "    // TODO(user): Enable users to specify the expected number of neighbors\n", "    // of a new node.\n", "    nodeToIncidentEdges.put(node, DirectedIncidentEdges.<E>of());\n"], "9": ["    } else if (!config.isMultigraph() && containsNode(node1) && containsNode(node2)) {\n", "    nodeToIncidentEdges.get(node1).outEdges().add(edge);\n", "    nodeToIncidentEdges.get(node2).inEdges().add(edge);\n"], "10": ["    if (!containsNode(node)) {\n", "    // Since views are returned, we need to copy the set of incident edges\n", "    // to an equivalent collection to avoid removing the edges we are looping on.\n", "    for (Object edge : incidentEdges(node).toArray()) {\n", "    nodeToIncidentEdges.remove(node);\n"], "11": ["    nodeToIncidentEdges.get(endpoints.source()).outEdges().remove(edge);\n", "    nodeToIncidentEdges.get(endpoints.target()).inEdges().remove(edge);\n", "    return (other instanceof DirectedGraph) && Graphs.equal(this, (DirectedGraph) other);\n", "    // This map encapsulates all of the structural relationships of this graph, so its hash code\n", "    // is consistent with the above definition of equals().\n", "    return nodeToIncidentEdges.hashCode();\n", "        nodeToIncidentEdges.keySet(),\n", "  private boolean containsNode(Object node) {\n", "    return nodeToIncidentEdges.containsKey(node);\n"]}, "added_lines": {"1": [27, 28], "2": [36], "3": [78, 79, 84, 86, 87, 93, 94, 95, 97, 98], "4": [107, 109, 115], "5": [124], "6": [139, 143, 145], "7": [155, 156, 157, 158, 159, 160, 161, 165, 173, 174, 175, 176, 177, 178, 179, 180, 185, 190, 195, 200, 205, 210, 215, 220, 225], "8": [234, 237], "9": [268, 273, 274, 276, 277], "10": [287, 288, 291, 292, 293, 296, 297, 298, 299], "11": [312, 313, 320, 325, 326, 333, 337, 338, 339, 340, 341, 342, 343, 344, 345, 346, 347, 348]}, "removed_lines": {"3": [75, 76, 81, 82, 83, 84, 85, 86, 87, 88, 89, 90, 91, 93, 94, 95, 96, 102, 103, 104, 105], "4": [115, 117, 123], "5": [132], "6": [147, 148, 149, 150, 154, 155, 157, 158, 159], "7": [169, 170, 171, 172, 173, 174, 178, 183, 184, 185, 186, 190, 191, 192, 193, 194, 195, 196, 197, 198, 199, 200, 205, 206, 207, 208, 213, 214, 215, 216, 221, 222, 223, 224, 225, 226, 227, 228, 229, 230, 231, 232, 233, 234, 235, 236, 237, 238, 239, 244, 245, 246, 247, 248, 249, 250, 251, 252, 253, 254, 255, 256, 257, 258, 259, 260, 261, 262, 267, 268, 269, 270, 275, 276, 277, 278, 283, 284, 285, 286, 291, 292, 293, 294, 299, 300, 301, 302], "8": [311, 314, 315, 316], "9": [347, 352, 354], "10": [364, 367, 368, 369, 372], "11": [385, 386, 393, 398, 399, 400, 407, 411, 412]}}, {"10": "guava/src/com/google/common/graph/IncidenceSetUndirectedGraph.java", "added": {"1": ["import com.google.common.base.Objects;\n", "import com.google.common.collect.ImmutableList;\n"], "3": [" * are returning views.\n"], "4": [" *     (does not support parallel edges), then this method is O(min(d_node1, d_node2)).\n", " * <li>{@code removeNode(node)}: O(d_node).\n", " * where d_node is the degree of node.\n"], "5": ["  private final Map<N, NodeConnections<N, E>> nodeConnections;\n", "    this.nodeConnections =\n"], "6": ["    return Collections.unmodifiableSet(nodeConnections.keySet());\n"], "7": ["    return checkedConnections(node).incidentEdges();\n"], "8": ["  public Set<N> adjacentNodes(Object node) {\n", "    return checkedConnections(node).adjacentNodes();\n", "    Iterator<N> incidentNodesIterator = incidentNodes(edge).iterator();\n", "      endpointsIncidentEdges =\n", "          Sets.union(incidentEdges(incidentNodesIterator.next()), endpointsIncidentEdges);\n", "   * If {@code node1} is equal to {@code node2}, the set of self-loop edges is returned.\n", "   * Otherwise, returns the intersection of these two sets, using {@link Sets#intersection}:\n", "  public Set<E> edgesConnecting(Object node1, Object node2) {\n", "    Set<E> incidentEdgesN1 = incidentEdges(node1);\n", "      Set<E> selfLoopEdges = Sets.filter(incidentEdgesN1, Graphs.selfLoopPredicate(this));\n", "      return Collections.unmodifiableSet(selfLoopEdges);\n", "    Set<E> incidentEdgesN2 = incidentEdges(node2);\n", "    return (incidentEdgesN1.size() <= incidentEdgesN2.size())\n"], "9": ["    return incidentEdges(node).size();\n"], "10": ["    if (nodes().contains(node)) {\n", "    nodeConnections.put(node, UndirectedNodeConnections.<N, E>of());\n"], "11": ["    } else if (!config.isMultigraph() && nodes().contains(node1) && nodes().contains(node2)) {\n", "    addNode(node1);\n", "    NodeConnections<N, E> connectionsN1 = nodeConnections.get(node1);\n", "    connectionsN1.addSuccessor(node2, edge);\n", "    if (!incidentNodes.isSelfLoop()) {\n", "      addNode(node2);\n", "      NodeConnections<N, E> connectionsN2 = nodeConnections.get(node2);\n", "      connectionsN2.addPredecessor(node1, edge);\n"], "12": ["    NodeConnections<N, E> connections = nodeConnections.get(node);\n", "    if (connections == null) {\n", "    // Since views are returned, we need to copy the nodes and edges that will be removed.\n", "    // Thus we avoid modifying the underlying views while iterating over them.\n", "    for (E edge : ImmutableList.copyOf(incidentEdges(node))) {\n", "    for (N adjacentNode : ImmutableList.copyOf(connections.adjacentNodes())) {\n", "      nodeConnections.get(adjacentNode).removeNode(node);\n", "    }\n", "    nodeConnections.remove(node);\n"], "13": ["      nodeConnections.get(node).removeEdge(edge);\n"], "14": ["    return (object instanceof UndirectedGraph)\n", "        && Graphs.equal(this, (UndirectedGraph<?, ?>) object);\n", "    // The node set is included in the hash to differentiate between graphs with isolated nodes.\n", "    return Objects.hashCode(nodes(), edgeToIncidentNodes);\n", "        nodes(),\n", "  private NodeConnections<N, E> checkedConnections(Object node) {\n", "    checkNotNull(node, \"node\");\n", "    NodeConnections<N, E> connections = nodeConnections.get(node);\n", "    checkArgument(connections != null, NODE_NOT_IN_GRAPH, node);\n", "    return connections;\n"]}, "removed": {"1": ["import static com.google.common.graph.Graphs.oppositeNode;\n"], "2": ["import java.util.LinkedHashSet;\n"], "3": [" * are returning views. It should be noted that for the following methods:\n", " * <ul>\n", " * <li>Methods that ask for adjacent nodes (e.g. {@code adjacentNodes}).\n", " * <li>{@code adjacentEdges}.\n", " * <li>{@code edgesConnecting}.\n", " * </ul>\n", " * the view is calculated lazily and the backing set is <b>not</b> cached, so every time the user\n", " * accesses the returned view, the backing set will be reconstructed again. If the user wants\n", " * to avoid this, they should either use {@code ImmutableUndirectedGraph}\n", " * (if their input is not changing) or make a copy of the return value.\n"], "4": [" * (does not support parallel edges). In such case, this method may call\n", " * {@code edgesConnecting(node1, node2)}.\n", " * <li>{@code removeNode(node)} O(d), where d is the degree of {@code node}.\n"], "5": ["  private final Map<N, Set<E>> nodeToIncidentEdges;\n", "    this.nodeToIncidentEdges =\n"], "6": ["    return Collections.unmodifiableSet(nodeToIncidentEdges.keySet());\n"], "7": ["    checkNotNull(node, \"node\");\n", "    Set<E> incidentEdges = nodeToIncidentEdges.get(node);\n", "    checkArgument(incidentEdges != null, NODE_NOT_IN_GRAPH, node);\n", "    return Collections.unmodifiableSet(incidentEdges);\n"], "8": ["  public Set<N> adjacentNodes(final Object node) {\n", "    checkNotNull(node, \"node\");\n", "    final Set<E> incidentEdges = nodeToIncidentEdges.get(node);\n", "    checkArgument(incidentEdges != null, NODE_NOT_IN_GRAPH, node);\n", "    return new SetView<N>() {\n", "      @Override\n", "      public boolean isEmpty() {\n", "        return incidentEdges.isEmpty();\n", "      }\n", "\n", "      @Override\n", "      Set<N> elements() {\n", "        Set<N> nodes = Sets.newLinkedHashSetWithExpectedSize(incidentEdges.size());\n", "        for (E edge : incidentEdges) {\n", "          nodes.add(oppositeNode(IncidenceSetUndirectedGraph.this, edge, node));\n", "        }\n", "        return nodes;\n", "      }\n", "    };\n", "    checkNotNull(edge, \"edge\");\n", "    UndirectedIncidentNodes<N> incidentNodes = edgeToIncidentNodes.get(edge);\n", "    checkArgument(incidentNodes != null, EDGE_NOT_IN_GRAPH, edge);\n", "    Iterator<N> incidentNodesIterator = incidentNodes.iterator();\n", "      endpointsIncidentEdges = Sets.union(incidentEdges(incidentNodesIterator.next()),\n", "          endpointsIncidentEdges);\n", "   * If {@code node1} is equal to {@code node2} and self-loops are allowed (if self-loops\n", "   * are not allowed, this would be a trivial case and an empty set is returned),\n", "   * a {@code SetView} instance is returned, calculating the set of self-loop edges.\n", "   * Otherwise, this method returns the intersection of these two sets,\n", "   * using {@code Sets.intersection}:\n", "   * The first argument passed to {@code Sets.intersection} is the smaller of\n", "   * the two sets.\n", "   *\n", "   * @see Sets#intersection\n", "  public Set<E> edgesConnecting(final Object node1, Object node2) {\n", "    checkNotNull(node1, \"node1\");\n", "    checkNotNull(node2, \"node2\");\n", "    final Set<E> incidentEdgesN1 = nodeToIncidentEdges.get(node1);\n", "    checkArgument(incidentEdgesN1 != null, NODE_NOT_IN_GRAPH, node1);\n", "      return new SetView<E>() {\n", "        @Override\n", "        Set<E> elements() {\n", "          Set<E> selfLoopEdges = Sets.newLinkedHashSet();\n", "          for (E edge : incidentEdgesN1) {\n", "            if (edgeToIncidentNodes.get(edge).isSelfLoop()) {\n", "              selfLoopEdges.add(edge);\n", "            }\n", "          }\n", "          return selfLoopEdges;\n", "        }\n", "      };\n", "    final Set<E> incidentEdgesN2 = nodeToIncidentEdges.get(node2);\n", "    checkArgument(incidentEdgesN2 != null, NODE_NOT_IN_GRAPH, node2);\n", "    return incidentEdgesN1.size() <= incidentEdgesN2.size()\n"], "9": ["    checkNotNull(node, \"node\");\n", "    Set<E> incidentEdges = nodeToIncidentEdges.get(node);\n", "    checkArgument(incidentEdges != null, NODE_NOT_IN_GRAPH, node);\n", "    return incidentEdges.size();\n"], "10": ["    if (containsNode(node)) {\n", "    // TODO(user): Enable users to specify expected number of neighbors for\n", "    // a node.\n", "    nodeToIncidentEdges.put(node, new LinkedHashSet<E>());\n"], "11": ["    } else if (!config.isMultigraph() && containsNode(node1) && containsNode(node2)) {\n", "    for (N node : incidentNodes) {\n", "      addNode(node);\n", "      nodeToIncidentEdges.get(node).add(edge);\n"], "12": ["    Set<E> incidentEdges = nodeToIncidentEdges.get(node);\n", "    if (incidentEdges == null) {\n", "    // Since views are returned, we need to copy the set of incident edges\n", "    // to an equivalent collection to avoid removing the edges we are looping on.\n", "    for (Object edge : incidentEdges.toArray()) {\n", "    nodeToIncidentEdges.remove(node);\n"], "13": ["      nodeToIncidentEdges.get(node).remove(edge);\n"], "14": ["    return (object instanceof UndirectedGraph) && Graphs.equal(this, (UndirectedGraph) object);\n", "    // This map encapsulates all of the structural relationships of this graph, so its hash code\n", "    // is consistent with the above definition of equals().\n", "    return nodeToIncidentEdges.hashCode();\n", "        nodeToIncidentEdges.keySet(),\n", "  private boolean containsNode(Object node) {\n", "    return nodeToIncidentEdges.containsKey(node);\n"]}, "added_lines": {"1": [27, 28], "3": [81], "4": [90, 91, 93], "5": [105, 112], "6": [121], "7": [136], "8": [148, 149, 154, 157, 158, 164, 165, 172, 173, 178, 179, 181, 182], "9": [209], "10": [228, 231], "11": [262, 266, 267, 268, 269, 270, 271, 272], "12": [283, 284, 287, 288, 289, 292, 293, 294, 295], "13": [309], "14": [317, 318, 323, 324, 331, 335, 336, 337, 338, 339]}, "removed_lines": {"1": [26], "2": [36], "3": [81, 82, 83, 84, 85, 86, 87, 88, 89, 90], "4": [99, 100, 101], "5": [114, 121], "6": [130], "7": [145, 146, 147, 148], "8": [160, 161, 162, 163, 164, 165, 166, 167, 168, 169, 170, 171, 172, 173, 174, 175, 176, 177, 178, 183, 184, 185, 186, 189, 190, 196, 197, 198, 199, 200, 205, 206, 207, 208, 211, 212, 213, 214, 215, 220, 221, 222, 223, 224, 225, 226, 227, 228, 229, 230, 231, 233, 234, 235], "9": [262, 263, 264, 265], "10": [284, 287, 288, 289], "11": [320, 324, 325, 326], "12": [337, 338, 341, 342, 343, 346], "13": [360], "14": [368, 373, 374, 375, 382, 386, 387]}}, {"11": "guava/src/com/google/common/graph/NodeConnections.java", "added": {"1": ["/*\n", " * Copyright (C) 2016 The Guava Authors\n", " *\n", " * Licensed under the Apache License, Version 2.0 (the \"License\");\n", " * you may not use this file except in compliance with the License.\n", " * You may obtain a copy of the License at\n", " *\n", " * http://www.apache.org/licenses/LICENSE-2.0\n", " *\n", " * Unless required by applicable law or agreed to in writing, software\n", " * distributed under the License is distributed on an \"AS IS\" BASIS,\n", " * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n", " * See the License for the specific language governing permissions and\n", " * limitations under the License.\n", " */\n", "\n", "package com.google.common.graph;\n", "\n", "import java.util.Set;\n", "\n", "/**\n", " * An interface for representing an origin node's adjacent nodes and incident edges in a graph.\n", " *\n", " * @author James Sexton\n", " * @param <N> Node parameter type\n", " * @param <E> Edge parameter type\n", " */\n", "interface NodeConnections<N, E> {\n", "\n", "  Set<N> adjacentNodes();\n", "\n", "  Set<N> predecessors();\n", "\n", "  Set<N> successors();\n", "\n", "  Set<E> incidentEdges();\n", "\n", "  Set<E> inEdges();\n", "\n", "  Set<E> outEdges();\n", "\n", "  /**\n", "   * Remove all references to {@code node} in the sets of adjacent nodes.\n", "   */\n", "  void removeNode(Object node);\n", "\n", "  /**\n", "   * Remove all references to {@code edge} in the sets of incident edges.\n", "   */\n", "  void removeEdge(Object edge);\n", "\n", "  /**\n", "   * Add {@code node} as a predecessor to the origin node, connected with {@code edge}.\n", "   * In the case of an undirected graph, it also becomes a successor.\n", "   */\n", "  void addPredecessor(N node, E edge);\n", "\n", "  /**\n", "   * Add {@code node} as a successor to the origin node, connected with {@code edge}.\n", "   * In the case of an undirected graph, it also becomes a predecessor.\n", "   */\n", "  void addSuccessor(N node, E edge);\n", "}\n"]}, "removed": {}, "added_lines": {"1": [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 58, 59, 60, 61, 62, 63]}, "removed_lines": {}}, {"12": "guava/src/com/google/common/graph/SetView.java", "added": {}, "removed": {"1": ["/*\n", " * Copyright (C) 2014 The Guava Authors\n", " *\n", " * Licensed under the Apache License, Version 2.0 (the \"License\");\n", " * you may not use this file except in compliance with the License.\n", " * You may obtain a copy of the License at\n", " *\n", " * http://www.apache.org/licenses/LICENSE-2.0\n", " *\n", " * Unless required by applicable law or agreed to in writing, software\n", " * distributed under the License is distributed on an \"AS IS\" BASIS,\n", " * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n", " * See the License for the specific language governing permissions and\n", " * limitations under the License.\n", " */\n", "\n", "package com.google.common.graph;\n", "\n", "import com.google.common.collect.Iterators;\n", "\n", "import java.util.AbstractSet;\n", "import java.util.Iterator;\n", "import java.util.Set;\n", "\n", "/**\n", " * An unmodifiable view of a set which may be backed by other sets; this view\n", " * will change as the backing sets do.\n", " */\n", "abstract class SetView<E> extends AbstractSet<E> {\n", "\n", "  SetView() {}\n", "\n", "  @Override\n", "  public int size() {\n", "    return elements().size();\n", "  }\n", "\n", "  @Override\n", "  public boolean isEmpty() {\n", "    return elements().isEmpty();\n", "  }\n", "\n", "  @Override\n", "  public Iterator<E> iterator() {\n", "    return Iterators.unmodifiableIterator(elements().iterator());\n", "  }\n", "\n", "  @Override\n", "  public boolean contains(Object object) {\n", "    return elements().contains(object);\n", "  }\n", "\n", "  abstract Set<E> elements();\n", "}\n"]}, "added_lines": {}, "removed_lines": {"1": [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51, 52, 53, 54]}}, {"13": "guava/src/com/google/common/graph/UndirectedNodeConnections.java", "added": {"1": ["/*\n", " * Copyright (C) 2016 The Guava Authors\n", " *\n", " * Licensed under the Apache License, Version 2.0 (the \"License\");\n", " * you may not use this file except in compliance with the License.\n", " * You may obtain a copy of the License at\n", " *\n", " * http://www.apache.org/licenses/LICENSE-2.0\n", " *\n", " * Unless required by applicable law or agreed to in writing, software\n", " * distributed under the License is distributed on an \"AS IS\" BASIS,\n", " * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n", " * See the License for the specific language governing permissions and\n", " * limitations under the License.\n", " */\n", "\n", "package com.google.common.graph;\n", "\n", "import static com.google.common.base.Preconditions.checkNotNull;\n", "\n", "import com.google.common.base.MoreObjects;\n", "import com.google.common.base.Objects;\n", "import com.google.common.collect.ImmutableSet;\n", "import com.google.common.collect.Sets;\n", "\n", "import java.util.Collections;\n", "import java.util.Set;\n", "\n", "import javax.annotation.Nullable;\n", "\n", "/**\n", " * A class representing an origin node's adjacent nodes and incident edges in an undirected graph.\n", " *\n", " * @author James Sexton\n", " * @param <N> Node parameter type\n", " * @param <E> Edge parameter type\n", " */\n", "final class UndirectedNodeConnections<N, E> implements NodeConnections<N, E> {\n", "  private final Set<N> adjacentNodes;\n", "  private final Set<E> incidentEdges;\n", "\n", "  private UndirectedNodeConnections(Set<N> adjacentNodes, Set<E> incidentEdges) {\n", "    this.adjacentNodes = checkNotNull(adjacentNodes, \"adjacentNodes\");\n", "    this.incidentEdges = checkNotNull(incidentEdges, \"incidentEdges\");\n", "  }\n", "\n", "  static <N, E> UndirectedNodeConnections<N, E> of() {\n", "    // TODO(user): Enable users to specify the expected number of neighbors of a new node.\n", "    return new UndirectedNodeConnections<N, E>(\n", "        Sets.<N>newLinkedHashSet(), Sets.<E>newLinkedHashSet());\n", "  }\n", "\n", "  static <N, E> UndirectedNodeConnections<N, E> ofImmutable(\n", "      Set<N> adjacentNodes, Set<E> incidentEdges) {\n", "    return new UndirectedNodeConnections<N, E>(\n", "        ImmutableSet.copyOf(adjacentNodes), ImmutableSet.copyOf(incidentEdges));\n", "  }\n", "\n", "  @Override\n", "  public Set<N> adjacentNodes() {\n", "    return Collections.unmodifiableSet(adjacentNodes);\n", "  }\n", "\n", "  @Override\n", "  public Set<N> predecessors() {\n", "    return adjacentNodes();\n", "  }\n", "\n", "  @Override\n", "  public Set<N> successors() {\n", "    return adjacentNodes();\n", "  }\n", "\n", "  @Override\n", "  public Set<E> incidentEdges() {\n", "    return Collections.unmodifiableSet(incidentEdges);\n", "  }\n", "\n", "  @Override\n", "  public Set<E> inEdges() {\n", "    return incidentEdges();\n", "  }\n", "\n", "  @Override\n", "  public Set<E> outEdges() {\n", "    return incidentEdges();\n", "  }\n", "\n", "  @Override\n", "  public void removeNode(Object node) {\n", "    checkNotNull(node, \"node\");\n", "    adjacentNodes.remove(node);\n", "  }\n", "\n", "  @Override\n", "  public void removeEdge(Object edge) {\n", "    checkNotNull(edge, \"edge\");\n", "    incidentEdges.remove(edge);\n", "  }\n", "\n", "  @Override\n", "  public void addPredecessor(N node, E edge) {\n", "    addSuccessor(node, edge);\n", "  }\n", "\n", "  @Override\n", "  public void addSuccessor(N node, E edge) {\n", "    checkNotNull(node, \"node\");\n", "    checkNotNull(edge, \"edge\");\n", "    adjacentNodes.add(node);\n", "    incidentEdges.add(edge);\n", "  }\n", "\n", "  @Override\n", "  public int hashCode() {\n", "    return Objects.hashCode(adjacentNodes, incidentEdges);\n", "  }\n", "\n", "  @Override\n", "  public boolean equals(@Nullable Object object) {\n", "    if (object instanceof UndirectedNodeConnections) {\n", "      UndirectedNodeConnections<?, ?> that = (UndirectedNodeConnections<?, ?>) object;\n", "      return this.adjacentNodes.equals(that.adjacentNodes)\n", "          && this.incidentEdges.equals(that.incidentEdges);\n", "    }\n", "    return false;\n", "  }\n", "\n", "  @Override\n", "  public String toString() {\n", "    return MoreObjects.toStringHelper(this)\n", "        .add(\"adjacentNodes\", adjacentNodes)\n", "        .add(\"incidentEdges\", incidentEdges)\n", "        .toString();\n", "  }\n", "}"]}, "removed": {}, "added_lines": {"1": [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 58, 59, 60, 61, 62, 63, 64, 65, 66, 67, 68, 69, 70, 71, 72, 73, 74, 75, 76, 77, 78, 79, 80, 81, 82, 83, 84, 85, 86, 87, 88, 89, 90, 91, 92, 93, 94, 95, 96, 97, 98, 99, 100, 101, 102, 103, 104, 105, 106, 107, 108, 109, 110, 111, 112, 113, 114, 115, 116, 117, 118, 119, 120, 121, 122, 123, 124, 125, 126, 127, 128, 129, 130, 131, 132, 133, 134, 135, 136]}, "removed_lines": {}}]}
