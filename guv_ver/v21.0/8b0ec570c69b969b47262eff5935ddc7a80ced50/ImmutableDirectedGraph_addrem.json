{
    "addition": {
        "25": "import com.google.common.base.Objects;\n",
        "60": " * <p>The time complexity of all {@code Set}-returning accessors is O(1), since we\n",
        "61": " * are returning views. An exception to this is {@code edgesConnecting(node1, node2)},\n",
        "62": " * which is O(min(outD_node1, inD_node2)).\n",
        "64": " * <p>All other accessors have a time complexity of O(1), except for {@code degree(node)},\n",
        "65": " * whose time complexity is O(outD_node).\n",
        "79": "  private final ImmutableMap<N, NodeConnections<N, E>> nodeConnections;\n",
        "86": "    ImmutableMap.Builder<N, NodeConnections<N, E>> nodeConnectionsBuilder =\n",
        "89": "      NodeConnections<N, E> connections = DirectedNodeConnections.ofImmutable(\n",
        "90": "          directedGraph.predecessors(node), directedGraph.successors(node),\n",
        "92": "      nodeConnectionsBuilder.put(node, connections);\n",
        "94": "    this.nodeConnections = nodeConnectionsBuilder.build();\n",
        "102": "    this.edgeToIncidentNodes = edgeToIncidentNodesBuilder.build();\n",
        "108": "    return nodeConnections.keySet();\n",
        "123": "    return Sets.union(inEdges(node), outEdges(node));\n",
        "128": "    return checkedEndpoints(edge).asImmutableSet();\n",
        "133": "    return Sets.union(predecessors(node), successors(node));\n",
        "139": "    for (N node : incidentNodes(edge)) {\n",
        "148": "   * Returns the intersection of these two sets, using {@link Sets#intersection}:\n",
        "156": "    Set<E> sourceOutEdges = outEdges(node1); // Verifies that node1 is in graph\n",
        "157": "    if (!config.isSelfLoopsAllowed() && node1.equals(node2)) {\n",
        "158": "      return ImmutableSet.of();\n",
        "159": "    }\n",
        "161": "    return (sourceOutEdges.size() <= targetInEdges.size())\n",
        "168": "    return checkedConnections(node).inEdges();\n",
        "173": "    return checkedConnections(node).outEdges();\n",
        "178": "    return checkedConnections(node).predecessors();\n",
        "183": "    return checkedConnections(node).successors();\n",
        "188": "    return incidentEdges(node).size();\n",
        "203": "    return checkedEndpoints(edge).source();\n",
        "208": "    return checkedEndpoints(edge).target();\n",
        "213": "    return (object instanceof DirectedGraph) && Graphs.equal(this, (DirectedGraph<?, ?>) object);\n",
        "218": "    // The node set is included in the hash to differentiate between graphs with isolated nodes.\n",
        "219": "    return Objects.hashCode(nodes(), edgeToIncidentNodes);\n",
        "220": "  }\n",
        "221": "\n",
        "222": "  @Override\n",
        "223": "  public String toString() {\n",
        "224": "    return String.format(\"config: %s, nodes: %s, edges: %s\",\n",
        "225": "        config,\n",
        "226": "        nodes(),\n",
        "227": "        edgeToIncidentNodes);\n",
        "228": "  }\n",
        "229": "\n",
        "230": "  private NodeConnections<N, E> checkedConnections(Object node) {\n",
        "231": "    checkNotNull(node, \"node\");\n",
        "232": "    NodeConnections<N, E> connections = nodeConnections.get(node);\n",
        "233": "    checkArgument(connections != null, NODE_NOT_IN_GRAPH, node);\n",
        "234": "    return connections;\n",
        "235": "  }\n",
        "236": "\n",
        "237": "  private DirectedIncidentNodes<N> checkedEndpoints(Object edge) {\n",
        "238": "    checkNotNull(edge, \"edge\");\n",
        "239": "    DirectedIncidentNodes<N> endpoints = edgeToIncidentNodes.get(edge);\n",
        "240": "    checkArgument(endpoints != null, EDGE_NOT_IN_GRAPH, edge);\n",
        "241": "    return endpoints;\n"
    },
    "removed": {
        "59": " * <p>Most of the {@code Set}-returning accessors return an immutable set which is an internal\n",
        "60": " * data structure, hence they have a time complexity of O(1). The rest of these accessors build\n",
        "61": " * and return an immutable set that is <b>derived</b> from the internal data structures, hence\n",
        "62": " * they have the following time complexities:\n",
        "63": " * <ul>\n",
        "64": " * <li>{@code incidentEdges(node)}: O(d_node).\n",
        "65": " * <li>Methods that ask for adjacent nodes:\n",
        "66": " *     <ul>\n",
        "67": " *     <li>{@code adjacentNodes(node)}: O(d_node).\n",
        "68": " *     <li>{@code predecessors(node)}: O(inD_node).\n",
        "69": " *     <li>{@code successors(node)}: O(outD_node).\n",
        "70": " *     </ul>\n",
        "71": " * <li>{@code adjacentEdges(edge)}: O(d_node1 + d_node2), where node1 and node2 are\n",
        "72": " *     {@code edge}'s incident nodes.\n",
        "73": " * <li>{@code edgesConnecting(node1, node2)}: O(min(outD_node1, inD_node2)).\n",
        "74": " * </ul>\n",
        "75": " * where d_node is the degree of node, inD_node is the in-degree of node, and outD_node is the\n",
        "76": " * out-degree of node. The set returned by these methods is <b>not</b> cached, so every time the\n",
        "77": " * user calls the method, the same set will be reconstructed again.\n",
        "79": " * <p>All other accessors have a time complexity of O(1), except for\n",
        "80": " * {@code degree(node)}, whose time complexity is linear in the minimum of\n",
        "81": " * the out-degree and in-degree of {@code node}. This is due to a call to {@code edgesConnecting}.\n",
        "95": "  private final ImmutableMap<N, DirectedIncidentEdges<E>> nodeToIncidentEdges;\n",
        "102": "    ImmutableMap.Builder<N, DirectedIncidentEdges<E>> nodeToIncidentEdgesBuilder =\n",
        "105": "      DirectedIncidentEdges<E> incidentEdges = DirectedIncidentEdges.ofImmutable(\n",
        "107": "      nodeToIncidentEdgesBuilder.put(node, incidentEdges);\n",
        "109": "    nodeToIncidentEdges = nodeToIncidentEdgesBuilder.build();\n",
        "117": "    edgeToIncidentNodes = edgeToIncidentNodesBuilder.build();\n",
        "123": "    return nodeToIncidentEdges.keySet();\n",
        "138": "    return Sets.union(inEdges(node), outEdges(node)).immutableCopy();\n",
        "143": "    checkNotNull(edge, \"edge\");\n",
        "144": "    DirectedIncidentNodes<N> endpoints = edgeToIncidentNodes.get(edge);\n",
        "145": "    checkArgument(endpoints != null, EDGE_NOT_IN_GRAPH, edge);\n",
        "146": "    return endpoints.asImmutableSet();\n",
        "151": "    return Sets.union(predecessors(node), successors(node)).immutableCopy();\n",
        "156": "    checkNotNull(edge, \"edge\");\n",
        "157": "    DirectedIncidentNodes<N> endpoints = edgeToIncidentNodes.get(edge);\n",
        "158": "    checkArgument(endpoints != null, EDGE_NOT_IN_GRAPH, edge);\n",
        "160": "    for (N node : endpoints.asImmutableSet()) {\n",
        "169": "   * Returns the intersection of these two sets, using {@code Sets.intersection}:\n",
        "174": "   * The first argument passed to {@code Sets.intersection} is the smaller of the two sets.\n",
        "175": "   *\n",
        "176": "   * @see Sets#intersection\n",
        "180": "    checkNotNull(node1, \"node1\");\n",
        "181": "    checkNotNull(node2, \"node2\");\n",
        "182": "    Set<E> sourceOutEdges = outEdges(node1);\n",
        "184": "    return sourceOutEdges.size() <= targetInEdges.size()\n",
        "191": "    checkNotNull(node, \"node\");\n",
        "192": "    DirectedIncidentEdges<E> incidentEdges = nodeToIncidentEdges.get(node);\n",
        "193": "    checkArgument(incidentEdges != null, NODE_NOT_IN_GRAPH, node);\n",
        "194": "    return incidentEdges.inEdges();\n",
        "199": "    checkNotNull(node, \"node\");\n",
        "200": "    DirectedIncidentEdges<E> incidentEdges = nodeToIncidentEdges.get(node);\n",
        "201": "    checkArgument(incidentEdges != null, NODE_NOT_IN_GRAPH, node);\n",
        "202": "    return incidentEdges.outEdges();\n",
        "207": "    ImmutableSet.Builder<N> predecessorsBuilder = ImmutableSet.builder();\n",
        "208": "    for (E edge : inEdges(node)) {\n",
        "209": "      predecessorsBuilder.add(source(edge));\n",
        "210": "    }\n",
        "211": "    return predecessorsBuilder.build();\n",
        "216": "    ImmutableSet.Builder<N> successorsBuilder = ImmutableSet.builder();\n",
        "217": "    for (E edge : outEdges(node)) {\n",
        "218": "      successorsBuilder.add(target(edge));\n",
        "219": "    }\n",
        "220": "    return successorsBuilder.build();\n",
        "225": "    return inDegree(node) + outDegree(node) - edgesConnecting(node, node).size();\n",
        "240": "    checkNotNull(edge, \"edge\");\n",
        "241": "    DirectedIncidentNodes<N> endpoints = edgeToIncidentNodes.get(edge);\n",
        "242": "    checkArgument(endpoints != null, EDGE_NOT_IN_GRAPH, edge);\n",
        "243": "    return endpoints.source();\n",
        "248": "    checkNotNull(edge, \"edge\");\n",
        "249": "    DirectedIncidentNodes<N> endpoints = edgeToIncidentNodes.get(edge);\n",
        "250": "    checkArgument(endpoints != null, EDGE_NOT_IN_GRAPH, edge);\n",
        "251": "    return endpoints.target();\n",
        "256": "    return (object instanceof DirectedGraph) && Graphs.equal(this, (DirectedGraph) object);\n",
        "261": "    // This map encapsulates all of the structural relationships of this graph, so its hash code\n",
        "262": "    // is consistent with the above definition of equals().\n",
        "263": "    return nodeToIncidentEdges.hashCode();\n",
        "292": "  @Override\n",
        "293": "  public String toString() {\n",
        "294": "    return String.format(\"config: %s, nodes: %s, edges: %s\",\n",
        "295": "        config,\n",
        "296": "        nodeToIncidentEdges.keySet(),\n",
        "297": "        edgeToIncidentNodes);\n",
        "298": "  }\n",
        "299": "\n"
    }
}