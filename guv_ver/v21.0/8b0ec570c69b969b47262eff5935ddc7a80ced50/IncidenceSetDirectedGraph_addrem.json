{
    "addition": {
        "27": "import com.google.common.base.Objects;\n",
        "28": "import com.google.common.collect.ImmutableList;\n",
        "36": "import java.util.Iterator;\n",
        "78": " *     Set<N> preds = predecessors(node);\n",
        "79": " *     graph.removeNode(node);}</pre>\n",
        "84": " * are returning views.\n",
        "86": " * <p>All other accessors have a time complexity of O(1), except for {@code degree(node)},\n",
        "87": " * whose time complexity is O(outD_node).\n",
        "93": " * <li>{@code addEdge(E edge, N node1, N node2)}: O(1), unless this graph is not a multigraph\n",
        "94": " *     (does not support parallel edges), then this method is O(min(outD_node1, inD_node2)).\n",
        "95": " * <li>{@code removeNode(node)}: O(d_node).\n",
        "97": " * where d_node is the degree of node, inD_node is the in-degree of node, and outD_node is the\n",
        "98": " * out-degree of node.\n",
        "107": "  // TODO(b/24620028): Enable this class to support sorted nodes/edges.\n",
        "109": "  private final Map<N, NodeConnections<N, E>> nodeConnections;\n",
        "115": "    this.nodeConnections =\n",
        "124": "    return Collections.unmodifiableSet(nodeConnections.keySet());\n",
        "139": "    return Sets.union(inEdges(node), outEdges(node));\n",
        "143": "  public Set<N> incidentNodes(Object edge) {\n",
        "145": "    return checkedEndpoints(edge).asImmutableSet();\n",
        "155": "    Iterator<N> incidentNodesIterator = incidentNodes(edge).iterator();\n",
        "156": "    Set<E> endpointsIncidentEdges = incidentEdges(incidentNodesIterator.next());\n",
        "157": "    while (incidentNodesIterator.hasNext()) {\n",
        "158": "      endpointsIncidentEdges =\n",
        "159": "          Sets.union(incidentEdges(incidentNodesIterator.next()), endpointsIncidentEdges);\n",
        "160": "    }\n",
        "161": "    return Sets.difference(endpointsIncidentEdges, ImmutableSet.of(edge));\n",
        "165": "   * Returns the intersection of these two sets, using {@link Sets#intersection}:\n",
        "173": "    Set<E> sourceOutEdges = outEdges(node1); // Verifies that node1 is in graph\n",
        "174": "    if (!config.isSelfLoopsAllowed() && node1.equals(node2)) {\n",
        "175": "      return ImmutableSet.of();\n",
        "176": "    }\n",
        "177": "    Set<E> targetInEdges = inEdges(node2);\n",
        "178": "    return (sourceOutEdges.size() <= targetInEdges.size())\n",
        "179": "        ? Sets.intersection(sourceOutEdges, targetInEdges)\n",
        "180": "        : Sets.intersection(targetInEdges, sourceOutEdges);\n",
        "185": "    return checkedConnections(node).inEdges();\n",
        "190": "    return checkedConnections(node).outEdges();\n",
        "195": "    return checkedConnections(node).predecessors();\n",
        "200": "    return checkedConnections(node).successors();\n",
        "205": "    return incidentEdges(node).size();\n",
        "210": "    return inEdges(node).size();\n",
        "215": "    return outEdges(node).size();\n",
        "220": "    return checkedEndpoints(edge).source();\n",
        "225": "    return checkedEndpoints(edge).target();\n",
        "234": "    if (nodes().contains(node)) {\n",
        "237": "    nodeConnections.put(node, DirectedNodeConnections.<N, E>of());\n",
        "268": "    } else if (!config.isMultigraph() && nodes().contains(node1) && nodes().contains(node2)) {\n",
        "273": "    NodeConnections<N, E> connectionsN1 = nodeConnections.get(node1);\n",
        "274": "    connectionsN1.addSuccessor(node2, edge);\n",
        "276": "    NodeConnections<N, E> connectionsN2 = nodeConnections.get(node2);\n",
        "277": "    connectionsN2.addPredecessor(node1, edge);\n",
        "287": "    NodeConnections<N, E> connections = nodeConnections.get(node);\n",
        "288": "    if (connections == null) {\n",
        "291": "    // Since views are returned, we need to copy the nodes and edges that will be removed.\n",
        "292": "    // Thus we avoid modifying the underlying views while iterating over them.\n",
        "293": "    for (E edge : ImmutableList.copyOf(incidentEdges(node))) {\n",
        "296": "    for (N adjacentNode : ImmutableList.copyOf(connections.adjacentNodes())) {\n",
        "297": "      nodeConnections.get(adjacentNode).removeNode(node);\n",
        "298": "    }\n",
        "299": "    nodeConnections.remove(node);\n",
        "312": "    nodeConnections.get(endpoints.source()).removeEdge(edge);\n",
        "313": "    nodeConnections.get(endpoints.target()).removeEdge(edge);\n",
        "320": "    return (other instanceof DirectedGraph) && Graphs.equal(this, (DirectedGraph<?, ?>) other);\n",
        "325": "    // The node set is included in the hash to differentiate between graphs with isolated nodes.\n",
        "326": "    return Objects.hashCode(nodes(), edgeToIncidentNodes);\n",
        "333": "        nodes(),\n",
        "337": "  private NodeConnections<N, E> checkedConnections(Object node) {\n",
        "338": "    checkNotNull(node, \"node\");\n",
        "339": "    NodeConnections<N, E> connections = nodeConnections.get(node);\n",
        "340": "    checkArgument(connections != null, NODE_NOT_IN_GRAPH, node);\n",
        "341": "    return connections;\n",
        "342": "  }\n",
        "343": "\n",
        "344": "  private DirectedIncidentNodes<N> checkedEndpoints(Object edge) {\n",
        "345": "    checkNotNull(edge, \"edge\");\n",
        "346": "    DirectedIncidentNodes<N> endpoints = edgeToIncidentNodes.get(edge);\n",
        "347": "    checkArgument(endpoints != null, EDGE_NOT_IN_GRAPH, edge);\n",
        "348": "    return endpoints;\n"
    },
    "removed": {
        "75": " *     Set<N> preds = predecessors(n);\n",
        "76": " *     graph.removeNode(n);}</pre>\n",
        "81": " * are returning views. It should be noted that for the following methods:\n",
        "82": " * <ul>\n",
        "83": " * <li>{@code incidentEdges}.\n",
        "84": " * <li>Methods that ask for adjacent nodes (e.g. {@code predecessors}).\n",
        "85": " * <li>{@code adjacentEdges}.\n",
        "86": " * <li>{@code edgesConnecting}.\n",
        "87": " * </ul>\n",
        "88": " * the view is calculated lazily and the backing set is <b>not</b> cached, so every time the user\n",
        "89": " * accesses the returned view, the backing set will be reconstructed again. If the user wants\n",
        "90": " * to avoid this, they should either use {@code ImmutableDirectedGraph}\n",
        "91": " * (if their input is not changing) or make a copy of the return value.\n",
        "93": " * <p>All other accessors have a time complexity of O(1), except for\n",
        "94": " * {@code degree(n)}, whose time complexity is linear in the minimum of\n",
        "95": " * the out-degree and in-degree of {@code n}, in case of allowing self-loop edges.\n",
        "96": " * This is due to a call to {@code edgesConnecting}.\n",
        "102": " * <li>{@code addEdge(E e, N n1, N n2)}: O(1), unless this graph is not a multigraph\n",
        "103": " * (does not support parallel edges). In such case, this method may call\n",
        "104": " * {@code edgesConnecting(n1, n2)}.\n",
        "105": " * <li>{@code removeNode(n)}: O(d), where d is the degree of the node {@code n}.\n",
        "115": " // TODO(b/24620028): Enable this class to support sorted nodes/edges.\n",
        "117": "  private final Map<N, DirectedIncidentEdges<E>> nodeToIncidentEdges;\n",
        "123": "    this.nodeToIncidentEdges =\n",
        "132": "    return Collections.unmodifiableSet(nodeToIncidentEdges.keySet());\n",
        "147": "    checkNotNull(node, \"node\");\n",
        "148": "    DirectedIncidentEdges<E> incidentEdges = nodeToIncidentEdges.get(node);\n",
        "149": "    checkArgument(incidentEdges != null, NODE_NOT_IN_GRAPH, node);\n",
        "150": "    return Sets.union(incidentEdges.inEdges(), incidentEdges.outEdges());\n",
        "154": "  public Set<N> incidentNodes(final Object edge) {\n",
        "155": "    checkNotNull(edge, \"edge\");\n",
        "157": "    DirectedIncidentNodes<N> endpoints = edgeToIncidentNodes.get(edge);\n",
        "158": "    checkArgument(endpoints != null, EDGE_NOT_IN_GRAPH, edge);\n",
        "159": "    return endpoints.asImmutableSet();\n",
        "169": "    checkNotNull(edge, \"edge\");\n",
        "170": "    DirectedIncidentNodes<N> endpoints = edgeToIncidentNodes.get(edge);\n",
        "171": "    checkArgument(endpoints != null, EDGE_NOT_IN_GRAPH, edge);\n",
        "172": "    return Sets.difference(\n",
        "173": "        Sets.union(incidentEdges(endpoints.target()), incidentEdges(endpoints.source())),\n",
        "174": "        ImmutableSet.of(edge));\n",
        "178": "   * Returns the intersection of these two sets, using {@code Sets.intersection}:\n",
        "183": "   * The first argument passed to {@code Sets.intersection} is the smaller of\n",
        "184": "   * the two sets.\n",
        "185": "   *\n",
        "186": "   * @see Sets#intersection\n",
        "190": "    checkNotNull(node1, \"node1\");\n",
        "191": "    checkNotNull(node2, \"node2\");\n",
        "192": "    DirectedIncidentEdges<E> incidentEdgesN1 = nodeToIncidentEdges.get(node1);\n",
        "193": "    checkArgument(incidentEdgesN1 != null, NODE_NOT_IN_GRAPH, node1);\n",
        "194": "    DirectedIncidentEdges<E> incidentEdgesN2 = nodeToIncidentEdges.get(node2);\n",
        "195": "    checkArgument(incidentEdgesN2 != null, NODE_NOT_IN_GRAPH, node2);\n",
        "196": "    Set<E> outEdges = incidentEdgesN1.outEdges();\n",
        "197": "    Set<E> inEdges = incidentEdgesN2.inEdges();\n",
        "198": "    return outEdges.size() <= inEdges.size()\n",
        "199": "        ? Sets.intersection(outEdges, inEdges)\n",
        "200": "        : Sets.intersection(inEdges, outEdges);\n",
        "205": "    checkNotNull(node, \"node\");\n",
        "206": "    DirectedIncidentEdges<E> incidentEdges = nodeToIncidentEdges.get(node);\n",
        "207": "    checkArgument(incidentEdges != null, NODE_NOT_IN_GRAPH, node);\n",
        "208": "    return Collections.unmodifiableSet(incidentEdges.inEdges());\n",
        "213": "    checkNotNull(node, \"node\");\n",
        "214": "    DirectedIncidentEdges<E> incidentEdges = nodeToIncidentEdges.get(node);\n",
        "215": "    checkArgument(incidentEdges != null, NODE_NOT_IN_GRAPH, node);\n",
        "216": "    return Collections.unmodifiableSet(incidentEdges.outEdges());\n",
        "221": "    checkNotNull(node, \"node\");\n",
        "222": "    DirectedIncidentEdges<E> incidentEdges = nodeToIncidentEdges.get(node);\n",
        "223": "    checkArgument(incidentEdges != null, NODE_NOT_IN_GRAPH, node);\n",
        "224": "    final Set<E> inEdges = incidentEdges.inEdges();\n",
        "225": "    return new SetView<N>() {\n",
        "226": "      @Override\n",
        "227": "      public boolean isEmpty() {\n",
        "228": "        return inEdges.isEmpty();\n",
        "229": "      }\n",
        "230": "\n",
        "231": "      @Override\n",
        "232": "      Set<N> elements() {\n",
        "233": "        Set<N> nodes = Sets.newLinkedHashSet();\n",
        "234": "        for (E edge : inEdges) {\n",
        "235": "          nodes.add(source(edge));\n",
        "236": "        }\n",
        "237": "        return nodes;\n",
        "238": "      }\n",
        "239": "    };\n",
        "244": "    checkNotNull(node, \"node\");\n",
        "245": "    DirectedIncidentEdges<E> incidentEdges = nodeToIncidentEdges.get(node);\n",
        "246": "    checkArgument(incidentEdges != null, NODE_NOT_IN_GRAPH, node);\n",
        "247": "    final Set<E> outEdges = incidentEdges.outEdges();\n",
        "248": "    return new SetView<N>() {\n",
        "249": "      @Override\n",
        "250": "      public boolean isEmpty() {\n",
        "251": "        return outEdges.isEmpty();\n",
        "252": "      }\n",
        "253": "\n",
        "254": "      @Override\n",
        "255": "      Set<N> elements() {\n",
        "256": "        Set<N> nodes = Sets.newLinkedHashSet();\n",
        "257": "        for (E edge : outEdges) {\n",
        "258": "          nodes.add(target(edge));\n",
        "259": "        }\n",
        "260": "        return nodes;\n",
        "261": "      }\n",
        "262": "    };\n",
        "267": "    checkNotNull(node, \"node\");\n",
        "268": "    return config.isSelfLoopsAllowed()\n",
        "269": "        ? inDegree(node) + outDegree(node) - edgesConnecting(node, node).size()\n",
        "270": "        : inDegree(node) + outDegree(node);\n",
        "275": "    checkNotNull(node, \"node\");\n",
        "276": "    DirectedIncidentEdges<E> incidentEdges = nodeToIncidentEdges.get(node);\n",
        "277": "    checkArgument(incidentEdges != null, NODE_NOT_IN_GRAPH, node);\n",
        "278": "    return incidentEdges.inEdges().size();\n",
        "283": "    checkNotNull(node, \"node\");\n",
        "284": "    DirectedIncidentEdges<E> incidentEdges = nodeToIncidentEdges.get(node);\n",
        "285": "    checkArgument(incidentEdges != null, NODE_NOT_IN_GRAPH, node);\n",
        "286": "    return incidentEdges.outEdges().size();\n",
        "291": "    checkNotNull(edge, \"edge\");\n",
        "292": "    DirectedIncidentNodes<N> endpoints = edgeToIncidentNodes.get(edge);\n",
        "293": "    checkArgument(endpoints != null, EDGE_NOT_IN_GRAPH, edge);\n",
        "294": "    return endpoints.source();\n",
        "299": "    checkNotNull(edge, \"edge\");\n",
        "300": "    DirectedIncidentNodes<N> endpoints = edgeToIncidentNodes.get(edge);\n",
        "301": "    checkArgument(endpoints != null, EDGE_NOT_IN_GRAPH, edge);\n",
        "302": "    return endpoints.target();\n",
        "311": "    if (containsNode(node)) {\n",
        "314": "    // TODO(user): Enable users to specify the expected number of neighbors\n",
        "315": "    // of a new node.\n",
        "316": "    nodeToIncidentEdges.put(node, DirectedIncidentEdges.<E>of());\n",
        "347": "    } else if (!config.isMultigraph() && containsNode(node1) && containsNode(node2)) {\n",
        "352": "    nodeToIncidentEdges.get(node1).outEdges().add(edge);\n",
        "354": "    nodeToIncidentEdges.get(node2).inEdges().add(edge);\n",
        "364": "    if (!containsNode(node)) {\n",
        "367": "    // Since views are returned, we need to copy the set of incident edges\n",
        "368": "    // to an equivalent collection to avoid removing the edges we are looping on.\n",
        "369": "    for (Object edge : incidentEdges(node).toArray()) {\n",
        "372": "    nodeToIncidentEdges.remove(node);\n",
        "385": "    nodeToIncidentEdges.get(endpoints.source()).outEdges().remove(edge);\n",
        "386": "    nodeToIncidentEdges.get(endpoints.target()).inEdges().remove(edge);\n",
        "393": "    return (other instanceof DirectedGraph) && Graphs.equal(this, (DirectedGraph) other);\n",
        "398": "    // This map encapsulates all of the structural relationships of this graph, so its hash code\n",
        "399": "    // is consistent with the above definition of equals().\n",
        "400": "    return nodeToIncidentEdges.hashCode();\n",
        "407": "        nodeToIncidentEdges.keySet(),\n",
        "411": "  private boolean containsNode(Object node) {\n",
        "412": "    return nodeToIncidentEdges.containsKey(node);\n"
    }
}