{
    "addition": {
        "22": " * TODO(b/30133524): Rewrite the top-level javadoc from scratch.\n",
        "23": " *\n",
        "28": " * <p>For convenience, we may use the term 'graph' refer to {@link BasicGraph}s and/or\n",
        "29": " * {@link Network}s.\n",
        "32": " * {@link MutableBasicGraph}.\n",
        "88": " * <li>There are no Node classes built in.  So you can have a {@code BasicGraph<Integer>}\n",
        "89": " *     or a {@code BasicGraph<Author>} or a {@code BasicGraph<Webpage>}.\n",
        "137": " * <li>Prefer extending {@link AbstractBasicGraph} over implementing {@link BasicGraph} directly.\n",
        "138": " *     This will ensure consistent {@link #equals(Object)} and {@link #hashCode()} across\n",
        "139": " *     implementations.\n",
        "171": "public interface BasicGraph<N> extends ValueGraph<N, BasicGraph.Presence> {\n",
        "174": "   * A placeholder for the (generally ignored) Value type of a {@link BasicGraph}. Users shouldn't\n",
        "175": "   * have to reference this enum unless they are implementing the {@link BasicGraph} interface.\n",
        "177": "  public enum Presence {\n",
        "178": "    EDGE_EXISTS\n",
        "179": "  }\n"
    },
    "removed": {
        "20": "import java.util.Set;\n",
        "21": "import javax.annotation.Nullable;\n",
        "28": " * <p>For convenience, we may use the term 'graph' refer to {@link Graph}s and/or {@link Network}s.\n",
        "31": " * {@link MutableGraph}.\n",
        "87": " * <li>There are no Node classes built in.  So you can have a {@code Graph<Integer>}\n",
        "88": " *     or a {@code Graph<Author>} or a {@code Graph<Webpage>}.\n",
        "136": " * <li>Prefer extending {@link AbstractGraph} over implementing {@link Graph} directly. This will\n",
        "137": " *     ensure consistent {@link #equals(Object)} and {@link #hashCode()} across implementations.\n",
        "169": "public interface Graph<N> {\n",
        "170": "  //\n",
        "171": "  // Graph-level accessors\n",
        "172": "  //\n",
        "173": "\n",
        "174": "  /**\n",
        "175": "   * Returns all nodes in this graph, in the order specified by {@link #nodeOrder()}.\n",
        "176": "   */\n",
        "177": "  Set<N> nodes();\n",
        "178": "\n",
        "179": "  /**\n",
        "180": "   * Returns all edges in this graph.\n",
        "181": "   */\n",
        "182": "  Set<Endpoints<N>> edges();\n",
        "183": "\n",
        "184": "  //\n",
        "185": "  // Graph properties\n",
        "186": "  //\n",
        "187": "\n",
        "188": "  /**\n",
        "189": "   * Returns true if the edges in this graph have a direction associated with them.\n",
        "190": "   */\n",
        "191": "  boolean isDirected();\n",
        "192": "\n",
        "193": "  /**\n",
        "194": "   * Returns true if this graph allows self-loops (edges that connect a node to itself).\n",
        "195": "   * Attempting to add a self-loop to a graph that does not allow them will throw an\n",
        "196": "   * {@link UnsupportedOperationException}.\n",
        "197": "   */\n",
        "198": "  boolean allowsSelfLoops();\n",
        "199": "\n",
        "200": "  /**\n",
        "201": "   * Returns the order of iteration for the elements of {@link #nodes()}.\n",
        "202": "   */\n",
        "203": "  ElementOrder<N> nodeOrder();\n",
        "204": "\n",
        "205": "  //\n",
        "206": "  // Element-level accessors\n",
        "207": "  //\n",
        "208": "\n",
        "209": "  /**\n",
        "210": "   * Returns the nodes which have an incident edge in common with {@code node} in this graph.\n",
        "211": "   *\n",
        "212": "   * @throws IllegalArgumentException if {@code node} is not an element of this graph\n",
        "213": "   */\n",
        "214": "  Set<N> adjacentNodes(Object node);\n",
        "215": "\n",
        "216": "  /**\n",
        "217": "   * Returns all nodes in this graph adjacent to {@code node} which can be reached by traversing\n",
        "218": "   * {@code node}'s incoming edges <i>against</i> the direction (if any) of the edge.\n",
        "219": "   *\n",
        "220": "   * @throws IllegalArgumentException if {@code node} is not an element of this graph\n",
        "221": "   */\n",
        "222": "  Set<N> predecessors(Object node);\n",
        "223": "\n",
        "224": "  /**\n",
        "225": "   * Returns all nodes in this graph adjacent to {@code node} which can be reached by traversing\n",
        "226": "   * {@code node}'s outgoing edges in the direction (if any) of the edge.\n",
        "227": "   *\n",
        "228": "   * <p>This is <i>not</i> the same as \"all nodes reachable from {@code node} by following outgoing\n",
        "229": "   * edges\". For that functionality, see {@link Graphs#reachableNodes(Graph, Object)} and\n",
        "230": "   * {@link Graphs#transitiveClosure(Graph)}.\n",
        "231": "   *\n",
        "232": "   * @throws IllegalArgumentException if {@code node} is not an element of this graph\n",
        "233": "   */\n",
        "234": "  Set<N> successors(Object node);\n",
        "235": "\n",
        "236": "  //\n",
        "237": "  // Graph identity\n",
        "238": "  //\n",
        "239": "\n",
        "240": "  /**\n",
        "241": "   * Returns {@code true} iff {@code object} is a {@link Graph} that has the same structural\n",
        "242": "   * relationships as those in this graph. Additionally, a {@link Graph} is defined to never be\n",
        "243": "   * equal to a {@link ValueGraph} (and vice versa).\n",
        "244": "   *\n",
        "245": "   * <p>Thus, two graphs A and B are equal if <b>all</b> of the following are true:\n",
        "246": "   * <ul>\n",
        "247": "   * <li>'A instanceof ValueGraph' and 'B instanceof ValueGraph' are equal.\n",
        "248": "   * <li>A and B have equal {@link #isDirected() directedness}.\n",
        "249": "   * <li>A and B have equal {@link #nodes() node sets}.\n",
        "250": "   * <li>A and B have equal {@link #edges() edge sets}.\n",
        "251": "   * </ul>\n",
        "252": "   *\n",
        "253": "   * <p>Graph properties besides {@link #isDirected() directedness} do <b>not</b> affect equality.\n",
        "254": "   * For example, two graphs may be considered equal even if one allows self-loops and the other\n",
        "255": "   * doesn't. Additionally, the order in which nodes or edges are added to the graph, and the order\n",
        "256": "   * in which they are iterated over, are irrelevant.\n",
        "257": "   *\n",
        "258": "   * <p>A reference implementation of this is provided by {@link AbstractGraph#equals(Object)}.\n",
        "259": "   */\n",
        "260": "  @Override\n",
        "261": "  boolean equals(@Nullable Object object);\n",
        "264": "   * Returns the hash code for this graph. The hash code of a graph is defined as the hash code of a\n",
        "265": "   * map from each of its {@link #nodes() nodes} to {@link #successors(Object) successor nodes}.\n",
        "266": "   *\n",
        "267": "   * <p>A reference implementation of this is provided by {@link AbstractGraph#hashCode()}.\n",
        "269": "  @Override\n",
        "270": "  int hashCode();\n"
    }
}