{"id": "ceee77fafdc9bdc5e2e6df85e231879c4ab6d755", "code": [{"0": "guava-tests/test/com/google/common/graph/AbstractDirectedGraphTest.java", "added": {"1": [" * Abstract base class for testing implementations of {@link BasicGraph} interface.\n", " * <p>This class is responsible for testing that a directed implementation of {@link BasicGraph}\n"]}, "removed": {"1": [" * Abstract base class for testing implementations of {@link Graph} interface.\n", " * <p>This class is responsible for testing that a directed implementation of {@link Graph}\n"]}, "added_lines": {"1": [26, 28]}, "removed_lines": {"1": [26, 28]}}, {"1": "guava-tests/test/com/google/common/graph/AbstractGraphTest.java", "added": {"1": [" * Abstract base class for testing implementations of {@link BasicGraph} interface. Graph\n"], "2": [" * <li>Test cases related to the specific implementation of the {@link BasicGraph} interface.\n", "  MutableBasicGraph<Integer> graph;\n"], "3": ["  public abstract MutableBasicGraph<Integer> createGraph();\n"], "4": ["  static <N> void validateGraph(ValueGraph<N, ?> graph) {\n", "    if (graph instanceof BasicGraph) {\n", "      @SuppressWarnings(\"unchecked\")\n", "      BasicGraph<N> basicGraph = (BasicGraph<N>) graph;\n", "          basicGraph,\n", "          Graphs.copyOf(basicGraph),\n", "          ImmutableBasicGraph.copyOf(basicGraph)).testEquals();\n"]}, "removed": {"1": [" * Abstract base class for testing implementations of {@link Graph} interface. Graph\n"], "2": [" * <li>Test cases related to the specific implementation of the {@link Graph} interface.\n", "  MutableGraph<Integer> graph;\n"], "3": ["  public abstract MutableGraph<Integer> createGraph();\n"], "4": ["  static <N> void validateGraph(Graph<N> graph) {\n", "    if (!(graph instanceof ValueGraph)) {\n", "          graph,\n", "          Graphs.copyOf(graph),\n", "          ImmutableGraph.copyOf(graph)).testEquals();\n"]}, "added_lines": {"1": [33], "2": [43, 50], "3": [74], "4": [125, 126, 127, 128, 130, 131, 132]}, "removed_lines": {"1": [33], "2": [43, 50], "3": [74], "4": [125, 126, 128, 129, 130]}}, {"2": "guava-tests/test/com/google/common/graph/AbstractNetworkTest.java", "added": {"1": ["    ValueGraph<Integer, Set<String>> asGraph = network.asGraph();\n"], "2": ["          assertThat(edgesConnecting).isEqualTo(asGraph.edgeValue(node, otherNode));\n"]}, "removed": {"1": ["    Graph<Integer> asGraph = network.asGraph();\n"]}, "added_lines": {"1": [160], "2": [218]}, "removed_lines": {"1": [160]}}, {"3": "guava-tests/test/com/google/common/graph/AbstractUndirectedGraphTest.java", "added": {"1": [" * Abstract base class for testing undirected implementations of the {@link BasicGraph} interface.\n", " * <p>This class is responsible for testing that an undirected implementation of {@link BasicGraph}\n"]}, "removed": {"1": [" * Abstract base class for testing undirected implementations of the {@link Graph} interface.\n", " * <p>This class is responsible for testing that an undirected implementation of {@link Graph}\n"]}, "added_lines": {"1": [28, 30]}, "removed_lines": {"1": [28, 30]}}, {"4": "guava-tests/test/com/google/common/graph/ConfigurableDirectedGraphTest.java", "added": {"1": [" * Tests for a directed {@link ConfigurableMutableBasicGraph} with default graph properties.\n", "  public MutableBasicGraph<Integer> createGraph() {\n", "    return BasicGraphBuilder.directed().build();\n"]}, "removed": {"1": [" * Tests for a directed {@link ConfigurableMutableGraph} with default graph properties.\n", "  public MutableGraph<Integer> createGraph() {\n", "    return GraphBuilder.directed().build();\n"]}, "added_lines": {"1": [28, 34, 35]}, "removed_lines": {"1": [28, 34, 35]}}, {"5": "guava-tests/test/com/google/common/graph/ConfigurableSimpleDirectedGraphTest.java", "added": {"1": [" * Tests for a directed {@link ConfigurableMutableBasicGraph}, creating a simple directed graph\n", "  public MutableBasicGraph<Integer> createGraph() {\n", "    return BasicGraphBuilder.directed().allowsSelfLoops(false).build();\n"]}, "removed": {"1": [" * Tests for a directed {@link ConfigurableMutableGraph}, creating a simple directed graph\n", "  public MutableGraph<Integer> createGraph() {\n", "    return GraphBuilder.directed().allowsSelfLoops(false).build();\n"]}, "added_lines": {"1": [29, 36, 37]}, "removed_lines": {"1": [29, 36, 37]}}, {"6": "guava-tests/test/com/google/common/graph/ConfigurableSimpleUndirectedGraphTest.java", "added": {"1": [" * Tests for an undirected {@link ConfigurableMutableBasicGraph}, creating a simple undirected\n", " * graph (parallel and self-loop edges are not allowed).\n", "  public MutableBasicGraph<Integer> createGraph() {\n", "    return BasicGraphBuilder.undirected().allowsSelfLoops(false).build();\n"]}, "removed": {"1": [" * Tests for an undirected {@link ConfigurableMutableGraph}, creating a simple undirected graph\n", " * (parallel and self-loop edges are not allowed).\n", "  public MutableGraph<Integer> createGraph() {\n", "    return GraphBuilder.undirected().allowsSelfLoops(false).build();\n"]}, "added_lines": {"1": [29, 30, 36, 37]}, "removed_lines": {"1": [29, 30, 36, 37]}}, {"7": "guava-tests/test/com/google/common/graph/ConfigurableUndirectedGraphTest.java", "added": {"1": [" * Tests for an undirected {@link ConfigurableMutableBasicGraph} with default graph properties.\n", "  public MutableBasicGraph<Integer> createGraph() {\n", "    return BasicGraphBuilder.undirected().build();\n"]}, "removed": {"1": [" * Tests for an undirected {@link ConfigurableMutableGraph} with default graph properties.\n", "  public MutableGraph<Integer> createGraph() {\n", "    return GraphBuilder.undirected().build();\n"]}, "added_lines": {"1": [28, 34, 35]}, "removed_lines": {"1": [28, 34, 35]}}, {"8": "guava-tests/test/com/google/common/graph/ElementOrderTest.java", "added": {"1": ["    MutableBasicGraph<Integer> graph = BasicGraphBuilder\n"], "2": ["    MutableBasicGraph<Integer> graph = BasicGraphBuilder\n"], "3": ["    MutableBasicGraph<Integer> graph = BasicGraphBuilder\n"], "4": ["    MutableBasicGraph<Integer> graph = BasicGraphBuilder\n"], "5": ["    MutableBasicGraph<Integer> graph = BasicGraphBuilder\n"], "6": ["    MutableBasicGraph<NonComparableSuperClass> graph = BasicGraphBuilder\n"], "7": ["    MutableBasicGraph<ComparableSubClass> graph = BasicGraphBuilder\n"], "8": ["  private static void addNodes(MutableBasicGraph<Integer> graph) {\n"]}, "removed": {"1": ["    MutableGraph<Integer> graph = GraphBuilder\n"], "2": ["    MutableGraph<Integer> graph = GraphBuilder\n"], "3": ["    MutableGraph<Integer> graph = GraphBuilder\n"], "4": ["    MutableGraph<Integer> graph = GraphBuilder\n"], "5": ["    MutableGraph<Integer> graph = GraphBuilder\n"], "6": ["    MutableGraph<NonComparableSuperClass> graph = GraphBuilder\n"], "7": ["    MutableGraph<ComparableSubClass> graph = GraphBuilder\n"], "8": ["  private static void addNodes(MutableGraph<Integer> graph) {\n"]}, "added_lines": {"1": [39], "2": [49], "3": [63], "4": [75], "5": [88], "6": [200], "7": [220], "8": [238]}, "removed_lines": {"1": [39], "2": [49], "3": [63], "4": [75], "5": [88], "6": [200], "7": [220], "8": [238]}}, {"9": "guava-tests/test/com/google/common/graph/EndpointsTest.java", "added": {"1": [" * Tests for {@link Endpoints} and {@link BasicGraph#edges()}.\n"], "2": ["    MutableBasicGraph<Integer> directedGraph = BasicGraphBuilder.directed().build();\n"], "3": ["    MutableBasicGraph<Integer> undirectedGraph = BasicGraphBuilder.undirected().build();\n"], "4": ["    MutableBasicGraph<Integer> directedGraph = BasicGraphBuilder.directed().build();\n"], "5": ["    MutableBasicGraph<Integer> undirectedGraph = BasicGraphBuilder.undirected().build();\n"]}, "removed": {"1": [" * Tests for {@link Endpoints} and {@link Graph#edges()}.\n"], "2": ["    MutableGraph<Integer> directedGraph = GraphBuilder.directed().build();\n"], "3": ["    MutableGraph<Integer> undirectedGraph = GraphBuilder.undirected().build();\n"], "4": ["    MutableGraph<Integer> directedGraph = GraphBuilder.directed().build();\n"], "5": ["    MutableGraph<Integer> undirectedGraph = GraphBuilder.undirected().build();\n"]}, "added_lines": {"1": [32], "2": [116], "3": [132], "4": [179], "5": [204]}, "removed_lines": {"1": [32], "2": [116], "3": [132], "4": [179], "5": [204]}}, {"10": "guava-tests/test/com/google/common/graph/GraphEqualsTest.java", "added": {"1": ["  private final MutableBasicGraph<Integer> graph;\n"], "2": ["  private static MutableBasicGraph<Integer> createGraph(GraphType graphType) {\n", "        return BasicGraphBuilder.undirected().build();\n", "        return BasicGraphBuilder.directed().build();\n"], "3": ["    MutableBasicGraph<Integer> g2 = createGraph(graphType);\n"], "4": ["    MutableBasicGraph<Integer> g2 = createGraph(oppositeType(graphType));\n"], "5": ["    MutableBasicGraph<Integer> g2 = createGraph(oppositeType(graphType));\n"], "6": ["    MutableBasicGraph<Integer> g2 = BasicGraphBuilder.from(graph)\n"], "7": ["    BasicGraphBuilder<Integer> builder = BasicGraphBuilder.from(graph);\n", "    MutableBasicGraph<Integer> g1 = builder.build();\n", "    MutableBasicGraph<Integer> g2 = builder.build();\n"], "8": ["    MutableBasicGraph<Integer> g2 = createGraph(graphType);\n"]}, "removed": {"1": ["  private final MutableGraph<Integer> graph;\n"], "2": ["  private static MutableGraph<Integer> createGraph(GraphType graphType) {\n", "        return GraphBuilder.undirected().build();\n", "        return GraphBuilder.directed().build();\n"], "3": ["    MutableGraph<Integer> g2 = createGraph(graphType);\n"], "4": ["    MutableGraph<Integer> g2 = createGraph(oppositeType(graphType));\n"], "5": ["    MutableGraph<Integer> g2 = createGraph(oppositeType(graphType));\n"], "6": ["    MutableGraph<Integer> g2 = GraphBuilder.from(graph)\n"], "7": ["    GraphBuilder<Integer> builder = GraphBuilder.from(graph);\n", "    MutableGraph<Integer> g1 = builder.build();\n", "    MutableGraph<Integer> g2 = builder.build();\n"], "8": ["    MutableGraph<Integer> g2 = createGraph(graphType);\n"]}, "added_lines": {"1": [42], "2": [55, 58, 60], "3": [81], "4": [92], "5": [103], "6": [115], "7": [127, 128, 129], "8": [146]}, "removed_lines": {"1": [42], "2": [55, 58, 60], "3": [81], "4": [92], "5": [103], "6": [115], "7": [127, 128, 129], "8": [146]}}, {"11": "guava-tests/test/com/google/common/graph/GraphPropertiesTest.java", "added": {"1": [" * Tests for {@link Graphs#hasCycle(ValueGraph)} and {@link Graphs#hasCycle(Network)}.\n", "  ImmutableList<MutableBasicGraph<Integer>> graphsToTest;\n", "  BasicGraph<Integer> directedGraph;\n", "  BasicGraph<Integer> undirectedGraph;\n"], "2": ["        BasicGraphBuilder.directed().<Integer>build(),\n", "        BasicGraphBuilder.undirected().<Integer>build());\n"], "3": ["    for (MutableBasicGraph<Integer> graph : graphsToTest) {\n"], "4": ["    for (MutableBasicGraph<Integer> graph : graphsToTest) {\n"], "5": ["    for (MutableBasicGraph<Integer> graph : graphsToTest) {\n"], "6": ["    for (MutableBasicGraph<Integer> graph : graphsToTest) {\n"], "7": ["    for (MutableBasicGraph<Integer> graph : graphsToTest) {\n"], "8": ["    for (MutableBasicGraph<Integer> graph : graphsToTest) {\n"], "9": ["    for (MutableBasicGraph<Integer> graph : graphsToTest) {\n"], "10": ["    for (MutableBasicGraph<Integer> graph : graphsToTest) {\n"], "11": ["    for (MutableBasicGraph<Integer> graph : graphsToTest) {\n"]}, "removed": {"1": [" * Tests for {@link Graphs#hasCycle(Graph)} and {@link Graphs#hasCycle(Network)}.\n", "  ImmutableList<MutableGraph<Integer>> graphsToTest;\n", "  Graph<Integer> directedGraph;\n", "  Graph<Integer> undirectedGraph;\n"], "2": ["        GraphBuilder.directed().<Integer>build(),\n", "        GraphBuilder.undirected().<Integer>build());\n"], "3": ["    for (MutableGraph<Integer> graph : graphsToTest) {\n"], "4": ["    for (MutableGraph<Integer> graph : graphsToTest) {\n"], "5": ["    for (MutableGraph<Integer> graph : graphsToTest) {\n"], "6": ["    for (MutableGraph<Integer> graph : graphsToTest) {\n"], "7": ["    for (MutableGraph<Integer> graph : graphsToTest) {\n"], "8": ["    for (MutableGraph<Integer> graph : graphsToTest) {\n"], "9": ["    for (MutableGraph<Integer> graph : graphsToTest) {\n"], "10": ["    for (MutableGraph<Integer> graph : graphsToTest) {\n"], "11": ["    for (MutableGraph<Integer> graph : graphsToTest) {\n"]}, "added_lines": {"1": [29, 34, 35, 36], "2": [45, 46], "3": [65], "4": [75], "5": [84], "6": [93], "7": [103], "8": [113], "9": [124], "10": [135], "11": [146]}, "removed_lines": {"1": [29, 34, 35, 36], "2": [45, 46], "3": [65], "4": [75], "5": [84], "6": [93], "7": [103], "8": [113], "9": [124], "10": [135], "11": [146]}}, {"12": "guava-tests/test/com/google/common/graph/GraphsTest.java", "added": {"1": ["    MutableBasicGraph<Integer> directedGraph =\n", "        BasicGraphBuilder.directed().allowsSelfLoops(false).build();\n", "    MutableBasicGraph<Integer> expectedClosure =\n", "        BasicGraphBuilder.directed().allowsSelfLoops(true).build();\n"], "2": ["    MutableBasicGraph<Integer> undirectedGraph =\n", "        BasicGraphBuilder.undirected().allowsSelfLoops(false).build();\n", "    MutableBasicGraph<Integer> expectedClosure =\n", "        BasicGraphBuilder.undirected().allowsSelfLoops(true).build();\n"], "3": ["    MutableBasicGraph<Integer> directedGraph =\n", "        BasicGraphBuilder.directed().allowsSelfLoops(false).build();\n", "    MutableBasicGraph<Integer> expectedClosure =\n", "        BasicGraphBuilder.directed().allowsSelfLoops(true).build();\n"], "4": ["    MutableBasicGraph<Integer> undirectedGraph =\n", "        BasicGraphBuilder.undirected().allowsSelfLoops(false).build();\n", "    MutableBasicGraph<Integer> expectedClosure =\n", "        BasicGraphBuilder.undirected().allowsSelfLoops(true).build();\n"], "5": ["    MutableBasicGraph<Integer> directedGraph =\n", "        BasicGraphBuilder.directed().allowsSelfLoops(false).build();\n", "    MutableBasicGraph<Integer> expectedClosure =\n", "        BasicGraphBuilder.directed().allowsSelfLoops(true).build();\n"], "6": ["    MutableBasicGraph<Integer> undirectedGraph =\n", "        BasicGraphBuilder.undirected().allowsSelfLoops(false).build();\n", "    MutableBasicGraph<Integer> expectedClosure =\n", "        BasicGraphBuilder.undirected().allowsSelfLoops(true).build();\n"], "7": ["    MutableBasicGraph<Integer> directedGraph = BasicGraphBuilder.directed().build();\n", "    MutableBasicGraph<Integer> expectedSubgraph = BasicGraphBuilder.directed().build();\n"], "8": ["      copyOf((BasicGraph<?>) null);\n"], "9": ["    BasicGraph<Integer> directedGraph = buildDirectedTestGraph();\n", "    BasicGraph<Integer> copy = copyOf(directedGraph);\n", "    BasicGraph<Integer> undirectedGraph = buildUndirectedTestGraph();\n", "    BasicGraph<Integer> copy = copyOf(undirectedGraph);\n"], "10": ["    ValueGraph<Integer, String> copy = copyOf(directedGraph);\n"], "11": ["    ValueGraph<Integer, String> copy = copyOf(undirectedGraph);\n"], "12": ["  private static <N> void checkTransitiveClosure(\n", "      BasicGraph<N> originalGraph, BasicGraph<N> expectedClosure) {\n", "  private static MutableBasicGraph<Integer> buildDirectedTestGraph() {\n", "    MutableBasicGraph<Integer> directedGraph =\n", "        BasicGraphBuilder.directed().allowsSelfLoops(true).build();\n"], "13": ["  private static MutableBasicGraph<Integer> buildUndirectedTestGraph() {\n", "    MutableBasicGraph<Integer> undirectedGraph =\n", "        BasicGraphBuilder.undirected().allowsSelfLoops(true).build();\n"]}, "removed": {"1": ["    MutableGraph<Integer> directedGraph = GraphBuilder.directed().allowsSelfLoops(false).build();\n", "    MutableGraph<Integer> expectedClosure = GraphBuilder.directed().allowsSelfLoops(true).build();\n"], "2": ["    MutableGraph<Integer> undirectedGraph =\n", "        GraphBuilder.undirected().allowsSelfLoops(false).build();\n", "    MutableGraph<Integer> expectedClosure = GraphBuilder.undirected().allowsSelfLoops(true).build();\n"], "3": ["    MutableGraph<Integer> directedGraph = GraphBuilder.directed().allowsSelfLoops(false).build();\n", "    MutableGraph<Integer> expectedClosure = GraphBuilder.directed().allowsSelfLoops(true).build();\n"], "4": ["    MutableGraph<Integer> undirectedGraph =\n", "        GraphBuilder.undirected().allowsSelfLoops(false).build();\n", "    MutableGraph<Integer> expectedClosure = GraphBuilder.undirected().allowsSelfLoops(true).build();\n"], "5": ["    MutableGraph<Integer> directedGraph = GraphBuilder.directed().allowsSelfLoops(false).build();\n", "    MutableGraph<Integer> expectedClosure = GraphBuilder.directed().allowsSelfLoops(true).build();\n"], "6": ["    MutableGraph<Integer> undirectedGraph =\n", "        GraphBuilder.undirected().allowsSelfLoops(false).build();\n", "    MutableGraph<Integer> expectedClosure = GraphBuilder.undirected().allowsSelfLoops(true).build();\n"], "7": ["    MutableGraph<Integer> directedGraph = GraphBuilder.directed().build();\n", "    MutableGraph<Integer> expectedSubgraph = GraphBuilder.directed().build();\n"], "8": ["      copyOf((Graph<?>) null);\n"], "9": ["    Graph<Integer> directedGraph = buildDirectedTestGraph();\n", "    Graph<Integer> copy = copyOf(directedGraph);\n", "    Graph<Integer> undirectedGraph = buildUndirectedTestGraph();\n", "    Graph<Integer> copy = copyOf(undirectedGraph);\n"], "10": ["    Graph<Integer> copy = copyOf(directedGraph);\n"], "11": ["    Graph<Integer> copy = copyOf(undirectedGraph);\n"], "12": ["  @Test\n", "  public void defaultImplementations_notValueGraph() {\n", "    assertThat(buildDirectedTestGraph()).isNotInstanceOf(ValueGraph.class);\n", "    assertThat(buildUndirectedTestGraph()).isNotInstanceOf(ValueGraph.class);\n", "    assertThat(ImmutableGraph.copyOf(buildDirectedTestGraph())).isNotInstanceOf(ValueGraph.class);\n", "    assertThat(ImmutableGraph.copyOf(buildUndirectedTestGraph())).isNotInstanceOf(ValueGraph.class);\n", "  }\n", "\n", "  private static <N> void checkTransitiveClosure(Graph<N> originalGraph, Graph<N> expectedClosure) {\n", "  private static MutableGraph<Integer> buildDirectedTestGraph() {\n", "    MutableGraph<Integer> directedGraph = GraphBuilder.directed().allowsSelfLoops(true).build();\n"], "13": ["  private static MutableGraph<Integer> buildUndirectedTestGraph() {\n", "    MutableGraph<Integer> undirectedGraph = GraphBuilder.undirected().allowsSelfLoops(true).build();\n"]}, "added_lines": {"1": [71, 72, 78, 79], "2": [93, 94, 100, 101], "3": [115, 116, 121, 122], "4": [139, 140, 145, 146], "5": [163, 164, 170, 171], "6": [194, 195, 201, 202], "7": [342, 349], "8": [409], "9": [417, 419, 425, 427], "10": [435], "11": [443], "12": [614, 615, 622, 623, 624], "13": [632, 633, 634]}, "removed_lines": {"1": [71, 77], "2": [91, 92, 98], "3": [112, 117], "4": [134, 135, 140], "5": [157, 163], "6": [186, 187, 193], "7": [333, 340], "8": [400], "9": [408, 410, 416, 418], "10": [426], "11": [434], "12": [605, 606, 607, 608, 609, 610, 611, 612, 613, 620, 621], "13": [629, 630]}}, {"13": "guava-tests/test/com/google/common/graph/ImmutableBasicGraphTest.java", "added": {"1": [" * Tests for {@link ImmutableBasicGraph}.\n", "public class ImmutableBasicGraphTest {\n", "    BasicGraph<String> graph1 =\n", "        ImmutableBasicGraph.copyOf(BasicGraphBuilder.directed().<String>build());\n", "    BasicGraph<String> graph2 = ImmutableBasicGraph.copyOf(graph1);\n"]}, "removed": {"1": [" * Tests for {@link ImmutableGraph}.\n", "public class ImmutableGraphTest {\n", "    Graph<String> graph1 = ImmutableGraph.copyOf(GraphBuilder.directed().<String>build());\n", "    Graph<String> graph2 = ImmutableGraph.copyOf(graph1);\n"]}, "added_lines": {"1": [26, 29, 33, 34, 35]}, "removed_lines": {"1": [26, 29, 33, 34]}}, {"14": "guava-tests/test/com/google/common/graph/PackageSanityTests.java", "added": {"1": ["      BasicGraphBuilder.directed().expectedNodeCount(10);\n", "  private static final ImmutableBasicGraph<String> IMMUTABLE_GRAPH_A = graphWithNode(\"A\");\n", "  private static final ImmutableBasicGraph<String> IMMUTABLE_GRAPH_B = graphWithNode(\"B\");\n"], "2": ["    setDistinctValues(BasicGraph.class, IMMUTABLE_GRAPH_A, IMMUTABLE_GRAPH_B);\n"], "3": ["  private static <N> ImmutableBasicGraph<N> graphWithNode(N node) {\n", "    MutableBasicGraph<N> graph = BasicGraphBuilder.directed().build();\n", "    return ImmutableBasicGraph.copyOf(graph);\n"]}, "removed": {"1": ["      GraphBuilder.directed().expectedNodeCount(10);\n", "  private static final ImmutableGraph<String> IMMUTABLE_GRAPH_A = graphWithNode(\"A\");\n", "  private static final ImmutableGraph<String> IMMUTABLE_GRAPH_B = graphWithNode(\"B\");\n"], "2": ["    setDistinctValues(Graph.class, IMMUTABLE_GRAPH_A, IMMUTABLE_GRAPH_B);\n"], "3": ["  private static <N> ImmutableGraph<N> graphWithNode(N node) {\n", "    MutableGraph<N> graph = GraphBuilder.directed().build();\n", "    return ImmutableGraph.copyOf(graph);\n"]}, "added_lines": {"1": [33, 37, 38], "2": [50], "3": [65, 66, 68]}, "removed_lines": {"1": [33, 37, 38], "2": [50], "3": [65, 66, 68]}}, {"15": "guava-tests/test/com/google/common/graph/ValueGraphTest.java", "added": {"1": ["    new EqualsTester().addEqualityGroup(\n", "        graph,\n", "        Graphs.copyOf(graph),\n", "        ImmutableValueGraph.copyOf(graph)).testEquals();\n"]}, "removed": {"1": ["    new EqualsTester()\n", "        .addEqualityGroup(\n", "            graph,\n", "            Graphs.copyOf(graph),\n", "            ImmutableValueGraph.copyOf(graph))\n", "        .addEqualityGroup(\n", "            Graphs.copyOf((Graph<Integer>) graph),\n", "            ImmutableGraph.copyOf(graph))\n", "        .testEquals();\n"]}, "added_lines": {"1": [38, 39, 40, 41]}, "removed_lines": {"1": [38, 39, 40, 41, 42, 43, 44, 45, 46]}}, {"16": "guava/src/com/google/common/graph/AbstractBasicGraph.java", "added": {"1": ["/*\n", " * Copyright (C) 2016 The Guava Authors\n", " *\n", " * Licensed under the Apache License, Version 2.0 (the \"License\");\n", " * you may not use this file except in compliance with the License.\n", " * You may obtain a copy of the License at\n", " *\n", " * http://www.apache.org/licenses/LICENSE-2.0\n", " *\n", " * Unless required by applicable law or agreed to in writing, software\n", " * distributed under the License is distributed on an \"AS IS\" BASIS,\n", " * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n", " * See the License for the specific language governing permissions and\n", " * limitations under the License.\n", " */\n", "\n", "package com.google.common.graph;\n", "\n", "import static com.google.common.graph.GraphConstants.GRAPH_STRING_FORMAT;\n", "\n", "import com.google.common.annotations.Beta;\n", "import com.google.common.graph.BasicGraph.Presence;\n", "\n", "/**\n", " * This class provides a skeletal implementation of {@link BasicGraph}. It is recommended to extend\n", " * this class rather than implement {@link BasicGraph} directly, to ensure consistent {@link\n", " * #equals(Object)} and {@link #hashCode()} results across different graph implementations.\n", " *\n", " * @author James Sexton\n", " * @param <N> Node parameter type\n", " * @since 20.0\n", " */\n", "@Beta\n", "public abstract class AbstractBasicGraph<N>\n", "    extends AbstractValueGraph<N, Presence> implements BasicGraph<N> {\n", "\n", "  /**\n", "   * Returns a string representation of this graph.\n", "   */\n", "  @Override\n", "  public String toString() {\n", "    String propertiesString = String.format(\n", "        \"isDirected: %s, allowsSelfLoops: %s\", isDirected(), allowsSelfLoops());\n", "    return String.format(GRAPH_STRING_FORMAT,\n", "        propertiesString,\n", "        nodes(),\n", "        edges());\n", "  }\n", "}\n"]}, "removed": {}, "added_lines": {"1": [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 49]}, "removed_lines": {}}, {"17": "guava/src/com/google/common/graph/AbstractGraph.java", "added": {}, "removed": {"1": ["/*\n", " * Copyright (C) 2016 The Guava Authors\n", " *\n", " * Licensed under the Apache License, Version 2.0 (the \"License\");\n", " * you may not use this file except in compliance with the License.\n", " * You may obtain a copy of the License at\n", " *\n", " * http://www.apache.org/licenses/LICENSE-2.0\n", " *\n", " * Unless required by applicable law or agreed to in writing, software\n", " * distributed under the License is distributed on an \"AS IS\" BASIS,\n", " * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n", " * See the License for the specific language governing permissions and\n", " * limitations under the License.\n", " */\n", "\n", "package com.google.common.graph;\n", "\n", "import static com.google.common.base.Preconditions.checkState;\n", "import static com.google.common.graph.GraphConstants.GRAPH_STRING_FORMAT;\n", "\n", "import com.google.common.annotations.Beta;\n", "import com.google.common.base.Function;\n", "import com.google.common.collect.Maps;\n", "import com.google.common.math.IntMath;\n", "import com.google.common.primitives.Ints;\n", "import java.util.AbstractSet;\n", "import java.util.Iterator;\n", "import java.util.Set;\n", "import javax.annotation.Nullable;\n", "\n", "/**\n", " * This class provides a skeletal implementation of {@link Graph}. It is recommended to extend this\n", " * class rather than implement {@link Graph} directly, to ensure consistent {@link #equals(Object)}\n", " * and {@link #hashCode()} results across different graph implementations.\n", " *\n", " * @author James Sexton\n", " * @param <N> Node parameter type\n", " * @since 20.0\n", " */\n", "@Beta\n", "public abstract class AbstractGraph<N> implements Graph<N> {\n", "\n", "  /**\n", "   * Returns the number of edges in this graph; used to calculate the size of {@link #edges()}.\n", "   * The default implementation is O(|N|). You can manually keep track of the number of edges and\n", "   * override this method for better performance.\n", "   */\n", "  protected long edgeCount() {\n", "    long degreeSum = 0L;\n", "    for (N node : nodes()) {\n", "      degreeSum += degree(this, node);\n", "    }\n", "    // According to the degree sum formula, this is equal to twice the number of edges.\n", "    checkState((degreeSum & 1) == 0);\n", "    return degreeSum >>> 1;\n", "  }\n", "\n", "  /**\n", "   * A reasonable default implementation of {@link Graph#edges()} defined in terms of\n", "   * {@link #nodes()} and {@link #successors(Object)}.\n", "   */\n", "  @Override\n", "  public Set<Endpoints<N>> edges() {\n", "    return new AbstractSet<Endpoints<N>>() {\n", "      @Override\n", "      public Iterator<Endpoints<N>> iterator() {\n", "        return EndpointsIterator.of(AbstractGraph.this);\n", "      }\n", "\n", "      @Override\n", "      public int size() {\n", "        return Ints.saturatedCast(edgeCount());\n", "      }\n", "\n", "      @Override\n", "      public boolean contains(Object obj) {\n", "        if (!(obj instanceof Endpoints)) {\n", "          return false;\n", "        }\n", "        Endpoints<?> endpoints = (Endpoints<?>) obj;\n", "        return isDirected() == endpoints.isDirected()\n", "            && nodes().contains(endpoints.nodeA())\n", "            && successors(endpoints.nodeA()).contains(endpoints.nodeB());\n", "      }\n", "    };\n", "  }\n", "\n", "  @Override\n", "  public boolean equals(@Nullable Object obj) {\n", "    if (obj == this) {\n", "      return true;\n", "    }\n", "    if (!(obj instanceof Graph)) {\n", "      return false;\n", "    }\n", "    Graph<?> other = (Graph<?>) obj;\n", "\n", "    return (this instanceof ValueGraph) == (other instanceof ValueGraph)\n", "        && isDirected() == other.isDirected()\n", "        && nodes().equals(other.nodes())\n", "        && edges().equals(other.edges());\n", "  }\n", "\n", "  @Override\n", "  public int hashCode() {\n", "    Function<N, Set<N>> nodeToSuccessors = new Function<N, Set<N>>() {\n", "      @Override\n", "      public Set<N> apply(N node) {\n", "        return successors(node);\n", "      }\n", "    };\n", "    return Maps.asMap(nodes(), nodeToSuccessors).hashCode();\n", "  }\n", "\n", "  /**\n", "   * Returns a string representation of this graph.\n", "   */\n", "  @Override\n", "  public String toString() {\n", "    String propertiesString = String.format(\n", "        \"isDirected: %s, allowsSelfLoops: %s\", isDirected(), allowsSelfLoops());\n", "    return String.format(GRAPH_STRING_FORMAT,\n", "        propertiesString,\n", "        nodes(),\n", "        edges());\n", "  }\n", "\n", "  /**\n", "   * Returns the number of times an edge touches {@code node} in {@code graph}. This is equivalent\n", "   * to the number of edges incident to {@code node} in the graph, with self-loops counting twice.\n", "   *\n", "   * <p>If this number is greater than {@code Integer.MAX_VALUE}, returns {@code Integer.MAX_VALUE}.\n", "   *\n", "   * @throws IllegalArgumentException if {@code node} is not an element of this graph\n", "   */\n", "  // TODO(b/30649235): What to do with this? Move to Graphs or interfaces? Provide in/outDegree?\n", "  private static int degree(Graph<?> graph, Object node) {\n", "    if (graph.isDirected()) {\n", "      return IntMath.saturatedAdd(graph.predecessors(node).size(), graph.successors(node).size());\n", "    } else {\n", "      int selfLoops = (graph.allowsSelfLoops() && graph.adjacentNodes(node).contains(node)) ? 1 : 0;\n", "      return IntMath.saturatedAdd(graph.adjacentNodes(node).size(), selfLoops);\n", "    }\n", "  }\n", "}\n"]}, "added_lines": {}, "removed_lines": {"1": [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 58, 59, 60, 61, 62, 63, 64, 65, 66, 67, 68, 69, 70, 71, 72, 73, 74, 75, 76, 77, 78, 79, 80, 81, 82, 83, 84, 85, 86, 87, 88, 89, 90, 91, 92, 93, 94, 95, 96, 97, 98, 99, 100, 101, 102, 103, 104, 105, 106, 107, 108, 109, 110, 111, 112, 113, 114, 115, 116, 117, 118, 119, 120, 121, 122, 123, 124, 125, 126, 127, 128, 129, 130, 131, 132, 133, 134, 135, 136, 137, 138, 139, 140, 141, 142, 143, 144, 145, 146]}}, {"18": "guava/src/com/google/common/graph/AbstractNetwork.java", "added": {"1": ["import static com.google.common.base.Preconditions.checkNotNull;\n"], "2": ["  public ValueGraph<N, Set<E>> asGraph() {\n", "    return new AbstractValueGraph<N, Set<E>>() {\n"], "3": ["\n", "      @Override\n", "      public Set<E> edgeValue(Object nodeA, Object nodeB) {\n", "        return checkNotNull(edgesConnecting(nodeA, nodeB));\n", "      }\n", "\n", "      @Override\n", "      public Set<E> edgeValueOrDefault(Object nodeA, Object nodeB, Set<E> defaultValue) {\n", "        return checkNotNull(edgesConnecting(nodeA, nodeB));\n", "      }\n"]}, "removed": {"2": ["  public Graph<N> asGraph() {\n", "    return new AbstractGraph<N>() {\n"]}, "added_lines": {"1": [19], "2": [45, 46], "3": [118, 119, 120, 121, 122, 123, 124, 125, 126, 127]}, "removed_lines": {"2": [44, 45]}}, {"19": "guava/src/com/google/common/graph/AbstractValueGraph.java", "added": {"1": ["import static com.google.common.base.Preconditions.checkState;\n", "import com.google.common.math.IntMath;\n", "import com.google.common.primitives.Ints;\n", "import java.util.AbstractSet;\n", "import java.util.Iterator;\n", "import java.util.Set;\n", " * #equals(Object)} and {@link #hashCode()} results across different graph implementations.\n"], "2": ["public abstract class AbstractValueGraph<N, V> implements ValueGraph<N, V> {\n", "  /**\n", "   * Returns the number of edges in this graph; used to calculate the size of {@link #edges()}.\n", "   * The default implementation is O(|N|). You can manually keep track of the number of edges and\n", "   * override this method for better performance.\n", "   */\n", "  protected long edgeCount() {\n", "    long degreeSum = 0L;\n", "    for (N node : nodes()) {\n", "      degreeSum += degree(this, node);\n", "    }\n", "    // According to the degree sum formula, this is equal to twice the number of edges.\n", "    checkState((degreeSum & 1) == 0);\n", "    return degreeSum >>> 1;\n", "  }\n", "\n", "  /**\n", "   * A reasonable default implementation of {@link ValueGraph#edges()} defined in terms of\n", "   * {@link #nodes()} and {@link #successors(Object)}.\n", "   */\n", "  @Override\n", "  public Set<Endpoints<N>> edges() {\n", "    return new AbstractSet<Endpoints<N>>() {\n", "      @Override\n", "      public Iterator<Endpoints<N>> iterator() {\n", "        return EndpointsIterator.of(AbstractValueGraph.this);\n", "      }\n", "\n", "      @Override\n", "      public int size() {\n", "        return Ints.saturatedCast(edgeCount());\n", "      }\n", "\n", "      @Override\n", "      public boolean contains(Object obj) {\n", "        if (!(obj instanceof Endpoints)) {\n", "          return false;\n", "        }\n", "        Endpoints<?> endpoints = (Endpoints<?>) obj;\n", "        return isDirected() == endpoints.isDirected()\n", "            && nodes().contains(endpoints.nodeA())\n", "            && successors(endpoints.nodeA()).contains(endpoints.nodeB());\n", "      }\n", "    };\n", "  }\n", "\n", "  @SuppressWarnings({\"unchecked\", \"rawtypes\"})\n"], "3": ["    for (Endpoints<N> edge : edges()) {\n"], "4": ["   * Returns a string representation of this graph.\n"], "5": ["\n", "  /**\n", "   * Returns the number of times an edge touches {@code node} in {@code graph}. This is equivalent\n", "   * to the number of edges incident to {@code node} in the graph, with self-loops counting twice.\n", "   *\n", "   * <p>If this number is greater than {@code Integer.MAX_VALUE}, returns {@code Integer.MAX_VALUE}.\n", "   *\n", "   * @throws IllegalArgumentException if {@code node} is not an element of this graph\n", "   */\n", "  // TODO(b/30649235): What to do with this? Move to Graphs or interfaces? Provide in/outDegree?\n", "  private static int degree(ValueGraph<?, ?> graph, Object node) {\n", "    if (graph.isDirected()) {\n", "      return IntMath.saturatedAdd(graph.predecessors(node).size(), graph.successors(node).size());\n", "    } else {\n", "      int selfLoops = (graph.allowsSelfLoops() && graph.adjacentNodes(node).contains(node)) ? 1 : 0;\n", "      return IntMath.saturatedAdd(graph.adjacentNodes(node).size(), selfLoops);\n", "    }\n", "  }\n"]}, "removed": {"1": [" * #equals(Object)} and {@link #hashCode()} results across different value graph implementations.\n"], "2": ["public abstract class AbstractValueGraph<N, V>\n", "    extends AbstractGraph<N> implements ValueGraph<N, V> {\n"], "3": ["    for (Endpoints<?> edge : edges()) {\n"], "4": ["   * Returns a string representation of this value graph.\n"]}, "added_lines": {"1": [19, 25, 26, 27, 28, 30, 36], "2": [44, 46, 47, 48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 58, 59, 60, 61, 62, 63, 64, 65, 66, 67, 68, 69, 70, 71, 72, 73, 74, 75, 76, 77, 78, 79, 80, 81, 82, 83, 84, 85, 86, 87, 88, 89, 90, 91], "3": [108], "4": [124], "5": [145, 146, 147, 148, 149, 150, 151, 152, 153, 154, 155, 156, 157, 158, 159, 160, 161, 162]}, "removed_lines": {"1": [30], "2": [38, 39], "3": [57], "4": [73]}}, {"20": "guava/src/com/google/common/graph/BasicGraph.java", "added": {"1": [" * TODO(b/30133524): Rewrite the top-level javadoc from scratch.\n", " *\n", " * <p>For convenience, we may use the term 'graph' refer to {@link BasicGraph}s and/or\n", " * {@link Network}s.\n", " * {@link MutableBasicGraph}.\n"], "2": [" * <li>There are no Node classes built in.  So you can have a {@code BasicGraph<Integer>}\n", " *     or a {@code BasicGraph<Author>} or a {@code BasicGraph<Webpage>}.\n"], "3": [" * <li>Prefer extending {@link AbstractBasicGraph} over implementing {@link BasicGraph} directly.\n", " *     This will ensure consistent {@link #equals(Object)} and {@link #hashCode()} across\n", " *     implementations.\n"], "4": ["public interface BasicGraph<N> extends ValueGraph<N, BasicGraph.Presence> {\n", "   * A placeholder for the (generally ignored) Value type of a {@link BasicGraph}. Users shouldn't\n", "   * have to reference this enum unless they are implementing the {@link BasicGraph} interface.\n", "  public enum Presence {\n", "    EDGE_EXISTS\n", "  }\n"]}, "removed": {"1": ["import java.util.Set;\n", "import javax.annotation.Nullable;\n", " * <p>For convenience, we may use the term 'graph' refer to {@link Graph}s and/or {@link Network}s.\n", " * {@link MutableGraph}.\n"], "2": [" * <li>There are no Node classes built in.  So you can have a {@code Graph<Integer>}\n", " *     or a {@code Graph<Author>} or a {@code Graph<Webpage>}.\n"], "3": [" * <li>Prefer extending {@link AbstractGraph} over implementing {@link Graph} directly. This will\n", " *     ensure consistent {@link #equals(Object)} and {@link #hashCode()} across implementations.\n"], "4": ["public interface Graph<N> {\n", "  //\n", "  // Graph-level accessors\n", "  //\n", "\n", "  /**\n", "   * Returns all nodes in this graph, in the order specified by {@link #nodeOrder()}.\n", "   */\n", "  Set<N> nodes();\n", "\n", "  /**\n", "   * Returns all edges in this graph.\n", "   */\n", "  Set<Endpoints<N>> edges();\n", "\n", "  //\n", "  // Graph properties\n", "  //\n", "\n", "  /**\n", "   * Returns true if the edges in this graph have a direction associated with them.\n", "   */\n", "  boolean isDirected();\n", "\n", "  /**\n", "   * Returns true if this graph allows self-loops (edges that connect a node to itself).\n", "   * Attempting to add a self-loop to a graph that does not allow them will throw an\n", "   * {@link UnsupportedOperationException}.\n", "   */\n", "  boolean allowsSelfLoops();\n", "\n", "  /**\n", "   * Returns the order of iteration for the elements of {@link #nodes()}.\n", "   */\n", "  ElementOrder<N> nodeOrder();\n", "\n", "  //\n", "  // Element-level accessors\n", "  //\n", "\n", "  /**\n", "   * Returns the nodes which have an incident edge in common with {@code node} in this graph.\n", "   *\n", "   * @throws IllegalArgumentException if {@code node} is not an element of this graph\n", "   */\n", "  Set<N> adjacentNodes(Object node);\n", "\n", "  /**\n", "   * Returns all nodes in this graph adjacent to {@code node} which can be reached by traversing\n", "   * {@code node}'s incoming edges <i>against</i> the direction (if any) of the edge.\n", "   *\n", "   * @throws IllegalArgumentException if {@code node} is not an element of this graph\n", "   */\n", "  Set<N> predecessors(Object node);\n", "\n", "  /**\n", "   * Returns all nodes in this graph adjacent to {@code node} which can be reached by traversing\n", "   * {@code node}'s outgoing edges in the direction (if any) of the edge.\n", "   *\n", "   * <p>This is <i>not</i> the same as \"all nodes reachable from {@code node} by following outgoing\n", "   * edges\". For that functionality, see {@link Graphs#reachableNodes(Graph, Object)} and\n", "   * {@link Graphs#transitiveClosure(Graph)}.\n", "   *\n", "   * @throws IllegalArgumentException if {@code node} is not an element of this graph\n", "   */\n", "  Set<N> successors(Object node);\n", "\n", "  //\n", "  // Graph identity\n", "  //\n", "\n", "  /**\n", "   * Returns {@code true} iff {@code object} is a {@link Graph} that has the same structural\n", "   * relationships as those in this graph. Additionally, a {@link Graph} is defined to never be\n", "   * equal to a {@link ValueGraph} (and vice versa).\n", "   *\n", "   * <p>Thus, two graphs A and B are equal if <b>all</b> of the following are true:\n", "   * <ul>\n", "   * <li>'A instanceof ValueGraph' and 'B instanceof ValueGraph' are equal.\n", "   * <li>A and B have equal {@link #isDirected() directedness}.\n", "   * <li>A and B have equal {@link #nodes() node sets}.\n", "   * <li>A and B have equal {@link #edges() edge sets}.\n", "   * </ul>\n", "   *\n", "   * <p>Graph properties besides {@link #isDirected() directedness} do <b>not</b> affect equality.\n", "   * For example, two graphs may be considered equal even if one allows self-loops and the other\n", "   * doesn't. Additionally, the order in which nodes or edges are added to the graph, and the order\n", "   * in which they are iterated over, are irrelevant.\n", "   *\n", "   * <p>A reference implementation of this is provided by {@link AbstractGraph#equals(Object)}.\n", "   */\n", "  @Override\n", "  boolean equals(@Nullable Object object);\n", "   * Returns the hash code for this graph. The hash code of a graph is defined as the hash code of a\n", "   * map from each of its {@link #nodes() nodes} to {@link #successors(Object) successor nodes}.\n", "   *\n", "   * <p>A reference implementation of this is provided by {@link AbstractGraph#hashCode()}.\n", "  @Override\n", "  int hashCode();\n"]}, "added_lines": {"1": [22, 23, 28, 29, 32], "2": [88, 89], "3": [137, 138, 139], "4": [171, 174, 175, 177, 178, 179]}, "removed_lines": {"1": [20, 21, 28, 31], "2": [87, 88], "3": [136, 137], "4": [169, 170, 171, 172, 173, 174, 175, 176, 177, 178, 179, 180, 181, 182, 183, 184, 185, 186, 187, 188, 189, 190, 191, 192, 193, 194, 195, 196, 197, 198, 199, 200, 201, 202, 203, 204, 205, 206, 207, 208, 209, 210, 211, 212, 213, 214, 215, 216, 217, 218, 219, 220, 221, 222, 223, 224, 225, 226, 227, 228, 229, 230, 231, 232, 233, 234, 235, 236, 237, 238, 239, 240, 241, 242, 243, 244, 245, 246, 247, 248, 249, 250, 251, 252, 253, 254, 255, 256, 257, 258, 259, 260, 261, 264, 265, 266, 267, 269, 270]}}, {"21": "guava/src/com/google/common/graph/BasicGraphBuilder.java", "added": {"1": [" * A builder for constructing instances of {@link BasicGraph} with user-defined properties.\n"], "2": ["public final class BasicGraphBuilder<N> extends AbstractGraphBuilder<N> {\n"], "3": ["  private BasicGraphBuilder(boolean directed) {\n", "   * Returns a {@link BasicGraphBuilder} for building directed graphs.\n", "  public static BasicGraphBuilder<Object> directed() {\n", "    return new BasicGraphBuilder<Object>(true);\n", "   * Returns a {@link BasicGraphBuilder} for building undirected graphs.\n", "  public static BasicGraphBuilder<Object> undirected() {\n", "    return new BasicGraphBuilder<Object>(false);\n", "   * Returns a {@link BasicGraphBuilder} initialized with all properties queryable from\n", "   * {@code graph}.\n", "   * <p>The \"queryable\" properties are those that are exposed through the {@link ValueGraph}\n", "   * interface, such as {@link ValueGraph#isDirected()}. Other properties, such as\n", "   * {@link #expectedNodeCount(int)}, are not set in the new builder.\n", "  public static <N> BasicGraphBuilder<N> from(ValueGraph<N, ?> graph) {\n", "    return new BasicGraphBuilder<Object>(graph.isDirected())\n"], "4": ["  public BasicGraphBuilder<N> allowsSelfLoops(boolean allowsSelfLoops) {\n"], "5": ["  public BasicGraphBuilder<N> expectedNodeCount(int expectedNodeCount) {\n"], "6": ["   * Specifies the order of iteration for the elements of {@link ValueGraph#nodes()}.\n", "  public <N1 extends N> BasicGraphBuilder<N1> nodeOrder(ElementOrder<N1> nodeOrder) {\n", "    BasicGraphBuilder<N1> newBuilder = cast();\n", "   * Returns an empty {@link MutableBasicGraph} with the properties of this\n", "   * {@link BasicGraphBuilder}.\n", "  public <N1 extends N> MutableBasicGraph<N1> build() {\n", "    return new ConfigurableMutableBasicGraph<N1>(this);\n", "  private <N1 extends N> BasicGraphBuilder<N1> cast() {\n", "    return (BasicGraphBuilder<N1>) this;\n"]}, "removed": {"1": [" * A builder for constructing instances of {@link Graph} with user-defined properties.\n"], "2": ["public final class GraphBuilder<N> extends AbstractGraphBuilder<N> {\n"], "3": ["  private GraphBuilder(boolean directed) {\n", "   * Returns a {@link GraphBuilder} for building directed graphs.\n", "  public static GraphBuilder<Object> directed() {\n", "    return new GraphBuilder<Object>(true);\n", "   * Returns a {@link GraphBuilder} for building undirected graphs.\n", "  public static GraphBuilder<Object> undirected() {\n", "    return new GraphBuilder<Object>(false);\n", "   * Returns a {@link GraphBuilder} initialized with all properties queryable from {@code graph}.\n", "   * <p>The \"queryable\" properties are those that are exposed through the {@link Graph} interface,\n", "   * such as {@link Graph#isDirected()}. Other properties, such as {@link #expectedNodeCount(int)},\n", "   * are not set in the new builder.\n", "  public static <N> GraphBuilder<N> from(Graph<N> graph) {\n", "    return new GraphBuilder<Object>(graph.isDirected())\n"], "4": ["  public GraphBuilder<N> allowsSelfLoops(boolean allowsSelfLoops) {\n"], "5": ["  public GraphBuilder<N> expectedNodeCount(int expectedNodeCount) {\n"], "6": ["   * Specifies the order of iteration for the elements of {@link Graph#nodes()}.\n", "  public <N1 extends N> GraphBuilder<N1> nodeOrder(ElementOrder<N1> nodeOrder) {\n", "    GraphBuilder<N1> newBuilder = cast();\n", "   * Returns an empty {@link MutableGraph} with the properties of this {@link GraphBuilder}.\n", "  public <N1 extends N> MutableGraph<N1> build() {\n", "    return new ConfigurableMutableGraph<N1>(this);\n", "  private <N1 extends N> GraphBuilder<N1> cast() {\n", "    return (GraphBuilder<N1>) this;\n"]}, "added_lines": {"1": [26], "2": [39], "3": [47, 52, 54, 55, 59, 61, 62, 66, 67, 69, 70, 71, 73, 75], "4": [85], "5": [95], "6": [103, 105, 107, 113, 114, 116, 117, 121, 122]}, "removed_lines": {"1": [26], "2": [39], "3": [47, 52, 54, 55, 59, 61, 62, 66, 68, 69, 70, 72, 74], "4": [84], "5": [94], "6": [102, 104, 106, 112, 114, 115, 119, 120]}}, {"22": "guava/src/com/google/common/graph/ConfigurableMutableBasicGraph.java", "added": {"1": ["/*\n", " * Copyright (C) 2016 The Guava Authors\n", " *\n", " * Licensed under the Apache License, Version 2.0 (the \"License\");\n", " * you may not use this file except in compliance with the License.\n", " * You may obtain a copy of the License at\n", " *\n", " * http://www.apache.org/licenses/LICENSE-2.0\n", " *\n", " * Unless required by applicable law or agreed to in writing, software\n", " * distributed under the License is distributed on an \"AS IS\" BASIS,\n", " * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n", " * See the License for the specific language governing permissions and\n", " * limitations under the License.\n", " */\n", "\n", "package com.google.common.graph;\n", "\n", "import java.util.Set;\n", "\n", "/**\n", " * Configurable implementation of {@link MutableBasicGraph} that supports both directed and\n", " * undirected graphs. Instances of this class should be constructed with {@link BasicGraphBuilder}.\n", " *\n", " * <p>Time complexities for mutation methods are all O(1) except for {@code removeNode(N node)},\n", " * which is in O(d_node) where d_node is the degree of {@code node}.\n", " *\n", " * @author James Sexton\n", " * @param <N> Node parameter type\n", " */\n", "final class ConfigurableMutableBasicGraph<N>\n", "    extends AbstractBasicGraph<N> implements MutableBasicGraph<N> {\n", "  private final MutableValueGraph<N, Presence> backingGraph;\n", "\n", "  /**\n", "   * Constructs a {@link MutableBasicGraph} with the properties specified in {@code builder}.\n", "   */\n", "  ConfigurableMutableBasicGraph(AbstractGraphBuilder<? super N> builder) {\n", "    this.backingGraph = new ConfigurableMutableValueGraph<N, Presence>(builder);\n", "  }\n", "\n", "  @Override\n", "  public Set<N> nodes() {\n", "    return backingGraph.nodes();\n", "  }\n", "\n", "  @Override\n", "  public Set<Endpoints<N>> edges() {\n", "    return backingGraph.edges();\n", "  }\n", "\n", "  @Override\n", "  public boolean isDirected() {\n", "    return backingGraph.isDirected();\n", "  }\n", "\n", "  @Override\n", "  public boolean allowsSelfLoops() {\n", "    return backingGraph.allowsSelfLoops();\n", "  }\n", "\n", "  @Override\n", "  public ElementOrder<N> nodeOrder() {\n", "    return backingGraph.nodeOrder();\n", "  }\n", "\n", "  @Override\n", "  public Set<N> adjacentNodes(Object node) {\n", "    return backingGraph.adjacentNodes(node);\n", "  }\n", "\n", "  @Override\n", "  public Set<N> predecessors(Object node) {\n", "    return backingGraph.predecessors(node);\n", "  }\n", "\n", "  @Override\n", "  public Set<N> successors(Object node) {\n", "    return backingGraph.successors(node);\n", "  }\n", "\n", "  @Override\n", "  public Presence edgeValue(Object nodeA, Object nodeB) {\n", "    return backingGraph.edgeValue(nodeA, nodeB);\n", "  }\n", "\n", "  @Override\n", "  public Presence edgeValueOrDefault(Object nodeA, Object nodeB, Presence defaultValue) {\n", "    return backingGraph.edgeValueOrDefault(nodeA, nodeB, defaultValue);\n", "  }\n", "\n", "  @Override\n", "  public boolean addNode(N node) {\n", "    return backingGraph.addNode(node);\n", "  }\n", "\n", "  @Override\n", "  public boolean putEdge(N nodeA, N nodeB) {\n", "    return backingGraph.putEdgeValue(nodeA, nodeB, Presence.EDGE_EXISTS) == null;\n", "  }\n", "\n", "  @Override\n", "  public boolean removeNode(Object node) {\n", "    return backingGraph.removeNode(node);\n", "  }\n", "\n", "  @Override\n", "  public boolean removeEdge(Object nodeA, Object nodeB) {\n", "    return backingGraph.removeEdge(nodeA, nodeB) != null;\n", "  }\n", "}\n"]}, "removed": {}, "added_lines": {"1": [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 58, 59, 60, 61, 62, 63, 64, 65, 66, 67, 68, 69, 70, 71, 72, 73, 74, 75, 76, 77, 78, 79, 80, 81, 82, 83, 84, 85, 86, 87, 88, 89, 90, 91, 92, 93, 94, 95, 96, 97, 98, 99, 100, 101, 102, 103, 104, 105, 106, 107, 108, 109, 110, 111]}, "removed_lines": {}}, {"23": "guava/src/com/google/common/graph/ConfigurableMutableGraph.java", "added": {}, "removed": {"1": ["/*\n", " * Copyright (C) 2016 The Guava Authors\n", " *\n", " * Licensed under the Apache License, Version 2.0 (the \"License\");\n", " * you may not use this file except in compliance with the License.\n", " * You may obtain a copy of the License at\n", " *\n", " * http://www.apache.org/licenses/LICENSE-2.0\n", " *\n", " * Unless required by applicable law or agreed to in writing, software\n", " * distributed under the License is distributed on an \"AS IS\" BASIS,\n", " * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n", " * See the License for the specific language governing permissions and\n", " * limitations under the License.\n", " */\n", "\n", "package com.google.common.graph;\n", "\n", "/**\n", " * Configurable implementation of {@link MutableGraph} that supports both directed and undirected\n", " * graphs. Instances of this class should be constructed with {@link GraphBuilder}.\n", " *\n", " * <p>Time complexities for mutation methods are all O(1) except for {@code removeNode(N node)},\n", " * which is in O(d_node) where d_node is the degree of {@code node}.\n", " *\n", " * @author James Sexton\n", " * @param <N> Node parameter type\n", " */\n", "final class ConfigurableMutableGraph<N> extends ForwardingGraph<N> implements MutableGraph<N> {\n", "  private static final Object DUMMY_EDGE_VALUE = new Object();\n", "\n", "  private final MutableValueGraph<N, Object> backingGraph;\n", "\n", "  /**\n", "   * Constructs a {@link MutableGraph} with the properties specified in {@code builder}.\n", "   */\n", "  ConfigurableMutableGraph(AbstractGraphBuilder<? super N> builder) {\n", "    this.backingGraph = new ConfigurableMutableValueGraph<N, Object>(builder);\n", "  }\n", "\n", "  @Override\n", "  public boolean addNode(N node) {\n", "    return backingGraph.addNode(node);\n", "  }\n", "\n", "  @Override\n", "  public boolean putEdge(N nodeA, N nodeB) {\n", "    return backingGraph.putEdgeValue(nodeA, nodeB, DUMMY_EDGE_VALUE) == null;\n", "  }\n", "\n", "  @Override\n", "  public boolean removeNode(Object node) {\n", "    return backingGraph.removeNode(node);\n", "  }\n", "\n", "  @Override\n", "  public boolean removeEdge(Object nodeA, Object nodeB) {\n", "    return backingGraph.removeEdge(nodeA, nodeB) != null;\n", "  }\n", "\n", "  @Override\n", "  protected Graph<N> delegate() {\n", "    return backingGraph;\n", "  }\n", "}\n"]}, "added_lines": {}, "removed_lines": {"1": [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 58, 59, 60, 61, 62, 63, 64, 65]}}, {"24": "guava/src/com/google/common/graph/ConfigurableNetwork.java", "added": {}, "removed": {"1": ["  /**\n", "   * {@inheritDoc}\n", "   *\n", "   * <p>The order of iteration for this set is determined by the {@code ElementOrder<N>} provided\n", "   * to the {@code GraphBuilder} that was used to create this instance.\n", "   * By default, that order is the order in which the nodes were added to the graph.\n", "   */\n", "  /**\n", "   * {@inheritDoc}\n", "   *\n", "   * <p>The order of iteration for this set is determined by the {@code ElementOrder<E>} provided\n", "   * to the {@code GraphBuilder} that was used to create this instance.\n", "   * By default, that order is the order in which the edges were added to the graph.\n", "   */\n"]}, "added_lines": {}, "removed_lines": {"1": [104, 105, 106, 107, 108, 109, 110, 116, 117, 118, 119, 120, 121, 122]}}, {"25": "guava/src/com/google/common/graph/ConfigurableValueGraph.java", "added": {}, "removed": {"1": ["  /**\n", "   * {@inheritDoc}\n", "   *\n", "   * <p>The order of iteration for this set is determined by the {@code ElementOrder<N>} provided\n", "   * to the {@code GraphBuilder} that was used to create this instance.\n", "   * By default, that order is the order in which the nodes were added to the graph.\n", "   */\n"]}, "added_lines": {}, "removed_lines": {"1": [92, 93, 94, 95, 96, 97, 98]}}, {"26": "guava/src/com/google/common/graph/ElementOrder.java", "added": {"1": [" *   MutableBasicGraph<Integer> graph\n", " *       = BasicGraphBuilder.directed().nodeOrder(ElementOrder.<Integer>natural()).build();\n"]}, "removed": {"1": [" *   MutableGraph<Integer> graph\n", " *       = GraphBuilder.directed().nodeOrder(ElementOrder.<Integer>natural()).build();\n"]}, "added_lines": {"1": [36, 37]}, "removed_lines": {"1": [36, 37]}}, {"27": "guava/src/com/google/common/graph/Endpoints.java", "added": {"1": ["  public static <N> Endpoints<N> of(ValueGraph<?, ?> graph, N nodeA, N nodeB) {\n"]}, "removed": {"1": ["  public static <N> Endpoints<N> of(Graph<?> graph, N nodeA, N nodeB) {\n"]}, "added_lines": {"1": [46]}, "removed_lines": {"1": [46]}}, {"28": "guava/src/com/google/common/graph/EndpointsIterator.java", "added": {"1": [" * A class to facilitate the set returned by {@link ValueGraph#edges()}.\n", "  private final ValueGraph<N, ?> graph;\n", "  static <N> EndpointsIterator<N> of(ValueGraph<N, ?> graph) {\n", "  EndpointsIterator(ValueGraph<N, ?> graph) {\n"], "2": ["    Directed(ValueGraph<N, ?> graph){\n"], "3": ["    Undirected(ValueGraph<N, ?> graph) {\n"]}, "removed": {"1": [" * A class to facilitate the set returned by {@link Graph#edges()}.\n", "  private final Graph<N> graph;\n", "  static <N> EndpointsIterator<N> of(Graph<N> graph) {\n", "  EndpointsIterator(Graph<N> graph) {\n"], "2": ["    Directed(Graph<N> graph){\n"], "3": ["    Undirected(Graph<N> graph) {\n"]}, "added_lines": {"1": [28, 34, 40, 44], "2": [68], "3": [112]}, "removed_lines": {"1": [28, 34, 40, 44], "2": [68], "3": [112]}}, {"29": "guava/src/com/google/common/graph/ForwardingGraph.java", "added": {}, "removed": {"1": ["/*\n", " * Copyright (C) 2016 The Guava Authors\n", " *\n", " * Licensed under the Apache License, Version 2.0 (the \"License\");\n", " * you may not use this file except in compliance with the License.\n", " * You may obtain a copy of the License at\n", " *\n", " * http://www.apache.org/licenses/LICENSE-2.0\n", " *\n", " * Unless required by applicable law or agreed to in writing, software\n", " * distributed under the License is distributed on an \"AS IS\" BASIS,\n", " * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n", " * See the License for the specific language governing permissions and\n", " * limitations under the License.\n", " */\n", "\n", "package com.google.common.graph;\n", "\n", "import java.util.Set;\n", "\n", "/**\n", " * A {@link Graph} which forwards its method calls (except equals/hashCode/toString, which instead\n", " * it inherits from AbstractGraph) to another {@link Graph}.\n", " * \n", " * <p>Currently used to allow {@link Graph}s to be implemented via {ValueGraph}s.\n", " *\n", " * @author James Sexton\n", " * @since 20.0\n", " */\n", "abstract class ForwardingGraph<N> extends AbstractGraph<N> implements Graph<N> {\n", "\n", "  protected abstract Graph<N> delegate();\n", "\n", "  @Override\n", "  public Set<N> nodes() {\n", "    return delegate().nodes();\n", "  }\n", "\n", "  @Override\n", "  public Set<Endpoints<N>> edges() {\n", "    return delegate().edges();\n", "  }\n", "\n", "  @Override\n", "  public boolean isDirected() {\n", "    return delegate().isDirected();\n", "  }\n", "\n", "  @Override\n", "  public boolean allowsSelfLoops() {\n", "    return delegate().allowsSelfLoops();\n", "  }\n", "\n", "  @Override\n", "  public ElementOrder<N> nodeOrder() {\n", "    return delegate().nodeOrder();\n", "  }\n", "\n", "  @Override\n", "  public Set<N> adjacentNodes(Object node) {\n", "    return delegate().adjacentNodes(node);\n", "  }\n", "\n", "  @Override\n", "  public Set<N> predecessors(Object node) {\n", "    return delegate().predecessors(node);\n", "  }\n", "\n", "  @Override\n", "  public Set<N> successors(Object node) {\n", "    return delegate().successors(node);\n", "  }\n", "}\n", "\n"]}, "added_lines": {}, "removed_lines": {"1": [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 58, 59, 60, 61, 62, 63, 64, 65, 66, 67, 68, 69, 70, 71, 72, 73, 74]}}, {"30": "guava/src/com/google/common/graph/Graphs.java", "added": {"1": [" * Static utility methods for {@link ValueGraph} and {@link Network} instances.\n"], "2": ["  public static boolean hasCycle(ValueGraph<?, ?> graph) {\n"], "3": ["      ValueGraph<?, ?> graph,\n"], "4": ["      ValueGraph<?, ?> graph, Object nextNode, @Nullable Object previousNode) {\n"], "5": ["   * graph with an edge connecting node A to node B iff node B is {@link #reachableNodes(ValueGraph,\n", "   * <p>This is a \"snapshot\" based on the current topology of {@code graph}, rather than a live view\n", "   * of the transitive closure of {@code graph}. In other words, the returned {@link BasicGraph}\n", "  public static <N> BasicGraph<N> transitiveClosure(ValueGraph<N, ?> graph) {\n", "    MutableBasicGraph<N> transitiveClosure =\n", "        BasicGraphBuilder.from(graph).allowsSelfLoops(true).build();\n"], "6": ["   * <p>This is a \"snapshot\" based on the current topology of {@code graph}, rather than a live view\n", "   * of the set of nodes reachable from {@code node}. In other words, the returned {@link Set} will\n", "   * not be updated after modifications to {@code graph}.\n", "  public static <N> Set<N> reachableNodes(ValueGraph<N, ?> graph, Object node) {\n"], "7": ["   * all of the nodes in {@code nodes}, and all of the {@link ValueGraph#edges() edges} from {@code\n", "  public static <N> MutableBasicGraph<N> inducedSubgraph(BasicGraph<N> graph,\n", "      Iterable<? extends N> nodes) {\n", "    MutableBasicGraph<N> subgraph = BasicGraphBuilder.from(graph).build();\n"], "8": ["   * all of the nodes in {@code nodes}, and all of the {@link ValueGraph#edges() edges} (and\n", "   * associated edge values) from {@code graph} for which the endpoints are both contained by\n", "   * {@code nodes}.\n"], "9": ["  public static <N> MutableBasicGraph<N> copyOf(BasicGraph<N> graph) {\n", "    MutableBasicGraph<N> copy = BasicGraphBuilder.from(graph)\n"]}, "removed": {"1": [" * Static utility methods for {@link Graph} instances.\n"], "2": ["  public static boolean hasCycle(Graph<?> graph) {\n"], "3": ["      Graph<?> graph,\n"], "4": ["      Graph<?> graph, Object nextNode, @Nullable Object previousNode) {\n"], "5": ["   * graph with an edge connecting node A to node B iff node B is {@link #reachableNodes(Graph,\n", "   * <p>This is a \"snapshot\" based on the current topology of {@code graph}, rather than a live\n", "   * view of the transitive closure of {@code graph}. In other words, the returned {@link Graph}\n", "  public static <N> Graph<N> transitiveClosure(Graph<N> graph) {\n", "    MutableGraph<N> transitiveClosure = GraphBuilder.from(graph).allowsSelfLoops(true).build();\n"], "6": ["   * <p>This is a \"snapshot\" based on the current topology of {@code graph}, rather than a live\n", "   * view of the set of nodes reachable from {@code node}. In other words, the returned {@link Set}\n", "   * will not be updated after modifications to {@code graph}.\n", "  public static <N> Set<N> reachableNodes(Graph<N> graph, Object node) {\n"], "7": ["   * all of the nodes in {@code nodes}, and all of the {@link Graph#edges() edges} from {@code\n", "  public static <N> MutableGraph<N> inducedSubgraph(Graph<N> graph, Iterable<? extends N> nodes) {\n", "    MutableGraph<N> subgraph = GraphBuilder.from(graph).build();\n"], "8": ["   * all of the nodes in {@code nodes}, and all of the {@link Graph#edges() edges} (and associated\n", "   * edge values) from {@code graph} for which the endpoints are both contained by {@code nodes}.\n"], "9": ["  public static <N> MutableGraph<N> copyOf(Graph<N> graph) {\n", "    MutableGraph<N> copy = GraphBuilder.from(graph)\n"]}, "added_lines": {"1": [38], "2": [58], "3": [100], "4": [130], "5": [141, 144, 145, 148, 149, 150], "6": [188, 189, 190, 195], "7": [247, 252, 253, 254], "8": [270, 271, 272], "9": [319, 320]}, "removed_lines": {"1": [38], "2": [58], "3": [100], "4": [130], "5": [141, 144, 145, 148, 149], "6": [187, 188, 189, 194], "7": [246, 251, 252], "8": [268, 269], "9": [316, 317]}}, {"31": "guava/src/com/google/common/graph/ImmutableBasicGraph.java", "added": {"1": ["/*\n", " * Copyright (C) 2014 The Guava Authors\n", " *\n", " * Licensed under the Apache License, Version 2.0 (the \"License\");\n", " * you may not use this file except in compliance with the License.\n", " * You may obtain a copy of the License at\n", " *\n", " * http://www.apache.org/licenses/LICENSE-2.0\n", " *\n", " * Unless required by applicable law or agreed to in writing, software\n", " * distributed under the License is distributed on an \"AS IS\" BASIS,\n", " * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n", " * See the License for the specific language governing permissions and\n", " * limitations under the License.\n", " */\n", "\n", "package com.google.common.graph;\n", "\n", "import static com.google.common.base.Preconditions.checkNotNull;\n", "\n", "import com.google.common.annotations.Beta;\n", "import com.google.common.graph.BasicGraph.Presence;\n", "\n", "/**\n", " * A {@link BasicGraph} whose relationships are constant. Instances of this class may be obtained\n", " * with {@link #copyOf(BasicGraph)}.\n", " *\n", " * @author James Sexton\n", " * @author Joshua O'Madadhain\n", " * @author Omar Darwish\n", " * @param <N> Node parameter type\n", " * @since 20.0\n", " */\n", "@Beta\n", "public class ImmutableBasicGraph<N>\n", "    extends ImmutableValueGraph<N, Presence> implements BasicGraph<N> {\n", "\n", "  private ImmutableBasicGraph(BasicGraph<N> graph) {\n", "    super(graph);\n", "  }\n", "\n", "  /**\n", "   * Returns an immutable copy of {@code graph}.\n", "   */\n", "  @SuppressWarnings(\"unchecked\")\n", "  public static <N> ImmutableBasicGraph<N> copyOf(BasicGraph<N> graph) {\n", "    return (graph instanceof ImmutableBasicGraph)\n", "        ? (ImmutableBasicGraph<N>) graph\n", "        : new ImmutableBasicGraph<N>(graph);\n", "  }\n", "\n", "  /**\n", "   * Simply returns its argument.\n", "   *\n", "   * @deprecated no need to use this\n", "   */\n", "  @Deprecated\n", "  public static <N> ImmutableBasicGraph<N> copyOf(ImmutableBasicGraph<N> graph) {\n", "    return checkNotNull(graph);\n", "  }\n", "}\n"]}, "removed": {}, "added_lines": {"1": [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 58, 59, 60, 61]}, "removed_lines": {}}, {"32": "guava/src/com/google/common/graph/ImmutableGraph.java", "added": {}, "removed": {"1": ["/*\n", " * Copyright (C) 2014 The Guava Authors\n", " *\n", " * Licensed under the Apache License, Version 2.0 (the \"License\");\n", " * you may not use this file except in compliance with the License.\n", " * You may obtain a copy of the License at\n", " *\n", " * http://www.apache.org/licenses/LICENSE-2.0\n", " *\n", " * Unless required by applicable law or agreed to in writing, software\n", " * distributed under the License is distributed on an \"AS IS\" BASIS,\n", " * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n", " * See the License for the specific language governing permissions and\n", " * limitations under the License.\n", " */\n", "\n", "package com.google.common.graph;\n", "\n", "import static com.google.common.base.Preconditions.checkNotNull;\n", "\n", "import com.google.common.annotations.Beta;\n", "import com.google.common.base.Functions;\n", "import com.google.common.collect.ImmutableMap;\n", "import com.google.common.collect.Maps;\n", "\n", "/**\n", " * A {@link Graph} whose relationships are constant. Instances of this class may be obtained\n", " * with {@link #copyOf(Graph)}.\n", " *\n", " * @author James Sexton\n", " * @author Joshua O'Madadhain\n", " * @author Omar Darwish\n", " * @param <N> Node parameter type\n", " * @since 20.0\n", " */\n", "@Beta\n", "public final class ImmutableGraph<N> extends ForwardingGraph<N> {\n", "  private static final Object DUMMY_EDGE_VALUE = new Object();\n", "\n", "  private final ValueGraph<N, Object> backingGraph;\n", "\n", "  private ImmutableGraph(Graph<N> graph) {\n", "    this.backingGraph = new ConfigurableValueGraph<N, Object>(\n", "        GraphBuilder.from(graph), getNodeConnections(graph), graph.edges().size());\n", "  }\n", "\n", "  /**\n", "   * Returns an immutable copy of {@code graph}.\n", "   */\n", "  @SuppressWarnings(\"unchecked\")\n", "  public static <N> ImmutableGraph<N> copyOf(Graph<N> graph) {\n", "    return (graph instanceof ImmutableGraph)\n", "        ? (ImmutableGraph<N>) graph\n", "        : new ImmutableGraph<N>(graph);\n", "  }\n", "\n", "  /**\n", "   * Simply returns its argument.\n", "   *\n", "   * @deprecated no need to use this\n", "   */\n", "  @Deprecated\n", "  public static <N> ImmutableGraph<N> copyOf(ImmutableGraph<N> graph) {\n", "    return checkNotNull(graph);\n", "  }\n", "\n", "  private static <N> ImmutableMap<N, GraphConnections<N, Object>> getNodeConnections(\n", "      Graph<N> graph) {\n", "    // ImmutableMap.Builder maintains the order of the elements as inserted, so the map will have\n", "    // whatever ordering the graph's nodes do, so ImmutableSortedMap is unnecessary even if the\n", "    // input nodes are sorted.\n", "    ImmutableMap.Builder<N, GraphConnections<N, Object>> nodeConnections = ImmutableMap.builder();\n", "    for (N node : graph.nodes()) {\n", "      nodeConnections.put(node, connectionsOf(graph, node));\n", "    }\n", "    return nodeConnections.build();\n", "  }\n", "\n", "  private static <N> GraphConnections<N, Object> connectionsOf(Graph<N> graph, N node) {\n", "    return graph.isDirected()\n", "        ? DirectedGraphConnections.ofImmutable(\n", "            graph.predecessors(node),\n", "            Maps.asMap(graph.successors(node), Functions.constant(DUMMY_EDGE_VALUE)))\n", "        : UndirectedGraphConnections.ofImmutable(\n", "            Maps.asMap(graph.adjacentNodes(node), Functions.constant(DUMMY_EDGE_VALUE)));\n", "  }\n", "\n", "  @Override\n", "  protected Graph<N> delegate() {\n", "    return backingGraph;\n", "  }\n", "}\n"]}, "added_lines": {}, "removed_lines": {"1": [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 58, 59, 60, 61, 62, 63, 64, 65, 66, 67, 68, 69, 70, 71, 72, 73, 74, 75, 76, 77, 78, 79, 80, 81, 82, 83, 84, 85, 86, 87, 88, 89, 90, 91, 92]}}, {"33": "guava/src/com/google/common/graph/ImmutableNetwork.java", "added": {"1": ["public class ImmutableNetwork<N, E> extends ConfigurableNetwork<N, E> {\n"]}, "removed": {"1": ["public final class ImmutableNetwork<N, E> extends ConfigurableNetwork<N, E> {\n"]}, "added_lines": {"1": [39]}, "removed_lines": {"1": [39]}}, {"34": "guava/src/com/google/common/graph/ImmutableValueGraph.java", "added": {"1": ["public class ImmutableValueGraph<N, V> extends ConfigurableValueGraph<N, V> {\n", "  ImmutableValueGraph(ValueGraph<N, V> graph) {\n", "    super(ValueGraphBuilder.from(graph), getNodeConnections(graph), graph.edges().size());\n"]}, "removed": {"1": ["public final class ImmutableValueGraph<N, V> extends ConfigurableValueGraph<N, V> {\n", "  private ImmutableValueGraph(ValueGraph<N, V> graph) {\n", "    super(GraphBuilder.from(graph), getNodeConnections(graph), graph.edges().size());\n"]}, "added_lines": {"1": [36, 38, 39]}, "removed_lines": {"1": [36, 38, 39]}}, {"35": "guava/src/com/google/common/graph/MutableBasicGraph.java", "added": {"1": [" * A subtype of {@link BasicGraph} which permits mutations.\n", " * Users should generally use the {@link BasicGraph} interface where possible.\n"], "2": ["public interface MutableBasicGraph<N> extends BasicGraph<N> {\n"]}, "removed": {"1": [" * A subtype of {@link Graph} which permits mutations.\n", " * Users should generally use the {@link Graph} interface where possible.\n"], "2": ["public interface MutableGraph<N> extends Graph<N> {\n"]}, "added_lines": {"1": [23, 24], "2": [32]}, "removed_lines": {"1": [23, 24], "2": [32]}}, {"36": "guava/src/com/google/common/graph/Network.java", "added": {"1": [" * Unlike {@link BasicGraph}, {@link Network} represents edges as explicit first-class objects.\n", " * Users that are not interested in edges as first-class objects should use the {@link BasicGraph}\n", " * <p>For convenience, we may use the term 'graph' refer to {@link BasicGraph}s and/or\n", " * {@link Network}s.\n"], "2": [" * <li>There are no Node or Edge classes built in.  So you can have a\n", " *     {@code Network<Integer, String>} or a {@code Network<Author,Publication>} or a\n", " *     {@code Network<Webpage,Link>}.\n"], "3": [" * <li>Prefer extending {@link AbstractBasicGraph} over implementing {@link BasicGraph} directly.\n", " *     This will ensure that the implementations of {@link #equals(Object)} and\n"], "4": ["   * Returns a live view of this graph as a {@link ValueGraph}. The resulting {@link ValueGraph}\n", "   * will have an edge connecting node A to node B iff this {@link Network} has an edge connecting\n", "   * A to B.\n", "   *\n", "   * <p>{@link ValueGraph#edgeValue(Object, Object)} will return the set of edges connecting node A\n", "   * to node B. It will return the empty set if there are no edges connecting A to B.\n", "  ValueGraph<N, Set<E>> asGraph();\n"]}, "removed": {"1": [" * Unlike {@link Graph}, {@link Network} represents edges as explicit first-class objects.\n", " * Users that are not interested in edges as first-class objects should use the {@link Graph}\n", " * <p>For convenience, we may use the term 'graph' refer to {@link Graph}s and/or {@link Network}s.\n"], "2": [" * <li>There are no Node or Edge classes built in.  So you can have a {@code Graph<Integer, String>}\n", " *     or a {@code Graph<Author,Publication>} or a {@code Graph<Webpage,Link>}.\n"], "3": [" * <li>Prefer extending {@link AbstractGraph} over implementing {@link Graph} directly. This will\n", " *     ensure that the implementations of {@link #equals(Object)} and\n"], "4": ["   * Returns a live view of this graph as a {@link Graph}. The resulting {@link Graph} will have an\n", "   * edge connecting node A to node B iff this {@link Network} has an edge connecting A to B.\n", "  Graph<N> asGraph();\n"]}, "added_lines": {"1": [25, 26, 29, 30], "2": [109, 110, 111], "3": [160, 161], "4": [227, 228, 229, 230, 231, 232, 234]}, "removed_lines": {"1": [25, 26, 29], "2": [108, 109], "3": [158, 159], "4": [225, 226, 228]}}, {"37": "guava/src/com/google/common/graph/ValueGraph.java", "added": {"1": ["import java.util.Set;\n", " * An interface to represent a graph data structure. Graphs can be either directed or undirected\n", " * (but cannot have both directed edges and undirected edges). Every edge is associated with an\n", " * arbitrary user-provided value. Parallel edges are not supported (although the Value type may be,\n", " * for example, a collection).\n", " * <p>Nodes in a graph are analogous to keys in a Map - they must be unique within a graph.\n", " * Values in a graph are analogous to values in a Map - they may be any arbitrary object.\n", " *\n", " * TODO(b/30133524): Rewrite the top-level javadoc from scratch.\n", " *\n", " * TODO(jasexton): Rename interface (and various other classes) to \"Graph\".\n"], "2": ["public interface ValueGraph<N, V> {\n", "  //\n", "  // Graph-level accessors\n", "  //\n", "\n", "  /**\n", "   * Returns all nodes in this graph, in the order specified by {@link #nodeOrder()}.\n", "   */\n", "  Set<N> nodes();\n", "\n", "  /**\n", "   * Returns all edges in this graph.\n", "   */\n", "  Set<Endpoints<N>> edges();\n", "\n", "  //\n", "  // Graph properties\n", "  //\n", "\n", "  /**\n", "   * Returns true if the edges in this graph have a direction associated with them.\n", "   */\n", "  boolean isDirected();\n", "\n", "  /**\n", "   * Returns true if this graph allows self-loops (edges that connect a node to itself).\n", "   * Attempting to add a self-loop to a graph that does not allow them will throw an\n", "   * {@link UnsupportedOperationException}.\n", "   */\n", "  boolean allowsSelfLoops();\n", "\n", "  /**\n", "   * Returns the order of iteration for the elements of {@link #nodes()}.\n", "   */\n", "  ElementOrder<N> nodeOrder();\n", "\n", "  //\n", "  // Element-level accessors\n", "  //\n", "\n", "  /**\n", "   * Returns the nodes which have an incident edge in common with {@code node} in this graph.\n", "   *\n", "   * @throws IllegalArgumentException if {@code node} is not an element of this graph\n", "   */\n", "  Set<N> adjacentNodes(Object node);\n", "\n", "  /**\n", "   * Returns all nodes in this graph adjacent to {@code node} which can be reached by traversing\n", "   * {@code node}'s incoming edges <i>against</i> the direction (if any) of the edge.\n", "   *\n", "   * @throws IllegalArgumentException if {@code node} is not an element of this graph\n", "   */\n", "  Set<N> predecessors(Object node);\n", "\n", "  /**\n", "   * Returns all nodes in this graph adjacent to {@code node} which can be reached by traversing\n", "   * {@code node}'s outgoing edges in the direction (if any) of the edge.\n", "   *\n", "   * <p>This is <i>not</i> the same as \"all nodes reachable from {@code node} by following outgoing\n", "   * edges\". For that functionality, see {@link Graphs#reachableNodes(ValueGraph, Object)} and\n", "   * {@link Graphs#transitiveClosure(ValueGraph)}.\n", "   *\n", "   * @throws IllegalArgumentException if {@code node} is not an element of this graph\n", "   */\n", "  Set<N> successors(Object node);\n", "\n"], "3": ["   * associated with that edge; otherwise, returns {@code defaultValue}.\n", "   *\n", "   * @throws IllegalArgumentException if {@code nodeA} or {@code nodeB} is not an element of\n", "   *     this graph\n", "  // Graph identity\n", "   * <p>Thus, two graphs A and B are equal if <b>all</b> of the following are true:\n"], "4": ["   * Returns the hash code for this graph. The hash code of a graph is defined as the hash code\n", "   * of a map from each of its {@link #edges() edges} to the associated {@link #edgeValue(Object,\n", "   * Object) edge value}.\n"]}, "removed": {"1": [" * A subtype of {@link Graph} that associates a value with each edge.\n", " * TODO(b/30133524) Flesh out class-level javadoc.\n"], "2": ["public interface ValueGraph<N, V> extends Graph<N> {\n"], "3": ["   * associated with that edge. Otherwise, returns {@code defaultValue}.\n", "  // ValueGraph identity\n", "   * <p>Thus, two value graphs A and B are equal if <b>all</b> of the following are true:\n"], "4": ["   * Returns the hash code for this value graph. The hash code of a value graph is defined as\n", "   * the hash code of a map from each of its {@link #edges() edges} to the associated {@link\n", "   * #edgeValue(Object, Object) edge value}.\n"]}, "added_lines": {"1": [20, 24, 25, 26, 27, 29, 30, 31, 32, 33, 34], "2": [42, 43, 44, 45, 46, 47, 48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 58, 59, 60, 61, 62, 63, 64, 65, 66, 67, 68, 69, 70, 71, 72, 73, 74, 75, 76, 77, 78, 79, 80, 81, 82, 83, 84, 85, 86, 87, 88, 89, 90, 91, 92, 93, 94, 95, 96, 97, 98, 99, 100, 101, 102, 103, 104, 105, 106, 107, 108], "3": [119, 120, 121, 122, 127, 134], "4": [153, 154, 155]}, "removed_lines": {"1": [23, 25], "2": [33], "3": [44, 49, 56], "4": [75, 76, 77]}}, {"38": "guava/src/com/google/common/graph/ValueGraphBuilder.java", "added": {"1": ["   * Returns a {@link ValueGraphBuilder} for building directed graphs.\n", "   * Returns a {@link ValueGraphBuilder} for building undirected graphs.\n"], "2": ["   * <p>The \"queryable\" properties are those that are exposed through the {@link ValueGraph}\n", "   * interface, such as {@link ValueGraph#isDirected()}. Other properties, such as\n", "   * {@link #expectedNodeCount(int)}, are not set in the new builder.\n", "  public static <N> ValueGraphBuilder<N, Object> from(ValueGraph<N, ?> graph) {\n"], "3": ["   * Specifies the order of iteration for the elements of {@link BasicGraph#nodes()}.\n"]}, "removed": {"1": ["   * Returns a {@link ValueGraphBuilder} for building directed value graphs.\n", "   * Returns a {@link ValueGraphBuilder} for building undirected value graphs.\n"], "2": ["   * <p>The \"queryable\" properties are those that are exposed through the {@link Graph} interface,\n", "   * such as {@link Graph#isDirected()}. Other properties, such as {@link #expectedNodeCount(int)},\n", "   * are not set in the new builder.\n", "  public static <N> ValueGraphBuilder<N, Object> from(Graph<N> graph) {\n"], "3": ["   * Specifies the order of iteration for the elements of {@link Graph#nodes()}.\n"]}, "added_lines": {"1": [52, 59], "2": [69, 70, 71, 73], "3": [103]}, "removed_lines": {"1": [52, 59], "2": [69, 70, 71, 73], "3": [103]}}]}
