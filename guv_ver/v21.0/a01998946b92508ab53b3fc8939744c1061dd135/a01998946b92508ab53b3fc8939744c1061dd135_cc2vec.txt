{"id": "a01998946b92508ab53b3fc8939744c1061dd135", "code": [{"0": "guava/src/com/google/common/graph/AbstractGraph.java", "added": {"1": ["import static com.google.common.graph.GraphConstants.GRAPH_STRING_FORMAT;\n", "import com.google.common.annotations.Beta;\n", "import com.google.common.base.Function;\n", "import com.google.common.base.Joiner;\n", "import com.google.common.collect.Maps;\n", "import java.util.Set;\n"], "2": ["  public boolean equals(@Nullable Object obj) {\n", "    if (obj == this) {\n", "      return true;\n", "    }\n", "    if (!(obj instanceof Graph)) {\n", "      return false;\n", "    }\n", "    Graph<?> other = (Graph<?>) obj;\n", "\n", "    // Needed to enforce a symmetric equality relationship.\n", "    if (other instanceof Network) {\n", "\n", "    if (isDirected() != other.isDirected()) {\n", "      return false;\n", "    }\n", "\n", "    if (!nodes().equals(other.nodes())) {\n", "      return false;\n", "    }\n", "\n", "    for (Object node : nodes()) {\n", "      if (!successors(node).equals(other.successors(node))) {\n", "        return false;\n", "      }\n", "    }\n", "\n", "    return true;\n", "    return Maps.asMap(nodes(), new Function<N, Set<N>>() {\n", "      @Override\n", "      public Set<N> apply(N node) {\n", "        return successors(node);\n", "      }\n", "    }).hashCode();\n", "  /**\n", "   * Returns a string representation of this graph. Encodes edge direction if any.\n", "   */\n", "    return String.format(GRAPH_STRING_FORMAT,\n", "        getPropertiesString(),\n", "        nodes(),\n", "        endpointsString());\n", "  }\n", "\n", "  // TODO(b/28087289): add allowsParallelEdges() once that's supported\n", "  private String getPropertiesString() {\n", "    return String.format(\"isDirected: %s, allowsSelfLoops: %s\", isDirected(), allowsSelfLoops());\n", "  }\n", "\n", "  private String endpointsString() {\n", "    return String.format(\"{%s}\", Joiner.on(\", \").join(Graphs.endpointsInternal(this)));\n"]}, "removed": {"1": ["import com.google.common.annotations.Beta;\n"], "2": ["  public boolean equals(@Nullable Object object) {\n", "    if (!(object instanceof Graph)) {\n", "    return Graphs.equal(this, (Graph<?>) object);\n", "    return Graphs.hashCode(this);\n", "    return Graphs.toString(this);\n"]}, "added_lines": {"1": [19, 21, 22, 23, 24, 25], "2": [59, 60, 61, 62, 63, 64, 65, 66, 67, 68, 69, 72, 73, 74, 75, 76, 77, 78, 79, 80, 81, 82, 83, 84, 85, 86, 87, 92, 93, 94, 95, 96, 97, 100, 101, 102, 105, 106, 107, 108, 109, 110, 111, 112, 113, 114, 115, 116, 117]}, "removed_lines": {"1": [19], "2": [54, 55, 58, 63, 68]}}, {"1": "guava/src/com/google/common/graph/AbstractNetwork.java", "added": {"1": ["import static com.google.common.graph.GraphConstants.GRAPH_STRING_FORMAT;\n", "import com.google.common.annotations.Beta;\n", "import com.google.common.base.Function;\n", "import com.google.common.collect.Maps;\n", "import java.util.Set;\n"], "2": ["  public boolean equals(@Nullable Object obj) {\n", "    if (obj == this) {\n", "      return true;\n", "    }\n", "    if (!(obj instanceof Network)) {\n", "      return false;\n", "    }\n", "    Network<?, ?> other = (Network<?, ?>) obj;\n", "\n", "    if (isDirected() != other.isDirected()) {\n", "\n", "    if (!nodes().equals(other.nodes()) || !edges().equals(other.edges())) {\n", "      return false;\n", "    }\n", "\n", "    for (Object edge : edges()) {\n", "      if (!incidentNodes(edge).equals(other.incidentNodes(edge))) {\n", "        return false;\n", "      }\n", "    }\n", "\n", "    return true;\n", "    return Maps.asMap(nodes(), new Function<N, Set<E>>() {\n", "      @Override\n", "      public Set<E> apply(N node) {\n", "        return outEdges(node);\n", "      }\n", "    }).hashCode();\n", "  /**\n", "   * Returns a string representation of this graph. Encodes edge direction if any.\n", "   */\n", "    return String.format(GRAPH_STRING_FORMAT,\n", "        getPropertiesString(),\n", "        nodes(),\n", "        Maps.asMap(edges(), edgeToEndpointsString()));\n", "\n", "  private String getPropertiesString() {\n", "    return String.format(\"isDirected: %s, allowsParallelEdges: %s, allowsSelfLoops: %s\",\n", "        isDirected(), allowsParallelEdges(), allowsSelfLoops());\n", "  }\n", "\n", "  private Function<Object, String> edgeToEndpointsString() {\n", "    return new Function<Object, String>() {\n", "      @Override\n", "      public String apply(Object edge) {\n", "        return incidentNodes(edge).toString();\n", "      }\n", "    };\n", " }\n"]}, "removed": {"1": ["import com.google.common.annotations.Beta;\n"], "2": ["  public boolean equals(@Nullable Object object) {\n", "    if (!(object instanceof Network)) {\n", "    return Graphs.equal(this, (Network<?, ?>) object);\n", "    return Graphs.hashCode(this);\n", "    return Graphs.toString(this);\n"]}, "added_lines": {"1": [19, 21, 22, 23, 24], "2": [56, 57, 58, 59, 60, 61, 62, 63, 64, 65, 68, 69, 70, 71, 72, 73, 74, 75, 76, 77, 78, 79, 84, 85, 86, 87, 88, 89, 92, 93, 94, 97, 98, 99, 100, 102, 103, 104, 105, 106, 107, 108, 109, 110, 111, 112, 113, 114, 115]}, "removed_lines": {"1": [19], "2": [52, 53, 56, 61, 66]}}, {"2": "guava/src/com/google/common/graph/Graph.java", "added": {"1": ["   * <p>A reference implementation of this is provided by {@link AbstractGraph#equals(Object)}.\n"], "2": ["   * <p>A reference implementation of this is provided by {@link AbstractGraph#hashCode()}.\n"]}, "removed": {"1": ["   * <p>A reference implementation of this is provided by {@link Graphs#equal(Graph, Graph)}.\n"], "2": ["   * <p>A reference implementation of this is provided by {@link Graphs#hashCode(Graph)}.\n"]}, "added_lines": {"1": [277], "2": [286]}, "removed_lines": {"1": [279], "2": [288]}}, {"3": "guava/src/com/google/common/graph/GraphConstants.java", "added": {"1": ["\n", "  static final String GRAPH_STRING_FORMAT = \"%s, nodes: %s, edges: %s\";\n"]}, "removed": {}, "added_lines": {"1": [57, 58]}, "removed_lines": {}}, {"4": "guava/src/com/google/common/graph/Graphs.java", "added": {"2": ["  static <N> Set<Endpoints<N>> endpointsInternal(final Graph<N> graph) {\n"], "4": ["   * Visited Nodes = {N1}\n"]}, "removed": {"1": ["import com.google.common.base.Joiner;\n", "import com.google.common.collect.Maps;\n", "\n", "import java.util.Map;\n", "import javax.annotation.Nullable;\n", "\n"], "2": ["  private static final String GRAPH_FORMAT = \"%s, nodes: %s, edges: %s\";\n", "\n", "  private static <N> Set<Endpoints<N>> endpointsInternal(final Graph<N> graph) {\n"], "3": ["  /**\n", "   * Returns true iff {@code graph1} and {@code graph2} are equal as defined by\n", "   * {@link Graph#equals(Object)}.\n", "   */\n", "  public static boolean equal(@Nullable Graph<?> graph1, @Nullable Graph<?> graph2) {\n", "    // If both graphs are Network instances, use equal(Network, Network) instead\n", "    if (graph1 instanceof Network && graph2 instanceof Network) {\n", "      return equal(castToNetwork(graph1), castToNetwork(graph2));\n", "    }\n", "\n", "    // Otherwise, if either graph is a Network (but not both), they can't be equal.\n", "    if (graph1 instanceof Network || graph2 instanceof Network) {\n", "      return false;\n", "    }\n", "\n", "    if (graph1 == graph2) {\n", "      return true;\n", "    }\n", "\n", "    if (graph1 == null || graph2 == null) {\n", "      return false;\n", "    }\n", "\n", "    if (graph1.isDirected() != graph2.isDirected()) {\n", "      return false;\n", "    }\n", "\n", "    if (!graph1.nodes().equals(graph2.nodes())) {\n", "      return false;\n", "    }\n", "\n", "    for (Object node : graph1.nodes()) {\n", "      if (!graph1.successors(node).equals(graph2.successors(node))) {\n", "        return false;\n", "      }\n", "    }\n", "\n", "    return true;\n", "  }\n", "\n", "  /**\n", "   * Returns true iff {@code graph1} and {@code graph2} are equal as defined by\n", "   * {@link Network#equals(Object)}.\n", "   */\n", "  public static boolean equal(@Nullable Network<?, ?> graph1, @Nullable Network<?, ?> graph2) {\n", "    if (graph1 == graph2) {\n", "      return true;\n", "    }\n", "\n", "    if (graph1 == null || graph2 == null) {\n", "      return false;\n", "    }\n", "\n", "    if (graph1.isDirected() != graph2.isDirected()) {\n", "      return false;\n", "    }\n", "\n", "    if (!graph1.nodes().equals(graph2.nodes()) || !graph1.edges().equals(graph2.edges())) {\n", "      return false;\n", "    }\n", "\n", "    for (Object edge : graph1.edges()) {\n", "      if (!graph1.incidentNodes(edge).equals(graph2.incidentNodes(edge))) {\n", "        return false;\n", "      }\n", "    }\n", "\n", "    return true;\n", "  }\n", "\n", "  /**\n", "   * Returns the hash code of {@code graph} as defined by {@link Graph#hashCode()}.\n", "   */\n", "  public static int hashCode(Graph<?> graph) {\n", "    if (graph instanceof Network) {\n", "      return hashCode(castToNetwork(graph));\n", "    }\n", "    return nodeToSuccessorNodes(graph).hashCode();\n", "  }\n", "\n", "  /**\n", "   * Returns the hash code of {@code graph} as defined by {@link Network#hashCode()}.\n", "   */\n", "  public static int hashCode(Network<?, ?> graph) {\n", "    return nodeToOutEdges(graph).hashCode();\n", "  }\n", "\n", "  /**\n", "   * Returns a string representation of {@code graph}. Encodes edge direction if {@code graph}\n", "   * is directed.\n", "   */\n", "  public static String toString(Graph<?> graph) {\n", "    if (graph instanceof Network) {\n", "      return toString(castToNetwork(graph));\n", "    }\n", "    return String.format(GRAPH_FORMAT,\n", "        getPropertiesString(graph),\n", "        graph.nodes(),\n", "        endpointsString(graph));\n", "  }\n", "\n", "  /**\n", "   * Returns a string representation of {@code graph}. Encodes edge direction if {@code graph}\n", "   * is directed.\n", "   */\n", "  public static String toString(Network<?, ?> graph) {\n", "    return String.format(GRAPH_FORMAT,\n", "        getPropertiesString(graph),\n", "        graph.nodes(),\n", "        Maps.asMap(graph.edges(), edgeToEndpointsString(graph)));\n", "  }\n", "\n", "  /**\n", "   * Returns a String of the endpoints for {@code graph}.\n", "   */\n", "  private static <N> String endpointsString(final Graph<N> graph) {\n", "    checkNotNull(graph, \"graph\");\n", "    return String.format(\"{%s}\", Joiner.on(\", \").join(endpointsInternal(graph)));\n", "  }\n", "\n", "  /**\n", "   * Returns a map that is a live view of {@code graph}, with nodes as keys\n", "   * and the set of outgoing edges as values.\n", "   */\n", "  private static <N, E> Map<N, Set<E>> nodeToOutEdges(final Network<N, E> graph) {\n", "    checkNotNull(graph, \"graph\");\n", "    return Maps.asMap(graph.nodes(), new Function<N, Set<E>>() {\n", "      @Override\n", "      public Set<E> apply(N node) {\n", "        return graph.outEdges(node);\n", "      }\n", "    });\n", "  }\n", "\n", "  /**\n", "   * Returns a map that is a live view of {@code graph}, with nodes as keys\n", "   * and the set of successor nodes as values.\n", "   */\n", "  private static <N> Map<N, Set<N>> nodeToSuccessorNodes(final Graph<N> graph) {\n", "    checkNotNull(graph, \"graph\");\n", "    return Maps.asMap(graph.nodes(), new Function<N, Set<N>>() {\n", "      @Override\n", "      public Set<N> apply(N node) {\n", "        return graph.successors(node);\n", "      }\n", "    });\n", "  }\n", "\n", "  /**\n", "   * Returns a function that transforms an edge into a string representation of its endpoints\n", "   * in {@code graph}. The function's {@code apply} method will throw an\n", "   * {@link IllegalArgumentException} if {@code graph} does not contain {@code edge}.\n", "   */\n", "  private static Function<Object, String> edgeToEndpointsString(final Network<?, ?> graph) {\n", "    checkNotNull(graph, \"graph\");\n", "    return new Function<Object, String>() {\n", "      @Override\n", "      public String apply(Object edge) {\n", "        return graph.incidentNodes(edge).toString();\n", "      }\n", "    };\n", " }\n", "\n", "  /**\n", "   * Returns a string representation of the properties of {@code graph}.\n", "   */\n", "  // TODO(b/28087289): add allowsParallelEdges() once that's supported\n", "  private static String getPropertiesString(Graph<?> graph) {\n", "    if (graph instanceof Network) {\n", "      return getPropertiesString(castToNetwork(graph));\n", "    }\n", "    return String.format(\"isDirected: %s, allowsSelfLoops: %s\",\n", "        graph.isDirected(), graph.allowsSelfLoops());\n", "  }\n", "\n", "  /**\n", "   * Returns a string representation of the properties of {@code graph}.\n", "   */\n", "  private static String getPropertiesString(Network<?, ?> graph) {\n", "    return String.format(\"isDirected: %s, allowsParallelEdges: %s, allowsSelfLoops: %s\",\n", "        graph.isDirected(), graph.allowsParallelEdges(), graph.allowsSelfLoops());\n", "  }\n", "\n"], "4": ["   * Visited Nodess = {N1}\n"]}, "added_lines": {"2": [50], "4": [291]}, "removed_lines": {"1": [26, 30, 33, 37, 40, 41], "2": [52, 53, 58], "3": [226, 227, 228, 229, 230, 231, 232, 233, 234, 235, 236, 237, 238, 239, 240, 241, 242, 243, 244, 245, 246, 247, 248, 249, 250, 251, 252, 253, 254, 255, 256, 257, 258, 259, 260, 261, 262, 263, 264, 265, 266, 267, 268, 269, 270, 271, 272, 273, 274, 275, 276, 277, 278, 279, 280, 281, 282, 283, 284, 285, 286, 287, 288, 289, 290, 291, 292, 293, 294, 295, 296, 297, 298, 299, 300, 301, 302, 303, 304, 305, 306, 307, 308, 309, 310, 311, 312, 313, 314, 315, 316, 317, 318, 319, 320, 321, 322, 323, 324, 325, 326, 327, 328, 329, 330, 331, 332, 333, 334, 335, 336, 337, 338, 339, 340, 341, 342, 343, 344, 345, 346, 347, 348, 349, 350, 351, 352, 353, 354, 355, 356, 357, 358, 359, 360, 361, 362, 363, 364, 365, 366, 367, 368, 369, 370, 371, 372, 373, 374, 375, 376, 377, 378, 379, 380, 381, 382, 383, 384, 385, 386, 387, 388, 389, 390, 391, 392, 393, 394, 395, 396, 397, 398, 399, 400, 401, 402, 403, 404, 405, 406, 407, 408], "4": [482]}}, {"5": "guava/src/com/google/common/graph/Network.java", "added": {"1": ["   * <p>A reference implementation of this is provided by {@link AbstractNetwork#equals(Object)}.\n"], "2": ["   * <p>A reference implementation of this is provided by {@link AbstractNetwork#hashCode()}.\n"]}, "removed": {"1": ["   * <p>A reference implementation of this is provided by {@link Graphs#equal(Network, Network)}.\n"], "2": ["   * <p>A reference implementation of this is provided by {@link Graphs#hashCode(Graph)}.\n"]}, "added_lines": {"1": [346], "2": [355]}, "removed_lines": {"1": [348], "2": [357]}}]}
