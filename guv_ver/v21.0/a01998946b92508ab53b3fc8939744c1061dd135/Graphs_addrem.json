{
    "addition": {
        "50": "  static <N> Set<Endpoints<N>> endpointsInternal(final Graph<N> graph) {\n",
        "291": "   * Visited Nodes = {N1}\n"
    },
    "removed": {
        "26": "import com.google.common.base.Joiner;\n",
        "30": "import com.google.common.collect.Maps;\n",
        "33": "\n",
        "37": "import java.util.Map;\n",
        "40": "import javax.annotation.Nullable;\n",
        "41": "\n",
        "52": "  private static final String GRAPH_FORMAT = \"%s, nodes: %s, edges: %s\";\n",
        "53": "\n",
        "58": "  private static <N> Set<Endpoints<N>> endpointsInternal(final Graph<N> graph) {\n",
        "226": "  /**\n",
        "227": "   * Returns true iff {@code graph1} and {@code graph2} are equal as defined by\n",
        "228": "   * {@link Graph#equals(Object)}.\n",
        "229": "   */\n",
        "230": "  public static boolean equal(@Nullable Graph<?> graph1, @Nullable Graph<?> graph2) {\n",
        "231": "    // If both graphs are Network instances, use equal(Network, Network) instead\n",
        "232": "    if (graph1 instanceof Network && graph2 instanceof Network) {\n",
        "233": "      return equal(castToNetwork(graph1), castToNetwork(graph2));\n",
        "234": "    }\n",
        "235": "\n",
        "236": "    // Otherwise, if either graph is a Network (but not both), they can't be equal.\n",
        "237": "    if (graph1 instanceof Network || graph2 instanceof Network) {\n",
        "238": "      return false;\n",
        "239": "    }\n",
        "240": "\n",
        "241": "    if (graph1 == graph2) {\n",
        "242": "      return true;\n",
        "243": "    }\n",
        "244": "\n",
        "245": "    if (graph1 == null || graph2 == null) {\n",
        "246": "      return false;\n",
        "247": "    }\n",
        "248": "\n",
        "249": "    if (graph1.isDirected() != graph2.isDirected()) {\n",
        "250": "      return false;\n",
        "251": "    }\n",
        "252": "\n",
        "253": "    if (!graph1.nodes().equals(graph2.nodes())) {\n",
        "254": "      return false;\n",
        "255": "    }\n",
        "256": "\n",
        "257": "    for (Object node : graph1.nodes()) {\n",
        "258": "      if (!graph1.successors(node).equals(graph2.successors(node))) {\n",
        "259": "        return false;\n",
        "260": "      }\n",
        "261": "    }\n",
        "262": "\n",
        "263": "    return true;\n",
        "264": "  }\n",
        "265": "\n",
        "266": "  /**\n",
        "267": "   * Returns true iff {@code graph1} and {@code graph2} are equal as defined by\n",
        "268": "   * {@link Network#equals(Object)}.\n",
        "269": "   */\n",
        "270": "  public static boolean equal(@Nullable Network<?, ?> graph1, @Nullable Network<?, ?> graph2) {\n",
        "271": "    if (graph1 == graph2) {\n",
        "272": "      return true;\n",
        "273": "    }\n",
        "274": "\n",
        "275": "    if (graph1 == null || graph2 == null) {\n",
        "276": "      return false;\n",
        "277": "    }\n",
        "278": "\n",
        "279": "    if (graph1.isDirected() != graph2.isDirected()) {\n",
        "280": "      return false;\n",
        "281": "    }\n",
        "282": "\n",
        "283": "    if (!graph1.nodes().equals(graph2.nodes()) || !graph1.edges().equals(graph2.edges())) {\n",
        "284": "      return false;\n",
        "285": "    }\n",
        "286": "\n",
        "287": "    for (Object edge : graph1.edges()) {\n",
        "288": "      if (!graph1.incidentNodes(edge).equals(graph2.incidentNodes(edge))) {\n",
        "289": "        return false;\n",
        "290": "      }\n",
        "291": "    }\n",
        "292": "\n",
        "293": "    return true;\n",
        "294": "  }\n",
        "295": "\n",
        "296": "  /**\n",
        "297": "   * Returns the hash code of {@code graph} as defined by {@link Graph#hashCode()}.\n",
        "298": "   */\n",
        "299": "  public static int hashCode(Graph<?> graph) {\n",
        "300": "    if (graph instanceof Network) {\n",
        "301": "      return hashCode(castToNetwork(graph));\n",
        "302": "    }\n",
        "303": "    return nodeToSuccessorNodes(graph).hashCode();\n",
        "304": "  }\n",
        "305": "\n",
        "306": "  /**\n",
        "307": "   * Returns the hash code of {@code graph} as defined by {@link Network#hashCode()}.\n",
        "308": "   */\n",
        "309": "  public static int hashCode(Network<?, ?> graph) {\n",
        "310": "    return nodeToOutEdges(graph).hashCode();\n",
        "311": "  }\n",
        "312": "\n",
        "313": "  /**\n",
        "314": "   * Returns a string representation of {@code graph}. Encodes edge direction if {@code graph}\n",
        "315": "   * is directed.\n",
        "316": "   */\n",
        "317": "  public static String toString(Graph<?> graph) {\n",
        "318": "    if (graph instanceof Network) {\n",
        "319": "      return toString(castToNetwork(graph));\n",
        "320": "    }\n",
        "321": "    return String.format(GRAPH_FORMAT,\n",
        "322": "        getPropertiesString(graph),\n",
        "323": "        graph.nodes(),\n",
        "324": "        endpointsString(graph));\n",
        "325": "  }\n",
        "326": "\n",
        "327": "  /**\n",
        "328": "   * Returns a string representation of {@code graph}. Encodes edge direction if {@code graph}\n",
        "329": "   * is directed.\n",
        "330": "   */\n",
        "331": "  public static String toString(Network<?, ?> graph) {\n",
        "332": "    return String.format(GRAPH_FORMAT,\n",
        "333": "        getPropertiesString(graph),\n",
        "334": "        graph.nodes(),\n",
        "335": "        Maps.asMap(graph.edges(), edgeToEndpointsString(graph)));\n",
        "336": "  }\n",
        "337": "\n",
        "338": "  /**\n",
        "339": "   * Returns a String of the endpoints for {@code graph}.\n",
        "340": "   */\n",
        "341": "  private static <N> String endpointsString(final Graph<N> graph) {\n",
        "342": "    checkNotNull(graph, \"graph\");\n",
        "343": "    return String.format(\"{%s}\", Joiner.on(\", \").join(endpointsInternal(graph)));\n",
        "344": "  }\n",
        "345": "\n",
        "346": "  /**\n",
        "347": "   * Returns a map that is a live view of {@code graph}, with nodes as keys\n",
        "348": "   * and the set of outgoing edges as values.\n",
        "349": "   */\n",
        "350": "  private static <N, E> Map<N, Set<E>> nodeToOutEdges(final Network<N, E> graph) {\n",
        "351": "    checkNotNull(graph, \"graph\");\n",
        "352": "    return Maps.asMap(graph.nodes(), new Function<N, Set<E>>() {\n",
        "353": "      @Override\n",
        "354": "      public Set<E> apply(N node) {\n",
        "355": "        return graph.outEdges(node);\n",
        "356": "      }\n",
        "357": "    });\n",
        "358": "  }\n",
        "359": "\n",
        "360": "  /**\n",
        "361": "   * Returns a map that is a live view of {@code graph}, with nodes as keys\n",
        "362": "   * and the set of successor nodes as values.\n",
        "363": "   */\n",
        "364": "  private static <N> Map<N, Set<N>> nodeToSuccessorNodes(final Graph<N> graph) {\n",
        "365": "    checkNotNull(graph, \"graph\");\n",
        "366": "    return Maps.asMap(graph.nodes(), new Function<N, Set<N>>() {\n",
        "367": "      @Override\n",
        "368": "      public Set<N> apply(N node) {\n",
        "369": "        return graph.successors(node);\n",
        "370": "      }\n",
        "371": "    });\n",
        "372": "  }\n",
        "373": "\n",
        "374": "  /**\n",
        "375": "   * Returns a function that transforms an edge into a string representation of its endpoints\n",
        "376": "   * in {@code graph}. The function's {@code apply} method will throw an\n",
        "377": "   * {@link IllegalArgumentException} if {@code graph} does not contain {@code edge}.\n",
        "378": "   */\n",
        "379": "  private static Function<Object, String> edgeToEndpointsString(final Network<?, ?> graph) {\n",
        "380": "    checkNotNull(graph, \"graph\");\n",
        "381": "    return new Function<Object, String>() {\n",
        "382": "      @Override\n",
        "383": "      public String apply(Object edge) {\n",
        "384": "        return graph.incidentNodes(edge).toString();\n",
        "385": "      }\n",
        "386": "    };\n",
        "387": " }\n",
        "388": "\n",
        "389": "  /**\n",
        "390": "   * Returns a string representation of the properties of {@code graph}.\n",
        "391": "   */\n",
        "392": "  // TODO(b/28087289): add allowsParallelEdges() once that's supported\n",
        "393": "  private static String getPropertiesString(Graph<?> graph) {\n",
        "394": "    if (graph instanceof Network) {\n",
        "395": "      return getPropertiesString(castToNetwork(graph));\n",
        "396": "    }\n",
        "397": "    return String.format(\"isDirected: %s, allowsSelfLoops: %s\",\n",
        "398": "        graph.isDirected(), graph.allowsSelfLoops());\n",
        "399": "  }\n",
        "400": "\n",
        "401": "  /**\n",
        "402": "   * Returns a string representation of the properties of {@code graph}.\n",
        "403": "   */\n",
        "404": "  private static String getPropertiesString(Network<?, ?> graph) {\n",
        "405": "    return String.format(\"isDirected: %s, allowsParallelEdges: %s, allowsSelfLoops: %s\",\n",
        "406": "        graph.isDirected(), graph.allowsParallelEdges(), graph.allowsSelfLoops());\n",
        "407": "  }\n",
        "408": "\n",
        "482": "   * Visited Nodess = {N1}\n"
    }
}