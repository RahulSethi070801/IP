{"id": "3776f45d1054faaa5e368db33dc5ebcc38af0292", "code": [{"0": "guava-tests/test/com/google/common/graph/AbstractDirectedNetworkTest.java", "added": {"1": ["    for (Integer node : network.nodes()) {\n", "      for (String inEdge : network.inEdges(node)) {\n", "        Endpoints<Integer> endpoints = network.incidentNodes(inEdge);\n", "      for (String outEdge : network.outEdges(node)) {\n", "        Endpoints<Integer> endpoints = network.incidentNodes(outEdge);\n", "      for (Integer adjacentNode : network.adjacentNodes(node)) {\n", "        Set<String> edges = network.edgesConnecting(node, adjacentNode);\n", "        Set<String> antiParallelEdges = network.edgesConnecting(adjacentNode, node);\n"], "2": ["    assertThat(network.incidentNodes(E12)).containsExactly(N1, N2).inOrder();\n", "    assertThat(network.edgesConnecting(N1, N2)).containsExactly(E12);\n", "    assertThat(network.edgesConnecting(N2, N1)).isEmpty();\n", "    assertThat(network.inEdges(N2)).containsExactly(E12);\n", "    assertThat(network.inEdges(N1)).isEmpty();\n", "    assertThat(network.outEdges(N1)).containsExactly(E12);\n", "    assertThat(network.outEdges(N2)).isEmpty();\n", "    assertThat(network.predecessors(N2)).containsExactly(N1);\n", "    assertThat(network.predecessors(N1)).isEmpty();\n", "    assertThat(network.successors(N1)).containsExactly(N2);\n", "    assertThat(network.successors(N2)).isEmpty();\n", "    assertEquals(1, network.inDegree(N2));\n", "    assertEquals(0, network.inDegree(N1));\n", "    assertEquals(1, network.outDegree(N1));\n", "    assertEquals(0, network.outDegree(N2));\n", "    assertEquals(N1, network.incidentNodes(E12).source());\n", "      network.incidentNodes(EDGE_NOT_IN_GRAPH).source();\n"], "3": ["    assertEquals(N2, network.incidentNodes(E12).target());\n", "      network.incidentNodes(EDGE_NOT_IN_GRAPH).target();\n"], "4": ["    assertThat(network.edges()).contains(E12);\n", "    assertThat(network.edgesConnecting(N1, N2)).containsExactly(E12);\n", "    assertThat(network.edgesConnecting(N2, N1)).isEmpty();\n", "    ImmutableSet<String> edges = ImmutableSet.copyOf(network.edges());\n", "    assertThat(network.edges()).containsExactlyElementsIn(edges);\n"], "5": ["    assertTrue(network.removeEdge(E12));\n", "    assertThat(network.edges()).doesNotContain(E12);\n", "    assertThat(network.edgesConnecting(N1, N2)).isEmpty();\n"]}, "removed": {"1": ["    for (Integer node : graph.nodes()) {\n", "      for (String inEdge : graph.inEdges(node)) {\n", "        Endpoints<Integer> endpoints = graph.incidentNodes(inEdge);\n", "      for (String outEdge : graph.outEdges(node)) {\n", "        Endpoints<Integer> endpoints = graph.incidentNodes(outEdge);\n", "      for (Integer adjacentNode : graph.adjacentNodes(node)) {\n", "        Set<String> edges = graph.edgesConnecting(node, adjacentNode);\n", "        Set<String> antiParallelEdges = graph.edgesConnecting(adjacentNode, node);\n"], "2": ["    assertThat(graph.incidentNodes(E12)).containsExactly(N1, N2).inOrder();\n", "    assertThat(graph.edgesConnecting(N1, N2)).containsExactly(E12);\n", "    assertThat(graph.edgesConnecting(N2, N1)).isEmpty();\n", "    assertThat(graph.inEdges(N2)).containsExactly(E12);\n", "    assertThat(graph.inEdges(N1)).isEmpty();\n", "    assertThat(graph.outEdges(N1)).containsExactly(E12);\n", "    assertThat(graph.outEdges(N2)).isEmpty();\n", "    assertThat(graph.predecessors(N2)).containsExactly(N1);\n", "    assertThat(graph.predecessors(N1)).isEmpty();\n", "    assertThat(graph.successors(N1)).containsExactly(N2);\n", "    assertThat(graph.successors(N2)).isEmpty();\n", "    assertEquals(1, graph.inDegree(N2));\n", "    assertEquals(0, graph.inDegree(N1));\n", "    assertEquals(1, graph.outDegree(N1));\n", "    assertEquals(0, graph.outDegree(N2));\n", "    assertEquals(N1, graph.incidentNodes(E12).source());\n", "      graph.incidentNodes(EDGE_NOT_IN_GRAPH).source();\n"], "3": ["    assertEquals(N2, graph.incidentNodes(E12).target());\n", "      graph.incidentNodes(EDGE_NOT_IN_GRAPH).target();\n"], "4": ["    assertThat(graph.edges()).contains(E12);\n", "    assertThat(graph.edgesConnecting(N1, N2)).containsExactly(E12);\n", "    assertThat(graph.edgesConnecting(N2, N1)).isEmpty();\n", "    ImmutableSet<String> edges = ImmutableSet.copyOf(graph.edges());\n", "    assertThat(graph.edges()).containsExactlyElementsIn(edges);\n"], "5": ["    assertTrue(graph.removeEdge(E12));\n", "    assertThat(graph.edges()).doesNotContain(E12);\n", "    assertThat(graph.edgesConnecting(N1, N2)).isEmpty();\n"]}, "added_lines": {"1": [43, 44, 45, 50, 51, 56, 57, 58], "2": [68, 74, 77, 83, 85, 91, 93, 99, 101, 107, 109, 115, 117, 123, 125, 131, 137], "3": [147, 153], "4": [169, 170, 172, 178, 180], "5": [216, 217, 218]}, "removed_lines": {"1": [43, 44, 45, 50, 51, 56, 57, 58], "2": [68, 74, 77, 83, 85, 91, 93, 99, 101, 107, 109, 115, 117, 123, 125, 131, 137], "3": [147, 153], "4": [169, 170, 172, 178, 180], "5": [216, 217, 218]}}, {"1": "guava-tests/test/com/google/common/graph/AbstractNetworkTest.java", "added": {"1": ["  MutableNetwork<Integer, String> network;\n"], "2": ["    return network.addNode(n);\n"], "3": ["    network.addNode(n1);\n", "    network.addNode(n2);\n", "    return network.addEdge(e, n1, n2);\n", "    network = createGraph();\n", "        network,\n", "        Graphs.copyOf(network),\n", "        ImmutableNetwork.copyOf(network)).testEquals();\n", "\n", "    String networkString = network.toString();\n", "    assertThat(networkString).contains(\"isDirected: \" + network.isDirected());\n", "    assertThat(networkString).contains(\"allowsParallelEdges: \" + network.allowsParallelEdges());\n", "    assertThat(networkString).contains(\"allowsSelfLoops: \" + network.allowsSelfLoops());\n", "\n", "    int nodeStart = networkString.indexOf(\"nodes:\");\n", "    int edgeStart = networkString.indexOf(\"edges:\");\n", "    String nodeString = networkString.substring(nodeStart, edgeStart);\n", "    String edgeString = networkString.substring(edgeStart);\n", "\n", "    Graph<Integer> asGraph = network.asGraph();\n", "    assertThat(network.nodes()).isEqualTo(asGraph.nodes());\n", "    assertThat(network.nodeOrder()).isEqualTo(asGraph.nodeOrder());\n", "    assertThat(network.isDirected()).isEqualTo(asGraph.isDirected());\n", "    assertThat(network.allowsSelfLoops()).isEqualTo(asGraph.allowsSelfLoops());\n", "\n", "    for (String edge : network.edges()) {\n", "      Iterator<Integer> endpointsIterator = network.incidentNodes(edge).iterator();\n", "      assertThat(network.edgesConnecting(nodeA, nodeB)).contains(edge);\n", "      assertThat(network.successors(nodeA)).contains(nodeB);\n", "      assertThat(network.adjacentNodes(nodeA)).contains(nodeB);\n", "      assertThat(network.outEdges(nodeA)).contains(edge);\n", "      assertThat(network.incidentEdges(nodeA)).contains(edge);\n", "      assertThat(network.predecessors(nodeB)).contains(nodeA);\n", "      assertThat(network.adjacentNodes(nodeB)).contains(nodeA);\n", "      assertThat(network.inEdges(nodeB)).contains(edge);\n", "      assertThat(network.incidentEdges(nodeB)).contains(edge);\n", "\n", "      for (Integer incidentNode : network.incidentNodes(edge)) {\n", "        assertThat(network.nodes()).contains(incidentNode);\n", "        for (String adjacentEdge : network.incidentEdges(incidentNode)) {\n", "          assertTrue(edge.equals(adjacentEdge)\n", "              || network.adjacentEdges(edge).contains(adjacentEdge));\n", "    for (Integer node : network.nodes()) {\n", "      assertThat(network.adjacentNodes(node)).isEqualTo(asGraph.adjacentNodes(node));\n", "      assertThat(network.predecessors(node)).isEqualTo(asGraph.predecessors(node));\n", "      assertThat(network.successors(node)).isEqualTo(asGraph.successors(node));\n", "\n", "      assertThat(network.incidentEdges(node)).hasSize(network.degree(node));\n", "      assertThat(network.degree(node)).isAtLeast(network.adjacentNodes(node).size());\n", "      assertThat(network.inEdges(node)).hasSize(network.inDegree(node));\n", "      assertThat(network.inDegree(node)).isAtLeast(network.predecessors(node).size());\n", "      assertThat(network.outEdges(node)).hasSize(network.outDegree(node));\n", "      assertThat(network.outDegree(node)).isAtLeast(network.successors(node).size());\n", "      for (Integer otherNode : network.nodes()) {\n", "        Set<String> edgesConnecting = network.edgesConnecting(node, otherNode);\n", "        if (network.isDirected() || !isSelfLoop) {\n", "              Sets.intersection(network.outEdges(node), network.inEdges(otherNode)));\n", "        if (!network.allowsParallelEdges()) {\n", "        if (!network.allowsSelfLoops() && isSelfLoop) {\n", "          assertThat(network.incidentNodes(edge)).isEqualTo(Endpoints.of(network, node, otherNode));\n", "      for (String incidentEdge : network.incidentEdges(node)) {\n", "        assertTrue(network.inEdges(node).contains(incidentEdge)\n", "            || network.outEdges(node).contains(incidentEdge));\n", "        assertThat(network.edges()).contains(incidentEdge);\n", "        assertThat(network.incidentNodes(incidentEdge)).contains(node);\n", "      for (String inEdge : network.inEdges(node)) {\n", "        assertThat(network.incidentEdges(node)).contains(inEdge);\n", "        assertThat(network.outEdges(network.incidentNodes(inEdge).adjacentNode(node)))\n", "            .contains(inEdge);\n", "      for (String outEdge : network.outEdges(node)) {\n", "        assertThat(network.incidentEdges(node)).contains(outEdge);\n", "        assertThat(network.inEdges(network.incidentNodes(outEdge).adjacentNode(node)))\n", "      for (Integer adjacentNode : network.adjacentNodes(node)) {\n", "        assertTrue(network.predecessors(node).contains(adjacentNode)\n", "            || network.successors(node).contains(adjacentNode));\n", "        assertTrue(!network.edgesConnecting(node, adjacentNode).isEmpty()\n", "            || !network.edgesConnecting(adjacentNode, node).isEmpty());\n", "      for (Integer predecessor : network.predecessors(node)) {\n", "        assertThat(network.successors(predecessor)).contains(node);\n", "        assertThat(network.edgesConnecting(predecessor, node)).isNotEmpty();\n", "      for (Integer successor : network.successors(node)) {\n", "        assertThat(network.predecessors(successor)).contains(node);\n", "        assertThat(network.edgesConnecting(node, successor)).isNotEmpty();\n"], "4": ["    assertThat(network.nodes()).containsExactly(N1);\n", "    assertThat(network.nodes()).isEmpty();\n", "    assertThat(network.edges()).containsExactly(E12);\n", "    assertThat(network.edges()).isEmpty();\n", "    assertThat(network.edges()).isEmpty();\n", "    assertThat(network.incidentEdges(N2)).containsExactly(E12);\n", "    assertThat(network.incidentEdges(N1)).containsExactly(E12);\n", "    assertThat(network.incidentEdges(N1)).isEmpty();\n", "      network.incidentEdges(NODE_NOT_IN_GRAPH);\n"], "5": ["    assertThat(network.incidentNodes(E12)).containsExactly(N1, N2);\n", "      network.incidentNodes(EDGE_NOT_IN_GRAPH);\n"], "6": ["    assertThat(network.adjacentNodes(N1)).containsExactly(N2);\n", "    assertThat(network.adjacentNodes(N2)).containsExactly(N1);\n", "    assertThat(network.adjacentNodes(N1)).isEmpty();\n", "      network.adjacentNodes(NODE_NOT_IN_GRAPH);\n"], "7": ["    assertThat(network.adjacentEdges(E12)).containsExactly(E13, E23);\n", "    assertThat(network.adjacentEdges(E12)).isEmpty();\n", "      network.adjacentEdges(EDGE_NOT_IN_GRAPH);\n"], "8": ["    assertThat(network.edgesConnecting(N1, N2)).isEmpty();\n"], "9": ["      network.edgesConnecting(N1, NODE_NOT_IN_GRAPH);\n", "      network.edgesConnecting(NODE_NOT_IN_GRAPH, N2);\n", "      network.edgesConnecting(NODE_NOT_IN_GRAPH, NODE_NOT_IN_GRAPH);\n"], "10": ["    assertThat(network.inEdges(N1)).isEmpty();\n", "      network.inEdges(NODE_NOT_IN_GRAPH);\n"], "11": ["    assertThat(network.outEdges(N1)).isEmpty();\n", "      network.outEdges(NODE_NOT_IN_GRAPH);\n"], "12": ["    assertThat(network.predecessors(N1)).isEmpty();\n", "      network.predecessors(NODE_NOT_IN_GRAPH);\n"], "13": ["    assertThat(network.successors(N1)).isEmpty();\n", "      network.successors(NODE_NOT_IN_GRAPH);\n"], "14": ["    assertEquals(1, network.degree(N1));\n", "    assertEquals(1, network.degree(N2));\n", "    assertEquals(0, network.degree(N1));\n", "      network.degree(NODE_NOT_IN_GRAPH);\n"], "15": ["    assertEquals(0, network.inDegree(N1));\n", "      network.inDegree(NODE_NOT_IN_GRAPH);\n"], "16": ["    assertEquals(0, network.outDegree(N1));\n", "      network.outDegree(NODE_NOT_IN_GRAPH);\n"], "17": ["    assertThat(network.nodes()).contains(N1);\n", "    ImmutableSet<Integer> nodes = ImmutableSet.copyOf(network.nodes());\n", "    assertThat(network.nodes()).containsExactlyElementsIn(nodes);\n", "    assertTrue(network.removeNode(N1));\n", "    assertThat(network.nodes()).containsExactly(N2, N4);\n", "    assertThat(network.edges()).doesNotContain(E12);\n", "    assertThat(network.edges()).doesNotContain(E41);\n", "    ImmutableSet<Integer> nodes = ImmutableSet.copyOf(network.nodes());\n", "    assertFalse(network.removeNode(NODE_NOT_IN_GRAPH));\n", "    assertThat(network.nodes()).containsExactlyElementsIn(nodes);\n", "    Set<Integer> unused = network.adjacentNodes(N1); // ensure cache (if any) is populated\n", "    assertTrue(network.removeNode(N1));\n", "      network.adjacentNodes(N1);\n"], "18": ["    assertThat(network.edges()).containsExactly(E12, E13, E14);\n", "    assertTrue(network.removeEdge(E13));\n", "    assertThat(network.edges()).containsExactly(E12, E14);\n", "    ImmutableSet<String> edges = ImmutableSet.copyOf(network.edges());\n", "    assertFalse(network.removeEdge(EDGE_NOT_IN_GRAPH));\n", "    assertThat(network.edges()).containsExactlyElementsIn(edges);\n", "    Endpoints<Integer> unused = network.incidentNodes(E12); // ensure cache (if any) is populated\n", "    assertTrue(network.removeEdge(E12));\n", "      network.incidentNodes(E12);\n"]}, "removed": {"1": ["  MutableNetwork<Integer, String> graph;\n"], "2": ["    return graph.addNode(n);\n"], "3": ["    graph.addNode(n1);\n", "    graph.addNode(n2);\n", "    return graph.addEdge(e, n1, n2);\n", "    graph = createGraph();\n", "        graph,\n", "        Graphs.copyOf(graph),\n", "        ImmutableNetwork.copyOf(graph)).testEquals();\n", "\n", "    String graphString = graph.toString();\n", "    assertThat(graphString).contains(\"isDirected: \" + graph.isDirected());\n", "    assertThat(graphString).contains(\"allowsParallelEdges: \" + graph.allowsParallelEdges());\n", "    assertThat(graphString).contains(\"allowsSelfLoops: \" + graph.allowsSelfLoops());\n", "\n", "    int nodeStart = graphString.indexOf(\"nodes:\");\n", "    int edgeStart = graphString.indexOf(\"edges:\");\n", "    String nodeString = graphString.substring(nodeStart, edgeStart);\n", "    String edgeString = graphString.substring(edgeStart);\n", "\n", "    for (String edge : graph.edges()) {\n", "      Iterator<Integer> endpointsIterator = graph.incidentNodes(edge).iterator();\n", "      assertThat(graph.edgesConnecting(nodeA, nodeB)).contains(edge);\n", "      assertThat(graph.successors(nodeA)).contains(nodeB);\n", "      assertThat(graph.adjacentNodes(nodeA)).contains(nodeB);\n", "      assertThat(graph.outEdges(nodeA)).contains(edge);\n", "      assertThat(graph.incidentEdges(nodeA)).contains(edge);\n", "      assertThat(graph.predecessors(nodeB)).contains(nodeA);\n", "      assertThat(graph.adjacentNodes(nodeB)).contains(nodeA);\n", "      assertThat(graph.inEdges(nodeB)).contains(edge);\n", "      assertThat(graph.incidentEdges(nodeB)).contains(edge);\n", "\n", "      for (Integer incidentNode : graph.incidentNodes(edge)) {\n", "        assertThat(graph.nodes()).contains(incidentNode);\n", "        for (String adjacentEdge : graph.incidentEdges(incidentNode)) {\n", "          assertTrue(edge.equals(adjacentEdge) || graph.adjacentEdges(edge).contains(adjacentEdge));\n", "    for (Integer node : graph.nodes()) {\n", "      assertThat(graph.incidentEdges(node)).hasSize(graph.degree(node));\n", "      assertThat(graph.degree(node)).isAtLeast(graph.adjacentNodes(node).size());\n", "      assertThat(graph.inEdges(node)).hasSize(graph.inDegree(node));\n", "      assertThat(graph.inDegree(node)).isAtLeast(graph.predecessors(node).size());\n", "      assertThat(graph.outEdges(node)).hasSize(graph.outDegree(node));\n", "      assertThat(graph.outDegree(node)).isAtLeast(graph.successors(node).size());\n", "      for (Integer otherNode : graph.nodes()) {\n", "        Set<String> edgesConnecting = graph.edgesConnecting(node, otherNode);\n", "        if (graph.isDirected() || !isSelfLoop) {\n", "              Sets.intersection(graph.outEdges(node), graph.inEdges(otherNode)));\n", "        if (!graph.allowsParallelEdges()) {\n", "        if (!graph.allowsSelfLoops() && isSelfLoop) {\n", "          assertThat(graph.incidentNodes(edge)).isEqualTo(Endpoints.of(graph, node, otherNode));\n", "      for (String incidentEdge : graph.incidentEdges(node)) {\n", "        assertTrue(graph.inEdges(node).contains(incidentEdge)\n", "            || graph.outEdges(node).contains(incidentEdge));\n", "        assertThat(graph.edges()).contains(incidentEdge);\n", "        assertThat(graph.incidentNodes(incidentEdge)).contains(node);\n", "      for (String inEdge : graph.inEdges(node)) {\n", "        assertThat(graph.incidentEdges(node)).contains(inEdge);\n", "        assertThat(graph.outEdges(graph.incidentNodes(inEdge).adjacentNode(node))).contains(inEdge);\n", "      for (String outEdge : graph.outEdges(node)) {\n", "        assertThat(graph.incidentEdges(node)).contains(outEdge);\n", "        assertThat(graph.inEdges(graph.incidentNodes(outEdge).adjacentNode(node)))\n", "      for (Integer adjacentNode : graph.adjacentNodes(node)) {\n", "        assertTrue(graph.predecessors(node).contains(adjacentNode)\n", "            || graph.successors(node).contains(adjacentNode));\n", "        assertTrue(!graph.edgesConnecting(node, adjacentNode).isEmpty()\n", "            || !graph.edgesConnecting(adjacentNode, node).isEmpty());\n", "      for (Integer predecessor : graph.predecessors(node)) {\n", "        assertThat(graph.successors(predecessor)).contains(node);\n", "        assertThat(graph.edgesConnecting(predecessor, node)).isNotEmpty();\n", "      for (Integer successor : graph.successors(node)) {\n", "        assertThat(graph.predecessors(successor)).contains(node);\n", "        assertThat(graph.edgesConnecting(node, successor)).isNotEmpty();\n"], "4": ["    assertThat(graph.nodes()).containsExactly(N1);\n", "    assertThat(graph.nodes()).isEmpty();\n", "    assertThat(graph.edges()).containsExactly(E12);\n", "    assertThat(graph.edges()).isEmpty();\n", "    assertThat(graph.edges()).isEmpty();\n", "    assertThat(graph.incidentEdges(N2)).containsExactly(E12);\n", "    assertThat(graph.incidentEdges(N1)).containsExactly(E12);\n", "    assertThat(graph.incidentEdges(N1)).isEmpty();\n", "      graph.incidentEdges(NODE_NOT_IN_GRAPH);\n"], "5": ["    assertThat(graph.incidentNodes(E12)).containsExactly(N1, N2);\n", "      graph.incidentNodes(EDGE_NOT_IN_GRAPH);\n"], "6": ["    assertThat(graph.adjacentNodes(N1)).containsExactly(N2);\n", "    assertThat(graph.adjacentNodes(N2)).containsExactly(N1);\n", "    assertThat(graph.adjacentNodes(N1)).isEmpty();\n", "      graph.adjacentNodes(NODE_NOT_IN_GRAPH);\n"], "7": ["    assertThat(graph.adjacentEdges(E12)).containsExactly(E13, E23);\n", "    assertThat(graph.adjacentEdges(E12)).isEmpty();\n", "      graph.adjacentEdges(EDGE_NOT_IN_GRAPH);\n"], "8": ["    assertThat(graph.edgesConnecting(N1, N2)).isEmpty();\n"], "9": ["      graph.edgesConnecting(N1, NODE_NOT_IN_GRAPH);\n", "      graph.edgesConnecting(NODE_NOT_IN_GRAPH, N2);\n", "      graph.edgesConnecting(NODE_NOT_IN_GRAPH, NODE_NOT_IN_GRAPH);\n"], "10": ["    assertThat(graph.inEdges(N1)).isEmpty();\n", "      graph.inEdges(NODE_NOT_IN_GRAPH);\n"], "11": ["    assertThat(graph.outEdges(N1)).isEmpty();\n", "      graph.outEdges(NODE_NOT_IN_GRAPH);\n"], "12": ["    assertThat(graph.predecessors(N1)).isEmpty();\n", "      graph.predecessors(NODE_NOT_IN_GRAPH);\n"], "13": ["    assertThat(graph.successors(N1)).isEmpty();\n", "      graph.successors(NODE_NOT_IN_GRAPH);\n"], "14": ["    assertEquals(1, graph.degree(N1));\n", "    assertEquals(1, graph.degree(N2));\n", "    assertEquals(0, graph.degree(N1));\n", "      graph.degree(NODE_NOT_IN_GRAPH);\n"], "15": ["    assertEquals(0, graph.inDegree(N1));\n", "      graph.inDegree(NODE_NOT_IN_GRAPH);\n"], "16": ["    assertEquals(0, graph.outDegree(N1));\n", "      graph.outDegree(NODE_NOT_IN_GRAPH);\n"], "17": ["    assertThat(graph.nodes()).contains(N1);\n", "    ImmutableSet<Integer> nodes = ImmutableSet.copyOf(graph.nodes());\n", "    assertThat(graph.nodes()).containsExactlyElementsIn(nodes);\n", "    assertTrue(graph.removeNode(N1));\n", "    assertThat(graph.nodes()).containsExactly(N2, N4);\n", "    assertThat(graph.edges()).doesNotContain(E12);\n", "    assertThat(graph.edges()).doesNotContain(E41);\n", "    ImmutableSet<Integer> nodes = ImmutableSet.copyOf(graph.nodes());\n", "    assertFalse(graph.removeNode(NODE_NOT_IN_GRAPH));\n", "    assertThat(graph.nodes()).containsExactlyElementsIn(nodes);\n", "    Set<Integer> unused = graph.adjacentNodes(N1); // ensure cache (if any) is populated\n", "    assertTrue(graph.removeNode(N1));\n", "      graph.adjacentNodes(N1);\n"], "18": ["    assertThat(graph.edges()).containsExactly(E12, E13, E14);\n", "    assertTrue(graph.removeEdge(E13));\n", "    assertThat(graph.edges()).containsExactly(E12, E14);\n", "    ImmutableSet<String> edges = ImmutableSet.copyOf(graph.edges());\n", "    assertFalse(graph.removeEdge(EDGE_NOT_IN_GRAPH));\n", "    assertThat(graph.edges()).containsExactlyElementsIn(edges);\n", "    Endpoints<Integer> unused = graph.incidentNodes(E12); // ensure cache (if any) is populated\n", "    assertTrue(graph.removeEdge(E12));\n", "      graph.incidentNodes(E12);\n"]}, "added_lines": {"1": [53], "2": [110], "3": [134, 135, 136, 141, 147, 148, 149, 150, 151, 152, 153, 154, 155, 156, 157, 158, 159, 160, 161, 162, 163, 164, 165, 166, 167, 171, 174, 175, 176, 177, 178, 179, 180, 181, 182, 183, 184, 185, 186, 187, 188, 193, 196, 197, 198, 199, 200, 201, 202, 203, 204, 205, 207, 208, 210, 212, 214, 217, 221, 225, 226, 227, 228, 229, 232, 233, 234, 235, 238, 239, 240, 244, 245, 246, 247, 248, 251, 252, 253, 256, 257, 258], "4": [343, 348, 354, 359, 363, 369, 370, 376, 382], "5": [392, 398], "6": [408, 409, 415, 421], "7": [433, 439, 445], "8": [456], "9": [464, 470, 476], "10": [486, 492], "11": [502, 508], "12": [518, 524], "13": [534, 540], "14": [550, 551, 557, 563], "15": [573, 579], "16": [589, 595], "17": [605, 611, 613, 620, 621, 622, 623, 629, 630, 631, 637, 638, 640], "18": [652, 653, 654, 660, 661, 662, 668, 669, 671]}, "removed_lines": {"1": [53], "2": [110], "3": [134, 135, 136, 141, 147, 148, 149, 150, 151, 152, 153, 154, 155, 156, 157, 158, 159, 160, 161, 165, 168, 169, 170, 171, 172, 173, 174, 175, 176, 177, 178, 179, 180, 181, 186, 189, 190, 191, 192, 193, 194, 196, 197, 199, 201, 203, 206, 210, 214, 215, 216, 217, 218, 221, 222, 223, 226, 227, 228, 232, 233, 234, 235, 236, 239, 240, 241, 244, 245, 246], "4": [331, 336, 342, 347, 351, 357, 358, 364, 370], "5": [380, 386], "6": [396, 397, 403, 409], "7": [421, 427, 433], "8": [444], "9": [452, 458, 464], "10": [474, 480], "11": [490, 496], "12": [506, 512], "13": [522, 528], "14": [538, 539, 545, 551], "15": [561, 567], "16": [577, 583], "17": [593, 599, 601, 608, 609, 610, 611, 617, 618, 619, 625, 626, 628], "18": [640, 641, 642, 648, 649, 650, 656, 657, 659]}}, {"2": "guava-tests/test/com/google/common/graph/AbstractUndirectedNetworkTest.java", "added": {"1": ["    for (Integer node : network.nodes()) {\n", "          .addEqualityGroup(\n", "              network.inEdges(node),\n", "              network.outEdges(node),\n", "              network.incidentEdges(node))\n", "          .addEqualityGroup(\n", "              network.predecessors(node),\n", "              network.successors(node),\n", "              network.adjacentNodes(node))\n", "      for (Integer adjacentNode : network.adjacentNodes(node)) {\n", "        assertThat(network.edgesConnecting(node, adjacentNode))\n", "            .containsExactlyElementsIn(network.edgesConnecting(adjacentNode, node));\n"], "2": ["    assertThat(network.edgesConnecting(N1, N2)).containsExactly(E12);\n", "    assertThat(network.edgesConnecting(N2, N1)).containsExactly(E12);\n", "    assertThat(network.inEdges(N2)).containsExactly(E12);\n", "    assertThat(network.inEdges(N1)).containsExactly(E12);\n", "    assertThat(network.outEdges(N2)).containsExactly(E12);\n", "    assertThat(network.outEdges(N1)).containsExactly(E12);\n", "    assertThat(network.predecessors(N2)).containsExactly(N1);\n", "    assertThat(network.predecessors(N1)).containsExactly(N2);\n", "    assertThat(network.successors(N1)).containsExactly(N2);\n", "    assertThat(network.successors(N2)).containsExactly(N1);\n", "    assertEquals(1, network.inDegree(N2));\n", "    assertEquals(1, network.inDegree(N1));\n", "    assertEquals(1, network.outDegree(N1));\n", "    assertEquals(1, network.outDegree(N2));\n"], "3": ["    assertThat(network.edges()).contains(E12);\n", "    assertThat(network.edgesConnecting(N1, N2)).containsExactly(E12);\n", "    assertThat(network.edgesConnecting(N2, N1)).containsExactly(E12);\n", "    ImmutableSet<String> edges = ImmutableSet.copyOf(network.edges());\n", "    assertThat(network.edges()).containsExactlyElementsIn(edges);\n", "    assertThat(network.edges()).containsExactlyElementsIn(edges);\n"], "4": ["    assertTrue(network.removeEdge(E12));\n", "    assertThat(network.edges()).doesNotContain(E12);\n", "    assertThat(network.edgesConnecting(N1, N2)).isEmpty();\n", "    assertThat(network.edgesConnecting(N2, N1)).isEmpty();\n"]}, "removed": {"1": ["    for (Integer node : graph.nodes()) {\n", "          .addEqualityGroup(graph.inEdges(node), graph.outEdges(node), graph.incidentEdges(node))\n", "          .addEqualityGroup(graph.predecessors(node), graph.successors(node),\n", "              graph.adjacentNodes(node))\n", "      for (Integer adjacentNode : graph.adjacentNodes(node)) {\n", "        assertThat(graph.edgesConnecting(node, adjacentNode))\n", "            .containsExactlyElementsIn(graph.edgesConnecting(adjacentNode, node));\n"], "2": ["    assertThat(graph.edgesConnecting(N1, N2)).containsExactly(E12);\n", "    assertThat(graph.edgesConnecting(N2, N1)).containsExactly(E12);\n", "    assertThat(graph.inEdges(N2)).containsExactly(E12);\n", "    assertThat(graph.inEdges(N1)).containsExactly(E12);\n", "    assertThat(graph.outEdges(N2)).containsExactly(E12);\n", "    assertThat(graph.outEdges(N1)).containsExactly(E12);\n", "    assertThat(graph.predecessors(N2)).containsExactly(N1);\n", "    assertThat(graph.predecessors(N1)).containsExactly(N2);\n", "    assertThat(graph.successors(N1)).containsExactly(N2);\n", "    assertThat(graph.successors(N2)).containsExactly(N1);\n", "    assertEquals(1, graph.inDegree(N2));\n", "    assertEquals(1, graph.inDegree(N1));\n", "    assertEquals(1, graph.outDegree(N1));\n", "    assertEquals(1, graph.outDegree(N2));\n"], "3": ["    assertThat(graph.edges()).contains(E12);\n", "    assertThat(graph.edgesConnecting(N1, N2)).containsExactly(E12);\n", "    assertThat(graph.edgesConnecting(N2, N1)).containsExactly(E12);\n", "    ImmutableSet<String> edges = ImmutableSet.copyOf(graph.edges());\n", "    assertThat(graph.edges()).containsExactlyElementsIn(edges);\n", "    assertThat(graph.edges()).containsExactlyElementsIn(edges);\n"], "4": ["    assertTrue(graph.removeEdge(E12));\n", "    assertThat(graph.edges()).doesNotContain(E12);\n", "    assertThat(graph.edgesConnecting(N1, N2)).isEmpty();\n", "    assertThat(graph.edgesConnecting(N2, N1)).isEmpty();\n"]}, "added_lines": {"1": [41, 43, 44, 45, 46, 49, 50, 51, 52, 55, 56, 57], "2": [65, 66, 72, 73, 79, 80, 86, 87, 93, 94, 100, 101, 107, 108], "3": [120, 121, 122, 128, 130, 132], "4": [167, 168, 169, 170]}, "removed_lines": {"1": [42, 44, 47, 48, 51, 52, 53], "2": [61, 62, 68, 69, 75, 76, 82, 83, 89, 90, 96, 97, 103, 104], "3": [116, 117, 118, 124, 126, 128], "4": [163, 164, 165, 166]}}, {"3": "guava-tests/test/com/google/common/graph/ConfigurableDirectedMultiNetworkTest.java", "added": {"1": ["    assertThat(network.edgesConnecting(N1, N2)).containsExactly(E12, E12_A);\n", "    assertThat(network.edgesConnecting(N2, N1)).isEmpty();\n", "    assertThat(network.edgesConnecting(N1, N1)).containsExactly(E11, E11_A);\n"], "2": ["    assertThat(network.edgesConnecting(N1, N2)).containsExactly(E12, E12_A);\n"], "3": ["    assertThat(network.edgesConnecting(N1, N1)).containsExactly(E11, E11_A);\n", "    assertTrue(network.removeEdge(E12_A));\n", "    assertThat(network.edgesConnecting(N1, N2)).containsExactly(E12);\n"], "4": ["    assertTrue(network.removeEdge(E11_A));\n", "    assertThat(network.edgesConnecting(N1, N1)).containsExactly(E11);\n", "    assertThat(network.edgesConnecting(N1, N2)).containsExactly(E12);\n", "    assertTrue(network.removeEdge(E11));\n", "    assertThat(network.edgesConnecting(N1, N1)).isEmpty();\n", "    assertThat(network.edgesConnecting(N1, N2)).containsExactly(E12);\n"]}, "removed": {"1": ["    assertThat(graph.edgesConnecting(N1, N2)).containsExactly(E12, E12_A);\n", "    assertThat(graph.edgesConnecting(N2, N1)).isEmpty();\n", "    assertThat(graph.edgesConnecting(N1, N1)).containsExactly(E11, E11_A);\n"], "2": ["    assertThat(graph.edgesConnecting(N1, N2)).containsExactly(E12, E12_A);\n"], "3": ["    assertThat(graph.edgesConnecting(N1, N1)).containsExactly(E11, E11_A);\n", "    assertTrue(graph.removeEdge(E12_A));\n", "    assertThat(graph.edgesConnecting(N1, N2)).containsExactly(E12);\n"], "4": ["    assertTrue(graph.removeEdge(E11_A));\n", "    assertThat(graph.edgesConnecting(N1, N1)).containsExactly(E11);\n", "    assertThat(graph.edgesConnecting(N1, N2)).containsExactly(E12);\n", "    assertTrue(graph.removeEdge(E11));\n", "    assertThat(graph.edgesConnecting(N1, N1)).isEmpty();\n", "    assertThat(graph.edgesConnecting(N1, N2)).containsExactly(E12);\n"]}, "added_lines": {"1": [40, 43, 50], "2": [58], "3": [66, 73, 74], "4": [82, 83, 84, 85, 86, 87]}, "removed_lines": {"1": [40, 43, 50], "2": [58], "3": [66, 73, 74], "4": [82, 83, 84, 85, 86, 87]}}, {"4": "guava-tests/test/com/google/common/graph/ConfigurableDirectedNetworkTest.java", "added": {"1": ["    assertThat(network.edges()).containsExactly(E11);\n", "    assertThat(network.incidentEdges(N1)).containsExactly(E11);\n", "    assertThat(network.incidentNodes(E11)).containsExactly(N1, N1);\n", "    assertThat(network.adjacentNodes(N1)).containsExactly(N1, N2);\n", "    assertThat(network.adjacentEdges(E11)).isEmpty();\n", "    assertThat(network.adjacentEdges(E11)).containsExactly(E12);\n", "    assertThat(network.edgesConnecting(N1, N1)).containsExactly(E11);\n", "    assertThat(network.edgesConnecting(N1, N2)).containsExactly(E12);\n", "    assertThat(network.edgesConnecting(N1, N1)).containsExactly(E11);\n", "    assertThat(network.inEdges(N1)).containsExactly(E11);\n", "    assertThat(network.inEdges(N1)).containsExactly(E11, E41);\n", "    assertThat(network.outEdges(N1)).containsExactly(E11);\n", "    assertThat(network.outEdges(N1)).containsExactly(E11, E12);\n", "    assertThat(network.predecessors(N1)).containsExactly(N1);\n", "    assertThat(network.predecessors(N1)).containsExactly(N1, N4);\n", "    assertThat(network.successors(N1)).containsExactly(N1);\n", "    assertThat(network.successors(N1)).containsExactly(N1, N2);\n", "    assertEquals(1, network.degree(N1));\n", "    assertEquals(2, network.degree(N1));\n", "    assertEquals(1, network.inDegree(N1));\n", "    assertEquals(2, network.inDegree(N1));\n", "    assertEquals(1, network.outDegree(N1));\n", "    assertEquals(2, network.outDegree(N1));\n", "    assertEquals(N1, network.incidentNodes(E11).source());\n", "    assertEquals(N1, network.incidentNodes(E11).target());\n", "    assertThat(network.edges()).contains(E11);\n", "    assertThat(network.edgesConnecting(N1, N1)).containsExactly(E11);\n", "    ImmutableSet<String> edges = ImmutableSet.copyOf(network.edges());\n", "    assertThat(network.edges()).containsExactlyElementsIn(edges);\n"], "2": ["    assertTrue(network.removeNode(N1));\n", "    assertThat(network.nodes()).isEmpty();\n", "    assertThat(network.edges()).doesNotContain(E11);\n", "    assertTrue(network.removeEdge(E11));\n", "    assertThat(network.edges()).doesNotContain(E11);\n", "    assertThat(network.edgesConnecting(N1, N1)).isEmpty();\n"]}, "removed": {"1": ["    assertThat(graph.edges()).containsExactly(E11);\n", "    assertThat(graph.incidentEdges(N1)).containsExactly(E11);\n", "    assertThat(graph.incidentNodes(E11)).containsExactly(N1, N1);\n", "    assertThat(graph.adjacentNodes(N1)).containsExactly(N1, N2);\n", "    assertThat(graph.adjacentEdges(E11)).isEmpty();\n", "    assertThat(graph.adjacentEdges(E11)).containsExactly(E12);\n", "    assertThat(graph.edgesConnecting(N1, N1)).containsExactly(E11);\n", "    assertThat(graph.edgesConnecting(N1, N2)).containsExactly(E12);\n", "    assertThat(graph.edgesConnecting(N1, N1)).containsExactly(E11);\n", "    assertThat(graph.inEdges(N1)).containsExactly(E11);\n", "    assertThat(graph.inEdges(N1)).containsExactly(E11, E41);\n", "    assertThat(graph.outEdges(N1)).containsExactly(E11);\n", "    assertThat(graph.outEdges(N1)).containsExactly(E11, E12);\n", "    assertThat(graph.predecessors(N1)).containsExactly(N1);\n", "    assertThat(graph.predecessors(N1)).containsExactly(N1, N4);\n", "    assertThat(graph.successors(N1)).containsExactly(N1);\n", "    assertThat(graph.successors(N1)).containsExactly(N1, N2);\n", "    assertEquals(1, graph.degree(N1));\n", "    assertEquals(2, graph.degree(N1));\n", "    assertEquals(1, graph.inDegree(N1));\n", "    assertEquals(2, graph.inDegree(N1));\n", "    assertEquals(1, graph.outDegree(N1));\n", "    assertEquals(2, graph.outDegree(N1));\n", "    assertEquals(N1, graph.incidentNodes(E11).source());\n", "    assertEquals(N1, graph.incidentNodes(E11).target());\n", "    assertThat(graph.edges()).contains(E11);\n", "    assertThat(graph.edgesConnecting(N1, N1)).containsExactly(E11);\n", "    ImmutableSet<String> edges = ImmutableSet.copyOf(graph.edges());\n", "    assertThat(graph.edges()).containsExactlyElementsIn(edges);\n"], "2": ["    assertTrue(graph.removeNode(N1));\n", "    assertThat(graph.nodes()).isEmpty();\n", "    assertThat(graph.edges()).doesNotContain(E11);\n", "    assertTrue(graph.removeEdge(E11));\n", "    assertThat(graph.edges()).doesNotContain(E11);\n", "    assertThat(graph.edgesConnecting(N1, N1)).isEmpty();\n"]}, "added_lines": {"1": [44, 50, 56, 63, 70, 72, 78, 80, 81, 87, 89, 95, 97, 103, 105, 111, 113, 119, 121, 127, 129, 135, 137, 143, 149, 156, 157, 163, 165], "2": [207, 208, 209, 215, 216, 217]}, "removed_lines": {"1": [45, 51, 57, 64, 71, 73, 79, 81, 82, 88, 90, 96, 98, 104, 106, 112, 114, 120, 122, 128, 130, 136, 138, 144, 150, 157, 158, 164, 166], "2": [208, 209, 210, 216, 217, 218]}}, {"5": "guava-tests/test/com/google/common/graph/ConfigurableSimpleDirectedNetworkTest.java", "added": {"1": ["    Set<Integer> nodes = network.nodes();\n", "      assertThat(network.nodes()).containsExactlyElementsIn(nodes);\n", "    Set<String> edges = network.edges();\n", "      assertThat(network.edges()).containsExactlyElementsIn(edges);\n"], "2": ["    Set<String> incidentEdges = network.incidentEdges(N1);\n", "      assertThat(network.incidentEdges(N1)).containsExactlyElementsIn(incidentEdges);\n"], "3": ["    Endpoints<Integer> incidentNodes = network.incidentNodes(E12);\n"], "4": ["    Set<Integer> adjacentNodes = network.adjacentNodes(N1);\n", "      assertThat(network.adjacentNodes(N1)).containsExactlyElementsIn(adjacentNodes);\n"], "5": ["    Set<String> adjacentEdges = network.adjacentEdges(E12);\n", "      assertThat(network.adjacentEdges(E12)).containsExactlyElementsIn(adjacentEdges);\n"], "6": ["    Set<String> edgesConnecting = network.edgesConnecting(N1, N2);\n", "      assertThat(network.edgesConnecting(N1, N2)).containsExactlyElementsIn(edgesConnecting);\n"], "7": ["    Set<String> inEdges = network.inEdges(N2);\n", "      assertThat(network.inEdges(N2)).containsExactlyElementsIn(inEdges);\n"], "8": ["    Set<String> outEdges = network.outEdges(N1);\n", "      assertThat(network.outEdges(N1)).containsExactlyElementsIn(outEdges);\n"], "9": ["    Set<Integer> predecessors = network.predecessors(N2);\n", "      assertThat(network.predecessors(N2)).containsExactlyElementsIn(predecessors);\n"], "10": ["    Set<Integer> successors = network.successors(N1);\n", "      assertThat(successors).containsExactlyElementsIn(network.successors(N1));\n"], "11": ["    network.addNode(N1);\n", "    assertTrue(network.addEdge(E15, N1, N5));\n", "    assertTrue(network.addEdge(E41, N4, N1));\n", "    assertTrue(network.addEdge(E23, N2, N3));\n", "    assertThat(network.nodes()).containsExactly(N1, N5, N4, N2, N3).inOrder();\n", "    assertThat(network.edges()).containsExactly(E15, E41, E23).inOrder();\n", "    assertThat(network.edgesConnecting(N1, N5)).containsExactly(E15);\n", "    assertThat(network.edgesConnecting(N4, N1)).containsExactly(E41);\n", "    assertThat(network.edgesConnecting(N2, N3)).containsExactly(E23);\n", "    assertThat(network.edgesConnecting(N3, N2)).isEmpty();\n"]}, "removed": {"1": ["    Set<Integer> nodes = graph.nodes();\n", "      assertThat(graph.nodes()).containsExactlyElementsIn(nodes);\n", "    Set<String> edges = graph.edges();\n", "      assertThat(graph.edges()).containsExactlyElementsIn(edges);\n"], "2": ["    Set<String> incidentEdges = graph.incidentEdges(N1);\n", "      assertThat(graph.incidentEdges(N1)).containsExactlyElementsIn(incidentEdges);\n"], "3": ["    Endpoints<Integer> incidentNodes = graph.incidentNodes(E12);\n"], "4": ["    Set<Integer> adjacentNodes = graph.adjacentNodes(N1);\n", "      assertThat(graph.adjacentNodes(N1)).containsExactlyElementsIn(adjacentNodes);\n"], "5": ["    Set<String> adjacentEdges = graph.adjacentEdges(E12);\n", "      assertThat(graph.adjacentEdges(E12)).containsExactlyElementsIn(adjacentEdges);\n"], "6": ["    Set<String> edgesConnecting = graph.edgesConnecting(N1, N2);\n", "      assertThat(graph.edgesConnecting(N1, N2)).containsExactlyElementsIn(edgesConnecting);\n"], "7": ["    Set<String> inEdges = graph.inEdges(N2);\n", "      assertThat(graph.inEdges(N2)).containsExactlyElementsIn(inEdges);\n"], "8": ["    Set<String> outEdges = graph.outEdges(N1);\n", "      assertThat(graph.outEdges(N1)).containsExactlyElementsIn(outEdges);\n"], "9": ["    Set<Integer> predecessors = graph.predecessors(N2);\n", "      assertThat(graph.predecessors(N2)).containsExactlyElementsIn(predecessors);\n"], "10": ["    Set<Integer> successors = graph.successors(N1);\n", "      assertThat(successors).containsExactlyElementsIn(graph.successors(N1));\n"], "11": ["    graph.addNode(N1);\n", "    assertTrue(graph.addEdge(E15, N1, N5));\n", "    assertTrue(graph.addEdge(E41, N4, N1));\n", "    assertTrue(graph.addEdge(E23, N2, N3));\n", "    assertThat(graph.nodes()).containsExactly(N1, N5, N4, N2, N3).inOrder();\n", "    assertThat(graph.edges()).containsExactly(E15, E41, E23).inOrder();\n", "    assertThat(graph.edgesConnecting(N1, N5)).containsExactly(E15);\n", "    assertThat(graph.edgesConnecting(N4, N1)).containsExactly(E41);\n", "    assertThat(graph.edgesConnecting(N2, N3)).containsExactly(E23);\n", "    assertThat(graph.edgesConnecting(N3, N2)).isEmpty();\n"]}, "added_lines": {"1": [43, 49, 56, 62], "2": [70, 76], "3": [84], "4": [96, 102], "5": [110, 116], "6": [125, 131], "7": [139, 145], "8": [153, 159], "9": [167, 173], "10": [181, 187], "11": [212, 213, 214, 215, 216, 217, 218, 219, 220, 222]}, "removed_lines": {"1": [43, 49, 56, 62], "2": [70, 76], "3": [84], "4": [96, 102], "5": [110, 116], "6": [125, 131], "7": [139, 145], "8": [153, 159], "9": [167, 173], "10": [181, 187], "11": [212, 213, 214, 215, 216, 217, 218, 219, 220, 222]}}, {"6": "guava-tests/test/com/google/common/graph/ConfigurableSimpleUndirectedNetworkTest.java", "added": {"1": ["    Set<Integer> nodes = network.nodes();\n", "      assertThat(network.nodes()).containsExactlyElementsIn(nodes);\n", "    Set<String> edges = network.edges();\n", "      assertThat(network.edges()).containsExactlyElementsIn(edges);\n"], "2": ["    Set<String> incidentEdges = network.incidentEdges(N1);\n", "      assertThat(network.incidentEdges(N1)).containsExactlyElementsIn(incidentEdges);\n"], "3": ["    Endpoints<Integer> incidentNodes = network.incidentNodes(E12);\n"], "4": ["    Set<Integer> adjacentNodes = network.adjacentNodes(N1);\n", "      assertThat(network.adjacentNodes(N1)).containsExactlyElementsIn(adjacentNodes);\n"], "5": ["    Set<String> adjacentEdges = network.adjacentEdges(E12);\n", "      assertThat(network.adjacentEdges(E12)).containsExactlyElementsIn(adjacentEdges);\n"], "6": ["    Set<String> edgesConnecting = network.edgesConnecting(N1, N2);\n", "      assertThat(network.edgesConnecting(N1, N2))\n"], "7": ["    Set<String> inEdges = network.inEdges(N2);\n", "      assertThat(network.inEdges(N2)).containsExactlyElementsIn(inEdges);\n"], "8": ["    Set<String> outEdges = network.outEdges(N1);\n", "      assertThat(network.outEdges(N1)).containsExactlyElementsIn(outEdges);\n"], "9": ["    Set<Integer> predecessors = network.predecessors(N2);\n", "      assertThat(network.predecessors(N2)).containsExactlyElementsIn(predecessors);\n"], "10": ["    Set<Integer> successors = network.successors(N1);\n", "      assertThat(network.successors(N1)).containsExactlyElementsIn(successors);\n"], "11": ["    network.addNode(N1);\n", "    assertTrue(network.addEdge(E15, N1, N5));\n", "    assertTrue(network.addEdge(E41, N4, N1));\n", "    assertTrue(network.addEdge(E23, N2, N3));\n", "    assertThat(network.nodes()).containsExactly(N1, N5, N4, N2, N3).inOrder();\n", "    assertThat(network.edges()).containsExactly(E15, E41, E23).inOrder();\n", "    assertThat(network.edgesConnecting(N1, N5)).containsExactly(E15);\n", "    assertThat(network.edgesConnecting(N4, N1)).containsExactly(E41);\n", "    assertThat(network.edgesConnecting(N2, N3)).containsExactly(E23);\n", "    assertThat(network.edgesConnecting(N3, N2)).containsExactly(E23);\n"]}, "removed": {"1": ["    Set<Integer> nodes = graph.nodes();\n", "      assertThat(graph.nodes()).containsExactlyElementsIn(nodes);\n", "    Set<String> edges = graph.edges();\n", "      assertThat(graph.edges()).containsExactlyElementsIn(edges);\n"], "2": ["    Set<String> incidentEdges = graph.incidentEdges(N1);\n", "      assertThat(graph.incidentEdges(N1)).containsExactlyElementsIn(incidentEdges);\n"], "3": ["    Endpoints<Integer> incidentNodes = graph.incidentNodes(E12);\n"], "4": ["    Set<Integer> adjacentNodes = graph.adjacentNodes(N1);\n", "      assertThat(graph.adjacentNodes(N1)).containsExactlyElementsIn(adjacentNodes);\n"], "5": ["    Set<String> adjacentEdges = graph.adjacentEdges(E12);\n", "      assertThat(graph.adjacentEdges(E12)).containsExactlyElementsIn(adjacentEdges);\n"], "6": ["    Set<String> edgesConnecting = graph.edgesConnecting(N1, N2);\n", "      assertThat(graph.edgesConnecting(N1, N2))\n"], "7": ["    Set<String> inEdges = graph.inEdges(N2);\n", "      assertThat(graph.inEdges(N2)).containsExactlyElementsIn(inEdges);\n"], "8": ["    Set<String> outEdges = graph.outEdges(N1);\n", "      assertThat(graph.outEdges(N1)).containsExactlyElementsIn(outEdges);\n"], "9": ["    Set<Integer> predecessors = graph.predecessors(N2);\n", "      assertThat(graph.predecessors(N2)).containsExactlyElementsIn(predecessors);\n"], "10": ["    Set<Integer> successors = graph.successors(N1);\n", "      assertThat(graph.successors(N1)).containsExactlyElementsIn(successors);\n"], "11": ["    graph.addNode(N1);\n", "    assertTrue(graph.addEdge(E15, N1, N5));\n", "    assertTrue(graph.addEdge(E41, N4, N1));\n", "    assertTrue(graph.addEdge(E23, N2, N3));\n", "    assertThat(graph.nodes()).containsExactly(N1, N5, N4, N2, N3).inOrder();\n", "    assertThat(graph.edges()).containsExactly(E15, E41, E23).inOrder();\n", "    assertThat(graph.edgesConnecting(N1, N5)).containsExactly(E15);\n", "    assertThat(graph.edgesConnecting(N4, N1)).containsExactly(E41);\n", "    assertThat(graph.edgesConnecting(N2, N3)).containsExactly(E23);\n", "    assertThat(graph.edgesConnecting(N3, N2)).containsExactly(E23);\n"]}, "added_lines": {"1": [43, 49, 56, 62], "2": [70, 76], "3": [84], "4": [96, 102], "5": [110, 116], "6": [125, 131], "7": [140, 146], "8": [154, 160], "9": [168, 174], "10": [182, 188], "11": [213, 214, 215, 216, 217, 218, 219, 220, 221, 222]}, "removed_lines": {"1": [43, 49, 56, 62], "2": [70, 76], "3": [84], "4": [96, 102], "5": [110, 116], "6": [125, 131], "7": [140, 146], "8": [154, 160], "9": [168, 174], "10": [182, 188], "11": [213, 214, 215, 216, 217, 218, 219, 220, 221, 222]}}, {"7": "guava-tests/test/com/google/common/graph/ConfigurableUndirectedMultiNetworkTest.java", "added": {"1": ["    assertThat(network.edgesConnecting(N1, N2)).containsExactly(E12, E12_A, E21);\n", "    assertThat(network.edgesConnecting(N2, N1)).containsExactly(E12, E12_A, E21);\n", "    assertThat(network.edgesConnecting(N1, N1)).containsExactly(E11, E11_A);\n"], "2": ["    assertThat(network.edgesConnecting(N1, N2)).containsExactly(E12, E12_A, E21);\n"], "3": ["    assertThat(network.edgesConnecting(N1, N1)).containsExactly(E11, E11_A);\n"], "4": ["    assertTrue(network.removeEdge(E12_A));\n", "    assertThat(network.edgesConnecting(N1, N2)).containsExactly(E12, E21);\n"], "5": ["    assertTrue(network.removeEdge(E11_A));\n", "    assertThat(network.edgesConnecting(N1, N1)).containsExactly(E11);\n", "    assertThat(network.edgesConnecting(N1, N2)).containsExactly(E12);\n", "    assertTrue(network.removeEdge(E11));\n", "    assertThat(network.edgesConnecting(N1, N1)).isEmpty();\n", "    assertThat(network.edgesConnecting(N1, N2)).containsExactly(E12);\n"]}, "removed": {"1": ["    assertThat(graph.edgesConnecting(N1, N2)).containsExactly(E12, E12_A, E21);\n", "    assertThat(graph.edgesConnecting(N2, N1)).containsExactly(E12, E12_A, E21);\n", "    assertThat(graph.edgesConnecting(N1, N1)).containsExactly(E11, E11_A);\n"], "2": ["    assertThat(graph.edgesConnecting(N1, N2)).containsExactly(E12, E12_A, E21);\n"], "3": ["    assertThat(graph.edgesConnecting(N1, N1)).containsExactly(E11, E11_A);\n"], "4": ["    assertTrue(graph.removeEdge(E12_A));\n", "    assertThat(graph.edgesConnecting(N1, N2)).containsExactly(E12, E21);\n"], "5": ["    assertTrue(graph.removeEdge(E11_A));\n", "    assertThat(graph.edgesConnecting(N1, N1)).containsExactly(E11);\n", "    assertThat(graph.edgesConnecting(N1, N2)).containsExactly(E12);\n", "    assertTrue(graph.removeEdge(E11));\n", "    assertThat(graph.edgesConnecting(N1, N1)).isEmpty();\n", "    assertThat(graph.edgesConnecting(N1, N2)).containsExactly(E12);\n"]}, "added_lines": {"1": [41, 42, 49], "2": [58], "3": [66], "4": [74, 75], "5": [83, 84, 85, 86, 87, 88]}, "removed_lines": {"1": [41, 42, 49], "2": [58], "3": [66], "4": [74, 75], "5": [83, 84, 85, 86, 87, 88]}}, {"8": "guava-tests/test/com/google/common/graph/ConfigurableUndirectedNetworkTest.java", "added": {"1": ["    assertThat(network.edges()).containsExactly(E11);\n", "    assertThat(network.incidentEdges(N1)).containsExactly(E11);\n", "    assertThat(network.incidentNodes(E11)).containsExactly(N1, N1);\n", "    assertThat(network.adjacentNodes(N1)).containsExactly(N1, N2);\n", "    assertThat(network.adjacentEdges(E11)).isEmpty();\n", "    assertThat(network.adjacentEdges(E11)).containsExactly(E12);\n", "    assertThat(network.edgesConnecting(N1, N1)).containsExactly(E11);\n", "    assertThat(network.edgesConnecting(N1, N2)).containsExactly(E12);\n", "    assertThat(network.edgesConnecting(N2, N1)).containsExactly(E12);\n", "    assertThat(network.edgesConnecting(N1, N1)).containsExactly(E11);\n", "    assertThat(network.inEdges(N1)).containsExactly(E11);\n", "    assertThat(network.inEdges(N1)).containsExactly(E11, E12);\n", "    assertThat(network.outEdges(N1)).containsExactly(E11);\n", "    assertThat(network.outEdges(N1)).containsExactly(E11, E12);\n", "    assertThat(network.predecessors(N1)).containsExactly(N1);\n", "    assertThat(network.predecessors(N1)).containsExactly(N1, N2);\n", "    assertThat(network.successors(N1)).containsExactly(N1);\n", "    assertThat(network.successors(N1)).containsExactly(N1, N2);\n", "    assertEquals(1, network.degree(N1));\n", "    assertEquals(2, network.degree(N1));\n", "    assertEquals(1, network.inDegree(N1));\n", "    assertEquals(2, network.inDegree(N1));\n", "    assertEquals(1, network.outDegree(N1));\n", "    assertEquals(2, network.outDegree(N1));\n", "    assertThat(network.edges()).contains(E11);\n", "    assertThat(network.edgesConnecting(N1, N1)).containsExactly(E11);\n", "    ImmutableSet<String> edges = ImmutableSet.copyOf(network.edges());\n", "    assertThat(network.edges()).containsExactlyElementsIn(edges);\n"], "2": ["    assertTrue(network.removeNode(N1));\n", "    assertThat(network.nodes()).isEmpty();\n", "    assertThat(network.edges()).doesNotContain(E11);\n", "    assertTrue(network.removeEdge(E11));\n", "    assertThat(network.edges()).doesNotContain(E11);\n", "    assertThat(network.edgesConnecting(N1, N1)).isEmpty();\n"]}, "removed": {"1": ["    assertThat(graph.edges()).containsExactly(E11);\n", "    assertThat(graph.incidentEdges(N1)).containsExactly(E11);\n", "    assertThat(graph.incidentNodes(E11)).containsExactly(N1, N1);\n", "    assertThat(graph.adjacentNodes(N1)).containsExactly(N1, N2);\n", "    assertThat(graph.adjacentEdges(E11)).isEmpty();\n", "    assertThat(graph.adjacentEdges(E11)).containsExactly(E12);\n", "    assertThat(graph.edgesConnecting(N1, N1)).containsExactly(E11);\n", "    assertThat(graph.edgesConnecting(N1, N2)).containsExactly(E12);\n", "    assertThat(graph.edgesConnecting(N2, N1)).containsExactly(E12);\n", "    assertThat(graph.edgesConnecting(N1, N1)).containsExactly(E11);\n", "    assertThat(graph.inEdges(N1)).containsExactly(E11);\n", "    assertThat(graph.inEdges(N1)).containsExactly(E11, E12);\n", "    assertThat(graph.outEdges(N1)).containsExactly(E11);\n", "    assertThat(graph.outEdges(N1)).containsExactly(E11, E12);\n", "    assertThat(graph.predecessors(N1)).containsExactly(N1);\n", "    assertThat(graph.predecessors(N1)).containsExactly(N1, N2);\n", "    assertThat(graph.successors(N1)).containsExactly(N1);\n", "    assertThat(graph.successors(N1)).containsExactly(N1, N2);\n", "    assertEquals(1, graph.degree(N1));\n", "    assertEquals(2, graph.degree(N1));\n", "    assertEquals(1, graph.inDegree(N1));\n", "    assertEquals(2, graph.inDegree(N1));\n", "    assertEquals(1, graph.outDegree(N1));\n", "    assertEquals(2, graph.outDegree(N1));\n", "    assertThat(graph.edges()).contains(E11);\n", "    assertThat(graph.edgesConnecting(N1, N1)).containsExactly(E11);\n", "    ImmutableSet<String> edges = ImmutableSet.copyOf(graph.edges());\n", "    assertThat(graph.edges()).containsExactlyElementsIn(edges);\n"], "2": ["    assertTrue(graph.removeNode(N1));\n", "    assertThat(graph.nodes()).isEmpty();\n", "    assertThat(graph.edges()).doesNotContain(E11);\n", "    assertTrue(graph.removeEdge(E11));\n", "    assertThat(graph.edges()).doesNotContain(E11);\n", "    assertThat(graph.edgesConnecting(N1, N1)).isEmpty();\n"]}, "added_lines": {"1": [44, 50, 56, 63, 70, 72, 78, 80, 81, 82, 88, 90, 96, 98, 104, 106, 112, 114, 120, 122, 128, 130, 136, 138, 145, 146, 152, 154], "2": [196, 197, 198, 204, 205, 206]}, "removed_lines": {"1": [45, 51, 57, 64, 71, 73, 79, 81, 82, 83, 89, 91, 97, 99, 105, 107, 113, 115, 121, 123, 129, 131, 137, 139, 146, 147, 153, 155], "2": [197, 198, 199, 205, 206, 207]}}, {"9": "guava-tests/test/com/google/common/graph/GraphPropertiesTest.java", "added": {"1": ["    Graph<Integer> directedGraph = GraphBuilder.directed().build();\n", "    MutableGraph<Integer> directedGraph = GraphBuilder.directed().build();\n", "    directedGraph.addNode(1);\n", "    directedGraph.addNode(2);\n", "    MutableGraph<Integer> directedGraph = GraphBuilder.directed().build();\n", "    directedGraph.addEdge(1, 2);\n", "    MutableGraph<Integer> directedGraph = GraphBuilder.directed().build();\n", "    directedGraph.addEdge(1, 1);\n", "    MutableGraph<Integer> directedGraph = GraphBuilder.directed().build();\n", "    directedGraph.addEdge(1, 2);\n", "    directedGraph.addEdge(1, 3);\n", "    MutableGraph<Integer> directedGraph = GraphBuilder.directed().build();\n", "    directedGraph.addEdge(1, 2);\n", "    directedGraph.addEdge(2, 1);\n", "    MutableGraph<Integer> directedGraph = GraphBuilder.directed().build();\n", "    directedGraph.addEdge(1, 2);\n", "    directedGraph.addEdge(2, 3);\n", "    directedGraph.addEdge(1, 3);\n", "    MutableGraph<Integer> directedGraph = GraphBuilder.directed().build();\n", "    directedGraph.addEdge(1, 2);\n", "    directedGraph.addEdge(2, 3);\n", "    directedGraph.addEdge(3, 1);\n", "    MutableGraph<Integer> directedGraph = GraphBuilder.directed().build();\n", "    directedGraph.addEdge(1, 2);\n", "    directedGraph.addEdge(2, 1);\n", "    directedGraph.addNode(3);\n", "    MutableGraph<Integer> directedGraph = GraphBuilder.directed().build();\n", "    directedGraph.addEdge(1, 2);\n", "    directedGraph.addEdge(2, 1);\n", "    directedGraph.addEdge(2, 3);\n", "    directedGraph.addEdge(3, 1);\n"]}, "removed": {"1": ["  private static final Integer N1 = 1;\n", "  private static final Integer N2 = 2;\n", "  private static final Integer N3 = 3;\n", "  private static final String E11 = \"1-1\";\n", "  private static final String E12 = \"1-2\";\n", "  private static final String E12_A = \"1-2a\";\n", "  private static final String E13 = \"1-3\";\n", "  private static final String E21 = \"2-1\";\n", "  private static final String E23 = \"2-3\";\n", "  private static final String E31 = \"3-1\";\n", "    Network<Integer, String> directedGraph = NetworkBuilder.directed().build();\n", "    MutableNetwork<Integer, String> directedGraph = NetworkBuilder.directed().build();\n", "    directedGraph.addNode(N1);\n", "    directedGraph.addNode(N2);\n", "    MutableNetwork<Integer, String> directedGraph = NetworkBuilder.directed().build();\n", "    directedGraph.addEdge(E12, N1, N2);\n", "    MutableNetwork<Integer, String> directedGraph = NetworkBuilder.directed().build();\n", "    directedGraph.addEdge(E11, N1, N1);\n", "  @Test\n", "  public void isCyclic_twoParallelEdges() {\n", "    MutableNetwork<Integer, String> directedGraph =\n", "        NetworkBuilder.directed().allowsParallelEdges(true).build();\n", "    directedGraph.addEdge(E12, N1, N2);\n", "    directedGraph.addEdge(E12_A, N1, N2);\n", "    assertThat(isCyclic(directedGraph)).isFalse();\n", "  }\n", "\n", "    MutableNetwork<Integer, String> directedGraph = NetworkBuilder.directed().build();\n", "    directedGraph.addEdge(E12, N1, N2);\n", "    directedGraph.addEdge(E13, N1, N3);\n", "    MutableNetwork<Integer, String> directedGraph = NetworkBuilder.directed().build();\n", "    directedGraph.addEdge(E12, N1, N2);\n", "    directedGraph.addEdge(E21, N2, N1);\n", "    MutableNetwork<Integer, String> directedGraph = NetworkBuilder.directed().build();\n", "    directedGraph.addEdge(E12, N1, N2);\n", "    directedGraph.addEdge(E23, N2, N3);\n", "    directedGraph.addEdge(E13, N1, N3);\n", "    MutableNetwork<Integer, String> directedGraph = NetworkBuilder.directed().build();\n", "    directedGraph.addEdge(E12, N1, N2);\n", "    directedGraph.addEdge(E23, N2, N3);\n", "    directedGraph.addEdge(E31, N3, N1);\n", "    MutableNetwork<Integer, String> directedGraph = NetworkBuilder.directed().build();\n", "    directedGraph.addEdge(E12, N1, N2);\n", "    directedGraph.addEdge(E21, N2, N1);\n", "    directedGraph.addNode(N3);\n", "    assertThat(isCyclic(directedGraph)).isTrue();\n", "  }\n", "\n", "  @Test\n", "  public void isCyclic_cyclicMultigraph() {\n", "    MutableNetwork<Integer, String> directedGraph =\n", "        NetworkBuilder.directed().allowsParallelEdges(true).build();\n", "    directedGraph.addEdge(E12, N1, N2);\n", "    directedGraph.addEdge(E12_A, N1, N2);\n", "    directedGraph.addEdge(E23, N2, N3);\n", "    directedGraph.addEdge(E31, N3, N1);\n", "    MutableNetwork<Integer, String> directedGraph =\n", "        NetworkBuilder.directed().allowsParallelEdges(true).build();\n", "    directedGraph.addEdge(E12, N1, N2);\n", "    directedGraph.addEdge(E21, N2, N1);\n", "    directedGraph.addEdge(E23, N2, N3);\n", "    directedGraph.addEdge(E31, N3, N1);\n"]}, "added_lines": {"1": [34, 40, 41, 43, 49, 50, 56, 57, 63, 64, 65, 71, 72, 73, 79, 80, 81, 82, 88, 89, 90, 91, 97, 98, 99, 100, 106, 107, 108, 109, 110]}, "removed_lines": {"1": [31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 44, 50, 51, 53, 59, 60, 66, 67, 71, 72, 73, 74, 75, 76, 77, 78, 79, 82, 83, 84, 90, 91, 92, 98, 99, 100, 101, 107, 108, 109, 110, 116, 117, 118, 119, 120, 121, 122, 123, 124, 125, 126, 127, 128, 129, 130, 136, 137, 138, 139, 140, 141]}}, {"10": "guava-tests/test/com/google/common/graph/GraphsTest.java", "added": {"1": ["      copyOf((Graph<?>) null);\n"]}, "removed": {"1": ["      copyOf(null);\n"]}, "added_lines": {"1": [178]}, "removed_lines": {"1": [178]}}, {"11": "guava/src/com/google/common/graph/AbstractGraph.java", "added": {}, "removed": {"1": ["    // Needed to enforce a symmetric equality relationship.\n", "    if (other instanceof Network) {\n", "      return false;\n", "    }\n", "\n"]}, "added_lines": {}, "removed_lines": {"1": [65, 66, 67, 68, 69]}}, {"12": "guava/src/com/google/common/graph/AbstractNetwork.java", "added": {"1": [" * This class provides a skeletal implementation of {@link Network}. It is recommended to extend\n", " * this class rather than implement {@link Network} directly, to ensure consistent\n", " * {@link #equals(Object)} and {@link #hashCode()} results across different graph implementations.\n"], "2": ["  @Override\n", "  public Graph<N> asGraph() {\n", "    return new AbstractGraph<N>() {\n", "      @Override\n", "      public Set<N> nodes() {\n", "        return AbstractNetwork.this.nodes();\n", "      }\n", "\n", "      @Override\n", "      public ElementOrder<? super N> nodeOrder() {\n", "        return AbstractNetwork.this.nodeOrder();\n", "      }\n", "\n", "      @Override\n", "      public boolean isDirected() {\n", "        return AbstractNetwork.this.isDirected();\n", "      }\n", "\n", "      @Override\n", "      public boolean allowsSelfLoops() {\n", "        return AbstractNetwork.this.allowsSelfLoops();\n", "      }\n", "\n", "      @Override\n", "      public Set<N> adjacentNodes(Object node) {\n", "        return AbstractNetwork.this.adjacentNodes(node);\n", "      }\n", "\n", "      @Override\n", "      public Set<N> predecessors(Object node) {\n", "        return AbstractNetwork.this.predecessors(node);\n", "      }\n", "\n", "      @Override\n", "      public Set<N> successors(Object node) {\n", "        return AbstractNetwork.this.successors(node);\n", "      }\n", "    };\n", "  }\n", "\n"]}, "removed": {"1": [" * This class provides a skeletal implementation of {@link Graph}. It is recommended to extend this\n", " * class rather than implement {@link Graph} directly, to ensure consistent {@link #equals(Object)}\n", " * and {@link #hashCode()} results across different graph implementations.\n"]}, "added_lines": {"1": [28, 29, 30], "2": [40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 58, 59, 60, 61, 62, 63, 64, 65, 66, 67, 68, 69, 70, 71, 72, 73, 74, 75, 76, 77, 78, 79]}, "removed_lines": {"1": [28, 29, 30]}}, {"13": "guava/src/com/google/common/graph/Endpoints.java", "added": {"1": ["  /**\n", "   * Returns {@link Endpoints} representing the endpoints of an edge in {@code network}.\n", "   */\n", "  public static <N> Endpoints<N> of(Network<?, ?> network, N nodeA, N nodeB) {\n", "    return network.isDirected() ? ofDirected(nodeA, nodeB) : ofUndirected(nodeA, nodeB);\n", "  }\n", "\n"]}, "removed": {}, "added_lines": {"1": [58, 59, 60, 61, 62, 63, 64]}, "removed_lines": {}}, {"14": "guava/src/com/google/common/graph/Graph.java", "added": {"1": [" * Users that want edges to be first-class objects or support for parallel edges should use the\n", " * {@link Network} interface instead.\n", " * <p>For convenience, we may use the term 'graph' refer to {@link Graph}s and/or {@link Network}s.\n"], "2": ["  //\n", "  // Graph-level accessors\n", "  //\n", "  \n", "  /**\n", "   * Returns the order of iteration for the elements of {@link #nodes()}.\n", "   */\n", "  ElementOrder<? super N> nodeOrder();\n", "\n"]}, "removed": {"1": [" * Users that want edges to be first-class objects should use the subtype {@link Network} instead.\n", " * <p>For convenience, we may use the term 'graph' to refer to any subtype of {@link Graph},\n", " * including {@link Network}.\n"], "3": ["  /**\n", "   * Returns the order of iteration for the elements of {@link #nodes()}.\n", "   */\n", "  ElementOrder<? super N> nodeOrder();\n", "\n"], "4": ["   * <p>A {@link Graph} cannot be equal to an instance of a subinterface of {@link Graph} that\n", "   * redefines the definition of equality, such as {@link Network}, even if by this definition they\n", "   * would otherwise be equal.\n", "   *\n"]}, "added_lines": {"1": [25, 26, 28], "2": [170, 171, 172, 173, 179, 180, 181, 182, 183]}, "removed_lines": {"1": [25, 27, 28], "3": [191, 192, 193, 194, 195], "4": [273, 274, 275, 276]}}, {"15": "guava/src/com/google/common/graph/GraphConstants.java", "added": {}, "removed": {"1": ["  static final String NETWORK_WITH_PARALLEL_EDGE =\n", "      \"Cannot make a Graph copy of a Network that allows parallel edges.\";\n"]}, "added_lines": {}, "removed_lines": {"1": [55, 56]}}, {"16": "guava/src/com/google/common/graph/GraphProperties.java", "added": {"1": ["  /**\n", "   * See {@link #isCyclic(Graph)}.\n", "   */\n", "  // TODO(b/27628622): When migrating to Graphs, remove this method and make clients call asGraph().\n", "  public static boolean isCyclic(Network<?, ?> network) {\n", "    return isCyclic(network.asGraph());\n", "  }\n", "\n"]}, "removed": {}, "added_lines": {"1": [59, 60, 61, 62, 63, 64, 65, 66]}, "removed_lines": {}}, {"17": "guava/src/com/google/common/graph/Graphs.java", "added": {}, "removed": {"1": ["import static com.google.common.base.Preconditions.checkArgument;\n", "import static com.google.common.graph.GraphConstants.NETWORK_WITH_PARALLEL_EDGE;\n", "import com.google.common.base.Function;\n", "import com.google.common.collect.Iterators;\n"], "2": ["    if (graph instanceof Network && !allowsParallelEdges(graph)) {\n", "      // Use an optimized implementation for networks without parallel edges.\n", "      return endpointsSimpleNetwork(castToNetwork(graph));\n", "    }\n", "\n"], "3": ["  private static <N> Set<Endpoints<N>> endpointsSimpleNetwork(final Network<N, ?> graph) {\n", "    checkState(!graph.allowsParallelEdges());\n", "    return new AbstractSet<Endpoints<N>>() {\n", "      @Override\n", "      public Iterator<Endpoints<N>> iterator() {\n", "        return Iterators.transform(\n", "            graph.edges().iterator(),\n", "            new Function<Object, Endpoints<N>>() {\n", "              @Override\n", "              public Endpoints<N> apply(Object edge) {\n", "                return graph.incidentNodes(edge);\n", "              }\n", "            });\n", "      }\n", "\n", "      @Override\n", "      public int size() {\n", "        return graph.edges().size();\n", "      }\n", "\n", "      @Override\n", "      public boolean contains(Object obj) {\n", "        if (!(obj instanceof Endpoints)) {\n", "          return false;\n", "        }\n", "        return containsEndpoints(graph, (Endpoints<?>) obj);\n", "      }\n", "    };\n", "  }\n", "\n"], "4": ["    // TODO(user): Consider dropping this restriction. Would this do what users expect?\n", "    checkArgument(!allowsParallelEdges(graph), NETWORK_WITH_PARALLEL_EDGE);\n"], "5": ["  private static boolean allowsParallelEdges(Graph<?> graph) {\n", "    return (graph instanceof Network) && castToNetwork(graph).allowsParallelEdges();\n", "  }\n", "\n", "  @SuppressWarnings(\"unchecked\")\n", "  private static <N> Network<N, ?> castToNetwork(Graph<N> graph) {\n", "    return (Network<N, ?>) graph;\n", "  }\n", "\n"]}, "added_lines": {}, "removed_lines": {"1": [19, 22, 25, 28], "2": [51, 52, 53, 54, 55], "3": [93, 94, 95, 96, 97, 98, 99, 100, 101, 102, 103, 104, 105, 106, 107, 108, 109, 110, 111, 112, 113, 114, 115, 116, 117, 118, 119, 120, 121, 122], "4": [181, 182], "5": [218, 219, 220, 221, 222, 223, 224, 225, 226]}}, {"18": "guava/src/com/google/common/graph/ImmutableGraph.java", "added": {}, "removed": {"1": ["import static com.google.common.base.Preconditions.checkArgument;\n", "import static com.google.common.graph.GraphConstants.NETWORK_WITH_PARALLEL_EDGE;\n"], "2": ["    // TODO(user): Consider dropping this restriction. Would this do what users expect?\n", "    checkArgument(!((graph instanceof Network) && ((Network<N, ?>) graph).allowsParallelEdges()),\n", "        NETWORK_WITH_PARALLEL_EDGE);\n"]}, "added_lines": {}, "removed_lines": {"1": [19, 21], "2": [50, 51, 52]}}, {"19": "guava/src/com/google/common/graph/Network.java", "added": {"1": [" * Unlike {@link Graph}, {@link Network} represents edges as explicit first-class objects.\n", " * Users that are not interested in edges as first-class objects should use the {@link Graph}\n", " * interface instead.\n", " *\n", " * <p>For convenience, we may use the term 'graph' refer to {@link Graph}s and/or {@link Network}s.\n"], "2": ["public interface Network<N, E> {\n", "  //\n", "  // Network-level accessors\n", "  //\n", "  \n", "  /**\n", "   * Returns all nodes in this graph, in the order specified by {@link #nodeOrder()}.\n", "   */\n", "  Set<N> nodes();\n", "\n", "  /**\n", "   * Returns the order of iteration for the elements of {@link #nodes()}.\n", "   */\n", "  ElementOrder<? super N> nodeOrder();\n", "\n", "  /**\n", "   * Returns the order of iteration for the elements of {@link #edges()}.\n", "   */\n", "  ElementOrder<? super E> edgeOrder();\n", "  \n", "  /**\n", "   * Returns a live view of this graph as a {@link Graph}. The resulting {@link Graph} will have an\n", "   * edge connecting node A to node B iff this {@link Network} has an edge connecting A to B.\n", "   */\n", "  Graph<N> asGraph();\n", "\n", "  // Network properties\n", "   * Returns true if the edges in this graph have a direction associated with them.\n"], "3": ["   * Returns true if this graph allows self-loops (edges that connect a node to itself).\n", "   * Attempting to add a self-loop to a graph that does not allow them will throw an\n", "   * {@link UnsupportedOperationException}.\n", "  boolean allowsSelfLoops();\n", "   * Returns true if this graph allows parallel edges. Attempting to add a parallel edge to a graph\n", "   * that does not allow them will throw an {@link UnsupportedOperationException}.\n", "  boolean allowsParallelEdges();\n", "  /**\n", "   * Returns the nodes which have an incident edge in common with {@code node} in this graph.\n", "   *\n", "   * @throws IllegalArgumentException if {@code node} is not an element of this graph\n", "   */\n", "  Set<N> adjacentNodes(Object node);\n", "\n", "  /**\n", "   * Returns all nodes in this graph adjacent to {@code node} which can be reached by traversing\n", "   * {@code node}'s incoming edges <i>against</i> the direction (if any) of the edge.\n", "   *\n", "   * @throws IllegalArgumentException if {@code node} is not an element of this graph\n", "   */\n", "  Set<N> predecessors(Object node);\n", "\n", "  /**\n", "   * Returns all nodes in this graph adjacent to {@code node} which can be reached by traversing\n", "   * {@code node}'s outgoing edges in the direction (if any) of the edge.\n", "   *\n", "   * <p>This is <i>not</i> the same as \"all nodes reachable from {@code node} by following outgoing\n", "   * edges\" (also known as {@code node}'s transitive closure).\n", "   *\n", "   * @throws IllegalArgumentException if {@code node} is not an element of this graph\n", "   */\n", "  Set<N> successors(Object node);\n", "\n"], "4": ["  /**\n", "   * Returns all edges in this graph which can be traversed in the direction (if any) of the edge\n", "   * to end at {@code node}.\n", "   *\n", "   * @throws IllegalArgumentException if {@code node} is not an element of this graph\n", "   */\n", "  Set<E> inEdges(Object node);\n", "\n", "  /**\n", "   * Returns all edges in this graph which can be traversed in the direction (if any) of the edge\n", "   * starting from {@code node}.\n", "   *\n", "   * @throws IllegalArgumentException if {@code node} is not an element of this graph\n", "   */\n", "  Set<E> outEdges(Object node);\n", "\n"], "5": ["   * Returns the number of edges incident in this graph to {@code node}.  If this node has more than\n", "   * {@code Integer.MAX_VALUE} incident edges in this graph, returns {@code Integer.MAX_VALUE}.\n", "   *\n", "   * <p>Note that self-loops only count once towards a node's degree.\n", "   *\n", "   * @throws IllegalArgumentException if {@code node} is not an element of this graph\n", "   * Returns the number of incoming edges in this graph of {@code node}.  If this node has more than\n", "   * {@code Integer.MAX_VALUE} incoming edges in this graph, returns {@code Integer.MAX_VALUE}.\n", "   *\n", "   * @throws IllegalArgumentException if {@code node} is not an element of this graph\n", "   * Returns the number of outgoing edges in this graph of {@code node}.  If this node has more than\n", "   * {@code Integer.MAX_VALUE} outgoing edges in this graph, returns {@code Integer.MAX_VALUE}.\n", "   *\n", "   * @throws IllegalArgumentException if {@code node} is not an element of this graph\n"]}, "removed": {"1": [" * That is, a subtype of {@link Graph} that represents edges as explicit first-class objects.\n", " * Users that are not interested in edges as first-class objects should use a {@link Graph}\n", " * instead.\n"], "2": ["public interface Network<N, E> extends Graph<N> {\n", "  // Graph properties\n", "   * {@inheritDoc}\n"], "3": ["  @Override\n", "   * Returns true if this graph allows parallel edges. Attempting to add a parallel edge to a graph\n", "   * that does not allow them will throw an {@link UnsupportedOperationException}.\n", "  boolean allowsParallelEdges();\n", "   * Returns the order of iteration for the elements of {@link #edges()}.\n", "  ElementOrder<? super E> edgeOrder();\n"], "5": ["  /**\n", "   * Returns all edges in this graph which can be traversed in the direction (if any) of the edge\n", "   * to end at {@code node}.\n", "   *\n", "   * @throws IllegalArgumentException if {@code node} is not an element of this graph\n", "   */\n", "  Set<E> inEdges(Object node);\n", "\n", "  /**\n", "   * Returns all edges in this graph which can be traversed in the direction (if any) of the edge\n", "   * starting from {@code node}.\n", "   *\n", "   * @throws IllegalArgumentException if {@code node} is not an element of this graph\n", "   */\n", "  Set<E> outEdges(Object node);\n", "\n", "   * {@inheritDoc}\n", "  @Override\n", "   * {@inheritDoc}\n", "  @Override\n", "   * {@inheritDoc}\n", "  @Override\n"]}, "added_lines": {"1": [25, 26, 27, 28, 29], "2": [209, 210, 211, 212, 213, 214, 215, 216, 217, 218, 224, 225, 226, 227, 228, 229, 230, 231, 232, 233, 234, 235, 236, 237, 238, 239, 241, 245], "3": [257, 258, 259, 261, 264, 265, 267, 273, 274, 275, 276, 277, 278, 279, 280, 281, 282, 283, 284, 285, 286, 287, 288, 289, 290, 291, 292, 293, 294, 295, 296, 297, 298], "4": [306, 307, 308, 309, 310, 311, 312, 313, 314, 315, 316, 317, 318, 319, 320, 321], "5": [356, 357, 358, 359, 362, 363, 368, 369, 372, 373, 378, 379, 382, 383]}, "removed_lines": {"1": [25, 26, 27], "2": [207, 214, 218], "3": [227, 231, 232, 234, 237, 239], "5": [281, 282, 283, 284, 285, 286, 287, 288, 289, 290, 291, 292, 293, 294, 295, 296, 302, 306, 310, 314, 318, 322]}}]}
