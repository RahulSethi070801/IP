{
    "addition": {
        "4": " * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not use this file except\n",
        "5": " * in compliance with the License. You may obtain a copy of the License at\n",
        "9": " * Unless required by applicable law or agreed to in writing, software distributed under the License\n",
        "10": " * is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express\n",
        "11": " * or implied. See the License for the specific language governing permissions and limitations under\n",
        "12": " * the License.\n",
        "89": " * <p>This implementation is heavily derived from revision 1.96 of\n",
        "90": " * <a href=\"http://tinyurl.com/ConcurrentHashMap\">ConcurrentHashMap.java</a>.\n",
        "222": "   * Accumulates global cache statistics. Note that there are also per-segments stats counters which\n",
        "223": "   * must be aggregated to obtain a global stats view.\n",
        "230": "  @Nullable final CacheLoader<? super K, V> defaultLoader;\n",
        "252": "    removalNotificationQueue =\n",
        "253": "        (removalListener == NullListener.INSTANCE)\n",
        "254": "            ? LocalCache.<RemovalNotification<K, V>>discardingQueue()\n",
        "255": "            : new ConcurrentLinkedQueue<RemovalNotification<K, V>>();\n",
        "274": "    while (segmentCount < concurrencyLevel && (!evictsBySize() || segmentCount * 20 <= maxWeight)) {\n",
        "559": "      STRONG,\n",
        "560": "      STRONG_ACCESS,\n",
        "561": "      STRONG_WRITE,\n",
        "562": "      STRONG_ACCESS_WRITE,\n",
        "563": "      WEAK,\n",
        "564": "      WEAK_ACCESS,\n",
        "565": "      WEAK_WRITE,\n",
        "566": "      WEAK_ACCESS_WRITE,\n",
        "569": "    static EntryFactory getFactory(\n",
        "570": "        Strength keyStrength, boolean usesAccessQueue, boolean usesWriteQueue) {\n",
        "571": "      int flags =\n",
        "572": "          ((keyStrength == Strength.WEAK) ? WEAK_MASK : 0)\n",
        "573": "              | (usesAccessQueue ? ACCESS_MASK : 0)\n",
        "574": "              | (usesWriteQueue ? WRITE_MASK : 0);\n",
        "637": "     * Waits for a value that may still be loading. Unlike get(), this method can block (in the case\n",
        "638": "     * of FutureValueReference).\n",
        "666": "     * Notifify pending loads that a new value was set. This is only relevant to loading value\n",
        "667": "     * references.\n",
        "691": "  static final ValueReference<Object, Object> UNSET =\n",
        "692": "      new ValueReference<Object, Object>() {\n",
        "693": "        @Override\n",
        "694": "        public Object get() {\n",
        "695": "          return null;\n",
        "696": "        }\n",
        "698": "        @Override\n",
        "699": "        public int getWeight() {\n",
        "700": "          return 0;\n",
        "701": "        }\n",
        "703": "        @Override\n",
        "704": "        public ReferenceEntry<Object, Object> getEntry() {\n",
        "705": "          return null;\n",
        "706": "        }\n",
        "708": "        @Override\n",
        "709": "        public ValueReference<Object, Object> copyFor(\n",
        "710": "            ReferenceQueue<Object> queue,\n",
        "711": "            @Nullable Object value,\n",
        "712": "            ReferenceEntry<Object, Object> entry) {\n",
        "713": "          return this;\n",
        "714": "        }\n",
        "716": "        @Override\n",
        "717": "        public boolean isLoading() {\n",
        "718": "          return false;\n",
        "719": "        }\n",
        "721": "        @Override\n",
        "722": "        public boolean isActive() {\n",
        "723": "          return false;\n",
        "724": "        }\n",
        "726": "        @Override\n",
        "727": "        public Object waitForValue() {\n",
        "728": "          return null;\n",
        "729": "        }\n",
        "731": "        @Override\n",
        "732": "        public void notifyNewValue(Object newValue) {}\n",
        "733": "      };\n",
        "749": "   *\n",
        "751": "   *\n",
        "755": "   *\n",
        "757": "   *\n",
        "759": "   *\n",
        "827": "     * Implemented by entries that use write order. Write entries are maintained in a doubly-linked\n",
        "828": "     * list. New entries are added at the tail of the list at write time and stale entries are\n",
        "829": "     * expired from the head of the list.\n",
        "1030": "  static final Queue<? extends Object> DISCARDING_QUEUE =\n",
        "1031": "      new AbstractQueue<Object>() {\n",
        "1032": "        @Override\n",
        "1033": "        public boolean offer(Object o) {\n",
        "1034": "          return true;\n",
        "1035": "        }\n",
        "1037": "        @Override\n",
        "1038": "        public Object peek() {\n",
        "1039": "          return null;\n",
        "1040": "        }\n",
        "1042": "        @Override\n",
        "1043": "        public Object poll() {\n",
        "1044": "          return null;\n",
        "1045": "        }\n",
        "1047": "        @Override\n",
        "1048": "        public int size() {\n",
        "1049": "          return 0;\n",
        "1050": "        }\n",
        "1052": "        @Override\n",
        "1053": "        public Iterator<Object> iterator() {\n",
        "1054": "          return ImmutableSet.of().iterator();\n",
        "1055": "        }\n",
        "1056": "      };\n",
        "1408": "    WeakAccessEntry(ReferenceQueue<K> queue, K key, int hash, @Nullable ReferenceEntry<K, V> next) {\n",
        "1454": "    WeakWriteEntry(ReferenceQueue<K> queue, K key, int hash, @Nullable ReferenceEntry<K, V> next) {\n",
        "1589": "  static class WeakValueReference<K, V> extends WeakReference<V> implements ValueReference<K, V> {\n",
        "1635": "  static class SoftValueReference<K, V> extends SoftReference<V> implements ValueReference<K, V> {\n",
        "1734": "    WeightedWeakValueReference(\n",
        "1735": "        ReferenceQueue<V> queue, V referent, ReferenceEntry<K, V> entry, int weight) {\n",
        "1758": "    WeightedSoftValueReference(\n",
        "1759": "        ReferenceQueue<V> queue, V referent, ReferenceEntry<K, V> entry, int weight) {\n",
        "1796": "   * tables, that otherwise encounter collisions for hash codes that do not differ in lower or upper\n",
        "1797": "   * bits.\n",
        "1917": "    if (expiresAfterAccess() && (now - entry.getAccessTime() >= expireAfterAccessNanos)) {\n",
        "1920": "    if (expiresAfterWrite() && (now - entry.getWriteTime() >= expireAfterWriteNanos)) {\n",
        "1955": "   * Notifies listeners that an entry has been automatically removed due to expiration, eviction, or\n",
        "1956": "   * eligibility for garbage collection. This should be called every time expireEntries or\n",
        "2003": "     * - All (unsynchronized) read operations must first read the \"count\" field, and should not look\n",
        "2004": "     * at table entries if it is 0.\n",
        "2007": "     * changing any bin. The operations must not take any action that could even momentarily cause a\n",
        "2008": "     * concurrent read operation to see inconsistent data. This is made easier by the nature of the\n",
        "2009": "     * read operations in Map. For example, no operation can reveal that the table has grown but the\n",
        "2010": "     * threshold has not yet been updated, so there are no atomicity requirements for this with\n",
        "2011": "     * respect to reads.\n",
        "2033": "     * loading size or checking containsValue, then we might have an inconsistent view of state so\n",
        "2034": "     * (usually) must retry.\n",
        "2096": "    Segment(\n",
        "2097": "        LocalCache<K, V> map,\n",
        "2098": "        int initialCapacity,\n",
        "2099": "        long maxSegmentWeight,\n",
        "2106": "      keyReferenceQueue = map.usesKeyReferences() ? new ReferenceQueue<K>() : null;\n",
        "2108": "      valueReferenceQueue = map.usesValueReferences() ? new ReferenceQueue<V>() : null;\n",
        "2110": "      recencyQueue =\n",
        "2111": "          map.usesAccessQueue()\n",
        "2112": "              ? new ConcurrentLinkedQueue<ReferenceEntry<K, V>>()\n",
        "2113": "              : LocalCache.<ReferenceEntry<K, V>>discardingQueue();\n",
        "2115": "      writeQueue =\n",
        "2116": "          map.usesWriteQueue()\n",
        "2117": "              ? new WriteQueue<K, V>()\n",
        "2118": "              : LocalCache.<ReferenceEntry<K, V>>discardingQueue();\n",
        "2120": "      accessQueue =\n",
        "2121": "          map.usesAccessQueue()\n",
        "2122": "              ? new AccessQueue<K, V>()\n",
        "2123": "              : LocalCache.<ReferenceEntry<K, V>>discardingQueue();\n",
        "2222": "    V lockedGetOrLoad(K key, int hash, CacheLoader<? super K, V> loader) throws ExecutionException {\n",
        "2241": "          if (e.getHash() == hash\n",
        "2242": "              && entryKey != null\n",
        "2250": "                enqueueNotification(\n",
        "2251": "                    entryKey, hash, value, valueReference.getWeight(), RemovalCause.COLLECTED);\n",
        "2255": "                enqueueNotification(\n",
        "2256": "                    entryKey, hash, value, valueReference.getWeight(), RemovalCause.EXPIRED);\n",
        "2330": "    V loadSync(\n",
        "2331": "        K key,\n",
        "2332": "        int hash,\n",
        "2333": "        LoadingValueReference<K, V> loadingValueReference,\n",
        "2334": "        CacheLoader<? super K, V> loader)\n",
        "2335": "        throws ExecutionException {\n",
        "2340": "    ListenableFuture<V> loadAsync(\n",
        "2341": "        final K key,\n",
        "2342": "        final int hash,\n",
        "2343": "        final LoadingValueReference<K, V> loadingValueReference,\n",
        "2344": "        CacheLoader<? super K, V> loader) {\n",
        "2357": "          },\n",
        "2358": "          directExecutor());\n",
        "2365": "    V getAndRecordStats(\n",
        "2366": "        K key,\n",
        "2367": "        int hash,\n",
        "2368": "        LoadingValueReference<K, V> loadingValueReference,\n",
        "2369": "        ListenableFuture<V> newValue)\n",
        "2370": "        throws ExecutionException {\n",
        "2388": "    V scheduleRefresh(\n",
        "2389": "        ReferenceEntry<K, V> entry,\n",
        "2390": "        K key,\n",
        "2391": "        int hash,\n",
        "2392": "        V oldValue,\n",
        "2393": "        long now,\n",
        "2395": "      if (map.refreshes()\n",
        "2396": "          && (now - entry.getWriteTime() > map.refreshNanos)\n",
        "2436": "    LoadingValueReference<K, V> insertLoadingValueReference(\n",
        "2437": "        final K key, final int hash, boolean checkTime) {\n",
        "2451": "          if (e.getHash() == hash\n",
        "2452": "              && entryKey != null\n",
        "2567": "     * recency queue. At write-time, or when the queue is full past the threshold, the queue will be\n",
        "2568": "     * drained and the entries therein processed.\n",
        "2670": "    void enqueueNotification(\n",
        "2671": "        @Nullable K key, int hash, @Nullable V value, int weight, RemovalCause cause) {\n",
        "2831": "     * This method is a convenience for testing. Code should call {@link LocalCache#containsValue}\n",
        "2832": "     * directly.\n",
        "2880": "          if (e.getHash() == hash\n",
        "2881": "              && entryKey != null\n",
        "2891": "                enqueueNotification(\n",
        "2892": "                    key, hash, entryValue, valueReference.getWeight(), RemovalCause.COLLECTED);\n",
        "2911": "              enqueueNotification(\n",
        "2912": "                  key, hash, entryValue, valueReference.getWeight(), RemovalCause.REPLACED);\n",
        "2950": "       * because their next fields won't change. Statistically, at the default threshold, only about\n",
        "2951": "       * one-sixth of them need cloning when a table doubles. The nodes they replace will be garbage\n",
        "2952": "       * collectable as soon as they are no longer referenced by any reader thread that may be in\n",
        "2953": "       * the midst of traversing table right now.\n",
        "3019": "          if (e.getHash() == hash\n",
        "3020": "              && entryKey != null\n",
        "3029": "                ReferenceEntry<K, V> newFirst =\n",
        "3030": "                    removeValueFromChain(\n",
        "3031": "                        first,\n",
        "3032": "                        e,\n",
        "3033": "                        entryKey,\n",
        "3034": "                        hash,\n",
        "3035": "                        entryValue,\n",
        "3036": "                        valueReference,\n",
        "3037": "                        RemovalCause.COLLECTED);\n",
        "3047": "              enqueueNotification(\n",
        "3048": "                  key, hash, entryValue, valueReference.getWeight(), RemovalCause.REPLACED);\n",
        "3081": "          if (e.getHash() == hash\n",
        "3082": "              && entryKey != null\n",
        "3091": "                ReferenceEntry<K, V> newFirst =\n",
        "3092": "                    removeValueFromChain(\n",
        "3093": "                        first,\n",
        "3094": "                        e,\n",
        "3095": "                        entryKey,\n",
        "3096": "                        hash,\n",
        "3097": "                        entryValue,\n",
        "3098": "                        valueReference,\n",
        "3099": "                        RemovalCause.COLLECTED);\n",
        "3108": "            enqueueNotification(\n",
        "3109": "                key, hash, entryValue, valueReference.getWeight(), RemovalCause.REPLACED);\n",
        "3137": "          if (e.getHash() == hash\n",
        "3138": "              && entryKey != null\n",
        "3154": "            ReferenceEntry<K, V> newFirst =\n",
        "3155": "                removeValueFromChain(first, e, entryKey, hash, entryValue, valueReference, cause);\n",
        "3170": "    boolean storeLoadedValue(\n",
        "3171": "        K key, int hash, LoadingValueReference<K, V> oldValueReference, V newValue) {\n",
        "3189": "          if (e.getHash() == hash\n",
        "3190": "              && entryKey != null\n",
        "3243": "          if (e.getHash() == hash\n",
        "3244": "              && entryKey != null\n",
        "3260": "            ReferenceEntry<K, V> newFirst =\n",
        "3261": "                removeValueFromChain(first, e, entryKey, hash, entryValue, valueReference, cause);\n",
        "3293": "                enqueueNotification(\n",
        "3294": "                    key, e.getHash(), value, e.getValueReference().getWeight(), cause);\n",
        "3317": "    ReferenceEntry<K, V> removeValueFromChain(\n",
        "3318": "        ReferenceEntry<K, V> first,\n",
        "3319": "        ReferenceEntry<K, V> entry,\n",
        "3320": "        @Nullable K key,\n",
        "3321": "        int hash,\n",
        "3322": "        V value,\n",
        "3323": "        ValueReference<K, V> valueReference,\n",
        "3324": "        RemovalCause cause) {\n",
        "3339": "    ReferenceEntry<K, V> removeEntryFromChain(\n",
        "3340": "        ReferenceEntry<K, V> first, ReferenceEntry<K, V> entry) {\n",
        "3358": "      enqueueNotification(\n",
        "3359": "          entry.getKey(),\n",
        "3360": "          entry.getHash(),\n",
        "3361": "          entry.getValueReference().get(),\n",
        "3362": "          entry.getValueReference().getWeight(),\n",
        "3363": "          RemovalCause.COLLECTED);\n",
        "3382": "            ReferenceEntry<K, V> newFirst =\n",
        "3383": "                removeValueFromChain(\n",
        "3384": "                    first,\n",
        "3385": "                    e,\n",
        "3386": "                    e.getKey(),\n",
        "3387": "                    hash,\n",
        "3388": "                    e.getValueReference().get(),\n",
        "3389": "                    e.getValueReference(),\n",
        "3390": "                    RemovalCause.COLLECTED);\n",
        "3418": "          if (e.getHash() == hash\n",
        "3419": "              && entryKey != null\n",
        "3424": "              ReferenceEntry<K, V> newFirst =\n",
        "3425": "                  removeValueFromChain(\n",
        "3426": "                      first,\n",
        "3427": "                      e,\n",
        "3428": "                      entryKey,\n",
        "3429": "                      hash,\n",
        "3430": "                      valueReference.get(),\n",
        "3431": "                      valueReference,\n",
        "3432": "                      RemovalCause.COLLECTED);\n",
        "3460": "          if (e.getHash() == hash\n",
        "3461": "              && entryKey != null\n",
        "3495": "          ReferenceEntry<K, V> newFirst =\n",
        "3496": "              removeValueFromChain(\n",
        "3497": "                  first,\n",
        "3498": "                  e,\n",
        "3499": "                  e.getKey(),\n",
        "3500": "                  hash,\n",
        "3501": "                  e.getValueReference().get(),\n",
        "3502": "                  e.getValueReference(),\n",
        "3503": "                  cause);\n",
        "3525": "     * Performs routine cleanup prior to executing a write. This should be called every time a write\n",
        "3526": "     * thread acquires the segment lock, immediately after acquiring the lock.\n",
        "3638": "        return Futures.transform(\n",
        "3639": "            newValue,\n",
        "3640": "            new Function<V, V>() {\n",
        "3641": "              @Override\n",
        "3642": "              public V apply(V newValue) {\n",
        "3643": "                LoadingValueReference.this.set(newValue);\n",
        "3644": "                return newValue;\n",
        "3645": "              }\n",
        "3646": "            });\n",
        "3692": "   * <p>Note that this entire implementation makes the assumption that all elements which are in the\n",
        "3693": "   * map are also in this queue, and that all elements not in the queue are not in the map.\n",
        "3695": "   * <p>The benefits of creating our own queue are that (1) we can replace elements in the middle of\n",
        "3696": "   * the queue as part of copyWriteEntry, and (2) the contains method is highly optimized for the\n",
        "3697": "   * current model.\n",
        "3700": "    final ReferenceEntry<K, V> head =\n",
        "3701": "        new AbstractReferenceEntry<K, V>() {\n",
        "3703": "          @Override\n",
        "3704": "          public long getWriteTime() {\n",
        "3705": "            return Long.MAX_VALUE;\n",
        "3706": "          }\n",
        "3708": "          @Override\n",
        "3709": "          public void setWriteTime(long time) {}\n",
        "3711": "          ReferenceEntry<K, V> nextWrite = this;\n",
        "3713": "          @Override\n",
        "3714": "          public ReferenceEntry<K, V> getNextInWriteQueue() {\n",
        "3715": "            return nextWrite;\n",
        "3716": "          }\n",
        "3718": "          @Override\n",
        "3719": "          public void setNextInWriteQueue(ReferenceEntry<K, V> next) {\n",
        "3720": "            this.nextWrite = next;\n",
        "3721": "          }\n",
        "3723": "          ReferenceEntry<K, V> previousWrite = this;\n",
        "3725": "          @Override\n",
        "3726": "          public ReferenceEntry<K, V> getPreviousInWriteQueue() {\n",
        "3727": "            return previousWrite;\n",
        "3728": "          }\n",
        "3730": "          @Override\n",
        "3731": "          public void setPreviousInWriteQueue(ReferenceEntry<K, V> previous) {\n",
        "3732": "            this.previousWrite = previous;\n",
        "3733": "          }\n",
        "3734": "        };\n",
        "3794": "      for (ReferenceEntry<K, V> e = head.getNextInWriteQueue();\n",
        "3795": "          e != head;\n",
        "3831": "   * <p>Note that this entire implementation makes the assumption that all elements which are in the\n",
        "3832": "   * map are also in this queue, and that all elements not in the queue are not in the map.\n",
        "3834": "   * <p>The benefits of creating our own queue are that (1) we can replace elements in the middle of\n",
        "3835": "   * the queue as part of copyWriteEntry, and (2) the contains method is highly optimized for the\n",
        "3836": "   * current model.\n",
        "3839": "    final ReferenceEntry<K, V> head =\n",
        "3840": "        new AbstractReferenceEntry<K, V>() {\n",
        "3842": "          @Override\n",
        "3843": "          public long getAccessTime() {\n",
        "3844": "            return Long.MAX_VALUE;\n",
        "3845": "          }\n",
        "3847": "          @Override\n",
        "3848": "          public void setAccessTime(long time) {}\n",
        "3850": "          ReferenceEntry<K, V> nextAccess = this;\n",
        "3852": "          @Override\n",
        "3853": "          public ReferenceEntry<K, V> getNextInAccessQueue() {\n",
        "3854": "            return nextAccess;\n",
        "3855": "          }\n",
        "3857": "          @Override\n",
        "3858": "          public void setNextInAccessQueue(ReferenceEntry<K, V> next) {\n",
        "3859": "            this.nextAccess = next;\n",
        "3860": "          }\n",
        "3862": "          ReferenceEntry<K, V> previousAccess = this;\n",
        "3864": "          @Override\n",
        "3865": "          public ReferenceEntry<K, V> getPreviousInAccessQueue() {\n",
        "3866": "            return previousAccess;\n",
        "3867": "          }\n",
        "3869": "          @Override\n",
        "3870": "          public void setPreviousInAccessQueue(ReferenceEntry<K, V> previous) {\n",
        "3871": "            this.previousAccess = previous;\n",
        "3872": "          }\n",
        "3873": "        };\n",
        "3933": "      for (ReferenceEntry<K, V> e = head.getNextInAccessQueue();\n",
        "3934": "          e != head;\n",
        "3982": "     * modifications before recheck.) Method containsValue() uses similar constructions for\n",
        "4494": "   * Custom Entry class used by EntryIterator.next(), that relays setValue changes to the underlying\n",
        "4495": "   * map.\n",
        "4540": "    @Override\n",
        "4541": "    public String toString() {\n",
        "4628": "    @Override\n",
        "4629": "    public int size() {\n",
        "4633": "    @Override\n",
        "4634": "    public boolean isEmpty() {\n",
        "4638": "    @Override\n",
        "4639": "    public void clear() {\n",
        "4708": "   * Serializes the configuration of a LocalCache, reconsitituting it as a Cache using CacheBuilder\n",
        "4709": "   * upon deserialization. An instance of this class is fit for use by the writeReplace of\n",
        "4710": "   * LocalManualCache.\n",
        "4715": "  static class ManualSerializationProxy<K, V> extends ForwardingCache<K, V>\n",
        "4716": "      implements Serializable {\n",
        "4751": "        Strength keyStrength,\n",
        "4752": "        Strength valueStrength,\n",
        "4753": "        Equivalence<Object> keyEquivalence,\n",
        "4754": "        Equivalence<Object> valueEquivalence,\n",
        "4755": "        long expireAfterWriteNanos,\n",
        "4756": "        long expireAfterAccessNanos,\n",
        "4757": "        long maxWeight,\n",
        "4758": "        Weigher<K, V> weigher,\n",
        "4759": "        int concurrencyLevel,\n",
        "4761": "        Ticker ticker,\n",
        "4762": "        CacheLoader<? super K, V> loader) {\n",
        "4773": "      this.ticker = (ticker == Ticker.systemTicker() || ticker == NULL_TICKER) ? null : ticker;\n",
        "4777": "    CacheBuilder<K, V> recreateCacheBuilder() {\n",
        "4778": "      CacheBuilder<K, V> builder =\n",
        "4779": "          CacheBuilder.newBuilder()\n",
        "4780": "              .setKeyStrength(keyStrength)\n",
        "4781": "              .setValueStrength(valueStrength)\n",
        "4782": "              .keyEquivalence(keyEquivalence)\n",
        "4783": "              .valueEquivalence(valueEquivalence)\n",
        "4784": "              .concurrencyLevel(concurrencyLevel)\n",
        "4785": "              .removalListener(removalListener);\n",
        "4833": "  static final class LoadingSerializationProxy<K, V> extends ManualSerializationProxy<K, V>\n",
        "4834": "      implements LoadingCache<K, V>, Serializable {\n",
        "4901": "      return localCache.get(\n",
        "4902": "          key,\n",
        "4903": "          new CacheLoader<Object, V>() {\n",
        "4904": "            @Override\n",
        "4905": "            public V load(Object key) throws Exception {\n",
        "4906": "              return valueLoader.call();\n",
        "4907": "            }\n",
        "4908": "          });\n",
        "4976": "  static class LocalLoadingCache<K, V> extends LocalManualCache<K, V>\n",
        "4977": "      implements LoadingCache<K, V> {\n",
        "4979": "    LocalLoadingCache(\n",
        "4980": "        CacheBuilder<? super K, ? super V> builder, CacheLoader<? super K, V> loader) {\n"
    },
    "removed": {
        "4": " * Licensed under the Apache License, Version 2.0 (the \"License\");\n",
        "5": " * you may not use this file except in compliance with the License.\n",
        "6": " * You may obtain a copy of the License at\n",
        "10": " * Unless required by applicable law or agreed to in writing, software\n",
        "11": " * distributed under the License is distributed on an \"AS IS\" BASIS,\n",
        "12": " * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n",
        "13": " * See the License for the specific language governing permissions and\n",
        "14": " * limitations under the License.\n",
        "91": " * <p>This implementation is heavily derived from revision 1.96 of <a\n",
        "92": " * href=\"http://tinyurl.com/ConcurrentHashMap\">ConcurrentHashMap.java</a>.\n",
        "224": "   * Accumulates global cache statistics. Note that there are also per-segments stats counters\n",
        "225": "   * which must be aggregated to obtain a global stats view.\n",
        "232": "  @Nullable\n",
        "233": "  final CacheLoader<? super K, V> defaultLoader;\n",
        "255": "    removalNotificationQueue = (removalListener == NullListener.INSTANCE)\n",
        "256": "        ? LocalCache.<RemovalNotification<K, V>>discardingQueue()\n",
        "257": "        : new ConcurrentLinkedQueue<RemovalNotification<K, V>>();\n",
        "276": "    while (segmentCount < concurrencyLevel\n",
        "277": "           && (!evictsBySize() || segmentCount * 20 <= maxWeight)) {\n",
        "565": "      STRONG, STRONG_ACCESS, STRONG_WRITE, STRONG_ACCESS_WRITE,\n",
        "566": "      WEAK, WEAK_ACCESS, WEAK_WRITE, WEAK_ACCESS_WRITE,\n",
        "569": "    static EntryFactory getFactory(Strength keyStrength, boolean usesAccessQueue,\n",
        "570": "        boolean usesWriteQueue) {\n",
        "571": "      int flags = ((keyStrength == Strength.WEAK) ? WEAK_MASK : 0)\n",
        "572": "          | (usesAccessQueue ? ACCESS_MASK : 0)\n",
        "573": "          | (usesWriteQueue ? WRITE_MASK : 0);\n",
        "636": "     * Waits for a value that may still be loading. Unlike get(), this method can block (in the\n",
        "637": "     * case of FutureValueReference).\n",
        "665": "     * Notifify pending loads that a new value was set. This is only relevant to loading\n",
        "666": "     * value references.\n",
        "690": "  static final ValueReference<Object, Object> UNSET = new ValueReference<Object, Object>() {\n",
        "691": "    @Override\n",
        "692": "    public Object get() {\n",
        "693": "      return null;\n",
        "694": "    }\n",
        "696": "    @Override\n",
        "697": "    public int getWeight() {\n",
        "698": "      return 0;\n",
        "699": "    }\n",
        "701": "    @Override\n",
        "702": "    public ReferenceEntry<Object, Object> getEntry() {\n",
        "703": "      return null;\n",
        "704": "    }\n",
        "706": "    @Override\n",
        "707": "    public ValueReference<Object, Object> copyFor(ReferenceQueue<Object> queue,\n",
        "708": "        @Nullable Object value, ReferenceEntry<Object, Object> entry) {\n",
        "709": "      return this;\n",
        "710": "    }\n",
        "712": "    @Override\n",
        "713": "    public boolean isLoading() {\n",
        "714": "      return false;\n",
        "715": "    }\n",
        "717": "    @Override\n",
        "718": "    public boolean isActive() {\n",
        "719": "      return false;\n",
        "720": "    }\n",
        "722": "    @Override\n",
        "723": "    public Object waitForValue() {\n",
        "724": "      return null;\n",
        "725": "    }\n",
        "727": "    @Override\n",
        "728": "    public void notifyNewValue(Object newValue) {}\n",
        "729": "  };\n",
        "818": "     * Implemented by entries that use write order. Write entries are maintained in a\n",
        "819": "     * doubly-linked list. New entries are added at the tail of the list at write time and stale\n",
        "820": "     * entries are expired from the head of the list.\n",
        "1021": "  static final Queue<? extends Object> DISCARDING_QUEUE = new AbstractQueue<Object>() {\n",
        "1022": "    @Override\n",
        "1023": "    public boolean offer(Object o) {\n",
        "1024": "      return true;\n",
        "1025": "    }\n",
        "1027": "    @Override\n",
        "1028": "    public Object peek() {\n",
        "1029": "      return null;\n",
        "1030": "    }\n",
        "1032": "    @Override\n",
        "1033": "    public Object poll() {\n",
        "1034": "      return null;\n",
        "1035": "    }\n",
        "1037": "    @Override\n",
        "1038": "    public int size() {\n",
        "1039": "      return 0;\n",
        "1040": "    }\n",
        "1042": "    @Override\n",
        "1043": "    public Iterator<Object> iterator() {\n",
        "1044": "      return ImmutableSet.of().iterator();\n",
        "1045": "    }\n",
        "1046": "  };\n",
        "1398": "    WeakAccessEntry(\n",
        "1399": "        ReferenceQueue<K> queue, K key, int hash, @Nullable ReferenceEntry<K, V> next) {\n",
        "1445": "    WeakWriteEntry(\n",
        "1446": "        ReferenceQueue<K> queue, K key, int hash, @Nullable ReferenceEntry<K, V> next) {\n",
        "1581": "  static class WeakValueReference<K, V>\n",
        "1582": "      extends WeakReference<V> implements ValueReference<K, V> {\n",
        "1628": "  static class SoftValueReference<K, V>\n",
        "1629": "      extends SoftReference<V> implements ValueReference<K, V> {\n",
        "1728": "    WeightedWeakValueReference(ReferenceQueue<V> queue, V referent, ReferenceEntry<K, V> entry,\n",
        "1729": "        int weight) {\n",
        "1752": "    WeightedSoftValueReference(ReferenceQueue<V> queue, V referent, ReferenceEntry<K, V> entry,\n",
        "1753": "        int weight) {\n",
        "1790": "   * tables, that otherwise encounter collisions for hash codes that do not differ in lower or\n",
        "1791": "   * upper bits.\n",
        "1911": "    if (expiresAfterAccess()\n",
        "1912": "        && (now - entry.getAccessTime() >= expireAfterAccessNanos)) {\n",
        "1915": "    if (expiresAfterWrite()\n",
        "1916": "        && (now - entry.getWriteTime() >= expireAfterWriteNanos)) {\n",
        "1951": "   * Notifies listeners that an entry has been automatically removed due to expiration, eviction,\n",
        "1952": "   * or eligibility for garbage collection. This should be called every time expireEntries or\n",
        "1999": "     * - All (unsynchronized) read operations must first read the \"count\" field, and should not\n",
        "2000": "     * look at table entries if it is 0.\n",
        "2003": "     * changing any bin. The operations must not take any action that could even momentarily\n",
        "2004": "     * cause a concurrent read operation to see inconsistent data. This is made easier by the\n",
        "2005": "     * nature of the read operations in Map. For example, no operation can reveal that the table\n",
        "2006": "     * has grown but the threshold has not yet been updated, so there are no atomicity requirements\n",
        "2007": "     * for this with respect to reads.\n",
        "2029": "     * loading size or checking containsValue, then we might have an inconsistent view of state\n",
        "2030": "     * so (usually) must retry.\n",
        "2092": "    Segment(LocalCache<K, V> map, int initialCapacity, long maxSegmentWeight,\n",
        "2099": "      keyReferenceQueue = map.usesKeyReferences()\n",
        "2100": "           ? new ReferenceQueue<K>() : null;\n",
        "2102": "      valueReferenceQueue = map.usesValueReferences()\n",
        "2103": "           ? new ReferenceQueue<V>() : null;\n",
        "2105": "      recencyQueue = map.usesAccessQueue()\n",
        "2106": "          ? new ConcurrentLinkedQueue<ReferenceEntry<K, V>>()\n",
        "2107": "          : LocalCache.<ReferenceEntry<K, V>>discardingQueue();\n",
        "2109": "      writeQueue = map.usesWriteQueue()\n",
        "2110": "          ? new WriteQueue<K, V>()\n",
        "2111": "          : LocalCache.<ReferenceEntry<K, V>>discardingQueue();\n",
        "2113": "      accessQueue = map.usesAccessQueue()\n",
        "2114": "          ? new AccessQueue<K, V>()\n",
        "2115": "          : LocalCache.<ReferenceEntry<K, V>>discardingQueue();\n",
        "2214": "    V lockedGetOrLoad(K key, int hash, CacheLoader<? super K, V> loader)\n",
        "2215": "        throws ExecutionException {\n",
        "2234": "          if (e.getHash() == hash && entryKey != null\n",
        "2242": "                enqueueNotification(entryKey, hash, value,\n",
        "2243": "                    valueReference.getWeight(), RemovalCause.COLLECTED);\n",
        "2247": "                enqueueNotification(entryKey, hash, value,\n",
        "2248": "                    valueReference.getWeight(), RemovalCause.EXPIRED);\n",
        "2322": "    V loadSync(K key, int hash, LoadingValueReference<K, V> loadingValueReference,\n",
        "2323": "        CacheLoader<? super K, V> loader) throws ExecutionException {\n",
        "2328": "    ListenableFuture<V> loadAsync(final K key, final int hash,\n",
        "2329": "        final LoadingValueReference<K, V> loadingValueReference, CacheLoader<? super K, V> loader) {\n",
        "2342": "          }, directExecutor());\n",
        "2349": "    V getAndRecordStats(K key, int hash, LoadingValueReference<K, V> loadingValueReference,\n",
        "2350": "        ListenableFuture<V> newValue) throws ExecutionException {\n",
        "2368": "    V scheduleRefresh(ReferenceEntry<K, V> entry, K key, int hash, V oldValue, long now,\n",
        "2370": "      if (map.refreshes() && (now - entry.getWriteTime() > map.refreshNanos)\n",
        "2410": "    LoadingValueReference<K, V> insertLoadingValueReference(final K key, final int hash,\n",
        "2411": "        boolean checkTime) {\n",
        "2425": "          if (e.getHash() == hash && entryKey != null\n",
        "2540": "     * recency queue. At write-time, or when the queue is full past the threshold, the queue will\n",
        "2541": "     * be drained and the entries therein processed.\n",
        "2643": "    void enqueueNotification(@Nullable K key, int hash, @Nullable V value, int weight,\n",
        "2644": "        RemovalCause cause) {\n",
        "2804": "     * This method is a convenience for testing. Code should call {@link\n",
        "2805": "     * LocalCache#containsValue} directly.\n",
        "2853": "          if (e.getHash() == hash && entryKey != null\n",
        "2863": "                enqueueNotification(key, hash, entryValue,\n",
        "2864": "                    valueReference.getWeight(), RemovalCause.COLLECTED);\n",
        "2883": "              enqueueNotification(key, hash, entryValue,\n",
        "2884": "                  valueReference.getWeight(), RemovalCause.REPLACED);\n",
        "2922": "       * because their next fields won't change. Statistically, at the default threshold, only\n",
        "2923": "       * about one-sixth of them need cloning when a table doubles. The nodes they replace will be\n",
        "2924": "       * garbage collectable as soon as they are no longer referenced by any reader thread that may\n",
        "2925": "       * be in the midst of traversing table right now.\n",
        "2991": "          if (e.getHash() == hash && entryKey != null\n",
        "3000": "                ReferenceEntry<K, V> newFirst = removeValueFromChain(\n",
        "3001": "                    first, e, entryKey, hash, entryValue, valueReference, RemovalCause.COLLECTED);\n",
        "3011": "              enqueueNotification(key, hash, entryValue,\n",
        "3012": "                  valueReference.getWeight(), RemovalCause.REPLACED);\n",
        "3045": "          if (e.getHash() == hash && entryKey != null\n",
        "3054": "                ReferenceEntry<K, V> newFirst = removeValueFromChain(\n",
        "3055": "                    first, e, entryKey, hash, entryValue, valueReference, RemovalCause.COLLECTED);\n",
        "3064": "            enqueueNotification(key, hash, entryValue,\n",
        "3065": "                valueReference.getWeight(), RemovalCause.REPLACED);\n",
        "3093": "          if (e.getHash() == hash && entryKey != null\n",
        "3109": "            ReferenceEntry<K, V> newFirst = removeValueFromChain(\n",
        "3110": "                first, e, entryKey, hash, entryValue, valueReference, cause);\n",
        "3125": "    boolean storeLoadedValue(K key, int hash, LoadingValueReference<K, V> oldValueReference,\n",
        "3126": "        V newValue) {\n",
        "3144": "          if (e.getHash() == hash && entryKey != null\n",
        "3197": "          if (e.getHash() == hash && entryKey != null\n",
        "3213": "            ReferenceEntry<K, V> newFirst = removeValueFromChain(\n",
        "3214": "                first, e, entryKey, hash, entryValue, valueReference, cause);\n",
        "3246": "                enqueueNotification(key, e.getHash(), value,\n",
        "3247": "                    e.getValueReference().getWeight(), cause);\n",
        "3270": "    ReferenceEntry<K, V> removeValueFromChain(ReferenceEntry<K, V> first,\n",
        "3271": "        ReferenceEntry<K, V> entry, @Nullable K key, int hash, V value,\n",
        "3272": "        ValueReference<K, V> valueReference, RemovalCause cause) {\n",
        "3287": "    ReferenceEntry<K, V> removeEntryFromChain(ReferenceEntry<K, V> first,\n",
        "3288": "        ReferenceEntry<K, V> entry) {\n",
        "3306": "      enqueueNotification(entry.getKey(), entry.getHash(), entry.getValueReference().get(),\n",
        "3307": "          entry.getValueReference().getWeight(), RemovalCause.COLLECTED);\n",
        "3326": "            ReferenceEntry<K, V> newFirst = removeValueFromChain(first, e, e.getKey(), hash,\n",
        "3327": "                e.getValueReference().get(), e.getValueReference(), RemovalCause.COLLECTED);\n",
        "3355": "          if (e.getHash() == hash && entryKey != null\n",
        "3360": "              ReferenceEntry<K, V> newFirst = removeValueFromChain(first, e, entryKey, hash,\n",
        "3361": "                  valueReference.get(), valueReference, RemovalCause.COLLECTED);\n",
        "3389": "          if (e.getHash() == hash && entryKey != null\n",
        "3423": "          ReferenceEntry<K, V> newFirst = removeValueFromChain(first, e, e.getKey(), hash,\n",
        "3424": "              e.getValueReference().get(), e.getValueReference(), cause);\n",
        "3446": "     * Performs routine cleanup prior to executing a write. This should be called every time a\n",
        "3447": "     * write thread acquires the segment lock, immediately after acquiring the lock.\n",
        "3560": "        return Futures.transform(newValue, new Function<V, V>() {\n",
        "3561": "          @Override\n",
        "3562": "          public V apply(V newValue) {\n",
        "3563": "            LoadingValueReference.this.set(newValue);\n",
        "3564": "            return newValue;\n",
        "3565": "          }\n",
        "3566": "        });\n",
        "3612": "   * <p>Note that this entire implementation makes the assumption that all elements which are in\n",
        "3613": "   * the map are also in this queue, and that all elements not in the queue are not in the map.\n",
        "3615": "   * <p>The benefits of creating our own queue are that (1) we can replace elements in the middle\n",
        "3616": "   * of the queue as part of copyWriteEntry, and (2) the contains method is highly optimized\n",
        "3617": "   * for the current model.\n",
        "3620": "    final ReferenceEntry<K, V> head = new AbstractReferenceEntry<K, V>() {\n",
        "3622": "      @Override\n",
        "3623": "      public long getWriteTime() {\n",
        "3624": "        return Long.MAX_VALUE;\n",
        "3625": "      }\n",
        "3627": "      @Override\n",
        "3628": "      public void setWriteTime(long time) {}\n",
        "3630": "      ReferenceEntry<K, V> nextWrite = this;\n",
        "3632": "      @Override\n",
        "3633": "      public ReferenceEntry<K, V> getNextInWriteQueue() {\n",
        "3634": "        return nextWrite;\n",
        "3635": "      }\n",
        "3637": "      @Override\n",
        "3638": "      public void setNextInWriteQueue(ReferenceEntry<K, V> next) {\n",
        "3639": "        this.nextWrite = next;\n",
        "3640": "      }\n",
        "3642": "      ReferenceEntry<K, V> previousWrite = this;\n",
        "3644": "      @Override\n",
        "3645": "      public ReferenceEntry<K, V> getPreviousInWriteQueue() {\n",
        "3646": "        return previousWrite;\n",
        "3647": "      }\n",
        "3649": "      @Override\n",
        "3650": "      public void setPreviousInWriteQueue(ReferenceEntry<K, V> previous) {\n",
        "3651": "        this.previousWrite = previous;\n",
        "3652": "      }\n",
        "3653": "    };\n",
        "3713": "      for (ReferenceEntry<K, V> e = head.getNextInWriteQueue(); e != head;\n",
        "3749": "   * <p>Note that this entire implementation makes the assumption that all elements which are in\n",
        "3750": "   * the map are also in this queue, and that all elements not in the queue are not in the map.\n",
        "3752": "   * <p>The benefits of creating our own queue are that (1) we can replace elements in the middle\n",
        "3753": "   * of the queue as part of copyWriteEntry, and (2) the contains method is highly optimized\n",
        "3754": "   * for the current model.\n",
        "3757": "    final ReferenceEntry<K, V> head = new AbstractReferenceEntry<K, V>() {\n",
        "3759": "      @Override\n",
        "3760": "      public long getAccessTime() {\n",
        "3761": "        return Long.MAX_VALUE;\n",
        "3762": "      }\n",
        "3764": "      @Override\n",
        "3765": "      public void setAccessTime(long time) {}\n",
        "3767": "      ReferenceEntry<K, V> nextAccess = this;\n",
        "3769": "      @Override\n",
        "3770": "      public ReferenceEntry<K, V> getNextInAccessQueue() {\n",
        "3771": "        return nextAccess;\n",
        "3772": "      }\n",
        "3774": "      @Override\n",
        "3775": "      public void setNextInAccessQueue(ReferenceEntry<K, V> next) {\n",
        "3776": "        this.nextAccess = next;\n",
        "3777": "      }\n",
        "3779": "      ReferenceEntry<K, V> previousAccess = this;\n",
        "3781": "      @Override\n",
        "3782": "      public ReferenceEntry<K, V> getPreviousInAccessQueue() {\n",
        "3783": "        return previousAccess;\n",
        "3784": "      }\n",
        "3786": "      @Override\n",
        "3787": "      public void setPreviousInAccessQueue(ReferenceEntry<K, V> previous) {\n",
        "3788": "        this.previousAccess = previous;\n",
        "3789": "      }\n",
        "3790": "    };\n",
        "3850": "      for (ReferenceEntry<K, V> e = head.getNextInAccessQueue(); e != head;\n",
        "3898": "     * modifications before recheck.)  Method containsValue() uses similar constructions for\n",
        "4410": "   * Custom Entry class used by EntryIterator.next(), that relays setValue changes to the\n",
        "4411": "   * underlying map.\n",
        "4456": "    @Override public String toString() {\n",
        "4543": "    @Override public int size() {\n",
        "4547": "    @Override public boolean isEmpty() {\n",
        "4551": "    @Override public void clear() {\n",
        "4620": "   * Serializes the configuration of a LocalCache, reconsitituting it as a Cache using\n",
        "4621": "   * CacheBuilder upon deserialization. An instance of this class is fit for use by the writeReplace\n",
        "4622": "   * of LocalManualCache.\n",
        "4627": "  static class ManualSerializationProxy<K, V>\n",
        "4628": "      extends ForwardingCache<K, V> implements Serializable {\n",
        "4663": "        Strength keyStrength, Strength valueStrength,\n",
        "4664": "        Equivalence<Object> keyEquivalence, Equivalence<Object> valueEquivalence,\n",
        "4665": "        long expireAfterWriteNanos, long expireAfterAccessNanos, long maxWeight,\n",
        "4666": "        Weigher<K, V> weigher, int concurrencyLevel,\n",
        "4668": "        Ticker ticker, CacheLoader<? super K, V> loader) {\n",
        "4679": "      this.ticker = (ticker == Ticker.systemTicker() || ticker == NULL_TICKER)\n",
        "4680": "          ? null : ticker;\n",
        "4684": "   CacheBuilder<K, V> recreateCacheBuilder() {\n",
        "4685": "      CacheBuilder<K, V> builder = CacheBuilder.newBuilder()\n",
        "4686": "          .setKeyStrength(keyStrength)\n",
        "4687": "          .setValueStrength(valueStrength)\n",
        "4688": "          .keyEquivalence(keyEquivalence)\n",
        "4689": "          .valueEquivalence(valueEquivalence)\n",
        "4690": "          .concurrencyLevel(concurrencyLevel)\n",
        "4691": "          .removalListener(removalListener);\n",
        "4739": "  static final class LoadingSerializationProxy<K, V>\n",
        "4740": "      extends ManualSerializationProxy<K, V> implements LoadingCache<K, V>, Serializable {\n",
        "4807": "      return localCache.get(key, new CacheLoader<Object, V>() {\n",
        "4808": "        @Override\n",
        "4809": "        public V load(Object key) throws Exception {\n",
        "4810": "          return valueLoader.call();\n",
        "4811": "        }\n",
        "4812": "      });\n",
        "4880": "  static class LocalLoadingCache<K, V>\n",
        "4881": "      extends LocalManualCache<K, V> implements LoadingCache<K, V> {\n",
        "4883": "    LocalLoadingCache(CacheBuilder<? super K, ? super V> builder,\n",
        "4884": "        CacheLoader<? super K, V> loader) {\n"
    }
}