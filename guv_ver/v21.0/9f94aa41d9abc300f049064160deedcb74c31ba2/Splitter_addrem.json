{
    "addition": {
        "4": " * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not use this file except\n",
        "5": " * in compliance with the License. You may obtain a copy of the License at\n",
        "9": " * Unless required by applicable law or agreed to in writing, software distributed under the License\n",
        "10": " * is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express\n",
        "11": " * or implied. See the License for the specific language governing permissions and limitations under\n",
        "12": " * the License.\n",
        "34": " * Extracts non-overlapping substrings from an input string, typically by recognizing appearances of\n",
        "35": " * a <i>separator</i> sequence. This separator can be specified as a single {@linkplain #on(char)\n",
        "36": " * character}, fixed {@linkplain #on(String) string}, {@linkplain #onPattern regular expression} or\n",
        "37": " * {@link #on(CharMatcher) CharMatcher} instance. Or, instead of using a separator at all, a\n",
        "38": " * splitter can extract adjacent substrings of a given {@linkplain #fixedLength fixed length}.\n",
        "44": " * ... produces an {@code Iterable} containing {@code \"foo\"}, {@code \"bar\"} and {@code \"qux\"}, in\n",
        "45": " * that order.\n",
        "47": " * <p>By default, {@code Splitter}'s behavior is simplistic and unassuming. The following\n",
        "48": " * expression: <pre>   {@code\n",
        "52": " * ... yields the substrings {@code [\" foo\", \"\", \"\", \"  bar \", \"\"]}. If this is not the desired\n",
        "53": " * behavior, use configuration methods to obtain a <i>new</i> splitter instance with modified\n",
        "54": " * behavior: <pre>   {@code\n",
        "61": " * \"bar\"]}. Note that the order in which these configuration methods are called is never\n",
        "62": " * significant.\n",
        "64": " * <p><b>Warning:</b> Splitter instances are immutable. Invoking a configuration method has no\n",
        "65": " * effect on the receiving instance; you must store and use the new splitter instance it returns\n",
        "66": " * instead. <pre>   {@code\n",
        "73": " * <p>For separator-based splitters that do not use {@code omitEmptyStrings}, an input string\n",
        "74": " * containing {@code n} occurrences of the separator naturally yields an iterable of size\n",
        "75": " * {@code n + 1}. So if the separator does not occur anywhere in the input, a single substring is\n",
        "76": " * returned containing the entire input. Consequently, all splitters split the empty string to\n",
        "77": " * {@code [\"\"]} (note: even fixed-length splitters).\n",
        "79": " * <p>Splitter instances are thread-safe immutable, and are therefore safe to store as\n",
        "80": " * {@code static final} constants.\n",
        "82": " * <p>The {@link Joiner} class provides the inverse operation to splitting, but note that a\n",
        "83": " * round-trip between the two should be assumed to be lossy.\n",
        "85": " * <p>See the Guava User Guide article on\n",
        "86": " * <a href=\"https://github.com/google/guava/wiki/StringsExplained#splitter\">{@code Splitter}</a>.\n",
        "113": "   * Returns a splitter that uses the given single-character separator. For example,\n",
        "114": "   * {@code Splitter.on(',').split(\"foo,,bar\")} returns an iterable containing\n",
        "115": "   * {@code [\"foo\", \"\", \"bar\"]}.\n",
        "125": "   * Returns a splitter that considers any single character matched by the given {@code CharMatcher}\n",
        "126": "   * to be a separator. For example, {@code\n",
        "127": "   * Splitter.on(CharMatcher.anyOf(\";,\")).split(\"foo,;bar,quux\")} returns an iterable containing\n",
        "128": "   * {@code [\"foo\", \"\", \"bar\", \"quux\"]}.\n",
        "130": "   * @param separatorMatcher a {@link CharMatcher} that determines whether a character is a\n",
        "131": "   *     separator\n",
        "157": "   * Returns a splitter that uses the given fixed string as a separator. For example,\n",
        "158": "   * {@code Splitter.on(\", \").split(\"foo, bar,baz\")} returns an iterable containing\n",
        "159": "   * {@code [\"foo\", \"bar,baz\"]}.\n",
        "202": "   * Splitter.on(Pattern.compile(\"\\r?\\n\")).split(entireFile)} splits a string into lines whether it\n",
        "203": "   * uses DOS-style or UNIX-style line terminators.\n",
        "205": "   * @param separatorPattern the pattern that determines whether a subsequence is a separator. This\n",
        "206": "   *     pattern may not match the empty string.\n",
        "208": "   * @throws IllegalArgumentException if {@code separatorPattern} matches the empty string\n",
        "239": "   * Returns a splitter that considers any subsequence matching a given pattern (regular expression)\n",
        "240": "   * to be a separator. For example, {@code\n",
        "241": "   * Splitter.onPattern(\"\\r?\\n\").split(entireFile)} splits a string into lines whether it uses\n",
        "242": "   * DOS-style or UNIX-style line terminators. This is equivalent to\n",
        "243": "   * {@code Splitter.on(Pattern.compile(pattern))}.\n",
        "245": "   * @param separatorPattern the pattern that determines whether a subsequence is a separator. This\n",
        "246": "   *     pattern may not match the empty string.\n",
        "248": "   * @throws java.util.regex.PatternSyntaxException if {@code separatorPattern} is a malformed\n",
        "249": "   *     expression\n",
        "250": "   * @throws IllegalArgumentException if {@code separatorPattern} matches the empty string\n",
        "258": "   * Returns a splitter that divides strings into pieces of the given length. For example,\n",
        "259": "   * {@code Splitter.fixedLength(2).split(\"abcde\")} returns an iterable containing\n",
        "260": "   * {@code [\"ab\", \"cd\", \"e\"]}. The last piece can be smaller than {@code length} but will never be\n",
        "261": "   * empty.\n",
        "264": "   * split(\"\")} does not yield an empty iterable, but an iterable containing {@code \"\"}. This is the\n",
        "265": "   * only case in which {@code\n",
        "267": "   * IntMath.divide(input.length(), length, CEILING)}. To avoid this behavior, use\n",
        "268": "   * {@code omitEmptyStrings}.\n",
        "270": "   * @param length the desired length of pieces after splitting, a positive integer\n",
        "271": "   * @return a splitter, with default settings, that can split into fixed sized pieces\n",
        "298": "   * Returns a splitter that behaves equivalently to {@code this} splitter, but automatically omits\n",
        "299": "   * empty strings from the results. For example, {@code\n",
        "300": "   * Splitter.on(',').omitEmptyStrings().split(\",a,,,b,c,,\")} returns an iterable containing only\n",
        "301": "   * {@code [\"a\", \"b\", \"c\"]}.\n",
        "303": "   * <p>If either {@code trimResults} option is also specified when creating a splitter, that\n",
        "304": "   * splitter always trims results first before checking for emptiness. So, for example, {@code\n",
        "305": "   * Splitter.on(':').omitEmptyStrings().trimResults().split(\": : : \")} returns an empty iterable.\n",
        "307": "   * <p>Note that it is ordinarily not possible for {@link #split(CharSequence)} to return an empty\n",
        "308": "   * iterable, but when using this option, it can (if the input sequence consists of nothing but\n",
        "309": "   * separators).\n",
        "318": "   * Returns a splitter that behaves equivalently to {@code this} splitter but stops splitting after\n",
        "319": "   * it reaches the limit. The limit defines the maximum number of items returned by the iterator,\n",
        "320": "   * or the maximum size of the list returned by {@link #splitToList}.\n",
        "322": "   * <p>For example, {@code Splitter.on(',').limit(3).split(\"a,b,c,d\")} returns an iterable\n",
        "323": "   * containing {@code [\"a\", \"b\", \"c,d\"]}. When omitting empty strings, the omitted strings do no\n",
        "324": "   * count. Hence, {@code Splitter.on(',').limit(3).omitEmptyStrings().split(\"a,,,b,,,c,d\")} returns\n",
        "325": "   * an iterable containing {@code [\"a\", \"b\", \"c,d\"}. When trim is requested, all entries, including\n",
        "326": "   * the last are trimmed. Hence\n",
        "327": "   * {@code Splitter.on(',').limit(3).trimResults().split(\" a , b , c , d \")} results in\n",
        "328": "   * {@code [\"a\", \"b\", \"c , d\"]}.\n",
        "340": "   * Returns a splitter that behaves equivalently to {@code this} splitter, but automatically\n",
        "341": "   * removes leading and trailing {@linkplain CharMatcher#WHITESPACE whitespace} from each returned\n",
        "342": "   * substring; equivalent to {@code trimResults(CharMatcher.whitespace())}. For example, {@code\n",
        "343": "   * Splitter.on(',').trimResults().split(\" a, b ,c \")} returns an iterable containing\n",
        "344": "   * {@code [\"a\", \"b\", \"c\"]}.\n",
        "353": "   * Returns a splitter that behaves equivalently to {@code this} splitter, but removes all leading\n",
        "354": "   * or trailing characters matching the given {@code\n",
        "356": "   * Splitter.on(',').trimResults(CharMatcher.is('_')).split(\"_a ,_b_ ,c__\")} returns an iterable\n",
        "357": "   * containing {@code [\"a \", \"b_ \", \"c\"]}.\n",
        "359": "   * @param trimmer a {@link CharMatcher} that determines whether a character should be removed from\n",
        "360": "   *     the beginning/end of a subsequence\n",
        "370": "   * Splits {@code sequence} into string components and makes them available through an\n",
        "371": "   * {@link Iterator}, which may be lazily evaluated. If you want an eagerly computed {@link List},\n",
        "372": "   * use {@link #splitToList(CharSequence)}.\n",
        "401": "   * Splits {@code sequence} into string components and returns them as an immutable list. If you\n",
        "402": "   * want an {@link Iterable} which may be lazily evaluated, use {@link #split(CharSequence)}.\n",
        "423": "   * Returns a {@code MapSplitter} which splits entries based on this splitter, and splits entries\n",
        "424": "   * into keys and values using the specified separator.\n",
        "434": "   * Returns a {@code MapSplitter} which splits entries based on this splitter, and splits entries\n",
        "435": "   * into keys and values using the specified separator.\n",
        "445": "   * Returns a {@code MapSplitter} which splits entries based on this splitter, and splits entries\n",
        "446": "   * into keys and values using the specified key-value splitter.\n",
        "456": "   * An object that splits strings into maps as {@code Splitter} splits iterables and lists. Like\n",
        "457": "   * {@code Splitter}, it is thread-safe and immutable.\n",
        "473": "     * Splits {@code sequence} into substrings, splits each substring into an entry, and returns an\n",
        "474": "     * unmodifiable map with each of the entries. For example, <code>\n",
        "477": "     * </code> will return a mapping from {@code \"a\"} to {@code \"b\"} and {@code \"c\"} to {@code b}.\n",
        "479": "     * <p>The returned map preserves the order of the entries from {@code sequence}.\n",
        "481": "     * @throws IllegalArgumentException if the specified sequence does not split into valid map\n",
        "482": "     *     entries, or if there are duplicate keys\n",
        "513": "     * Returns the first index in {@code toSplit} at or after {@code start} that contains the\n",
        "514": "     * separator.\n",
        "520": "     * separatorPosition} that does not contain a separator. This method is only invoked after a\n",
        "521": "     * call to {@code separatorStart}.\n",
        "538": "       * The returned string will be from the end of the last match to the beginning of the next\n",
        "539": "       * one. nextStart is the start position of the returned substring, while offset is the place\n",
        "540": "       * to start looking for a separator.\n",
        "557": "           * This occurs when some pattern has an empty match, even if it doesn't match the empty\n",
        "558": "           * string -- for example, if it requires lookahead or the like. The offset must be\n",
        "559": "           * increased to look for separators beyond this point, without changing the start position\n",
        "584": "          // final item. This is tested after empty string removal so that\n"
    },
    "removed": {
        "4": " * Licensed under the Apache License, Version 2.0 (the \"License\");\n",
        "5": " * you may not use this file except in compliance with the License.\n",
        "6": " * You may obtain a copy of the License at\n",
        "10": " * Unless required by applicable law or agreed to in writing, software\n",
        "11": " * distributed under the License is distributed on an \"AS IS\" BASIS,\n",
        "12": " * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n",
        "13": " * See the License for the specific language governing permissions and\n",
        "14": " * limitations under the License.\n",
        "36": " * Extracts non-overlapping substrings from an input string, typically by\n",
        "37": " * recognizing appearances of a <i>separator</i> sequence. This separator can be\n",
        "38": " * specified as a single {@linkplain #on(char) character}, fixed {@linkplain\n",
        "39": " * #on(String) string}, {@linkplain #onPattern regular expression} or {@link\n",
        "40": " * #on(CharMatcher) CharMatcher} instance. Or, instead of using a separator at\n",
        "41": " * all, a splitter can extract adjacent substrings of a given {@linkplain\n",
        "42": " * #fixedLength fixed length}.\n",
        "48": " * ... produces an {@code Iterable} containing {@code \"foo\"}, {@code \"bar\"} and\n",
        "49": " * {@code \"qux\"}, in that order.\n",
        "51": " * <p>By default, {@code Splitter}'s behavior is simplistic and unassuming. The\n",
        "52": " * following expression: <pre>   {@code\n",
        "56": " * ... yields the substrings {@code [\" foo\", \"\", \"\", \"  bar \", \"\"]}. If this\n",
        "57": " * is not the desired behavior, use configuration methods to obtain a <i>new</i>\n",
        "58": " * splitter instance with modified behavior: <pre>   {@code\n",
        "65": " * \"bar\"]}. Note that the order in which these configuration methods are called\n",
        "66": " * is never significant.\n",
        "68": " * <p><b>Warning:</b> Splitter instances are immutable. Invoking a configuration\n",
        "69": " * method has no effect on the receiving instance; you must store and use the\n",
        "70": " * new splitter instance it returns instead. <pre>   {@code\n",
        "77": " * <p>For separator-based splitters that do not use {@code omitEmptyStrings}, an\n",
        "78": " * input string containing {@code n} occurrences of the separator naturally\n",
        "79": " * yields an iterable of size {@code n + 1}. So if the separator does not occur\n",
        "80": " * anywhere in the input, a single substring is returned containing the entire\n",
        "81": " * input. Consequently, all splitters split the empty string to {@code [\"\"]}\n",
        "82": " * (note: even fixed-length splitters).\n",
        "84": " * <p>Splitter instances are thread-safe immutable, and are therefore safe to\n",
        "85": " * store as {@code static final} constants.\n",
        "87": " * <p>The {@link Joiner} class provides the inverse operation to splitting, but\n",
        "88": " * note that a round-trip between the two should be assumed to be lossy.\n",
        "90": " * <p>See the Guava User Guide article on <a href=\n",
        "91": " * \"https://github.com/google/guava/wiki/StringsExplained#splitter\">\n",
        "92": " * {@code Splitter}</a>.\n",
        "119": "   * Returns a splitter that uses the given single-character separator. For\n",
        "120": "   * example, {@code Splitter.on(',').split(\"foo,,bar\")} returns an iterable\n",
        "121": "   * containing {@code [\"foo\", \"\", \"bar\"]}.\n",
        "131": "   * Returns a splitter that considers any single character matched by the\n",
        "132": "   * given {@code CharMatcher} to be a separator. For example, {@code\n",
        "133": "   * Splitter.on(CharMatcher.anyOf(\";,\")).split(\"foo,;bar,quux\")} returns an\n",
        "134": "   * iterable containing {@code [\"foo\", \"\", \"bar\", \"quux\"]}.\n",
        "136": "   * @param separatorMatcher a {@link CharMatcher} that determines whether a\n",
        "137": "   *     character is a separator\n",
        "163": "   * Returns a splitter that uses the given fixed string as a separator. For\n",
        "164": "   * example, {@code Splitter.on(\", \").split(\"foo, bar,baz\")} returns an\n",
        "165": "   * iterable containing {@code [\"foo\", \"bar,baz\"]}.\n",
        "208": "   * Splitter.on(Pattern.compile(\"\\r?\\n\")).split(entireFile)} splits a string\n",
        "209": "   * into lines whether it uses DOS-style or UNIX-style line terminators.\n",
        "211": "   * @param separatorPattern the pattern that determines whether a subsequence\n",
        "212": "   *     is a separator. This pattern may not match the empty string.\n",
        "214": "   * @throws IllegalArgumentException if {@code separatorPattern} matches the\n",
        "215": "   *     empty string\n",
        "246": "   * Returns a splitter that considers any subsequence matching a given\n",
        "247": "   * pattern (regular expression) to be a separator. For example, {@code\n",
        "248": "   * Splitter.onPattern(\"\\r?\\n\").split(entireFile)} splits a string into lines\n",
        "249": "   * whether it uses DOS-style or UNIX-style line terminators. This is\n",
        "250": "   * equivalent to {@code Splitter.on(Pattern.compile(pattern))}.\n",
        "252": "   * @param separatorPattern the pattern that determines whether a subsequence\n",
        "253": "   *     is a separator. This pattern may not match the empty string.\n",
        "255": "   * @throws java.util.regex.PatternSyntaxException if {@code separatorPattern}\n",
        "256": "   *     is a malformed expression\n",
        "257": "   * @throws IllegalArgumentException if {@code separatorPattern} matches the\n",
        "258": "   *     empty string\n",
        "266": "   * Returns a splitter that divides strings into pieces of the given length.\n",
        "267": "   * For example, {@code Splitter.fixedLength(2).split(\"abcde\")} returns an\n",
        "268": "   * iterable containing {@code [\"ab\", \"cd\", \"e\"]}. The last piece can be\n",
        "269": "   * smaller than {@code length} but will never be empty.\n",
        "272": "   * split(\"\")} does not yield an empty iterable, but an iterable containing\n",
        "273": "   * {@code \"\"}. This is the only case in which {@code\n",
        "275": "   * IntMath.divide(input.length(), length, CEILING)}. To avoid this behavior,\n",
        "276": "   * use {@code omitEmptyStrings}.\n",
        "278": "   * @param length the desired length of pieces after splitting, a positive\n",
        "279": "   *     integer\n",
        "280": "   * @return a splitter, with default settings, that can split into fixed sized\n",
        "281": "   *     pieces\n",
        "308": "   * Returns a splitter that behaves equivalently to {@code this} splitter, but\n",
        "309": "   * automatically omits empty strings from the results. For example, {@code\n",
        "310": "   * Splitter.on(',').omitEmptyStrings().split(\",a,,,b,c,,\")} returns an\n",
        "311": "   * iterable containing only {@code [\"a\", \"b\", \"c\"]}.\n",
        "313": "   * <p>If either {@code trimResults} option is also specified when creating a\n",
        "314": "   * splitter, that splitter always trims results first before checking for\n",
        "315": "   * emptiness. So, for example, {@code\n",
        "316": "   * Splitter.on(':').omitEmptyStrings().trimResults().split(\": : : \")} returns\n",
        "317": "   * an empty iterable.\n",
        "319": "   * <p>Note that it is ordinarily not possible for {@link #split(CharSequence)}\n",
        "320": "   * to return an empty iterable, but when using this option, it can (if the\n",
        "321": "   * input sequence consists of nothing but separators).\n",
        "330": "   * Returns a splitter that behaves equivalently to {@code this} splitter but\n",
        "331": "   * stops splitting after it reaches the limit.\n",
        "332": "   * The limit defines the maximum number of items returned by the iterator, or\n",
        "333": "   * the maximum size of the list returned by {@link #splitToList}.\n",
        "335": "   * <p>For example,\n",
        "336": "   * {@code Splitter.on(',').limit(3).split(\"a,b,c,d\")} returns an iterable\n",
        "337": "   * containing {@code [\"a\", \"b\", \"c,d\"]}.  When omitting empty strings, the\n",
        "338": "   * omitted strings do no count.  Hence,\n",
        "339": "   * {@code Splitter.on(',').limit(3).omitEmptyStrings().split(\"a,,,b,,,c,d\")}\n",
        "340": "   * returns an iterable containing {@code [\"a\", \"b\", \"c,d\"}.\n",
        "341": "   * When trim is requested, all entries, including the last are trimmed.  Hence\n",
        "342": "   * {@code Splitter.on(',').limit(3).trimResults().split(\" a , b , c , d \")}\n",
        "343": "   * results in {@code [\"a\", \"b\", \"c , d\"]}.\n",
        "355": "   * Returns a splitter that behaves equivalently to {@code this} splitter, but\n",
        "356": "   * automatically removes leading and trailing {@linkplain\n",
        "357": "   * CharMatcher#WHITESPACE whitespace} from each returned substring; equivalent\n",
        "358": "   * to {@code trimResults(CharMatcher.whitespace())}. For example, {@code\n",
        "359": "   * Splitter.on(',').trimResults().split(\" a, b ,c \")} returns an iterable\n",
        "360": "   * containing {@code [\"a\", \"b\", \"c\"]}.\n",
        "369": "   * Returns a splitter that behaves equivalently to {@code this} splitter, but\n",
        "370": "   * removes all leading or trailing characters matching the given {@code\n",
        "372": "   * Splitter.on(',').trimResults(CharMatcher.is('_')).split(\"_a ,_b_ ,c__\")}\n",
        "373": "   * returns an iterable containing {@code [\"a \", \"b_ \", \"c\"]}.\n",
        "375": "   * @param trimmer a {@link CharMatcher} that determines whether a character\n",
        "376": "   *     should be removed from the beginning/end of a subsequence\n",
        "386": "   * Splits {@code sequence} into string components and makes them available\n",
        "387": "   * through an {@link Iterator}, which may be lazily evaluated. If you want\n",
        "388": "   * an eagerly computed {@link List}, use {@link #splitToList(CharSequence)}.\n",
        "417": "   * Splits {@code sequence} into string components and returns them as\n",
        "418": "   * an immutable list. If you want an {@link Iterable} which may be lazily\n",
        "419": "   * evaluated, use {@link #split(CharSequence)}.\n",
        "440": "   * Returns a {@code MapSplitter} which splits entries based on this splitter,\n",
        "441": "   * and splits entries into keys and values using the specified separator.\n",
        "451": "   * Returns a {@code MapSplitter} which splits entries based on this splitter,\n",
        "452": "   * and splits entries into keys and values using the specified separator.\n",
        "462": "   * Returns a {@code MapSplitter} which splits entries based on this splitter,\n",
        "463": "   * and splits entries into keys and values using the specified key-value\n",
        "464": "   * splitter.\n",
        "474": "   * An object that splits strings into maps as {@code Splitter} splits\n",
        "475": "   * iterables and lists. Like {@code Splitter}, it is thread-safe and\n",
        "476": "   * immutable.\n",
        "492": "     * Splits {@code sequence} into substrings, splits each substring into\n",
        "493": "     * an entry, and returns an unmodifiable map with each of the entries. For\n",
        "494": "     * example, <code>\n",
        "497": "     * </code> will return a mapping from {@code \"a\"} to {@code \"b\"} and\n",
        "498": "     * {@code \"c\"} to {@code b}.\n",
        "500": "     * <p>The returned map preserves the order of the entries from\n",
        "501": "     * {@code sequence}.\n",
        "503": "     * @throws IllegalArgumentException if the specified sequence does not split\n",
        "504": "     *         into valid map entries, or if there are duplicate keys\n",
        "535": "     * Returns the first index in {@code toSplit} at or after {@code start}\n",
        "536": "     * that contains the separator.\n",
        "542": "     * separatorPosition} that does not contain a separator. This method is only\n",
        "543": "     * invoked after a call to {@code separatorStart}.\n",
        "560": "       * The returned string will be from the end of the last match to the\n",
        "561": "       * beginning of the next one. nextStart is the start position of the\n",
        "562": "       * returned substring, while offset is the place to start looking for a\n",
        "563": "       * separator.\n",
        "580": "           * This occurs when some pattern has an empty match, even if it\n",
        "581": "           * doesn't match the empty string -- for example, if it requires\n",
        "582": "           * lookahead or the like. The offset must be increased to look for\n",
        "583": "           * separators beyond this point, without changing the start position\n",
        "608": "          // final item.  This is tested after empty string removal so that\n"
    }
}