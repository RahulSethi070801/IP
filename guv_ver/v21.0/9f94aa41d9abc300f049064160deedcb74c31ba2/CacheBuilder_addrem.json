{
    "addition": {
        "4": " * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not use this file except\n",
        "5": " * in compliance with the License. You may obtain a copy of the License at\n",
        "9": " * Unless required by applicable law or agreed to in writing, software distributed under the License\n",
        "10": " * is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express\n",
        "11": " * or implied. See the License for the specific language governing permissions and limitations under\n",
        "12": " * the License.\n",
        "52": " * <li>values automatically wrapped in {@linkplain WeakReference weak} or {@linkplain SoftReference\n",
        "53": " *     soft} references\n",
        "94": " * are reflected in that iterator. These iterators never throw\n",
        "95": " * {@link ConcurrentModificationException}.\n",
        "99": " * {@link #weakKeys} was specified, the cache uses identity ({@code ==}) comparisons instead for\n",
        "100": " * keys. Likewise, if {@link #weakValues} or {@link #softValues} was specified, the cache uses\n",
        "101": " * identity comparisons for values.\n",
        "103": " * <p>Entries are automatically evicted from the cache when any of {@linkplain #maximumSize(long)\n",
        "104": " * maximumSize}, {@linkplain #maximumWeight(long) maximumWeight}, {@linkplain #expireAfterWrite\n",
        "105": " * expireAfterWrite}, {@linkplain #expireAfterAccess expireAfterAccess}, {@linkplain #weakKeys\n",
        "106": " * weakKeys}, {@linkplain #weakValues weakValues}, or {@linkplain #softValues softValues} are\n",
        "107": " * requested.\n",
        "109": " * <p>If {@linkplain #maximumSize(long) maximumSize} or {@linkplain #maximumWeight(long)\n",
        "110": " * maximumWeight} is requested entries may be evicted on each cache modification.\n",
        "112": " * <p>If {@linkplain #expireAfterWrite expireAfterWrite} or {@linkplain #expireAfterAccess\n",
        "113": " * expireAfterAccess} is requested entries may be evicted on each cache modification, on occasional\n",
        "114": " * cache accesses, or on calls to {@link Cache#cleanUp}. Expired entries may be counted by\n",
        "115": " * {@link Cache#size}, but will never be visible to read or write operations.\n",
        "137": " * <p>See the Guava User Guide article on\n",
        "138": " * <a href=\"https://github.com/google/guava/wiki/CachesExplained\">caching</a> for a higher-level\n",
        "154": "  static final Supplier<? extends StatsCounter> NULL_STATS_COUNTER =\n",
        "155": "      Suppliers.ofInstance(\n",
        "156": "          new StatsCounter() {\n",
        "157": "            @Override\n",
        "158": "            public void recordHits(int count) {}\n",
        "160": "            @Override\n",
        "161": "            public void recordMisses(int count) {}\n",
        "163": "            @Override\n",
        "164": "            public void recordLoadSuccess(long loadTime) {}\n",
        "166": "            @Override\n",
        "167": "            public void recordLoadException(long loadTime) {}\n",
        "169": "            @Override\n",
        "170": "            public void recordEviction() {}\n",
        "172": "            @Override\n",
        "173": "            public CacheStats snapshot() {\n",
        "174": "              return EMPTY_STATS;\n",
        "175": "            }\n",
        "176": "          });\n",
        "181": "        @Override\n",
        "182": "        public StatsCounter get() {\n",
        "183": "          return new SimpleStatsCounter();\n",
        "184": "        }\n",
        "185": "      };\n",
        "203": "  static final Ticker NULL_TICKER =\n",
        "204": "      new Ticker() {\n",
        "205": "        @Override\n",
        "206": "        public long read() {\n",
        "207": "          return 0;\n",
        "208": "        }\n",
        "209": "      };\n",
        "256": "    return spec.toCacheBuilder().lenientParsing();\n",
        "312": "    checkState(\n",
        "313": "        valueEquivalence == null, \"value equivalence was already set to %s\", valueEquivalence);\n",
        "334": "    checkState(\n",
        "335": "        this.initialCapacity == UNSET_INT,\n",
        "336": "        \"initial capacity was already set to %s\",\n",
        "359": "   * <p>Defaults to 4. <b>Note:</b>The default may change in the future. If you care about this\n",
        "364": "   * write, and twice for each cache loading computation (once prior to loading the new value, and\n",
        "365": "   * once after loading completes). Much internal cache management is performed at the segment\n",
        "379": "    checkState(\n",
        "380": "        this.concurrencyLevel == UNSET_INT,\n",
        "381": "        \"concurrency level was already set to %s\",\n",
        "409": "    checkState(\n",
        "410": "        this.maximumSize == UNSET_INT, \"maximum size was already set to %s\", this.maximumSize);\n",
        "411": "    checkState(\n",
        "412": "        this.maximumWeight == UNSET_INT,\n",
        "413": "        \"maximum weight was already set to %s\",\n",
        "432": "   * cache. This can be useful in testing, or to disable caching temporarily without a code change.\n",
        "447": "    checkState(\n",
        "448": "        this.maximumWeight == UNSET_INT,\n",
        "449": "        \"maximum weight was already set to %s\",\n",
        "451": "    checkState(\n",
        "452": "        this.maximumSize == UNSET_INT, \"maximum size was already set to %s\", this.maximumSize);\n",
        "459": "   * Specifies the weigher to use in determining the weight of entries. Entry weight is taken into\n",
        "460": "   * consideration by {@link #maximumWeight(long)} when determining which entries to evict, and use\n",
        "461": "   * of this method requires a corresponding call to {@link #maximumWeight(long)} prior to calling\n",
        "462": "   * {@link #build}. Weights are measured and recorded when entries are inserted into the cache, and\n",
        "463": "   * are thus effectively static during the lifetime of a cache entry.\n",
        "477": "   * <p><b>Warning:</b> if you ignore the above advice, and use this {@code CacheBuilder} to build a\n",
        "478": "   * cache whose key or value type is incompatible with the weigher, you will likely experience a\n",
        "479": "   * {@link ClassCastException} at some <i>undefined</i> point in the future.\n",
        "492": "      checkState(\n",
        "493": "          this.maximumSize == UNSET_INT,\n",
        "494": "          \"weigher can not be combined with maximum size\",\n",
        "519": "   * Specifies that each key (not value) stored in the cache should be wrapped in a\n",
        "520": "   * {@link WeakReference} (by default, strong references are used).\n",
        "525": "   * <p>Entries with keys that have been garbage collected may be counted in {@link Cache#size}, but\n",
        "526": "   * will never be visible to read or write operations; such entries are cleaned up as part of the\n",
        "527": "   * routine maintenance described in the class javadoc.\n",
        "575": "   * <p><b>Warning:</b> in most circumstances it is better to set a per-cache\n",
        "576": "   * {@linkplain #maximumSize(long) maximum size} instead of using soft references. You should only\n",
        "577": "   * use this method if you are well familiar with the practical consequences of soft references.\n",
        "608": "   * <p>When {@code duration} is zero, this method hands off to {@link #maximumSize(long)\n",
        "609": "   * maximumSize}{@code (0)}, ignoring any otherwise-specificed maximum size or weight. This can be\n",
        "610": "   * useful in testing, or to disable caching temporarily without a code change.\n",
        "624": "    checkState(\n",
        "625": "        expireAfterWriteNanos == UNSET_INT,\n",
        "626": "        \"expireAfterWrite was already set to %s ns\",\n",
        "644": "   * <p>When {@code duration} is zero, this method hands off to {@link #maximumSize(long)\n",
        "645": "   * maximumSize}{@code (0)}, ignoring any otherwise-specificed maximum size or weight. This can be\n",
        "646": "   * useful in testing, or to disable caching temporarily without a code change.\n",
        "660": "    checkState(\n",
        "661": "        expireAfterAccessNanos == UNSET_INT,\n",
        "662": "        \"expireAfterAccess was already set to %s ns\",\n",
        "671": "        ? DEFAULT_EXPIRATION_NANOS\n",
        "672": "        : expireAfterAccessNanos;\n",
        "742": "   * <p><b>Warning:</b> after invoking this method, do not continue to use <i>this</i> cache builder\n",
        "743": "   * reference; instead use the reference this method <i>returns</i>. At runtime, these point to the\n",
        "744": "   * same instance, but only the returned reference has the correct generic type information so as\n",
        "745": "   * to ensure type safety. For best results, use the standard method-chaining idiom illustrated in\n",
        "746": "   * the class documentation above, configuring a builder and building your cache in a single\n",
        "747": "   * statement. Failure to heed this advice can result in a {@link ClassCastException} being thrown\n",
        "748": "   * by a cache operation at some <i>undefined</i> point in the future.\n",
        "802": "   * loading the value for this key, simply waits for that thread to finish and returns its loaded\n",
        "803": "   * value. Note that multiple threads can concurrently load values for distinct keys.\n",
        "812": "      CacheLoader<? super K1, V1> loader) {\n"
    },
    "removed": {
        "4": " * Licensed under the Apache License, Version 2.0 (the \"License\");\n",
        "5": " * you may not use this file except in compliance with the License.\n",
        "6": " * You may obtain a copy of the License at\n",
        "10": " * Unless required by applicable law or agreed to in writing, software\n",
        "11": " * distributed under the License is distributed on an \"AS IS\" BASIS,\n",
        "12": " * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n",
        "13": " * See the License for the specific language governing permissions and\n",
        "14": " * limitations under the License.\n",
        "54": " * <li>values automatically wrapped in {@linkplain WeakReference weak} or\n",
        "55": " *     {@linkplain SoftReference soft} references\n",
        "96": " * are reflected in that iterator. These iterators never throw {@link\n",
        "97": " * ConcurrentModificationException}.\n",
        "101": " * {@link #weakKeys} was specified, the cache uses identity ({@code ==})\n",
        "102": " * comparisons instead for keys. Likewise, if {@link #weakValues} or {@link #softValues} was\n",
        "103": " * specified, the cache uses identity comparisons for values.\n",
        "105": " * <p>Entries are automatically evicted from the cache when any of\n",
        "106": " * {@linkplain #maximumSize(long) maximumSize}, {@linkplain #maximumWeight(long) maximumWeight},\n",
        "107": " * {@linkplain #expireAfterWrite expireAfterWrite},\n",
        "108": " * {@linkplain #expireAfterAccess expireAfterAccess}, {@linkplain #weakKeys weakKeys},\n",
        "109": " * {@linkplain #weakValues weakValues}, or {@linkplain #softValues softValues} are requested.\n",
        "111": " * <p>If {@linkplain #maximumSize(long) maximumSize} or\n",
        "112": " * {@linkplain #maximumWeight(long) maximumWeight} is requested entries may be evicted on each cache\n",
        "113": " * modification.\n",
        "115": " * <p>If {@linkplain #expireAfterWrite expireAfterWrite} or\n",
        "116": " * {@linkplain #expireAfterAccess expireAfterAccess} is requested entries may be evicted on each\n",
        "117": " * cache modification, on occasional cache accesses, or on calls to {@link Cache#cleanUp}. Expired\n",
        "118": " * entries may be counted by {@link Cache#size}, but will never be visible to read or write\n",
        "119": " * operations.\n",
        "141": " * <p>See the Guava User Guide article on <a href=\n",
        "142": " * \"https://github.com/google/guava/wiki/CachesExplained\">caching</a> for a higher-level\n",
        "158": "  static final Supplier<? extends StatsCounter> NULL_STATS_COUNTER = Suppliers.ofInstance(\n",
        "159": "      new StatsCounter() {\n",
        "160": "        @Override\n",
        "161": "        public void recordHits(int count) {}\n",
        "163": "        @Override\n",
        "164": "        public void recordMisses(int count) {}\n",
        "166": "        @Override\n",
        "167": "        public void recordLoadSuccess(long loadTime) {}\n",
        "169": "        @Override\n",
        "170": "        public void recordLoadException(long loadTime) {}\n",
        "172": "        @Override\n",
        "173": "        public void recordEviction() {}\n",
        "175": "        @Override\n",
        "176": "        public CacheStats snapshot() {\n",
        "177": "          return EMPTY_STATS;\n",
        "178": "        }\n",
        "179": "      });\n",
        "184": "    @Override\n",
        "185": "    public StatsCounter get() {\n",
        "186": "      return new SimpleStatsCounter();\n",
        "187": "    }\n",
        "188": "  };\n",
        "206": "  static final Ticker NULL_TICKER = new Ticker() {\n",
        "207": "    @Override\n",
        "208": "    public long read() {\n",
        "209": "      return 0;\n",
        "210": "    }\n",
        "211": "  };\n",
        "258": "    return spec.toCacheBuilder()\n",
        "259": "        .lenientParsing();\n",
        "315": "    checkState(valueEquivalence == null,\n",
        "316": "        \"value equivalence was already set to %s\", valueEquivalence);\n",
        "337": "    checkState(this.initialCapacity == UNSET_INT, \"initial capacity was already set to %s\",\n",
        "360": "   * <p> Defaults to 4. <b>Note:</b>The default may change in the future. If you care about this\n",
        "365": "   * write, and twice for each cache loading computation (once prior to loading the new value,\n",
        "366": "   * and once after loading completes). Much internal cache management is performed at the segment\n",
        "380": "    checkState(this.concurrencyLevel == UNSET_INT, \"concurrency level was already set to %s\",\n",
        "408": "    checkState(this.maximumSize == UNSET_INT, \"maximum size was already set to %s\",\n",
        "409": "        this.maximumSize);\n",
        "410": "    checkState(this.maximumWeight == UNSET_INT, \"maximum weight was already set to %s\",\n",
        "429": "   * cache. This can be useful in testing, or to disable caching temporarily without a code\n",
        "430": "   * change.\n",
        "445": "    checkState(this.maximumWeight == UNSET_INT, \"maximum weight was already set to %s\",\n",
        "447": "    checkState(this.maximumSize == UNSET_INT, \"maximum size was already set to %s\",\n",
        "448": "        this.maximumSize);\n",
        "455": "   * Specifies the weigher to use in determining the weight of entries. Entry weight is taken\n",
        "456": "   * into consideration by {@link #maximumWeight(long)} when determining which entries to evict, and\n",
        "457": "   * use of this method requires a corresponding call to {@link #maximumWeight(long)} prior to\n",
        "458": "   * calling {@link #build}. Weights are measured and recorded when entries are inserted into the\n",
        "459": "   * cache, and are thus effectively static during the lifetime of a cache entry.\n",
        "473": "   * <p><b>Warning:</b> if you ignore the above advice, and use this {@code CacheBuilder} to build\n",
        "474": "   * a cache whose key or value type is incompatible with the weigher, you will likely experience\n",
        "475": "   * a {@link ClassCastException} at some <i>undefined</i> point in the future.\n",
        "488": "      checkState(this.maximumSize == UNSET_INT, \"weigher can not be combined with maximum size\",\n",
        "513": "   * Specifies that each key (not value) stored in the cache should be wrapped in a {@link\n",
        "514": "   * WeakReference} (by default, strong references are used).\n",
        "519": "   * <p>Entries with keys that have been garbage collected may be counted in {@link Cache#size},\n",
        "520": "   * but will never be visible to read or write operations; such entries are cleaned up as part of\n",
        "521": "   * the routine maintenance described in the class javadoc.\n",
        "569": "   * <p><b>Warning:</b> in most circumstances it is better to set a per-cache {@linkplain\n",
        "570": "   * #maximumSize(long) maximum size} instead of using soft references. You should only use this\n",
        "571": "   * method if you are well familiar with the practical consequences of soft references.\n",
        "602": "   * <p>When {@code duration} is zero, this method hands off to\n",
        "603": "   * {@link #maximumSize(long) maximumSize}{@code (0)}, ignoring any otherwise-specificed maximum\n",
        "604": "   * size or weight. This can be useful in testing, or to disable caching temporarily without a code\n",
        "605": "   * change.\n",
        "619": "    checkState(expireAfterWriteNanos == UNSET_INT, \"expireAfterWrite was already set to %s ns\",\n",
        "637": "   * <p>When {@code duration} is zero, this method hands off to\n",
        "638": "   * {@link #maximumSize(long) maximumSize}{@code (0)}, ignoring any otherwise-specificed maximum\n",
        "639": "   * size or weight. This can be useful in testing, or to disable caching temporarily without a code\n",
        "640": "   * change.\n",
        "654": "    checkState(expireAfterAccessNanos == UNSET_INT, \"expireAfterAccess was already set to %s ns\",\n",
        "663": "        ? DEFAULT_EXPIRATION_NANOS : expireAfterAccessNanos;\n",
        "733": "   * <p><b>Warning:</b> after invoking this method, do not continue to use <i>this</i> cache\n",
        "734": "   * builder reference; instead use the reference this method <i>returns</i>. At runtime, these\n",
        "735": "   * point to the same instance, but only the returned reference has the correct generic type\n",
        "736": "   * information so as to ensure type safety. For best results, use the standard method-chaining\n",
        "737": "   * idiom illustrated in the class documentation above, configuring a builder and building your\n",
        "738": "   * cache in a single statement. Failure to heed this advice can result in a {@link\n",
        "739": "   * ClassCastException} being thrown by a cache operation at some <i>undefined</i> point in the\n",
        "740": "   * future.\n",
        "794": "   * loading the value for this key, simply waits for that thread to finish and returns its\n",
        "795": "   * loaded value. Note that multiple threads can concurrently load values for distinct keys.\n",
        "804": "          CacheLoader<? super K1, V1> loader) {\n"
    }
}