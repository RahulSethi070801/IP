{"id": "2b4067d26e1533a878349434b73deb1282f8432d", "code": [{"0": "guava-gwt/src-super/com/google/common/collect/super/com/google/common/collect/MapMaker.java", "added": {"2": ["    ExpiringComputingMap(long expirationMillis, int initialCapacity) {\n", "      this(expirationMillis, null, initialCapacity);\n", "    ExpiringComputingMap(\n", "        long expirationMillis, Function<? super K, ? extends V> computer, int initialCapacity) {\n", "      super(initialCapacity, /* ignored loadFactor */ 0.75f, true);\n"], "6": ["        ? new ExpiringComputingMap<K, V>(expirationMillis, null, initialCapacity)\n", "    return new ExpiringComputingMap<K, V>(expirationMillis, computer, initialCapacity);\n"]}, "removed": {"1": ["import java.util.Map;\n"], "2": ["    private final int maximumSize;\n", "    ExpiringComputingMap(\n", "        long expirationMillis, int maximumSize, int initialCapacity) {\n", "      this(expirationMillis, null, maximumSize, initialCapacity);\n", "    ExpiringComputingMap(long expirationMillis, Function<? super K, ? extends V> computer,\n", "        int maximumSize, int initialCapacity) {\n", "      super(initialCapacity, /* ignored loadFactor */ 0.75f, (maximumSize != -1));\n", "      this.maximumSize = maximumSize;\n"], "3": ["    @Override\n", "    protected boolean removeEldestEntry(Map.Entry<K, V> ignored) {\n", "      return (maximumSize == -1) ? false : size() > maximumSize;\n", "    }\n", "\n"], "4": ["  private int maximumSize = -1;\n"], "5": ["  @Override\n", "  MapMaker maximumSize(int maximumSize) {\n", "    if (this.maximumSize != -1) {\n", "      throw new IllegalStateException(\"maximum size of \" + maximumSize + \" was already set\");\n", "    }\n", "    if (maximumSize < 0) {\n", "      throw new IllegalArgumentException(\"invalid maximum size: \" + maximumSize);\n", "    }\n", "    this.maximumSize = maximumSize;\n", "    useCustomMap = true;\n", "    return this;\n", "  }\n", "\n"], "6": ["        ? new ExpiringComputingMap<K, V>(expirationMillis, null, maximumSize, initialCapacity)\n", "    return new ExpiringComputingMap<K, V>(\n", "        expirationMillis, computer, maximumSize, initialCapacity);\n"]}, "added_lines": {"2": [46, 47, 50, 51, 52], "6": [205, 211]}, "removed_lines": {"1": [26], "2": [46, 48, 49, 50, 53, 54, 55, 58], "3": [70, 71, 72, 73, 74], "4": [174], "5": [202, 203, 204, 205, 206, 207, 208, 209, 210, 211, 212, 213, 214], "6": [228, 234, 235]}}, {"1": "guava-gwt/test/com/google/common/collect/MapMakerTest_gwt.java", "added": {}, "removed": {"1": ["public void testPut_sizeIsZero__MaximumSizeTest() throws Exception {\n", "  com.google.common.collect.MapMakerTest.MaximumSizeTest testCase = new com.google.common.collect.MapMakerTest.MaximumSizeTest();\n", "  testCase.testPut_sizeIsZero();\n", "}\n", "\n", "public void testSizeBasedEviction__MaximumSizeTest() throws Exception {\n", "  com.google.common.collect.MapMakerTest.MaximumSizeTest testCase = new com.google.common.collect.MapMakerTest.MaximumSizeTest();\n", "  testCase.testSizeBasedEviction();\n", "}\n", "\n"], "2": ["public void testMaximumSize_setTwice__MakerTest() throws Exception {\n", "  com.google.common.collect.MapMakerTest.MakerTest testCase = new com.google.common.collect.MapMakerTest.MakerTest();\n", "  testCase.testMaximumSize_setTwice();\n", "}\n", "\n"]}, "added_lines": {}, "removed_lines": {"1": [36, 37, 38, 39, 40, 41, 42, 43, 44, 45], "2": [56, 57, 58, 59, 60]}}, {"2": "guava-tests/benchmark/com/google/common/collect/MapMakerSingleThreadBenchmark.java", "added": {}, "removed": {"1": ["        .maximumSize(maximumSize)\n"]}, "added_lines": {}, "removed_lines": {"1": [61]}}, {"3": "guava-tests/test/com/google/common/collect/ConcurrentHashMultisetTest.java", "added": {"1": ["      fail();\n"]}, "removed": {"2": ["  public void testWithMapMakerEvictionListener() {\n", "    @SuppressWarnings(\"deprecation\") // TODO(kevinb): what to do?\n", "    MapMaker mapMaker = new MapMaker()\n", "        .concurrencyLevel(1)\n", "        .maximumSize(1);\n", "\n", "    ConcurrentHashMultiset<String> multiset = ConcurrentHashMultiset.create(mapMaker);\n", "\n", "    multiset.add(\"a\", 5);\n", "    assertTrue(multiset.contains(\"a\"));\n", "    assertEquals(5, multiset.count(\"a\"));\n", "\n", "    multiset.add(\"b\", 3);\n", "\n", "    assertFalse(multiset.contains(\"a\"));\n", "    assertTrue(multiset.contains(\"b\"));\n", "    assertEquals(3, multiset.count(\"b\"));\n", "  }\n", "\n"]}, "added_lines": {"1": [280]}, "removed_lines": {"2": [531, 532, 533, 534, 535, 536, 537, 538, 539, 540, 541, 542, 543, 544, 545, 546, 547, 548, 549]}}, {"4": "guava-tests/test/com/google/common/collect/MapMakerInternalMapTest.java", "added": {"5": ["    MapMakerInternalMap<Object, Object> map =\n", "        makeMap(\n", "            createMapMaker().concurrencyLevel(concurrencyLevel).initialCapacity(initialCapacity));\n"], "19": ["    if (map.expiresAfterAccess()) {\n"], "22": ["   * Returns an iterable containing all combinations of expireAfterAccess/Write.\n", "    return ImmutableList.of(\n", "        createMapMaker().expireAfterAccess(SMALL_MAX_SIZE, TimeUnit.SECONDS),\n", "        createMapMaker().expireAfterWrite(SMALL_MAX_SIZE, TimeUnit.SECONDS));\n"]}, "removed": {"1": ["import java.util.LinkedHashMap;\n"], "2": ["  private static <K, V> MapMakerInternalMap<K, V> makeMap(GenericMapMaker<K, V> maker) {\n", "    return new MapMakerInternalMap<K, V>((MapMaker) maker);\n", "  }\n", "\n"], "3": ["    assertEquals(MapMaker.UNSET_INT, map.maximumSize);\n"], "4": ["    assertFalse(map.evictsBySize());\n"], "5": ["    MapMakerInternalMap<Object, Object> map = makeMap(createMapMaker()\n", "        .concurrencyLevel(concurrencyLevel)\n", "        .initialCapacity(initialCapacity)\n", "        .maximumSize(maxSize));\n"], "6": ["      if (map.evictsBySize()) {\n", "        MapMakerInternalMap.connectEvictables(entryOne, entryTwo);\n", "      }\n"], "7": ["    if (map.evictsBySize()) {\n", "      assertSame(two, one.getNextEvictable());\n", "    }\n"], "8": ["  public void testSegmentPut_evict() {\n", "    int maxSize = 10;\n", "    MapMakerInternalMap<Object, Object> map =\n", "        makeMap(createMapMaker().concurrencyLevel(1).maximumSize(maxSize));\n", "\n", "    // manually add elements to avoid eviction\n", "    int originalCount = 1024;\n", "    LinkedHashMap<Object, Object> originalMap = Maps.newLinkedHashMap();\n", "    for (int i = 0; i < originalCount; i++) {\n", "      Object key = new Object();\n", "      Object value = new Object();\n", "      map.put(key, value);\n", "      originalMap.put(key, value);\n", "      if (i >= maxSize) {\n", "        Iterator<Object> it = originalMap.keySet().iterator();\n", "        it.next();\n", "        it.remove();\n", "      }\n", "      assertEquals(originalMap, map);\n", "    }\n", "  }\n", "\n"], "9": ["                .maximumSize(SMALL_MAX_SIZE)\n"], "10": ["    assertFalse(segment.evictionQueue.contains(entryOne));\n"], "11": ["        .maximumSize(SMALL_MAX_SIZE)\n"], "12": ["    assertSame(entry, segment.evictionQueue.peek());\n", "    assertTrue(segment.evictionQueue.isEmpty());\n"], "13": ["                .maximumSize(SMALL_MAX_SIZE)\n"], "14": ["    assertFalse(segment.evictionQueue.contains(entry));\n"], "15": ["                .maximumSize(SMALL_MAX_SIZE)\n"], "16": ["    assertFalse(segment.evictionQueue.contains(entry));\n"], "17": ["                .maximumSize(SMALL_MAX_SIZE)\n"], "18": ["    assertFalse(segment.evictionQueue.contains(entry));\n"], "19": ["    if (map.evictsBySize() || map.expiresAfterAccess()) {\n"], "20": ["    if (map.evictsBySize()) {\n", "      assertSameEntries(readOrder, ImmutableList.copyOf(segment.evictionQueue));\n", "    }\n"], "21": ["  public void testEvictEntries() {\n", "    int maxSize = 10;\n", "    MapMakerInternalMap<Object, Object> map =\n", "        makeMap(createMapMaker().concurrencyLevel(1).maximumSize(maxSize));\n", "    Segment<Object, Object> segment = map.segments[0];\n", "\n", "    // manually add elements to avoid eviction\n", "    int originalCount = 1024;\n", "    ReferenceEntry<Object, Object> entry = null;\n", "    LinkedHashMap<Object, Object> originalMap = Maps.newLinkedHashMap();\n", "    for (int i = 0; i < originalCount; i++) {\n", "      Object key = new Object();\n", "      Object value = new Object();\n", "      AtomicReferenceArray<ReferenceEntry<Object, Object>> table = segment.table;\n", "      int hash = map.hash(key);\n", "      int index = hash & (table.length() - 1);\n", "      ReferenceEntry<Object, Object> first = table.get(index);\n", "      entry = map.newEntry(key, hash, first);\n", "      ValueReference<Object, Object> valueRef = map.newValueReference(entry, value);\n", "      entry.setValueReference(valueRef);\n", "      segment.recordWrite(entry);\n", "      table.set(index, entry);\n", "      originalMap.put(key, value);\n", "    }\n", "    segment.count = originalCount;\n", "    assertEquals(originalCount, originalMap.size());\n", "    assertEquals(originalMap, map);\n", "\n", "    for (int i = maxSize - 1; i < originalCount; i++) {\n", "      assertTrue(segment.evictEntries());\n", "      Iterator<Object> it = originalMap.keySet().iterator();\n", "      it.next();\n", "      it.remove();\n", "      assertEquals(originalMap, map);\n", "    }\n", "    assertFalse(segment.evictEntries());\n", "  }\n", "\n"], "22": ["    for (MapMaker maker : allKeyValueStrengthMakers()) {\n", "      result.add(maker.maximumSize(SMALL_MAX_SIZE));\n", "    }\n", "    for (MapMaker maker : allKeyValueStrengthMakers()) {\n", "      result.add(maker.maximumSize(SMALL_MAX_SIZE).expireAfterAccess(99999, SECONDS));\n", "    }\n", "    for (MapMaker maker : allKeyValueStrengthMakers()) {\n", "      result.add(maker.maximumSize(SMALL_MAX_SIZE).expireAfterWrite(99999, SECONDS));\n", "    }\n", "   * Returns an iterable containing all combinations of maximumSize and expireAfterAccess/Write.\n", "    return ImmutableList.of(createMapMaker().maximumSize(SMALL_MAX_SIZE),\n", "        createMapMaker()\n", "            .maximumSize(SMALL_MAX_SIZE)\n", "            .expireAfterAccess(SMALL_MAX_SIZE, TimeUnit.SECONDS),\n", "        createMapMaker()\n", "            .maximumSize(SMALL_MAX_SIZE)\n", "            .expireAfterWrite(SMALL_MAX_SIZE, TimeUnit.SECONDS));\n"]}, "added_lines": {"5": [199, 200, 201], "19": [1161], "22": [1356, 1359, 1362, 1363]}, "removed_lines": {"1": [41], "2": [55, 56, 57, 58], "3": [81], "4": [93], "5": [206, 207, 208, 209], "6": [308, 309, 310], "7": [334, 335, 336], "8": [580, 581, 582, 583, 584, 585, 586, 587, 588, 589, 590, 591, 592, 593, 594, 595, 596, 597, 598, 599, 600, 601], "9": [728], "10": [760], "11": [873], "12": [889, 894], "13": [906], "14": [925], "15": [937], "16": [958], "17": [977], "18": [999], "19": [1208], "20": [1217, 1218, 1219], "21": [1262, 1263, 1264, 1265, 1266, 1267, 1268, 1269, 1270, 1271, 1272, 1273, 1274, 1275, 1276, 1277, 1278, 1279, 1280, 1281, 1282, 1283, 1284, 1285, 1286, 1287, 1288, 1289, 1290, 1291, 1292, 1293, 1294, 1295, 1296, 1297, 1298, 1299], "22": [1434, 1435, 1436, 1443, 1444, 1445, 1446, 1447, 1448, 1453, 1456, 1459, 1460, 1461, 1462, 1463, 1464]}}, {"5": "guava-tests/test/com/google/common/collect/MapMakerTest.java", "added": {}, "removed": {"1": ["    public void testMaximumSize_setTwice() {\n", "      MapMaker maker = new MapMaker().maximumSize(16);\n", "      try {\n", "        // even to the same value is not allowed\n", "        maker.maximumSize(16);\n", "        fail();\n", "      } catch (IllegalStateException expected) {\n", "      }\n", "    }\n", "\n"], "2": ["  /** Tests of the built map with maximumSize. */\n", "  public static class MaximumSizeTest extends TestCase {\n", "    public void testPut_sizeIsZero() {\n", "      ConcurrentMap<Object, Object> map =\n", "          new MapMaker().maximumSize(0).makeMap();\n", "      assertEquals(0, map.size());\n", "      map.put(new Object(), new Object());\n", "      assertEquals(0, map.size());\n", "    }\n", "\n", "    public void testSizeBasedEviction() {\n", "      int numKeys = 10;\n", "      int mapSize = 5;\n", "      ConcurrentMap<Object, Object> map =\n", "          new MapMaker().maximumSize(mapSize).makeMap();\n", "      for (int i = 0; i < numKeys; i++) {\n", "        map.put(i, i);\n", "      }\n", "      assertEquals(mapSize, map.size());\n", "      for (int i = numKeys - mapSize; i < mapSize; i++) {\n", "        assertTrue(map.containsKey(i));\n", "      }\n", "    }\n", "  }\n", "\n"]}, "added_lines": {}, "removed_lines": {"1": [137, 138, 139, 140, 141, 142, 143, 144, 145, 146], "2": [155, 156, 157, 158, 159, 160, 161, 162, 163, 164, 165, 166, 167, 168, 169, 170, 171, 172, 173, 174, 175, 176, 177, 178, 179]}}, {"6": "guava/src/com/google/common/collect/ComputingConcurrentHashMap.java", "added": {}, "removed": {"1": ["                    evictionQueue.remove(e);\n"], "2": ["        maximumSize,\n"], "3": ["        int maximumSize,\n"], "4": ["          maximumSize,\n"]}, "added_lines": {}, "removed_lines": {"1": [128], "2": [384], "3": [401], "4": [412]}}, {"7": "guava/src/com/google/common/collect/GenericMapMaker.java", "added": {}, "removed": {"1": ["  /**\n", "   * See {@link MapMaker#maximumSize}.\n", "   */\n", "  abstract GenericMapMaker<K0, V0> maximumSize(int maximumSize);\n", "\n"]}, "added_lines": {}, "removed_lines": {"1": [63, 64, 65, 66, 67]}}, {"8": "guava/src/com/google/common/collect/MapMaker.java", "added": {"3": ["   * <p><b>Warning:</b> you should only use this method if you are well familiar with the practical\n", "   * consequences of soft references.\n"], "4": ["   * evicted immediately. It can be useful in testing, or to disable caching temporarily without\n"], "5": ["   * evicted immediately. It can be useful in testing, or to disable caching temporarily without\n"]}, "removed": {"1": ["  int maximumSize = UNSET_INT;\n"], "2": ["  /**\n", "   * Specifies the maximum number of entries the map may contain. Note that the map <b>may evict an\n", "   * entry before this limit is exceeded</b>. As the map size grows close to the maximum, the map\n", "   * evicts entries that are less likely to be used again. For example, the map may evict an entry\n", "   * because it hasn't been used recently or very often.\n", "   *\n", "   * <p>When {@code size} is zero, elements can be successfully added to the map, but are evicted\n", "   * immediately. This has the same effect as invoking {@link #expireAfterWrite expireAfterWrite}\n", "   * {@code (0, unit)}. It can be useful in testing, or to disable caching temporarily without\n", "   * a code change.\n", "   *\n", "   * @param size the maximum size of the map\n", "   * @throws IllegalArgumentException if {@code size} is negative\n", "   * @throws IllegalStateException if a maximum size was already set\n", "   */\n", "  @CanIgnoreReturnValue\n", "  @Override\n", "  MapMaker maximumSize(int size) {\n", "    checkState(\n", "        this.maximumSize == UNSET_INT, \"maximum size was already set to %s\", this.maximumSize);\n", "    checkArgument(size >= 0, \"maximum size must not be negative\");\n", "    this.maximumSize = size;\n", "    this.useCustomMap = true;\n", "    if (maximumSize == 0) {\n", "      this.evictImmediately = true;\n", "    }\n", "    return this;\n", "  }\n", "\n"], "3": ["   * <p><b>Warning:</b> in most circumstances it is better to set a per-cache\n", "   * {@linkplain #maximumSize maximum size} instead of using soft references. You should only use\n", "   * this method if you are well familiar with the practical consequences of soft references.\n"], "4": ["   * evicted immediately. This has a very similar effect to invoking {@link #maximumSize\n", "   * maximumSize}{@code (0)}. It can be useful in testing, or to disable caching temporarily without\n"], "5": ["   * evicted immediately. This has a very similar effect to invoking {@link #maximumSize\n", "   * maximumSize}{@code (0)}. It can be useful in testing, or to disable caching temporarily without\n"], "6": ["    if (maximumSize != UNSET_INT) {\n", "      s.add(\"maximumSize\", maximumSize);\n", "    }\n"]}, "added_lines": {"3": [281, 282], "4": [323], "5": [376]}, "removed_lines": {"1": [118], "2": [185, 186, 187, 188, 189, 190, 191, 192, 193, 194, 195, 196, 197, 198, 199, 200, 201, 202, 203, 204, 205, 206, 207, 208, 209, 210, 211, 212, 213], "3": [311, 312, 313], "4": [354, 355], "5": [408, 409], "6": [553, 554, 555]}}, {"9": "guava/src/com/google/common/collect/MapMakerInternalMap.java", "added": {"4": ["    entryFactory = EntryFactory.getFactory(keyStrength, expires());\n", "    // (segmentCount > concurrencyLevel)\n", "    while (segmentCount < concurrencyLevel) {\n"], "5": ["    for (int i = 0; i < this.segments.length; ++i) {\n", "      this.segments[i] = createSegment(segmentSize, MapMaker.UNSET_INT);\n"], "7": ["    static EntryFactory getFactory(Strength keyStrength, boolean expireAfterWrite) {\n", "      int flags = (expireAfterWrite ? EXPIRABLE_MASK : 0) | 0;\n"], "9": ["          (map.expiresAfterAccess())\n"]}, "removed": {"1": ["import java.util.logging.Logger;\n"], "2": ["  private static final Logger logger = Logger.getLogger(MapMakerInternalMap.class.getName());\n", "\n"], "3": ["  /** The maximum size of this map. MapMaker.UNSET_INT if there is no maximum. */\n", "  final int maximumSize;\n", "\n"], "4": ["    maximumSize = builder.maximumSize;\n", "    entryFactory = EntryFactory.getFactory(keyStrength, expires(), evictsBySize());\n", "    if (evictsBySize()) {\n", "      initialCapacity = Math.min(initialCapacity, maximumSize);\n", "    }\n", "    // (segmentCount <= maximumSize)\n", "    // && (concurrencyLevel > maximumSize || segmentCount > concurrencyLevel)\n", "    while (segmentCount < concurrencyLevel\n", "        && (!evictsBySize() || segmentCount * 2 <= maximumSize)) {\n"], "5": ["    if (evictsBySize()) {\n", "      // Ensure sum of segment max sizes = overall max size\n", "      int maximumSegmentSize = maximumSize / segmentCount + 1;\n", "      int remainder = maximumSize % segmentCount;\n", "      for (int i = 0; i < this.segments.length; ++i) {\n", "        if (i == remainder) {\n", "          maximumSegmentSize--;\n", "        }\n", "        this.segments[i] = createSegment(segmentSize, maximumSegmentSize);\n", "      }\n", "    } else {\n", "      for (int i = 0; i < this.segments.length; ++i) {\n", "        this.segments[i] = createSegment(segmentSize, MapMaker.UNSET_INT);\n", "      }\n", "  boolean evictsBySize() {\n", "    return maximumSize != MapMaker.UNSET_INT;\n", "  }\n", "\n"], "6": ["    static final int EVICTABLE_MASK = 2;\n", "\n"], "7": ["    static EntryFactory getFactory(\n", "        Strength keyStrength, boolean expireAfterWrite, boolean evictsBySize) {\n", "      int flags = (expireAfterWrite ? EXPIRABLE_MASK : 0) | (evictsBySize ? EVICTABLE_MASK : 0);\n"], "8": ["    /**\n", "     * A queue of elements currently in the map, ordered by access time. Elements are added to the\n", "     * tail of the queue on access/write.\n", "     */\n", "    @GuardedBy(\"this\")\n", "    final Queue<ReferenceEntry<K, V>> evictionQueue;\n", "\n"], "9": ["          (map.evictsBySize() || map.expiresAfterAccess())\n", "      evictionQueue =\n", "          map.evictsBySize()\n", "              ? new EvictionQueue<K, V>()\n", "              : MapMakerInternalMap.<ReferenceEntry<K, V>>discardingQueue();\n", "\n"], "10": ["      evictionQueue.add(entry);\n"], "11": ["      evictionQueue.add(entry);\n"], "12": ["        if (evictionQueue.contains(e)) {\n", "          evictionQueue.add(e);\n", "        }\n"], "13": ["    /**\n", "     * Performs eviction if the segment is full. This should only be called prior to adding a new\n", "     * entry and increasing {@code count}.\n", "     *\n", "     * @return {@code true} if eviction occurred\n", "     */\n", "    @GuardedBy(\"this\")\n", "    boolean evictEntries() {\n", "      if (map.evictsBySize() && count >= maxSegmentSize) {\n", "        drainRecencyQueue();\n", "\n", "        ReferenceEntry<K, V> e = evictionQueue.remove();\n", "        if (!removeEntry(e, e.getHash())) {\n", "          throw new AssertionError();\n", "        }\n", "        return true;\n", "      }\n", "      return false;\n", "    }\n", "\n"], "14": ["              } else if (evictEntries()) { // evictEntries after setting new value\n", "                newCount = this.count + 1;\n"], "15": ["        if (evictEntries()) { // evictEntries after setting new value\n", "          newCount = this.count + 1;\n", "        }\n"], "16": ["          evictionQueue.clear();\n"], "17": ["      evictionQueue.remove(entry);\n"], "18": ["      evictionQueue.remove(entry);\n"], "19": ["  /**\n", "   * A custom queue for managing eviction order. Note that this is tightly integrated with {@code\n", "   * ReferenceEntry}, upon which it relies to perform its linking.\n", "   *\n", "   * <p>Note that this entire implementation makes the assumption that all elements which are in\n", "   * the map are also in this queue, and that all elements not in the queue are not in the map.\n", "   *\n", "   * <p>The benefits of creating our own queue are that (1) we can replace elements in the middle\n", "   * of the queue as part of copyEvictableEntry, and (2) the contains method is highly optimized\n", "   * for the current model.\n", "   */\n", "  static final class EvictionQueue<K, V> extends AbstractQueue<ReferenceEntry<K, V>> {\n", "    final ReferenceEntry<K, V> head =\n", "        new AbstractReferenceEntry<K, V>() {\n", "\n", "          ReferenceEntry<K, V> nextEvictable = this;\n", "\n", "          @Override\n", "          public ReferenceEntry<K, V> getNextEvictable() {\n", "            return nextEvictable;\n", "          }\n", "\n", "          @Override\n", "          public void setNextEvictable(ReferenceEntry<K, V> next) {\n", "            this.nextEvictable = next;\n", "          }\n", "\n", "          ReferenceEntry<K, V> previousEvictable = this;\n", "\n", "          @Override\n", "          public ReferenceEntry<K, V> getPreviousEvictable() {\n", "            return previousEvictable;\n", "          }\n", "\n", "          @Override\n", "          public void setPreviousEvictable(ReferenceEntry<K, V> previous) {\n", "            this.previousEvictable = previous;\n", "          }\n", "        };\n", "\n", "    // implements Queue\n", "\n", "    @Override\n", "    public boolean offer(ReferenceEntry<K, V> entry) {\n", "      // unlink\n", "      connectEvictables(entry.getPreviousEvictable(), entry.getNextEvictable());\n", "\n", "      // add to tail\n", "      connectEvictables(head.getPreviousEvictable(), entry);\n", "      connectEvictables(entry, head);\n", "\n", "      return true;\n", "    }\n", "\n", "    @Override\n", "    public ReferenceEntry<K, V> peek() {\n", "      ReferenceEntry<K, V> next = head.getNextEvictable();\n", "      return (next == head) ? null : next;\n", "    }\n", "\n", "    @Override\n", "    public ReferenceEntry<K, V> poll() {\n", "      ReferenceEntry<K, V> next = head.getNextEvictable();\n", "      if (next == head) {\n", "        return null;\n", "      }\n", "\n", "      remove(next);\n", "      return next;\n", "    }\n", "\n", "    @CanIgnoreReturnValue\n", "    @Override\n", "    @SuppressWarnings(\"unchecked\")\n", "    public boolean remove(Object o) {\n", "      ReferenceEntry<K, V> e = (ReferenceEntry) o;\n", "      ReferenceEntry<K, V> previous = e.getPreviousEvictable();\n", "      ReferenceEntry<K, V> next = e.getNextEvictable();\n", "      connectEvictables(previous, next);\n", "      nullifyEvictable(e);\n", "\n", "      return next != NullEntry.INSTANCE;\n", "    }\n", "\n", "    @Override\n", "    @SuppressWarnings(\"unchecked\")\n", "    public boolean contains(Object o) {\n", "      ReferenceEntry<K, V> e = (ReferenceEntry) o;\n", "      return e.getNextEvictable() != NullEntry.INSTANCE;\n", "    }\n", "\n", "    @Override\n", "    public boolean isEmpty() {\n", "      return head.getNextEvictable() == head;\n", "    }\n", "\n", "    @Override\n", "    public int size() {\n", "      int size = 0;\n", "      for (ReferenceEntry<K, V> e = head.getNextEvictable(); e != head; e = e.getNextEvictable()) {\n", "        size++;\n", "      }\n", "      return size;\n", "    }\n", "\n", "    @Override\n", "    public void clear() {\n", "      ReferenceEntry<K, V> e = head.getNextEvictable();\n", "      while (e != head) {\n", "        ReferenceEntry<K, V> next = e.getNextEvictable();\n", "        nullifyEvictable(e);\n", "        e = next;\n", "      }\n", "\n", "      head.setNextEvictable(head);\n", "      head.setPreviousEvictable(head);\n", "    }\n", "\n", "    @Override\n", "    public Iterator<ReferenceEntry<K, V>> iterator() {\n", "      return new AbstractSequentialIterator<ReferenceEntry<K, V>>(peek()) {\n", "        @Override\n", "        protected ReferenceEntry<K, V> computeNext(ReferenceEntry<K, V> previous) {\n", "          ReferenceEntry<K, V> next = previous.getNextEvictable();\n", "          return (next == head) ? null : next;\n", "        }\n", "      };\n", "    }\n", "  }\n", "\n"], "20": ["        maximumSize,\n"], "21": ["    final int maximumSize;\n"], "22": ["        int maximumSize,\n"], "23": ["      this.maximumSize = maximumSize;\n"], "24": ["      if (maximumSize != MapMaker.UNSET_INT) {\n", "        mapMaker.maximumSize(maximumSize);\n", "      }\n"], "25": ["        int maximumSize,\n"], "26": ["          maximumSize,\n"]}, "added_lines": {"4": [193, 199, 202], "5": [221, 222], "7": [432, 433], "9": [2036]}, "removed_lines": {"1": [56], "2": [137, 138], "3": [169, 170, 171], "4": [196, 200, 204, 205, 206, 209, 210, 213, 214], "5": [233, 234, 235, 236, 237, 238, 239, 240, 241, 242, 243, 244, 245, 246, 250, 251, 252, 253], "6": [450, 451], "7": [462, 463, 464], "8": [2050, 2051, 2052, 2053, 2054, 2055, 2056], "9": [2074, 2078, 2079, 2080, 2081, 2082], "10": [2242], "11": [2257], "12": [2282, 2283, 2284], "13": [2329, 2330, 2331, 2332, 2333, 2334, 2335, 2336, 2337, 2338, 2339, 2340, 2341, 2342, 2343, 2344, 2345, 2346, 2347, 2348], "14": [2488, 2489], "15": [2513, 2514, 2515], "16": [2779], "17": [2805], "18": [2824], "19": [3021, 3022, 3023, 3024, 3025, 3026, 3027, 3028, 3029, 3030, 3031, 3032, 3033, 3034, 3035, 3036, 3037, 3038, 3039, 3040, 3041, 3042, 3043, 3044, 3045, 3046, 3047, 3048, 3049, 3050, 3051, 3052, 3053, 3054, 3055, 3056, 3057, 3058, 3059, 3060, 3061, 3062, 3063, 3064, 3065, 3066, 3067, 3068, 3069, 3070, 3071, 3072, 3073, 3074, 3075, 3076, 3077, 3078, 3079, 3080, 3081, 3082, 3083, 3084, 3085, 3086, 3087, 3088, 3089, 3090, 3091, 3092, 3093, 3094, 3095, 3096, 3097, 3098, 3099, 3100, 3101, 3102, 3103, 3104, 3105, 3106, 3107, 3108, 3109, 3110, 3111, 3112, 3113, 3114, 3115, 3116, 3117, 3118, 3119, 3120, 3121, 3122, 3123, 3124, 3125, 3126, 3127, 3128, 3129, 3130, 3131, 3132, 3133, 3134, 3135, 3136, 3137, 3138, 3139, 3140, 3141, 3142, 3143, 3144, 3145, 3146, 3147, 3148, 3149, 3150], "20": [3862], "21": [3881], "22": [3893], "23": [3902], "24": [3937, 3938, 3939], "25": [3970], "26": [3980]}}]}
