{
    "addition": {
        "193": "    entryFactory = EntryFactory.getFactory(keyStrength, expires());\n",
        "199": "    // (segmentCount > concurrencyLevel)\n",
        "202": "    while (segmentCount < concurrencyLevel) {\n",
        "221": "    for (int i = 0; i < this.segments.length; ++i) {\n",
        "222": "      this.segments[i] = createSegment(segmentSize, MapMaker.UNSET_INT);\n",
        "432": "    static EntryFactory getFactory(Strength keyStrength, boolean expireAfterWrite) {\n",
        "433": "      int flags = (expireAfterWrite ? EXPIRABLE_MASK : 0) | 0;\n",
        "2036": "          (map.expiresAfterAccess())\n"
    },
    "removed": {
        "56": "import java.util.logging.Logger;\n",
        "137": "  private static final Logger logger = Logger.getLogger(MapMakerInternalMap.class.getName());\n",
        "138": "\n",
        "169": "  /** The maximum size of this map. MapMaker.UNSET_INT if there is no maximum. */\n",
        "170": "  final int maximumSize;\n",
        "171": "\n",
        "196": "    maximumSize = builder.maximumSize;\n",
        "200": "    entryFactory = EntryFactory.getFactory(keyStrength, expires(), evictsBySize());\n",
        "204": "    if (evictsBySize()) {\n",
        "205": "      initialCapacity = Math.min(initialCapacity, maximumSize);\n",
        "206": "    }\n",
        "209": "    // (segmentCount <= maximumSize)\n",
        "210": "    // && (concurrencyLevel > maximumSize || segmentCount > concurrencyLevel)\n",
        "213": "    while (segmentCount < concurrencyLevel\n",
        "214": "        && (!evictsBySize() || segmentCount * 2 <= maximumSize)) {\n",
        "233": "    if (evictsBySize()) {\n",
        "234": "      // Ensure sum of segment max sizes = overall max size\n",
        "235": "      int maximumSegmentSize = maximumSize / segmentCount + 1;\n",
        "236": "      int remainder = maximumSize % segmentCount;\n",
        "237": "      for (int i = 0; i < this.segments.length; ++i) {\n",
        "238": "        if (i == remainder) {\n",
        "239": "          maximumSegmentSize--;\n",
        "240": "        }\n",
        "241": "        this.segments[i] = createSegment(segmentSize, maximumSegmentSize);\n",
        "242": "      }\n",
        "243": "    } else {\n",
        "244": "      for (int i = 0; i < this.segments.length; ++i) {\n",
        "245": "        this.segments[i] = createSegment(segmentSize, MapMaker.UNSET_INT);\n",
        "246": "      }\n",
        "250": "  boolean evictsBySize() {\n",
        "251": "    return maximumSize != MapMaker.UNSET_INT;\n",
        "252": "  }\n",
        "253": "\n",
        "450": "    static final int EVICTABLE_MASK = 2;\n",
        "451": "\n",
        "462": "    static EntryFactory getFactory(\n",
        "463": "        Strength keyStrength, boolean expireAfterWrite, boolean evictsBySize) {\n",
        "464": "      int flags = (expireAfterWrite ? EXPIRABLE_MASK : 0) | (evictsBySize ? EVICTABLE_MASK : 0);\n",
        "2050": "    /**\n",
        "2051": "     * A queue of elements currently in the map, ordered by access time. Elements are added to the\n",
        "2052": "     * tail of the queue on access/write.\n",
        "2053": "     */\n",
        "2054": "    @GuardedBy(\"this\")\n",
        "2055": "    final Queue<ReferenceEntry<K, V>> evictionQueue;\n",
        "2056": "\n",
        "2074": "          (map.evictsBySize() || map.expiresAfterAccess())\n",
        "2078": "      evictionQueue =\n",
        "2079": "          map.evictsBySize()\n",
        "2080": "              ? new EvictionQueue<K, V>()\n",
        "2081": "              : MapMakerInternalMap.<ReferenceEntry<K, V>>discardingQueue();\n",
        "2082": "\n",
        "2242": "      evictionQueue.add(entry);\n",
        "2257": "      evictionQueue.add(entry);\n",
        "2282": "        if (evictionQueue.contains(e)) {\n",
        "2283": "          evictionQueue.add(e);\n",
        "2284": "        }\n",
        "2329": "    /**\n",
        "2330": "     * Performs eviction if the segment is full. This should only be called prior to adding a new\n",
        "2331": "     * entry and increasing {@code count}.\n",
        "2332": "     *\n",
        "2333": "     * @return {@code true} if eviction occurred\n",
        "2334": "     */\n",
        "2335": "    @GuardedBy(\"this\")\n",
        "2336": "    boolean evictEntries() {\n",
        "2337": "      if (map.evictsBySize() && count >= maxSegmentSize) {\n",
        "2338": "        drainRecencyQueue();\n",
        "2339": "\n",
        "2340": "        ReferenceEntry<K, V> e = evictionQueue.remove();\n",
        "2341": "        if (!removeEntry(e, e.getHash())) {\n",
        "2342": "          throw new AssertionError();\n",
        "2343": "        }\n",
        "2344": "        return true;\n",
        "2345": "      }\n",
        "2346": "      return false;\n",
        "2347": "    }\n",
        "2348": "\n",
        "2488": "              } else if (evictEntries()) { // evictEntries after setting new value\n",
        "2489": "                newCount = this.count + 1;\n",
        "2513": "        if (evictEntries()) { // evictEntries after setting new value\n",
        "2514": "          newCount = this.count + 1;\n",
        "2515": "        }\n",
        "2779": "          evictionQueue.clear();\n",
        "2805": "      evictionQueue.remove(entry);\n",
        "2824": "      evictionQueue.remove(entry);\n",
        "3021": "  /**\n",
        "3022": "   * A custom queue for managing eviction order. Note that this is tightly integrated with {@code\n",
        "3023": "   * ReferenceEntry}, upon which it relies to perform its linking.\n",
        "3024": "   *\n",
        "3025": "   * <p>Note that this entire implementation makes the assumption that all elements which are in\n",
        "3026": "   * the map are also in this queue, and that all elements not in the queue are not in the map.\n",
        "3027": "   *\n",
        "3028": "   * <p>The benefits of creating our own queue are that (1) we can replace elements in the middle\n",
        "3029": "   * of the queue as part of copyEvictableEntry, and (2) the contains method is highly optimized\n",
        "3030": "   * for the current model.\n",
        "3031": "   */\n",
        "3032": "  static final class EvictionQueue<K, V> extends AbstractQueue<ReferenceEntry<K, V>> {\n",
        "3033": "    final ReferenceEntry<K, V> head =\n",
        "3034": "        new AbstractReferenceEntry<K, V>() {\n",
        "3035": "\n",
        "3036": "          ReferenceEntry<K, V> nextEvictable = this;\n",
        "3037": "\n",
        "3038": "          @Override\n",
        "3039": "          public ReferenceEntry<K, V> getNextEvictable() {\n",
        "3040": "            return nextEvictable;\n",
        "3041": "          }\n",
        "3042": "\n",
        "3043": "          @Override\n",
        "3044": "          public void setNextEvictable(ReferenceEntry<K, V> next) {\n",
        "3045": "            this.nextEvictable = next;\n",
        "3046": "          }\n",
        "3047": "\n",
        "3048": "          ReferenceEntry<K, V> previousEvictable = this;\n",
        "3049": "\n",
        "3050": "          @Override\n",
        "3051": "          public ReferenceEntry<K, V> getPreviousEvictable() {\n",
        "3052": "            return previousEvictable;\n",
        "3053": "          }\n",
        "3054": "\n",
        "3055": "          @Override\n",
        "3056": "          public void setPreviousEvictable(ReferenceEntry<K, V> previous) {\n",
        "3057": "            this.previousEvictable = previous;\n",
        "3058": "          }\n",
        "3059": "        };\n",
        "3060": "\n",
        "3061": "    // implements Queue\n",
        "3062": "\n",
        "3063": "    @Override\n",
        "3064": "    public boolean offer(ReferenceEntry<K, V> entry) {\n",
        "3065": "      // unlink\n",
        "3066": "      connectEvictables(entry.getPreviousEvictable(), entry.getNextEvictable());\n",
        "3067": "\n",
        "3068": "      // add to tail\n",
        "3069": "      connectEvictables(head.getPreviousEvictable(), entry);\n",
        "3070": "      connectEvictables(entry, head);\n",
        "3071": "\n",
        "3072": "      return true;\n",
        "3073": "    }\n",
        "3074": "\n",
        "3075": "    @Override\n",
        "3076": "    public ReferenceEntry<K, V> peek() {\n",
        "3077": "      ReferenceEntry<K, V> next = head.getNextEvictable();\n",
        "3078": "      return (next == head) ? null : next;\n",
        "3079": "    }\n",
        "3080": "\n",
        "3081": "    @Override\n",
        "3082": "    public ReferenceEntry<K, V> poll() {\n",
        "3083": "      ReferenceEntry<K, V> next = head.getNextEvictable();\n",
        "3084": "      if (next == head) {\n",
        "3085": "        return null;\n",
        "3086": "      }\n",
        "3087": "\n",
        "3088": "      remove(next);\n",
        "3089": "      return next;\n",
        "3090": "    }\n",
        "3091": "\n",
        "3092": "    @CanIgnoreReturnValue\n",
        "3093": "    @Override\n",
        "3094": "    @SuppressWarnings(\"unchecked\")\n",
        "3095": "    public boolean remove(Object o) {\n",
        "3096": "      ReferenceEntry<K, V> e = (ReferenceEntry) o;\n",
        "3097": "      ReferenceEntry<K, V> previous = e.getPreviousEvictable();\n",
        "3098": "      ReferenceEntry<K, V> next = e.getNextEvictable();\n",
        "3099": "      connectEvictables(previous, next);\n",
        "3100": "      nullifyEvictable(e);\n",
        "3101": "\n",
        "3102": "      return next != NullEntry.INSTANCE;\n",
        "3103": "    }\n",
        "3104": "\n",
        "3105": "    @Override\n",
        "3106": "    @SuppressWarnings(\"unchecked\")\n",
        "3107": "    public boolean contains(Object o) {\n",
        "3108": "      ReferenceEntry<K, V> e = (ReferenceEntry) o;\n",
        "3109": "      return e.getNextEvictable() != NullEntry.INSTANCE;\n",
        "3110": "    }\n",
        "3111": "\n",
        "3112": "    @Override\n",
        "3113": "    public boolean isEmpty() {\n",
        "3114": "      return head.getNextEvictable() == head;\n",
        "3115": "    }\n",
        "3116": "\n",
        "3117": "    @Override\n",
        "3118": "    public int size() {\n",
        "3119": "      int size = 0;\n",
        "3120": "      for (ReferenceEntry<K, V> e = head.getNextEvictable(); e != head; e = e.getNextEvictable()) {\n",
        "3121": "        size++;\n",
        "3122": "      }\n",
        "3123": "      return size;\n",
        "3124": "    }\n",
        "3125": "\n",
        "3126": "    @Override\n",
        "3127": "    public void clear() {\n",
        "3128": "      ReferenceEntry<K, V> e = head.getNextEvictable();\n",
        "3129": "      while (e != head) {\n",
        "3130": "        ReferenceEntry<K, V> next = e.getNextEvictable();\n",
        "3131": "        nullifyEvictable(e);\n",
        "3132": "        e = next;\n",
        "3133": "      }\n",
        "3134": "\n",
        "3135": "      head.setNextEvictable(head);\n",
        "3136": "      head.setPreviousEvictable(head);\n",
        "3137": "    }\n",
        "3138": "\n",
        "3139": "    @Override\n",
        "3140": "    public Iterator<ReferenceEntry<K, V>> iterator() {\n",
        "3141": "      return new AbstractSequentialIterator<ReferenceEntry<K, V>>(peek()) {\n",
        "3142": "        @Override\n",
        "3143": "        protected ReferenceEntry<K, V> computeNext(ReferenceEntry<K, V> previous) {\n",
        "3144": "          ReferenceEntry<K, V> next = previous.getNextEvictable();\n",
        "3145": "          return (next == head) ? null : next;\n",
        "3146": "        }\n",
        "3147": "      };\n",
        "3148": "    }\n",
        "3149": "  }\n",
        "3150": "\n",
        "3862": "        maximumSize,\n",
        "3881": "    final int maximumSize;\n",
        "3893": "        int maximumSize,\n",
        "3902": "      this.maximumSize = maximumSize;\n",
        "3937": "      if (maximumSize != MapMaker.UNSET_INT) {\n",
        "3938": "        mapMaker.maximumSize(maximumSize);\n",
        "3939": "      }\n",
        "3970": "        int maximumSize,\n",
        "3980": "          maximumSize,\n"
    }
}