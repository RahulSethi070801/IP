{
    "addition": {
        "199": "    MapMakerInternalMap<Object, Object> map =\n",
        "200": "        makeMap(\n",
        "201": "            createMapMaker().concurrencyLevel(concurrencyLevel).initialCapacity(initialCapacity));\n",
        "1161": "    if (map.expiresAfterAccess()) {\n",
        "1356": "   * Returns an iterable containing all combinations of expireAfterAccess/Write.\n",
        "1359": "    return ImmutableList.of(\n",
        "1362": "        createMapMaker().expireAfterAccess(SMALL_MAX_SIZE, TimeUnit.SECONDS),\n",
        "1363": "        createMapMaker().expireAfterWrite(SMALL_MAX_SIZE, TimeUnit.SECONDS));\n"
    },
    "removed": {
        "41": "import java.util.LinkedHashMap;\n",
        "55": "  private static <K, V> MapMakerInternalMap<K, V> makeMap(GenericMapMaker<K, V> maker) {\n",
        "56": "    return new MapMakerInternalMap<K, V>((MapMaker) maker);\n",
        "57": "  }\n",
        "58": "\n",
        "81": "    assertEquals(MapMaker.UNSET_INT, map.maximumSize);\n",
        "93": "    assertFalse(map.evictsBySize());\n",
        "206": "    MapMakerInternalMap<Object, Object> map = makeMap(createMapMaker()\n",
        "207": "        .concurrencyLevel(concurrencyLevel)\n",
        "208": "        .initialCapacity(initialCapacity)\n",
        "209": "        .maximumSize(maxSize));\n",
        "308": "      if (map.evictsBySize()) {\n",
        "309": "        MapMakerInternalMap.connectEvictables(entryOne, entryTwo);\n",
        "310": "      }\n",
        "334": "    if (map.evictsBySize()) {\n",
        "335": "      assertSame(two, one.getNextEvictable());\n",
        "336": "    }\n",
        "580": "  public void testSegmentPut_evict() {\n",
        "581": "    int maxSize = 10;\n",
        "582": "    MapMakerInternalMap<Object, Object> map =\n",
        "583": "        makeMap(createMapMaker().concurrencyLevel(1).maximumSize(maxSize));\n",
        "584": "\n",
        "585": "    // manually add elements to avoid eviction\n",
        "586": "    int originalCount = 1024;\n",
        "587": "    LinkedHashMap<Object, Object> originalMap = Maps.newLinkedHashMap();\n",
        "588": "    for (int i = 0; i < originalCount; i++) {\n",
        "589": "      Object key = new Object();\n",
        "590": "      Object value = new Object();\n",
        "591": "      map.put(key, value);\n",
        "592": "      originalMap.put(key, value);\n",
        "593": "      if (i >= maxSize) {\n",
        "594": "        Iterator<Object> it = originalMap.keySet().iterator();\n",
        "595": "        it.next();\n",
        "596": "        it.remove();\n",
        "597": "      }\n",
        "598": "      assertEquals(originalMap, map);\n",
        "599": "    }\n",
        "600": "  }\n",
        "601": "\n",
        "728": "                .maximumSize(SMALL_MAX_SIZE)\n",
        "760": "    assertFalse(segment.evictionQueue.contains(entryOne));\n",
        "873": "        .maximumSize(SMALL_MAX_SIZE)\n",
        "889": "    assertSame(entry, segment.evictionQueue.peek());\n",
        "894": "    assertTrue(segment.evictionQueue.isEmpty());\n",
        "906": "                .maximumSize(SMALL_MAX_SIZE)\n",
        "925": "    assertFalse(segment.evictionQueue.contains(entry));\n",
        "937": "                .maximumSize(SMALL_MAX_SIZE)\n",
        "958": "    assertFalse(segment.evictionQueue.contains(entry));\n",
        "977": "                .maximumSize(SMALL_MAX_SIZE)\n",
        "999": "    assertFalse(segment.evictionQueue.contains(entry));\n",
        "1208": "    if (map.evictsBySize() || map.expiresAfterAccess()) {\n",
        "1217": "    if (map.evictsBySize()) {\n",
        "1218": "      assertSameEntries(readOrder, ImmutableList.copyOf(segment.evictionQueue));\n",
        "1219": "    }\n",
        "1262": "  public void testEvictEntries() {\n",
        "1263": "    int maxSize = 10;\n",
        "1264": "    MapMakerInternalMap<Object, Object> map =\n",
        "1265": "        makeMap(createMapMaker().concurrencyLevel(1).maximumSize(maxSize));\n",
        "1266": "    Segment<Object, Object> segment = map.segments[0];\n",
        "1267": "\n",
        "1268": "    // manually add elements to avoid eviction\n",
        "1269": "    int originalCount = 1024;\n",
        "1270": "    ReferenceEntry<Object, Object> entry = null;\n",
        "1271": "    LinkedHashMap<Object, Object> originalMap = Maps.newLinkedHashMap();\n",
        "1272": "    for (int i = 0; i < originalCount; i++) {\n",
        "1273": "      Object key = new Object();\n",
        "1274": "      Object value = new Object();\n",
        "1275": "      AtomicReferenceArray<ReferenceEntry<Object, Object>> table = segment.table;\n",
        "1276": "      int hash = map.hash(key);\n",
        "1277": "      int index = hash & (table.length() - 1);\n",
        "1278": "      ReferenceEntry<Object, Object> first = table.get(index);\n",
        "1279": "      entry = map.newEntry(key, hash, first);\n",
        "1280": "      ValueReference<Object, Object> valueRef = map.newValueReference(entry, value);\n",
        "1281": "      entry.setValueReference(valueRef);\n",
        "1282": "      segment.recordWrite(entry);\n",
        "1283": "      table.set(index, entry);\n",
        "1284": "      originalMap.put(key, value);\n",
        "1285": "    }\n",
        "1286": "    segment.count = originalCount;\n",
        "1287": "    assertEquals(originalCount, originalMap.size());\n",
        "1288": "    assertEquals(originalMap, map);\n",
        "1289": "\n",
        "1290": "    for (int i = maxSize - 1; i < originalCount; i++) {\n",
        "1291": "      assertTrue(segment.evictEntries());\n",
        "1292": "      Iterator<Object> it = originalMap.keySet().iterator();\n",
        "1293": "      it.next();\n",
        "1294": "      it.remove();\n",
        "1295": "      assertEquals(originalMap, map);\n",
        "1296": "    }\n",
        "1297": "    assertFalse(segment.evictEntries());\n",
        "1298": "  }\n",
        "1299": "\n",
        "1434": "    for (MapMaker maker : allKeyValueStrengthMakers()) {\n",
        "1435": "      result.add(maker.maximumSize(SMALL_MAX_SIZE));\n",
        "1436": "    }\n",
        "1443": "    for (MapMaker maker : allKeyValueStrengthMakers()) {\n",
        "1444": "      result.add(maker.maximumSize(SMALL_MAX_SIZE).expireAfterAccess(99999, SECONDS));\n",
        "1445": "    }\n",
        "1446": "    for (MapMaker maker : allKeyValueStrengthMakers()) {\n",
        "1447": "      result.add(maker.maximumSize(SMALL_MAX_SIZE).expireAfterWrite(99999, SECONDS));\n",
        "1448": "    }\n",
        "1453": "   * Returns an iterable containing all combinations of maximumSize and expireAfterAccess/Write.\n",
        "1456": "    return ImmutableList.of(createMapMaker().maximumSize(SMALL_MAX_SIZE),\n",
        "1459": "        createMapMaker()\n",
        "1460": "            .maximumSize(SMALL_MAX_SIZE)\n",
        "1461": "            .expireAfterAccess(SMALL_MAX_SIZE, TimeUnit.SECONDS),\n",
        "1462": "        createMapMaker()\n",
        "1463": "            .maximumSize(SMALL_MAX_SIZE)\n",
        "1464": "            .expireAfterWrite(SMALL_MAX_SIZE, TimeUnit.SECONDS));\n"
    }
}