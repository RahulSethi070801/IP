{"id": "f206690a68af12667fea42eb6df515c98dedf575", "code": [{"0": "guava-gwt/src-super/com/google/common/collect/super/com/google/common/collect/MapMaker.java", "added": {"2": ["  private static class ComputingMap<K, V> extends LinkedHashMap<K, V>\n", "    ComputingMap(int initialCapacity) {\n", "      this(null, initialCapacity);\n", "    ComputingMap(Function<? super K, ? extends V> computer, int initialCapacity) {\n"], "6": ["        ? new ComputingMap<K, V>(null, initialCapacity)\n", "    return new ComputingMap<K, V>(computer, initialCapacity);\n"]}, "removed": {"1": ["import jsinterop.annotations.JsFunction;\n", "import jsinterop.annotations.JsMethod;\n", "import jsinterop.annotations.JsPackage;\n", "\n", "import java.util.concurrent.TimeUnit;\n"], "2": ["  private static class ExpiringComputingMap<K, V> extends LinkedHashMap<K, V>\n", "    private final long expirationMillis;\n", "    ExpiringComputingMap(long expirationMillis, int initialCapacity) {\n", "      this(expirationMillis, null, initialCapacity);\n", "    ExpiringComputingMap(\n", "        long expirationMillis, Function<? super K, ? extends V> computer, int initialCapacity) {\n", "      this.expirationMillis = expirationMillis;\n", "    @Override\n", "    public V put(K key, V value) {\n", "      V result = super.put(key, value);\n", "      if (expirationMillis > 0) {\n", "        scheduleRemoval(key, value);\n", "      }\n", "      return result;\n", "    }\n", "\n"], "3": ["    private void scheduleRemoval(final K key, final V value) {\n", "      // from MapMaker\n", "      /*\n", "       * TODO: Keep weak reference to map, too. Build a priority queue out of the entries themselves\n", "       * instead of creating a task per entry. Then, we could have one recurring task per map (which\n", "       * would clean the entire map and then reschedule itself depending upon when the next\n", "       * expiration comes). We also want to avoid removing an entry prematurely if the entry was set\n", "       * to the same value again.\n", "       */\n", "      setTimeout(new Callback() {\n", "        @Override\n", "        public void run() {\n", "          remove(key, value);\n", "        }\n", "      }, (int) expirationMillis);\n", "    }\n", "\n", "    @JsFunction\n", "    private interface Callback {\n", "      void run();\n", "    }\n", "\n", "    // TODO(user): Move this logic to a common location.\n", "    @JsMethod(name = \"setTimeout\", namespace = JsPackage.GLOBAL)\n", "    private static native void setTimeout(Callback callback, int delayInMs);\n", "\n"], "4": ["  private long expirationMillis = 0;\n"], "5": ["  @Override\n", "  MapMaker expireAfterWrite(long duration, TimeUnit unit) {\n", "    if (expirationMillis != 0) {\n", "      throw new IllegalStateException(\n", "          \"expiration time of \" + expirationMillis + \" ns was already set\");\n", "    }\n", "    if (duration <= 0) {\n", "      throw new IllegalArgumentException(\"invalid duration: \" + duration);\n", "    }\n", "    this.expirationMillis = unit.toMillis(duration);\n", "    useCustomMap = true;\n", "    return this;\n", "  }\n", "\n"], "6": ["        ? new ExpiringComputingMap<K, V>(expirationMillis, null, initialCapacity)\n", "    return new ExpiringComputingMap<K, V>(expirationMillis, computer, initialCapacity);\n"]}, "added_lines": {"2": [36, 40, 41, 44], "6": [147, 153]}, "removed_lines": {"1": [21, 22, 23, 24, 28], "2": [41, 43, 46, 47, 50, 51, 53, 57, 58, 59, 60, 61, 62, 63, 64, 65], "3": [98, 99, 100, 101, 102, 103, 104, 105, 106, 107, 108, 109, 110, 111, 112, 113, 114, 115, 116, 117, 118, 119, 120, 121, 122, 123], "4": [164], "5": [178, 179, 180, 181, 182, 183, 184, 185, 186, 187, 188, 189, 190, 191], "6": [205, 211]}}, {"1": "guava-gwt/test/com/google/common/collect/MapMakerTest_gwt.java", "added": {}, "removed": {"1": ["public void testExpiration_setTwice__MakerTest() throws Exception {\n", "  com.google.common.collect.MapMakerTest.MakerTest testCase = new com.google.common.collect.MapMakerTest.MakerTest();\n", "  testCase.testExpiration_setTwice();\n", "}\n", "\n"]}, "added_lines": {}, "removed_lines": {"1": [36, 37, 38, 39, 40]}}, {"2": "guava-tests/test/com/google/common/collect/ComputingConcurrentHashMapTest.java", "added": {}, "removed": {"1": ["import static com.google.common.collect.MapMakerInternalMapTest.SMALL_MAX_SIZE;\n", "import static com.google.common.collect.MapMakerInternalMapTest.allEvictingMakers;\n", "import static com.google.common.collect.MapMakerInternalMapTest.checkEvictionQueues;\n", "import static com.google.common.collect.MapMakerInternalMapTest.checkExpirationTimes;\n", "\n"], "2": ["import java.util.Iterator;\n", "import java.util.List;\n", "import java.util.Random;\n", "import java.util.concurrent.TimeUnit;\n"], "3": ["  public void testRecordReadOnCompute() throws ExecutionException {\n", "    CountingFunction computingFunction = new CountingFunction();\n", "    for (MapMaker maker : allEvictingMakers()) {\n", "      ComputingConcurrentHashMap<Object, Object> map =\n", "          makeComputingMap(maker.concurrencyLevel(1), computingFunction);\n", "      Segment<Object, Object> segment = map.segments[0];\n", "      List<ReferenceEntry<Object, Object>> writeOrder = Lists.newLinkedList();\n", "      List<ReferenceEntry<Object, Object>> readOrder = Lists.newLinkedList();\n", "      for (int i = 0; i < SMALL_MAX_SIZE; i++) {\n", "        Object key = new Object();\n", "        int hash = map.hash(key);\n", "\n", "        map.getOrCompute(key);\n", "        ReferenceEntry<Object, Object> entry = segment.getEntry(key, hash);\n", "        writeOrder.add(entry);\n", "        readOrder.add(entry);\n", "      }\n", "\n", "      checkEvictionQueues(map, segment, readOrder, writeOrder);\n", "      checkExpirationTimes(map);\n", "\n", "      // access some of the elements\n", "      Random random = new Random();\n", "      List<ReferenceEntry<Object, Object>> reads = Lists.newArrayList();\n", "      Iterator<ReferenceEntry<Object, Object>> i = readOrder.iterator();\n", "      while (i.hasNext()) {\n", "        ReferenceEntry<Object, Object> entry = i.next();\n", "        if (random.nextBoolean()) {\n", "          map.getOrCompute(entry.getKey());\n", "          reads.add(entry);\n", "          i.remove();\n", "        }\n", "      }\n", "      readOrder.addAll(reads);\n", "\n", "      checkEvictionQueues(map, segment, readOrder, writeOrder);\n", "      checkExpirationTimes(map);\n", "    }\n", "  }\n", "\n"], "4": ["  @AndroidIncompatible // Perhaps emulator clock does not update between the two get() calls?\n", "  @SuppressWarnings(\"deprecation\") // test of deprecated method\n", "  public void testComputeExpiredEntry() throws ExecutionException {\n", "    MapMaker maker = createMapMaker().expireAfterWrite(1, TimeUnit.NANOSECONDS);\n", "    CountingFunction computingFunction = new CountingFunction();\n", "    ComputingConcurrentHashMap<Object, Object> map = makeComputingMap(maker, computingFunction);\n", "    assertEquals(0, computingFunction.getCount());\n", "\n", "    Object key = new Object();\n", "    Object one = map.getOrCompute(key);\n", "    assertEquals(1, computingFunction.getCount());\n", "\n", "    Object two = map.getOrCompute(key);\n", "    assertNotSame(one, two);\n", "    assertEquals(2, computingFunction.getCount());\n", "  }\n", "\n"]}, "added_lines": {}, "removed_lines": {"1": [19, 20, 21, 22, 23], "2": [35, 36, 37, 40], "3": [100, 101, 102, 103, 104, 105, 106, 107, 108, 109, 110, 111, 112, 113, 114, 115, 116, 117, 118, 119, 120, 121, 122, 123, 124, 125, 126, 127, 128, 129, 130, 131, 132, 133, 134, 135, 136, 137, 138, 139], "4": [212, 213, 214, 215, 216, 217, 218, 219, 220, 221, 222, 223, 224, 225, 226, 227, 228]}}, {"3": "guava-tests/test/com/google/common/collect/ConcurrentHashMultisetTest.java", "added": {"2": ["    MapMaker mapMaker = new MapMaker();\n"]}, "removed": {"1": ["import java.util.concurrent.TimeUnit;\n"], "2": ["    MapMaker mapMaker = new MapMaker().expireAfterWrite(1, TimeUnit.SECONDS);\n"], "3": ["//  @Suppress(owner = \"bmanes\", detail = \"Does not call the eviction listener\")\n", "//  public void testWithMapMakerEvictionListener_BROKEN1()\n", "//      throws InterruptedException {\n", "//    MapEvictionListener<String, Number> evictionListener =\n", "//        mockEvictionListener();\n", "//    evictionListener.onEviction(\"a\", 5);\n", "//    EasyMock.replay(evictionListener);\n", "//\n", "//    GenericMapMaker<String, Number> mapMaker = new MapMaker()\n", "//        .expireAfterWrite(100, TimeUnit.MILLISECONDS)\n", "//        .evictionListener(evictionListener);\n", "//\n", "//    ConcurrentHashMultiset<String> multiset =\n", "//        ConcurrentHashMultiset.create(mapMaker);\n", "//\n", "//    multiset.add(\"a\", 5);\n", "//\n", "//    assertTrue(multiset.contains(\"a\"));\n", "//    assertEquals(5, multiset.count(\"a\"));\n", "//\n", "//    Thread.sleep(2000);\n", "//\n", "//    EasyMock.verify(evictionListener);\n", "//  }\n", "\n", "//  @Suppress(owner = \"bmanes\", detail = \"Does not call the eviction listener\")\n", "//  public void testWithMapMakerEvictionListener_BROKEN2()\n", "//      throws InterruptedException {\n", "//    MapEvictionListener<String, Number> evictionListener =\n", "//        mockEvictionListener();\n", "//    evictionListener.onEviction(\"a\", 5);\n", "//    EasyMock.replay(evictionListener);\n", "//\n", "//    GenericMapMaker<String, Number> mapMaker = new MapMaker()\n", "//        .expireAfterWrite(100, TimeUnit.MILLISECONDS)\n", "//        .evictionListener(evictionListener);\n", "//\n", "//    ConcurrentHashMultiset<String> multiset =\n", "//        ConcurrentHashMultiset.create(mapMaker);\n", "//\n", "//    multiset.add(\"a\", 5);\n", "//\n", "//    assertTrue(multiset.contains(\"a\"));\n", "//    assertEquals(5, multiset.count(\"a\"));\n", "//\n", "//    Thread.sleep(2000);\n", "//\n", "//    // This call should have the side-effect of calling the\n", "//    // eviction listener, but it does not.\n", "//    assertFalse(multiset.contains(\"a\"));\n", "//\n", "//    EasyMock.verify(evictionListener);\n", "//  }\n", "\n"]}, "added_lines": {"2": [451]}, "removed_lines": {"1": [44], "2": [452], "3": [478, 479, 480, 481, 482, 483, 484, 485, 486, 487, 488, 489, 490, 491, 492, 493, 494, 495, 496, 497, 498, 499, 500, 501, 502, 503, 504, 505, 506, 507, 508, 509, 510, 511, 512, 513, 514, 515, 516, 517, 518, 519, 520, 521, 522, 523, 524, 525, 526, 527, 528, 529, 530, 531]}}, {"4": "guava-tests/test/com/google/common/collect/MapMakerInternalMapTest.java", "added": {"5": ["    for (MapMaker maker : allKeyValueStrengthMakers()) {\n"], "6": ["    for (MapMaker maker : allKeyValueStrengthMakers()) {\n"], "9": ["    MapMakerInternalMap<Object, Object> map =\n", "        makeMap(createMapMaker().concurrencyLevel(1).initialCapacity(1));\n"], "10": ["\n", "        makeMap(createMapMaker().concurrencyLevel(1).initialCapacity(1));\n"], "11": ["        makeMap(createMapMaker().concurrencyLevel(1).initialCapacity(1));\n"]}, "removed": {"1": ["import static com.google.common.collect.Lists.newArrayList;\n", "import static java.util.concurrent.TimeUnit.SECONDS;\n", "import com.google.common.base.Ticker;\n"], "2": ["import java.util.Iterator;\n", "import java.util.List;\n", "import java.util.Random;\n", "import java.util.concurrent.TimeUnit;\n"], "3": ["    assertEquals(0, map.expireAfterWriteNanos);\n", "\n", "    assertSame(Ticker.systemTicker(), map.ticker);\n"], "4": ["\n", "    assertFalse(map.expires());\n"], "5": ["  public void testSetExpireAfterWrite() {\n", "    long duration = 42;\n", "    TimeUnit unit = SECONDS;\n", "    MapMakerInternalMap<Object, Object> map =\n", "        makeMap(createMapMaker().expireAfterWrite(duration, unit));\n", "    assertEquals(unit.toNanos(duration), map.expireAfterWriteNanos);\n", "  }\n", "\n", "    for (MapMaker maker : allEntryTypeMakers()) {\n"], "6": ["    for (MapMaker maker : allEntryTypeMakers()) {\n"], "7": ["      if (map.expires()) {\n", "        MapMakerInternalMap.connectExpirables(entryOne, entryTwo);\n", "      }\n", "      assertConnected(map, entryOne, entryTwo);\n", "      assertConnected(map, copyOne, entryTwo);\n", "      assertConnected(map, copyOne, copyTwo);\n", "    }\n", "  }\n", "\n", "  private static <K, V> void assertConnected(\n", "      MapMakerInternalMap<K, V> map, ReferenceEntry<K, V> one, ReferenceEntry<K, V> two) {\n", "    if (map.expires()) {\n", "      assertSame(two, one.getNextExpirable());\n"], "8": ["  public void testReclaimKey() {\n", "    MapMakerInternalMap<Object, Object> map =\n", "        makeMap(\n", "            createMapMaker()\n", "                .concurrencyLevel(1)\n", "                .initialCapacity(1)\n", "                .expireAfterWrite(99999, SECONDS));\n", "    Segment<Object, Object> segment = map.segments[0];\n", "    AtomicReferenceArray<ReferenceEntry<Object, Object>> table = segment.table;\n", "    assertEquals(1, table.length());\n", "\n", "    // create 3 objects and chain them together\n", "    Object keyOne = new Object();\n", "    Object valueOne = new Object();\n", "    int hashOne = map.hash(keyOne);\n", "    DummyEntry<Object, Object> entryOne = createDummyEntry(keyOne, hashOne, valueOne, null);\n", "    Object keyTwo = new Object();\n", "    Object valueTwo = new Object();\n", "    int hashTwo = map.hash(keyTwo);\n", "    DummyEntry<Object, Object> entryTwo = createDummyEntry(keyTwo, hashTwo, valueTwo, entryOne);\n", "    Object keyThree = new Object();\n", "    Object valueThree = new Object();\n", "    int hashThree = map.hash(keyThree);\n", "    DummyEntry<Object, Object> entryThree =\n", "        createDummyEntry(keyThree, hashThree, valueThree, entryTwo);\n", "\n", "    // absent\n", "    assertFalse(segment.reclaimKey(entryOne, hashOne));\n", "    table.set(0, entryOne);\n", "    assertFalse(segment.reclaimKey(entryTwo, hashTwo));\n", "    table.set(0, entryTwo);\n", "    assertFalse(segment.reclaimKey(entryThree, hashThree));\n", "\n", "    // present\n", "    table.set(0, entryOne);\n", "    segment.count = 1;\n", "    assertTrue(segment.reclaimKey(entryOne, hashOne));\n", "    assertFalse(segment.expirationQueue.contains(entryOne));\n", "    assertEquals(0, segment.count);\n", "    assertNull(table.get(0));\n", "  }\n", "\n"], "9": ["    MapMakerInternalMap<Object, Object> map = makeMap(createMapMaker()\n", "        .concurrencyLevel(1)\n", "        .initialCapacity(1)\n", "        .expireAfterWrite(99999, SECONDS));\n"], "10": ["    segment.recordWrite(entry);\n", "    assertSame(entry, segment.expirationQueue.peek());\n", "    assertTrue(segment.expirationQueue.isEmpty());\n", "        makeMap(\n", "            createMapMaker()\n", "                .concurrencyLevel(1)\n", "                .initialCapacity(1)\n", "                .expireAfterWrite(99999, SECONDS));\n"], "11": ["    // remove live\n", "    segment.recordWrite(entry);\n", "    assertFalse(segment.expirationQueue.contains(entry));\n", "    assertEquals(0, segment.count);\n", "    assertNull(table.get(0));\n", "  }\n", "\n", "  public void testReclaimValue() {\n", "    MapMakerInternalMap<Object, Object> map =\n", "        makeMap(\n", "            createMapMaker()\n", "                .concurrencyLevel(1)\n", "                .initialCapacity(1)\n", "                .expireAfterWrite(99999, SECONDS));\n", "    Segment<Object, Object> segment = map.segments[0];\n", "    AtomicReferenceArray<ReferenceEntry<Object, Object>> table = segment.table;\n", "    assertEquals(1, table.length());\n", "\n", "    Object key = new Object();\n", "    Object value = new Object();\n", "    int hash = map.hash(key);\n", "    DummyEntry<Object, Object> entry = DummyEntry.create(key, hash, null);\n", "    DummyValueReference<Object, Object> valueRef = DummyValueReference.create(value, entry);\n", "    entry.setValueReference(valueRef);\n", "\n", "    // reclaim absent\n", "    assertFalse(segment.reclaimValue(key, hash, valueRef));\n", "\n", "    // reclaim live\n", "    segment.recordWrite(entry);\n", "    table.set(0, entry);\n", "    segment.count = 1;\n", "    assertTrue(segment.reclaimValue(key, hash, valueRef));\n", "    assertFalse(segment.expirationQueue.contains(entry));\n", "\n", "    // reclaim wrong value reference\n", "    table.set(0, entry);\n", "    DummyValueReference<Object, Object> otherValueRef = DummyValueReference.create(value, entry);\n", "    entry.setValueReference(otherValueRef);\n", "    assertFalse(segment.reclaimValue(key, hash, valueRef));\n", "    assertTrue(segment.reclaimValue(key, hash, otherValueRef));\n", "        makeMap(\n", "            createMapMaker()\n", "                .concurrencyLevel(1)\n", "                .initialCapacity(1)\n", "                .expireAfterWrite(99999, SECONDS));\n"], "12": ["    // clear live\n", "    segment.recordWrite(entry);\n", "    assertFalse(segment.expirationQueue.contains(entry));\n"], "13": ["  // Segment eviction tests\n", "\n", "  public void testRecordRead() {\n", "    for (MapMaker maker : allEvictingMakers()) {\n", "      MapMakerInternalMap<Object, Object> map = makeMap(maker.concurrencyLevel(1));\n", "      Segment<Object, Object> segment = map.segments[0];\n", "      List<ReferenceEntry<Object, Object>> writeOrder = Lists.newLinkedList();\n", "      List<ReferenceEntry<Object, Object>> readOrder = Lists.newLinkedList();\n", "      for (int i = 0; i < DRAIN_THRESHOLD * 2; i++) {\n", "        Object key = new Object();\n", "        int hash = map.hash(key);\n", "        Object value = new Object();\n", "\n", "        ReferenceEntry<Object, Object> entry = createDummyEntry(key, hash, value, null);\n", "        segment.recordWrite(entry);\n", "        writeOrder.add(entry);\n", "        readOrder.add(entry);\n", "      }\n", "\n", "      checkEvictionQueues(map, segment, readOrder, writeOrder);\n", "      checkExpirationTimes(map);\n", "\n", "      // access some of the elements\n", "      Random random = new Random();\n", "      List<ReferenceEntry<Object, Object>> reads = Lists.newArrayList();\n", "      Iterator<ReferenceEntry<Object, Object>> i = readOrder.iterator();\n", "      while (i.hasNext()) {\n", "        ReferenceEntry<Object, Object> entry = i.next();\n", "        if (random.nextBoolean()) {\n", "          reads.add(entry);\n", "          i.remove();\n", "        }\n", "      }\n", "      readOrder.addAll(reads);\n", "\n", "      checkEvictionQueues(map, segment, readOrder, writeOrder);\n", "      checkExpirationTimes(map);\n", "    }\n", "  }\n", "\n", "  public void testRecordReadOnGet() {\n", "    for (MapMaker maker : allEvictingMakers()) {\n", "      MapMakerInternalMap<Object, Object> map = makeMap(maker.concurrencyLevel(1));\n", "      Segment<Object, Object> segment = map.segments[0];\n", "      List<ReferenceEntry<Object, Object>> writeOrder = Lists.newLinkedList();\n", "      List<ReferenceEntry<Object, Object>> readOrder = Lists.newLinkedList();\n", "      for (int i = 0; i < DRAIN_THRESHOLD * 2; i++) {\n", "        Object key = new Object();\n", "        int hash = map.hash(key);\n", "        Object value = new Object();\n", "\n", "        map.put(key, value);\n", "        ReferenceEntry<Object, Object> entry = segment.getEntry(key, hash);\n", "        writeOrder.add(entry);\n", "        readOrder.add(entry);\n", "      }\n", "\n", "      checkEvictionQueues(map, segment, readOrder, writeOrder);\n", "      checkExpirationTimes(map);\n", "\n", "      // access some of the elements\n", "      Random random = new Random();\n", "      List<ReferenceEntry<Object, Object>> reads = Lists.newArrayList();\n", "      Iterator<ReferenceEntry<Object, Object>> i = readOrder.iterator();\n", "      while (i.hasNext()) {\n", "        ReferenceEntry<Object, Object> entry = i.next();\n", "        if (random.nextBoolean()) {\n", "          Object unused = map.get(entry.getKey());\n", "          reads.add(entry);\n", "          i.remove();\n", "        }\n", "      }\n", "      readOrder.addAll(reads);\n", "\n", "      checkEvictionQueues(map, segment, readOrder, writeOrder);\n", "      checkExpirationTimes(map);\n", "    }\n", "  }\n", "\n", "  public void testRecordWrite() {\n", "    for (MapMaker maker : allEvictingMakers()) {\n", "      MapMakerInternalMap<Object, Object> map = makeMap(maker.concurrencyLevel(1));\n", "      Segment<Object, Object> segment = map.segments[0];\n", "      List<ReferenceEntry<Object, Object>> writeOrder = Lists.newLinkedList();\n", "      for (int i = 0; i < DRAIN_THRESHOLD * 2; i++) {\n", "        Object key = new Object();\n", "        int hash = map.hash(key);\n", "        Object value = new Object();\n", "\n", "        ReferenceEntry<Object, Object> entry = createDummyEntry(key, hash, value, null);\n", "        segment.recordWrite(entry);\n", "        writeOrder.add(entry);\n", "      }\n", "\n", "      checkEvictionQueues(map, segment, writeOrder, writeOrder);\n", "      checkExpirationTimes(map);\n", "\n", "      // access some of the elements\n", "      Random random = new Random();\n", "      List<ReferenceEntry<Object, Object>> writes = Lists.newArrayList();\n", "      Iterator<ReferenceEntry<Object, Object>> i = writeOrder.iterator();\n", "      while (i.hasNext()) {\n", "        ReferenceEntry<Object, Object> entry = i.next();\n", "        if (random.nextBoolean()) {\n", "          segment.recordWrite(entry);\n", "          writes.add(entry);\n", "          i.remove();\n", "        }\n", "      }\n", "      writeOrder.addAll(writes);\n", "\n", "      checkEvictionQueues(map, segment, writeOrder, writeOrder);\n", "      checkExpirationTimes(map);\n", "    }\n", "  }\n", "\n", "  static <K, V> void checkEvictionQueues(MapMakerInternalMap<K, V> map,\n", "      Segment<K, V> segment, List<ReferenceEntry<K, V>> readOrder,\n", "      List<ReferenceEntry<K, V>> writeOrder) {\n", "    if (map.expires()) {\n", "      assertSameEntries(writeOrder, ImmutableList.copyOf(segment.expirationQueue));\n", "    }\n", "  }\n", "\n", "  private static <K, V> void assertSameEntries(List<ReferenceEntry<K, V>> expectedEntries,\n", "      List<ReferenceEntry<K, V>> actualEntries) {\n", "    int size = expectedEntries.size();\n", "    assertEquals(size, actualEntries.size());\n", "    for (int i = 0; i < size; i++) {\n", "      ReferenceEntry<K, V> expectedEntry = expectedEntries.get(0);\n", "      ReferenceEntry<K, V> actualEntry = actualEntries.get(0);\n", "      assertSame(expectedEntry.getKey(), actualEntry.getKey());\n", "      assertSame(expectedEntry.getValueReference().get(), actualEntry.getValueReference().get());\n", "    }\n", "  }\n", "\n", "  static <K, V> void checkExpirationTimes(MapMakerInternalMap<K, V> map) {\n", "    if (!map.expires()) {\n", "      return;\n", "    }\n", "\n", "    for (Segment<K, V> segment : map.segments) {\n", "      long lastExpirationTime = 0;\n", "      for (ReferenceEntry<K, V> e : segment.expirationQueue) {\n", "        long expirationTime = e.getExpirationTime();\n", "        assertTrue(expirationTime >= lastExpirationTime);\n", "        lastExpirationTime = expirationTime;\n", "      }\n", "    }\n", "  }\n", "\n"], "14": ["  /**\n", "   * Returns an iterable containing all combinations of expireAfterWrite,\n", "   * weakKeys and weak/softValues.\n", "   */\n", "  private static Iterable<MapMaker> allEntryTypeMakers() {\n", "    List<MapMaker> result = newArrayList(allKeyValueStrengthMakers());\n", "    for (MapMaker maker : allKeyValueStrengthMakers()) {\n", "      result.add(maker.expireAfterWrite(99999, SECONDS));\n", "    }\n", "    return result;\n", "  }\n", "\n", "  /**\n", "   * Returns an iterable containing all combinations of expireAfterWrite.\n", "   */\n", "  static Iterable<MapMaker> allEvictingMakers() {\n", "    return ImmutableList.of(\n", "        createMapMaker().expireAfterWrite(99999, SECONDS),\n", "        createMapMaker().expireAfterWrite(SMALL_MAX_SIZE, TimeUnit.SECONDS));\n", "  }\n", "\n"], "15": ["\n", "    private long expirationTime = Long.MAX_VALUE;\n", "\n", "    @Override\n", "    public long getExpirationTime() {\n", "      return expirationTime;\n", "    }\n", "\n", "    @Override\n", "    public void setExpirationTime(long time) {\n", "      this.expirationTime = time;\n", "    }\n", "\n", "    private ReferenceEntry<K, V> nextExpirable = nullEntry();\n", "\n", "    @Override\n", "    public ReferenceEntry<K, V> getNextExpirable() {\n", "      return nextExpirable;\n", "    }\n", "\n", "    @Override\n", "    public void setNextExpirable(ReferenceEntry<K, V> next) {\n", "      this.nextExpirable = next;\n", "    }\n", "\n", "    private ReferenceEntry<K, V> previousExpirable = nullEntry();\n", "\n", "    @Override\n", "    public ReferenceEntry<K, V> getPreviousExpirable() {\n", "      return previousExpirable;\n", "    }\n", "\n", "    @Override\n", "    public void setPreviousExpirable(ReferenceEntry<K, V> previous) {\n", "      this.previousExpirable = previous;\n", "    }\n", "\n", "    private ReferenceEntry<K, V> nextEvictable = nullEntry();\n", "\n", "    @Override\n", "    public ReferenceEntry<K, V> getNextEvictable() {\n", "      return nextEvictable;\n", "    }\n", "\n", "    @Override\n", "    public void setNextEvictable(ReferenceEntry<K, V> next) {\n", "      this.nextEvictable = next;\n", "    }\n", "\n", "    private ReferenceEntry<K, V> previousEvictable = nullEntry();\n", "\n", "    @Override\n", "    public ReferenceEntry<K, V> getPreviousEvictable() {\n", "      return previousEvictable;\n", "    }\n", "\n", "    @Override\n", "    public void setPreviousEvictable(ReferenceEntry<K, V> previous) {\n", "      this.previousEvictable = previous;\n", "    }\n"]}, "added_lines": {"5": [222], "6": [254], "9": [733, 734], "10": [743, 758], "11": [780]}, "removed_lines": {"1": [19, 24, 27], "2": [39, 40, 41, 42], "3": [73, 74, 76], "4": [84, 85], "5": [231, 232, 233, 234, 235, 236, 237, 238, 242], "6": [274], "7": [288, 289, 290, 291, 298, 305, 306, 307, 308, 309, 310, 311, 312], "8": [662, 663, 664, 665, 666, 667, 668, 669, 670, 671, 672, 673, 674, 675, 676, 677, 678, 679, 680, 681, 682, 683, 684, 685, 686, 687, 688, 689, 690, 691, 692, 693, 694, 695, 696, 697, 698, 699, 700, 701, 702, 703], "9": [808, 809, 810, 811], "10": [820, 826, 830, 837, 838, 839, 840, 841], "11": [854, 855, 859, 860, 861, 862, 863, 864, 865, 866, 867, 868, 869, 870, 871, 872, 873, 874, 875, 876, 877, 878, 879, 880, 881, 882, 883, 884, 885, 886, 887, 888, 889, 890, 893, 894, 895, 896, 897, 898, 899, 904, 905, 906, 907, 908], "12": [923, 924, 929], "13": [942, 943, 944, 945, 946, 947, 948, 949, 950, 951, 952, 953, 954, 955, 956, 957, 958, 959, 960, 961, 962, 963, 964, 965, 966, 967, 968, 969, 970, 971, 972, 973, 974, 975, 976, 977, 978, 979, 980, 981, 982, 983, 984, 985, 986, 987, 988, 989, 990, 991, 992, 993, 994, 995, 996, 997, 998, 999, 1000, 1001, 1002, 1003, 1004, 1005, 1006, 1007, 1008, 1009, 1010, 1011, 1012, 1013, 1014, 1015, 1016, 1017, 1018, 1019, 1020, 1021, 1022, 1023, 1024, 1025, 1026, 1027, 1028, 1029, 1030, 1031, 1032, 1033, 1034, 1035, 1036, 1037, 1038, 1039, 1040, 1041, 1042, 1043, 1044, 1045, 1046, 1047, 1048, 1049, 1050, 1051, 1052, 1053, 1054, 1055, 1056, 1057, 1058, 1059, 1060, 1061, 1062, 1063, 1064, 1065, 1066, 1067, 1068, 1069, 1070, 1071, 1072, 1073, 1074, 1075, 1076, 1077, 1078, 1079, 1080, 1081, 1082, 1083, 1084, 1085, 1086, 1087, 1088, 1089, 1090, 1091, 1092], "14": [1221, 1222, 1223, 1224, 1225, 1226, 1227, 1228, 1229, 1230, 1231, 1232, 1233, 1234, 1235, 1236, 1237, 1238, 1239, 1240, 1241], "15": [1309, 1310, 1311, 1312, 1313, 1314, 1315, 1316, 1317, 1318, 1319, 1320, 1321, 1322, 1323, 1324, 1325, 1326, 1327, 1328, 1329, 1330, 1331, 1332, 1333, 1334, 1335, 1336, 1337, 1338, 1339, 1340, 1341, 1342, 1343, 1344, 1345, 1346, 1347, 1348, 1349, 1350, 1351, 1352, 1353, 1354, 1355, 1356, 1357, 1358, 1359, 1360, 1361, 1362, 1363, 1364, 1365, 1366, 1367, 1368]}}, {"5": "guava-tests/test/com/google/common/collect/MapMakerTest.java", "added": {}, "removed": {"1": ["import static java.util.concurrent.TimeUnit.HOURS;\n"], "2": ["    @SuppressWarnings(\"deprecation\") // test of deprecated method\n", "    public void testExpiration_setTwice() {\n", "      MapMaker maker = new MapMaker().expireAfterWrite(1, HOURS);\n", "      try {\n", "        // even to the same value is not allowed\n", "        maker.expireAfterWrite(1, HOURS);\n", "        fail();\n", "      } catch (IllegalStateException expected) {\n", "      }\n", "    }\n", "\n"]}, "added_lines": {}, "removed_lines": {"1": [20], "2": [126, 127, 128, 129, 130, 131, 132, 133, 134, 135, 136]}}, {"6": "guava/src/com/google/common/collect/ComputingConcurrentHashMap.java", "added": {"1": ["                    if (value != null) {\n"]}, "removed": {"1": ["                    if (value == null) {\n", "                      // TODO(kak): Remove this branch.\n", "                    } else if (map.expires() && map.isExpired(e)) {\n", "                      // This is a duplicate check, as preWriteCleanup already purged expired\n", "                      // entries, but let's accomodate an incorrect expiration queue.\n", "                      // TODO(kak): Remove this branch.\n", "                    } else {\n", "                    // immediately reuse invalid entries\n", "                    expirationQueue.remove(e);\n"], "2": ["        expireAfterWriteNanos,\n"], "3": ["        long expireAfterWriteNanos,\n"], "4": ["          expireAfterWriteNanos,\n"]}, "added_lines": {"1": [115]}, "removed_lines": {"1": [115, 116, 117, 118, 119, 120, 121, 125, 126], "2": [378], "3": [393], "4": [402]}}, {"7": "guava/src/com/google/common/collect/GenericMapMaker.java", "added": {}, "removed": {"1": ["import java.util.concurrent.TimeUnit;\n"], "2": ["  /**\n", "   * See {@link MapMaker#expireAfterWrite}.\n", "   */\n", "  abstract GenericMapMaker<K0, V0> expireAfterWrite(long duration, TimeUnit unit);\n", "\n"]}, "added_lines": {}, "removed_lines": {"1": [26], "2": [92, 93, 94, 95, 96]}}, {"8": "guava/src/com/google/common/collect/MapMaker.java", "added": {}, "removed": {"1": ["import com.google.common.base.Ticker;\n"], "2": ["import java.util.concurrent.TimeUnit;\n"], "3": ["  private static final int DEFAULT_EXPIRATION_NANOS = 0;\n"], "4": ["  long expireAfterWriteNanos = UNSET_INT;\n", "\n", "  Ticker ticker;\n", "\n"], "5": ["  /**\n", "   * Specifies that each entry should be automatically removed from the map once a fixed duration\n", "   * has elapsed after the entry's creation, or the most recent replacement of its value.\n", "   *\n", "   * <p>When {@code duration} is zero, elements can be successfully added to the map, but are\n", "   * evicted immediately. It can be useful in testing, or to disable caching temporarily without\n", "   * a code change.\n", "   *\n", "   * <p>Expired entries may be counted by {@link Map#size}, but will never be visible to read or\n", "   * write operations. Expired entries are currently cleaned up during write operations, or during\n", "   * occasional read operations in the absense of writes; though this behavior may change in the\n", "   * future.\n", "   *\n", "   * @param duration the length of time after an entry is created that it should be automatically\n", "   *     removed\n", "   * @param unit the unit that {@code duration} is expressed in\n", "   * @throws IllegalArgumentException if {@code duration} is negative\n", "   * @throws IllegalStateException if the time to live or time to idle was already set\n", "   * @deprecated Caching functionality in {@code MapMaker} has been moved to\n", "   *     {@link com.google.common.cache.CacheBuilder}, with {@link #expireAfterWrite} being replaced\n", "   *     by {@link com.google.common.cache.CacheBuilder#expireAfterWrite}. Note that\n", "   *     {@code CacheBuilder} is simply an enhanced API for an implementation which was branched\n", "   *     from {@code MapMaker}.\n", "   */\n", "  @CanIgnoreReturnValue\n", "  @Deprecated\n", "  @Override\n", "  MapMaker expireAfterWrite(long duration, TimeUnit unit) {\n", "    checkExpiration(duration, unit);\n", "    this.expireAfterWriteNanos = unit.toNanos(duration);\n", "    if (duration == 0) {\n", "      this.evictImmediately = true;\n", "    }\n", "    useCustomMap = true;\n", "    return this;\n", "  }\n", "\n", "  private void checkExpiration(long duration, TimeUnit unit) {\n", "    checkState(\n", "        expireAfterWriteNanos == UNSET_INT,\n", "        \"expireAfterWrite was already set to %s ns\",\n", "        expireAfterWriteNanos);\n", "    checkArgument(duration >= 0, \"duration cannot be negative: %s %s\", duration, unit);\n", "  }\n", "\n", "  long getExpireAfterWriteNanos() {\n", "    return (expireAfterWriteNanos == UNSET_INT) ? DEFAULT_EXPIRATION_NANOS : expireAfterWriteNanos;\n", "  }\n", "\n", "  Ticker getTicker() {\n", "    return MoreObjects.firstNonNull(ticker, Ticker.systemTicker());\n", "  }\n", "\n"], "6": ["    if (expireAfterWriteNanos != UNSET_INT) {\n", "      s.add(\"expireAfterWrite\", expireAfterWriteNanos + \"ns\");\n", "    }\n"]}, "added_lines": {}, "removed_lines": {"1": [29], "2": [44], "3": [109], "4": [122, 123, 128, 129], "5": [317, 318, 319, 320, 321, 322, 323, 324, 325, 326, 327, 328, 329, 330, 331, 332, 333, 334, 335, 336, 337, 338, 339, 340, 341, 342, 343, 344, 345, 346, 347, 348, 349, 350, 351, 352, 353, 354, 355, 356, 357, 358, 359, 360, 361, 362, 363, 364, 365, 366, 367, 368, 369], "6": [477, 478, 479]}}, {"9": "guava/src/com/google/common/collect/MapMakerInternalMap.java", "added": {"5": ["    entryFactory = EntryFactory.getFactory(keyStrength);\n"], "8": ["    static EntryFactory getFactory(Strength keyStrength) {\n", "      switch (keyStrength) {\n", "        case STRONG:\n", "          return EntryFactory.STRONG;\n", "        case WEAK:\n", "          return EntryFactory.WEAK;\n", "        case SOFT:\n", "          throw new IllegalArgumentException();\n", "      }\n", "      throw new AssertionError();\n"], "11": ["    ReferenceEntry<K, V> getNext();\n", "    /**\n", "     * Gets the entry's hash.\n", "     */\n", "    int getHash();\n", "    /**\n", "     * Gets the key for this entry.\n", "     */\n", "    K getKey();\n", "  }\n", "  private enum NullEntry implements ReferenceEntry<Object, Object> {\n", "    INSTANCE;\n", "    public ValueReference<Object, Object> getValueReference() {\n", "      return null;\n", "    public void setValueReference(ValueReference<Object, Object> valueReference) {}\n", "    public ReferenceEntry<Object, Object> getNext() {\n", "      return null;\n", "    public int getHash() {\n", "      return 0;\n", "    public Object getKey() {\n", "      return null;\n", "  abstract static class AbstractReferenceEntry<K, V> implements ReferenceEntry<K, V> {\n", "    @Override\n", "    public ValueReference<K, V> getValueReference() {\n", "      throw new UnsupportedOperationException();\n", "    public void setValueReference(ValueReference<K, V> valueReference) {\n", "      throw new UnsupportedOperationException();\n", "    public ReferenceEntry<K, V> getNext() {\n", "      throw new UnsupportedOperationException();\n", "    public int getHash() {\n", "      throw new UnsupportedOperationException();\n", "    public K getKey() {\n", "      throw new UnsupportedOperationException();\n", "  @SuppressWarnings(\"unchecked\") // impl never uses a parameter or returns any non-null value\n", "  static <K, V> ReferenceEntry<K, V> nullEntry() {\n", "    return (ReferenceEntry<K, V>) NullEntry.INSTANCE;\n", "  }\n", "  /*\n", "   * Note: All of this duplicate code sucks, but it saves a lot of memory. If only Java had mixins!\n", "   * To maintain this code, make a change for the strong reference type. Then, cut and paste, and\n", "   * replace \"Strong\" with \"Soft\" or \"Weak\" within the pasted text. The primary difference is that\n", "   * strong entries store the key reference directly while soft and weak entries delegate to their\n", "   * respective superclasses.\n", "   */\n", "  /**\n", "   * Used for strongly-referenced keys.\n", "   */\n", "  static class StrongEntry<K, V> implements ReferenceEntry<K, V> {\n", "    final K key;\n", "    StrongEntry(K key, int hash, @Nullable ReferenceEntry<K, V> next) {\n", "      this.key = key;\n", "      this.hash = hash;\n", "      this.next = next;\n", "    public K getKey() {\n", "      return this.key;\n", "    // The code below is exactly the same for each entry type.\n", "\n", "    final int hash;\n", "    final ReferenceEntry<K, V> next;\n", "    volatile ValueReference<K, V> valueReference = unset();\n", "    public ValueReference<K, V> getValueReference() {\n", "      return valueReference;\n", "    public void setValueReference(ValueReference<K, V> valueReference) {\n", "      ValueReference<K, V> previous = this.valueReference;\n", "      this.valueReference = valueReference;\n", "      previous.clear(valueReference);\n", "    @Override\n", "    public int getHash() {\n", "      return hash;\n", "    }\n", "    public ReferenceEntry<K, V> getNext() {\n", "      return next;\n", "    }\n", "  }\n", "\n", "  /**\n", "   * Used for weakly-referenced keys.\n", "   */\n", "  static class WeakEntry<K, V> extends WeakReference<K> implements ReferenceEntry<K, V> {\n", "    WeakEntry(ReferenceQueue<K> queue, K key, int hash, @Nullable ReferenceEntry<K, V> next) {\n", "      super(key, queue);\n", "      this.hash = hash;\n", "      this.next = next;\n", "    public K getKey() {\n", "      return get();\n", "    // The code below is exactly the same for each entry type.\n", "    final int hash;\n", "    final ReferenceEntry<K, V> next;\n", "    volatile ValueReference<K, V> valueReference = unset();\n", "    public ValueReference<K, V> getValueReference() {\n", "      return valueReference;\n", "    public void setValueReference(ValueReference<K, V> valueReference) {\n", "      ValueReference<K, V> previous = this.valueReference;\n", "      this.valueReference = valueReference;\n", "      previous.clear(valueReference);\n", "    public int getHash() {\n", "      return hash;\n", "    public ReferenceEntry<K, V> getNext() {\n", "      return next;\n"], "12": ["   * partially-collected or computing. Unlike {@link Segment#getLiveValue} this method\n"], "17": ["     * Sets a new value of an entry.\n"], "25": ["     * partially-collected or computing.\n"], "30": ["   * Returns the internal entry for the specified key. The entry may be computing or\n"], "34": ["      return new MapMaker()\n", "          .initialCapacity(size)\n", "          .setKeyStrength(keyStrength)\n", "          .setValueStrength(valueStrength)\n", "          .keyEquivalence(keyEquivalence)\n", "          .concurrencyLevel(concurrencyLevel);\n"]}, "removed": {"1": ["import com.google.common.base.Ticker;\n"], "2": ["import java.util.AbstractQueue;\n", "import java.util.Queue;\n", "import java.util.concurrent.TimeUnit;\n"], "3": ["   * If a maximum size is specified, a best-effort bounding is performed per segment, using a\n", "   * page-replacement algorithm to determine which entries to evict when the capacity has been\n", "   * exceeded.\n", "   *\n"], "4": ["  /** How long after the last write to an entry the map will retain that entry. */\n", "  final long expireAfterWriteNanos;\n", "\n", "  /** Measures time in a testable way. */\n", "  final Ticker ticker;\n", "\n"], "5": ["    expireAfterWriteNanos = builder.getExpireAfterWriteNanos();\n", "\n", "    entryFactory = EntryFactory.getFactory(keyStrength, expires());\n", "    ticker = builder.getTicker();\n"], "6": ["  boolean expires() {\n", "    return expireAfterWriteNanos > 0;\n", "  }\n", "\n"], "7": ["    STRONG_EXPIRABLE {\n", "      @Override\n", "      <K, V> ReferenceEntry<K, V> newEntry(\n", "          Segment<K, V> segment, K key, int hash, @Nullable ReferenceEntry<K, V> next) {\n", "        return new StrongExpirableEntry<K, V>(key, hash, next);\n", "      }\n", "\n", "      @Override\n", "      <K, V> ReferenceEntry<K, V> copyEntry(\n", "          Segment<K, V> segment, ReferenceEntry<K, V> original, ReferenceEntry<K, V> newNext) {\n", "        ReferenceEntry<K, V> newEntry = super.copyEntry(segment, original, newNext);\n", "        copyExpirableEntry(original, newEntry);\n", "        return newEntry;\n", "      }\n", "    },\n", "    STRONG_EVICTABLE {\n", "      @Override\n", "      <K, V> ReferenceEntry<K, V> newEntry(\n", "          Segment<K, V> segment, K key, int hash, @Nullable ReferenceEntry<K, V> next) {\n", "        return new StrongEvictableEntry<K, V>(key, hash, next);\n", "      }\n", "\n", "      @Override\n", "      <K, V> ReferenceEntry<K, V> copyEntry(\n", "          Segment<K, V> segment, ReferenceEntry<K, V> original, ReferenceEntry<K, V> newNext) {\n", "        ReferenceEntry<K, V> newEntry = super.copyEntry(segment, original, newNext);\n", "        copyEvictableEntry(original, newEntry);\n", "        return newEntry;\n", "      }\n", "    },\n", "    STRONG_EXPIRABLE_EVICTABLE {\n", "      @Override\n", "      <K, V> ReferenceEntry<K, V> newEntry(\n", "          Segment<K, V> segment, K key, int hash, @Nullable ReferenceEntry<K, V> next) {\n", "        return new StrongExpirableEvictableEntry<K, V>(key, hash, next);\n", "      }\n", "\n", "      @Override\n", "      <K, V> ReferenceEntry<K, V> copyEntry(\n", "          Segment<K, V> segment, ReferenceEntry<K, V> original, ReferenceEntry<K, V> newNext) {\n", "        ReferenceEntry<K, V> newEntry = super.copyEntry(segment, original, newNext);\n", "        copyExpirableEntry(original, newEntry);\n", "        copyEvictableEntry(original, newEntry);\n", "        return newEntry;\n", "      }\n", "    },\n"], "8": ["    },\n", "    WEAK_EXPIRABLE {\n", "      @Override\n", "      <K, V> ReferenceEntry<K, V> newEntry(\n", "          Segment<K, V> segment, K key, int hash, @Nullable ReferenceEntry<K, V> next) {\n", "        return new WeakExpirableEntry<K, V>(segment.keyReferenceQueue, key, hash, next);\n", "      }\n", "\n", "      @Override\n", "      <K, V> ReferenceEntry<K, V> copyEntry(\n", "          Segment<K, V> segment, ReferenceEntry<K, V> original, ReferenceEntry<K, V> newNext) {\n", "        ReferenceEntry<K, V> newEntry = super.copyEntry(segment, original, newNext);\n", "        copyExpirableEntry(original, newEntry);\n", "        return newEntry;\n", "      }\n", "    },\n", "    WEAK_EVICTABLE {\n", "      @Override\n", "      <K, V> ReferenceEntry<K, V> newEntry(\n", "          Segment<K, V> segment, K key, int hash, @Nullable ReferenceEntry<K, V> next) {\n", "        return new WeakEvictableEntry<K, V>(segment.keyReferenceQueue, key, hash, next);\n", "      }\n", "\n", "      @Override\n", "      <K, V> ReferenceEntry<K, V> copyEntry(\n", "          Segment<K, V> segment, ReferenceEntry<K, V> original, ReferenceEntry<K, V> newNext) {\n", "        ReferenceEntry<K, V> newEntry = super.copyEntry(segment, original, newNext);\n", "        copyEvictableEntry(original, newEntry);\n", "        return newEntry;\n", "      }\n", "    },\n", "    WEAK_EXPIRABLE_EVICTABLE {\n", "      @Override\n", "      <K, V> ReferenceEntry<K, V> newEntry(\n", "          Segment<K, V> segment, K key, int hash, @Nullable ReferenceEntry<K, V> next) {\n", "        return new WeakExpirableEvictableEntry<K, V>(segment.keyReferenceQueue, key, hash, next);\n", "      }\n", "\n", "      @Override\n", "      <K, V> ReferenceEntry<K, V> copyEntry(\n", "          Segment<K, V> segment, ReferenceEntry<K, V> original, ReferenceEntry<K, V> newNext) {\n", "        ReferenceEntry<K, V> newEntry = super.copyEntry(segment, original, newNext);\n", "        copyExpirableEntry(original, newEntry);\n", "        copyEvictableEntry(original, newEntry);\n", "        return newEntry;\n", "      }\n", "    };\n", "\n", "    /**\n", "     * Masks used to compute indices in the following table.\n", "     */\n", "    static final int EXPIRABLE_MASK = 1;\n", "\n", "    /**\n", "     * Look-up table for factories. First dimension is the reference type. The second dimension is\n", "     * the result of OR-ing the feature masks.\n", "     */\n", "    static final EntryFactory[][] factories = {\n", "      {STRONG, STRONG_EXPIRABLE, STRONG_EVICTABLE, STRONG_EXPIRABLE_EVICTABLE},\n", "      {}, // no support for SOFT keys\n", "      {WEAK, WEAK_EXPIRABLE, WEAK_EVICTABLE, WEAK_EXPIRABLE_EVICTABLE}\n", "    static EntryFactory getFactory(Strength keyStrength, boolean expireAfterWrite) {\n", "      int flags = (expireAfterWrite ? EXPIRABLE_MASK : 0) | 0;\n", "      return factories[keyStrength.ordinal()][flags];\n"], "9": ["\n", "    // Guarded By Segment.this\n", "    <K, V> void copyExpirableEntry(ReferenceEntry<K, V> original, ReferenceEntry<K, V> newEntry) {\n", "      // TODO(fry): when we link values instead of entries this method can go\n", "      // away, as can connectExpirables, nullifyExpirable.\n", "      newEntry.setExpirationTime(original.getExpirationTime());\n", "\n", "      connectExpirables(original.getPreviousExpirable(), newEntry);\n", "      connectExpirables(newEntry, original.getNextExpirable());\n", "\n", "      nullifyExpirable(original);\n", "    }\n", "\n", "    // Guarded By Segment.this\n", "    <K, V> void copyEvictableEntry(ReferenceEntry<K, V> original, ReferenceEntry<K, V> newEntry) {\n", "      // TODO(fry): when we link values instead of entries this method can go\n", "      // away, as can connectEvictables, nullifyEvictable.\n", "      connectEvictables(original.getPreviousEvictable(), newEntry);\n", "      connectEvictables(newEntry, original.getNextEvictable());\n", "\n", "      nullifyEvictable(original);\n", "    }\n"], "10": ["   * - Expired: time expired (key/value may still be set)\n"], "11": ["    ReferenceEntry<K, V> getNext();\n", "\n", "    /**\n", "     * Gets the entry's hash.\n", "     */\n", "    int getHash();\n", "\n", "    /**\n", "     * Gets the key for this entry.\n", "     */\n", "    K getKey();\n", "\n", "    /*\n", "     * Used by entries that are expirable. Expirable entries are maintained in a doubly-linked list.\n", "     * New entries are added at the tail of the list at write time; stale entries are expired from\n", "     * the head of the list.\n", "     */\n", "\n", "    /**\n", "     * Gets the entry expiration time in ns.\n", "     */\n", "    long getExpirationTime();\n", "\n", "    /**\n", "     * Sets the entry expiration time in ns.\n", "     */\n", "    void setExpirationTime(long time);\n", "\n", "    /**\n", "     * Gets the next entry in the recency list.\n", "     */\n", "    ReferenceEntry<K, V> getNextExpirable();\n", "\n", "    /**\n", "     * Sets the next entry in the recency list.\n", "     */\n", "    void setNextExpirable(ReferenceEntry<K, V> next);\n", "\n", "    /**\n", "     * Gets the previous entry in the recency list.\n", "     */\n", "    ReferenceEntry<K, V> getPreviousExpirable();\n", "\n", "    /**\n", "     * Sets the previous entry in the recency list.\n", "     */\n", "    void setPreviousExpirable(ReferenceEntry<K, V> previous);\n", "\n", "    /*\n", "     * Implemented by entries that are evictable. Evictable entries are maintained in a\n", "     * doubly-linked list. New entries are added at the tail of the list at write time and stale\n", "     * entries are expired from the head of the list.\n", "     */\n", "\n", "    /**\n", "     * Gets the next entry in the recency list.\n", "     */\n", "    ReferenceEntry<K, V> getNextEvictable();\n", "\n", "    /**\n", "     * Sets the next entry in the recency list.\n", "     */\n", "    void setNextEvictable(ReferenceEntry<K, V> next);\n", "\n", "    /**\n", "     * Gets the previous entry in the recency list.\n", "     */\n", "    ReferenceEntry<K, V> getPreviousEvictable();\n", "\n", "    /**\n", "     * Sets the previous entry in the recency list.\n", "     */\n", "    void setPreviousEvictable(ReferenceEntry<K, V> previous);\n", "  }\n", "\n", "  private enum NullEntry implements ReferenceEntry<Object, Object> {\n", "    INSTANCE;\n", "\n", "    @Override\n", "    public ValueReference<Object, Object> getValueReference() {\n", "      return null;\n", "    }\n", "\n", "    @Override\n", "    public void setValueReference(ValueReference<Object, Object> valueReference) {}\n", "\n", "    @Override\n", "    public ReferenceEntry<Object, Object> getNext() {\n", "      return null;\n", "    }\n", "\n", "    @Override\n", "    public int getHash() {\n", "      return 0;\n", "    }\n", "\n", "    @Override\n", "    public Object getKey() {\n", "      return null;\n", "    }\n", "\n", "    @Override\n", "    public long getExpirationTime() {\n", "      return 0;\n", "    }\n", "\n", "    @Override\n", "    public void setExpirationTime(long time) {}\n", "\n", "    @Override\n", "    public ReferenceEntry<Object, Object> getNextExpirable() {\n", "      return this;\n", "    }\n", "\n", "    @Override\n", "    public void setNextExpirable(ReferenceEntry<Object, Object> next) {}\n", "\n", "    @Override\n", "    public ReferenceEntry<Object, Object> getPreviousExpirable() {\n", "      return this;\n", "    }\n", "\n", "    @Override\n", "    public void setPreviousExpirable(ReferenceEntry<Object, Object> previous) {}\n", "\n", "    @Override\n", "    public ReferenceEntry<Object, Object> getNextEvictable() {\n", "      return this;\n", "    }\n", "\n", "    @Override\n", "    public void setNextEvictable(ReferenceEntry<Object, Object> next) {}\n", "\n", "    @Override\n", "    public ReferenceEntry<Object, Object> getPreviousEvictable() {\n", "      return this;\n", "    }\n", "\n", "    @Override\n", "    public void setPreviousEvictable(ReferenceEntry<Object, Object> previous) {}\n", "  }\n", "\n", "  abstract static class AbstractReferenceEntry<K, V> implements ReferenceEntry<K, V> {\n", "    @Override\n", "    public ValueReference<K, V> getValueReference() {\n", "      throw new UnsupportedOperationException();\n", "    }\n", "\n", "    @Override\n", "    public void setValueReference(ValueReference<K, V> valueReference) {\n", "      throw new UnsupportedOperationException();\n", "    }\n", "\n", "    @Override\n", "    public ReferenceEntry<K, V> getNext() {\n", "      throw new UnsupportedOperationException();\n", "    }\n", "\n", "    @Override\n", "    public int getHash() {\n", "      throw new UnsupportedOperationException();\n", "    }\n", "\n", "    @Override\n", "    public K getKey() {\n", "      throw new UnsupportedOperationException();\n", "    }\n", "\n", "    @Override\n", "    public long getExpirationTime() {\n", "      throw new UnsupportedOperationException();\n", "    }\n", "\n", "    @Override\n", "    public void setExpirationTime(long time) {\n", "      throw new UnsupportedOperationException();\n", "    }\n", "\n", "    @Override\n", "    public ReferenceEntry<K, V> getNextExpirable() {\n", "      throw new UnsupportedOperationException();\n", "    }\n", "\n", "    @Override\n", "    public void setNextExpirable(ReferenceEntry<K, V> next) {\n", "      throw new UnsupportedOperationException();\n", "    }\n", "\n", "    @Override\n", "    public ReferenceEntry<K, V> getPreviousExpirable() {\n", "      throw new UnsupportedOperationException();\n", "    }\n", "\n", "    @Override\n", "    public void setPreviousExpirable(ReferenceEntry<K, V> previous) {\n", "      throw new UnsupportedOperationException();\n", "    }\n", "\n", "    @Override\n", "    public ReferenceEntry<K, V> getNextEvictable() {\n", "      throw new UnsupportedOperationException();\n", "    }\n", "\n", "    @Override\n", "    public void setNextEvictable(ReferenceEntry<K, V> next) {\n", "      throw new UnsupportedOperationException();\n", "    }\n", "\n", "    @Override\n", "    public ReferenceEntry<K, V> getPreviousEvictable() {\n", "      throw new UnsupportedOperationException();\n", "    }\n", "\n", "    @Override\n", "    public void setPreviousEvictable(ReferenceEntry<K, V> previous) {\n", "      throw new UnsupportedOperationException();\n", "    }\n", "  }\n", "\n", "  @SuppressWarnings(\"unchecked\") // impl never uses a parameter or returns any non-null value\n", "  static <K, V> ReferenceEntry<K, V> nullEntry() {\n", "    return (ReferenceEntry<K, V>) NullEntry.INSTANCE;\n", "  }\n", "\n", "  static final Queue<? extends Object> DISCARDING_QUEUE =\n", "      new AbstractQueue<Object>() {\n", "        @Override\n", "        public boolean offer(Object o) {\n", "          return true;\n", "        }\n", "\n", "        @Override\n", "        public Object peek() {\n", "          return null;\n", "        }\n", "\n", "        @Override\n", "        public Object poll() {\n", "          return null;\n", "        }\n", "\n", "        @Override\n", "        public int size() {\n", "          return 0;\n", "        }\n", "\n", "        @Override\n", "        public Iterator<Object> iterator() {\n", "          return Iterators.emptyIterator();\n", "        }\n", "      };\n", "\n", "  /**\n", "   * Queue that discards all elements.\n", "   */\n", "  @SuppressWarnings(\"unchecked\") // impl never uses a parameter or returns any non-null value\n", "  static <E> Queue<E> discardingQueue() {\n", "    return (Queue) DISCARDING_QUEUE;\n", "  }\n", "\n", "  /*\n", "   * Note: All of this duplicate code sucks, but it saves a lot of memory. If only Java had mixins!\n", "   * To maintain this code, make a change for the strong reference type. Then, cut and paste, and\n", "   * replace \"Strong\" with \"Soft\" or \"Weak\" within the pasted text. The primary difference is that\n", "   * strong entries store the key reference directly while soft and weak entries delegate to their\n", "   * respective superclasses.\n", "   */\n", "\n", "  /**\n", "   * Used for strongly-referenced keys.\n", "   */\n", "  static class StrongEntry<K, V> implements ReferenceEntry<K, V> {\n", "    final K key;\n", "\n", "    StrongEntry(K key, int hash, @Nullable ReferenceEntry<K, V> next) {\n", "      this.key = key;\n", "      this.hash = hash;\n", "      this.next = next;\n", "    }\n", "\n", "    @Override\n", "    public K getKey() {\n", "      return this.key;\n", "    }\n", "\n", "    // null expiration\n", "\n", "    @Override\n", "    public long getExpirationTime() {\n", "      throw new UnsupportedOperationException();\n", "    }\n", "\n", "    @Override\n", "    public void setExpirationTime(long time) {\n", "      throw new UnsupportedOperationException();\n", "    }\n", "\n", "    @Override\n", "    public ReferenceEntry<K, V> getNextExpirable() {\n", "      throw new UnsupportedOperationException();\n", "    }\n", "\n", "    @Override\n", "    public void setNextExpirable(ReferenceEntry<K, V> next) {\n", "      throw new UnsupportedOperationException();\n", "    }\n", "\n", "    @Override\n", "    public ReferenceEntry<K, V> getPreviousExpirable() {\n", "      throw new UnsupportedOperationException();\n", "    }\n", "\n", "    @Override\n", "    public void setPreviousExpirable(ReferenceEntry<K, V> previous) {\n", "      throw new UnsupportedOperationException();\n", "    }\n", "\n", "    // null eviction\n", "\n", "    @Override\n", "    public ReferenceEntry<K, V> getNextEvictable() {\n", "      throw new UnsupportedOperationException();\n", "    }\n", "\n", "    @Override\n", "    public void setNextEvictable(ReferenceEntry<K, V> next) {\n", "      throw new UnsupportedOperationException();\n", "    }\n", "\n", "    @Override\n", "    public ReferenceEntry<K, V> getPreviousEvictable() {\n", "      throw new UnsupportedOperationException();\n", "    }\n", "\n", "    @Override\n", "    public void setPreviousEvictable(ReferenceEntry<K, V> previous) {\n", "      throw new UnsupportedOperationException();\n", "    }\n", "\n", "    // The code below is exactly the same for each entry type.\n", "\n", "    final int hash;\n", "    final ReferenceEntry<K, V> next;\n", "    volatile ValueReference<K, V> valueReference = unset();\n", "\n", "    @Override\n", "    public ValueReference<K, V> getValueReference() {\n", "      return valueReference;\n", "    }\n", "\n", "    @Override\n", "    public void setValueReference(ValueReference<K, V> valueReference) {\n", "      ValueReference<K, V> previous = this.valueReference;\n", "      this.valueReference = valueReference;\n", "      previous.clear(valueReference);\n", "    }\n", "\n", "    @Override\n", "    public int getHash() {\n", "      return hash;\n", "    }\n", "\n", "    @Override\n", "    public ReferenceEntry<K, V> getNext() {\n", "      return next;\n", "    }\n", "  }\n", "\n", "  static final class StrongExpirableEntry<K, V> extends StrongEntry<K, V>\n", "      implements ReferenceEntry<K, V> {\n", "    StrongExpirableEntry(K key, int hash, @Nullable ReferenceEntry<K, V> next) {\n", "      super(key, hash, next);\n", "    }\n", "\n", "    // The code below is exactly the same for each expirable entry type.\n", "\n", "    volatile long time = Long.MAX_VALUE;\n", "\n", "    @Override\n", "    public long getExpirationTime() {\n", "      return time;\n", "    }\n", "\n", "    @Override\n", "    public void setExpirationTime(long time) {\n", "      this.time = time;\n", "    }\n", "\n", "    // Guarded By Segment.this\n", "    ReferenceEntry<K, V> nextExpirable = nullEntry();\n", "\n", "    @Override\n", "    public ReferenceEntry<K, V> getNextExpirable() {\n", "      return nextExpirable;\n", "    }\n", "\n", "    @Override\n", "    public void setNextExpirable(ReferenceEntry<K, V> next) {\n", "      this.nextExpirable = next;\n", "    }\n", "\n", "    // Guarded By Segment.this\n", "    ReferenceEntry<K, V> previousExpirable = nullEntry();\n", "\n", "    @Override\n", "    public ReferenceEntry<K, V> getPreviousExpirable() {\n", "      return previousExpirable;\n", "    }\n", "\n", "    @Override\n", "    public void setPreviousExpirable(ReferenceEntry<K, V> previous) {\n", "      this.previousExpirable = previous;\n", "    }\n", "  }\n", "\n", "  static final class StrongEvictableEntry<K, V> extends StrongEntry<K, V>\n", "      implements ReferenceEntry<K, V> {\n", "    StrongEvictableEntry(K key, int hash, @Nullable ReferenceEntry<K, V> next) {\n", "      super(key, hash, next);\n", "    }\n", "\n", "    // The code below is exactly the same for each evictable entry type.\n", "\n", "    // Guarded By Segment.this\n", "    ReferenceEntry<K, V> nextEvictable = nullEntry();\n", "\n", "    @Override\n", "    public ReferenceEntry<K, V> getNextEvictable() {\n", "      return nextEvictable;\n", "    }\n", "\n", "    @Override\n", "    public void setNextEvictable(ReferenceEntry<K, V> next) {\n", "      this.nextEvictable = next;\n", "    }\n", "\n", "    // Guarded By Segment.this\n", "    ReferenceEntry<K, V> previousEvictable = nullEntry();\n", "\n", "    @Override\n", "    public ReferenceEntry<K, V> getPreviousEvictable() {\n", "      return previousEvictable;\n", "    }\n", "\n", "    @Override\n", "    public void setPreviousEvictable(ReferenceEntry<K, V> previous) {\n", "      this.previousEvictable = previous;\n", "    }\n", "  }\n", "\n", "  static final class StrongExpirableEvictableEntry<K, V> extends StrongEntry<K, V>\n", "      implements ReferenceEntry<K, V> {\n", "    StrongExpirableEvictableEntry(K key, int hash, @Nullable ReferenceEntry<K, V> next) {\n", "      super(key, hash, next);\n", "    }\n", "\n", "    // The code below is exactly the same for each expirable entry type.\n", "\n", "    volatile long time = Long.MAX_VALUE;\n", "\n", "    @Override\n", "    public long getExpirationTime() {\n", "      return time;\n", "    }\n", "\n", "    @Override\n", "    public void setExpirationTime(long time) {\n", "      this.time = time;\n", "    }\n", "\n", "    // Guarded By Segment.this\n", "    ReferenceEntry<K, V> nextExpirable = nullEntry();\n", "\n", "    @Override\n", "    public ReferenceEntry<K, V> getNextExpirable() {\n", "      return nextExpirable;\n", "    }\n", "\n", "    @Override\n", "    public void setNextExpirable(ReferenceEntry<K, V> next) {\n", "      this.nextExpirable = next;\n", "    }\n", "\n", "    // Guarded By Segment.this\n", "    ReferenceEntry<K, V> previousExpirable = nullEntry();\n", "\n", "    @Override\n", "    public ReferenceEntry<K, V> getPreviousExpirable() {\n", "      return previousExpirable;\n", "    }\n", "\n", "    @Override\n", "    public void setPreviousExpirable(ReferenceEntry<K, V> previous) {\n", "      this.previousExpirable = previous;\n", "    }\n", "\n", "    // The code below is exactly the same for each evictable entry type.\n", "\n", "    // Guarded By Segment.this\n", "    ReferenceEntry<K, V> nextEvictable = nullEntry();\n", "\n", "    @Override\n", "    public ReferenceEntry<K, V> getNextEvictable() {\n", "      return nextEvictable;\n", "    }\n", "\n", "    @Override\n", "    public void setNextEvictable(ReferenceEntry<K, V> next) {\n", "      this.nextEvictable = next;\n", "    }\n", "\n", "    // Guarded By Segment.this\n", "    ReferenceEntry<K, V> previousEvictable = nullEntry();\n", "\n", "    @Override\n", "    public ReferenceEntry<K, V> getPreviousEvictable() {\n", "      return previousEvictable;\n", "    }\n", "\n", "    @Override\n", "    public void setPreviousEvictable(ReferenceEntry<K, V> previous) {\n", "      this.previousEvictable = previous;\n", "    }\n", "  }\n", "\n", "  /**\n", "   * Used for softly-referenced keys.\n", "   */\n", "  static class SoftEntry<K, V> extends SoftReference<K> implements ReferenceEntry<K, V> {\n", "    SoftEntry(ReferenceQueue<K> queue, K key, int hash, @Nullable ReferenceEntry<K, V> next) {\n", "      super(key, queue);\n", "      this.hash = hash;\n", "      this.next = next;\n", "    }\n", "\n", "    @Override\n", "    public K getKey() {\n", "      return get();\n", "    }\n", "\n", "    // null expiration\n", "    @Override\n", "    public long getExpirationTime() {\n", "      throw new UnsupportedOperationException();\n", "    }\n", "\n", "    @Override\n", "    public void setExpirationTime(long time) {\n", "      throw new UnsupportedOperationException();\n", "    }\n", "\n", "    @Override\n", "    public ReferenceEntry<K, V> getNextExpirable() {\n", "      throw new UnsupportedOperationException();\n", "    }\n", "\n", "    @Override\n", "    public void setNextExpirable(ReferenceEntry<K, V> next) {\n", "      throw new UnsupportedOperationException();\n", "    }\n", "\n", "    @Override\n", "    public ReferenceEntry<K, V> getPreviousExpirable() {\n", "      throw new UnsupportedOperationException();\n", "    }\n", "\n", "    @Override\n", "    public void setPreviousExpirable(ReferenceEntry<K, V> previous) {\n", "      throw new UnsupportedOperationException();\n", "    }\n", "\n", "    // null eviction\n", "\n", "    @Override\n", "    public ReferenceEntry<K, V> getNextEvictable() {\n", "      throw new UnsupportedOperationException();\n", "    }\n", "\n", "    @Override\n", "    public void setNextEvictable(ReferenceEntry<K, V> next) {\n", "      throw new UnsupportedOperationException();\n", "    }\n", "\n", "    @Override\n", "    public ReferenceEntry<K, V> getPreviousEvictable() {\n", "      throw new UnsupportedOperationException();\n", "    }\n", "\n", "    @Override\n", "    public void setPreviousEvictable(ReferenceEntry<K, V> previous) {\n", "      throw new UnsupportedOperationException();\n", "    }\n", "\n", "    // The code below is exactly the same for each entry type.\n", "\n", "    final int hash;\n", "    final ReferenceEntry<K, V> next;\n", "    volatile ValueReference<K, V> valueReference = unset();\n", "\n", "    @Override\n", "    public ValueReference<K, V> getValueReference() {\n", "      return valueReference;\n", "    }\n", "\n", "    @Override\n", "    public void setValueReference(ValueReference<K, V> valueReference) {\n", "      ValueReference<K, V> previous = this.valueReference;\n", "      this.valueReference = valueReference;\n", "      previous.clear(valueReference);\n", "    }\n", "\n", "    @Override\n", "    public int getHash() {\n", "      return hash;\n", "    }\n", "\n", "    @Override\n", "    public ReferenceEntry<K, V> getNext() {\n", "      return next;\n", "    }\n", "  }\n", "\n", "  static final class SoftExpirableEntry<K, V> extends SoftEntry<K, V>\n", "      implements ReferenceEntry<K, V> {\n", "    SoftExpirableEntry(\n", "        ReferenceQueue<K> queue, K key, int hash, @Nullable ReferenceEntry<K, V> next) {\n", "      super(queue, key, hash, next);\n", "    }\n", "\n", "    // The code below is exactly the same for each expirable entry type.\n", "\n", "    volatile long time = Long.MAX_VALUE;\n", "\n", "    @Override\n", "    public long getExpirationTime() {\n", "      return time;\n", "    }\n", "\n", "    @Override\n", "    public void setExpirationTime(long time) {\n", "      this.time = time;\n", "    }\n", "\n", "    // Guarded By Segment.this\n", "    ReferenceEntry<K, V> nextExpirable = nullEntry();\n", "\n", "    @Override\n", "    public ReferenceEntry<K, V> getNextExpirable() {\n", "      return nextExpirable;\n", "    }\n", "\n", "    @Override\n", "    public void setNextExpirable(ReferenceEntry<K, V> next) {\n", "      this.nextExpirable = next;\n", "    }\n", "\n", "    // Guarded By Segment.this\n", "    ReferenceEntry<K, V> previousExpirable = nullEntry();\n", "\n", "    @Override\n", "    public ReferenceEntry<K, V> getPreviousExpirable() {\n", "      return previousExpirable;\n", "    }\n", "\n", "    @Override\n", "    public void setPreviousExpirable(ReferenceEntry<K, V> previous) {\n", "      this.previousExpirable = previous;\n", "    }\n", "  }\n", "\n", "  static final class SoftEvictableEntry<K, V> extends SoftEntry<K, V>\n", "      implements ReferenceEntry<K, V> {\n", "    SoftEvictableEntry(\n", "        ReferenceQueue<K> queue, K key, int hash, @Nullable ReferenceEntry<K, V> next) {\n", "      super(queue, key, hash, next);\n", "    }\n", "\n", "    // The code below is exactly the same for each evictable entry type.\n", "\n", "    // Guarded By Segment.this\n", "    ReferenceEntry<K, V> nextEvictable = nullEntry();\n", "\n", "    @Override\n", "    public ReferenceEntry<K, V> getNextEvictable() {\n", "      return nextEvictable;\n", "    }\n", "\n", "    @Override\n", "    public void setNextEvictable(ReferenceEntry<K, V> next) {\n", "      this.nextEvictable = next;\n", "    }\n", "\n", "    // Guarded By Segment.this\n", "    ReferenceEntry<K, V> previousEvictable = nullEntry();\n", "\n", "    @Override\n", "    public ReferenceEntry<K, V> getPreviousEvictable() {\n", "      return previousEvictable;\n", "    }\n", "\n", "    @Override\n", "    public void setPreviousEvictable(ReferenceEntry<K, V> previous) {\n", "      this.previousEvictable = previous;\n", "    }\n", "  }\n", "\n", "  static final class SoftExpirableEvictableEntry<K, V> extends SoftEntry<K, V>\n", "      implements ReferenceEntry<K, V> {\n", "    SoftExpirableEvictableEntry(\n", "        ReferenceQueue<K> queue, K key, int hash, @Nullable ReferenceEntry<K, V> next) {\n", "      super(queue, key, hash, next);\n", "    }\n", "\n", "    // The code below is exactly the same for each expirable entry type.\n", "\n", "    volatile long time = Long.MAX_VALUE;\n", "\n", "    @Override\n", "    public long getExpirationTime() {\n", "      return time;\n", "    }\n", "\n", "    @Override\n", "    public void setExpirationTime(long time) {\n", "      this.time = time;\n", "    }\n", "\n", "    // Guarded By Segment.this\n", "    ReferenceEntry<K, V> nextExpirable = nullEntry();\n", "\n", "    @Override\n", "    public ReferenceEntry<K, V> getNextExpirable() {\n", "      return nextExpirable;\n", "    }\n", "\n", "    @Override\n", "    public void setNextExpirable(ReferenceEntry<K, V> next) {\n", "      this.nextExpirable = next;\n", "    }\n", "\n", "    // Guarded By Segment.this\n", "    ReferenceEntry<K, V> previousExpirable = nullEntry();\n", "\n", "    @Override\n", "    public ReferenceEntry<K, V> getPreviousExpirable() {\n", "      return previousExpirable;\n", "    }\n", "\n", "    @Override\n", "    public void setPreviousExpirable(ReferenceEntry<K, V> previous) {\n", "      this.previousExpirable = previous;\n", "    }\n", "\n", "    // The code below is exactly the same for each evictable entry type.\n", "\n", "    // Guarded By Segment.this\n", "    ReferenceEntry<K, V> nextEvictable = nullEntry();\n", "\n", "    @Override\n", "    public ReferenceEntry<K, V> getNextEvictable() {\n", "      return nextEvictable;\n", "    }\n", "\n", "    @Override\n", "    public void setNextEvictable(ReferenceEntry<K, V> next) {\n", "      this.nextEvictable = next;\n", "    }\n", "\n", "    // Guarded By Segment.this\n", "    ReferenceEntry<K, V> previousEvictable = nullEntry();\n", "\n", "    @Override\n", "    public ReferenceEntry<K, V> getPreviousEvictable() {\n", "      return previousEvictable;\n", "    }\n", "\n", "    @Override\n", "    public void setPreviousEvictable(ReferenceEntry<K, V> previous) {\n", "      this.previousEvictable = previous;\n", "    }\n", "  }\n", "\n", "  /**\n", "   * Used for weakly-referenced keys.\n", "   */\n", "  static class WeakEntry<K, V> extends WeakReference<K> implements ReferenceEntry<K, V> {\n", "    WeakEntry(ReferenceQueue<K> queue, K key, int hash, @Nullable ReferenceEntry<K, V> next) {\n", "      super(key, queue);\n", "      this.hash = hash;\n", "      this.next = next;\n", "    }\n", "\n", "    @Override\n", "    public K getKey() {\n", "      return get();\n", "    }\n", "\n", "    // null expiration\n", "\n", "    @Override\n", "    public long getExpirationTime() {\n", "      throw new UnsupportedOperationException();\n", "    }\n", "\n", "    @Override\n", "    public void setExpirationTime(long time) {\n", "      throw new UnsupportedOperationException();\n", "    }\n", "\n", "    @Override\n", "    public ReferenceEntry<K, V> getNextExpirable() {\n", "      throw new UnsupportedOperationException();\n", "    }\n", "\n", "    @Override\n", "    public void setNextExpirable(ReferenceEntry<K, V> next) {\n", "      throw new UnsupportedOperationException();\n", "    }\n", "\n", "    @Override\n", "    public ReferenceEntry<K, V> getPreviousExpirable() {\n", "      throw new UnsupportedOperationException();\n", "    }\n", "\n", "    @Override\n", "    public void setPreviousExpirable(ReferenceEntry<K, V> previous) {\n", "      throw new UnsupportedOperationException();\n", "    }\n", "\n", "    // null eviction\n", "\n", "    @Override\n", "    public ReferenceEntry<K, V> getNextEvictable() {\n", "      throw new UnsupportedOperationException();\n", "    }\n", "\n", "    @Override\n", "    public void setNextEvictable(ReferenceEntry<K, V> next) {\n", "      throw new UnsupportedOperationException();\n", "    }\n", "\n", "    @Override\n", "    public ReferenceEntry<K, V> getPreviousEvictable() {\n", "      throw new UnsupportedOperationException();\n", "    }\n", "\n", "    @Override\n", "    public void setPreviousEvictable(ReferenceEntry<K, V> previous) {\n", "      throw new UnsupportedOperationException();\n", "    }\n", "\n", "    // The code below is exactly the same for each entry type.\n", "\n", "    final int hash;\n", "    final ReferenceEntry<K, V> next;\n", "    volatile ValueReference<K, V> valueReference = unset();\n", "\n", "    @Override\n", "    public ValueReference<K, V> getValueReference() {\n", "      return valueReference;\n", "    }\n", "\n", "    @Override\n", "    public void setValueReference(ValueReference<K, V> valueReference) {\n", "      ValueReference<K, V> previous = this.valueReference;\n", "      this.valueReference = valueReference;\n", "      previous.clear(valueReference);\n", "    }\n", "\n", "    @Override\n", "    public int getHash() {\n", "      return hash;\n", "    }\n", "\n", "    @Override\n", "    public ReferenceEntry<K, V> getNext() {\n", "      return next;\n", "    }\n", "  }\n", "\n", "  static final class WeakExpirableEntry<K, V> extends WeakEntry<K, V>\n", "      implements ReferenceEntry<K, V> {\n", "    WeakExpirableEntry(\n", "        ReferenceQueue<K> queue, K key, int hash, @Nullable ReferenceEntry<K, V> next) {\n", "      super(queue, key, hash, next);\n", "    }\n", "    // The code below is exactly the same for each expirable entry type.\n", "    volatile long time = Long.MAX_VALUE;\n", "    @Override\n", "    public long getExpirationTime() {\n", "      return time;\n", "    }\n", "    public void setExpirationTime(long time) {\n", "      this.time = time;\n", "    // Guarded By Segment.this\n", "    ReferenceEntry<K, V> nextExpirable = nullEntry();\n", "\n", "    public ReferenceEntry<K, V> getNextExpirable() {\n", "      return nextExpirable;\n", "    }\n", "    public void setNextExpirable(ReferenceEntry<K, V> next) {\n", "      this.nextExpirable = next;\n", "    // Guarded By Segment.this\n", "    ReferenceEntry<K, V> previousExpirable = nullEntry();\n", "\n", "    public ReferenceEntry<K, V> getPreviousExpirable() {\n", "      return previousExpirable;\n", "    public void setPreviousExpirable(ReferenceEntry<K, V> previous) {\n", "      this.previousExpirable = previous;\n", "  static final class WeakEvictableEntry<K, V> extends WeakEntry<K, V>\n", "      implements ReferenceEntry<K, V> {\n", "    WeakEvictableEntry(\n", "        ReferenceQueue<K> queue, K key, int hash, @Nullable ReferenceEntry<K, V> next) {\n", "      super(queue, key, hash, next);\n", "    // The code below is exactly the same for each evictable entry type.\n", "\n", "    // Guarded By Segment.this\n", "    ReferenceEntry<K, V> nextEvictable = nullEntry();\n", "\n", "    public ReferenceEntry<K, V> getNextEvictable() {\n", "      return nextEvictable;\n", "    public void setNextEvictable(ReferenceEntry<K, V> next) {\n", "      this.nextEvictable = next;\n", "    // Guarded By Segment.this\n", "    ReferenceEntry<K, V> previousEvictable = nullEntry();\n", "\n", "    public ReferenceEntry<K, V> getPreviousEvictable() {\n", "      return previousEvictable;\n", "    public void setPreviousEvictable(ReferenceEntry<K, V> previous) {\n", "      this.previousEvictable = previous;\n", "  static final class WeakExpirableEvictableEntry<K, V> extends WeakEntry<K, V>\n", "      implements ReferenceEntry<K, V> {\n", "    WeakExpirableEvictableEntry(\n", "        ReferenceQueue<K> queue, K key, int hash, @Nullable ReferenceEntry<K, V> next) {\n", "      super(queue, key, hash, next);\n", "    }\n", "    // The code below is exactly the same for each expirable entry type.\n", "    volatile long time = Long.MAX_VALUE;\n", "    @Override\n", "    public long getExpirationTime() {\n", "      return time;\n", "    public void setExpirationTime(long time) {\n", "      this.time = time;\n", "    // Guarded By Segment.this\n", "    ReferenceEntry<K, V> nextExpirable = nullEntry();\n", "    public ReferenceEntry<K, V> getNextExpirable() {\n", "      return nextExpirable;\n", "    public void setNextExpirable(ReferenceEntry<K, V> next) {\n", "      this.nextExpirable = next;\n", "    // Guarded By Segment.this\n", "    ReferenceEntry<K, V> previousExpirable = nullEntry();\n", "    public ReferenceEntry<K, V> getPreviousExpirable() {\n", "      return previousExpirable;\n", "    public void setPreviousExpirable(ReferenceEntry<K, V> previous) {\n", "      this.previousExpirable = previous;\n", "    // The code below is exactly the same for each evictable entry type.\n", "    // Guarded By Segment.this\n", "    ReferenceEntry<K, V> nextEvictable = nullEntry();\n", "    public ReferenceEntry<K, V> getNextEvictable() {\n", "      return nextEvictable;\n", "    public void setNextEvictable(ReferenceEntry<K, V> next) {\n", "      this.nextEvictable = next;\n", "    // Guarded By Segment.this\n", "    ReferenceEntry<K, V> previousEvictable = nullEntry();\n", "\n", "    public ReferenceEntry<K, V> getPreviousEvictable() {\n", "      return previousEvictable;\n", "    public void setPreviousEvictable(ReferenceEntry<K, V> previous) {\n", "      this.previousEvictable = previous;\n"], "12": ["   * partially-collected, computing, or expired. Unlike {@link Segment#getLiveValue} this method\n"], "13": ["\n", "    if (expires() && isExpired(entry)) {\n", "      return null;\n", "    }\n", "  // expiration\n", "\n", "  /**\n", "   * Returns {@code true} if the entry has expired.\n", "   */\n", "  boolean isExpired(ReferenceEntry<K, V> entry) {\n", "    return isExpired(entry, ticker.read());\n", "  }\n", "\n", "  /**\n", "   * Returns {@code true} if the entry has expired.\n", "   */\n", "  boolean isExpired(ReferenceEntry<K, V> entry, long now) {\n", "    // if the expiration time had overflowed, this \"undoes\" the overflow\n", "    return now - entry.getExpirationTime() > 0;\n", "  }\n", "\n", "  // Guarded By Segment.this\n", "  static <K, V> void connectExpirables(ReferenceEntry<K, V> previous, ReferenceEntry<K, V> next) {\n", "    previous.setNextExpirable(next);\n", "    next.setPreviousExpirable(previous);\n", "  }\n", "\n", "  // Guarded By Segment.this\n", "  static <K, V> void nullifyExpirable(ReferenceEntry<K, V> nulled) {\n", "    ReferenceEntry<K, V> nullEntry = nullEntry();\n", "    nulled.setNextExpirable(nullEntry);\n", "    nulled.setPreviousExpirable(nullEntry);\n", "  }\n", "\n", "  // eviction\n", "\n", "  /** Links the evitables together. */\n", "  // Guarded By Segment.this\n", "  static <K, V> void connectEvictables(ReferenceEntry<K, V> previous, ReferenceEntry<K, V> next) {\n", "    previous.setNextEvictable(next);\n", "    next.setPreviousEvictable(previous);\n", "  }\n", "\n", "  // Guarded By Segment.this\n", "  static <K, V> void nullifyEvictable(ReferenceEntry<K, V> nulled) {\n", "    ReferenceEntry<K, V> nullEntry = nullEntry();\n", "    nulled.setNextEvictable(nullEntry);\n", "    nulled.setPreviousEvictable(nullEntry);\n", "  }\n", "\n"], "14": ["    /*\n", "     * TODO(fry): Consider copying variables (like evictsBySize) from outer class into this class.\n", "     * It will require more memory but will reduce indirection.\n", "     */\n", "\n"], "15": ["    /**\n", "     * A queue of elements currently in the map, ordered by expiration time (write time).\n", "     * Elements are added to the tail of the queue on write.\n", "     */\n", "    @GuardedBy(\"this\")\n", "    final Queue<ReferenceEntry<K, V>> expirationQueue;\n", "\n"], "16": ["\n", "      expirationQueue =\n", "          map.expires()\n", "              ? new ExpirationQueue<K, V>()\n", "              : MapMakerInternalMap.<ReferenceEntry<K, V>>discardingQueue();\n"], "17": ["     * Sets a new value of an entry. Adds newly created entries at the end of the expiration queue.\n", "      recordWrite(entry);\n"], "18": ["    // recency queue, shared by expiration and eviction\n", "\n", "    /**\n", "     * Updates eviction metadata that {@code entry} was just written. This currently amounts to\n", "     * adding {@code entry} to relevant eviction lists.\n", "     */\n", "    @GuardedBy(\"this\")\n", "    void recordWrite(ReferenceEntry<K, V> entry) {\n", "      if (map.expires()) {\n", "        long expiration = map.expireAfterWriteNanos;\n", "        recordExpirationTime(entry, expiration);\n", "        expirationQueue.add(entry);\n", "      }\n", "    }\n", "\n", "    // expiration\n", "\n", "    void recordExpirationTime(ReferenceEntry<K, V> entry, long expirationNanos) {\n", "      // might overflow, but that's okay (see isExpired())\n", "      entry.setExpirationTime(map.ticker.read() + expirationNanos);\n", "    }\n", "\n", "    /**\n", "     * Cleanup expired entries when the lock is available.\n", "     */\n", "    void tryExpireEntries() {\n", "      if (tryLock()) {\n", "        try {\n", "          expireEntries();\n", "        } finally {\n", "          unlock();\n", "        }\n", "      }\n", "    }\n", "\n", "    @GuardedBy(\"this\")\n", "    void expireEntries() {\n", "\n", "      if (expirationQueue.isEmpty()) {\n", "        // There's no point in calling nanoTime() if we have no entries to\n", "        // expire.\n", "        return;\n", "      }\n", "      long now = map.ticker.read();\n", "      ReferenceEntry<K, V> e;\n", "      while ((e = expirationQueue.peek()) != null && map.isExpired(e, now)) {\n", "        if (!removeEntry(e, e.getHash())) {\n", "          throw new AssertionError();\n", "        }\n", "      }\n", "    }\n", "\n"], "19": ["      } else if (map.expires() && map.isExpired(e)) {\n", "        tryExpireEntries();\n", "        return null;\n"], "20": ["                removeCollectedEntry(e);\n"], "21": ["          expirationQueue.clear();\n"], "22": ["      expirationQueue.remove(entry);\n", "\n"], "23": ["          removeCollectedEntry(e);\n"], "24": ["    void removeCollectedEntry(ReferenceEntry<K, V> entry) {\n", "      expirationQueue.remove(entry);\n", "    }\n", "\n"], "25": ["     * partially-collected, computing, or expired.\n"], "26": ["      if (map.expires() && map.isExpired(entry)) {\n", "        tryExpireEntries();\n", "        return null;\n", "      }\n"], "27": ["     *\n", "     * <p>Post-condition: expireEntries has been run.\n"], "28": ["          expireEntries();\n"], "29": ["  // Queues\n", "\n", "  /**\n", "   * A custom queue for managing expiration order. Note that this is tightly integrated with\n", "   * {@code ReferenceEntry}, upon which it reliese to perform its linking.\n", "   *\n", "   * <p>Note that this entire implementation makes the assumption that all elements which are in\n", "   * the map are also in this queue, and that all elements not in the queue are not in the map.\n", "   *\n", "   * <p>The benefits of creating our own queue are that (1) we can replace elements in the middle\n", "   * of the queue as part of copyEvictableEntry, and (2) the contains method is highly optimized\n", "   * for the current model.\n", "   */\n", "  static final class ExpirationQueue<K, V> extends AbstractQueue<ReferenceEntry<K, V>> {\n", "    final ReferenceEntry<K, V> head =\n", "        new AbstractReferenceEntry<K, V>() {\n", "\n", "          @Override\n", "          public long getExpirationTime() {\n", "            return Long.MAX_VALUE;\n", "          }\n", "\n", "          @Override\n", "          public void setExpirationTime(long time) {}\n", "\n", "          ReferenceEntry<K, V> nextExpirable = this;\n", "\n", "          @Override\n", "          public ReferenceEntry<K, V> getNextExpirable() {\n", "            return nextExpirable;\n", "          }\n", "\n", "          @Override\n", "          public void setNextExpirable(ReferenceEntry<K, V> next) {\n", "            this.nextExpirable = next;\n", "          }\n", "\n", "          ReferenceEntry<K, V> previousExpirable = this;\n", "\n", "          @Override\n", "          public ReferenceEntry<K, V> getPreviousExpirable() {\n", "            return previousExpirable;\n", "          }\n", "\n", "          @Override\n", "          public void setPreviousExpirable(ReferenceEntry<K, V> previous) {\n", "            this.previousExpirable = previous;\n", "          }\n", "        };\n", "\n", "    // implements Queue\n", "\n", "    @Override\n", "    public boolean offer(ReferenceEntry<K, V> entry) {\n", "      // unlink\n", "      connectExpirables(entry.getPreviousExpirable(), entry.getNextExpirable());\n", "\n", "      // add to tail\n", "      connectExpirables(head.getPreviousExpirable(), entry);\n", "      connectExpirables(entry, head);\n", "\n", "      return true;\n", "    }\n", "\n", "    @Override\n", "    public ReferenceEntry<K, V> peek() {\n", "      ReferenceEntry<K, V> next = head.getNextExpirable();\n", "      return (next == head) ? null : next;\n", "    }\n", "\n", "    @Override\n", "    public ReferenceEntry<K, V> poll() {\n", "      ReferenceEntry<K, V> next = head.getNextExpirable();\n", "      if (next == head) {\n", "        return null;\n", "      }\n", "\n", "      remove(next);\n", "      return next;\n", "    }\n", "\n", "    @CanIgnoreReturnValue\n", "    @Override\n", "    @SuppressWarnings(\"unchecked\")\n", "    public boolean remove(Object o) {\n", "      ReferenceEntry<K, V> e = (ReferenceEntry) o;\n", "      ReferenceEntry<K, V> previous = e.getPreviousExpirable();\n", "      ReferenceEntry<K, V> next = e.getNextExpirable();\n", "      connectExpirables(previous, next);\n", "      nullifyExpirable(e);\n", "\n", "      return next != NullEntry.INSTANCE;\n", "    }\n", "\n", "    @Override\n", "    @SuppressWarnings(\"unchecked\")\n", "    public boolean contains(Object o) {\n", "      ReferenceEntry<K, V> e = (ReferenceEntry) o;\n", "      return e.getNextExpirable() != NullEntry.INSTANCE;\n", "    }\n", "\n", "    @Override\n", "    public boolean isEmpty() {\n", "      return head.getNextExpirable() == head;\n", "    }\n", "\n", "    @Override\n", "    public int size() {\n", "      int size = 0;\n", "      for (ReferenceEntry<K, V> e = head.getNextExpirable(); e != head; e = e.getNextExpirable()) {\n", "        size++;\n", "      }\n", "      return size;\n", "    }\n", "\n", "    @Override\n", "    public void clear() {\n", "      ReferenceEntry<K, V> e = head.getNextExpirable();\n", "      while (e != head) {\n", "        ReferenceEntry<K, V> next = e.getNextExpirable();\n", "        nullifyExpirable(e);\n", "        e = next;\n", "      }\n", "\n", "      head.setNextExpirable(head);\n", "      head.setPreviousExpirable(head);\n", "    }\n", "\n", "    @Override\n", "    public Iterator<ReferenceEntry<K, V>> iterator() {\n", "      return new AbstractSequentialIterator<ReferenceEntry<K, V>>(peek()) {\n", "        @Override\n", "        protected ReferenceEntry<K, V> computeNext(ReferenceEntry<K, V> previous) {\n", "          ReferenceEntry<K, V> next = previous.getNextExpirable();\n", "          return (next == head) ? null : next;\n", "        }\n", "      };\n", "    }\n", "  }\n", "\n"], "30": ["   * Returns the internal entry for the specified key. The entry may be computing, expired, or\n"], "31": ["        expireAfterWriteNanos,\n"], "32": ["    final long expireAfterWriteNanos;\n"], "33": ["        long expireAfterWriteNanos,\n", "      this.expireAfterWriteNanos = expireAfterWriteNanos;\n"], "34": ["      MapMaker mapMaker =\n", "          new MapMaker()\n", "              .initialCapacity(size)\n", "              .setKeyStrength(keyStrength)\n", "              .setValueStrength(valueStrength)\n", "              .keyEquivalence(keyEquivalence)\n", "              .concurrencyLevel(concurrencyLevel);\n", "      if (expireAfterWriteNanos > 0) {\n", "        mapMaker.expireAfterWrite(expireAfterWriteNanos, TimeUnit.NANOSECONDS);\n", "      }\n", "      return mapMaker;\n"], "35": ["        long expireAfterWriteNanos,\n"], "36": ["          expireAfterWriteNanos,\n"]}, "added_lines": {"5": [172], "8": [291, 292, 293, 294, 295, 296, 297, 298, 299, 300], "11": [445, 447, 448, 449, 450, 452, 453, 454, 455, 456, 458, 459, 462, 463, 467, 470, 471, 475, 476, 480, 481, 485, 486, 487, 488, 492, 493, 497, 498, 502, 503, 507, 508, 512, 513, 514, 515, 517, 518, 519, 520, 521, 522, 523, 525, 526, 527, 528, 529, 531, 532, 533, 534, 538, 539, 542, 543, 544, 545, 546, 549, 550, 554, 555, 556, 557, 560, 561, 562, 563, 566, 567, 568, 569, 570, 571, 572, 573, 574, 575, 576, 577, 578, 582, 583, 586, 588, 589, 590, 593, 594, 598, 599, 600, 601, 605, 606, 610, 611], "12": [824], "17": [982], "25": [1654], "30": [1780], "34": [2329, 2330, 2331, 2332, 2333, 2334]}, "removed_lines": {"1": [23], "2": [39, 46, 51], "3": [79, 80, 81, 82], "4": [165, 166, 167, 171, 172, 173], "5": [186, 187, 188, 189], "6": [221, 222, 223, 224], "7": [303, 304, 305, 306, 307, 308, 309, 310, 311, 312, 313, 314, 315, 316, 317, 318, 319, 320, 321, 322, 323, 324, 325, 326, 327, 328, 329, 330, 331, 332, 333, 334, 335, 336, 337, 338, 339, 340, 341, 342, 343, 344, 345, 346, 347, 348], "8": [356, 357, 358, 359, 360, 361, 362, 363, 364, 365, 366, 367, 368, 369, 370, 371, 372, 373, 374, 375, 376, 377, 378, 379, 380, 381, 382, 383, 384, 385, 386, 387, 388, 389, 390, 391, 392, 393, 394, 395, 396, 397, 398, 399, 400, 401, 402, 403, 404, 405, 406, 407, 408, 409, 410, 411, 412, 413, 414, 415, 416, 419, 420, 421], "9": [446, 447, 448, 449, 450, 451, 452, 453, 454, 455, 456, 457, 458, 459, 460, 461, 462, 463, 464, 465, 466, 467], "10": [572], "11": [589, 590, 591, 592, 593, 594, 595, 596, 597, 598, 599, 600, 601, 602, 603, 604, 605, 606, 607, 608, 609, 610, 611, 612, 613, 614, 615, 616, 617, 618, 619, 620, 621, 622, 623, 624, 625, 626, 627, 628, 629, 630, 631, 632, 633, 634, 635, 636, 637, 638, 639, 640, 641, 642, 643, 644, 645, 646, 647, 648, 649, 650, 651, 652, 653, 654, 655, 656, 657, 658, 659, 660, 661, 662, 663, 664, 665, 666, 667, 668, 669, 670, 671, 672, 673, 674, 675, 676, 677, 678, 679, 680, 681, 682, 683, 684, 685, 686, 687, 688, 689, 690, 691, 692, 693, 694, 695, 696, 697, 698, 699, 700, 701, 702, 703, 704, 705, 706, 707, 708, 709, 710, 711, 712, 713, 714, 715, 716, 717, 718, 719, 720, 721, 722, 723, 724, 725, 726, 727, 728, 729, 730, 731, 732, 733, 734, 735, 736, 737, 738, 739, 740, 741, 742, 743, 744, 745, 746, 747, 748, 749, 750, 751, 752, 753, 754, 755, 756, 757, 758, 759, 760, 761, 762, 763, 764, 765, 766, 767, 768, 769, 770, 771, 772, 773, 774, 775, 776, 777, 778, 779, 780, 781, 782, 783, 784, 785, 786, 787, 788, 789, 790, 791, 792, 793, 794, 795, 796, 797, 798, 799, 800, 801, 802, 803, 804, 805, 806, 807, 808, 809, 810, 811, 812, 813, 814, 815, 816, 817, 818, 819, 820, 821, 822, 823, 824, 825, 826, 827, 828, 829, 830, 831, 832, 833, 834, 835, 836, 837, 838, 839, 840, 841, 842, 843, 844, 845, 846, 847, 848, 849, 850, 851, 852, 853, 854, 855, 856, 857, 858, 859, 860, 861, 862, 863, 864, 865, 866, 867, 868, 869, 870, 871, 872, 873, 874, 875, 876, 877, 878, 879, 880, 881, 882, 883, 884, 885, 886, 887, 888, 889, 890, 891, 892, 893, 894, 895, 896, 897, 898, 899, 900, 901, 902, 903, 904, 905, 906, 907, 908, 909, 910, 911, 912, 913, 914, 915, 916, 917, 918, 919, 920, 921, 922, 923, 924, 925, 926, 927, 928, 929, 930, 931, 932, 933, 934, 935, 936, 937, 938, 939, 940, 941, 942, 943, 944, 945, 946, 947, 948, 949, 950, 951, 952, 953, 954, 955, 956, 957, 958, 959, 960, 961, 962, 963, 964, 965, 966, 967, 968, 969, 970, 971, 972, 973, 974, 975, 976, 977, 978, 979, 980, 981, 982, 983, 984, 985, 986, 987, 988, 989, 990, 991, 992, 993, 994, 995, 996, 997, 998, 999, 1000, 1001, 1002, 1003, 1004, 1005, 1006, 1007, 1008, 1009, 1010, 1011, 1012, 1013, 1014, 1015, 1016, 1017, 1018, 1019, 1020, 1021, 1022, 1023, 1024, 1025, 1026, 1027, 1028, 1029, 1030, 1031, 1032, 1033, 1034, 1035, 1036, 1037, 1038, 1039, 1040, 1041, 1042, 1043, 1044, 1045, 1046, 1047, 1048, 1049, 1050, 1051, 1052, 1053, 1054, 1055, 1056, 1057, 1058, 1059, 1060, 1061, 1062, 1063, 1064, 1065, 1066, 1067, 1068, 1069, 1070, 1071, 1072, 1073, 1074, 1075, 1076, 1077, 1078, 1079, 1080, 1081, 1082, 1083, 1084, 1085, 1086, 1087, 1088, 1089, 1090, 1091, 1092, 1093, 1094, 1095, 1096, 1097, 1098, 1099, 1100, 1101, 1102, 1103, 1104, 1105, 1106, 1107, 1108, 1109, 1110, 1111, 1112, 1113, 1114, 1115, 1116, 1117, 1118, 1119, 1120, 1121, 1122, 1123, 1124, 1125, 1126, 1127, 1128, 1129, 1130, 1131, 1132, 1133, 1134, 1135, 1136, 1137, 1138, 1139, 1140, 1141, 1142, 1143, 1144, 1145, 1146, 1147, 1148, 1149, 1150, 1151, 1152, 1153, 1154, 1155, 1156, 1157, 1158, 1159, 1160, 1161, 1162, 1163, 1164, 1165, 1166, 1167, 1168, 1169, 1170, 1171, 1172, 1173, 1174, 1175, 1176, 1177, 1178, 1179, 1180, 1181, 1182, 1183, 1184, 1185, 1186, 1187, 1188, 1189, 1190, 1191, 1192, 1193, 1194, 1195, 1196, 1197, 1198, 1199, 1200, 1201, 1202, 1203, 1204, 1205, 1206, 1207, 1208, 1209, 1210, 1211, 1212, 1213, 1214, 1215, 1216, 1217, 1218, 1219, 1220, 1221, 1222, 1223, 1224, 1225, 1226, 1227, 1228, 1229, 1230, 1231, 1232, 1233, 1234, 1235, 1236, 1237, 1238, 1239, 1240, 1241, 1242, 1243, 1244, 1245, 1246, 1247, 1248, 1249, 1250, 1251, 1252, 1253, 1254, 1255, 1256, 1257, 1258, 1259, 1260, 1261, 1262, 1263, 1264, 1265, 1266, 1267, 1268, 1269, 1270, 1271, 1272, 1273, 1274, 1275, 1276, 1277, 1278, 1279, 1280, 1281, 1282, 1283, 1284, 1285, 1286, 1287, 1288, 1289, 1290, 1291, 1292, 1293, 1294, 1295, 1296, 1297, 1298, 1299, 1300, 1301, 1302, 1303, 1304, 1305, 1306, 1307, 1308, 1309, 1310, 1311, 1312, 1313, 1314, 1315, 1316, 1317, 1318, 1319, 1320, 1321, 1322, 1323, 1324, 1325, 1326, 1327, 1328, 1329, 1330, 1331, 1332, 1333, 1334, 1335, 1336, 1337, 1338, 1339, 1340, 1341, 1342, 1343, 1344, 1345, 1346, 1347, 1348, 1349, 1350, 1351, 1352, 1353, 1354, 1355, 1356, 1357, 1358, 1359, 1360, 1361, 1362, 1363, 1364, 1365, 1366, 1367, 1368, 1369, 1370, 1371, 1372, 1373, 1374, 1375, 1376, 1377, 1378, 1379, 1380, 1381, 1382, 1383, 1384, 1385, 1386, 1387, 1388, 1389, 1390, 1391, 1392, 1393, 1394, 1395, 1396, 1397, 1398, 1399, 1400, 1401, 1402, 1403, 1404, 1405, 1406, 1407, 1408, 1409, 1410, 1411, 1412, 1413, 1414, 1415, 1416, 1417, 1418, 1419, 1420, 1421, 1422, 1423, 1424, 1425, 1426, 1427, 1428, 1429, 1430, 1431, 1432, 1433, 1434, 1435, 1436, 1437, 1438, 1439, 1440, 1441, 1442, 1443, 1444, 1445, 1446, 1447, 1448, 1449, 1450, 1451, 1452, 1453, 1454, 1455, 1456, 1457, 1458, 1459, 1460, 1461, 1462, 1463, 1464, 1465, 1466, 1467, 1468, 1469, 1470, 1471, 1472, 1473, 1474, 1476, 1478, 1480, 1481, 1482, 1483, 1486, 1487, 1490, 1491, 1492, 1494, 1495, 1496, 1499, 1500, 1503, 1504, 1505, 1507, 1508, 1512, 1513, 1517, 1518, 1519, 1520, 1521, 1524, 1525, 1526, 1527, 1528, 1530, 1531, 1535, 1536, 1539, 1540, 1541, 1543, 1544, 1548, 1549, 1553, 1554, 1555, 1556, 1557, 1558, 1560, 1562, 1564, 1565, 1566, 1570, 1571, 1574, 1575, 1578, 1579, 1583, 1584, 1587, 1588, 1591, 1592, 1596, 1597, 1600, 1602, 1603, 1606, 1607, 1611, 1612, 1615, 1616, 1617, 1619, 1620, 1624, 1625], "12": [1838], "13": [1849, 1850, 1851, 1852, 1856, 1857, 1858, 1859, 1860, 1861, 1862, 1863, 1864, 1865, 1866, 1867, 1868, 1869, 1870, 1871, 1872, 1873, 1874, 1875, 1876, 1877, 1878, 1879, 1880, 1881, 1882, 1883, 1884, 1885, 1886, 1887, 1888, 1889, 1890, 1891, 1892, 1893, 1894, 1895, 1896, 1897, 1898, 1899, 1900, 1901], "14": [1916, 1917, 1918, 1919, 1920], "15": [1999, 2000, 2001, 2002, 2003, 2004, 2005], "16": [2014, 2015, 2016, 2017, 2018], "17": [2063, 2069], "18": [2149, 2150, 2151, 2152, 2153, 2154, 2155, 2156, 2157, 2158, 2159, 2160, 2161, 2162, 2163, 2164, 2165, 2166, 2167, 2168, 2169, 2170, 2171, 2172, 2173, 2174, 2175, 2176, 2177, 2178, 2179, 2180, 2181, 2182, 2183, 2184, 2185, 2186, 2187, 2188, 2189, 2190, 2191, 2192, 2193, 2194, 2195, 2196, 2197, 2198, 2199, 2200], "19": [2238, 2239, 2240], "20": [2428], "21": [2622], "22": [2647, 2648], "23": [2656], "24": [2664, 2665, 2666, 2667], "25": [2800], "26": [2813, 2814, 2815, 2816], "27": [2834, 2835], "28": [2850], "29": [2859, 2860, 2861, 2862, 2863, 2864, 2865, 2866, 2867, 2868, 2869, 2870, 2871, 2872, 2873, 2874, 2875, 2876, 2877, 2878, 2879, 2880, 2881, 2882, 2883, 2884, 2885, 2886, 2887, 2888, 2889, 2890, 2891, 2892, 2893, 2894, 2895, 2896, 2897, 2898, 2899, 2900, 2901, 2902, 2903, 2904, 2905, 2906, 2907, 2908, 2909, 2910, 2911, 2912, 2913, 2914, 2915, 2916, 2917, 2918, 2919, 2920, 2921, 2922, 2923, 2924, 2925, 2926, 2927, 2928, 2929, 2930, 2931, 2932, 2933, 2934, 2935, 2936, 2937, 2938, 2939, 2940, 2941, 2942, 2943, 2944, 2945, 2946, 2947, 2948, 2949, 2950, 2951, 2952, 2953, 2954, 2955, 2956, 2957, 2958, 2959, 2960, 2961, 2962, 2963, 2964, 2965, 2966, 2967, 2968, 2969, 2970, 2971, 2972, 2973, 2974, 2975, 2976, 2977, 2978, 2979, 2980, 2981, 2982, 2983, 2984, 2985, 2986, 2987, 2988, 2989, 2990, 2991, 2992, 2993, 2994, 2995, 2996, 2997, 2998], "30": [3073], "31": [3570], "32": [3587], "33": [3597, 3604], "34": [3626, 3627, 3628, 3629, 3630, 3631, 3632, 3633, 3634, 3635, 3636], "35": [3664], "36": [3672]}}]}
