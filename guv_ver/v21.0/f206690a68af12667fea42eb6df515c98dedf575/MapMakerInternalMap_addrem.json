{
    "addition": {
        "172": "    entryFactory = EntryFactory.getFactory(keyStrength);\n",
        "291": "    static EntryFactory getFactory(Strength keyStrength) {\n",
        "292": "      switch (keyStrength) {\n",
        "293": "        case STRONG:\n",
        "294": "          return EntryFactory.STRONG;\n",
        "295": "        case WEAK:\n",
        "296": "          return EntryFactory.WEAK;\n",
        "297": "        case SOFT:\n",
        "298": "          throw new IllegalArgumentException();\n",
        "299": "      }\n",
        "300": "      throw new AssertionError();\n",
        "445": "    ReferenceEntry<K, V> getNext();\n",
        "447": "    /**\n",
        "448": "     * Gets the entry's hash.\n",
        "449": "     */\n",
        "450": "    int getHash();\n",
        "452": "    /**\n",
        "453": "     * Gets the key for this entry.\n",
        "454": "     */\n",
        "455": "    K getKey();\n",
        "456": "  }\n",
        "458": "  private enum NullEntry implements ReferenceEntry<Object, Object> {\n",
        "459": "    INSTANCE;\n",
        "462": "    public ValueReference<Object, Object> getValueReference() {\n",
        "463": "      return null;\n",
        "467": "    public void setValueReference(ValueReference<Object, Object> valueReference) {}\n",
        "470": "    public ReferenceEntry<Object, Object> getNext() {\n",
        "471": "      return null;\n",
        "475": "    public int getHash() {\n",
        "476": "      return 0;\n",
        "480": "    public Object getKey() {\n",
        "481": "      return null;\n",
        "485": "  abstract static class AbstractReferenceEntry<K, V> implements ReferenceEntry<K, V> {\n",
        "486": "    @Override\n",
        "487": "    public ValueReference<K, V> getValueReference() {\n",
        "488": "      throw new UnsupportedOperationException();\n",
        "492": "    public void setValueReference(ValueReference<K, V> valueReference) {\n",
        "493": "      throw new UnsupportedOperationException();\n",
        "497": "    public ReferenceEntry<K, V> getNext() {\n",
        "498": "      throw new UnsupportedOperationException();\n",
        "502": "    public int getHash() {\n",
        "503": "      throw new UnsupportedOperationException();\n",
        "507": "    public K getKey() {\n",
        "508": "      throw new UnsupportedOperationException();\n",
        "512": "  @SuppressWarnings(\"unchecked\") // impl never uses a parameter or returns any non-null value\n",
        "513": "  static <K, V> ReferenceEntry<K, V> nullEntry() {\n",
        "514": "    return (ReferenceEntry<K, V>) NullEntry.INSTANCE;\n",
        "515": "  }\n",
        "517": "  /*\n",
        "518": "   * Note: All of this duplicate code sucks, but it saves a lot of memory. If only Java had mixins!\n",
        "519": "   * To maintain this code, make a change for the strong reference type. Then, cut and paste, and\n",
        "520": "   * replace \"Strong\" with \"Soft\" or \"Weak\" within the pasted text. The primary difference is that\n",
        "521": "   * strong entries store the key reference directly while soft and weak entries delegate to their\n",
        "522": "   * respective superclasses.\n",
        "523": "   */\n",
        "525": "  /**\n",
        "526": "   * Used for strongly-referenced keys.\n",
        "527": "   */\n",
        "528": "  static class StrongEntry<K, V> implements ReferenceEntry<K, V> {\n",
        "529": "    final K key;\n",
        "531": "    StrongEntry(K key, int hash, @Nullable ReferenceEntry<K, V> next) {\n",
        "532": "      this.key = key;\n",
        "533": "      this.hash = hash;\n",
        "534": "      this.next = next;\n",
        "538": "    public K getKey() {\n",
        "539": "      return this.key;\n",
        "542": "    // The code below is exactly the same for each entry type.\n",
        "543": "\n",
        "544": "    final int hash;\n",
        "545": "    final ReferenceEntry<K, V> next;\n",
        "546": "    volatile ValueReference<K, V> valueReference = unset();\n",
        "549": "    public ValueReference<K, V> getValueReference() {\n",
        "550": "      return valueReference;\n",
        "554": "    public void setValueReference(ValueReference<K, V> valueReference) {\n",
        "555": "      ValueReference<K, V> previous = this.valueReference;\n",
        "556": "      this.valueReference = valueReference;\n",
        "557": "      previous.clear(valueReference);\n",
        "560": "    @Override\n",
        "561": "    public int getHash() {\n",
        "562": "      return hash;\n",
        "563": "    }\n",
        "566": "    public ReferenceEntry<K, V> getNext() {\n",
        "567": "      return next;\n",
        "568": "    }\n",
        "569": "  }\n",
        "570": "\n",
        "571": "  /**\n",
        "572": "   * Used for weakly-referenced keys.\n",
        "573": "   */\n",
        "574": "  static class WeakEntry<K, V> extends WeakReference<K> implements ReferenceEntry<K, V> {\n",
        "575": "    WeakEntry(ReferenceQueue<K> queue, K key, int hash, @Nullable ReferenceEntry<K, V> next) {\n",
        "576": "      super(key, queue);\n",
        "577": "      this.hash = hash;\n",
        "578": "      this.next = next;\n",
        "582": "    public K getKey() {\n",
        "583": "      return get();\n",
        "586": "    // The code below is exactly the same for each entry type.\n",
        "588": "    final int hash;\n",
        "589": "    final ReferenceEntry<K, V> next;\n",
        "590": "    volatile ValueReference<K, V> valueReference = unset();\n",
        "593": "    public ValueReference<K, V> getValueReference() {\n",
        "594": "      return valueReference;\n",
        "598": "    public void setValueReference(ValueReference<K, V> valueReference) {\n",
        "599": "      ValueReference<K, V> previous = this.valueReference;\n",
        "600": "      this.valueReference = valueReference;\n",
        "601": "      previous.clear(valueReference);\n",
        "605": "    public int getHash() {\n",
        "606": "      return hash;\n",
        "610": "    public ReferenceEntry<K, V> getNext() {\n",
        "611": "      return next;\n",
        "824": "   * partially-collected or computing. Unlike {@link Segment#getLiveValue} this method\n",
        "982": "     * Sets a new value of an entry.\n",
        "1654": "     * partially-collected or computing.\n",
        "1780": "   * Returns the internal entry for the specified key. The entry may be computing or\n",
        "2329": "      return new MapMaker()\n",
        "2330": "          .initialCapacity(size)\n",
        "2331": "          .setKeyStrength(keyStrength)\n",
        "2332": "          .setValueStrength(valueStrength)\n",
        "2333": "          .keyEquivalence(keyEquivalence)\n",
        "2334": "          .concurrencyLevel(concurrencyLevel);\n"
    },
    "removed": {
        "23": "import com.google.common.base.Ticker;\n",
        "39": "import java.util.AbstractQueue;\n",
        "46": "import java.util.Queue;\n",
        "51": "import java.util.concurrent.TimeUnit;\n",
        "79": "   * If a maximum size is specified, a best-effort bounding is performed per segment, using a\n",
        "80": "   * page-replacement algorithm to determine which entries to evict when the capacity has been\n",
        "81": "   * exceeded.\n",
        "82": "   *\n",
        "165": "  /** How long after the last write to an entry the map will retain that entry. */\n",
        "166": "  final long expireAfterWriteNanos;\n",
        "167": "\n",
        "171": "  /** Measures time in a testable way. */\n",
        "172": "  final Ticker ticker;\n",
        "173": "\n",
        "186": "    expireAfterWriteNanos = builder.getExpireAfterWriteNanos();\n",
        "187": "\n",
        "188": "    entryFactory = EntryFactory.getFactory(keyStrength, expires());\n",
        "189": "    ticker = builder.getTicker();\n",
        "221": "  boolean expires() {\n",
        "222": "    return expireAfterWriteNanos > 0;\n",
        "223": "  }\n",
        "224": "\n",
        "303": "    STRONG_EXPIRABLE {\n",
        "304": "      @Override\n",
        "305": "      <K, V> ReferenceEntry<K, V> newEntry(\n",
        "306": "          Segment<K, V> segment, K key, int hash, @Nullable ReferenceEntry<K, V> next) {\n",
        "307": "        return new StrongExpirableEntry<K, V>(key, hash, next);\n",
        "308": "      }\n",
        "309": "\n",
        "310": "      @Override\n",
        "311": "      <K, V> ReferenceEntry<K, V> copyEntry(\n",
        "312": "          Segment<K, V> segment, ReferenceEntry<K, V> original, ReferenceEntry<K, V> newNext) {\n",
        "313": "        ReferenceEntry<K, V> newEntry = super.copyEntry(segment, original, newNext);\n",
        "314": "        copyExpirableEntry(original, newEntry);\n",
        "315": "        return newEntry;\n",
        "316": "      }\n",
        "317": "    },\n",
        "318": "    STRONG_EVICTABLE {\n",
        "319": "      @Override\n",
        "320": "      <K, V> ReferenceEntry<K, V> newEntry(\n",
        "321": "          Segment<K, V> segment, K key, int hash, @Nullable ReferenceEntry<K, V> next) {\n",
        "322": "        return new StrongEvictableEntry<K, V>(key, hash, next);\n",
        "323": "      }\n",
        "324": "\n",
        "325": "      @Override\n",
        "326": "      <K, V> ReferenceEntry<K, V> copyEntry(\n",
        "327": "          Segment<K, V> segment, ReferenceEntry<K, V> original, ReferenceEntry<K, V> newNext) {\n",
        "328": "        ReferenceEntry<K, V> newEntry = super.copyEntry(segment, original, newNext);\n",
        "329": "        copyEvictableEntry(original, newEntry);\n",
        "330": "        return newEntry;\n",
        "331": "      }\n",
        "332": "    },\n",
        "333": "    STRONG_EXPIRABLE_EVICTABLE {\n",
        "334": "      @Override\n",
        "335": "      <K, V> ReferenceEntry<K, V> newEntry(\n",
        "336": "          Segment<K, V> segment, K key, int hash, @Nullable ReferenceEntry<K, V> next) {\n",
        "337": "        return new StrongExpirableEvictableEntry<K, V>(key, hash, next);\n",
        "338": "      }\n",
        "339": "\n",
        "340": "      @Override\n",
        "341": "      <K, V> ReferenceEntry<K, V> copyEntry(\n",
        "342": "          Segment<K, V> segment, ReferenceEntry<K, V> original, ReferenceEntry<K, V> newNext) {\n",
        "343": "        ReferenceEntry<K, V> newEntry = super.copyEntry(segment, original, newNext);\n",
        "344": "        copyExpirableEntry(original, newEntry);\n",
        "345": "        copyEvictableEntry(original, newEntry);\n",
        "346": "        return newEntry;\n",
        "347": "      }\n",
        "348": "    },\n",
        "356": "    },\n",
        "357": "    WEAK_EXPIRABLE {\n",
        "358": "      @Override\n",
        "359": "      <K, V> ReferenceEntry<K, V> newEntry(\n",
        "360": "          Segment<K, V> segment, K key, int hash, @Nullable ReferenceEntry<K, V> next) {\n",
        "361": "        return new WeakExpirableEntry<K, V>(segment.keyReferenceQueue, key, hash, next);\n",
        "362": "      }\n",
        "363": "\n",
        "364": "      @Override\n",
        "365": "      <K, V> ReferenceEntry<K, V> copyEntry(\n",
        "366": "          Segment<K, V> segment, ReferenceEntry<K, V> original, ReferenceEntry<K, V> newNext) {\n",
        "367": "        ReferenceEntry<K, V> newEntry = super.copyEntry(segment, original, newNext);\n",
        "368": "        copyExpirableEntry(original, newEntry);\n",
        "369": "        return newEntry;\n",
        "370": "      }\n",
        "371": "    },\n",
        "372": "    WEAK_EVICTABLE {\n",
        "373": "      @Override\n",
        "374": "      <K, V> ReferenceEntry<K, V> newEntry(\n",
        "375": "          Segment<K, V> segment, K key, int hash, @Nullable ReferenceEntry<K, V> next) {\n",
        "376": "        return new WeakEvictableEntry<K, V>(segment.keyReferenceQueue, key, hash, next);\n",
        "377": "      }\n",
        "378": "\n",
        "379": "      @Override\n",
        "380": "      <K, V> ReferenceEntry<K, V> copyEntry(\n",
        "381": "          Segment<K, V> segment, ReferenceEntry<K, V> original, ReferenceEntry<K, V> newNext) {\n",
        "382": "        ReferenceEntry<K, V> newEntry = super.copyEntry(segment, original, newNext);\n",
        "383": "        copyEvictableEntry(original, newEntry);\n",
        "384": "        return newEntry;\n",
        "385": "      }\n",
        "386": "    },\n",
        "387": "    WEAK_EXPIRABLE_EVICTABLE {\n",
        "388": "      @Override\n",
        "389": "      <K, V> ReferenceEntry<K, V> newEntry(\n",
        "390": "          Segment<K, V> segment, K key, int hash, @Nullable ReferenceEntry<K, V> next) {\n",
        "391": "        return new WeakExpirableEvictableEntry<K, V>(segment.keyReferenceQueue, key, hash, next);\n",
        "392": "      }\n",
        "393": "\n",
        "394": "      @Override\n",
        "395": "      <K, V> ReferenceEntry<K, V> copyEntry(\n",
        "396": "          Segment<K, V> segment, ReferenceEntry<K, V> original, ReferenceEntry<K, V> newNext) {\n",
        "397": "        ReferenceEntry<K, V> newEntry = super.copyEntry(segment, original, newNext);\n",
        "398": "        copyExpirableEntry(original, newEntry);\n",
        "399": "        copyEvictableEntry(original, newEntry);\n",
        "400": "        return newEntry;\n",
        "401": "      }\n",
        "402": "    };\n",
        "403": "\n",
        "404": "    /**\n",
        "405": "     * Masks used to compute indices in the following table.\n",
        "406": "     */\n",
        "407": "    static final int EXPIRABLE_MASK = 1;\n",
        "408": "\n",
        "409": "    /**\n",
        "410": "     * Look-up table for factories. First dimension is the reference type. The second dimension is\n",
        "411": "     * the result of OR-ing the feature masks.\n",
        "412": "     */\n",
        "413": "    static final EntryFactory[][] factories = {\n",
        "414": "      {STRONG, STRONG_EXPIRABLE, STRONG_EVICTABLE, STRONG_EXPIRABLE_EVICTABLE},\n",
        "415": "      {}, // no support for SOFT keys\n",
        "416": "      {WEAK, WEAK_EXPIRABLE, WEAK_EVICTABLE, WEAK_EXPIRABLE_EVICTABLE}\n",
        "419": "    static EntryFactory getFactory(Strength keyStrength, boolean expireAfterWrite) {\n",
        "420": "      int flags = (expireAfterWrite ? EXPIRABLE_MASK : 0) | 0;\n",
        "421": "      return factories[keyStrength.ordinal()][flags];\n",
        "446": "\n",
        "447": "    // Guarded By Segment.this\n",
        "448": "    <K, V> void copyExpirableEntry(ReferenceEntry<K, V> original, ReferenceEntry<K, V> newEntry) {\n",
        "449": "      // TODO(fry): when we link values instead of entries this method can go\n",
        "450": "      // away, as can connectExpirables, nullifyExpirable.\n",
        "451": "      newEntry.setExpirationTime(original.getExpirationTime());\n",
        "452": "\n",
        "453": "      connectExpirables(original.getPreviousExpirable(), newEntry);\n",
        "454": "      connectExpirables(newEntry, original.getNextExpirable());\n",
        "455": "\n",
        "456": "      nullifyExpirable(original);\n",
        "457": "    }\n",
        "458": "\n",
        "459": "    // Guarded By Segment.this\n",
        "460": "    <K, V> void copyEvictableEntry(ReferenceEntry<K, V> original, ReferenceEntry<K, V> newEntry) {\n",
        "461": "      // TODO(fry): when we link values instead of entries this method can go\n",
        "462": "      // away, as can connectEvictables, nullifyEvictable.\n",
        "463": "      connectEvictables(original.getPreviousEvictable(), newEntry);\n",
        "464": "      connectEvictables(newEntry, original.getNextEvictable());\n",
        "465": "\n",
        "466": "      nullifyEvictable(original);\n",
        "467": "    }\n",
        "572": "   * - Expired: time expired (key/value may still be set)\n",
        "589": "    ReferenceEntry<K, V> getNext();\n",
        "590": "\n",
        "591": "    /**\n",
        "592": "     * Gets the entry's hash.\n",
        "593": "     */\n",
        "594": "    int getHash();\n",
        "595": "\n",
        "596": "    /**\n",
        "597": "     * Gets the key for this entry.\n",
        "598": "     */\n",
        "599": "    K getKey();\n",
        "600": "\n",
        "601": "    /*\n",
        "602": "     * Used by entries that are expirable. Expirable entries are maintained in a doubly-linked list.\n",
        "603": "     * New entries are added at the tail of the list at write time; stale entries are expired from\n",
        "604": "     * the head of the list.\n",
        "605": "     */\n",
        "606": "\n",
        "607": "    /**\n",
        "608": "     * Gets the entry expiration time in ns.\n",
        "609": "     */\n",
        "610": "    long getExpirationTime();\n",
        "611": "\n",
        "612": "    /**\n",
        "613": "     * Sets the entry expiration time in ns.\n",
        "614": "     */\n",
        "615": "    void setExpirationTime(long time);\n",
        "616": "\n",
        "617": "    /**\n",
        "618": "     * Gets the next entry in the recency list.\n",
        "619": "     */\n",
        "620": "    ReferenceEntry<K, V> getNextExpirable();\n",
        "621": "\n",
        "622": "    /**\n",
        "623": "     * Sets the next entry in the recency list.\n",
        "624": "     */\n",
        "625": "    void setNextExpirable(ReferenceEntry<K, V> next);\n",
        "626": "\n",
        "627": "    /**\n",
        "628": "     * Gets the previous entry in the recency list.\n",
        "629": "     */\n",
        "630": "    ReferenceEntry<K, V> getPreviousExpirable();\n",
        "631": "\n",
        "632": "    /**\n",
        "633": "     * Sets the previous entry in the recency list.\n",
        "634": "     */\n",
        "635": "    void setPreviousExpirable(ReferenceEntry<K, V> previous);\n",
        "636": "\n",
        "637": "    /*\n",
        "638": "     * Implemented by entries that are evictable. Evictable entries are maintained in a\n",
        "639": "     * doubly-linked list. New entries are added at the tail of the list at write time and stale\n",
        "640": "     * entries are expired from the head of the list.\n",
        "641": "     */\n",
        "642": "\n",
        "643": "    /**\n",
        "644": "     * Gets the next entry in the recency list.\n",
        "645": "     */\n",
        "646": "    ReferenceEntry<K, V> getNextEvictable();\n",
        "647": "\n",
        "648": "    /**\n",
        "649": "     * Sets the next entry in the recency list.\n",
        "650": "     */\n",
        "651": "    void setNextEvictable(ReferenceEntry<K, V> next);\n",
        "652": "\n",
        "653": "    /**\n",
        "654": "     * Gets the previous entry in the recency list.\n",
        "655": "     */\n",
        "656": "    ReferenceEntry<K, V> getPreviousEvictable();\n",
        "657": "\n",
        "658": "    /**\n",
        "659": "     * Sets the previous entry in the recency list.\n",
        "660": "     */\n",
        "661": "    void setPreviousEvictable(ReferenceEntry<K, V> previous);\n",
        "662": "  }\n",
        "663": "\n",
        "664": "  private enum NullEntry implements ReferenceEntry<Object, Object> {\n",
        "665": "    INSTANCE;\n",
        "666": "\n",
        "667": "    @Override\n",
        "668": "    public ValueReference<Object, Object> getValueReference() {\n",
        "669": "      return null;\n",
        "670": "    }\n",
        "671": "\n",
        "672": "    @Override\n",
        "673": "    public void setValueReference(ValueReference<Object, Object> valueReference) {}\n",
        "674": "\n",
        "675": "    @Override\n",
        "676": "    public ReferenceEntry<Object, Object> getNext() {\n",
        "677": "      return null;\n",
        "678": "    }\n",
        "679": "\n",
        "680": "    @Override\n",
        "681": "    public int getHash() {\n",
        "682": "      return 0;\n",
        "683": "    }\n",
        "684": "\n",
        "685": "    @Override\n",
        "686": "    public Object getKey() {\n",
        "687": "      return null;\n",
        "688": "    }\n",
        "689": "\n",
        "690": "    @Override\n",
        "691": "    public long getExpirationTime() {\n",
        "692": "      return 0;\n",
        "693": "    }\n",
        "694": "\n",
        "695": "    @Override\n",
        "696": "    public void setExpirationTime(long time) {}\n",
        "697": "\n",
        "698": "    @Override\n",
        "699": "    public ReferenceEntry<Object, Object> getNextExpirable() {\n",
        "700": "      return this;\n",
        "701": "    }\n",
        "702": "\n",
        "703": "    @Override\n",
        "704": "    public void setNextExpirable(ReferenceEntry<Object, Object> next) {}\n",
        "705": "\n",
        "706": "    @Override\n",
        "707": "    public ReferenceEntry<Object, Object> getPreviousExpirable() {\n",
        "708": "      return this;\n",
        "709": "    }\n",
        "710": "\n",
        "711": "    @Override\n",
        "712": "    public void setPreviousExpirable(ReferenceEntry<Object, Object> previous) {}\n",
        "713": "\n",
        "714": "    @Override\n",
        "715": "    public ReferenceEntry<Object, Object> getNextEvictable() {\n",
        "716": "      return this;\n",
        "717": "    }\n",
        "718": "\n",
        "719": "    @Override\n",
        "720": "    public void setNextEvictable(ReferenceEntry<Object, Object> next) {}\n",
        "721": "\n",
        "722": "    @Override\n",
        "723": "    public ReferenceEntry<Object, Object> getPreviousEvictable() {\n",
        "724": "      return this;\n",
        "725": "    }\n",
        "726": "\n",
        "727": "    @Override\n",
        "728": "    public void setPreviousEvictable(ReferenceEntry<Object, Object> previous) {}\n",
        "729": "  }\n",
        "730": "\n",
        "731": "  abstract static class AbstractReferenceEntry<K, V> implements ReferenceEntry<K, V> {\n",
        "732": "    @Override\n",
        "733": "    public ValueReference<K, V> getValueReference() {\n",
        "734": "      throw new UnsupportedOperationException();\n",
        "735": "    }\n",
        "736": "\n",
        "737": "    @Override\n",
        "738": "    public void setValueReference(ValueReference<K, V> valueReference) {\n",
        "739": "      throw new UnsupportedOperationException();\n",
        "740": "    }\n",
        "741": "\n",
        "742": "    @Override\n",
        "743": "    public ReferenceEntry<K, V> getNext() {\n",
        "744": "      throw new UnsupportedOperationException();\n",
        "745": "    }\n",
        "746": "\n",
        "747": "    @Override\n",
        "748": "    public int getHash() {\n",
        "749": "      throw new UnsupportedOperationException();\n",
        "750": "    }\n",
        "751": "\n",
        "752": "    @Override\n",
        "753": "    public K getKey() {\n",
        "754": "      throw new UnsupportedOperationException();\n",
        "755": "    }\n",
        "756": "\n",
        "757": "    @Override\n",
        "758": "    public long getExpirationTime() {\n",
        "759": "      throw new UnsupportedOperationException();\n",
        "760": "    }\n",
        "761": "\n",
        "762": "    @Override\n",
        "763": "    public void setExpirationTime(long time) {\n",
        "764": "      throw new UnsupportedOperationException();\n",
        "765": "    }\n",
        "766": "\n",
        "767": "    @Override\n",
        "768": "    public ReferenceEntry<K, V> getNextExpirable() {\n",
        "769": "      throw new UnsupportedOperationException();\n",
        "770": "    }\n",
        "771": "\n",
        "772": "    @Override\n",
        "773": "    public void setNextExpirable(ReferenceEntry<K, V> next) {\n",
        "774": "      throw new UnsupportedOperationException();\n",
        "775": "    }\n",
        "776": "\n",
        "777": "    @Override\n",
        "778": "    public ReferenceEntry<K, V> getPreviousExpirable() {\n",
        "779": "      throw new UnsupportedOperationException();\n",
        "780": "    }\n",
        "781": "\n",
        "782": "    @Override\n",
        "783": "    public void setPreviousExpirable(ReferenceEntry<K, V> previous) {\n",
        "784": "      throw new UnsupportedOperationException();\n",
        "785": "    }\n",
        "786": "\n",
        "787": "    @Override\n",
        "788": "    public ReferenceEntry<K, V> getNextEvictable() {\n",
        "789": "      throw new UnsupportedOperationException();\n",
        "790": "    }\n",
        "791": "\n",
        "792": "    @Override\n",
        "793": "    public void setNextEvictable(ReferenceEntry<K, V> next) {\n",
        "794": "      throw new UnsupportedOperationException();\n",
        "795": "    }\n",
        "796": "\n",
        "797": "    @Override\n",
        "798": "    public ReferenceEntry<K, V> getPreviousEvictable() {\n",
        "799": "      throw new UnsupportedOperationException();\n",
        "800": "    }\n",
        "801": "\n",
        "802": "    @Override\n",
        "803": "    public void setPreviousEvictable(ReferenceEntry<K, V> previous) {\n",
        "804": "      throw new UnsupportedOperationException();\n",
        "805": "    }\n",
        "806": "  }\n",
        "807": "\n",
        "808": "  @SuppressWarnings(\"unchecked\") // impl never uses a parameter or returns any non-null value\n",
        "809": "  static <K, V> ReferenceEntry<K, V> nullEntry() {\n",
        "810": "    return (ReferenceEntry<K, V>) NullEntry.INSTANCE;\n",
        "811": "  }\n",
        "812": "\n",
        "813": "  static final Queue<? extends Object> DISCARDING_QUEUE =\n",
        "814": "      new AbstractQueue<Object>() {\n",
        "815": "        @Override\n",
        "816": "        public boolean offer(Object o) {\n",
        "817": "          return true;\n",
        "818": "        }\n",
        "819": "\n",
        "820": "        @Override\n",
        "821": "        public Object peek() {\n",
        "822": "          return null;\n",
        "823": "        }\n",
        "824": "\n",
        "825": "        @Override\n",
        "826": "        public Object poll() {\n",
        "827": "          return null;\n",
        "828": "        }\n",
        "829": "\n",
        "830": "        @Override\n",
        "831": "        public int size() {\n",
        "832": "          return 0;\n",
        "833": "        }\n",
        "834": "\n",
        "835": "        @Override\n",
        "836": "        public Iterator<Object> iterator() {\n",
        "837": "          return Iterators.emptyIterator();\n",
        "838": "        }\n",
        "839": "      };\n",
        "840": "\n",
        "841": "  /**\n",
        "842": "   * Queue that discards all elements.\n",
        "843": "   */\n",
        "844": "  @SuppressWarnings(\"unchecked\") // impl never uses a parameter or returns any non-null value\n",
        "845": "  static <E> Queue<E> discardingQueue() {\n",
        "846": "    return (Queue) DISCARDING_QUEUE;\n",
        "847": "  }\n",
        "848": "\n",
        "849": "  /*\n",
        "850": "   * Note: All of this duplicate code sucks, but it saves a lot of memory. If only Java had mixins!\n",
        "851": "   * To maintain this code, make a change for the strong reference type. Then, cut and paste, and\n",
        "852": "   * replace \"Strong\" with \"Soft\" or \"Weak\" within the pasted text. The primary difference is that\n",
        "853": "   * strong entries store the key reference directly while soft and weak entries delegate to their\n",
        "854": "   * respective superclasses.\n",
        "855": "   */\n",
        "856": "\n",
        "857": "  /**\n",
        "858": "   * Used for strongly-referenced keys.\n",
        "859": "   */\n",
        "860": "  static class StrongEntry<K, V> implements ReferenceEntry<K, V> {\n",
        "861": "    final K key;\n",
        "862": "\n",
        "863": "    StrongEntry(K key, int hash, @Nullable ReferenceEntry<K, V> next) {\n",
        "864": "      this.key = key;\n",
        "865": "      this.hash = hash;\n",
        "866": "      this.next = next;\n",
        "867": "    }\n",
        "868": "\n",
        "869": "    @Override\n",
        "870": "    public K getKey() {\n",
        "871": "      return this.key;\n",
        "872": "    }\n",
        "873": "\n",
        "874": "    // null expiration\n",
        "875": "\n",
        "876": "    @Override\n",
        "877": "    public long getExpirationTime() {\n",
        "878": "      throw new UnsupportedOperationException();\n",
        "879": "    }\n",
        "880": "\n",
        "881": "    @Override\n",
        "882": "    public void setExpirationTime(long time) {\n",
        "883": "      throw new UnsupportedOperationException();\n",
        "884": "    }\n",
        "885": "\n",
        "886": "    @Override\n",
        "887": "    public ReferenceEntry<K, V> getNextExpirable() {\n",
        "888": "      throw new UnsupportedOperationException();\n",
        "889": "    }\n",
        "890": "\n",
        "891": "    @Override\n",
        "892": "    public void setNextExpirable(ReferenceEntry<K, V> next) {\n",
        "893": "      throw new UnsupportedOperationException();\n",
        "894": "    }\n",
        "895": "\n",
        "896": "    @Override\n",
        "897": "    public ReferenceEntry<K, V> getPreviousExpirable() {\n",
        "898": "      throw new UnsupportedOperationException();\n",
        "899": "    }\n",
        "900": "\n",
        "901": "    @Override\n",
        "902": "    public void setPreviousExpirable(ReferenceEntry<K, V> previous) {\n",
        "903": "      throw new UnsupportedOperationException();\n",
        "904": "    }\n",
        "905": "\n",
        "906": "    // null eviction\n",
        "907": "\n",
        "908": "    @Override\n",
        "909": "    public ReferenceEntry<K, V> getNextEvictable() {\n",
        "910": "      throw new UnsupportedOperationException();\n",
        "911": "    }\n",
        "912": "\n",
        "913": "    @Override\n",
        "914": "    public void setNextEvictable(ReferenceEntry<K, V> next) {\n",
        "915": "      throw new UnsupportedOperationException();\n",
        "916": "    }\n",
        "917": "\n",
        "918": "    @Override\n",
        "919": "    public ReferenceEntry<K, V> getPreviousEvictable() {\n",
        "920": "      throw new UnsupportedOperationException();\n",
        "921": "    }\n",
        "922": "\n",
        "923": "    @Override\n",
        "924": "    public void setPreviousEvictable(ReferenceEntry<K, V> previous) {\n",
        "925": "      throw new UnsupportedOperationException();\n",
        "926": "    }\n",
        "927": "\n",
        "928": "    // The code below is exactly the same for each entry type.\n",
        "929": "\n",
        "930": "    final int hash;\n",
        "931": "    final ReferenceEntry<K, V> next;\n",
        "932": "    volatile ValueReference<K, V> valueReference = unset();\n",
        "933": "\n",
        "934": "    @Override\n",
        "935": "    public ValueReference<K, V> getValueReference() {\n",
        "936": "      return valueReference;\n",
        "937": "    }\n",
        "938": "\n",
        "939": "    @Override\n",
        "940": "    public void setValueReference(ValueReference<K, V> valueReference) {\n",
        "941": "      ValueReference<K, V> previous = this.valueReference;\n",
        "942": "      this.valueReference = valueReference;\n",
        "943": "      previous.clear(valueReference);\n",
        "944": "    }\n",
        "945": "\n",
        "946": "    @Override\n",
        "947": "    public int getHash() {\n",
        "948": "      return hash;\n",
        "949": "    }\n",
        "950": "\n",
        "951": "    @Override\n",
        "952": "    public ReferenceEntry<K, V> getNext() {\n",
        "953": "      return next;\n",
        "954": "    }\n",
        "955": "  }\n",
        "956": "\n",
        "957": "  static final class StrongExpirableEntry<K, V> extends StrongEntry<K, V>\n",
        "958": "      implements ReferenceEntry<K, V> {\n",
        "959": "    StrongExpirableEntry(K key, int hash, @Nullable ReferenceEntry<K, V> next) {\n",
        "960": "      super(key, hash, next);\n",
        "961": "    }\n",
        "962": "\n",
        "963": "    // The code below is exactly the same for each expirable entry type.\n",
        "964": "\n",
        "965": "    volatile long time = Long.MAX_VALUE;\n",
        "966": "\n",
        "967": "    @Override\n",
        "968": "    public long getExpirationTime() {\n",
        "969": "      return time;\n",
        "970": "    }\n",
        "971": "\n",
        "972": "    @Override\n",
        "973": "    public void setExpirationTime(long time) {\n",
        "974": "      this.time = time;\n",
        "975": "    }\n",
        "976": "\n",
        "977": "    // Guarded By Segment.this\n",
        "978": "    ReferenceEntry<K, V> nextExpirable = nullEntry();\n",
        "979": "\n",
        "980": "    @Override\n",
        "981": "    public ReferenceEntry<K, V> getNextExpirable() {\n",
        "982": "      return nextExpirable;\n",
        "983": "    }\n",
        "984": "\n",
        "985": "    @Override\n",
        "986": "    public void setNextExpirable(ReferenceEntry<K, V> next) {\n",
        "987": "      this.nextExpirable = next;\n",
        "988": "    }\n",
        "989": "\n",
        "990": "    // Guarded By Segment.this\n",
        "991": "    ReferenceEntry<K, V> previousExpirable = nullEntry();\n",
        "992": "\n",
        "993": "    @Override\n",
        "994": "    public ReferenceEntry<K, V> getPreviousExpirable() {\n",
        "995": "      return previousExpirable;\n",
        "996": "    }\n",
        "997": "\n",
        "998": "    @Override\n",
        "999": "    public void setPreviousExpirable(ReferenceEntry<K, V> previous) {\n",
        "1000": "      this.previousExpirable = previous;\n",
        "1001": "    }\n",
        "1002": "  }\n",
        "1003": "\n",
        "1004": "  static final class StrongEvictableEntry<K, V> extends StrongEntry<K, V>\n",
        "1005": "      implements ReferenceEntry<K, V> {\n",
        "1006": "    StrongEvictableEntry(K key, int hash, @Nullable ReferenceEntry<K, V> next) {\n",
        "1007": "      super(key, hash, next);\n",
        "1008": "    }\n",
        "1009": "\n",
        "1010": "    // The code below is exactly the same for each evictable entry type.\n",
        "1011": "\n",
        "1012": "    // Guarded By Segment.this\n",
        "1013": "    ReferenceEntry<K, V> nextEvictable = nullEntry();\n",
        "1014": "\n",
        "1015": "    @Override\n",
        "1016": "    public ReferenceEntry<K, V> getNextEvictable() {\n",
        "1017": "      return nextEvictable;\n",
        "1018": "    }\n",
        "1019": "\n",
        "1020": "    @Override\n",
        "1021": "    public void setNextEvictable(ReferenceEntry<K, V> next) {\n",
        "1022": "      this.nextEvictable = next;\n",
        "1023": "    }\n",
        "1024": "\n",
        "1025": "    // Guarded By Segment.this\n",
        "1026": "    ReferenceEntry<K, V> previousEvictable = nullEntry();\n",
        "1027": "\n",
        "1028": "    @Override\n",
        "1029": "    public ReferenceEntry<K, V> getPreviousEvictable() {\n",
        "1030": "      return previousEvictable;\n",
        "1031": "    }\n",
        "1032": "\n",
        "1033": "    @Override\n",
        "1034": "    public void setPreviousEvictable(ReferenceEntry<K, V> previous) {\n",
        "1035": "      this.previousEvictable = previous;\n",
        "1036": "    }\n",
        "1037": "  }\n",
        "1038": "\n",
        "1039": "  static final class StrongExpirableEvictableEntry<K, V> extends StrongEntry<K, V>\n",
        "1040": "      implements ReferenceEntry<K, V> {\n",
        "1041": "    StrongExpirableEvictableEntry(K key, int hash, @Nullable ReferenceEntry<K, V> next) {\n",
        "1042": "      super(key, hash, next);\n",
        "1043": "    }\n",
        "1044": "\n",
        "1045": "    // The code below is exactly the same for each expirable entry type.\n",
        "1046": "\n",
        "1047": "    volatile long time = Long.MAX_VALUE;\n",
        "1048": "\n",
        "1049": "    @Override\n",
        "1050": "    public long getExpirationTime() {\n",
        "1051": "      return time;\n",
        "1052": "    }\n",
        "1053": "\n",
        "1054": "    @Override\n",
        "1055": "    public void setExpirationTime(long time) {\n",
        "1056": "      this.time = time;\n",
        "1057": "    }\n",
        "1058": "\n",
        "1059": "    // Guarded By Segment.this\n",
        "1060": "    ReferenceEntry<K, V> nextExpirable = nullEntry();\n",
        "1061": "\n",
        "1062": "    @Override\n",
        "1063": "    public ReferenceEntry<K, V> getNextExpirable() {\n",
        "1064": "      return nextExpirable;\n",
        "1065": "    }\n",
        "1066": "\n",
        "1067": "    @Override\n",
        "1068": "    public void setNextExpirable(ReferenceEntry<K, V> next) {\n",
        "1069": "      this.nextExpirable = next;\n",
        "1070": "    }\n",
        "1071": "\n",
        "1072": "    // Guarded By Segment.this\n",
        "1073": "    ReferenceEntry<K, V> previousExpirable = nullEntry();\n",
        "1074": "\n",
        "1075": "    @Override\n",
        "1076": "    public ReferenceEntry<K, V> getPreviousExpirable() {\n",
        "1077": "      return previousExpirable;\n",
        "1078": "    }\n",
        "1079": "\n",
        "1080": "    @Override\n",
        "1081": "    public void setPreviousExpirable(ReferenceEntry<K, V> previous) {\n",
        "1082": "      this.previousExpirable = previous;\n",
        "1083": "    }\n",
        "1084": "\n",
        "1085": "    // The code below is exactly the same for each evictable entry type.\n",
        "1086": "\n",
        "1087": "    // Guarded By Segment.this\n",
        "1088": "    ReferenceEntry<K, V> nextEvictable = nullEntry();\n",
        "1089": "\n",
        "1090": "    @Override\n",
        "1091": "    public ReferenceEntry<K, V> getNextEvictable() {\n",
        "1092": "      return nextEvictable;\n",
        "1093": "    }\n",
        "1094": "\n",
        "1095": "    @Override\n",
        "1096": "    public void setNextEvictable(ReferenceEntry<K, V> next) {\n",
        "1097": "      this.nextEvictable = next;\n",
        "1098": "    }\n",
        "1099": "\n",
        "1100": "    // Guarded By Segment.this\n",
        "1101": "    ReferenceEntry<K, V> previousEvictable = nullEntry();\n",
        "1102": "\n",
        "1103": "    @Override\n",
        "1104": "    public ReferenceEntry<K, V> getPreviousEvictable() {\n",
        "1105": "      return previousEvictable;\n",
        "1106": "    }\n",
        "1107": "\n",
        "1108": "    @Override\n",
        "1109": "    public void setPreviousEvictable(ReferenceEntry<K, V> previous) {\n",
        "1110": "      this.previousEvictable = previous;\n",
        "1111": "    }\n",
        "1112": "  }\n",
        "1113": "\n",
        "1114": "  /**\n",
        "1115": "   * Used for softly-referenced keys.\n",
        "1116": "   */\n",
        "1117": "  static class SoftEntry<K, V> extends SoftReference<K> implements ReferenceEntry<K, V> {\n",
        "1118": "    SoftEntry(ReferenceQueue<K> queue, K key, int hash, @Nullable ReferenceEntry<K, V> next) {\n",
        "1119": "      super(key, queue);\n",
        "1120": "      this.hash = hash;\n",
        "1121": "      this.next = next;\n",
        "1122": "    }\n",
        "1123": "\n",
        "1124": "    @Override\n",
        "1125": "    public K getKey() {\n",
        "1126": "      return get();\n",
        "1127": "    }\n",
        "1128": "\n",
        "1129": "    // null expiration\n",
        "1130": "    @Override\n",
        "1131": "    public long getExpirationTime() {\n",
        "1132": "      throw new UnsupportedOperationException();\n",
        "1133": "    }\n",
        "1134": "\n",
        "1135": "    @Override\n",
        "1136": "    public void setExpirationTime(long time) {\n",
        "1137": "      throw new UnsupportedOperationException();\n",
        "1138": "    }\n",
        "1139": "\n",
        "1140": "    @Override\n",
        "1141": "    public ReferenceEntry<K, V> getNextExpirable() {\n",
        "1142": "      throw new UnsupportedOperationException();\n",
        "1143": "    }\n",
        "1144": "\n",
        "1145": "    @Override\n",
        "1146": "    public void setNextExpirable(ReferenceEntry<K, V> next) {\n",
        "1147": "      throw new UnsupportedOperationException();\n",
        "1148": "    }\n",
        "1149": "\n",
        "1150": "    @Override\n",
        "1151": "    public ReferenceEntry<K, V> getPreviousExpirable() {\n",
        "1152": "      throw new UnsupportedOperationException();\n",
        "1153": "    }\n",
        "1154": "\n",
        "1155": "    @Override\n",
        "1156": "    public void setPreviousExpirable(ReferenceEntry<K, V> previous) {\n",
        "1157": "      throw new UnsupportedOperationException();\n",
        "1158": "    }\n",
        "1159": "\n",
        "1160": "    // null eviction\n",
        "1161": "\n",
        "1162": "    @Override\n",
        "1163": "    public ReferenceEntry<K, V> getNextEvictable() {\n",
        "1164": "      throw new UnsupportedOperationException();\n",
        "1165": "    }\n",
        "1166": "\n",
        "1167": "    @Override\n",
        "1168": "    public void setNextEvictable(ReferenceEntry<K, V> next) {\n",
        "1169": "      throw new UnsupportedOperationException();\n",
        "1170": "    }\n",
        "1171": "\n",
        "1172": "    @Override\n",
        "1173": "    public ReferenceEntry<K, V> getPreviousEvictable() {\n",
        "1174": "      throw new UnsupportedOperationException();\n",
        "1175": "    }\n",
        "1176": "\n",
        "1177": "    @Override\n",
        "1178": "    public void setPreviousEvictable(ReferenceEntry<K, V> previous) {\n",
        "1179": "      throw new UnsupportedOperationException();\n",
        "1180": "    }\n",
        "1181": "\n",
        "1182": "    // The code below is exactly the same for each entry type.\n",
        "1183": "\n",
        "1184": "    final int hash;\n",
        "1185": "    final ReferenceEntry<K, V> next;\n",
        "1186": "    volatile ValueReference<K, V> valueReference = unset();\n",
        "1187": "\n",
        "1188": "    @Override\n",
        "1189": "    public ValueReference<K, V> getValueReference() {\n",
        "1190": "      return valueReference;\n",
        "1191": "    }\n",
        "1192": "\n",
        "1193": "    @Override\n",
        "1194": "    public void setValueReference(ValueReference<K, V> valueReference) {\n",
        "1195": "      ValueReference<K, V> previous = this.valueReference;\n",
        "1196": "      this.valueReference = valueReference;\n",
        "1197": "      previous.clear(valueReference);\n",
        "1198": "    }\n",
        "1199": "\n",
        "1200": "    @Override\n",
        "1201": "    public int getHash() {\n",
        "1202": "      return hash;\n",
        "1203": "    }\n",
        "1204": "\n",
        "1205": "    @Override\n",
        "1206": "    public ReferenceEntry<K, V> getNext() {\n",
        "1207": "      return next;\n",
        "1208": "    }\n",
        "1209": "  }\n",
        "1210": "\n",
        "1211": "  static final class SoftExpirableEntry<K, V> extends SoftEntry<K, V>\n",
        "1212": "      implements ReferenceEntry<K, V> {\n",
        "1213": "    SoftExpirableEntry(\n",
        "1214": "        ReferenceQueue<K> queue, K key, int hash, @Nullable ReferenceEntry<K, V> next) {\n",
        "1215": "      super(queue, key, hash, next);\n",
        "1216": "    }\n",
        "1217": "\n",
        "1218": "    // The code below is exactly the same for each expirable entry type.\n",
        "1219": "\n",
        "1220": "    volatile long time = Long.MAX_VALUE;\n",
        "1221": "\n",
        "1222": "    @Override\n",
        "1223": "    public long getExpirationTime() {\n",
        "1224": "      return time;\n",
        "1225": "    }\n",
        "1226": "\n",
        "1227": "    @Override\n",
        "1228": "    public void setExpirationTime(long time) {\n",
        "1229": "      this.time = time;\n",
        "1230": "    }\n",
        "1231": "\n",
        "1232": "    // Guarded By Segment.this\n",
        "1233": "    ReferenceEntry<K, V> nextExpirable = nullEntry();\n",
        "1234": "\n",
        "1235": "    @Override\n",
        "1236": "    public ReferenceEntry<K, V> getNextExpirable() {\n",
        "1237": "      return nextExpirable;\n",
        "1238": "    }\n",
        "1239": "\n",
        "1240": "    @Override\n",
        "1241": "    public void setNextExpirable(ReferenceEntry<K, V> next) {\n",
        "1242": "      this.nextExpirable = next;\n",
        "1243": "    }\n",
        "1244": "\n",
        "1245": "    // Guarded By Segment.this\n",
        "1246": "    ReferenceEntry<K, V> previousExpirable = nullEntry();\n",
        "1247": "\n",
        "1248": "    @Override\n",
        "1249": "    public ReferenceEntry<K, V> getPreviousExpirable() {\n",
        "1250": "      return previousExpirable;\n",
        "1251": "    }\n",
        "1252": "\n",
        "1253": "    @Override\n",
        "1254": "    public void setPreviousExpirable(ReferenceEntry<K, V> previous) {\n",
        "1255": "      this.previousExpirable = previous;\n",
        "1256": "    }\n",
        "1257": "  }\n",
        "1258": "\n",
        "1259": "  static final class SoftEvictableEntry<K, V> extends SoftEntry<K, V>\n",
        "1260": "      implements ReferenceEntry<K, V> {\n",
        "1261": "    SoftEvictableEntry(\n",
        "1262": "        ReferenceQueue<K> queue, K key, int hash, @Nullable ReferenceEntry<K, V> next) {\n",
        "1263": "      super(queue, key, hash, next);\n",
        "1264": "    }\n",
        "1265": "\n",
        "1266": "    // The code below is exactly the same for each evictable entry type.\n",
        "1267": "\n",
        "1268": "    // Guarded By Segment.this\n",
        "1269": "    ReferenceEntry<K, V> nextEvictable = nullEntry();\n",
        "1270": "\n",
        "1271": "    @Override\n",
        "1272": "    public ReferenceEntry<K, V> getNextEvictable() {\n",
        "1273": "      return nextEvictable;\n",
        "1274": "    }\n",
        "1275": "\n",
        "1276": "    @Override\n",
        "1277": "    public void setNextEvictable(ReferenceEntry<K, V> next) {\n",
        "1278": "      this.nextEvictable = next;\n",
        "1279": "    }\n",
        "1280": "\n",
        "1281": "    // Guarded By Segment.this\n",
        "1282": "    ReferenceEntry<K, V> previousEvictable = nullEntry();\n",
        "1283": "\n",
        "1284": "    @Override\n",
        "1285": "    public ReferenceEntry<K, V> getPreviousEvictable() {\n",
        "1286": "      return previousEvictable;\n",
        "1287": "    }\n",
        "1288": "\n",
        "1289": "    @Override\n",
        "1290": "    public void setPreviousEvictable(ReferenceEntry<K, V> previous) {\n",
        "1291": "      this.previousEvictable = previous;\n",
        "1292": "    }\n",
        "1293": "  }\n",
        "1294": "\n",
        "1295": "  static final class SoftExpirableEvictableEntry<K, V> extends SoftEntry<K, V>\n",
        "1296": "      implements ReferenceEntry<K, V> {\n",
        "1297": "    SoftExpirableEvictableEntry(\n",
        "1298": "        ReferenceQueue<K> queue, K key, int hash, @Nullable ReferenceEntry<K, V> next) {\n",
        "1299": "      super(queue, key, hash, next);\n",
        "1300": "    }\n",
        "1301": "\n",
        "1302": "    // The code below is exactly the same for each expirable entry type.\n",
        "1303": "\n",
        "1304": "    volatile long time = Long.MAX_VALUE;\n",
        "1305": "\n",
        "1306": "    @Override\n",
        "1307": "    public long getExpirationTime() {\n",
        "1308": "      return time;\n",
        "1309": "    }\n",
        "1310": "\n",
        "1311": "    @Override\n",
        "1312": "    public void setExpirationTime(long time) {\n",
        "1313": "      this.time = time;\n",
        "1314": "    }\n",
        "1315": "\n",
        "1316": "    // Guarded By Segment.this\n",
        "1317": "    ReferenceEntry<K, V> nextExpirable = nullEntry();\n",
        "1318": "\n",
        "1319": "    @Override\n",
        "1320": "    public ReferenceEntry<K, V> getNextExpirable() {\n",
        "1321": "      return nextExpirable;\n",
        "1322": "    }\n",
        "1323": "\n",
        "1324": "    @Override\n",
        "1325": "    public void setNextExpirable(ReferenceEntry<K, V> next) {\n",
        "1326": "      this.nextExpirable = next;\n",
        "1327": "    }\n",
        "1328": "\n",
        "1329": "    // Guarded By Segment.this\n",
        "1330": "    ReferenceEntry<K, V> previousExpirable = nullEntry();\n",
        "1331": "\n",
        "1332": "    @Override\n",
        "1333": "    public ReferenceEntry<K, V> getPreviousExpirable() {\n",
        "1334": "      return previousExpirable;\n",
        "1335": "    }\n",
        "1336": "\n",
        "1337": "    @Override\n",
        "1338": "    public void setPreviousExpirable(ReferenceEntry<K, V> previous) {\n",
        "1339": "      this.previousExpirable = previous;\n",
        "1340": "    }\n",
        "1341": "\n",
        "1342": "    // The code below is exactly the same for each evictable entry type.\n",
        "1343": "\n",
        "1344": "    // Guarded By Segment.this\n",
        "1345": "    ReferenceEntry<K, V> nextEvictable = nullEntry();\n",
        "1346": "\n",
        "1347": "    @Override\n",
        "1348": "    public ReferenceEntry<K, V> getNextEvictable() {\n",
        "1349": "      return nextEvictable;\n",
        "1350": "    }\n",
        "1351": "\n",
        "1352": "    @Override\n",
        "1353": "    public void setNextEvictable(ReferenceEntry<K, V> next) {\n",
        "1354": "      this.nextEvictable = next;\n",
        "1355": "    }\n",
        "1356": "\n",
        "1357": "    // Guarded By Segment.this\n",
        "1358": "    ReferenceEntry<K, V> previousEvictable = nullEntry();\n",
        "1359": "\n",
        "1360": "    @Override\n",
        "1361": "    public ReferenceEntry<K, V> getPreviousEvictable() {\n",
        "1362": "      return previousEvictable;\n",
        "1363": "    }\n",
        "1364": "\n",
        "1365": "    @Override\n",
        "1366": "    public void setPreviousEvictable(ReferenceEntry<K, V> previous) {\n",
        "1367": "      this.previousEvictable = previous;\n",
        "1368": "    }\n",
        "1369": "  }\n",
        "1370": "\n",
        "1371": "  /**\n",
        "1372": "   * Used for weakly-referenced keys.\n",
        "1373": "   */\n",
        "1374": "  static class WeakEntry<K, V> extends WeakReference<K> implements ReferenceEntry<K, V> {\n",
        "1375": "    WeakEntry(ReferenceQueue<K> queue, K key, int hash, @Nullable ReferenceEntry<K, V> next) {\n",
        "1376": "      super(key, queue);\n",
        "1377": "      this.hash = hash;\n",
        "1378": "      this.next = next;\n",
        "1379": "    }\n",
        "1380": "\n",
        "1381": "    @Override\n",
        "1382": "    public K getKey() {\n",
        "1383": "      return get();\n",
        "1384": "    }\n",
        "1385": "\n",
        "1386": "    // null expiration\n",
        "1387": "\n",
        "1388": "    @Override\n",
        "1389": "    public long getExpirationTime() {\n",
        "1390": "      throw new UnsupportedOperationException();\n",
        "1391": "    }\n",
        "1392": "\n",
        "1393": "    @Override\n",
        "1394": "    public void setExpirationTime(long time) {\n",
        "1395": "      throw new UnsupportedOperationException();\n",
        "1396": "    }\n",
        "1397": "\n",
        "1398": "    @Override\n",
        "1399": "    public ReferenceEntry<K, V> getNextExpirable() {\n",
        "1400": "      throw new UnsupportedOperationException();\n",
        "1401": "    }\n",
        "1402": "\n",
        "1403": "    @Override\n",
        "1404": "    public void setNextExpirable(ReferenceEntry<K, V> next) {\n",
        "1405": "      throw new UnsupportedOperationException();\n",
        "1406": "    }\n",
        "1407": "\n",
        "1408": "    @Override\n",
        "1409": "    public ReferenceEntry<K, V> getPreviousExpirable() {\n",
        "1410": "      throw new UnsupportedOperationException();\n",
        "1411": "    }\n",
        "1412": "\n",
        "1413": "    @Override\n",
        "1414": "    public void setPreviousExpirable(ReferenceEntry<K, V> previous) {\n",
        "1415": "      throw new UnsupportedOperationException();\n",
        "1416": "    }\n",
        "1417": "\n",
        "1418": "    // null eviction\n",
        "1419": "\n",
        "1420": "    @Override\n",
        "1421": "    public ReferenceEntry<K, V> getNextEvictable() {\n",
        "1422": "      throw new UnsupportedOperationException();\n",
        "1423": "    }\n",
        "1424": "\n",
        "1425": "    @Override\n",
        "1426": "    public void setNextEvictable(ReferenceEntry<K, V> next) {\n",
        "1427": "      throw new UnsupportedOperationException();\n",
        "1428": "    }\n",
        "1429": "\n",
        "1430": "    @Override\n",
        "1431": "    public ReferenceEntry<K, V> getPreviousEvictable() {\n",
        "1432": "      throw new UnsupportedOperationException();\n",
        "1433": "    }\n",
        "1434": "\n",
        "1435": "    @Override\n",
        "1436": "    public void setPreviousEvictable(ReferenceEntry<K, V> previous) {\n",
        "1437": "      throw new UnsupportedOperationException();\n",
        "1438": "    }\n",
        "1439": "\n",
        "1440": "    // The code below is exactly the same for each entry type.\n",
        "1441": "\n",
        "1442": "    final int hash;\n",
        "1443": "    final ReferenceEntry<K, V> next;\n",
        "1444": "    volatile ValueReference<K, V> valueReference = unset();\n",
        "1445": "\n",
        "1446": "    @Override\n",
        "1447": "    public ValueReference<K, V> getValueReference() {\n",
        "1448": "      return valueReference;\n",
        "1449": "    }\n",
        "1450": "\n",
        "1451": "    @Override\n",
        "1452": "    public void setValueReference(ValueReference<K, V> valueReference) {\n",
        "1453": "      ValueReference<K, V> previous = this.valueReference;\n",
        "1454": "      this.valueReference = valueReference;\n",
        "1455": "      previous.clear(valueReference);\n",
        "1456": "    }\n",
        "1457": "\n",
        "1458": "    @Override\n",
        "1459": "    public int getHash() {\n",
        "1460": "      return hash;\n",
        "1461": "    }\n",
        "1462": "\n",
        "1463": "    @Override\n",
        "1464": "    public ReferenceEntry<K, V> getNext() {\n",
        "1465": "      return next;\n",
        "1466": "    }\n",
        "1467": "  }\n",
        "1468": "\n",
        "1469": "  static final class WeakExpirableEntry<K, V> extends WeakEntry<K, V>\n",
        "1470": "      implements ReferenceEntry<K, V> {\n",
        "1471": "    WeakExpirableEntry(\n",
        "1472": "        ReferenceQueue<K> queue, K key, int hash, @Nullable ReferenceEntry<K, V> next) {\n",
        "1473": "      super(queue, key, hash, next);\n",
        "1474": "    }\n",
        "1476": "    // The code below is exactly the same for each expirable entry type.\n",
        "1478": "    volatile long time = Long.MAX_VALUE;\n",
        "1480": "    @Override\n",
        "1481": "    public long getExpirationTime() {\n",
        "1482": "      return time;\n",
        "1483": "    }\n",
        "1486": "    public void setExpirationTime(long time) {\n",
        "1487": "      this.time = time;\n",
        "1490": "    // Guarded By Segment.this\n",
        "1491": "    ReferenceEntry<K, V> nextExpirable = nullEntry();\n",
        "1492": "\n",
        "1494": "    public ReferenceEntry<K, V> getNextExpirable() {\n",
        "1495": "      return nextExpirable;\n",
        "1496": "    }\n",
        "1499": "    public void setNextExpirable(ReferenceEntry<K, V> next) {\n",
        "1500": "      this.nextExpirable = next;\n",
        "1503": "    // Guarded By Segment.this\n",
        "1504": "    ReferenceEntry<K, V> previousExpirable = nullEntry();\n",
        "1505": "\n",
        "1507": "    public ReferenceEntry<K, V> getPreviousExpirable() {\n",
        "1508": "      return previousExpirable;\n",
        "1512": "    public void setPreviousExpirable(ReferenceEntry<K, V> previous) {\n",
        "1513": "      this.previousExpirable = previous;\n",
        "1517": "  static final class WeakEvictableEntry<K, V> extends WeakEntry<K, V>\n",
        "1518": "      implements ReferenceEntry<K, V> {\n",
        "1519": "    WeakEvictableEntry(\n",
        "1520": "        ReferenceQueue<K> queue, K key, int hash, @Nullable ReferenceEntry<K, V> next) {\n",
        "1521": "      super(queue, key, hash, next);\n",
        "1524": "    // The code below is exactly the same for each evictable entry type.\n",
        "1525": "\n",
        "1526": "    // Guarded By Segment.this\n",
        "1527": "    ReferenceEntry<K, V> nextEvictable = nullEntry();\n",
        "1528": "\n",
        "1530": "    public ReferenceEntry<K, V> getNextEvictable() {\n",
        "1531": "      return nextEvictable;\n",
        "1535": "    public void setNextEvictable(ReferenceEntry<K, V> next) {\n",
        "1536": "      this.nextEvictable = next;\n",
        "1539": "    // Guarded By Segment.this\n",
        "1540": "    ReferenceEntry<K, V> previousEvictable = nullEntry();\n",
        "1541": "\n",
        "1543": "    public ReferenceEntry<K, V> getPreviousEvictable() {\n",
        "1544": "      return previousEvictable;\n",
        "1548": "    public void setPreviousEvictable(ReferenceEntry<K, V> previous) {\n",
        "1549": "      this.previousEvictable = previous;\n",
        "1553": "  static final class WeakExpirableEvictableEntry<K, V> extends WeakEntry<K, V>\n",
        "1554": "      implements ReferenceEntry<K, V> {\n",
        "1555": "    WeakExpirableEvictableEntry(\n",
        "1556": "        ReferenceQueue<K> queue, K key, int hash, @Nullable ReferenceEntry<K, V> next) {\n",
        "1557": "      super(queue, key, hash, next);\n",
        "1558": "    }\n",
        "1560": "    // The code below is exactly the same for each expirable entry type.\n",
        "1562": "    volatile long time = Long.MAX_VALUE;\n",
        "1564": "    @Override\n",
        "1565": "    public long getExpirationTime() {\n",
        "1566": "      return time;\n",
        "1570": "    public void setExpirationTime(long time) {\n",
        "1571": "      this.time = time;\n",
        "1574": "    // Guarded By Segment.this\n",
        "1575": "    ReferenceEntry<K, V> nextExpirable = nullEntry();\n",
        "1578": "    public ReferenceEntry<K, V> getNextExpirable() {\n",
        "1579": "      return nextExpirable;\n",
        "1583": "    public void setNextExpirable(ReferenceEntry<K, V> next) {\n",
        "1584": "      this.nextExpirable = next;\n",
        "1587": "    // Guarded By Segment.this\n",
        "1588": "    ReferenceEntry<K, V> previousExpirable = nullEntry();\n",
        "1591": "    public ReferenceEntry<K, V> getPreviousExpirable() {\n",
        "1592": "      return previousExpirable;\n",
        "1596": "    public void setPreviousExpirable(ReferenceEntry<K, V> previous) {\n",
        "1597": "      this.previousExpirable = previous;\n",
        "1600": "    // The code below is exactly the same for each evictable entry type.\n",
        "1602": "    // Guarded By Segment.this\n",
        "1603": "    ReferenceEntry<K, V> nextEvictable = nullEntry();\n",
        "1606": "    public ReferenceEntry<K, V> getNextEvictable() {\n",
        "1607": "      return nextEvictable;\n",
        "1611": "    public void setNextEvictable(ReferenceEntry<K, V> next) {\n",
        "1612": "      this.nextEvictable = next;\n",
        "1615": "    // Guarded By Segment.this\n",
        "1616": "    ReferenceEntry<K, V> previousEvictable = nullEntry();\n",
        "1617": "\n",
        "1619": "    public ReferenceEntry<K, V> getPreviousEvictable() {\n",
        "1620": "      return previousEvictable;\n",
        "1624": "    public void setPreviousEvictable(ReferenceEntry<K, V> previous) {\n",
        "1625": "      this.previousEvictable = previous;\n",
        "1838": "   * partially-collected, computing, or expired. Unlike {@link Segment#getLiveValue} this method\n",
        "1849": "\n",
        "1850": "    if (expires() && isExpired(entry)) {\n",
        "1851": "      return null;\n",
        "1852": "    }\n",
        "1856": "  // expiration\n",
        "1857": "\n",
        "1858": "  /**\n",
        "1859": "   * Returns {@code true} if the entry has expired.\n",
        "1860": "   */\n",
        "1861": "  boolean isExpired(ReferenceEntry<K, V> entry) {\n",
        "1862": "    return isExpired(entry, ticker.read());\n",
        "1863": "  }\n",
        "1864": "\n",
        "1865": "  /**\n",
        "1866": "   * Returns {@code true} if the entry has expired.\n",
        "1867": "   */\n",
        "1868": "  boolean isExpired(ReferenceEntry<K, V> entry, long now) {\n",
        "1869": "    // if the expiration time had overflowed, this \"undoes\" the overflow\n",
        "1870": "    return now - entry.getExpirationTime() > 0;\n",
        "1871": "  }\n",
        "1872": "\n",
        "1873": "  // Guarded By Segment.this\n",
        "1874": "  static <K, V> void connectExpirables(ReferenceEntry<K, V> previous, ReferenceEntry<K, V> next) {\n",
        "1875": "    previous.setNextExpirable(next);\n",
        "1876": "    next.setPreviousExpirable(previous);\n",
        "1877": "  }\n",
        "1878": "\n",
        "1879": "  // Guarded By Segment.this\n",
        "1880": "  static <K, V> void nullifyExpirable(ReferenceEntry<K, V> nulled) {\n",
        "1881": "    ReferenceEntry<K, V> nullEntry = nullEntry();\n",
        "1882": "    nulled.setNextExpirable(nullEntry);\n",
        "1883": "    nulled.setPreviousExpirable(nullEntry);\n",
        "1884": "  }\n",
        "1885": "\n",
        "1886": "  // eviction\n",
        "1887": "\n",
        "1888": "  /** Links the evitables together. */\n",
        "1889": "  // Guarded By Segment.this\n",
        "1890": "  static <K, V> void connectEvictables(ReferenceEntry<K, V> previous, ReferenceEntry<K, V> next) {\n",
        "1891": "    previous.setNextEvictable(next);\n",
        "1892": "    next.setPreviousEvictable(previous);\n",
        "1893": "  }\n",
        "1894": "\n",
        "1895": "  // Guarded By Segment.this\n",
        "1896": "  static <K, V> void nullifyEvictable(ReferenceEntry<K, V> nulled) {\n",
        "1897": "    ReferenceEntry<K, V> nullEntry = nullEntry();\n",
        "1898": "    nulled.setNextEvictable(nullEntry);\n",
        "1899": "    nulled.setPreviousEvictable(nullEntry);\n",
        "1900": "  }\n",
        "1901": "\n",
        "1916": "    /*\n",
        "1917": "     * TODO(fry): Consider copying variables (like evictsBySize) from outer class into this class.\n",
        "1918": "     * It will require more memory but will reduce indirection.\n",
        "1919": "     */\n",
        "1920": "\n",
        "1999": "    /**\n",
        "2000": "     * A queue of elements currently in the map, ordered by expiration time (write time).\n",
        "2001": "     * Elements are added to the tail of the queue on write.\n",
        "2002": "     */\n",
        "2003": "    @GuardedBy(\"this\")\n",
        "2004": "    final Queue<ReferenceEntry<K, V>> expirationQueue;\n",
        "2005": "\n",
        "2014": "\n",
        "2015": "      expirationQueue =\n",
        "2016": "          map.expires()\n",
        "2017": "              ? new ExpirationQueue<K, V>()\n",
        "2018": "              : MapMakerInternalMap.<ReferenceEntry<K, V>>discardingQueue();\n",
        "2063": "     * Sets a new value of an entry. Adds newly created entries at the end of the expiration queue.\n",
        "2069": "      recordWrite(entry);\n",
        "2149": "    // recency queue, shared by expiration and eviction\n",
        "2150": "\n",
        "2151": "    /**\n",
        "2152": "     * Updates eviction metadata that {@code entry} was just written. This currently amounts to\n",
        "2153": "     * adding {@code entry} to relevant eviction lists.\n",
        "2154": "     */\n",
        "2155": "    @GuardedBy(\"this\")\n",
        "2156": "    void recordWrite(ReferenceEntry<K, V> entry) {\n",
        "2157": "      if (map.expires()) {\n",
        "2158": "        long expiration = map.expireAfterWriteNanos;\n",
        "2159": "        recordExpirationTime(entry, expiration);\n",
        "2160": "        expirationQueue.add(entry);\n",
        "2161": "      }\n",
        "2162": "    }\n",
        "2163": "\n",
        "2164": "    // expiration\n",
        "2165": "\n",
        "2166": "    void recordExpirationTime(ReferenceEntry<K, V> entry, long expirationNanos) {\n",
        "2167": "      // might overflow, but that's okay (see isExpired())\n",
        "2168": "      entry.setExpirationTime(map.ticker.read() + expirationNanos);\n",
        "2169": "    }\n",
        "2170": "\n",
        "2171": "    /**\n",
        "2172": "     * Cleanup expired entries when the lock is available.\n",
        "2173": "     */\n",
        "2174": "    void tryExpireEntries() {\n",
        "2175": "      if (tryLock()) {\n",
        "2176": "        try {\n",
        "2177": "          expireEntries();\n",
        "2178": "        } finally {\n",
        "2179": "          unlock();\n",
        "2180": "        }\n",
        "2181": "      }\n",
        "2182": "    }\n",
        "2183": "\n",
        "2184": "    @GuardedBy(\"this\")\n",
        "2185": "    void expireEntries() {\n",
        "2186": "\n",
        "2187": "      if (expirationQueue.isEmpty()) {\n",
        "2188": "        // There's no point in calling nanoTime() if we have no entries to\n",
        "2189": "        // expire.\n",
        "2190": "        return;\n",
        "2191": "      }\n",
        "2192": "      long now = map.ticker.read();\n",
        "2193": "      ReferenceEntry<K, V> e;\n",
        "2194": "      while ((e = expirationQueue.peek()) != null && map.isExpired(e, now)) {\n",
        "2195": "        if (!removeEntry(e, e.getHash())) {\n",
        "2196": "          throw new AssertionError();\n",
        "2197": "        }\n",
        "2198": "      }\n",
        "2199": "    }\n",
        "2200": "\n",
        "2238": "      } else if (map.expires() && map.isExpired(e)) {\n",
        "2239": "        tryExpireEntries();\n",
        "2240": "        return null;\n",
        "2428": "                removeCollectedEntry(e);\n",
        "2622": "          expirationQueue.clear();\n",
        "2647": "      expirationQueue.remove(entry);\n",
        "2648": "\n",
        "2656": "          removeCollectedEntry(e);\n",
        "2664": "    void removeCollectedEntry(ReferenceEntry<K, V> entry) {\n",
        "2665": "      expirationQueue.remove(entry);\n",
        "2666": "    }\n",
        "2667": "\n",
        "2800": "     * partially-collected, computing, or expired.\n",
        "2813": "      if (map.expires() && map.isExpired(entry)) {\n",
        "2814": "        tryExpireEntries();\n",
        "2815": "        return null;\n",
        "2816": "      }\n",
        "2834": "     *\n",
        "2835": "     * <p>Post-condition: expireEntries has been run.\n",
        "2850": "          expireEntries();\n",
        "2859": "  // Queues\n",
        "2860": "\n",
        "2861": "  /**\n",
        "2862": "   * A custom queue for managing expiration order. Note that this is tightly integrated with\n",
        "2863": "   * {@code ReferenceEntry}, upon which it reliese to perform its linking.\n",
        "2864": "   *\n",
        "2865": "   * <p>Note that this entire implementation makes the assumption that all elements which are in\n",
        "2866": "   * the map are also in this queue, and that all elements not in the queue are not in the map.\n",
        "2867": "   *\n",
        "2868": "   * <p>The benefits of creating our own queue are that (1) we can replace elements in the middle\n",
        "2869": "   * of the queue as part of copyEvictableEntry, and (2) the contains method is highly optimized\n",
        "2870": "   * for the current model.\n",
        "2871": "   */\n",
        "2872": "  static final class ExpirationQueue<K, V> extends AbstractQueue<ReferenceEntry<K, V>> {\n",
        "2873": "    final ReferenceEntry<K, V> head =\n",
        "2874": "        new AbstractReferenceEntry<K, V>() {\n",
        "2875": "\n",
        "2876": "          @Override\n",
        "2877": "          public long getExpirationTime() {\n",
        "2878": "            return Long.MAX_VALUE;\n",
        "2879": "          }\n",
        "2880": "\n",
        "2881": "          @Override\n",
        "2882": "          public void setExpirationTime(long time) {}\n",
        "2883": "\n",
        "2884": "          ReferenceEntry<K, V> nextExpirable = this;\n",
        "2885": "\n",
        "2886": "          @Override\n",
        "2887": "          public ReferenceEntry<K, V> getNextExpirable() {\n",
        "2888": "            return nextExpirable;\n",
        "2889": "          }\n",
        "2890": "\n",
        "2891": "          @Override\n",
        "2892": "          public void setNextExpirable(ReferenceEntry<K, V> next) {\n",
        "2893": "            this.nextExpirable = next;\n",
        "2894": "          }\n",
        "2895": "\n",
        "2896": "          ReferenceEntry<K, V> previousExpirable = this;\n",
        "2897": "\n",
        "2898": "          @Override\n",
        "2899": "          public ReferenceEntry<K, V> getPreviousExpirable() {\n",
        "2900": "            return previousExpirable;\n",
        "2901": "          }\n",
        "2902": "\n",
        "2903": "          @Override\n",
        "2904": "          public void setPreviousExpirable(ReferenceEntry<K, V> previous) {\n",
        "2905": "            this.previousExpirable = previous;\n",
        "2906": "          }\n",
        "2907": "        };\n",
        "2908": "\n",
        "2909": "    // implements Queue\n",
        "2910": "\n",
        "2911": "    @Override\n",
        "2912": "    public boolean offer(ReferenceEntry<K, V> entry) {\n",
        "2913": "      // unlink\n",
        "2914": "      connectExpirables(entry.getPreviousExpirable(), entry.getNextExpirable());\n",
        "2915": "\n",
        "2916": "      // add to tail\n",
        "2917": "      connectExpirables(head.getPreviousExpirable(), entry);\n",
        "2918": "      connectExpirables(entry, head);\n",
        "2919": "\n",
        "2920": "      return true;\n",
        "2921": "    }\n",
        "2922": "\n",
        "2923": "    @Override\n",
        "2924": "    public ReferenceEntry<K, V> peek() {\n",
        "2925": "      ReferenceEntry<K, V> next = head.getNextExpirable();\n",
        "2926": "      return (next == head) ? null : next;\n",
        "2927": "    }\n",
        "2928": "\n",
        "2929": "    @Override\n",
        "2930": "    public ReferenceEntry<K, V> poll() {\n",
        "2931": "      ReferenceEntry<K, V> next = head.getNextExpirable();\n",
        "2932": "      if (next == head) {\n",
        "2933": "        return null;\n",
        "2934": "      }\n",
        "2935": "\n",
        "2936": "      remove(next);\n",
        "2937": "      return next;\n",
        "2938": "    }\n",
        "2939": "\n",
        "2940": "    @CanIgnoreReturnValue\n",
        "2941": "    @Override\n",
        "2942": "    @SuppressWarnings(\"unchecked\")\n",
        "2943": "    public boolean remove(Object o) {\n",
        "2944": "      ReferenceEntry<K, V> e = (ReferenceEntry) o;\n",
        "2945": "      ReferenceEntry<K, V> previous = e.getPreviousExpirable();\n",
        "2946": "      ReferenceEntry<K, V> next = e.getNextExpirable();\n",
        "2947": "      connectExpirables(previous, next);\n",
        "2948": "      nullifyExpirable(e);\n",
        "2949": "\n",
        "2950": "      return next != NullEntry.INSTANCE;\n",
        "2951": "    }\n",
        "2952": "\n",
        "2953": "    @Override\n",
        "2954": "    @SuppressWarnings(\"unchecked\")\n",
        "2955": "    public boolean contains(Object o) {\n",
        "2956": "      ReferenceEntry<K, V> e = (ReferenceEntry) o;\n",
        "2957": "      return e.getNextExpirable() != NullEntry.INSTANCE;\n",
        "2958": "    }\n",
        "2959": "\n",
        "2960": "    @Override\n",
        "2961": "    public boolean isEmpty() {\n",
        "2962": "      return head.getNextExpirable() == head;\n",
        "2963": "    }\n",
        "2964": "\n",
        "2965": "    @Override\n",
        "2966": "    public int size() {\n",
        "2967": "      int size = 0;\n",
        "2968": "      for (ReferenceEntry<K, V> e = head.getNextExpirable(); e != head; e = e.getNextExpirable()) {\n",
        "2969": "        size++;\n",
        "2970": "      }\n",
        "2971": "      return size;\n",
        "2972": "    }\n",
        "2973": "\n",
        "2974": "    @Override\n",
        "2975": "    public void clear() {\n",
        "2976": "      ReferenceEntry<K, V> e = head.getNextExpirable();\n",
        "2977": "      while (e != head) {\n",
        "2978": "        ReferenceEntry<K, V> next = e.getNextExpirable();\n",
        "2979": "        nullifyExpirable(e);\n",
        "2980": "        e = next;\n",
        "2981": "      }\n",
        "2982": "\n",
        "2983": "      head.setNextExpirable(head);\n",
        "2984": "      head.setPreviousExpirable(head);\n",
        "2985": "    }\n",
        "2986": "\n",
        "2987": "    @Override\n",
        "2988": "    public Iterator<ReferenceEntry<K, V>> iterator() {\n",
        "2989": "      return new AbstractSequentialIterator<ReferenceEntry<K, V>>(peek()) {\n",
        "2990": "        @Override\n",
        "2991": "        protected ReferenceEntry<K, V> computeNext(ReferenceEntry<K, V> previous) {\n",
        "2992": "          ReferenceEntry<K, V> next = previous.getNextExpirable();\n",
        "2993": "          return (next == head) ? null : next;\n",
        "2994": "        }\n",
        "2995": "      };\n",
        "2996": "    }\n",
        "2997": "  }\n",
        "2998": "\n",
        "3073": "   * Returns the internal entry for the specified key. The entry may be computing, expired, or\n",
        "3570": "        expireAfterWriteNanos,\n",
        "3587": "    final long expireAfterWriteNanos;\n",
        "3597": "        long expireAfterWriteNanos,\n",
        "3604": "      this.expireAfterWriteNanos = expireAfterWriteNanos;\n",
        "3626": "      MapMaker mapMaker =\n",
        "3627": "          new MapMaker()\n",
        "3628": "              .initialCapacity(size)\n",
        "3629": "              .setKeyStrength(keyStrength)\n",
        "3630": "              .setValueStrength(valueStrength)\n",
        "3631": "              .keyEquivalence(keyEquivalence)\n",
        "3632": "              .concurrencyLevel(concurrencyLevel);\n",
        "3633": "      if (expireAfterWriteNanos > 0) {\n",
        "3634": "        mapMaker.expireAfterWrite(expireAfterWriteNanos, TimeUnit.NANOSECONDS);\n",
        "3635": "      }\n",
        "3636": "      return mapMaker;\n",
        "3664": "        long expireAfterWriteNanos,\n",
        "3672": "          expireAfterWriteNanos,\n"
    }
}