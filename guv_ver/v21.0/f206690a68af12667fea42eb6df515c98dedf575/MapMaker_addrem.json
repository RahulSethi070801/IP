{
    "addition": {
        "36": "  private static class ComputingMap<K, V> extends LinkedHashMap<K, V>\n",
        "40": "    ComputingMap(int initialCapacity) {\n",
        "41": "      this(null, initialCapacity);\n",
        "44": "    ComputingMap(Function<? super K, ? extends V> computer, int initialCapacity) {\n",
        "147": "        ? new ComputingMap<K, V>(null, initialCapacity)\n",
        "153": "    return new ComputingMap<K, V>(computer, initialCapacity);\n"
    },
    "removed": {
        "21": "import jsinterop.annotations.JsFunction;\n",
        "22": "import jsinterop.annotations.JsMethod;\n",
        "23": "import jsinterop.annotations.JsPackage;\n",
        "24": "\n",
        "28": "import java.util.concurrent.TimeUnit;\n",
        "41": "  private static class ExpiringComputingMap<K, V> extends LinkedHashMap<K, V>\n",
        "43": "    private final long expirationMillis;\n",
        "46": "    ExpiringComputingMap(long expirationMillis, int initialCapacity) {\n",
        "47": "      this(expirationMillis, null, initialCapacity);\n",
        "50": "    ExpiringComputingMap(\n",
        "51": "        long expirationMillis, Function<? super K, ? extends V> computer, int initialCapacity) {\n",
        "53": "      this.expirationMillis = expirationMillis;\n",
        "57": "    @Override\n",
        "58": "    public V put(K key, V value) {\n",
        "59": "      V result = super.put(key, value);\n",
        "60": "      if (expirationMillis > 0) {\n",
        "61": "        scheduleRemoval(key, value);\n",
        "62": "      }\n",
        "63": "      return result;\n",
        "64": "    }\n",
        "65": "\n",
        "98": "    private void scheduleRemoval(final K key, final V value) {\n",
        "99": "      // from MapMaker\n",
        "100": "      /*\n",
        "101": "       * TODO: Keep weak reference to map, too. Build a priority queue out of the entries themselves\n",
        "102": "       * instead of creating a task per entry. Then, we could have one recurring task per map (which\n",
        "103": "       * would clean the entire map and then reschedule itself depending upon when the next\n",
        "104": "       * expiration comes). We also want to avoid removing an entry prematurely if the entry was set\n",
        "105": "       * to the same value again.\n",
        "106": "       */\n",
        "107": "      setTimeout(new Callback() {\n",
        "108": "        @Override\n",
        "109": "        public void run() {\n",
        "110": "          remove(key, value);\n",
        "111": "        }\n",
        "112": "      }, (int) expirationMillis);\n",
        "113": "    }\n",
        "114": "\n",
        "115": "    @JsFunction\n",
        "116": "    private interface Callback {\n",
        "117": "      void run();\n",
        "118": "    }\n",
        "119": "\n",
        "120": "    // TODO(user): Move this logic to a common location.\n",
        "121": "    @JsMethod(name = \"setTimeout\", namespace = JsPackage.GLOBAL)\n",
        "122": "    private static native void setTimeout(Callback callback, int delayInMs);\n",
        "123": "\n",
        "164": "  private long expirationMillis = 0;\n",
        "178": "  @Override\n",
        "179": "  MapMaker expireAfterWrite(long duration, TimeUnit unit) {\n",
        "180": "    if (expirationMillis != 0) {\n",
        "181": "      throw new IllegalStateException(\n",
        "182": "          \"expiration time of \" + expirationMillis + \" ns was already set\");\n",
        "183": "    }\n",
        "184": "    if (duration <= 0) {\n",
        "185": "      throw new IllegalArgumentException(\"invalid duration: \" + duration);\n",
        "186": "    }\n",
        "187": "    this.expirationMillis = unit.toMillis(duration);\n",
        "188": "    useCustomMap = true;\n",
        "189": "    return this;\n",
        "190": "  }\n",
        "191": "\n",
        "205": "        ? new ExpiringComputingMap<K, V>(expirationMillis, null, initialCapacity)\n",
        "211": "    return new ExpiringComputingMap<K, V>(expirationMillis, computer, initialCapacity);\n"
    }
}