{
    "addition": {
        "222": "    for (MapMaker maker : allKeyValueStrengthMakers()) {\n",
        "254": "    for (MapMaker maker : allKeyValueStrengthMakers()) {\n",
        "733": "    MapMakerInternalMap<Object, Object> map =\n",
        "734": "        makeMap(createMapMaker().concurrencyLevel(1).initialCapacity(1));\n",
        "743": "\n",
        "758": "        makeMap(createMapMaker().concurrencyLevel(1).initialCapacity(1));\n",
        "780": "        makeMap(createMapMaker().concurrencyLevel(1).initialCapacity(1));\n"
    },
    "removed": {
        "19": "import static com.google.common.collect.Lists.newArrayList;\n",
        "24": "import static java.util.concurrent.TimeUnit.SECONDS;\n",
        "27": "import com.google.common.base.Ticker;\n",
        "39": "import java.util.Iterator;\n",
        "40": "import java.util.List;\n",
        "41": "import java.util.Random;\n",
        "42": "import java.util.concurrent.TimeUnit;\n",
        "73": "    assertEquals(0, map.expireAfterWriteNanos);\n",
        "74": "\n",
        "76": "    assertSame(Ticker.systemTicker(), map.ticker);\n",
        "84": "\n",
        "85": "    assertFalse(map.expires());\n",
        "231": "  public void testSetExpireAfterWrite() {\n",
        "232": "    long duration = 42;\n",
        "233": "    TimeUnit unit = SECONDS;\n",
        "234": "    MapMakerInternalMap<Object, Object> map =\n",
        "235": "        makeMap(createMapMaker().expireAfterWrite(duration, unit));\n",
        "236": "    assertEquals(unit.toNanos(duration), map.expireAfterWriteNanos);\n",
        "237": "  }\n",
        "238": "\n",
        "242": "    for (MapMaker maker : allEntryTypeMakers()) {\n",
        "274": "    for (MapMaker maker : allEntryTypeMakers()) {\n",
        "288": "      if (map.expires()) {\n",
        "289": "        MapMakerInternalMap.connectExpirables(entryOne, entryTwo);\n",
        "290": "      }\n",
        "291": "      assertConnected(map, entryOne, entryTwo);\n",
        "298": "      assertConnected(map, copyOne, entryTwo);\n",
        "305": "      assertConnected(map, copyOne, copyTwo);\n",
        "306": "    }\n",
        "307": "  }\n",
        "308": "\n",
        "309": "  private static <K, V> void assertConnected(\n",
        "310": "      MapMakerInternalMap<K, V> map, ReferenceEntry<K, V> one, ReferenceEntry<K, V> two) {\n",
        "311": "    if (map.expires()) {\n",
        "312": "      assertSame(two, one.getNextExpirable());\n",
        "662": "  public void testReclaimKey() {\n",
        "663": "    MapMakerInternalMap<Object, Object> map =\n",
        "664": "        makeMap(\n",
        "665": "            createMapMaker()\n",
        "666": "                .concurrencyLevel(1)\n",
        "667": "                .initialCapacity(1)\n",
        "668": "                .expireAfterWrite(99999, SECONDS));\n",
        "669": "    Segment<Object, Object> segment = map.segments[0];\n",
        "670": "    AtomicReferenceArray<ReferenceEntry<Object, Object>> table = segment.table;\n",
        "671": "    assertEquals(1, table.length());\n",
        "672": "\n",
        "673": "    // create 3 objects and chain them together\n",
        "674": "    Object keyOne = new Object();\n",
        "675": "    Object valueOne = new Object();\n",
        "676": "    int hashOne = map.hash(keyOne);\n",
        "677": "    DummyEntry<Object, Object> entryOne = createDummyEntry(keyOne, hashOne, valueOne, null);\n",
        "678": "    Object keyTwo = new Object();\n",
        "679": "    Object valueTwo = new Object();\n",
        "680": "    int hashTwo = map.hash(keyTwo);\n",
        "681": "    DummyEntry<Object, Object> entryTwo = createDummyEntry(keyTwo, hashTwo, valueTwo, entryOne);\n",
        "682": "    Object keyThree = new Object();\n",
        "683": "    Object valueThree = new Object();\n",
        "684": "    int hashThree = map.hash(keyThree);\n",
        "685": "    DummyEntry<Object, Object> entryThree =\n",
        "686": "        createDummyEntry(keyThree, hashThree, valueThree, entryTwo);\n",
        "687": "\n",
        "688": "    // absent\n",
        "689": "    assertFalse(segment.reclaimKey(entryOne, hashOne));\n",
        "690": "    table.set(0, entryOne);\n",
        "691": "    assertFalse(segment.reclaimKey(entryTwo, hashTwo));\n",
        "692": "    table.set(0, entryTwo);\n",
        "693": "    assertFalse(segment.reclaimKey(entryThree, hashThree));\n",
        "694": "\n",
        "695": "    // present\n",
        "696": "    table.set(0, entryOne);\n",
        "697": "    segment.count = 1;\n",
        "698": "    assertTrue(segment.reclaimKey(entryOne, hashOne));\n",
        "699": "    assertFalse(segment.expirationQueue.contains(entryOne));\n",
        "700": "    assertEquals(0, segment.count);\n",
        "701": "    assertNull(table.get(0));\n",
        "702": "  }\n",
        "703": "\n",
        "808": "    MapMakerInternalMap<Object, Object> map = makeMap(createMapMaker()\n",
        "809": "        .concurrencyLevel(1)\n",
        "810": "        .initialCapacity(1)\n",
        "811": "        .expireAfterWrite(99999, SECONDS));\n",
        "820": "    segment.recordWrite(entry);\n",
        "826": "    assertSame(entry, segment.expirationQueue.peek());\n",
        "830": "    assertTrue(segment.expirationQueue.isEmpty());\n",
        "837": "        makeMap(\n",
        "838": "            createMapMaker()\n",
        "839": "                .concurrencyLevel(1)\n",
        "840": "                .initialCapacity(1)\n",
        "841": "                .expireAfterWrite(99999, SECONDS));\n",
        "854": "    // remove live\n",
        "855": "    segment.recordWrite(entry);\n",
        "859": "    assertFalse(segment.expirationQueue.contains(entry));\n",
        "860": "    assertEquals(0, segment.count);\n",
        "861": "    assertNull(table.get(0));\n",
        "862": "  }\n",
        "863": "\n",
        "864": "  public void testReclaimValue() {\n",
        "865": "    MapMakerInternalMap<Object, Object> map =\n",
        "866": "        makeMap(\n",
        "867": "            createMapMaker()\n",
        "868": "                .concurrencyLevel(1)\n",
        "869": "                .initialCapacity(1)\n",
        "870": "                .expireAfterWrite(99999, SECONDS));\n",
        "871": "    Segment<Object, Object> segment = map.segments[0];\n",
        "872": "    AtomicReferenceArray<ReferenceEntry<Object, Object>> table = segment.table;\n",
        "873": "    assertEquals(1, table.length());\n",
        "874": "\n",
        "875": "    Object key = new Object();\n",
        "876": "    Object value = new Object();\n",
        "877": "    int hash = map.hash(key);\n",
        "878": "    DummyEntry<Object, Object> entry = DummyEntry.create(key, hash, null);\n",
        "879": "    DummyValueReference<Object, Object> valueRef = DummyValueReference.create(value, entry);\n",
        "880": "    entry.setValueReference(valueRef);\n",
        "881": "\n",
        "882": "    // reclaim absent\n",
        "883": "    assertFalse(segment.reclaimValue(key, hash, valueRef));\n",
        "884": "\n",
        "885": "    // reclaim live\n",
        "886": "    segment.recordWrite(entry);\n",
        "887": "    table.set(0, entry);\n",
        "888": "    segment.count = 1;\n",
        "889": "    assertTrue(segment.reclaimValue(key, hash, valueRef));\n",
        "890": "    assertFalse(segment.expirationQueue.contains(entry));\n",
        "893": "\n",
        "894": "    // reclaim wrong value reference\n",
        "895": "    table.set(0, entry);\n",
        "896": "    DummyValueReference<Object, Object> otherValueRef = DummyValueReference.create(value, entry);\n",
        "897": "    entry.setValueReference(otherValueRef);\n",
        "898": "    assertFalse(segment.reclaimValue(key, hash, valueRef));\n",
        "899": "    assertTrue(segment.reclaimValue(key, hash, otherValueRef));\n",
        "904": "        makeMap(\n",
        "905": "            createMapMaker()\n",
        "906": "                .concurrencyLevel(1)\n",
        "907": "                .initialCapacity(1)\n",
        "908": "                .expireAfterWrite(99999, SECONDS));\n",
        "923": "    // clear live\n",
        "924": "    segment.recordWrite(entry);\n",
        "929": "    assertFalse(segment.expirationQueue.contains(entry));\n",
        "942": "  // Segment eviction tests\n",
        "943": "\n",
        "944": "  public void testRecordRead() {\n",
        "945": "    for (MapMaker maker : allEvictingMakers()) {\n",
        "946": "      MapMakerInternalMap<Object, Object> map = makeMap(maker.concurrencyLevel(1));\n",
        "947": "      Segment<Object, Object> segment = map.segments[0];\n",
        "948": "      List<ReferenceEntry<Object, Object>> writeOrder = Lists.newLinkedList();\n",
        "949": "      List<ReferenceEntry<Object, Object>> readOrder = Lists.newLinkedList();\n",
        "950": "      for (int i = 0; i < DRAIN_THRESHOLD * 2; i++) {\n",
        "951": "        Object key = new Object();\n",
        "952": "        int hash = map.hash(key);\n",
        "953": "        Object value = new Object();\n",
        "954": "\n",
        "955": "        ReferenceEntry<Object, Object> entry = createDummyEntry(key, hash, value, null);\n",
        "956": "        segment.recordWrite(entry);\n",
        "957": "        writeOrder.add(entry);\n",
        "958": "        readOrder.add(entry);\n",
        "959": "      }\n",
        "960": "\n",
        "961": "      checkEvictionQueues(map, segment, readOrder, writeOrder);\n",
        "962": "      checkExpirationTimes(map);\n",
        "963": "\n",
        "964": "      // access some of the elements\n",
        "965": "      Random random = new Random();\n",
        "966": "      List<ReferenceEntry<Object, Object>> reads = Lists.newArrayList();\n",
        "967": "      Iterator<ReferenceEntry<Object, Object>> i = readOrder.iterator();\n",
        "968": "      while (i.hasNext()) {\n",
        "969": "        ReferenceEntry<Object, Object> entry = i.next();\n",
        "970": "        if (random.nextBoolean()) {\n",
        "971": "          reads.add(entry);\n",
        "972": "          i.remove();\n",
        "973": "        }\n",
        "974": "      }\n",
        "975": "      readOrder.addAll(reads);\n",
        "976": "\n",
        "977": "      checkEvictionQueues(map, segment, readOrder, writeOrder);\n",
        "978": "      checkExpirationTimes(map);\n",
        "979": "    }\n",
        "980": "  }\n",
        "981": "\n",
        "982": "  public void testRecordReadOnGet() {\n",
        "983": "    for (MapMaker maker : allEvictingMakers()) {\n",
        "984": "      MapMakerInternalMap<Object, Object> map = makeMap(maker.concurrencyLevel(1));\n",
        "985": "      Segment<Object, Object> segment = map.segments[0];\n",
        "986": "      List<ReferenceEntry<Object, Object>> writeOrder = Lists.newLinkedList();\n",
        "987": "      List<ReferenceEntry<Object, Object>> readOrder = Lists.newLinkedList();\n",
        "988": "      for (int i = 0; i < DRAIN_THRESHOLD * 2; i++) {\n",
        "989": "        Object key = new Object();\n",
        "990": "        int hash = map.hash(key);\n",
        "991": "        Object value = new Object();\n",
        "992": "\n",
        "993": "        map.put(key, value);\n",
        "994": "        ReferenceEntry<Object, Object> entry = segment.getEntry(key, hash);\n",
        "995": "        writeOrder.add(entry);\n",
        "996": "        readOrder.add(entry);\n",
        "997": "      }\n",
        "998": "\n",
        "999": "      checkEvictionQueues(map, segment, readOrder, writeOrder);\n",
        "1000": "      checkExpirationTimes(map);\n",
        "1001": "\n",
        "1002": "      // access some of the elements\n",
        "1003": "      Random random = new Random();\n",
        "1004": "      List<ReferenceEntry<Object, Object>> reads = Lists.newArrayList();\n",
        "1005": "      Iterator<ReferenceEntry<Object, Object>> i = readOrder.iterator();\n",
        "1006": "      while (i.hasNext()) {\n",
        "1007": "        ReferenceEntry<Object, Object> entry = i.next();\n",
        "1008": "        if (random.nextBoolean()) {\n",
        "1009": "          Object unused = map.get(entry.getKey());\n",
        "1010": "          reads.add(entry);\n",
        "1011": "          i.remove();\n",
        "1012": "        }\n",
        "1013": "      }\n",
        "1014": "      readOrder.addAll(reads);\n",
        "1015": "\n",
        "1016": "      checkEvictionQueues(map, segment, readOrder, writeOrder);\n",
        "1017": "      checkExpirationTimes(map);\n",
        "1018": "    }\n",
        "1019": "  }\n",
        "1020": "\n",
        "1021": "  public void testRecordWrite() {\n",
        "1022": "    for (MapMaker maker : allEvictingMakers()) {\n",
        "1023": "      MapMakerInternalMap<Object, Object> map = makeMap(maker.concurrencyLevel(1));\n",
        "1024": "      Segment<Object, Object> segment = map.segments[0];\n",
        "1025": "      List<ReferenceEntry<Object, Object>> writeOrder = Lists.newLinkedList();\n",
        "1026": "      for (int i = 0; i < DRAIN_THRESHOLD * 2; i++) {\n",
        "1027": "        Object key = new Object();\n",
        "1028": "        int hash = map.hash(key);\n",
        "1029": "        Object value = new Object();\n",
        "1030": "\n",
        "1031": "        ReferenceEntry<Object, Object> entry = createDummyEntry(key, hash, value, null);\n",
        "1032": "        segment.recordWrite(entry);\n",
        "1033": "        writeOrder.add(entry);\n",
        "1034": "      }\n",
        "1035": "\n",
        "1036": "      checkEvictionQueues(map, segment, writeOrder, writeOrder);\n",
        "1037": "      checkExpirationTimes(map);\n",
        "1038": "\n",
        "1039": "      // access some of the elements\n",
        "1040": "      Random random = new Random();\n",
        "1041": "      List<ReferenceEntry<Object, Object>> writes = Lists.newArrayList();\n",
        "1042": "      Iterator<ReferenceEntry<Object, Object>> i = writeOrder.iterator();\n",
        "1043": "      while (i.hasNext()) {\n",
        "1044": "        ReferenceEntry<Object, Object> entry = i.next();\n",
        "1045": "        if (random.nextBoolean()) {\n",
        "1046": "          segment.recordWrite(entry);\n",
        "1047": "          writes.add(entry);\n",
        "1048": "          i.remove();\n",
        "1049": "        }\n",
        "1050": "      }\n",
        "1051": "      writeOrder.addAll(writes);\n",
        "1052": "\n",
        "1053": "      checkEvictionQueues(map, segment, writeOrder, writeOrder);\n",
        "1054": "      checkExpirationTimes(map);\n",
        "1055": "    }\n",
        "1056": "  }\n",
        "1057": "\n",
        "1058": "  static <K, V> void checkEvictionQueues(MapMakerInternalMap<K, V> map,\n",
        "1059": "      Segment<K, V> segment, List<ReferenceEntry<K, V>> readOrder,\n",
        "1060": "      List<ReferenceEntry<K, V>> writeOrder) {\n",
        "1061": "    if (map.expires()) {\n",
        "1062": "      assertSameEntries(writeOrder, ImmutableList.copyOf(segment.expirationQueue));\n",
        "1063": "    }\n",
        "1064": "  }\n",
        "1065": "\n",
        "1066": "  private static <K, V> void assertSameEntries(List<ReferenceEntry<K, V>> expectedEntries,\n",
        "1067": "      List<ReferenceEntry<K, V>> actualEntries) {\n",
        "1068": "    int size = expectedEntries.size();\n",
        "1069": "    assertEquals(size, actualEntries.size());\n",
        "1070": "    for (int i = 0; i < size; i++) {\n",
        "1071": "      ReferenceEntry<K, V> expectedEntry = expectedEntries.get(0);\n",
        "1072": "      ReferenceEntry<K, V> actualEntry = actualEntries.get(0);\n",
        "1073": "      assertSame(expectedEntry.getKey(), actualEntry.getKey());\n",
        "1074": "      assertSame(expectedEntry.getValueReference().get(), actualEntry.getValueReference().get());\n",
        "1075": "    }\n",
        "1076": "  }\n",
        "1077": "\n",
        "1078": "  static <K, V> void checkExpirationTimes(MapMakerInternalMap<K, V> map) {\n",
        "1079": "    if (!map.expires()) {\n",
        "1080": "      return;\n",
        "1081": "    }\n",
        "1082": "\n",
        "1083": "    for (Segment<K, V> segment : map.segments) {\n",
        "1084": "      long lastExpirationTime = 0;\n",
        "1085": "      for (ReferenceEntry<K, V> e : segment.expirationQueue) {\n",
        "1086": "        long expirationTime = e.getExpirationTime();\n",
        "1087": "        assertTrue(expirationTime >= lastExpirationTime);\n",
        "1088": "        lastExpirationTime = expirationTime;\n",
        "1089": "      }\n",
        "1090": "    }\n",
        "1091": "  }\n",
        "1092": "\n",
        "1221": "  /**\n",
        "1222": "   * Returns an iterable containing all combinations of expireAfterWrite,\n",
        "1223": "   * weakKeys and weak/softValues.\n",
        "1224": "   */\n",
        "1225": "  private static Iterable<MapMaker> allEntryTypeMakers() {\n",
        "1226": "    List<MapMaker> result = newArrayList(allKeyValueStrengthMakers());\n",
        "1227": "    for (MapMaker maker : allKeyValueStrengthMakers()) {\n",
        "1228": "      result.add(maker.expireAfterWrite(99999, SECONDS));\n",
        "1229": "    }\n",
        "1230": "    return result;\n",
        "1231": "  }\n",
        "1232": "\n",
        "1233": "  /**\n",
        "1234": "   * Returns an iterable containing all combinations of expireAfterWrite.\n",
        "1235": "   */\n",
        "1236": "  static Iterable<MapMaker> allEvictingMakers() {\n",
        "1237": "    return ImmutableList.of(\n",
        "1238": "        createMapMaker().expireAfterWrite(99999, SECONDS),\n",
        "1239": "        createMapMaker().expireAfterWrite(SMALL_MAX_SIZE, TimeUnit.SECONDS));\n",
        "1240": "  }\n",
        "1241": "\n",
        "1309": "\n",
        "1310": "    private long expirationTime = Long.MAX_VALUE;\n",
        "1311": "\n",
        "1312": "    @Override\n",
        "1313": "    public long getExpirationTime() {\n",
        "1314": "      return expirationTime;\n",
        "1315": "    }\n",
        "1316": "\n",
        "1317": "    @Override\n",
        "1318": "    public void setExpirationTime(long time) {\n",
        "1319": "      this.expirationTime = time;\n",
        "1320": "    }\n",
        "1321": "\n",
        "1322": "    private ReferenceEntry<K, V> nextExpirable = nullEntry();\n",
        "1323": "\n",
        "1324": "    @Override\n",
        "1325": "    public ReferenceEntry<K, V> getNextExpirable() {\n",
        "1326": "      return nextExpirable;\n",
        "1327": "    }\n",
        "1328": "\n",
        "1329": "    @Override\n",
        "1330": "    public void setNextExpirable(ReferenceEntry<K, V> next) {\n",
        "1331": "      this.nextExpirable = next;\n",
        "1332": "    }\n",
        "1333": "\n",
        "1334": "    private ReferenceEntry<K, V> previousExpirable = nullEntry();\n",
        "1335": "\n",
        "1336": "    @Override\n",
        "1337": "    public ReferenceEntry<K, V> getPreviousExpirable() {\n",
        "1338": "      return previousExpirable;\n",
        "1339": "    }\n",
        "1340": "\n",
        "1341": "    @Override\n",
        "1342": "    public void setPreviousExpirable(ReferenceEntry<K, V> previous) {\n",
        "1343": "      this.previousExpirable = previous;\n",
        "1344": "    }\n",
        "1345": "\n",
        "1346": "    private ReferenceEntry<K, V> nextEvictable = nullEntry();\n",
        "1347": "\n",
        "1348": "    @Override\n",
        "1349": "    public ReferenceEntry<K, V> getNextEvictable() {\n",
        "1350": "      return nextEvictable;\n",
        "1351": "    }\n",
        "1352": "\n",
        "1353": "    @Override\n",
        "1354": "    public void setNextEvictable(ReferenceEntry<K, V> next) {\n",
        "1355": "      this.nextEvictable = next;\n",
        "1356": "    }\n",
        "1357": "\n",
        "1358": "    private ReferenceEntry<K, V> previousEvictable = nullEntry();\n",
        "1359": "\n",
        "1360": "    @Override\n",
        "1361": "    public ReferenceEntry<K, V> getPreviousEvictable() {\n",
        "1362": "      return previousEvictable;\n",
        "1363": "    }\n",
        "1364": "\n",
        "1365": "    @Override\n",
        "1366": "    public void setPreviousEvictable(ReferenceEntry<K, V> previous) {\n",
        "1367": "      this.previousEvictable = previous;\n",
        "1368": "    }\n"
    }
}