{
    "addition": {},
    "removed": {
        "19": "import static com.google.common.collect.MapMakerInternalMapTest.SMALL_MAX_SIZE;\n",
        "20": "import static com.google.common.collect.MapMakerInternalMapTest.allEvictingMakers;\n",
        "21": "import static com.google.common.collect.MapMakerInternalMapTest.checkEvictionQueues;\n",
        "22": "import static com.google.common.collect.MapMakerInternalMapTest.checkExpirationTimes;\n",
        "23": "\n",
        "35": "import java.util.Iterator;\n",
        "36": "import java.util.List;\n",
        "37": "import java.util.Random;\n",
        "40": "import java.util.concurrent.TimeUnit;\n",
        "100": "  public void testRecordReadOnCompute() throws ExecutionException {\n",
        "101": "    CountingFunction computingFunction = new CountingFunction();\n",
        "102": "    for (MapMaker maker : allEvictingMakers()) {\n",
        "103": "      ComputingConcurrentHashMap<Object, Object> map =\n",
        "104": "          makeComputingMap(maker.concurrencyLevel(1), computingFunction);\n",
        "105": "      Segment<Object, Object> segment = map.segments[0];\n",
        "106": "      List<ReferenceEntry<Object, Object>> writeOrder = Lists.newLinkedList();\n",
        "107": "      List<ReferenceEntry<Object, Object>> readOrder = Lists.newLinkedList();\n",
        "108": "      for (int i = 0; i < SMALL_MAX_SIZE; i++) {\n",
        "109": "        Object key = new Object();\n",
        "110": "        int hash = map.hash(key);\n",
        "111": "\n",
        "112": "        map.getOrCompute(key);\n",
        "113": "        ReferenceEntry<Object, Object> entry = segment.getEntry(key, hash);\n",
        "114": "        writeOrder.add(entry);\n",
        "115": "        readOrder.add(entry);\n",
        "116": "      }\n",
        "117": "\n",
        "118": "      checkEvictionQueues(map, segment, readOrder, writeOrder);\n",
        "119": "      checkExpirationTimes(map);\n",
        "120": "\n",
        "121": "      // access some of the elements\n",
        "122": "      Random random = new Random();\n",
        "123": "      List<ReferenceEntry<Object, Object>> reads = Lists.newArrayList();\n",
        "124": "      Iterator<ReferenceEntry<Object, Object>> i = readOrder.iterator();\n",
        "125": "      while (i.hasNext()) {\n",
        "126": "        ReferenceEntry<Object, Object> entry = i.next();\n",
        "127": "        if (random.nextBoolean()) {\n",
        "128": "          map.getOrCompute(entry.getKey());\n",
        "129": "          reads.add(entry);\n",
        "130": "          i.remove();\n",
        "131": "        }\n",
        "132": "      }\n",
        "133": "      readOrder.addAll(reads);\n",
        "134": "\n",
        "135": "      checkEvictionQueues(map, segment, readOrder, writeOrder);\n",
        "136": "      checkExpirationTimes(map);\n",
        "137": "    }\n",
        "138": "  }\n",
        "139": "\n",
        "212": "  @AndroidIncompatible // Perhaps emulator clock does not update between the two get() calls?\n",
        "213": "  @SuppressWarnings(\"deprecation\") // test of deprecated method\n",
        "214": "  public void testComputeExpiredEntry() throws ExecutionException {\n",
        "215": "    MapMaker maker = createMapMaker().expireAfterWrite(1, TimeUnit.NANOSECONDS);\n",
        "216": "    CountingFunction computingFunction = new CountingFunction();\n",
        "217": "    ComputingConcurrentHashMap<Object, Object> map = makeComputingMap(maker, computingFunction);\n",
        "218": "    assertEquals(0, computingFunction.getCount());\n",
        "219": "\n",
        "220": "    Object key = new Object();\n",
        "221": "    Object one = map.getOrCompute(key);\n",
        "222": "    assertEquals(1, computingFunction.getCount());\n",
        "223": "\n",
        "224": "    Object two = map.getOrCompute(key);\n",
        "225": "    assertNotSame(one, two);\n",
        "226": "    assertEquals(2, computingFunction.getCount());\n",
        "227": "  }\n",
        "228": "\n"
    }
}