{
    "addition": {
        "53": " * <li>keys or values automatically wrapped in {@linkplain WeakReference weak} references\n",
        "72": " * specified, the map uses identity ({@code ==}) comparisons instead for keys. Likewise, if\n",
        "73": " * {@link #weakValues}\n",
        "74": " * was specified, the map uses identity comparisons for values.\n",
        "81": " * <p>If {@link #weakKeys}/{@link #weakValues}\n",
        "82": " * are requested, it is possible for a key or value present in the map to be reclaimed by the\n",
        "83": " * garbage collector. Entries with reclaimed keys or values may be removed from the map on each map\n",
        "84": " * modification or on occasional map accesses; such entries may be counted by {@link Map#size}, but\n",
        "85": " * will never be visible to read or write operations. A partially-reclaimed entry is never exposed\n",
        "86": " * to the user. Any {@link java.util.Map.Entry} instance retrieved from the map's\n",
        "87": " * {@linkplain Map#entrySet entry set} is a snapshot of that entry's state at the time of retrieval;\n",
        "88": " * such entries do, however, support {@link java.util.Map.Entry#setValue}, which simply calls\n",
        "89": " * {@link Map#put} on the entry's key.\n",
        "93": " * used weak\n",
        "94": " * references, the entries are reconstructed as they were, but it's not unlikely they'll be quickly\n",
        "95": " * garbage-collected before they are ever accessed.\n",
        "97": " * <p>{@code new MapMaker().weakKeys().makeMap()} is a recommended replacement for\n",
        "98": " * {@link java.util.WeakHashMap}, but note that it compares keys using object identity whereas\n",
        "99": " * {@code WeakHashMap} uses {@link Object#equals}.\n",
        "143": "   * <p>By default, the map uses {@link Equivalence#identity} to determine key equality when\n",
        "144": "   * {@link #weakKeys} is specified, and {@link Equivalence#equals()} otherwise. The only place this\n",
        "145": "   * is used is in {@link Interners.WeakInterner}.\n",
        "194": "   * immediately. This has the same effect as invoking {@link #expireAfterWrite expireAfterWrite}\n",
        "195": "   * {@code (0, unit)} or {@link #expireAfterAccess expireAfterAccess}{@code (0, unit)}. It can be\n",
        "196": "   * useful in testing, or to disable caching temporarily without a code change.\n",
        "205": "   *     {@link com.google.common.cache.CacheBuilder}, with {@link #maximumSize} being replaced by\n",
        "206": "   *     {@link com.google.common.cache.CacheBuilder#maximumSize}. Note that {@code CacheBuilder} is\n",
        "207": "   *     simply an enhanced API for an implementation which was branched from {@code MapMaker}.\n",
        "214": "        this.maximumSize == UNSET_INT, \"maximum size was already set to %s\", this.maximumSize);\n",
        "261": "   * Specifies that each key (not value) stored in the map should be wrapped in a\n",
        "262": "   * {@link WeakReference} (by default, strong references are used).\n",
        "298": "   * candidate for caching.\n",
        "301": "   * comparison to determine equality of values. This technically violates the specifications of the\n",
        "302": "   * methods {@link Map#containsValue containsValue}, {@link ConcurrentMap#remove(Object, Object)\n",
        "303": "   * remove(Object, Object)} and {@link ConcurrentMap#replace(Object, Object, Object) replace(K, V,\n",
        "304": "   * V)}, and may not be what you expect.\n",
        "322": "   * <p><b>Warning:</b> in most circumstances it is better to set a per-cache\n",
        "323": "   * {@linkplain #maximumSize maximum size} instead of using soft references. You should only use\n",
        "324": "   * this method if you are well familiar with the practical consequences of soft references.\n",
        "327": "   * comparison to determine equality of values. This technically violates the specifications of the\n",
        "328": "   * methods {@link Map#containsValue containsValue}, {@link ConcurrentMap#remove(Object, Object)\n",
        "329": "   * remove(Object, Object)} and {@link ConcurrentMap#replace(Object, Object, Object) replace(K, V,\n",
        "330": "   * V)}, and may not be what you expect.\n",
        "333": "   * @deprecated Caching functionality in {@code MapMaker} has been moved to\n",
        "334": "   *     {@link com.google.common.cache.CacheBuilder}, with {@link #softValues} being replaced by\n",
        "335": "   *     {@link com.google.common.cache.CacheBuilder#softValues}. Note that {@code CacheBuilder} is\n",
        "336": "   *     simply an enhanced API for an implementation which was branched from {@code MapMaker}.\n",
        "380": "   *     {@link com.google.common.cache.CacheBuilder}, with {@link #expireAfterWrite} being replaced\n",
        "381": "   *     by {@link com.google.common.cache.CacheBuilder#expireAfterWrite}. Note that\n",
        "382": "   *     {@code CacheBuilder} is simply an enhanced API for an implementation which was branched\n",
        "383": "   *     from {@code MapMaker}.\n",
        "474": "   * <p><b>Important note:</b> Instead of returning <i>this</i> as a {@code MapMaker} instance, this\n",
        "475": "   * method returns {@code GenericMapMaker<K, V>}. From this point on, either the original reference\n",
        "476": "   * or the returned reference may be used to complete configuration and build the map, but only the\n",
        "477": "   * \"generic\" one is type-safe. That is, it will properly prevent you from building maps whose key\n",
        "478": "   * or value types are incompatible with the types accepted by the listener already provided; the\n",
        "479": "   * {@code MapMaker} type cannot do this. For best results, simply use the standard method-chaining\n",
        "480": "   * idiom, as illustrated in the documentation at top, configuring a {@code MapMaker} and building\n",
        "481": "   * your {@link Map} all in a single statement.\n",
        "489": "   *     {@link com.google.common.cache.CacheBuilder}, with {@link #removalListener} being replaced\n",
        "490": "   *     by {@link com.google.common.cache.CacheBuilder#removalListener}. Note that\n",
        "491": "   *     {@code CacheBuilder} is simply an enhanced API for an implementation which was branched\n",
        "492": "   *     from {@code MapMaker}.\n",
        "513": "   * be performed atomically on the returned map. Additionally, {@code size} and\n",
        "514": "   * {@code containsValue} are implemented as bulk read operations, and thus may fail to observe\n",
        "515": "   * concurrent writes.\n",
        "530": "   * Returns a MapMakerInternalMap for the benefit of internal callers that use features of that\n",
        "531": "   * class not exposed through ConcurrentMap.\n",
        "560": "   * result\n",
        "584": "   * be performed atomically on the returned map. Additionally, {@code size} and\n",
        "585": "   * {@code containsValue} are implemented as bulk read operations, and thus may fail to observe\n",
        "586": "   * concurrent writes.\n",
        "593": "   *     <a href=\"https://github.com/google/guava/wiki/MapMakerMigration\">MapMaker Migration\n",
        "594": "   *     Guide</a> for more details.\n",
        "651": "   * @param <K> the most general type of keys this listener can listen for; for example\n",
        "652": "   *     {@code Object} if any key is acceptable\n",
        "653": "   * @param <V> the most general type of values this listener can listen for; for example\n",
        "654": "   *     {@code Object} if any key is acceptable\n",
        "736": "     * The entry's expiration timestamp has passed. This can occur when using\n",
        "737": "     * {@link #expireAfterWrite} or {@link #expireAfterAccess}.\n",
        "747": "     * The entry was evicted due to size constraints. This can occur when using\n",
        "748": "     * {@link #maximumSize}.\n"
    },
    "removed": {
        "53": " * <li>keys or values automatically wrapped in {@linkplain WeakReference weak} or {@linkplain\n",
        "54": " *     SoftReference soft} references\n",
        "55": " * <li>notification of evicted (or otherwise removed) entries\n",
        "74": " * specified, the map uses identity ({@code ==}) comparisons instead for keys. Likewise, if {@link\n",
        "75": " * #weakValues} or {@link #softValues} was specified, the map uses identity comparisons for values.\n",
        "82": " * <p>If {@link #weakKeys}, {@link #weakValues}, or {@link #softValues} are requested, it is\n",
        "83": " * possible for a key or value present in the map to be reclaimed by the garbage collector. Entries\n",
        "84": " * with reclaimed keys or values may be removed from the map on each map modification or on\n",
        "85": " * occasional map accesses; such entries may be counted by {@link Map#size}, but will never be\n",
        "86": " * visible to read or write operations. A partially-reclaimed entry is never exposed to the user.\n",
        "87": " * Any {@link java.util.Map.Entry} instance retrieved from the map's\n",
        "88": " * {@linkplain Map#entrySet entry set} is a snapshot of that entry's state at the time of\n",
        "89": " * retrieval; such entries do, however, support {@link java.util.Map.Entry#setValue}, which simply\n",
        "90": " * calls {@link Map#put} on the entry's key.\n",
        "94": " * used soft or weak references, the entries are reconstructed as they were, but it's not unlikely\n",
        "95": " * they'll be quickly garbage-collected before they are ever accessed.\n",
        "97": " * <p>{@code new MapMaker().weakKeys().makeMap()} is a recommended replacement for {@link\n",
        "98": " * java.util.WeakHashMap}, but note that it compares keys using object identity whereas {@code\n",
        "99": " * WeakHashMap} uses {@link Object#equals}.\n",
        "143": "   * <p>By default, the map uses {@link Equivalence#identity} to determine key equality when {@link\n",
        "144": "   * #weakKeys} is specified, and {@link Equivalence#equals()} otherwise. The only place this is\n",
        "145": "   * used is in {@link Interners.WeakInterner}.\n",
        "194": "   * immediately. This has the same effect as invoking {@link #expireAfterWrite\n",
        "195": "   * expireAfterWrite}{@code (0, unit)} or {@link #expireAfterAccess expireAfterAccess}{@code (0,\n",
        "196": "   * unit)}. It can be useful in testing, or to disable caching temporarily without a code change.\n",
        "205": "   *     {@link com.google.common.cache.CacheBuilder}, with {@link #maximumSize} being\n",
        "206": "   *     replaced by {@link com.google.common.cache.CacheBuilder#maximumSize}. Note that {@code\n",
        "207": "   *     CacheBuilder} is simply an enhanced API for an implementation which was branched from\n",
        "208": "   *     {@code MapMaker}.\n",
        "215": "        this.maximumSize == UNSET_INT,\n",
        "216": "        \"maximum size was already set to %s\",\n",
        "217": "        this.maximumSize);\n",
        "264": "   * Specifies that each key (not value) stored in the map should be wrapped in a {@link\n",
        "265": "   * WeakReference} (by default, strong references are used).\n",
        "301": "   * candidate for caching; consider {@link #softValues} instead.\n",
        "304": "   * comparison to determine equality of values. This technically violates the specifications of\n",
        "305": "   * the methods {@link Map#containsValue containsValue},\n",
        "306": "   * {@link ConcurrentMap#remove(Object, Object) remove(Object, Object)} and\n",
        "307": "   * {@link ConcurrentMap#replace(Object, Object, Object) replace(K, V, V)}, and may not be what you\n",
        "308": "   * expect.\n",
        "326": "   * <p><b>Warning:</b> in most circumstances it is better to set a per-cache {@linkplain\n",
        "327": "   * #maximumSize maximum size} instead of using soft references. You should only use this method if\n",
        "328": "   * you are well familiar with the practical consequences of soft references.\n",
        "331": "   * comparison to determine equality of values. This technically violates the specifications of\n",
        "332": "   * the methods {@link Map#containsValue containsValue},\n",
        "333": "   * {@link ConcurrentMap#remove(Object, Object) remove(Object, Object)} and\n",
        "334": "   * {@link ConcurrentMap#replace(Object, Object, Object) replace(K, V, V)}, and may not be what you\n",
        "335": "   * expect.\n",
        "338": "   * @see SoftReference\n",
        "339": "   * @deprecated Caching functionality in {@code MapMaker} has been moved to {@link\n",
        "340": "   *     com.google.common.cache.CacheBuilder}, with {@link #softValues} being replaced by {@link\n",
        "341": "   *     com.google.common.cache.CacheBuilder#softValues}. Note that {@code CacheBuilder} is simply\n",
        "342": "   *     an enhanced API for an implementation which was branched from {@code MapMaker}.\n",
        "386": "   *     {@link com.google.common.cache.CacheBuilder}, with {@link #expireAfterWrite} being\n",
        "387": "   *     replaced by {@link com.google.common.cache.CacheBuilder#expireAfterWrite}. Note that {@code\n",
        "388": "   *     CacheBuilder} is simply an enhanced API for an implementation which was branched from\n",
        "389": "   *     {@code MapMaker}.\n",
        "480": "   * <p><b>Important note:</b> Instead of returning <i>this</i> as a {@code MapMaker} instance,\n",
        "481": "   * this method returns {@code GenericMapMaker<K, V>}. From this point on, either the original\n",
        "482": "   * reference or the returned reference may be used to complete configuration and build the map,\n",
        "483": "   * but only the \"generic\" one is type-safe. That is, it will properly prevent you from building\n",
        "484": "   * maps whose key or value types are incompatible with the types accepted by the listener already\n",
        "485": "   * provided; the {@code MapMaker} type cannot do this. For best results, simply use the standard\n",
        "486": "   * method-chaining idiom, as illustrated in the documentation at top, configuring a {@code\n",
        "487": "   * MapMaker} and building your {@link Map} all in a single statement.\n",
        "495": "   *     {@link com.google.common.cache.CacheBuilder}, with {@link #removalListener} being\n",
        "496": "   *     replaced by {@link com.google.common.cache.CacheBuilder#removalListener}. Note that {@code\n",
        "497": "   *     CacheBuilder} is simply an enhanced API for an implementation which was branched from\n",
        "498": "   *     {@code MapMaker}.\n",
        "519": "   * be performed atomically on the returned map. Additionally, {@code size} and {@code\n",
        "520": "   * containsValue} are implemented as bulk read operations, and thus may fail to observe concurrent\n",
        "521": "   * writes.\n",
        "536": "   * Returns a MapMakerInternalMap for the benefit of internal callers that use features of\n",
        "537": "   * that class not exposed through ConcurrentMap.\n",
        "566": "   *     result\n",
        "590": "   * be performed atomically on the returned map. Additionally, {@code size} and {@code\n",
        "591": "   * containsValue} are implemented as bulk read operations, and thus may fail to observe concurrent\n",
        "592": "   * writes.\n",
        "599": "   *     <a href=\"https://github.com/google/guava/wiki/MapMakerMigration\">MapMaker\n",
        "600": "   *     Migration Guide</a> for more details.\n",
        "657": "   * @param <K> the most general type of keys this listener can listen for; for\n",
        "658": "   *     example {@code Object} if any key is acceptable\n",
        "659": "   * @param <V> the most general type of values this listener can listen for; for\n",
        "660": "   *     example {@code Object} if any key is acceptable\n",
        "742": "     * The entry's expiration timestamp has passed. This can occur when using {@link\n",
        "743": "     * #expireAfterWrite} or {@link #expireAfterAccess}.\n",
        "753": "     * The entry was evicted due to size constraints. This can occur when using {@link\n",
        "754": "     * #maximumSize}.\n"
    }
}