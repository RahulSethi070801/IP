{"id": "517267d764f32383fdac36fcd6eabad855dd2f93", "code": [{"0": "guava/src/com/google/common/collect/MapMaker.java", "added": {"1": [" * <li>keys or values automatically wrapped in {@linkplain WeakReference weak} references\n"], "2": [" * specified, the map uses identity ({@code ==}) comparisons instead for keys. Likewise, if\n", " * {@link #weakValues}\n", " * was specified, the map uses identity comparisons for values.\n", " * <p>If {@link #weakKeys}/{@link #weakValues}\n", " * are requested, it is possible for a key or value present in the map to be reclaimed by the\n", " * garbage collector. Entries with reclaimed keys or values may be removed from the map on each map\n", " * modification or on occasional map accesses; such entries may be counted by {@link Map#size}, but\n", " * will never be visible to read or write operations. A partially-reclaimed entry is never exposed\n", " * to the user. Any {@link java.util.Map.Entry} instance retrieved from the map's\n", " * {@linkplain Map#entrySet entry set} is a snapshot of that entry's state at the time of retrieval;\n", " * such entries do, however, support {@link java.util.Map.Entry#setValue}, which simply calls\n", " * {@link Map#put} on the entry's key.\n", " * used weak\n", " * references, the entries are reconstructed as they were, but it's not unlikely they'll be quickly\n", " * garbage-collected before they are ever accessed.\n", " * <p>{@code new MapMaker().weakKeys().makeMap()} is a recommended replacement for\n", " * {@link java.util.WeakHashMap}, but note that it compares keys using object identity whereas\n", " * {@code WeakHashMap} uses {@link Object#equals}.\n"], "3": ["   * <p>By default, the map uses {@link Equivalence#identity} to determine key equality when\n", "   * {@link #weakKeys} is specified, and {@link Equivalence#equals()} otherwise. The only place this\n", "   * is used is in {@link Interners.WeakInterner}.\n"], "4": ["   * immediately. This has the same effect as invoking {@link #expireAfterWrite expireAfterWrite}\n", "   * {@code (0, unit)} or {@link #expireAfterAccess expireAfterAccess}{@code (0, unit)}. It can be\n", "   * useful in testing, or to disable caching temporarily without a code change.\n"], "5": ["   *     {@link com.google.common.cache.CacheBuilder}, with {@link #maximumSize} being replaced by\n", "   *     {@link com.google.common.cache.CacheBuilder#maximumSize}. Note that {@code CacheBuilder} is\n", "   *     simply an enhanced API for an implementation which was branched from {@code MapMaker}.\n", "        this.maximumSize == UNSET_INT, \"maximum size was already set to %s\", this.maximumSize);\n"], "6": ["   * Specifies that each key (not value) stored in the map should be wrapped in a\n", "   * {@link WeakReference} (by default, strong references are used).\n"], "7": ["   * candidate for caching.\n", "   * comparison to determine equality of values. This technically violates the specifications of the\n", "   * methods {@link Map#containsValue containsValue}, {@link ConcurrentMap#remove(Object, Object)\n", "   * remove(Object, Object)} and {@link ConcurrentMap#replace(Object, Object, Object) replace(K, V,\n", "   * V)}, and may not be what you expect.\n"], "8": ["   * <p><b>Warning:</b> in most circumstances it is better to set a per-cache\n", "   * {@linkplain #maximumSize maximum size} instead of using soft references. You should only use\n", "   * this method if you are well familiar with the practical consequences of soft references.\n", "   * comparison to determine equality of values. This technically violates the specifications of the\n", "   * methods {@link Map#containsValue containsValue}, {@link ConcurrentMap#remove(Object, Object)\n", "   * remove(Object, Object)} and {@link ConcurrentMap#replace(Object, Object, Object) replace(K, V,\n", "   * V)}, and may not be what you expect.\n", "   * @deprecated Caching functionality in {@code MapMaker} has been moved to\n", "   *     {@link com.google.common.cache.CacheBuilder}, with {@link #softValues} being replaced by\n", "   *     {@link com.google.common.cache.CacheBuilder#softValues}. Note that {@code CacheBuilder} is\n", "   *     simply an enhanced API for an implementation which was branched from {@code MapMaker}.\n"], "9": ["   *     {@link com.google.common.cache.CacheBuilder}, with {@link #expireAfterWrite} being replaced\n", "   *     by {@link com.google.common.cache.CacheBuilder#expireAfterWrite}. Note that\n", "   *     {@code CacheBuilder} is simply an enhanced API for an implementation which was branched\n", "   *     from {@code MapMaker}.\n"], "10": ["   * <p><b>Important note:</b> Instead of returning <i>this</i> as a {@code MapMaker} instance, this\n", "   * method returns {@code GenericMapMaker<K, V>}. From this point on, either the original reference\n", "   * or the returned reference may be used to complete configuration and build the map, but only the\n", "   * \"generic\" one is type-safe. That is, it will properly prevent you from building maps whose key\n", "   * or value types are incompatible with the types accepted by the listener already provided; the\n", "   * {@code MapMaker} type cannot do this. For best results, simply use the standard method-chaining\n", "   * idiom, as illustrated in the documentation at top, configuring a {@code MapMaker} and building\n", "   * your {@link Map} all in a single statement.\n"], "11": ["   *     {@link com.google.common.cache.CacheBuilder}, with {@link #removalListener} being replaced\n", "   *     by {@link com.google.common.cache.CacheBuilder#removalListener}. Note that\n", "   *     {@code CacheBuilder} is simply an enhanced API for an implementation which was branched\n", "   *     from {@code MapMaker}.\n"], "12": ["   * be performed atomically on the returned map. Additionally, {@code size} and\n", "   * {@code containsValue} are implemented as bulk read operations, and thus may fail to observe\n", "   * concurrent writes.\n"], "13": ["   * Returns a MapMakerInternalMap for the benefit of internal callers that use features of that\n", "   * class not exposed through ConcurrentMap.\n"], "14": ["   * result\n"], "15": ["   * be performed atomically on the returned map. Additionally, {@code size} and\n", "   * {@code containsValue} are implemented as bulk read operations, and thus may fail to observe\n", "   * concurrent writes.\n", "   *     <a href=\"https://github.com/google/guava/wiki/MapMakerMigration\">MapMaker Migration\n", "   *     Guide</a> for more details.\n"], "16": ["   * @param <K> the most general type of keys this listener can listen for; for example\n", "   *     {@code Object} if any key is acceptable\n", "   * @param <V> the most general type of values this listener can listen for; for example\n", "   *     {@code Object} if any key is acceptable\n"], "17": ["     * The entry's expiration timestamp has passed. This can occur when using\n", "     * {@link #expireAfterWrite} or {@link #expireAfterAccess}.\n"], "18": ["     * The entry was evicted due to size constraints. This can occur when using\n", "     * {@link #maximumSize}.\n"]}, "removed": {"1": [" * <li>keys or values automatically wrapped in {@linkplain WeakReference weak} or {@linkplain\n", " *     SoftReference soft} references\n", " * <li>notification of evicted (or otherwise removed) entries\n"], "2": [" * specified, the map uses identity ({@code ==}) comparisons instead for keys. Likewise, if {@link\n", " * #weakValues} or {@link #softValues} was specified, the map uses identity comparisons for values.\n", " * <p>If {@link #weakKeys}, {@link #weakValues}, or {@link #softValues} are requested, it is\n", " * possible for a key or value present in the map to be reclaimed by the garbage collector. Entries\n", " * with reclaimed keys or values may be removed from the map on each map modification or on\n", " * occasional map accesses; such entries may be counted by {@link Map#size}, but will never be\n", " * visible to read or write operations. A partially-reclaimed entry is never exposed to the user.\n", " * Any {@link java.util.Map.Entry} instance retrieved from the map's\n", " * {@linkplain Map#entrySet entry set} is a snapshot of that entry's state at the time of\n", " * retrieval; such entries do, however, support {@link java.util.Map.Entry#setValue}, which simply\n", " * calls {@link Map#put} on the entry's key.\n", " * used soft or weak references, the entries are reconstructed as they were, but it's not unlikely\n", " * they'll be quickly garbage-collected before they are ever accessed.\n", " * <p>{@code new MapMaker().weakKeys().makeMap()} is a recommended replacement for {@link\n", " * java.util.WeakHashMap}, but note that it compares keys using object identity whereas {@code\n", " * WeakHashMap} uses {@link Object#equals}.\n"], "3": ["   * <p>By default, the map uses {@link Equivalence#identity} to determine key equality when {@link\n", "   * #weakKeys} is specified, and {@link Equivalence#equals()} otherwise. The only place this is\n", "   * used is in {@link Interners.WeakInterner}.\n"], "4": ["   * immediately. This has the same effect as invoking {@link #expireAfterWrite\n", "   * expireAfterWrite}{@code (0, unit)} or {@link #expireAfterAccess expireAfterAccess}{@code (0,\n", "   * unit)}. It can be useful in testing, or to disable caching temporarily without a code change.\n"], "5": ["   *     {@link com.google.common.cache.CacheBuilder}, with {@link #maximumSize} being\n", "   *     replaced by {@link com.google.common.cache.CacheBuilder#maximumSize}. Note that {@code\n", "   *     CacheBuilder} is simply an enhanced API for an implementation which was branched from\n", "   *     {@code MapMaker}.\n", "        this.maximumSize == UNSET_INT,\n", "        \"maximum size was already set to %s\",\n", "        this.maximumSize);\n"], "6": ["   * Specifies that each key (not value) stored in the map should be wrapped in a {@link\n", "   * WeakReference} (by default, strong references are used).\n"], "7": ["   * candidate for caching; consider {@link #softValues} instead.\n", "   * comparison to determine equality of values. This technically violates the specifications of\n", "   * the methods {@link Map#containsValue containsValue},\n", "   * {@link ConcurrentMap#remove(Object, Object) remove(Object, Object)} and\n", "   * {@link ConcurrentMap#replace(Object, Object, Object) replace(K, V, V)}, and may not be what you\n", "   * expect.\n"], "8": ["   * <p><b>Warning:</b> in most circumstances it is better to set a per-cache {@linkplain\n", "   * #maximumSize maximum size} instead of using soft references. You should only use this method if\n", "   * you are well familiar with the practical consequences of soft references.\n", "   * comparison to determine equality of values. This technically violates the specifications of\n", "   * the methods {@link Map#containsValue containsValue},\n", "   * {@link ConcurrentMap#remove(Object, Object) remove(Object, Object)} and\n", "   * {@link ConcurrentMap#replace(Object, Object, Object) replace(K, V, V)}, and may not be what you\n", "   * expect.\n", "   * @see SoftReference\n", "   * @deprecated Caching functionality in {@code MapMaker} has been moved to {@link\n", "   *     com.google.common.cache.CacheBuilder}, with {@link #softValues} being replaced by {@link\n", "   *     com.google.common.cache.CacheBuilder#softValues}. Note that {@code CacheBuilder} is simply\n", "   *     an enhanced API for an implementation which was branched from {@code MapMaker}.\n"], "9": ["   *     {@link com.google.common.cache.CacheBuilder}, with {@link #expireAfterWrite} being\n", "   *     replaced by {@link com.google.common.cache.CacheBuilder#expireAfterWrite}. Note that {@code\n", "   *     CacheBuilder} is simply an enhanced API for an implementation which was branched from\n", "   *     {@code MapMaker}.\n"], "10": ["   * <p><b>Important note:</b> Instead of returning <i>this</i> as a {@code MapMaker} instance,\n", "   * this method returns {@code GenericMapMaker<K, V>}. From this point on, either the original\n", "   * reference or the returned reference may be used to complete configuration and build the map,\n", "   * but only the \"generic\" one is type-safe. That is, it will properly prevent you from building\n", "   * maps whose key or value types are incompatible with the types accepted by the listener already\n", "   * provided; the {@code MapMaker} type cannot do this. For best results, simply use the standard\n", "   * method-chaining idiom, as illustrated in the documentation at top, configuring a {@code\n", "   * MapMaker} and building your {@link Map} all in a single statement.\n"], "11": ["   *     {@link com.google.common.cache.CacheBuilder}, with {@link #removalListener} being\n", "   *     replaced by {@link com.google.common.cache.CacheBuilder#removalListener}. Note that {@code\n", "   *     CacheBuilder} is simply an enhanced API for an implementation which was branched from\n", "   *     {@code MapMaker}.\n"], "12": ["   * be performed atomically on the returned map. Additionally, {@code size} and {@code\n", "   * containsValue} are implemented as bulk read operations, and thus may fail to observe concurrent\n", "   * writes.\n"], "13": ["   * Returns a MapMakerInternalMap for the benefit of internal callers that use features of\n", "   * that class not exposed through ConcurrentMap.\n"], "14": ["   *     result\n"], "15": ["   * be performed atomically on the returned map. Additionally, {@code size} and {@code\n", "   * containsValue} are implemented as bulk read operations, and thus may fail to observe concurrent\n", "   * writes.\n", "   *     <a href=\"https://github.com/google/guava/wiki/MapMakerMigration\">MapMaker\n", "   *     Migration Guide</a> for more details.\n"], "16": ["   * @param <K> the most general type of keys this listener can listen for; for\n", "   *     example {@code Object} if any key is acceptable\n", "   * @param <V> the most general type of values this listener can listen for; for\n", "   *     example {@code Object} if any key is acceptable\n"], "17": ["     * The entry's expiration timestamp has passed. This can occur when using {@link\n", "     * #expireAfterWrite} or {@link #expireAfterAccess}.\n"], "18": ["     * The entry was evicted due to size constraints. This can occur when using {@link\n", "     * #maximumSize}.\n"]}, "added_lines": {"1": [53], "2": [72, 73, 74, 81, 82, 83, 84, 85, 86, 87, 88, 89, 93, 94, 95, 97, 98, 99], "3": [143, 144, 145], "4": [194, 195, 196], "5": [205, 206, 207, 214], "6": [261, 262], "7": [298, 301, 302, 303, 304], "8": [322, 323, 324, 327, 328, 329, 330, 333, 334, 335, 336], "9": [380, 381, 382, 383], "10": [474, 475, 476, 477, 478, 479, 480, 481], "11": [489, 490, 491, 492], "12": [513, 514, 515], "13": [530, 531], "14": [560], "15": [584, 585, 586, 593, 594], "16": [651, 652, 653, 654], "17": [736, 737], "18": [747, 748]}, "removed_lines": {"1": [53, 54, 55], "2": [74, 75, 82, 83, 84, 85, 86, 87, 88, 89, 90, 94, 95, 97, 98, 99], "3": [143, 144, 145], "4": [194, 195, 196], "5": [205, 206, 207, 208, 215, 216, 217], "6": [264, 265], "7": [301, 304, 305, 306, 307, 308], "8": [326, 327, 328, 331, 332, 333, 334, 335, 338, 339, 340, 341, 342], "9": [386, 387, 388, 389], "10": [480, 481, 482, 483, 484, 485, 486, 487], "11": [495, 496, 497, 498], "12": [519, 520, 521], "13": [536, 537], "14": [566], "15": [590, 591, 592, 599, 600], "16": [657, 658, 659, 660], "17": [742, 743], "18": [753, 754]}}]}
