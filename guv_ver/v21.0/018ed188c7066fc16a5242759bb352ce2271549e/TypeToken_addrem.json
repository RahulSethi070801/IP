{
    "addition": {
        "4": " * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not use this file except\n",
        "5": " * in compliance with the License. You may obtain a copy of the License at\n",
        "9": " * Unless required by applicable law or agreed to in writing, software distributed under the License\n",
        "10": " * is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express\n",
        "11": " * or implied. See the License for the specific language governing permissions and limitations under\n",
        "12": " * the License.\n",
        "57": " * <p>There are three ways to get a {@code TypeToken} instance:\n",
        "58": " *\n",
        "59": " * <ul>\n",
        "60": " *\n",
        "61": " * <li>Wrap a {@code Type} obtained via reflection. For example:\n",
        "62": " *     {@code TypeToken.of(method.getGenericReturnType())}.\n",
        "63": " *\n",
        "66": " *\n",
        "67": " *     <p>Note that it's critical that the actual type argument is carried by a subclass. The\n",
        "68": " *     following code is wrong because it only captures the {@code <T>} type variable of the {@code\n",
        "69": " *     listType()} method signature; while {@code <String>} is lost in erasure:\n",
        "70": " *\n",
        "79": " *\n",
        "80": " * <li>Capture a generic type with a (usually anonymous) subclass and resolve it against a context\n",
        "81": " *     class that knows what the type parameters are. For example: <pre>   {@code\n",
        "86": " *\n",
        "91": " * <p>Note to Guice users: {@code} TypeToken is similar to Guice's {@code TypeLiteral} class except\n",
        "92": " * that it is serializable and offers numerous additional utility methods.\n",
        "111": "   * <p>Clients create an empty anonymous subclass. Doing so embeds the type parameter in the\n",
        "112": "   * anonymous class's type hierarchy so we can reconstitute it at runtime despite erasure.\n",
        "119": "    checkState(\n",
        "120": "        !(runtimeType instanceof TypeVariable),\n",
        "122": "            + \"You probably meant to call new TypeToken<%s>(getClass()) \"\n",
        "123": "            + \"that can resolve the type variable for you.\\n\"\n",
        "124": "            + \"If you do need to create a TypeToken of a type variable, \"\n",
        "125": "            + \"please use TypeToken.of() instead.\",\n",
        "126": "        runtimeType);\n",
        "133": "   * <p>Clients create an empty anonymous subclass. Doing so embeds the type parameter in the\n",
        "134": "   * anonymous class's type hierarchy so we can reconstitute it at runtime despite erasure.\n",
        "196": "   * <p>Returns a new {@code TypeToken} where type variables represented by {@code typeParam} are\n",
        "197": "   * substituted by {@code typeArg}. For example, it can be used to construct {@code Map<K, V>} for\n",
        "198": "   * any {@code K} and {@code V} type: <pre>   {@code\n",
        "211": "    TypeResolver resolver =\n",
        "212": "        new TypeResolver()\n",
        "213": "            .where(\n",
        "214": "                ImmutableMap.of(\n",
        "215": "                    new TypeResolver.TypeVariableKey(typeParam.typeVariable), typeArg.runtimeType));\n",
        "221": "   * <p>Returns a new {@code TypeToken} where type variables represented by {@code typeParam} are\n",
        "222": "   * substituted by {@code typeArg}. For example, it can be used to construct {@code Map<K, V>} for\n",
        "223": "   * any {@code K} and {@code V} type: <pre>   {@code\n",
        "240": "   * <p>Resolves the given {@code type} against the type context represented by this type. For\n",
        "241": "   * example: <pre>   {@code\n",
        "271": "   * {@link Object} or an interface. This method is similar but different from\n",
        "272": "   * {@link Class#getGenericSuperclass}. For example, {@code new TypeToken<StringArrayList>()\n",
        "273": "   * {}.getGenericSuperclass()} will return {@code new TypeToken<ArrayList<String>>() {}}; while\n",
        "274": "   * {@code StringArrayList.class.getGenericSuperclass()} will return {@code ArrayList<E>}, where\n",
        "275": "   * {@code E} is the type variable declared by class {@code ArrayList}.\n",
        "300": "  @Nullable\n",
        "301": "  private TypeToken<? super T> boundAsSuperclass(Type bound) {\n",
        "313": "   * similar but different from {@link Class#getGenericInterfaces()}. For example, {@code new\n",
        "314": "   * TypeToken<List<String>>() {}.getGenericInterfaces()} will return a list that contains\n",
        "333": "      TypeToken<? super T> resolvedInterface =\n",
        "334": "          (TypeToken<? super T>) resolveSupertype(interfaceType);\n",
        "369": "   * {@code ArrayList<String>}, {@code Iterable<String>} is returned given the input\n",
        "370": "   * {@code Iterable.class}.\n",
        "373": "    checkArgument(\n",
        "374": "        this.someRawTypeIsSubclassOf(superclass),\n",
        "375": "        \"%s is not a super class of %s\",\n",
        "376": "        superclass,\n",
        "377": "        this);\n",
        "388": "    TypeToken<? super T> supertype =\n",
        "389": "        (TypeToken<? super T>) resolveSupertype(toGenericType(superclass).runtimeType);\n",
        "394": "   * Returns subtype of {@code this} with {@code subclass} as the raw class. For example, if this is\n",
        "395": "   * {@code Iterable<String>} and {@code subclass} is {@code List}, {@code List<String>} is\n",
        "396": "   * returned.\n",
        "399": "    checkArgument(\n",
        "400": "        !(runtimeType instanceof TypeVariable), \"Cannot get subtype of type variable <%s>\", this);\n",
        "409": "    checkArgument(\n",
        "410": "        getRawType().isAssignableFrom(subclass), \"%s isn't a subclass of %s\", subclass, this);\n",
        "419": "   * according to\n",
        "420": "   * <a href=\"http://docs.oracle.com/javase/specs/jls/se8/html/jls-4.html#jls-4.5.1\">the rules for\n",
        "421": "   * type arguments</a> introduced with Java generics.\n",
        "431": "   * according to\n",
        "432": "   * <a href=\"http://docs.oracle.com/javase/specs/jls/se8/html/jls-4.html#jls-4.5.1\">the rules for\n",
        "433": "   * type arguments</a> introduced with Java generics.\n",
        "443": "   * according to\n",
        "444": "   * <a href=\"http://docs.oracle.com/javase/specs/jls/se8/html/jls-4.html#jls-4.5.1\">the rules for\n",
        "445": "   * type arguments</a> introduced with Java generics.\n",
        "455": "   * according to\n",
        "456": "   * <a href=\"http://docs.oracle.com/javase/specs/jls/se8/html/jls-4.html#jls-4.5.1\">the rules for\n",
        "457": "   * type arguments</a> introduced with Java generics.\n",
        "551": "  @Nullable\n",
        "552": "  public final TypeToken<?> getComponentType() {\n",
        "566": "    checkArgument(\n",
        "567": "        this.someRawTypeIsSubclassOf(method.getDeclaringClass()),\n",
        "568": "        \"%s not declared by %s\",\n",
        "569": "        method,\n",
        "570": "        this);\n",
        "572": "      @Override\n",
        "573": "      Type getGenericReturnType() {\n",
        "576": "\n",
        "577": "      @Override\n",
        "578": "      Type[] getGenericParameterTypes() {\n",
        "581": "\n",
        "582": "      @Override\n",
        "583": "      Type[] getGenericExceptionTypes() {\n",
        "586": "\n",
        "587": "      @Override\n",
        "588": "      public TypeToken<T> getOwnerType() {\n",
        "591": "\n",
        "592": "      @Override\n",
        "593": "      public String toString() {\n",
        "605": "    checkArgument(\n",
        "606": "        constructor.getDeclaringClass() == getRawType(),\n",
        "607": "        \"%s not declared by %s\",\n",
        "608": "        constructor,\n",
        "609": "        getRawType());\n",
        "611": "      @Override\n",
        "612": "      Type getGenericReturnType() {\n",
        "615": "\n",
        "616": "      @Override\n",
        "617": "      Type[] getGenericParameterTypes() {\n",
        "620": "\n",
        "621": "      @Override\n",
        "622": "      Type[] getGenericExceptionTypes() {\n",
        "625": "\n",
        "626": "      @Override\n",
        "627": "      public TypeToken<T> getOwnerType() {\n",
        "630": "\n",
        "631": "      @Override\n",
        "632": "      public String toString() {\n",
        "658": "    @Override\n",
        "659": "    protected Set<TypeToken<? super T>> delegate() {\n",
        "664": "        ImmutableList<TypeToken<? super T>> collectedTypes =\n",
        "665": "            (ImmutableList) TypeCollector.FOR_GENERIC_TYPE.collectTypes(TypeToken.this);\n",
        "666": "        return (types =\n",
        "667": "            FluentIterable.from(collectedTypes)\n",
        "679": "      ImmutableList<Class<? super T>> collectedTypes =\n",
        "680": "          (ImmutableList) TypeCollector.FOR_RAW_TYPE.collectTypes(getRawTypes());\n",
        "696": "    @Override\n",
        "697": "    protected Set<TypeToken<? super T>> delegate() {\n",
        "700": "        return (interfaces =\n",
        "701": "            FluentIterable.from(allTypes).filter(TypeFilter.INTERFACE_ONLY).toSet());\n",
        "707": "    @Override\n",
        "708": "    public TypeSet interfaces() {\n",
        "712": "    @Override\n",
        "713": "    public Set<Class<? super T>> rawTypes() {\n",
        "716": "      ImmutableList<Class<? super T>> collectedTypes =\n",
        "717": "          (ImmutableList) TypeCollector.FOR_RAW_TYPE.collectTypes(getRawTypes());\n",
        "719": "          .filter(\n",
        "720": "              new Predicate<Class<?>>() {\n",
        "721": "                @Override\n",
        "722": "                public boolean apply(Class<?> type) {\n",
        "723": "                  return type.isInterface();\n",
        "724": "                }\n",
        "725": "              })\n",
        "729": "    @Override\n",
        "730": "    public TypeSet classes() {\n",
        "745": "    @Override\n",
        "746": "    protected Set<TypeToken<? super T>> delegate() {\n",
        "750": "        ImmutableList<TypeToken<? super T>> collectedTypes =\n",
        "751": "            (ImmutableList)\n",
        "752": "                TypeCollector.FOR_GENERIC_TYPE.classesOnly().collectTypes(TypeToken.this);\n",
        "753": "        return (classes =\n",
        "754": "            FluentIterable.from(collectedTypes)\n",
        "755": "                .filter(TypeFilter.IGNORE_TYPE_VARIABLE_OR_WILDCARD)\n",
        "756": "                .toSet());\n",
        "762": "    @Override\n",
        "763": "    public TypeSet classes() {\n",
        "767": "    @Override\n",
        "768": "    public Set<Class<? super T>> rawTypes() {\n",
        "771": "      ImmutableList<Class<? super T>> collectedTypes =\n",
        "772": "          (ImmutableList) TypeCollector.FOR_RAW_TYPE.classesOnly().collectTypes(getRawTypes());\n",
        "776": "    @Override\n",
        "777": "    public TypeSet interfaces() {\n",
        "790": "      @Override\n",
        "791": "      public boolean apply(TypeToken<?> type) {\n",
        "797": "      @Override\n",
        "798": "      public boolean apply(TypeToken<?> type) {\n",
        "807": "  @Override\n",
        "808": "  public boolean equals(@Nullable Object o) {\n",
        "816": "  @Override\n",
        "817": "  public int hashCode() {\n",
        "821": "  @Override\n",
        "822": "  public String toString() {\n",
        "840": "      @Override\n",
        "841": "      void visitTypeVariable(TypeVariable<?> type) {\n",
        "845": "\n",
        "846": "      @Override\n",
        "847": "      void visitWildcardType(WildcardType type) {\n",
        "851": "\n",
        "852": "      @Override\n",
        "853": "      void visitParameterizedType(ParameterizedType type) {\n",
        "857": "\n",
        "858": "      @Override\n",
        "859": "      void visitGenericArrayType(GenericArrayType type) {\n",
        "929": "   * Return true if any of the following conditions is met:\n",
        "930": "   *\n",
        "931": "   * <ul>\n",
        "995": "      @Override\n",
        "996": "      void visitTypeVariable(TypeVariable<?> t) {\n",
        "999": "\n",
        "1000": "      @Override\n",
        "1001": "      void visitWildcardType(WildcardType t) {\n",
        "1004": "\n",
        "1005": "      @Override\n",
        "1006": "      void visitParameterizedType(ParameterizedType t) {\n",
        "1009": "\n",
        "1010": "      @Override\n",
        "1011": "      void visitClass(Class<?> t) {\n",
        "1015": "      @Override\n",
        "1016": "      void visitGenericArrayType(GenericArrayType t) {\n",
        "1017": "        builder.add(Types.getArrayClass(of(t.getGenericComponentType()).getRawType()));\n",
        "1018": "      }\n",
        "1033": "  @VisibleForTesting\n",
        "1034": "  static <T> TypeToken<? extends T> toGenericType(Class<T> cls) {\n",
        "1036": "      Type arrayOfGenericType =\n",
        "1037": "          Types.newArrayType(\n",
        "1038": "              // If we are passed with int[].class, don't turn it to GenericArrayType\n",
        "1039": "              toGenericType(cls.getComponentType()).runtimeType);\n",
        "1045": "    Type ownerType =\n",
        "1046": "        cls.isMemberClass() ? toGenericType(cls.getEnclosingClass()).runtimeType : null;\n",
        "1050": "      TypeToken<? extends T> type =\n",
        "1051": "          (TypeToken<? extends T>)\n",
        "1052": "              of(Types.newParameterizedTypeWithOwner(ownerType, cls, typeParams));\n",
        "1087": "    TypeToken componentType =\n",
        "1088": "        checkNotNull(getComponentType(), \"%s isn't a super type of %s\", supertype, this);\n",
        "1093": "    TypeToken<? super T> result =\n",
        "1094": "        (TypeToken<? super T>)\n",
        "1095": "            // If we are passed with int[].class, don't turn it to GenericArrayType\n",
        "1096": "            of(newArrayClassOrGenericArrayType(componentSupertype.runtimeType));\n",
        "1102": "    TypeToken<?> componentSubtype = getComponentType().getSubtype(subclass.getComponentType());\n",
        "1104": "    TypeToken<? extends T> result =\n",
        "1105": "        (TypeToken<? extends T>)\n",
        "1106": "            // If we are passed with int[].class, don't turn it to GenericArrayType\n",
        "1107": "            of(newArrayClassOrGenericArrayType(componentSubtype.runtimeType));\n",
        "1125": "    Type supertypeWithArgsFromSubtype =\n",
        "1126": "        genericSubtype.getSupertype((Class) getRawType()).runtimeType;\n",
        "1127": "    return new TypeResolver()\n",
        "1128": "        .where(supertypeWithArgsFromSubtype, runtimeType)\n",
        "1134": "   * {@link GenericArrayType}. This is what Java7 does for generic array type parameters.\n",
        "1158": "          @Override\n",
        "1159": "          Class<?> getRawType(TypeToken<?> type) {\n",
        "1163": "          @Override\n",
        "1164": "          Iterable<? extends TypeToken<?>> getInterfaces(TypeToken<?> type) {\n",
        "1169": "          @Override\n",
        "1170": "          TypeToken<?> getSuperclass(TypeToken<?> type) {\n",
        "1177": "          @Override\n",
        "1178": "          Class<?> getRawType(Class<?> type) {\n",
        "1182": "          @Override\n",
        "1183": "          Iterable<? extends Class<?>> getInterfaces(Class<?> type) {\n",
        "1188": "          @Override\n",
        "1189": "          Class<?> getSuperclass(Class<?> type) {\n",
        "1197": "        @Override\n",
        "1198": "        Iterable<? extends K> getInterfaces(K type) {\n",
        "1201": "\n",
        "1202": "        @Override\n",
        "1203": "        ImmutableList<K> collectTypes(Iterable<? extends K> types) {\n",
        "1236": "      // Interfaces should be listed before Object.\n",
        "1237": "      int aboveMe = getRawType(type).isInterface() ? 1 : 0;\n",
        "1246": "       * TODO(benyu): should we include Object for interface? Also, CharSequence[] and Object[] for\n",
        "1247": "       * String[]?\n",
        "1256": "      Ordering<K> keyOrdering =\n",
        "1257": "          new Ordering<K>() {\n",
        "1258": "            @Override\n",
        "1259": "            public int compare(K left, K right) {\n",
        "1260": "              return valueComparator.compare(map.get(left), map.get(right));\n",
        "1261": "            }\n",
        "1262": "          };\n",
        "1267": "\n",
        "1269": "\n",
        "1270": "    @Nullable\n",
        "1271": "    abstract K getSuperclass(K type);\n",
        "1281": "      @Override\n",
        "1282": "      Class<?> getRawType(K type) {\n",
        "1286": "      @Override\n",
        "1287": "      Iterable<? extends K> getInterfaces(K type) {\n",
        "1291": "      @Override\n",
        "1292": "      K getSuperclass(K type) {\n"
    },
    "removed": {
        "4": " * Licensed under the Apache License, Version 2.0 (the \"License\");\n",
        "5": " * you may not use this file except in compliance with the License.\n",
        "6": " * You may obtain a copy of the License at\n",
        "10": " * Unless required by applicable law or agreed to in writing, software\n",
        "11": " * distributed under the License is distributed on an \"AS IS\" BASIS,\n",
        "12": " * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n",
        "13": " * See the License for the specific language governing permissions and\n",
        "14": " * limitations under the License.\n",
        "59": " * <p>There are three ways to get a {@code TypeToken} instance: <ul>\n",
        "60": " * <li>Wrap a {@code Type} obtained via reflection. For example: {@code\n",
        "61": " * TypeToken.of(method.getGenericReturnType())}.\n",
        "64": " * <p>Note that it's critical that the actual type argument is carried by a subclass.\n",
        "65": " * The following code is wrong because it only captures the {@code <T>} type variable\n",
        "66": " * of the {@code listType()} method signature; while {@code <String>} is lost in erasure:\n",
        "75": " * <li>Capture a generic type with a (usually anonymous) subclass and resolve it against\n",
        "76": " * a context class that knows what the type parameters are. For example: <pre>   {@code\n",
        "85": " * <p>Note to Guice users: {@code} TypeToken is similar to Guice's {@code TypeLiteral} class\n",
        "86": " * except that it is serializable and offers numerous additional utility methods.\n",
        "105": "   * <p>Clients create an empty anonymous subclass. Doing so embeds the type\n",
        "106": "   * parameter in the anonymous class's type hierarchy so we can reconstitute\n",
        "107": "   * it at runtime despite erasure.\n",
        "114": "    checkState(!(runtimeType instanceof TypeVariable),\n",
        "116": "        + \"You probably meant to call new TypeToken<%s>(getClass()) \"\n",
        "117": "        + \"that can resolve the type variable for you.\\n\"\n",
        "118": "        + \"If you do need to create a TypeToken of a type variable, \"\n",
        "119": "        + \"please use TypeToken.of() instead.\", runtimeType);\n",
        "126": "   * <p>Clients create an empty anonymous subclass. Doing so embeds the type\n",
        "127": "   * parameter in the anonymous class's type hierarchy so we can reconstitute\n",
        "128": "   * it at runtime despite erasure.\n",
        "190": "   * <p>Returns a new {@code TypeToken} where type variables represented by {@code typeParam}\n",
        "191": "   * are substituted by {@code typeArg}. For example, it can be used to construct\n",
        "192": "   * {@code Map<K, V>} for any {@code K} and {@code V} type: <pre>   {@code\n",
        "205": "    TypeResolver resolver = new TypeResolver()\n",
        "206": "        .where(ImmutableMap.of(\n",
        "207": "            new TypeResolver.TypeVariableKey(typeParam.typeVariable),\n",
        "208": "            typeArg.runtimeType));\n",
        "214": "   * <p>Returns a new {@code TypeToken} where type variables represented by {@code typeParam}\n",
        "215": "   * are substituted by {@code typeArg}. For example, it can be used to construct\n",
        "216": "   * {@code Map<K, V>} for any {@code K} and {@code V} type: <pre>   {@code\n",
        "233": "   * <p>Resolves the given {@code type} against the type context represented by this type.\n",
        "234": "   * For example: <pre>   {@code\n",
        "264": "   * {@link Object} or an interface. This method is similar but different from {@link\n",
        "265": "   * Class#getGenericSuperclass}. For example, {@code\n",
        "266": "   * new TypeToken<StringArrayList>() {}.getGenericSuperclass()} will return {@code\n",
        "267": "   * new TypeToken<ArrayList<String>>() {}}; while {@code\n",
        "268": "   * StringArrayList.class.getGenericSuperclass()} will return {@code ArrayList<E>}, where {@code E}\n",
        "269": "   * is the type variable declared by class {@code ArrayList}.\n",
        "294": "  @Nullable private TypeToken<? super T> boundAsSuperclass(Type bound) {\n",
        "306": "   * similar but different from {@link Class#getGenericInterfaces()}. For example, {@code\n",
        "307": "   * new TypeToken<List<String>>() {}.getGenericInterfaces()} will return a list that contains\n",
        "326": "      TypeToken<? super T> resolvedInterface = (TypeToken<? super T>)\n",
        "327": "          resolveSupertype(interfaceType);\n",
        "362": "   * {@code ArrayList<String>}, {@code Iterable<String>} is returned given the\n",
        "363": "   * input {@code Iterable.class}.\n",
        "366": "    checkArgument(this.someRawTypeIsSubclassOf(superclass),\n",
        "367": "        \"%s is not a super class of %s\", superclass, this);\n",
        "378": "    TypeToken<? super T> supertype = (TypeToken<? super T>)\n",
        "379": "        resolveSupertype(toGenericType(superclass).runtimeType);\n",
        "384": "   * Returns subtype of {@code this} with {@code subclass} as the raw class.\n",
        "385": "   * For example, if this is {@code Iterable<String>} and {@code subclass} is {@code List},\n",
        "386": "   * {@code List<String>} is returned.\n",
        "389": "    checkArgument(!(runtimeType instanceof TypeVariable),\n",
        "390": "        \"Cannot get subtype of type variable <%s>\", this);\n",
        "399": "    checkArgument(getRawType().isAssignableFrom(subclass),\n",
        "400": "        \"%s isn't a subclass of %s\", subclass, this);\n",
        "409": "   * according to <a href=\"http://docs.oracle.com/javase/specs/jls/se8/html/jls-4.html#jls-4.5.1\"\n",
        "410": "   * >the rules for type arguments</a> introduced with Java generics.\n",
        "420": "   * according to <a href=\"http://docs.oracle.com/javase/specs/jls/se8/html/jls-4.html#jls-4.5.1\"\n",
        "421": "   * >the rules for type arguments</a> introduced with Java generics.\n",
        "431": "   * according to <a href=\"http://docs.oracle.com/javase/specs/jls/se8/html/jls-4.html#jls-4.5.1\"\n",
        "432": "   * >the rules for type arguments</a> introduced with Java generics.\n",
        "442": "   * according to <a href=\"http://docs.oracle.com/javase/specs/jls/se8/html/jls-4.html#jls-4.5.1\"\n",
        "443": "   * >the rules for type arguments</a> introduced with Java generics.\n",
        "537": "  @Nullable public final TypeToken<?> getComponentType() {\n",
        "551": "    checkArgument(this.someRawTypeIsSubclassOf(method.getDeclaringClass()),\n",
        "552": "        \"%s not declared by %s\", method, this);\n",
        "554": "      @Override Type getGenericReturnType() {\n",
        "557": "      @Override Type[] getGenericParameterTypes() {\n",
        "560": "      @Override Type[] getGenericExceptionTypes() {\n",
        "563": "      @Override public TypeToken<T> getOwnerType() {\n",
        "566": "      @Override public String toString() {\n",
        "578": "    checkArgument(constructor.getDeclaringClass() == getRawType(),\n",
        "579": "        \"%s not declared by %s\", constructor, getRawType());\n",
        "581": "      @Override Type getGenericReturnType() {\n",
        "584": "      @Override Type[] getGenericParameterTypes() {\n",
        "587": "      @Override Type[] getGenericExceptionTypes() {\n",
        "590": "      @Override public TypeToken<T> getOwnerType() {\n",
        "593": "      @Override public String toString() {\n",
        "619": "    @Override protected Set<TypeToken<? super T>> delegate() {\n",
        "624": "        ImmutableList<TypeToken<? super T>> collectedTypes = (ImmutableList)\n",
        "625": "            TypeCollector.FOR_GENERIC_TYPE.collectTypes(TypeToken.this);\n",
        "626": "        return (types = FluentIterable.from(collectedTypes)\n",
        "638": "      ImmutableList<Class<? super T>> collectedTypes = (ImmutableList)\n",
        "639": "          TypeCollector.FOR_RAW_TYPE.collectTypes(getRawTypes());\n",
        "655": "    @Override protected Set<TypeToken<? super T>> delegate() {\n",
        "658": "        return (interfaces = FluentIterable.from(allTypes)\n",
        "659": "            .filter(TypeFilter.INTERFACE_ONLY)\n",
        "660": "            .toSet());\n",
        "666": "    @Override public TypeSet interfaces() {\n",
        "670": "    @Override public Set<Class<? super T>> rawTypes() {\n",
        "673": "      ImmutableList<Class<? super T>> collectedTypes = (ImmutableList)\n",
        "674": "          TypeCollector.FOR_RAW_TYPE.collectTypes(getRawTypes());\n",
        "676": "          .filter(new Predicate<Class<?>>() {\n",
        "677": "            @Override public boolean apply(Class<?> type) {\n",
        "678": "              return type.isInterface();\n",
        "679": "            }\n",
        "680": "          })\n",
        "684": "    @Override public TypeSet classes() {\n",
        "699": "    @Override protected Set<TypeToken<? super T>> delegate() {\n",
        "703": "        ImmutableList<TypeToken<? super T>> collectedTypes = (ImmutableList)\n",
        "704": "            TypeCollector.FOR_GENERIC_TYPE.classesOnly().collectTypes(TypeToken.this);\n",
        "705": "        return (classes = FluentIterable.from(collectedTypes)\n",
        "706": "            .filter(TypeFilter.IGNORE_TYPE_VARIABLE_OR_WILDCARD)\n",
        "707": "            .toSet());\n",
        "713": "    @Override public TypeSet classes() {\n",
        "717": "    @Override public Set<Class<? super T>> rawTypes() {\n",
        "720": "      ImmutableList<Class<? super T>> collectedTypes = (ImmutableList)\n",
        "721": "          TypeCollector.FOR_RAW_TYPE.classesOnly().collectTypes(getRawTypes());\n",
        "725": "    @Override public TypeSet interfaces() {\n",
        "737": "\n",
        "739": "      @Override public boolean apply(TypeToken<?> type) {\n",
        "745": "      @Override public boolean apply(TypeToken<?> type) {\n",
        "754": "  @Override public boolean equals(@Nullable Object o) {\n",
        "762": "  @Override public int hashCode() {\n",
        "766": "  @Override public String toString() {\n",
        "784": "      @Override void visitTypeVariable(TypeVariable<?> type) {\n",
        "788": "      @Override void visitWildcardType(WildcardType type) {\n",
        "792": "      @Override void visitParameterizedType(ParameterizedType type) {\n",
        "796": "      @Override void visitGenericArrayType(GenericArrayType type) {\n",
        "866": "   * Return true if any of the following conditions is met: <ul>\n",
        "930": "      @Override void visitTypeVariable(TypeVariable<?> t) {\n",
        "933": "      @Override void visitWildcardType(WildcardType t) {\n",
        "936": "      @Override void visitParameterizedType(ParameterizedType t) {\n",
        "939": "      @Override void visitClass(Class<?> t) {\n",
        "942": "      @Override void visitGenericArrayType(GenericArrayType t) {\n",
        "943": "        builder.add(Types.getArrayClass(\n",
        "944": "            of(t.getGenericComponentType()).getRawType()));\n",
        "945": "      }\n",
        "961": "  @VisibleForTesting static <T> TypeToken<? extends T> toGenericType(Class<T> cls) {\n",
        "963": "      Type arrayOfGenericType = Types.newArrayType(\n",
        "964": "          // If we are passed with int[].class, don't turn it to GenericArrayType\n",
        "965": "          toGenericType(cls.getComponentType()).runtimeType);\n",
        "971": "    Type ownerType = cls.isMemberClass()\n",
        "972": "        ? toGenericType(cls.getEnclosingClass()).runtimeType : null;\n",
        "976": "      TypeToken<? extends T> type = (TypeToken<? extends T>)\n",
        "977": "          of(Types.newParameterizedTypeWithOwner(ownerType, cls, typeParams));\n",
        "1012": "    TypeToken componentType = checkNotNull(getComponentType(),\n",
        "1013": "        \"%s isn't a super type of %s\", supertype, this);\n",
        "1018": "    TypeToken<? super T> result = (TypeToken<? super T>)\n",
        "1019": "        // If we are passed with int[].class, don't turn it to GenericArrayType\n",
        "1020": "        of(newArrayClassOrGenericArrayType(componentSupertype.runtimeType));\n",
        "1026": "    TypeToken<?> componentSubtype = getComponentType()\n",
        "1027": "        .getSubtype(subclass.getComponentType());\n",
        "1029": "    TypeToken<? extends T> result = (TypeToken<? extends T>)\n",
        "1030": "        // If we are passed with int[].class, don't turn it to GenericArrayType\n",
        "1031": "        of(newArrayClassOrGenericArrayType(componentSubtype.runtimeType));\n",
        "1049": "    Type supertypeWithArgsFromSubtype = genericSubtype\n",
        "1050": "        .getSupertype((Class) getRawType())\n",
        "1051": "        .runtimeType;\n",
        "1052": "    return new TypeResolver().where(supertypeWithArgsFromSubtype, runtimeType)\n",
        "1058": "   * {@link GenericArrayType}. This is what Java7 does for generic array type\n",
        "1059": "   * parameters.\n",
        "1083": "          @Override Class<?> getRawType(TypeToken<?> type) {\n",
        "1087": "          @Override Iterable<? extends TypeToken<?>> getInterfaces(TypeToken<?> type) {\n",
        "1092": "          @Override TypeToken<?> getSuperclass(TypeToken<?> type) {\n",
        "1099": "          @Override Class<?> getRawType(Class<?> type) {\n",
        "1103": "          @Override Iterable<? extends Class<?>> getInterfaces(Class<?> type) {\n",
        "1108": "          @Override Class<?> getSuperclass(Class<?> type) {\n",
        "1116": "        @Override Iterable<? extends K> getInterfaces(K type) {\n",
        "1119": "        @Override ImmutableList<K> collectTypes(Iterable<? extends K> types) {\n",
        "1152": "      int aboveMe = getRawType(type).isInterface()\n",
        "1153": "          ? 1 // interfaces should be listed before Object\n",
        "1154": "          : 0;\n",
        "1163": "       * TODO(benyu): should we include Object for interface?\n",
        "1164": "       * Also, CharSequence[] and Object[] for String[]?\n",
        "1173": "      Ordering<K> keyOrdering = new Ordering<K>() {\n",
        "1174": "        @Override public int compare(K left, K right) {\n",
        "1175": "          return valueComparator.compare(map.get(left), map.get(right));\n",
        "1176": "        }\n",
        "1177": "      };\n",
        "1183": "    @Nullable abstract K getSuperclass(K type);\n",
        "1193": "      @Override Class<?> getRawType(K type) {\n",
        "1197": "      @Override Iterable<? extends K> getInterfaces(K type) {\n",
        "1201": "      @Override K getSuperclass(K type) {\n"
    }
}