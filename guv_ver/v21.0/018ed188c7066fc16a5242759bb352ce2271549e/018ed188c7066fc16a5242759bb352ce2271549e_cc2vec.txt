{"id": "018ed188c7066fc16a5242759bb352ce2271549e", "code": [{"0": "guava/src/com/google/common/reflect/AbstractInvocationHandler.java", "added": {"1": [" * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not use this file except\n", " * in compliance with the License. You may obtain a copy of the License at\n", " * Unless required by applicable law or agreed to in writing, software distributed under the License\n", " * is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express\n", " * or implied. See the License for the specific language governing permissions and limitations under\n", " * the License.\n"], "2": [" *   protected Object handleInvocation(Object proxy, Method method, Object[] args) {\n"], "3": ["   * <ul>\n", "   * <li>{@code proxy.equals(argument)} returns true if:\n", "   *   <ul>\n", "   *   <li>and {@link AbstractInvocationHandler#equals} returns true for the\n", "   *       {@link InvocationHandler} of {@code argument}\n", "  @Override\n", "  public final Object invoke(Object proxy, Method method, @Nullable Object[] args)\n"], "4": ["   * identical. {@code proxy.equals(argument)} returns true if:\n", "   *\n", "   * <ul>\n", "   *\n", "  @Override\n", "  public boolean equals(Object obj) {\n"], "5": ["  @Override\n", "  public int hashCode() {\n"], "6": ["  @Override\n", "  public String toString() {\n"]}, "removed": {"1": [" * Licensed under the Apache License, Version 2.0 (the \"License\");\n", " * you may not use this file except in compliance with the License.\n", " * You may obtain a copy of the License at\n", " * Unless required by applicable law or agreed to in writing, software\n", " * distributed under the License is distributed on an \"AS IS\" BASIS,\n", " * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n", " * See the License for the specific language governing permissions and\n", " * limitations under the License.\n"], "2": [" *   protected Object handleInvocation(\n", " *       Object proxy, Method method, Object[] args) {\n"], "3": ["   * <p><ul>\n", "   * <li>{@code proxy.equals(argument)} returns true if: <ul>\n", "   *   <li>and {@link AbstractInvocationHandler#equals} returns true for the {@link\n", "   *       InvocationHandler} of {@code argument}\n", "  @Override public final Object invoke(Object proxy, Method method, @Nullable Object[] args)\n"], "4": ["   * identical. {@code proxy.equals(argument)} returns true if: <ul>\n", "  @Override public boolean equals(Object obj) {\n"], "5": ["  @Override public int hashCode() {\n"], "6": ["  @Override public String toString() {\n"]}, "added_lines": {"1": [4, 5, 9, 10, 11, 12], "2": [30], "3": [49, 52, 53, 55, 56, 61, 62], "4": [102, 103, 104, 108, 111, 112], "5": [120, 121], "6": [130, 131]}, "removed_lines": {"1": [4, 5, 6, 10, 11, 12, 13, 14], "2": [32, 33], "3": [52, 55, 57, 58, 63], "4": [103, 109], "5": [117], "6": [126]}}, {"1": "guava/src/com/google/common/reflect/ClassPath.java", "added": {"1": [" * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not use this file except\n", " * in compliance with the License. You may obtain a copy of the License at\n", " * Unless required by applicable law or agreed to in writing, software distributed under the License\n", " * is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express\n", " * or implied. See the License for the specific language governing permissions and limitations under\n", " * the License.\n"], "2": ["  private static final Predicate<ClassInfo> IS_TOP_LEVEL =\n", "      new Predicate<ClassInfo>() {\n", "        @Override\n", "        public boolean apply(ClassInfo info) {\n", "          return info.className.indexOf('$') == -1;\n", "        }\n", "      };\n"], "3": ["   *     failed.\n"], "4": ["    ResourceInfo(String resourceName, ClassLoader loader) {\n"], "5": ["    @Override\n", "    public int hashCode() {\n", "    @Override\n", "    public boolean equals(Object obj) {\n", "        return resourceName.equals(that.resourceName) && loader == that.loader;\n", "    @Override\n", "    public String toString() {\n"], "6": ["     *     For example, {@link NoClassDefFoundError}.\n"], "7": ["    @Override\n", "    public String toString() {\n"], "8": ["    protected abstract void scanDirectory(ClassLoader loader, File directory) throws IOException;\n", "    @VisibleForTesting\n", "    final void scan(File file, ClassLoader classloader) throws IOException {\n"], "9": ["        } catch (IOException ignored) {\n", "        }\n"], "10": ["    @VisibleForTesting\n", "    static ImmutableSet<File> getClassPathFromManifest(File jarFile, @Nullable Manifest manifest) {\n", "      String classpathAttribute =\n", "          manifest.getMainAttributes().getValue(Attributes.Name.CLASS_PATH.toString());\n"], "11": ["    @VisibleForTesting\n", "    static ImmutableMap<File, ClassLoader> getClassPathEntries(ClassLoader classloader) {\n"], "12": ["    @VisibleForTesting\n", "    static URL getClassPathEntry(File jarFile, String path) throws MalformedURLException {\n", "  @VisibleForTesting\n", "  static final class DefaultScanner extends Scanner {\n"], "13": ["    @Override\n", "    protected void scanJarFile(ClassLoader classloader, JarFile file) {\n"], "14": ["    @Override\n", "    protected void scanDirectory(ClassLoader classloader, File directory) throws IOException {\n", "    private void scanDirectory(File directory, ClassLoader classloader, String packagePrefix)\n", "        throws IOException {\n"], "15": ["  @VisibleForTesting\n", "  static String getClassName(String filename) {\n"]}, "removed": {"1": [" * Licensed under the Apache License, Version 2.0 (the \"License\");\n", " * you may not use this file except in compliance with the License.\n", " * You may obtain a copy of the License at\n", " * Unless required by applicable law or agreed to in writing, software\n", " * distributed under the License is distributed on an \"AS IS\" BASIS,\n", " * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n", " * See the License for the specific language governing permissions and\n", " * limitations under the License.\n"], "2": ["  private static final Predicate<ClassInfo> IS_TOP_LEVEL = new Predicate<ClassInfo>() {\n", "    @Override public boolean apply(ClassInfo info) {\n", "      return info.className.indexOf('$') == -1;\n", "    }\n", "  };\n"], "3": ["   *         failed.\n"], "4": ["    ResourceInfo(String resourceName,  ClassLoader loader) {\n"], "5": ["    @Override public int hashCode() {\n", "    @Override public boolean equals(Object obj) {\n", "        return resourceName.equals(that.resourceName)\n", "            && loader == that.loader;\n", "    @Override public String toString() {\n"], "6": ["     *         For example, {@link NoClassDefFoundError}.\n"], "7": ["    @Override public String toString() {\n"], "8": ["    protected abstract void scanDirectory(ClassLoader loader, File directory)\n", "        throws IOException;\n", "    @VisibleForTesting final void scan(File file, ClassLoader classloader) throws IOException {\n"], "9": ["        } catch (IOException ignored) {}\n"], "10": ["    @VisibleForTesting static ImmutableSet<File> getClassPathFromManifest(\n", "        File jarFile, @Nullable Manifest manifest) {\n", "      String classpathAttribute = manifest.getMainAttributes()\n", "          .getValue(Attributes.Name.CLASS_PATH.toString());\n"], "11": ["    @VisibleForTesting static ImmutableMap<File, ClassLoader> getClassPathEntries(\n", "        ClassLoader classloader) {\n"], "12": ["    @VisibleForTesting static URL getClassPathEntry(File jarFile, String path)\n", "        throws MalformedURLException {\n", "  @VisibleForTesting static final class DefaultScanner extends Scanner {\n"], "13": ["    @Override protected void scanJarFile(ClassLoader classloader, JarFile file) {\n"], "14": ["    @Override protected void scanDirectory(ClassLoader classloader, File directory)\n", "        throws IOException {\n", "    private void scanDirectory(\n", "        File directory, ClassLoader classloader, String packagePrefix) throws IOException {\n"], "15": ["  @VisibleForTesting static String getClassName(String filename) {\n"]}, "added_lines": {"1": [4, 5, 9, 10, 11, 12], "2": [67, 68, 69, 70, 71, 72, 73], "3": [95], "4": [173], "5": [222, 223, 227, 228, 231, 237, 238], "6": [304], "7": [315, 316], "8": [339, 344, 345], "9": [378, 379], "10": [390, 391, 396, 397], "11": [416, 417], "12": [444, 445, 450, 451], "13": [463, 464], "14": [475, 476, 480, 481], "15": [502, 503]}, "removed_lines": {"1": [4, 5, 6, 10, 11, 12, 13, 14], "2": [69, 70, 71, 72, 73], "3": [95], "4": [173], "5": [222, 226, 229, 230, 236], "6": [302], "7": [313], "8": [336, 337, 342], "9": [375], "10": [386, 387, 392, 393], "11": [412, 413], "12": [440, 441, 446], "13": [458], "14": [469, 470, 474, 475], "15": [496]}}, {"2": "guava/src/com/google/common/reflect/Element.java", "added": {"1": [" * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not use this file except\n", " * in compliance with the License. You may obtain a copy of the License at\n", " * Unless required by applicable law or agreed to in writing, software distributed under the License\n", " * is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express\n", " * or implied. See the License for the specific language governing permissions and limitations under\n", " * the License.\n"], "2": [" * Represents either a {@link Field}, a {@link Method} or a {@link Constructor}. Provides\n", " * convenience methods such as {@link #isPublic} and {@link #isPackagePrivate}.\n"], "3": ["  @Override\n", "  public final boolean isAnnotationPresent(Class<? extends Annotation> annotationClass) {\n", "  @Override\n", "  public final <A extends Annotation> A getAnnotation(Class<A> annotationClass) {\n", "  @Override\n", "  public final Annotation[] getAnnotations() {\n", "  @Override\n", "  public final Annotation[] getDeclaredAnnotations() {\n", "  @Override\n", "  public final void setAccessible(boolean flag) throws SecurityException {\n", "  @Override\n", "  public final boolean isAccessible() {\n", "  @Override\n", "  public Class<?> getDeclaringClass() {\n", "  @Override\n", "  public final String getName() {\n", "  @Override\n", "  public final int getModifiers() {\n", "  @Override\n", "  public final boolean isSynthetic() {\n"], "4": ["  @Override\n", "  public boolean equals(@Nullable Object obj) {\n"], "5": ["  @Override\n", "  public int hashCode() {\n", "  @Override\n", "  public String toString() {\n"]}, "removed": {"1": [" * Licensed under the Apache License, Version 2.0 (the \"License\");\n", " * you may not use this file except in compliance with the License.\n", " * You may obtain a copy of the License at\n", " * Unless required by applicable law or agreed to in writing, software\n", " * distributed under the License is distributed on an \"AS IS\" BASIS,\n", " * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n", " * See the License for the specific language governing permissions and\n", " * limitations under the License.\n"], "2": [" * Represents either a {@link Field}, a {@link Method} or a {@link Constructor}.\n", " * Provides convenience methods such as {@link #isPublic} and {@link #isPackagePrivate}.\n"], "3": ["  @Override public final boolean isAnnotationPresent(Class<? extends Annotation> annotationClass) {\n", "  @Override public final <A extends Annotation> A getAnnotation(Class<A> annotationClass) {\n", "  @Override public final Annotation[] getAnnotations() {\n", "  @Override public final Annotation[] getDeclaredAnnotations() {\n", "  @Override public final void setAccessible(boolean flag) throws SecurityException {\n", "  @Override public final boolean isAccessible() {\n", "  @Override public Class<?> getDeclaringClass() {\n", "  @Override public final String getName() {\n", "  @Override public final int getModifiers() {\n", "  @Override public final boolean isSynthetic() {\n"], "4": ["  @Override public boolean equals(@Nullable Object obj) {\n"], "5": ["  @Override public int hashCode() {\n", "  @Override public String toString() {\n"]}, "added_lines": {"1": [4, 5, 9, 10, 11, 12], "2": [30, 31], "3": [50, 51, 55, 56, 60, 61, 65, 66, 70, 71, 75, 76, 80, 81, 85, 86, 90, 91, 95, 96], "4": [161, 162], "5": [170, 171, 175, 176]}, "removed_lines": {"1": [4, 5, 6, 10, 11, 12, 13, 14], "2": [32, 33], "3": [52, 56, 60, 64, 68, 72, 76, 80, 84, 88], "4": [153], "5": [161, 165]}}, {"3": "guava/src/com/google/common/reflect/ImmutableTypeToInstanceMap.java", "added": {"1": [" * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not use this file except\n", " * in compliance with the License. You may obtain a copy of the License at\n", " * Unless required by applicable law or agreed to in writing, software distributed under the License\n", " * is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express\n", " * or implied. See the License for the specific language governing permissions and limitations under\n", " * the License.\n"], "2": [" * A type-to-instance map backed by an {@link ImmutableMap}. See also\n", " * {@link MutableTypeToInstanceMap}.\n"], "3": ["   * <p>After invoking {@link #build()} it is still possible to add more entries and build again.\n", "   * Thus each map generated by this builder will be a superset of any map generated before it.\n", "    private final ImmutableMap.Builder<TypeToken<? extends B>, B> mapBuilder =\n", "        ImmutableMap.builder();\n", "     * Associates {@code key} with {@code value} in the built map. Duplicate keys are not allowed,\n", "     * and will cause {@link #build} to fail.\n"], "4": ["     * Associates {@code key} with {@code value} in the built map. Duplicate keys are not allowed,\n", "     * and will cause {@link #build} to fail.\n"], "5": ["     * Returns a new immutable type-to-instance map containing the entries provided to this builder.\n"], "6": ["  @Override\n", "  public <T extends B> T getInstance(TypeToken<T> type) {\n"], "7": ["  @Override\n", "  public <T extends B> T putInstance(TypeToken<T> type, T value) {\n", "  @Override\n", "  public <T extends B> T getInstance(Class<T> type) {\n"], "8": ["  @Override\n", "  public <T extends B> T putInstance(Class<T> type, T value) {\n"], "9": ["  @Override\n", "  public B put(TypeToken<? extends B> key, B value) {\n"], "10": ["  @Override\n", "  public void putAll(Map<? extends TypeToken<? extends B>, ? extends B> map) {\n", "  @Override\n", "  protected Map<TypeToken<? extends B>, B> delegate() {\n"]}, "removed": {"1": [" * Licensed under the Apache License, Version 2.0 (the \"License\");\n", " * you may not use this file except in compliance with the License.\n", " * You may obtain a copy of the License at\n", " * Unless required by applicable law or agreed to in writing, software\n", " * distributed under the License is distributed on an \"AS IS\" BASIS,\n", " * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n", " * See the License for the specific language governing permissions and\n", " * limitations under the License.\n"], "2": [" * A type-to-instance map backed by an {@link ImmutableMap}. See also {@link\n", " * MutableTypeToInstanceMap}.\n"], "3": ["   * <p>After invoking {@link #build()} it is still possible to add more entries\n", "   * and build again. Thus each map generated by this builder will be a superset\n", "   * of any map generated before it.\n", "    private final ImmutableMap.Builder<TypeToken<? extends B>, B> mapBuilder\n", "        = ImmutableMap.builder();\n", "     * Associates {@code key} with {@code value} in the built map. Duplicate\n", "     * keys are not allowed, and will cause {@link #build} to fail.\n"], "4": ["     * Associates {@code key} with {@code value} in the built map. Duplicate\n", "     * keys are not allowed, and will cause {@link #build} to fail.\n"], "5": ["     * Returns a new immutable type-to-instance map containing the entries\n", "     * provided to this builder.\n"], "6": ["  @Override public <T extends B> T getInstance(TypeToken<T> type) {\n"], "7": ["  @Override public <T extends B> T putInstance(TypeToken<T> type, T value) {\n", "  @Override public <T extends B> T getInstance(Class<T> type) {\n"], "8": ["  @Override public <T extends B> T putInstance(Class<T> type, T value) {\n"], "9": ["  @Override public B put(TypeToken<? extends B> key, B value) {\n"], "10": ["  @Override public void putAll(Map<? extends TypeToken<? extends B>, ? extends B> map) {\n", "  @Override protected Map<TypeToken<? extends B>, B> delegate() {\n"]}, "added_lines": {"1": [4, 5, 9, 10, 11, 12], "2": [25, 26], "3": [55, 56, 62, 63, 68, 69], "4": [78, 79], "5": [88], "6": [103, 104], "7": [116, 117, 121, 122], "8": [134, 135], "9": [147, 148], "10": [159, 160, 164, 165]}, "removed_lines": {"1": [4, 5, 6, 10, 11, 12, 13, 14], "2": [27, 28], "3": [57, 58, 59, 65, 66, 71, 72], "4": [81, 82], "5": [91, 92], "6": [107], "7": [119, 123], "8": [135], "9": [147], "10": [158, 162]}}, {"4": "guava/src/com/google/common/reflect/Invokable.java", "added": {"1": [" * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not use this file except\n", " * in compliance with the License. You may obtain a copy of the License at\n", " * Unless required by applicable law or agreed to in writing, software distributed under the License\n", " * is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express\n", " * or implied. See the License for the specific language governing permissions and limitations under\n", " * the License.\n"], "2": [" * Wrapper around either a {@link Method} or a {@link Constructor}. Convenience API is provided to\n", " * make common reflective operation easier to deal with, such as {@link #isPublic},\n", " * {@link #getParameters} etc.\n", " * <p>In addition to convenience methods, {@link TypeToken#method} and {@link TypeToken#constructor}\n", " * will resolve the type parameters of the method or constructor in the context of the owner type,\n", " * which may be a subtype of the declaring class. For example:\n"], "3": [" *     constructor.\n"], "4": ["   * Invokes with {@code receiver} as 'this' and {@code args} passed to the underlying method and\n", "   * returns the return value; or calls the underlying constructor with {@code args} and returns the\n", "   * constructed instance.\n", "   * @throws IllegalAccessException if this {@code Constructor} object enforces Java language access\n", "   *     control and the underlying method or constructor is inaccessible.\n", "   * @throws IllegalArgumentException if the number of actual and formal parameters differ; if an\n", "   *     unwrapping conversion for primitive arguments fails; or if, after possible unwrapping, a\n", "   *     parameter value cannot be converted to the corresponding formal parameter type by a method\n", "   *     invocation conversion.\n"], "5": ["      builder.add(new Parameter(this, i, TypeToken.of(parameterTypes[i]), annotations[i]));\n"], "6": ["      // getGenericExceptionTypes() will never return a type that's not exception\n", "      TypeToken<? extends Throwable> exceptionType =\n", "          (TypeToken<? extends Throwable>) TypeToken.of(type);\n"], "7": ["  @Override\n", "  public final Class<? super T> getDeclaringClass() {\n", "  @Override\n", "  public TypeToken<T> getOwnerType() {\n"], "8": ["    @Override\n", "    final Object invokeInternal(@Nullable Object receiver, Object[] args)\n", "    @Override\n", "    Type getGenericReturnType() {\n", "    @Override\n", "    Type[] getGenericParameterTypes() {\n", "    @Override\n", "    Type[] getGenericExceptionTypes() {\n", "    @Override\n", "    final Annotation[][] getParameterAnnotations() {\n", "    @Override\n", "    public final TypeVariable<?>[] getTypeParameters() {\n", "    @Override\n", "    public final boolean isOverridable() {\n", "      return !(isFinal()\n", "          || isPrivate()\n", "          || isStatic()\n", "    @Override\n", "    public final boolean isVarArgs() {\n"], "9": ["    @Override\n", "    final Object invokeInternal(@Nullable Object receiver, Object[] args)\n"], "10": ["    @Override\n", "    Type getGenericReturnType() {\n"], "11": ["    @Override\n", "    Type[] getGenericParameterTypes() {\n"], "12": ["    @Override\n", "    Type[] getGenericExceptionTypes() {\n", "    @Override\n", "    final Annotation[][] getParameterAnnotations() {\n"], "13": ["     * the other. From the declaration syntax, the class type parameter appears first, but the call\n", "     * syntax may show up in opposite order such as {@code new <A>Foo<B>()}.\n", "    @Override\n", "    public final TypeVariable<?>[] getTypeParameters() {\n"], "14": ["    @Override\n", "    public final boolean isOverridable() {\n", "    @Override\n", "    public final boolean isVarArgs() {\n"]}, "removed": {"1": [" * Licensed under the Apache License, Version 2.0 (the \"License\");\n", " * you may not use this file except in compliance with the License.\n", " * You may obtain a copy of the License at\n", " * Unless required by applicable law or agreed to in writing, software\n", " * distributed under the License is distributed on an \"AS IS\" BASIS,\n", " * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n", " * See the License for the specific language governing permissions and\n", " * limitations under the License.\n"], "2": [" * Wrapper around either a {@link Method} or a {@link Constructor}.\n", " * Convenience API is provided to make common reflective operation easier to deal with,\n", " * such as {@link #isPublic}, {@link #getParameters} etc.\n", " * <p>In addition to convenience methods, {@link TypeToken#method} and {@link\n", " * TypeToken#constructor} will resolve the type parameters of the method or constructor in the\n", " * context of the owner type, which may be a subtype of the declaring class. For example:\n"], "3": [" *            constructor.\n"], "4": ["   * Invokes with {@code receiver} as 'this' and {@code args} passed to the underlying method\n", "   * and returns the return value; or calls the underlying constructor with {@code args} and returns\n", "   * the constructed instance.\n", "   * @throws IllegalAccessException if this {@code Constructor} object enforces Java language\n", "   *         access control and the underlying method or constructor is inaccessible.\n", "   * @throws IllegalArgumentException if the number of actual and formal parameters differ;\n", "   *         if an unwrapping conversion for primitive arguments fails; or if, after possible\n", "   *         unwrapping, a parameter value cannot be converted to the corresponding formal\n", "   *         parameter type by a method invocation conversion.\n"], "5": ["      builder.add(new Parameter(\n", "          this, i, TypeToken.of(parameterTypes[i]), annotations[i]));\n"], "6": ["       // getGenericExceptionTypes() will never return a type that's not exception\n", "      TypeToken<? extends Throwable> exceptionType = (TypeToken<? extends Throwable>)\n", "          TypeToken.of(type);\n"], "7": ["  @Override public final Class<? super T> getDeclaringClass() {\n", "  @Override public TypeToken<T> getOwnerType() {\n"], "8": ["    @Override final Object invokeInternal(@Nullable Object receiver, Object[] args)\n", "    @Override Type getGenericReturnType() {\n", "    @Override Type[] getGenericParameterTypes() {\n", "    @Override Type[] getGenericExceptionTypes() {\n", "    @Override final Annotation[][] getParameterAnnotations() {\n", "    @Override public final TypeVariable<?>[] getTypeParameters() {\n", "    @Override public final boolean isOverridable() {\n", "      return  !(isFinal() || isPrivate() || isStatic()\n", "    @Override public final boolean isVarArgs() {\n"], "9": ["    @Override final Object invokeInternal(@Nullable Object receiver, Object[] args)\n"], "10": ["    @Override Type getGenericReturnType() {\n"], "11": ["    @Override Type[] getGenericParameterTypes() {\n"], "12": ["    @Override Type[] getGenericExceptionTypes() {\n", "    @Override final Annotation[][] getParameterAnnotations() {\n"], "13": ["     * the other. From the declaration syntax, the class type parameter appears first, but the\n", "     * call syntax may show up in opposite order such as {@code new <A>Foo<B>()}.\n", "    @Override public final TypeVariable<?>[] getTypeParameters() {\n"], "14": ["    @Override public final boolean isOverridable() {\n", "    @Override public final boolean isVarArgs() {\n"]}, "added_lines": {"1": [4, 5, 9, 10, 11, 12], "2": [38, 39, 40, 42, 43, 44], "3": [54], "4": [85, 86, 87, 89, 90, 91, 92, 93, 94], "5": [122], "6": [131, 133, 134], "7": [162, 163, 170, 171], "8": [196, 197, 202, 203, 207, 208, 212, 213, 217, 218, 222, 223, 227, 228, 229, 230, 231, 235, 236], "9": [250, 251], "10": [261, 262], "11": [272, 273], "12": [286, 287, 291, 292], "13": [302, 303, 305, 306], "14": [319, 320, 324, 325]}, "removed_lines": {"1": [4, 5, 6, 10, 11, 12, 13, 14], "2": [40, 41, 42, 44, 45, 46], "3": [56], "4": [87, 88, 89, 91, 92, 93, 94, 95, 96], "5": [124, 125], "6": [134, 136, 137], "7": [165, 172], "8": [197, 202, 206, 210, 214, 218, 222, 223, 227], "9": [241], "10": [251], "11": [261], "12": [274, 278], "13": [288, 289, 291], "14": [304, 308]}}, {"5": "guava/src/com/google/common/reflect/MutableTypeToInstanceMap.java", "added": {"1": [" * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not use this file except\n", " * in compliance with the License. You may obtain a copy of the License at\n", " * Unless required by applicable law or agreed to in writing, software distributed under the License\n", " * is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express\n", " * or implied. See the License for the specific language governing permissions and limitations under\n", " * the License.\n"], "2": [" * A mutable type-to-instance map. See also {@link ImmutableTypeToInstanceMap}.\n"], "3": ["  @Override\n", "  public B put(TypeToken<? extends B> key, B value) {\n"], "4": ["  @Override\n", "  public void putAll(Map<? extends TypeToken<? extends B>, ? extends B> map) {\n", "  @Override\n", "  public Set<Entry<TypeToken<? extends B>, B>> entrySet() {\n", "  @Override\n", "  protected Map<TypeToken<? extends B>, B> delegate() {\n"], "5": ["        @Override\n", "        protected Set<Entry<K, V>> delegate() {\n", "\n", "        @Override\n", "        public Iterator<Entry<K, V>> iterator() {\n", "\n", "        @Override\n", "        public Object[] toArray() {\n", "\n", "        @Override\n", "        public <T> T[] toArray(T[] array) {\n", "      return Iterators.transform(\n", "          entries,\n", "          new Function<Entry<K, V>, Entry<K, V>>() {\n", "            @Override\n", "            public Entry<K, V> apply(Entry<K, V> entry) {\n", "              return new UnmodifiableEntry<K, V>(entry);\n", "            }\n", "          });\n", "    @Override\n", "    protected Entry<K, V> delegate() {\n", "    @Override\n", "    public V setValue(V value) {\n"]}, "removed": {"1": [" * Licensed under the Apache License, Version 2.0 (the \"License\");\n", " * you may not use this file except in compliance with the License.\n", " * You may obtain a copy of the License at\n", " * Unless required by applicable law or agreed to in writing, software\n", " * distributed under the License is distributed on an \"AS IS\" BASIS,\n", " * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n", " * See the License for the specific language governing permissions and\n", " * limitations under the License.\n"], "2": [" * A mutable type-to-instance map.\n", " * See also {@link ImmutableTypeToInstanceMap}.\n"], "3": ["  @Override public B put(TypeToken<? extends B> key, B value) {\n"], "4": ["  @Override public void putAll(Map<? extends TypeToken<? extends B>, ? extends B> map) {\n", "  @Override public Set<Entry<TypeToken<? extends B>, B>> entrySet() {\n", "  @Override protected Map<TypeToken<? extends B>, B> delegate() {\n"], "5": ["        @Override protected Set<Entry<K, V>> delegate() {\n", "        @Override public Iterator<Entry<K, V>> iterator() {\n", "        @Override public Object[] toArray() {\n", "        @Override public <T> T[] toArray(T[] array) {\n", "      return Iterators.transform(entries, new Function<Entry<K, V>, Entry<K, V>>() {\n", "        @Override public Entry<K, V> apply(Entry<K, V> entry) {\n", "          return new UnmodifiableEntry<K, V>(entry);\n", "        }\n", "      });\n", "    @Override protected Entry<K, V> delegate() {\n", "    @Override public V setValue(V value) {\n"]}, "added_lines": {"1": [4, 5, 9, 10, 11, 12], "2": [35], "3": [80, 81], "4": [92, 93, 97, 98, 102, 103], "5": [125, 126, 129, 130, 131, 134, 135, 136, 139, 140, 141, 148, 149, 150, 151, 152, 153, 154, 155, 162, 163, 167, 168]}, "removed_lines": {"1": [4, 5, 6, 10, 11, 12, 13, 14], "2": [37, 38], "3": [83], "4": [94, 98, 102], "5": [124, 127, 130, 133, 140, 141, 142, 143, 144, 151, 155]}}, {"6": "guava/src/com/google/common/reflect/Parameter.java", "added": {"1": [" * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not use this file except\n", " * in compliance with the License. You may obtain a copy of the License at\n", " * Unless required by applicable law or agreed to in writing, software distributed under the License\n", " * is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express\n", " * or implied. See the License for the specific language governing permissions and limitations under\n", " * the License.\n"], "2": ["      Invokable<?, ?> declaration, int position, TypeToken<?> type, Annotation[] annotations) {\n"], "3": ["  @Override\n", "  public boolean isAnnotationPresent(Class<? extends Annotation> annotationType) {\n"], "4": ["  @Override\n", "  public Annotation[] getAnnotations() {\n"], "5": ["  @Override\n", "  public Annotation[] getDeclaredAnnotations() {\n"], "6": ["    return FluentIterable.from(annotations).filter(annotationType).first().orNull();\n", "  public <A extends Annotation> A[] getDeclaredAnnotationsByType(Class<A> annotationType) {\n", "    return FluentIterable.from(annotations).filter(annotationType).toArray(annotationType);\n", "  @Override\n", "  public boolean equals(@Nullable Object obj) {\n"], "7": ["  @Override\n", "  public int hashCode() {\n", "  @Override\n", "  public String toString() {\n"]}, "removed": {"1": [" * Licensed under the Apache License, Version 2.0 (the \"License\");\n", " * you may not use this file except in compliance with the License.\n", " * You may obtain a copy of the License at\n", " * Unless required by applicable law or agreed to in writing, software\n", " * distributed under the License is distributed on an \"AS IS\" BASIS,\n", " * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n", " * See the License for the specific language governing permissions and\n", " * limitations under the License.\n"], "2": ["      Invokable<?, ?> declaration,\n", "      int position,\n", "      TypeToken<?> type,\n", "      Annotation[] annotations) {\n"], "3": ["  @Override public boolean isAnnotationPresent(Class<? extends Annotation> annotationType) {\n"], "4": ["  @Override public Annotation[] getAnnotations() {\n"], "5": ["  @Override public Annotation[] getDeclaredAnnotations() {\n"], "6": ["    return FluentIterable.from(annotations)\n", "        .filter(annotationType)\n", "        .first()\n", "        .orNull();\n", "  public <A extends Annotation> A[]\n", "      getDeclaredAnnotationsByType(Class<A> annotationType) {\n", "    return FluentIterable.from(annotations)\n", "        .filter(annotationType)\n", "        .toArray(annotationType);\n", "  @Override public boolean equals(@Nullable Object obj) {\n"], "7": ["  @Override public int hashCode() {\n", "  @Override public String toString() {\n"]}, "added_lines": {"1": [4, 5, 9, 10, 11, 12], "2": [43], "3": [60, 61], "4": [77, 78], "5": [94, 95], "6": [106, 113, 114, 117, 118], "7": [126, 127, 131, 132]}, "removed_lines": {"1": [4, 5, 6, 10, 11, 12, 13, 14], "2": [45, 46, 47, 48], "3": [65], "4": [81], "5": [97], "6": [108, 109, 110, 111, 118, 119, 120, 121, 122, 125], "7": [133, 137]}}, {"7": "guava/src/com/google/common/reflect/Reflection.java", "added": {"1": [" * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not use this file except\n", " * in compliance with the License. You may obtain a copy of the License at\n", " * Unless required by applicable law or agreed to in writing, software distributed under the License\n", " * is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express\n", " * or implied. See the License for the specific language governing permissions and limitations under\n", " * the License.\n"], "2": ["   * @throws ExceptionInInitializerError if an exception is thrown during initialization of a class\n"], "3": ["   * Returns a proxy instance that implements {@code interfaceType} by dispatching method\n", "   * invocations to {@code handler}. The class loader of {@code interfaceType} will be used to\n", "   * define the proxy class. To implement multiple interfaces or specify a class loader, use\n", "   * @throws IllegalArgumentException if {@code interfaceType} does not specify the type of a Java\n", "   *     interface\n", "  public static <T> T newProxy(Class<T> interfaceType, InvocationHandler handler) {\n", "    Object object =\n", "        Proxy.newProxyInstance(\n", "            interfaceType.getClassLoader(), new Class<?>[] {interfaceType}, handler);\n"]}, "removed": {"1": [" * Licensed under the Apache License, Version 2.0 (the \"License\");\n", " * you may not use this file except in compliance with the License.\n", " * You may obtain a copy of the License at\n", " * Unless required by applicable law or agreed to in writing, software\n", " * distributed under the License is distributed on an \"AS IS\" BASIS,\n", " * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n", " * See the License for the specific language governing permissions and\n", " * limitations under the License.\n"], "2": ["   * @throws ExceptionInInitializerError if an exception is thrown during\n", "   *   initialization of a class\n"], "3": ["   * Returns a proxy instance that implements {@code interfaceType} by\n", "   * dispatching method invocations to {@code handler}. The class loader of\n", "   * {@code interfaceType} will be used to define the proxy class. To implement\n", "   * multiple interfaces or specify a class loader, use\n", "   * @throws IllegalArgumentException if {@code interfaceType} does not specify\n", "   *     the type of a Java interface\n", "  public static <T> T newProxy(\n", "      Class<T> interfaceType, InvocationHandler handler) {\n", "    Object object = Proxy.newProxyInstance(\n", "        interfaceType.getClassLoader(),\n", "        new Class<?>[] { interfaceType },\n", "        handler);\n"]}, "added_lines": {"1": [4, 5, 9, 10, 11, 12], "2": [61], "3": [74, 75, 76, 79, 80, 82, 85, 86, 87]}, "removed_lines": {"1": [4, 5, 6, 10, 11, 12, 13, 14], "2": [63, 64], "3": [77, 78, 79, 80, 83, 84, 86, 87, 90, 91, 92, 93]}}, {"8": "guava/src/com/google/common/reflect/TypeCapture.java", "added": {"1": [" * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not use this file except\n", " * in compliance with the License. You may obtain a copy of the License at\n", " * Unless required by applicable law or agreed to in writing, software distributed under the License\n", " * is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express\n", " * or implied. See the License for the specific language governing permissions and limitations under\n", " * the License.\n"], "2": ["    checkArgument(superclass instanceof ParameterizedType, \"%s isn't parameterized\", superclass);\n"]}, "removed": {"1": [" * Licensed under the Apache License, Version 2.0 (the \"License\");\n", " * you may not use this file except in compliance with the License.\n", " * You may obtain a copy of the License at\n", " * Unless required by applicable law or agreed to in writing, software\n", " * distributed under the License is distributed on an \"AS IS\" BASIS,\n", " * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n", " * See the License for the specific language governing permissions and\n", " * limitations under the License.\n"], "2": ["    checkArgument(superclass instanceof ParameterizedType,\n", "        \"%s isn't parameterized\", superclass);\n"]}, "added_lines": {"1": [4, 5, 9, 10, 11, 12], "2": [32]}, "removed_lines": {"1": [4, 5, 6, 10, 11, 12, 13, 14], "2": [34, 35]}}, {"9": "guava/src/com/google/common/reflect/TypeParameter.java", "added": {"1": [" * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not use this file except\n", " * in compliance with the License. You may obtain a copy of the License at\n", " * Unless required by applicable law or agreed to in writing, software distributed under the License\n", " * is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express\n", " * or implied. See the License for the specific language governing permissions and limitations under\n", " * the License.\n"], "2": [" * Captures a free type variable that can be used in {@link TypeToken#where}. For example:\n"], "3": ["  @Override\n", "  public final int hashCode() {\n", "  @Override\n", "  public final boolean equals(@Nullable Object o) {\n"], "4": ["  @Override\n", "  public String toString() {\n"]}, "removed": {"1": [" * Licensed under the Apache License, Version 2.0 (the \"License\");\n", " * you may not use this file except in compliance with the License.\n", " * You may obtain a copy of the License at\n", " * Unless required by applicable law or agreed to in writing, software\n", " * distributed under the License is distributed on an \"AS IS\" BASIS,\n", " * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n", " * See the License for the specific language governing permissions and\n", " * limitations under the License.\n"], "2": [" * Captures a free type variable that can be used in {@link TypeToken#where}.\n", " * For example:\n"], "3": ["  @Override public final int hashCode() {\n", "  @Override public final boolean equals(@Nullable Object o) {\n"], "4": ["  @Override public String toString() {\n"]}, "added_lines": {"1": [4, 5, 9, 10, 11, 12], "2": [27], "3": [49, 50, 54, 55], "4": [63, 64]}, "removed_lines": {"1": [4, 5, 6, 10, 11, 12, 13, 14], "2": [29, 30], "3": [52, 56], "4": [64]}}, {"10": "guava/src/com/google/common/reflect/TypeResolver.java", "added": {"1": [" * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not use this file except\n", " * in compliance with the License. You may obtain a copy of the License at\n", " * Unless required by applicable law or agreed to in writing, software distributed under the License\n", " * is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express\n", " * or implied. See the License for the specific language governing permissions and limitations under\n", " * the License.\n"], "2": ["   * String.class}, then {@code new TypeResolver().where(formal, actual)} will\n", "   * {@linkplain #resolveType resolve} {@code ParameterizedType List<T>} to {@code List<String>},\n", "   * and resolve {@code Map<T, Something>} to {@code Map<String, Something>} etc. Similarly,\n", "   * {@code formal} and {@code actual} can be {@code Map<K, V>} and {@code Map<String, Integer>}\n", "   * respectively, or they can be {@code E[]} and {@code String[]} respectively, or even any\n", "   * arbitrary combination thereof.\n", "   *     always a bug if {@code formal} isn't a type variable and contains no type variable. Make\n", "   *     sure you are passing the two parameters in the right order.\n", "   *     other type variables, in which case these type variables will be further resolved if\n", "   *     corresponding mappings exist in the current {@code TypeResolver} instance.\n"], "3": ["      @Override\n", "      void visitTypeVariable(TypeVariable<?> typeVariable) {\n", "\n", "      @Override\n", "      void visitWildcardType(WildcardType fromWildcardType) {\n"], "4": ["            \"Incompatible type: %s vs. %s\",\n", "            fromWildcardType,\n", "            to);\n"], "5": ["\n", "      @Override\n", "      void visitParameterizedType(ParameterizedType fromParameterizedType) {\n", "          return; // Okay to say Foo<A> is <?>\n", "        checkArgument(\n", "            fromParameterizedType.getRawType().equals(toParameterizedType.getRawType()),\n", "            \"Inconsistent raw type: %s vs. %s\",\n", "            fromParameterizedType,\n", "            to);\n", "        checkArgument(\n", "            fromArgs.length == toArgs.length,\n", "            \"%s not compatible with %s\",\n", "            fromParameterizedType,\n", "            toParameterizedType);\n", "\n", "      @Override\n", "      void visitGenericArrayType(GenericArrayType fromArrayType) {\n", "          return; // Okay to say A[] is <?>\n", "\n", "      @Override\n", "      void visitClass(Class<?> fromClass) {\n", "          return; // Okay to say Foo is <?>\n"], "6": ["   * Resolves all type variables in {@code type} and all downstream types and returns a\n", "   * corresponding type with type variables resolved.\n"], "7": ["    return new Types.WildcardTypeImpl(resolveTypes(lowerBounds), resolveTypes(upperBounds));\n"], "8": ["      TypeTable guarded =\n", "          new TypeTable() {\n", "            @Override\n", "            public Type resolveInternal(TypeVariable<?> intermediateVar, TypeTable forDependent) {\n", "              if (intermediateVar.getGenericDeclaration().equals(var.getGenericDeclaration())) {\n", "                return intermediateVar;\n", "              }\n", "              return unguarded.resolveInternal(intermediateVar, forDependent);\n", "            }\n", "          };\n"], "9": ["     * Returns type mappings using type parameters and type arguments found in the generic\n", "     * superclass and the super interfaces of {@code contextClass}.\n", "    static ImmutableMap<TypeVariableKey, Type> getTypeMappings(Type contextType) {\n", "    @Override\n", "    void visitClass(Class<?> clazz) {\n", "    @Override\n", "    void visitParameterizedType(ParameterizedType parameterizedType) {\n"], "10": ["    @Override\n", "    void visitTypeVariable(TypeVariable<?> t) {\n", "    @Override\n", "    void visitWildcardType(WildcardType t) {\n"], "11": ["          String name =\n", "              \"capture#\"\n", "                  + id.incrementAndGet()\n", "                  + \"-of ? extends \"\n", "                  + Joiner.on('&').join(upperBounds);\n"], "12": ["   * <p>While resolving a type variable from a {var -> type} map, we don't care whether the type\n", "   * variable's bound has been partially resolved. As long as the type variable \"identity\" matches.\n", "   * <p>On the other hand, if for example we are resolving List<A extends B> to List<A extends\n", "   * String>, we need to compare that <A extends B> is unequal to <A extends String> in order to\n", "   * decide to use the transformed type instead of the original type.\n"], "13": ["    @Override\n", "    public int hashCode() {\n", "    @Override\n", "    public boolean equals(Object obj) {\n"], "14": ["    @Override\n", "    public String toString() {\n"], "15": ["     * Returns true if {@code type} is a {@code TypeVariable} with the same name and declared by the\n", "     * same {@code GenericDeclaration}.\n"]}, "removed": {"1": [" * Licensed under the Apache License, Version 2.0 (the \"License\");\n", " * you may not use this file except in compliance with the License.\n", " * You may obtain a copy of the License at\n", " * Unless required by applicable law or agreed to in writing, software\n", " * distributed under the License is distributed on an \"AS IS\" BASIS,\n", " * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n", " * See the License for the specific language governing permissions and\n", " * limitations under the License.\n"], "2": ["   * String.class}, then {@code new TypeResolver().where(formal, actual)} will {@linkplain\n", "   * #resolveType resolve} {@code ParameterizedType List<T>} to {@code List<String>}, and resolve\n", "   * {@code Map<T, Something>} to {@code Map<String, Something>} etc. Similarly, {@code formal} and\n", "   * {@code actual} can be {@code Map<K, V>} and {@code Map<String, Integer>} respectively, or they\n", "   * can be {@code E[]} and {@code String[]} respectively, or even any arbitrary combination\n", "   * thereof.\n", "   *        always a bug if {@code formal} isn't a type variable and contains no type variable. Make\n", "   *        sure you are passing the two parameters in the right order.\n", "   *        other type variables, in which case these type variables will be further resolved if\n", "   *        corresponding mappings exist in the current {@code TypeResolver} instance.\n"], "3": ["      @Override void visitTypeVariable(TypeVariable<?> typeVariable) {\n", "      @Override void visitWildcardType(WildcardType fromWildcardType) {\n"], "4": ["            \"Incompatible type: %s vs. %s\", fromWildcardType, to);\n"], "5": ["      @Override void visitParameterizedType(ParameterizedType fromParameterizedType) {\n", "          return;  // Okay to say Foo<A> is <?>\n", "        checkArgument(fromParameterizedType.getRawType().equals(toParameterizedType.getRawType()),\n", "            \"Inconsistent raw type: %s vs. %s\", fromParameterizedType, to);\n", "        checkArgument(fromArgs.length == toArgs.length,\n", "            \"%s not compatible with %s\", fromParameterizedType, toParameterizedType);\n", "      @Override void visitGenericArrayType(GenericArrayType fromArrayType) {\n", "          return;  // Okay to say A[] is <?>\n", "      @Override void visitClass(Class<?> fromClass) {\n", "          return;  // Okay to say Foo is <?>\n"], "6": ["   * Resolves all type variables in {@code type} and all downstream types and\n", "   * returns a corresponding type with type variables resolved.\n"], "7": ["    return new Types.WildcardTypeImpl(\n", "        resolveTypes(lowerBounds), resolveTypes(upperBounds));\n"], "8": ["      TypeTable guarded = new TypeTable() {\n", "        @Override public Type resolveInternal(\n", "            TypeVariable<?> intermediateVar, TypeTable forDependent) {\n", "          if (intermediateVar.getGenericDeclaration().equals(var.getGenericDeclaration())) {\n", "            return intermediateVar;\n", "          }\n", "          return unguarded.resolveInternal(intermediateVar, forDependent);\n", "        }\n", "      };\n"], "9": ["     * Returns type mappings using type parameters and type arguments found in\n", "     * the generic superclass and the super interfaces of {@code contextClass}.\n", "    static ImmutableMap<TypeVariableKey, Type> getTypeMappings(\n", "        Type contextType) {\n", "    @Override void visitClass(Class<?> clazz) {\n", "    @Override void visitParameterizedType(ParameterizedType parameterizedType) {\n"], "10": ["    @Override void visitTypeVariable(TypeVariable<?> t) {\n", "    @Override void visitWildcardType(WildcardType t) {\n"], "11": ["          String name = \"capture#\" + id.incrementAndGet() + \"-of ? extends \"\n", "              + Joiner.on('&').join(upperBounds);\n"], "12": ["   * <p>While resolving a type variable from a {var -> type} map, we don't care whether the\n", "   * type variable's bound has been partially resolved. As long as the type variable \"identity\"\n", "   * matches.\n", "   * <p>On the other hand, if for example we are resolving List<A extends B> to\n", "   * List<A extends String>, we need to compare that <A extends B> is unequal to\n", "   * <A extends String> in order to decide to use the transformed type instead of the original\n", "   * type.\n"], "13": ["    @Override public int hashCode() {\n", "    @Override public boolean equals(Object obj) {\n"], "14": ["    @Override public String toString() {\n"], "15": ["     * Returns true if {@code type} is a {@code TypeVariable} with the same name and declared by\n", "     * the same {@code GenericDeclaration}.\n"]}, "added_lines": {"1": [4, 5, 9, 10, 11, 12], "2": [74, 75, 76, 77, 78, 79, 82, 83, 85, 86], "3": [105, 106, 109, 110, 111], "4": [123, 124, 125], "5": [133, 134, 135, 137, 140, 141, 142, 143, 144, 147, 148, 149, 150, 151, 156, 157, 158, 160, 166, 167, 168, 170], "6": [181, 182], "7": [211], "8": [266, 267, 268, 269, 270, 271, 272, 273, 274, 275], "9": [342, 343, 345, 351, 352, 357, 358], "10": [370, 371, 375, 376], "11": [439, 440, 441, 442, 443], "12": [475, 476, 478, 479, 480], "13": [489, 490, 494, 495], "14": [504, 505], "15": [519, 520]}, "removed_lines": {"1": [4, 5, 6, 10, 11, 12, 13, 14], "2": [76, 77, 78, 79, 80, 81, 84, 85, 87, 88], "3": [107, 110], "4": [122], "5": [130, 132, 135, 136, 139, 140, 145, 147, 153, 155], "6": [166, 167], "7": [196, 197], "8": [252, 253, 254, 255, 256, 257, 258, 259, 260], "9": [327, 328, 330, 331, 337, 342], "10": [354, 358], "11": [421, 422], "12": [454, 455, 456, 458, 459, 460, 461], "13": [470, 474], "14": [483], "15": [497, 498]}}, {"11": "guava/src/com/google/common/reflect/TypeToInstanceMap.java", "added": {"1": [" * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not use this file except\n", " * in compliance with the License. You may obtain a copy of the License at\n", " * Unless required by applicable law or agreed to in writing, software distributed under the License\n", " * is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express\n", " * or implied. See the License for the specific language governing permissions and limitations under\n", " * the License.\n"], "2": [" * A map, each entry of which maps a {@link TypeToken} to an instance of that type. In addition to\n", " * implementing {@code Map}, the additional type-safe operations {@link #putInstance} and\n", " * {@link #getInstance} are available.\n", " * <p>Generally, implementations don't support {@link #put} and {@link #putAll} because there is no\n", " * way to check an object at runtime to be an instance of a {@link TypeToken}. Instead, caller\n", " * should use the type safe {@link #putInstance}.\n", " * <p>Also, if caller suppresses unchecked warnings and passes in an {@code Iterable<String>} for\n", " * type {@code Iterable<Integer>}, the map won't be able to detect and throw type error.\n", " * <p>Like any other {@code Map<Class, Object>}, this map may contain entries for primitive types,\n", " * and a primitive type and its corresponding wrapper type may map to different values.\n", " * @param <B> the common supertype that all entries must share; often this is simply {@link Object}\n", "public interface TypeToInstanceMap<B> extends Map<TypeToken<? extends B>, B> {\n", "   * Returns the value the specified class is mapped to, or {@code null} if no entry for this class\n", "   * is present. This will only return a value that was bound to this specific class, not a value\n", "   * that may have been bound to a subtype.\n"], "3": ["   * Maps the specified class to the specified value. Does <i>not</i> associate this value with any\n", "   * of the class's supertypes.\n", "   * @return the value previously associated with this class (possibly {@code null}), or\n", "   *     {@code null} if there was no previous entry.\n", "   * Returns the value the specified type is mapped to, or {@code null} if no entry for this type is\n", "   * present. This will only return a value that was bound to this specific type, not a value that\n", "   * may have been bound to a subtype.\n", "   * Maps the specified type to the specified value. Does <i>not</i> associate this value with any\n", "   * of the type's supertypes.\n", "   * @return the value previously associated with this type (possibly {@code null}), or {@code null}\n", "   *     if there was no previous entry.\n"]}, "removed": {"1": [" * Licensed under the Apache License, Version 2.0 (the \"License\");\n", " * you may not use this file except in compliance with the License.\n", " * You may obtain a copy of the License at\n", " * Unless required by applicable law or agreed to in writing, software\n", " * distributed under the License is distributed on an \"AS IS\" BASIS,\n", " * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n", " * See the License for the specific language governing permissions and\n", " * limitations under the License.\n"], "2": [" * A map, each entry of which maps a {@link TypeToken} to an instance of that type.\n", " * In addition to implementing {@code Map}, the additional type-safe operations\n", " * {@link #putInstance} and {@link #getInstance} are available.\n", " * <p>Generally, implementations don't support {@link #put} and {@link #putAll}\n", " * because there is no way to check an object at runtime to be an instance of a\n", " * {@link TypeToken}. Instead, caller should use the type safe {@link #putInstance}.\n", " * <p>Also, if caller suppresses unchecked warnings and passes in an {@code Iterable<String>}\n", " * for type {@code Iterable<Integer>}, the map won't be able to detect and throw type error.\n", " * <p>Like any other {@code Map<Class, Object>}, this map may contain entries\n", " * for primitive types, and a primitive type and its corresponding wrapper type\n", " * may map to different values.\n", " * @param <B> the common supertype that all entries must share; often this is\n", " *     simply {@link Object}\n", "public interface TypeToInstanceMap<B> extends Map<TypeToken<? extends B>, B>  {\n", "   * Returns the value the specified class is mapped to, or {@code null} if no\n", "   * entry for this class is present. This will only return a value that was\n", "   * bound to this specific class, not a value that may have been bound to a\n", "   * subtype.\n"], "3": ["   * Maps the specified class to the specified value. Does <i>not</i> associate\n", "   * this value with any of the class's supertypes.\n", "   * @return the value previously associated with this class (possibly {@code null}),\n", "   *         or {@code null} if there was no previous entry.\n", "   * Returns the value the specified type is mapped to, or {@code null} if no\n", "   * entry for this type is present. This will only return a value that was\n", "   * bound to this specific type, not a value that may have been bound to a subtype.\n", "   * Maps the specified type to the specified value. Does <i>not</i> associate\n", "   * this value with any of the type's supertypes.\n", "   * @return the value previously associated with this type (possibly {@code null}),\n", "   *         or {@code null} if there was no previous entry.\n"]}, "added_lines": {"1": [4, 5, 9, 10, 11, 12], "2": [25, 26, 27, 29, 30, 31, 33, 34, 36, 37, 39, 45, 48, 49, 50], "3": [59, 60, 65, 66, 73, 74, 75, 81, 82, 84, 85]}, "removed_lines": {"1": [4, 5, 6, 10, 11, 12, 13, 14], "2": [27, 28, 29, 31, 32, 33, 35, 36, 38, 39, 40, 42, 43, 49, 52, 53, 54, 55], "3": [64, 65, 70, 71, 78, 79, 80, 86, 87, 89, 90]}}, {"12": "guava/src/com/google/common/reflect/TypeToken.java", "added": {"1": [" * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not use this file except\n", " * in compliance with the License. You may obtain a copy of the License at\n", " * Unless required by applicable law or agreed to in writing, software distributed under the License\n", " * is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express\n", " * or implied. See the License for the specific language governing permissions and limitations under\n", " * the License.\n"], "2": [" * <p>There are three ways to get a {@code TypeToken} instance:\n", " *\n", " * <ul>\n", " *\n", " * <li>Wrap a {@code Type} obtained via reflection. For example:\n", " *     {@code TypeToken.of(method.getGenericReturnType())}.\n", " *\n", " *\n", " *     <p>Note that it's critical that the actual type argument is carried by a subclass. The\n", " *     following code is wrong because it only captures the {@code <T>} type variable of the {@code\n", " *     listType()} method signature; while {@code <String>} is lost in erasure:\n", " *\n"], "3": [" *\n", " * <li>Capture a generic type with a (usually anonymous) subclass and resolve it against a context\n", " *     class that knows what the type parameters are. For example: <pre>   {@code\n", " *\n", " * <p>Note to Guice users: {@code} TypeToken is similar to Guice's {@code TypeLiteral} class except\n", " * that it is serializable and offers numerous additional utility methods.\n"], "4": ["   * <p>Clients create an empty anonymous subclass. Doing so embeds the type parameter in the\n", "   * anonymous class's type hierarchy so we can reconstitute it at runtime despite erasure.\n", "    checkState(\n", "        !(runtimeType instanceof TypeVariable),\n", "            + \"You probably meant to call new TypeToken<%s>(getClass()) \"\n", "            + \"that can resolve the type variable for you.\\n\"\n", "            + \"If you do need to create a TypeToken of a type variable, \"\n", "            + \"please use TypeToken.of() instead.\",\n", "        runtimeType);\n", "   * <p>Clients create an empty anonymous subclass. Doing so embeds the type parameter in the\n", "   * anonymous class's type hierarchy so we can reconstitute it at runtime despite erasure.\n"], "5": ["   * <p>Returns a new {@code TypeToken} where type variables represented by {@code typeParam} are\n", "   * substituted by {@code typeArg}. For example, it can be used to construct {@code Map<K, V>} for\n", "   * any {@code K} and {@code V} type: <pre>   {@code\n"], "6": ["    TypeResolver resolver =\n", "        new TypeResolver()\n", "            .where(\n", "                ImmutableMap.of(\n", "                    new TypeResolver.TypeVariableKey(typeParam.typeVariable), typeArg.runtimeType));\n", "   * <p>Returns a new {@code TypeToken} where type variables represented by {@code typeParam} are\n", "   * substituted by {@code typeArg}. For example, it can be used to construct {@code Map<K, V>} for\n", "   * any {@code K} and {@code V} type: <pre>   {@code\n"], "7": ["   * <p>Resolves the given {@code type} against the type context represented by this type. For\n", "   * example: <pre>   {@code\n"], "8": ["   * {@link Object} or an interface. This method is similar but different from\n", "   * {@link Class#getGenericSuperclass}. For example, {@code new TypeToken<StringArrayList>()\n", "   * {}.getGenericSuperclass()} will return {@code new TypeToken<ArrayList<String>>() {}}; while\n", "   * {@code StringArrayList.class.getGenericSuperclass()} will return {@code ArrayList<E>}, where\n", "   * {@code E} is the type variable declared by class {@code ArrayList}.\n"], "9": ["  @Nullable\n", "  private TypeToken<? super T> boundAsSuperclass(Type bound) {\n"], "10": ["   * similar but different from {@link Class#getGenericInterfaces()}. For example, {@code new\n", "   * TypeToken<List<String>>() {}.getGenericInterfaces()} will return a list that contains\n"], "11": ["      TypeToken<? super T> resolvedInterface =\n", "          (TypeToken<? super T>) resolveSupertype(interfaceType);\n"], "12": ["   * {@code ArrayList<String>}, {@code Iterable<String>} is returned given the input\n", "   * {@code Iterable.class}.\n", "    checkArgument(\n", "        this.someRawTypeIsSubclassOf(superclass),\n", "        \"%s is not a super class of %s\",\n", "        superclass,\n", "        this);\n"], "13": ["    TypeToken<? super T> supertype =\n", "        (TypeToken<? super T>) resolveSupertype(toGenericType(superclass).runtimeType);\n", "   * Returns subtype of {@code this} with {@code subclass} as the raw class. For example, if this is\n", "   * {@code Iterable<String>} and {@code subclass} is {@code List}, {@code List<String>} is\n", "   * returned.\n", "    checkArgument(\n", "        !(runtimeType instanceof TypeVariable), \"Cannot get subtype of type variable <%s>\", this);\n"], "14": ["    checkArgument(\n", "        getRawType().isAssignableFrom(subclass), \"%s isn't a subclass of %s\", subclass, this);\n"], "15": ["   * according to\n", "   * <a href=\"http://docs.oracle.com/javase/specs/jls/se8/html/jls-4.html#jls-4.5.1\">the rules for\n", "   * type arguments</a> introduced with Java generics.\n"], "16": ["   * according to\n", "   * <a href=\"http://docs.oracle.com/javase/specs/jls/se8/html/jls-4.html#jls-4.5.1\">the rules for\n", "   * type arguments</a> introduced with Java generics.\n"], "17": ["   * according to\n", "   * <a href=\"http://docs.oracle.com/javase/specs/jls/se8/html/jls-4.html#jls-4.5.1\">the rules for\n", "   * type arguments</a> introduced with Java generics.\n"], "18": ["   * according to\n", "   * <a href=\"http://docs.oracle.com/javase/specs/jls/se8/html/jls-4.html#jls-4.5.1\">the rules for\n", "   * type arguments</a> introduced with Java generics.\n"], "19": ["  @Nullable\n", "  public final TypeToken<?> getComponentType() {\n"], "20": ["    checkArgument(\n", "        this.someRawTypeIsSubclassOf(method.getDeclaringClass()),\n", "        \"%s not declared by %s\",\n", "        method,\n", "        this);\n", "      @Override\n", "      Type getGenericReturnType() {\n", "\n", "      @Override\n", "      Type[] getGenericParameterTypes() {\n", "\n", "      @Override\n", "      Type[] getGenericExceptionTypes() {\n", "\n", "      @Override\n", "      public TypeToken<T> getOwnerType() {\n", "\n", "      @Override\n", "      public String toString() {\n"], "21": ["    checkArgument(\n", "        constructor.getDeclaringClass() == getRawType(),\n", "        \"%s not declared by %s\",\n", "        constructor,\n", "        getRawType());\n", "      @Override\n", "      Type getGenericReturnType() {\n", "\n", "      @Override\n", "      Type[] getGenericParameterTypes() {\n", "\n", "      @Override\n", "      Type[] getGenericExceptionTypes() {\n", "\n", "      @Override\n", "      public TypeToken<T> getOwnerType() {\n", "\n", "      @Override\n", "      public String toString() {\n"], "22": ["    @Override\n", "    protected Set<TypeToken<? super T>> delegate() {\n", "        ImmutableList<TypeToken<? super T>> collectedTypes =\n", "            (ImmutableList) TypeCollector.FOR_GENERIC_TYPE.collectTypes(TypeToken.this);\n", "        return (types =\n", "            FluentIterable.from(collectedTypes)\n"], "23": ["      ImmutableList<Class<? super T>> collectedTypes =\n", "          (ImmutableList) TypeCollector.FOR_RAW_TYPE.collectTypes(getRawTypes());\n"], "24": ["    @Override\n", "    protected Set<TypeToken<? super T>> delegate() {\n", "        return (interfaces =\n", "            FluentIterable.from(allTypes).filter(TypeFilter.INTERFACE_ONLY).toSet());\n", "    @Override\n", "    public TypeSet interfaces() {\n", "    @Override\n", "    public Set<Class<? super T>> rawTypes() {\n", "      ImmutableList<Class<? super T>> collectedTypes =\n", "          (ImmutableList) TypeCollector.FOR_RAW_TYPE.collectTypes(getRawTypes());\n", "          .filter(\n", "              new Predicate<Class<?>>() {\n", "                @Override\n", "                public boolean apply(Class<?> type) {\n", "                  return type.isInterface();\n", "                }\n", "              })\n", "    @Override\n", "    public TypeSet classes() {\n"], "25": ["    @Override\n", "    protected Set<TypeToken<? super T>> delegate() {\n", "        ImmutableList<TypeToken<? super T>> collectedTypes =\n", "            (ImmutableList)\n", "                TypeCollector.FOR_GENERIC_TYPE.classesOnly().collectTypes(TypeToken.this);\n", "        return (classes =\n", "            FluentIterable.from(collectedTypes)\n", "                .filter(TypeFilter.IGNORE_TYPE_VARIABLE_OR_WILDCARD)\n", "                .toSet());\n", "    @Override\n", "    public TypeSet classes() {\n", "    @Override\n", "    public Set<Class<? super T>> rawTypes() {\n", "      ImmutableList<Class<? super T>> collectedTypes =\n", "          (ImmutableList) TypeCollector.FOR_RAW_TYPE.classesOnly().collectTypes(getRawTypes());\n", "    @Override\n", "    public TypeSet interfaces() {\n"], "26": ["      @Override\n", "      public boolean apply(TypeToken<?> type) {\n", "      @Override\n", "      public boolean apply(TypeToken<?> type) {\n"], "27": ["  @Override\n", "  public boolean equals(@Nullable Object o) {\n"], "28": ["  @Override\n", "  public int hashCode() {\n", "  @Override\n", "  public String toString() {\n"], "29": ["      @Override\n", "      void visitTypeVariable(TypeVariable<?> type) {\n", "\n", "      @Override\n", "      void visitWildcardType(WildcardType type) {\n", "\n", "      @Override\n", "      void visitParameterizedType(ParameterizedType type) {\n", "\n", "      @Override\n", "      void visitGenericArrayType(GenericArrayType type) {\n"], "30": ["   * Return true if any of the following conditions is met:\n", "   *\n", "   * <ul>\n"], "31": ["      @Override\n", "      void visitTypeVariable(TypeVariable<?> t) {\n", "\n", "      @Override\n", "      void visitWildcardType(WildcardType t) {\n", "\n", "      @Override\n", "      void visitParameterizedType(ParameterizedType t) {\n", "\n", "      @Override\n", "      void visitClass(Class<?> t) {\n", "      @Override\n", "      void visitGenericArrayType(GenericArrayType t) {\n", "        builder.add(Types.getArrayClass(of(t.getGenericComponentType()).getRawType()));\n", "      }\n"], "32": ["  @VisibleForTesting\n", "  static <T> TypeToken<? extends T> toGenericType(Class<T> cls) {\n", "      Type arrayOfGenericType =\n", "          Types.newArrayType(\n", "              // If we are passed with int[].class, don't turn it to GenericArrayType\n", "              toGenericType(cls.getComponentType()).runtimeType);\n", "    Type ownerType =\n", "        cls.isMemberClass() ? toGenericType(cls.getEnclosingClass()).runtimeType : null;\n", "      TypeToken<? extends T> type =\n", "          (TypeToken<? extends T>)\n", "              of(Types.newParameterizedTypeWithOwner(ownerType, cls, typeParams));\n"], "33": ["    TypeToken componentType =\n", "        checkNotNull(getComponentType(), \"%s isn't a super type of %s\", supertype, this);\n", "    TypeToken<? super T> result =\n", "        (TypeToken<? super T>)\n", "            // If we are passed with int[].class, don't turn it to GenericArrayType\n", "            of(newArrayClassOrGenericArrayType(componentSupertype.runtimeType));\n", "    TypeToken<?> componentSubtype = getComponentType().getSubtype(subclass.getComponentType());\n", "    TypeToken<? extends T> result =\n", "        (TypeToken<? extends T>)\n", "            // If we are passed with int[].class, don't turn it to GenericArrayType\n", "            of(newArrayClassOrGenericArrayType(componentSubtype.runtimeType));\n"], "34": ["    Type supertypeWithArgsFromSubtype =\n", "        genericSubtype.getSupertype((Class) getRawType()).runtimeType;\n", "    return new TypeResolver()\n", "        .where(supertypeWithArgsFromSubtype, runtimeType)\n", "   * {@link GenericArrayType}. This is what Java7 does for generic array type parameters.\n"], "35": ["          @Override\n", "          Class<?> getRawType(TypeToken<?> type) {\n", "          @Override\n", "          Iterable<? extends TypeToken<?>> getInterfaces(TypeToken<?> type) {\n", "          @Override\n", "          TypeToken<?> getSuperclass(TypeToken<?> type) {\n", "          @Override\n", "          Class<?> getRawType(Class<?> type) {\n", "          @Override\n", "          Iterable<? extends Class<?>> getInterfaces(Class<?> type) {\n", "          @Override\n", "          Class<?> getSuperclass(Class<?> type) {\n"], "36": ["        @Override\n", "        Iterable<? extends K> getInterfaces(K type) {\n", "\n", "        @Override\n", "        ImmutableList<K> collectTypes(Iterable<? extends K> types) {\n"], "37": ["      // Interfaces should be listed before Object.\n", "      int aboveMe = getRawType(type).isInterface() ? 1 : 0;\n"], "38": ["       * TODO(benyu): should we include Object for interface? Also, CharSequence[] and Object[] for\n", "       * String[]?\n"], "39": ["      Ordering<K> keyOrdering =\n", "          new Ordering<K>() {\n", "            @Override\n", "            public int compare(K left, K right) {\n", "              return valueComparator.compare(map.get(left), map.get(right));\n", "            }\n", "          };\n", "\n", "\n", "    @Nullable\n", "    abstract K getSuperclass(K type);\n"], "40": ["      @Override\n", "      Class<?> getRawType(K type) {\n", "      @Override\n", "      Iterable<? extends K> getInterfaces(K type) {\n", "      @Override\n", "      K getSuperclass(K type) {\n"]}, "removed": {"1": [" * Licensed under the Apache License, Version 2.0 (the \"License\");\n", " * you may not use this file except in compliance with the License.\n", " * You may obtain a copy of the License at\n", " * Unless required by applicable law or agreed to in writing, software\n", " * distributed under the License is distributed on an \"AS IS\" BASIS,\n", " * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n", " * See the License for the specific language governing permissions and\n", " * limitations under the License.\n"], "2": [" * <p>There are three ways to get a {@code TypeToken} instance: <ul>\n", " * <li>Wrap a {@code Type} obtained via reflection. For example: {@code\n", " * TypeToken.of(method.getGenericReturnType())}.\n", " * <p>Note that it's critical that the actual type argument is carried by a subclass.\n", " * The following code is wrong because it only captures the {@code <T>} type variable\n", " * of the {@code listType()} method signature; while {@code <String>} is lost in erasure:\n"], "3": [" * <li>Capture a generic type with a (usually anonymous) subclass and resolve it against\n", " * a context class that knows what the type parameters are. For example: <pre>   {@code\n", " * <p>Note to Guice users: {@code} TypeToken is similar to Guice's {@code TypeLiteral} class\n", " * except that it is serializable and offers numerous additional utility methods.\n"], "4": ["   * <p>Clients create an empty anonymous subclass. Doing so embeds the type\n", "   * parameter in the anonymous class's type hierarchy so we can reconstitute\n", "   * it at runtime despite erasure.\n", "    checkState(!(runtimeType instanceof TypeVariable),\n", "        + \"You probably meant to call new TypeToken<%s>(getClass()) \"\n", "        + \"that can resolve the type variable for you.\\n\"\n", "        + \"If you do need to create a TypeToken of a type variable, \"\n", "        + \"please use TypeToken.of() instead.\", runtimeType);\n", "   * <p>Clients create an empty anonymous subclass. Doing so embeds the type\n", "   * parameter in the anonymous class's type hierarchy so we can reconstitute\n", "   * it at runtime despite erasure.\n"], "5": ["   * <p>Returns a new {@code TypeToken} where type variables represented by {@code typeParam}\n", "   * are substituted by {@code typeArg}. For example, it can be used to construct\n", "   * {@code Map<K, V>} for any {@code K} and {@code V} type: <pre>   {@code\n"], "6": ["    TypeResolver resolver = new TypeResolver()\n", "        .where(ImmutableMap.of(\n", "            new TypeResolver.TypeVariableKey(typeParam.typeVariable),\n", "            typeArg.runtimeType));\n", "   * <p>Returns a new {@code TypeToken} where type variables represented by {@code typeParam}\n", "   * are substituted by {@code typeArg}. For example, it can be used to construct\n", "   * {@code Map<K, V>} for any {@code K} and {@code V} type: <pre>   {@code\n"], "7": ["   * <p>Resolves the given {@code type} against the type context represented by this type.\n", "   * For example: <pre>   {@code\n"], "8": ["   * {@link Object} or an interface. This method is similar but different from {@link\n", "   * Class#getGenericSuperclass}. For example, {@code\n", "   * new TypeToken<StringArrayList>() {}.getGenericSuperclass()} will return {@code\n", "   * new TypeToken<ArrayList<String>>() {}}; while {@code\n", "   * StringArrayList.class.getGenericSuperclass()} will return {@code ArrayList<E>}, where {@code E}\n", "   * is the type variable declared by class {@code ArrayList}.\n"], "9": ["  @Nullable private TypeToken<? super T> boundAsSuperclass(Type bound) {\n"], "10": ["   * similar but different from {@link Class#getGenericInterfaces()}. For example, {@code\n", "   * new TypeToken<List<String>>() {}.getGenericInterfaces()} will return a list that contains\n"], "11": ["      TypeToken<? super T> resolvedInterface = (TypeToken<? super T>)\n", "          resolveSupertype(interfaceType);\n"], "12": ["   * {@code ArrayList<String>}, {@code Iterable<String>} is returned given the\n", "   * input {@code Iterable.class}.\n", "    checkArgument(this.someRawTypeIsSubclassOf(superclass),\n", "        \"%s is not a super class of %s\", superclass, this);\n"], "13": ["    TypeToken<? super T> supertype = (TypeToken<? super T>)\n", "        resolveSupertype(toGenericType(superclass).runtimeType);\n", "   * Returns subtype of {@code this} with {@code subclass} as the raw class.\n", "   * For example, if this is {@code Iterable<String>} and {@code subclass} is {@code List},\n", "   * {@code List<String>} is returned.\n", "    checkArgument(!(runtimeType instanceof TypeVariable),\n", "        \"Cannot get subtype of type variable <%s>\", this);\n"], "14": ["    checkArgument(getRawType().isAssignableFrom(subclass),\n", "        \"%s isn't a subclass of %s\", subclass, this);\n"], "15": ["   * according to <a href=\"http://docs.oracle.com/javase/specs/jls/se8/html/jls-4.html#jls-4.5.1\"\n", "   * >the rules for type arguments</a> introduced with Java generics.\n"], "16": ["   * according to <a href=\"http://docs.oracle.com/javase/specs/jls/se8/html/jls-4.html#jls-4.5.1\"\n", "   * >the rules for type arguments</a> introduced with Java generics.\n"], "17": ["   * according to <a href=\"http://docs.oracle.com/javase/specs/jls/se8/html/jls-4.html#jls-4.5.1\"\n", "   * >the rules for type arguments</a> introduced with Java generics.\n"], "18": ["   * according to <a href=\"http://docs.oracle.com/javase/specs/jls/se8/html/jls-4.html#jls-4.5.1\"\n", "   * >the rules for type arguments</a> introduced with Java generics.\n"], "19": ["  @Nullable public final TypeToken<?> getComponentType() {\n"], "20": ["    checkArgument(this.someRawTypeIsSubclassOf(method.getDeclaringClass()),\n", "        \"%s not declared by %s\", method, this);\n", "      @Override Type getGenericReturnType() {\n", "      @Override Type[] getGenericParameterTypes() {\n", "      @Override Type[] getGenericExceptionTypes() {\n", "      @Override public TypeToken<T> getOwnerType() {\n", "      @Override public String toString() {\n"], "21": ["    checkArgument(constructor.getDeclaringClass() == getRawType(),\n", "        \"%s not declared by %s\", constructor, getRawType());\n", "      @Override Type getGenericReturnType() {\n", "      @Override Type[] getGenericParameterTypes() {\n", "      @Override Type[] getGenericExceptionTypes() {\n", "      @Override public TypeToken<T> getOwnerType() {\n", "      @Override public String toString() {\n"], "22": ["    @Override protected Set<TypeToken<? super T>> delegate() {\n", "        ImmutableList<TypeToken<? super T>> collectedTypes = (ImmutableList)\n", "            TypeCollector.FOR_GENERIC_TYPE.collectTypes(TypeToken.this);\n", "        return (types = FluentIterable.from(collectedTypes)\n"], "23": ["      ImmutableList<Class<? super T>> collectedTypes = (ImmutableList)\n", "          TypeCollector.FOR_RAW_TYPE.collectTypes(getRawTypes());\n"], "24": ["    @Override protected Set<TypeToken<? super T>> delegate() {\n", "        return (interfaces = FluentIterable.from(allTypes)\n", "            .filter(TypeFilter.INTERFACE_ONLY)\n", "            .toSet());\n", "    @Override public TypeSet interfaces() {\n", "    @Override public Set<Class<? super T>> rawTypes() {\n", "      ImmutableList<Class<? super T>> collectedTypes = (ImmutableList)\n", "          TypeCollector.FOR_RAW_TYPE.collectTypes(getRawTypes());\n", "          .filter(new Predicate<Class<?>>() {\n", "            @Override public boolean apply(Class<?> type) {\n", "              return type.isInterface();\n", "            }\n", "          })\n", "    @Override public TypeSet classes() {\n"], "25": ["    @Override protected Set<TypeToken<? super T>> delegate() {\n", "        ImmutableList<TypeToken<? super T>> collectedTypes = (ImmutableList)\n", "            TypeCollector.FOR_GENERIC_TYPE.classesOnly().collectTypes(TypeToken.this);\n", "        return (classes = FluentIterable.from(collectedTypes)\n", "            .filter(TypeFilter.IGNORE_TYPE_VARIABLE_OR_WILDCARD)\n", "            .toSet());\n", "    @Override public TypeSet classes() {\n", "    @Override public Set<Class<? super T>> rawTypes() {\n", "      ImmutableList<Class<? super T>> collectedTypes = (ImmutableList)\n", "          TypeCollector.FOR_RAW_TYPE.classesOnly().collectTypes(getRawTypes());\n", "    @Override public TypeSet interfaces() {\n"], "26": ["\n", "      @Override public boolean apply(TypeToken<?> type) {\n", "      @Override public boolean apply(TypeToken<?> type) {\n"], "27": ["  @Override public boolean equals(@Nullable Object o) {\n"], "28": ["  @Override public int hashCode() {\n", "  @Override public String toString() {\n"], "29": ["      @Override void visitTypeVariable(TypeVariable<?> type) {\n", "      @Override void visitWildcardType(WildcardType type) {\n", "      @Override void visitParameterizedType(ParameterizedType type) {\n", "      @Override void visitGenericArrayType(GenericArrayType type) {\n"], "30": ["   * Return true if any of the following conditions is met: <ul>\n"], "31": ["      @Override void visitTypeVariable(TypeVariable<?> t) {\n", "      @Override void visitWildcardType(WildcardType t) {\n", "      @Override void visitParameterizedType(ParameterizedType t) {\n", "      @Override void visitClass(Class<?> t) {\n", "      @Override void visitGenericArrayType(GenericArrayType t) {\n", "        builder.add(Types.getArrayClass(\n", "            of(t.getGenericComponentType()).getRawType()));\n", "      }\n"], "32": ["  @VisibleForTesting static <T> TypeToken<? extends T> toGenericType(Class<T> cls) {\n", "      Type arrayOfGenericType = Types.newArrayType(\n", "          // If we are passed with int[].class, don't turn it to GenericArrayType\n", "          toGenericType(cls.getComponentType()).runtimeType);\n", "    Type ownerType = cls.isMemberClass()\n", "        ? toGenericType(cls.getEnclosingClass()).runtimeType : null;\n", "      TypeToken<? extends T> type = (TypeToken<? extends T>)\n", "          of(Types.newParameterizedTypeWithOwner(ownerType, cls, typeParams));\n"], "33": ["    TypeToken componentType = checkNotNull(getComponentType(),\n", "        \"%s isn't a super type of %s\", supertype, this);\n", "    TypeToken<? super T> result = (TypeToken<? super T>)\n", "        // If we are passed with int[].class, don't turn it to GenericArrayType\n", "        of(newArrayClassOrGenericArrayType(componentSupertype.runtimeType));\n", "    TypeToken<?> componentSubtype = getComponentType()\n", "        .getSubtype(subclass.getComponentType());\n", "    TypeToken<? extends T> result = (TypeToken<? extends T>)\n", "        // If we are passed with int[].class, don't turn it to GenericArrayType\n", "        of(newArrayClassOrGenericArrayType(componentSubtype.runtimeType));\n"], "34": ["    Type supertypeWithArgsFromSubtype = genericSubtype\n", "        .getSupertype((Class) getRawType())\n", "        .runtimeType;\n", "    return new TypeResolver().where(supertypeWithArgsFromSubtype, runtimeType)\n", "   * {@link GenericArrayType}. This is what Java7 does for generic array type\n", "   * parameters.\n"], "35": ["          @Override Class<?> getRawType(TypeToken<?> type) {\n", "          @Override Iterable<? extends TypeToken<?>> getInterfaces(TypeToken<?> type) {\n", "          @Override TypeToken<?> getSuperclass(TypeToken<?> type) {\n", "          @Override Class<?> getRawType(Class<?> type) {\n", "          @Override Iterable<? extends Class<?>> getInterfaces(Class<?> type) {\n", "          @Override Class<?> getSuperclass(Class<?> type) {\n"], "36": ["        @Override Iterable<? extends K> getInterfaces(K type) {\n", "        @Override ImmutableList<K> collectTypes(Iterable<? extends K> types) {\n"], "37": ["      int aboveMe = getRawType(type).isInterface()\n", "          ? 1 // interfaces should be listed before Object\n", "          : 0;\n"], "38": ["       * TODO(benyu): should we include Object for interface?\n", "       * Also, CharSequence[] and Object[] for String[]?\n"], "39": ["      Ordering<K> keyOrdering = new Ordering<K>() {\n", "        @Override public int compare(K left, K right) {\n", "          return valueComparator.compare(map.get(left), map.get(right));\n", "        }\n", "      };\n", "    @Nullable abstract K getSuperclass(K type);\n"], "40": ["      @Override Class<?> getRawType(K type) {\n", "      @Override Iterable<? extends K> getInterfaces(K type) {\n", "      @Override K getSuperclass(K type) {\n"]}, "added_lines": {"1": [4, 5, 9, 10, 11, 12], "2": [57, 58, 59, 60, 61, 62, 63, 66, 67, 68, 69, 70], "3": [79, 80, 81, 86, 91, 92], "4": [111, 112, 119, 120, 122, 123, 124, 125, 126, 133, 134], "5": [196, 197, 198], "6": [211, 212, 213, 214, 215, 221, 222, 223], "7": [240, 241], "8": [271, 272, 273, 274, 275], "9": [300, 301], "10": [313, 314], "11": [333, 334], "12": [369, 370, 373, 374, 375, 376, 377], "13": [388, 389, 394, 395, 396, 399, 400], "14": [409, 410], "15": [419, 420, 421], "16": [431, 432, 433], "17": [443, 444, 445], "18": [455, 456, 457], "19": [551, 552], "20": [566, 567, 568, 569, 570, 572, 573, 576, 577, 578, 581, 582, 583, 586, 587, 588, 591, 592, 593], "21": [605, 606, 607, 608, 609, 611, 612, 615, 616, 617, 620, 621, 622, 625, 626, 627, 630, 631, 632], "22": [658, 659, 664, 665, 666, 667], "23": [679, 680], "24": [696, 697, 700, 701, 707, 708, 712, 713, 716, 717, 719, 720, 721, 722, 723, 724, 725, 729, 730], "25": [745, 746, 750, 751, 752, 753, 754, 755, 756, 762, 763, 767, 768, 771, 772, 776, 777], "26": [790, 791, 797, 798], "27": [807, 808], "28": [816, 817, 821, 822], "29": [840, 841, 845, 846, 847, 851, 852, 853, 857, 858, 859], "30": [929, 930, 931], "31": [995, 996, 999, 1000, 1001, 1004, 1005, 1006, 1009, 1010, 1011, 1015, 1016, 1017, 1018], "32": [1033, 1034, 1036, 1037, 1038, 1039, 1045, 1046, 1050, 1051, 1052], "33": [1087, 1088, 1093, 1094, 1095, 1096, 1102, 1104, 1105, 1106, 1107], "34": [1125, 1126, 1127, 1128, 1134], "35": [1158, 1159, 1163, 1164, 1169, 1170, 1177, 1178, 1182, 1183, 1188, 1189], "36": [1197, 1198, 1201, 1202, 1203], "37": [1236, 1237], "38": [1246, 1247], "39": [1256, 1257, 1258, 1259, 1260, 1261, 1262, 1267, 1269, 1270, 1271], "40": [1281, 1282, 1286, 1287, 1291, 1292]}, "removed_lines": {"1": [4, 5, 6, 10, 11, 12, 13, 14], "2": [59, 60, 61, 64, 65, 66], "3": [75, 76, 85, 86], "4": [105, 106, 107, 114, 116, 117, 118, 119, 126, 127, 128], "5": [190, 191, 192], "6": [205, 206, 207, 208, 214, 215, 216], "7": [233, 234], "8": [264, 265, 266, 267, 268, 269], "9": [294], "10": [306, 307], "11": [326, 327], "12": [362, 363, 366, 367], "13": [378, 379, 384, 385, 386, 389, 390], "14": [399, 400], "15": [409, 410], "16": [420, 421], "17": [431, 432], "18": [442, 443], "19": [537], "20": [551, 552, 554, 557, 560, 563, 566], "21": [578, 579, 581, 584, 587, 590, 593], "22": [619, 624, 625, 626], "23": [638, 639], "24": [655, 658, 659, 660, 666, 670, 673, 674, 676, 677, 678, 679, 680, 684], "25": [699, 703, 704, 705, 706, 707, 713, 717, 720, 721, 725], "26": [737, 739, 745], "27": [754], "28": [762, 766], "29": [784, 788, 792, 796], "30": [866], "31": [930, 933, 936, 939, 942, 943, 944, 945], "32": [961, 963, 964, 965, 971, 972, 976, 977], "33": [1012, 1013, 1018, 1019, 1020, 1026, 1027, 1029, 1030, 1031], "34": [1049, 1050, 1051, 1052, 1058, 1059], "35": [1083, 1087, 1092, 1099, 1103, 1108], "36": [1116, 1119], "37": [1152, 1153, 1154], "38": [1163, 1164], "39": [1173, 1174, 1175, 1176, 1177, 1183], "40": [1193, 1197, 1201]}}, {"13": "guava/src/com/google/common/reflect/TypeVisitor.java", "added": {"1": [" * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not use this file except\n", " * in compliance with the License. You may obtain a copy of the License at\n", " * Unless required by applicable law or agreed to in writing, software distributed under the License\n", " * is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express\n", " * or implied. See the License for the specific language governing permissions and limitations under\n", " * the License.\n"]}, "removed": {"1": [" * Licensed under the Apache License, Version 2.0 (the \"License\");\n", " * you may not use this file except in compliance with the License.\n", " * You may obtain a copy of the License at\n", " * Unless required by applicable law or agreed to in writing, software\n", " * distributed under the License is distributed on an \"AS IS\" BASIS,\n", " * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n", " * See the License for the specific language governing permissions and\n", " * limitations under the License.\n"]}, "added_lines": {"1": [4, 5, 9, 10, 11, 12]}, "removed_lines": {"1": [4, 5, 6, 10, 11, 12, 13, 14]}}, {"14": "guava/src/com/google/common/reflect/Types.java", "added": {"1": [" * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not use this file except\n", " * in compliance with the License. You may obtain a copy of the License at\n", " * Unless required by applicable law or agreed to in writing, software distributed under the License\n", " * is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express\n", " * or implied. See the License for the specific language governing permissions and limitations under\n", " * the License.\n"], "2": ["        @Override\n", "        public String apply(Type from) {\n"], "3": ["   * Returns a type where {@code rawType} is parameterized by {@code arguments} and is owned by\n", "   * {@code ownerType}.\n"], "4": ["   * Returns a type where {@code rawType} is parameterized by {@code arguments}.\n", "    return new ParameterizedTypeImpl(\n", "        ClassOwnership.JVM_BEHAVIOR.getOwnerType(rawType), rawType, arguments);\n"], "5": ["    @Nullable\n", "    abstract Class<?> getOwnerType(Class<?> rawType);\n", "      ParameterizedType parameterizedType = (ParameterizedType) subclass.getGenericSuperclass();\n"], "6": ["   * Returns a new {@link TypeVariable} that belongs to {@code declaration} with {@code name} and\n", "   * {@code bounds}.\n", "        declaration, name, (bounds.length == 0) ? new Type[] {Object.class} : bounds);\n", "  @VisibleForTesting\n", "  static WildcardType subtypeOf(Type upperBound) {\n", "    return new WildcardTypeImpl(new Type[0], new Type[] {upperBound});\n", "  @VisibleForTesting\n", "  static WildcardType supertypeOf(Type lowerBound) {\n", "    return new WildcardTypeImpl(new Type[] {lowerBound}, new Type[] {Object.class});\n", "   * <li>For array type {@code Foo[]}, {@code \"com.mypackage.Foo[]\"} are returned.\n", "   * <li>For any class, {@code theClass.getName()} are returned.\n", "   * <li>For all other types, {@code type.toString()} are returned.\n", "    return (type instanceof Class) ? ((Class<?>) type).getName() : type.toString();\n", "  @Nullable\n", "  static Type getComponentType(Type type) {\n", "      @Override\n", "      void visitTypeVariable(TypeVariable<?> t) {\n", "\n", "      @Override\n", "      void visitWildcardType(WildcardType t) {\n", "\n", "      @Override\n", "      void visitGenericArrayType(GenericArrayType t) {\n", "\n", "      @Override\n", "      void visitClass(Class<?> t) {\n"], "7": ["  @Nullable\n", "  private static Type subtypeOfComponentType(Type[] bounds) {\n"], "8": ["  private static final class GenericArrayTypeImpl implements GenericArrayType, Serializable {\n"], "9": ["    @Override\n", "    public Type getGenericComponentType() {\n", "    @Override\n", "    public String toString() {\n", "    @Override\n", "    public int hashCode() {\n", "    @Override\n", "    public boolean equals(Object obj) {\n", "        return Objects.equal(getGenericComponentType(), that.getGenericComponentType());\n"], "10": ["  private static final class ParameterizedTypeImpl implements ParameterizedType, Serializable {\n", "    ParameterizedTypeImpl(@Nullable Type ownerType, Class<?> rawType, Type[] typeArguments) {\n"], "11": ["    @Override\n", "    public Type[] getActualTypeArguments() {\n", "    @Override\n", "    public Type getRawType() {\n", "    @Override\n", "    public Type getOwnerType() {\n", "    @Override\n", "    public String toString() {\n", "      return builder\n", "          .append(rawType.getName())\n", "          .append('>')\n", "          .toString();\n", "    @Override\n", "    public int hashCode() {\n", "          ^ argumentsList.hashCode()\n", "          ^ rawType.hashCode();\n", "    @Override\n", "    public boolean equals(Object other) {\n", "          && Arrays.equals(getActualTypeArguments(), that.getActualTypeArguments());\n"], "12": ["    TypeVariable<D> typeVariable =\n", "        Reflection.newProxy(\n", "            TypeVariable.class, new TypeVariableInvocationHandler(typeVariableImpl));\n"], "13": ["   * Java 8. If we include the {@code getAnnotatedBounds()} method then its return type means it\n", "   * won't compile on Java 7, while if we don't include the method then the compiler will complain\n", "   * that an abstract method is unimplemented. So instead we use a dynamic proxy to get an\n", "   * implementation. If the method being called on the {@code TypeVariable} instance has the same\n", "   * name as one of the public methods of {@link TypeVariableImpl}, the proxy calls the same method\n", "   * on its instance of {@code TypeVariableImpl}. Otherwise it throws\n", "   * {@link UnsupportedOperationException}; this should only apply to {@code getAnnotatedBounds()}.\n", "   * This does mean that users on Java 8 who obtain an instance of {@code TypeVariable} from\n", "   * {@link TypeResolver#resolveType} will not be able to call {@code getAnnotatedBounds()} on it,\n", "   * but that should hopefully be rare.\n"], "14": ["    @Override\n", "    public Object invoke(Object proxy, Method method, Object[] args) throws Throwable {\n"], "15": ["    @Override\n", "    public String toString() {\n", "    @Override\n", "    public int hashCode() {\n", "    @Override\n", "    public boolean equals(Object obj) {\n"], "16": ["    @Override\n", "    public Type[] getLowerBounds() {\n", "    @Override\n", "    public Type[] getUpperBounds() {\n", "    @Override\n", "    public boolean equals(Object obj) {\n"], "17": ["    @Override\n", "    public int hashCode() {\n", "    @Override\n", "    public String toString() {\n"], "18": ["    return Iterables.filter(bounds, Predicates.not(Predicates.<Type>equalTo(Object.class)));\n", "        checkArgument(!cls.isPrimitive(), \"Primitive type '%s' used as %s\", cls, usedAs);\n"], "19": ["      @Override\n", "      GenericArrayType newArrayType(Type componentType) {\n", "\n", "      @Override\n", "      Type usedInGenericType(Type type) {\n"], "20": ["      @Override\n", "      Type newArrayType(Type componentType) {\n", "\n", "      @Override\n", "      Type usedInGenericType(Type type) {\n", "      @Override\n", "      Type newArrayType(Type componentType) {\n", "\n", "      @Override\n", "      Type usedInGenericType(Type type) {\n", "\n", "      @Override\n", "      String typeName(Type type) {\n"], "21": ["    };\n", "\n"], "22": ["   * Per https://code.google.com/p/guava-libraries/issues/detail?id=1635, In JDK 1.7.0_51-b13,\n", "   * TypeVariableImpl.equals() is changed to no longer be equal to custom TypeVariable\n", "   * implementations. As a result, we need to make sure our TypeVariable implementation respects\n", "   * symmetry. Moreover, we don't want to reconstruct a native type variable <A> using our\n", "   * implementation unless some of its bounds have changed in resolution. This avoids creating\n", "   * unequal TypeVariable implementation unnecessarily. When the bounds do change, however, it's\n", "   * fine for the synthetic TypeVariable to be unequal to any native TypeVariable anyway.\n", "        !NativeTypeVariableEquals.class.getTypeParameters()[0]\n", "            .equals(newArtificialTypeVariable(NativeTypeVariableEquals.class, \"X\"));\n"]}, "removed": {"1": [" * Licensed under the Apache License, Version 2.0 (the \"License\");\n", " * you may not use this file except in compliance with the License.\n", " * You may obtain a copy of the License at\n", " * Unless required by applicable law or agreed to in writing, software\n", " * distributed under the License is distributed on an \"AS IS\" BASIS,\n", " * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n", " * See the License for the specific language governing permissions and\n", " * limitations under the License.\n"], "2": ["        @Override public String apply(Type from) {\n"], "3": ["   * Returns a type where {@code rawType} is parameterized by\n", "   * {@code arguments} and is owned by {@code ownerType}.\n"], "4": ["   * Returns a type where {@code rawType} is parameterized by\n", "   * {@code arguments}.\n", "      return new ParameterizedTypeImpl(\n", "          ClassOwnership.JVM_BEHAVIOR.getOwnerType(rawType), rawType, arguments);\n"], "5": ["    @Nullable abstract Class<?> getOwnerType(Class<?> rawType);\n", "      ParameterizedType parameterizedType = (ParameterizedType)\n", "          subclass.getGenericSuperclass();\n"], "6": ["   * Returns a new {@link TypeVariable} that belongs to {@code declaration} with\n", "   * {@code name} and {@code bounds}.\n", "        declaration,\n", "        name,\n", "        (bounds.length == 0)\n", "            ? new Type[] { Object.class }\n", "            : bounds);\n", "  @VisibleForTesting static WildcardType subtypeOf(Type upperBound) {\n", "    return new WildcardTypeImpl(new Type[0], new Type[] { upperBound });\n", "  @VisibleForTesting static WildcardType supertypeOf(Type lowerBound) {\n", "    return new WildcardTypeImpl(new Type[] { lowerBound }, new Type[] { Object.class });\n", "   * <li> For array type {@code Foo[]}, {@code \"com.mypackage.Foo[]\"} are\n", "   * returned.\n", "   * <li> For any class, {@code theClass.getName()} are returned.\n", "   * <li> For all other types, {@code type.toString()} are returned.\n", "    return (type instanceof Class)\n", "        ? ((Class<?>) type).getName()\n", "        : type.toString();\n", "  @Nullable static Type getComponentType(Type type) {\n", "      @Override void visitTypeVariable(TypeVariable<?> t) {\n", "      @Override void visitWildcardType(WildcardType t) {\n", "      @Override void visitGenericArrayType(GenericArrayType t) {\n", "      @Override void visitClass(Class<?> t) {\n"], "7": ["  @Nullable private static Type subtypeOfComponentType(Type[] bounds) {\n"], "8": ["  private static final class GenericArrayTypeImpl\n", "      implements GenericArrayType, Serializable {\n"], "9": ["    @Override public Type getGenericComponentType() {\n", "    @Override public String toString() {\n", "    @Override public int hashCode() {\n", "    @Override public boolean equals(Object obj) {\n", "        return Objects.equal(\n", "            getGenericComponentType(), that.getGenericComponentType());\n"], "10": ["  private static final class ParameterizedTypeImpl\n", "      implements ParameterizedType, Serializable {\n", "    ParameterizedTypeImpl(\n", "        @Nullable Type ownerType, Class<?> rawType, Type[] typeArguments) {\n"], "11": ["    @Override public Type[] getActualTypeArguments() {\n", "    @Override public Type getRawType() {\n", "    @Override public Type getOwnerType() {\n", "    @Override public String toString() {\n", "      builder.append(rawType.getName())\n", "          .append('>');\n", "      return builder.toString();\n", "    @Override public int hashCode() {\n", "          ^ argumentsList.hashCode() ^ rawType.hashCode();\n", "    @Override public boolean equals(Object other) {\n", "          && Arrays.equals(\n", "              getActualTypeArguments(), that.getActualTypeArguments());\n"], "12": ["    TypeVariable<D> typeVariable = Reflection.newProxy(\n", "        TypeVariable.class, new TypeVariableInvocationHandler(typeVariableImpl));\n"], "13": ["   * Java 8. If we include the {@code getAnnotatedBounds()} method then its return type means\n", "   * it won't compile on Java 7, while if we don't include the method then the compiler will\n", "   * complain that an abstract method is unimplemented. So instead we use a dynamic proxy to\n", "   * get an implementation. If the method being called on the {@code TypeVariable} instance has\n", "   * the same name as one of the public methods of {@link TypeVariableImpl}, the proxy calls\n", "   * the same method on its instance of {@code TypeVariableImpl}. Otherwise it throws {@link\n", "   * UnsupportedOperationException}; this should only apply to {@code getAnnotatedBounds()}. This\n", "   * does mean that users on Java 8 who obtain an instance of {@code TypeVariable} from {@link\n", "   * TypeResolver#resolveType} will not be able to call {@code getAnnotatedBounds()} on it, but that\n", "   * should hopefully be rare.\n"], "14": ["    @Override public Object invoke(Object proxy, Method method, Object[] args) throws Throwable {\n"], "15": ["    @Override public String toString() {\n", "    @Override public int hashCode() {\n", "    @Override public boolean equals(Object obj) {\n"], "16": ["    @Override public Type[] getLowerBounds() {\n", "    @Override public Type[] getUpperBounds() {\n", "    @Override public boolean equals(Object obj) {\n"], "17": ["    @Override public int hashCode() {\n", "    @Override public String toString() {\n"], "18": ["    return Iterables.filter(\n", "        bounds, Predicates.not(Predicates.<Type>equalTo(Object.class)));\n", "        checkArgument(!cls.isPrimitive(),\n", "            \"Primitive type '%s' used as %s\", cls, usedAs);\n"], "19": ["\n", "      @Override GenericArrayType newArrayType(Type componentType) {\n", "      @Override Type usedInGenericType(Type type) {\n"], "20": ["      @Override Type newArrayType(Type componentType) {\n", "      @Override Type usedInGenericType(Type type) {\n", "      @Override Type newArrayType(Type componentType) {\n", "      @Override Type usedInGenericType(Type type) {\n", "      @Override String typeName(Type type) {\n"], "21": ["    }\n", "    ;\n"], "22": ["   * Per https://code.google.com/p/guava-libraries/issues/detail?id=1635,\n", "   * In JDK 1.7.0_51-b13, TypeVariableImpl.equals() is changed to no longer be equal to custom\n", "   * TypeVariable implementations. As a result, we need to make sure our TypeVariable implementation\n", "   * respects symmetry.\n", "   * Moreover, we don't want to reconstruct a native type variable <A> using our implementation\n", "   * unless some of its bounds have changed in resolution. This avoids creating unequal TypeVariable\n", "   * implementation unnecessarily. When the bounds do change, however, it's fine for the synthetic\n", "   * TypeVariable to be unequal to any native TypeVariable anyway.\n", "        !NativeTypeVariableEquals.class.getTypeParameters()[0].equals(\n", "            newArtificialTypeVariable(NativeTypeVariableEquals.class, \"X\"));\n"]}, "added_lines": {"1": [4, 5, 9, 10, 11, 12], "2": [60, 61], "3": [86, 87], "4": [101, 104, 105], "5": [129, 130, 137], "6": [148, 149, 154, 158, 159, 160, 164, 165, 166, 172, 173, 174, 178, 181, 182, 186, 187, 190, 191, 192, 195, 196, 197, 200, 201, 202], "7": [213, 214], "8": [232], "9": [240, 241, 245, 246, 250, 251, 255, 256, 259], "10": [267, 273], "11": [282, 283, 287, 288, 292, 293, 297, 298, 303, 304, 307, 308, 311, 312, 314, 315, 318, 319, 326], "12": [337, 338, 339], "13": [349, 350, 351, 352, 353, 354, 355, 356, 357, 358], "14": [388, 389], "15": [433, 434, 438, 439, 443, 444], "16": [482, 483, 487, 488, 492, 493], "17": [502, 503, 507, 508], "18": [527, 534], "19": [550, 551, 554, 555, 556], "20": [568, 569, 576, 577, 578, 583, 584, 587, 588, 589, 592, 593, 594], "21": [606, 609], "22": [638, 639, 640, 641, 642, 643, 644, 648, 649]}, "removed_lines": {"1": [4, 5, 6, 10, 11, 12, 13, 14], "2": [62], "3": [87, 88], "4": [102, 103, 106, 107], "5": [132, 139, 140], "6": [151, 152, 157, 158, 159, 160, 161, 165, 166, 170, 171, 177, 178, 179, 180, 184, 185, 186, 189, 193, 196, 199, 202], "7": [213], "8": [231, 232], "9": [240, 244, 248, 252, 255, 256], "10": [264, 265, 271, 272], "11": [281, 285, 289, 293, 298, 301, 302, 305, 307, 310, 317, 318], "12": [329, 330], "13": [340, 341, 342, 343, 344, 345, 346, 347, 348, 349], "14": [378], "15": [422, 426, 430], "16": [468, 472, 476], "17": [485, 489], "18": [508, 509, 516, 517], "19": [532, 534, 537], "20": [549, 556, 561, 564, 567], "21": [579, 580], "22": [609, 610, 611, 612, 613, 614, 615, 616, 620, 621]}}, {"15": "guava/src/com/google/common/reflect/package-info.java", "added": {"1": [" * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not use this file except\n", " * in compliance with the License. You may obtain a copy of the License at\n", " * Unless required by applicable law or agreed to in writing, software distributed under the License\n", " * is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express\n", " * or implied. See the License for the specific language governing permissions and limitations under\n", " * the License.\n", " * This package contains utilities to work with Java reflection. It is a part of the open-source\n"]}, "removed": {"1": [" * Licensed under the Apache License, Version 2.0 (the \"License\");\n", " * you may not use this file except in compliance with the License.\n", " * You may obtain a copy of the License at\n", " * Unless required by applicable law or agreed to in writing, software\n", " * distributed under the License is distributed on an \"AS IS\" BASIS,\n", " * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n", " * See the License for the specific language governing permissions and\n", " * limitations under the License.\n", " * This package contains utilities to work with Java reflection.\n", " * It is a part of the open-source\n"]}, "added_lines": {"1": [4, 5, 9, 10, 11, 12, 16]}, "removed_lines": {"1": [4, 5, 6, 10, 11, 12, 13, 14, 18, 19]}}]}
