{
    "addition": {
        "4": " * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not use this file except\n",
        "5": " * in compliance with the License. You may obtain a copy of the License at\n",
        "9": " * Unless required by applicable law or agreed to in writing, software distributed under the License\n",
        "10": " * is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express\n",
        "11": " * or implied. See the License for the specific language governing permissions and limitations under\n",
        "12": " * the License.\n",
        "74": "   * String.class}, then {@code new TypeResolver().where(formal, actual)} will\n",
        "75": "   * {@linkplain #resolveType resolve} {@code ParameterizedType List<T>} to {@code List<String>},\n",
        "76": "   * and resolve {@code Map<T, Something>} to {@code Map<String, Something>} etc. Similarly,\n",
        "77": "   * {@code formal} and {@code actual} can be {@code Map<K, V>} and {@code Map<String, Integer>}\n",
        "78": "   * respectively, or they can be {@code E[]} and {@code String[]} respectively, or even any\n",
        "79": "   * arbitrary combination thereof.\n",
        "82": "   *     always a bug if {@code formal} isn't a type variable and contains no type variable. Make\n",
        "83": "   *     sure you are passing the two parameters in the right order.\n",
        "85": "   *     other type variables, in which case these type variables will be further resolved if\n",
        "86": "   *     corresponding mappings exist in the current {@code TypeResolver} instance.\n",
        "105": "      @Override\n",
        "106": "      void visitTypeVariable(TypeVariable<?> typeVariable) {\n",
        "109": "\n",
        "110": "      @Override\n",
        "111": "      void visitWildcardType(WildcardType fromWildcardType) {\n",
        "123": "            \"Incompatible type: %s vs. %s\",\n",
        "124": "            fromWildcardType,\n",
        "125": "            to);\n",
        "133": "\n",
        "134": "      @Override\n",
        "135": "      void visitParameterizedType(ParameterizedType fromParameterizedType) {\n",
        "137": "          return; // Okay to say Foo<A> is <?>\n",
        "140": "        checkArgument(\n",
        "141": "            fromParameterizedType.getRawType().equals(toParameterizedType.getRawType()),\n",
        "142": "            \"Inconsistent raw type: %s vs. %s\",\n",
        "143": "            fromParameterizedType,\n",
        "144": "            to);\n",
        "147": "        checkArgument(\n",
        "148": "            fromArgs.length == toArgs.length,\n",
        "149": "            \"%s not compatible with %s\",\n",
        "150": "            fromParameterizedType,\n",
        "151": "            toParameterizedType);\n",
        "156": "\n",
        "157": "      @Override\n",
        "158": "      void visitGenericArrayType(GenericArrayType fromArrayType) {\n",
        "160": "          return; // Okay to say A[] is <?>\n",
        "166": "\n",
        "167": "      @Override\n",
        "168": "      void visitClass(Class<?> fromClass) {\n",
        "170": "          return; // Okay to say Foo is <?>\n",
        "181": "   * Resolves all type variables in {@code type} and all downstream types and returns a\n",
        "182": "   * corresponding type with type variables resolved.\n",
        "211": "    return new Types.WildcardTypeImpl(resolveTypes(lowerBounds), resolveTypes(upperBounds));\n",
        "266": "      TypeTable guarded =\n",
        "267": "          new TypeTable() {\n",
        "268": "            @Override\n",
        "269": "            public Type resolveInternal(TypeVariable<?> intermediateVar, TypeTable forDependent) {\n",
        "270": "              if (intermediateVar.getGenericDeclaration().equals(var.getGenericDeclaration())) {\n",
        "271": "                return intermediateVar;\n",
        "272": "              }\n",
        "273": "              return unguarded.resolveInternal(intermediateVar, forDependent);\n",
        "274": "            }\n",
        "275": "          };\n",
        "342": "     * Returns type mappings using type parameters and type arguments found in the generic\n",
        "343": "     * superclass and the super interfaces of {@code contextClass}.\n",
        "345": "    static ImmutableMap<TypeVariableKey, Type> getTypeMappings(Type contextType) {\n",
        "351": "    @Override\n",
        "352": "    void visitClass(Class<?> clazz) {\n",
        "357": "    @Override\n",
        "358": "    void visitParameterizedType(ParameterizedType parameterizedType) {\n",
        "370": "    @Override\n",
        "371": "    void visitTypeVariable(TypeVariable<?> t) {\n",
        "375": "    @Override\n",
        "376": "    void visitWildcardType(WildcardType t) {\n",
        "439": "          String name =\n",
        "440": "              \"capture#\"\n",
        "441": "                  + id.incrementAndGet()\n",
        "442": "                  + \"-of ? extends \"\n",
        "443": "                  + Joiner.on('&').join(upperBounds);\n",
        "475": "   * <p>While resolving a type variable from a {var -> type} map, we don't care whether the type\n",
        "476": "   * variable's bound has been partially resolved. As long as the type variable \"identity\" matches.\n",
        "478": "   * <p>On the other hand, if for example we are resolving List<A extends B> to List<A extends\n",
        "479": "   * String>, we need to compare that <A extends B> is unequal to <A extends String> in order to\n",
        "480": "   * decide to use the transformed type instead of the original type.\n",
        "489": "    @Override\n",
        "490": "    public int hashCode() {\n",
        "494": "    @Override\n",
        "495": "    public boolean equals(Object obj) {\n",
        "504": "    @Override\n",
        "505": "    public String toString() {\n",
        "519": "     * Returns true if {@code type} is a {@code TypeVariable} with the same name and declared by the\n",
        "520": "     * same {@code GenericDeclaration}.\n"
    },
    "removed": {
        "4": " * Licensed under the Apache License, Version 2.0 (the \"License\");\n",
        "5": " * you may not use this file except in compliance with the License.\n",
        "6": " * You may obtain a copy of the License at\n",
        "10": " * Unless required by applicable law or agreed to in writing, software\n",
        "11": " * distributed under the License is distributed on an \"AS IS\" BASIS,\n",
        "12": " * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n",
        "13": " * See the License for the specific language governing permissions and\n",
        "14": " * limitations under the License.\n",
        "76": "   * String.class}, then {@code new TypeResolver().where(formal, actual)} will {@linkplain\n",
        "77": "   * #resolveType resolve} {@code ParameterizedType List<T>} to {@code List<String>}, and resolve\n",
        "78": "   * {@code Map<T, Something>} to {@code Map<String, Something>} etc. Similarly, {@code formal} and\n",
        "79": "   * {@code actual} can be {@code Map<K, V>} and {@code Map<String, Integer>} respectively, or they\n",
        "80": "   * can be {@code E[]} and {@code String[]} respectively, or even any arbitrary combination\n",
        "81": "   * thereof.\n",
        "84": "   *        always a bug if {@code formal} isn't a type variable and contains no type variable. Make\n",
        "85": "   *        sure you are passing the two parameters in the right order.\n",
        "87": "   *        other type variables, in which case these type variables will be further resolved if\n",
        "88": "   *        corresponding mappings exist in the current {@code TypeResolver} instance.\n",
        "107": "      @Override void visitTypeVariable(TypeVariable<?> typeVariable) {\n",
        "110": "      @Override void visitWildcardType(WildcardType fromWildcardType) {\n",
        "122": "            \"Incompatible type: %s vs. %s\", fromWildcardType, to);\n",
        "130": "      @Override void visitParameterizedType(ParameterizedType fromParameterizedType) {\n",
        "132": "          return;  // Okay to say Foo<A> is <?>\n",
        "135": "        checkArgument(fromParameterizedType.getRawType().equals(toParameterizedType.getRawType()),\n",
        "136": "            \"Inconsistent raw type: %s vs. %s\", fromParameterizedType, to);\n",
        "139": "        checkArgument(fromArgs.length == toArgs.length,\n",
        "140": "            \"%s not compatible with %s\", fromParameterizedType, toParameterizedType);\n",
        "145": "      @Override void visitGenericArrayType(GenericArrayType fromArrayType) {\n",
        "147": "          return;  // Okay to say A[] is <?>\n",
        "153": "      @Override void visitClass(Class<?> fromClass) {\n",
        "155": "          return;  // Okay to say Foo is <?>\n",
        "166": "   * Resolves all type variables in {@code type} and all downstream types and\n",
        "167": "   * returns a corresponding type with type variables resolved.\n",
        "196": "    return new Types.WildcardTypeImpl(\n",
        "197": "        resolveTypes(lowerBounds), resolveTypes(upperBounds));\n",
        "252": "      TypeTable guarded = new TypeTable() {\n",
        "253": "        @Override public Type resolveInternal(\n",
        "254": "            TypeVariable<?> intermediateVar, TypeTable forDependent) {\n",
        "255": "          if (intermediateVar.getGenericDeclaration().equals(var.getGenericDeclaration())) {\n",
        "256": "            return intermediateVar;\n",
        "257": "          }\n",
        "258": "          return unguarded.resolveInternal(intermediateVar, forDependent);\n",
        "259": "        }\n",
        "260": "      };\n",
        "327": "     * Returns type mappings using type parameters and type arguments found in\n",
        "328": "     * the generic superclass and the super interfaces of {@code contextClass}.\n",
        "330": "    static ImmutableMap<TypeVariableKey, Type> getTypeMappings(\n",
        "331": "        Type contextType) {\n",
        "337": "    @Override void visitClass(Class<?> clazz) {\n",
        "342": "    @Override void visitParameterizedType(ParameterizedType parameterizedType) {\n",
        "354": "    @Override void visitTypeVariable(TypeVariable<?> t) {\n",
        "358": "    @Override void visitWildcardType(WildcardType t) {\n",
        "421": "          String name = \"capture#\" + id.incrementAndGet() + \"-of ? extends \"\n",
        "422": "              + Joiner.on('&').join(upperBounds);\n",
        "454": "   * <p>While resolving a type variable from a {var -> type} map, we don't care whether the\n",
        "455": "   * type variable's bound has been partially resolved. As long as the type variable \"identity\"\n",
        "456": "   * matches.\n",
        "458": "   * <p>On the other hand, if for example we are resolving List<A extends B> to\n",
        "459": "   * List<A extends String>, we need to compare that <A extends B> is unequal to\n",
        "460": "   * <A extends String> in order to decide to use the transformed type instead of the original\n",
        "461": "   * type.\n",
        "470": "    @Override public int hashCode() {\n",
        "474": "    @Override public boolean equals(Object obj) {\n",
        "483": "    @Override public String toString() {\n",
        "497": "     * Returns true if {@code type} is a {@code TypeVariable} with the same name and declared by\n",
        "498": "     * the same {@code GenericDeclaration}.\n"
    }
}