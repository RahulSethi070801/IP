{
    "addition": {
        "56": "          + (-56.78 - TWO_VALUES_MEAN) * (-56.78 - TWO_VALUES_MEAN);\n",
        "64": "          + (-56.78 - TWO_VALUES_MEAN) * (-789.012 - OTHER_TWO_VALUES_MEAN);\n",
        "147": "  static final double[] LARGE_VALUES = {Double.MAX_VALUE, Double.MAX_VALUE / 2.0};\n",
        "168": "          + (-22.0 - INTEGER_MANY_VALUES_MEAN) * (-22.0 - INTEGER_MANY_VALUES_MEAN)\n",
        "169": "          + (3333.0 - INTEGER_MANY_VALUES_MEAN) * (3333.0 - INTEGER_MANY_VALUES_MEAN)\n",
        "170": "          + (-4444.0 - INTEGER_MANY_VALUES_MEAN) * (-4444.0 - INTEGER_MANY_VALUES_MEAN)\n",
        "171": "          + (555555.0 - INTEGER_MANY_VALUES_MEAN) * (555555.0 - INTEGER_MANY_VALUES_MEAN);\n",
        "176": "  static final int[] LARGE_INTEGER_VALUES = {Integer.MAX_VALUE, Integer.MAX_VALUE / 2};\n",
        "177": "  static final double LARGE_INTEGER_VALUES_MEAN =\n",
        "178": "      BigInteger.valueOf(Integer.MAX_VALUE)\n",
        "179": "          .multiply(BigInteger.valueOf(3L))\n",
        "180": "          .divide(BigInteger.valueOf(4L))\n",
        "181": "          .doubleValue();\n",
        "183": "      BigInteger.valueOf(Integer.MAX_VALUE)\n",
        "184": "          .multiply(BigInteger.valueOf(Integer.MAX_VALUE))\n",
        "185": "          .divide(BigInteger.valueOf(16L))\n",
        "186": "          .doubleValue();\n",
        "195": "          + (-2222.0 - LONG_MANY_VALUES_MEAN) * (-2222.0 - LONG_MANY_VALUES_MEAN)\n",
        "196": "          + (33333333.0 - LONG_MANY_VALUES_MEAN) * (33333333.0 - LONG_MANY_VALUES_MEAN)\n",
        "197": "          + (-44444444.0 - LONG_MANY_VALUES_MEAN) * (-44444444.0 - LONG_MANY_VALUES_MEAN)\n",
        "198": "          + (5555555555.0 - LONG_MANY_VALUES_MEAN) * (5555555555.0 - LONG_MANY_VALUES_MEAN);\n",
        "203": "  static final long[] LARGE_LONG_VALUES = {Long.MAX_VALUE, Long.MAX_VALUE / 2};\n",
        "204": "  static final double LARGE_LONG_VALUES_MEAN =\n",
        "205": "      BigInteger.valueOf(Long.MAX_VALUE)\n",
        "206": "          .multiply(BigInteger.valueOf(3L))\n",
        "207": "          .divide(BigInteger.valueOf(4L))\n",
        "208": "          .doubleValue();\n",
        "210": "      BigInteger.valueOf(Long.MAX_VALUE)\n",
        "211": "          .multiply(BigInteger.valueOf(Long.MAX_VALUE))\n",
        "212": "          .divide(BigInteger.valueOf(16L))\n",
        "213": "          .doubleValue();\n",
        "250": "  static final List<Stats> ALL_STATS =\n",
        "251": "      ImmutableList.of(\n",
        "252": "          EMPTY_STATS_VARARGS,\n",
        "253": "          EMPTY_STATS_ITERABLE,\n",
        "254": "          ONE_VALUE_STATS,\n",
        "255": "          OTHER_ONE_VALUE_STATS,\n",
        "256": "          TWO_VALUES_STATS,\n",
        "257": "          OTHER_TWO_VALUES_STATS,\n",
        "258": "          MANY_VALUES_STATS_VARARGS,\n",
        "259": "          MANY_VALUES_STATS_ITERABLE,\n",
        "260": "          MANY_VALUES_STATS_ITERATOR,\n",
        "261": "          MANY_VALUES_STATS_SNAPSHOT,\n",
        "262": "          LARGE_VALUES_STATS,\n",
        "263": "          OTHER_MANY_VALUES_STATS,\n",
        "264": "          INTEGER_MANY_VALUES_STATS_VARARGS,\n",
        "265": "          INTEGER_MANY_VALUES_STATS_ITERABLE,\n",
        "266": "          LARGE_INTEGER_VALUES_STATS,\n",
        "267": "          LONG_MANY_VALUES_STATS_ITERATOR,\n",
        "268": "          LONG_MANY_VALUES_STATS_SNAPSHOT,\n",
        "269": "          LARGE_LONG_VALUES_STATS);\n",
        "317": "  static final List<PairedStats> ALL_PAIRED_STATS =\n",
        "318": "      ImmutableList.of(\n",
        "319": "          EMPTY_PAIRED_STATS,\n",
        "320": "          ONE_VALUE_PAIRED_STATS,\n",
        "321": "          TWO_VALUES_PAIRED_STATS,\n",
        "322": "          MANY_VALUES_PAIRED_STATS,\n",
        "323": "          DUPLICATE_MANY_VALUES_PAIRED_STATS,\n",
        "324": "          HORIZONTAL_VALUES_PAIRED_STATS,\n",
        "325": "          VERTICAL_VALUES_PAIRED_STATS,\n",
        "326": "          CONSTANT_VALUES_PAIRED_STATS);\n",
        "330": "  static void assertStatsApproxEqual(Stats expectedStats, Stats actualStats) {\n",
        "371": "   * assertions about all the public instance methods of {@link LinearTransformation} (on both\n",
        "372": "   * {@code transformation} and its inverse). Since the transformation is expected to be diagonal,\n",
        "373": "   * neither {@code xDelta} nor {@code yDelta} may be zero.\n",
        "381": "    assertThat(transformation.inverse().isHorizontal()).isFalse();\n",
        "382": "    assertThat(transformation.inverse().isVertical()).isFalse();\n",
        "383": "    assertThat(transformation.transform(x1)).isWithin(ALLOWED_ERROR).of(y1);\n",
        "384": "    assertThat(transformation.transform(x1 + xDelta)).isWithin(ALLOWED_ERROR).of(y1 + yDelta);\n",
        "385": "    assertThat(transformation.inverse().transform(y1)).isWithin(ALLOWED_ERROR).of(x1);\n",
        "386": "    assertThat(transformation.inverse().transform(y1 + yDelta))\n",
        "387": "        .isWithin(ALLOWED_ERROR)\n",
        "388": "        .of(x1 + xDelta);\n",
        "390": "    assertThat(transformation.inverse().slope()).isWithin(ALLOWED_ERROR).of(xDelta / yDelta);\n",
        "391": "    assertThat(transformation.inverse()).isSameAs(transformation.inverse());\n",
        "392": "    assertThat(transformation.inverse().inverse()).isSameAs(transformation);\n",
        "398": "   * assertion that {@link LinearTransformation#transform} and {@link LinearTransformation#slope}\n",
        "399": "   * on its inverse throws as expected.\n",
        "404": "    assertThat(transformation.inverse().isHorizontal()).isFalse();\n",
        "405": "    assertThat(transformation.inverse().isVertical()).isTrue();\n",
        "406": "    assertThat(transformation.transform(-1.0)).isWithin(ALLOWED_ERROR).of(y);\n",
        "407": "    assertThat(transformation.transform(1.0)).isWithin(ALLOWED_ERROR).of(y);\n",
        "409": "      transformation.inverse().transform(0.0);\n",
        "414": "    try {\n",
        "415": "      transformation.inverse().slope();\n",
        "416": "      fail(\"Expected IllegalStateException\");\n",
        "417": "    } catch (IllegalStateException expected) {\n",
        "418": "    }\n",
        "419": "    assertThat(transformation.inverse()).isSameAs(transformation.inverse());\n",
        "420": "    assertThat(transformation.inverse().inverse()).isSameAs(transformation);\n",
        "426": "   * assertions that {@link LinearTransformation#slope} and {@link LinearTransformation#transform}\n",
        "432": "    assertThat(transformation.inverse().isHorizontal()).isTrue();\n",
        "433": "    assertThat(transformation.inverse().isVertical()).isFalse();\n",
        "435": "      transformation.transform(0.0);\n",
        "439": "    assertThat(transformation.inverse().transform(-1.0)).isWithin(ALLOWED_ERROR).of(x);\n",
        "440": "    assertThat(transformation.inverse().transform(1.0)).isWithin(ALLOWED_ERROR).of(x);\n",
        "446": "    assertThat(transformation.inverse().slope()).isWithin(ALLOWED_ERROR).of(0.0);\n",
        "447": "    assertThat(transformation.inverse()).isSameAs(transformation.inverse());\n",
        "448": "    assertThat(transformation.inverse().inverse()).isSameAs(transformation);\n",
        "459": "    assertThat(transformation.transform(0.0)).isNaN();\n",
        "460": "    assertThat(transformation.inverse()).isSameAs(transformation);\n",
        "503": "  private StatsTesting() {}\n"
    },
    "removed": {
        "56": "      + (-56.78 - TWO_VALUES_MEAN) * (-56.78 - TWO_VALUES_MEAN);\n",
        "64": "      + (-56.78 - TWO_VALUES_MEAN) * (-789.012 - OTHER_TWO_VALUES_MEAN);\n",
        "147": "  static final double[] LARGE_VALUES = { Double.MAX_VALUE, Double.MAX_VALUE / 2.0 };\n",
        "168": "      + (-22.0 - INTEGER_MANY_VALUES_MEAN) * (-22.0 - INTEGER_MANY_VALUES_MEAN)\n",
        "169": "      + (3333.0 - INTEGER_MANY_VALUES_MEAN) * (3333.0 - INTEGER_MANY_VALUES_MEAN)\n",
        "170": "      + (-4444.0 - INTEGER_MANY_VALUES_MEAN) * (-4444.0 - INTEGER_MANY_VALUES_MEAN)\n",
        "171": "      + (555555.0 - INTEGER_MANY_VALUES_MEAN) * (555555.0 - INTEGER_MANY_VALUES_MEAN);\n",
        "176": "  static final int[] LARGE_INTEGER_VALUES = { Integer.MAX_VALUE, Integer.MAX_VALUE / 2 };\n",
        "177": "  static final double LARGE_INTEGER_VALUES_MEAN = BigInteger.valueOf(Integer.MAX_VALUE)\n",
        "178": "      .multiply(BigInteger.valueOf(3L)).divide(BigInteger.valueOf(4L)).doubleValue();\n",
        "180": "      BigInteger.valueOf(Integer.MAX_VALUE).multiply(BigInteger.valueOf(Integer.MAX_VALUE))\n",
        "181": "          .divide(BigInteger.valueOf(16L)).doubleValue();\n",
        "190": "      + (-2222.0 - LONG_MANY_VALUES_MEAN) * (-2222.0 - LONG_MANY_VALUES_MEAN)\n",
        "191": "      + (33333333.0 - LONG_MANY_VALUES_MEAN) * (33333333.0 - LONG_MANY_VALUES_MEAN)\n",
        "192": "      + (-44444444.0 - LONG_MANY_VALUES_MEAN) * (-44444444.0 - LONG_MANY_VALUES_MEAN)\n",
        "193": "      + (5555555555.0 - LONG_MANY_VALUES_MEAN) * (5555555555.0 - LONG_MANY_VALUES_MEAN);\n",
        "198": "  static final long[] LARGE_LONG_VALUES = { Long.MAX_VALUE, Long.MAX_VALUE / 2 };\n",
        "199": "  static final double LARGE_LONG_VALUES_MEAN = BigInteger.valueOf(Long.MAX_VALUE)\n",
        "200": "      .multiply(BigInteger.valueOf(3L)).divide(BigInteger.valueOf(4L)).doubleValue();\n",
        "202": "      BigInteger.valueOf(Long.MAX_VALUE).multiply(BigInteger.valueOf(Long.MAX_VALUE))\n",
        "203": "          .divide(BigInteger.valueOf(16L)).doubleValue();\n",
        "240": "  static final List<Stats> ALL_STATS = ImmutableList.of(\n",
        "241": "      EMPTY_STATS_VARARGS,\n",
        "242": "      EMPTY_STATS_ITERABLE,\n",
        "243": "      ONE_VALUE_STATS,\n",
        "244": "      OTHER_ONE_VALUE_STATS,\n",
        "245": "      TWO_VALUES_STATS,\n",
        "246": "      OTHER_TWO_VALUES_STATS,\n",
        "247": "      MANY_VALUES_STATS_VARARGS,\n",
        "248": "      MANY_VALUES_STATS_ITERABLE,\n",
        "249": "      MANY_VALUES_STATS_ITERATOR,\n",
        "250": "      MANY_VALUES_STATS_SNAPSHOT,\n",
        "251": "      LARGE_VALUES_STATS,\n",
        "252": "      OTHER_MANY_VALUES_STATS,\n",
        "253": "      INTEGER_MANY_VALUES_STATS_VARARGS,\n",
        "254": "      INTEGER_MANY_VALUES_STATS_ITERABLE,\n",
        "255": "      LARGE_INTEGER_VALUES_STATS,\n",
        "256": "      LONG_MANY_VALUES_STATS_ITERATOR,\n",
        "257": "      LONG_MANY_VALUES_STATS_SNAPSHOT,\n",
        "258": "      LARGE_LONG_VALUES_STATS);\n",
        "306": "  static final List<PairedStats> ALL_PAIRED_STATS = ImmutableList.of(\n",
        "307": "      EMPTY_PAIRED_STATS,\n",
        "308": "      ONE_VALUE_PAIRED_STATS,\n",
        "309": "      TWO_VALUES_PAIRED_STATS,\n",
        "310": "      MANY_VALUES_PAIRED_STATS,\n",
        "311": "      DUPLICATE_MANY_VALUES_PAIRED_STATS,\n",
        "312": "      HORIZONTAL_VALUES_PAIRED_STATS,\n",
        "313": "      VERTICAL_VALUES_PAIRED_STATS,\n",
        "314": "      CONSTANT_VALUES_PAIRED_STATS);\n",
        "318": "  static void assertStatsApproxEqual(\n",
        "319": "      Stats expectedStats, Stats actualStats) {\n",
        "360": "   * assertions about all the public instance methods of {@link LinearTransformation} (including\n",
        "361": "   * doing the transformation in both directions). Since the transformation is expected to be\n",
        "362": "   * diagonal, neither {@code xDelta} nor {@code yDelta} may be zero.\n",
        "370": "    assertThat(transformation.transformX(x1)).isWithin(ALLOWED_ERROR).of(y1);\n",
        "371": "    assertThat(transformation.transformX(x1 + xDelta)).isWithin(ALLOWED_ERROR).of(y1 + yDelta);\n",
        "372": "    assertThat(transformation.transformY(y1)).isWithin(ALLOWED_ERROR).of(x1);\n",
        "373": "    assertThat(transformation.transformY(y1 + yDelta)).isWithin(ALLOWED_ERROR).of(x1 + xDelta);\n",
        "380": "   * assertion that {@link LinearTransformation#transformY} throws as expected.\n",
        "385": "    assertThat(transformation.transformX(-1.0)).isWithin(ALLOWED_ERROR).of(y);\n",
        "386": "    assertThat(transformation.transformX(1.0)).isWithin(ALLOWED_ERROR).of(y);\n",
        "388": "      transformation.transformY(0.0);\n",
        "398": "   * assertions that {@link LinearTransformation#slope} and {@link LinearTransformation#transformY}\n",
        "405": "      transformation.transformX(0.0);\n",
        "409": "    assertThat(transformation.transformY(-1.0)).isWithin(ALLOWED_ERROR).of(x);\n",
        "410": "    assertThat(transformation.transformY(1.0)).isWithin(ALLOWED_ERROR).of(x);\n",
        "426": "    assertThat(transformation.transformX(0.0)).isNaN();\n",
        "427": "    assertThat(transformation.transformY(0.0)).isNaN();\n",
        "470": "  private StatsTesting() {\n",
        "471": "  }\n"
    }
}