{"id": "0657551ce26c5c1e2f43c3e191f05f238fdd2acf", "code": [{"0": "guava-tests/test/com/google/common/math/StatsTesting.java", "added": {"1": ["          + (-56.78 - TWO_VALUES_MEAN) * (-56.78 - TWO_VALUES_MEAN);\n"], "2": ["          + (-56.78 - TWO_VALUES_MEAN) * (-789.012 - OTHER_TWO_VALUES_MEAN);\n"], "3": ["  static final double[] LARGE_VALUES = {Double.MAX_VALUE, Double.MAX_VALUE / 2.0};\n"], "4": ["          + (-22.0 - INTEGER_MANY_VALUES_MEAN) * (-22.0 - INTEGER_MANY_VALUES_MEAN)\n", "          + (3333.0 - INTEGER_MANY_VALUES_MEAN) * (3333.0 - INTEGER_MANY_VALUES_MEAN)\n", "          + (-4444.0 - INTEGER_MANY_VALUES_MEAN) * (-4444.0 - INTEGER_MANY_VALUES_MEAN)\n", "          + (555555.0 - INTEGER_MANY_VALUES_MEAN) * (555555.0 - INTEGER_MANY_VALUES_MEAN);\n", "  static final int[] LARGE_INTEGER_VALUES = {Integer.MAX_VALUE, Integer.MAX_VALUE / 2};\n", "  static final double LARGE_INTEGER_VALUES_MEAN =\n", "      BigInteger.valueOf(Integer.MAX_VALUE)\n", "          .multiply(BigInteger.valueOf(3L))\n", "          .divide(BigInteger.valueOf(4L))\n", "          .doubleValue();\n", "      BigInteger.valueOf(Integer.MAX_VALUE)\n", "          .multiply(BigInteger.valueOf(Integer.MAX_VALUE))\n", "          .divide(BigInteger.valueOf(16L))\n", "          .doubleValue();\n"], "5": ["          + (-2222.0 - LONG_MANY_VALUES_MEAN) * (-2222.0 - LONG_MANY_VALUES_MEAN)\n", "          + (33333333.0 - LONG_MANY_VALUES_MEAN) * (33333333.0 - LONG_MANY_VALUES_MEAN)\n", "          + (-44444444.0 - LONG_MANY_VALUES_MEAN) * (-44444444.0 - LONG_MANY_VALUES_MEAN)\n", "          + (5555555555.0 - LONG_MANY_VALUES_MEAN) * (5555555555.0 - LONG_MANY_VALUES_MEAN);\n", "  static final long[] LARGE_LONG_VALUES = {Long.MAX_VALUE, Long.MAX_VALUE / 2};\n", "  static final double LARGE_LONG_VALUES_MEAN =\n", "      BigInteger.valueOf(Long.MAX_VALUE)\n", "          .multiply(BigInteger.valueOf(3L))\n", "          .divide(BigInteger.valueOf(4L))\n", "          .doubleValue();\n", "      BigInteger.valueOf(Long.MAX_VALUE)\n", "          .multiply(BigInteger.valueOf(Long.MAX_VALUE))\n", "          .divide(BigInteger.valueOf(16L))\n", "          .doubleValue();\n"], "6": ["  static final List<Stats> ALL_STATS =\n", "      ImmutableList.of(\n", "          EMPTY_STATS_VARARGS,\n", "          EMPTY_STATS_ITERABLE,\n", "          ONE_VALUE_STATS,\n", "          OTHER_ONE_VALUE_STATS,\n", "          TWO_VALUES_STATS,\n", "          OTHER_TWO_VALUES_STATS,\n", "          MANY_VALUES_STATS_VARARGS,\n", "          MANY_VALUES_STATS_ITERABLE,\n", "          MANY_VALUES_STATS_ITERATOR,\n", "          MANY_VALUES_STATS_SNAPSHOT,\n", "          LARGE_VALUES_STATS,\n", "          OTHER_MANY_VALUES_STATS,\n", "          INTEGER_MANY_VALUES_STATS_VARARGS,\n", "          INTEGER_MANY_VALUES_STATS_ITERABLE,\n", "          LARGE_INTEGER_VALUES_STATS,\n", "          LONG_MANY_VALUES_STATS_ITERATOR,\n", "          LONG_MANY_VALUES_STATS_SNAPSHOT,\n", "          LARGE_LONG_VALUES_STATS);\n"], "7": ["  static final List<PairedStats> ALL_PAIRED_STATS =\n", "      ImmutableList.of(\n", "          EMPTY_PAIRED_STATS,\n", "          ONE_VALUE_PAIRED_STATS,\n", "          TWO_VALUES_PAIRED_STATS,\n", "          MANY_VALUES_PAIRED_STATS,\n", "          DUPLICATE_MANY_VALUES_PAIRED_STATS,\n", "          HORIZONTAL_VALUES_PAIRED_STATS,\n", "          VERTICAL_VALUES_PAIRED_STATS,\n", "          CONSTANT_VALUES_PAIRED_STATS);\n", "  static void assertStatsApproxEqual(Stats expectedStats, Stats actualStats) {\n"], "8": ["   * assertions about all the public instance methods of {@link LinearTransformation} (on both\n", "   * {@code transformation} and its inverse). Since the transformation is expected to be diagonal,\n", "   * neither {@code xDelta} nor {@code yDelta} may be zero.\n"], "9": ["    assertThat(transformation.inverse().isHorizontal()).isFalse();\n", "    assertThat(transformation.inverse().isVertical()).isFalse();\n", "    assertThat(transformation.transform(x1)).isWithin(ALLOWED_ERROR).of(y1);\n", "    assertThat(transformation.transform(x1 + xDelta)).isWithin(ALLOWED_ERROR).of(y1 + yDelta);\n", "    assertThat(transformation.inverse().transform(y1)).isWithin(ALLOWED_ERROR).of(x1);\n", "    assertThat(transformation.inverse().transform(y1 + yDelta))\n", "        .isWithin(ALLOWED_ERROR)\n", "        .of(x1 + xDelta);\n", "    assertThat(transformation.inverse().slope()).isWithin(ALLOWED_ERROR).of(xDelta / yDelta);\n", "    assertThat(transformation.inverse()).isSameAs(transformation.inverse());\n", "    assertThat(transformation.inverse().inverse()).isSameAs(transformation);\n", "   * assertion that {@link LinearTransformation#transform} and {@link LinearTransformation#slope}\n", "   * on its inverse throws as expected.\n", "    assertThat(transformation.inverse().isHorizontal()).isFalse();\n", "    assertThat(transformation.inverse().isVertical()).isTrue();\n", "    assertThat(transformation.transform(-1.0)).isWithin(ALLOWED_ERROR).of(y);\n", "    assertThat(transformation.transform(1.0)).isWithin(ALLOWED_ERROR).of(y);\n", "      transformation.inverse().transform(0.0);\n", "    try {\n", "      transformation.inverse().slope();\n", "      fail(\"Expected IllegalStateException\");\n", "    } catch (IllegalStateException expected) {\n", "    }\n", "    assertThat(transformation.inverse()).isSameAs(transformation.inverse());\n", "    assertThat(transformation.inverse().inverse()).isSameAs(transformation);\n", "   * assertions that {@link LinearTransformation#slope} and {@link LinearTransformation#transform}\n", "    assertThat(transformation.inverse().isHorizontal()).isTrue();\n", "    assertThat(transformation.inverse().isVertical()).isFalse();\n", "      transformation.transform(0.0);\n", "    assertThat(transformation.inverse().transform(-1.0)).isWithin(ALLOWED_ERROR).of(x);\n", "    assertThat(transformation.inverse().transform(1.0)).isWithin(ALLOWED_ERROR).of(x);\n", "    assertThat(transformation.inverse().slope()).isWithin(ALLOWED_ERROR).of(0.0);\n", "    assertThat(transformation.inverse()).isSameAs(transformation.inverse());\n", "    assertThat(transformation.inverse().inverse()).isSameAs(transformation);\n"], "10": ["    assertThat(transformation.transform(0.0)).isNaN();\n", "    assertThat(transformation.inverse()).isSameAs(transformation);\n"], "11": ["  private StatsTesting() {}\n"]}, "removed": {"1": ["      + (-56.78 - TWO_VALUES_MEAN) * (-56.78 - TWO_VALUES_MEAN);\n"], "2": ["      + (-56.78 - TWO_VALUES_MEAN) * (-789.012 - OTHER_TWO_VALUES_MEAN);\n"], "3": ["  static final double[] LARGE_VALUES = { Double.MAX_VALUE, Double.MAX_VALUE / 2.0 };\n"], "4": ["      + (-22.0 - INTEGER_MANY_VALUES_MEAN) * (-22.0 - INTEGER_MANY_VALUES_MEAN)\n", "      + (3333.0 - INTEGER_MANY_VALUES_MEAN) * (3333.0 - INTEGER_MANY_VALUES_MEAN)\n", "      + (-4444.0 - INTEGER_MANY_VALUES_MEAN) * (-4444.0 - INTEGER_MANY_VALUES_MEAN)\n", "      + (555555.0 - INTEGER_MANY_VALUES_MEAN) * (555555.0 - INTEGER_MANY_VALUES_MEAN);\n", "  static final int[] LARGE_INTEGER_VALUES = { Integer.MAX_VALUE, Integer.MAX_VALUE / 2 };\n", "  static final double LARGE_INTEGER_VALUES_MEAN = BigInteger.valueOf(Integer.MAX_VALUE)\n", "      .multiply(BigInteger.valueOf(3L)).divide(BigInteger.valueOf(4L)).doubleValue();\n", "      BigInteger.valueOf(Integer.MAX_VALUE).multiply(BigInteger.valueOf(Integer.MAX_VALUE))\n", "          .divide(BigInteger.valueOf(16L)).doubleValue();\n"], "5": ["      + (-2222.0 - LONG_MANY_VALUES_MEAN) * (-2222.0 - LONG_MANY_VALUES_MEAN)\n", "      + (33333333.0 - LONG_MANY_VALUES_MEAN) * (33333333.0 - LONG_MANY_VALUES_MEAN)\n", "      + (-44444444.0 - LONG_MANY_VALUES_MEAN) * (-44444444.0 - LONG_MANY_VALUES_MEAN)\n", "      + (5555555555.0 - LONG_MANY_VALUES_MEAN) * (5555555555.0 - LONG_MANY_VALUES_MEAN);\n", "  static final long[] LARGE_LONG_VALUES = { Long.MAX_VALUE, Long.MAX_VALUE / 2 };\n", "  static final double LARGE_LONG_VALUES_MEAN = BigInteger.valueOf(Long.MAX_VALUE)\n", "      .multiply(BigInteger.valueOf(3L)).divide(BigInteger.valueOf(4L)).doubleValue();\n", "      BigInteger.valueOf(Long.MAX_VALUE).multiply(BigInteger.valueOf(Long.MAX_VALUE))\n", "          .divide(BigInteger.valueOf(16L)).doubleValue();\n"], "6": ["  static final List<Stats> ALL_STATS = ImmutableList.of(\n", "      EMPTY_STATS_VARARGS,\n", "      EMPTY_STATS_ITERABLE,\n", "      ONE_VALUE_STATS,\n", "      OTHER_ONE_VALUE_STATS,\n", "      TWO_VALUES_STATS,\n", "      OTHER_TWO_VALUES_STATS,\n", "      MANY_VALUES_STATS_VARARGS,\n", "      MANY_VALUES_STATS_ITERABLE,\n", "      MANY_VALUES_STATS_ITERATOR,\n", "      MANY_VALUES_STATS_SNAPSHOT,\n", "      LARGE_VALUES_STATS,\n", "      OTHER_MANY_VALUES_STATS,\n", "      INTEGER_MANY_VALUES_STATS_VARARGS,\n", "      INTEGER_MANY_VALUES_STATS_ITERABLE,\n", "      LARGE_INTEGER_VALUES_STATS,\n", "      LONG_MANY_VALUES_STATS_ITERATOR,\n", "      LONG_MANY_VALUES_STATS_SNAPSHOT,\n", "      LARGE_LONG_VALUES_STATS);\n"], "7": ["  static final List<PairedStats> ALL_PAIRED_STATS = ImmutableList.of(\n", "      EMPTY_PAIRED_STATS,\n", "      ONE_VALUE_PAIRED_STATS,\n", "      TWO_VALUES_PAIRED_STATS,\n", "      MANY_VALUES_PAIRED_STATS,\n", "      DUPLICATE_MANY_VALUES_PAIRED_STATS,\n", "      HORIZONTAL_VALUES_PAIRED_STATS,\n", "      VERTICAL_VALUES_PAIRED_STATS,\n", "      CONSTANT_VALUES_PAIRED_STATS);\n", "  static void assertStatsApproxEqual(\n", "      Stats expectedStats, Stats actualStats) {\n"], "8": ["   * assertions about all the public instance methods of {@link LinearTransformation} (including\n", "   * doing the transformation in both directions). Since the transformation is expected to be\n", "   * diagonal, neither {@code xDelta} nor {@code yDelta} may be zero.\n"], "9": ["    assertThat(transformation.transformX(x1)).isWithin(ALLOWED_ERROR).of(y1);\n", "    assertThat(transformation.transformX(x1 + xDelta)).isWithin(ALLOWED_ERROR).of(y1 + yDelta);\n", "    assertThat(transformation.transformY(y1)).isWithin(ALLOWED_ERROR).of(x1);\n", "    assertThat(transformation.transformY(y1 + yDelta)).isWithin(ALLOWED_ERROR).of(x1 + xDelta);\n", "   * assertion that {@link LinearTransformation#transformY} throws as expected.\n", "    assertThat(transformation.transformX(-1.0)).isWithin(ALLOWED_ERROR).of(y);\n", "    assertThat(transformation.transformX(1.0)).isWithin(ALLOWED_ERROR).of(y);\n", "      transformation.transformY(0.0);\n", "   * assertions that {@link LinearTransformation#slope} and {@link LinearTransformation#transformY}\n", "      transformation.transformX(0.0);\n", "    assertThat(transformation.transformY(-1.0)).isWithin(ALLOWED_ERROR).of(x);\n", "    assertThat(transformation.transformY(1.0)).isWithin(ALLOWED_ERROR).of(x);\n"], "10": ["    assertThat(transformation.transformX(0.0)).isNaN();\n", "    assertThat(transformation.transformY(0.0)).isNaN();\n"], "11": ["  private StatsTesting() {\n", "  }\n"]}, "added_lines": {"1": [56], "2": [64], "3": [147], "4": [168, 169, 170, 171, 176, 177, 178, 179, 180, 181, 183, 184, 185, 186], "5": [195, 196, 197, 198, 203, 204, 205, 206, 207, 208, 210, 211, 212, 213], "6": [250, 251, 252, 253, 254, 255, 256, 257, 258, 259, 260, 261, 262, 263, 264, 265, 266, 267, 268, 269], "7": [317, 318, 319, 320, 321, 322, 323, 324, 325, 326, 330], "8": [371, 372, 373], "9": [381, 382, 383, 384, 385, 386, 387, 388, 390, 391, 392, 398, 399, 404, 405, 406, 407, 409, 414, 415, 416, 417, 418, 419, 420, 426, 432, 433, 435, 439, 440, 446, 447, 448], "10": [459, 460], "11": [503]}, "removed_lines": {"1": [56], "2": [64], "3": [147], "4": [168, 169, 170, 171, 176, 177, 178, 180, 181], "5": [190, 191, 192, 193, 198, 199, 200, 202, 203], "6": [240, 241, 242, 243, 244, 245, 246, 247, 248, 249, 250, 251, 252, 253, 254, 255, 256, 257, 258], "7": [306, 307, 308, 309, 310, 311, 312, 313, 314, 318, 319], "8": [360, 361, 362], "9": [370, 371, 372, 373, 380, 385, 386, 388, 398, 405, 409, 410], "10": [426, 427], "11": [470, 471]}}, {"1": "guava/src/com/google/common/math/LinearTransformation.java", "added": {"2": ["   * (The inverse of this will be a horizontal transformation.)\n"], "3": ["   * (The inverse of this will be a vertical transformation.)\n"], "4": ["   * and {@link #isVertical} methods return {@code false} and the {@link #slope}, and\n", "   * {@link #transform} methods all return {@link Double#NaN}. The {@link #inverse} method returns\n", "   * the same instance.\n"], "5": ["  public abstract double transform(double x);\n", "   * Returns the inverse linear transformation. The inverse of a horizontal transformation is a\n", "   * vertical transformation, and vice versa. The inverse of the {@link #forNaN} transformation is\n", "   * itself. In all other cases, the inverse is a transformation such that applying both the\n", "   * original transformation and its inverse to a value gives you the original value give-or-take\n", "   * numerical errors. Calling this method multiple times on the same instance will always return\n", "   * the same instance. Calling this method on the result of calling this method on an instance will\n", "   * always return that original instance.\n", "  public abstract LinearTransformation inverse();\n", "    LinearTransformation inverse;\n", "\n", "      this.inverse = null; // to be lazily initialized\n", "    }\n", "\n", "    RegularLinearTransformation(double slope, double yIntercept, LinearTransformation inverse) {\n", "      this.slope = slope;\n", "      this.yIntercept = yIntercept;\n", "      this.inverse = inverse;\n"], "6": ["    public double transform(double x) {\n", "    public LinearTransformation inverse() {\n", "      LinearTransformation result = inverse;\n", "      return (result == null) ? inverse = createInverse() : result;\n", "\n", "    private LinearTransformation createInverse() {\n", "      if (slope != 0.0) {\n", "        return new RegularLinearTransformation(1.0 / slope, -1.0 * yIntercept / slope, this);\n", "      } else {\n", "        return new VerticalLinearTransformation(yIntercept, this);\n", "      }\n", "    }\n", "    LinearTransformation inverse;\n", "\n", "      this.inverse = null; // to be lazily initialized\n", "    }\n", "\n", "    VerticalLinearTransformation(double x, LinearTransformation inverse) {\n", "      this.x = x;\n", "      this.inverse = inverse;\n"], "7": ["    public double transform(double x) {\n", "    public LinearTransformation inverse() {\n", "      LinearTransformation result = inverse;\n", "      return (result == null) ? inverse = createInverse() : result;\n", "\n", "    private LinearTransformation createInverse() {\n", "      return new RegularLinearTransformation(0.0, x, this);\n", "    }\n"], "8": ["    public double transform(double x) {\n", "    public LinearTransformation inverse() {\n", "      return this;\n"]}, "removed": {"1": ["import static com.google.common.base.Preconditions.checkState;\n"], "4": ["   * and {@link #isVertical} methods return {@code false} and the {@link #slope},\n", "   * {@link #transformX}, and {@link #transformY} methods all return {@link Double#NaN}.\n"], "5": ["  public abstract double transformX(double x);\n", "   * Returns the {@code x} corresponding to the given {@code y}. This must not be called on a\n", "   * horizontal transformation (i.e. when {@link #isHorizontal()} is true).\n", "  public abstract double transformY(double y);\n"], "6": ["    public double transformX(double x) {\n", "    public double transformY(double y) {\n", "      checkState(slope != 0.0);\n", "      return (y - yIntercept) / slope;\n"], "7": ["    public double transformX(double x) {\n", "    public double transformY(double y) {\n", "      return x;\n"], "8": ["    public double transformX(double x) {\n", "    public double transformY(double y) {\n", "      return NaN;\n"]}, "added_lines": {"2": [100], "3": [109], "4": [119, 120, 121], "5": [148, 151, 152, 153, 154, 155, 156, 157, 159, 166, 167, 171, 172, 173, 174, 175, 176, 177], "6": [196, 201, 202, 203, 210, 211, 212, 213, 214, 215, 216, 217, 224, 225, 228, 229, 230, 231, 232, 233], "7": [252, 257, 258, 259, 266, 267, 268, 269], "8": [292, 297, 298]}, "removed_lines": {"1": [18], "4": [118, 119], "5": [146, 149, 150, 152], "6": [180, 185, 186, 187], "7": [220, 225, 226], "8": [255, 260, 261]}}]}
