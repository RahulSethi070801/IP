{"id": "f1f4c88f47c7c2a260a0d9410392e233eaada068", "code": [{"0": "guava-tests/test/com/google/common/graph/AbstractDirectedNetworkTest.java", "added": {"1": ["        assertThat(endpoints.source()).isEqualTo(endpoints.otherNode(node));\n", "        assertThat(endpoints.target()).isEqualTo(endpoints.otherNode(node));\n"]}, "removed": {"1": ["        Integer oppositeNode = Graphs.oppositeNode(graph, inEdge, node);\n", "        assertThat(endpoints.source()).isEqualTo(oppositeNode);\n", "        Integer oppositeNode = Graphs.oppositeNode(graph, outEdge, node);\n", "        assertThat(endpoints.target()).isEqualTo(oppositeNode);\n"]}, "added_lines": {"1": [48, 55]}, "removed_lines": {"1": [47, 49, 54, 57]}}, {"1": "guava-tests/test/com/google/common/graph/AbstractNetworkTest.java", "added": {"1": ["        assertThat(graph.outEdges(graph.incidentNodes(inEdge).otherNode(node))).contains(inEdge);\n", "        assertThat(graph.inEdges(graph.incidentNodes(outEdge).otherNode(node))).contains(outEdge);\n"]}, "removed": {"1": ["        assertThat(graph.outEdges(Graphs.oppositeNode(graph, inEdge, node))).contains(inEdge);\n", "        assertThat(graph.inEdges(Graphs.oppositeNode(graph, outEdge, node))).contains(outEdge);\n"]}, "added_lines": {"1": [203, 208]}, "removed_lines": {"1": [203, 208]}}, {"2": "guava-tests/test/com/google/common/graph/EndpointsTest.java", "added": {"1": ["import static org.junit.Assert.fail;\n", "import com.google.common.collect.ImmutableList;\n", "import java.util.List;\n", "\n"], "2": ["    assertThat(directed.otherNode(\"source\")).isEqualTo(\"target\");\n", "    assertThat(directed.otherNode(\"target\")).isEqualTo(\"source\");\n"], "3": ["    assertThat(undirected.otherNode(\"chicken\")).isEqualTo(\"egg\");\n", "    assertThat(undirected.otherNode(\"egg\")).isEqualTo(\"chicken\");\n"], "4": ["    assertThat(undirected.otherNode(\"node\")).isEqualTo(\"node\");\n", "  @Test\n", "  public void testOtherNode_nodeNotIncident() {\n", "    List<MutableNetwork<Integer, String>> testGraphs = ImmutableList.of(\n", "        NetworkBuilder.directed().<Integer, String>build(),\n", "        NetworkBuilder.undirected().<Integer, String>build());\n", "    for (MutableNetwork<Integer, String> graph : testGraphs) {\n", "      graph.addEdge(\"1-2\", 1, 2);\n", "      Endpoints<Integer> endpoints = graph.incidentNodes(\"1-2\");\n", "      try {\n", "        endpoints.otherNode(3);\n", "        fail(\"Should have rejected otherNode() called with a node not incident to edge.\");\n", "      } catch (IllegalArgumentException expected) {\n", "      }\n", "    }\n", "  }\n", "\n"]}, "removed": {}, "added_lines": {"1": [20, 22, 29, 30], "2": [42, 43], "3": [51, 52], "4": [61, 66, 67, 68, 69, 70, 71, 72, 73, 74, 75, 76, 77, 78, 79, 80, 81]}, "removed_lines": {}}, {"3": "guava-tests/test/com/google/common/graph/GraphsTest.java", "added": {}, "removed": {"1": ["import static com.google.common.graph.Graphs.oppositeNode;\n", "import com.google.common.collect.ImmutableList;\n", "import java.util.List;\n"], "2": ["  @Test\n", "  public void oppositeNode_basic() {\n", "    List<MutableNetwork<Integer, String>> testNetworks = ImmutableList.of(\n", "        NetworkBuilder.directed().<Integer, String>build(),\n", "        NetworkBuilder.undirected().<Integer, String>build());\n", "    for (MutableNetwork<Integer, String> graph : testNetworks) {\n", "      graph.addEdge(E12, N1, N2);\n", "      assertThat(oppositeNode(graph, E12, N1)).isEqualTo(N2);\n", "      assertThat(oppositeNode(graph, E12, N2)).isEqualTo(N1);\n", "    }\n", "  }\n", "\n", "  @Test\n", "  public void oppositeNode_parallelEdge() {\n", "    List<MutableNetwork<Integer, String>> testNetworks = ImmutableList.of(\n", "        NetworkBuilder.directed().allowsParallelEdges(true).<Integer, String>build(),\n", "        NetworkBuilder.undirected().allowsParallelEdges(true).<Integer, String>build());\n", "    for (MutableNetwork<Integer, String> graph : testNetworks) {\n", "      graph.addEdge(E12, N1, N2);\n", "      graph.addEdge(E12_A, N1, N2);\n", "      assertThat(oppositeNode(graph, E12, N1)).isEqualTo(N2);\n", "      assertThat(oppositeNode(graph, E12, N2)).isEqualTo(N1);\n", "      assertThat(oppositeNode(graph, E12_A, N1)).isEqualTo(N2);\n", "      assertThat(oppositeNode(graph, E12_A, N2)).isEqualTo(N1);\n", "    }\n", "  }\n", "\n", "  @Test\n", "  public void oppositeNode_selfLoop() {\n", "    List<MutableNetwork<Integer, String>> testNetworks = ImmutableList.of(\n", "        NetworkBuilder.directed().<Integer, String>build(),\n", "        NetworkBuilder.undirected().<Integer, String>build());\n", "    for (MutableNetwork<Integer, String> graph : testNetworks) {\n", "      graph.addEdge(E11, N1, N1);\n", "      assertThat(oppositeNode(graph, E11, N1)).isEqualTo(N1);\n", "    }\n", "  }\n", "\n", "  @Test\n", "  public void oppositeNode_nodeNotIncident() {\n", "    List<MutableNetwork<Integer, String>> testNetworks = ImmutableList.of(\n", "        NetworkBuilder.directed().<Integer, String>build(),\n", "        NetworkBuilder.undirected().<Integer, String>build());\n", "    for (MutableNetwork<Integer, String> graph : testNetworks) {\n", "      graph.addEdge(E12, N1, N2);\n", "      graph.addEdge(E13, N1, N3);\n", "      try {\n", "        oppositeNode(graph, E12, N3);\n", "        fail(\"Should have rejected oppositeNode() called without a node incident to edge\");\n", "      } catch (IllegalArgumentException expected) {\n", "      }\n", "    }\n", "  }\n", "\n"]}, "added_lines": {}, "removed_lines": {"1": [23, 29, 36], "2": [135, 136, 137, 138, 139, 140, 141, 142, 143, 144, 145, 146, 147, 148, 149, 150, 151, 152, 153, 154, 155, 156, 157, 158, 159, 160, 161, 162, 163, 164, 165, 166, 167, 168, 169, 170, 171, 172, 173, 174, 175, 176, 177, 178, 179, 180, 181, 182, 183, 184, 185, 186, 187, 188]}}, {"4": "guava/src/com/google/common/graph/Endpoints.java", "added": {"1": [" * An immutable {@link Collection} to represent the two (possibly equal, in the case of a self-loop)\n", " * endpoints of an edge in a graph.\n"], "2": ["   * If this {@link Endpoints} is directed, returns the node which is the source of the origin edge.\n", "   * If this {@link Endpoints} is directed, returns the node which is the target of the origin edge.\n", "   * If this {@link Endpoints} is directed, returns the {@link #source()};\n", "   * otherwise, returns an arbitrary (but consistent) endpoint of the origin edge.\n", "   * Returns the node that is adjacent to {@link #nodeA()} via the origin edge.\n", "   * If this {@link Endpoints} is directed, this is equal to the {@link #target()}.\n", "  /**\n", "   * Returns the node that is adjacent to {@code node} via the origin edge.\n", "   *\n", "   * @throws IllegalArgumentException if the origin edge is not incident to {@code node}\n", "   */\n", "  public final N otherNode(Object node) {\n", "    checkNotNull(node, \"node\");\n", "    if (node.equals(nodeA())) {\n", "      return nodeB();\n", "    } else if (node.equals(nodeB())) {\n", "      return nodeA();\n", "    } else {\n", "      throw new IllegalArgumentException(\n", "          String.format(\"Endpoints %s does not contain node %s\", this, node));\n", "    }\n", "  }\n", "\n", "  public final UnmodifiableIterator<N> iterator() {\n"], "3": ["  public final int size() {\n", "  public final boolean contains(Object obj) {\n"]}, "removed": {"1": [" * An immutable {@link Collection} to represent the endpoints of an edge in a graph.\n"], "2": ["   * If this {@link Endpoints} is directed, returns the node which is the source.\n", "   * If this {@link Endpoints} is directed, returns the node which is the target.\n", "   * If this {@link Endpoints} is directed, returns the node which is the source.\n", "   * Otherwise, returns an arbitrary (but consistent) endpoint of the edge.\n", "   * Returns the node that is opposite {@link #nodeA()}. In the directed case, this is the target.\n", "  public UnmodifiableIterator<N> iterator() {\n"], "3": ["  public int size() {\n", "  public boolean contains(Object obj) {\n"]}, "added_lines": {"1": [31, 32], "2": [75, 82, 89, 90, 97, 98, 104, 105, 106, 107, 108, 109, 110, 111, 112, 113, 114, 115, 116, 117, 118, 119, 120, 122], "3": [147, 152]}, "removed_lines": {"1": [31], "2": [74, 81, 88, 89, 96, 103], "3": [128, 133]}}, {"5": "guava/src/com/google/common/graph/GraphConstants.java", "added": {"1": ["      \"Cannot call source()/target() on undirected endpoints. Consider calling otherNode() to get \"\n", "          + \"a single node or using the endpoints' iterator to get both nodes.\";\n"]}, "removed": {"1": ["      \"Cannot call source()/target() on undirected endpoints.\";\n"]}, "added_lines": {"1": [53, 54]}, "removed_lines": {"1": [53]}}, {"6": "guava/src/com/google/common/graph/Graphs.java", "added": {"1": ["  // Graph query methods\n"], "3": ["        N otherNode = graph.incidentNodes(edge).otherNode(node);\n", "        if (subgraph.nodes().contains(otherNode)) {\n", "          subgraph.addEdge(edge, node, otherNode);\n"]}, "removed": {"1": ["  // Graph properties (methods that act solely on a Graph/Network)\n"], "2": ["  // Node-based properties\n", "\n", "  /**\n", "   * Returns the node at the other end of {@code edge} from {@code node}.\n", "   *\n", "   * @throws IllegalArgumentException if {@code edge} is not incident to {@code node}\n", "   */\n", "  public static <N> N oppositeNode(Network<N, ?> graph, Object edge, Object node) {\n", "    checkNotNull(node, \"node\");\n", "    Endpoints<N> endpoints = graph.incidentNodes(edge);\n", "    if (node.equals(endpoints.nodeA())) {\n", "      return endpoints.nodeB();\n", "    } else {\n", "      checkArgument(node.equals(endpoints.nodeB()),\n", "          \"Edge %s is not incident to node %s\", edge, node);\n", "      return endpoints.nodeA();\n", "    }\n", "  }\n", "\n", "  // Edge-based properties\n", "\n"], "3": ["        N oppositeNode = Graphs.oppositeNode(graph, edge, node);\n", "        if (subgraph.nodes().contains(oppositeNode)) {\n", "          subgraph.addEdge(edge, node, oppositeNode);\n"]}, "added_lines": {"1": [57], "3": [124, 125, 126]}, "removed_lines": {"1": [57], "2": [73, 74, 75, 76, 77, 78, 79, 80, 81, 82, 83, 84, 85, 86, 87, 88, 89, 90, 91, 92, 93], "3": [145, 146, 147]}}, {"7": "guava/src/com/google/common/graph/ImmutableNetwork.java", "added": {"1": ["      Map<E, N> incidentEdgeMap = Maps.asMap(graph.incidentEdges(node), otherNodeFn(graph, node));\n"], "2": ["  private static <N, E> Function<E, N> otherNodeFn(final Network<N, E> graph, final N node) {\n", "        return graph.incidentNodes(edge).otherNode(node);\n"]}, "removed": {"1": ["      Map<E, N> incidentEdgeMap =\n", "          Maps.asMap(graph.incidentEdges(node), oppositeNodeFn(graph, node));\n"], "2": ["  private static <N, E> Function<E, N> oppositeNodeFn(final Network<N, E> graph, final N node) {\n", "        return Graphs.oppositeNode(graph, edge, node);\n"]}, "added_lines": {"1": [108], "2": [133, 137]}, "removed_lines": {"1": [108, 109], "2": [134, 138]}}]}
