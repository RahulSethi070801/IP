{"id": "20078868d0e6b7739cc806319dcfe1534f82d74d", "code": [{"0": "guava-tests/test/com/google/common/graph/GraphEqualsTest.java", "added": {"1": ["  private static final String E11 = \"1-1\";\n"], "2": ["  // Node/edge sets are the same, but node/edge connections differ due to graph type.\n", "  public void equals_directedVsUndirected() {\n"], "3": ["  // Node/edge sets and node/edge connections are the same, but types differ.\n", "  // (In this case the graphs are considered equal; the type differences are irrelevant.)\n", "  @Test\n", "  public void equals_selfLoop_directedVsUndirected() {\n", "    graph.addEdge(E11, N1, N1);\n", "\n", "    Graph<Integer, String> g2;\n", "    switch (graphType) {\n", "      case UNDIRECTED:\n", "        g2 = Graphs.createDirected();\n", "        break;\n", "      case DIRECTED:\n", "        g2 = Graphs.createUndirected();\n", "        break;\n", "      default:\n", "        throw new IllegalStateException(\"Unexpected graph type: \" + graphType);\n", "    }\n", "\n", "    g2.addEdge(E11, N1, N1);\n", "\n", "    new EqualsTester().addEqualityGroup(graph, g2).testEquals();\n", "  }\n", "\n", "  // Node/edge sets are the same, but node/edge connections differ.\n"], "4": ["  // Node/edge sets and node/edge connections are the same, but GraphConfigs differ.\n"], "5": ["  // Node/edge sets and node/edge connections are the same, but edge order differs.\n"]}, "removed": {"2": ["  // Node/edge sets are the same, but types differ.\n", "  public void equals_typesDiffer() {\n", "    // Whatever graphType specifies, pick another type.\n"], "3": ["  // Node/edge sets and graph type are the same, but node/edge connections differ.\n"], "4": ["  // Node/edge sets, graph type, and node/edge connections are the same, but GraphConfigs differ.\n"], "5": ["  // Node/edge sets, graph type, and node/edge connections are the same, but edge order differs.\n"]}, "added_lines": {"1": [39], "2": [100, 102], "3": [122, 123, 124, 125, 126, 127, 128, 129, 130, 131, 132, 133, 134, 135, 136, 137, 138, 139, 140, 141, 142, 143, 144, 145], "4": [159], "5": [171]}, "removed_lines": {"2": [99, 101, 104], "3": [122], "4": [136], "5": [148]}}, {"1": "guava/src/com/google/common/graph/AbstractGraph.java", "added": {"1": ["/*\n", " * Copyright (C) 2016 The Guava Authors\n", " *\n", " * Licensed under the Apache License, Version 2.0 (the \"License\");\n", " * you may not use this file except in compliance with the License.\n", " * You may obtain a copy of the License at\n", " *\n", " * http://www.apache.org/licenses/LICENSE-2.0\n", " *\n", " * Unless required by applicable law or agreed to in writing, software\n", " * distributed under the License is distributed on an \"AS IS\" BASIS,\n", " * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n", " * See the License for the specific language governing permissions and\n", " * limitations under the License.\n", " */\n", "\n", "package com.google.common.graph;\n", "\n", "import javax.annotation.Nullable;\n", "\n", "/**\n", " * This class provides a skeletal implementation of {@link Graph}. It is recommended to extend this\n", " * class rather than implement {@link Graph} directly, to ensure consistent {@link #equals(Object)}\n", " * and {@link #hashCode()} results across different graph implementations.\n", " *\n", " * @author James Sexton\n", " * @param <N> Node parameter type\n", " * @param <E> Edge parameter type\n", " */\n", "public abstract class AbstractGraph<N, E> implements Graph<N, E> {\n", "\n", "  protected final GraphConfig config;\n", "\n", "  /**\n", "   * Not all subclasses necessarily need to expose a constructor that takes a {@link GraphConfig},\n", "   * but they do need to provide the {@code config} here that will be returned by {@link #config()}.\n", "   */\n", "  protected AbstractGraph(GraphConfig config) {\n", "    this.config = config;\n", "  }\n", "\n", "  @Override\n", "  public GraphConfig config() {\n", "    return config;\n", "  }\n", "\n", "  @Override\n", "  public long degree(Object node) {\n", "    return incidentEdges(node).size();\n", "  }\n", "\n", "  @Override\n", "  public long inDegree(Object node) {\n", "    return inEdges(node).size();\n", "  }\n", "\n", "  @Override\n", "  public long outDegree(Object node) {\n", "    return outEdges(node).size();\n", "  }\n", "\n", "  @Override\n", "  public boolean equals(@Nullable Object object) {\n", "    if (!(object instanceof Graph)) {\n", "      return false;\n", "    }\n", "    return Graphs.equal(this, (Graph<?, ?>) object);\n", "  }\n", "\n", "  @Override\n", "  public int hashCode() {\n", "    return Graphs.hashCode(this);\n", "  }\n", "\n", "  @Override\n", "  public String toString() {\n", "    return Graphs.toString(this);\n", "  }\n", "}\n"]}, "removed": {}, "added_lines": {"1": [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 58, 59, 60, 61, 62, 63, 64, 65, 66, 67, 68, 69, 70, 71, 72, 73, 74, 75, 76, 77, 78, 79]}, "removed_lines": {}}, {"2": "guava/src/com/google/common/graph/AbstractImmutableGraph.java", "added": {"1": ["abstract class AbstractImmutableGraph<N, E> extends AbstractGraph<N, E> {\n", "\n", "  AbstractImmutableGraph(GraphConfig config) {\n", "    super(config);\n", "  }\n"]}, "removed": {"1": ["abstract class AbstractImmutableGraph<N, E> implements Graph<N, E> {\n"]}, "added_lines": {"1": [28, 29, 30, 31, 32]}, "removed_lines": {"1": [28]}}, {"3": "guava/src/com/google/common/graph/Graph.java", "added": {"1": [" * <li>Prefer extending {@link AbstractGraph} over implementing {@link Graph} directly. This will\n", " *     ensure consistent {@link #equals(Object)} and {@link #hashCode()} across implementations.\n"], "2": ["   * Returns {@code true} iff {@code object} is a graph that has the same node/edge relationships\n", "   * as those in this graph.\n", "   *     <br>Thus, every edge in A and B connect the same nodes in the same direction (if any).\n"], "3": ["   *\n", "   * <p>A reference implementation of this is provided by {@link Graphs#equal(Graph, Graph)}.\n", "\n", "  /**\n", "   * Returns the hash code for this graph. The hash code of a graph is defined as the hash code\n", "   * of a map from each of the graph's nodes to their incident edges.\n", "   *\n", "   * <p>A reference implementation of this is provided by {@link Graphs#hashCode(Graph)}.\n", "   *\n", "   * <p>Note that by this definition, two graphs that are equal in every aspect except edge\n", "   * direction will have the same hash code (but can still be differentiated by {@link #equals}.\n", "   */\n", "  @Override\n", "  int hashCode();\n"]}, "removed": {"2": ["   * Returns {@code true} iff {@code object} is the same type of graph (directed, undirected,\n", "   * hypergraph) as this graph, and the same node/edge relationships exist in both graphs.\n", "   * <li>A and B are of the same type ({@code DirectedGraph, UndirectedGraph, Hypergraph})\n", "   *     <br>Thus, even if a {@code node} has the same sets of <i>adjacent</i> nodes\n", "   *         (neighbors) in both A and B, if the sets of edges by which {@code node} is connected to\n", "   *         its adjacent nodes are not the same in both A and B, then A and B are not equal.\n"]}, "added_lines": {"1": [159, 160], "2": [398, 399, 407], "3": [418, 419, 423, 424, 425, 426, 427, 428, 429, 430, 431, 432, 433, 434]}, "removed_lines": {"2": [396, 397, 401, 406, 407, 408]}}, {"4": "guava/src/com/google/common/graph/Graphs.java", "added": {"1": ["import java.util.Map;\n"], "2": ["   * Returns true iff {@code graph1} and {@code graph2} have the same node/edge relationships.\n", "  public static boolean equal(@Nullable Graph<?, ?> graph1, @Nullable Graph<?, ?> graph2) {\n"], "3": ["    if (graph1.edges().size() != graph2.edges().size()) {\n", "    if (!graph1.nodes().equals(graph2.nodes())) {\n", "    for (Object node : graph1.nodes()) {\n", "      if (!graph1.inEdges(node).equals(graph2.inEdges(node))) {\n", "        return false;\n", "      }\n", "      // TODO(b/27195992): Consider an optimization for the case where both graphs are undirected.\n", "      if (!graph1.outEdges(node).equals(graph2.outEdges(node))) {\n"], "4": ["   * Returns the hash code of {@code graph}.\n", "   *\n", "   * @see Graph#hashCode()\n", "  public static int hashCode(Graph<?, ?> graph) {\n", "    return nodeToIncidentEdges(graph).hashCode();\n", "   * Returns a string representation of {@code graph}. Encodes edge direction if {@code graph}\n", "   * is a {@link DirectedGraph}.\n", "  public static String toString(Graph<?, ?> graph) {\n", "        Maps.asMap(graph.edges(), edgeToIncidentNodesString(graph)));\n"], "5": ["\n", "  /**\n", "   * Returns a map that is a live view of {@code graph}, with nodes as keys\n", "   * and the set of incident edges as values.\n", "   */\n", "  private static <N, E> Map<N, Set<E>> nodeToIncidentEdges(final Graph<N, E> graph) {\n", "    checkNotNull(graph, \"graph\");\n", "    return Maps.asMap(graph.nodes(), new Function<N, Set<E>>() {\n", "      @Override\n", "      public Set<E> apply(N node) {\n", "        return graph.incidentEdges(node);\n", "      }\n", "    });\n", "  }\n", "\n", "  /**\n", "   * Returns a function that transforms an edge into a string representation of its incident nodes\n", "   * in {@code graph}. The function's {@code apply} method will throw an\n", "   * {@link IllegalArgumentException} if {@code graph} does not contain {@code edge}.\n", "   */\n", "  private static Function<Object, String> edgeToIncidentNodesString(final Graph<?, ?> graph) {\n", "    if (graph instanceof DirectedGraph) {\n", "      @SuppressWarnings(\"unchecked\")\n", "      final DirectedGraph<?, ?> directedGraph = (DirectedGraph<?, ?>) graph;\n", "      return new Function<Object, String>() {\n", "        @Override\n", "        public String apply(Object edge) {\n", "          return String.format(\"<%s -> %s>\",\n", "              directedGraph.source(edge), directedGraph.target(edge));\n", "          }\n", "        };\n", "    }\n", "    return new Function<Object, String>() {\n", "      @Override\n", "      public String apply(Object edge) {\n", "        return graph.incidentNodes(edge).toString();\n", "      }\n", "    };\n", "  }\n"]}, "removed": {"2": ["   * Returns true iff {@code graph1} and {@code graph2} have the same node and edge sets and\n", "   * each edge has the same source and target in both graphs.\n", "  public static <N, E> boolean equal(\n", "      @Nullable DirectedGraph<?, ?> graph1, @Nullable DirectedGraph<?, ?> graph2) {\n"], "3": ["    if (!graph1.nodes().equals(graph2.nodes()) || !graph1.edges().equals(graph2.edges())) {\n", "    for (Object edge : graph1.edges()) {\n", "      if (!graph1.source(edge).equals(graph2.source(edge))\n", "          || !graph1.target(edge).equals(graph2.target(edge))) {\n", "        return false;\n", "      }\n", "    }\n", "    return true;\n", "  }\n", "\n", "  /**\n", "   * Returns true iff {@code graph1} and {@code graph2} have the same node and edge sets and\n", "   * each edge has the same incident node set in both graphs.\n", "   *\n", "   * @see Graph#equals(Object)\n", "   */\n", "  public static boolean equal(@Nullable Graph<?, ?> graph1, @Nullable Graph<?, ?> graph2) {\n", "    if (graph1 == graph2) {\n", "      return true;\n", "    }\n", "\n", "    if (graph1 == null || graph2 == null) {\n", "    if (!graph1.nodes().equals(graph2.nodes()) || !graph1.edges().equals(graph2.edges())) {\n", "      return false;\n", "    }\n", "\n", "    for (Object edge : graph1.edges()) {\n", "      if (!graph1.incidentNodes(edge).equals(graph2.incidentNodes(edge))) {\n"], "4": ["   * Returns a string representation of {@code graph}, encoding the direction of each edge.\n", "  public static String toString(final DirectedGraph<?, ?> graph) {\n", "    Function<Object, String> edgeToEndpoints = new Function<Object, String>() {\n", "      @Override\n", "      public String apply(Object edge) {\n", "        return String.format(\"<%s -> %s>\", graph.source(edge), graph.target(edge));\n", "      }\n", "    };\n", "    return String.format(\"config: %s, nodes: %s, edges: %s\",\n", "        graph.config(),\n", "        graph.nodes(),\n", "        Maps.asMap(graph.edges(), edgeToEndpoints));\n", "   * Returns a string representation of {@code graph}, without regard to direction of edges.\n", "  public static String toString(final Graph<?, ?> graph) {\n", "    Function<Object, String> edgeToIncidentNodes = new Function<Object, String>() {\n", "      @Override\n", "      public String apply(Object edge) {\n", "        return graph.incidentNodes(edge).toString();\n", "      }\n", "    };\n", "        Maps.asMap(graph.edges(), edgeToIncidentNodes));\n"]}, "added_lines": {"1": [32], "2": [383, 387], "3": [396, 400, 404, 405, 406, 407, 408, 409], "4": [418, 419, 420, 422, 423, 427, 428, 430, 434], "5": [452, 453, 454, 455, 456, 457, 458, 459, 460, 461, 462, 463, 464, 465, 466, 467, 468, 469, 470, 471, 472, 473, 474, 475, 476, 477, 478, 479, 480, 481, 482, 483, 484, 485, 486, 487, 488, 489, 490]}, "removed_lines": {"2": [382, 383, 387, 388], "3": [397, 401, 402, 403, 404, 405, 406, 407, 408, 409, 410, 411, 412, 413, 414, 415, 416, 417, 418, 419, 420, 421, 425, 426, 427, 428, 429, 430], "4": [438, 440, 441, 442, 443, 444, 445, 446, 447, 448, 449, 450, 454, 456, 457, 458, 459, 460, 461, 462, 466]}}, {"5": "guava/src/com/google/common/graph/ImmutableDirectedGraph.java", "added": {"3": ["    super(builder.directedGraph.config());\n"]}, "removed": {"1": ["import com.google.common.base.Objects;\n"], "2": ["import javax.annotation.Nullable;\n", "\n"], "3": ["  private final GraphConfig config;\n"], "4": ["    this.config = directedGraph.config();\n"], "5": ["  @Override\n", "  public GraphConfig config() {\n", "    return config;\n", "  }\n", "\n"], "6": ["  @Override\n", "  public long degree(Object node) {\n", "    return incidentEdges(node).size();\n", "  }\n", "\n", "  @Override\n", "  public long inDegree(Object node) {\n", "    return inEdges(node).size();\n", "  }\n", "\n", "  @Override\n", "  public long outDegree(Object node) {\n", "    return outEdges(node).size();\n", "  }\n", "\n"], "7": ["  @Override\n", "  public boolean equals(@Nullable Object object) {\n", "    return (object instanceof DirectedGraph) && Graphs.equal(this, (DirectedGraph<?, ?>) object);\n", "  }\n", "\n", "  @Override\n", "  public int hashCode() {\n", "    // The node set is included in the hash to differentiate between graphs with isolated nodes.\n", "    return Objects.hashCode(nodes(), edgeToIncidentNodes);\n", "  }\n", "\n", "  @Override\n", "  public String toString() {\n", "    return Graphs.toString(this);\n", "  }\n", "\n"]}, "added_lines": {"3": [80]}, "removed_lines": {"1": [25], "2": [33, 34], "3": [81], "4": [101], "5": [114, 115, 116, 117, 118], "6": [186, 187, 188, 189, 190, 191, 192, 193, 194, 195, 196, 197, 198, 199, 200], "7": [211, 212, 213, 214, 215, 216, 217, 218, 219, 220, 221, 222, 223, 224, 225, 226]}}, {"6": "guava/src/com/google/common/graph/ImmutableUndirectedGraph.java", "added": {"3": ["    super(builder.undirectedGraph.config());\n"]}, "removed": {"1": ["import com.google.common.base.Objects;\n"], "2": ["import javax.annotation.Nullable;\n", "\n"], "3": ["  private final GraphConfig config;\n"], "4": ["    this.config = undirectedGraph.config();\n"], "5": ["  @Override\n", "  public GraphConfig config() {\n", "    return config;\n", "  }\n", "\n"], "6": ["  @Override\n", "  public long degree(Object node) {\n", "    return incidentEdges(node).size();\n", "  }\n", "\n", "  @Override\n", "  public long inDegree(Object node) {\n", "    return degree(node);\n", "  }\n", "\n", "  @Override\n", "  public long outDegree(Object node) {\n", "    return degree(node);\n", "  }\n", "\n", "  @Override\n", "  public boolean equals(@Nullable Object object) {\n", "    return (object instanceof UndirectedGraph)\n", "        && Graphs.equal(this, (UndirectedGraph<?, ?>) object);\n", "  }\n", "\n", "  @Override\n", "  public int hashCode() {\n", "    // The node set is included in the hash to differentiate between graphs with isolated nodes.\n", "    return Objects.hashCode(nodes(), edgeToIncidentNodes);\n", "  }\n", "\n", "  @Override\n", "  public String toString() {\n", "    return Graphs.toString(this);\n", "  }\n", "\n"]}, "added_lines": {"3": [77]}, "removed_lines": {"1": [25], "2": [34, 35], "3": [77], "4": [92], "5": [105, 106, 107, 108, 109], "6": [181, 182, 183, 184, 185, 186, 187, 188, 189, 190, 191, 192, 193, 194, 195, 196, 197, 198, 199, 200, 201, 202, 203, 204, 205, 206, 207, 208, 209, 210, 211, 212]}}, {"7": "guava/src/com/google/common/graph/IncidenceSetDirectedGraph.java", "added": {"3": ["final class IncidenceSetDirectedGraph<N, E> extends AbstractGraph<N, E>\n", "    implements DirectedGraph<N, E> {\n", "    super(config);\n"]}, "removed": {"1": ["import com.google.common.base.Objects;\n"], "2": ["import javax.annotation.Nullable;\n", "\n"], "3": ["final class IncidenceSetDirectedGraph<N, E> implements DirectedGraph<N, E> {\n", "  private final GraphConfig config;\n", "    this.config = config;\n"], "4": ["  @Override\n", "  public GraphConfig config() {\n", "    return config;\n", "  }\n", "\n"], "5": ["  @Override\n", "  public long degree(Object node) {\n", "    return incidentEdges(node).size();\n", "  }\n", "\n", "  @Override\n", "  public long inDegree(Object node) {\n", "    return inEdges(node).size();\n", "  }\n", "\n", "  @Override\n", "  public long outDegree(Object node) {\n", "    return outEdges(node).size();\n", "  }\n", "\n"], "6": ["  @Override\n", "  public boolean equals(@Nullable Object other) {\n", "    return (other instanceof DirectedGraph) && Graphs.equal(this, (DirectedGraph<?, ?>) other);\n", "  }\n", "\n", "  @Override\n", "  public int hashCode() {\n", "    // The node set is included in the hash to differentiate between graphs with isolated nodes.\n", "    return Objects.hashCode(nodes(), edgeToIncidentNodes);\n", "  }\n", "\n", "  @Override\n", "  public String toString() {\n", "    return Graphs.toString(this);\n", "  }\n", "\n"]}, "added_lines": {"3": [103, 104, 111]}, "removed_lines": {"1": [27], "2": [39, 40], "3": [106, 111, 119], "4": [132, 133, 134, 135, 136], "5": [202, 203, 204, 205, 206, 207, 208, 209, 210, 211, 212, 213, 214, 215, 216], "6": [339, 340, 341, 342, 343, 344, 345, 346, 347, 348, 349, 350, 351, 352, 353, 354]}}, {"8": "guava/src/com/google/common/graph/IncidenceSetUndirectedGraph.java", "added": {"3": ["final class IncidenceSetUndirectedGraph<N, E> extends AbstractGraph<N, E>\n", "    implements UndirectedGraph<N, E> {\n", "    super(config);\n"]}, "removed": {"1": ["import com.google.common.base.Objects;\n"], "2": ["import javax.annotation.Nullable;\n", "\n"], "3": ["final class IncidenceSetUndirectedGraph<N, E> implements UndirectedGraph<N, E> {\n", "  private final GraphConfig config;\n", "    this.config = config;\n"], "4": ["  @Override\n", "  public GraphConfig config() {\n", "    return config;\n", "  }\n", "\n"], "5": ["  @Override\n", "  public long degree(Object node) {\n", "    return incidentEdges(node).size();\n", "  }\n", "\n", "  @Override\n", "  public long inDegree(Object node) {\n", "    return degree(node);\n", "  }\n", "\n", "  @Override\n", "  public long outDegree(Object node) {\n", "    return degree(node);\n", "  }\n", "\n"], "6": ["  @Override\n", "  public boolean equals(@Nullable Object object) {\n", "    return (object instanceof UndirectedGraph)\n", "        && Graphs.equal(this, (UndirectedGraph<?, ?>) object);\n", "  }\n", "\n", "  @Override\n", "  public int hashCode() {\n", "    // The node set is included in the hash to differentiate between graphs with isolated nodes.\n", "    return Objects.hashCode(nodes(), edgeToIncidentNodes);\n", "  }\n", "\n", "  @Override\n", "  public String toString() {\n", "    return Graphs.toString(this);\n", "  }\n", "\n"]}, "added_lines": {"3": [98, 99, 108]}, "removed_lines": {"1": [27], "2": [39, 40], "3": [101, 108, 116], "4": [129, 130, 131, 132, 133], "5": [204, 205, 206, 207, 208, 209, 210, 211, 212, 213, 214, 215, 216, 217, 218], "6": [317, 318, 319, 320, 321, 322, 323, 324, 325, 326, 327, 328, 329, 330, 331, 332, 333]}}]}
