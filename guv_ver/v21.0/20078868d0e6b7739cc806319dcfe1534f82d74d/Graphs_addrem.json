{
    "addition": {
        "32": "import java.util.Map;\n",
        "383": "   * Returns true iff {@code graph1} and {@code graph2} have the same node/edge relationships.\n",
        "387": "  public static boolean equal(@Nullable Graph<?, ?> graph1, @Nullable Graph<?, ?> graph2) {\n",
        "396": "    if (graph1.edges().size() != graph2.edges().size()) {\n",
        "400": "    if (!graph1.nodes().equals(graph2.nodes())) {\n",
        "404": "    for (Object node : graph1.nodes()) {\n",
        "405": "      if (!graph1.inEdges(node).equals(graph2.inEdges(node))) {\n",
        "406": "        return false;\n",
        "407": "      }\n",
        "408": "      // TODO(b/27195992): Consider an optimization for the case where both graphs are undirected.\n",
        "409": "      if (!graph1.outEdges(node).equals(graph2.outEdges(node))) {\n",
        "418": "   * Returns the hash code of {@code graph}.\n",
        "419": "   *\n",
        "420": "   * @see Graph#hashCode()\n",
        "422": "  public static int hashCode(Graph<?, ?> graph) {\n",
        "423": "    return nodeToIncidentEdges(graph).hashCode();\n",
        "427": "   * Returns a string representation of {@code graph}. Encodes edge direction if {@code graph}\n",
        "428": "   * is a {@link DirectedGraph}.\n",
        "430": "  public static String toString(Graph<?, ?> graph) {\n",
        "434": "        Maps.asMap(graph.edges(), edgeToIncidentNodesString(graph)));\n",
        "452": "\n",
        "453": "  /**\n",
        "454": "   * Returns a map that is a live view of {@code graph}, with nodes as keys\n",
        "455": "   * and the set of incident edges as values.\n",
        "456": "   */\n",
        "457": "  private static <N, E> Map<N, Set<E>> nodeToIncidentEdges(final Graph<N, E> graph) {\n",
        "458": "    checkNotNull(graph, \"graph\");\n",
        "459": "    return Maps.asMap(graph.nodes(), new Function<N, Set<E>>() {\n",
        "460": "      @Override\n",
        "461": "      public Set<E> apply(N node) {\n",
        "462": "        return graph.incidentEdges(node);\n",
        "463": "      }\n",
        "464": "    });\n",
        "465": "  }\n",
        "466": "\n",
        "467": "  /**\n",
        "468": "   * Returns a function that transforms an edge into a string representation of its incident nodes\n",
        "469": "   * in {@code graph}. The function's {@code apply} method will throw an\n",
        "470": "   * {@link IllegalArgumentException} if {@code graph} does not contain {@code edge}.\n",
        "471": "   */\n",
        "472": "  private static Function<Object, String> edgeToIncidentNodesString(final Graph<?, ?> graph) {\n",
        "473": "    if (graph instanceof DirectedGraph) {\n",
        "474": "      @SuppressWarnings(\"unchecked\")\n",
        "475": "      final DirectedGraph<?, ?> directedGraph = (DirectedGraph<?, ?>) graph;\n",
        "476": "      return new Function<Object, String>() {\n",
        "477": "        @Override\n",
        "478": "        public String apply(Object edge) {\n",
        "479": "          return String.format(\"<%s -> %s>\",\n",
        "480": "              directedGraph.source(edge), directedGraph.target(edge));\n",
        "481": "          }\n",
        "482": "        };\n",
        "483": "    }\n",
        "484": "    return new Function<Object, String>() {\n",
        "485": "      @Override\n",
        "486": "      public String apply(Object edge) {\n",
        "487": "        return graph.incidentNodes(edge).toString();\n",
        "488": "      }\n",
        "489": "    };\n",
        "490": "  }\n"
    },
    "removed": {
        "382": "   * Returns true iff {@code graph1} and {@code graph2} have the same node and edge sets and\n",
        "383": "   * each edge has the same source and target in both graphs.\n",
        "387": "  public static <N, E> boolean equal(\n",
        "388": "      @Nullable DirectedGraph<?, ?> graph1, @Nullable DirectedGraph<?, ?> graph2) {\n",
        "397": "    if (!graph1.nodes().equals(graph2.nodes()) || !graph1.edges().equals(graph2.edges())) {\n",
        "401": "    for (Object edge : graph1.edges()) {\n",
        "402": "      if (!graph1.source(edge).equals(graph2.source(edge))\n",
        "403": "          || !graph1.target(edge).equals(graph2.target(edge))) {\n",
        "404": "        return false;\n",
        "405": "      }\n",
        "406": "    }\n",
        "407": "    return true;\n",
        "408": "  }\n",
        "409": "\n",
        "410": "  /**\n",
        "411": "   * Returns true iff {@code graph1} and {@code graph2} have the same node and edge sets and\n",
        "412": "   * each edge has the same incident node set in both graphs.\n",
        "413": "   *\n",
        "414": "   * @see Graph#equals(Object)\n",
        "415": "   */\n",
        "416": "  public static boolean equal(@Nullable Graph<?, ?> graph1, @Nullable Graph<?, ?> graph2) {\n",
        "417": "    if (graph1 == graph2) {\n",
        "418": "      return true;\n",
        "419": "    }\n",
        "420": "\n",
        "421": "    if (graph1 == null || graph2 == null) {\n",
        "425": "    if (!graph1.nodes().equals(graph2.nodes()) || !graph1.edges().equals(graph2.edges())) {\n",
        "426": "      return false;\n",
        "427": "    }\n",
        "428": "\n",
        "429": "    for (Object edge : graph1.edges()) {\n",
        "430": "      if (!graph1.incidentNodes(edge).equals(graph2.incidentNodes(edge))) {\n",
        "438": "   * Returns a string representation of {@code graph}, encoding the direction of each edge.\n",
        "440": "  public static String toString(final DirectedGraph<?, ?> graph) {\n",
        "441": "    Function<Object, String> edgeToEndpoints = new Function<Object, String>() {\n",
        "442": "      @Override\n",
        "443": "      public String apply(Object edge) {\n",
        "444": "        return String.format(\"<%s -> %s>\", graph.source(edge), graph.target(edge));\n",
        "445": "      }\n",
        "446": "    };\n",
        "447": "    return String.format(\"config: %s, nodes: %s, edges: %s\",\n",
        "448": "        graph.config(),\n",
        "449": "        graph.nodes(),\n",
        "450": "        Maps.asMap(graph.edges(), edgeToEndpoints));\n",
        "454": "   * Returns a string representation of {@code graph}, without regard to direction of edges.\n",
        "456": "  public static String toString(final Graph<?, ?> graph) {\n",
        "457": "    Function<Object, String> edgeToIncidentNodes = new Function<Object, String>() {\n",
        "458": "      @Override\n",
        "459": "      public String apply(Object edge) {\n",
        "460": "        return graph.incidentNodes(edge).toString();\n",
        "461": "      }\n",
        "462": "    };\n",
        "466": "        Maps.asMap(graph.edges(), edgeToIncidentNodes));\n"
    }
}