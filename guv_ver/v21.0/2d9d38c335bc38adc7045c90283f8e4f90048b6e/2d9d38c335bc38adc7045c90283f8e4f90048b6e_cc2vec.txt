{"id": "2d9d38c335bc38adc7045c90283f8e4f90048b6e", "code": [{"0": "guava-gwt/src-super/com/google/common/collect/super/com/google/common/collect/TreeTraverser.java", "added": {"1": ["import com.google.common.base.Function;\n"], "2": [" * <p>For example, the tree\n", " * <pre>{@code\n", " *        h\n", " *      / | \\\n", " *     /  e  \\\n", " *    d       g\n", " *   /|\\      |\n", " *  / | \\     f\n", " * a  b  c\n", " *\n", " * }</pre>\n", " * <p><b>For Java 8 users:</b> Because this is an abstract class, not an interface, you can't use a\n", " * lambda expression to extend it:\n", " *\n", " * <pre>{@code\n", " * // won't work\n", " * TreeTraverser<NodeType> traverser = node -> node.getChildNodes();\n", " * }</pre>\n", " *\n", " * Instead, you can pass a lambda expression to the {@code using} factory method:\n", " *\n", " * <pre>{@code\n", " * TreeTraverser<NodeType> traverser = TreeTraverser.using(node -> node.getChildNodes());\n", " * }</pre>\n", " *\n", "  /**\n", "   * Returns a tree traverser that uses the given function to navigate from a node to its children.\n", "   * This is useful if the function instance already exists, or so that you can supply a lambda\n", "   * expressions. If those circumstances don't apply, you probably don't need to use this; subclass\n", "   * {@code TreeTraverser} and implement its {@link #children} method directly.\n", "   *\n", "   * @since 20.0\n", "   */\n", "  public static <T> TreeTraverser<T> using(\n", "      final Function<T, ? extends Iterable<T>> nodeToChildrenFunction) {\n", "    checkNotNull(nodeToChildrenFunction);\n", "    return new TreeTraverser<T>() {\n", "      @Override\n", "      public Iterable<T> children(T root) {\n", "        return nodeToChildrenFunction.apply(root);\n", "      }\n", "    };\n", "  }\n"]}, "removed": {"2": [" * <p>For example, the tree <pre>   {@code\n", " *          h\n", " *        / | \\\n", " *       /  e  \\\n", " *      d       g\n", " *     /|\\      |\n", " *    / | \\     f\n", " *   a  b  c\n", " *   }</pre>\n"]}, "added_lines": {"1": [21], "2": [30, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 58, 59, 60, 61, 65, 66, 67, 68, 69, 70, 71, 72, 73, 74, 75, 76, 77, 78, 79, 80, 81, 82]}, "removed_lines": {"2": [29, 31, 32, 33, 34, 35, 36, 37, 38]}}, {"1": "guava-gwt/test/com/google/common/collect/TreeTraverserTest_gwt.java", "added": {"1": ["\n", "public void testUsing() throws Exception {\n", "  com.google.common.collect.TreeTraverserTest testCase = new com.google.common.collect.TreeTraverserTest();\n", "  testCase.testUsing();\n", "}\n"]}, "removed": {}, "added_lines": {"1": [40, 41, 42, 43, 44]}, "removed_lines": {}}, {"2": "guava-tests/test/com/google/common/collect/TreeTraverserTest.java", "added": {"1": ["import com.google.common.base.Function;\n"], "2": ["  private static final TreeTraverser<Tree> ADAPTER_USING_USING =\n", "      TreeTraverser.using(\n", "          new Function<Tree, Iterable<Tree>>() {\n", "            @Override\n", "            public Iterable<Tree> apply(Tree node) {\n", "              return node.children;\n", "            }\n", "          });\n", "\n"], "3": ["  public void testUsing() {\n", "    assertThat(iterationOrder(ADAPTER_USING_USING.preOrderTraversal(h))).isEqualTo(\"hdabcegf\");\n", "  }\n", "\n"]}, "removed": {}, "added_lines": {"1": [21], "2": [67, 68, 69, 70, 71, 72, 73, 74, 75], "3": [156, 157, 158, 159]}, "removed_lines": {}}, {"3": "guava/src/com/google/common/base/Converter.java", "added": {"1": ["   * Returns a converter based on separate forward and backward functions. This is useful if the\n", "   * function instances already exist, or so that you can supply lambda expressions. If those\n", "   * circumstances don't apply, you probably don't need to use this; subclass {@code Converter} and\n", "   * implement its {@link #doForward} and {@link #doBackward} methods directly.\n"]}, "removed": {"1": ["   * Returns a converter based on <i>existing</i> forward and backward functions. Note that it is\n", "   * unnecessary to create <i>new</i> classes implementing {@code Function} just to pass them in\n", "   * here. Instead, simply subclass {@code Converter} and implement its {@link #doForward} and\n", "   * {@link #doBackward} methods directly.\n"]}, "added_lines": {"1": [409, 410, 411, 412]}, "removed_lines": {"1": [409, 410, 411, 412]}}, {"4": "guava/src/com/google/common/collect/TreeTraverser.java", "added": {"1": ["import com.google.common.base.Function;\n"], "2": [" * <pre>{@code\n", " *        h\n", " *      / | \\\n", " *     /  e  \\\n", " *    d       g\n", " *   /|\\      |\n", " *  / | \\     f\n", " * a  b  c\n", " * }</pre>\n", " * <p><b>For Java 8 users:</b> Because this is an abstract class, not an interface, you can't use a\n", " * lambda expression to extend it:\n", " *\n", " * <pre>{@code\n", " * // won't work\n", " * TreeTraverser<NodeType> traverser = node -> node.getChildNodes();\n", " * }</pre>\n", " *\n", " * Instead, you can pass a lambda expression to the {@code using} factory method:\n", " *\n", " * <pre>{@code\n", " * TreeTraverser<NodeType> traverser = TreeTraverser.using(node -> node.getChildNodes());\n", " * }</pre>\n", " *\n"], "3": ["  /**\n", "   * Returns a tree traverser that uses the given function to navigate from a node to its children.\n", "   * This is useful if the function instance already exists, or so that you can supply a lambda\n", "   * expressions. If those circumstances don't apply, you probably don't need to use this; subclass\n", "   * {@code TreeTraverser} and implement its {@link #children} method directly.\n", "   *\n", "   * @since 20.0\n", "   */\n", "  public static <T> TreeTraverser<T> using(\n", "      final Function<T, ? extends Iterable<T>> nodeToChildrenFunction) {\n", "    checkNotNull(nodeToChildrenFunction);\n", "    return new TreeTraverser<T>() {\n", "      @Override\n", "      public Iterable<T> children(T root) {\n", "        return nodeToChildrenFunction.apply(root);\n", "      }\n", "    };\n", "  }\n", "\n"]}, "removed": {"2": [" * <pre>          {@code\n", " *          h\n", " *        / | \\\n", " *       /  e  \\\n", " *      d       g\n", " *     /|\\      |\n", " *    / | \\     f\n", " *   a  b  c       }</pre>\n"]}, "added_lines": {"1": [23], "2": [35, 36, 37, 38, 39, 40, 41, 42, 43, 50, 51, 52, 53, 54, 55, 56, 57, 58, 59, 60, 61, 62, 63], "3": [72, 73, 74, 75, 76, 77, 78, 79, 80, 81, 82, 83, 84, 85, 86, 87, 88, 89, 90]}, "removed_lines": {"2": [34, 35, 36, 37, 38, 39, 40, 41]}}]}
