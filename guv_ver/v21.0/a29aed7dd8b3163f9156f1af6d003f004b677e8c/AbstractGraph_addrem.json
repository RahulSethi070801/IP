{
    "addition": {
        "54": "      degreeSum += degree(node);\n",
        "91": "  @Override\n",
        "92": "  public int degree(Object node) {\n",
        "93": "    if (isDirected()) {\n",
        "94": "      return IntMath.saturatedAdd(predecessors(node).size(), successors(node).size());\n",
        "95": "    } else {\n",
        "96": "      Set<N> neighbors = adjacentNodes(node);\n",
        "97": "      int selfLoop = (allowsSelfLoops() && neighbors.contains(node)) ? 1 : 0;\n",
        "98": "      return IntMath.saturatedAdd(neighbors.size(), selfLoop);\n",
        "99": "    }\n",
        "100": "  }\n",
        "101": "\n",
        "102": "  @Override\n",
        "103": "  public int inDegree(Object node) {\n",
        "104": "    return isDirected() ? predecessors(node).size() : degree(node);\n",
        "105": "  }\n",
        "106": "\n",
        "107": "  @Override\n",
        "108": "  public int outDegree(Object node) {\n",
        "109": "    return isDirected() ? successors(node).size() : degree(node);\n",
        "110": "  }\n",
        "111": "\n"
    },
    "removed": {
        "54": "      degreeSum += degree(this, node);\n",
        "91": "  @SuppressWarnings({\"unchecked\", \"rawtypes\"})\n",
        "145": "\n",
        "146": "  /**\n",
        "147": "   * Returns the number of times an edge touches {@code node} in {@code graph}. This is equivalent\n",
        "148": "   * to the number of edges incident to {@code node} in the graph, with self-loops counting twice.\n",
        "149": "   *\n",
        "150": "   * <p>If this number is greater than {@code Integer.MAX_VALUE}, returns {@code Integer.MAX_VALUE}.\n",
        "151": "   *\n",
        "152": "   * @throws IllegalArgumentException if {@code node} is not an element of this graph\n",
        "153": "   */\n",
        "154": "  // TODO(b/30649235): What to do with this? Move to Graphs or interfaces? Provide in/outDegree?\n",
        "155": "  private static int degree(Graph<?, ?> graph, Object node) {\n",
        "156": "    if (graph.isDirected()) {\n",
        "157": "      return IntMath.saturatedAdd(graph.predecessors(node).size(), graph.successors(node).size());\n",
        "158": "    } else {\n",
        "159": "      int selfLoops = (graph.allowsSelfLoops() && graph.adjacentNodes(node).contains(node)) ? 1 : 0;\n",
        "160": "      return IntMath.saturatedAdd(graph.adjacentNodes(node).size(), selfLoops);\n",
        "161": "    }\n",
        "162": "  }\n"
    }
}