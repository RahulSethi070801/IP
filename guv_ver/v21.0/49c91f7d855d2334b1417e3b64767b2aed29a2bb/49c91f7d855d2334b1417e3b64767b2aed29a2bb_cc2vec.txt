{"id": "49c91f7d855d2334b1417e3b64767b2aed29a2bb", "code": [{"0": "guava-tests/test/com/google/common/graph/GraphsTest.java", "added": {}, "removed": {"1": ["import static com.google.common.graph.Graphs.copyEdges;\n", "import static com.google.common.graph.Graphs.copyNodes;\n"], "2": ["  @Test\n", "  public void copyNodes_directedGraph() {\n", "    MutableGraph<Integer> directedGraph = buildDirectedTestGraph();\n", "    directedGraph.addNode(N3);\n", "\n", "    MutableGraph<Integer> actualGraph = GraphBuilder.directed().build();\n", "    // prepopulate actualGraph to make sure that existing elements don't interfere with the merging\n", "    actualGraph.addNode(N4);\n", "    actualGraph.addNode(N2);\n", "\n", "    copyNodes(directedGraph, actualGraph);\n", "\n", "    MutableGraph<Integer> expectedGraph = GraphBuilder.directed().build();\n", "    expectedGraph.addNode(N1);\n", "    expectedGraph.addNode(N2);\n", "    expectedGraph.addNode(N3);\n", "    expectedGraph.addNode(N4);\n", "\n", "    assertThat(actualGraph).isEqualTo(expectedGraph);\n", "  }\n", "\n", "  @Test\n", "  public void copyNodes_undirectedGraph() {\n", "    MutableGraph<Integer> undirectedGraph = buildUndirectedTestGraph();\n", "    undirectedGraph.addNode(N3);\n", "\n", "    MutableGraph<Integer> actualGraph = GraphBuilder.undirected().build();\n", "    // prepopulate actualGraph to make sure that existing elements don't interfere with the merging\n", "    actualGraph.addNode(N4);\n", "    actualGraph.addNode(N2);\n", "\n", "    copyNodes(undirectedGraph, actualGraph);\n", "\n", "    MutableGraph<Integer> expectedGraph = GraphBuilder.undirected().build();\n", "    expectedGraph.addNode(N1);\n", "    expectedGraph.addNode(N2);\n", "    expectedGraph.addNode(N3);\n", "    expectedGraph.addNode(N4);\n", "\n", "    assertThat(actualGraph).isEqualTo(expectedGraph);\n", "  }\n", "\n"], "3": ["  @Test\n", "  public void copyNodes_directedNetwork() {\n", "    MutableNetwork<Integer, String> directedGraph = buildDirectedTestNetwork();\n", "    directedGraph.addNode(N3);\n", "\n", "    MutableNetwork<Integer, String> actualGraph = NetworkBuilder.directed().build();\n", "    // prepopulate actualGraph to make sure that existing elements don't interfere with the merging\n", "    actualGraph.addNode(N4);\n", "    actualGraph.addNode(N2);\n", "\n", "    copyNodes(directedGraph, actualGraph);\n", "\n", "    MutableNetwork<Integer, String> expectedGraph = NetworkBuilder.directed().build();\n", "    expectedGraph.addNode(N1);\n", "    expectedGraph.addNode(N2);\n", "    expectedGraph.addNode(N3);\n", "    expectedGraph.addNode(N4);\n", "\n", "    assertThat(actualGraph).isEqualTo(expectedGraph);\n", "  }\n", "\n", "  @Test\n", "  public void copyNodes_undirectedNetwork() {\n", "    MutableNetwork<Integer, String> undirectedGraph = buildUndirectedTestNetwork();\n", "    undirectedGraph.addNode(N3);\n", "\n", "    MutableNetwork<Integer, String> actualGraph = NetworkBuilder.undirected().build();\n", "    // prepopulate actualGraph to make sure that existing elements don't interfere with the merging\n", "    actualGraph.addNode(N4);\n", "    actualGraph.addNode(N2);\n", "\n", "    copyNodes(undirectedGraph, actualGraph);\n", "\n", "    MutableNetwork<Integer, String> expectedGraph = NetworkBuilder.undirected().build();\n", "    expectedGraph.addNode(N1);\n", "    expectedGraph.addNode(N2);\n", "    expectedGraph.addNode(N3);\n", "    expectedGraph.addNode(N4);\n", "\n", "    assertThat(actualGraph).isEqualTo(expectedGraph);\n", "  }\n", "\n", "  @Test\n", "  public void copyEdges_directedNetwork() {\n", "    Network<Integer, String> directedGraph = buildDirectedTestNetwork();\n", "\n", "    MutableNetwork<Integer, String> actualGraph\n", "        = NetworkBuilder.directed().allowsParallelEdges(true).build();\n", "    // prepopulate actualGraph to make sure that existing elements don't interfere with the merging\n", "    actualGraph.addEdge(E11, N1, N1);\n", "    actualGraph.addEdge(E22, N2, N2);\n", "\n", "    copyEdges(directedGraph, actualGraph);\n", "\n", "    MutableNetwork<Integer, String> expectedGraph = buildDirectedTestNetwork();\n", "    expectedGraph.addEdge(E22, N2, N2);\n", "\n", "    assertThat(actualGraph).isEqualTo(expectedGraph);\n", "  }\n", "\n", "  @Test\n", "  public void copyEdges_undirectedNetwork() {\n", "    Network<Integer, String> undirectedGraph = buildUndirectedTestNetwork();\n", "\n", "    MutableNetwork<Integer, String> actualGraph =\n", "        NetworkBuilder.undirected().allowsParallelEdges(true).build();\n", "    // prepopulate actualGraph to make sure that existing elements don't interfere with the merging\n", "    actualGraph.addEdge(E11, N1, N1);\n", "    actualGraph.addEdge(E22, N2, N2);\n", "\n", "    copyEdges(undirectedGraph, actualGraph);\n", "\n", "    MutableNetwork<Integer, String> expectedGraph = buildUndirectedTestNetwork();\n", "    expectedGraph.addEdge(E22, N2, N2);\n", "\n", "    assertThat(actualGraph).isEqualTo(expectedGraph);\n", "  }\n", "\n", "  @Test\n", "  public void copyEdges_incidentNodesMissing() {\n", "    MutableNetwork<Integer, String> srcGraph = NetworkBuilder.undirected().build();\n", "    srcGraph.addEdge(E12, N1, N2);\n", "    srcGraph.addEdge(E13, N1, N3);\n", "\n", "    MutableNetwork<Integer, String> destGraph = NetworkBuilder.undirected().build();\n", "    destGraph.addNode(N1);\n", "    destGraph.addNode(N2);\n", "\n", "    copyEdges(srcGraph, destGraph);\n", "\n", "    // E13 should not be copied over because an incident node is missing in the destination graph.\n", "    assertThat(destGraph.edges()).containsExactly(E12);\n", "    assertThat(destGraph.nodes()).doesNotContain(N3);\n", "  }\n", "\n"]}, "added_lines": {}, "removed_lines": {"1": [21, 22], "2": [332, 333, 334, 335, 336, 337, 338, 339, 340, 341, 342, 343, 344, 345, 346, 347, 348, 349, 350, 351, 352, 353, 354, 355, 356, 357, 358, 359, 360, 361, 362, 363, 364, 365, 366, 367, 368, 369, 370, 371, 372, 373], "3": [390, 391, 392, 393, 394, 395, 396, 397, 398, 399, 400, 401, 402, 403, 404, 405, 406, 407, 408, 409, 410, 411, 412, 413, 414, 415, 416, 417, 418, 419, 420, 421, 422, 423, 424, 425, 426, 427, 428, 429, 430, 431, 432, 433, 434, 435, 436, 437, 438, 439, 440, 441, 442, 443, 444, 445, 446, 447, 448, 449, 450, 451, 452, 453, 454, 455, 456, 457, 458, 459, 460, 461, 462, 463, 464, 465, 466, 467, 468, 469, 470, 471, 472, 473, 474, 475, 476, 477, 478, 479, 480, 481, 482, 483, 484]}}, {"1": "guava/src/com/google/common/graph/Graphs.java", "added": {"2": ["   * Creates a mutable copy of {@code graph}, using the same nodes and edges.\n", "  public static <N> MutableGraph<N> copyOf(Graph<N> graph) {\n", "    MutableGraph<N> copy = GraphBuilder.from(graph)\n", "        .expectedNodeCount(graph.nodes().size())\n", "        .build();\n", "    for (N node : graph.nodes()) {\n", "      for (N successor : graph.successors(node)) {\n"], "3": ["    MutableNetwork<N, E> copy = NetworkBuilder.from(graph)\n", "        .expectedNodeCount(graph.nodes().size())\n", "        .expectedEdgeCount(graph.edges().size())\n", "        .build();\n", "    for (N node : graph.nodes()) {\n", "      copy.addNode(node);\n", "    for (E edge : graph.edges()) {\n", "      addEdge(copy, edge, graph.incidentNodes(edge));\n", "\n", "    return copy;\n"], "4": ["   * @see Graph#equals(Object)\n"]}, "removed": {"1": ["import com.google.common.base.Predicates;\n"], "2": ["   * Creates a mutable copy of {@code graph}, using the same nodes.\n", "  public static <N> MutableGraph<N> copyOf(Graph<N> graph) {\n", "    return copyOfInternal(\n", "        graph,\n", "        GraphBuilder.from(graph).expectedNodeCount(graph.nodes().size()),\n", "        Predicates.alwaysTrue());\n", "  }\n", "\n", "  private static <N> MutableGraph<N> copyOfInternal(\n", "      Graph<N> graph, GraphBuilder<N> copyBuilder, Predicate<? super N> nodePredicate) {\n", "    checkNotNull(nodePredicate, \"nodePredicate\");\n", "    MutableGraph<N> copy = copyBuilder.build();\n", "    for (N node : Sets.filter(graph.nodes(), nodePredicate)) {\n", "      for (N successor : Sets.filter(graph.successors(node), nodePredicate)) {\n"], "3": ["  /**\n", "   * Copies all nodes from {@code src} into {@code dest}.\n", "   */\n", "  public static <N> void copyNodes(Graph<N> src, MutableGraph<N> dest) {\n", "    copyNodesInternal(src, dest, Predicates.alwaysTrue());\n", "  }\n", "\n", "  private static <N, E> void copyNodesInternal(\n", "      Graph<N> src, MutableGraph<N> dest, Predicate<? super N> nodePredicate) {\n", "    checkNotNull(src, \"src\");\n", "    checkNotNull(dest, \"dest\");\n", "    checkNotNull(nodePredicate, \"nodePredicate\");\n", "    for (N node : Sets.filter(src.nodes(), nodePredicate)) {\n", "      dest.addNode(node);\n", "    }\n", "  }\n", "\n", "    return copyOfInternal(\n", "        graph,\n", "        NetworkBuilder.from(graph)\n", "            .expectedNodeCount(graph.nodes().size())\n", "            .expectedEdgeCount(graph.edges().size()),\n", "        Predicates.alwaysTrue(),\n", "        Predicates.alwaysTrue());\n", "  }\n", "\n", "  private static <N, E> MutableNetwork<N, E> copyOfInternal(\n", "      Network<N, E> graph,\n", "      NetworkBuilder<N, E> copyBuilder,\n", "      Predicate<? super N> nodePredicate,\n", "      Predicate<? super E> edgePredicate) {\n", "    checkNotNull(nodePredicate, \"nodePredicate\");\n", "    checkNotNull(edgePredicate, \"edgePredicate\");\n", "    MutableNetwork<N, E> copy = copyBuilder.build();\n", "\n", "    copyNodesInternal(graph, copy, nodePredicate);\n", "    copyEdgesInternal(graph, copy, edgePredicate);\n", "    return copy;\n", "  }\n", "\n", "  /**\n", "   * Copies all nodes from {@code src} into {@code dest}.\n", "   */\n", "  public static <N> void copyNodes(Graph<N> src, MutableNetwork<N, ?> dest) {\n", "    copyNodesInternal(src, dest, Predicates.alwaysTrue());\n", "  }\n", "\n", "  private static <N, E> void copyNodesInternal(\n", "      Graph<N> src, MutableNetwork<N, ?> dest, Predicate<? super N> nodePredicate) {\n", "    checkNotNull(src, \"src\");\n", "    checkNotNull(dest, \"dest\");\n", "    checkNotNull(nodePredicate, \"nodePredicate\");\n", "    for (N node : Sets.filter(src.nodes(), nodePredicate)) {\n", "      dest.addNode(node);\n", "  }\n", "\n", "  /**\n", "   * Copies edges from {@code src} into {@code dest}.\n", "   * <p>\n", "   * This method DOES NOT copy over edges if their incident nodes are not already in {@code dest}.\n", "   */\n", "  public static <N, E> void copyEdges(Network<N, E> src, MutableNetwork<N, E> dest) {\n", "    copyEdgesInternal(src, dest, Predicates.alwaysTrue());\n", "  }\n", "\n", "  private static <N, E> void copyEdgesInternal(\n", "      Network<N, E> src, MutableNetwork<N, E> dest, Predicate<? super E> edgePredicate) {\n", "    checkNotNull(src, \"src\");\n", "    checkNotNull(dest, \"dest\");\n", "    checkNotNull(edgePredicate, \"edgePredicate\");\n", "    for (E edge : Sets.filter(src.edges(), edgePredicate)) {\n", "      Endpoints<N> endpoints = src.incidentNodes(edge);\n", "      if (dest.nodes().containsAll(endpoints)) {\n", "        addEdge(dest, edge, endpoints);\n", "      }\n"], "4": ["   * @see Network#equals(Object)\n"]}, "added_lines": {"2": [155, 158, 163, 164, 165, 167, 169], "3": [183, 184, 185, 186, 188, 189, 191, 192, 194, 195], "4": [205]}, "removed_lines": {"1": [28], "2": [156, 158, 159, 160, 161, 162, 163, 164, 166, 167, 169, 173, 175, 177], "3": [186, 187, 188, 189, 190, 191, 192, 193, 194, 195, 196, 197, 198, 199, 200, 201, 202, 207, 208, 209, 210, 211, 212, 213, 214, 215, 216, 217, 218, 219, 220, 222, 223, 224, 225, 226, 227, 229, 230, 231, 232, 233, 234, 235, 236, 237, 238, 239, 240, 241, 242, 243, 244, 245, 247, 248, 249, 250, 251, 252, 253, 254, 255, 256, 257, 258, 259, 260, 261, 262, 263, 264, 265, 266, 267], "4": [278]}}]}
