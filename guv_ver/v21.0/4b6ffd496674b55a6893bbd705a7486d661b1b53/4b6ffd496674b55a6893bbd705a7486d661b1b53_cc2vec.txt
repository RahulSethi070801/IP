{"id": "4b6ffd496674b55a6893bbd705a7486d661b1b53", "code": [{"0": "guava-gwt/test/com/google/common/collect/IteratorsTest_gwt.java", "added": {"1": ["public void testConcatNested_appendToBeginning() throws Exception {\n", "  com.google.common.collect.IteratorsTest testCase = new com.google.common.collect.IteratorsTest();\n", "  testCase.testConcatNested_appendToBeginning();\n", "}\n", "\n", "public void testConcatNested_appendToEnd() throws Exception {\n", "  com.google.common.collect.IteratorsTest testCase = new com.google.common.collect.IteratorsTest();\n", "  testCase.testConcatNested_appendToEnd();\n", "}\n", "\n"]}, "removed": {}, "added_lines": {"1": [81, 82, 83, 84, 85, 86, 87, 88, 89, 90]}, "removed_lines": {}}, {"1": "guava-tests/test/com/google/common/collect/IteratorsTest.java", "added": {"1": ["  public void testConcatNested_appendToEnd() {\n", "    final int nestingDepth = 128;\n", "    Iterator<Integer> iterator = iterateOver();\n", "    for (int i = 0; i < nestingDepth; i++) {\n", "      iterator = Iterators.concat(iterator, iterateOver(1));\n", "    }\n", "    assertEquals(nestingDepth, Iterators.size(iterator));\n", "  }\n", "\n", "  public void testConcatNested_appendToBeginning() {\n", "    final int nestingDepth = 128;\n", "    Iterator<Integer> iterator = iterateOver();\n", "    for (int i = 0; i < nestingDepth; i++) {\n", "      iterator = Iterators.concat(iterateOver(1), iterator);\n", "    }\n", "    assertEquals(nestingDepth, Iterators.size(iterator));\n", "  }\n", "\n"]}, "removed": {}, "added_lines": {"1": [820, 821, 822, 823, 824, 825, 826, 827, 828, 829, 830, 831, 832, 833, 834, 835, 836, 837]}, "removed_lines": {}}, {"2": "guava/src/com/google/common/collect/Iterables.java", "added": {"1": ["        return Iterators.concat(Iterables.transform(inputs, Iterables.<T>toIterator()).iterator());\n"]}, "removed": {"1": ["        return Iterators.concat(iterators(inputs));\n", "      }\n", "    };\n", "  }\n", "\n", "  /**\n", "   * Returns an iterator over the iterators of the given iterables.\n", "   */\n", "  private static <T> Iterator<Iterator<? extends T>> iterators(\n", "      Iterable<? extends Iterable<? extends T>> iterables) {\n", "    return new TransformedIterator<Iterable<? extends T>, Iterator<? extends T>>(\n", "        iterables.iterator()) {\n", "      @Override\n", "      Iterator<? extends T> transform(Iterable<? extends T> from) {\n", "        return from.iterator();\n"]}, "added_lines": {"1": [505]}, "removed_lines": {"1": [505, 506, 507, 508, 509, 510, 511, 512, 513, 514, 515, 516, 517, 518, 519]}}, {"3": "guava/src/com/google/common/collect/Iterators.java", "added": {"5": ["  public static <T> Iterator<T> concat(Iterator<? extends Iterator<? extends T>> inputs) {\n", "    return new ConcatenatedIterator<T>(inputs);\n"], "6": ["  private static class ConcatenatedIterator<T>\n", "      extends MultitransformedIterator<Iterator<? extends T>, T>  {\n", "\n", "    public ConcatenatedIterator(Iterator<? extends Iterator<? extends T>> iterators) {\n", "      super(getComponentIterators(iterators));\n", "    }\n", "\n", "    @Override\n", "    Iterator<? extends T> transform(Iterator<? extends T> iterator) {\n", "      return iterator;\n", "    }\n", "\n", "    /**\n", "     * Using the component iterators, rather than the input iterators directly,\n", "     * allows for higher performance in the case of nested concatenation.\n", "     */\n", "    private static <T> Iterator<Iterator<? extends T>> getComponentIterators(\n", "        Iterator<? extends Iterator<? extends T>> iterators) {\n", "      return new MultitransformedIterator<Iterator<? extends T>, Iterator<? extends T>>(iterators) {\n", "        @Override\n", "        Iterator<? extends Iterator<? extends T>> transform(Iterator<? extends T> iterator) {\n", "          if (iterator instanceof ConcatenatedIterator) {\n", "            ConcatenatedIterator<? extends T> concatIterator =\n", "                (ConcatenatedIterator<? extends T>) iterator;\n", "            return getComponentIterators(concatIterator.backingIterator);\n", "          } else {\n", "            return Iterators.singletonIterator(iterator);\n", "          }\n", "        }\n", "      };\n", "    }\n", "  }\n", "\n"]}, "removed": {"1": ["   *\n", "   * <p><b>Note:</b> the current implementation is not suitable for nested\n", "   * concatenated iterators, i.e. the following should be avoided when in a loop:\n", "   * {@code iterator = Iterators.concat(iterator, suffix);}, since iteration over the\n", "   * resulting iterator has a cubic complexity to the depth of the nesting.\n"], "2": ["   *\n", "   * <p><b>Note:</b> the current implementation is not suitable for nested\n", "   * concatenated iterators, i.e. the following should be avoided when in a loop:\n", "   * {@code iterator = Iterators.concat(iterator, suffix);}, since iteration over the\n", "   * resulting iterator has a cubic complexity to the depth of the nesting.\n"], "3": ["   *\n", "   * <p><b>Note:</b> the current implementation is not suitable for nested\n", "   * concatenated iterators, i.e. the following should be avoided when in a loop:\n", "   * {@code iterator = Iterators.concat(iterator, suffix);}, since iteration over the\n", "   * resulting iterator has a cubic complexity to the depth of the nesting.\n"], "4": ["   * <p><b>Note:</b> the current implementation is not suitable for nested\n", "   * concatenated iterators, i.e. the following should be avoided when in a loop:\n", "   * {@code iterator = Iterators.concat(iterator, suffix);}, since iteration over the\n", "   * resulting iterator has a cubic complexity to the depth of the nesting.\n", "   *\n"], "5": ["   *\n", "   * <p><b>Note:</b> the current implementation is not suitable for nested\n", "   * concatenated iterators, i.e. the following should be avoided when in a loop:\n", "   * {@code iterator = Iterators.concat(iterator, suffix);}, since iteration over the\n", "   * resulting iterator has a cubic complexity to the depth of the nesting.\n", "  public static <T> Iterator<T> concat(final Iterator<? extends Iterator<? extends T>> inputs) {\n", "    checkNotNull(inputs);\n", "    return new Iterator<T>() {\n", "      Iterator<? extends T> current = emptyIterator();\n", "      Iterator<? extends T> removeFrom;\n", "\n", "      @Override\n", "      public boolean hasNext() {\n", "        // http://code.google.com/p/google-collections/issues/detail?id=151\n", "        // current.hasNext() might be relatively expensive, worth minimizing.\n", "        boolean currentHasNext;\n", "        // checkNotNull eager for GWT\n", "        // note: it must be here & not where 'current' is assigned,\n", "        // because otherwise we'll have called inputs.next() before throwing\n", "        // the first NPE, and the next time around we'll call inputs.next()\n", "        // again, incorrectly moving beyond the error.\n", "        while (!(currentHasNext = checkNotNull(current).hasNext()) && inputs.hasNext()) {\n", "          current = inputs.next();\n", "        }\n", "        return currentHasNext;\n", "      }\n", "\n", "      @Override\n", "      public T next() {\n", "        if (!hasNext()) {\n", "          throw new NoSuchElementException();\n", "        }\n", "        removeFrom = current;\n", "        return current.next();\n", "      }\n", "\n", "      @Override\n", "      public void remove() {\n", "        checkRemove(removeFrom != null);\n", "        removeFrom.remove();\n", "        removeFrom = null;\n", "      }\n", "    };\n"]}, "added_lines": {"5": [527, 528], "6": [1271, 1272, 1273, 1274, 1275, 1276, 1277, 1278, 1279, 1280, 1281, 1282, 1283, 1284, 1285, 1286, 1287, 1288, 1289, 1290, 1291, 1292, 1293, 1294, 1295, 1296, 1297, 1298, 1299, 1300, 1301, 1302, 1303]}, "removed_lines": {"1": [456, 457, 458, 459, 460], "2": [476, 477, 478, 479, 480], "3": [498, 499, 500, 501, 502], "4": [524, 525, 526, 527, 528], "5": [546, 547, 548, 549, 550, 552, 553, 554, 555, 556, 557, 558, 559, 560, 561, 562, 563, 564, 565, 566, 567, 568, 569, 570, 571, 572, 573, 574, 575, 576, 577, 578, 579, 580, 581, 582, 583, 584, 585, 586, 587, 588, 589]}}, {"4": "guava/src/com/google/common/collect/MultitransformedIterator.java", "added": {"1": ["/*\n", " * Copyright (C) 2016 The Guava Authors\n", " *\n", " * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not use this file except\n", " * in compliance with the License. You may obtain a copy of the License at\n", " *\n", " * http://www.apache.org/licenses/LICENSE-2.0\n", " *\n", " * Unless required by applicable law or agreed to in writing, software distributed under the License\n", " * is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express\n", " * or implied. See the License for the specific language governing permissions and limitations under\n", " * the License.\n", " */\n", "\n", "package com.google.common.collect;\n", "\n", "import static com.google.common.base.Preconditions.checkNotNull;\n", "import static com.google.common.collect.CollectPreconditions.checkRemove;\n", "\n", "import com.google.common.annotations.GwtCompatible;\n", "\n", "import java.util.Iterator;\n", "import java.util.NoSuchElementException;\n", "\n", "/**\n", " * Similar to {@link TransformedIterator}, this iterator transforms a backing iterator.\n", " * However, rather than enforcing a one-to-one mapping, each element in the backing iterator\n", " * can be transformed into an arbitrary number of elements (i.e. a one-to-many mapping).\n", " *\n", " * @author James Sexton\n", " */\n", "@GwtCompatible\n", "abstract class MultitransformedIterator<F, T>  implements Iterator<T> {\n", "  final Iterator<? extends F> backingIterator;\n", "\n", "  private Iterator<? extends T> current = Iterators.emptyIterator();\n", "  private Iterator<? extends T> removeFrom;\n", "\n", "  MultitransformedIterator(Iterator<? extends F> backingIterator) {\n", "    this.backingIterator = checkNotNull(backingIterator);\n", "  }\n", "\n", "  abstract Iterator<? extends T> transform(F from);\n", "\n", "  @Override\n", "  public boolean hasNext() {\n", "    checkNotNull(current); // eager for GWT\n", "    if (current.hasNext()) {\n", "      return true;\n", "    }\n", "    while (backingIterator.hasNext()) {\n", "      // checkNotNull the assignment, so that current is null even if the exception is caught\n", "      checkNotNull(current = transform(backingIterator.next()));\n", "      if (current.hasNext()) {\n", "        return true;\n", "      }\n", "    }\n", "    return false;\n", "  }\n", "\n", "  @Override\n", "  public T next() {\n", "    if (!hasNext()) {\n", "      throw new NoSuchElementException();\n", "    }\n", "    removeFrom = current;\n", "    return current.next();\n", "  }\n", "\n", "  @Override\n", "  public void remove() {\n", "    checkRemove(removeFrom != null);\n", "    removeFrom.remove();\n", "    removeFrom = null;\n", "  }\n", "}\n"]}, "removed": {}, "added_lines": {"1": [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 58, 59, 60, 61, 62, 63, 64, 65, 66, 67, 68, 69, 70, 71, 72, 73, 74, 75, 76]}, "removed_lines": {}}, {"5": "guava/src/com/google/common/collect/Sets.java", "added": {}, "removed": {"1": ["   *\n", "   * <p>Further, note that the current implementation is not suitable for nested\n", "   * {@code union} views, i.e. the following should be avoided when in a loop:\n", "   * {@code union = Sets.union(union, anotherSet);}, since iterating over the resulting\n", "   * set has a cubic complexity to the depth of the nesting.\n"]}, "added_lines": {}, "removed_lines": {"1": [591, 592, 593, 594, 595]}}]}
