{"id": "f02ea7e285d73bb13fe02a4a05802b4710fa3d44", "code": [{"0": "guava-tests/test/com/google/common/graph/GraphsTest.java", "added": {"1": ["    directedGraph.putEdge(N1, N3);\n", "    expectedTranspose.putEdge(N3, N1);\n"], "2": ["    directedGraph.putEdgeValue(N1, N3, E13);\n"], "3": ["    expectedTranspose.putEdgeValue(N3, N1, E13);\n"], "4": ["    assertThat(transpose.edgeValueOrDefault(N1, N2, null)).isNull();\n", "    assertThat(transpose.edgeValueOrDefault(N1, N2, null)).isEqualTo(E21);\n"], "5": ["        NetworkBuilder.directed().allowsParallelEdges(true).allowsSelfLoops(true).build();\n", "    directedGraph.addEdge(N1, N3, E13);\n", "    directedGraph.addEdge(N1, N2, E12_A);\n", "        NetworkBuilder.directed().allowsParallelEdges(true).allowsSelfLoops(true).build();\n", "    expectedTranspose.addEdge(N3, N1, E13);\n", "    expectedTranspose.addEdge(N2, N1, E12_A);\n"]}, "removed": {"4": ["    EndpointPair<Integer> pair12 = EndpointPair.ordered(N1, N2);\n", "    assertThat(transpose.edgeValues().get(pair12)).isNull();\n", "    assertThat(transpose.edgeValues().get(pair12)).isEqualTo(E21);\n"], "5": ["        NetworkBuilder.directed().allowsSelfLoops(true).build();\n", "        NetworkBuilder.directed().allowsSelfLoops(true).build();\n"]}, "added_lines": {"1": [215, 222], "2": [252], "3": [260], "4": [271, 274], "5": [289, 290, 293, 298, 299, 302]}, "removed_lines": {"4": [267, 268, 271], "5": [286, 293]}}, {"1": "guava-tests/test/com/google/common/graph/ValueGraphTest.java", "added": {"2": ["        boolean connected = graph.successors(node).contains(otherNode);\n", "        assertThat(graph.edgeValueOrDefault(node, otherNode, null) != null).isEqualTo(connected);\n"], "3": ["  public void edgeValueOrDefault() {\n", "    assertThat(graph.edgeValueOrDefault(1, 2, \"default\")).isEqualTo(\"default\");\n", "    assertThat(graph.edgeValueOrDefault(2, 1, \"default\")).isEqualTo(\"default\");\n", "    assertThat(graph.edgeValueOrDefault(1, 2, \"default\")).isEqualTo(\"valueA\");\n", "    assertThat(graph.edgeValueOrDefault(2, 1, \"default\")).isEqualTo(\"valueB\");\n", "    assertThat(graph.edgeValueOrDefault(1, 2, \"default\")).isEqualTo(\"default\");\n", "    assertThat(graph.edgeValueOrDefault(2, 1, \"default\")).isEqualTo(\"valueC\");\n"]}, "removed": {"1": ["import java.util.Map;\n"], "2": ["    assertThat(graph.edgeValues().keySet()).isEqualTo(graph.edges());\n", "\n", "        EndpointPair<Integer> endpointPair = EndpointPair.of(graph, node, otherNode);\n", "        if (graph.successors(node).contains(otherNode)) {\n", "          String value = graph.edgeValue(node, otherNode);\n", "          assertThat(value).isNotNull();\n", "          assertThat(value).isEqualTo(graph.edgeValues().get(endpointPair));\n", "        } else {\n", "          assertThat(graph.edgeValues()).doesNotContainKey(endpointPair);\n", "        }\n"], "3": ["  public void edgeValues() {\n", "    Map<EndpointPair<Integer>, String> edgeValues = graph.edgeValues();\n", "    EndpointPair<Integer> pair12 = EndpointPair.ordered(1, 2);\n", "    EndpointPair<Integer> pair21 = EndpointPair.ordered(2, 1);\n", "    graph.addNode(1);\n", "    graph.addNode(2);\n", "    assertThat(edgeValues).doesNotContainKey(pair12);\n", "    assertThat(edgeValues).doesNotContainKey(pair21);\n", "    assertThat(edgeValues.get(pair12)).isEqualTo(\"valueA\");\n", "    assertThat(edgeValues.get(pair21)).isEqualTo(\"valueB\");\n", "    assertThat(edgeValues).doesNotContainKey(pair12);\n", "    assertThat(edgeValues.get(pair21)).isEqualTo(\"valueC\");\n", "\n", "    try {\n", "      edgeValues.put(pair12, \"valueA\");\n", "      fail(\"Map returned by edgeValues() should be unmodifiable\");\n", "    } catch (UnsupportedOperationException expected) {\n", "    }\n"]}, "added_lines": {"2": [41, 42], "3": [166, 169, 170, 174, 175, 179, 180]}, "removed_lines": {"1": [23], "2": [40, 41, 44, 45, 46, 47, 48, 49, 50, 51], "3": [175, 177, 178, 179, 181, 182, 183, 184, 188, 189, 193, 194, 195, 196, 197, 198, 199, 200]}}, {"2": "guava/src/com/google/common/graph/AbstractValueGraph.java", "added": {"1": ["import static com.google.common.base.Preconditions.checkNotNull;\n", "import javax.annotation.Nullable;\n"], "2": ["  public V edgeValueOrDefault(Object nodeU, Object nodeV, @Nullable V defaultValue) {\n", "    checkNotNull(nodeU);\n", "    checkNotNull(nodeV);\n", "    boolean connected = nodes().contains(nodeU) && successors(nodeU).contains(nodeV);\n", "    return connected ? edgeValue(nodeU, nodeV) : defaultValue;\n"], "3": ["    return String.format(GRAPH_STRING_FORMAT, propertiesString, nodes(), edgeValueMap());\n", "  }\n", "\n", "  private Map<EndpointPair<N>, V> edgeValueMap() {\n", "    Function<EndpointPair<N>, V> edgeToValueFn =\n", "        new Function<EndpointPair<N>, V>() {\n", "          @Override\n", "          public V apply(EndpointPair<N> edge) {\n", "            return edgeValue(edge.nodeU(), edge.nodeV());\n", "          }\n", "        };\n", "    return Maps.asMap(edges(), edgeToValueFn);\n"]}, "removed": {"2": ["  private transient Map<EndpointPair<N>, V> edgeValueMap;\n", "\n", "  public Map<EndpointPair<N>, V> edgeValues() {\n", "    if (edgeValueMap == null) {\n", "      Function<EndpointPair<N>, V> edgeToValueFn =\n", "          new Function<EndpointPair<N>, V>() {\n", "            @Override\n", "            public V apply(EndpointPair<N> edge) {\n", "              return edgeValue(edge.nodeU(), edge.nodeV());\n", "            }\n", "          };\n", "      edgeValueMap = Maps.asMap(edges(), edgeToValueFn);\n", "    }\n", "    return edgeValueMap;\n"], "3": ["    return String.format(GRAPH_STRING_FORMAT, propertiesString, nodes(), edgeValues());\n"]}, "added_lines": {"1": [19, 26], "2": [42, 43, 44, 45, 46], "3": [54, 55, 56, 57, 58, 59, 60, 61, 62, 63, 64, 65]}, "removed_lines": {"2": [39, 40, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51, 52, 53], "3": [61]}}, {"3": "guava/src/com/google/common/graph/Graphs.java", "added": {"1": ["    if (graphA.isDirected() != graphB.isDirected()\n", "        || !graphA.nodes().equals(graphB.nodes())\n", "        || !graphA.edges().equals(graphB.edges())) {\n", "      return false;\n", "    }\n", "\n", "    for (EndpointPair<?> edge : graphA.edges()) {\n", "      if (!graphA\n", "          .edgeValue(edge.nodeU(), edge.nodeV())\n", "          .equals(graphB.edgeValue(edge.nodeU(), edge.nodeV()))) {\n", "        return false;\n", "      }\n", "    }\n", "\n", "    return true;\n"], "2": ["    @Override\n", "    public V edgeValueOrDefault(Object nodeU, Object nodeV, @Nullable V defaultValue) {\n", "      return graph.edgeValueOrDefault(nodeV, nodeU, defaultValue); // transpose\n", "    }\n"]}, "removed": {"1": ["    return graphA.isDirected() == graphB.isDirected()\n", "        && graphA.nodes().equals(graphB.nodes())\n", "        && graphA.edgeValues().equals(graphB.edgeValues());\n"], "2": ["    // Defer to AbstractValueGraph for edgeValues() implementation based on edgeValue().\n"]}, "added_lines": {"1": [273, 274, 275, 276, 277, 278, 279, 280, 281, 282, 283, 284, 285, 286, 287], "2": [478, 479, 480, 481]}, "removed_lines": {"1": [273, 274, 275], "2": [466]}}, {"4": "guava/src/com/google/common/graph/ImmutableValueGraph.java", "added": {"1": ["import javax.annotation.Nullable;\n"], "2": ["  public V edgeValueOrDefault(Object nodeU, Object nodeV, @Nullable V defaultValue) {\n", "    return backingValueGraph.edgeValueOrDefault(nodeU, nodeV, defaultValue);\n"]}, "removed": {"1": ["import java.util.Map;\n"], "2": ["  public Map<EndpointPair<N>, V> edgeValues() {\n", "    return backingValueGraph.edgeValues();\n"]}, "added_lines": {"1": [26], "2": [99, 100]}, "removed_lines": {"1": [26], "2": [99, 100]}}, {"5": "guava/src/com/google/common/graph/ValueGraph.java", "added": {"1": ["   * @throws IllegalArgumentException if there is no edge connecting {@code nodeU} to {@code nodeV}.\n", "   * If there is an edge connecting {@code nodeU} to {@code nodeV}, returns the non-null value\n", "   * associated with that edge; otherwise, returns {@code defaultValue}.\n", "   * <p>In an undirected graph, this is equal to {@code edgeValueOrDefault(nodeV, nodeU,\n", "   * defaultValue)}.\n", "  V edgeValueOrDefault(Object nodeU, Object nodeV, @Nullable V defaultValue);\n"]}, "removed": {"1": ["   * @throws IllegalArgumentException if there is no edge connecting {@code nodeU} to {@code nodeV},\n", "   *     or if {@code nodeU} or {@code nodeV} is not an element of this graph\n", "   * Returns a {@link Map} of all {@link #edges() edges} mapped to their associated {@link\n", "   * #edgeValue(Object, Object) value}.\n", "   * <p>Note: {@link Map#get(Object)} returns null if you supply an {@link EndpointPair} whose nodes\n", "   * are not connected in this graph. This contrasts with the behavior of {@link #edgeValue(Object,\n", "   * Object)}, which throws {@link IllegalArgumentException} in that case.\n", "  Map<EndpointPair<N>, V> edgeValues();\n"]}, "added_lines": {"1": [116, 121, 122, 124, 125, 127]}, "removed_lines": {"1": [116, 117, 122, 123, 125, 126, 127, 129]}}]}
