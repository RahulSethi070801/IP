{"id": "9d2a5e9beaf310d81134e3629e5ffec1854f420c", "code": [{"0": "guava/src/com/google/common/graph/AbstractDirectedNodeConnections.java", "added": {"1": ["import static com.google.common.base.Preconditions.checkState;\n", "import com.google.common.collect.Iterables;\n", "import com.google.common.math.IntMath;\n", "import java.util.AbstractSet;\n", "import java.util.Iterator;\n"], "2": ["  private int selfLoopCount;\n", "\n", "  protected AbstractDirectedNodeConnections(Map<E, N> inEdgeMap, Map<E, N> outEdgeMap,\n", "      int selfLoopCount) {\n", "    this.selfLoopCount = selfLoopCount;\n"], "3": ["    return new AbstractSet<E>() {\n", "      @Override\n", "      public Iterator<E> iterator() {\n", "        return selfLoopCount == 0\n", "            ? Iterables.concat(inEdges(), outEdges()).iterator()\n", "            : Sets.union(inEdges(), outEdges()).iterator();\n", "      }\n", "\n", "      @Override\n", "      public int size() {\n", "        return IntMath.saturatedAdd(inEdgeMap.size() - selfLoopCount, outEdgeMap.size());\n", "      }\n", "\n", "      @Override\n", "      public boolean contains(Object obj) {\n", "        return inEdgeMap.containsKey(obj) || outEdgeMap.containsKey(obj);\n", "      }\n", "    };\n"], "4": ["  public N removeInEdge(Object edge, boolean isSelfLoop) {\n", "    if (isSelfLoop) {\n", "      selfLoopCount--;\n", "      checkState(selfLoopCount >= 0);\n", "    }\n"], "5": ["  public boolean addInEdge(E edge, N node, boolean isSelfLoop) {\n", "    if (isSelfLoop) {\n", "      selfLoopCount++;\n", "      checkState(selfLoopCount >= 1);\n", "    }\n", "      checkState(node.equals(previousNode));\n"], "6": ["      checkState(node.equals(previousNode));\n"]}, "removed": {"1": ["import static com.google.common.base.Preconditions.checkArgument;\n"], "2": ["  protected AbstractDirectedNodeConnections(Map<E, N> inEdgeMap, Map<E, N> outEdgeMap) {\n"], "3": ["    return Sets.union(inEdges(), outEdges());\n"], "4": ["  public N removeInEdge(Object edge) {\n"], "5": ["  public boolean addInEdge(E edge, N node) {\n", "      checkArgument(node.equals(previousNode));\n"], "6": ["      checkArgument(node.equals(previousNode));\n"]}, "added_lines": {"1": [20, 22, 24, 26, 28], "2": [50, 51, 52, 53, 56], "3": [66, 67, 68, 69, 70, 71, 72, 73, 74, 75, 76, 77, 78, 79, 80, 81, 82, 83], "4": [104, 106, 107, 108, 109], "5": [120, 123, 124, 125, 126, 129], "6": [141]}, "removed_lines": {"1": [19], "2": [46], "3": [58], "4": [79], "5": [91, 96], "6": [108]}}, {"1": "guava/src/com/google/common/graph/AbstractUndirectedNodeConnections.java", "added": {"1": ["  public N removeInEdge(Object edge, boolean isSelfLoop) {\n", "    if (isSelfLoop) {\n", "      return null;\n", "    }\n"], "2": ["  public boolean addInEdge(E edge, N node, boolean isSelfLoop) {\n", "    if (isSelfLoop) {\n", "      return false;\n", "    }\n"]}, "removed": {"1": ["  public N removeInEdge(Object edge) {\n"], "2": ["  public boolean addInEdge(E edge, N node) {\n"]}, "added_lines": {"1": [74, 75, 76, 77], "2": [88, 89, 90, 91]}, "removed_lines": {"1": [74], "2": [85]}}, {"2": "guava/src/com/google/common/graph/ConfigurableMutableGraph.java", "added": {"2": ["    NodeAdjacencies<N> connectionsB = isSelfLoop ? connectionsA : nodeConnections.get(nodeB);\n", "      connectionsB = addNodeInternal(nodeB);\n"]}, "removed": {"1": ["    NodeAdjacencies<N> connectionsB = nodeConnections.get(nodeB);\n"], "2": ["      connectionsB = isSelfLoop ? connectionsA : addNodeInternal(nodeB);\n"]}, "added_lines": {"2": [100, 102]}, "removed_lines": {"1": [91], "2": [102]}}, {"3": "guava/src/com/google/common/graph/ConfigurableMutableNetwork.java", "added": {"2": ["    NodeConnections<N, E> connectionsB = isSelfLoop ? connectionsA : nodeConnections.get(nodeB);\n", "      connectionsB = addNodeInternal(nodeB);\n", "    connectionsB.addInEdge(edge, nodeA, isSelfLoop);\n"], "3": ["    boolean isSelfLoop = allowsSelfLoops() && nodeA.equals(nodeB);\n", "    NodeConnections<N, E> connectionsB = isSelfLoop ? connectionsA : nodeConnections.get(nodeB);\n", "    connectionsB.removeInEdge(edge, isSelfLoop);\n"]}, "removed": {"1": ["    NodeConnections<N, E> connectionsB = nodeConnections.get(nodeB);\n"], "2": ["      connectionsB = isSelfLoop ? connectionsA : addNodeInternal(nodeB);\n", "    connectionsB.addInEdge(edge, nodeA);\n"], "3": ["    NodeConnections<N, E> connectionsB = nodeConnections.get(nodeB);\n", "    connectionsB.removeInEdge(edge);\n"]}, "added_lines": {"2": [112, 114, 116], "3": [148, 149, 151]}, "removed_lines": {"1": [103], "2": [114, 116], "3": [148, 150]}}, {"4": "guava/src/com/google/common/graph/DirectedMultiNodeConnections.java", "added": {"1": ["  private DirectedMultiNodeConnections(Map<E, N> inEdges, Map<E, N> outEdges, int selfLoopCount) {\n", "    super(inEdges, outEdges, selfLoopCount);\n", "        Maps.<E, N>newHashMapWithExpectedSize(EXPECTED_DEGREE),\n", "        0);\n", "      Map<E, N> inEdges, Map<E, N> outEdges, int selfLoopCount) {\n", "        ImmutableMap.copyOf(inEdges), ImmutableMap.copyOf(outEdges), selfLoopCount);\n"], "2": ["  public N removeInEdge(Object edge, boolean isSelfLoop) {\n", "    N node = super.removeInEdge(edge, isSelfLoop);\n"], "3": ["  public boolean addInEdge(E edge, N node, boolean isSelfLoop) {\n", "    if (super.addInEdge(edge, node, isSelfLoop)) {\n"]}, "removed": {"1": ["  private DirectedMultiNodeConnections(Map<E, N> inEdges, Map<E, N> outEdges) {\n", "    super(inEdges, outEdges);\n", "        Maps.<E, N>newHashMapWithExpectedSize(EXPECTED_DEGREE));\n", "      Map<E, N> inEdges, Map<E, N> outEdges) {\n", "        ImmutableMap.copyOf(inEdges), ImmutableMap.copyOf(outEdges));\n"], "2": ["  public N removeInEdge(Object edge) {\n", "    N node = super.removeInEdge(edge);\n"], "3": ["  public boolean addInEdge(E edge, N node) {\n", "    if (super.addInEdge(edge, node)) {\n"]}, "added_lines": {"1": [46, 47, 53, 54, 58, 60], "2": [99, 100], "3": [123, 124]}, "removed_lines": {"1": [46, 47, 53, 57, 59], "2": [98, 99], "3": [122, 123]}}, {"5": "guava/src/com/google/common/graph/DirectedNodeConnections.java", "added": {"1": ["  protected DirectedNodeConnections(Map<E, N> inEdgeMap, Map<E, N> outEdgeMap, int selfLoopCount) {\n", "    super(inEdgeMap, outEdgeMap, selfLoopCount);\n", "        HashBiMap.<E, N>create(EXPECTED_DEGREE), HashBiMap.<E, N>create(EXPECTED_DEGREE), 0);\n", "  static <N, E> DirectedNodeConnections<N, E> ofImmutable(Map<E, N> inEdges, Map<E, N> outEdges,\n", "      int selfLoopCount) {\n", "        ImmutableBiMap.copyOf(inEdges), ImmutableBiMap.copyOf(outEdges), selfLoopCount);\n"]}, "removed": {"1": ["  protected DirectedNodeConnections(Map<E, N> inEdgeMap, Map<E, N> outEdgeMap) {\n", "    super(inEdgeMap, outEdgeMap);\n", "        HashBiMap.<E, N>create(EXPECTED_DEGREE), HashBiMap.<E, N>create(EXPECTED_DEGREE));\n", "  static <N, E> DirectedNodeConnections<N, E> ofImmutable(Map<E, N> inEdges, Map<E, N> outEdges) {\n", "        ImmutableBiMap.copyOf(inEdges), ImmutableBiMap.copyOf(outEdges));\n"]}, "added_lines": {"1": [38, 39, 44, 47, 48, 50]}, "removed_lines": {"1": [38, 39, 44, 47, 49]}}, {"6": "guava/src/com/google/common/graph/ImmutableNetwork.java", "added": {"1": ["import com.google.common.collect.Sets;\n"], "2": ["      int selfLoopCount = graph.allowsSelfLoops()\n", "          ? Sets.intersection(inEdgeMap.keySet(), outEdgeMap.keySet()).size()\n", "          : 0;\n", "           ? DirectedMultiNodeConnections.ofImmutable(inEdgeMap, outEdgeMap, selfLoopCount)\n", "           : DirectedNodeConnections.ofImmutable(inEdgeMap, outEdgeMap, selfLoopCount);\n"]}, "removed": {"2": ["           ? DirectedMultiNodeConnections.ofImmutable(inEdgeMap, outEdgeMap)\n", "           : DirectedNodeConnections.ofImmutable(inEdgeMap, outEdgeMap);\n"]}, "added_lines": {"1": [26], "2": [101, 102, 103, 105, 106]}, "removed_lines": {"2": [101, 102]}}, {"7": "guava/src/com/google/common/graph/NodeConnections.java", "added": {"1": ["   * Remove {@code edge} from the set of incoming edges. Returns the former predecessor node,\n", "   * or null if the edge did not exist.\n", "  N removeInEdge(Object edge, boolean isSelfLoop);\n", "   * Remove {@code edge} from the set of outgoing edges. Returns the former successor node,\n", "   * or null if the edge did not exist.\n", "   * Returns false if the edge already existed.\n", "  boolean addInEdge(E edge, N node, boolean isSelfLoop);\n", "   * Returns false if the edge already existed.\n"]}, "removed": {"1": ["   * Remove {@code edge} from the set of incoming edges. Returns the former predecessor node.\n", "  N removeInEdge(Object edge);\n", "   * Remove {@code edge} from the set of outgoing edges. Returns the former successor node.\n", "   * Returns true if the edge did not already exist.\n", "  boolean addInEdge(E edge, N node);\n", "   * Returns true if the edge did not already exist.\n"]}, "added_lines": {"1": [57, 58, 61, 64, 65, 72, 75, 79]}, "removed_lines": {"1": [57, 60, 63, 70, 73, 77]}}, {"8": "guava/src/com/google/common/graph/UndirectedMultiNodeConnections.java", "added": {"1": ["  public N removeInEdge(Object edge, boolean isSelfLoop) {\n", "    if (isSelfLoop) {\n", "      return null;\n", "    }\n"], "2": ["  public boolean addInEdge(E edge, N node, boolean isSelfLoop) {\n", "    if (isSelfLoop) {\n", "      return false;\n", "    }\n"]}, "removed": {"1": ["  public N removeInEdge(Object edge) {\n"], "2": ["  public boolean addInEdge(E edge, N node) {\n"]}, "added_lines": {"1": [83, 84, 85, 86], "2": [103, 104, 105, 106]}, "removed_lines": {"1": [83], "2": [100]}}]}
