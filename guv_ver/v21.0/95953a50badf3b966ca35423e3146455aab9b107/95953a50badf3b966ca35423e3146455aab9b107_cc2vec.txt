{"id": "95953a50badf3b966ca35423e3146455aab9b107", "code": [{"0": "guava-gwt/src-super/com/google/common/util/concurrent/super/com/google/common/util/concurrent/AbstractFuture.java", "added": {"1": ["import static com.google.common.util.concurrent.Futures.getDone;\n"], "2": ["    /*\n", "     * We don't need to override any of methods that we override in the prod version (and in fact we\n", "     * can't) because they are already final.\n", "     */\n"], "3": ["  /*\n", "   * TODO(cpovirk): Consider making cancel() final (under GWT only, since we can't change the\n", "   * server) by migrating our overrides to use afterDone().\n", "   */\n"], "4": ["  public final boolean isCancelled() {\n", "  public final boolean isDone() {\n", "  /*\n", "   * We let people override {@code get()} in the server version (though perhaps we shouldn't). Here,\n", "   * we don't want that, and anyway, users can't, thanks to the package-private parameter.\n", "   */\n", "  public final V get() throws InterruptedException, ExecutionException {\n", "  public final V get(long timeout, TimeUnit unit)\n", "  public final void addListener(Runnable runnable, Executor executor) {\n"], "5": ["      if (delegate instanceof AbstractFuture) {\n"], "6": ["      /*\n", "       * Almost everything in GWT is an AbstractFuture (which is as good as TrustedFuture under\n", "       * GWT). But ImmediateFuture and UncheckedThrowingFuture aren't, so we still need this case.\n", "       */\n", "        forceSet(getDone(delegate));\n"]}, "removed": {"1": ["import static com.google.common.util.concurrent.Uninterruptibles.getUninterruptibly;\n"], "2": ["    @Override public final V get() throws InterruptedException, ExecutionException {\n", "      return super.get();\n", "    }\n", "\n", "    @Override public final V get(long timeout, TimeUnit unit)\n", "        throws InterruptedException, ExecutionException, TimeoutException {\n", "      return super.get(timeout, unit);\n", "    }\n", "\n", "    @Override public final boolean isDone() {\n", "      return super.isDone();\n", "    }\n", "\n", "    @Override public final boolean isCancelled() {\n", "      return super.isCancelled();\n", "    }\n", "\n", "    @Override public final void addListener(Runnable listener, Executor executor) {\n", "      super.addListener(listener, executor);\n", "    }\n"], "4": ["  public boolean isCancelled() {\n", "  public boolean isDone() {\n", "  public V get() throws InterruptedException, ExecutionException {\n", "  public V get(long timeout, TimeUnit unit)\n", "  public void addListener(Runnable runnable, Executor executor) {\n"], "5": ["      if (delegate instanceof TrustedFuture) {\n"], "6": ["        forceSet(getUninterruptibly(delegate));\n"]}, "added_lines": {"1": [21], "2": [43, 44, 45, 46], "3": [63, 64, 65, 66], "4": [87, 92, 96, 97, 98, 99, 101, 107, 114], "5": [298], "6": [309, 310, 311, 312, 314]}, "removed_lines": {"1": [22], "2": [43, 44, 45, 46, 47, 48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 58, 59, 60, 61, 62], "4": [99, 104, 109, 115, 122], "5": [306], "6": [318]}}, {"1": "guava-gwt/test/com/google/common/util/concurrent/TrustedInputFutureTest_gwt.java", "added": {}, "removed": {"1": ["public void testSetFutureDelegateAlreadyInterrupted() throws Exception {\n", "  com.google.common.util.concurrent.TrustedInputFutureTest testCase = new com.google.common.util.concurrent.TrustedInputFutureTest();\n", "  testCase.setUp();\n", "  testCase.testSetFutureDelegateAlreadyInterrupted();\n", "}\n", "\n"], "2": ["public void testSetFutureDelegateLaterInterrupted() throws Exception {\n", "  com.google.common.util.concurrent.TrustedInputFutureTest testCase = new com.google.common.util.concurrent.TrustedInputFutureTest();\n", "  testCase.setUp();\n", "  testCase.testSetFutureDelegateLaterInterrupted();\n", "}\n", "\n"]}, "added_lines": {}, "removed_lines": {"1": [159, 160, 161, 162, 163, 164], "2": [177, 178, 179, 180, 181, 182]}}, {"2": "guava-gwt/test/com/google/common/util/concurrent/UntrustedInputFutureTest_gwt.java", "added": {}, "removed": {"1": ["public void testSetFutureDelegateAlreadyInterrupted() throws Exception {\n", "  com.google.common.util.concurrent.UntrustedInputFutureTest testCase = new com.google.common.util.concurrent.UntrustedInputFutureTest();\n", "  testCase.setUp();\n", "  testCase.testSetFutureDelegateAlreadyInterrupted();\n", "}\n", "\n"], "2": ["public void testSetFutureDelegateLaterInterrupted() throws Exception {\n", "  com.google.common.util.concurrent.UntrustedInputFutureTest testCase = new com.google.common.util.concurrent.UntrustedInputFutureTest();\n", "  testCase.setUp();\n", "  testCase.testSetFutureDelegateLaterInterrupted();\n", "}\n", "\n"]}, "added_lines": {}, "removed_lines": {"1": [159, 160, 161, 162, 163, 164], "2": [177, 178, 179, 180, 181, 182]}}, {"3": "guava-tests/test/com/google/common/util/concurrent/AbstractAbstractFutureTest.java", "added": {"1": ["  @GwtIncompatible // All GWT Futures behaves like TrustedFuture.\n"], "2": ["  @GwtIncompatible // All GWT Futures behaves like TrustedFuture.\n"]}, "removed": {}, "added_lines": {"1": [126], "2": [138]}, "removed_lines": {}}, {"4": "guava/src/com/google/common/util/concurrent/ImmediateFuture.java", "added": {"2": ["    // TODO(lukes): Consider throwing InterruptedException when appropriate.\n"]}, "removed": {"1": ["  /*\n", "   * TODO(lukes): Use AbstractFuture.TrustedFuture instead of special classes so that get() throws\n", "   * InterruptedException when appropriate, and, more importantly for failed/cancelled Futures, we\n", "   * can take advantage of the TrustedFuture optimizations.\n", "   */\n"]}, "added_lines": {"2": [87]}, "removed_lines": {"1": [36, 37, 38, 39, 40]}}]}
