{
    "addition": {
        "39": " * An expanded {@code Iterable} API, providing functionality similar to Java 8's powerful <a href=\n",
        "40": " * \"https://docs.oracle.com/javase/8/docs/api/java/util/stream/package-summary.html#package.description\"\n",
        "41": " * >streams library</a> in a slightly different way.\n",
        "42": " *\n",
        "43": " * <p>The following types of methods are provided:\n",
        "44": " *\n",
        "46": " * <li>chaining methods which return a new {@code FluentIterable} based in some way on the contents\n",
        "47": " *     of the current one (for example {@link #transform})\n",
        "49": " *     {@link #last})\n",
        "51": " *     {@link #anyMatch})\n",
        "52": " * <li>conversion methods which copy the {@code FluentIterable}'s contents into a new collection or\n",
        "53": " *     array (for example {@link #toList})\n",
        "54": " * </ul>\n",
        "55": " *\n",
        "56": " * <p>Several lesser-used features are currently available only as static methods on the {@link\n",
        "57": " * Iterables} class.\n",
        "58": " *\n",
        "59": " * <a name=\"streams\"></a>\n",
        "60": " * <h3>Comparison to streams</h3>\n",
        "61": " *\n",
        "62": " * <p>Starting with Java 8, the core Java class libraries provide a new \"Streams\" library (in {@code\n",
        "63": " * java.util.stream}), which is similar to {@code FluentIterable} but generally more powerful. Key\n",
        "64": " * differences include:</b>\n",
        "65": " *\n",
        "66": " * <ul>\n",
        "67": " * <li>A stream is <i>single-use</i>; it becomes invalid as soon as any \"terminal operation\" such as\n",
        "68": " *     {@code findFirst()} or {@code iterator()} is invoked. (Even though {@code Stream} contains\n",
        "69": " *     all the right method <i>signatures</i> to implement {@link Iterable}, it does not actually\n",
        "70": " *     do so, to avoid implying repeat-iterability.) {@code FluentIterable}, on the other hand, is\n",
        "71": " *     multiple-use, and does implement {@link Iterable}.\n",
        "72": " * <li>Streams offer many features not found here, including {@code min/max}, {@code\n",
        "73": " *     distinct}, {@code reduce}, {@code sorted}, the very powerful {@code collect}, and built-in\n",
        "74": " *     support for parallelizing stream operations.\n",
        "75": " * <li>{@code FluentIterable} contains several features not available on {@code Stream}, which are\n",
        "76": " *     noted in the method descriptions below.\n",
        "77": " * <li>Streams include primitive-specialized variants such as {@code IntStream}, the use of which is\n",
        "78": " *     strongly recommended.\n",
        "79": " * <li>Streams are standard Java, not requiring a third-party dependency (but do render your code\n",
        "80": " *     incompatible with Java 7 and earlier).\n",
        "83": " * <h3>Example</h3>\n",
        "84": " *\n",
        "87": " * as a {@code List}: <pre>   {@code\n",
        "88": " *\n",
        "89": " *   List<String> results =\n",
        "90": " *       FluentIterable.from(database.getClientList())\n",
        "91": " *           .filter(activeInLastMonthPredicate)\n",
        "92": " *           .transform(Functions.toStringFunction())\n",
        "93": " *           .limit(10)\n",
        "94": " *           .toList();}</pre>\n",
        "96": " * The approximate stream equivalent is: <pre>   {@code\n",
        "98": " *   List<String> results =\n",
        "99": " *       database.getClientList()\n",
        "100": " *           .stream()\n",
        "101": " *           .filter(activeInLastMonthPredicate)\n",
        "102": " *           .map(Functions.toStringFunction())\n",
        "103": " *           .limit(10)\n",
        "104": " *           .collect(Collectors.toList());}</pre>\n",
        "127": "   *\n",
        "128": "   * <p><b>{@code Stream} equivalent:</b> {@code iterable.stream()} if {@code iterable} is a\n",
        "129": "   * {@link Collection}; {@code StreamSupport.stream(iterable.spliterator(), false)} otherwise.\n",
        "160": "   * <p><b>{@code Stream} equivalent:</b> {@code Stream.of(elements)} or {@code\n",
        "161": "   * Arrays.stream(elements)}.\n",
        "162": "   *\n",
        "174": "   *\n",
        "175": "   * <p><b>{@code Stream} equivalent:</b> {@code stream.collect(Collectors.joining(\", \", \"[\", \"]\"))}\n",
        "176": "   * or (less efficiently) {@code collect(Collectors.toList()).toString()}.\n",
        "186": "   *\n",
        "187": "   * <p><b>{@code Stream} equivalent:</b> {@code stream.count()}.\n",
        "196": "   * {@code equals(target)} is true.\n",
        "197": "   *\n",
        "198": "   * <p><b>{@code Stream} equivalent:</b> {@code stream.anyMatch(Predicate.isEqual(target))}\n",
        "201": "  public final boolean contains(@Nullable Object target) {\n",
        "202": "    return Iterables.contains(iterable, target);\n",
        "217": "   *\n",
        "218": "   * <p><b>{@code Stream} equivalent:</b> if this iterable has only a single element {@code\n",
        "219": "   * element}, use {@code Stream.generate(() -> element}. Otherwise there is no simple replacement.\n",
        "233": "   * <p><b>{@code Stream} equivalent:</b> {@code Stream.concat(thisStream, otherStream)}.\n",
        "234": "   *\n",
        "247": "   * <p><b>{@code Stream} equivalent:</b> {@code Stream.concat(thisStream, Stream.of(elements))}.\n",
        "248": "   *\n",
        "260": "   *\n",
        "261": "   * <p><b>{@code Stream} equivalent:</b> {@code stream.filter(predicate)} (same).\n",
        "270": "   *\n",
        "271": "   * <p><b>{@code Stream} equivalent:</b> {@code stream.anyMatch(predicate)} (same).\n",
        "281": "   *\n",
        "282": "   * <p><b>{@code Stream} equivalent:</b> {@code stream.allMatch(predicate)} (same).\n",
        "295": "   *\n",
        "296": "   * <p><b>{@code Stream} equivalent:</b> {@code stream.filter(predicate).findFirst()}.\n",
        "310": "   *\n",
        "311": "   * <p><b>{@code Stream} equivalent:</b> {@code stream.map(function)}.\n",
        "327": "   * <p><b>{@code Stream} equivalent:</b> {@code stream.flatMap(function)} (using a function that\n",
        "328": "   * produces streams, not iterables).\n",
        "329": "   *\n",
        "342": "   * <p><b>{@code Stream} equivalent:</b> if the goal is to obtain any element, {@code\n",
        "343": "   * stream.findAny()}; if it must specifically be the <i>first</i> element, {@code\n",
        "344": "   * stream.findFirst()}.\n",
        "345": "   *\n",
        "361": "   * <p><b>{@code Stream} equivalent:</b> {@code stream.reduce((a, b) -> b)}\n",
        "362": "   *\n",
        "417": "   *\n",
        "418": "   * <p><b>{@code Stream} equivalent:</b> {@code stream.skip(numberToSkip)} (same)\n",
        "432": "   * <p><b>{@code Stream} equivalent:</b> {@code stream.limit(maxSize)} (same)\n",
        "433": "   *\n",
        "434": "   * @param maxSize the maximum number of elements in the returned fluent iterable\n",
        "438": "  public final FluentIterable<E> limit(int maxSize) {\n",
        "439": "    return from(Iterables.limit(iterable, maxSize));\n",
        "444": "   *\n",
        "445": "   * <p><b>{@code Stream} equivalent:</b> {@code !stream.findAny().isPresent()}\n",
        "456": "   * <p><b>{@code Stream} equivalent:</b> {@code ImmutableList.copyOf(stream.iterator())}\n",
        "457": "   *\n",
        "470": "   * <p><b>{@code Stream} equivalent:</b>\n",
        "471": "   * {@code ImmutableList.copyOf(stream.sorted(comparator).iterator())}\n",
        "472": "   *\n",
        "486": "   * <p><b>{@code Stream} equivalent:</b> {@code ImmutableSet.copyOf(stream.iterator())}\n",
        "487": "   *\n",
        "501": "   * <p><b>{@code Stream} equivalent:</b>\n",
        "502": "   * {@code ImmutableSortedSet.copyOf(comparator, stream.iterator())}\n",
        "503": "   *\n",
        "516": "   * <p><b>{@code Stream} equivalent:</b> {@code ImmutableMultiset.copyOf(stream.iterator())}\n",
        "517": "   *\n",
        "534": "   * <p><b>{@code Stream} equivalent:</b> TODO (note that Collectors.toMap would trash the order...)\n",
        "535": "   *\n",
        "585": "   * <p><b>{@code Stream} equivalent:</b> TODO\n",
        "586": "   *\n"
    },
    "removed": {
        "39": " * {@code FluentIterable} provides a rich interface for manipulating {@code Iterable} instances in a\n",
        "40": " * chained fashion. A {@code FluentIterable} can be created from an {@code Iterable}, or from a set\n",
        "41": " * of elements. The following types of methods are provided on {@code FluentIterable}:\n",
        "43": " * <li>chained methods which return a new {@code FluentIterable} based in some way on the contents\n",
        "44": " * of the current one (for example {@link #transform})\n",
        "45": " * <li>conversion methods which copy the {@code FluentIterable}'s contents into a new collection or\n",
        "46": " * array (for example {@link #toList})\n",
        "48": " * {@link #last})\n",
        "50": " * {@link #anyMatch})\n",
        "55": " * as an {@code ImmutableList}: <pre>   {@code\n",
        "57": " *   FluentIterable\n",
        "58": " *       .from(database.getClientList())\n",
        "59": " *       .filter(activeInLastMonth)\n",
        "60": " *       .transform(Functions.toStringFunction())\n",
        "61": " *       .limit(10)\n",
        "62": " *       .toList();}</pre>\n",
        "64": " * <p>Anything which can be done using {@code FluentIterable} could be done in a different fashion\n",
        "65": " * (often with {@link Iterables}), however the use of {@code FluentIterable} makes many sets of\n",
        "66": " * operations significantly more concise.\n",
        "147": "   * {@code equals(element)} is true.\n",
        "150": "  public final boolean contains(@Nullable Object element) {\n",
        "151": "    return Iterables.contains(iterable, element);\n",
        "353": "   * @param size the maximum number of elements in the returned fluent iterable\n",
        "357": "  public final FluentIterable<E> limit(int size) {\n",
        "358": "    return from(Iterables.limit(iterable, size));\n"
    }
}