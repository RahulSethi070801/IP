{
    "addition": {
        "40": " * An expanded {@code Iterable} API, providing functionality similar to Java 8's powerful <a href=\n",
        "41": " * \"https://docs.oracle.com/javase/8/docs/api/java/util/stream/package-summary.html#package.description\"\n",
        "42": " * >streams library</a> in a slightly different way.\n",
        "43": " *\n",
        "44": " * <p>The following types of methods are provided:\n",
        "45": " *\n",
        "47": " * <li>chaining methods which return a new {@code FluentIterable} based in some way on the contents\n",
        "48": " *     of the current one (for example {@link #transform})\n",
        "50": " *     {@link #last})\n",
        "52": " *     {@link #anyMatch})\n",
        "53": " * <li>conversion methods which copy the {@code FluentIterable}'s contents into a new collection or\n",
        "54": " *     array (for example {@link #toList})\n",
        "57": " * <p>Several lesser-used features are currently available only as static methods on the {@link\n",
        "58": " * Iterables} class.\n",
        "59": " *\n",
        "60": " * <a name=\"streams\"></a>\n",
        "61": " * <h3>Comparison to streams</h3>\n",
        "62": " *\n",
        "63": " * <p>Starting with Java 8, the core Java class libraries provide a new \"Streams\" library (in {@code\n",
        "64": " * java.util.stream}), which is similar to {@code FluentIterable} but generally more powerful. Key\n",
        "65": " * differences include:</b>\n",
        "66": " *\n",
        "67": " * <ul>\n",
        "68": " * <li>A stream is <i>single-use</i>; it becomes invalid as soon as any \"terminal operation\" such as\n",
        "69": " *     {@code findFirst()} or {@code iterator()} is invoked. (Even though {@code Stream} contains\n",
        "70": " *     all the right method <i>signatures</i> to implement {@link Iterable}, it does not actually\n",
        "71": " *     do so, to avoid implying repeat-iterability.) {@code FluentIterable}, on the other hand, is\n",
        "72": " *     multiple-use, and does implement {@link Iterable}.\n",
        "73": " * <li>Streams offer many features not found here, including {@code min/max}, {@code\n",
        "74": " *     distinct}, {@code reduce}, {@code sorted}, the very powerful {@code collect}, and built-in\n",
        "75": " *     support for parallelizing stream operations.\n",
        "76": " * <li>{@code FluentIterable} contains several features not available on {@code Stream}, which are\n",
        "77": " *     noted in the method descriptions below.\n",
        "78": " * <li>Streams include primitive-specialized variants such as {@code IntStream}, the use of which is\n",
        "79": " *     strongly recommended.\n",
        "80": " * <li>Streams are standard Java, not requiring a third-party dependency (but do render your code\n",
        "81": " *     incompatible with Java 7 and earlier).\n",
        "82": " * </ul>\n",
        "83": " *\n",
        "84": " * <h3>Example</h3>\n",
        "85": " *\n",
        "88": " * as a {@code List}: <pre>   {@code\n",
        "90": " *   List<String> results =\n",
        "91": " *       FluentIterable.from(database.getClientList())\n",
        "92": " *           .filter(activeInLastMonthPredicate)\n",
        "93": " *           .transform(Functions.toStringFunction())\n",
        "94": " *           .limit(10)\n",
        "95": " *           .toList();}</pre>\n",
        "97": " * The approximate stream equivalent is: <pre>   {@code\n",
        "98": " *\n",
        "99": " *   List<String> results =\n",
        "100": " *       database.getClientList()\n",
        "101": " *           .stream()\n",
        "102": " *           .filter(activeInLastMonthPredicate)\n",
        "103": " *           .map(Functions.toStringFunction())\n",
        "104": " *           .limit(10)\n",
        "105": " *           .collect(Collectors.toList());}</pre>\n",
        "128": "   *\n",
        "129": "   * <p><b>{@code Stream} equivalent:</b> {@code iterable.stream()} if {@code iterable} is a\n",
        "130": "   * {@link Collection}; {@code StreamSupport.stream(iterable.spliterator(), false)} otherwise.\n",
        "161": "   * <p><b>{@code Stream} equivalent:</b> {@code Stream.of(elements)} or {@code\n",
        "162": "   * Arrays.stream(elements)}.\n",
        "163": "   *\n",
        "175": "   *\n",
        "176": "   * <p><b>{@code Stream} equivalent:</b> {@code stream.collect(Collectors.joining(\", \", \"[\", \"]\"))}\n",
        "177": "   * or (less efficiently) {@code collect(Collectors.toList()).toString()}.\n",
        "187": "   *\n",
        "188": "   * <p><b>{@code Stream} equivalent:</b> {@code stream.count()}.\n",
        "197": "   * {@code equals(target)} is true.\n",
        "198": "   *\n",
        "199": "   * <p><b>{@code Stream} equivalent:</b> {@code stream.anyMatch(Predicate.isEqual(target))}\n",
        "202": "  public final boolean contains(@Nullable Object target) {\n",
        "203": "    return Iterables.contains(iterable, target);\n",
        "218": "   *\n",
        "219": "   * <p><b>{@code Stream} equivalent:</b> if this iterable has only a single element {@code\n",
        "220": "   * element}, use {@code Stream.generate(() -> element}. Otherwise there is no simple replacement.\n",
        "234": "   * <p><b>{@code Stream} equivalent:</b> {@code Stream.concat(thisStream, otherStream)}.\n",
        "235": "   *\n",
        "248": "   * <p><b>{@code Stream} equivalent:</b> {@code Stream.concat(thisStream, Stream.of(elements))}.\n",
        "249": "   *\n",
        "261": "   *\n",
        "262": "   * <p><b>{@code Stream} equivalent:</b> {@code stream.filter(predicate)} (same).\n",
        "273": "   *\n",
        "274": "   * <p><b>{@code Stream} equivalent:</b> <pre>   {@code\n",
        "275": "   *\n",
        "276": "   *   @SuppressWarnings(\"unchecked\") // safe by runtime check\n",
        "277": "   *   Stream<T> result = (Stream) stream.filter(type::isInstance);}</pre>\n",
        "278": "   *\n",
        "279": "   * ... or if {@code type} is a class literal {@code MyType.class}, <pre>   {@code\n",
        "280": "   *\n",
        "281": "   *   @SuppressWarnings(\"unchecked\") // safe by runtime check\n",
        "282": "   *   Stream<MyType> result = (Stream) stream.filter(e -> e instanceof MyType);}</pre>\n",
        "292": "   *\n",
        "293": "   * <p><b>{@code Stream} equivalent:</b> {@code stream.anyMatch(predicate)} (same).\n",
        "303": "   *\n",
        "304": "   * <p><b>{@code Stream} equivalent:</b> {@code stream.allMatch(predicate)} (same).\n",
        "317": "   *\n",
        "318": "   * <p><b>{@code Stream} equivalent:</b> {@code stream.filter(predicate).findFirst()}.\n",
        "332": "   *\n",
        "333": "   * <p><b>{@code Stream} equivalent:</b> {@code stream.map(function)}.\n",
        "349": "   * <p><b>{@code Stream} equivalent:</b> {@code stream.flatMap(function)} (using a function that\n",
        "350": "   * produces streams, not iterables).\n",
        "351": "   *\n",
        "364": "   * <p><b>{@code Stream} equivalent:</b> if the goal is to obtain any element, {@code\n",
        "365": "   * stream.findAny()}; if it must specifically be the <i>first</i> element, {@code\n",
        "366": "   * stream.findFirst()}.\n",
        "367": "   *\n",
        "383": "   * <p><b>{@code Stream} equivalent:</b> {@code stream.reduce((a, b) -> b)}\n",
        "384": "   *\n",
        "439": "   *\n",
        "440": "   * <p><b>{@code Stream} equivalent:</b> {@code stream.skip(numberToSkip)} (same)\n",
        "454": "   * <p><b>{@code Stream} equivalent:</b> {@code stream.limit(maxSize)} (same)\n",
        "455": "   *\n",
        "456": "   * @param maxSize the maximum number of elements in the returned fluent iterable\n",
        "460": "  public final FluentIterable<E> limit(int maxSize) {\n",
        "461": "    return from(Iterables.limit(iterable, maxSize));\n",
        "466": "   *\n",
        "467": "   * <p><b>{@code Stream} equivalent:</b> {@code !stream.findAny().isPresent()}\n",
        "478": "   * <p><b>{@code Stream} equivalent:</b> {@code ImmutableList.copyOf(stream.iterator())}\n",
        "479": "   *\n",
        "492": "   * <p><b>{@code Stream} equivalent:</b>\n",
        "493": "   * {@code ImmutableList.copyOf(stream.sorted(comparator).iterator())}\n",
        "494": "   *\n",
        "508": "   * <p><b>{@code Stream} equivalent:</b> {@code ImmutableSet.copyOf(stream.iterator())}\n",
        "509": "   *\n",
        "523": "   * <p><b>{@code Stream} equivalent:</b>\n",
        "524": "   * {@code ImmutableSortedSet.copyOf(comparator, stream.iterator())}\n",
        "525": "   *\n",
        "538": "   * <p><b>{@code Stream} equivalent:</b> {@code ImmutableMultiset.copyOf(stream.iterator())}\n",
        "539": "   *\n",
        "556": "   * <p><b>{@code Stream} equivalent:</b> TODO (note that Collectors.toMap would trash the order...)\n",
        "557": "   *\n",
        "607": "   * <p><b>{@code Stream} equivalent:</b> TODO\n",
        "608": "   *\n"
    },
    "removed": {
        "40": " * {@code FluentIterable} provides a rich interface for manipulating {@code Iterable} instances in a\n",
        "41": " * chained fashion. A {@code FluentIterable} can be created from an {@code Iterable}, or from a set\n",
        "42": " * of elements. The following types of methods are provided on {@code FluentIterable}:\n",
        "44": " * <li>chained methods which return a new {@code FluentIterable} based in some way on the contents\n",
        "45": " * of the current one (for example {@link #transform})\n",
        "46": " * <li>conversion methods which copy the {@code FluentIterable}'s contents into a new collection or\n",
        "47": " * array (for example {@link #toList})\n",
        "49": " * {@link #last})\n",
        "51": " * {@link #anyMatch})\n",
        "56": " * as an {@code ImmutableList}: <pre>   {@code\n",
        "58": " *   FluentIterable\n",
        "59": " *       .from(database.getClientList())\n",
        "60": " *       .filter(activeInLastMonth)\n",
        "61": " *       .transform(Functions.toStringFunction())\n",
        "62": " *       .limit(10)\n",
        "63": " *       .toList();}</pre>\n",
        "65": " * <p>Anything which can be done using {@code FluentIterable} could be done in a different fashion\n",
        "66": " * (often with {@link Iterables}), however the use of {@code FluentIterable} makes many sets of\n",
        "67": " * operations significantly more concise.\n",
        "148": "   * {@code equals(element)} is true.\n",
        "151": "  public final boolean contains(@Nullable Object element) {\n",
        "152": "    return Iterables.contains(iterable, element);\n",
        "365": "   * @param size the maximum number of elements in the returned fluent iterable\n",
        "369": "  public final FluentIterable<E> limit(int size) {\n",
        "370": "    return from(Iterables.limit(iterable, size));\n"
    }
}