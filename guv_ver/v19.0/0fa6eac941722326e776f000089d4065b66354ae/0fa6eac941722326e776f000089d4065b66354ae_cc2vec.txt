{"id": "0fa6eac941722326e776f000089d4065b66354ae", "code": [{"0": "guava-gwt/src-super/com/google/common/collect/super/com/google/common/collect/FluentIterable.java", "added": {"1": [" * An expanded {@code Iterable} API, providing functionality similar to Java 8's powerful <a href=\n", " * \"https://docs.oracle.com/javase/8/docs/api/java/util/stream/package-summary.html#package.description\"\n", " * >streams library</a> in a slightly different way.\n", " *\n", " * <p>The following types of methods are provided:\n", " *\n", " * <li>chaining methods which return a new {@code FluentIterable} based in some way on the contents\n", " *     of the current one (for example {@link #transform})\n", " *     {@link #last})\n", " *     {@link #anyMatch})\n", " * <li>conversion methods which copy the {@code FluentIterable}'s contents into a new collection or\n", " *     array (for example {@link #toList})\n", " * </ul>\n", " *\n", " * <p>Several lesser-used features are currently available only as static methods on the {@link\n", " * Iterables} class.\n", " *\n", " * <a name=\"streams\"></a>\n", " * <h3>Comparison to streams</h3>\n", " *\n", " * <p>Starting with Java 8, the core Java class libraries provide a new \"Streams\" library (in {@code\n", " * java.util.stream}), which is similar to {@code FluentIterable} but generally more powerful. Key\n", " * differences include:</b>\n", " *\n", " * <ul>\n", " * <li>A stream is <i>single-use</i>; it becomes invalid as soon as any \"terminal operation\" such as\n", " *     {@code findFirst()} or {@code iterator()} is invoked. (Even though {@code Stream} contains\n", " *     all the right method <i>signatures</i> to implement {@link Iterable}, it does not actually\n", " *     do so, to avoid implying repeat-iterability.) {@code FluentIterable}, on the other hand, is\n", " *     multiple-use, and does implement {@link Iterable}.\n", " * <li>Streams offer many features not found here, including {@code min/max}, {@code\n", " *     distinct}, {@code reduce}, {@code sorted}, the very powerful {@code collect}, and built-in\n", " *     support for parallelizing stream operations.\n", " * <li>{@code FluentIterable} contains several features not available on {@code Stream}, which are\n", " *     noted in the method descriptions below.\n", " * <li>Streams include primitive-specialized variants such as {@code IntStream}, the use of which is\n", " *     strongly recommended.\n", " * <li>Streams are standard Java, not requiring a third-party dependency (but do render your code\n", " *     incompatible with Java 7 and earlier).\n", " * <h3>Example</h3>\n", " *\n", " * as a {@code List}: <pre>   {@code\n", " *\n", " *   List<String> results =\n", " *       FluentIterable.from(database.getClientList())\n", " *           .filter(activeInLastMonthPredicate)\n", " *           .transform(Functions.toStringFunction())\n", " *           .limit(10)\n", " *           .toList();}</pre>\n", " * The approximate stream equivalent is: <pre>   {@code\n", " *   List<String> results =\n", " *       database.getClientList()\n", " *           .stream()\n", " *           .filter(activeInLastMonthPredicate)\n", " *           .map(Functions.toStringFunction())\n", " *           .limit(10)\n", " *           .collect(Collectors.toList());}</pre>\n"], "2": ["   *\n", "   * <p><b>{@code Stream} equivalent:</b> {@code iterable.stream()} if {@code iterable} is a\n", "   * {@link Collection}; {@code StreamSupport.stream(iterable.spliterator(), false)} otherwise.\n"], "3": ["   * <p><b>{@code Stream} equivalent:</b> {@code Stream.of(elements)} or {@code\n", "   * Arrays.stream(elements)}.\n", "   *\n"], "4": ["   *\n", "   * <p><b>{@code Stream} equivalent:</b> {@code stream.collect(Collectors.joining(\", \", \"[\", \"]\"))}\n", "   * or (less efficiently) {@code collect(Collectors.toList()).toString()}.\n"], "5": ["   *\n", "   * <p><b>{@code Stream} equivalent:</b> {@code stream.count()}.\n"], "6": ["   * {@code equals(target)} is true.\n", "   *\n", "   * <p><b>{@code Stream} equivalent:</b> {@code stream.anyMatch(Predicate.isEqual(target))}\n", "  public final boolean contains(@Nullable Object target) {\n", "    return Iterables.contains(iterable, target);\n"], "7": ["   *\n", "   * <p><b>{@code Stream} equivalent:</b> if this iterable has only a single element {@code\n", "   * element}, use {@code Stream.generate(() -> element}. Otherwise there is no simple replacement.\n"], "8": ["   * <p><b>{@code Stream} equivalent:</b> {@code Stream.concat(thisStream, otherStream)}.\n", "   *\n"], "9": ["   * <p><b>{@code Stream} equivalent:</b> {@code Stream.concat(thisStream, Stream.of(elements))}.\n", "   *\n"], "10": ["   *\n", "   * <p><b>{@code Stream} equivalent:</b> {@code stream.filter(predicate)} (same).\n"], "11": ["   *\n", "   * <p><b>{@code Stream} equivalent:</b> {@code stream.anyMatch(predicate)} (same).\n"], "12": ["   *\n", "   * <p><b>{@code Stream} equivalent:</b> {@code stream.allMatch(predicate)} (same).\n"], "13": ["   *\n", "   * <p><b>{@code Stream} equivalent:</b> {@code stream.filter(predicate).findFirst()}.\n"], "14": ["   *\n", "   * <p><b>{@code Stream} equivalent:</b> {@code stream.map(function)}.\n"], "15": ["   * <p><b>{@code Stream} equivalent:</b> {@code stream.flatMap(function)} (using a function that\n", "   * produces streams, not iterables).\n", "   *\n"], "16": ["   * <p><b>{@code Stream} equivalent:</b> if the goal is to obtain any element, {@code\n", "   * stream.findAny()}; if it must specifically be the <i>first</i> element, {@code\n", "   * stream.findFirst()}.\n", "   *\n"], "17": ["   * <p><b>{@code Stream} equivalent:</b> {@code stream.reduce((a, b) -> b)}\n", "   *\n"], "18": ["   *\n", "   * <p><b>{@code Stream} equivalent:</b> {@code stream.skip(numberToSkip)} (same)\n"], "19": ["   * <p><b>{@code Stream} equivalent:</b> {@code stream.limit(maxSize)} (same)\n", "   *\n", "   * @param maxSize the maximum number of elements in the returned fluent iterable\n", "  public final FluentIterable<E> limit(int maxSize) {\n", "    return from(Iterables.limit(iterable, maxSize));\n", "   *\n", "   * <p><b>{@code Stream} equivalent:</b> {@code !stream.findAny().isPresent()}\n"], "20": ["   * <p><b>{@code Stream} equivalent:</b> {@code ImmutableList.copyOf(stream.iterator())}\n", "   *\n"], "21": ["   * <p><b>{@code Stream} equivalent:</b>\n", "   * {@code ImmutableList.copyOf(stream.sorted(comparator).iterator())}\n", "   *\n"], "22": ["   * <p><b>{@code Stream} equivalent:</b> {@code ImmutableSet.copyOf(stream.iterator())}\n", "   *\n"], "23": ["   * <p><b>{@code Stream} equivalent:</b>\n", "   * {@code ImmutableSortedSet.copyOf(comparator, stream.iterator())}\n", "   *\n"], "24": ["   * <p><b>{@code Stream} equivalent:</b> {@code ImmutableMultiset.copyOf(stream.iterator())}\n", "   *\n"], "25": ["   * <p><b>{@code Stream} equivalent:</b> TODO (note that Collectors.toMap would trash the order...)\n", "   *\n"], "26": ["   * <p><b>{@code Stream} equivalent:</b> TODO\n", "   *\n"]}, "removed": {"1": [" * {@code FluentIterable} provides a rich interface for manipulating {@code Iterable} instances in a\n", " * chained fashion. A {@code FluentIterable} can be created from an {@code Iterable}, or from a set\n", " * of elements. The following types of methods are provided on {@code FluentIterable}:\n", " * <li>chained methods which return a new {@code FluentIterable} based in some way on the contents\n", " * of the current one (for example {@link #transform})\n", " * <li>conversion methods which copy the {@code FluentIterable}'s contents into a new collection or\n", " * array (for example {@link #toList})\n", " * {@link #last})\n", " * {@link #anyMatch})\n", " * as an {@code ImmutableList}: <pre>   {@code\n", " *   FluentIterable\n", " *       .from(database.getClientList())\n", " *       .filter(activeInLastMonth)\n", " *       .transform(Functions.toStringFunction())\n", " *       .limit(10)\n", " *       .toList();}</pre>\n", " * <p>Anything which can be done using {@code FluentIterable} could be done in a different fashion\n", " * (often with {@link Iterables}), however the use of {@code FluentIterable} makes many sets of\n", " * operations significantly more concise.\n"], "6": ["   * {@code equals(element)} is true.\n", "  public final boolean contains(@Nullable Object element) {\n", "    return Iterables.contains(iterable, element);\n"], "19": ["   * @param size the maximum number of elements in the returned fluent iterable\n", "  public final FluentIterable<E> limit(int size) {\n", "    return from(Iterables.limit(iterable, size));\n"]}, "added_lines": {"1": [39, 40, 41, 42, 43, 44, 46, 47, 49, 51, 52, 53, 54, 55, 56, 57, 58, 59, 60, 61, 62, 63, 64, 65, 66, 67, 68, 69, 70, 71, 72, 73, 74, 75, 76, 77, 78, 79, 80, 83, 84, 87, 88, 89, 90, 91, 92, 93, 94, 96, 98, 99, 100, 101, 102, 103, 104], "2": [127, 128, 129], "3": [160, 161, 162], "4": [174, 175, 176], "5": [186, 187], "6": [196, 197, 198, 201, 202], "7": [217, 218, 219], "8": [233, 234], "9": [247, 248], "10": [260, 261], "11": [270, 271], "12": [281, 282], "13": [295, 296], "14": [310, 311], "15": [327, 328, 329], "16": [342, 343, 344, 345], "17": [361, 362], "18": [417, 418], "19": [432, 433, 434, 438, 439, 444, 445], "20": [456, 457], "21": [470, 471, 472], "22": [486, 487], "23": [501, 502, 503], "24": [516, 517], "25": [534, 535], "26": [585, 586]}, "removed_lines": {"1": [39, 40, 41, 43, 44, 45, 46, 48, 50, 55, 57, 58, 59, 60, 61, 62, 64, 65, 66], "6": [147, 150, 151], "19": [353, 357, 358]}}, {"1": "guava/src/com/google/common/collect/FluentIterable.java", "added": {"1": [" * An expanded {@code Iterable} API, providing functionality similar to Java 8's powerful <a href=\n", " * \"https://docs.oracle.com/javase/8/docs/api/java/util/stream/package-summary.html#package.description\"\n", " * >streams library</a> in a slightly different way.\n", " *\n", " * <p>The following types of methods are provided:\n", " *\n", " * <li>chaining methods which return a new {@code FluentIterable} based in some way on the contents\n", " *     of the current one (for example {@link #transform})\n", " *     {@link #last})\n", " *     {@link #anyMatch})\n", " * <li>conversion methods which copy the {@code FluentIterable}'s contents into a new collection or\n", " *     array (for example {@link #toList})\n", " * <p>Several lesser-used features are currently available only as static methods on the {@link\n", " * Iterables} class.\n", " *\n", " * <a name=\"streams\"></a>\n", " * <h3>Comparison to streams</h3>\n", " *\n", " * <p>Starting with Java 8, the core Java class libraries provide a new \"Streams\" library (in {@code\n", " * java.util.stream}), which is similar to {@code FluentIterable} but generally more powerful. Key\n", " * differences include:</b>\n", " *\n", " * <ul>\n", " * <li>A stream is <i>single-use</i>; it becomes invalid as soon as any \"terminal operation\" such as\n", " *     {@code findFirst()} or {@code iterator()} is invoked. (Even though {@code Stream} contains\n", " *     all the right method <i>signatures</i> to implement {@link Iterable}, it does not actually\n", " *     do so, to avoid implying repeat-iterability.) {@code FluentIterable}, on the other hand, is\n", " *     multiple-use, and does implement {@link Iterable}.\n", " * <li>Streams offer many features not found here, including {@code min/max}, {@code\n", " *     distinct}, {@code reduce}, {@code sorted}, the very powerful {@code collect}, and built-in\n", " *     support for parallelizing stream operations.\n", " * <li>{@code FluentIterable} contains several features not available on {@code Stream}, which are\n", " *     noted in the method descriptions below.\n", " * <li>Streams include primitive-specialized variants such as {@code IntStream}, the use of which is\n", " *     strongly recommended.\n", " * <li>Streams are standard Java, not requiring a third-party dependency (but do render your code\n", " *     incompatible with Java 7 and earlier).\n", " * </ul>\n", " *\n", " * <h3>Example</h3>\n", " *\n", " * as a {@code List}: <pre>   {@code\n", " *   List<String> results =\n", " *       FluentIterable.from(database.getClientList())\n", " *           .filter(activeInLastMonthPredicate)\n", " *           .transform(Functions.toStringFunction())\n", " *           .limit(10)\n", " *           .toList();}</pre>\n", " * The approximate stream equivalent is: <pre>   {@code\n", " *\n", " *   List<String> results =\n", " *       database.getClientList()\n", " *           .stream()\n", " *           .filter(activeInLastMonthPredicate)\n", " *           .map(Functions.toStringFunction())\n", " *           .limit(10)\n", " *           .collect(Collectors.toList());}</pre>\n"], "2": ["   *\n", "   * <p><b>{@code Stream} equivalent:</b> {@code iterable.stream()} if {@code iterable} is a\n", "   * {@link Collection}; {@code StreamSupport.stream(iterable.spliterator(), false)} otherwise.\n"], "3": ["   * <p><b>{@code Stream} equivalent:</b> {@code Stream.of(elements)} or {@code\n", "   * Arrays.stream(elements)}.\n", "   *\n"], "4": ["   *\n", "   * <p><b>{@code Stream} equivalent:</b> {@code stream.collect(Collectors.joining(\", \", \"[\", \"]\"))}\n", "   * or (less efficiently) {@code collect(Collectors.toList()).toString()}.\n"], "5": ["   *\n", "   * <p><b>{@code Stream} equivalent:</b> {@code stream.count()}.\n"], "6": ["   * {@code equals(target)} is true.\n", "   *\n", "   * <p><b>{@code Stream} equivalent:</b> {@code stream.anyMatch(Predicate.isEqual(target))}\n", "  public final boolean contains(@Nullable Object target) {\n", "    return Iterables.contains(iterable, target);\n"], "7": ["   *\n", "   * <p><b>{@code Stream} equivalent:</b> if this iterable has only a single element {@code\n", "   * element}, use {@code Stream.generate(() -> element}. Otherwise there is no simple replacement.\n"], "8": ["   * <p><b>{@code Stream} equivalent:</b> {@code Stream.concat(thisStream, otherStream)}.\n", "   *\n"], "9": ["   * <p><b>{@code Stream} equivalent:</b> {@code Stream.concat(thisStream, Stream.of(elements))}.\n", "   *\n"], "10": ["   *\n", "   * <p><b>{@code Stream} equivalent:</b> {@code stream.filter(predicate)} (same).\n"], "11": ["   *\n", "   * <p><b>{@code Stream} equivalent:</b> <pre>   {@code\n", "   *\n", "   *   @SuppressWarnings(\"unchecked\") // safe by runtime check\n", "   *   Stream<T> result = (Stream) stream.filter(type::isInstance);}</pre>\n", "   *\n", "   * ... or if {@code type} is a class literal {@code MyType.class}, <pre>   {@code\n", "   *\n", "   *   @SuppressWarnings(\"unchecked\") // safe by runtime check\n", "   *   Stream<MyType> result = (Stream) stream.filter(e -> e instanceof MyType);}</pre>\n"], "12": ["   *\n", "   * <p><b>{@code Stream} equivalent:</b> {@code stream.anyMatch(predicate)} (same).\n"], "13": ["   *\n", "   * <p><b>{@code Stream} equivalent:</b> {@code stream.allMatch(predicate)} (same).\n"], "14": ["   *\n", "   * <p><b>{@code Stream} equivalent:</b> {@code stream.filter(predicate).findFirst()}.\n"], "15": ["   *\n", "   * <p><b>{@code Stream} equivalent:</b> {@code stream.map(function)}.\n"], "16": ["   * <p><b>{@code Stream} equivalent:</b> {@code stream.flatMap(function)} (using a function that\n", "   * produces streams, not iterables).\n", "   *\n"], "17": ["   * <p><b>{@code Stream} equivalent:</b> if the goal is to obtain any element, {@code\n", "   * stream.findAny()}; if it must specifically be the <i>first</i> element, {@code\n", "   * stream.findFirst()}.\n", "   *\n"], "18": ["   * <p><b>{@code Stream} equivalent:</b> {@code stream.reduce((a, b) -> b)}\n", "   *\n"], "19": ["   *\n", "   * <p><b>{@code Stream} equivalent:</b> {@code stream.skip(numberToSkip)} (same)\n"], "20": ["   * <p><b>{@code Stream} equivalent:</b> {@code stream.limit(maxSize)} (same)\n", "   *\n", "   * @param maxSize the maximum number of elements in the returned fluent iterable\n", "  public final FluentIterable<E> limit(int maxSize) {\n", "    return from(Iterables.limit(iterable, maxSize));\n", "   *\n", "   * <p><b>{@code Stream} equivalent:</b> {@code !stream.findAny().isPresent()}\n"], "21": ["   * <p><b>{@code Stream} equivalent:</b> {@code ImmutableList.copyOf(stream.iterator())}\n", "   *\n"], "22": ["   * <p><b>{@code Stream} equivalent:</b>\n", "   * {@code ImmutableList.copyOf(stream.sorted(comparator).iterator())}\n", "   *\n"], "23": ["   * <p><b>{@code Stream} equivalent:</b> {@code ImmutableSet.copyOf(stream.iterator())}\n", "   *\n"], "24": ["   * <p><b>{@code Stream} equivalent:</b>\n", "   * {@code ImmutableSortedSet.copyOf(comparator, stream.iterator())}\n", "   *\n"], "25": ["   * <p><b>{@code Stream} equivalent:</b> {@code ImmutableMultiset.copyOf(stream.iterator())}\n", "   *\n"], "26": ["   * <p><b>{@code Stream} equivalent:</b> TODO (note that Collectors.toMap would trash the order...)\n", "   *\n"], "27": ["   * <p><b>{@code Stream} equivalent:</b> TODO\n", "   *\n"]}, "removed": {"1": [" * {@code FluentIterable} provides a rich interface for manipulating {@code Iterable} instances in a\n", " * chained fashion. A {@code FluentIterable} can be created from an {@code Iterable}, or from a set\n", " * of elements. The following types of methods are provided on {@code FluentIterable}:\n", " * <li>chained methods which return a new {@code FluentIterable} based in some way on the contents\n", " * of the current one (for example {@link #transform})\n", " * <li>conversion methods which copy the {@code FluentIterable}'s contents into a new collection or\n", " * array (for example {@link #toList})\n", " * {@link #last})\n", " * {@link #anyMatch})\n", " * as an {@code ImmutableList}: <pre>   {@code\n", " *   FluentIterable\n", " *       .from(database.getClientList())\n", " *       .filter(activeInLastMonth)\n", " *       .transform(Functions.toStringFunction())\n", " *       .limit(10)\n", " *       .toList();}</pre>\n", " * <p>Anything which can be done using {@code FluentIterable} could be done in a different fashion\n", " * (often with {@link Iterables}), however the use of {@code FluentIterable} makes many sets of\n", " * operations significantly more concise.\n"], "6": ["   * {@code equals(element)} is true.\n", "  public final boolean contains(@Nullable Object element) {\n", "    return Iterables.contains(iterable, element);\n"], "20": ["   * @param size the maximum number of elements in the returned fluent iterable\n", "  public final FluentIterable<E> limit(int size) {\n", "    return from(Iterables.limit(iterable, size));\n"]}, "added_lines": {"1": [40, 41, 42, 43, 44, 45, 47, 48, 50, 52, 53, 54, 57, 58, 59, 60, 61, 62, 63, 64, 65, 66, 67, 68, 69, 70, 71, 72, 73, 74, 75, 76, 77, 78, 79, 80, 81, 82, 83, 84, 85, 88, 90, 91, 92, 93, 94, 95, 97, 98, 99, 100, 101, 102, 103, 104, 105], "2": [128, 129, 130], "3": [161, 162, 163], "4": [175, 176, 177], "5": [187, 188], "6": [197, 198, 199, 202, 203], "7": [218, 219, 220], "8": [234, 235], "9": [248, 249], "10": [261, 262], "11": [273, 274, 275, 276, 277, 278, 279, 280, 281, 282], "12": [292, 293], "13": [303, 304], "14": [317, 318], "15": [332, 333], "16": [349, 350, 351], "17": [364, 365, 366, 367], "18": [383, 384], "19": [439, 440], "20": [454, 455, 456, 460, 461, 466, 467], "21": [478, 479], "22": [492, 493, 494], "23": [508, 509], "24": [523, 524, 525], "25": [538, 539], "26": [556, 557], "27": [607, 608]}, "removed_lines": {"1": [40, 41, 42, 44, 45, 46, 47, 49, 51, 56, 58, 59, 60, 61, 62, 63, 65, 66, 67], "6": [148, 151, 152], "20": [365, 369, 370]}}]}
