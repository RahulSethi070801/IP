{
    "addition": {
        "129": "      assertWontGrow(size,\n",
        "130": "          Maps.newHashMapWithExpectedSize(size),\n",
        "131": "          Maps.newHashMapWithExpectedSize(size));\n",
        "132": "    }\n",
        "133": "  }\n",
        "135": "  /**\n",
        "136": "   * Same test as above but for newLinkedHashMapWithExpectedSize\n",
        "137": "   */\n",
        "138": "  @GwtIncompatible(\"reflection\")\n",
        "139": "  public void testNewLinkedHashMapWithExpectedSize_wontGrow() throws Exception {\n",
        "140": "    assertTrue(bucketsOf(Maps.newLinkedHashMapWithExpectedSize(0)) <= 1);\n",
        "142": "    for (int size = 1; size < 200; size++) {\n",
        "143": "      assertWontGrow(size,\n",
        "144": "          Maps.newLinkedHashMapWithExpectedSize(size),\n",
        "145": "          Maps.newLinkedHashMapWithExpectedSize(size));\n",
        "146": "    }\n",
        "147": "  }\n",
        "149": "  @GwtIncompatible(\"reflection\")\n",
        "150": "  private static void assertWontGrow(\n",
        "151": "      int size, HashMap<Object, Object> map1, HashMap<Object, Object> map2) throws Exception {\n",
        "152": "    // Only start measuring table size after the first element inserted, to\n",
        "153": "    // deal with empty-map optimization.\n",
        "154": "    map1.put(0, null);\n",
        "155": "\n",
        "156": "    int initialBuckets = bucketsOf(map1);\n",
        "157": "\n",
        "158": "    for (int i = 1; i < size; i++) {\n",
        "159": "      map1.put(i, null);\n",
        "161": "    assertThat(bucketsOf(map1))\n",
        "162": "        .named(\"table size after adding \" + size + \" elements\")\n",
        "163": "        .isEqualTo(initialBuckets);\n",
        "164": "\n",
        "165": "    /*\n",
        "166": "     * Something slightly different happens when the entries are added all at\n",
        "167": "     * once; make sure that passes too.\n",
        "168": "     */\n",
        "169": "    map2.putAll(map1);\n",
        "170": "    assertThat(bucketsOf(map1))\n",
        "171": "        .named(\"table size after adding \" + size + \" elements\")\n",
        "172": "        .isEqualTo(initialBuckets);\n"
    },
    "removed": {
        "129": "      HashMap<Integer, Void> map1 = Maps.newHashMapWithExpectedSize(size);\n",
        "131": "      // Only start measuring table size after the first element inserted, to\n",
        "132": "      // deal with empty-map optimization.\n",
        "133": "      map1.put(0, null);\n",
        "135": "      int initialBuckets = bucketsOf(map1);\n",
        "137": "      for (int i = 1; i < size; i++) {\n",
        "138": "        map1.put(i, null);\n",
        "139": "      }\n",
        "140": "      assertEquals(\"table size after adding \" + size + \" elements\",\n",
        "141": "          initialBuckets, bucketsOf(map1));\n",
        "142": "\n",
        "143": "      /*\n",
        "144": "       * Something slightly different happens when the entries are added all at\n",
        "145": "       * once; make sure that passes too.\n",
        "146": "       */\n",
        "147": "      HashMap<Integer, Void> map2 = Maps.newHashMapWithExpectedSize(size);\n",
        "148": "      map2.putAll(map1);\n",
        "149": "      assertEquals(\"table size after adding \" + size + \" elements: \",\n",
        "150": "          initialBuckets, bucketsOf(map2));\n"
    }
}