{"id": "ba240ccb80fe88e1ee6793800622ec3dca53a575", "code": [{"0": "guava-gwt/src-super/com/google/common/collect/super/com/google/common/collect/Maps.java", "added": {"1": ["   * for OpenJDK 1.7. It also can't be guaranteed that the method isn't\n", "   * @param expectedSize the number of entries you expect to add to the\n", "   *         expectedSize} entries without resizing\n"], "2": ["  /**\n", "   * Creates a {@code LinkedHashMap} instance, with a high enough\n", "   * \"initial capacity\" that it <i>should</i> hold {@code expectedSize}\n", "   * elements without growth. This behavior cannot be broadly guaranteed, but\n", "   * it is observed to be true for OpenJDK 1.7. It also can't be guaranteed\n", "   * that the method isn't inadvertently <i>oversizing</i> the returned map.\n", "   *\n", "   * @param expectedSize the number of entries you expect to add to the\n", "   *        returned map\n", "   * @return a new, empty {@code LinkedHashMap} with enough capacity to hold\n", "   *         {@code expectedSize} entries without resizing\n", "   * @throws IllegalArgumentException if {@code expectedSize} is negative\n", "   * @since 19.0\n", "   */\n", "  public static <K, V> LinkedHashMap<K, V> newLinkedHashMapWithExpectedSize(\n", "      int expectedSize) {\n", "    return new LinkedHashMap<K, V>(capacity(expectedSize));\n", "  }\n", "\n"]}, "removed": {"1": ["   * for OpenJDK 1.6. It also can't be guaranteed that the method isn't\n", "   * @param expectedSize the number of elements you expect to add to the\n", "   *         expectedSize} elements without resizing\n"]}, "added_lines": {"1": [165, 168, 171], "2": [230, 231, 232, 233, 234, 235, 236, 237, 238, 239, 240, 241, 242, 243, 244, 245, 246, 247, 248]}, "removed_lines": {"1": [165, 168, 171]}}, {"1": "guava-tests/test/com/google/common/collect/MapsTest.java", "added": {"1": ["      assertWontGrow(size,\n", "          Maps.newHashMapWithExpectedSize(size),\n", "          Maps.newHashMapWithExpectedSize(size));\n", "    }\n", "  }\n", "  /**\n", "   * Same test as above but for newLinkedHashMapWithExpectedSize\n", "   */\n", "  @GwtIncompatible(\"reflection\")\n", "  public void testNewLinkedHashMapWithExpectedSize_wontGrow() throws Exception {\n", "    assertTrue(bucketsOf(Maps.newLinkedHashMapWithExpectedSize(0)) <= 1);\n", "    for (int size = 1; size < 200; size++) {\n", "      assertWontGrow(size,\n", "          Maps.newLinkedHashMapWithExpectedSize(size),\n", "          Maps.newLinkedHashMapWithExpectedSize(size));\n", "    }\n", "  }\n", "  @GwtIncompatible(\"reflection\")\n", "  private static void assertWontGrow(\n", "      int size, HashMap<Object, Object> map1, HashMap<Object, Object> map2) throws Exception {\n", "    // Only start measuring table size after the first element inserted, to\n", "    // deal with empty-map optimization.\n", "    map1.put(0, null);\n", "\n", "    int initialBuckets = bucketsOf(map1);\n", "\n", "    for (int i = 1; i < size; i++) {\n", "      map1.put(i, null);\n", "    assertThat(bucketsOf(map1))\n", "        .named(\"table size after adding \" + size + \" elements\")\n", "        .isEqualTo(initialBuckets);\n", "\n", "    /*\n", "     * Something slightly different happens when the entries are added all at\n", "     * once; make sure that passes too.\n", "     */\n", "    map2.putAll(map1);\n", "    assertThat(bucketsOf(map1))\n", "        .named(\"table size after adding \" + size + \" elements\")\n", "        .isEqualTo(initialBuckets);\n"]}, "removed": {"1": ["      HashMap<Integer, Void> map1 = Maps.newHashMapWithExpectedSize(size);\n", "      // Only start measuring table size after the first element inserted, to\n", "      // deal with empty-map optimization.\n", "      map1.put(0, null);\n", "      int initialBuckets = bucketsOf(map1);\n", "      for (int i = 1; i < size; i++) {\n", "        map1.put(i, null);\n", "      }\n", "      assertEquals(\"table size after adding \" + size + \" elements\",\n", "          initialBuckets, bucketsOf(map1));\n", "\n", "      /*\n", "       * Something slightly different happens when the entries are added all at\n", "       * once; make sure that passes too.\n", "       */\n", "      HashMap<Integer, Void> map2 = Maps.newHashMapWithExpectedSize(size);\n", "      map2.putAll(map1);\n", "      assertEquals(\"table size after adding \" + size + \" elements: \",\n", "          initialBuckets, bucketsOf(map2));\n"]}, "added_lines": {"1": [129, 130, 131, 132, 133, 135, 136, 137, 138, 139, 140, 142, 143, 144, 145, 146, 147, 149, 150, 151, 152, 153, 154, 155, 156, 157, 158, 159, 161, 162, 163, 164, 165, 166, 167, 168, 169, 170, 171, 172]}, "removed_lines": {"1": [129, 131, 132, 133, 135, 137, 138, 139, 140, 141, 142, 143, 144, 145, 146, 147, 148, 149, 150]}}, {"2": "guava/src/com/google/common/collect/Maps.java", "added": {"1": ["   * for OpenJDK 1.7. It also can't be guaranteed that the method isn't\n", "   * @param expectedSize the number of entries you expect to add to the\n", "   *         expectedSize} entries without resizing\n"], "2": ["  /**\n", "   * Creates a {@code LinkedHashMap} instance, with a high enough\n", "   * \"initial capacity\" that it <i>should</i> hold {@code expectedSize}\n", "   * elements without growth. This behavior cannot be broadly guaranteed, but\n", "   * it is observed to be true for OpenJDK 1.7. It also can't be guaranteed\n", "   * that the method isn't inadvertently <i>oversizing</i> the returned map.\n", "   *\n", "   * @param expectedSize the number of entries you expect to add to the\n", "   *        returned map\n", "   * @return a new, empty {@code LinkedHashMap} with enough capacity to hold\n", "   *         {@code expectedSize} entries without resizing\n", "   * @throws IllegalArgumentException if {@code expectedSize} is negative\n", "   * @since 19.0\n", "   */\n", "  public static <K, V> LinkedHashMap<K, V> newLinkedHashMapWithExpectedSize(\n", "      int expectedSize) {\n", "    return new LinkedHashMap<K, V>(capacity(expectedSize));\n", "  }\n", "\n"]}, "removed": {"1": ["   * for OpenJDK 1.6. It also can't be guaranteed that the method isn't\n", "   * @param expectedSize the number of elements you expect to add to the\n", "   *         expectedSize} elements without resizing\n"]}, "added_lines": {"1": [170, 173, 176], "2": [235, 236, 237, 238, 239, 240, 241, 242, 243, 244, 245, 246, 247, 248, 249, 250, 251, 252, 253]}, "removed_lines": {"1": [170, 173, 176]}}]}
