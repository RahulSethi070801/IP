{
    "addition": {
        "4": " * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not use this file except\n",
        "5": " * in compliance with the License. You may obtain a copy of the License at\n",
        "9": " * Unless required by applicable law or agreed to in writing, software distributed under the License\n",
        "10": " * is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express\n",
        "11": " * or implied. See the License for the specific language governing permissions and limitations under\n",
        "12": " * the License.\n",
        "46": " * {@link #runOneIteration} that will be executed periodically as specified by its {@link\n",
        "47": " * Scheduler}. When this service is asked to stop via {@link #stopAsync} it will cancel the periodic\n",
        "48": " * task (but not interrupt it) and wait for it to stop before running the {@link #shutDown} method.\n",
        "87": " * outstanding URIs when shutting down. Also, it takes advantage of the scheduling functionality to\n",
        "103": "   * service with a fixed schedule. If more flexibility is needed then consider subclassing {@link\n",
        "104": "   * CustomScheduler}.\n",
        "111": "     * Returns a {@link Scheduler} that schedules the task using the {@link\n",
        "112": "     * ScheduledExecutorService#scheduleWithFixedDelay} method.\n",
        "116": "     *     next\n",
        "119": "    public static Scheduler newFixedDelaySchedule(\n",
        "120": "        final long initialDelay, final long delay, final TimeUnit unit) {\n",
        "125": "        public Future<?> schedule(\n",
        "126": "            AbstractService service, ScheduledExecutorService executor, Runnable task) {\n",
        "133": "     * Returns a {@link Scheduler} that schedules the task using the {@link\n",
        "134": "     * ScheduledExecutorService#scheduleAtFixedRate} method.\n",
        "140": "    public static Scheduler newFixedRateSchedule(\n",
        "141": "        final long initialDelay, final long period, final TimeUnit unit) {\n",
        "146": "        public Future<?> schedule(\n",
        "147": "            AbstractService service, ScheduledExecutorService executor, Runnable task) {\n",
        "154": "    abstract Future<?> schedule(\n",
        "155": "        AbstractService service, ScheduledExecutorService executor, Runnable runnable);\n",
        "179": "      @Override\n",
        "180": "      public void run() {\n",
        "192": "            logger.log(\n",
        "193": "                Level.WARNING,\n",
        "194": "                \"Error while attempting to shut down the service after failure.\",\n",
        "195": "                ignored);\n",
        "198": "          runningTask.cancel(false); // prevent future invocations.\n",
        "207": "    @Override\n",
        "208": "    protected final void doStart() {\n",
        "209": "      executorService =\n",
        "210": "          MoreExecutors.renamingDecorator(\n",
        "211": "              executor(),\n",
        "212": "              new Supplier<String>() {\n",
        "213": "                @Override\n",
        "214": "                public String get() {\n",
        "215": "                  return serviceName() + \" \" + state();\n",
        "216": "                }\n",
        "217": "              });\n",
        "218": "      executorService.execute(\n",
        "219": "          new Runnable() {\n",
        "220": "            @Override\n",
        "221": "            public void run() {\n",
        "222": "              lock.lock();\n",
        "223": "              try {\n",
        "224": "                startUp();\n",
        "225": "                runningTask = scheduler().schedule(delegate, executorService, task);\n",
        "226": "                notifyStarted();\n",
        "227": "              } catch (Throwable t) {\n",
        "228": "                notifyFailed(t);\n",
        "229": "                if (runningTask != null) {\n",
        "230": "                  // prevent the task from running if possible\n",
        "231": "                  runningTask.cancel(false);\n",
        "232": "                }\n",
        "233": "              } finally {\n",
        "234": "                lock.unlock();\n",
        "235": "              }\n",
        "237": "          });\n",
        "240": "    @Override\n",
        "241": "    protected final void doStop() {\n",
        "243": "      executorService.execute(\n",
        "244": "          new Runnable() {\n",
        "245": "            @Override\n",
        "246": "            public void run() {\n",
        "247": "              try {\n",
        "248": "                lock.lock();\n",
        "249": "                try {\n",
        "250": "                  if (state() != State.STOPPING) {\n",
        "251": "                    // This means that the state has changed since we were scheduled.  This implies\n",
        "252": "                    // that an execution of runOneIteration has thrown an exception and we have\n",
        "253": "                    // transitioned to a failed state, also this means that shutDown has already\n",
        "254": "                    // been called, so we do not want to call it again.\n",
        "255": "                    return;\n",
        "256": "                  }\n",
        "257": "                  shutDown();\n",
        "258": "                } finally {\n",
        "259": "                  lock.unlock();\n",
        "260": "                }\n",
        "261": "                notifyStopped();\n",
        "262": "              } catch (Throwable t) {\n",
        "263": "                notifyFailed(t);\n",
        "266": "          });\n",
        "269": "    @Override\n",
        "270": "    public String toString() {\n",
        "300": "   * Returns the {@link Scheduler} object used to configure this service. This method will only be\n",
        "307": "   * {@link #runOneIteration} and {@link #shutDown} methods. If this method is overridden the\n",
        "308": "   * executor will not be {@linkplain ScheduledExecutorService#shutdown shutdown} when this service\n",
        "309": "   * {@linkplain Service.State#TERMINATED terminates} or {@linkplain Service.State#TERMINATED\n",
        "310": "   * fails}. Subclasses may override this method to supply a custom {@link ScheduledExecutorService}\n",
        "311": "   * instance. This method is guaranteed to only be called once.\n",
        "314": "   * pool that sets the name of the thread to the {@linkplain #serviceName() service name}. Also,\n",
        "315": "   * the pool will be {@linkplain ScheduledExecutorService#shutdown() shut down} when the service\n",
        "316": "   * {@linkplain Service.State#TERMINATED terminates} or {@linkplain Service.State#TERMINATED\n",
        "317": "   * fails}.\n",
        "320": "    @WeakOuter\n",
        "321": "    class ThreadFactoryImpl implements ThreadFactory {\n",
        "322": "      @Override\n",
        "323": "      public Thread newThread(Runnable runnable) {\n",
        "334": "    addListener(\n",
        "335": "        new Listener() {\n",
        "336": "          @Override\n",
        "337": "          public void terminated(State from) {\n",
        "338": "            executor.shutdown();\n",
        "339": "          }\n",
        "340": "\n",
        "341": "          @Override\n",
        "342": "          public void failed(State from, Throwable failure) {\n",
        "343": "            executor.shutdown();\n",
        "344": "          }\n",
        "345": "        },\n",
        "346": "        directExecutor());\n",
        "360": "  @Override\n",
        "361": "  public String toString() {\n",
        "365": "  @Override\n",
        "366": "  public final boolean isRunning() {\n",
        "370": "  @Override\n",
        "371": "  public final State state() {\n",
        "378": "  @Override\n",
        "379": "  public final void addListener(Listener listener, Executor executor) {\n",
        "386": "  @Override\n",
        "387": "  public final Throwable failureCause() {\n",
        "394": "  @Override\n",
        "395": "  public final Service startAsync() {\n",
        "403": "  @Override\n",
        "404": "  public final Service stopAsync() {\n",
        "412": "  @Override\n",
        "413": "  public final void awaitRunning() {\n",
        "420": "  @Override\n",
        "421": "  public final void awaitRunning(long timeout, TimeUnit unit) throws TimeoutException {\n",
        "428": "  @Override\n",
        "429": "  public final void awaitTerminated() {\n",
        "436": "  @Override\n",
        "437": "  public final void awaitTerminated(long timeout, TimeUnit unit) throws TimeoutException {\n",
        "443": "   * use a dynamically changing schedule. After every execution of the task, assuming it hasn't been\n",
        "444": "   * cancelled, the {@link #getNextSchedule} method will be called.\n",
        "464": "       * The service that is managing this callable. This is used so that failure can be reported\n",
        "465": "       * properly.\n",
        "471": "       * not scheduled while a cancel is ongoing. Also it protects the currentFuture variable to\n",
        "480": "      ReschedulableCallable(\n",
        "481": "          AbstractService service, ScheduledExecutorService executor, Runnable runnable) {\n",
        "566": "    final Future<?> schedule(\n",
        "567": "        AbstractService service, ScheduledExecutorService executor, Runnable runnable) {\n"
    },
    "removed": {
        "4": " * Licensed under the Apache License, Version 2.0 (the \"License\");\n",
        "5": " * you may not use this file except in compliance with the License.\n",
        "6": " * You may obtain a copy of the License at\n",
        "10": " * Unless required by applicable law or agreed to in writing, software\n",
        "11": " * distributed under the License is distributed on an \"AS IS\" BASIS,\n",
        "12": " * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n",
        "13": " * See the License for the specific language governing permissions and\n",
        "14": " * limitations under the License.\n",
        "48": " * {@link #runOneIteration} that will be executed periodically as specified by its \n",
        "49": " * {@link Scheduler}. When this service is asked to stop via {@link #stopAsync} it will cancel the \n",
        "50": " * periodic task (but not interrupt it) and wait for it to stop before running the \n",
        "51": " * {@link #shutDown} method.  \n",
        "90": " * outstanding URIs when shutting down.  Also, it takes advantage of the scheduling functionality to\n",
        "106": "   * service with a fixed schedule.  If more flexibility is needed then consider subclassing  \n",
        "107": "   * {@link CustomScheduler}. \n",
        "114": "     * Returns a {@link Scheduler} that schedules the task using the \n",
        "115": "     * {@link ScheduledExecutorService#scheduleWithFixedDelay} method.\n",
        "119": "     *        next\n",
        "122": "    public static Scheduler newFixedDelaySchedule(final long initialDelay, final long delay, \n",
        "123": "        final TimeUnit unit) {\n",
        "128": "        public Future<?> schedule(AbstractService service, ScheduledExecutorService executor,\n",
        "129": "            Runnable task) {\n",
        "136": "     * Returns a {@link Scheduler} that schedules the task using the \n",
        "137": "     * {@link ScheduledExecutorService#scheduleAtFixedRate} method.\n",
        "143": "    public static Scheduler newFixedRateSchedule(final long initialDelay, final long period, \n",
        "144": "        final TimeUnit unit) {\n",
        "149": "        public Future<?> schedule(AbstractService service, ScheduledExecutorService executor,\n",
        "150": "            Runnable task) {\n",
        "157": "    abstract Future<?> schedule(AbstractService service, ScheduledExecutorService executor, \n",
        "158": "        Runnable runnable);\n",
        "182": "      @Override public void run() {\n",
        "194": "            logger.log(Level.WARNING,\n",
        "195": "                \"Error while attempting to shut down the service after failure.\", ignored);\n",
        "198": "          runningTask.cancel(false);  // prevent future invocations.\n",
        "207": "    @Override protected final void doStart() {\n",
        "208": "      executorService = MoreExecutors.renamingDecorator(executor(), new Supplier<String>() {\n",
        "209": "        @Override public String get() {\n",
        "210": "          return serviceName() + \" \" + state();\n",
        "211": "        }\n",
        "212": "      });\n",
        "213": "      executorService.execute(new Runnable() {\n",
        "214": "        @Override public void run() {\n",
        "215": "          lock.lock();\n",
        "216": "          try {\n",
        "217": "            startUp();\n",
        "218": "            runningTask = scheduler().schedule(delegate, executorService, task);\n",
        "219": "            notifyStarted();\n",
        "220": "          } catch (Throwable t) {\n",
        "221": "            notifyFailed(t);\n",
        "222": "            if (runningTask != null) {\n",
        "223": "              // prevent the task from running if possible\n",
        "224": "              runningTask.cancel(false);\n",
        "226": "          } finally {\n",
        "227": "            lock.unlock();\n",
        "228": "          }\n",
        "229": "        }\n",
        "230": "      });\n",
        "233": "    @Override protected final void doStop() {\n",
        "235": "      executorService.execute(new Runnable() {\n",
        "236": "        @Override public void run() {\n",
        "237": "          try {\n",
        "238": "            lock.lock();\n",
        "239": "            try {\n",
        "240": "              if (state() != State.STOPPING) {\n",
        "241": "                // This means that the state has changed since we were scheduled.  This implies that\n",
        "242": "                // an execution of runOneIteration has thrown an exception and we have transitioned\n",
        "243": "                // to a failed state, also this means that shutDown has already been called, so we\n",
        "244": "                // do not want to call it again.\n",
        "245": "                return;\n",
        "247": "              shutDown();\n",
        "248": "            } finally {\n",
        "249": "              lock.unlock();\n",
        "251": "            notifyStopped();\n",
        "252": "          } catch (Throwable t) {\n",
        "253": "            notifyFailed(t);\n",
        "254": "          }\n",
        "255": "        }\n",
        "256": "      });\n",
        "259": "    @Override public String toString() {\n",
        "289": "   * Returns the {@link Scheduler} object used to configure this service.  This method will only be\n",
        "296": "   * {@link #runOneIteration} and {@link #shutDown} methods.  If this method is overridden the \n",
        "297": "   * executor will not be {@linkplain ScheduledExecutorService#shutdown shutdown} when this \n",
        "298": "   * service {@linkplain Service.State#TERMINATED terminates} or \n",
        "299": "   * {@linkplain Service.State#TERMINATED fails}. Subclasses may override this method to supply a \n",
        "300": "   * custom {@link ScheduledExecutorService} instance. This method is guaranteed to only be called \n",
        "301": "   * once.\n",
        "304": "   * pool that sets the name of the thread to the {@linkplain #serviceName() service name}.  \n",
        "305": "   * Also, the pool will be {@linkplain ScheduledExecutorService#shutdown() shut down} when the \n",
        "306": "   * service {@linkplain Service.State#TERMINATED terminates} or \n",
        "307": "   * {@linkplain Service.State#TERMINATED fails}.\n",
        "310": "    @WeakOuter class ThreadFactoryImpl implements ThreadFactory {\n",
        "311": "      @Override public Thread newThread(Runnable runnable) {\n",
        "322": "    addListener(new Listener() {\n",
        "323": "      @Override public void terminated(State from) {\n",
        "324": "        executor.shutdown();\n",
        "325": "      }\n",
        "326": "      @Override public void failed(State from, Throwable failure) {\n",
        "327": "        executor.shutdown();\n",
        "328": "      }\n",
        "329": "    }, directExecutor());\n",
        "343": "  @Override public String toString() {\n",
        "347": "  @Override public final boolean isRunning() {\n",
        "351": "  @Override public final State state() {\n",
        "358": "  @Override public final void addListener(Listener listener, Executor executor) {\n",
        "365": "  @Override public final Throwable failureCause() {\n",
        "372": "  @Override public final Service startAsync() {\n",
        "380": "  @Override public final Service stopAsync() {\n",
        "388": "  @Override public final void awaitRunning() {\n",
        "395": "  @Override public final void awaitRunning(long timeout, TimeUnit unit) throws TimeoutException {\n",
        "402": "  @Override public final void awaitTerminated() {\n",
        "409": "  @Override public final void awaitTerminated(long timeout, TimeUnit unit) throws TimeoutException {\n",
        "415": "   * use a dynamically changing schedule.  After every execution of the task, assuming it hasn't \n",
        "416": "   * been cancelled, the {@link #getNextSchedule} method will be called.\n",
        "436": "       * The service that is managing this callable.  This is used so that failure can be \n",
        "437": "       * reported properly.\n",
        "443": "       * not scheduled while a cancel is ongoing.  Also it protects the currentFuture variable to \n",
        "452": "      ReschedulableCallable(AbstractService service, ScheduledExecutorService executor, \n",
        "453": "          Runnable runnable) {\n",
        "538": "    final Future<?> schedule(AbstractService service, ScheduledExecutorService executor, \n",
        "539": "        Runnable runnable) {\n"
    }
}