{
    "addition": {
        "238": "      public void handlePotentialDeadlock(PotentialDeadlockException e) {}\n",
        "262": "    return policy == Policies.DISABLED\n",
        "263": "        ? new ReentrantLock(fair)\n",
        "264": "        : new CycleDetectingReentrantLock(new LockGraphNode(lockName), fair);\n",
        "279": "  public ReentrantReadWriteLock newReentrantReadWriteLock(String lockName, boolean fair) {\n",
        "280": "    return policy == Policies.DISABLED\n",
        "281": "        ? new ReentrantReadWriteLock(fair)\n",
        "282": "        : new CycleDetectingReentrantReadWriteLock(new LockGraphNode(lockName), fair);\n",
        "286": "  private static final ConcurrentMap<Class<? extends Enum>, Map<? extends Enum, LockGraphNode>>\n",
        "287": "      lockGraphNodesPerType = new MapMaker().weakKeys().makeMap();\n",
        "292": "  public static <E extends Enum<E>> WithExplicitOrdering<E> newInstanceWithExplicitOrdering(\n",
        "293": "      Class<E> enumClass, Policy policy) {\n",
        "299": "    Map<E, LockGraphNode> lockGraphNodes = (Map<E, LockGraphNode>) getOrCreateNodes(enumClass);\n",
        "303": "  private static Map<? extends Enum, LockGraphNode> getOrCreateNodes(Class<? extends Enum> clazz) {\n",
        "304": "    Map<? extends Enum, LockGraphNode> existing = lockGraphNodesPerType.get(clazz);\n",
        "324": "    ArrayList<LockGraphNode> nodes = Lists.newArrayListWithCapacity(numKeys);\n",
        "337": "      nodes.get(i).checkAcquiredLocks(Policies.DISABLED, nodes.subList(i + 1, numKeys));\n",
        "419": "    WithExplicitOrdering(Policy policy, Map<E, LockGraphNode> lockGraphNodes) {\n",
        "441": "      return policy == Policies.DISABLED\n",
        "442": "          ? new ReentrantLock(fair)\n",
        "462": "    public ReentrantReadWriteLock newReentrantReadWriteLock(E rank, boolean fair) {\n",
        "463": "      return policy == Policies.DISABLED\n",
        "464": "          ? new ReentrantReadWriteLock(fair)\n",
        "465": "          : new CycleDetectingReentrantReadWriteLock(lockGraphNodes.get(rank), fair);\n",
        "471": "  private static final Logger logger = Logger.getLogger(CycleDetectingLockFactory.class.getName());\n",
        "486": "  private static final ThreadLocal<ArrayList<LockGraphNode>> acquiredLocks =\n",
        "487": "      new ThreadLocal<ArrayList<LockGraphNode>>() {\n",
        "488": "        @Override\n",
        "489": "        protected ArrayList<LockGraphNode> initialValue() {\n",
        "490": "          return Lists.<LockGraphNode>newArrayListWithCapacity(3);\n",
        "491": "        }\n",
        "492": "      };\n",
        "510": "    static final StackTraceElement[] EMPTY_STACK_TRACE = new StackTraceElement[0];\n",
        "512": "    static final Set<String> EXCLUDED_CLASS_NAMES =\n",
        "513": "        ImmutableSet.of(\n",
        "514": "            CycleDetectingLockFactory.class.getName(),\n",
        "515": "            ExampleStackTrace.class.getName(),\n",
        "516": "            LockGraphNode.class.getName());\n",
        "522": "        if (WithExplicitOrdering.class.getName().equals(origStackTrace[i].getClassName())) {\n",
        "558": "  public static final class PotentialDeadlockException extends ExampleStackTrace {\n",
        "563": "        LockGraphNode node1, LockGraphNode node2, ExampleStackTrace conflictingStackTrace) {\n",
        "619": "    final Map<LockGraphNode, PotentialDeadlockException> disallowedPriorLocks =\n",
        "620": "        new MapMaker().weakKeys().makeMap();\n",
        "632": "    void checkAcquiredLocks(Policy policy, List<LockGraphNode> acquiredLocks) {\n",
        "654": "      Preconditions.checkState(\n",
        "655": "          this != acquiredLock,\n",
        "656": "          \"Attempted to acquire multiple locks with the same rank %s\",\n",
        "657": "          acquiredLock.getLockName());\n",
        "665": "      PotentialDeadlockException previousDeadlockException = disallowedPriorLocks.get(acquiredLock);\n",
        "670": "        PotentialDeadlockException exception =\n",
        "671": "            new PotentialDeadlockException(\n",
        "672": "                acquiredLock, this, previousDeadlockException.getConflictingStackTrace());\n",
        "690": "        allowedPriorLocks.put(acquiredLock, new ExampleStackTrace(acquiredLock, this));\n",
        "711": "    private ExampleStackTrace findPathTo(LockGraphNode node, Set<LockGraphNode> seen) {\n",
        "713": "        return null; // Already traversed this node.\n",
        "717": "        return found; // Found a path ending at the node!\n",
        "720": "      for (Map.Entry<LockGraphNode, ExampleStackTrace> entry : allowedPriorLocks.entrySet()) {\n",
        "727": "          ExampleStackTrace path = new ExampleStackTrace(preAcquiredLock, this);\n",
        "771": "  final class CycleDetectingReentrantLock extends ReentrantLock implements CycleDetectingLock {\n",
        "775": "    private CycleDetectingReentrantLock(LockGraphNode lockGraphNode, boolean fair) {\n",
        "825": "    public boolean tryLock(long timeout, TimeUnit unit) throws InterruptedException {\n",
        "844": "  final class CycleDetectingReentrantReadWriteLock extends ReentrantReadWriteLock\n",
        "845": "      implements CycleDetectingLock {\n",
        "856": "    private CycleDetectingReentrantReadWriteLock(LockGraphNode lockGraphNode, boolean fair) {\n",
        "888": "  private class CycleDetectingReentrantReadLock extends ReentrantReadWriteLock.ReadLock {\n",
        "892": "    CycleDetectingReentrantReadLock(CycleDetectingReentrantReadWriteLock readWriteLock) {\n",
        "928": "    public boolean tryLock(long timeout, TimeUnit unit) throws InterruptedException {\n",
        "947": "  private class CycleDetectingReentrantWriteLock extends ReentrantReadWriteLock.WriteLock {\n",
        "951": "    CycleDetectingReentrantWriteLock(CycleDetectingReentrantReadWriteLock readWriteLock) {\n",
        "987": "    public boolean tryLock(long timeout, TimeUnit unit) throws InterruptedException {\n"
    },
    "removed": {
        "238": "      public void handlePotentialDeadlock(PotentialDeadlockException e) {\n",
        "239": "      }\n",
        "263": "    return policy == Policies.DISABLED ? new ReentrantLock(fair)\n",
        "264": "        : new CycleDetectingReentrantLock(\n",
        "265": "            new LockGraphNode(lockName), fair);\n",
        "280": "  public ReentrantReadWriteLock newReentrantReadWriteLock(\n",
        "281": "      String lockName, boolean fair) {\n",
        "282": "    return policy == Policies.DISABLED ? new ReentrantReadWriteLock(fair)\n",
        "283": "        : new CycleDetectingReentrantReadWriteLock(\n",
        "284": "            new LockGraphNode(lockName), fair);\n",
        "288": "  private static final ConcurrentMap<Class<? extends Enum>,\n",
        "289": "      Map<? extends Enum, LockGraphNode>> lockGraphNodesPerType =\n",
        "290": "          new MapMaker().weakKeys().makeMap();\n",
        "295": "  public static <E extends Enum<E>> WithExplicitOrdering<E>\n",
        "296": "      newInstanceWithExplicitOrdering(Class<E> enumClass, Policy policy) {\n",
        "302": "    Map<E, LockGraphNode> lockGraphNodes =\n",
        "303": "        (Map<E, LockGraphNode>) getOrCreateNodes(enumClass);\n",
        "307": "  private static Map<? extends Enum, LockGraphNode> getOrCreateNodes(\n",
        "308": "      Class<? extends Enum> clazz) {\n",
        "309": "    Map<? extends Enum, LockGraphNode> existing =\n",
        "310": "        lockGraphNodesPerType.get(clazz);\n",
        "330": "    ArrayList<LockGraphNode> nodes =\n",
        "331": "        Lists.newArrayListWithCapacity(numKeys);\n",
        "344": "      nodes.get(i).checkAcquiredLocks(\n",
        "345": "          Policies.DISABLED, nodes.subList(i + 1, numKeys));\n",
        "427": "    WithExplicitOrdering(\n",
        "428": "        Policy policy, Map<E, LockGraphNode> lockGraphNodes) {\n",
        "450": "      return policy == Policies.DISABLED ? new ReentrantLock(fair)\n",
        "470": "    public ReentrantReadWriteLock newReentrantReadWriteLock(\n",
        "471": "        E rank, boolean fair) {\n",
        "472": "      return policy == Policies.DISABLED ? new ReentrantReadWriteLock(fair)\n",
        "473": "          : new CycleDetectingReentrantReadWriteLock(\n",
        "474": "              lockGraphNodes.get(rank), fair);\n",
        "480": "  private static final Logger logger = Logger.getLogger(\n",
        "481": "      CycleDetectingLockFactory.class.getName());\n",
        "496": "  private static final ThreadLocal<ArrayList<LockGraphNode>>\n",
        "497": "      acquiredLocks = new ThreadLocal<ArrayList<LockGraphNode>>() {\n",
        "498": "    @Override\n",
        "499": "    protected ArrayList<LockGraphNode> initialValue() {\n",
        "500": "      return Lists.<LockGraphNode>newArrayListWithCapacity(3);\n",
        "501": "    }\n",
        "502": "  };\n",
        "520": "    static final StackTraceElement[] EMPTY_STACK_TRACE =\n",
        "521": "        new StackTraceElement[0];\n",
        "523": "    static final Set<String> EXCLUDED_CLASS_NAMES = ImmutableSet.of(\n",
        "524": "        CycleDetectingLockFactory.class.getName(),\n",
        "525": "        ExampleStackTrace.class.getName(),\n",
        "526": "        LockGraphNode.class.getName());\n",
        "532": "        if (WithExplicitOrdering.class.getName().equals(\n",
        "533": "                origStackTrace[i].getClassName())) {\n",
        "569": "  public static final class PotentialDeadlockException\n",
        "570": "      extends ExampleStackTrace {\n",
        "575": "        LockGraphNode node1,\n",
        "576": "        LockGraphNode node2,\n",
        "577": "        ExampleStackTrace conflictingStackTrace) {\n",
        "633": "    final Map<LockGraphNode, PotentialDeadlockException>\n",
        "634": "        disallowedPriorLocks = new MapMaker().weakKeys().makeMap();\n",
        "646": "    void checkAcquiredLocks(\n",
        "647": "        Policy policy, List<LockGraphNode> acquiredLocks) {\n",
        "669": "      Preconditions.checkState(this != acquiredLock,\n",
        "670": "          \"Attempted to acquire multiple locks with the same rank %s\", acquiredLock.getLockName());\n",
        "678": "      PotentialDeadlockException previousDeadlockException =\n",
        "679": "          disallowedPriorLocks.get(acquiredLock);\n",
        "684": "        PotentialDeadlockException exception = new PotentialDeadlockException(\n",
        "685": "            acquiredLock, this,\n",
        "686": "            previousDeadlockException.getConflictingStackTrace());\n",
        "704": "        allowedPriorLocks.put(\n",
        "705": "            acquiredLock, new ExampleStackTrace(acquiredLock, this));\n",
        "726": "    private ExampleStackTrace findPathTo(\n",
        "727": "        LockGraphNode node, Set<LockGraphNode> seen) {\n",
        "729": "        return null;  // Already traversed this node.\n",
        "733": "        return found;  // Found a path ending at the node!\n",
        "736": "      for (Map.Entry<LockGraphNode, ExampleStackTrace> entry :\n",
        "737": "               allowedPriorLocks.entrySet()) {\n",
        "744": "          ExampleStackTrace path =\n",
        "745": "              new ExampleStackTrace(preAcquiredLock, this);\n",
        "789": "  final class CycleDetectingReentrantLock\n",
        "790": "      extends ReentrantLock implements CycleDetectingLock {\n",
        "794": "    private CycleDetectingReentrantLock(\n",
        "795": "        LockGraphNode lockGraphNode, boolean fair) {\n",
        "845": "    public boolean tryLock(long timeout, TimeUnit unit)\n",
        "846": "        throws InterruptedException {\n",
        "865": "  final class CycleDetectingReentrantReadWriteLock\n",
        "866": "      extends ReentrantReadWriteLock implements CycleDetectingLock {\n",
        "877": "    private CycleDetectingReentrantReadWriteLock(\n",
        "878": "        LockGraphNode lockGraphNode, boolean fair) {\n",
        "910": "  private class CycleDetectingReentrantReadLock\n",
        "911": "      extends ReentrantReadWriteLock.ReadLock {\n",
        "915": "    CycleDetectingReentrantReadLock(\n",
        "916": "        CycleDetectingReentrantReadWriteLock readWriteLock) {\n",
        "952": "    public boolean tryLock(long timeout, TimeUnit unit)\n",
        "953": "        throws InterruptedException {\n",
        "972": "  private class CycleDetectingReentrantWriteLock\n",
        "973": "      extends ReentrantReadWriteLock.WriteLock {\n",
        "977": "    CycleDetectingReentrantWriteLock(\n",
        "978": "        CycleDetectingReentrantReadWriteLock readWriteLock) {\n",
        "1014": "    public boolean tryLock(long timeout, TimeUnit unit)\n",
        "1015": "        throws InterruptedException {\n"
    }
}