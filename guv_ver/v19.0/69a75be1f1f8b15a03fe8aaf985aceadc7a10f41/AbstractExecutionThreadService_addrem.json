{
    "addition": {
        "4": " * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not use this file except\n",
        "5": " * in compliance with the License. You may obtain a copy of the License at\n",
        "9": " * Unless required by applicable law or agreed to in writing, software distributed under the License\n",
        "10": " * is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express\n",
        "11": " * or implied. See the License for the specific language governing permissions and limitations under\n",
        "12": " * the License.\n",
        "27": " * Base class for services that can implement {@link #startUp}, {@link #run} and {@link #shutDown}\n",
        "28": " * methods. This class uses a single thread to execute the service; consider {@link AbstractService}\n",
        "29": " * if you would like to manage any threading manually.\n",
        "36": "  private static final Logger logger =\n",
        "37": "      Logger.getLogger(AbstractExecutionThreadService.class.getName());\n",
        "40": "  private final Service delegate =\n",
        "41": "      new AbstractService() {\n",
        "43": "        protected final void doStart() {\n",
        "44": "          Executor executor =\n",
        "45": "              MoreExecutors.renamingDecorator(\n",
        "46": "                  executor(),\n",
        "47": "                  new Supplier<String>() {\n",
        "48": "                    @Override\n",
        "49": "                    public String get() {\n",
        "50": "                      return serviceName();\n",
        "51": "                    }\n",
        "52": "                  });\n",
        "53": "          executor.execute(\n",
        "54": "              new Runnable() {\n",
        "55": "                @Override\n",
        "56": "                public void run() {\n",
        "57": "                  try {\n",
        "58": "                    startUp();\n",
        "59": "                    notifyStarted();\n",
        "60": "                    // If stopAsync() is called while starting we may be in the STOPPING state in\n",
        "61": "                    // which case we should skip right down to shutdown.\n",
        "62": "                    if (isRunning()) {\n",
        "63": "                      try {\n",
        "64": "                        AbstractExecutionThreadService.this.run();\n",
        "65": "                      } catch (Throwable t) {\n",
        "66": "                        try {\n",
        "67": "                          shutDown();\n",
        "68": "                        } catch (Exception ignored) {\n",
        "69": "                          // TODO(lukes): if guava ever moves to java7, this would be a good\n",
        "70": "                          // candidate for a suppressed exception, or maybe we could generalize\n",
        "71": "                          // Closer.Suppressor\n",
        "72": "                          logger.log(\n",
        "73": "                              Level.WARNING,\n",
        "74": "                              \"Error while attempting to shut down the service\" + \" after failure.\",\n",
        "75": "                              ignored);\n",
        "76": "                        }\n",
        "77": "                        notifyFailed(t);\n",
        "78": "                        return;\n",
        "79": "                      }\n",
        "80": "                    }\n",
        "81": "\n",
        "82": "                    shutDown();\n",
        "83": "                    notifyStopped();\n",
        "84": "                  } catch (Throwable t) {\n",
        "85": "                    notifyFailed(t);\n",
        "86": "                  }\n",
        "88": "              });\n",
        "91": "        @Override\n",
        "92": "        protected void doStop() {\n",
        "93": "          triggerShutdown();\n",
        "94": "        }\n",
        "96": "        @Override\n",
        "97": "        public String toString() {\n",
        "98": "          return AbstractExecutionThreadService.this.toString();\n",
        "99": "        }\n",
        "100": "      };\n",
        "115": "   * Run the service. This method is invoked on the execution thread. Implementations must respond\n",
        "116": "   * to stop requests. You could poll for lifecycle changes in a work loop:\n",
        "117": "   *\n",
        "125": "   *\n",
        "126": "   * <p>...or you could respond to stop requests by implementing {@link #triggerShutdown()}, which\n",
        "127": "   * should cause {@link #run()} to return.\n",
        "147": "   * Returns the {@link Executor} that will be used to run this service. Subclasses may override\n",
        "148": "   * this method to use a custom {@link Executor}, which may configure its worker thread with a\n",
        "149": "   * specific name, thread group or priority. The returned executor's {@link\n",
        "150": "   * Executor#execute(Runnable) execute()} method is called when this service is started, and should\n",
        "151": "   * return promptly.\n",
        "153": "   * <p>The default implementation returns a new {@link Executor} that sets the name of its threads\n",
        "154": "   * to the string returned by {@link #serviceName}\n",
        "165": "  @Override\n",
        "166": "  public String toString() {\n",
        "170": "  @Override\n",
        "171": "  public final boolean isRunning() {\n",
        "175": "  @Override\n",
        "176": "  public final State state() {\n",
        "183": "  @Override\n",
        "184": "  public final void addListener(Listener listener, Executor executor) {\n",
        "191": "  @Override\n",
        "192": "  public final Throwable failureCause() {\n",
        "199": "  @Override\n",
        "200": "  public final Service startAsync() {\n",
        "208": "  @Override\n",
        "209": "  public final Service stopAsync() {\n",
        "217": "  @Override\n",
        "218": "  public final void awaitRunning() {\n",
        "225": "  @Override\n",
        "226": "  public final void awaitRunning(long timeout, TimeUnit unit) throws TimeoutException {\n",
        "233": "  @Override\n",
        "234": "  public final void awaitTerminated() {\n",
        "241": "  @Override\n",
        "242": "  public final void awaitTerminated(long timeout, TimeUnit unit) throws TimeoutException {\n",
        "247": "   * Returns the name of this service. {@link AbstractExecutionThreadService} may include the name\n",
        "248": "   * in debugging output.\n"
    },
    "removed": {
        "4": " * Licensed under the Apache License, Version 2.0 (the \"License\");\n",
        "5": " * you may not use this file except in compliance with the License.\n",
        "6": " * You may obtain a copy of the License at\n",
        "10": " * Unless required by applicable law or agreed to in writing, software\n",
        "11": " * distributed under the License is distributed on an \"AS IS\" BASIS,\n",
        "12": " * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n",
        "13": " * See the License for the specific language governing permissions and\n",
        "14": " * limitations under the License.\n",
        "29": " * Base class for services that can implement {@link #startUp}, {@link #run} and\n",
        "30": " * {@link #shutDown} methods. This class uses a single thread to execute the\n",
        "31": " * service; consider {@link AbstractService} if you would like to manage any\n",
        "32": " * threading manually.\n",
        "39": "  private static final Logger logger = Logger.getLogger(\n",
        "40": "      AbstractExecutionThreadService.class.getName());\n",
        "43": "  private final Service delegate = new AbstractService() {\n",
        "44": "    @Override protected final void doStart() {\n",
        "45": "      Executor executor = MoreExecutors.renamingDecorator(executor(), new Supplier<String>() {\n",
        "46": "        @Override public String get() {\n",
        "47": "          return serviceName();\n",
        "48": "        }\n",
        "49": "      });\n",
        "50": "      executor.execute(new Runnable() {\n",
        "52": "        public void run() {\n",
        "53": "          try {\n",
        "54": "            startUp();\n",
        "55": "            notifyStarted();\n",
        "56": "            // If stopAsync() is called while starting we may be in the STOPPING state in which\n",
        "57": "            // case we should skip right down to shutdown.\n",
        "58": "            if (isRunning()) {\n",
        "59": "              try {\n",
        "60": "                AbstractExecutionThreadService.this.run();\n",
        "61": "              } catch (Throwable t) {\n",
        "62": "                try {\n",
        "63": "                  shutDown();\n",
        "64": "                } catch (Exception ignored) {\n",
        "65": "                  // TODO(lukes): if guava ever moves to java7, this would be a good candidate for\n",
        "66": "                  // a suppressed exception, or maybe we could generalize Closer.Suppressor\n",
        "67": "                  logger.log(Level.WARNING, \n",
        "68": "                      \"Error while attempting to shut down the service\"\n",
        "69": "                      + \" after failure.\", ignored);\n",
        "71": "                notifyFailed(t);\n",
        "72": "                return;\n",
        "73": "              }\n",
        "74": "            }\n",
        "75": "\n",
        "76": "            shutDown();\n",
        "77": "            notifyStopped();\n",
        "78": "          } catch (Throwable t) {\n",
        "79": "            notifyFailed(t);\n",
        "80": "          }\n",
        "82": "      });\n",
        "83": "    }\n",
        "85": "    @Override protected void doStop() {\n",
        "86": "      triggerShutdown();\n",
        "87": "    }\n",
        "89": "    @Override public String toString() {\n",
        "90": "      return AbstractExecutionThreadService.this.toString();\n",
        "91": "    }\n",
        "92": "  };\n",
        "107": "   * Run the service. This method is invoked on the execution thread.\n",
        "108": "   * Implementations must respond to stop requests. You could poll for lifecycle\n",
        "109": "   * changes in a work loop:\n",
        "117": "   * ...or you could respond to stop requests by implementing {@link\n",
        "118": "   * #triggerShutdown()}, which should cause {@link #run()} to return.\n",
        "138": "   * Returns the {@link Executor} that will be used to run this service.\n",
        "139": "   * Subclasses may override this method to use a custom {@link Executor}, which\n",
        "140": "   * may configure its worker thread with a specific name, thread group or\n",
        "141": "   * priority. The returned executor's {@link Executor#execute(Runnable)\n",
        "142": "   * execute()} method is called when this service is started, and should return\n",
        "143": "   * promptly.\n",
        "145": "   * <p>The default implementation returns a new {@link Executor} that sets the \n",
        "146": "   * name of its threads to the string returned by {@link #serviceName}\n",
        "157": "  @Override public String toString() {\n",
        "161": "  @Override public final boolean isRunning() {\n",
        "165": "  @Override public final State state() {\n",
        "172": "  @Override public final void addListener(Listener listener, Executor executor) {\n",
        "179": "  @Override public final Throwable failureCause() {\n",
        "186": "  @Override public final Service startAsync() {\n",
        "194": "  @Override public final Service stopAsync() {\n",
        "202": "  @Override public final void awaitRunning() {\n",
        "209": "  @Override public final void awaitRunning(long timeout, TimeUnit unit) throws TimeoutException {\n",
        "216": "  @Override public final void awaitTerminated() {\n",
        "223": "  @Override public final void awaitTerminated(long timeout, TimeUnit unit) throws TimeoutException {\n",
        "228": "   * Returns the name of this service. {@link AbstractExecutionThreadService}\n",
        "229": "   * may include the name in debugging output.\n"
    }
}