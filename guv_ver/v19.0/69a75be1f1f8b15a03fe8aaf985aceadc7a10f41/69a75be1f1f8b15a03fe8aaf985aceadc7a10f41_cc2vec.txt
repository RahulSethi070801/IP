{"id": "69a75be1f1f8b15a03fe8aaf985aceadc7a10f41", "code": [{"0": "guava-gwt/src-super/com/google/common/util/concurrent/super/com/google/common/util/concurrent/Callables.java", "added": {"1": [" * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not use this file except\n", " * in compliance with the License. You may obtain a copy of the License at\n", " * Unless required by applicable law or agreed to in writing, software distributed under the License\n", " * is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express\n", " * or implied. See the License for the specific language governing permissions and limitations under\n", " * the License.\n"], "2": ["   * Creates a {@code Callable} which immediately returns a preset value each time it is called.\n", "  public static <T> Callable<T> returning(@Nullable final T value) {\n", "      @Override\n", "      public T call() {\n"]}, "removed": {"1": [" * Licensed under the Apache License, Version 2.0 (the \"License\");\n", " * you may not use this file except in compliance with the License.\n", " * You may obtain a copy of the License at\n", " * Unless required by applicable law or agreed to in writing, software\n", " * distributed under the License is distributed on an \"AS IS\" BASIS,\n", " * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n", " * See the License for the specific language governing permissions and\n", " * limitations under the License.\n"], "2": ["   * Creates a {@code Callable} which immediately returns a preset value each\n", "   * time it is called.\n", "  public static <T> Callable<T> returning(final @Nullable T value) {\n", "      @Override public T call() {\n"]}, "added_lines": {"1": [4, 5, 9, 10, 11, 12], "2": [34, 36, 38, 39]}, "removed_lines": {"1": [4, 5, 6, 10, 11, 12, 13, 14], "2": [36, 37, 39, 41]}}, {"1": "guava-gwt/src-super/com/google/common/util/concurrent/super/com/google/common/util/concurrent/CollectionFuture.java", "added": {"1": [" * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not use this file except\n", " * in compliance with the License. You may obtain a copy of the License at\n", " * Unless required by applicable law or agreed to in writing, software distributed under the License\n", " * is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express\n", " * or implied. See the License for the specific language governing permissions and limitations under\n", " * the License.\n"], "2": ["      this.values =\n", "          futures.isEmpty()\n", "              ? ImmutableList.<Optional<V>>of()\n", "              : Lists.<Optional<V>>newArrayListWithCapacity(futures.size());\n"], "3": ["        // Some other future failed or has been cancelled, causing this one to also be cancelled or\n", "        // have an exception set. This should only happen if allMustSucceed is true or if the output\n", "        // itself has been cancelled.\n", "        checkState(\n", "            allMustSucceed || isCancelled(), \"Future was done before all dependencies completed\");\n"]}, "removed": {"1": [" * Licensed under the Apache License, Version 2.0 (the \"License\");\n", " * you may not use this file except in compliance with the License.\n", " * You may obtain a copy of the License at\n", " * Unless required by applicable law or agreed to in writing, software\n", " * distributed under the License is distributed on an \"AS IS\" BASIS,\n", " * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n", " * See the License for the specific language governing permissions and\n", " * limitations under the License.\n"], "2": ["      this.values = futures.isEmpty() ? ImmutableList.<Optional<V>>of()\n", "          : Lists.<Optional<V>>newArrayListWithCapacity(futures.size());\n"], "3": ["        // Some other future failed or has been cancelled, causing this one to\n", "        // also be cancelled or have an exception set. This should only happen\n", "        // if allMustSucceed is true or if the output itself has been\n", "        // cancelled.\n", "        checkState(allMustSucceed || isCancelled(),\n", "            \"Future was done before all dependencies completed\");\n"]}, "added_lines": {"1": [4, 5, 9, 10, 11, 12], "2": [47, 48, 49, 50], "3": [65, 66, 67, 68, 69]}, "removed_lines": {"1": [4, 5, 6, 10, 11, 12, 13, 14], "2": [49, 50], "3": [65, 66, 67, 68, 69, 70]}}, {"2": "guava-gwt/src-super/com/google/common/util/concurrent/super/com/google/common/util/concurrent/Futures.java", "added": {"1": [" * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not use this file except\n", " * in compliance with the License. You may obtain a copy of the License at\n", " * Unless required by applicable law or agreed to in writing, software distributed under the License\n", " * is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express\n", " * or implied. See the License for the specific language governing permissions and limitations under\n", " * the License.\n"], "2": ["   * Creates a {@code ListenableFuture} which has its value set immediately upon construction. The\n", "   * getters just return the value. This {@code Future} can't be canceled or timed out and its\n", "   * {@code isDone()} method always returns {@code true}.\n"], "3": ["   * Returns a {@code ListenableFuture} which has an exception set immediately upon construction.\n", "   * <p>The returned {@code Future} can't be cancelled, and its {@code isDone()} method always\n", "   * returns {@code true}. Calling {@code get()} will immediately throw the provided {@code\n", "   * Throwable} wrapped in an {@code ExecutionException}.\n", "  public static <V> ListenableFuture<V> immediateFailedFuture(Throwable throwable) {\n", "   * Returns a {@code Future} whose result is taken from the given primary {@code input} or, if the\n", "   * primary input fails, from the {@code Future} provided by the {@code fallback}. {@link\n", "   * FutureFallback#create} is not invoked until the primary input has failed, so if the primary\n", "   * input succeeds, it is never invoked. If, during the invocation of {@code fallback}, an\n", "   * exception is thrown, this exception is used as the result of the output {@code Future}.\n", "   * <p>Below is an example of a fallback that returns a default value if an exception occurs:\n"], "4": ["   * <p>The fallback can also choose to propagate the original exception when desired:\n"], "5": ["   * <p>This overload, which does not accept an executor, uses {@code directExecutor}, a dangerous\n", "   * choice in some cases. See the discussion in the {@link ListenableFuture#addListener\n", "   * ListenableFuture.addListener} documentation. The documentation's warnings about \"lightweight\n", "   * listeners\" refer here to the work done during {@code FutureFallback.create}, not to any work\n", "   * done to complete the returned {@code Future}.\n", "   * @param fallback the {@link FutureFallback} implementation to be called if {@code input} fails\n", "   * @deprecated Use {@link #catchingAsync(ListenableFuture, Class, AsyncFunction)\n", "   *     catchingAsync(input, Throwable.class, fallbackImplementedAsAnAsyncFunction)}, usually\n", "   *     replacing {@code Throwable.class} with the specific type you want to handle. This method\n", "      ListenableFuture<? extends V> input, FutureFallback<? extends V> fallback) {\n", "   * Returns a {@code Future} whose result is taken from the given primary {@code input} or, if the\n", "   * primary input fails, from the {@code Future} provided by the {@code fallback}. {@link\n", "   * FutureFallback#create} is not invoked until the primary input has failed, so if the primary\n", "   * input succeeds, it is never invoked. If, during the invocation of {@code fallback}, an\n", "   * exception is thrown, this exception is used as the result of the output {@code Future}.\n", "   * <p>Below is an example of a fallback that returns a default value if an exception occurs:\n"], "6": ["   * <p>The fallback can also choose to propagate the original exception when desired:\n"], "7": ["   * <p>When selecting an executor, note that {@code directExecutor} is dangerous in some cases. See\n", "   * the discussion in the {@link ListenableFuture#addListener ListenableFuture.addListener}\n", "   * documentation. The documentation's warnings about \"lightweight listeners\" refer here to the\n", "   * work done during {@code FutureFallback.create}, not to any work done to complete the returned\n", "   * {@code Future}.\n", "   * @param fallback the {@link FutureFallback} implementation to be called if {@code input} fails\n", "   * @param executor the executor that runs {@code fallback} if {@code input} fails\n", "   * @deprecated Use {@link #catchingAsync(ListenableFuture, Class, AsyncFunction, Executor)\n", "   *     catchingAsync(input, Throwable.class, fallbackImplementedAsAnAsyncFunction, executor)},\n", "   *     usually replacing {@code Throwable.class} with the specific type you want to handle. This\n", "   *     method will be removed in Guava release 20.0.\n", "      FutureFallback<? extends V> fallback,\n", "      Executor executor) {\n", "    return catchingAsync(input, Throwable.class, asAsyncFunction(fallback), executor);\n"], "8": ["        return checkNotNull(\n", "            fallback.create(t),\n", "            \"FutureFallback.create returned null instead of a \"\n", "                + \"Future. Did you mean to return immediateFuture(null)?\");\n", "   * Returns a new {@code ListenableFuture} whose result is asynchronously derived from the result\n", "   * of the given {@code Future}. More precisely, the returned {@code Future} takes its result from\n", "   * a {@code Future} produced by applying the given {@code AsyncFunction} to the result of the\n", "   * original {@code Future}. Example:\n"], "9": ["   * <p>This overload, which does not accept an executor, uses {@code directExecutor}, a dangerous\n", "   * choice in some cases. See the discussion in the {@link ListenableFuture#addListener\n", "   * ListenableFuture.addListener} documentation. The documentation's warnings about \"lightweight\n", "   * listeners\" refer here to the work done during {@code AsyncFunction.apply}, not to any work done\n", "   * to complete the returned {@code Future}.\n", "   * <p>The returned {@code Future} attempts to keep its cancellation state in sync with that of the\n", "   * input future and that of the future returned by the function. That is, if the returned {@code\n", "   * Future} is cancelled, it will attempt to cancel the other two, and if either of the other two\n", "   * is cancelled, the returned {@code Future} will receive a callback in which it will attempt to\n", "   * cancel itself.\n", "   * @param function A function to transform the result of the input future to the result of the\n", "   *     output future\n", "   * @return A future that holds result of the function (if the input succeeded) or the original\n", "   *     input's failure (if not)\n", "   * @deprecated These {@code AsyncFunction} overloads of {@code transform} are being renamed to\n", "   *     {@code transformAsync}. (The {@code Function} overloads are keeping the \"transform\" name.)\n", "   *     This method will be removed in Guava release 20.0.\n", "  public static <I, O> ListenableFuture<O> transform(\n", "      ListenableFuture<I> input, AsyncFunction<? super I, ? extends O> function) {\n", "   * Returns a new {@code ListenableFuture} whose result is asynchronously derived from the result\n", "   * of the given {@code Future}. More precisely, the returned {@code Future} takes its result from\n", "   * a {@code Future} produced by applying the given {@code AsyncFunction} to the result of the\n", "   * original {@code Future}. Example:\n"], "10": ["   * <p>When selecting an executor, note that {@code directExecutor} is dangerous in some cases. See\n", "   * the discussion in the {@link ListenableFuture#addListener ListenableFuture.addListener}\n", "   * documentation. The documentation's warnings about \"lightweight listeners\" refer here to the\n", "   * work done during {@code AsyncFunction.apply}, not to any work done to complete the returned\n", "   * {@code Future}.\n", "   * <p>The returned {@code Future} attempts to keep its cancellation state in sync with that of the\n", "   * input future and that of the future returned by the chain function. That is, if the returned\n", "   * {@code Future} is cancelled, it will attempt to cancel the other two, and if either of the\n", "   * other two is cancelled, the returned {@code Future} will receive a callback in which it will\n", "   * attempt to cancel itself.\n", "   * @param function A function to transform the result of the input future to the result of the\n", "   *     output future\n", "   * @return A future that holds result of the function (if the input succeeded) or the original\n", "   *     input's failure (if not)\n", "   * @deprecated These {@code AsyncFunction} overloads of {@code transform} are being renamed to\n", "   *     {@code transformAsync}. (The {@code Function} overloads are keeping the \"transform\" name.)\n", "   *     This method will be removed in Guava release 20.0.\n", "  public static <I, O> ListenableFuture<O> transform(\n", "      ListenableFuture<I> input,\n"], "11": ["  public static <I, O> ListenableFuture<O> transformAsync(\n", "      ListenableFuture<I> input,\n", "      AsyncFunction<? super I, ? extends O> function,\n", "      Executor executor) {\n", "   * Returns a new {@code ListenableFuture} whose result is the product of applying the given {@code\n", "   * Function} to the result of the given {@code Future}. Example:\n"], "12": ["   * <p>This overload, which does not accept an executor, uses {@code directExecutor}, a dangerous\n", "   * choice in some cases. See the discussion in the {@link ListenableFuture#addListener\n", "   * ListenableFuture.addListener} documentation. The documentation's warnings about \"lightweight\n", "   * listeners\" refer here to the work done during {@code Function.apply}.\n", "   * <p>The returned {@code Future} attempts to keep its cancellation state in sync with that of the\n", "   * input future. That is, if the returned {@code Future} is cancelled, it will attempt to cancel\n", "   * the input, and if the input is cancelled, the returned {@code Future} will receive a callback\n", "   * in which it will attempt to cancel itself.\n", "   * <p>An example use of this method is to convert a serializable object returned from an RPC into\n", "   * a POJO.\n", "   * @param function A Function to transform the results of the provided future to the results of\n", "   *     the returned future.  This will be run in the thread that notifies input it is complete.\n"], "13": ["   * Returns a new {@code ListenableFuture} whose result is the product of applying the given {@code\n", "   * Function} to the result of the given {@code Future}. Example:\n"], "14": ["   * <p>When selecting an executor, note that {@code directExecutor} is dangerous in some cases. See\n", "   * the discussion in the {@link ListenableFuture#addListener ListenableFuture.addListener}\n", "   * documentation. The documentation's warnings about \"lightweight listeners\" refer here to the\n", "   * work done during {@code Function.apply}.\n", "   * <p>The returned {@code Future} attempts to keep its cancellation state in sync with that of the\n", "   * input future. That is, if the returned {@code Future} is cancelled, it will attempt to cancel\n", "   * the input, and if the input is cancelled, the returned {@code Future} will receive a callback\n", "   * in which it will attempt to cancel itself.\n", "   * <p>An example use of this method is to convert a serializable object returned from an RPC into\n", "   * a POJO.\n", "   * @param function A Function to transform the results of the provided future to the results of\n", "   *     the returned future.\n"], "15": ["   * Returns a new {@code ListenableFuture} whose result is the product of calling {@code get()} on\n", "   * the {@code Future} nested within the given {@code Future}, effectively chaining the futures one\n", "   * after the other.  Example:\n", "   * #transform(ListenableFuture, AsyncFunction)}, in that the returned {@code Future} attempts to\n", "   * keep its cancellation state in sync with both the input {@code Future} and the nested {@code\n", "   * Future}.  The transformation is very lightweight and therefore takes place in the same thread\n", "   * (either the thread that called {@code dereference}, or the thread in which the dereferenced\n", "   * future completes).\n"], "16": ["        @Override\n", "        public ListenableFuture<Object> apply(ListenableFuture<Object> input) {\n", "   * Creates a new {@code ListenableFuture} whose value is a list containing the values of all its\n", "   * input futures, if all succeed. If any input fails, the returned future fails immediately.\n", "   * <p>Canceling this future will attempt to cancel all the component futures, and if any of the\n", "   * provided futures fails or is canceled, this one is, too.\n", "   * @return a future that provides a list of the results of the component futures\n", "  public static <V> ListenableFuture<List<V>> allAsList(ListenableFuture<? extends V>... futures) {\n", "   * Creates a new {@code ListenableFuture} whose value is a list containing the values of all its\n", "   * input futures, if all succeed. If any input fails, the returned future fails immediately.\n", "   * <p>Canceling this future will attempt to cancel all the component futures, and if any of the\n", "   * provided futures fails or is canceled, this one is, too.\n", "   * @return a future that provides a list of the results of the component futures\n"], "17": ["   * Creates a new {@code ListenableFuture} whose value is a list containing the values of all its\n", "   * successful input futures. The list of results is in the same order as the input list, and if\n", "   * any of the provided futures fails or is canceled, its corresponding position will contain\n", "   * {@code null} (which is indistinguishable from the future having a successful value of {@code\n", "   * null}).\n", "   * @return a future that provides a list of the results of the component futures\n"], "18": ["   * Creates a new {@code ListenableFuture} whose value is a list containing the values of all its\n", "   * successful input futures. The list of results is in the same order as the input list, and if\n", "   * any of the provided futures fails or is canceled, its corresponding position will contain\n", "   * {@code null} (which is indistinguishable from the future having a successful value of {@code\n", "   * null}).\n", "   * @return a future that provides a list of the results of the component futures\n"], "19": ["   * Registers separate success and failure callbacks to be run when the {@code Future}'s\n", "   * computation is {@linkplain java.util.concurrent.Future#isDone() complete} or, if the\n", "   * computation is already complete, immediately.\n", "   * <p>There is no guaranteed ordering of execution of callbacks, but any callback added through\n", "   * this method is guaranteed to be called once the computation is complete.\n"], "20": ["   * <p>This overload, which does not accept an executor, uses {@code directExecutor}, a dangerous\n", "   * choice in some cases. See the discussion in the {@link ListenableFuture#addListener\n", "   * ListenableFuture.addListener} documentation.\n", "   * <p>For a more general interface to attach a completion listener to a {@code Future}, see {@link\n", "   * ListenableFuture#addListener addListener}.\n", "  public static <V> void addCallback(\n", "      ListenableFuture<V> future, FutureCallback<? super V> callback) {\n", "   * Registers separate success and failure callbacks to be run when the {@code Future}'s\n", "   * computation is {@linkplain java.util.concurrent.Future#isDone() complete} or, if the\n", "   * computation is already complete, immediately.\n", "   * <p>The callback is run in {@code executor}. There is no guaranteed ordering of execution of\n", "   * callbacks, but any callback added through this method is guaranteed to be called once the\n"], "21": ["   * <p>When selecting an executor, note that {@code directExecutor} is dangerous in some cases. See\n", "   * the discussion in the {@link ListenableFuture#addListener ListenableFuture.addListener}\n", "   * documentation.\n", "   * <p>For a more general interface to attach a completion listener to a {@code Future}, see {@link\n", "   * ListenableFuture#addListener addListener}.\n", "   * @param executor The executor to run {@code callback} when the future completes.\n", "  public static <V> void addCallback(\n", "      final ListenableFuture<V> future,\n", "      final FutureCallback<? super V> callback,\n", "      Executor executor) {\n", "    Runnable callbackListener =\n", "        new Runnable() {\n", "          @Override\n", "          public void run() {\n", "            final V value;\n", "            try {\n", "              // TODO(user): (Before Guava release), validate that this\n", "              // is the thing for IE.\n", "              value = getUninterruptibly(future);\n", "            } catch (ExecutionException e) {\n", "              callback.onFailure(e.getCause());\n", "              return;\n", "            } catch (RuntimeException e) {\n", "              callback.onFailure(e);\n", "              return;\n", "            } catch (Error e) {\n", "              callback.onFailure(e);\n", "              return;\n", "            }\n", "            callback.onSuccess(value);\n", "          }\n", "        };\n", "   * Arguably we don't need a timed getUnchecked because any operation slow enough to require a\n", "   * timeout is heavyweight enough to throw a checked exception and therefore be inappropriate to\n", "   * use with getUnchecked. Further, it's not clear that converting the checked TimeoutException to\n", "   * a RuntimeException -- especially to an UncheckedExecutionException, since it wasn't thrown by\n", "   * the computation -- makes sense, and if we don't convert it, the user still has to write a\n", "   * try-catch block.\n", "   *\n", "   * If you think you would use this method, let us know. You might also also look into the\n", "   * Fork-Join framework: http://docs.oracle.com/javase/tutorial/essential/concurrency/forkjoin.html\n"]}, "removed": {"1": [" * Licensed under the Apache License, Version 2.0 (the \"License\");\n", " * you may not use this file except in compliance with the License.\n", " * You may obtain a copy of the License at\n", " * Unless required by applicable law or agreed to in writing, software\n", " * distributed under the License is distributed on an \"AS IS\" BASIS,\n", " * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n", " * See the License for the specific language governing permissions and\n", " * limitations under the License.\n"], "2": ["   * Creates a {@code ListenableFuture} which has its value set immediately upon\n", "   * construction. The getters just return the value. This {@code Future} can't\n", "   * be canceled or timed out and its {@code isDone()} method always returns\n", "   * {@code true}.\n"], "3": ["   * Returns a {@code ListenableFuture} which has an exception set immediately\n", "   * upon construction.\n", "   * <p>The returned {@code Future} can't be cancelled, and its {@code isDone()}\n", "   * method always returns {@code true}. Calling {@code get()} will immediately\n", "   * throw the provided {@code Throwable} wrapped in an {@code\n", "   * ExecutionException}.\n", "  public static <V> ListenableFuture<V> immediateFailedFuture(\n", "      Throwable throwable) {\n", "   * Returns a {@code Future} whose result is taken from the given primary\n", "   * {@code input} or, if the primary input fails, from the {@code Future}\n", "   * provided by the {@code fallback}. {@link FutureFallback#create} is not\n", "   * invoked until the primary input has failed, so if the primary input\n", "   * succeeds, it is never invoked. If, during the invocation of {@code\n", "   * fallback}, an exception is thrown, this exception is used as the result of\n", "   * the output {@code Future}.\n", "   * <p>Below is an example of a fallback that returns a default value if an\n", "   * exception occurs:\n"], "4": ["   * <p>The fallback can also choose to propagate the original exception when\n", "   * desired:\n"], "5": ["   * <p>This overload, which does not accept an executor, uses {@code\n", "   * directExecutor}, a dangerous choice in some cases. See the discussion in\n", "   * the {@link ListenableFuture#addListener ListenableFuture.addListener}\n", "   * documentation. The documentation's warnings about \"lightweight listeners\"\n", "   * refer here to the work done during {@code FutureFallback.create}, not to\n", "   * any work done to complete the returned {@code Future}.\n", "   * @param fallback the {@link FutureFallback} implementation to be called if\n", "   *     {@code input} fails\n", "   * @deprecated Use {@link #catchingAsync(ListenableFuture, Class,\n", "   *     AsyncFunction) catchingAsync(input, Throwable.class,\n", "   *     fallbackImplementedAsAnAsyncFunction)}, usually replacing {@code\n", "   *     Throwable.class} with the specific type you want to handle. This method\n", "      ListenableFuture<? extends V> input,\n", "      FutureFallback<? extends V> fallback) {\n", "   * Returns a {@code Future} whose result is taken from the given primary\n", "   * {@code input} or, if the primary input fails, from the {@code Future}\n", "   * provided by the {@code fallback}. {@link FutureFallback#create} is not\n", "   * invoked until the primary input has failed, so if the primary input\n", "   * succeeds, it is never invoked. If, during the invocation of {@code\n", "   * fallback}, an exception is thrown, this exception is used as the result of\n", "   * the output {@code Future}.\n", "   * <p>Below is an example of a fallback that returns a default value if an\n", "   * exception occurs:\n"], "6": ["   * <p>The fallback can also choose to propagate the original exception when\n", "   * desired:\n"], "7": ["   * <p>When selecting an executor, note that {@code directExecutor} is\n", "   * dangerous in some cases. See the discussion in the {@link\n", "   * ListenableFuture#addListener ListenableFuture.addListener} documentation.\n", "   * The documentation's warnings about \"lightweight listeners\" refer here to\n", "   * the work done during {@code FutureFallback.create}, not to any work done to\n", "   * complete the returned {@code Future}.\n", "   * @param fallback the {@link FutureFallback} implementation to be called if\n", "   *     {@code input} fails\n", "   * @param executor the executor that runs {@code fallback} if {@code input}\n", "   *     fails\n", "   * @deprecated Use {@link #catchingAsync(ListenableFuture, Class,\n", "   *     AsyncFunction, Executor) catchingAsync(input, Throwable.class,\n", "   *     fallbackImplementedAsAnAsyncFunction, executor)}, usually replacing\n", "   *     {@code Throwable.class} with the specific type you want to handle. This method\n", "   *     will be removed in Guava release 20.0.\n", "      FutureFallback<? extends V> fallback, Executor executor) {\n", "    return catchingAsync(\n", "        input, Throwable.class, asAsyncFunction(fallback), executor);\n"], "8": ["        return checkNotNull(fallback.create(t), \"FutureFallback.create returned null instead of a \"\n", "            + \"Future. Did you mean to return immediateFuture(null)?\");\n", "   * Returns a new {@code ListenableFuture} whose result is asynchronously\n", "   * derived from the result of the given {@code Future}. More precisely, the\n", "   * returned {@code Future} takes its result from a {@code Future} produced by\n", "   * applying the given {@code AsyncFunction} to the result of the original\n", "   * {@code Future}. Example:\n"], "9": ["   * <p>This overload, which does not accept an executor, uses {@code\n", "   * directExecutor}, a dangerous choice in some cases. See the discussion in\n", "   * the {@link ListenableFuture#addListener ListenableFuture.addListener}\n", "   * documentation. The documentation's warnings about \"lightweight listeners\"\n", "   * refer here to the work done during {@code AsyncFunction.apply}, not to any\n", "   * work done to complete the returned {@code Future}.\n", "   * <p>The returned {@code Future} attempts to keep its cancellation state in\n", "   * sync with that of the input future and that of the future returned by the\n", "   * function. That is, if the returned {@code Future} is cancelled, it will\n", "   * attempt to cancel the other two, and if either of the other two is\n", "   * cancelled, the returned {@code Future} will receive a callback in which it\n", "   * will attempt to cancel itself.\n", "   * @param function A function to transform the result of the input future\n", "   *     to the result of the output future\n", "   * @return A future that holds result of the function (if the input succeeded)\n", "   *     or the original input's failure (if not)\n", "   * @deprecated These {@code AsyncFunction} overloads of {@code transform} are\n", "   *     being renamed to {@code transformAsync}. (The {@code Function}\n", "   *     overloads are keeping the \"transform\" name.) This method will be removed in Guava release\n", "   *     20.0.\n", "  public static <I, O> ListenableFuture<O> transform(ListenableFuture<I> input,\n", "      AsyncFunction<? super I, ? extends O> function) {\n", "   * Returns a new {@code ListenableFuture} whose result is asynchronously\n", "   * derived from the result of the given {@code Future}. More precisely, the\n", "   * returned {@code Future} takes its result from a {@code Future} produced by\n", "   * applying the given {@code AsyncFunction} to the result of the original\n", "   * {@code Future}. Example:\n"], "10": ["   * <p>When selecting an executor, note that {@code directExecutor} is\n", "   * dangerous in some cases. See the discussion in the {@link\n", "   * ListenableFuture#addListener ListenableFuture.addListener} documentation.\n", "   * The documentation's warnings about \"lightweight listeners\" refer here to\n", "   * the work done during {@code AsyncFunction.apply}, not to any work done to\n", "   * complete the returned {@code Future}.\n", "   * <p>The returned {@code Future} attempts to keep its cancellation state in\n", "   * sync with that of the input future and that of the future returned by the\n", "   * chain function. That is, if the returned {@code Future} is cancelled, it\n", "   * will attempt to cancel the other two, and if either of the other two is\n", "   * cancelled, the returned {@code Future} will receive a callback in which it\n", "   * will attempt to cancel itself.\n", "   * @param function A function to transform the result of the input future\n", "   *     to the result of the output future\n", "   * @return A future that holds result of the function (if the input succeeded)\n", "   *     or the original input's failure (if not)\n", "   * @deprecated These {@code AsyncFunction} overloads of {@code transform} are\n", "   *     being renamed to {@code transformAsync}. (The {@code Function}\n", "   *     overloads are keeping the \"transform\" name.) This method will be removed in Guava release\n", "   *     20.0.\n", "  public static <I, O> ListenableFuture<O> transform(ListenableFuture<I> input,\n"], "11": ["  public static <I, O> ListenableFuture<O> transformAsync(ListenableFuture<I> input,\n", "      AsyncFunction<? super I, ? extends O> function, Executor executor) {\n", "   * Returns a new {@code ListenableFuture} whose result is the product of\n", "   * applying the given {@code Function} to the result of the given {@code\n", "   * Future}. Example:\n"], "12": ["   * <p>This overload, which does not accept an executor, uses {@code\n", "   * directExecutor}, a dangerous choice in some cases. See the discussion in\n", "   * the {@link ListenableFuture#addListener ListenableFuture.addListener}\n", "   * documentation. The documentation's warnings about \"lightweight listeners\"\n", "   * refer here to the work done during {@code Function.apply}.\n", "   * <p>The returned {@code Future} attempts to keep its cancellation state in\n", "   * sync with that of the input future. That is, if the returned {@code Future}\n", "   * is cancelled, it will attempt to cancel the input, and if the input is\n", "   * cancelled, the returned {@code Future} will receive a callback in which it\n", "   * will attempt to cancel itself.\n", "   * <p>An example use of this method is to convert a serializable object\n", "   * returned from an RPC into a POJO.\n", "   * @param function A Function to transform the results of the provided future\n", "   *     to the results of the returned future.  This will be run in the thread\n", "   *     that notifies input it is complete.\n"], "13": ["   * Returns a new {@code ListenableFuture} whose result is the product of\n", "   * applying the given {@code Function} to the result of the given {@code\n", "   * Future}. Example:\n"], "14": ["   * <p>When selecting an executor, note that {@code directExecutor} is\n", "   * dangerous in some cases. See the discussion in the {@link\n", "   * ListenableFuture#addListener ListenableFuture.addListener} documentation.\n", "   * The documentation's warnings about \"lightweight listeners\" refer here to\n", "   * the work done during {@code Function.apply}.\n", "   * <p>The returned {@code Future} attempts to keep its cancellation state in\n", "   * sync with that of the input future. That is, if the returned {@code Future}\n", "   * is cancelled, it will attempt to cancel the input, and if the input is\n", "   * cancelled, the returned {@code Future} will receive a callback in which it\n", "   * will attempt to cancel itself.\n", "   * <p>An example use of this method is to convert a serializable object\n", "   * returned from an RPC into a POJO.\n", "   * @param function A Function to transform the results of the provided future\n", "   *     to the results of the returned future.\n"], "15": ["   * Returns a new {@code ListenableFuture} whose result is the product of\n", "   * calling {@code get()} on the {@code Future} nested within the given {@code\n", "   * Future}, effectively chaining the futures one after the other.  Example:\n", "   * #transform(ListenableFuture, AsyncFunction)}, in that the returned {@code\n", "   * Future} attempts to keep its cancellation state in sync with both the\n", "   * input {@code Future} and the nested {@code Future}.  The transformation\n", "   * is very lightweight and therefore takes place in the same thread (either\n", "   * the thread that called {@code dereference}, or the thread in which the\n", "   * dereferenced future completes).\n"], "16": ["        @Override public ListenableFuture<Object> apply(ListenableFuture<Object> input) {\n", "   * Creates a new {@code ListenableFuture} whose value is a list containing the\n", "   * values of all its input futures, if all succeed. If any input fails, the\n", "   * returned future fails immediately.\n", "   * <p>Canceling this future will attempt to cancel all the component futures,\n", "   * and if any of the provided futures fails or is canceled, this one is,\n", "   * too.\n", "   * @return a future that provides a list of the results of the component\n", "   *         futures\n", "  public static <V> ListenableFuture<List<V>> allAsList(\n", "      ListenableFuture<? extends V>... futures) {\n", "   * Creates a new {@code ListenableFuture} whose value is a list containing the\n", "   * values of all its input futures, if all succeed. If any input fails, the\n", "   * returned future fails immediately.\n", "   * <p>Canceling this future will attempt to cancel all the component futures,\n", "   * and if any of the provided futures fails or is canceled, this one is,\n", "   * too.\n", "   * @return a future that provides a list of the results of the component\n", "   *         futures\n"], "17": ["   * Creates a new {@code ListenableFuture} whose value is a list containing the\n", "   * values of all its successful input futures. The list of results is in the\n", "   * same order as the input list, and if any of the provided futures fails or\n", "   * is canceled, its corresponding position will contain {@code null} (which is\n", "   * indistinguishable from the future having a successful value of\n", "   * {@code null}).\n", "   * @return a future that provides a list of the results of the component\n", "   *         futures\n"], "18": ["   * Creates a new {@code ListenableFuture} whose value is a list containing the\n", "   * values of all its successful input futures. The list of results is in the\n", "   * same order as the input list, and if any of the provided futures fails or\n", "   * is canceled, its corresponding position will contain {@code null} (which is\n", "   * indistinguishable from the future having a successful value of\n", "   * {@code null}).\n", "   * @return a future that provides a list of the results of the component\n", "   *         futures\n"], "19": ["   * Registers separate success and failure callbacks to be run when the {@code\n", "   * Future}'s computation is {@linkplain java.util.concurrent.Future#isDone()\n", "   * complete} or, if the computation is already complete, immediately.\n", "   * <p>There is no guaranteed ordering of execution of callbacks, but any\n", "   * callback added through this method is guaranteed to be called once the\n", "   * computation is complete.\n"], "20": ["   * <p>This overload, which does not accept an executor, uses {@code\n", "   * directExecutor}, a dangerous choice in some cases. See the discussion in\n", "   * the {@link ListenableFuture#addListener ListenableFuture.addListener}\n", "   * documentation.\n", "   * <p>For a more general interface to attach a completion listener to a\n", "   * {@code Future}, see {@link ListenableFuture#addListener addListener}.\n", "  public static <V> void addCallback(ListenableFuture<V> future,\n", "      FutureCallback<? super V> callback) {\n", "   * Registers separate success and failure callbacks to be run when the {@code\n", "   * Future}'s computation is {@linkplain java.util.concurrent.Future#isDone()\n", "   * complete} or, if the computation is already complete, immediately.\n", "   * <p>The callback is run in {@code executor}.\n", "   * There is no guaranteed ordering of execution of callbacks, but any\n", "   * callback added through this method is guaranteed to be called once the\n"], "21": ["   * <p>When selecting an executor, note that {@code directExecutor} is\n", "   * dangerous in some cases. See the discussion in the {@link\n", "   * ListenableFuture#addListener ListenableFuture.addListener} documentation.\n", "   * <p>For a more general interface to attach a completion listener to a\n", "   * {@code Future}, see {@link ListenableFuture#addListener addListener}.\n", "   * @param executor The executor to run {@code callback} when the future\n", "   *    completes.\n", "  public static <V> void addCallback(final ListenableFuture<V> future,\n", "      final FutureCallback<? super V> callback, Executor executor) {\n", "    Runnable callbackListener = new Runnable() {\n", "      @Override\n", "      public void run() {\n", "        final V value;\n", "        try {\n", "          // TODO(user): (Before Guava release), validate that this\n", "          // is the thing for IE.\n", "          value = getUninterruptibly(future);\n", "        } catch (ExecutionException e) {\n", "          callback.onFailure(e.getCause());\n", "          return;\n", "        } catch (RuntimeException e) {\n", "          callback.onFailure(e);\n", "          return;\n", "        } catch (Error e) {\n", "          callback.onFailure(e);\n", "          return;\n", "        }\n", "        callback.onSuccess(value);\n", "      }\n", "    };\n", "   * Arguably we don't need a timed getUnchecked because any operation slow\n", "   * enough to require a timeout is heavyweight enough to throw a checked\n", "   * exception and therefore be inappropriate to use with getUnchecked. Further,\n", "   * it's not clear that converting the checked TimeoutException to a\n", "   * RuntimeException -- especially to an UncheckedExecutionException, since it\n", "   * wasn't thrown by the computation -- makes sense, and if we don't convert\n", "   * it, the user still has to write a try-catch block.\n", "   *\n", "   * If you think you would use this method, let us know. You might also also\n", "   * look into the Fork-Join framework:\n", "   * http://docs.oracle.com/javase/tutorial/essential/concurrency/forkjoin.html\n"]}, "added_lines": {"1": [4, 5, 9, 10, 11, 12], "2": [102, 103, 104], "3": [118, 120, 121, 122, 125, 131, 132, 133, 134, 135, 137], "4": [153], "5": [170, 171, 172, 173, 174, 177, 179, 180, 181, 187, 192, 193, 194, 195, 196, 198], "6": [214], "7": [231, 232, 233, 234, 235, 238, 239, 241, 242, 243, 244, 250, 251, 252], "8": [261, 262, 263, 264, 270, 271, 272, 273], "9": [286, 287, 288, 289, 290, 292, 293, 294, 295, 296, 299, 300, 301, 302, 304, 305, 306, 309, 310, 315, 316, 317, 318], "10": [331, 332, 333, 334, 335, 337, 338, 339, 340, 341, 344, 345, 347, 348, 350, 351, 352, 355, 356], "11": [440, 441, 442, 443, 448, 449], "12": [462, 463, 464, 465, 467, 468, 469, 470, 472, 473, 476, 477], "13": [487, 488], "14": [501, 502, 503, 504, 506, 507, 508, 509, 511, 512, 515, 516], "15": [527, 528, 529, 536, 537, 538, 539, 540], "16": [558, 559, 565, 566, 570, 571, 574, 580, 585, 586, 590, 591, 594], "17": [605, 606, 607, 608, 609, 614], "18": [626, 627, 628, 629, 630, 635], "19": [646, 647, 648, 650, 651], "20": [665, 666, 667, 669, 670, 676, 677, 682, 683, 684, 686, 687], "21": [703, 704, 705, 707, 708, 712, 715, 716, 717, 718, 720, 721, 722, 723, 724, 725, 726, 727, 728, 729, 730, 731, 732, 733, 734, 735, 736, 737, 738, 739, 740, 741, 746, 747, 748, 749, 750, 751, 752, 753, 754]}, "removed_lines": {"1": [4, 5, 6, 10, 11, 12, 13, 14], "2": [104, 105, 106, 107], "3": [121, 122, 124, 125, 126, 127, 130, 131, 137, 138, 139, 140, 141, 142, 143, 145, 146], "4": [162, 163], "5": [180, 181, 182, 183, 184, 185, 188, 189, 191, 192, 193, 194, 200, 201, 206, 207, 208, 209, 210, 211, 212, 214, 215], "6": [231, 232], "7": [249, 250, 251, 252, 253, 254, 257, 258, 259, 260, 262, 263, 264, 265, 266, 272, 273, 274], "8": [283, 284, 290, 291, 292, 293, 294], "9": [307, 308, 309, 310, 311, 312, 314, 315, 316, 317, 318, 319, 322, 323, 324, 325, 327, 328, 329, 330, 333, 334, 339, 340, 341, 342, 343], "10": [356, 357, 358, 359, 360, 361, 363, 364, 365, 366, 367, 368, 371, 372, 374, 375, 377, 378, 379, 380, 383], "11": [467, 468, 473, 474, 475], "12": [488, 489, 490, 491, 492, 494, 495, 496, 497, 498, 500, 501, 504, 505, 506], "13": [516, 517, 518], "14": [531, 532, 533, 534, 535, 537, 538, 539, 540, 541, 543, 544, 547, 548], "15": [559, 560, 561, 568, 569, 570, 571, 572, 573], "16": [591, 597, 598, 599, 603, 604, 605, 608, 609, 615, 616, 621, 622, 623, 627, 628, 629, 632, 633], "17": [644, 645, 646, 647, 648, 649, 654, 655], "18": [667, 668, 669, 670, 671, 672, 677, 678], "19": [689, 690, 691, 693, 694, 695], "20": [709, 710, 711, 712, 714, 715, 721, 722, 727, 728, 729, 731, 732, 733], "21": [749, 750, 751, 753, 754, 758, 759, 762, 763, 765, 766, 767, 768, 769, 770, 771, 772, 773, 774, 775, 776, 777, 778, 779, 780, 781, 782, 783, 784, 785, 790, 791, 792, 793, 794, 795, 796, 797, 798, 799, 800]}}, {"3": "guava/src/com/google/common/util/concurrent/AbstractCheckedFuture.java", "added": {"1": [" * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not use this file except\n", " * in compliance with the License. You may obtain a copy of the License at\n", " * Unless required by applicable law or agreed to in writing, software distributed under the License\n", " * is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express\n", " * or implied. See the License for the specific language governing permissions and limitations under\n", " * the License.\n"], "2": [" * A delegating wrapper around a {@link ListenableFuture} that adds support for the {@link\n", " * #checkedGet()} and {@link #checkedGet(long, TimeUnit)} methods.\n"], "3": ["   * Translates from an {@link InterruptedException}, {@link CancellationException} or {@link\n", "   * ExecutionException} thrown by {@code get} to an exception of type {@code X} to be thrown by\n", "   * <p>If {@code e} is an {@code InterruptedException}, the calling {@code checkedGet} method has\n", "   * already restored the interrupt after catching the exception. If an implementation of {@link\n", "   * #mapException(Exception)} wishes to swallow the interrupt, it can do so by calling {@link\n", "   * Thread#interrupted()}.\n", "   * <p>Subclasses may choose to throw, rather than return, a subclass of {@code RuntimeException}\n", "   * to allow creating a CheckedFuture that throws both checked and unchecked exceptions.\n", "   * <p>This implementation calls {@link #get()} and maps that method's standard exceptions to\n", "   * instances of type {@code X} using {@link #mapException}.\n", "   * <p>In addition, if {@code get} throws an {@link InterruptedException}, this implementation will\n", "   * set the current thread's interrupt status before calling {@code mapException}.\n", "   * @throws X if {@link #get()} throws an {@link InterruptedException}, {@link\n", "   *     CancellationException}, or {@link ExecutionException}\n"], "4": ["   * <p>This implementation calls {@link #get(long, TimeUnit)} and maps that method's standard\n", "   * exceptions (excluding {@link TimeoutException}, which is propagated) to instances of type\n", "   * {@code X} using {@link #mapException}.\n", "   * <p>In addition, if {@code get} throws an {@link InterruptedException}, this implementation will\n", "   * set the current thread's interrupt status before calling {@code mapException}.\n", "   * @throws X if {@link #get()} throws an {@link InterruptedException}, {@link\n", "   *     CancellationException}, or {@link ExecutionException}\n"]}, "removed": {"1": [" * Licensed under the Apache License, Version 2.0 (the \"License\");\n", " * you may not use this file except in compliance with the License.\n", " * You may obtain a copy of the License at\n", " * Unless required by applicable law or agreed to in writing, software\n", " * distributed under the License is distributed on an \"AS IS\" BASIS,\n", " * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n", " * See the License for the specific language governing permissions and\n", " * limitations under the License.\n"], "2": [" * A delegating wrapper around a {@link ListenableFuture} that adds support for\n", " * the {@link #checkedGet()} and {@link #checkedGet(long, TimeUnit)} methods.\n"], "3": ["   * Translates from an {@link InterruptedException},\n", "   * {@link CancellationException} or {@link ExecutionException} thrown by\n", "   * {@code get} to an exception of type {@code X} to be thrown by\n", "   * <p>If {@code e} is an {@code InterruptedException}, the calling\n", "   * {@code checkedGet} method has already restored the interrupt after catching\n", "   * the exception. If an implementation of {@link #mapException(Exception)}\n", "   * wishes to swallow the interrupt, it can do so by calling\n", "   * {@link Thread#interrupted()}.\n", "   * <p>Subclasses may choose to throw, rather than return, a subclass of\n", "   * {@code RuntimeException} to allow creating a CheckedFuture that throws\n", "   * both checked and unchecked exceptions.\n", "   * <p>This implementation calls {@link #get()} and maps that method's standard\n", "   * exceptions to instances of type {@code X} using {@link #mapException}.\n", "   * <p>In addition, if {@code get} throws an {@link InterruptedException}, this\n", "   * implementation will set the current thread's interrupt status before\n", "   * calling {@code mapException}.\n", "   * @throws X if {@link #get()} throws an {@link InterruptedException},\n", "   *         {@link CancellationException}, or {@link ExecutionException}\n"], "4": ["   * <p>This implementation calls {@link #get(long, TimeUnit)} and maps that\n", "   * method's standard exceptions (excluding {@link TimeoutException}, which is\n", "   * propagated) to instances of type {@code X} using {@link #mapException}.\n", "   * <p>In addition, if {@code get} throws an {@link InterruptedException}, this\n", "   * implementation will set the current thread's interrupt status before\n", "   * calling {@code mapException}.\n", "   * @throws X if {@link #get()} throws an {@link InterruptedException},\n", "   *         {@link CancellationException}, or {@link ExecutionException}\n", "   * @throws TimeoutException {@inheritDoc}\n"]}, "added_lines": {"1": [4, 5, 9, 10, 11, 12], "2": [25, 26], "3": [43, 44, 47, 48, 49, 50, 52, 53, 60, 61, 63, 64, 66, 67], "4": [86, 87, 88, 90, 91, 93, 94]}, "removed_lines": {"1": [4, 5, 6, 10, 11, 12, 13, 14], "2": [27, 28], "3": [45, 46, 47, 50, 51, 52, 53, 54, 56, 57, 58, 65, 66, 68, 69, 70, 72, 73], "4": [92, 93, 94, 96, 97, 98, 100, 101, 102]}}, {"4": "guava/src/com/google/common/util/concurrent/AbstractExecutionThreadService.java", "added": {"1": [" * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not use this file except\n", " * in compliance with the License. You may obtain a copy of the License at\n", " * Unless required by applicable law or agreed to in writing, software distributed under the License\n", " * is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express\n", " * or implied. See the License for the specific language governing permissions and limitations under\n", " * the License.\n"], "2": [" * Base class for services that can implement {@link #startUp}, {@link #run} and {@link #shutDown}\n", " * methods. This class uses a single thread to execute the service; consider {@link AbstractService}\n", " * if you would like to manage any threading manually.\n", "  private static final Logger logger =\n", "      Logger.getLogger(AbstractExecutionThreadService.class.getName());\n", "  private final Service delegate =\n", "      new AbstractService() {\n", "        protected final void doStart() {\n", "          Executor executor =\n", "              MoreExecutors.renamingDecorator(\n", "                  executor(),\n", "                  new Supplier<String>() {\n", "                    @Override\n", "                    public String get() {\n", "                      return serviceName();\n", "                    }\n", "                  });\n", "          executor.execute(\n", "              new Runnable() {\n", "                @Override\n", "                public void run() {\n", "                  try {\n", "                    startUp();\n", "                    notifyStarted();\n", "                    // If stopAsync() is called while starting we may be in the STOPPING state in\n", "                    // which case we should skip right down to shutdown.\n", "                    if (isRunning()) {\n", "                      try {\n", "                        AbstractExecutionThreadService.this.run();\n", "                      } catch (Throwable t) {\n", "                        try {\n", "                          shutDown();\n", "                        } catch (Exception ignored) {\n", "                          // TODO(lukes): if guava ever moves to java7, this would be a good\n", "                          // candidate for a suppressed exception, or maybe we could generalize\n", "                          // Closer.Suppressor\n", "                          logger.log(\n", "                              Level.WARNING,\n", "                              \"Error while attempting to shut down the service\" + \" after failure.\",\n", "                              ignored);\n", "                        }\n", "                        notifyFailed(t);\n", "                        return;\n", "                      }\n", "                    }\n", "\n", "                    shutDown();\n", "                    notifyStopped();\n", "                  } catch (Throwable t) {\n", "                    notifyFailed(t);\n", "                  }\n", "              });\n", "        @Override\n", "        protected void doStop() {\n", "          triggerShutdown();\n", "        }\n", "        @Override\n", "        public String toString() {\n", "          return AbstractExecutionThreadService.this.toString();\n", "        }\n", "      };\n"], "3": ["   * Run the service. This method is invoked on the execution thread. Implementations must respond\n", "   * to stop requests. You could poll for lifecycle changes in a work loop:\n", "   *\n"], "4": ["   *\n", "   * <p>...or you could respond to stop requests by implementing {@link #triggerShutdown()}, which\n", "   * should cause {@link #run()} to return.\n"], "5": ["   * Returns the {@link Executor} that will be used to run this service. Subclasses may override\n", "   * this method to use a custom {@link Executor}, which may configure its worker thread with a\n", "   * specific name, thread group or priority. The returned executor's {@link\n", "   * Executor#execute(Runnable) execute()} method is called when this service is started, and should\n", "   * return promptly.\n", "   * <p>The default implementation returns a new {@link Executor} that sets the name of its threads\n", "   * to the string returned by {@link #serviceName}\n"], "6": ["  @Override\n", "  public String toString() {\n", "  @Override\n", "  public final boolean isRunning() {\n", "  @Override\n", "  public final State state() {\n", "  @Override\n", "  public final void addListener(Listener listener, Executor executor) {\n", "  @Override\n", "  public final Throwable failureCause() {\n", "  @Override\n", "  public final Service startAsync() {\n"], "7": ["  @Override\n", "  public final Service stopAsync() {\n"], "8": ["  @Override\n", "  public final void awaitRunning() {\n", "  @Override\n", "  public final void awaitRunning(long timeout, TimeUnit unit) throws TimeoutException {\n", "  @Override\n", "  public final void awaitTerminated() {\n", "  @Override\n", "  public final void awaitTerminated(long timeout, TimeUnit unit) throws TimeoutException {\n", "   * Returns the name of this service. {@link AbstractExecutionThreadService} may include the name\n", "   * in debugging output.\n"]}, "removed": {"1": [" * Licensed under the Apache License, Version 2.0 (the \"License\");\n", " * you may not use this file except in compliance with the License.\n", " * You may obtain a copy of the License at\n", " * Unless required by applicable law or agreed to in writing, software\n", " * distributed under the License is distributed on an \"AS IS\" BASIS,\n", " * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n", " * See the License for the specific language governing permissions and\n", " * limitations under the License.\n"], "2": [" * Base class for services that can implement {@link #startUp}, {@link #run} and\n", " * {@link #shutDown} methods. This class uses a single thread to execute the\n", " * service; consider {@link AbstractService} if you would like to manage any\n", " * threading manually.\n", "  private static final Logger logger = Logger.getLogger(\n", "      AbstractExecutionThreadService.class.getName());\n", "  private final Service delegate = new AbstractService() {\n", "    @Override protected final void doStart() {\n", "      Executor executor = MoreExecutors.renamingDecorator(executor(), new Supplier<String>() {\n", "        @Override public String get() {\n", "          return serviceName();\n", "        }\n", "      });\n", "      executor.execute(new Runnable() {\n", "        public void run() {\n", "          try {\n", "            startUp();\n", "            notifyStarted();\n", "            // If stopAsync() is called while starting we may be in the STOPPING state in which\n", "            // case we should skip right down to shutdown.\n", "            if (isRunning()) {\n", "              try {\n", "                AbstractExecutionThreadService.this.run();\n", "              } catch (Throwable t) {\n", "                try {\n", "                  shutDown();\n", "                } catch (Exception ignored) {\n", "                  // TODO(lukes): if guava ever moves to java7, this would be a good candidate for\n", "                  // a suppressed exception, or maybe we could generalize Closer.Suppressor\n", "                  logger.log(Level.WARNING, \n", "                      \"Error while attempting to shut down the service\"\n", "                      + \" after failure.\", ignored);\n", "                notifyFailed(t);\n", "                return;\n", "              }\n", "            }\n", "\n", "            shutDown();\n", "            notifyStopped();\n", "          } catch (Throwable t) {\n", "            notifyFailed(t);\n", "          }\n", "      });\n", "    }\n", "    @Override protected void doStop() {\n", "      triggerShutdown();\n", "    }\n", "    @Override public String toString() {\n", "      return AbstractExecutionThreadService.this.toString();\n", "    }\n", "  };\n"], "3": ["   * Run the service. This method is invoked on the execution thread.\n", "   * Implementations must respond to stop requests. You could poll for lifecycle\n", "   * changes in a work loop:\n"], "4": ["   * ...or you could respond to stop requests by implementing {@link\n", "   * #triggerShutdown()}, which should cause {@link #run()} to return.\n"], "5": ["   * Returns the {@link Executor} that will be used to run this service.\n", "   * Subclasses may override this method to use a custom {@link Executor}, which\n", "   * may configure its worker thread with a specific name, thread group or\n", "   * priority. The returned executor's {@link Executor#execute(Runnable)\n", "   * execute()} method is called when this service is started, and should return\n", "   * promptly.\n", "   * <p>The default implementation returns a new {@link Executor} that sets the \n", "   * name of its threads to the string returned by {@link #serviceName}\n"], "6": ["  @Override public String toString() {\n", "  @Override public final boolean isRunning() {\n", "  @Override public final State state() {\n", "  @Override public final void addListener(Listener listener, Executor executor) {\n", "  @Override public final Throwable failureCause() {\n", "  @Override public final Service startAsync() {\n"], "7": ["  @Override public final Service stopAsync() {\n"], "8": ["  @Override public final void awaitRunning() {\n", "  @Override public final void awaitRunning(long timeout, TimeUnit unit) throws TimeoutException {\n", "  @Override public final void awaitTerminated() {\n", "  @Override public final void awaitTerminated(long timeout, TimeUnit unit) throws TimeoutException {\n", "   * Returns the name of this service. {@link AbstractExecutionThreadService}\n", "   * may include the name in debugging output.\n"]}, "added_lines": {"1": [4, 5, 9, 10, 11, 12], "2": [27, 28, 29, 36, 37, 40, 41, 43, 44, 45, 46, 47, 48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 58, 59, 60, 61, 62, 63, 64, 65, 66, 67, 68, 69, 70, 71, 72, 73, 74, 75, 76, 77, 78, 79, 80, 81, 82, 83, 84, 85, 86, 88, 91, 92, 93, 94, 96, 97, 98, 99, 100], "3": [115, 116, 117], "4": [125, 126, 127], "5": [147, 148, 149, 150, 151, 153, 154], "6": [165, 166, 170, 171, 175, 176, 183, 184, 191, 192, 199, 200], "7": [208, 209], "8": [217, 218, 225, 226, 233, 234, 241, 242, 247, 248]}, "removed_lines": {"1": [4, 5, 6, 10, 11, 12, 13, 14], "2": [29, 30, 31, 32, 39, 40, 43, 44, 45, 46, 47, 48, 49, 50, 52, 53, 54, 55, 56, 57, 58, 59, 60, 61, 62, 63, 64, 65, 66, 67, 68, 69, 71, 72, 73, 74, 75, 76, 77, 78, 79, 80, 82, 83, 85, 86, 87, 89, 90, 91, 92], "3": [107, 108, 109], "4": [117, 118], "5": [138, 139, 140, 141, 142, 143, 145, 146], "6": [157, 161, 165, 172, 179, 186], "7": [194], "8": [202, 209, 216, 223, 228, 229]}}, {"5": "guava/src/com/google/common/util/concurrent/AbstractFuture.java", "added": {"1": [" * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not use this file except\n", " * in compliance with the License. You may obtain a copy of the License at\n", " * Unless required by applicable law or agreed to in writing, software distributed under the License\n", " * is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express\n", " * or implied. See the License for the specific language governing permissions and limitations under\n", " * the License.\n"], "2": ["    @Override\n", "    public final V get() throws InterruptedException, ExecutionException {\n", "    @Override\n", "    public final V get(long timeout, TimeUnit unit)\n", "    @Override\n", "    public final boolean isDone() {\n", "    @Override\n", "    public final boolean isCancelled() {\n", "    @Override\n", "    public final void addListener(Runnable listener, Executor executor) {\n"], "3": ["    /**\n", "     * Constructor for the TOMBSTONE, avoids use of ATOMIC_HELPER in case this class is loaded\n", "     * before the ATOMIC_HELPER. Apparently this is possible on some android platforms.\n", "     */\n"], "4": ["    node.thread = null; // mark as 'deleted'\n", "    restart:\n", "    while (true) {\n", "        return; // give up if someone is calling complete\n", "        if (curr.thread != null) { // we aren't unlinking this node, update pred.\n", "          if (pred.thread == null) { // We raced with another node that unlinked pred. Restart.\n", "        } else if (!ATOMIC_HELPER.casWaiters(this, curr, succ)) { // We are unlinking head\n", "          continue restart; // We raced with an add or complete\n"], "5": ["    static final Failure FALLBACK_INSTANCE =\n", "        new Failure(\n", "            new Throwable(\"Failure occurred while trying to finish a future.\") {\n", "              @Override\n", "              public synchronized Throwable fillInStackTrace() {\n", "                return this; // no stack trace\n", "              }\n", "            });\n"], "6": ["    @Override\n", "    public void run() {\n"], "8": ["  /*\n", "   * Improve the documentation of when InterruptedException is thrown. Our behavior matches the\n", "   * JDK's, but the JDK's documentation is misleading.\n", "   */\n", "\n", "   * <p>The default {@link AbstractFuture} implementation throws {@code InterruptedException} if the\n", "   * current thread is interrupted before or during the call, even if the value is already\n", "   * available.\n", "   * @throws InterruptedException if the current thread was interrupted before or during the call\n", "   *     (optional but recommended).\n"], "9": ["    long_wait_loop:\n", "    if (remainingNanos >= SPIN_THRESHOLD_NANOS) {\n"], "10": ["                break long_wait_loop; // jump down to the busy wait loop\n", "          oldHead = waiters; // re-read and loop.\n"], "11": ["   * Improve the documentation of when InterruptedException is thrown. Our behavior matches the\n", "   * JDK's, but the JDK's documentation is misleading.\n", "\n", "   * <p>The default {@link AbstractFuture} implementation throws {@code InterruptedException} if the\n", "   * current thread is interrupted before or during the call, even if the value is already\n", "   * available.\n", "   * @throws InterruptedException if the current thread was interrupted before or during the call\n", "   *     (optional but recommended).\n", "  @Override\n", "  public V get() throws InterruptedException, ExecutionException {\n"], "12": ["        oldHead = waiters; // re-read and loop.\n"], "13": ["      @SuppressWarnings(\"unchecked\") // this is the only other option\n"], "14": ["      Throwable cause =\n", "          GENERATE_CANCELLATION_CAUSES\n", "              ? new CancellationException(\"Future.cancel() was called.\")\n", "              : null;\n"], "15": ["   * Subclasses can override this method to implement interruption of the future's computation. The\n", "   * method is invoked automatically by a successful call to {@link #cancel(boolean) cancel(true)}.\n", "  protected void interruptTask() {}\n", "   * Returns true if this future was cancelled with {@code mayInterruptIfRunning} set to {@code\n", "   * true}.\n"], "16": ["        oldHead = listeners; // re-read\n"], "17": ["  @Beta\n", "  protected boolean setFuture(ListenableFuture<? extends V> future) {\n"], "18": ["      localValue = value; // we lost the cas, fall through and maybe cancel\n"], "19": ["      log.log(\n", "          Level.SEVERE,\n", "          \"RuntimeException while executing runnable \" + runnable + \" with executor \" + executor,\n", "          e);\n"], "20": ["          unsafe =\n", "              AccessController.doPrivileged(\n", "                  new PrivilegedExceptionAction<sun.misc.Unsafe>() {\n", "                    @Override\n", "                    public sun.misc.Unsafe run() throws Exception {\n", "                      Class<sun.misc.Unsafe> k = sun.misc.Unsafe.class;\n", "                      for (java.lang.reflect.Field f : k.getDeclaredFields()) {\n", "                        f.setAccessible(true);\n", "                        Object x = f.get(null);\n", "                        if (k.isInstance(x)) {\n", "                          return k.cast(x);\n", "                        }\n", "                      }\n", "                      throw new NoSuchFieldError(\"the Unsafe\");\n", "                  });\n"], "21": ["    @Override\n", "    void putThread(Waiter waiter, Thread thread) {\n", "    @Override\n", "    void putNext(Waiter waiter, Waiter next) {\n", "    @Override\n", "    boolean casWaiters(AbstractFuture future, Waiter curr, Waiter next) {\n", "    @Override\n", "    boolean casListeners(AbstractFuture future, Listener curr, Listener next) {\n", "    @Override\n", "    boolean casValue(AbstractFuture future, Object expected, Object v) {\n"]}, "removed": {"1": [" * Licensed under the Apache License, Version 2.0 (the \"License\");\n", " * you may not use this file except in compliance with the License.\n", " * You may obtain a copy of the License at\n", " * Unless required by applicable law or agreed to in writing, software\n", " * distributed under the License is distributed on an \"AS IS\" BASIS,\n", " * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n", " * See the License for the specific language governing permissions and\n", " * limitations under the License.\n"], "2": ["    @Override public final V get() throws InterruptedException, ExecutionException {\n", "    @Override public final V get(long timeout, TimeUnit unit)\n", "    @Override public final boolean isDone() {\n", "    @Override public final boolean isCancelled() {\n", "    @Override public final void addListener(Runnable listener, Executor executor) {\n"], "3": ["    // Constructor for the TOMBSTONE, avoids use of ATOMIC_HELPER in case this class is loaded\n", "    // before the ATOMIC_HELPER.  Apparently this is possible on some android platforms.\n"], "4": ["    node.thread = null;  // mark as 'deleted'\n", "    restart: while (true) {\n", "        return;  // give up if someone is calling complete\n", "        if (curr.thread != null) {  // we aren't unlinking this node, update pred.\n", "          if (pred.thread == null) {  // We raced with another node that unlinked pred. Restart.\n", "        } else if (!ATOMIC_HELPER.casWaiters(this, curr, succ)) {  // We are unlinking head\n", "          continue restart;  // We raced with an add or complete\n"], "5": ["    static final Failure FALLBACK_INSTANCE = new Failure(\n", "        new Throwable(\"Failure occurred while trying to finish a future.\") {\n", "          @Override public synchronized Throwable fillInStackTrace() {\n", "            return this;  // no stack trace\n", "          }\n", "        });\n"], "6": ["    @Override public void run() {\n"], "7": ["  /*\n", "   * Improve the documentation of when InterruptedException is thrown. Our\n", "   * behavior matches the JDK's, but the JDK's documentation is misleading.\n", "   */\n", "\n"], "8": ["   * <p>The default {@link AbstractFuture} implementation throws {@code\n", "   * InterruptedException} if the current thread is interrupted before or during\n", "   * the call, even if the value is already available.\n", "   * @throws InterruptedException if the current thread was interrupted before\n", "   *     or during the call (optional but recommended).\n"], "9": ["    long_wait_loop: if (remainingNanos >= SPIN_THRESHOLD_NANOS) {\n"], "10": ["                break long_wait_loop;  // jump down to the busy wait loop\n", "          oldHead = waiters;  // re-read and loop.\n"], "11": ["   * Improve the documentation of when InterruptedException is thrown. Our\n", "   * behavior matches the JDK's, but the JDK's documentation is misleading.\n", "   * <p>The default {@link AbstractFuture} implementation throws {@code\n", "   * InterruptedException} if the current thread is interrupted before or during\n", "   * the call, even if the value is already available.\n", "   * @throws InterruptedException if the current thread was interrupted before\n", "   *     or during the call (optional but recommended).\n", "  @Override public V get() throws InterruptedException, ExecutionException {\n"], "12": ["        oldHead = waiters;  // re-read and loop.\n"], "13": ["      @SuppressWarnings(\"unchecked\")  // this is the only other option\n"], "14": ["      Throwable cause = GENERATE_CANCELLATION_CAUSES\n", "          ? new CancellationException(\"Future.cancel() was called.\")\n", "          : null;\n"], "15": ["   * Subclasses can override this method to implement interruption of the\n", "   * future's computation. The method is invoked automatically by a successful\n", "   * call to {@link #cancel(boolean) cancel(true)}.\n", "  protected void interruptTask() {\n", "  }\n", "   * Returns true if this future was cancelled with {@code\n", "   * mayInterruptIfRunning} set to {@code true}.\n"], "16": ["        oldHead = listeners;  // re-read\n"], "17": ["  @Beta protected boolean setFuture(ListenableFuture<? extends V> future) {\n"], "18": ["      localValue = value;  // we lost the cas, fall through and maybe cancel\n"], "19": ["      log.log(Level.SEVERE, \"RuntimeException while executing runnable \"\n", "          + runnable + \" with executor \" + executor, e);\n"], "20": ["          unsafe = AccessController.doPrivileged(\n", "              new PrivilegedExceptionAction<sun.misc.Unsafe>() {\n", "                @Override public sun.misc.Unsafe run() throws Exception {\n", "                  Class<sun.misc.Unsafe> k = sun.misc.Unsafe.class;\n", "                  for (java.lang.reflect.Field f : k.getDeclaredFields()) {\n", "                    f.setAccessible(true);\n", "                    Object x = f.get(null);\n", "                    if (k.isInstance(x)) {\n", "                      return k.cast(x);\n", "                  }\n", "                  throw new NoSuchFieldError(\"the Unsafe\");\n", "                }\n", "              });\n"], "21": ["    @Override void putThread(Waiter waiter, Thread thread) {\n", "    @Override void putNext(Waiter waiter, Waiter next) {\n", "    @Override boolean casWaiters(AbstractFuture future, Waiter curr, Waiter next) {\n", "    @Override boolean casListeners(AbstractFuture future, Listener curr, Listener next) {\n", "    @Override boolean casValue(AbstractFuture future, Object expected, Object v) {\n"]}, "added_lines": {"1": [4, 5, 9, 10, 11, 12], "2": [76, 77, 81, 82, 87, 88, 92, 93, 97, 98], "3": [157, 158, 159, 160], "4": [197, 198, 199, 203, 208, 212, 215, 216], "5": [244, 245, 246, 247, 248, 249, 250, 251], "6": [278, 279], "8": [341, 342, 343, 344, 345, 349, 350, 351, 353, 354], "9": [372, 373], "10": [400, 404], "11": [427, 428, 430, 434, 435, 436, 438, 439, 442, 443], "12": [473], "13": [494], "14": [527, 528, 529, 530], "15": [557, 558, 564, 567, 568], "16": [594], "17": [665, 666], "18": [694], "19": [827, 828, 829, 830], "20": [906, 907, 908, 909, 910, 911, 912, 913, 914, 915, 916, 917, 918, 919, 921], "21": [970, 971, 975, 976, 980, 981, 985, 986, 990, 991]}, "removed_lines": {"1": [4, 5, 6, 10, 11, 12, 13, 14], "2": [78, 82, 87, 91, 95], "3": [154, 155], "4": [192, 193, 197, 202, 206, 209, 210], "5": [238, 239, 240, 241, 242, 243], "6": [270], "7": [308, 309, 310, 311, 312], "8": [340, 341, 342, 344, 345], "9": [363], "10": [390, 394], "11": [417, 418, 423, 424, 425, 427, 428, 431], "12": [461], "13": [482], "14": [515, 516, 517], "15": [544, 545, 546, 552, 553, 556, 557], "16": [583], "17": [654], "18": [682], "19": [815, 816], "20": [892, 893, 894, 895, 896, 897, 898, 899, 900, 902, 903, 904, 905], "21": [954, 958, 962, 966, 970]}}, {"6": "guava/src/com/google/common/util/concurrent/AbstractIdleService.java", "added": {"1": [" * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not use this file except\n", " * in compliance with the License. You may obtain a copy of the License at\n", " * Unless required by applicable law or agreed to in writing, software distributed under the License\n", " * is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express\n", " * or implied. See the License for the specific language governing permissions and limitations under\n", " * the License.\n"], "2": [" * Base class for services that do not need a thread while \"running\" but may need one during startup\n", " * and shutdown. Subclasses can implement {@link #startUp} and {@link #shutDown} methods, each which\n", " * run in a executor which by default uses a separate thread for each method.\n"], "3": ["    @Override\n", "    public String get() {\n"], "4": ["    @Override\n", "    protected final void doStart() {\n", "          .execute(\n", "              new Runnable() {\n", "                @Override\n", "                public void run() {\n", "                  try {\n", "                    startUp();\n", "                    notifyStarted();\n", "                  } catch (Throwable t) {\n", "                    notifyFailed(t);\n", "                  }\n", "                }\n", "              });\n", "    @Override\n", "    protected final void doStop() {\n", "          .execute(\n", "              new Runnable() {\n", "                @Override\n", "                public void run() {\n", "                  try {\n", "                    shutDown();\n", "                    notifyStopped();\n", "                  } catch (Throwable t) {\n", "                    notifyFailed(t);\n", "                  }\n", "                }\n", "              });\n", "    @Override\n", "    public String toString() {\n"], "5": ["   * Returns the {@link Executor} that will be used to run this service. Subclasses may override\n", "   * this method to use a custom {@link Executor}, which may configure its worker thread with a\n", "   * specific name, thread group or priority. The returned executor's {@link\n", "   * Executor#execute(Runnable) execute()} method is called when this service is started and\n", "   * stopped, and should return promptly.\n", "      @Override\n", "      public void execute(Runnable command) {\n", "  @Override\n", "  public String toString() {\n", "  @Override\n", "  public final boolean isRunning() {\n", "  @Override\n", "  public final State state() {\n", "  @Override\n", "  public final void addListener(Listener listener, Executor executor) {\n", "  @Override\n", "  public final Throwable failureCause() {\n", "  @Override\n", "  public final Service startAsync() {\n"], "6": ["  @Override\n", "  public final Service stopAsync() {\n"], "7": ["  @Override\n", "  public final void awaitRunning() {\n", "  @Override\n", "  public final void awaitRunning(long timeout, TimeUnit unit) throws TimeoutException {\n", "  @Override\n", "  public final void awaitTerminated() {\n", "  @Override\n", "  public final void awaitTerminated(long timeout, TimeUnit unit) throws TimeoutException {\n"]}, "removed": {"1": [" * Licensed under the Apache License, Version 2.0 (the \"License\");\n", " * you may not use this file except in compliance with the License.\n", " * You may obtain a copy of the License at\n", " * Unless required by applicable law or agreed to in writing, software\n", " * distributed under the License is distributed on an \"AS IS\" BASIS,\n", " * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n", " * See the License for the specific language governing permissions and\n", " * limitations under the License.\n"], "2": [" * Base class for services that do not need a thread while \"running\"\n", " * but may need one during startup and shutdown. Subclasses can\n", " * implement {@link #startUp} and {@link #shutDown} methods, each\n", " * which run in a executor which by default uses a separate thread\n", " * for each method.\n"], "3": ["    @Override public String get() {\n"], "4": ["    @Override protected final void doStart() {\n", "          .execute(new Runnable() {\n", "            @Override public void run() {\n", "              try {\n", "                startUp();\n", "                notifyStarted();\n", "              } catch (Throwable t) {\n", "                notifyFailed(t);\n", "              }\n", "            }\n", "          });\n", "    @Override protected final void doStop() {\n", "          .execute(new Runnable() {\n", "            @Override public void run() {\n", "              try {\n", "                shutDown();\n", "                notifyStopped();\n", "              } catch (Throwable t) {\n", "                notifyFailed(t);\n", "              }\n", "            }\n", "          });\n", "    @Override public String toString() {\n"], "5": ["   * Returns the {@link Executor} that will be used to run this service.\n", "   * Subclasses may override this method to use a custom {@link Executor}, which\n", "   * may configure its worker thread with a specific name, thread group or\n", "   * priority. The returned executor's {@link Executor#execute(Runnable)\n", "   * execute()} method is called when this service is started and stopped,\n", "   * and should return promptly.\n", "      @Override public void execute(Runnable command) {\n", "  @Override public String toString() {\n", "  @Override public final boolean isRunning() {\n", "  @Override public final State state() {\n", "  @Override public final void addListener(Listener listener, Executor executor) {\n", "  @Override public final Throwable failureCause() {\n", "  @Override public final Service startAsync() {\n"], "6": ["  @Override public final Service stopAsync() {\n"], "7": ["  @Override public final void awaitRunning() {\n", "  @Override public final void awaitRunning(long timeout, TimeUnit unit) throws TimeoutException {\n", "  @Override public final void awaitTerminated() {\n", "  @Override public final void awaitTerminated(long timeout, TimeUnit unit) throws TimeoutException {\n"]}, "added_lines": {"1": [4, 5, 9, 10, 11, 12], "2": [26, 27, 28], "3": [41, 42], "4": [52, 53, 55, 56, 57, 58, 59, 60, 61, 62, 63, 64, 65, 66, 69, 70, 72, 73, 74, 75, 76, 77, 78, 79, 80, 81, 82, 83, 86, 87], "5": [102, 103, 104, 105, 106, 110, 111, 117, 118, 122, 123, 127, 128, 135, 136, 143, 144, 151, 152], "6": [160, 161], "7": [169, 170, 177, 178, 185, 186, 193, 194]}, "removed_lines": {"1": [4, 5, 6, 10, 11, 12, 13, 14], "2": [28, 29, 30, 31, 32], "3": [45], "4": [55, 57, 58, 59, 60, 61, 62, 63, 64, 65, 66, 69, 71, 72, 73, 74, 75, 76, 77, 78, 79, 80, 83], "5": [98, 99, 100, 101, 102, 103, 107, 113, 117, 121, 128, 135, 142], "6": [150], "7": [158, 165, 172, 179]}}, {"7": "guava/src/com/google/common/util/concurrent/AbstractListeningExecutorService.java", "added": {"1": [" * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not use this file except\n", " * in compliance with the License. You may obtain a copy of the License at\n", " * Unless required by applicable law or agreed to in writing, software distributed under the License\n", " * is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express\n", " * or implied. See the License for the specific language governing permissions and limitations under\n", " * the License.\n"], "2": ["public abstract class AbstractListeningExecutorService extends AbstractExecutorService\n", "    implements ListeningExecutorService {\n", "  @Override\n", "  protected final <T> RunnableFuture<T> newTaskFor(Runnable runnable, T value) {\n", "  @Override\n", "  protected final <T> RunnableFuture<T> newTaskFor(Callable<T> callable) {\n", "  @Override\n", "  public ListenableFuture<?> submit(Runnable task) {\n", "  @Override\n", "  public <T> ListenableFuture<T> submit(Runnable task, @Nullable T result) {\n", "  @Override\n", "  public <T> ListenableFuture<T> submit(Callable<T> task) {\n"]}, "removed": {"1": [" * Licensed under the Apache License, Version 2.0 (the \"License\");\n", " * you may not use this file except in compliance with the License.\n", " * You may obtain a copy of the License at\n", " * Unless required by applicable law or agreed to in writing, software\n", " * distributed under the License is distributed on an \"AS IS\" BASIS,\n", " * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n", " * See the License for the specific language governing permissions and\n", " * limitations under the License.\n"], "2": ["public abstract class AbstractListeningExecutorService\n", "    extends AbstractExecutorService implements ListeningExecutorService {\n", "  @Override protected final <T> RunnableFuture<T> newTaskFor(Runnable runnable, T value) {\n", "  @Override protected final <T> RunnableFuture<T> newTaskFor(Callable<T> callable) {\n", "  @Override public ListenableFuture<?> submit(Runnable task) {\n", "  @Override public <T> ListenableFuture<T> submit(Runnable task, @Nullable T result) {\n", "  @Override public <T> ListenableFuture<T> submit(Callable<T> task) {\n"]}, "added_lines": {"1": [4, 5, 9, 10, 11, 12], "2": [37, 38, 41, 42, 47, 48, 52, 53, 57, 58, 62, 63]}, "removed_lines": {"1": [4, 5, 6, 10, 11, 12, 13, 14], "2": [39, 40, 43, 48, 52, 56, 60]}}, {"8": "guava/src/com/google/common/util/concurrent/AbstractScheduledService.java", "added": {"1": [" * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not use this file except\n", " * in compliance with the License. You may obtain a copy of the License at\n", " * Unless required by applicable law or agreed to in writing, software distributed under the License\n", " * is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express\n", " * or implied. See the License for the specific language governing permissions and limitations under\n", " * the License.\n"], "2": [" * {@link #runOneIteration} that will be executed periodically as specified by its {@link\n", " * Scheduler}. When this service is asked to stop via {@link #stopAsync} it will cancel the periodic\n", " * task (but not interrupt it) and wait for it to stop before running the {@link #shutDown} method.\n"], "3": [" * outstanding URIs when shutting down. Also, it takes advantage of the scheduling functionality to\n"], "4": ["   * service with a fixed schedule. If more flexibility is needed then consider subclassing {@link\n", "   * CustomScheduler}.\n", "     * Returns a {@link Scheduler} that schedules the task using the {@link\n", "     * ScheduledExecutorService#scheduleWithFixedDelay} method.\n", "     *     next\n", "    public static Scheduler newFixedDelaySchedule(\n", "        final long initialDelay, final long delay, final TimeUnit unit) {\n", "        public Future<?> schedule(\n", "            AbstractService service, ScheduledExecutorService executor, Runnable task) {\n", "     * Returns a {@link Scheduler} that schedules the task using the {@link\n", "     * ScheduledExecutorService#scheduleAtFixedRate} method.\n", "    public static Scheduler newFixedRateSchedule(\n", "        final long initialDelay, final long period, final TimeUnit unit) {\n", "        public Future<?> schedule(\n", "            AbstractService service, ScheduledExecutorService executor, Runnable task) {\n", "    abstract Future<?> schedule(\n", "        AbstractService service, ScheduledExecutorService executor, Runnable runnable);\n"], "5": ["      @Override\n", "      public void run() {\n"], "6": ["            logger.log(\n", "                Level.WARNING,\n", "                \"Error while attempting to shut down the service after failure.\",\n", "                ignored);\n", "          runningTask.cancel(false); // prevent future invocations.\n"], "7": ["    @Override\n", "    protected final void doStart() {\n", "      executorService =\n", "          MoreExecutors.renamingDecorator(\n", "              executor(),\n", "              new Supplier<String>() {\n", "                @Override\n", "                public String get() {\n", "                  return serviceName() + \" \" + state();\n", "                }\n", "              });\n", "      executorService.execute(\n", "          new Runnable() {\n", "            @Override\n", "            public void run() {\n", "              lock.lock();\n", "              try {\n", "                startUp();\n", "                runningTask = scheduler().schedule(delegate, executorService, task);\n", "                notifyStarted();\n", "              } catch (Throwable t) {\n", "                notifyFailed(t);\n", "                if (runningTask != null) {\n", "                  // prevent the task from running if possible\n", "                  runningTask.cancel(false);\n", "                }\n", "              } finally {\n", "                lock.unlock();\n", "              }\n", "          });\n", "    @Override\n", "    protected final void doStop() {\n", "      executorService.execute(\n", "          new Runnable() {\n", "            @Override\n", "            public void run() {\n", "              try {\n", "                lock.lock();\n", "                try {\n", "                  if (state() != State.STOPPING) {\n", "                    // This means that the state has changed since we were scheduled.  This implies\n", "                    // that an execution of runOneIteration has thrown an exception and we have\n", "                    // transitioned to a failed state, also this means that shutDown has already\n", "                    // been called, so we do not want to call it again.\n", "                    return;\n", "                  }\n", "                  shutDown();\n", "                } finally {\n", "                  lock.unlock();\n", "                }\n", "                notifyStopped();\n", "              } catch (Throwable t) {\n", "                notifyFailed(t);\n", "          });\n", "    @Override\n", "    public String toString() {\n"], "8": ["   * Returns the {@link Scheduler} object used to configure this service. This method will only be\n", "   * {@link #runOneIteration} and {@link #shutDown} methods. If this method is overridden the\n", "   * executor will not be {@linkplain ScheduledExecutorService#shutdown shutdown} when this service\n", "   * {@linkplain Service.State#TERMINATED terminates} or {@linkplain Service.State#TERMINATED\n", "   * fails}. Subclasses may override this method to supply a custom {@link ScheduledExecutorService}\n", "   * instance. This method is guaranteed to only be called once.\n", "   * pool that sets the name of the thread to the {@linkplain #serviceName() service name}. Also,\n", "   * the pool will be {@linkplain ScheduledExecutorService#shutdown() shut down} when the service\n", "   * {@linkplain Service.State#TERMINATED terminates} or {@linkplain Service.State#TERMINATED\n", "   * fails}.\n", "    @WeakOuter\n", "    class ThreadFactoryImpl implements ThreadFactory {\n", "      @Override\n", "      public Thread newThread(Runnable runnable) {\n"], "9": ["    addListener(\n", "        new Listener() {\n", "          @Override\n", "          public void terminated(State from) {\n", "            executor.shutdown();\n", "          }\n", "\n", "          @Override\n", "          public void failed(State from, Throwable failure) {\n", "            executor.shutdown();\n", "          }\n", "        },\n", "        directExecutor());\n"], "10": ["  @Override\n", "  public String toString() {\n", "  @Override\n", "  public final boolean isRunning() {\n", "  @Override\n", "  public final State state() {\n", "  @Override\n", "  public final void addListener(Listener listener, Executor executor) {\n", "  @Override\n", "  public final Throwable failureCause() {\n", "  @Override\n", "  public final Service startAsync() {\n"], "11": ["  @Override\n", "  public final Service stopAsync() {\n"], "12": ["  @Override\n", "  public final void awaitRunning() {\n", "  @Override\n", "  public final void awaitRunning(long timeout, TimeUnit unit) throws TimeoutException {\n", "  @Override\n", "  public final void awaitTerminated() {\n", "  @Override\n", "  public final void awaitTerminated(long timeout, TimeUnit unit) throws TimeoutException {\n", "   * use a dynamically changing schedule. After every execution of the task, assuming it hasn't been\n", "   * cancelled, the {@link #getNextSchedule} method will be called.\n"], "13": ["       * The service that is managing this callable. This is used so that failure can be reported\n", "       * properly.\n", "       * not scheduled while a cancel is ongoing. Also it protects the currentFuture variable to\n"], "14": ["      ReschedulableCallable(\n", "          AbstractService service, ScheduledExecutorService executor, Runnable runnable) {\n"], "15": ["    final Future<?> schedule(\n", "        AbstractService service, ScheduledExecutorService executor, Runnable runnable) {\n"]}, "removed": {"1": [" * Licensed under the Apache License, Version 2.0 (the \"License\");\n", " * you may not use this file except in compliance with the License.\n", " * You may obtain a copy of the License at\n", " * Unless required by applicable law or agreed to in writing, software\n", " * distributed under the License is distributed on an \"AS IS\" BASIS,\n", " * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n", " * See the License for the specific language governing permissions and\n", " * limitations under the License.\n"], "2": [" * {@link #runOneIteration} that will be executed periodically as specified by its \n", " * {@link Scheduler}. When this service is asked to stop via {@link #stopAsync} it will cancel the \n", " * periodic task (but not interrupt it) and wait for it to stop before running the \n", " * {@link #shutDown} method.  \n"], "3": [" * outstanding URIs when shutting down.  Also, it takes advantage of the scheduling functionality to\n"], "4": ["   * service with a fixed schedule.  If more flexibility is needed then consider subclassing  \n", "   * {@link CustomScheduler}. \n", "     * Returns a {@link Scheduler} that schedules the task using the \n", "     * {@link ScheduledExecutorService#scheduleWithFixedDelay} method.\n", "     *        next\n", "    public static Scheduler newFixedDelaySchedule(final long initialDelay, final long delay, \n", "        final TimeUnit unit) {\n", "        public Future<?> schedule(AbstractService service, ScheduledExecutorService executor,\n", "            Runnable task) {\n", "     * Returns a {@link Scheduler} that schedules the task using the \n", "     * {@link ScheduledExecutorService#scheduleAtFixedRate} method.\n", "    public static Scheduler newFixedRateSchedule(final long initialDelay, final long period, \n", "        final TimeUnit unit) {\n", "        public Future<?> schedule(AbstractService service, ScheduledExecutorService executor,\n", "            Runnable task) {\n", "    abstract Future<?> schedule(AbstractService service, ScheduledExecutorService executor, \n", "        Runnable runnable);\n"], "5": ["      @Override public void run() {\n"], "6": ["            logger.log(Level.WARNING,\n", "                \"Error while attempting to shut down the service after failure.\", ignored);\n", "          runningTask.cancel(false);  // prevent future invocations.\n"], "7": ["    @Override protected final void doStart() {\n", "      executorService = MoreExecutors.renamingDecorator(executor(), new Supplier<String>() {\n", "        @Override public String get() {\n", "          return serviceName() + \" \" + state();\n", "        }\n", "      });\n", "      executorService.execute(new Runnable() {\n", "        @Override public void run() {\n", "          lock.lock();\n", "          try {\n", "            startUp();\n", "            runningTask = scheduler().schedule(delegate, executorService, task);\n", "            notifyStarted();\n", "          } catch (Throwable t) {\n", "            notifyFailed(t);\n", "            if (runningTask != null) {\n", "              // prevent the task from running if possible\n", "              runningTask.cancel(false);\n", "          } finally {\n", "            lock.unlock();\n", "          }\n", "        }\n", "      });\n", "    @Override protected final void doStop() {\n", "      executorService.execute(new Runnable() {\n", "        @Override public void run() {\n", "          try {\n", "            lock.lock();\n", "            try {\n", "              if (state() != State.STOPPING) {\n", "                // This means that the state has changed since we were scheduled.  This implies that\n", "                // an execution of runOneIteration has thrown an exception and we have transitioned\n", "                // to a failed state, also this means that shutDown has already been called, so we\n", "                // do not want to call it again.\n", "                return;\n", "              shutDown();\n", "            } finally {\n", "              lock.unlock();\n", "            notifyStopped();\n", "          } catch (Throwable t) {\n", "            notifyFailed(t);\n", "          }\n", "        }\n", "      });\n", "    @Override public String toString() {\n"], "8": ["   * Returns the {@link Scheduler} object used to configure this service.  This method will only be\n", "   * {@link #runOneIteration} and {@link #shutDown} methods.  If this method is overridden the \n", "   * executor will not be {@linkplain ScheduledExecutorService#shutdown shutdown} when this \n", "   * service {@linkplain Service.State#TERMINATED terminates} or \n", "   * {@linkplain Service.State#TERMINATED fails}. Subclasses may override this method to supply a \n", "   * custom {@link ScheduledExecutorService} instance. This method is guaranteed to only be called \n", "   * once.\n", "   * pool that sets the name of the thread to the {@linkplain #serviceName() service name}.  \n", "   * Also, the pool will be {@linkplain ScheduledExecutorService#shutdown() shut down} when the \n", "   * service {@linkplain Service.State#TERMINATED terminates} or \n", "   * {@linkplain Service.State#TERMINATED fails}.\n", "    @WeakOuter class ThreadFactoryImpl implements ThreadFactory {\n", "      @Override public Thread newThread(Runnable runnable) {\n"], "9": ["    addListener(new Listener() {\n", "      @Override public void terminated(State from) {\n", "        executor.shutdown();\n", "      }\n", "      @Override public void failed(State from, Throwable failure) {\n", "        executor.shutdown();\n", "      }\n", "    }, directExecutor());\n"], "10": ["  @Override public String toString() {\n", "  @Override public final boolean isRunning() {\n", "  @Override public final State state() {\n", "  @Override public final void addListener(Listener listener, Executor executor) {\n", "  @Override public final Throwable failureCause() {\n", "  @Override public final Service startAsync() {\n"], "11": ["  @Override public final Service stopAsync() {\n"], "12": ["  @Override public final void awaitRunning() {\n", "  @Override public final void awaitRunning(long timeout, TimeUnit unit) throws TimeoutException {\n", "  @Override public final void awaitTerminated() {\n", "  @Override public final void awaitTerminated(long timeout, TimeUnit unit) throws TimeoutException {\n", "   * use a dynamically changing schedule.  After every execution of the task, assuming it hasn't \n", "   * been cancelled, the {@link #getNextSchedule} method will be called.\n"], "13": ["       * The service that is managing this callable.  This is used so that failure can be \n", "       * reported properly.\n", "       * not scheduled while a cancel is ongoing.  Also it protects the currentFuture variable to \n"], "14": ["      ReschedulableCallable(AbstractService service, ScheduledExecutorService executor, \n", "          Runnable runnable) {\n"], "15": ["    final Future<?> schedule(AbstractService service, ScheduledExecutorService executor, \n", "        Runnable runnable) {\n"]}, "added_lines": {"1": [4, 5, 9, 10, 11, 12], "2": [46, 47, 48], "3": [87], "4": [103, 104, 111, 112, 116, 119, 120, 125, 126, 133, 134, 140, 141, 146, 147, 154, 155], "5": [179, 180], "6": [192, 193, 194, 195, 198], "7": [207, 208, 209, 210, 211, 212, 213, 214, 215, 216, 217, 218, 219, 220, 221, 222, 223, 224, 225, 226, 227, 228, 229, 230, 231, 232, 233, 234, 235, 237, 240, 241, 243, 244, 245, 246, 247, 248, 249, 250, 251, 252, 253, 254, 255, 256, 257, 258, 259, 260, 261, 262, 263, 266, 269, 270], "8": [300, 307, 308, 309, 310, 311, 314, 315, 316, 317, 320, 321, 322, 323], "9": [334, 335, 336, 337, 338, 339, 340, 341, 342, 343, 344, 345, 346], "10": [360, 361, 365, 366, 370, 371, 378, 379, 386, 387, 394, 395], "11": [403, 404], "12": [412, 413, 420, 421, 428, 429, 436, 437, 443, 444], "13": [464, 465, 471], "14": [480, 481], "15": [566, 567]}, "removed_lines": {"1": [4, 5, 6, 10, 11, 12, 13, 14], "2": [48, 49, 50, 51], "3": [90], "4": [106, 107, 114, 115, 119, 122, 123, 128, 129, 136, 137, 143, 144, 149, 150, 157, 158], "5": [182], "6": [194, 195, 198], "7": [207, 208, 209, 210, 211, 212, 213, 214, 215, 216, 217, 218, 219, 220, 221, 222, 223, 224, 226, 227, 228, 229, 230, 233, 235, 236, 237, 238, 239, 240, 241, 242, 243, 244, 245, 247, 248, 249, 251, 252, 253, 254, 255, 256, 259], "8": [289, 296, 297, 298, 299, 300, 301, 304, 305, 306, 307, 310, 311], "9": [322, 323, 324, 325, 326, 327, 328, 329], "10": [343, 347, 351, 358, 365, 372], "11": [380], "12": [388, 395, 402, 409, 415, 416], "13": [436, 437, 443], "14": [452, 453], "15": [538, 539]}}, {"9": "guava/src/com/google/common/util/concurrent/AbstractService.java", "added": {"1": [" * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not use this file except\n", " * in compliance with the License. You may obtain a copy of the License at\n", " * Unless required by applicable law or agreed to in writing, software distributed under the License\n", " * is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express\n", " * or implied. See the License for the specific language governing permissions and limitations under\n", " * the License.\n"], "2": [" * callbacks. Its subclasses must manage threads manually; consider {@link\n", " * AbstractExecutionThreadService} if you need only a single execution thread.\n"], "3": ["        @Override\n", "        void call(Listener listener) {\n", "        @Override\n", "        void call(Listener listener) {\n"], "4": ["  private static final Callback<Listener> TERMINATED_FROM_NEW_CALLBACK = terminatedCallback(NEW);\n"], "5": ["      @Override\n", "      void call(Listener listener) {\n"], "6": ["      @Override\n", "      void call(Listener listener) {\n"], "7": ["    @Override\n", "    public boolean isSatisfied() {\n"], "8": ["    @Override\n", "    public boolean isSatisfied() {\n"], "9": ["    @Override\n", "    public boolean isSatisfied() {\n"], "10": ["    @Override\n", "    public boolean isSatisfied() {\n"], "11": ["   * The current state of the service. This should be written with the lock held but can be read\n", "   * without it because it is an immutable object in a volatile field. This is desirable so that\n"], "12": ["   * or after it has returned. If startup fails, the invocation should cause a call to {@link\n", "   * #notifyFailed(Throwable)} instead.\n"], "13": ["   * returned. If shutdown fails, the invocation should cause a call to {@link\n", "   * #notifyFailed(Throwable)} instead.\n", "   * <p>This method should return promptly; prefer to do work on a different thread where it is\n", "  @Override\n", "  public final Service startAsync() {\n"], "14": ["  @Override\n", "  public final Service stopAsync() {\n"], "15": ["  @Override\n", "  public final void awaitRunning() {\n"], "16": ["  @Override\n", "  public final void awaitRunning(long timeout, TimeUnit unit) throws TimeoutException {\n"], "17": ["  @Override\n", "  public final void awaitTerminated() {\n"], "18": ["  @Override\n", "  public final void awaitTerminated(long timeout, TimeUnit unit) throws TimeoutException {\n"], "19": ["      throw new TimeoutException(\n", "          \"Timed out waiting for \"\n", "              + this\n", "              + \" to reach a terminal state. \"\n", "              + \"Current state: \"\n", "              + state());\n"], "20": ["        throw new IllegalStateException(\n", "            \"Expected the service to be \" + expected + \", but the service has FAILED\",\n", "            failureCause());\n", "      throw new IllegalStateException(\n", "          \"Expected the service to be \" + expected + \", but was \" + actual);\n"], "21": ["        IllegalStateException failure =\n", "            new IllegalStateException(\n", "                \"Cannot notifyStarted() when the service is \" + snapshot.state);\n"], "22": ["   * @throws IllegalStateException if the service is neither {@link State#STOPPING} nor {@link\n", "   *     State#RUNNING}.\n"], "23": ["        IllegalStateException failure =\n", "            new IllegalStateException(\"Cannot notifyStopped() when the service is \" + previous);\n"], "24": ["  @Override\n", "  public String toString() {\n"], "25": ["    switch (from) {\n"], "26": ["      @Override\n", "      void call(Listener listener) {\n"], "27": ["    @Nullable final Throwable failure;\n"], "28": ["      checkArgument(\n", "          !shutdownWhenStartupFinishes || internalState == STARTING,\n", "      checkArgument(\n", "          !(failure != null ^ internalState == FAILED),\n", "              + \"instead.\",\n", "          internalState,\n", "          failure);\n"], "29": ["      checkState(\n", "          state == FAILED,\n", "          \"failureCause() is only valid if the service has failed, service is %s\",\n", "          state);\n"]}, "removed": {"1": [" * Licensed under the Apache License, Version 2.0 (the \"License\");\n", " * you may not use this file except in compliance with the License.\n", " * You may obtain a copy of the License at\n", " * Unless required by applicable law or agreed to in writing, software\n", " * distributed under the License is distributed on an \"AS IS\" BASIS,\n", " * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n", " * See the License for the specific language governing permissions and\n", " * limitations under the License.\n"], "2": [" * callbacks. Its subclasses must manage threads manually; consider\n", " * {@link AbstractExecutionThreadService} if you need only a single execution thread.\n"], "3": ["        @Override void call(Listener listener) {\n", "        @Override void call(Listener listener) {\n"], "4": ["  private static final Callback<Listener> TERMINATED_FROM_NEW_CALLBACK = \n", "      terminatedCallback(NEW);\n"], "5": ["      @Override void call(Listener listener) {\n"], "6": ["      @Override void call(Listener listener) {\n"], "7": ["    @Override public boolean isSatisfied() {\n"], "8": ["    @Override public boolean isSatisfied() {\n"], "9": ["    @Override public boolean isSatisfied() {\n"], "10": ["    @Override public boolean isSatisfied() {\n"], "11": ["   * The current state of the service.  This should be written with the lock held but can be read\n", "   * without it because it is an immutable object in a volatile field.  This is desirable so that\n"], "12": ["   * or after it has returned. If startup fails, the invocation should cause a call to\n", "   * {@link #notifyFailed(Throwable)} instead.\n"], "13": ["   * returned. If shutdown fails, the invocation should cause a call to\n", "   * {@link #notifyFailed(Throwable)} instead.\n", "   * <p> This method should return promptly; prefer to do work on a different thread where it is\n", "  @Override public final Service startAsync() {\n"], "14": ["  @Override public final Service stopAsync() {\n"], "15": ["  @Override public final void awaitRunning() {\n"], "16": ["  @Override public final void awaitRunning(long timeout, TimeUnit unit) throws TimeoutException {\n"], "17": ["  @Override public final void awaitTerminated() {\n"], "18": ["  @Override public final void awaitTerminated(long timeout, TimeUnit unit) throws TimeoutException {\n"], "19": ["      throw new TimeoutException(\"Timed out waiting for \" + this + \" to reach a terminal state. \"\n", "          + \"Current state: \" + state());\n"], "20": ["        throw new IllegalStateException(\"Expected the service to be \" + expected \n", "            + \", but the service has FAILED\", failureCause());\n", "      throw new IllegalStateException(\"Expected the service to be \" + expected + \", but was \" \n", "          + actual);\n"], "21": ["        IllegalStateException failure = new IllegalStateException(\n", "            \"Cannot notifyStarted() when the service is \" + snapshot.state);\n"], "22": ["   * @throws IllegalStateException if the service is neither {@link State#STOPPING} nor\n", "   *         {@link State#RUNNING}.\n"], "23": ["        IllegalStateException failure = new IllegalStateException(\n", "            \"Cannot notifyStopped() when the service is \" + previous);\n"], "24": ["  @Override public String toString() {\n"], "25": ["    switch(from) {\n"], "26": ["      @Override void call(Listener listener) {\n"], "27": ["    @Nullable\n", "    final Throwable failure;\n"], "28": ["      checkArgument(!shutdownWhenStartupFinishes || internalState == STARTING, \n", "      checkArgument(!(failure != null ^ internalState == FAILED),\n", "          + \"instead.\", internalState, failure);\n"], "29": ["      checkState(state == FAILED, \n", "          \"failureCause() is only valid if the service has failed, service is %s\", state);\n"]}, "added_lines": {"1": [4, 5, 9, 10, 11, 12], "2": [47, 48], "3": [58, 59, 65, 66], "4": [75], "5": [83, 84], "6": [92, 93], "7": [109, 110], "8": [123, 124], "9": [137, 138], "10": [151, 152], "11": [165, 166], "12": [182, 183], "13": [194, 195, 197, 203, 204], "14": [222, 223], "15": [259, 260], "16": [269, 270], "17": [286, 287], "18": [296, 297], "19": [309, 310, 311, 312, 313, 314], "20": [325, 326, 327, 329, 330], "21": [346, 347, 348], "22": [372, 373], "23": [382, 383], "24": [463, 464], "25": [504], "26": [526, 527], "27": [556], "28": [564, 565, 568, 569, 571, 572, 573], "29": [590, 591, 592, 593]}, "removed_lines": {"1": [4, 5, 6, 10, 11, 12, 13, 14], "2": [49, 50], "3": [60, 66], "4": [75, 76], "5": [84], "6": [92], "7": [108], "8": [121], "9": [134], "10": [147], "11": [160, 161], "12": [177, 178], "13": [189, 190, 192, 198], "14": [216], "15": [252], "16": [261], "17": [277], "18": [286], "19": [298, 299], "20": [310, 311, 313, 314], "21": [330, 331], "22": [355, 356], "23": [365, 366], "24": [446], "25": [486], "26": [508], "27": [537, 538], "28": [546, 549, 551], "29": [568, 569]}}, {"10": "guava/src/com/google/common/util/concurrent/AggregateFuture.java", "added": {"1": [" * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not use this file except\n", " * in compliance with the License. You may obtain a copy of the License at\n", " * Unless required by applicable law or agreed to in writing, software distributed under the License\n", " * is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express\n", " * or implied. See the License for the specific language governing permissions and limitations under\n", " * the License.\n"], "2": ["  private static final Logger logger = Logger.getLogger(AggregateFuture.class.getName());\n", "  @Override\n", "  final void done() {\n"], "3": ["  @Override\n", "  public final boolean cancel(boolean mayInterruptIfRunning) {\n"], "4": ["  @Override\n", "  protected final void interruptTask() {\n"], "5": ["    RunningState(\n", "        ImmutableCollection<? extends ListenableFuture<? extends InputT>> futures,\n", "        boolean allMustSucceed,\n", "        boolean collectsValues) {\n"], "6": ["    @Override\n", "    public final void run() {\n", "     * futures are already complete, we would not initialize the subclass before calling {@link\n", "     * #handleOneInputDone}. As this is called after the subclass is constructed, we're guaranteed\n", "     * to have properly initialized the subclass.\n"], "7": ["      // NOTE: If we ever want to use a custom executor here, have a look at CombinedFuture as we'll\n", "      // need to handle RejectedExecutionException\n", "        // Register a listener on each Future in the list to update the state of this future.\n", "        // Note that if all the futures on the list are done prior to completing this loop, the last\n", "        // call to addListener() will callback to setOneValue(), transitively call our cleanup\n", "        // listener, and set this.futures to null.\n", "        // This is not actually a problem, since the foreach only needs this.futures to be non-null\n", "        // at the beginning of the loop.\n", "          listenable.addListener(\n", "              new Runnable() {\n", "                @Override\n", "                public void run() {\n", "                  try {\n", "                    handleOneInputDone(index, listenable);\n", "                  } finally {\n", "                    decrementCountAndMaybeComplete();\n", "                  }\n", "                }\n", "              },\n", "              directExecutor());\n"], "8": ["     * Fails this future with the given Throwable if {@link #allMustSucceed} is true. Also, logs the\n", "     * throwable if it is an {@link Error} or if {@link #allMustSucceed} is {@code true}, the\n", "     * throwable did not cause this future to fail, and it is the first time we've seen that\n", "     * particular Throwable.\n"], "9": ["          // Go up the causal chain to see if we've already seen this cause; if we have, even if\n", "          // it's wrapped by a different exception, don't log it.\n"], "10": ["      // The only cases in which this Future should already be done are (a) if it was cancelled or\n", "      // (b) if an input failed and we propagated that immediately because of allMustSucceed.\n", "      checkState(\n", "          allMustSucceed || !isDone() || isCancelled(),\n", "        checkState(future.isDone(), \"Tried to set value from future which is not done\");\n", "            // this.cancel propagates the cancellation to children; we use super.cancel to set our\n", "            // own state but let the input futures keep running as some of them may be used\n", "            // elsewhere.\n"], "11": ["     * Listeners implicitly keep a reference to {@link RunningState} as they're inner classes, so we\n", "     * free resources here as well for the allMustSucceed=true case (i.e. when a future fails, we\n", "     * immediately release resources we no longer need); additionally, the future will release its\n", "     * reference to {@link RunningState}, which should free all associated memory when all the\n", "     * futures complete and the listeners are released.\n"], "12": ["     * <p>If {@code allMustSucceed} is true, called as each future completes; otherwise, called for\n", "     * each future when all futures complete.\n"]}, "removed": {"1": [" * Licensed under the Apache License, Version 2.0 (the \"License\");\n", " * you may not use this file except in compliance with the License.\n", " * You may obtain a copy of the License at\n", " * Unless required by applicable law or agreed to in writing, software\n", " * distributed under the License is distributed on an \"AS IS\" BASIS,\n", " * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n", " * See the License for the specific language governing permissions and\n", " * limitations under the License.\n"], "2": ["  private static final Logger logger =\n", "      Logger.getLogger(AggregateFuture.class.getName());\n", "  @Override final void done() {\n"], "3": ["  @Override public final boolean cancel(boolean mayInterruptIfRunning) {\n"], "4": ["  @Override protected final void interruptTask() {\n"], "5": ["    RunningState(ImmutableCollection<? extends ListenableFuture<? extends InputT>> futures,\n", "        boolean allMustSucceed, boolean collectsValues) {\n"], "6": ["    @Override public final void run() {\n", "     * futures are already complete, we would not initialize the subclass before calling\n", "     * {@link #handleOneInputDone}. As this is called after the subclass is constructed, we're\n", "     * guaranteed to have properly initialized the subclass.\n"], "7": ["      // NOTE: If we ever want to use a custom executor here, have a look at\n", "      // CombinedFuture as we'll need to handle RejectedExecutionException\n", "        // Register a listener on each Future in the list to update\n", "        // the state of this future.\n", "        // Note that if all the futures on the list are done prior to completing\n", "        // this loop, the last call to addListener() will callback to\n", "        // setOneValue(), transitively call our cleanup listener, and set\n", "        // this.futures to null.\n", "        // This is not actually a problem, since the foreach only needs\n", "        // this.futures to be non-null at the beginning of the loop.\n", "          listenable.addListener(new Runnable() {\n", "            @Override\n", "            public void run() {\n", "              try {\n", "                handleOneInputDone(index, listenable);\n", "              } finally {\n", "                decrementCountAndMaybeComplete();\n", "              }\n", "            }\n", "          }, directExecutor());\n"], "8": ["     * Fails this future with the given Throwable if {@link #allMustSucceed} is\n", "     * true. Also, logs the throwable if it is an {@link Error} or if\n", "     * {@link #allMustSucceed} is {@code true}, the throwable did not cause\n", "     * this future to fail, and it is the first time we've seen that particular Throwable.\n"], "9": ["          // Go up the causal chain to see if we've already seen this cause; if we have,\n", "          // even if it's wrapped by a different exception, don't log it.\n"], "10": ["      // The only cases in which this Future should already be done are (a) if\n", "      // it was cancelled or (b) if an input failed and we propagated that\n", "      // immediately because of allMustSucceed.\n", "      checkState(allMustSucceed || !isDone() || isCancelled(),\n", "        checkState(future.isDone(),\n", "            \"Tried to set value from future which is not done\");\n", "            // this.cancel propagates the cancellation to children; we use super.cancel\n", "            // to set our own state but let the input futures keep running\n", "            // as some of them may be used elsewhere.\n"], "11": ["     * Listeners implicitly keep a reference to {@link RunningState} as they're inner classes,\n", "     * so we free resources here as well for the allMustSucceed=true case (i.e. when a future fails,\n", "     * we immediately release resources we no longer need); additionally, the future will release\n", "     * its reference to {@link RunningState}, which should free all associated memory when all the\n", "     * futures complete & the listeners are released.\n"], "12": ["     * <p>If {@code allMustSucceed} is true, called as each future completes; otherwise,\n", "     * called for each future when all futures complete.\n"]}, "added_lines": {"1": [4, 5, 9, 10, 11, 12], "2": [43, 47, 48], "3": [56, 57], "4": [74, 75], "5": [96, 97, 98, 99], "6": [107, 108, 114, 115, 116], "7": [125, 126, 132, 133, 134, 135, 136, 137, 141, 142, 143, 144, 145, 146, 147, 148, 149, 150, 151, 152], "8": [164, 165, 166, 167], "9": [181, 182], "10": [209, 210, 211, 212, 216, 219, 220, 221], "11": [261, 262, 263, 264, 265], "12": [276, 277]}, "removed_lines": {"1": [4, 5, 6, 10, 11, 12, 13, 14], "2": [45, 46, 50], "3": [58], "4": [75], "5": [96, 97], "6": [105, 111, 112, 113], "7": [122, 123, 129, 130, 131, 132, 133, 134, 135, 136, 140, 141, 142, 143, 144, 145, 146, 147, 148, 149], "8": [161, 162, 163, 164], "9": [178, 179], "10": [206, 207, 208, 209, 213, 214, 217, 218, 219], "11": [259, 260, 261, 262, 263], "12": [274, 275]}}, {"11": "guava/src/com/google/common/util/concurrent/AggregateFutureState.java", "added": {"1": [" * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not use this file except\n", " * in compliance with the License. You may obtain a copy of the License at\n", " * Unless required by applicable law or agreed to in writing, software distributed under the License\n", " * is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express\n", " * or implied. See the License for the specific language governing permissions and limitations under\n", " * the License.\n"], "2": ["      SEEN_EXCEPTIONS_UDPATER =\n", "          newUpdater(AggregateFutureState.class, (Class) Set.class, \"seenExceptions\");\n", "  private static final AtomicIntegerFieldUpdater<AggregateFutureState> REMAINING_COUNT_UPDATER =\n", "      newUpdater(AggregateFutureState.class, \"remaining\");\n", "\n", "  @SuppressWarnings(\"unused\")\n", "  private volatile int remaining;\n"]}, "removed": {"1": [" * Licensed under the Apache License, Version 2.0 (the \"License\");\n", " * you may not use this file except in compliance with the License.\n", " * You may obtain a copy of the License at\n", " * Unless required by applicable law or agreed to in writing, software\n", " * distributed under the License is distributed on an \"AS IS\" BASIS,\n", " * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n", " * See the License for the specific language governing permissions and\n", " * limitations under the License.\n"], "2": ["      SEEN_EXCEPTIONS_UDPATER = newUpdater(\n", "          AggregateFutureState.class, (Class) Set.class, \"seenExceptions\");\n", "  private static final AtomicIntegerFieldUpdater<AggregateFutureState>\n", "      REMAINING_COUNT_UPDATER = newUpdater(AggregateFutureState.class, \"remaining\");\n", "  @SuppressWarnings(\"unused\") private volatile int remaining;\n"]}, "added_lines": {"1": [4, 5, 9, 10, 11, 12], "2": [37, 38, 40, 41, 46, 47, 48]}, "removed_lines": {"1": [4, 5, 6, 10, 11, 12, 13, 14], "2": [39, 40, 42, 43, 48]}}, {"12": "guava/src/com/google/common/util/concurrent/AsyncFunction.java", "added": {"1": [" * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not use this file except\n", " * in compliance with the License. You may obtain a copy of the License at\n", " * Unless required by applicable law or agreed to in writing, software distributed under the License\n", " * is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express\n", " * or implied. See the License for the specific language governing permissions and limitations under\n", " * the License.\n"], "2": [" * Transforms a value, possibly asynchronously. For an example usage and more information, see\n"], "3": ["   * Returns an output {@code Future} to use in place of the given {@code input}. The output {@code\n", "   * Future} need not be {@linkplain Future#isDone done}, making {@code AsyncFunction} suitable for\n", "   * asynchronous derivations.\n", "   * <p>Throwing an exception from this method is equivalent to returning a failing {@code Future}.\n"]}, "removed": {"1": [" * Licensed under the Apache License, Version 2.0 (the \"License\");\n", " * you may not use this file except in compliance with the License.\n", " * You may obtain a copy of the License at\n", " * Unless required by applicable law or agreed to in writing, software\n", " * distributed under the License is distributed on an \"AS IS\" BASIS,\n", " * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n", " * See the License for the specific language governing permissions and\n", " * limitations under the License.\n"], "2": [" * Transforms a value, possibly asynchronously. For an example usage and more\n", " * information, see\n"], "3": ["   * Returns an output {@code Future} to use in place of the given {@code\n", "   * input}. The output {@code Future} need not be {@linkplain Future#isDone\n", "   * done}, making {@code AsyncFunction} suitable for asynchronous derivations.\n", "   * <p>Throwing an exception from this method is equivalent to returning a\n", "   * failing {@code Future}.\n"]}, "added_lines": {"1": [4, 5, 9, 10, 11, 12], "2": [24], "3": [33, 34, 35, 37]}, "removed_lines": {"1": [4, 5, 6, 10, 11, 12, 13, 14], "2": [26, 27], "3": [36, 37, 38, 40, 41]}}, {"13": "guava/src/com/google/common/util/concurrent/AtomicLongMap.java", "added": {"1": [" * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not use this file except\n", " * in compliance with the License. You may obtain a copy of the License at\n", " * Unless required by applicable law or agreed to in writing, software distributed under the License\n", " * is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express\n", " * or implied. See the License for the specific language governing permissions and limitations under\n", " * the License.\n"], "2": [" * documented. Exceptions to this are {@link #containsKey}, {@link #size}, {@link #isEmpty}, {@link\n", " * #asMap}, and {@link #toString}.\n", " * {@link com.google.common.collect.Multiset} such as {@link\n", " * com.google.common.collect.ConcurrentHashMultiset} instead.\n"], "3": ["    outer:\n", "    while (true) {\n"], "4": ["      while (true) {\n"], "5": ["    outer:\n", "    while (true) {\n"], "6": ["      while (true) {\n"], "7": ["    outer:\n", "    while (true) {\n"], "8": ["      while (true) {\n"], "9": ["   * Removes and returns the value associated with {@code key}. If {@code key} is not in the map,\n", "   * this method has no effect and returns zero.\n"], "10": ["    while (true) {\n"], "11": ["   * <p>This method is not atomic: the map may be visible in intermediate states, where some of the\n", "   * zero values have been removed and others have not.\n"], "12": ["        Maps.transformValues(\n", "            map,\n", "            new Function<AtomicLong, Long>() {\n", "              @Override\n", "              public Long apply(AtomicLong atomic) {\n", "                return atomic.get();\n", "              }\n", "            }));\n"], "13": ["   * Returns the number of key-value mappings in this map. If the map contains more than {@code\n", "   * Integer.MAX_VALUE} elements, returns {@code Integer.MAX_VALUE}.\n"], "14": ["   * zero, associate it with {@code newValue}. Returns the previous value associated with {@code\n", "   * key}, or zero if there was no mapping for {@code key}.\n", "    while (true) {\n"], "15": ["   * If {@code (key, expectedOldValue)} is currently in the map, this method replaces {@code\n", "   * expectedOldValue} with {@code newValue} and returns true; otherwise, this method returns false.\n", "   * <p>If {@code expectedOldValue} is zero, this method will succeed if {@code (key, zero)} is\n", "   * currently in the map, or if {@code key} is not in the map at all.\n"], "16": ["   * If {@code (key, value)} is currently in the map, this method removes it and returns true;\n", "   * otherwise, this method returns false.\n"]}, "removed": {"1": [" * Licensed under the Apache License, Version 2.0 (the \"License\");\n", " * you may not use this file except in compliance with the License.\n", " * You may obtain a copy of the License at\n", " * Unless required by applicable law or agreed to in writing, software\n", " * distributed under the License is distributed on an \"AS IS\" BASIS,\n", " * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n", " * See the License for the specific language governing permissions and\n", " * limitations under the License.\n"], "2": [" * documented. Exceptions to this are {@link #containsKey}, {@link #size}, {@link #isEmpty},\n", " * {@link #asMap}, and {@link #toString}.\n", " * {@link com.google.common.collect.Multiset} such as\n", " * {@link com.google.common.collect.ConcurrentHashMultiset} instead.\n"], "3": ["    outer: for (;;) {\n"], "4": ["      for (;;) {\n"], "5": ["    outer: for (;;) {\n"], "6": ["      for (;;) {\n"], "7": ["    outer: for (;;) {\n"], "8": ["      for (;;) {\n"], "9": ["   * Removes and returns the value associated with {@code key}. If {@code key} is not\n", "   * in the map, this method has no effect and returns zero.\n"], "10": ["    for (;;) {\n"], "11": ["   * <p>This method is not atomic: the map may be visible in intermediate states, where some\n", "   * of the zero values have been removed and others have not.\n"], "12": ["        Maps.transformValues(map, new Function<AtomicLong, Long>() {\n", "          @Override\n", "          public Long apply(AtomicLong atomic) {\n", "            return atomic.get();\n", "          }\n", "        }));\n"], "13": ["   * Returns the number of key-value mappings in this map. If the map contains more than\n", "   * {@code Integer.MAX_VALUE} elements, returns {@code Integer.MAX_VALUE}.\n"], "14": ["   * zero, associate it with {@code newValue}. Returns the previous value associated with\n", "   * {@code key}, or zero if there was no mapping for {@code key}.\n", "    for (;;) {\n"], "15": ["   * If {@code (key, expectedOldValue)} is currently in the map, this method replaces\n", "   * {@code expectedOldValue} with {@code newValue} and returns true; otherwise, this method\n", "   * returns false.\n", "   * <p>If {@code expectedOldValue} is zero, this method will succeed if {@code (key, zero)}\n", "   * is currently in the map, or if {@code key} is not in the map at all.\n"], "16": ["   * If {@code (key, value)} is currently in the map, this method removes it and returns\n", "   * true; otherwise, this method returns false.\n"]}, "added_lines": {"1": [4, 5, 9, 10, 11, 12], "2": [36, 37, 43, 44], "3": [104, 105], "4": [115], "5": [154, 155], "6": [165], "7": [190, 191], "8": [201], "9": [233, 234], "10": [242], "11": [256, 257], "12": [295, 296, 297, 298, 299, 300, 301, 302], "13": [313, 314], "14": [367, 368, 371], "15": [396, 397, 399, 400], "16": [412, 413]}, "removed_lines": {"1": [4, 5, 6, 10, 11, 12, 13, 14], "2": [38, 39, 45, 46], "3": [106], "4": [116], "5": [155], "6": [165], "7": [190], "8": [200], "9": [232, 233], "10": [241], "11": [255, 256], "12": [294, 295, 296, 297, 298, 299], "13": [310, 311], "14": [364, 365, 368], "15": [393, 394, 395, 397, 398], "16": [410, 411]}}, {"14": "guava/src/com/google/common/util/concurrent/Atomics.java", "added": {"1": [" * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not use this file except\n", " * in compliance with the License. You may obtain a copy of the License at\n", " * Unless required by applicable law or agreed to in writing, software distributed under the License\n", " * is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express\n", " * or implied. See the License for the specific language governing permissions and limitations under\n", " * the License.\n"], "2": ["   * Creates an {@code AtomicReferenceArray} instance with the same length as, and all elements\n", "   * copied from, the given array.\n"]}, "removed": {"1": [" * Licensed under the Apache License, Version 2.0 (the \"License\");\n", " * you may not use this file except in compliance with the License.\n", " * You may obtain a copy of the License at\n", " * Unless required by applicable law or agreed to in writing, software\n", " * distributed under the License is distributed on an \"AS IS\" BASIS,\n", " * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n", " * See the License for the specific language governing permissions and\n", " * limitations under the License.\n"], "2": ["   * Creates an {@code AtomicReferenceArray} instance with the same length as,\n", "   * and all elements copied from, the given array.\n"]}, "added_lines": {"1": [4, 5, 9, 10, 11, 12], "2": [62, 63]}, "removed_lines": {"1": [4, 5, 6, 10, 11, 12, 13, 14], "2": [64, 65]}}, {"15": "guava/src/com/google/common/util/concurrent/Callables.java", "added": {"1": [" * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not use this file except\n", " * in compliance with the License. You may obtain a copy of the License at\n", " * Unless required by applicable law or agreed to in writing, software distributed under the License\n", " * is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express\n", " * or implied. See the License for the specific language governing permissions and limitations under\n", " * the License.\n"], "2": ["   * Creates a {@code Callable} which immediately returns a preset value each time it is called.\n", "  public static <T> Callable<T> returning(@Nullable final T value) {\n", "      @Override\n", "      public T call() {\n"], "3": ["  static <T> Callable<T> threadRenaming(\n", "      final Callable<T> callable, final Supplier<String> nameSupplier) {\n", "      @Override\n", "      public T call() throws Exception {\n"], "4": ["      @Override\n", "      public void run() {\n"]}, "removed": {"1": [" * Licensed under the Apache License, Version 2.0 (the \"License\");\n", " * you may not use this file except in compliance with the License.\n", " * You may obtain a copy of the License at\n", " * Unless required by applicable law or agreed to in writing, software\n", " * distributed under the License is distributed on an \"AS IS\" BASIS,\n", " * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n", " * See the License for the specific language governing permissions and\n", " * limitations under the License.\n"], "2": ["   * Creates a {@code Callable} which immediately returns a preset value each\n", "   * time it is called.\n", "  public static <T> Callable<T> returning(final @Nullable T value) {\n", "      @Override public T call() {\n"], "3": ["  static <T> Callable<T> threadRenaming(final Callable<T> callable,\n", "      final Supplier<String> nameSupplier) {\n", "      @Override public T call() throws Exception {\n"], "4": ["      @Override public void run() {\n"]}, "added_lines": {"1": [4, 5, 9, 10, 11, 12], "2": [38, 40, 42, 43], "3": [59, 60, 64, 65], "4": [94, 95]}, "removed_lines": {"1": [4, 5, 6, 10, 11, 12, 13, 14], "2": [40, 41, 43, 45], "3": [61, 62, 66], "4": [95]}}, {"16": "guava/src/com/google/common/util/concurrent/CheckedFuture.java", "added": {"1": [" * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not use this file except\n", " * in compliance with the License. You may obtain a copy of the License at\n", " * Unless required by applicable law or agreed to in writing, software distributed under the License\n", " * is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express\n", " * or implied. See the License for the specific language governing permissions and limitations under\n", " * the License.\n"], "2": [" * A {@code CheckedFuture} is a {@link ListenableFuture} that includes versions of the {@code get}\n", " * methods that can throw a checked exception.  This makes it easier to create a future that\n", " * executes logic which can throw an exception.\n", " * <p><b>Warning:</b> We recommend against using {@code CheckedFuture} in new projects. {@code\n", " * CheckedFuture} is difficult to build libraries atop. {@code CheckedFuture} ports of methods like\n", " * {@link Futures#transformAsync} have historically had bugs, and some of these bugs are necessary,\n", " * unavoidable consequences of the {@code CheckedFuture} API. Additionally, {@code CheckedFuture}\n", " * encourages users to take exceptions from one thread and rethrow them in another, producing\n", " * <p>Implementations of this interface must adapt the exceptions thrown by {@code Future#get()}:\n", " * {@link CancellationException}, {@link ExecutionException} and {@link InterruptedException} into\n", " * the type specified by the {@code X} type parameter.\n", " * <p>This interface also extends the ListenableFuture interface to allow listeners to be added.\n", " * This allows the future to be used as a normal {@link Future} or as an asynchronous callback\n", " * mechanism as needed. This allows multiple callbacks to be registered for a particular task, and\n", " * the future will guarantee execution of all listeners when the task completes.\n", " * <p>For a simpler alternative to CheckedFuture, consider accessing Future values with {@link\n", " * Futures#getChecked(Future, Class) Futures.getChecked()}.\n", "public interface CheckedFuture<V, X extends Exception> extends ListenableFuture<V> {\n", "   * Exception checking version of {@link Future#get()} that will translate {@link\n", "   * InterruptedException}, {@link CancellationException} and {@link ExecutionException} into\n", "   * application-specific exceptions.\n"], "3": ["   * Exception checking version of {@link Future#get(long, TimeUnit)} that will translate {@link\n", "   * InterruptedException}, {@link CancellationException} and {@link ExecutionException} into\n", "   * application-specific exceptions.  On timeout this method throws a normal {@link\n", "   * TimeoutException}.\n"]}, "removed": {"1": [" * Licensed under the Apache License, Version 2.0 (the \"License\");\n", " * you may not use this file except in compliance with the License.\n", " * You may obtain a copy of the License at\n", " * Unless required by applicable law or agreed to in writing, software\n", " * distributed under the License is distributed on an \"AS IS\" BASIS,\n", " * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n", " * See the License for the specific language governing permissions and\n", " * limitations under the License.\n"], "2": [" * A {@code CheckedFuture} is a {@link ListenableFuture} that includes versions\n", " * of the {@code get} methods that can throw a checked exception.  This makes it\n", " * easier to create a future that executes logic which can throw an exception.\n", " * <p><b>Warning:</b> We recommend against using {@code CheckedFuture} in new\n", " * projects. {@code CheckedFuture} is difficult to build libraries atop. {@code\n", " * CheckedFuture} ports of methods like {@link Futures#transformAsync} have\n", " * historically had bugs, and some of these bugs are necessary, unavoidable\n", " * consequences of the {@code CheckedFuture} API. Additionally, {@code\n", " * CheckedFuture} encourages users to take exceptions from one thread and\n", " * rethrow them in another, producing confusing stack traces.\n", " * <p>Implementations of this interface must adapt the exceptions thrown by\n", " * {@code Future#get()}: {@link CancellationException},\n", " * {@link ExecutionException} and {@link InterruptedException} into the type\n", " * specified by the {@code X} type parameter.\n", " * <p>This interface also extends the ListenableFuture interface to allow\n", " * listeners to be added. This allows the future to be used as a normal\n", " * {@link Future} or as an asynchronous callback mechanism as needed. This\n", " * allows multiple callbacks to be registered for a particular task, and the\n", " * future will guarantee execution of all listeners when the task completes.\n", " * <p>For a simpler alternative to CheckedFuture, consider accessing Future\n", " * values with {@link Futures#getChecked(Future, Class) Futures.getChecked()}.\n", "public interface CheckedFuture<V, X extends Exception>\n", "    extends ListenableFuture<V> {\n", "   * Exception checking version of {@link Future#get()} that will translate\n", "   * {@link InterruptedException}, {@link CancellationException} and\n", "   * {@link ExecutionException} into application-specific exceptions.\n"], "3": ["   * Exception checking version of {@link Future#get(long, TimeUnit)} that will\n", "   * translate {@link InterruptedException}, {@link CancellationException} and\n", "   * {@link ExecutionException} into application-specific exceptions.  On\n", "   * timeout this method throws a normal {@link TimeoutException}.\n"]}, "added_lines": {"1": [4, 5, 9, 10, 11, 12], "2": [27, 28, 29, 31, 32, 33, 34, 35, 39, 40, 41, 43, 44, 45, 46, 48, 49, 56, 59, 60, 61], "3": [69, 70, 71, 72]}, "removed_lines": {"1": [4, 5, 6, 10, 11, 12, 13, 14], "2": [29, 30, 31, 33, 34, 35, 36, 37, 38, 39, 43, 44, 45, 46, 48, 49, 50, 51, 52, 54, 55, 62, 63, 66, 67, 68], "3": [76, 77, 78, 79]}}, {"17": "guava/src/com/google/common/util/concurrent/CollectionFuture.java", "added": {"1": [" * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not use this file except\n", " * in compliance with the License. You may obtain a copy of the License at\n", " * Unless required by applicable law or agreed to in writing, software distributed under the License\n", " * is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express\n", " * or implied. See the License for the specific language governing permissions and limitations under\n", " * the License.\n"], "2": ["      this.values =\n", "          futures.isEmpty()\n", "              ? ImmutableList.<Optional<V>>of()\n", "              : Lists.<Optional<V>>newArrayListWithCapacity(futures.size());\n"], "3": ["        // Some other future failed or has been cancelled, causing this one to also be cancelled or\n", "        // have an exception set. This should only happen if allMustSucceed is true or if the output\n", "        // itself has been cancelled.\n", "        checkState(\n", "            allMustSucceed || isCancelled(), \"Future was done before all dependencies completed\");\n"]}, "removed": {"1": [" * Licensed under the Apache License, Version 2.0 (the \"License\");\n", " * you may not use this file except in compliance with the License.\n", " * You may obtain a copy of the License at\n", " * Unless required by applicable law or agreed to in writing, software\n", " * distributed under the License is distributed on an \"AS IS\" BASIS,\n", " * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n", " * See the License for the specific language governing permissions and\n", " * limitations under the License.\n"], "2": ["      this.values = futures.isEmpty() ? ImmutableList.<Optional<V>>of()\n", "          : Lists.<Optional<V>>newArrayListWithCapacity(futures.size());\n"], "3": ["        // Some other future failed or has been cancelled, causing this one to\n", "        // also be cancelled or have an exception set. This should only happen\n", "        // if allMustSucceed is true or if the output itself has been\n", "        // cancelled.\n", "        checkState(allMustSucceed || isCancelled(),\n", "            \"Future was done before all dependencies completed\");\n"]}, "added_lines": {"1": [4, 5, 9, 10, 11, 12], "2": [47, 48, 49, 50], "3": [65, 66, 67, 68, 69]}, "removed_lines": {"1": [4, 5, 6, 10, 11, 12, 13, 14], "2": [49, 50], "3": [65, 66, 67, 68, 69, 70]}}, {"18": "guava/src/com/google/common/util/concurrent/CycleDetectingLockFactory.java", "added": {"1": ["      public void handlePotentialDeadlock(PotentialDeadlockException e) {}\n"], "2": ["    return policy == Policies.DISABLED\n", "        ? new ReentrantLock(fair)\n", "        : new CycleDetectingReentrantLock(new LockGraphNode(lockName), fair);\n"], "3": ["  public ReentrantReadWriteLock newReentrantReadWriteLock(String lockName, boolean fair) {\n", "    return policy == Policies.DISABLED\n", "        ? new ReentrantReadWriteLock(fair)\n", "        : new CycleDetectingReentrantReadWriteLock(new LockGraphNode(lockName), fair);\n", "  private static final ConcurrentMap<Class<? extends Enum>, Map<? extends Enum, LockGraphNode>>\n", "      lockGraphNodesPerType = new MapMaker().weakKeys().makeMap();\n", "  public static <E extends Enum<E>> WithExplicitOrdering<E> newInstanceWithExplicitOrdering(\n", "      Class<E> enumClass, Policy policy) {\n", "    Map<E, LockGraphNode> lockGraphNodes = (Map<E, LockGraphNode>) getOrCreateNodes(enumClass);\n", "  private static Map<? extends Enum, LockGraphNode> getOrCreateNodes(Class<? extends Enum> clazz) {\n", "    Map<? extends Enum, LockGraphNode> existing = lockGraphNodesPerType.get(clazz);\n"], "4": ["    ArrayList<LockGraphNode> nodes = Lists.newArrayListWithCapacity(numKeys);\n"], "5": ["      nodes.get(i).checkAcquiredLocks(Policies.DISABLED, nodes.subList(i + 1, numKeys));\n"], "6": ["    WithExplicitOrdering(Policy policy, Map<E, LockGraphNode> lockGraphNodes) {\n"], "7": ["      return policy == Policies.DISABLED\n", "          ? new ReentrantLock(fair)\n"], "8": ["    public ReentrantReadWriteLock newReentrantReadWriteLock(E rank, boolean fair) {\n", "      return policy == Policies.DISABLED\n", "          ? new ReentrantReadWriteLock(fair)\n", "          : new CycleDetectingReentrantReadWriteLock(lockGraphNodes.get(rank), fair);\n", "  private static final Logger logger = Logger.getLogger(CycleDetectingLockFactory.class.getName());\n"], "9": ["  private static final ThreadLocal<ArrayList<LockGraphNode>> acquiredLocks =\n", "      new ThreadLocal<ArrayList<LockGraphNode>>() {\n", "        @Override\n", "        protected ArrayList<LockGraphNode> initialValue() {\n", "          return Lists.<LockGraphNode>newArrayListWithCapacity(3);\n", "        }\n", "      };\n"], "10": ["    static final StackTraceElement[] EMPTY_STACK_TRACE = new StackTraceElement[0];\n", "    static final Set<String> EXCLUDED_CLASS_NAMES =\n", "        ImmutableSet.of(\n", "            CycleDetectingLockFactory.class.getName(),\n", "            ExampleStackTrace.class.getName(),\n", "            LockGraphNode.class.getName());\n", "        if (WithExplicitOrdering.class.getName().equals(origStackTrace[i].getClassName())) {\n"], "11": ["  public static final class PotentialDeadlockException extends ExampleStackTrace {\n", "        LockGraphNode node1, LockGraphNode node2, ExampleStackTrace conflictingStackTrace) {\n"], "12": ["    final Map<LockGraphNode, PotentialDeadlockException> disallowedPriorLocks =\n", "        new MapMaker().weakKeys().makeMap();\n"], "13": ["    void checkAcquiredLocks(Policy policy, List<LockGraphNode> acquiredLocks) {\n"], "14": ["      Preconditions.checkState(\n", "          this != acquiredLock,\n", "          \"Attempted to acquire multiple locks with the same rank %s\",\n", "          acquiredLock.getLockName());\n"], "15": ["      PotentialDeadlockException previousDeadlockException = disallowedPriorLocks.get(acquiredLock);\n", "        PotentialDeadlockException exception =\n", "            new PotentialDeadlockException(\n", "                acquiredLock, this, previousDeadlockException.getConflictingStackTrace());\n"], "16": ["        allowedPriorLocks.put(acquiredLock, new ExampleStackTrace(acquiredLock, this));\n"], "17": ["    private ExampleStackTrace findPathTo(LockGraphNode node, Set<LockGraphNode> seen) {\n", "        return null; // Already traversed this node.\n", "        return found; // Found a path ending at the node!\n", "      for (Map.Entry<LockGraphNode, ExampleStackTrace> entry : allowedPriorLocks.entrySet()) {\n", "          ExampleStackTrace path = new ExampleStackTrace(preAcquiredLock, this);\n"], "18": ["  final class CycleDetectingReentrantLock extends ReentrantLock implements CycleDetectingLock {\n", "    private CycleDetectingReentrantLock(LockGraphNode lockGraphNode, boolean fair) {\n"], "19": ["    public boolean tryLock(long timeout, TimeUnit unit) throws InterruptedException {\n"], "20": ["  final class CycleDetectingReentrantReadWriteLock extends ReentrantReadWriteLock\n", "      implements CycleDetectingLock {\n"], "21": ["    private CycleDetectingReentrantReadWriteLock(LockGraphNode lockGraphNode, boolean fair) {\n"], "22": ["  private class CycleDetectingReentrantReadLock extends ReentrantReadWriteLock.ReadLock {\n", "    CycleDetectingReentrantReadLock(CycleDetectingReentrantReadWriteLock readWriteLock) {\n"], "23": ["    public boolean tryLock(long timeout, TimeUnit unit) throws InterruptedException {\n"], "24": ["  private class CycleDetectingReentrantWriteLock extends ReentrantReadWriteLock.WriteLock {\n", "    CycleDetectingReentrantWriteLock(CycleDetectingReentrantReadWriteLock readWriteLock) {\n"], "25": ["    public boolean tryLock(long timeout, TimeUnit unit) throws InterruptedException {\n"]}, "removed": {"1": ["      public void handlePotentialDeadlock(PotentialDeadlockException e) {\n", "      }\n"], "2": ["    return policy == Policies.DISABLED ? new ReentrantLock(fair)\n", "        : new CycleDetectingReentrantLock(\n", "            new LockGraphNode(lockName), fair);\n"], "3": ["  public ReentrantReadWriteLock newReentrantReadWriteLock(\n", "      String lockName, boolean fair) {\n", "    return policy == Policies.DISABLED ? new ReentrantReadWriteLock(fair)\n", "        : new CycleDetectingReentrantReadWriteLock(\n", "            new LockGraphNode(lockName), fair);\n", "  private static final ConcurrentMap<Class<? extends Enum>,\n", "      Map<? extends Enum, LockGraphNode>> lockGraphNodesPerType =\n", "          new MapMaker().weakKeys().makeMap();\n", "  public static <E extends Enum<E>> WithExplicitOrdering<E>\n", "      newInstanceWithExplicitOrdering(Class<E> enumClass, Policy policy) {\n", "    Map<E, LockGraphNode> lockGraphNodes =\n", "        (Map<E, LockGraphNode>) getOrCreateNodes(enumClass);\n", "  private static Map<? extends Enum, LockGraphNode> getOrCreateNodes(\n", "      Class<? extends Enum> clazz) {\n", "    Map<? extends Enum, LockGraphNode> existing =\n", "        lockGraphNodesPerType.get(clazz);\n"], "4": ["    ArrayList<LockGraphNode> nodes =\n", "        Lists.newArrayListWithCapacity(numKeys);\n"], "5": ["      nodes.get(i).checkAcquiredLocks(\n", "          Policies.DISABLED, nodes.subList(i + 1, numKeys));\n"], "6": ["    WithExplicitOrdering(\n", "        Policy policy, Map<E, LockGraphNode> lockGraphNodes) {\n"], "7": ["      return policy == Policies.DISABLED ? new ReentrantLock(fair)\n"], "8": ["    public ReentrantReadWriteLock newReentrantReadWriteLock(\n", "        E rank, boolean fair) {\n", "      return policy == Policies.DISABLED ? new ReentrantReadWriteLock(fair)\n", "          : new CycleDetectingReentrantReadWriteLock(\n", "              lockGraphNodes.get(rank), fair);\n", "  private static final Logger logger = Logger.getLogger(\n", "      CycleDetectingLockFactory.class.getName());\n"], "9": ["  private static final ThreadLocal<ArrayList<LockGraphNode>>\n", "      acquiredLocks = new ThreadLocal<ArrayList<LockGraphNode>>() {\n", "    @Override\n", "    protected ArrayList<LockGraphNode> initialValue() {\n", "      return Lists.<LockGraphNode>newArrayListWithCapacity(3);\n", "    }\n", "  };\n"], "10": ["    static final StackTraceElement[] EMPTY_STACK_TRACE =\n", "        new StackTraceElement[0];\n", "    static final Set<String> EXCLUDED_CLASS_NAMES = ImmutableSet.of(\n", "        CycleDetectingLockFactory.class.getName(),\n", "        ExampleStackTrace.class.getName(),\n", "        LockGraphNode.class.getName());\n", "        if (WithExplicitOrdering.class.getName().equals(\n", "                origStackTrace[i].getClassName())) {\n"], "11": ["  public static final class PotentialDeadlockException\n", "      extends ExampleStackTrace {\n", "        LockGraphNode node1,\n", "        LockGraphNode node2,\n", "        ExampleStackTrace conflictingStackTrace) {\n"], "12": ["    final Map<LockGraphNode, PotentialDeadlockException>\n", "        disallowedPriorLocks = new MapMaker().weakKeys().makeMap();\n"], "13": ["    void checkAcquiredLocks(\n", "        Policy policy, List<LockGraphNode> acquiredLocks) {\n"], "14": ["      Preconditions.checkState(this != acquiredLock,\n", "          \"Attempted to acquire multiple locks with the same rank %s\", acquiredLock.getLockName());\n"], "15": ["      PotentialDeadlockException previousDeadlockException =\n", "          disallowedPriorLocks.get(acquiredLock);\n", "        PotentialDeadlockException exception = new PotentialDeadlockException(\n", "            acquiredLock, this,\n", "            previousDeadlockException.getConflictingStackTrace());\n"], "16": ["        allowedPriorLocks.put(\n", "            acquiredLock, new ExampleStackTrace(acquiredLock, this));\n"], "17": ["    private ExampleStackTrace findPathTo(\n", "        LockGraphNode node, Set<LockGraphNode> seen) {\n", "        return null;  // Already traversed this node.\n", "        return found;  // Found a path ending at the node!\n", "      for (Map.Entry<LockGraphNode, ExampleStackTrace> entry :\n", "               allowedPriorLocks.entrySet()) {\n", "          ExampleStackTrace path =\n", "              new ExampleStackTrace(preAcquiredLock, this);\n"], "18": ["  final class CycleDetectingReentrantLock\n", "      extends ReentrantLock implements CycleDetectingLock {\n", "    private CycleDetectingReentrantLock(\n", "        LockGraphNode lockGraphNode, boolean fair) {\n"], "19": ["    public boolean tryLock(long timeout, TimeUnit unit)\n", "        throws InterruptedException {\n"], "20": ["  final class CycleDetectingReentrantReadWriteLock\n", "      extends ReentrantReadWriteLock implements CycleDetectingLock {\n"], "21": ["    private CycleDetectingReentrantReadWriteLock(\n", "        LockGraphNode lockGraphNode, boolean fair) {\n"], "22": ["  private class CycleDetectingReentrantReadLock\n", "      extends ReentrantReadWriteLock.ReadLock {\n", "    CycleDetectingReentrantReadLock(\n", "        CycleDetectingReentrantReadWriteLock readWriteLock) {\n"], "23": ["    public boolean tryLock(long timeout, TimeUnit unit)\n", "        throws InterruptedException {\n"], "24": ["  private class CycleDetectingReentrantWriteLock\n", "      extends ReentrantReadWriteLock.WriteLock {\n", "    CycleDetectingReentrantWriteLock(\n", "        CycleDetectingReentrantReadWriteLock readWriteLock) {\n"], "25": ["    public boolean tryLock(long timeout, TimeUnit unit)\n", "        throws InterruptedException {\n"]}, "added_lines": {"1": [238], "2": [262, 263, 264], "3": [279, 280, 281, 282, 286, 287, 292, 293, 299, 303, 304], "4": [324], "5": [337], "6": [419], "7": [441, 442], "8": [462, 463, 464, 465, 471], "9": [486, 487, 488, 489, 490, 491, 492], "10": [510, 512, 513, 514, 515, 516, 522], "11": [558, 563], "12": [619, 620], "13": [632], "14": [654, 655, 656, 657], "15": [665, 670, 671, 672], "16": [690], "17": [711, 713, 717, 720, 727], "18": [771, 775], "19": [825], "20": [844, 845], "21": [856], "22": [888, 892], "23": [928], "24": [947, 951], "25": [987]}, "removed_lines": {"1": [238, 239], "2": [263, 264, 265], "3": [280, 281, 282, 283, 284, 288, 289, 290, 295, 296, 302, 303, 307, 308, 309, 310], "4": [330, 331], "5": [344, 345], "6": [427, 428], "7": [450], "8": [470, 471, 472, 473, 474, 480, 481], "9": [496, 497, 498, 499, 500, 501, 502], "10": [520, 521, 523, 524, 525, 526, 532, 533], "11": [569, 570, 575, 576, 577], "12": [633, 634], "13": [646, 647], "14": [669, 670], "15": [678, 679, 684, 685, 686], "16": [704, 705], "17": [726, 727, 729, 733, 736, 737, 744, 745], "18": [789, 790, 794, 795], "19": [845, 846], "20": [865, 866], "21": [877, 878], "22": [910, 911, 915, 916], "23": [952, 953], "24": [972, 973, 977, 978], "25": [1014, 1015]}}, {"19": "guava/src/com/google/common/util/concurrent/ExecutionError.java", "added": {"1": [" * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not use this file except\n", " * in compliance with the License. You may obtain a copy of the License at\n", " * Unless required by applicable law or agreed to in writing, software distributed under the License\n", " * is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express\n", " * or implied. See the License for the specific language governing permissions and limitations under\n", " * the License.\n"], "2": [" * {@link Error} variant of {@link java.util.concurrent.ExecutionException}. As with {@code\n", " * ExecutionException}, the error's {@linkplain #getCause() cause} comes from a failed task,\n", " * possibly run in another thread. That cause should itself be an {@code Error}; if not, use {@code\n", " * ExecutionException} or {@link UncheckedExecutionException}. This allows the client code to\n", " * continue to distinguish between exceptions and errors, even when they come from other threads.\n"]}, "removed": {"1": [" * Licensed under the Apache License, Version 2.0 (the \"License\");\n", " * you may not use this file except in compliance with the License.\n", " * You may obtain a copy of the License at\n", " * Unless required by applicable law or agreed to in writing, software\n", " * distributed under the License is distributed on an \"AS IS\" BASIS,\n", " * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n", " * See the License for the specific language governing permissions and\n", " * limitations under the License.\n"], "2": [" * {@link Error} variant of {@link java.util.concurrent.ExecutionException}. As\n", " * with {@code ExecutionException}, the error's {@linkplain #getCause() cause}\n", " * comes from a failed task, possibly run in another thread. That cause should\n", " * itself be an {@code Error}; if not, use {@code ExecutionException} or {@link\n", " * UncheckedExecutionException}. This allows the client code to continue to\n", " * distinguish between exceptions and errors, even when they come from other\n", " * threads.\n"]}, "added_lines": {"1": [4, 5, 9, 10, 11, 12], "2": [22, 23, 24, 25, 26]}, "removed_lines": {"1": [4, 5, 6, 10, 11, 12, 13, 14], "2": [24, 25, 26, 27, 28, 29, 30]}}, {"20": "guava/src/com/google/common/util/concurrent/ExecutionList.java", "added": {"1": [" * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not use this file except\n", " * in compliance with the License. You may obtain a copy of the License at\n", " * Unless required by applicable law or agreed to in writing, software distributed under the License\n", " * is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express\n", " * or implied. See the License for the specific language governing permissions and limitations under\n", " * the License.\n"], "2": ["      runnables = null; // allow GC to free listeners even if this stays around for a while.\n"], "3": ["      log.log(\n", "          Level.SEVERE,\n", "          \"RuntimeException while executing runnable \" + runnable + \" with executor \" + executor,\n", "          e);\n"]}, "removed": {"1": [" * Licensed under the Apache License, Version 2.0 (the \"License\");\n", " * you may not use this file except in compliance with the License.\n", " * You may obtain a copy of the License at\n", " * Unless required by applicable law or agreed to in writing, software\n", " * distributed under the License is distributed on an \"AS IS\" BASIS,\n", " * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n", " * See the License for the specific language governing permissions and\n", " * limitations under the License.\n"], "2": ["      runnables = null;  // allow GC to free listeners even if this stays around for a while.\n"], "3": ["      log.log(Level.SEVERE, \"RuntimeException while executing runnable \"\n", "          + runnable + \" with executor \" + executor, e);\n"]}, "added_lines": {"1": [4, 5, 9, 10, 11, 12], "2": [112], "3": [147, 148, 149, 150]}, "removed_lines": {"1": [4, 5, 6, 10, 11, 12, 13, 14], "2": [113], "3": [148, 149]}}, {"21": "guava/src/com/google/common/util/concurrent/FakeTimeLimiter.java", "added": {"1": [" * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not use this file except\n", " * in compliance with the License. You may obtain a copy of the License at\n", " * Unless required by applicable law or agreed to in writing, software distributed under the License\n", " * is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express\n", " * or implied. See the License for the specific language governing permissions and limitations under\n", " * the License.\n"], "2": [" * A TimeLimiter implementation which actually does not attempt to limit time at all. This may be\n", " * desirable to use in some unit tests. More importantly, attempting to debug a call which is\n", " * time-limited would be extremely annoying, so this gives you a time-limiter you can easily swap in\n", " * for your real time-limiter while you're debugging.\n"], "3": ["  public <T> T newProxy(\n", "      T target, Class<T> interfaceType, long timeoutDuration, TimeUnit timeoutUnit) {\n"], "4": ["  public <T> T callWithTimeout(\n", "      Callable<T> callable, long timeoutDuration, TimeUnit timeoutUnit, boolean amInterruptible)\n", "      throws Exception {\n"]}, "removed": {"1": [" * Licensed under the Apache License, Version 2.0 (the \"License\");\n", " * you may not use this file except in compliance with the License.\n", " * You may obtain a copy of the License at\n", " * Unless required by applicable law or agreed to in writing, software\n", " * distributed under the License is distributed on an \"AS IS\" BASIS,\n", " * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n", " * See the License for the specific language governing permissions and\n", " * limitations under the License.\n"], "2": [" * A TimeLimiter implementation which actually does not attempt to limit time\n", " * at all.  This may be desirable to use in some unit tests.  More importantly,\n", " * attempting to debug a call which is time-limited would be extremely annoying,\n", " * so this gives you a time-limiter you can easily swap in for your real\n", " * time-limiter while you're debugging.\n"], "3": ["  public <T> T newProxy(T target, Class<T> interfaceType, long timeoutDuration,\n", "      TimeUnit timeoutUnit) {\n"], "4": ["  public <T> T callWithTimeout(Callable<T> callable, long timeoutDuration,\n", "      TimeUnit timeoutUnit, boolean amInterruptible) throws Exception {\n"]}, "added_lines": {"1": [4, 5, 9, 10, 11, 12], "2": [25, 26, 27, 28], "3": [36, 37], "4": [45, 46, 47]}, "removed_lines": {"1": [4, 5, 6, 10, 11, 12, 13, 14], "2": [27, 28, 29, 30, 31], "3": [39, 40], "4": [48, 49]}}, {"22": "guava/src/com/google/common/util/concurrent/ForwardingBlockingQueue.java", "added": {"1": [" * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not use this file except\n", " * in compliance with the License. You may obtain a copy of the License at\n", " * Unless required by applicable law or agreed to in writing, software distributed under the License\n", " * is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express\n", " * or implied. See the License for the specific language governing permissions and limitations under\n", " * the License.\n"], "2": [" * A {@link BlockingQueue} which forwards all its method calls to another {@link BlockingQueue}.\n", " * Subclasses should override one or more methods to modify the behavior of the backing collection\n", " * as desired per the <a href=\"http://en.wikipedia.org/wiki/Decorator_pattern\">decorator\n", " * pattern</a>.\n"], "3": ["  @Override\n", "  protected abstract BlockingQueue<E> delegate();\n", "  @Override\n", "  public int drainTo(Collection<? super E> c, int maxElements) {\n", "  @Override\n", "  public int drainTo(Collection<? super E> c) {\n", "  @Override\n", "  public boolean offer(E e, long timeout, TimeUnit unit) throws InterruptedException {\n", "  @Override\n", "  public E poll(long timeout, TimeUnit unit) throws InterruptedException {\n", "  @Override\n", "  public void put(E e) throws InterruptedException {\n", "  @Override\n", "  public int remainingCapacity() {\n", "  @Override\n", "  public E take() throws InterruptedException {\n"]}, "removed": {"1": [" * Licensed under the Apache License, Version 2.0 (the \"License\");\n", " * you may not use this file except in compliance with the License.\n", " * You may obtain a copy of the License at\n", " * Unless required by applicable law or agreed to in writing, software\n", " * distributed under the License is distributed on an \"AS IS\" BASIS,\n", " * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n", " * See the License for the specific language governing permissions and\n", " * limitations under the License.\n"], "2": [" * A {@link BlockingQueue} which forwards all its method calls to another\n", " * {@link BlockingQueue}. Subclasses should override one or more methods to\n", " * modify the behavior of the backing collection as desired per the <a\n", " * href=\"http://en.wikipedia.org/wiki/Decorator_pattern\">decorator pattern</a>.\n"], "3": ["  @Override protected abstract BlockingQueue<E> delegate();\n", "  @Override public int drainTo(\n", "      Collection<? super E> c, int maxElements) {\n", "  @Override public int drainTo(Collection<? super E> c) {\n", "  @Override public boolean offer(E e, long timeout, TimeUnit unit)\n", "      throws InterruptedException {\n", "  @Override public E poll(long timeout, TimeUnit unit)\n", "      throws InterruptedException {\n", "  @Override public void put(E e) throws InterruptedException {\n", "  @Override public int remainingCapacity() {\n", "  @Override public E take() throws InterruptedException {\n"]}, "added_lines": {"1": [4, 5, 9, 10, 11, 12], "2": [24, 25, 26, 27], "3": [40, 41, 43, 44, 48, 49, 53, 54, 58, 59, 63, 64, 68, 69, 73, 74]}, "removed_lines": {"1": [4, 5, 6, 10, 11, 12, 13, 14], "2": [26, 27, 28, 29], "3": [42, 44, 45, 49, 53, 54, 58, 59, 63, 67, 71]}}, {"23": "guava/src/com/google/common/util/concurrent/ForwardingCheckedFuture.java", "added": {"1": [" * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not use this file except\n", " * in compliance with the License. You may obtain a copy of the License at\n", " * Unless required by applicable law or agreed to in writing, software distributed under the License\n", " * is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express\n", " * or implied. See the License for the specific language governing permissions and limitations under\n", " * the License.\n"], "2": [" * A future which forwards all its method calls to another future. Subclasses should override one or\n", " * more methods to modify the behavior of the backing future as desired per the <a href=\n", " * @param <X> The type of the Exception thrown by the Future's {@code checkedGet} method\n"], "3": ["   * A simplified version of {@link ForwardingCheckedFuture} where subclasses can pass in an already\n", "   * constructed {@link CheckedFuture} as the delegate.\n", "  public abstract static class SimpleForwardingCheckedFuture<V, X extends Exception>\n", "      extends ForwardingCheckedFuture<V, X> {\n"]}, "removed": {"1": [" * Licensed under the Apache License, Version 2.0 (the \"License\");\n", " * you may not use this file except in compliance with the License.\n", " * You may obtain a copy of the License at\n", " * Unless required by applicable law or agreed to in writing, software\n", " * distributed under the License is distributed on an \"AS IS\" BASIS,\n", " * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n", " * See the License for the specific language governing permissions and\n", " * limitations under the License.\n"], "2": [" * A future which forwards all its method calls to another future. Subclasses\n", " * should override one or more methods to modify the behavior of the backing \n", " * future as desired per the <a href=\n", " * @param <X> The type of the Exception thrown by the Future's \n", " *            {@code checkedGet} method\n"], "3": ["   * A simplified version of {@link ForwardingCheckedFuture} where subclasses\n", "   * can pass in an already constructed {@link CheckedFuture} as the delegate.\n", "  public abstract static class SimpleForwardingCheckedFuture<\n", "      V, X extends Exception> extends ForwardingCheckedFuture<V, X> {\n"]}, "added_lines": {"1": [4, 5, 9, 10, 11, 12], "2": [24, 25, 31], "3": [55, 56, 61, 62]}, "removed_lines": {"1": [4, 5, 6, 10, 11, 12, 13, 14], "2": [26, 27, 28, 34, 35], "3": [59, 60, 65, 66]}}, {"24": "guava/src/com/google/common/util/concurrent/ForwardingExecutorService.java", "added": {"1": [" * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not use this file except\n", " * in compliance with the License. You may obtain a copy of the License at\n", " * Unless required by applicable law or agreed to in writing, software distributed under the License\n", " * is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express\n", " * or implied. See the License for the specific language governing permissions and limitations under\n", " * the License.\n"], "2": [" * An executor service which forwards all its method calls to another executor service. Subclasses\n", " * should override one or more methods to modify the behavior of the backing executor service as\n", " * desired per the <a href=\"http://en.wikipedia.org/wiki/Decorator_pattern\">decorator pattern</a>.\n"], "3": ["  public boolean awaitTermination(long timeout, TimeUnit unit) throws InterruptedException {\n", "  public <T> List<Future<T>> invokeAll(Collection<? extends Callable<T>> tasks)\n", "      throws InterruptedException {\n"], "4": ["  public <T> T invokeAny(Collection<? extends Callable<T>> tasks, long timeout, TimeUnit unit)\n"]}, "removed": {"1": [" * Licensed under the Apache License, Version 2.0 (the \"License\");\n", " * you may not use this file except in compliance with the License.\n", " * You may obtain a copy of the License at\n", " * Unless required by applicable law or agreed to in writing, software\n", " * distributed under the License is distributed on an \"AS IS\" BASIS,\n", " * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n", " * See the License for the specific language governing permissions and\n", " * limitations under the License.\n"], "2": [" * An executor service which forwards all its method calls to another executor\n", " * service. Subclasses should override one or more methods to modify the\n", " * behavior of the backing executor service as desired per the <a\n", " * href=\"http://en.wikipedia.org/wiki/Decorator_pattern\">decorator pattern</a>.\n"], "3": ["  public boolean awaitTermination(long timeout, TimeUnit unit)\n", "      throws InterruptedException {\n", "  public <T> List<Future<T>> invokeAll(\n", "      Collection<? extends Callable<T>> tasks) throws InterruptedException {\n"], "4": ["  public <T> T invokeAny(\n", "      Collection<? extends Callable<T>> tasks, long timeout, TimeUnit unit)\n"]}, "added_lines": {"1": [4, 5, 9, 10, 11, 12], "2": [29, 30, 31], "3": [45, 50, 51], "4": [69]}, "removed_lines": {"1": [4, 5, 6, 10, 11, 12, 13, 14], "2": [31, 32, 33, 34], "3": [48, 49, 54, 55], "4": [73, 74]}}, {"25": "guava/src/com/google/common/util/concurrent/ForwardingFuture.java", "added": {"1": [" * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not use this file except\n", " * in compliance with the License. You may obtain a copy of the License at\n", " * Unless required by applicable law or agreed to in writing, software distributed under the License\n", " * is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express\n", " * or implied. See the License for the specific language governing permissions and limitations under\n", " * the License.\n"], "2": [" * A {@link Future} which forwards all its method calls to another future. Subclasses should\n", " * override one or more methods to modify the behavior of the backing future as desired per the <a\n"], "3": ["public abstract class ForwardingFuture<V> extends ForwardingObject implements Future<V> {\n", "  @Override\n", "  protected abstract Future<V> delegate();\n"], "4": ["  // TODO(cpovirk): Use standard Javadoc form for SimpleForwarding* class and constructor\n", "   * A simplified version of {@link ForwardingFuture} where subclasses can pass in an already\n", "   * constructed {@link Future} as the delegate.\n", "  public abstract static class SimpleForwardingFuture<V> extends ForwardingFuture<V> {\n"]}, "removed": {"1": [" * Licensed under the Apache License, Version 2.0 (the \"License\");\n", " * you may not use this file except in compliance with the License.\n", " * You may obtain a copy of the License at\n", " * Unless required by applicable law or agreed to in writing, software\n", " * distributed under the License is distributed on an \"AS IS\" BASIS,\n", " * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n", " * See the License for the specific language governing permissions and\n", " * limitations under the License.\n"], "2": [" * A {@link Future} which forwards all its method calls to another future.\n", " * Subclasses should override one or more methods to modify the behavior of\n", " * the backing future as desired per the <a\n"], "3": ["public abstract class ForwardingFuture<V> extends ForwardingObject\n", "    implements Future<V> {\n", "\n", "  @Override protected abstract Future<V> delegate();\n"], "4": ["  /*\n", "   * TODO(cpovirk): Use standard Javadoc form for SimpleForwarding* class and\n", "   * constructor\n", "   */\n", "   * A simplified version of {@link ForwardingFuture} where subclasses\n", "   * can pass in an already constructed {@link Future} as the delegate.\n", "  public abstract static class SimpleForwardingFuture<V> \n", "      extends ForwardingFuture<V> {\n"]}, "added_lines": {"1": [4, 5, 9, 10, 11, 12], "2": [26, 27], "3": [35, 39, 40], "4": [68, 70, 71, 75]}, "removed_lines": {"1": [4, 5, 6, 10, 11, 12, 13, 14], "2": [28, 29, 30], "3": [38, 39, 40, 44], "4": [72, 73, 74, 75, 77, 78, 82, 83]}}, {"26": "guava/src/com/google/common/util/concurrent/ForwardingListenableFuture.java", "added": {"1": [" * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not use this file except\n", " * in compliance with the License. You may obtain a copy of the License at\n", " * Unless required by applicable law or agreed to in writing, software distributed under the License\n", " * is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express\n", " * or implied. See the License for the specific language governing permissions and limitations under\n", " * the License.\n"], "2": [" * A {@link ListenableFuture} which forwards all its method calls to another future. Subclasses\n", " * should override one or more methods to modify the behavior of the backing future as desired per\n", " * the <a href=\"http://en.wikipedia.org/wiki/Decorator_pattern\">decorator pattern</a>.\n"], "3": ["  // TODO(cpovirk): Use standard Javadoc form for SimpleForwarding* class and constructor\n", "   * A simplified version of {@link ForwardingListenableFuture} where subclasses can pass in an\n", "   * already constructed {@link ListenableFuture} as the delegate.\n"]}, "removed": {"1": [" * Licensed under the Apache License, Version 2.0 (the \"License\");\n", " * you may not use this file except in compliance with the License.\n", " * You may obtain a copy of the License at\n", " * Unless required by applicable law or agreed to in writing, software\n", " * distributed under the License is distributed on an \"AS IS\" BASIS,\n", " * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n", " * See the License for the specific language governing permissions and\n", " * limitations under the License.\n"], "2": [" * A {@link ListenableFuture} which forwards all its method calls to another\n", " * future. Subclasses should override one or more methods to modify the behavior\n", " * of the backing future as desired per the <a\n", " * href=\"http://en.wikipedia.org/wiki/Decorator_pattern\">decorator pattern</a>.\n", " * @param <V> The result type returned by this Future's {@code get} method\n", " * \n"], "3": ["  /*\n", "   * TODO(cpovirk): Use standard Javadoc form for SimpleForwarding* class and\n", "   * constructor\n", "   */\n", "   * A simplified version of {@link ForwardingListenableFuture} where subclasses\n", "   * can pass in an already constructed {@link ListenableFuture} \n", "   * as the delegate.\n"]}, "added_lines": {"1": [4, 5, 9, 10, 11, 12], "2": [22, 23, 24], "3": [45, 47, 48]}, "removed_lines": {"1": [4, 5, 6, 10, 11, 12, 13, 14], "2": [24, 25, 26, 27, 31, 32], "3": [50, 51, 52, 53, 55, 56, 57]}}, {"27": "guava/src/com/google/common/util/concurrent/ForwardingListeningExecutorService.java", "added": {"1": [" * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not use this file except\n", " * in compliance with the License. You may obtain a copy of the License at\n", " * Unless required by applicable law or agreed to in writing, software distributed under the License\n", " * is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express\n", " * or implied. See the License for the specific language governing permissions and limitations under\n", " * the License.\n"], "2": [" * A listening executor service which forwards all its method calls to another listening executor\n", " * service. Subclasses should override one or more methods to modify the behavior of the backing\n", " * executor service as desired per the <a\n", "public abstract class ForwardingListeningExecutorService extends ForwardingExecutorService\n", "    implements ListeningExecutorService {\n"]}, "removed": {"1": [" * Licensed under the Apache License, Version 2.0 (the \"License\");\n", " * you may not use this file except in compliance with the License.\n", " * You may obtain a copy of the License at\n", " * Unless required by applicable law or agreed to in writing, software\n", " * distributed under the License is distributed on an \"AS IS\" BASIS,\n", " * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n", " * See the License for the specific language governing permissions and\n", " * limitations under the License.\n"], "2": [" * A listening executor service which forwards all its method calls to another\n", " * listening executor service. Subclasses should override one or more methods to\n", " * modify the behavior of the backing executor service as desired per the <a\n", "public abstract class ForwardingListeningExecutorService\n", "    extends ForwardingExecutorService implements ListeningExecutorService {\n"]}, "added_lines": {"1": [4, 5, 9, 10, 11, 12], "2": [20, 21, 22, 28, 29]}, "removed_lines": {"1": [4, 5, 6, 10, 11, 12, 13, 14], "2": [22, 23, 24, 30, 31]}}, {"28": "guava/src/com/google/common/util/concurrent/FutureCallback.java", "added": {"1": [" * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not use this file except\n", " * in compliance with the License. You may obtain a copy of the License at\n", " * Unless required by applicable law or agreed to in writing, software distributed under the License\n", " * is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express\n", " * or implied. See the License for the specific language governing permissions and limitations under\n", " * the License.\n"], "2": [" * A callback for accepting the results of a {@link java.util.concurrent.Future} computation\n", " * asynchronously.\n"], "3": ["   * Invoked with the result of the {@code Future} computation when it is successful.\n", "   * <p>If the future's {@link Future#get() get} method throws an {@link ExecutionException}, then\n", "   * the cause is passed to this method. Any other thrown object is passed unaltered.\n"]}, "removed": {"1": [" * Licensed under the Apache License, Version 2.0 (the \"License\");\n", " * you may not use this file except in compliance with the License.\n", " * You may obtain a copy of the License at\n", " * Unless required by applicable law or agreed to in writing, software\n", " * distributed under the License is distributed on an \"AS IS\" BASIS,\n", " * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n", " * See the License for the specific language governing permissions and\n", " * limitations under the License.\n"], "2": [" * A callback for accepting the results of a {@link java.util.concurrent.Future}\n", " * computation asynchronously.\n"], "3": ["   * Invoked with the result of the {@code Future} computation when it is\n", "   * successful.\n", "   * <p>If the future's {@link Future#get() get} method throws an {@link\n", "   * ExecutionException}, then the cause is passed to this method. Any other\n", "   * thrown object is passed unaltered.\n"]}, "added_lines": {"1": [4, 5, 9, 10, 11, 12], "2": [25, 26], "3": [36, 43, 44]}, "removed_lines": {"1": [4, 5, 6, 10, 11, 12, 13, 14], "2": [27, 28], "3": [38, 39, 46, 47, 48]}}, {"29": "guava/src/com/google/common/util/concurrent/FutureFallback.java", "added": {"1": [" * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not use this file except\n", " * in compliance with the License. You may obtain a copy of the License at\n", " * Unless required by applicable law or agreed to in writing, software distributed under the License\n", " * is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express\n", " * or implied. See the License for the specific language governing permissions and limitations under\n", " * the License.\n"]}, "removed": {"1": [" * Licensed under the Apache License, Version 2.0 (the \"License\");\n", " * you may not use this file except in compliance with the License.\n", " * You may obtain a copy of the License at\n", " * Unless required by applicable law or agreed to in writing, software\n", " * distributed under the License is distributed on an \"AS IS\" BASIS,\n", " * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n", " * See the License for the specific language governing permissions and\n", " * limitations under the License.\n"]}, "added_lines": {"1": [4, 5, 9, 10, 11, 12]}, "removed_lines": {"1": [4, 5, 6, 10, 11, 12, 13, 14]}}, {"30": "guava/src/com/google/common/util/concurrent/Futures.java", "added": {"1": [" * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not use this file except\n", " * in compliance with the License. You may obtain a copy of the License at\n", " * Unless required by applicable law or agreed to in writing, software distributed under the License\n", " * is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express\n", " * or implied. See the License for the specific language governing permissions and limitations under\n", " * the License.\n"], "2": ["   * <p>The given mapping function will be applied to an {@link InterruptedException}, a {@link\n", "   * CancellationException}, or an {@link ExecutionException}. See {@link Future#get()} for details\n", "   * on the exceptions thrown.\n"], "3": ["   * Creates a {@code ListenableFuture} which has its value set immediately upon construction. The\n", "   * getters just return the value. This {@code Future} can't be canceled or timed out and its\n", "   * {@code isDone()} method always returns {@code true}.\n"], "4": ["   * Returns a {@code CheckedFuture} which has its value set immediately upon construction.\n", "   * <p>The returned {@code Future} can't be cancelled, and its {@code isDone()} method always\n", "   * returns {@code true}. Calling {@code get()} or {@code checkedGet()} will immediately return the\n", "   * provided value.\n", "  public static <V, X extends Exception> CheckedFuture<V, X> immediateCheckedFuture(\n", "      @Nullable V value) {\n", "   * Returns a {@code ListenableFuture} which has an exception set immediately upon construction.\n", "   * <p>The returned {@code Future} can't be cancelled, and its {@code isDone()} method always\n", "   * returns {@code true}. Calling {@code get()} will immediately throw the provided {@code\n", "   * Throwable} wrapped in an {@code ExecutionException}.\n", "  public static <V> ListenableFuture<V> immediateFailedFuture(Throwable throwable) {\n", "   * Creates a {@code ListenableFuture} which is cancelled immediately upon construction, so that\n", "   * {@code isCancelled()} always returns {@code true}.\n"], "5": ["   * Returns a {@code CheckedFuture} which has an exception set immediately upon construction.\n", "   *\n", "   * <p>The returned {@code Future} can't be cancelled, and its {@code isDone()} method always\n", "   * returns {@code true}. Calling {@code get()} will immediately throw the provided {@code\n", "   * Exception} wrapped in an {@code ExecutionException}, and calling {@code checkedGet()} will\n", "   * throw the provided exception itself.\n", "  public static <V, X extends Exception> CheckedFuture<V, X> immediateFailedCheckedFuture(\n", "      X exception) {\n", "   * Returns a {@code Future} whose result is taken from the given primary {@code input} or, if the\n", "   * primary input fails, from the {@code Future} provided by the {@code fallback}. {@link\n", "   * FutureFallback#create} is not invoked until the primary input has failed, so if the primary\n", "   * input succeeds, it is never invoked. If, during the invocation of {@code fallback}, an\n", "   * exception is thrown, this exception is used as the result of the output {@code Future}.\n", "   * <p>Below is an example of a fallback that returns a default value if an exception occurs:\n"], "6": ["   * <p>The fallback can also choose to propagate the original exception when desired:\n"], "7": ["   * <p>This overload, which does not accept an executor, uses {@code directExecutor}, a dangerous\n", "   * choice in some cases. See the discussion in the {@link ListenableFuture#addListener\n", "   * ListenableFuture.addListener} documentation. The documentation's warnings about \"lightweight\n", "   * listeners\" refer here to the work done during {@code FutureFallback.create}, not to any work\n", "   * done to complete the returned {@code Future}.\n", "   * @param fallback the {@link FutureFallback} implementation to be called if {@code input} fails\n", "   * @deprecated Use {@link #catchingAsync(ListenableFuture, Class, AsyncFunction)\n", "   *     catchingAsync(input, Throwable.class, fallbackImplementedAsAnAsyncFunction)}, usually\n", "   *     replacing {@code Throwable.class} with the specific type you want to handle. This method\n", "      ListenableFuture<? extends V> input, FutureFallback<? extends V> fallback) {\n", "   * Returns a {@code Future} whose result is taken from the given primary {@code input} or, if the\n", "   * primary input fails, from the {@code Future} provided by the {@code fallback}. {@link\n", "   * FutureFallback#create} is not invoked until the primary input has failed, so if the primary\n", "   * input succeeds, it is never invoked. If, during the invocation of {@code fallback}, an\n", "   * exception is thrown, this exception is used as the result of the output {@code Future}.\n", "   * <p>Below is an example of a fallback that returns a default value if an exception occurs:\n"], "8": ["   * <p>The fallback can also choose to propagate the original exception when desired:\n"], "9": ["   * <p>When selecting an executor, note that {@code directExecutor} is dangerous in some cases. See\n", "   * the discussion in the {@link ListenableFuture#addListener ListenableFuture.addListener}\n", "   * documentation. The documentation's warnings about \"lightweight listeners\" refer here to the\n", "   * work done during {@code FutureFallback.create}, not to any work done to complete the returned\n", "   * {@code Future}.\n", "   * @param fallback the {@link FutureFallback} implementation to be called if {@code input} fails\n", "   * @param executor the executor that runs {@code fallback} if {@code input} fails\n", "   * @deprecated Use {@link #catchingAsync(ListenableFuture, Class, AsyncFunction, Executor)\n", "   *     catchingAsync(input, Throwable.class, fallbackImplementedAsAnAsyncFunction, executor)},\n", "   *     usually replacing {@code Throwable.class} with the specific type you want to handle. This\n", "   *     method will be removed in Guava release 20.0.\n", "      FutureFallback<? extends V> fallback,\n", "      Executor executor) {\n", "    return catchingAsync(input, Throwable.class, asAsyncFunction(fallback), executor);\n"], "10": ["      ListenableFuture<? extends V> input,\n", "      Class<X> exceptionType,\n"], "11": ["      ListenableFuture<? extends V> input,\n", "      Class<X> exceptionType,\n", "      Function<? super X, ? extends V> fallback,\n", "      Executor executor) {\n"], "12": ["      ListenableFuture<? extends V> input,\n", "      Class<X> exceptionType,\n"], "13": ["      ListenableFuture<? extends V> input,\n", "      Class<X> exceptionType,\n", "      AsyncFunction<? super X, ? extends V> fallback,\n", "      Executor executor) {\n"], "14": ["        return checkNotNull(\n", "            fallback.create(t),\n", "            \"FutureFallback.create returned null instead of a \"\n", "                + \"Future. Did you mean to return immediateFuture(null)?\");\n", "   * Returns a future that delegates to another but will finish early (via a {@link\n", "   * TimeoutException} wrapped in an {@link ExecutionException}) if the specified duration expires.\n"], "15": ["  public static <V> ListenableFuture<V> withTimeout(\n", "      ListenableFuture<V> delegate,\n", "      long time,\n", "      TimeUnit unit,\n", "      ScheduledExecutorService scheduledExecutor) {\n", "   * Returns a new {@code ListenableFuture} whose result is asynchronously derived from the result\n", "   * of the given {@code Future}. More precisely, the returned {@code Future} takes its result from\n", "   * a {@code Future} produced by applying the given {@code AsyncFunction} to the result of the\n", "   * original {@code Future}. Example:\n"], "16": ["   * <p>This overload, which does not accept an executor, uses {@code directExecutor}, a dangerous\n", "   * choice in some cases. See the discussion in the {@link ListenableFuture#addListener\n", "   * ListenableFuture.addListener} documentation. The documentation's warnings about \"lightweight\n", "   * listeners\" refer here to the work done during {@code AsyncFunction.apply}, not to any work done\n", "   * to complete the returned {@code Future}.\n", "   * <p>The returned {@code Future} attempts to keep its cancellation state in sync with that of the\n", "   * input future and that of the future returned by the function. That is, if the returned {@code\n", "   * Future} is cancelled, it will attempt to cancel the other two, and if either of the other two\n", "   * is cancelled, the returned {@code Future} will receive a callback in which it will attempt to\n", "   * cancel itself.\n", "   * @param function A function to transform the result of the input future to the result of the\n", "   *     output future\n", "   * @return A future that holds result of the function (if the input succeeded) or the original\n", "   *     input's failure (if not)\n", "   * @deprecated These {@code AsyncFunction} overloads of {@code transform} are being renamed to\n", "   *     {@code transformAsync}. (The {@code Function} overloads are keeping the \"transform\" name.)\n", "   *     This method will be removed in Guava release 20.0.\n", "  public static <I, O> ListenableFuture<O> transform(\n", "      ListenableFuture<I> input, AsyncFunction<? super I, ? extends O> function) {\n", "   * Returns a new {@code ListenableFuture} whose result is asynchronously derived from the result\n", "   * of the given {@code Future}. More precisely, the returned {@code Future} takes its result from\n", "   * a {@code Future} produced by applying the given {@code AsyncFunction} to the result of the\n", "   * original {@code Future}. Example:\n"], "17": ["   * <p>When selecting an executor, note that {@code directExecutor} is dangerous in some cases. See\n", "   * the discussion in the {@link ListenableFuture#addListener ListenableFuture.addListener}\n", "   * documentation. The documentation's warnings about \"lightweight listeners\" refer here to the\n", "   * work done during {@code AsyncFunction.apply}, not to any work done to complete the returned\n", "   * {@code Future}.\n", "   * <p>The returned {@code Future} attempts to keep its cancellation state in sync with that of the\n", "   * input future and that of the future returned by the chain function. That is, if the returned\n", "   * {@code Future} is cancelled, it will attempt to cancel the other two, and if either of the\n", "   * other two is cancelled, the returned {@code Future} will receive a callback in which it will\n", "   * attempt to cancel itself.\n", "   * @param function A function to transform the result of the input future to the result of the\n", "   *     output future\n", "   * @return A future that holds result of the function (if the input succeeded) or the original\n", "   *     input's failure (if not)\n", "   * @deprecated These {@code AsyncFunction} overloads of {@code transform} are being renamed to\n", "   *     {@code transformAsync}. (The {@code Function} overloads are keeping the \"transform\" name.)\n", "   *     This method will be removed in Guava release 20.0.\n", "  public static <I, O> ListenableFuture<O> transform(\n", "      ListenableFuture<I> input,\n"], "18": ["  public static <I, O> ListenableFuture<O> transformAsync(\n", "      ListenableFuture<I> input,\n", "      AsyncFunction<? super I, ? extends O> function,\n", "      Executor executor) {\n", "   * Returns a new {@code ListenableFuture} whose result is the product of applying the given {@code\n", "   * Function} to the result of the given {@code Future}. Example:\n"], "19": ["   * <p>This overload, which does not accept an executor, uses {@code directExecutor}, a dangerous\n", "   * choice in some cases. See the discussion in the {@link ListenableFuture#addListener\n", "   * ListenableFuture.addListener} documentation. The documentation's warnings about \"lightweight\n", "   * listeners\" refer here to the work done during {@code Function.apply}.\n", "   * <p>The returned {@code Future} attempts to keep its cancellation state in sync with that of the\n", "   * input future. That is, if the returned {@code Future} is cancelled, it will attempt to cancel\n", "   * the input, and if the input is cancelled, the returned {@code Future} will receive a callback\n", "   * in which it will attempt to cancel itself.\n", "   * <p>An example use of this method is to convert a serializable object returned from an RPC into\n", "   * a POJO.\n", "   * @param function A Function to transform the results of the provided future to the results of\n", "   *     the returned future.  This will be run in the thread that notifies input it is complete.\n"], "20": ["   * Returns a new {@code ListenableFuture} whose result is the product of applying the given {@code\n", "   * Function} to the result of the given {@code Future}. Example:\n"], "21": ["   * <p>When selecting an executor, note that {@code directExecutor} is dangerous in some cases. See\n", "   * the discussion in the {@link ListenableFuture#addListener ListenableFuture.addListener}\n", "   * documentation. The documentation's warnings about \"lightweight listeners\" refer here to the\n", "   * work done during {@code Function.apply}.\n", "   * <p>The returned {@code Future} attempts to keep its cancellation state in sync with that of the\n", "   * input future. That is, if the returned {@code Future} is cancelled, it will attempt to cancel\n", "   * the input, and if the input is cancelled, the returned {@code Future} will receive a callback\n", "   * in which it will attempt to cancel itself.\n", "   * <p>An example use of this method is to convert a serializable object returned from an RPC into\n", "   * a POJO.\n", "   * @param function A Function to transform the results of the provided future to the results of\n", "   *     the returned future.\n"], "22": ["   * Like {@link #transform(ListenableFuture, Function)} except that the transformation {@code\n", "   * function} is invoked on each call to {@link Future#get() get()} on the returned future.\n", "   * <p>The returned {@code Future} reflects the input's cancellation state directly, and any\n", "   * attempt to cancel the returned Future is likewise passed through to the input Future.\n", "   * <p>Note that calls to {@linkplain Future#get(long, TimeUnit) timed get} only apply the timeout\n", "   * to the execution of the underlying {@code Future}, <em>not</em> to the execution of the\n", "   * transformation function.\n", "   * <p>The primary audience of this method is callers of {@code transform} who don't have a {@code\n", "   * ListenableFuture} available and do not mind repeated, lazy function evaluation.\n", "   * @param function A Function to transform the results of the provided future to the results of\n", "   *     the returned future.\n", "  public static <I, O> Future<O> lazyTransform(\n", "      final Future<I> input, final Function<? super I, ? extends O> function) {\n"], "23": ["   * Returns a new {@code ListenableFuture} whose result is the product of calling {@code get()} on\n", "   * the {@code Future} nested within the given {@code Future}, effectively chaining the futures one\n", "   * after the other.  Example:\n", "   * #transform(ListenableFuture, AsyncFunction)}, in that the returned {@code Future} attempts to\n", "   * keep its cancellation state in sync with both the input {@code Future} and the nested {@code\n", "   * Future}.  The transformation is very lightweight and therefore takes place in the same thread\n", "   * (either the thread that called {@code dereference}, or the thread in which the dereferenced\n", "   * future completes).\n"], "24": ["        @Override\n", "        public ListenableFuture<Object> apply(ListenableFuture<Object> input) {\n", "   * Creates a new {@code ListenableFuture} whose value is a list containing the values of all its\n", "   * input futures, if all succeed. If any input fails, the returned future fails immediately.\n", "   * <p>Canceling this future will attempt to cancel all the component futures, and if any of the\n", "   * provided futures fails or is canceled, this one is, too.\n", "   * @return a future that provides a list of the results of the component futures\n", "  public static <V> ListenableFuture<List<V>> allAsList(ListenableFuture<? extends V>... futures) {\n", "   * Creates a new {@code ListenableFuture} whose value is a list containing the values of all its\n", "   * input futures, if all succeed. If any input fails, the returned future fails immediately.\n", "   * <p>Canceling this future will attempt to cancel all the component futures, and if any of the\n", "   * provided futures fails or is canceled, this one is, too.\n", "   * @return a future that provides a list of the results of the component futures\n"], "25": ["   * Creates a new {@code ListenableFuture} whose result is set from the supplied future when it\n", "   * completes.  Cancelling the supplied future will also cancel the returned future, but cancelling\n", "   * the returned future will have no effect on the supplied future.\n", "  public static <V> ListenableFuture<V> nonCancellationPropagating(ListenableFuture<V> future) {\n"], "26": ["      delegate.addListener(\n", "          new Runnable() {\n", "            @Override\n", "            public void run() {\n", "              // This prevents cancellation from propagating because we don't assign delegate until\n", "              // delegate is already done, so calling cancel() on it is a no-op.\n", "              setFuture(delegate);\n", "            }\n", "          },\n", "          directExecutor());\n", "   * Creates a new {@code ListenableFuture} whose value is a list containing the values of all its\n", "   * successful input futures. The list of results is in the same order as the input list, and if\n", "   * any of the provided futures fails or is canceled, its corresponding position will contain\n", "   * {@code null} (which is indistinguishable from the future having a successful value of {@code\n", "   * null}).\n", "   * @return a future that provides a list of the results of the component futures\n"], "27": ["   * Creates a new {@code ListenableFuture} whose value is a list containing the values of all its\n", "   * successful input futures. The list of results is in the same order as the input list, and if\n", "   * any of the provided futures fails or is canceled, its corresponding position will contain\n", "   * {@code null} (which is indistinguishable from the future having a successful value of {@code\n", "   * null}).\n", "   * @return a future that provides a list of the results of the component futures\n"], "28": ["    final ConcurrentLinkedQueue<SettableFuture<T>> delegates = Queues.newConcurrentLinkedQueue();\n"], "29": ["      future.addListener(\n", "          new Runnable() {\n", "            @Override\n", "            public void run() {\n", "              delegates.remove().setFuture(future);\n", "            }\n", "          },\n", "          executor);\n", "   * Registers separate success and failure callbacks to be run when the {@code Future}'s\n", "   * computation is {@linkplain java.util.concurrent.Future#isDone() complete} or, if the\n", "   * computation is already complete, immediately.\n", "   * <p>There is no guaranteed ordering of execution of callbacks, but any callback added through\n", "   * this method is guaranteed to be called once the computation is complete.\n"], "30": ["   * <p>This overload, which does not accept an executor, uses {@code directExecutor}, a dangerous\n", "   * choice in some cases. See the discussion in the {@link ListenableFuture#addListener\n", "   * ListenableFuture.addListener} documentation.\n", "   * <p>For a more general interface to attach a completion listener to a {@code Future}, see {@link\n", "   * ListenableFuture#addListener addListener}.\n", "  public static <V> void addCallback(\n", "      ListenableFuture<V> future, FutureCallback<? super V> callback) {\n", "   * Registers separate success and failure callbacks to be run when the {@code Future}'s\n", "   * computation is {@linkplain java.util.concurrent.Future#isDone() complete} or, if the\n", "   * computation is already complete, immediately.\n", "   * <p>The callback is run in {@code executor}. There is no guaranteed ordering of execution of\n", "   * callbacks, but any callback added through this method is guaranteed to be called once the\n"], "31": ["   * <p>When selecting an executor, note that {@code directExecutor} is dangerous in some cases. See\n", "   * the discussion in the {@link ListenableFuture#addListener ListenableFuture.addListener}\n", "   * documentation.\n", "   * <p>For a more general interface to attach a completion listener to a {@code Future}, see {@link\n", "   * ListenableFuture#addListener addListener}.\n", "   * @param executor The executor to run {@code callback} when the future completes.\n", "  public static <V> void addCallback(\n", "      final ListenableFuture<V> future,\n", "      final FutureCallback<? super V> callback,\n", "      Executor executor) {\n", "    Runnable callbackListener =\n", "        new Runnable() {\n", "          @Override\n", "          public void run() {\n", "            final V value;\n", "            try {\n", "              // TODO(user): (Before Guava release), validate that this\n", "              // is the thing for IE.\n", "              value = getUninterruptibly(future);\n", "            } catch (ExecutionException e) {\n", "              callback.onFailure(e.getCause());\n", "              return;\n", "            } catch (RuntimeException e) {\n", "              callback.onFailure(e);\n", "              return;\n", "            } catch (Error e) {\n", "              callback.onFailure(e);\n", "              return;\n", "            }\n", "            callback.onSuccess(value);\n", "          }\n", "        };\n", "   * Returns the result of {@link Future#get()}, converting most exceptions to a new instance of the\n", "   * given checked exception type. This reduces boilerplate for a common use of {@code Future} in\n", "   * which it is unnecessary to programmatically distinguish between exception types or to extract\n", "   * other information from the exception instance.\n", "   * <li>Any {@link ExecutionException} has its <i>cause</i> wrapped in an {@code X} if the cause is\n", "   *     a checked exception, an {@link UncheckedExecutionException} if the cause is a {@code\n", "   *     RuntimeException}, or an {@link ExecutionError} if the cause is an {@code Error}.\n", "   * <li>Any {@link InterruptedException} is wrapped in an {@code X} (after restoring the\n", "   *     interrupt).\n", "   * <li>Any {@link CancellationException} is propagated untouched, as is any other {@link\n", "   *     RuntimeException} (though {@code get} implementations are discouraged from throwing such\n", "   *     exceptions).\n", "   * <p>The overall principle is to continue to treat every checked exception as a checked\n", "   * exception, every unchecked exception as an unchecked exception, and every error as an error. In\n", "   * addition, the cause of any {@code ExecutionException} is wrapped in order to ensure that the\n", "   * new stack trace matches that of the current thread.\n", "   *\n", "   * <p>Instances of {@code exceptionClass} are created by choosing an arbitrary public constructor\n", "   * that accepts zero or more arguments, all of type {@code String} or {@code Throwable}\n", "   * (preferring constructors with at least one {@code String}) and calling the constructor via\n", "   * reflection. If the exception did not already have a cause, one is set by calling {@link\n", "   * Throwable#initCause(Throwable)} on it. If no such constructor exists, an {@code\n", "   * IllegalArgumentException} is thrown.\n", "   *\n", "   * @throws X if {@code get} throws any checked exception except for an {@code ExecutionException}\n", "   *     whose cause is not itself a checked exception\n", "   * @throws UncheckedExecutionException if {@code get} throws an {@code ExecutionException} with a\n", "   *     {@code RuntimeException} as its cause\n", "   * @throws ExecutionError if {@code get} throws an {@code ExecutionException} with an {@code\n", "   *     Error} as its cause\n", "   * @throws CancellationException if {@code get} throws a {@code CancellationException}\n", "   * @throws IllegalArgumentException if {@code exceptionClass} extends {@code RuntimeException} or\n", "   *     does not have a suitable constructor\n", "   * @deprecated Use {@link #getChecked(Future, Class)}. This method will be removed in Guava\n", "   *     release 20.0.\n", "  public static <V, X extends Exception> V get(Future<V> future, Class<X> exceptionClass) throws X {\n", "   * Returns the result of {@link Future#get(long, TimeUnit)}, converting most exceptions to a new\n", "   * instance of the given checked exception type. This reduces boilerplate for a common use of\n", "   * {@code Future} in which it is unnecessary to programmatically distinguish between exception\n", "   * types or to extract other information from the exception instance.\n", "   * <li>Any {@link ExecutionException} has its <i>cause</i> wrapped in an {@code X} if the cause is\n", "   *     a checked exception, an {@link UncheckedExecutionException} if the cause is a {@code\n", "   *     RuntimeException}, or an {@link ExecutionError} if the cause is an {@code Error}.\n", "   * <li>Any {@link InterruptedException} is wrapped in an {@code X} (after restoring the\n", "   *     interrupt).\n", "   * <li>Any {@link CancellationException} is propagated untouched, as is any other {@link\n", "   *     RuntimeException} (though {@code get} implementations are discouraged from throwing such\n", "   *     exceptions).\n", "   * <p>The overall principle is to continue to treat every checked exception as a checked\n", "   * exception, every unchecked exception as an unchecked exception, and every error as an error. In\n", "   * addition, the cause of any {@code ExecutionException} is wrapped in order to ensure that the\n", "   * new stack trace matches that of the current thread.\n", "   *\n", "   * <p>Instances of {@code exceptionClass} are created by choosing an arbitrary public constructor\n", "   * that accepts zero or more arguments, all of type {@code String} or {@code Throwable}\n", "   * (preferring constructors with at least one {@code String}) and calling the constructor via\n", "   * reflection. If the exception did not already have a cause, one is set by calling {@link\n", "   * Throwable#initCause(Throwable)} on it. If no such constructor exists, an {@code\n", "   * IllegalArgumentException} is thrown.\n", "   *\n", "   * @throws X if {@code get} throws any checked exception except for an {@code ExecutionException}\n", "   *     whose cause is not itself a checked exception\n", "   * @throws UncheckedExecutionException if {@code get} throws an {@code ExecutionException} with a\n", "   *     {@code RuntimeException} as its cause\n", "   * @throws ExecutionError if {@code get} throws an {@code ExecutionException} with an {@code\n", "   *     Error} as its cause\n", "   * @throws CancellationException if {@code get} throws a {@code CancellationException}\n", "   * @throws IllegalArgumentException if {@code exceptionClass} extends {@code RuntimeException} or\n", "   *     does not have a suitable constructor\n", "   * @deprecated Use {@link #getChecked(Future, Class, long, TimeUnit)}, noting the change in\n", "   *     parameter order. This method will be removed in Guava release 20.0.\n", "      Future<V> future, long timeout, TimeUnit unit, Class<X> exceptionClass) throws X {\n", "   * Returns the result of {@link Future#get()}, converting most exceptions to a new instance of the\n", "   * given checked exception type. This reduces boilerplate for a common use of {@code Future} in\n", "   * which it is unnecessary to programmatically distinguish between exception types or to extract\n", "   * other information from the exception instance.\n", "   * <li>Any {@link ExecutionException} has its <i>cause</i> wrapped in an {@code X} if the cause is\n", "   *     a checked exception, an {@link UncheckedExecutionException} if the cause is a {@code\n", "   *     RuntimeException}, or an {@link ExecutionError} if the cause is an {@code Error}.\n", "   * <li>Any {@link InterruptedException} is wrapped in an {@code X} (after restoring the\n", "   *     interrupt).\n", "   * <li>Any {@link CancellationException} is propagated untouched, as is any other {@link\n", "   *     RuntimeException} (though {@code get} implementations are discouraged from throwing such\n", "   *     exceptions).\n", "   * <p>The overall principle is to continue to treat every checked exception as a checked\n", "   * exception, every unchecked exception as an unchecked exception, and every error as an error. In\n", "   * addition, the cause of any {@code ExecutionException} is wrapped in order to ensure that the\n", "   * new stack trace matches that of the current thread.\n", "   *\n", "   * <p>Instances of {@code exceptionClass} are created by choosing an arbitrary public constructor\n", "   * that accepts zero or more arguments, all of type {@code String} or {@code Throwable}\n", "   * (preferring constructors with at least one {@code String}) and calling the constructor via\n", "   * reflection. If the exception did not already have a cause, one is set by calling {@link\n", "   * Throwable#initCause(Throwable)} on it. If no such constructor exists, an {@code\n", "   * IllegalArgumentException} is thrown.\n", "   *\n", "   * @throws X if {@code get} throws any checked exception except for an {@code ExecutionException}\n", "   *     whose cause is not itself a checked exception\n", "   * @throws UncheckedExecutionException if {@code get} throws an {@code ExecutionException} with a\n", "   *     {@code RuntimeException} as its cause\n", "   * @throws ExecutionError if {@code get} throws an {@code ExecutionException} with an {@code\n", "   *     Error} as its cause\n", "   * @throws CancellationException if {@code get} throws a {@code CancellationException}\n", "   * @throws IllegalArgumentException if {@code exceptionClass} extends {@code RuntimeException} or\n", "   *     does not have a suitable constructor\n", "  public static <V, X extends Exception> V getChecked(Future<V> future, Class<X> exceptionClass)\n", "      throws X {\n", "   * Returns the result of {@link Future#get(long, TimeUnit)}, converting most exceptions to a new\n", "   * instance of the given checked exception type. This reduces boilerplate for a common use of\n", "   * {@code Future} in which it is unnecessary to programmatically distinguish between exception\n", "   * types or to extract other information from the exception instance.\n", "   * <li>Any {@link ExecutionException} has its <i>cause</i> wrapped in an {@code X} if the cause is\n", "   *     a checked exception, an {@link UncheckedExecutionException} if the cause is a {@code\n", "   *     RuntimeException}, or an {@link ExecutionError} if the cause is an {@code Error}.\n", "   * <li>Any {@link InterruptedException} is wrapped in an {@code X} (after restoring the\n", "   *     interrupt).\n", "   * <li>Any {@link CancellationException} is propagated untouched, as is any other {@link\n", "   *     RuntimeException} (though {@code get} implementations are discouraged from throwing such\n", "   *     exceptions).\n", "   * <p>The overall principle is to continue to treat every checked exception as a checked\n", "   * exception, every unchecked exception as an unchecked exception, and every error as an error. In\n", "   * addition, the cause of any {@code ExecutionException} is wrapped in order to ensure that the\n", "   * new stack trace matches that of the current thread.\n", "   *\n", "   * <p>Instances of {@code exceptionClass} are created by choosing an arbitrary public constructor\n", "   * that accepts zero or more arguments, all of type {@code String} or {@code Throwable}\n", "   * (preferring constructors with at least one {@code String}) and calling the constructor via\n", "   * reflection. If the exception did not already have a cause, one is set by calling {@link\n", "   * Throwable#initCause(Throwable)} on it. If no such constructor exists, an {@code\n", "   * IllegalArgumentException} is thrown.\n", "   *\n", "   * @throws X if {@code get} throws any checked exception except for an {@code ExecutionException}\n", "   *     whose cause is not itself a checked exception\n", "   * @throws UncheckedExecutionException if {@code get} throws an {@code ExecutionException} with a\n", "   *     {@code RuntimeException} as its cause\n", "   * @throws ExecutionError if {@code get} throws an {@code ExecutionException} with an {@code\n", "   *     Error} as its cause\n", "   * @throws CancellationException if {@code get} throws a {@code CancellationException}\n", "   * @throws IllegalArgumentException if {@code exceptionClass} extends {@code RuntimeException} or\n", "   *     does not have a suitable constructor\n", "      Future<V> future, Class<X> exceptionClass, long timeout, TimeUnit unit) throws X {\n", "   * Returns the result of calling {@link Future#get()} uninterruptibly on a task known not to throw\n", "   * a checked exception. This makes {@code Future} more suitable for lightweight, fast-running\n", "   * tasks that, barring bugs in the code, will not fail. This gives it exception-handling behavior\n", "   * similar to that of {@code ForkJoinTask.join}.\n", "   * <li>Any {@link ExecutionException} has its <i>cause</i> wrapped in an {@link\n", "   *     UncheckedExecutionException} (if the cause is an {@code Exception}) or {@link\n", "   *     ExecutionError} (if the cause is an {@code Error}).\n", "   * <li>Any {@link InterruptedException} causes a retry of the {@code get} call. The interrupt is\n", "   *     restored before {@code getUnchecked} returns.\n", "   * <li>Any {@link CancellationException} is propagated untouched. So is any other {@link\n", "   *     RuntimeException} ({@code get} implementations are discouraged from throwing such\n", "   *     exceptions).\n", "   * <p>The overall principle is to eliminate all checked exceptions: to loop to avoid {@code\n", "   * InterruptedException}, to pass through {@code CancellationException}, and to wrap any exception\n", "   * from the underlying computation in an {@code UncheckedExecutionException} or {@code\n", "   * <p>For an uninterruptible {@code get} that preserves other exceptions, see {@link\n", "   * Uninterruptibles#getUninterruptibly(Future)}.\n", "   * @throws UncheckedExecutionException if {@code get} throws an {@code ExecutionException} with an\n", "   *     {@code Exception} as its cause\n", "   * @throws ExecutionError if {@code get} throws an {@code ExecutionException} with an {@code\n", "   *     Error} as its cause\n", "   * @throws CancellationException if {@code get} throws a {@code CancellationException}\n"], "32": ["     * It's a non-Error, non-Exception Throwable. From my survey of such classes, I believe that\n", "     * most users intended to extend Exception, so we'll treat it like an Exception.\n", "   * Arguably we don't need a timed getUnchecked because any operation slow enough to require a\n", "   * timeout is heavyweight enough to throw a checked exception and therefore be inappropriate to\n", "   * use with getUnchecked. Further, it's not clear that converting the checked TimeoutException to\n", "   * a RuntimeException -- especially to an UncheckedExecutionException, since it wasn't thrown by\n", "   * the computation -- makes sense, and if we don't convert it, the user still has to write a\n", "   * try-catch block.\n", "   *\n", "   * If you think you would use this method, let us know. You might also also look into the\n", "   * Fork-Join framework: http://docs.oracle.com/javase/tutorial/essential/concurrency/forkjoin.html\n", "   * A checked future that uses a function to map from exceptions to the appropriate checked type.\n", "  private static class MappingCheckedFuture<V, X extends Exception>\n", "      extends AbstractCheckedFuture<V, X> {\n", "    MappingCheckedFuture(ListenableFuture<V> delegate, Function<? super Exception, X> mapper) {\n"]}, "removed": {"1": [" * Licensed under the Apache License, Version 2.0 (the \"License\");\n", " * you may not use this file except in compliance with the License.\n", " * You may obtain a copy of the License at\n", " * Unless required by applicable law or agreed to in writing, software\n", " * distributed under the License is distributed on an \"AS IS\" BASIS,\n", " * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n", " * See the License for the specific language governing permissions and\n", " * limitations under the License.\n"], "2": ["   * <p>The given mapping function will be applied to an\n", "   * {@link InterruptedException}, a {@link CancellationException}, or an\n", "   * {@link ExecutionException}.\n", "   * See {@link Future#get()} for details on the exceptions thrown.\n"], "3": ["   * Creates a {@code ListenableFuture} which has its value set immediately upon\n", "   * construction. The getters just return the value. This {@code Future} can't\n", "   * be canceled or timed out and its {@code isDone()} method always returns\n", "   * {@code true}.\n"], "4": ["   * Returns a {@code CheckedFuture} which has its value set immediately upon\n", "   * construction.\n", "   * <p>The returned {@code Future} can't be cancelled, and its {@code isDone()}\n", "   * method always returns {@code true}. Calling {@code get()} or {@code\n", "   * checkedGet()} will immediately return the provided value.\n", "  public static <V, X extends Exception> CheckedFuture<V, X>\n", "      immediateCheckedFuture(@Nullable V value) {\n", "   * Returns a {@code ListenableFuture} which has an exception set immediately\n", "   * upon construction.\n", "   * <p>The returned {@code Future} can't be cancelled, and its {@code isDone()}\n", "   * method always returns {@code true}. Calling {@code get()} will immediately\n", "   * throw the provided {@code Throwable} wrapped in an {@code\n", "   * ExecutionException}.\n", "  public static <V> ListenableFuture<V> immediateFailedFuture(\n", "      Throwable throwable) {\n", "   * Creates a {@code ListenableFuture} which is cancelled immediately upon\n", "   * construction, so that {@code isCancelled()} always returns {@code true}.\n"], "5": ["   * Returns a {@code CheckedFuture} which has an exception set immediately upon\n", "   * construction.\n", "   *\n", "   * <p>The returned {@code Future} can't be cancelled, and its {@code isDone()}\n", "   * method always returns {@code true}. Calling {@code get()} will immediately\n", "   * throw the provided {@code Exception} wrapped in an {@code\n", "   * ExecutionException}, and calling {@code checkedGet()} will throw the\n", "   * provided exception itself.\n", "  public static <V, X extends Exception> CheckedFuture<V, X>\n", "      immediateFailedCheckedFuture(X exception) {\n", "   * Returns a {@code Future} whose result is taken from the given primary\n", "   * {@code input} or, if the primary input fails, from the {@code Future}\n", "   * provided by the {@code fallback}. {@link FutureFallback#create} is not\n", "   * invoked until the primary input has failed, so if the primary input\n", "   * succeeds, it is never invoked. If, during the invocation of {@code\n", "   * fallback}, an exception is thrown, this exception is used as the result of\n", "   * the output {@code Future}.\n", "   * <p>Below is an example of a fallback that returns a default value if an\n", "   * exception occurs:\n"], "6": ["   * <p>The fallback can also choose to propagate the original exception when\n", "   * desired:\n"], "7": ["   * <p>This overload, which does not accept an executor, uses {@code\n", "   * directExecutor}, a dangerous choice in some cases. See the discussion in\n", "   * the {@link ListenableFuture#addListener ListenableFuture.addListener}\n", "   * documentation. The documentation's warnings about \"lightweight listeners\"\n", "   * refer here to the work done during {@code FutureFallback.create}, not to\n", "   * any work done to complete the returned {@code Future}.\n", "   * @param fallback the {@link FutureFallback} implementation to be called if\n", "   *     {@code input} fails\n", "   * @deprecated Use {@link #catchingAsync(ListenableFuture, Class,\n", "   *     AsyncFunction) catchingAsync(input, Throwable.class,\n", "   *     fallbackImplementedAsAnAsyncFunction)}, usually replacing {@code\n", "   *     Throwable.class} with the specific type you want to handle. This method\n", "      ListenableFuture<? extends V> input,\n", "      FutureFallback<? extends V> fallback) {\n", "   * Returns a {@code Future} whose result is taken from the given primary\n", "   * {@code input} or, if the primary input fails, from the {@code Future}\n", "   * provided by the {@code fallback}. {@link FutureFallback#create} is not\n", "   * invoked until the primary input has failed, so if the primary input\n", "   * succeeds, it is never invoked. If, during the invocation of {@code\n", "   * fallback}, an exception is thrown, this exception is used as the result of\n", "   * the output {@code Future}.\n", "   * <p>Below is an example of a fallback that returns a default value if an\n", "   * exception occurs:\n"], "8": ["   * <p>The fallback can also choose to propagate the original exception when\n", "   * desired:\n"], "9": ["   * <p>When selecting an executor, note that {@code directExecutor} is\n", "   * dangerous in some cases. See the discussion in the {@link\n", "   * ListenableFuture#addListener ListenableFuture.addListener} documentation.\n", "   * The documentation's warnings about \"lightweight listeners\" refer here to\n", "   * the work done during {@code FutureFallback.create}, not to any work done to\n", "   * complete the returned {@code Future}.\n", "   * @param fallback the {@link FutureFallback} implementation to be called if\n", "   *     {@code input} fails\n", "   * @param executor the executor that runs {@code fallback} if {@code input}\n", "   *     fails\n", "   * @deprecated Use {@link #catchingAsync(ListenableFuture, Class,\n", "   *     AsyncFunction, Executor) catchingAsync(input, Throwable.class,\n", "   *     fallbackImplementedAsAnAsyncFunction, executor)}, usually replacing\n", "   *     {@code Throwable.class} with the specific type you want to handle. This method\n", "   *     will be removed in Guava release 20.0.\n", "      FutureFallback<? extends V> fallback, Executor executor) {\n", "    return catchingAsync(\n", "        input, Throwable.class, asAsyncFunction(fallback), executor);\n"], "10": ["      ListenableFuture<? extends V> input, Class<X> exceptionType,\n"], "11": ["      ListenableFuture<? extends V> input, Class<X> exceptionType,\n", "      Function<? super X, ? extends V> fallback, Executor executor) {\n"], "12": ["      ListenableFuture<? extends V> input, Class<X> exceptionType,\n"], "13": ["      ListenableFuture<? extends V> input, Class<X> exceptionType,\n", "      AsyncFunction<? super X, ? extends V> fallback, Executor executor) {\n"], "14": ["        return checkNotNull(fallback.create(t), \"FutureFallback.create returned null instead of a \"\n", "            + \"Future. Did you mean to return immediateFuture(null)?\");\n", "   * Returns a future that delegates to another but will finish early (via a\n", "   * {@link TimeoutException} wrapped in an {@link ExecutionException}) if the\n", "   * specified duration expires.\n"], "15": ["  public static <V> ListenableFuture<V> withTimeout(ListenableFuture<V> delegate,\n", "      long time, TimeUnit unit, ScheduledExecutorService scheduledExecutor) {\n", "   * Returns a new {@code ListenableFuture} whose result is asynchronously\n", "   * derived from the result of the given {@code Future}. More precisely, the\n", "   * returned {@code Future} takes its result from a {@code Future} produced by\n", "   * applying the given {@code AsyncFunction} to the result of the original\n", "   * {@code Future}. Example:\n"], "16": ["   * <p>This overload, which does not accept an executor, uses {@code\n", "   * directExecutor}, a dangerous choice in some cases. See the discussion in\n", "   * the {@link ListenableFuture#addListener ListenableFuture.addListener}\n", "   * documentation. The documentation's warnings about \"lightweight listeners\"\n", "   * refer here to the work done during {@code AsyncFunction.apply}, not to any\n", "   * work done to complete the returned {@code Future}.\n", "   * <p>The returned {@code Future} attempts to keep its cancellation state in\n", "   * sync with that of the input future and that of the future returned by the\n", "   * function. That is, if the returned {@code Future} is cancelled, it will\n", "   * attempt to cancel the other two, and if either of the other two is\n", "   * cancelled, the returned {@code Future} will receive a callback in which it\n", "   * will attempt to cancel itself.\n", "   * @param function A function to transform the result of the input future\n", "   *     to the result of the output future\n", "   * @return A future that holds result of the function (if the input succeeded)\n", "   *     or the original input's failure (if not)\n", "   * @deprecated These {@code AsyncFunction} overloads of {@code transform} are\n", "   *     being renamed to {@code transformAsync}. (The {@code Function}\n", "   *     overloads are keeping the \"transform\" name.) This method will be removed in Guava release\n", "   *     20.0.\n", "  public static <I, O> ListenableFuture<O> transform(ListenableFuture<I> input,\n", "      AsyncFunction<? super I, ? extends O> function) {\n", "   * Returns a new {@code ListenableFuture} whose result is asynchronously\n", "   * derived from the result of the given {@code Future}. More precisely, the\n", "   * returned {@code Future} takes its result from a {@code Future} produced by\n", "   * applying the given {@code AsyncFunction} to the result of the original\n", "   * {@code Future}. Example:\n"], "17": ["   * <p>When selecting an executor, note that {@code directExecutor} is\n", "   * dangerous in some cases. See the discussion in the {@link\n", "   * ListenableFuture#addListener ListenableFuture.addListener} documentation.\n", "   * The documentation's warnings about \"lightweight listeners\" refer here to\n", "   * the work done during {@code AsyncFunction.apply}, not to any work done to\n", "   * complete the returned {@code Future}.\n", "   * <p>The returned {@code Future} attempts to keep its cancellation state in\n", "   * sync with that of the input future and that of the future returned by the\n", "   * chain function. That is, if the returned {@code Future} is cancelled, it\n", "   * will attempt to cancel the other two, and if either of the other two is\n", "   * cancelled, the returned {@code Future} will receive a callback in which it\n", "   * will attempt to cancel itself.\n", "   * @param function A function to transform the result of the input future\n", "   *     to the result of the output future\n", "   * @return A future that holds result of the function (if the input succeeded)\n", "   *     or the original input's failure (if not)\n", "   * @deprecated These {@code AsyncFunction} overloads of {@code transform} are\n", "   *     being renamed to {@code transformAsync}. (The {@code Function}\n", "   *     overloads are keeping the \"transform\" name.) This method will be removed in Guava release\n", "   *     20.0.\n", "  public static <I, O> ListenableFuture<O> transform(ListenableFuture<I> input,\n"], "18": ["  public static <I, O> ListenableFuture<O> transformAsync(ListenableFuture<I> input,\n", "      AsyncFunction<? super I, ? extends O> function, Executor executor) {\n", "   * Returns a new {@code ListenableFuture} whose result is the product of\n", "   * applying the given {@code Function} to the result of the given {@code\n", "   * Future}. Example:\n"], "19": ["   * <p>This overload, which does not accept an executor, uses {@code\n", "   * directExecutor}, a dangerous choice in some cases. See the discussion in\n", "   * the {@link ListenableFuture#addListener ListenableFuture.addListener}\n", "   * documentation. The documentation's warnings about \"lightweight listeners\"\n", "   * refer here to the work done during {@code Function.apply}.\n", "   * <p>The returned {@code Future} attempts to keep its cancellation state in\n", "   * sync with that of the input future. That is, if the returned {@code Future}\n", "   * is cancelled, it will attempt to cancel the input, and if the input is\n", "   * cancelled, the returned {@code Future} will receive a callback in which it\n", "   * will attempt to cancel itself.\n", "   * <p>An example use of this method is to convert a serializable object\n", "   * returned from an RPC into a POJO.\n", "   * @param function A Function to transform the results of the provided future\n", "   *     to the results of the returned future.  This will be run in the thread\n", "   *     that notifies input it is complete.\n"], "20": ["   * Returns a new {@code ListenableFuture} whose result is the product of\n", "   * applying the given {@code Function} to the result of the given {@code\n", "   * Future}. Example:\n"], "21": ["   * <p>When selecting an executor, note that {@code directExecutor} is\n", "   * dangerous in some cases. See the discussion in the {@link\n", "   * ListenableFuture#addListener ListenableFuture.addListener} documentation.\n", "   * The documentation's warnings about \"lightweight listeners\" refer here to\n", "   * the work done during {@code Function.apply}.\n", "   * <p>The returned {@code Future} attempts to keep its cancellation state in\n", "   * sync with that of the input future. That is, if the returned {@code Future}\n", "   * is cancelled, it will attempt to cancel the input, and if the input is\n", "   * cancelled, the returned {@code Future} will receive a callback in which it\n", "   * will attempt to cancel itself.\n", "   * <p>An example use of this method is to convert a serializable object\n", "   * returned from an RPC into a POJO.\n", "   * @param function A Function to transform the results of the provided future\n", "   *     to the results of the returned future.\n"], "22": ["   * Like {@link #transform(ListenableFuture, Function)} except that the\n", "   * transformation {@code function} is invoked on each call to\n", "   * {@link Future#get() get()} on the returned future.\n", "   * <p>The returned {@code Future} reflects the input's cancellation\n", "   * state directly, and any attempt to cancel the returned Future is likewise\n", "   * passed through to the input Future.\n", "   * <p>Note that calls to {@linkplain Future#get(long, TimeUnit) timed get}\n", "   * only apply the timeout to the execution of the underlying {@code Future},\n", "   * <em>not</em> to the execution of the transformation function.\n", "   * <p>The primary audience of this method is callers of {@code transform}\n", "   * who don't have a {@code ListenableFuture} available and\n", "   * do not mind repeated, lazy function evaluation.\n", "   * @param function A Function to transform the results of the provided future\n", "   *     to the results of the returned future.\n", "  public static <I, O> Future<O> lazyTransform(final Future<I> input,\n", "      final Function<? super I, ? extends O> function) {\n"], "23": ["   * Returns a new {@code ListenableFuture} whose result is the product of\n", "   * calling {@code get()} on the {@code Future} nested within the given {@code\n", "   * Future}, effectively chaining the futures one after the other.  Example:\n", "   * #transform(ListenableFuture, AsyncFunction)}, in that the returned {@code\n", "   * Future} attempts to keep its cancellation state in sync with both the\n", "   * input {@code Future} and the nested {@code Future}.  The transformation\n", "   * is very lightweight and therefore takes place in the same thread (either\n", "   * the thread that called {@code dereference}, or the thread in which the\n", "   * dereferenced future completes).\n"], "24": ["        @Override public ListenableFuture<Object> apply(ListenableFuture<Object> input) {\n", "   * Creates a new {@code ListenableFuture} whose value is a list containing the\n", "   * values of all its input futures, if all succeed. If any input fails, the\n", "   * returned future fails immediately.\n", "   * <p>Canceling this future will attempt to cancel all the component futures,\n", "   * and if any of the provided futures fails or is canceled, this one is,\n", "   * too.\n", "   * @return a future that provides a list of the results of the component\n", "   *         futures\n", "  public static <V> ListenableFuture<List<V>> allAsList(\n", "      ListenableFuture<? extends V>... futures) {\n", "   * Creates a new {@code ListenableFuture} whose value is a list containing the\n", "   * values of all its input futures, if all succeed. If any input fails, the\n", "   * returned future fails immediately.\n", "   * <p>Canceling this future will attempt to cancel all the component futures,\n", "   * and if any of the provided futures fails or is canceled, this one is,\n", "   * too.\n", "   * @return a future that provides a list of the results of the component\n", "   *         futures\n"], "25": ["   * Creates a new {@code ListenableFuture} whose result is set from the\n", "   * supplied future when it completes.  Cancelling the supplied future\n", "   * will also cancel the returned future, but cancelling the returned\n", "   * future will have no effect on the supplied future.\n", "  public static <V> ListenableFuture<V> nonCancellationPropagating(\n", "      ListenableFuture<V> future) {\n"], "26": ["      delegate.addListener(new Runnable() {\n", "        @Override public void run() {\n", "          // This prevents cancellation from propagating because we don't assign delegate until\n", "          // delegate is already done, so calling cancel() on it is a no-op.\n", "          setFuture(delegate);\n", "        }\n", "      }, directExecutor());\n", "   * Creates a new {@code ListenableFuture} whose value is a list containing the\n", "   * values of all its successful input futures. The list of results is in the\n", "   * same order as the input list, and if any of the provided futures fails or\n", "   * is canceled, its corresponding position will contain {@code null} (which is\n", "   * indistinguishable from the future having a successful value of\n", "   * {@code null}).\n", "   * @return a future that provides a list of the results of the component\n", "   *         futures\n"], "27": ["   * Creates a new {@code ListenableFuture} whose value is a list containing the\n", "   * values of all its successful input futures. The list of results is in the\n", "   * same order as the input list, and if any of the provided futures fails or\n", "   * is canceled, its corresponding position will contain {@code null} (which is\n", "   * indistinguishable from the future having a successful value of\n", "   * {@code null}).\n", "   * @return a future that provides a list of the results of the component\n", "   *         futures\n"], "28": ["    final ConcurrentLinkedQueue<SettableFuture<T>> delegates =\n", "        Queues.newConcurrentLinkedQueue();\n"], "29": ["      future.addListener(new Runnable() {\n", "        @Override public void run() {\n", "          delegates.remove().setFuture(future);\n", "        }\n", "      }, executor);\n", "   * Registers separate success and failure callbacks to be run when the {@code\n", "   * Future}'s computation is {@linkplain java.util.concurrent.Future#isDone()\n", "   * complete} or, if the computation is already complete, immediately.\n", "   * <p>There is no guaranteed ordering of execution of callbacks, but any\n", "   * callback added through this method is guaranteed to be called once the\n", "   * computation is complete.\n"], "30": ["   * <p>This overload, which does not accept an executor, uses {@code\n", "   * directExecutor}, a dangerous choice in some cases. See the discussion in\n", "   * the {@link ListenableFuture#addListener ListenableFuture.addListener}\n", "   * documentation.\n", "   * <p>For a more general interface to attach a completion listener to a\n", "   * {@code Future}, see {@link ListenableFuture#addListener addListener}.\n", "  public static <V> void addCallback(ListenableFuture<V> future,\n", "      FutureCallback<? super V> callback) {\n", "   * Registers separate success and failure callbacks to be run when the {@code\n", "   * Future}'s computation is {@linkplain java.util.concurrent.Future#isDone()\n", "   * complete} or, if the computation is already complete, immediately.\n", "   * <p>The callback is run in {@code executor}.\n", "   * There is no guaranteed ordering of execution of callbacks, but any\n", "   * callback added through this method is guaranteed to be called once the\n"], "31": ["   * <p>When selecting an executor, note that {@code directExecutor} is\n", "   * dangerous in some cases. See the discussion in the {@link\n", "   * ListenableFuture#addListener ListenableFuture.addListener} documentation.\n", "   * <p>For a more general interface to attach a completion listener to a\n", "   * {@code Future}, see {@link ListenableFuture#addListener addListener}.\n", "   * @param executor The executor to run {@code callback} when the future\n", "   *    completes.\n", "  public static <V> void addCallback(final ListenableFuture<V> future,\n", "      final FutureCallback<? super V> callback, Executor executor) {\n", "    Runnable callbackListener = new Runnable() {\n", "      @Override\n", "      public void run() {\n", "        final V value;\n", "        try {\n", "          // TODO(user): (Before Guava release), validate that this\n", "          // is the thing for IE.\n", "          value = getUninterruptibly(future);\n", "        } catch (ExecutionException e) {\n", "          callback.onFailure(e.getCause());\n", "          return;\n", "        } catch (RuntimeException e) {\n", "          callback.onFailure(e);\n", "          return;\n", "        } catch (Error e) {\n", "          callback.onFailure(e);\n", "          return;\n", "        }\n", "        callback.onSuccess(value);\n", "      }\n", "    };\n", "   * Returns the result of {@link Future#get()}, converting most exceptions to a\n", "   * new instance of the given checked exception type. This reduces boilerplate\n", "   * for a common use of {@code Future} in which it is unnecessary to\n", "   * programmatically distinguish between exception types or to extract other\n", "   * information from the exception instance.\n", "   * <li>Any {@link ExecutionException} has its <i>cause</i> wrapped in an\n", "   *     {@code X} if the cause is a checked exception, an {@link\n", "   *     UncheckedExecutionException} if the cause is a {@code\n", "   *     RuntimeException}, or an {@link ExecutionError} if the cause is an\n", "   *     {@code Error}.\n", "   * <li>Any {@link InterruptedException} is wrapped in an {@code X} (after\n", "   *     restoring the interrupt).\n", "   * <li>Any {@link CancellationException} is propagated untouched, as is any\n", "   *     other {@link RuntimeException} (though {@code get} implementations are\n", "   *     discouraged from throwing such exceptions).\n", "   * <p>The overall principle is to continue to treat every checked exception as a\n", "   * checked exception, every unchecked exception as an unchecked exception, and\n", "   * every error as an error. In addition, the cause of any {@code\n", "   * ExecutionException} is wrapped in order to ensure that the new stack trace\n", "   * matches that of the current thread.\n", "   *\n", "   * <p>Instances of {@code exceptionClass} are created by choosing an arbitrary\n", "   * public constructor that accepts zero or more arguments, all of type {@code\n", "   * String} or {@code Throwable} (preferring constructors with at least one\n", "   * {@code String}) and calling the constructor via reflection. If the\n", "   * exception did not already have a cause, one is set by calling {@link\n", "   * Throwable#initCause(Throwable)} on it. If no such constructor exists, an\n", "   * {@code IllegalArgumentException} is thrown.\n", "   *\n", "   * @throws X if {@code get} throws any checked exception except for an {@code\n", "   *         ExecutionException} whose cause is not itself a checked exception\n", "   * @throws UncheckedExecutionException if {@code get} throws an {@code\n", "   *         ExecutionException} with a {@code RuntimeException} as its cause\n", "   * @throws ExecutionError if {@code get} throws an {@code ExecutionException}\n", "   *         with an {@code Error} as its cause\n", "   * @throws CancellationException if {@code get} throws a {@code\n", "   *         CancellationException}\n", "   * @throws IllegalArgumentException if {@code exceptionClass} extends {@code\n", "   *         RuntimeException} or does not have a suitable constructor\n", "   * @deprecated Use {@link #getChecked(Future, Class)}. This method will be\n", "   *     removed in Guava release 20.0.\n", "  public static <V, X extends Exception> V get(\n", "      Future<V> future, Class<X> exceptionClass) throws X {\n", "   * Returns the result of {@link Future#get(long, TimeUnit)}, converting most\n", "   * exceptions to a new instance of the given checked exception type. This\n", "   * reduces boilerplate for a common use of {@code Future} in which it is\n", "   * unnecessary to programmatically distinguish between exception types or to\n", "   * extract other information from the exception instance.\n", "   * <li>Any {@link ExecutionException} has its <i>cause</i> wrapped in an\n", "   *     {@code X} if the cause is a checked exception, an {@link\n", "   *     UncheckedExecutionException} if the cause is a {@code\n", "   *     RuntimeException}, or an {@link ExecutionError} if the cause is an\n", "   *     {@code Error}.\n", "   * <li>Any {@link InterruptedException} is wrapped in an {@code X} (after\n", "   *     restoring the interrupt).\n", "   * <li>Any {@link CancellationException} is propagated untouched, as is any\n", "   *     other {@link RuntimeException} (though {@code get} implementations are\n", "   *     discouraged from throwing such exceptions).\n", "   * <p>The overall principle is to continue to treat every checked exception as a\n", "   * checked exception, every unchecked exception as an unchecked exception, and\n", "   * every error as an error. In addition, the cause of any {@code\n", "   * ExecutionException} is wrapped in order to ensure that the new stack trace\n", "   * matches that of the current thread.\n", "   *\n", "   * <p>Instances of {@code exceptionClass} are created by choosing an arbitrary\n", "   * public constructor that accepts zero or more arguments, all of type {@code\n", "   * String} or {@code Throwable} (preferring constructors with at least one\n", "   * {@code String}) and calling the constructor via reflection. If the\n", "   * exception did not already have a cause, one is set by calling {@link\n", "   * Throwable#initCause(Throwable)} on it. If no such constructor exists, an\n", "   * {@code IllegalArgumentException} is thrown.\n", "   *\n", "   * @throws X if {@code get} throws any checked exception except for an {@code\n", "   *         ExecutionException} whose cause is not itself a checked exception\n", "   * @throws UncheckedExecutionException if {@code get} throws an {@code\n", "   *         ExecutionException} with a {@code RuntimeException} as its cause\n", "   * @throws ExecutionError if {@code get} throws an {@code ExecutionException}\n", "   *         with an {@code Error} as its cause\n", "   * @throws CancellationException if {@code get} throws a {@code\n", "   *         CancellationException}\n", "   * @throws IllegalArgumentException if {@code exceptionClass} extends {@code\n", "   *         RuntimeException} or does not have a suitable constructor\n", "   * @deprecated Use {@link #getChecked(Future, Class, long, TimeUnit)}, noting\n", "   *     the change in parameter order. This method will be removed in Guava\n", "   *     release 20.0.\n", "      Future<V> future, long timeout, TimeUnit unit, Class<X> exceptionClass)\n", "      throws X {\n", "   * Returns the result of {@link Future#get()}, converting most exceptions to a\n", "   * new instance of the given checked exception type. This reduces boilerplate\n", "   * for a common use of {@code Future} in which it is unnecessary to\n", "   * programmatically distinguish between exception types or to extract other\n", "   * information from the exception instance.\n", "   * <li>Any {@link ExecutionException} has its <i>cause</i> wrapped in an\n", "   *     {@code X} if the cause is a checked exception, an {@link\n", "   *     UncheckedExecutionException} if the cause is a {@code\n", "   *     RuntimeException}, or an {@link ExecutionError} if the cause is an\n", "   *     {@code Error}.\n", "   * <li>Any {@link InterruptedException} is wrapped in an {@code X} (after\n", "   *     restoring the interrupt).\n", "   * <li>Any {@link CancellationException} is propagated untouched, as is any\n", "   *     other {@link RuntimeException} (though {@code get} implementations are\n", "   *     discouraged from throwing such exceptions).\n", "   * <p>The overall principle is to continue to treat every checked exception as a\n", "   * checked exception, every unchecked exception as an unchecked exception, and\n", "   * every error as an error. In addition, the cause of any {@code\n", "   * ExecutionException} is wrapped in order to ensure that the new stack trace\n", "   * matches that of the current thread.\n", "   *\n", "   * <p>Instances of {@code exceptionClass} are created by choosing an arbitrary\n", "   * public constructor that accepts zero or more arguments, all of type {@code\n", "   * String} or {@code Throwable} (preferring constructors with at least one\n", "   * {@code String}) and calling the constructor via reflection. If the\n", "   * exception did not already have a cause, one is set by calling {@link\n", "   * Throwable#initCause(Throwable)} on it. If no such constructor exists, an\n", "   * {@code IllegalArgumentException} is thrown.\n", "   *\n", "   * @throws X if {@code get} throws any checked exception except for an {@code\n", "   *     ExecutionException} whose cause is not itself a checked exception\n", "   * @throws UncheckedExecutionException if {@code get} throws an {@code\n", "   *     ExecutionException} with a {@code RuntimeException} as its cause\n", "   * @throws ExecutionError if {@code get} throws an {@code ExecutionException}\n", "   *     with an {@code Error} as its cause\n", "   * @throws CancellationException if {@code get} throws a {@code\n", "   *     CancellationException}\n", "   * @throws IllegalArgumentException if {@code exceptionClass} extends {@code\n", "   *     RuntimeException} or does not have a suitable constructor\n", "  public static <V, X extends Exception> V getChecked(\n", "      Future<V> future, Class<X> exceptionClass) throws X {\n", "   * Returns the result of {@link Future#get(long, TimeUnit)}, converting most\n", "   * exceptions to a new instance of the given checked exception type. This\n", "   * reduces boilerplate for a common use of {@code Future} in which it is\n", "   * unnecessary to programmatically distinguish between exception types or to\n", "   * extract other information from the exception instance.\n", "   * <li>Any {@link ExecutionException} has its <i>cause</i> wrapped in an\n", "   *     {@code X} if the cause is a checked exception, an {@link\n", "   *     UncheckedExecutionException} if the cause is a {@code\n", "   *     RuntimeException}, or an {@link ExecutionError} if the cause is an\n", "   *     {@code Error}.\n", "   * <li>Any {@link InterruptedException} is wrapped in an {@code X} (after\n", "   *     restoring the interrupt).\n", "   * <li>Any {@link CancellationException} is propagated untouched, as is any\n", "   *     other {@link RuntimeException} (though {@code get} implementations are\n", "   *     discouraged from throwing such exceptions).\n", "   * <p>The overall principle is to continue to treat every checked exception as a\n", "   * checked exception, every unchecked exception as an unchecked exception, and\n", "   * every error as an error. In addition, the cause of any {@code\n", "   * ExecutionException} is wrapped in order to ensure that the new stack trace\n", "   * matches that of the current thread.\n", "   *\n", "   * <p>Instances of {@code exceptionClass} are created by choosing an arbitrary\n", "   * public constructor that accepts zero or more arguments, all of type {@code\n", "   * String} or {@code Throwable} (preferring constructors with at least one\n", "   * {@code String}) and calling the constructor via reflection. If the\n", "   * exception did not already have a cause, one is set by calling {@link\n", "   * Throwable#initCause(Throwable)} on it. If no such constructor exists, an\n", "   * {@code IllegalArgumentException} is thrown.\n", "   *\n", "   * @throws X if {@code get} throws any checked exception except for an {@code\n", "   *     ExecutionException} whose cause is not itself a checked exception\n", "   * @throws UncheckedExecutionException if {@code get} throws an {@code\n", "   *     ExecutionException} with a {@code RuntimeException} as its cause\n", "   * @throws ExecutionError if {@code get} throws an {@code ExecutionException}\n", "   *     with an {@code Error} as its cause\n", "   * @throws CancellationException if {@code get} throws a {@code\n", "   *     CancellationException}\n", "   * @throws IllegalArgumentException if {@code exceptionClass} extends {@code\n", "   *     RuntimeException} or does not have a suitable constructor\n", "      Future<V> future, Class<X> exceptionClass, long timeout, TimeUnit unit)\n", "      throws X {\n", "   * Returns the result of calling {@link Future#get()} uninterruptibly on a\n", "   * task known not to throw a checked exception. This makes {@code Future} more\n", "   * suitable for lightweight, fast-running tasks that, barring bugs in the\n", "   * code, will not fail. This gives it exception-handling behavior similar to\n", "   * that of {@code ForkJoinTask.join}.\n", "   * <li>Any {@link ExecutionException} has its <i>cause</i> wrapped in an\n", "   *     {@link UncheckedExecutionException} (if the cause is an {@code\n", "   *     Exception}) or {@link ExecutionError} (if the cause is an {@code\n", "   *     Error}).\n", "   * <li>Any {@link InterruptedException} causes a retry of the {@code get}\n", "   *     call. The interrupt is restored before {@code getUnchecked} returns.\n", "   * <li>Any {@link CancellationException} is propagated untouched. So is any\n", "   *     other {@link RuntimeException} ({@code get} implementations are\n", "   *     discouraged from throwing such exceptions).\n", "   * <p>The overall principle is to eliminate all checked exceptions: to loop to\n", "   * avoid {@code InterruptedException}, to pass through {@code\n", "   * CancellationException}, and to wrap any exception from the underlying\n", "   * computation in an {@code UncheckedExecutionException} or {@code\n", "   * <p>For an uninterruptible {@code get} that preserves other exceptions, see\n", "   * {@link Uninterruptibles#getUninterruptibly(Future)}.\n", "   * @throws UncheckedExecutionException if {@code get} throws an {@code\n", "   *         ExecutionException} with an {@code Exception} as its cause\n", "   * @throws ExecutionError if {@code get} throws an {@code ExecutionException}\n", "   *         with an {@code Error} as its cause\n", "   * @throws CancellationException if {@code get} throws a {@code\n", "   *         CancellationException}\n"], "32": ["     * It's a non-Error, non-Exception Throwable. From my survey of such\n", "     * classes, I believe that most users intended to extend Exception, so we'll\n", "     * treat it like an Exception.\n", "   * Arguably we don't need a timed getUnchecked because any operation slow\n", "   * enough to require a timeout is heavyweight enough to throw a checked\n", "   * exception and therefore be inappropriate to use with getUnchecked. Further,\n", "   * it's not clear that converting the checked TimeoutException to a\n", "   * RuntimeException -- especially to an UncheckedExecutionException, since it\n", "   * wasn't thrown by the computation -- makes sense, and if we don't convert\n", "   * it, the user still has to write a try-catch block.\n", "   *\n", "   * If you think you would use this method, let us know. You might also also\n", "   * look into the Fork-Join framework:\n", "   * http://docs.oracle.com/javase/tutorial/essential/concurrency/forkjoin.html\n", "   * A checked future that uses a function to map from exceptions to the\n", "   * appropriate checked type.\n", "  private static class MappingCheckedFuture<V, X extends Exception> extends\n", "      AbstractCheckedFuture<V, X> {\n", "    MappingCheckedFuture(ListenableFuture<V> delegate,\n", "        Function<? super Exception, X> mapper) {\n"]}, "added_lines": {"1": [4, 5, 9, 10, 11, 12], "2": [123, 124, 125], "3": [137, 138, 139], "4": [153, 155, 156, 157, 161, 162, 167, 169, 170, 171, 174, 180, 181], "5": [192, 193, 194, 195, 196, 197, 201, 202, 208, 209, 210, 211, 212, 214], "6": [230], "7": [247, 248, 249, 250, 251, 254, 256, 257, 258, 264, 269, 270, 271, 272, 273, 275], "8": [291], "9": [308, 309, 310, 311, 312, 315, 316, 318, 319, 320, 321, 327, 328, 329], "10": [371, 372], "11": [417, 418, 419, 420], "12": [483, 484], "13": [549, 550, 551, 552], "14": [562, 563, 564, 565, 571, 572], "15": [585, 586, 587, 588, 589, 594, 595, 596, 597], "16": [610, 611, 612, 613, 614, 616, 617, 618, 619, 620, 623, 624, 625, 626, 628, 629, 630, 633, 634, 639, 640, 641, 642], "17": [655, 656, 657, 658, 659, 661, 662, 663, 664, 665, 668, 669, 671, 672, 674, 675, 676, 679, 680], "18": [764, 765, 766, 767, 772, 773], "19": [786, 787, 788, 789, 791, 792, 793, 794, 796, 797, 800, 801], "20": [811, 812], "21": [825, 826, 827, 828, 830, 831, 832, 833, 835, 836, 839, 840], "22": [851, 852, 854, 855, 857, 858, 859, 861, 862, 865, 866, 872, 873], "23": [915, 916, 917, 924, 925, 926, 927, 928], "24": [946, 947, 953, 954, 958, 959, 962, 968, 973, 974, 978, 979, 982], "25": [993, 994, 995, 1001], "26": [1012, 1013, 1014, 1015, 1016, 1017, 1018, 1019, 1020, 1021, 1026, 1027, 1028, 1029, 1030, 1035], "27": [1047, 1048, 1049, 1050, 1051, 1056], "28": [1086], "29": [1103, 1104, 1105, 1106, 1107, 1108, 1109, 1110, 1117, 1118, 1119, 1121, 1122], "30": [1136, 1137, 1138, 1140, 1141, 1147, 1148, 1153, 1154, 1155, 1157, 1158], "31": [1174, 1175, 1176, 1178, 1179, 1183, 1186, 1187, 1188, 1189, 1191, 1192, 1193, 1194, 1195, 1196, 1197, 1198, 1199, 1200, 1201, 1202, 1203, 1204, 1205, 1206, 1207, 1208, 1209, 1210, 1211, 1212, 1217, 1218, 1219, 1220, 1224, 1225, 1226, 1227, 1228, 1229, 1230, 1231, 1234, 1235, 1236, 1237, 1238, 1239, 1240, 1241, 1242, 1243, 1244, 1245, 1246, 1247, 1248, 1249, 1250, 1251, 1252, 1253, 1254, 1256, 1257, 1261, 1266, 1267, 1268, 1269, 1273, 1274, 1275, 1276, 1277, 1279, 1280, 1281, 1284, 1285, 1286, 1287, 1288, 1289, 1290, 1291, 1292, 1293, 1294, 1295, 1296, 1297, 1298, 1299, 1300, 1301, 1302, 1303, 1304, 1306, 1307, 1312, 1317, 1318, 1319, 1320, 1324, 1325, 1326, 1327, 1328, 1329, 1330, 1331, 1334, 1335, 1336, 1337, 1338, 1339, 1340, 1341, 1342, 1343, 1344, 1345, 1346, 1347, 1348, 1349, 1350, 1351, 1352, 1353, 1354, 1358, 1359, 1364, 1365, 1366, 1367, 1371, 1372, 1373, 1374, 1375, 1377, 1378, 1379, 1382, 1383, 1384, 1385, 1386, 1387, 1388, 1389, 1390, 1391, 1392, 1393, 1394, 1395, 1396, 1397, 1398, 1399, 1400, 1401, 1402, 1407, 1412, 1413, 1414, 1415, 1419, 1420, 1421, 1422, 1423, 1424, 1425, 1426, 1429, 1430, 1431, 1434, 1435, 1437, 1438, 1439, 1440, 1441], "32": [1461, 1462, 1468, 1469, 1470, 1471, 1472, 1473, 1474, 1475, 1476, 1480, 1483, 1484, 1488]}, "removed_lines": {"1": [4, 5, 6, 10, 11, 12, 13, 14], "2": [125, 126, 127, 128], "3": [140, 141, 142, 143], "4": [157, 158, 160, 161, 162, 166, 167, 172, 173, 175, 176, 177, 178, 181, 182, 188, 189], "5": [200, 201, 202, 203, 204, 205, 206, 207, 211, 212, 218, 219, 220, 221, 222, 223, 224, 226, 227], "6": [243, 244], "7": [261, 262, 263, 264, 265, 266, 269, 270, 272, 273, 274, 275, 281, 282, 287, 288, 289, 290, 291, 292, 293, 295, 296], "8": [312, 313], "9": [330, 331, 332, 333, 334, 335, 338, 339, 340, 341, 343, 344, 345, 346, 347, 353, 354, 355], "10": [397], "11": [442, 443], "12": [506], "13": [571, 572], "14": [582, 583, 589, 590, 591], "15": [604, 605, 610, 611, 612, 613, 614], "16": [627, 628, 629, 630, 631, 632, 634, 635, 636, 637, 638, 639, 642, 643, 644, 645, 647, 648, 649, 650, 653, 654, 659, 660, 661, 662, 663], "17": [676, 677, 678, 679, 680, 681, 683, 684, 685, 686, 687, 688, 691, 692, 694, 695, 697, 698, 699, 700, 703], "18": [787, 788, 793, 794, 795], "19": [808, 809, 810, 811, 812, 814, 815, 816, 817, 818, 820, 821, 824, 825, 826], "20": [836, 837, 838], "21": [851, 852, 853, 854, 855, 857, 858, 859, 860, 861, 863, 864, 867, 868], "22": [879, 880, 881, 883, 884, 885, 887, 888, 889, 891, 892, 893, 896, 897, 903, 904], "23": [946, 947, 948, 955, 956, 957, 958, 959, 960], "24": [978, 984, 985, 986, 990, 991, 992, 995, 996, 1002, 1003, 1008, 1009, 1010, 1014, 1015, 1016, 1019, 1020], "25": [1031, 1032, 1033, 1034, 1040, 1041], "26": [1052, 1053, 1054, 1055, 1056, 1057, 1058, 1063, 1064, 1065, 1066, 1067, 1068, 1073, 1074], "27": [1086, 1087, 1088, 1089, 1090, 1091, 1096, 1097], "28": [1127, 1128], "29": [1145, 1146, 1147, 1148, 1149, 1156, 1157, 1158, 1160, 1161, 1162], "30": [1176, 1177, 1178, 1179, 1181, 1182, 1188, 1189, 1194, 1195, 1196, 1198, 1199, 1200], "31": [1216, 1217, 1218, 1220, 1221, 1225, 1226, 1229, 1230, 1232, 1233, 1234, 1235, 1236, 1237, 1238, 1239, 1240, 1241, 1242, 1243, 1244, 1245, 1246, 1247, 1248, 1249, 1250, 1251, 1252, 1257, 1258, 1259, 1260, 1261, 1265, 1266, 1267, 1268, 1269, 1270, 1271, 1272, 1273, 1274, 1277, 1278, 1279, 1280, 1281, 1282, 1283, 1284, 1285, 1286, 1287, 1288, 1289, 1290, 1291, 1292, 1293, 1294, 1295, 1296, 1297, 1298, 1299, 1300, 1302, 1303, 1307, 1308, 1313, 1314, 1315, 1316, 1317, 1321, 1322, 1323, 1324, 1325, 1326, 1327, 1329, 1330, 1331, 1334, 1335, 1336, 1337, 1338, 1339, 1340, 1341, 1342, 1343, 1344, 1345, 1346, 1347, 1348, 1349, 1350, 1351, 1352, 1353, 1354, 1355, 1356, 1357, 1359, 1360, 1361, 1366, 1367, 1372, 1373, 1374, 1375, 1376, 1380, 1381, 1382, 1383, 1384, 1385, 1386, 1387, 1388, 1389, 1392, 1393, 1394, 1395, 1396, 1397, 1398, 1399, 1400, 1401, 1402, 1403, 1404, 1405, 1406, 1407, 1408, 1409, 1410, 1411, 1412, 1413, 1414, 1415, 1419, 1420, 1425, 1426, 1427, 1428, 1429, 1433, 1434, 1435, 1436, 1437, 1438, 1439, 1441, 1442, 1443, 1446, 1447, 1448, 1449, 1450, 1451, 1452, 1453, 1454, 1455, 1456, 1457, 1458, 1459, 1460, 1461, 1462, 1463, 1464, 1465, 1466, 1467, 1468, 1469, 1474, 1475, 1480, 1481, 1482, 1483, 1484, 1488, 1489, 1490, 1491, 1492, 1493, 1494, 1495, 1496, 1499, 1500, 1501, 1502, 1505, 1506, 1508, 1509, 1510, 1511, 1512, 1513], "32": [1533, 1534, 1535, 1541, 1542, 1543, 1544, 1545, 1546, 1547, 1548, 1549, 1550, 1551, 1555, 1556, 1559, 1560, 1564, 1565]}}, {"31": "guava/src/com/google/common/util/concurrent/GwtFuturesCatchingSpecialization.java", "added": {"1": [" * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not use this file except\n", " * in compliance with the License. You may obtain a copy of the License at\n", " * Unless required by applicable law or agreed to in writing, software distributed under the License\n", " * is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express\n", " * or implied. See the License for the specific language governing permissions and limitations under\n", " * the License.\n"]}, "removed": {"1": [" * Licensed under the Apache License, Version 2.0 (the \"License\");\n", " * you may not use this file except in compliance with the License.\n", " * You may obtain a copy of the License at\n", " * Unless required by applicable law or agreed to in writing, software\n", " * distributed under the License is distributed on an \"AS IS\" BASIS,\n", " * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n", " * See the License for the specific language governing permissions and\n", " * limitations under the License.\n"]}, "added_lines": {"1": [4, 5, 9, 10, 11, 12]}, "removed_lines": {"1": [4, 5, 6, 10, 11, 12, 13, 14]}}, {"32": "guava/src/com/google/common/util/concurrent/InterruptibleTask.java", "added": {"1": [" * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not use this file except\n", " * in compliance with the License. You may obtain a copy of the License at\n", " * Unless required by applicable law or agreed to in writing, software distributed under the License\n", " * is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express\n", " * or implied. See the License for the specific language governing permissions and limitations under\n", " * the License.\n"], "2": ["  // These two fields are used to interrupt running tasks.  The thread executing the task publishes\n", "  // itself to the 'runner' field and the thread interrupting sets 'doneInterrupting' when it has\n", "  // finished interrupting.\n", "  @Override\n", "  public final void run() {\n", "      return; // someone else has run or is running.\n"]}, "removed": {"1": [" * Licensed under the Apache License, Version 2.0 (the \"License\");\n", " * you may not use this file except in compliance with the License.\n", " * You may obtain a copy of the License at\n", " * Unless required by applicable law or agreed to in writing, software\n", " * distributed under the License is distributed on an \"AS IS\" BASIS,\n", " * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n", " * See the License for the specific language governing permissions and\n", " * limitations under the License.\n"], "2": ["  // These two fields are used to interrupt running tasks.  The thread executing the task\n", "  // publishes itself to the 'runner' field and the thread interrupting sets 'doneInterrupting'\n", "  // when it has finished interrupting.\n", "  @Override public final void run() {\n", "      return;  // someone else has run or is running.\n"]}, "added_lines": {"1": [4, 5, 9, 10, 11, 12], "2": [28, 29, 30, 34, 35, 37]}, "removed_lines": {"1": [4, 5, 6, 10, 11, 12, 13, 14], "2": [30, 31, 32, 36, 38]}}, {"33": "guava/src/com/google/common/util/concurrent/JdkFutureAdapters.java", "added": {"1": [" * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not use this file except\n", " * in compliance with the License. You may obtain a copy of the License at\n", " * Unless required by applicable law or agreed to in writing, software distributed under the License\n", " * is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express\n", " * or implied. See the License for the specific language governing permissions and limitations under\n", " * the License.\n"], "2": [" * Utilities necessary for working with libraries that supply plain {@link Future} instances. Note\n", " * that, whenver possible, it is strongly preferred to modify those libraries to return {@code\n", " * ListenableFuture} directly.\n", " * @since 10.0 (replacing {@code Futures.makeListenable}, which existed in 1.0)\n", "   * Assigns a thread to the given {@link Future} to provide {@link ListenableFuture} functionality.\n", "   * <p><b>Warning:</b> If the input future does not already implement {@code ListenableFuture}, the\n", "   * returned future will emulate {@link ListenableFuture#addListener} by taking a thread from an\n", "   * internal, unbounded pool at the first call to {@code addListener} and holding it until the\n", "   * future is {@linkplain Future#isDone() done}.\n", "   * <p>Prefer to create {@code ListenableFuture} instances with {@link SettableFuture}, {@link\n", "   * MoreExecutors#listeningDecorator( java.util.concurrent.ExecutorService)}, {@link\n", "   * ListenableFutureTask}, {@link AbstractFuture}, and other utilities over creating plain {@code\n", "   * Future} instances to be upgraded to {@code ListenableFuture} after the fact.\n", "  public static <V> ListenableFuture<V> listenInPoolThread(Future<V> future) {\n"], "3": ["   * Submits a blocking task for the given {@link Future} to provide {@link ListenableFuture}\n", "   * functionality.\n", "   * <p><b>Warning:</b> If the input future does not already implement {@code ListenableFuture}, the\n", "   * returned future will emulate {@link ListenableFuture#addListener} by submitting a task to the\n", "   * given executor at the first call to {@code addListener}. The task must be started by the\n", "   * executor promptly, or else the returned {@code ListenableFuture} may fail to work.  The task's\n", "   * execution consists of blocking until the input future is {@linkplain Future#isDone() done}, so\n", "   * each call to this method may claim and hold a thread for an arbitrary length of time. Use of\n", "   * bounded executors or other executors that may fail to execute a task promptly may result in\n", "   * deadlocks.\n", "   * <p>Prefer to create {@code ListenableFuture} instances with {@link SettableFuture}, {@link\n", "   * MoreExecutors#listeningDecorator( java.util.concurrent.ExecutorService)}, {@link\n", "   * ListenableFutureTask}, {@link AbstractFuture}, and other utilities over creating plain {@code\n", "   * Future} instances to be upgraded to {@code ListenableFuture} after the fact.\n", "  public static <V> ListenableFuture<V> listenInPoolThread(Future<V> future, Executor executor) {\n"], "4": ["   * An adapter to turn a {@link Future} into a {@link ListenableFuture}.  This will wait on the\n", "   * future to finish, and when it completes, run the listeners.  This implementation will wait on\n", "   * the source future indefinitely, so if the source future never completes, the adapter will never\n", "   * complete either.\n", "   * <p>If the delegate future is interrupted or throws an unexpected unchecked exception, the\n", "   * listeners will not be invoked.\n"], "5": ["    // This allows us to only start up a thread waiting on the delegate future when the first\n", "    // listener is added.\n"], "6": ["      // When a listener is first added, we run a task that will wait for the delegate to finish,\n", "      // and when it is done will run the listeners.\n", "          // If the delegate is already done, run the execution list immediately on the current\n", "          // thread.\n", "        adapterExecutor.execute(\n", "            new Runnable() {\n", "              @Override\n", "              public void run() {\n", "                try {\n", "                  /*\n", "                   * Threads from our private pool are never interrupted. Threads from a\n", "                   * user-supplied executor might be, but... what can we do? This is another reason\n", "                   * to return a proper ListenableFuture instead of using listenInPoolThread.\n", "                   */\n", "                  getUninterruptibly(delegate);\n", "                } catch (Throwable e) {\n", "                  // ExecutionException / CancellationException / RuntimeException / Error\n", "                  // The task is presumably done, run the listeners.\n", "                }\n", "                executionList.execute();\n", "              }\n", "            });\n"]}, "removed": {"1": [" * Licensed under the Apache License, Version 2.0 (the \"License\");\n", " * you may not use this file except in compliance with the License.\n", " * You may obtain a copy of the License at\n", " * Unless required by applicable law or agreed to in writing, software\n", " * distributed under the License is distributed on an \"AS IS\" BASIS,\n", " * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n", " * See the License for the specific language governing permissions and\n", " * limitations under the License.\n"], "2": [" * Utilities necessary for working with libraries that supply plain {@link\n", " * Future} instances. Note that, whenver possible, it is strongly preferred to\n", " * modify those libraries to return {@code ListenableFuture} directly.\n", " * @since 10.0 (replacing {@code Futures.makeListenable}, which\n", " *     existed in 1.0)\n", "   * Assigns a thread to the given {@link Future} to provide {@link\n", "   * ListenableFuture} functionality.\n", "   * <p><b>Warning:</b> If the input future does not already implement {@code\n", "   * ListenableFuture}, the returned future will emulate {@link\n", "   * ListenableFuture#addListener} by taking a thread from an internal,\n", "   * unbounded pool at the first call to {@code addListener} and holding it\n", "   * until the future is {@linkplain Future#isDone() done}.\n", "   * <p>Prefer to create {@code ListenableFuture} instances with {@link\n", "   * SettableFuture}, {@link MoreExecutors#listeningDecorator(\n", "   * java.util.concurrent.ExecutorService)}, {@link ListenableFutureTask},\n", "   * {@link AbstractFuture}, and other utilities over creating plain {@code\n", "   * Future} instances to be upgraded to {@code ListenableFuture} after the\n", "   * fact.\n", "  public static <V> ListenableFuture<V> listenInPoolThread(\n", "      Future<V> future) {\n"], "3": ["   * Submits a blocking task for the given {@link Future} to provide {@link\n", "   * ListenableFuture} functionality.\n", "   * <p><b>Warning:</b> If the input future does not already implement {@code\n", "   * ListenableFuture}, the returned future will emulate {@link\n", "   * ListenableFuture#addListener} by submitting a task to the given executor at\n", "   * the first call to {@code addListener}. The task must be started by the\n", "   * executor promptly, or else the returned {@code ListenableFuture} may fail\n", "   * to work.  The task's execution consists of blocking until the input future\n", "   * is {@linkplain Future#isDone() done}, so each call to this method may\n", "   * claim and hold a thread for an arbitrary length of time. Use of bounded\n", "   * executors or other executors that may fail to execute a task promptly may\n", "   * result in deadlocks.\n", "   * <p>Prefer to create {@code ListenableFuture} instances with {@link\n", "   * SettableFuture}, {@link MoreExecutors#listeningDecorator(\n", "   * java.util.concurrent.ExecutorService)}, {@link ListenableFutureTask},\n", "   * {@link AbstractFuture}, and other utilities over creating plain {@code\n", "   * Future} instances to be upgraded to {@code ListenableFuture} after the\n", "   * fact.\n", "  public static <V> ListenableFuture<V> listenInPoolThread(\n", "      Future<V> future, Executor executor) {\n"], "4": ["   * An adapter to turn a {@link Future} into a {@link ListenableFuture}.  This\n", "   * will wait on the future to finish, and when it completes, run the\n", "   * listeners.  This implementation will wait on the source future\n", "   * indefinitely, so if the source future never completes, the adapter will\n", "   * never complete either.\n", "   * <p>If the delegate future is interrupted or throws an unexpected unchecked\n", "   * exception, the listeners will not be invoked.\n"], "5": ["    // This allows us to only start up a thread waiting on the delegate future\n", "    // when the first listener is added.\n"], "6": ["      // When a listener is first added, we run a task that will wait for\n", "      // the delegate to finish, and when it is done will run the listeners.\n", "          // If the delegate is already done, run the execution list\n", "          // immediately on the current thread.\n", "        adapterExecutor.execute(new Runnable() {\n", "          @Override\n", "          public void run() {\n", "            try {\n", "              /*\n", "               * Threads from our private pool are never interrupted. Threads\n", "               * from a user-supplied executor might be, but... what can we do?\n", "               * This is another reason to return a proper ListenableFuture\n", "               * instead of using listenInPoolThread.\n", "               */\n", "              getUninterruptibly(delegate);\n", "            } catch (Throwable e) {\n", "              // ExecutionException / CancellationException / RuntimeException / Error\n", "              // The task is presumably done, run the listeners.\n", "            }\n", "            executionList.execute();\n", "          }\n", "        });\n"]}, "added_lines": {"1": [4, 5, 9, 10, 11, 12], "2": [29, 30, 31, 34, 39, 41, 42, 43, 44, 46, 47, 48, 49, 51], "3": [59, 60, 62, 63, 64, 65, 66, 67, 68, 69, 71, 72, 73, 74, 78], "4": [87, 88, 89, 90, 92, 93], "5": [111, 112], "6": [136, 137, 140, 141, 147, 148, 149, 150, 151, 152, 153, 154, 155, 156, 157, 158, 159, 160, 161, 162, 163, 164]}, "removed_lines": {"1": [4, 5, 6, 10, 11, 12, 13, 14], "2": [31, 32, 33, 36, 37, 42, 43, 45, 46, 47, 48, 49, 51, 52, 53, 54, 55, 56, 58, 59], "3": [67, 68, 70, 71, 72, 73, 74, 75, 76, 77, 78, 79, 81, 82, 83, 84, 85, 86, 90, 91], "4": [100, 101, 102, 103, 104, 106, 107], "5": [125, 126], "6": [150, 151, 154, 155, 161, 162, 163, 164, 165, 166, 167, 168, 169, 170, 171, 172, 173, 174, 175, 176, 177, 178]}}, {"34": "guava/src/com/google/common/util/concurrent/ListenableFuture.java", "added": {"1": [" * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not use this file except\n", " * in compliance with the License. You may obtain a copy of the License at\n", " * Unless required by applicable law or agreed to in writing, software distributed under the License\n", " * is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express\n", " * or implied. See the License for the specific language governing permissions and limitations under\n", " * the License.\n"], "2": [" * A {@link Future} that accepts completion listeners.  Each listener has an associated executor,\n", " * and it is invoked using this executor once the future's computation is {@linkplain\n", " * Future#isDone() complete}.  If the computation has already completed when the listener is added,\n", " * the listener will execute immediately.\n", " * \"https://github.com/google/guava/wiki/ListenableFutureExplained\"> {@code ListenableFuture}</a>.\n", " * <p>Most commonly, {@code ListenableFuture} is used as an input to another derived {@code Future},\n", " * as in {@link Futures#allAsList(Iterable) Futures.allAsList}. Many such methods are impossible to\n", " * implement efficiently without listener support.\n", " * <p>It is possible to call {@link #addListener addListener} directly, but this is uncommon because\n", " * the {@code Runnable} interface does not provide direct access to the {@code Future} result.\n", " * (Users who want such access may prefer {@link Futures#addCallback Futures.addCallback}.) Still,\n", " * direct {@code addListener} calls are occasionally useful:<pre>   {@code\n"], "3": [" * <p>Developers are encouraged to return {@code ListenableFuture} from their methods so that users\n", " * can take advantages of the {@linkplain Futures utilities built atop the class}. The way that they\n", " * will create {@code ListenableFuture} instances depends on how they currently create {@code\n", " * Future} instances: <ul> <li>If they are returned from an {@code ExecutorService}, convert that\n", " * MoreExecutors#listeningDecorator(ExecutorService) MoreExecutors.listeningDecorator}. (Custom\n", " * executors may find it more convenient to use {@link ListenableFutureTask} directly.) <li>If they\n", " * are manually filled in by a call to {@link FutureTask#set} or a similar method, create a {@link\n", " * SettableFuture} instead. (Users with more complex needs may prefer {@link AbstractFuture}.) </ul>\n", " * <p>Occasionally, an API will return a plain {@code Future} and it will be impossible to change\n", " * the return type. For this case, we provide a more expensive workaround in {@code\n", " * JdkFutureAdapters}. However, when possible, it is more efficient and reliable to create a {@code\n", " * ListenableFuture} directly.\n"], "4": ["   * Registers a listener to be {@linkplain Executor#execute(Runnable) run} on the given executor.\n", "   * The listener will run when the {@code Future}'s computation is {@linkplain Future#isDone()\n", "   * complete} or, if the computation is already complete, immediately.\n", "   * <p>There is no guaranteed ordering of execution of listeners, but any listener added through\n", "   * this method is guaranteed to be called once the computation is complete.\n", "   * <p>Exceptions thrown by a listener will be propagated up to the executor. Any exception thrown\n", "   * during {@code Executor.execute} (e.g., a {@code RejectedExecutionException} or an exception\n", "   * thrown by {@linkplain MoreExecutors#directExecutor direct execution}) will be caught and\n", "   * <p>Note: For fast, lightweight listeners that would be safe to execute in any thread, consider\n", "   * {@link MoreExecutors#directExecutor}. Otherwise, avoid it. Heavyweight {@code directExecutor}\n", "   * listeners can cause problems, and these problems can be difficult to reproduce because they\n", "   * depend on timing. For example:\n", "   * <li>The listener may be executed by the caller of {@code addListener}. That caller may be a UI\n", "   * thread or other latency-sensitive thread. This can harm UI responsiveness.\n", "   * <li>The listener may be executed by the thread that completes this {@code Future}. That thread\n", "   * may be an internal system thread such as an RPC network thread. Blocking that thread may stall\n", "   * progress of the whole system. It may even cause a deadlock.\n", "   * <li>The listener may delay other listeners, even listeners that are not themselves {@code\n", "   * directExecutor} listeners.\n", "   * <p>This is the most general listener interface. For common operations performed using\n", "   * listeners, see {@link Futures}. For a simplified but general listener interface, see {@link\n", "   * Futures#addCallback addCallback()}.\n", "   * <p>Memory consistency effects: Actions in a thread prior to adding a listener <a\n", "   * href=\"https://docs.oracle.com/javase/specs/jls/se7/html/jls-17.html#jls-17.4.5\">\n", "   * @throws RejectedExecutionException if we tried to execute the listener immediately but the\n", "   *     executor rejected it.\n"]}, "removed": {"1": [" * Licensed under the Apache License, Version 2.0 (the \"License\");\n", " * you may not use this file except in compliance with the License.\n", " * You may obtain a copy of the License at\n", " * Unless required by applicable law or agreed to in writing, software\n", " * distributed under the License is distributed on an \"AS IS\" BASIS,\n", " * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n", " * See the License for the specific language governing permissions and\n", " * limitations under the License.\n"], "2": [" * A {@link Future} that accepts completion listeners.  Each listener has an\n", " * associated executor, and it is invoked using this executor once the future's\n", " * computation is {@linkplain Future#isDone() complete}.  If the computation has\n", " * already completed when the listener is added, the listener will execute\n", " * immediately.\n", " * \"https://github.com/google/guava/wiki/ListenableFutureExplained\">\n", " * {@code ListenableFuture}</a>.\n", " * <p>Most commonly, {@code ListenableFuture} is used as an input to another\n", " * derived {@code Future}, as in {@link Futures#allAsList(Iterable)\n", " * Futures.allAsList}. Many such methods are impossible to implement efficiently\n", " * without listener support.\n", " * <p>It is possible to call {@link #addListener addListener} directly, but this\n", " * is uncommon because the {@code Runnable} interface does not provide direct\n", " * access to the {@code Future} result. (Users who want such access may prefer\n", " * {@link Futures#addCallback Futures.addCallback}.) Still, direct {@code\n", " * addListener} calls are occasionally useful:<pre>   {@code\n"], "3": [" * <p>Developers are encouraged to return {@code ListenableFuture} from their\n", " * methods so that users can take advantages of the {@linkplain Futures\n", " * utilities built atop the class}. The way that they will create {@code\n", " * ListenableFuture} instances depends on how they currently create {@code\n", " * Future} instances:\n", " * <ul>\n", " * <li>If they are returned from an {@code ExecutorService}, convert that\n", " * MoreExecutors#listeningDecorator(ExecutorService)\n", " * MoreExecutors.listeningDecorator}. (Custom executors may find it more\n", " * convenient to use {@link ListenableFutureTask} directly.)\n", " * <li>If they are manually filled in by a call to {@link FutureTask#set} or a\n", " * similar method, create a {@link SettableFuture} instead. (Users with more\n", " * complex needs may prefer {@link AbstractFuture}.)\n", " * </ul>\n", " * <p>Occasionally, an API will return a plain {@code Future} and it will be\n", " * impossible to change the return type. For this case, we provide a more\n", " * expensive workaround in {@code JdkFutureAdapters}. However, when possible, it\n", " * is more efficient and reliable to create a {@code ListenableFuture} directly.\n"], "4": ["   * Registers a listener to be {@linkplain Executor#execute(Runnable) run} on\n", "   * the given executor.  The listener will run when the {@code Future}'s\n", "   * computation is {@linkplain Future#isDone() complete} or, if the computation\n", "   * is already complete, immediately.\n", "   * <p>There is no guaranteed ordering of execution of listeners, but any\n", "   * listener added through this method is guaranteed to be called once the\n", "   * computation is complete.\n", "   * <p>Exceptions thrown by a listener will be propagated up to the executor.\n", "   * Any exception thrown during {@code Executor.execute} (e.g., a {@code\n", "   * RejectedExecutionException} or an exception thrown by {@linkplain\n", "   * MoreExecutors#directExecutor direct execution}) will be caught and\n", "   * <p>Note: For fast, lightweight listeners that would be safe to execute in\n", "   * any thread, consider {@link MoreExecutors#directExecutor}. Otherwise, avoid\n", "   * it. Heavyweight {@code directExecutor} listeners can cause problems, and\n", "   * these problems can be difficult to reproduce because they depend on timing.\n", "   * For example:\n", "   * <li>The listener may be executed by the caller of {@code addListener}. That\n", "   * caller may be a UI thread or other latency-sensitive thread. This can harm\n", "   * UI responsiveness.\n", "   * <li>The listener may be executed by the thread that completes this {@code\n", "   * Future}. That thread may be an internal system thread such as an RPC\n", "   * network thread. Blocking that thread may stall progress of the whole\n", "   * system. It may even cause a deadlock.\n", "   * <li>The listener may delay other listeners, even listeners that are not\n", "   * themselves {@code directExecutor} listeners.\n", "   * <p>This is the most general listener interface. For common operations\n", "   * performed using listeners, see {@link Futures}. For a simplified but\n", "   * general listener interface, see {@link Futures#addCallback addCallback()}.\n", "   * <p>Memory consistency effects: Actions in a thread prior to adding a listener\n", "   * <a href=\"https://docs.oracle.com/javase/specs/jls/se7/html/jls-17.html#jls-17.4.5\">\n", "   * @throws NullPointerException if the executor or listener was null\n", "   * @throws RejectedExecutionException if we tried to execute the listener\n", "   *         immediately but the executor rejected it.\n"]}, "added_lines": {"1": [4, 5, 9, 10, 11, 12], "2": [26, 27, 28, 29, 32, 36, 37, 38, 40, 41, 42, 43], "3": [58, 59, 60, 61, 63, 64, 65, 66, 68, 69, 70, 71], "4": [80, 81, 82, 84, 85, 87, 88, 89, 92, 93, 94, 95, 98, 99, 100, 101, 102, 103, 104, 107, 108, 109, 111, 112, 117, 118]}, "removed_lines": {"1": [4, 5, 6, 10, 11, 12, 13, 14], "2": [28, 29, 30, 31, 32, 35, 36, 40, 41, 42, 43, 45, 46, 47, 48, 49], "3": [64, 65, 66, 67, 68, 69, 70, 72, 73, 74, 75, 76, 77, 78, 80, 81, 82, 83], "4": [92, 93, 94, 95, 97, 98, 99, 101, 102, 103, 104, 107, 108, 109, 110, 111, 114, 115, 116, 117, 118, 119, 120, 121, 122, 125, 126, 127, 129, 130, 135, 136, 137]}}, {"35": "guava/src/com/google/common/util/concurrent/ListenableFutureTask.java", "added": {"1": [" * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not use this file except\n", " * in compliance with the License. You may obtain a copy of the License at\n", " * Unless required by applicable law or agreed to in writing, software distributed under the License\n", " * is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express\n", " * or implied. See the License for the specific language governing permissions and limitations under\n", " * the License.\n"], "2": [" * A {@link FutureTask} that also implements the {@link ListenableFuture} interface.  Unlike {@code\n", " * FutureTask}, {@code ListenableFutureTask} does not provide an overrideable {@link\n", " * FutureTask#done() done()} method.  For similar functionality, call {@link #addListener}.\n", "public class ListenableFutureTask<V> extends FutureTask<V> implements ListenableFuture<V> {\n", "  // TODO(cpovirk): explore ways of making ListenableFutureTask final. There are some valid reasons\n", "  // such as BoundedQueueExecutorService to allow extends but it would be nice to make it final to\n", "  // avoid unintended usage.\n", "   * Creates a {@code ListenableFutureTask} that will upon running, execute the given {@code\n", "   * Callable}.\n"], "3": ["   * Creates a {@code ListenableFutureTask} that will upon running, execute the given {@code\n", "   * Runnable}, and arrange that {@code get} will return the given result on successful completion.\n", "   * @param result the result to return on successful completion. If you don't need a particular\n", "   *     result, consider using constructions of the form: {@code ListenableFuture<?> f =\n", "   *     ListenableFutureTask.create(runnable, null)}\n", "  public static <V> ListenableFutureTask<V> create(Runnable runnable, @Nullable V result) {\n"]}, "removed": {"1": [" * Licensed under the Apache License, Version 2.0 (the \"License\");\n", " * you may not use this file except in compliance with the License.\n", " * You may obtain a copy of the License at\n", " * Unless required by applicable law or agreed to in writing, software\n", " * distributed under the License is distributed on an \"AS IS\" BASIS,\n", " * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n", " * See the License for the specific language governing permissions and\n", " * limitations under the License.\n"], "2": [" * A {@link FutureTask} that also implements the {@link ListenableFuture}\n", " * interface.  Unlike {@code FutureTask}, {@code ListenableFutureTask} does not\n", " * provide an overrideable {@link FutureTask#done() done()} method.  For similar\n", " * functionality, call {@link #addListener}.\n", "public class ListenableFutureTask<V> extends FutureTask<V>\n", "    implements ListenableFuture<V> {\n", "  // TODO(cpovirk): explore ways of making ListenableFutureTask final. There are\n", "  // some valid reasons such as BoundedQueueExecutorService to allow extends but it\n", "  // would be nice to make it final to avoid unintended usage.\n", "   * Creates a {@code ListenableFutureTask} that will upon running, execute the\n", "   * given {@code Callable}.\n"], "3": ["   * Creates a {@code ListenableFutureTask} that will upon running, execute the\n", "   * given {@code Runnable}, and arrange that {@code get} will return the\n", "   * given result on successful completion.\n", "   * @param result the result to return on successful completion. If you don't\n", "   *     need a particular result, consider using constructions of the form:\n", "   *     {@code ListenableFuture<?> f = ListenableFutureTask.create(runnable,\n", "   *     null)}\n", "  public static <V> ListenableFutureTask<V> create(\n", "      Runnable runnable, @Nullable V result) {\n"]}, "added_lines": {"1": [4, 5, 9, 10, 11, 12], "2": [24, 25, 26, 33, 34, 35, 36, 42, 43], "3": [53, 54, 57, 58, 59, 62]}, "removed_lines": {"1": [4, 5, 6, 10, 11, 12, 13, 14], "2": [26, 27, 28, 29, 36, 37, 38, 39, 40, 46, 47], "3": [57, 58, 59, 62, 63, 64, 65, 68, 69]}}, {"36": "guava/src/com/google/common/util/concurrent/ListenableScheduledFuture.java", "added": {"1": [" * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not use this file except\n", " * in compliance with the License. You may obtain a copy of the License at\n", " * Unless required by applicable law or agreed to in writing, software distributed under the License\n", " * is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express\n", " * or implied. See the License for the specific language governing permissions and limitations under\n", " * the License.\n"], "2": [" * Helper interface to implement both {@link ListenableFuture} and {@link ScheduledFuture}.\n", "public interface ListenableScheduledFuture<V> extends ScheduledFuture<V>, ListenableFuture<V> {}\n"]}, "removed": {"1": [" * Licensed under the Apache License, Version 2.0 (the \"License\");\n", " * you may not use this file except in compliance with the License.\n", " * You may obtain a copy of the License at\n", " * Unless required by applicable law or agreed to in writing, software\n", " * distributed under the License is distributed on an \"AS IS\" BASIS,\n", " * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n", " * See the License for the specific language governing permissions and\n", " * limitations under the License.\n"], "2": [" * Helper interface to implement both {@link ListenableFuture} and\n", " * {@link ScheduledFuture}.\n", "public interface ListenableScheduledFuture<V>\n", "    extends ScheduledFuture<V>, ListenableFuture<V> {}\n"]}, "added_lines": {"1": [4, 5, 9, 10, 11, 12], "2": [22, 29]}, "removed_lines": {"1": [4, 5, 6, 10, 11, 12, 13, 14], "2": [24, 25, 32, 33]}}, {"37": "guava/src/com/google/common/util/concurrent/ListenerCallQueue.java", "added": {"1": [" * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not use this file except\n", " * in compliance with the License. You may obtain a copy of the License at\n", " * Unless required by applicable law or agreed to in writing, software distributed under the License\n", " * is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express\n", " * or implied. See the License for the specific language governing permissions and limitations under\n", " * the License.\n"], "2": [" * executor. Each callback task can be enqueued and executed as separate phases.\n", " * <p>This class is very similar to {@link SerializingExecutor} with the exception that tasks can be\n", " * enqueued without necessarily executing immediately.\n"], "3": ["  @GuardedBy(\"this\")\n", "  private final Queue<Callback<L>> waitQueue = Queues.newArrayDeque();\n", "\n", "  @GuardedBy(\"this\")\n", "  private boolean isThreadScheduled;\n"], "4": ["        logger.log(\n", "            Level.SEVERE,\n"], "5": ["  @Override\n", "  public void run() {\n"], "6": ["          logger.log(\n", "              Level.SEVERE,\n", "        // An Error is bubbling up. We should mark ourselves as no longer running. That way, if\n", "        // anyone tries to keep using us, we won't be corrupted.\n"]}, "removed": {"1": [" * Licensed under the Apache License, Version 2.0 (the \"License\");\n", " * you may not use this file except in compliance with the License.\n", " * You may obtain a copy of the License at\n", " * Unless required by applicable law or agreed to in writing, software\n", " * distributed under the License is distributed on an \"AS IS\" BASIS,\n", " * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n", " * See the License for the specific language governing permissions and\n", " * limitations under the License.\n"], "2": [" * executor.  Each callback task can be enqueued and executed as separate phases.\n", " * <p>This class is very similar to {@link SerializingExecutor} with the exception that tasks can\n", " * be enqueued without necessarily executing immediately.\n"], "3": ["  @GuardedBy(\"this\") private final Queue<Callback<L>> waitQueue = Queues.newArrayDeque();\n", "  @GuardedBy(\"this\") private boolean isThreadScheduled;\n"], "4": ["        logger.log(Level.SEVERE,\n"], "5": ["  @Override public void run() {\n"], "6": ["          logger.log(Level.SEVERE, \n", "        // An Error is bubbling up, we should mark ourselves as no longer\n", "        // running, that way if anyone tries to keep using us we won't be\n", "        // corrupted.\n"]}, "added_lines": {"1": [4, 5, 9, 10, 11, 12], "2": [31, 33, 34], "3": [60, 61, 62, 63, 64], "4": [94, 95], "5": [103, 104], "6": [124, 125, 132, 133]}, "removed_lines": {"1": [4, 5, 6, 10, 11, 12, 13, 14], "2": [33, 35, 36], "3": [62, 63], "4": [93], "5": [101], "6": [121, 128, 129, 130]}}, {"38": "guava/src/com/google/common/util/concurrent/ListeningExecutorService.java", "added": {"1": [" * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not use this file except\n", " * in compliance with the License. You may obtain a copy of the License at\n", " * Unless required by applicable law or agreed to in writing, software distributed under the License\n", " * is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express\n", " * or implied. See the License for the specific language governing permissions and limitations under\n", " * the License.\n"], "2": [" * from an existing {@link ExecutorService}, call {@link\n", " * MoreExecutors#listeningDecorator(ExecutorService)}.\n"], "3": ["   *     sequential order as produced by the iterator for the given task list, each of which has\n", "   *     completed.\n"], "4": ["   *     sequential order as produced by the iterator for the given task list. If the operation did\n", "   *     not time out, each task will have completed. If it did time out, some of these tasks will\n", "   *     not have completed.\n"]}, "removed": {"1": [" * Licensed under the Apache License, Version 2.0 (the \"License\");\n", " * you may not use this file except in compliance with the License.\n", " * You may obtain a copy of the License at\n", " * Unless required by applicable law or agreed to in writing, software\n", " * distributed under the License is distributed on an \"AS IS\" BASIS,\n", " * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n", " * See the License for the specific language governing permissions and\n", " * limitations under the License.\n"], "2": [" * from an existing {@link ExecutorService}, call\n", " * {@link MoreExecutors#listeningDecorator(ExecutorService)}.\n"], "3": ["   *         sequential order as produced by the iterator for the given task list, each of which has\n", "   *         completed.\n"], "4": ["   *         sequential order as produced by the iterator for the given task list. If the operation\n", "   *         did not time out, each task will have completed. If it did time out, some of these\n", "   *         tasks will not have completed.\n"]}, "added_lines": {"1": [4, 5, 9, 10, 11, 12], "2": [27, 28], "3": [66, 67], "4": [86, 87, 88]}, "removed_lines": {"1": [4, 5, 6, 10, 11, 12, 13, 14], "2": [29, 30], "3": [68, 69], "4": [88, 89, 90]}}, {"39": "guava/src/com/google/common/util/concurrent/ListeningScheduledExecutorService.java", "added": {"1": [" * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not use this file except\n", " * in compliance with the License. You may obtain a copy of the License at\n", " * Unless required by applicable law or agreed to in writing, software distributed under the License\n", " * is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express\n", " * or implied. See the License for the specific language governing permissions and limitations under\n", " * the License.\n"], "2": [" * A {@link ScheduledExecutorService} that returns {@link ListenableFuture} instances from its\n", " * {@code ExecutorService} methods. To create an instance from an existing {@link\n", " * ScheduledExecutorService}, call {@link\n", " * MoreExecutors#listeningDecorator(ScheduledExecutorService)}.\n"], "3": ["  ListenableScheduledFuture<?> schedule(Runnable command, long delay, TimeUnit unit);\n", "  <V> ListenableScheduledFuture<V> schedule(Callable<V> callable, long delay, TimeUnit unit);\n"]}, "removed": {"1": [" * Licensed under the Apache License, Version 2.0 (the \"License\");\n", " * you may not use this file except in compliance with the License.\n", " * You may obtain a copy of the License at\n", " * Unless required by applicable law or agreed to in writing, software\n", " * distributed under the License is distributed on an \"AS IS\" BASIS,\n", " * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n", " * See the License for the specific language governing permissions and\n", " * limitations under the License.\n"], "2": [" * A {@link ScheduledExecutorService} that returns {@link ListenableFuture}\n", " * instances from its {@code ExecutorService} methods. To create an instance\n", " * from an existing {@link ScheduledExecutorService}, call\n", " * {@link MoreExecutors#listeningDecorator(ScheduledExecutorService)}.\n"], "3": ["  ListenableScheduledFuture<?> schedule(\n", "      Runnable command, long delay, TimeUnit unit);\n", "  <V> ListenableScheduledFuture<V> schedule(\n", "      Callable<V> callable, long delay, TimeUnit unit);\n"]}, "added_lines": {"1": [4, 5, 9, 10, 11, 12], "2": [24, 25, 26, 27], "3": [38, 42]}, "removed_lines": {"1": [4, 5, 6, 10, 11, 12, 13, 14], "2": [26, 27, 28, 29], "3": [40, 41, 45, 46]}}, {"40": "guava/src/com/google/common/util/concurrent/Monitor.java", "added": {"1": [" * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not use this file except\n", " * in compliance with the License. You may obtain a copy of the License at\n", " * Unless required by applicable law or agreed to in writing, software distributed under the License\n", " * is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express\n", " * or implied. See the License for the specific language governing permissions and limitations under\n", " * the License.\n"], "2": [" * evaluation and signaling of conditions. Signaling is entirely <a\n", " * href=\"http://en.wikipedia.org/wiki/Monitor_(synchronization)#Implicit_signaling\">implicit</a>.\n", " * By eliminating explicit signaling, this class can guarantee that only one thread is awakened when\n", " * a condition becomes true (no \"signaling storms\" due to use of {@link\n"], "3": [" * <p>A call to any of the <i>enter</i> methods with <b>boolean</b> return type should always appear\n", " * as the condition of an <i>if</i> statement containing a <i>try/finally</i> block to ensure that\n", " * the current thread leaves the monitor cleanly: <pre>   {@code\n"], "4": ["      for (long remainingNanos = timeoutNanos; ; ) {\n"], "5": ["    locked:\n", "    {\n"], "6": ["      satisfied =\n", "          guard.isSatisfied()\n", "              || awaitNanos(\n", "                  guard,\n", "                  (startTime == 0L) ? timeoutNanos : remainingNanos(startTime, timeoutNanos),\n", "                  reentrant);\n"], "7": ["        for (long remainingNanos = timeoutNanos; ; ) {\n"], "8": ["          lock.unlock(); // No need to signal if timed out\n"], "9": ["      for (long remainingNanos = timeoutNanos; ; ) {\n"], "10": ["      lock.unlock(); // Will throw IllegalMonitorStateException if not held\n"], "11": ["    return (timeoutNanos <= 0L)\n", "        ? 0L\n", "        : (timeoutNanos > (Long.MAX_VALUE / 4) * 3) ? (Long.MAX_VALUE / 4) * 3 : timeoutNanos;\n"], "12": ["      for (Guard p = activeGuards, pred = null; ; pred = p, p = p.next) {\n", "          p.next = null; // help GC\n"], "13": ["  private void await(Guard guard, boolean signalBeforeWaiting) throws InterruptedException {\n"]}, "removed": {"1": [" * Licensed under the Apache License, Version 2.0 (the \"License\");\n", " * you may not use this file except in compliance with the License.\n", " * You may obtain a copy of the License at\n", " * Unless required by applicable law or agreed to in writing, software\n", " * distributed under the License is distributed on an \"AS IS\" BASIS,\n", " * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n", " * See the License for the specific language governing permissions and\n", " * limitations under the License.\n"], "2": [" * evaluation and signaling of conditions.  Signaling is entirely\n", " * <a href=\"http://en.wikipedia.org/wiki/Monitor_(synchronization)#Implicit_signaling\">\n", " * implicit</a>.\n", " * By eliminating explicit signaling, this class can guarantee that only one thread is awakened\n", " * when a condition becomes true (no \"signaling storms\" due to use of {@link\n"], "3": [" * <p>A call to any of the <i>enter</i> methods with <b>boolean</b> return type should always\n", " * appear as the condition of an <i>if</i> statement containing a <i>try/finally</i> block to\n", " * ensure that the current thread leaves the monitor cleanly: <pre>   {@code\n"], "4": ["      for (long remainingNanos = timeoutNanos;;) {\n"], "5": [" locked: {\n"], "6": ["      satisfied = guard.isSatisfied()\n", "          || awaitNanos(guard,\n", "                        (startTime == 0L)\n", "                            ? timeoutNanos\n", "                            : remainingNanos(startTime, timeoutNanos),\n", "                        reentrant);\n"], "7": ["        for (long remainingNanos = timeoutNanos;;) {\n"], "8": ["          lock.unlock();  // No need to signal if timed out\n"], "9": ["      for (long remainingNanos = timeoutNanos;;) {\n"], "10": ["      lock.unlock();  // Will throw IllegalMonitorStateException if not held\n"], "11": ["    return (timeoutNanos <= 0L) ? 0L\n", "        : (timeoutNanos > (Long.MAX_VALUE / 4) * 3) ? (Long.MAX_VALUE / 4) * 3\n", "        : timeoutNanos;\n"], "12": ["      for (Guard p = activeGuards, pred = null;; pred = p, p = p.next) {\n", "          p.next = null;  // help GC\n"], "13": ["  private void await(Guard guard, boolean signalBeforeWaiting)\n", "      throws InterruptedException {\n"]}, "added_lines": {"1": [4, 5, 9, 10, 11, 12], "2": [35, 36, 37, 38], "3": [60, 61, 62], "4": [393], "5": [496, 497], "6": [516, 517, 518, 519, 520, 521], "7": [556], "8": [594], "9": [795], "10": [825], "11": [925, 926, 927], "12": [1055, 1062], "13": [1076]}, "removed_lines": {"1": [4, 5, 6, 10, 11, 12, 13, 14], "2": [37, 38, 39, 40, 41], "3": [63, 64, 65], "4": [397], "5": [500], "6": [519, 520, 521, 522, 523, 524], "7": [559], "8": [597], "9": [798], "10": [828], "11": [928, 929, 930], "12": [1058, 1065], "13": [1079, 1080]}}]}
