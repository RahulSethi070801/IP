{
    "addition": {
        "4": " * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not use this file except\n",
        "5": " * in compliance with the License. You may obtain a copy of the License at\n",
        "9": " * Unless required by applicable law or agreed to in writing, software distributed under the License\n",
        "10": " * is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express\n",
        "11": " * or implied. See the License for the specific language governing permissions and limitations under\n",
        "12": " * the License.\n",
        "35": " * evaluation and signaling of conditions. Signaling is entirely <a\n",
        "36": " * href=\"http://en.wikipedia.org/wiki/Monitor_(synchronization)#Implicit_signaling\">implicit</a>.\n",
        "37": " * By eliminating explicit signaling, this class can guarantee that only one thread is awakened when\n",
        "38": " * a condition becomes true (no \"signaling storms\" due to use of {@link\n",
        "60": " * <p>A call to any of the <i>enter</i> methods with <b>boolean</b> return type should always appear\n",
        "61": " * as the condition of an <i>if</i> statement containing a <i>try/finally</i> block to ensure that\n",
        "62": " * the current thread leaves the monitor cleanly: <pre>   {@code\n",
        "393": "      for (long remainingNanos = timeoutNanos; ; ) {\n",
        "496": "    locked:\n",
        "497": "    {\n",
        "516": "      satisfied =\n",
        "517": "          guard.isSatisfied()\n",
        "518": "              || awaitNanos(\n",
        "519": "                  guard,\n",
        "520": "                  (startTime == 0L) ? timeoutNanos : remainingNanos(startTime, timeoutNanos),\n",
        "521": "                  reentrant);\n",
        "556": "        for (long remainingNanos = timeoutNanos; ; ) {\n",
        "594": "          lock.unlock(); // No need to signal if timed out\n",
        "795": "      for (long remainingNanos = timeoutNanos; ; ) {\n",
        "825": "      lock.unlock(); // Will throw IllegalMonitorStateException if not held\n",
        "925": "    return (timeoutNanos <= 0L)\n",
        "926": "        ? 0L\n",
        "927": "        : (timeoutNanos > (Long.MAX_VALUE / 4) * 3) ? (Long.MAX_VALUE / 4) * 3 : timeoutNanos;\n",
        "1055": "      for (Guard p = activeGuards, pred = null; ; pred = p, p = p.next) {\n",
        "1062": "          p.next = null; // help GC\n",
        "1076": "  private void await(Guard guard, boolean signalBeforeWaiting) throws InterruptedException {\n"
    },
    "removed": {
        "4": " * Licensed under the Apache License, Version 2.0 (the \"License\");\n",
        "5": " * you may not use this file except in compliance with the License.\n",
        "6": " * You may obtain a copy of the License at\n",
        "10": " * Unless required by applicable law or agreed to in writing, software\n",
        "11": " * distributed under the License is distributed on an \"AS IS\" BASIS,\n",
        "12": " * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n",
        "13": " * See the License for the specific language governing permissions and\n",
        "14": " * limitations under the License.\n",
        "37": " * evaluation and signaling of conditions.  Signaling is entirely\n",
        "38": " * <a href=\"http://en.wikipedia.org/wiki/Monitor_(synchronization)#Implicit_signaling\">\n",
        "39": " * implicit</a>.\n",
        "40": " * By eliminating explicit signaling, this class can guarantee that only one thread is awakened\n",
        "41": " * when a condition becomes true (no \"signaling storms\" due to use of {@link\n",
        "63": " * <p>A call to any of the <i>enter</i> methods with <b>boolean</b> return type should always\n",
        "64": " * appear as the condition of an <i>if</i> statement containing a <i>try/finally</i> block to\n",
        "65": " * ensure that the current thread leaves the monitor cleanly: <pre>   {@code\n",
        "397": "      for (long remainingNanos = timeoutNanos;;) {\n",
        "500": " locked: {\n",
        "519": "      satisfied = guard.isSatisfied()\n",
        "520": "          || awaitNanos(guard,\n",
        "521": "                        (startTime == 0L)\n",
        "522": "                            ? timeoutNanos\n",
        "523": "                            : remainingNanos(startTime, timeoutNanos),\n",
        "524": "                        reentrant);\n",
        "559": "        for (long remainingNanos = timeoutNanos;;) {\n",
        "597": "          lock.unlock();  // No need to signal if timed out\n",
        "798": "      for (long remainingNanos = timeoutNanos;;) {\n",
        "828": "      lock.unlock();  // Will throw IllegalMonitorStateException if not held\n",
        "928": "    return (timeoutNanos <= 0L) ? 0L\n",
        "929": "        : (timeoutNanos > (Long.MAX_VALUE / 4) * 3) ? (Long.MAX_VALUE / 4) * 3\n",
        "930": "        : timeoutNanos;\n",
        "1058": "      for (Guard p = activeGuards, pred = null;; pred = p, p = p.next) {\n",
        "1065": "          p.next = null;  // help GC\n",
        "1079": "  private void await(Guard guard, boolean signalBeforeWaiting)\n",
        "1080": "      throws InterruptedException {\n"
    }
}