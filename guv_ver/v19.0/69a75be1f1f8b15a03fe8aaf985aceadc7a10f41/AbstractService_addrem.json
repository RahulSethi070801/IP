{
    "addition": {
        "4": " * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not use this file except\n",
        "5": " * in compliance with the License. You may obtain a copy of the License at\n",
        "9": " * Unless required by applicable law or agreed to in writing, software distributed under the License\n",
        "10": " * is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express\n",
        "11": " * or implied. See the License for the specific language governing permissions and limitations under\n",
        "12": " * the License.\n",
        "47": " * callbacks. Its subclasses must manage threads manually; consider {@link\n",
        "48": " * AbstractExecutionThreadService} if you need only a single execution thread.\n",
        "58": "        @Override\n",
        "59": "        void call(Listener listener) {\n",
        "65": "        @Override\n",
        "66": "        void call(Listener listener) {\n",
        "75": "  private static final Callback<Listener> TERMINATED_FROM_NEW_CALLBACK = terminatedCallback(NEW);\n",
        "83": "      @Override\n",
        "84": "      void call(Listener listener) {\n",
        "92": "      @Override\n",
        "93": "      void call(Listener listener) {\n",
        "109": "    @Override\n",
        "110": "    public boolean isSatisfied() {\n",
        "123": "    @Override\n",
        "124": "    public boolean isSatisfied() {\n",
        "137": "    @Override\n",
        "138": "    public boolean isSatisfied() {\n",
        "151": "    @Override\n",
        "152": "    public boolean isSatisfied() {\n",
        "165": "   * The current state of the service. This should be written with the lock held but can be read\n",
        "166": "   * without it because it is an immutable object in a volatile field. This is desirable so that\n",
        "182": "   * or after it has returned. If startup fails, the invocation should cause a call to {@link\n",
        "183": "   * #notifyFailed(Throwable)} instead.\n",
        "194": "   * returned. If shutdown fails, the invocation should cause a call to {@link\n",
        "195": "   * #notifyFailed(Throwable)} instead.\n",
        "197": "   * <p>This method should return promptly; prefer to do work on a different thread where it is\n",
        "203": "  @Override\n",
        "204": "  public final Service startAsync() {\n",
        "222": "  @Override\n",
        "223": "  public final Service stopAsync() {\n",
        "259": "  @Override\n",
        "260": "  public final void awaitRunning() {\n",
        "269": "  @Override\n",
        "270": "  public final void awaitRunning(long timeout, TimeUnit unit) throws TimeoutException {\n",
        "286": "  @Override\n",
        "287": "  public final void awaitTerminated() {\n",
        "296": "  @Override\n",
        "297": "  public final void awaitTerminated(long timeout, TimeUnit unit) throws TimeoutException {\n",
        "309": "      throw new TimeoutException(\n",
        "310": "          \"Timed out waiting for \"\n",
        "311": "              + this\n",
        "312": "              + \" to reach a terminal state. \"\n",
        "313": "              + \"Current state: \"\n",
        "314": "              + state());\n",
        "325": "        throw new IllegalStateException(\n",
        "326": "            \"Expected the service to be \" + expected + \", but the service has FAILED\",\n",
        "327": "            failureCause());\n",
        "329": "      throw new IllegalStateException(\n",
        "330": "          \"Expected the service to be \" + expected + \", but was \" + actual);\n",
        "346": "        IllegalStateException failure =\n",
        "347": "            new IllegalStateException(\n",
        "348": "                \"Cannot notifyStarted() when the service is \" + snapshot.state);\n",
        "372": "   * @throws IllegalStateException if the service is neither {@link State#STOPPING} nor {@link\n",
        "373": "   *     State#RUNNING}.\n",
        "382": "        IllegalStateException failure =\n",
        "383": "            new IllegalStateException(\"Cannot notifyStopped() when the service is \" + previous);\n",
        "463": "  @Override\n",
        "464": "  public String toString() {\n",
        "504": "    switch (from) {\n",
        "526": "      @Override\n",
        "527": "      void call(Listener listener) {\n",
        "556": "    @Nullable final Throwable failure;\n",
        "564": "      checkArgument(\n",
        "565": "          !shutdownWhenStartupFinishes || internalState == STARTING,\n",
        "568": "      checkArgument(\n",
        "569": "          !(failure != null ^ internalState == FAILED),\n",
        "571": "              + \"instead.\",\n",
        "572": "          internalState,\n",
        "573": "          failure);\n",
        "590": "      checkState(\n",
        "591": "          state == FAILED,\n",
        "592": "          \"failureCause() is only valid if the service has failed, service is %s\",\n",
        "593": "          state);\n"
    },
    "removed": {
        "4": " * Licensed under the Apache License, Version 2.0 (the \"License\");\n",
        "5": " * you may not use this file except in compliance with the License.\n",
        "6": " * You may obtain a copy of the License at\n",
        "10": " * Unless required by applicable law or agreed to in writing, software\n",
        "11": " * distributed under the License is distributed on an \"AS IS\" BASIS,\n",
        "12": " * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n",
        "13": " * See the License for the specific language governing permissions and\n",
        "14": " * limitations under the License.\n",
        "49": " * callbacks. Its subclasses must manage threads manually; consider\n",
        "50": " * {@link AbstractExecutionThreadService} if you need only a single execution thread.\n",
        "60": "        @Override void call(Listener listener) {\n",
        "66": "        @Override void call(Listener listener) {\n",
        "75": "  private static final Callback<Listener> TERMINATED_FROM_NEW_CALLBACK = \n",
        "76": "      terminatedCallback(NEW);\n",
        "84": "      @Override void call(Listener listener) {\n",
        "92": "      @Override void call(Listener listener) {\n",
        "108": "    @Override public boolean isSatisfied() {\n",
        "121": "    @Override public boolean isSatisfied() {\n",
        "134": "    @Override public boolean isSatisfied() {\n",
        "147": "    @Override public boolean isSatisfied() {\n",
        "160": "   * The current state of the service.  This should be written with the lock held but can be read\n",
        "161": "   * without it because it is an immutable object in a volatile field.  This is desirable so that\n",
        "177": "   * or after it has returned. If startup fails, the invocation should cause a call to\n",
        "178": "   * {@link #notifyFailed(Throwable)} instead.\n",
        "189": "   * returned. If shutdown fails, the invocation should cause a call to\n",
        "190": "   * {@link #notifyFailed(Throwable)} instead.\n",
        "192": "   * <p> This method should return promptly; prefer to do work on a different thread where it is\n",
        "198": "  @Override public final Service startAsync() {\n",
        "216": "  @Override public final Service stopAsync() {\n",
        "252": "  @Override public final void awaitRunning() {\n",
        "261": "  @Override public final void awaitRunning(long timeout, TimeUnit unit) throws TimeoutException {\n",
        "277": "  @Override public final void awaitTerminated() {\n",
        "286": "  @Override public final void awaitTerminated(long timeout, TimeUnit unit) throws TimeoutException {\n",
        "298": "      throw new TimeoutException(\"Timed out waiting for \" + this + \" to reach a terminal state. \"\n",
        "299": "          + \"Current state: \" + state());\n",
        "310": "        throw new IllegalStateException(\"Expected the service to be \" + expected \n",
        "311": "            + \", but the service has FAILED\", failureCause());\n",
        "313": "      throw new IllegalStateException(\"Expected the service to be \" + expected + \", but was \" \n",
        "314": "          + actual);\n",
        "330": "        IllegalStateException failure = new IllegalStateException(\n",
        "331": "            \"Cannot notifyStarted() when the service is \" + snapshot.state);\n",
        "355": "   * @throws IllegalStateException if the service is neither {@link State#STOPPING} nor\n",
        "356": "   *         {@link State#RUNNING}.\n",
        "365": "        IllegalStateException failure = new IllegalStateException(\n",
        "366": "            \"Cannot notifyStopped() when the service is \" + previous);\n",
        "446": "  @Override public String toString() {\n",
        "486": "    switch(from) {\n",
        "508": "      @Override void call(Listener listener) {\n",
        "537": "    @Nullable\n",
        "538": "    final Throwable failure;\n",
        "546": "      checkArgument(!shutdownWhenStartupFinishes || internalState == STARTING, \n",
        "549": "      checkArgument(!(failure != null ^ internalState == FAILED),\n",
        "551": "          + \"instead.\", internalState, failure);\n",
        "568": "      checkState(state == FAILED, \n",
        "569": "          \"failureCause() is only valid if the service has failed, service is %s\", state);\n"
    }
}