{
    "addition": {
        "4": " * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not use this file except\n",
        "5": " * in compliance with the License. You may obtain a copy of the License at\n",
        "9": " * Unless required by applicable law or agreed to in writing, software distributed under the License\n",
        "10": " * is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express\n",
        "11": " * or implied. See the License for the specific language governing permissions and limitations under\n",
        "12": " * the License.\n",
        "102": "   * Creates a {@code ListenableFuture} which has its value set immediately upon construction. The\n",
        "103": "   * getters just return the value. This {@code Future} can't be canceled or timed out and its\n",
        "104": "   * {@code isDone()} method always returns {@code true}.\n",
        "118": "   * Returns a {@code ListenableFuture} which has an exception set immediately upon construction.\n",
        "120": "   * <p>The returned {@code Future} can't be cancelled, and its {@code isDone()} method always\n",
        "121": "   * returns {@code true}. Calling {@code get()} will immediately throw the provided {@code\n",
        "122": "   * Throwable} wrapped in an {@code ExecutionException}.\n",
        "125": "  public static <V> ListenableFuture<V> immediateFailedFuture(Throwable throwable) {\n",
        "131": "   * Returns a {@code Future} whose result is taken from the given primary {@code input} or, if the\n",
        "132": "   * primary input fails, from the {@code Future} provided by the {@code fallback}. {@link\n",
        "133": "   * FutureFallback#create} is not invoked until the primary input has failed, so if the primary\n",
        "134": "   * input succeeds, it is never invoked. If, during the invocation of {@code fallback}, an\n",
        "135": "   * exception is thrown, this exception is used as the result of the output {@code Future}.\n",
        "137": "   * <p>Below is an example of a fallback that returns a default value if an exception occurs:\n",
        "153": "   * <p>The fallback can also choose to propagate the original exception when desired:\n",
        "170": "   * <p>This overload, which does not accept an executor, uses {@code directExecutor}, a dangerous\n",
        "171": "   * choice in some cases. See the discussion in the {@link ListenableFuture#addListener\n",
        "172": "   * ListenableFuture.addListener} documentation. The documentation's warnings about \"lightweight\n",
        "173": "   * listeners\" refer here to the work done during {@code FutureFallback.create}, not to any work\n",
        "174": "   * done to complete the returned {@code Future}.\n",
        "177": "   * @param fallback the {@link FutureFallback} implementation to be called if {@code input} fails\n",
        "179": "   * @deprecated Use {@link #catchingAsync(ListenableFuture, Class, AsyncFunction)\n",
        "180": "   *     catchingAsync(input, Throwable.class, fallbackImplementedAsAnAsyncFunction)}, usually\n",
        "181": "   *     replacing {@code Throwable.class} with the specific type you want to handle. This method\n",
        "187": "      ListenableFuture<? extends V> input, FutureFallback<? extends V> fallback) {\n",
        "192": "   * Returns a {@code Future} whose result is taken from the given primary {@code input} or, if the\n",
        "193": "   * primary input fails, from the {@code Future} provided by the {@code fallback}. {@link\n",
        "194": "   * FutureFallback#create} is not invoked until the primary input has failed, so if the primary\n",
        "195": "   * input succeeds, it is never invoked. If, during the invocation of {@code fallback}, an\n",
        "196": "   * exception is thrown, this exception is used as the result of the output {@code Future}.\n",
        "198": "   * <p>Below is an example of a fallback that returns a default value if an exception occurs:\n",
        "214": "   * <p>The fallback can also choose to propagate the original exception when desired:\n",
        "231": "   * <p>When selecting an executor, note that {@code directExecutor} is dangerous in some cases. See\n",
        "232": "   * the discussion in the {@link ListenableFuture#addListener ListenableFuture.addListener}\n",
        "233": "   * documentation. The documentation's warnings about \"lightweight listeners\" refer here to the\n",
        "234": "   * work done during {@code FutureFallback.create}, not to any work done to complete the returned\n",
        "235": "   * {@code Future}.\n",
        "238": "   * @param fallback the {@link FutureFallback} implementation to be called if {@code input} fails\n",
        "239": "   * @param executor the executor that runs {@code fallback} if {@code input} fails\n",
        "241": "   * @deprecated Use {@link #catchingAsync(ListenableFuture, Class, AsyncFunction, Executor)\n",
        "242": "   *     catchingAsync(input, Throwable.class, fallbackImplementedAsAnAsyncFunction, executor)},\n",
        "243": "   *     usually replacing {@code Throwable.class} with the specific type you want to handle. This\n",
        "244": "   *     method will be removed in Guava release 20.0.\n",
        "250": "      FutureFallback<? extends V> fallback,\n",
        "251": "      Executor executor) {\n",
        "252": "    return catchingAsync(input, Throwable.class, asAsyncFunction(fallback), executor);\n",
        "261": "        return checkNotNull(\n",
        "262": "            fallback.create(t),\n",
        "263": "            \"FutureFallback.create returned null instead of a \"\n",
        "264": "                + \"Future. Did you mean to return immediateFuture(null)?\");\n",
        "270": "   * Returns a new {@code ListenableFuture} whose result is asynchronously derived from the result\n",
        "271": "   * of the given {@code Future}. More precisely, the returned {@code Future} takes its result from\n",
        "272": "   * a {@code Future} produced by applying the given {@code AsyncFunction} to the result of the\n",
        "273": "   * original {@code Future}. Example:\n",
        "286": "   * <p>This overload, which does not accept an executor, uses {@code directExecutor}, a dangerous\n",
        "287": "   * choice in some cases. See the discussion in the {@link ListenableFuture#addListener\n",
        "288": "   * ListenableFuture.addListener} documentation. The documentation's warnings about \"lightweight\n",
        "289": "   * listeners\" refer here to the work done during {@code AsyncFunction.apply}, not to any work done\n",
        "290": "   * to complete the returned {@code Future}.\n",
        "292": "   * <p>The returned {@code Future} attempts to keep its cancellation state in sync with that of the\n",
        "293": "   * input future and that of the future returned by the function. That is, if the returned {@code\n",
        "294": "   * Future} is cancelled, it will attempt to cancel the other two, and if either of the other two\n",
        "295": "   * is cancelled, the returned {@code Future} will receive a callback in which it will attempt to\n",
        "296": "   * cancel itself.\n",
        "299": "   * @param function A function to transform the result of the input future to the result of the\n",
        "300": "   *     output future\n",
        "301": "   * @return A future that holds result of the function (if the input succeeded) or the original\n",
        "302": "   *     input's failure (if not)\n",
        "304": "   * @deprecated These {@code AsyncFunction} overloads of {@code transform} are being renamed to\n",
        "305": "   *     {@code transformAsync}. (The {@code Function} overloads are keeping the \"transform\" name.)\n",
        "306": "   *     This method will be removed in Guava release 20.0.\n",
        "309": "  public static <I, O> ListenableFuture<O> transform(\n",
        "310": "      ListenableFuture<I> input, AsyncFunction<? super I, ? extends O> function) {\n",
        "315": "   * Returns a new {@code ListenableFuture} whose result is asynchronously derived from the result\n",
        "316": "   * of the given {@code Future}. More precisely, the returned {@code Future} takes its result from\n",
        "317": "   * a {@code Future} produced by applying the given {@code AsyncFunction} to the result of the\n",
        "318": "   * original {@code Future}. Example:\n",
        "331": "   * <p>When selecting an executor, note that {@code directExecutor} is dangerous in some cases. See\n",
        "332": "   * the discussion in the {@link ListenableFuture#addListener ListenableFuture.addListener}\n",
        "333": "   * documentation. The documentation's warnings about \"lightweight listeners\" refer here to the\n",
        "334": "   * work done during {@code AsyncFunction.apply}, not to any work done to complete the returned\n",
        "335": "   * {@code Future}.\n",
        "337": "   * <p>The returned {@code Future} attempts to keep its cancellation state in sync with that of the\n",
        "338": "   * input future and that of the future returned by the chain function. That is, if the returned\n",
        "339": "   * {@code Future} is cancelled, it will attempt to cancel the other two, and if either of the\n",
        "340": "   * other two is cancelled, the returned {@code Future} will receive a callback in which it will\n",
        "341": "   * attempt to cancel itself.\n",
        "344": "   * @param function A function to transform the result of the input future to the result of the\n",
        "345": "   *     output future\n",
        "347": "   * @return A future that holds result of the function (if the input succeeded) or the original\n",
        "348": "   *     input's failure (if not)\n",
        "350": "   * @deprecated These {@code AsyncFunction} overloads of {@code transform} are being renamed to\n",
        "351": "   *     {@code transformAsync}. (The {@code Function} overloads are keeping the \"transform\" name.)\n",
        "352": "   *     This method will be removed in Guava release 20.0.\n",
        "355": "  public static <I, O> ListenableFuture<O> transform(\n",
        "356": "      ListenableFuture<I> input,\n",
        "440": "  public static <I, O> ListenableFuture<O> transformAsync(\n",
        "441": "      ListenableFuture<I> input,\n",
        "442": "      AsyncFunction<? super I, ? extends O> function,\n",
        "443": "      Executor executor) {\n",
        "448": "   * Returns a new {@code ListenableFuture} whose result is the product of applying the given {@code\n",
        "449": "   * Function} to the result of the given {@code Future}. Example:\n",
        "462": "   * <p>This overload, which does not accept an executor, uses {@code directExecutor}, a dangerous\n",
        "463": "   * choice in some cases. See the discussion in the {@link ListenableFuture#addListener\n",
        "464": "   * ListenableFuture.addListener} documentation. The documentation's warnings about \"lightweight\n",
        "465": "   * listeners\" refer here to the work done during {@code Function.apply}.\n",
        "467": "   * <p>The returned {@code Future} attempts to keep its cancellation state in sync with that of the\n",
        "468": "   * input future. That is, if the returned {@code Future} is cancelled, it will attempt to cancel\n",
        "469": "   * the input, and if the input is cancelled, the returned {@code Future} will receive a callback\n",
        "470": "   * in which it will attempt to cancel itself.\n",
        "472": "   * <p>An example use of this method is to convert a serializable object returned from an RPC into\n",
        "473": "   * a POJO.\n",
        "476": "   * @param function A Function to transform the results of the provided future to the results of\n",
        "477": "   *     the returned future.  This will be run in the thread that notifies input it is complete.\n",
        "487": "   * Returns a new {@code ListenableFuture} whose result is the product of applying the given {@code\n",
        "488": "   * Function} to the result of the given {@code Future}. Example:\n",
        "501": "   * <p>When selecting an executor, note that {@code directExecutor} is dangerous in some cases. See\n",
        "502": "   * the discussion in the {@link ListenableFuture#addListener ListenableFuture.addListener}\n",
        "503": "   * documentation. The documentation's warnings about \"lightweight listeners\" refer here to the\n",
        "504": "   * work done during {@code Function.apply}.\n",
        "506": "   * <p>The returned {@code Future} attempts to keep its cancellation state in sync with that of the\n",
        "507": "   * input future. That is, if the returned {@code Future} is cancelled, it will attempt to cancel\n",
        "508": "   * the input, and if the input is cancelled, the returned {@code Future} will receive a callback\n",
        "509": "   * in which it will attempt to cancel itself.\n",
        "511": "   * <p>An example use of this method is to convert a serializable object returned from an RPC into\n",
        "512": "   * a POJO.\n",
        "515": "   * @param function A Function to transform the results of the provided future to the results of\n",
        "516": "   *     the returned future.\n",
        "527": "   * Returns a new {@code ListenableFuture} whose result is the product of calling {@code get()} on\n",
        "528": "   * the {@code Future} nested within the given {@code Future}, effectively chaining the futures one\n",
        "529": "   * after the other.  Example:\n",
        "536": "   * #transform(ListenableFuture, AsyncFunction)}, in that the returned {@code Future} attempts to\n",
        "537": "   * keep its cancellation state in sync with both the input {@code Future} and the nested {@code\n",
        "538": "   * Future}.  The transformation is very lightweight and therefore takes place in the same thread\n",
        "539": "   * (either the thread that called {@code dereference}, or the thread in which the dereferenced\n",
        "540": "   * future completes).\n",
        "558": "        @Override\n",
        "559": "        public ListenableFuture<Object> apply(ListenableFuture<Object> input) {\n",
        "565": "   * Creates a new {@code ListenableFuture} whose value is a list containing the values of all its\n",
        "566": "   * input futures, if all succeed. If any input fails, the returned future fails immediately.\n",
        "570": "   * <p>Canceling this future will attempt to cancel all the component futures, and if any of the\n",
        "571": "   * provided futures fails or is canceled, this one is, too.\n",
        "574": "   * @return a future that provides a list of the results of the component futures\n",
        "580": "  public static <V> ListenableFuture<List<V>> allAsList(ListenableFuture<? extends V>... futures) {\n",
        "585": "   * Creates a new {@code ListenableFuture} whose value is a list containing the values of all its\n",
        "586": "   * input futures, if all succeed. If any input fails, the returned future fails immediately.\n",
        "590": "   * <p>Canceling this future will attempt to cancel all the component futures, and if any of the\n",
        "591": "   * provided futures fails or is canceled, this one is, too.\n",
        "594": "   * @return a future that provides a list of the results of the component futures\n",
        "605": "   * Creates a new {@code ListenableFuture} whose value is a list containing the values of all its\n",
        "606": "   * successful input futures. The list of results is in the same order as the input list, and if\n",
        "607": "   * any of the provided futures fails or is canceled, its corresponding position will contain\n",
        "608": "   * {@code null} (which is indistinguishable from the future having a successful value of {@code\n",
        "609": "   * null}).\n",
        "614": "   * @return a future that provides a list of the results of the component futures\n",
        "626": "   * Creates a new {@code ListenableFuture} whose value is a list containing the values of all its\n",
        "627": "   * successful input futures. The list of results is in the same order as the input list, and if\n",
        "628": "   * any of the provided futures fails or is canceled, its corresponding position will contain\n",
        "629": "   * {@code null} (which is indistinguishable from the future having a successful value of {@code\n",
        "630": "   * null}).\n",
        "635": "   * @return a future that provides a list of the results of the component futures\n",
        "646": "   * Registers separate success and failure callbacks to be run when the {@code Future}'s\n",
        "647": "   * computation is {@linkplain java.util.concurrent.Future#isDone() complete} or, if the\n",
        "648": "   * computation is already complete, immediately.\n",
        "650": "   * <p>There is no guaranteed ordering of execution of callbacks, but any callback added through\n",
        "651": "   * this method is guaranteed to be called once the computation is complete.\n",
        "665": "   * <p>This overload, which does not accept an executor, uses {@code directExecutor}, a dangerous\n",
        "666": "   * choice in some cases. See the discussion in the {@link ListenableFuture#addListener\n",
        "667": "   * ListenableFuture.addListener} documentation.\n",
        "669": "   * <p>For a more general interface to attach a completion listener to a {@code Future}, see {@link\n",
        "670": "   * ListenableFuture#addListener addListener}.\n",
        "676": "  public static <V> void addCallback(\n",
        "677": "      ListenableFuture<V> future, FutureCallback<? super V> callback) {\n",
        "682": "   * Registers separate success and failure callbacks to be run when the {@code Future}'s\n",
        "683": "   * computation is {@linkplain java.util.concurrent.Future#isDone() complete} or, if the\n",
        "684": "   * computation is already complete, immediately.\n",
        "686": "   * <p>The callback is run in {@code executor}. There is no guaranteed ordering of execution of\n",
        "687": "   * callbacks, but any callback added through this method is guaranteed to be called once the\n",
        "703": "   * <p>When selecting an executor, note that {@code directExecutor} is dangerous in some cases. See\n",
        "704": "   * the discussion in the {@link ListenableFuture#addListener ListenableFuture.addListener}\n",
        "705": "   * documentation.\n",
        "707": "   * <p>For a more general interface to attach a completion listener to a {@code Future}, see {@link\n",
        "708": "   * ListenableFuture#addListener addListener}.\n",
        "712": "   * @param executor The executor to run {@code callback} when the future completes.\n",
        "715": "  public static <V> void addCallback(\n",
        "716": "      final ListenableFuture<V> future,\n",
        "717": "      final FutureCallback<? super V> callback,\n",
        "718": "      Executor executor) {\n",
        "720": "    Runnable callbackListener =\n",
        "721": "        new Runnable() {\n",
        "722": "          @Override\n",
        "723": "          public void run() {\n",
        "724": "            final V value;\n",
        "725": "            try {\n",
        "726": "              // TODO(user): (Before Guava release), validate that this\n",
        "727": "              // is the thing for IE.\n",
        "728": "              value = getUninterruptibly(future);\n",
        "729": "            } catch (ExecutionException e) {\n",
        "730": "              callback.onFailure(e.getCause());\n",
        "731": "              return;\n",
        "732": "            } catch (RuntimeException e) {\n",
        "733": "              callback.onFailure(e);\n",
        "734": "              return;\n",
        "735": "            } catch (Error e) {\n",
        "736": "              callback.onFailure(e);\n",
        "737": "              return;\n",
        "738": "            }\n",
        "739": "            callback.onSuccess(value);\n",
        "740": "          }\n",
        "741": "        };\n",
        "746": "   * Arguably we don't need a timed getUnchecked because any operation slow enough to require a\n",
        "747": "   * timeout is heavyweight enough to throw a checked exception and therefore be inappropriate to\n",
        "748": "   * use with getUnchecked. Further, it's not clear that converting the checked TimeoutException to\n",
        "749": "   * a RuntimeException -- especially to an UncheckedExecutionException, since it wasn't thrown by\n",
        "750": "   * the computation -- makes sense, and if we don't convert it, the user still has to write a\n",
        "751": "   * try-catch block.\n",
        "752": "   *\n",
        "753": "   * If you think you would use this method, let us know. You might also also look into the\n",
        "754": "   * Fork-Join framework: http://docs.oracle.com/javase/tutorial/essential/concurrency/forkjoin.html\n"
    },
    "removed": {
        "4": " * Licensed under the Apache License, Version 2.0 (the \"License\");\n",
        "5": " * you may not use this file except in compliance with the License.\n",
        "6": " * You may obtain a copy of the License at\n",
        "10": " * Unless required by applicable law or agreed to in writing, software\n",
        "11": " * distributed under the License is distributed on an \"AS IS\" BASIS,\n",
        "12": " * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n",
        "13": " * See the License for the specific language governing permissions and\n",
        "14": " * limitations under the License.\n",
        "104": "   * Creates a {@code ListenableFuture} which has its value set immediately upon\n",
        "105": "   * construction. The getters just return the value. This {@code Future} can't\n",
        "106": "   * be canceled or timed out and its {@code isDone()} method always returns\n",
        "107": "   * {@code true}.\n",
        "121": "   * Returns a {@code ListenableFuture} which has an exception set immediately\n",
        "122": "   * upon construction.\n",
        "124": "   * <p>The returned {@code Future} can't be cancelled, and its {@code isDone()}\n",
        "125": "   * method always returns {@code true}. Calling {@code get()} will immediately\n",
        "126": "   * throw the provided {@code Throwable} wrapped in an {@code\n",
        "127": "   * ExecutionException}.\n",
        "130": "  public static <V> ListenableFuture<V> immediateFailedFuture(\n",
        "131": "      Throwable throwable) {\n",
        "137": "   * Returns a {@code Future} whose result is taken from the given primary\n",
        "138": "   * {@code input} or, if the primary input fails, from the {@code Future}\n",
        "139": "   * provided by the {@code fallback}. {@link FutureFallback#create} is not\n",
        "140": "   * invoked until the primary input has failed, so if the primary input\n",
        "141": "   * succeeds, it is never invoked. If, during the invocation of {@code\n",
        "142": "   * fallback}, an exception is thrown, this exception is used as the result of\n",
        "143": "   * the output {@code Future}.\n",
        "145": "   * <p>Below is an example of a fallback that returns a default value if an\n",
        "146": "   * exception occurs:\n",
        "162": "   * <p>The fallback can also choose to propagate the original exception when\n",
        "163": "   * desired:\n",
        "180": "   * <p>This overload, which does not accept an executor, uses {@code\n",
        "181": "   * directExecutor}, a dangerous choice in some cases. See the discussion in\n",
        "182": "   * the {@link ListenableFuture#addListener ListenableFuture.addListener}\n",
        "183": "   * documentation. The documentation's warnings about \"lightweight listeners\"\n",
        "184": "   * refer here to the work done during {@code FutureFallback.create}, not to\n",
        "185": "   * any work done to complete the returned {@code Future}.\n",
        "188": "   * @param fallback the {@link FutureFallback} implementation to be called if\n",
        "189": "   *     {@code input} fails\n",
        "191": "   * @deprecated Use {@link #catchingAsync(ListenableFuture, Class,\n",
        "192": "   *     AsyncFunction) catchingAsync(input, Throwable.class,\n",
        "193": "   *     fallbackImplementedAsAnAsyncFunction)}, usually replacing {@code\n",
        "194": "   *     Throwable.class} with the specific type you want to handle. This method\n",
        "200": "      ListenableFuture<? extends V> input,\n",
        "201": "      FutureFallback<? extends V> fallback) {\n",
        "206": "   * Returns a {@code Future} whose result is taken from the given primary\n",
        "207": "   * {@code input} or, if the primary input fails, from the {@code Future}\n",
        "208": "   * provided by the {@code fallback}. {@link FutureFallback#create} is not\n",
        "209": "   * invoked until the primary input has failed, so if the primary input\n",
        "210": "   * succeeds, it is never invoked. If, during the invocation of {@code\n",
        "211": "   * fallback}, an exception is thrown, this exception is used as the result of\n",
        "212": "   * the output {@code Future}.\n",
        "214": "   * <p>Below is an example of a fallback that returns a default value if an\n",
        "215": "   * exception occurs:\n",
        "231": "   * <p>The fallback can also choose to propagate the original exception when\n",
        "232": "   * desired:\n",
        "249": "   * <p>When selecting an executor, note that {@code directExecutor} is\n",
        "250": "   * dangerous in some cases. See the discussion in the {@link\n",
        "251": "   * ListenableFuture#addListener ListenableFuture.addListener} documentation.\n",
        "252": "   * The documentation's warnings about \"lightweight listeners\" refer here to\n",
        "253": "   * the work done during {@code FutureFallback.create}, not to any work done to\n",
        "254": "   * complete the returned {@code Future}.\n",
        "257": "   * @param fallback the {@link FutureFallback} implementation to be called if\n",
        "258": "   *     {@code input} fails\n",
        "259": "   * @param executor the executor that runs {@code fallback} if {@code input}\n",
        "260": "   *     fails\n",
        "262": "   * @deprecated Use {@link #catchingAsync(ListenableFuture, Class,\n",
        "263": "   *     AsyncFunction, Executor) catchingAsync(input, Throwable.class,\n",
        "264": "   *     fallbackImplementedAsAnAsyncFunction, executor)}, usually replacing\n",
        "265": "   *     {@code Throwable.class} with the specific type you want to handle. This method\n",
        "266": "   *     will be removed in Guava release 20.0.\n",
        "272": "      FutureFallback<? extends V> fallback, Executor executor) {\n",
        "273": "    return catchingAsync(\n",
        "274": "        input, Throwable.class, asAsyncFunction(fallback), executor);\n",
        "283": "        return checkNotNull(fallback.create(t), \"FutureFallback.create returned null instead of a \"\n",
        "284": "            + \"Future. Did you mean to return immediateFuture(null)?\");\n",
        "290": "   * Returns a new {@code ListenableFuture} whose result is asynchronously\n",
        "291": "   * derived from the result of the given {@code Future}. More precisely, the\n",
        "292": "   * returned {@code Future} takes its result from a {@code Future} produced by\n",
        "293": "   * applying the given {@code AsyncFunction} to the result of the original\n",
        "294": "   * {@code Future}. Example:\n",
        "307": "   * <p>This overload, which does not accept an executor, uses {@code\n",
        "308": "   * directExecutor}, a dangerous choice in some cases. See the discussion in\n",
        "309": "   * the {@link ListenableFuture#addListener ListenableFuture.addListener}\n",
        "310": "   * documentation. The documentation's warnings about \"lightweight listeners\"\n",
        "311": "   * refer here to the work done during {@code AsyncFunction.apply}, not to any\n",
        "312": "   * work done to complete the returned {@code Future}.\n",
        "314": "   * <p>The returned {@code Future} attempts to keep its cancellation state in\n",
        "315": "   * sync with that of the input future and that of the future returned by the\n",
        "316": "   * function. That is, if the returned {@code Future} is cancelled, it will\n",
        "317": "   * attempt to cancel the other two, and if either of the other two is\n",
        "318": "   * cancelled, the returned {@code Future} will receive a callback in which it\n",
        "319": "   * will attempt to cancel itself.\n",
        "322": "   * @param function A function to transform the result of the input future\n",
        "323": "   *     to the result of the output future\n",
        "324": "   * @return A future that holds result of the function (if the input succeeded)\n",
        "325": "   *     or the original input's failure (if not)\n",
        "327": "   * @deprecated These {@code AsyncFunction} overloads of {@code transform} are\n",
        "328": "   *     being renamed to {@code transformAsync}. (The {@code Function}\n",
        "329": "   *     overloads are keeping the \"transform\" name.) This method will be removed in Guava release\n",
        "330": "   *     20.0.\n",
        "333": "  public static <I, O> ListenableFuture<O> transform(ListenableFuture<I> input,\n",
        "334": "      AsyncFunction<? super I, ? extends O> function) {\n",
        "339": "   * Returns a new {@code ListenableFuture} whose result is asynchronously\n",
        "340": "   * derived from the result of the given {@code Future}. More precisely, the\n",
        "341": "   * returned {@code Future} takes its result from a {@code Future} produced by\n",
        "342": "   * applying the given {@code AsyncFunction} to the result of the original\n",
        "343": "   * {@code Future}. Example:\n",
        "356": "   * <p>When selecting an executor, note that {@code directExecutor} is\n",
        "357": "   * dangerous in some cases. See the discussion in the {@link\n",
        "358": "   * ListenableFuture#addListener ListenableFuture.addListener} documentation.\n",
        "359": "   * The documentation's warnings about \"lightweight listeners\" refer here to\n",
        "360": "   * the work done during {@code AsyncFunction.apply}, not to any work done to\n",
        "361": "   * complete the returned {@code Future}.\n",
        "363": "   * <p>The returned {@code Future} attempts to keep its cancellation state in\n",
        "364": "   * sync with that of the input future and that of the future returned by the\n",
        "365": "   * chain function. That is, if the returned {@code Future} is cancelled, it\n",
        "366": "   * will attempt to cancel the other two, and if either of the other two is\n",
        "367": "   * cancelled, the returned {@code Future} will receive a callback in which it\n",
        "368": "   * will attempt to cancel itself.\n",
        "371": "   * @param function A function to transform the result of the input future\n",
        "372": "   *     to the result of the output future\n",
        "374": "   * @return A future that holds result of the function (if the input succeeded)\n",
        "375": "   *     or the original input's failure (if not)\n",
        "377": "   * @deprecated These {@code AsyncFunction} overloads of {@code transform} are\n",
        "378": "   *     being renamed to {@code transformAsync}. (The {@code Function}\n",
        "379": "   *     overloads are keeping the \"transform\" name.) This method will be removed in Guava release\n",
        "380": "   *     20.0.\n",
        "383": "  public static <I, O> ListenableFuture<O> transform(ListenableFuture<I> input,\n",
        "467": "  public static <I, O> ListenableFuture<O> transformAsync(ListenableFuture<I> input,\n",
        "468": "      AsyncFunction<? super I, ? extends O> function, Executor executor) {\n",
        "473": "   * Returns a new {@code ListenableFuture} whose result is the product of\n",
        "474": "   * applying the given {@code Function} to the result of the given {@code\n",
        "475": "   * Future}. Example:\n",
        "488": "   * <p>This overload, which does not accept an executor, uses {@code\n",
        "489": "   * directExecutor}, a dangerous choice in some cases. See the discussion in\n",
        "490": "   * the {@link ListenableFuture#addListener ListenableFuture.addListener}\n",
        "491": "   * documentation. The documentation's warnings about \"lightweight listeners\"\n",
        "492": "   * refer here to the work done during {@code Function.apply}.\n",
        "494": "   * <p>The returned {@code Future} attempts to keep its cancellation state in\n",
        "495": "   * sync with that of the input future. That is, if the returned {@code Future}\n",
        "496": "   * is cancelled, it will attempt to cancel the input, and if the input is\n",
        "497": "   * cancelled, the returned {@code Future} will receive a callback in which it\n",
        "498": "   * will attempt to cancel itself.\n",
        "500": "   * <p>An example use of this method is to convert a serializable object\n",
        "501": "   * returned from an RPC into a POJO.\n",
        "504": "   * @param function A Function to transform the results of the provided future\n",
        "505": "   *     to the results of the returned future.  This will be run in the thread\n",
        "506": "   *     that notifies input it is complete.\n",
        "516": "   * Returns a new {@code ListenableFuture} whose result is the product of\n",
        "517": "   * applying the given {@code Function} to the result of the given {@code\n",
        "518": "   * Future}. Example:\n",
        "531": "   * <p>When selecting an executor, note that {@code directExecutor} is\n",
        "532": "   * dangerous in some cases. See the discussion in the {@link\n",
        "533": "   * ListenableFuture#addListener ListenableFuture.addListener} documentation.\n",
        "534": "   * The documentation's warnings about \"lightweight listeners\" refer here to\n",
        "535": "   * the work done during {@code Function.apply}.\n",
        "537": "   * <p>The returned {@code Future} attempts to keep its cancellation state in\n",
        "538": "   * sync with that of the input future. That is, if the returned {@code Future}\n",
        "539": "   * is cancelled, it will attempt to cancel the input, and if the input is\n",
        "540": "   * cancelled, the returned {@code Future} will receive a callback in which it\n",
        "541": "   * will attempt to cancel itself.\n",
        "543": "   * <p>An example use of this method is to convert a serializable object\n",
        "544": "   * returned from an RPC into a POJO.\n",
        "547": "   * @param function A Function to transform the results of the provided future\n",
        "548": "   *     to the results of the returned future.\n",
        "559": "   * Returns a new {@code ListenableFuture} whose result is the product of\n",
        "560": "   * calling {@code get()} on the {@code Future} nested within the given {@code\n",
        "561": "   * Future}, effectively chaining the futures one after the other.  Example:\n",
        "568": "   * #transform(ListenableFuture, AsyncFunction)}, in that the returned {@code\n",
        "569": "   * Future} attempts to keep its cancellation state in sync with both the\n",
        "570": "   * input {@code Future} and the nested {@code Future}.  The transformation\n",
        "571": "   * is very lightweight and therefore takes place in the same thread (either\n",
        "572": "   * the thread that called {@code dereference}, or the thread in which the\n",
        "573": "   * dereferenced future completes).\n",
        "591": "        @Override public ListenableFuture<Object> apply(ListenableFuture<Object> input) {\n",
        "597": "   * Creates a new {@code ListenableFuture} whose value is a list containing the\n",
        "598": "   * values of all its input futures, if all succeed. If any input fails, the\n",
        "599": "   * returned future fails immediately.\n",
        "603": "   * <p>Canceling this future will attempt to cancel all the component futures,\n",
        "604": "   * and if any of the provided futures fails or is canceled, this one is,\n",
        "605": "   * too.\n",
        "608": "   * @return a future that provides a list of the results of the component\n",
        "609": "   *         futures\n",
        "615": "  public static <V> ListenableFuture<List<V>> allAsList(\n",
        "616": "      ListenableFuture<? extends V>... futures) {\n",
        "621": "   * Creates a new {@code ListenableFuture} whose value is a list containing the\n",
        "622": "   * values of all its input futures, if all succeed. If any input fails, the\n",
        "623": "   * returned future fails immediately.\n",
        "627": "   * <p>Canceling this future will attempt to cancel all the component futures,\n",
        "628": "   * and if any of the provided futures fails or is canceled, this one is,\n",
        "629": "   * too.\n",
        "632": "   * @return a future that provides a list of the results of the component\n",
        "633": "   *         futures\n",
        "644": "   * Creates a new {@code ListenableFuture} whose value is a list containing the\n",
        "645": "   * values of all its successful input futures. The list of results is in the\n",
        "646": "   * same order as the input list, and if any of the provided futures fails or\n",
        "647": "   * is canceled, its corresponding position will contain {@code null} (which is\n",
        "648": "   * indistinguishable from the future having a successful value of\n",
        "649": "   * {@code null}).\n",
        "654": "   * @return a future that provides a list of the results of the component\n",
        "655": "   *         futures\n",
        "667": "   * Creates a new {@code ListenableFuture} whose value is a list containing the\n",
        "668": "   * values of all its successful input futures. The list of results is in the\n",
        "669": "   * same order as the input list, and if any of the provided futures fails or\n",
        "670": "   * is canceled, its corresponding position will contain {@code null} (which is\n",
        "671": "   * indistinguishable from the future having a successful value of\n",
        "672": "   * {@code null}).\n",
        "677": "   * @return a future that provides a list of the results of the component\n",
        "678": "   *         futures\n",
        "689": "   * Registers separate success and failure callbacks to be run when the {@code\n",
        "690": "   * Future}'s computation is {@linkplain java.util.concurrent.Future#isDone()\n",
        "691": "   * complete} or, if the computation is already complete, immediately.\n",
        "693": "   * <p>There is no guaranteed ordering of execution of callbacks, but any\n",
        "694": "   * callback added through this method is guaranteed to be called once the\n",
        "695": "   * computation is complete.\n",
        "709": "   * <p>This overload, which does not accept an executor, uses {@code\n",
        "710": "   * directExecutor}, a dangerous choice in some cases. See the discussion in\n",
        "711": "   * the {@link ListenableFuture#addListener ListenableFuture.addListener}\n",
        "712": "   * documentation.\n",
        "714": "   * <p>For a more general interface to attach a completion listener to a\n",
        "715": "   * {@code Future}, see {@link ListenableFuture#addListener addListener}.\n",
        "721": "  public static <V> void addCallback(ListenableFuture<V> future,\n",
        "722": "      FutureCallback<? super V> callback) {\n",
        "727": "   * Registers separate success and failure callbacks to be run when the {@code\n",
        "728": "   * Future}'s computation is {@linkplain java.util.concurrent.Future#isDone()\n",
        "729": "   * complete} or, if the computation is already complete, immediately.\n",
        "731": "   * <p>The callback is run in {@code executor}.\n",
        "732": "   * There is no guaranteed ordering of execution of callbacks, but any\n",
        "733": "   * callback added through this method is guaranteed to be called once the\n",
        "749": "   * <p>When selecting an executor, note that {@code directExecutor} is\n",
        "750": "   * dangerous in some cases. See the discussion in the {@link\n",
        "751": "   * ListenableFuture#addListener ListenableFuture.addListener} documentation.\n",
        "753": "   * <p>For a more general interface to attach a completion listener to a\n",
        "754": "   * {@code Future}, see {@link ListenableFuture#addListener addListener}.\n",
        "758": "   * @param executor The executor to run {@code callback} when the future\n",
        "759": "   *    completes.\n",
        "762": "  public static <V> void addCallback(final ListenableFuture<V> future,\n",
        "763": "      final FutureCallback<? super V> callback, Executor executor) {\n",
        "765": "    Runnable callbackListener = new Runnable() {\n",
        "766": "      @Override\n",
        "767": "      public void run() {\n",
        "768": "        final V value;\n",
        "769": "        try {\n",
        "770": "          // TODO(user): (Before Guava release), validate that this\n",
        "771": "          // is the thing for IE.\n",
        "772": "          value = getUninterruptibly(future);\n",
        "773": "        } catch (ExecutionException e) {\n",
        "774": "          callback.onFailure(e.getCause());\n",
        "775": "          return;\n",
        "776": "        } catch (RuntimeException e) {\n",
        "777": "          callback.onFailure(e);\n",
        "778": "          return;\n",
        "779": "        } catch (Error e) {\n",
        "780": "          callback.onFailure(e);\n",
        "781": "          return;\n",
        "782": "        }\n",
        "783": "        callback.onSuccess(value);\n",
        "784": "      }\n",
        "785": "    };\n",
        "790": "   * Arguably we don't need a timed getUnchecked because any operation slow\n",
        "791": "   * enough to require a timeout is heavyweight enough to throw a checked\n",
        "792": "   * exception and therefore be inappropriate to use with getUnchecked. Further,\n",
        "793": "   * it's not clear that converting the checked TimeoutException to a\n",
        "794": "   * RuntimeException -- especially to an UncheckedExecutionException, since it\n",
        "795": "   * wasn't thrown by the computation -- makes sense, and if we don't convert\n",
        "796": "   * it, the user still has to write a try-catch block.\n",
        "797": "   *\n",
        "798": "   * If you think you would use this method, let us know. You might also also\n",
        "799": "   * look into the Fork-Join framework:\n",
        "800": "   * http://docs.oracle.com/javase/tutorial/essential/concurrency/forkjoin.html\n"
    }
}