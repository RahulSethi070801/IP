{
    "addition": {
        "4": " * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not use this file except\n",
        "5": " * in compliance with the License. You may obtain a copy of the License at\n",
        "9": " * Unless required by applicable law or agreed to in writing, software distributed under the License\n",
        "10": " * is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express\n",
        "11": " * or implied. See the License for the specific language governing permissions and limitations under\n",
        "12": " * the License.\n",
        "76": "    @Override\n",
        "77": "    public final V get() throws InterruptedException, ExecutionException {\n",
        "81": "    @Override\n",
        "82": "    public final V get(long timeout, TimeUnit unit)\n",
        "87": "    @Override\n",
        "88": "    public final boolean isDone() {\n",
        "92": "    @Override\n",
        "93": "    public final boolean isCancelled() {\n",
        "97": "    @Override\n",
        "98": "    public final void addListener(Runnable listener, Executor executor) {\n",
        "157": "    /**\n",
        "158": "     * Constructor for the TOMBSTONE, avoids use of ATOMIC_HELPER in case this class is loaded\n",
        "159": "     * before the ATOMIC_HELPER. Apparently this is possible on some android platforms.\n",
        "160": "     */\n",
        "197": "    node.thread = null; // mark as 'deleted'\n",
        "198": "    restart:\n",
        "199": "    while (true) {\n",
        "203": "        return; // give up if someone is calling complete\n",
        "208": "        if (curr.thread != null) { // we aren't unlinking this node, update pred.\n",
        "212": "          if (pred.thread == null) { // We raced with another node that unlinked pred. Restart.\n",
        "215": "        } else if (!ATOMIC_HELPER.casWaiters(this, curr, succ)) { // We are unlinking head\n",
        "216": "          continue restart; // We raced with an add or complete\n",
        "244": "    static final Failure FALLBACK_INSTANCE =\n",
        "245": "        new Failure(\n",
        "246": "            new Throwable(\"Failure occurred while trying to finish a future.\") {\n",
        "247": "              @Override\n",
        "248": "              public synchronized Throwable fillInStackTrace() {\n",
        "249": "                return this; // no stack trace\n",
        "250": "              }\n",
        "251": "            });\n",
        "278": "    @Override\n",
        "279": "    public void run() {\n",
        "341": "  /*\n",
        "342": "   * Improve the documentation of when InterruptedException is thrown. Our behavior matches the\n",
        "343": "   * JDK's, but the JDK's documentation is misleading.\n",
        "344": "   */\n",
        "345": "\n",
        "349": "   * <p>The default {@link AbstractFuture} implementation throws {@code InterruptedException} if the\n",
        "350": "   * current thread is interrupted before or during the call, even if the value is already\n",
        "351": "   * available.\n",
        "353": "   * @throws InterruptedException if the current thread was interrupted before or during the call\n",
        "354": "   *     (optional but recommended).\n",
        "372": "    long_wait_loop:\n",
        "373": "    if (remainingNanos >= SPIN_THRESHOLD_NANOS) {\n",
        "400": "                break long_wait_loop; // jump down to the busy wait loop\n",
        "404": "          oldHead = waiters; // re-read and loop.\n",
        "427": "   * Improve the documentation of when InterruptedException is thrown. Our behavior matches the\n",
        "428": "   * JDK's, but the JDK's documentation is misleading.\n",
        "430": "\n",
        "434": "   * <p>The default {@link AbstractFuture} implementation throws {@code InterruptedException} if the\n",
        "435": "   * current thread is interrupted before or during the call, even if the value is already\n",
        "436": "   * available.\n",
        "438": "   * @throws InterruptedException if the current thread was interrupted before or during the call\n",
        "439": "   *     (optional but recommended).\n",
        "442": "  @Override\n",
        "443": "  public V get() throws InterruptedException, ExecutionException {\n",
        "473": "        oldHead = waiters; // re-read and loop.\n",
        "494": "      @SuppressWarnings(\"unchecked\") // this is the only other option\n",
        "527": "      Throwable cause =\n",
        "528": "          GENERATE_CANCELLATION_CAUSES\n",
        "529": "              ? new CancellationException(\"Future.cancel() was called.\")\n",
        "530": "              : null;\n",
        "557": "   * Subclasses can override this method to implement interruption of the future's computation. The\n",
        "558": "   * method is invoked automatically by a successful call to {@link #cancel(boolean) cancel(true)}.\n",
        "564": "  protected void interruptTask() {}\n",
        "567": "   * Returns true if this future was cancelled with {@code mayInterruptIfRunning} set to {@code\n",
        "568": "   * true}.\n",
        "594": "        oldHead = listeners; // re-read\n",
        "665": "  @Beta\n",
        "666": "  protected boolean setFuture(ListenableFuture<? extends V> future) {\n",
        "694": "      localValue = value; // we lost the cas, fall through and maybe cancel\n",
        "827": "      log.log(\n",
        "828": "          Level.SEVERE,\n",
        "829": "          \"RuntimeException while executing runnable \" + runnable + \" with executor \" + executor,\n",
        "830": "          e);\n",
        "906": "          unsafe =\n",
        "907": "              AccessController.doPrivileged(\n",
        "908": "                  new PrivilegedExceptionAction<sun.misc.Unsafe>() {\n",
        "909": "                    @Override\n",
        "910": "                    public sun.misc.Unsafe run() throws Exception {\n",
        "911": "                      Class<sun.misc.Unsafe> k = sun.misc.Unsafe.class;\n",
        "912": "                      for (java.lang.reflect.Field f : k.getDeclaredFields()) {\n",
        "913": "                        f.setAccessible(true);\n",
        "914": "                        Object x = f.get(null);\n",
        "915": "                        if (k.isInstance(x)) {\n",
        "916": "                          return k.cast(x);\n",
        "917": "                        }\n",
        "918": "                      }\n",
        "919": "                      throw new NoSuchFieldError(\"the Unsafe\");\n",
        "921": "                  });\n",
        "970": "    @Override\n",
        "971": "    void putThread(Waiter waiter, Thread thread) {\n",
        "975": "    @Override\n",
        "976": "    void putNext(Waiter waiter, Waiter next) {\n",
        "980": "    @Override\n",
        "981": "    boolean casWaiters(AbstractFuture future, Waiter curr, Waiter next) {\n",
        "985": "    @Override\n",
        "986": "    boolean casListeners(AbstractFuture future, Listener curr, Listener next) {\n",
        "990": "    @Override\n",
        "991": "    boolean casValue(AbstractFuture future, Object expected, Object v) {\n"
    },
    "removed": {
        "4": " * Licensed under the Apache License, Version 2.0 (the \"License\");\n",
        "5": " * you may not use this file except in compliance with the License.\n",
        "6": " * You may obtain a copy of the License at\n",
        "10": " * Unless required by applicable law or agreed to in writing, software\n",
        "11": " * distributed under the License is distributed on an \"AS IS\" BASIS,\n",
        "12": " * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n",
        "13": " * See the License for the specific language governing permissions and\n",
        "14": " * limitations under the License.\n",
        "78": "    @Override public final V get() throws InterruptedException, ExecutionException {\n",
        "82": "    @Override public final V get(long timeout, TimeUnit unit)\n",
        "87": "    @Override public final boolean isDone() {\n",
        "91": "    @Override public final boolean isCancelled() {\n",
        "95": "    @Override public final void addListener(Runnable listener, Executor executor) {\n",
        "154": "    // Constructor for the TOMBSTONE, avoids use of ATOMIC_HELPER in case this class is loaded\n",
        "155": "    // before the ATOMIC_HELPER.  Apparently this is possible on some android platforms.\n",
        "192": "    node.thread = null;  // mark as 'deleted'\n",
        "193": "    restart: while (true) {\n",
        "197": "        return;  // give up if someone is calling complete\n",
        "202": "        if (curr.thread != null) {  // we aren't unlinking this node, update pred.\n",
        "206": "          if (pred.thread == null) {  // We raced with another node that unlinked pred. Restart.\n",
        "209": "        } else if (!ATOMIC_HELPER.casWaiters(this, curr, succ)) {  // We are unlinking head\n",
        "210": "          continue restart;  // We raced with an add or complete\n",
        "238": "    static final Failure FALLBACK_INSTANCE = new Failure(\n",
        "239": "        new Throwable(\"Failure occurred while trying to finish a future.\") {\n",
        "240": "          @Override public synchronized Throwable fillInStackTrace() {\n",
        "241": "            return this;  // no stack trace\n",
        "242": "          }\n",
        "243": "        });\n",
        "270": "    @Override public void run() {\n",
        "308": "  /*\n",
        "309": "   * Improve the documentation of when InterruptedException is thrown. Our\n",
        "310": "   * behavior matches the JDK's, but the JDK's documentation is misleading.\n",
        "311": "   */\n",
        "312": "\n",
        "340": "   * <p>The default {@link AbstractFuture} implementation throws {@code\n",
        "341": "   * InterruptedException} if the current thread is interrupted before or during\n",
        "342": "   * the call, even if the value is already available.\n",
        "344": "   * @throws InterruptedException if the current thread was interrupted before\n",
        "345": "   *     or during the call (optional but recommended).\n",
        "363": "    long_wait_loop: if (remainingNanos >= SPIN_THRESHOLD_NANOS) {\n",
        "390": "                break long_wait_loop;  // jump down to the busy wait loop\n",
        "394": "          oldHead = waiters;  // re-read and loop.\n",
        "417": "   * Improve the documentation of when InterruptedException is thrown. Our\n",
        "418": "   * behavior matches the JDK's, but the JDK's documentation is misleading.\n",
        "423": "   * <p>The default {@link AbstractFuture} implementation throws {@code\n",
        "424": "   * InterruptedException} if the current thread is interrupted before or during\n",
        "425": "   * the call, even if the value is already available.\n",
        "427": "   * @throws InterruptedException if the current thread was interrupted before\n",
        "428": "   *     or during the call (optional but recommended).\n",
        "431": "  @Override public V get() throws InterruptedException, ExecutionException {\n",
        "461": "        oldHead = waiters;  // re-read and loop.\n",
        "482": "      @SuppressWarnings(\"unchecked\")  // this is the only other option\n",
        "515": "      Throwable cause = GENERATE_CANCELLATION_CAUSES\n",
        "516": "          ? new CancellationException(\"Future.cancel() was called.\")\n",
        "517": "          : null;\n",
        "544": "   * Subclasses can override this method to implement interruption of the\n",
        "545": "   * future's computation. The method is invoked automatically by a successful\n",
        "546": "   * call to {@link #cancel(boolean) cancel(true)}.\n",
        "552": "  protected void interruptTask() {\n",
        "553": "  }\n",
        "556": "   * Returns true if this future was cancelled with {@code\n",
        "557": "   * mayInterruptIfRunning} set to {@code true}.\n",
        "583": "        oldHead = listeners;  // re-read\n",
        "654": "  @Beta protected boolean setFuture(ListenableFuture<? extends V> future) {\n",
        "682": "      localValue = value;  // we lost the cas, fall through and maybe cancel\n",
        "815": "      log.log(Level.SEVERE, \"RuntimeException while executing runnable \"\n",
        "816": "          + runnable + \" with executor \" + executor, e);\n",
        "892": "          unsafe = AccessController.doPrivileged(\n",
        "893": "              new PrivilegedExceptionAction<sun.misc.Unsafe>() {\n",
        "894": "                @Override public sun.misc.Unsafe run() throws Exception {\n",
        "895": "                  Class<sun.misc.Unsafe> k = sun.misc.Unsafe.class;\n",
        "896": "                  for (java.lang.reflect.Field f : k.getDeclaredFields()) {\n",
        "897": "                    f.setAccessible(true);\n",
        "898": "                    Object x = f.get(null);\n",
        "899": "                    if (k.isInstance(x)) {\n",
        "900": "                      return k.cast(x);\n",
        "902": "                  }\n",
        "903": "                  throw new NoSuchFieldError(\"the Unsafe\");\n",
        "904": "                }\n",
        "905": "              });\n",
        "954": "    @Override void putThread(Waiter waiter, Thread thread) {\n",
        "958": "    @Override void putNext(Waiter waiter, Waiter next) {\n",
        "962": "    @Override boolean casWaiters(AbstractFuture future, Waiter curr, Waiter next) {\n",
        "966": "    @Override boolean casListeners(AbstractFuture future, Listener curr, Listener next) {\n",
        "970": "    @Override boolean casValue(AbstractFuture future, Object expected, Object v) {\n"
    }
}