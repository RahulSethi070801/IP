{
    "addition": {
        "4": " * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not use this file except\n",
        "5": " * in compliance with the License. You may obtain a copy of the License at\n",
        "9": " * Unless required by applicable law or agreed to in writing, software distributed under the License\n",
        "10": " * is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express\n",
        "11": " * or implied. See the License for the specific language governing permissions and limitations under\n",
        "12": " * the License.\n",
        "123": "   * <p>The given mapping function will be applied to an {@link InterruptedException}, a {@link\n",
        "124": "   * CancellationException}, or an {@link ExecutionException}. See {@link Future#get()} for details\n",
        "125": "   * on the exceptions thrown.\n",
        "137": "   * Creates a {@code ListenableFuture} which has its value set immediately upon construction. The\n",
        "138": "   * getters just return the value. This {@code Future} can't be canceled or timed out and its\n",
        "139": "   * {@code isDone()} method always returns {@code true}.\n",
        "153": "   * Returns a {@code CheckedFuture} which has its value set immediately upon construction.\n",
        "155": "   * <p>The returned {@code Future} can't be cancelled, and its {@code isDone()} method always\n",
        "156": "   * returns {@code true}. Calling {@code get()} or {@code checkedGet()} will immediately return the\n",
        "157": "   * provided value.\n",
        "161": "  public static <V, X extends Exception> CheckedFuture<V, X> immediateCheckedFuture(\n",
        "162": "      @Nullable V value) {\n",
        "167": "   * Returns a {@code ListenableFuture} which has an exception set immediately upon construction.\n",
        "169": "   * <p>The returned {@code Future} can't be cancelled, and its {@code isDone()} method always\n",
        "170": "   * returns {@code true}. Calling {@code get()} will immediately throw the provided {@code\n",
        "171": "   * Throwable} wrapped in an {@code ExecutionException}.\n",
        "174": "  public static <V> ListenableFuture<V> immediateFailedFuture(Throwable throwable) {\n",
        "180": "   * Creates a {@code ListenableFuture} which is cancelled immediately upon construction, so that\n",
        "181": "   * {@code isCancelled()} always returns {@code true}.\n",
        "192": "   * Returns a {@code CheckedFuture} which has an exception set immediately upon construction.\n",
        "193": "   *\n",
        "194": "   * <p>The returned {@code Future} can't be cancelled, and its {@code isDone()} method always\n",
        "195": "   * returns {@code true}. Calling {@code get()} will immediately throw the provided {@code\n",
        "196": "   * Exception} wrapped in an {@code ExecutionException}, and calling {@code checkedGet()} will\n",
        "197": "   * throw the provided exception itself.\n",
        "201": "  public static <V, X extends Exception> CheckedFuture<V, X> immediateFailedCheckedFuture(\n",
        "202": "      X exception) {\n",
        "208": "   * Returns a {@code Future} whose result is taken from the given primary {@code input} or, if the\n",
        "209": "   * primary input fails, from the {@code Future} provided by the {@code fallback}. {@link\n",
        "210": "   * FutureFallback#create} is not invoked until the primary input has failed, so if the primary\n",
        "211": "   * input succeeds, it is never invoked. If, during the invocation of {@code fallback}, an\n",
        "212": "   * exception is thrown, this exception is used as the result of the output {@code Future}.\n",
        "214": "   * <p>Below is an example of a fallback that returns a default value if an exception occurs:\n",
        "230": "   * <p>The fallback can also choose to propagate the original exception when desired:\n",
        "247": "   * <p>This overload, which does not accept an executor, uses {@code directExecutor}, a dangerous\n",
        "248": "   * choice in some cases. See the discussion in the {@link ListenableFuture#addListener\n",
        "249": "   * ListenableFuture.addListener} documentation. The documentation's warnings about \"lightweight\n",
        "250": "   * listeners\" refer here to the work done during {@code FutureFallback.create}, not to any work\n",
        "251": "   * done to complete the returned {@code Future}.\n",
        "254": "   * @param fallback the {@link FutureFallback} implementation to be called if {@code input} fails\n",
        "256": "   * @deprecated Use {@link #catchingAsync(ListenableFuture, Class, AsyncFunction)\n",
        "257": "   *     catchingAsync(input, Throwable.class, fallbackImplementedAsAnAsyncFunction)}, usually\n",
        "258": "   *     replacing {@code Throwable.class} with the specific type you want to handle. This method\n",
        "264": "      ListenableFuture<? extends V> input, FutureFallback<? extends V> fallback) {\n",
        "269": "   * Returns a {@code Future} whose result is taken from the given primary {@code input} or, if the\n",
        "270": "   * primary input fails, from the {@code Future} provided by the {@code fallback}. {@link\n",
        "271": "   * FutureFallback#create} is not invoked until the primary input has failed, so if the primary\n",
        "272": "   * input succeeds, it is never invoked. If, during the invocation of {@code fallback}, an\n",
        "273": "   * exception is thrown, this exception is used as the result of the output {@code Future}.\n",
        "275": "   * <p>Below is an example of a fallback that returns a default value if an exception occurs:\n",
        "291": "   * <p>The fallback can also choose to propagate the original exception when desired:\n",
        "308": "   * <p>When selecting an executor, note that {@code directExecutor} is dangerous in some cases. See\n",
        "309": "   * the discussion in the {@link ListenableFuture#addListener ListenableFuture.addListener}\n",
        "310": "   * documentation. The documentation's warnings about \"lightweight listeners\" refer here to the\n",
        "311": "   * work done during {@code FutureFallback.create}, not to any work done to complete the returned\n",
        "312": "   * {@code Future}.\n",
        "315": "   * @param fallback the {@link FutureFallback} implementation to be called if {@code input} fails\n",
        "316": "   * @param executor the executor that runs {@code fallback} if {@code input} fails\n",
        "318": "   * @deprecated Use {@link #catchingAsync(ListenableFuture, Class, AsyncFunction, Executor)\n",
        "319": "   *     catchingAsync(input, Throwable.class, fallbackImplementedAsAnAsyncFunction, executor)},\n",
        "320": "   *     usually replacing {@code Throwable.class} with the specific type you want to handle. This\n",
        "321": "   *     method will be removed in Guava release 20.0.\n",
        "327": "      FutureFallback<? extends V> fallback,\n",
        "328": "      Executor executor) {\n",
        "329": "    return catchingAsync(input, Throwable.class, asAsyncFunction(fallback), executor);\n",
        "371": "      ListenableFuture<? extends V> input,\n",
        "372": "      Class<X> exceptionType,\n",
        "417": "      ListenableFuture<? extends V> input,\n",
        "418": "      Class<X> exceptionType,\n",
        "419": "      Function<? super X, ? extends V> fallback,\n",
        "420": "      Executor executor) {\n",
        "483": "      ListenableFuture<? extends V> input,\n",
        "484": "      Class<X> exceptionType,\n",
        "549": "      ListenableFuture<? extends V> input,\n",
        "550": "      Class<X> exceptionType,\n",
        "551": "      AsyncFunction<? super X, ? extends V> fallback,\n",
        "552": "      Executor executor) {\n",
        "562": "        return checkNotNull(\n",
        "563": "            fallback.create(t),\n",
        "564": "            \"FutureFallback.create returned null instead of a \"\n",
        "565": "                + \"Future. Did you mean to return immediateFuture(null)?\");\n",
        "571": "   * Returns a future that delegates to another but will finish early (via a {@link\n",
        "572": "   * TimeoutException} wrapped in an {@link ExecutionException}) if the specified duration expires.\n",
        "585": "  public static <V> ListenableFuture<V> withTimeout(\n",
        "586": "      ListenableFuture<V> delegate,\n",
        "587": "      long time,\n",
        "588": "      TimeUnit unit,\n",
        "589": "      ScheduledExecutorService scheduledExecutor) {\n",
        "594": "   * Returns a new {@code ListenableFuture} whose result is asynchronously derived from the result\n",
        "595": "   * of the given {@code Future}. More precisely, the returned {@code Future} takes its result from\n",
        "596": "   * a {@code Future} produced by applying the given {@code AsyncFunction} to the result of the\n",
        "597": "   * original {@code Future}. Example:\n",
        "610": "   * <p>This overload, which does not accept an executor, uses {@code directExecutor}, a dangerous\n",
        "611": "   * choice in some cases. See the discussion in the {@link ListenableFuture#addListener\n",
        "612": "   * ListenableFuture.addListener} documentation. The documentation's warnings about \"lightweight\n",
        "613": "   * listeners\" refer here to the work done during {@code AsyncFunction.apply}, not to any work done\n",
        "614": "   * to complete the returned {@code Future}.\n",
        "616": "   * <p>The returned {@code Future} attempts to keep its cancellation state in sync with that of the\n",
        "617": "   * input future and that of the future returned by the function. That is, if the returned {@code\n",
        "618": "   * Future} is cancelled, it will attempt to cancel the other two, and if either of the other two\n",
        "619": "   * is cancelled, the returned {@code Future} will receive a callback in which it will attempt to\n",
        "620": "   * cancel itself.\n",
        "623": "   * @param function A function to transform the result of the input future to the result of the\n",
        "624": "   *     output future\n",
        "625": "   * @return A future that holds result of the function (if the input succeeded) or the original\n",
        "626": "   *     input's failure (if not)\n",
        "628": "   * @deprecated These {@code AsyncFunction} overloads of {@code transform} are being renamed to\n",
        "629": "   *     {@code transformAsync}. (The {@code Function} overloads are keeping the \"transform\" name.)\n",
        "630": "   *     This method will be removed in Guava release 20.0.\n",
        "633": "  public static <I, O> ListenableFuture<O> transform(\n",
        "634": "      ListenableFuture<I> input, AsyncFunction<? super I, ? extends O> function) {\n",
        "639": "   * Returns a new {@code ListenableFuture} whose result is asynchronously derived from the result\n",
        "640": "   * of the given {@code Future}. More precisely, the returned {@code Future} takes its result from\n",
        "641": "   * a {@code Future} produced by applying the given {@code AsyncFunction} to the result of the\n",
        "642": "   * original {@code Future}. Example:\n",
        "655": "   * <p>When selecting an executor, note that {@code directExecutor} is dangerous in some cases. See\n",
        "656": "   * the discussion in the {@link ListenableFuture#addListener ListenableFuture.addListener}\n",
        "657": "   * documentation. The documentation's warnings about \"lightweight listeners\" refer here to the\n",
        "658": "   * work done during {@code AsyncFunction.apply}, not to any work done to complete the returned\n",
        "659": "   * {@code Future}.\n",
        "661": "   * <p>The returned {@code Future} attempts to keep its cancellation state in sync with that of the\n",
        "662": "   * input future and that of the future returned by the chain function. That is, if the returned\n",
        "663": "   * {@code Future} is cancelled, it will attempt to cancel the other two, and if either of the\n",
        "664": "   * other two is cancelled, the returned {@code Future} will receive a callback in which it will\n",
        "665": "   * attempt to cancel itself.\n",
        "668": "   * @param function A function to transform the result of the input future to the result of the\n",
        "669": "   *     output future\n",
        "671": "   * @return A future that holds result of the function (if the input succeeded) or the original\n",
        "672": "   *     input's failure (if not)\n",
        "674": "   * @deprecated These {@code AsyncFunction} overloads of {@code transform} are being renamed to\n",
        "675": "   *     {@code transformAsync}. (The {@code Function} overloads are keeping the \"transform\" name.)\n",
        "676": "   *     This method will be removed in Guava release 20.0.\n",
        "679": "  public static <I, O> ListenableFuture<O> transform(\n",
        "680": "      ListenableFuture<I> input,\n",
        "764": "  public static <I, O> ListenableFuture<O> transformAsync(\n",
        "765": "      ListenableFuture<I> input,\n",
        "766": "      AsyncFunction<? super I, ? extends O> function,\n",
        "767": "      Executor executor) {\n",
        "772": "   * Returns a new {@code ListenableFuture} whose result is the product of applying the given {@code\n",
        "773": "   * Function} to the result of the given {@code Future}. Example:\n",
        "786": "   * <p>This overload, which does not accept an executor, uses {@code directExecutor}, a dangerous\n",
        "787": "   * choice in some cases. See the discussion in the {@link ListenableFuture#addListener\n",
        "788": "   * ListenableFuture.addListener} documentation. The documentation's warnings about \"lightweight\n",
        "789": "   * listeners\" refer here to the work done during {@code Function.apply}.\n",
        "791": "   * <p>The returned {@code Future} attempts to keep its cancellation state in sync with that of the\n",
        "792": "   * input future. That is, if the returned {@code Future} is cancelled, it will attempt to cancel\n",
        "793": "   * the input, and if the input is cancelled, the returned {@code Future} will receive a callback\n",
        "794": "   * in which it will attempt to cancel itself.\n",
        "796": "   * <p>An example use of this method is to convert a serializable object returned from an RPC into\n",
        "797": "   * a POJO.\n",
        "800": "   * @param function A Function to transform the results of the provided future to the results of\n",
        "801": "   *     the returned future.  This will be run in the thread that notifies input it is complete.\n",
        "811": "   * Returns a new {@code ListenableFuture} whose result is the product of applying the given {@code\n",
        "812": "   * Function} to the result of the given {@code Future}. Example:\n",
        "825": "   * <p>When selecting an executor, note that {@code directExecutor} is dangerous in some cases. See\n",
        "826": "   * the discussion in the {@link ListenableFuture#addListener ListenableFuture.addListener}\n",
        "827": "   * documentation. The documentation's warnings about \"lightweight listeners\" refer here to the\n",
        "828": "   * work done during {@code Function.apply}.\n",
        "830": "   * <p>The returned {@code Future} attempts to keep its cancellation state in sync with that of the\n",
        "831": "   * input future. That is, if the returned {@code Future} is cancelled, it will attempt to cancel\n",
        "832": "   * the input, and if the input is cancelled, the returned {@code Future} will receive a callback\n",
        "833": "   * in which it will attempt to cancel itself.\n",
        "835": "   * <p>An example use of this method is to convert a serializable object returned from an RPC into\n",
        "836": "   * a POJO.\n",
        "839": "   * @param function A Function to transform the results of the provided future to the results of\n",
        "840": "   *     the returned future.\n",
        "851": "   * Like {@link #transform(ListenableFuture, Function)} except that the transformation {@code\n",
        "852": "   * function} is invoked on each call to {@link Future#get() get()} on the returned future.\n",
        "854": "   * <p>The returned {@code Future} reflects the input's cancellation state directly, and any\n",
        "855": "   * attempt to cancel the returned Future is likewise passed through to the input Future.\n",
        "857": "   * <p>Note that calls to {@linkplain Future#get(long, TimeUnit) timed get} only apply the timeout\n",
        "858": "   * to the execution of the underlying {@code Future}, <em>not</em> to the execution of the\n",
        "859": "   * transformation function.\n",
        "861": "   * <p>The primary audience of this method is callers of {@code transform} who don't have a {@code\n",
        "862": "   * ListenableFuture} available and do not mind repeated, lazy function evaluation.\n",
        "865": "   * @param function A Function to transform the results of the provided future to the results of\n",
        "866": "   *     the returned future.\n",
        "872": "  public static <I, O> Future<O> lazyTransform(\n",
        "873": "      final Future<I> input, final Function<? super I, ? extends O> function) {\n",
        "915": "   * Returns a new {@code ListenableFuture} whose result is the product of calling {@code get()} on\n",
        "916": "   * the {@code Future} nested within the given {@code Future}, effectively chaining the futures one\n",
        "917": "   * after the other.  Example:\n",
        "924": "   * #transform(ListenableFuture, AsyncFunction)}, in that the returned {@code Future} attempts to\n",
        "925": "   * keep its cancellation state in sync with both the input {@code Future} and the nested {@code\n",
        "926": "   * Future}.  The transformation is very lightweight and therefore takes place in the same thread\n",
        "927": "   * (either the thread that called {@code dereference}, or the thread in which the dereferenced\n",
        "928": "   * future completes).\n",
        "946": "        @Override\n",
        "947": "        public ListenableFuture<Object> apply(ListenableFuture<Object> input) {\n",
        "953": "   * Creates a new {@code ListenableFuture} whose value is a list containing the values of all its\n",
        "954": "   * input futures, if all succeed. If any input fails, the returned future fails immediately.\n",
        "958": "   * <p>Canceling this future will attempt to cancel all the component futures, and if any of the\n",
        "959": "   * provided futures fails or is canceled, this one is, too.\n",
        "962": "   * @return a future that provides a list of the results of the component futures\n",
        "968": "  public static <V> ListenableFuture<List<V>> allAsList(ListenableFuture<? extends V>... futures) {\n",
        "973": "   * Creates a new {@code ListenableFuture} whose value is a list containing the values of all its\n",
        "974": "   * input futures, if all succeed. If any input fails, the returned future fails immediately.\n",
        "978": "   * <p>Canceling this future will attempt to cancel all the component futures, and if any of the\n",
        "979": "   * provided futures fails or is canceled, this one is, too.\n",
        "982": "   * @return a future that provides a list of the results of the component futures\n",
        "993": "   * Creates a new {@code ListenableFuture} whose result is set from the supplied future when it\n",
        "994": "   * completes.  Cancelling the supplied future will also cancel the returned future, but cancelling\n",
        "995": "   * the returned future will have no effect on the supplied future.\n",
        "1001": "  public static <V> ListenableFuture<V> nonCancellationPropagating(ListenableFuture<V> future) {\n",
        "1012": "      delegate.addListener(\n",
        "1013": "          new Runnable() {\n",
        "1014": "            @Override\n",
        "1015": "            public void run() {\n",
        "1016": "              // This prevents cancellation from propagating because we don't assign delegate until\n",
        "1017": "              // delegate is already done, so calling cancel() on it is a no-op.\n",
        "1018": "              setFuture(delegate);\n",
        "1019": "            }\n",
        "1020": "          },\n",
        "1021": "          directExecutor());\n",
        "1026": "   * Creates a new {@code ListenableFuture} whose value is a list containing the values of all its\n",
        "1027": "   * successful input futures. The list of results is in the same order as the input list, and if\n",
        "1028": "   * any of the provided futures fails or is canceled, its corresponding position will contain\n",
        "1029": "   * {@code null} (which is indistinguishable from the future having a successful value of {@code\n",
        "1030": "   * null}).\n",
        "1035": "   * @return a future that provides a list of the results of the component futures\n",
        "1047": "   * Creates a new {@code ListenableFuture} whose value is a list containing the values of all its\n",
        "1048": "   * successful input futures. The list of results is in the same order as the input list, and if\n",
        "1049": "   * any of the provided futures fails or is canceled, its corresponding position will contain\n",
        "1050": "   * {@code null} (which is indistinguishable from the future having a successful value of {@code\n",
        "1051": "   * null}).\n",
        "1056": "   * @return a future that provides a list of the results of the component futures\n",
        "1086": "    final ConcurrentLinkedQueue<SettableFuture<T>> delegates = Queues.newConcurrentLinkedQueue();\n",
        "1103": "      future.addListener(\n",
        "1104": "          new Runnable() {\n",
        "1105": "            @Override\n",
        "1106": "            public void run() {\n",
        "1107": "              delegates.remove().setFuture(future);\n",
        "1108": "            }\n",
        "1109": "          },\n",
        "1110": "          executor);\n",
        "1117": "   * Registers separate success and failure callbacks to be run when the {@code Future}'s\n",
        "1118": "   * computation is {@linkplain java.util.concurrent.Future#isDone() complete} or, if the\n",
        "1119": "   * computation is already complete, immediately.\n",
        "1121": "   * <p>There is no guaranteed ordering of execution of callbacks, but any callback added through\n",
        "1122": "   * this method is guaranteed to be called once the computation is complete.\n",
        "1136": "   * <p>This overload, which does not accept an executor, uses {@code directExecutor}, a dangerous\n",
        "1137": "   * choice in some cases. See the discussion in the {@link ListenableFuture#addListener\n",
        "1138": "   * ListenableFuture.addListener} documentation.\n",
        "1140": "   * <p>For a more general interface to attach a completion listener to a {@code Future}, see {@link\n",
        "1141": "   * ListenableFuture#addListener addListener}.\n",
        "1147": "  public static <V> void addCallback(\n",
        "1148": "      ListenableFuture<V> future, FutureCallback<? super V> callback) {\n",
        "1153": "   * Registers separate success and failure callbacks to be run when the {@code Future}'s\n",
        "1154": "   * computation is {@linkplain java.util.concurrent.Future#isDone() complete} or, if the\n",
        "1155": "   * computation is already complete, immediately.\n",
        "1157": "   * <p>The callback is run in {@code executor}. There is no guaranteed ordering of execution of\n",
        "1158": "   * callbacks, but any callback added through this method is guaranteed to be called once the\n",
        "1174": "   * <p>When selecting an executor, note that {@code directExecutor} is dangerous in some cases. See\n",
        "1175": "   * the discussion in the {@link ListenableFuture#addListener ListenableFuture.addListener}\n",
        "1176": "   * documentation.\n",
        "1178": "   * <p>For a more general interface to attach a completion listener to a {@code Future}, see {@link\n",
        "1179": "   * ListenableFuture#addListener addListener}.\n",
        "1183": "   * @param executor The executor to run {@code callback} when the future completes.\n",
        "1186": "  public static <V> void addCallback(\n",
        "1187": "      final ListenableFuture<V> future,\n",
        "1188": "      final FutureCallback<? super V> callback,\n",
        "1189": "      Executor executor) {\n",
        "1191": "    Runnable callbackListener =\n",
        "1192": "        new Runnable() {\n",
        "1193": "          @Override\n",
        "1194": "          public void run() {\n",
        "1195": "            final V value;\n",
        "1196": "            try {\n",
        "1197": "              // TODO(user): (Before Guava release), validate that this\n",
        "1198": "              // is the thing for IE.\n",
        "1199": "              value = getUninterruptibly(future);\n",
        "1200": "            } catch (ExecutionException e) {\n",
        "1201": "              callback.onFailure(e.getCause());\n",
        "1202": "              return;\n",
        "1203": "            } catch (RuntimeException e) {\n",
        "1204": "              callback.onFailure(e);\n",
        "1205": "              return;\n",
        "1206": "            } catch (Error e) {\n",
        "1207": "              callback.onFailure(e);\n",
        "1208": "              return;\n",
        "1209": "            }\n",
        "1210": "            callback.onSuccess(value);\n",
        "1211": "          }\n",
        "1212": "        };\n",
        "1217": "   * Returns the result of {@link Future#get()}, converting most exceptions to a new instance of the\n",
        "1218": "   * given checked exception type. This reduces boilerplate for a common use of {@code Future} in\n",
        "1219": "   * which it is unnecessary to programmatically distinguish between exception types or to extract\n",
        "1220": "   * other information from the exception instance.\n",
        "1224": "   * <li>Any {@link ExecutionException} has its <i>cause</i> wrapped in an {@code X} if the cause is\n",
        "1225": "   *     a checked exception, an {@link UncheckedExecutionException} if the cause is a {@code\n",
        "1226": "   *     RuntimeException}, or an {@link ExecutionError} if the cause is an {@code Error}.\n",
        "1227": "   * <li>Any {@link InterruptedException} is wrapped in an {@code X} (after restoring the\n",
        "1228": "   *     interrupt).\n",
        "1229": "   * <li>Any {@link CancellationException} is propagated untouched, as is any other {@link\n",
        "1230": "   *     RuntimeException} (though {@code get} implementations are discouraged from throwing such\n",
        "1231": "   *     exceptions).\n",
        "1234": "   * <p>The overall principle is to continue to treat every checked exception as a checked\n",
        "1235": "   * exception, every unchecked exception as an unchecked exception, and every error as an error. In\n",
        "1236": "   * addition, the cause of any {@code ExecutionException} is wrapped in order to ensure that the\n",
        "1237": "   * new stack trace matches that of the current thread.\n",
        "1238": "   *\n",
        "1239": "   * <p>Instances of {@code exceptionClass} are created by choosing an arbitrary public constructor\n",
        "1240": "   * that accepts zero or more arguments, all of type {@code String} or {@code Throwable}\n",
        "1241": "   * (preferring constructors with at least one {@code String}) and calling the constructor via\n",
        "1242": "   * reflection. If the exception did not already have a cause, one is set by calling {@link\n",
        "1243": "   * Throwable#initCause(Throwable)} on it. If no such constructor exists, an {@code\n",
        "1244": "   * IllegalArgumentException} is thrown.\n",
        "1245": "   *\n",
        "1246": "   * @throws X if {@code get} throws any checked exception except for an {@code ExecutionException}\n",
        "1247": "   *     whose cause is not itself a checked exception\n",
        "1248": "   * @throws UncheckedExecutionException if {@code get} throws an {@code ExecutionException} with a\n",
        "1249": "   *     {@code RuntimeException} as its cause\n",
        "1250": "   * @throws ExecutionError if {@code get} throws an {@code ExecutionException} with an {@code\n",
        "1251": "   *     Error} as its cause\n",
        "1252": "   * @throws CancellationException if {@code get} throws a {@code CancellationException}\n",
        "1253": "   * @throws IllegalArgumentException if {@code exceptionClass} extends {@code RuntimeException} or\n",
        "1254": "   *     does not have a suitable constructor\n",
        "1256": "   * @deprecated Use {@link #getChecked(Future, Class)}. This method will be removed in Guava\n",
        "1257": "   *     release 20.0.\n",
        "1261": "  public static <V, X extends Exception> V get(Future<V> future, Class<X> exceptionClass) throws X {\n",
        "1266": "   * Returns the result of {@link Future#get(long, TimeUnit)}, converting most exceptions to a new\n",
        "1267": "   * instance of the given checked exception type. This reduces boilerplate for a common use of\n",
        "1268": "   * {@code Future} in which it is unnecessary to programmatically distinguish between exception\n",
        "1269": "   * types or to extract other information from the exception instance.\n",
        "1273": "   * <li>Any {@link ExecutionException} has its <i>cause</i> wrapped in an {@code X} if the cause is\n",
        "1274": "   *     a checked exception, an {@link UncheckedExecutionException} if the cause is a {@code\n",
        "1275": "   *     RuntimeException}, or an {@link ExecutionError} if the cause is an {@code Error}.\n",
        "1276": "   * <li>Any {@link InterruptedException} is wrapped in an {@code X} (after restoring the\n",
        "1277": "   *     interrupt).\n",
        "1279": "   * <li>Any {@link CancellationException} is propagated untouched, as is any other {@link\n",
        "1280": "   *     RuntimeException} (though {@code get} implementations are discouraged from throwing such\n",
        "1281": "   *     exceptions).\n",
        "1284": "   * <p>The overall principle is to continue to treat every checked exception as a checked\n",
        "1285": "   * exception, every unchecked exception as an unchecked exception, and every error as an error. In\n",
        "1286": "   * addition, the cause of any {@code ExecutionException} is wrapped in order to ensure that the\n",
        "1287": "   * new stack trace matches that of the current thread.\n",
        "1288": "   *\n",
        "1289": "   * <p>Instances of {@code exceptionClass} are created by choosing an arbitrary public constructor\n",
        "1290": "   * that accepts zero or more arguments, all of type {@code String} or {@code Throwable}\n",
        "1291": "   * (preferring constructors with at least one {@code String}) and calling the constructor via\n",
        "1292": "   * reflection. If the exception did not already have a cause, one is set by calling {@link\n",
        "1293": "   * Throwable#initCause(Throwable)} on it. If no such constructor exists, an {@code\n",
        "1294": "   * IllegalArgumentException} is thrown.\n",
        "1295": "   *\n",
        "1296": "   * @throws X if {@code get} throws any checked exception except for an {@code ExecutionException}\n",
        "1297": "   *     whose cause is not itself a checked exception\n",
        "1298": "   * @throws UncheckedExecutionException if {@code get} throws an {@code ExecutionException} with a\n",
        "1299": "   *     {@code RuntimeException} as its cause\n",
        "1300": "   * @throws ExecutionError if {@code get} throws an {@code ExecutionException} with an {@code\n",
        "1301": "   *     Error} as its cause\n",
        "1302": "   * @throws CancellationException if {@code get} throws a {@code CancellationException}\n",
        "1303": "   * @throws IllegalArgumentException if {@code exceptionClass} extends {@code RuntimeException} or\n",
        "1304": "   *     does not have a suitable constructor\n",
        "1306": "   * @deprecated Use {@link #getChecked(Future, Class, long, TimeUnit)}, noting the change in\n",
        "1307": "   *     parameter order. This method will be removed in Guava release 20.0.\n",
        "1312": "      Future<V> future, long timeout, TimeUnit unit, Class<X> exceptionClass) throws X {\n",
        "1317": "   * Returns the result of {@link Future#get()}, converting most exceptions to a new instance of the\n",
        "1318": "   * given checked exception type. This reduces boilerplate for a common use of {@code Future} in\n",
        "1319": "   * which it is unnecessary to programmatically distinguish between exception types or to extract\n",
        "1320": "   * other information from the exception instance.\n",
        "1324": "   * <li>Any {@link ExecutionException} has its <i>cause</i> wrapped in an {@code X} if the cause is\n",
        "1325": "   *     a checked exception, an {@link UncheckedExecutionException} if the cause is a {@code\n",
        "1326": "   *     RuntimeException}, or an {@link ExecutionError} if the cause is an {@code Error}.\n",
        "1327": "   * <li>Any {@link InterruptedException} is wrapped in an {@code X} (after restoring the\n",
        "1328": "   *     interrupt).\n",
        "1329": "   * <li>Any {@link CancellationException} is propagated untouched, as is any other {@link\n",
        "1330": "   *     RuntimeException} (though {@code get} implementations are discouraged from throwing such\n",
        "1331": "   *     exceptions).\n",
        "1334": "   * <p>The overall principle is to continue to treat every checked exception as a checked\n",
        "1335": "   * exception, every unchecked exception as an unchecked exception, and every error as an error. In\n",
        "1336": "   * addition, the cause of any {@code ExecutionException} is wrapped in order to ensure that the\n",
        "1337": "   * new stack trace matches that of the current thread.\n",
        "1338": "   *\n",
        "1339": "   * <p>Instances of {@code exceptionClass} are created by choosing an arbitrary public constructor\n",
        "1340": "   * that accepts zero or more arguments, all of type {@code String} or {@code Throwable}\n",
        "1341": "   * (preferring constructors with at least one {@code String}) and calling the constructor via\n",
        "1342": "   * reflection. If the exception did not already have a cause, one is set by calling {@link\n",
        "1343": "   * Throwable#initCause(Throwable)} on it. If no such constructor exists, an {@code\n",
        "1344": "   * IllegalArgumentException} is thrown.\n",
        "1345": "   *\n",
        "1346": "   * @throws X if {@code get} throws any checked exception except for an {@code ExecutionException}\n",
        "1347": "   *     whose cause is not itself a checked exception\n",
        "1348": "   * @throws UncheckedExecutionException if {@code get} throws an {@code ExecutionException} with a\n",
        "1349": "   *     {@code RuntimeException} as its cause\n",
        "1350": "   * @throws ExecutionError if {@code get} throws an {@code ExecutionException} with an {@code\n",
        "1351": "   *     Error} as its cause\n",
        "1352": "   * @throws CancellationException if {@code get} throws a {@code CancellationException}\n",
        "1353": "   * @throws IllegalArgumentException if {@code exceptionClass} extends {@code RuntimeException} or\n",
        "1354": "   *     does not have a suitable constructor\n",
        "1358": "  public static <V, X extends Exception> V getChecked(Future<V> future, Class<X> exceptionClass)\n",
        "1359": "      throws X {\n",
        "1364": "   * Returns the result of {@link Future#get(long, TimeUnit)}, converting most exceptions to a new\n",
        "1365": "   * instance of the given checked exception type. This reduces boilerplate for a common use of\n",
        "1366": "   * {@code Future} in which it is unnecessary to programmatically distinguish between exception\n",
        "1367": "   * types or to extract other information from the exception instance.\n",
        "1371": "   * <li>Any {@link ExecutionException} has its <i>cause</i> wrapped in an {@code X} if the cause is\n",
        "1372": "   *     a checked exception, an {@link UncheckedExecutionException} if the cause is a {@code\n",
        "1373": "   *     RuntimeException}, or an {@link ExecutionError} if the cause is an {@code Error}.\n",
        "1374": "   * <li>Any {@link InterruptedException} is wrapped in an {@code X} (after restoring the\n",
        "1375": "   *     interrupt).\n",
        "1377": "   * <li>Any {@link CancellationException} is propagated untouched, as is any other {@link\n",
        "1378": "   *     RuntimeException} (though {@code get} implementations are discouraged from throwing such\n",
        "1379": "   *     exceptions).\n",
        "1382": "   * <p>The overall principle is to continue to treat every checked exception as a checked\n",
        "1383": "   * exception, every unchecked exception as an unchecked exception, and every error as an error. In\n",
        "1384": "   * addition, the cause of any {@code ExecutionException} is wrapped in order to ensure that the\n",
        "1385": "   * new stack trace matches that of the current thread.\n",
        "1386": "   *\n",
        "1387": "   * <p>Instances of {@code exceptionClass} are created by choosing an arbitrary public constructor\n",
        "1388": "   * that accepts zero or more arguments, all of type {@code String} or {@code Throwable}\n",
        "1389": "   * (preferring constructors with at least one {@code String}) and calling the constructor via\n",
        "1390": "   * reflection. If the exception did not already have a cause, one is set by calling {@link\n",
        "1391": "   * Throwable#initCause(Throwable)} on it. If no such constructor exists, an {@code\n",
        "1392": "   * IllegalArgumentException} is thrown.\n",
        "1393": "   *\n",
        "1394": "   * @throws X if {@code get} throws any checked exception except for an {@code ExecutionException}\n",
        "1395": "   *     whose cause is not itself a checked exception\n",
        "1396": "   * @throws UncheckedExecutionException if {@code get} throws an {@code ExecutionException} with a\n",
        "1397": "   *     {@code RuntimeException} as its cause\n",
        "1398": "   * @throws ExecutionError if {@code get} throws an {@code ExecutionException} with an {@code\n",
        "1399": "   *     Error} as its cause\n",
        "1400": "   * @throws CancellationException if {@code get} throws a {@code CancellationException}\n",
        "1401": "   * @throws IllegalArgumentException if {@code exceptionClass} extends {@code RuntimeException} or\n",
        "1402": "   *     does not have a suitable constructor\n",
        "1407": "      Future<V> future, Class<X> exceptionClass, long timeout, TimeUnit unit) throws X {\n",
        "1412": "   * Returns the result of calling {@link Future#get()} uninterruptibly on a task known not to throw\n",
        "1413": "   * a checked exception. This makes {@code Future} more suitable for lightweight, fast-running\n",
        "1414": "   * tasks that, barring bugs in the code, will not fail. This gives it exception-handling behavior\n",
        "1415": "   * similar to that of {@code ForkJoinTask.join}.\n",
        "1419": "   * <li>Any {@link ExecutionException} has its <i>cause</i> wrapped in an {@link\n",
        "1420": "   *     UncheckedExecutionException} (if the cause is an {@code Exception}) or {@link\n",
        "1421": "   *     ExecutionError} (if the cause is an {@code Error}).\n",
        "1422": "   * <li>Any {@link InterruptedException} causes a retry of the {@code get} call. The interrupt is\n",
        "1423": "   *     restored before {@code getUnchecked} returns.\n",
        "1424": "   * <li>Any {@link CancellationException} is propagated untouched. So is any other {@link\n",
        "1425": "   *     RuntimeException} ({@code get} implementations are discouraged from throwing such\n",
        "1426": "   *     exceptions).\n",
        "1429": "   * <p>The overall principle is to eliminate all checked exceptions: to loop to avoid {@code\n",
        "1430": "   * InterruptedException}, to pass through {@code CancellationException}, and to wrap any exception\n",
        "1431": "   * from the underlying computation in an {@code UncheckedExecutionException} or {@code\n",
        "1434": "   * <p>For an uninterruptible {@code get} that preserves other exceptions, see {@link\n",
        "1435": "   * Uninterruptibles#getUninterruptibly(Future)}.\n",
        "1437": "   * @throws UncheckedExecutionException if {@code get} throws an {@code ExecutionException} with an\n",
        "1438": "   *     {@code Exception} as its cause\n",
        "1439": "   * @throws ExecutionError if {@code get} throws an {@code ExecutionException} with an {@code\n",
        "1440": "   *     Error} as its cause\n",
        "1441": "   * @throws CancellationException if {@code get} throws a {@code CancellationException}\n",
        "1461": "     * It's a non-Error, non-Exception Throwable. From my survey of such classes, I believe that\n",
        "1462": "     * most users intended to extend Exception, so we'll treat it like an Exception.\n",
        "1468": "   * Arguably we don't need a timed getUnchecked because any operation slow enough to require a\n",
        "1469": "   * timeout is heavyweight enough to throw a checked exception and therefore be inappropriate to\n",
        "1470": "   * use with getUnchecked. Further, it's not clear that converting the checked TimeoutException to\n",
        "1471": "   * a RuntimeException -- especially to an UncheckedExecutionException, since it wasn't thrown by\n",
        "1472": "   * the computation -- makes sense, and if we don't convert it, the user still has to write a\n",
        "1473": "   * try-catch block.\n",
        "1474": "   *\n",
        "1475": "   * If you think you would use this method, let us know. You might also also look into the\n",
        "1476": "   * Fork-Join framework: http://docs.oracle.com/javase/tutorial/essential/concurrency/forkjoin.html\n",
        "1480": "   * A checked future that uses a function to map from exceptions to the appropriate checked type.\n",
        "1483": "  private static class MappingCheckedFuture<V, X extends Exception>\n",
        "1484": "      extends AbstractCheckedFuture<V, X> {\n",
        "1488": "    MappingCheckedFuture(ListenableFuture<V> delegate, Function<? super Exception, X> mapper) {\n"
    },
    "removed": {
        "4": " * Licensed under the Apache License, Version 2.0 (the \"License\");\n",
        "5": " * you may not use this file except in compliance with the License.\n",
        "6": " * You may obtain a copy of the License at\n",
        "10": " * Unless required by applicable law or agreed to in writing, software\n",
        "11": " * distributed under the License is distributed on an \"AS IS\" BASIS,\n",
        "12": " * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n",
        "13": " * See the License for the specific language governing permissions and\n",
        "14": " * limitations under the License.\n",
        "125": "   * <p>The given mapping function will be applied to an\n",
        "126": "   * {@link InterruptedException}, a {@link CancellationException}, or an\n",
        "127": "   * {@link ExecutionException}.\n",
        "128": "   * See {@link Future#get()} for details on the exceptions thrown.\n",
        "140": "   * Creates a {@code ListenableFuture} which has its value set immediately upon\n",
        "141": "   * construction. The getters just return the value. This {@code Future} can't\n",
        "142": "   * be canceled or timed out and its {@code isDone()} method always returns\n",
        "143": "   * {@code true}.\n",
        "157": "   * Returns a {@code CheckedFuture} which has its value set immediately upon\n",
        "158": "   * construction.\n",
        "160": "   * <p>The returned {@code Future} can't be cancelled, and its {@code isDone()}\n",
        "161": "   * method always returns {@code true}. Calling {@code get()} or {@code\n",
        "162": "   * checkedGet()} will immediately return the provided value.\n",
        "166": "  public static <V, X extends Exception> CheckedFuture<V, X>\n",
        "167": "      immediateCheckedFuture(@Nullable V value) {\n",
        "172": "   * Returns a {@code ListenableFuture} which has an exception set immediately\n",
        "173": "   * upon construction.\n",
        "175": "   * <p>The returned {@code Future} can't be cancelled, and its {@code isDone()}\n",
        "176": "   * method always returns {@code true}. Calling {@code get()} will immediately\n",
        "177": "   * throw the provided {@code Throwable} wrapped in an {@code\n",
        "178": "   * ExecutionException}.\n",
        "181": "  public static <V> ListenableFuture<V> immediateFailedFuture(\n",
        "182": "      Throwable throwable) {\n",
        "188": "   * Creates a {@code ListenableFuture} which is cancelled immediately upon\n",
        "189": "   * construction, so that {@code isCancelled()} always returns {@code true}.\n",
        "200": "   * Returns a {@code CheckedFuture} which has an exception set immediately upon\n",
        "201": "   * construction.\n",
        "202": "   *\n",
        "203": "   * <p>The returned {@code Future} can't be cancelled, and its {@code isDone()}\n",
        "204": "   * method always returns {@code true}. Calling {@code get()} will immediately\n",
        "205": "   * throw the provided {@code Exception} wrapped in an {@code\n",
        "206": "   * ExecutionException}, and calling {@code checkedGet()} will throw the\n",
        "207": "   * provided exception itself.\n",
        "211": "  public static <V, X extends Exception> CheckedFuture<V, X>\n",
        "212": "      immediateFailedCheckedFuture(X exception) {\n",
        "218": "   * Returns a {@code Future} whose result is taken from the given primary\n",
        "219": "   * {@code input} or, if the primary input fails, from the {@code Future}\n",
        "220": "   * provided by the {@code fallback}. {@link FutureFallback#create} is not\n",
        "221": "   * invoked until the primary input has failed, so if the primary input\n",
        "222": "   * succeeds, it is never invoked. If, during the invocation of {@code\n",
        "223": "   * fallback}, an exception is thrown, this exception is used as the result of\n",
        "224": "   * the output {@code Future}.\n",
        "226": "   * <p>Below is an example of a fallback that returns a default value if an\n",
        "227": "   * exception occurs:\n",
        "243": "   * <p>The fallback can also choose to propagate the original exception when\n",
        "244": "   * desired:\n",
        "261": "   * <p>This overload, which does not accept an executor, uses {@code\n",
        "262": "   * directExecutor}, a dangerous choice in some cases. See the discussion in\n",
        "263": "   * the {@link ListenableFuture#addListener ListenableFuture.addListener}\n",
        "264": "   * documentation. The documentation's warnings about \"lightweight listeners\"\n",
        "265": "   * refer here to the work done during {@code FutureFallback.create}, not to\n",
        "266": "   * any work done to complete the returned {@code Future}.\n",
        "269": "   * @param fallback the {@link FutureFallback} implementation to be called if\n",
        "270": "   *     {@code input} fails\n",
        "272": "   * @deprecated Use {@link #catchingAsync(ListenableFuture, Class,\n",
        "273": "   *     AsyncFunction) catchingAsync(input, Throwable.class,\n",
        "274": "   *     fallbackImplementedAsAnAsyncFunction)}, usually replacing {@code\n",
        "275": "   *     Throwable.class} with the specific type you want to handle. This method\n",
        "281": "      ListenableFuture<? extends V> input,\n",
        "282": "      FutureFallback<? extends V> fallback) {\n",
        "287": "   * Returns a {@code Future} whose result is taken from the given primary\n",
        "288": "   * {@code input} or, if the primary input fails, from the {@code Future}\n",
        "289": "   * provided by the {@code fallback}. {@link FutureFallback#create} is not\n",
        "290": "   * invoked until the primary input has failed, so if the primary input\n",
        "291": "   * succeeds, it is never invoked. If, during the invocation of {@code\n",
        "292": "   * fallback}, an exception is thrown, this exception is used as the result of\n",
        "293": "   * the output {@code Future}.\n",
        "295": "   * <p>Below is an example of a fallback that returns a default value if an\n",
        "296": "   * exception occurs:\n",
        "312": "   * <p>The fallback can also choose to propagate the original exception when\n",
        "313": "   * desired:\n",
        "330": "   * <p>When selecting an executor, note that {@code directExecutor} is\n",
        "331": "   * dangerous in some cases. See the discussion in the {@link\n",
        "332": "   * ListenableFuture#addListener ListenableFuture.addListener} documentation.\n",
        "333": "   * The documentation's warnings about \"lightweight listeners\" refer here to\n",
        "334": "   * the work done during {@code FutureFallback.create}, not to any work done to\n",
        "335": "   * complete the returned {@code Future}.\n",
        "338": "   * @param fallback the {@link FutureFallback} implementation to be called if\n",
        "339": "   *     {@code input} fails\n",
        "340": "   * @param executor the executor that runs {@code fallback} if {@code input}\n",
        "341": "   *     fails\n",
        "343": "   * @deprecated Use {@link #catchingAsync(ListenableFuture, Class,\n",
        "344": "   *     AsyncFunction, Executor) catchingAsync(input, Throwable.class,\n",
        "345": "   *     fallbackImplementedAsAnAsyncFunction, executor)}, usually replacing\n",
        "346": "   *     {@code Throwable.class} with the specific type you want to handle. This method\n",
        "347": "   *     will be removed in Guava release 20.0.\n",
        "353": "      FutureFallback<? extends V> fallback, Executor executor) {\n",
        "354": "    return catchingAsync(\n",
        "355": "        input, Throwable.class, asAsyncFunction(fallback), executor);\n",
        "397": "      ListenableFuture<? extends V> input, Class<X> exceptionType,\n",
        "442": "      ListenableFuture<? extends V> input, Class<X> exceptionType,\n",
        "443": "      Function<? super X, ? extends V> fallback, Executor executor) {\n",
        "506": "      ListenableFuture<? extends V> input, Class<X> exceptionType,\n",
        "571": "      ListenableFuture<? extends V> input, Class<X> exceptionType,\n",
        "572": "      AsyncFunction<? super X, ? extends V> fallback, Executor executor) {\n",
        "582": "        return checkNotNull(fallback.create(t), \"FutureFallback.create returned null instead of a \"\n",
        "583": "            + \"Future. Did you mean to return immediateFuture(null)?\");\n",
        "589": "   * Returns a future that delegates to another but will finish early (via a\n",
        "590": "   * {@link TimeoutException} wrapped in an {@link ExecutionException}) if the\n",
        "591": "   * specified duration expires.\n",
        "604": "  public static <V> ListenableFuture<V> withTimeout(ListenableFuture<V> delegate,\n",
        "605": "      long time, TimeUnit unit, ScheduledExecutorService scheduledExecutor) {\n",
        "610": "   * Returns a new {@code ListenableFuture} whose result is asynchronously\n",
        "611": "   * derived from the result of the given {@code Future}. More precisely, the\n",
        "612": "   * returned {@code Future} takes its result from a {@code Future} produced by\n",
        "613": "   * applying the given {@code AsyncFunction} to the result of the original\n",
        "614": "   * {@code Future}. Example:\n",
        "627": "   * <p>This overload, which does not accept an executor, uses {@code\n",
        "628": "   * directExecutor}, a dangerous choice in some cases. See the discussion in\n",
        "629": "   * the {@link ListenableFuture#addListener ListenableFuture.addListener}\n",
        "630": "   * documentation. The documentation's warnings about \"lightweight listeners\"\n",
        "631": "   * refer here to the work done during {@code AsyncFunction.apply}, not to any\n",
        "632": "   * work done to complete the returned {@code Future}.\n",
        "634": "   * <p>The returned {@code Future} attempts to keep its cancellation state in\n",
        "635": "   * sync with that of the input future and that of the future returned by the\n",
        "636": "   * function. That is, if the returned {@code Future} is cancelled, it will\n",
        "637": "   * attempt to cancel the other two, and if either of the other two is\n",
        "638": "   * cancelled, the returned {@code Future} will receive a callback in which it\n",
        "639": "   * will attempt to cancel itself.\n",
        "642": "   * @param function A function to transform the result of the input future\n",
        "643": "   *     to the result of the output future\n",
        "644": "   * @return A future that holds result of the function (if the input succeeded)\n",
        "645": "   *     or the original input's failure (if not)\n",
        "647": "   * @deprecated These {@code AsyncFunction} overloads of {@code transform} are\n",
        "648": "   *     being renamed to {@code transformAsync}. (The {@code Function}\n",
        "649": "   *     overloads are keeping the \"transform\" name.) This method will be removed in Guava release\n",
        "650": "   *     20.0.\n",
        "653": "  public static <I, O> ListenableFuture<O> transform(ListenableFuture<I> input,\n",
        "654": "      AsyncFunction<? super I, ? extends O> function) {\n",
        "659": "   * Returns a new {@code ListenableFuture} whose result is asynchronously\n",
        "660": "   * derived from the result of the given {@code Future}. More precisely, the\n",
        "661": "   * returned {@code Future} takes its result from a {@code Future} produced by\n",
        "662": "   * applying the given {@code AsyncFunction} to the result of the original\n",
        "663": "   * {@code Future}. Example:\n",
        "676": "   * <p>When selecting an executor, note that {@code directExecutor} is\n",
        "677": "   * dangerous in some cases. See the discussion in the {@link\n",
        "678": "   * ListenableFuture#addListener ListenableFuture.addListener} documentation.\n",
        "679": "   * The documentation's warnings about \"lightweight listeners\" refer here to\n",
        "680": "   * the work done during {@code AsyncFunction.apply}, not to any work done to\n",
        "681": "   * complete the returned {@code Future}.\n",
        "683": "   * <p>The returned {@code Future} attempts to keep its cancellation state in\n",
        "684": "   * sync with that of the input future and that of the future returned by the\n",
        "685": "   * chain function. That is, if the returned {@code Future} is cancelled, it\n",
        "686": "   * will attempt to cancel the other two, and if either of the other two is\n",
        "687": "   * cancelled, the returned {@code Future} will receive a callback in which it\n",
        "688": "   * will attempt to cancel itself.\n",
        "691": "   * @param function A function to transform the result of the input future\n",
        "692": "   *     to the result of the output future\n",
        "694": "   * @return A future that holds result of the function (if the input succeeded)\n",
        "695": "   *     or the original input's failure (if not)\n",
        "697": "   * @deprecated These {@code AsyncFunction} overloads of {@code transform} are\n",
        "698": "   *     being renamed to {@code transformAsync}. (The {@code Function}\n",
        "699": "   *     overloads are keeping the \"transform\" name.) This method will be removed in Guava release\n",
        "700": "   *     20.0.\n",
        "703": "  public static <I, O> ListenableFuture<O> transform(ListenableFuture<I> input,\n",
        "787": "  public static <I, O> ListenableFuture<O> transformAsync(ListenableFuture<I> input,\n",
        "788": "      AsyncFunction<? super I, ? extends O> function, Executor executor) {\n",
        "793": "   * Returns a new {@code ListenableFuture} whose result is the product of\n",
        "794": "   * applying the given {@code Function} to the result of the given {@code\n",
        "795": "   * Future}. Example:\n",
        "808": "   * <p>This overload, which does not accept an executor, uses {@code\n",
        "809": "   * directExecutor}, a dangerous choice in some cases. See the discussion in\n",
        "810": "   * the {@link ListenableFuture#addListener ListenableFuture.addListener}\n",
        "811": "   * documentation. The documentation's warnings about \"lightweight listeners\"\n",
        "812": "   * refer here to the work done during {@code Function.apply}.\n",
        "814": "   * <p>The returned {@code Future} attempts to keep its cancellation state in\n",
        "815": "   * sync with that of the input future. That is, if the returned {@code Future}\n",
        "816": "   * is cancelled, it will attempt to cancel the input, and if the input is\n",
        "817": "   * cancelled, the returned {@code Future} will receive a callback in which it\n",
        "818": "   * will attempt to cancel itself.\n",
        "820": "   * <p>An example use of this method is to convert a serializable object\n",
        "821": "   * returned from an RPC into a POJO.\n",
        "824": "   * @param function A Function to transform the results of the provided future\n",
        "825": "   *     to the results of the returned future.  This will be run in the thread\n",
        "826": "   *     that notifies input it is complete.\n",
        "836": "   * Returns a new {@code ListenableFuture} whose result is the product of\n",
        "837": "   * applying the given {@code Function} to the result of the given {@code\n",
        "838": "   * Future}. Example:\n",
        "851": "   * <p>When selecting an executor, note that {@code directExecutor} is\n",
        "852": "   * dangerous in some cases. See the discussion in the {@link\n",
        "853": "   * ListenableFuture#addListener ListenableFuture.addListener} documentation.\n",
        "854": "   * The documentation's warnings about \"lightweight listeners\" refer here to\n",
        "855": "   * the work done during {@code Function.apply}.\n",
        "857": "   * <p>The returned {@code Future} attempts to keep its cancellation state in\n",
        "858": "   * sync with that of the input future. That is, if the returned {@code Future}\n",
        "859": "   * is cancelled, it will attempt to cancel the input, and if the input is\n",
        "860": "   * cancelled, the returned {@code Future} will receive a callback in which it\n",
        "861": "   * will attempt to cancel itself.\n",
        "863": "   * <p>An example use of this method is to convert a serializable object\n",
        "864": "   * returned from an RPC into a POJO.\n",
        "867": "   * @param function A Function to transform the results of the provided future\n",
        "868": "   *     to the results of the returned future.\n",
        "879": "   * Like {@link #transform(ListenableFuture, Function)} except that the\n",
        "880": "   * transformation {@code function} is invoked on each call to\n",
        "881": "   * {@link Future#get() get()} on the returned future.\n",
        "883": "   * <p>The returned {@code Future} reflects the input's cancellation\n",
        "884": "   * state directly, and any attempt to cancel the returned Future is likewise\n",
        "885": "   * passed through to the input Future.\n",
        "887": "   * <p>Note that calls to {@linkplain Future#get(long, TimeUnit) timed get}\n",
        "888": "   * only apply the timeout to the execution of the underlying {@code Future},\n",
        "889": "   * <em>not</em> to the execution of the transformation function.\n",
        "891": "   * <p>The primary audience of this method is callers of {@code transform}\n",
        "892": "   * who don't have a {@code ListenableFuture} available and\n",
        "893": "   * do not mind repeated, lazy function evaluation.\n",
        "896": "   * @param function A Function to transform the results of the provided future\n",
        "897": "   *     to the results of the returned future.\n",
        "903": "  public static <I, O> Future<O> lazyTransform(final Future<I> input,\n",
        "904": "      final Function<? super I, ? extends O> function) {\n",
        "946": "   * Returns a new {@code ListenableFuture} whose result is the product of\n",
        "947": "   * calling {@code get()} on the {@code Future} nested within the given {@code\n",
        "948": "   * Future}, effectively chaining the futures one after the other.  Example:\n",
        "955": "   * #transform(ListenableFuture, AsyncFunction)}, in that the returned {@code\n",
        "956": "   * Future} attempts to keep its cancellation state in sync with both the\n",
        "957": "   * input {@code Future} and the nested {@code Future}.  The transformation\n",
        "958": "   * is very lightweight and therefore takes place in the same thread (either\n",
        "959": "   * the thread that called {@code dereference}, or the thread in which the\n",
        "960": "   * dereferenced future completes).\n",
        "978": "        @Override public ListenableFuture<Object> apply(ListenableFuture<Object> input) {\n",
        "984": "   * Creates a new {@code ListenableFuture} whose value is a list containing the\n",
        "985": "   * values of all its input futures, if all succeed. If any input fails, the\n",
        "986": "   * returned future fails immediately.\n",
        "990": "   * <p>Canceling this future will attempt to cancel all the component futures,\n",
        "991": "   * and if any of the provided futures fails or is canceled, this one is,\n",
        "992": "   * too.\n",
        "995": "   * @return a future that provides a list of the results of the component\n",
        "996": "   *         futures\n",
        "1002": "  public static <V> ListenableFuture<List<V>> allAsList(\n",
        "1003": "      ListenableFuture<? extends V>... futures) {\n",
        "1008": "   * Creates a new {@code ListenableFuture} whose value is a list containing the\n",
        "1009": "   * values of all its input futures, if all succeed. If any input fails, the\n",
        "1010": "   * returned future fails immediately.\n",
        "1014": "   * <p>Canceling this future will attempt to cancel all the component futures,\n",
        "1015": "   * and if any of the provided futures fails or is canceled, this one is,\n",
        "1016": "   * too.\n",
        "1019": "   * @return a future that provides a list of the results of the component\n",
        "1020": "   *         futures\n",
        "1031": "   * Creates a new {@code ListenableFuture} whose result is set from the\n",
        "1032": "   * supplied future when it completes.  Cancelling the supplied future\n",
        "1033": "   * will also cancel the returned future, but cancelling the returned\n",
        "1034": "   * future will have no effect on the supplied future.\n",
        "1040": "  public static <V> ListenableFuture<V> nonCancellationPropagating(\n",
        "1041": "      ListenableFuture<V> future) {\n",
        "1052": "      delegate.addListener(new Runnable() {\n",
        "1053": "        @Override public void run() {\n",
        "1054": "          // This prevents cancellation from propagating because we don't assign delegate until\n",
        "1055": "          // delegate is already done, so calling cancel() on it is a no-op.\n",
        "1056": "          setFuture(delegate);\n",
        "1057": "        }\n",
        "1058": "      }, directExecutor());\n",
        "1063": "   * Creates a new {@code ListenableFuture} whose value is a list containing the\n",
        "1064": "   * values of all its successful input futures. The list of results is in the\n",
        "1065": "   * same order as the input list, and if any of the provided futures fails or\n",
        "1066": "   * is canceled, its corresponding position will contain {@code null} (which is\n",
        "1067": "   * indistinguishable from the future having a successful value of\n",
        "1068": "   * {@code null}).\n",
        "1073": "   * @return a future that provides a list of the results of the component\n",
        "1074": "   *         futures\n",
        "1086": "   * Creates a new {@code ListenableFuture} whose value is a list containing the\n",
        "1087": "   * values of all its successful input futures. The list of results is in the\n",
        "1088": "   * same order as the input list, and if any of the provided futures fails or\n",
        "1089": "   * is canceled, its corresponding position will contain {@code null} (which is\n",
        "1090": "   * indistinguishable from the future having a successful value of\n",
        "1091": "   * {@code null}).\n",
        "1096": "   * @return a future that provides a list of the results of the component\n",
        "1097": "   *         futures\n",
        "1127": "    final ConcurrentLinkedQueue<SettableFuture<T>> delegates =\n",
        "1128": "        Queues.newConcurrentLinkedQueue();\n",
        "1145": "      future.addListener(new Runnable() {\n",
        "1146": "        @Override public void run() {\n",
        "1147": "          delegates.remove().setFuture(future);\n",
        "1148": "        }\n",
        "1149": "      }, executor);\n",
        "1156": "   * Registers separate success and failure callbacks to be run when the {@code\n",
        "1157": "   * Future}'s computation is {@linkplain java.util.concurrent.Future#isDone()\n",
        "1158": "   * complete} or, if the computation is already complete, immediately.\n",
        "1160": "   * <p>There is no guaranteed ordering of execution of callbacks, but any\n",
        "1161": "   * callback added through this method is guaranteed to be called once the\n",
        "1162": "   * computation is complete.\n",
        "1176": "   * <p>This overload, which does not accept an executor, uses {@code\n",
        "1177": "   * directExecutor}, a dangerous choice in some cases. See the discussion in\n",
        "1178": "   * the {@link ListenableFuture#addListener ListenableFuture.addListener}\n",
        "1179": "   * documentation.\n",
        "1181": "   * <p>For a more general interface to attach a completion listener to a\n",
        "1182": "   * {@code Future}, see {@link ListenableFuture#addListener addListener}.\n",
        "1188": "  public static <V> void addCallback(ListenableFuture<V> future,\n",
        "1189": "      FutureCallback<? super V> callback) {\n",
        "1194": "   * Registers separate success and failure callbacks to be run when the {@code\n",
        "1195": "   * Future}'s computation is {@linkplain java.util.concurrent.Future#isDone()\n",
        "1196": "   * complete} or, if the computation is already complete, immediately.\n",
        "1198": "   * <p>The callback is run in {@code executor}.\n",
        "1199": "   * There is no guaranteed ordering of execution of callbacks, but any\n",
        "1200": "   * callback added through this method is guaranteed to be called once the\n",
        "1216": "   * <p>When selecting an executor, note that {@code directExecutor} is\n",
        "1217": "   * dangerous in some cases. See the discussion in the {@link\n",
        "1218": "   * ListenableFuture#addListener ListenableFuture.addListener} documentation.\n",
        "1220": "   * <p>For a more general interface to attach a completion listener to a\n",
        "1221": "   * {@code Future}, see {@link ListenableFuture#addListener addListener}.\n",
        "1225": "   * @param executor The executor to run {@code callback} when the future\n",
        "1226": "   *    completes.\n",
        "1229": "  public static <V> void addCallback(final ListenableFuture<V> future,\n",
        "1230": "      final FutureCallback<? super V> callback, Executor executor) {\n",
        "1232": "    Runnable callbackListener = new Runnable() {\n",
        "1233": "      @Override\n",
        "1234": "      public void run() {\n",
        "1235": "        final V value;\n",
        "1236": "        try {\n",
        "1237": "          // TODO(user): (Before Guava release), validate that this\n",
        "1238": "          // is the thing for IE.\n",
        "1239": "          value = getUninterruptibly(future);\n",
        "1240": "        } catch (ExecutionException e) {\n",
        "1241": "          callback.onFailure(e.getCause());\n",
        "1242": "          return;\n",
        "1243": "        } catch (RuntimeException e) {\n",
        "1244": "          callback.onFailure(e);\n",
        "1245": "          return;\n",
        "1246": "        } catch (Error e) {\n",
        "1247": "          callback.onFailure(e);\n",
        "1248": "          return;\n",
        "1249": "        }\n",
        "1250": "        callback.onSuccess(value);\n",
        "1251": "      }\n",
        "1252": "    };\n",
        "1257": "   * Returns the result of {@link Future#get()}, converting most exceptions to a\n",
        "1258": "   * new instance of the given checked exception type. This reduces boilerplate\n",
        "1259": "   * for a common use of {@code Future} in which it is unnecessary to\n",
        "1260": "   * programmatically distinguish between exception types or to extract other\n",
        "1261": "   * information from the exception instance.\n",
        "1265": "   * <li>Any {@link ExecutionException} has its <i>cause</i> wrapped in an\n",
        "1266": "   *     {@code X} if the cause is a checked exception, an {@link\n",
        "1267": "   *     UncheckedExecutionException} if the cause is a {@code\n",
        "1268": "   *     RuntimeException}, or an {@link ExecutionError} if the cause is an\n",
        "1269": "   *     {@code Error}.\n",
        "1270": "   * <li>Any {@link InterruptedException} is wrapped in an {@code X} (after\n",
        "1271": "   *     restoring the interrupt).\n",
        "1272": "   * <li>Any {@link CancellationException} is propagated untouched, as is any\n",
        "1273": "   *     other {@link RuntimeException} (though {@code get} implementations are\n",
        "1274": "   *     discouraged from throwing such exceptions).\n",
        "1277": "   * <p>The overall principle is to continue to treat every checked exception as a\n",
        "1278": "   * checked exception, every unchecked exception as an unchecked exception, and\n",
        "1279": "   * every error as an error. In addition, the cause of any {@code\n",
        "1280": "   * ExecutionException} is wrapped in order to ensure that the new stack trace\n",
        "1281": "   * matches that of the current thread.\n",
        "1282": "   *\n",
        "1283": "   * <p>Instances of {@code exceptionClass} are created by choosing an arbitrary\n",
        "1284": "   * public constructor that accepts zero or more arguments, all of type {@code\n",
        "1285": "   * String} or {@code Throwable} (preferring constructors with at least one\n",
        "1286": "   * {@code String}) and calling the constructor via reflection. If the\n",
        "1287": "   * exception did not already have a cause, one is set by calling {@link\n",
        "1288": "   * Throwable#initCause(Throwable)} on it. If no such constructor exists, an\n",
        "1289": "   * {@code IllegalArgumentException} is thrown.\n",
        "1290": "   *\n",
        "1291": "   * @throws X if {@code get} throws any checked exception except for an {@code\n",
        "1292": "   *         ExecutionException} whose cause is not itself a checked exception\n",
        "1293": "   * @throws UncheckedExecutionException if {@code get} throws an {@code\n",
        "1294": "   *         ExecutionException} with a {@code RuntimeException} as its cause\n",
        "1295": "   * @throws ExecutionError if {@code get} throws an {@code ExecutionException}\n",
        "1296": "   *         with an {@code Error} as its cause\n",
        "1297": "   * @throws CancellationException if {@code get} throws a {@code\n",
        "1298": "   *         CancellationException}\n",
        "1299": "   * @throws IllegalArgumentException if {@code exceptionClass} extends {@code\n",
        "1300": "   *         RuntimeException} or does not have a suitable constructor\n",
        "1302": "   * @deprecated Use {@link #getChecked(Future, Class)}. This method will be\n",
        "1303": "   *     removed in Guava release 20.0.\n",
        "1307": "  public static <V, X extends Exception> V get(\n",
        "1308": "      Future<V> future, Class<X> exceptionClass) throws X {\n",
        "1313": "   * Returns the result of {@link Future#get(long, TimeUnit)}, converting most\n",
        "1314": "   * exceptions to a new instance of the given checked exception type. This\n",
        "1315": "   * reduces boilerplate for a common use of {@code Future} in which it is\n",
        "1316": "   * unnecessary to programmatically distinguish between exception types or to\n",
        "1317": "   * extract other information from the exception instance.\n",
        "1321": "   * <li>Any {@link ExecutionException} has its <i>cause</i> wrapped in an\n",
        "1322": "   *     {@code X} if the cause is a checked exception, an {@link\n",
        "1323": "   *     UncheckedExecutionException} if the cause is a {@code\n",
        "1324": "   *     RuntimeException}, or an {@link ExecutionError} if the cause is an\n",
        "1325": "   *     {@code Error}.\n",
        "1326": "   * <li>Any {@link InterruptedException} is wrapped in an {@code X} (after\n",
        "1327": "   *     restoring the interrupt).\n",
        "1329": "   * <li>Any {@link CancellationException} is propagated untouched, as is any\n",
        "1330": "   *     other {@link RuntimeException} (though {@code get} implementations are\n",
        "1331": "   *     discouraged from throwing such exceptions).\n",
        "1334": "   * <p>The overall principle is to continue to treat every checked exception as a\n",
        "1335": "   * checked exception, every unchecked exception as an unchecked exception, and\n",
        "1336": "   * every error as an error. In addition, the cause of any {@code\n",
        "1337": "   * ExecutionException} is wrapped in order to ensure that the new stack trace\n",
        "1338": "   * matches that of the current thread.\n",
        "1339": "   *\n",
        "1340": "   * <p>Instances of {@code exceptionClass} are created by choosing an arbitrary\n",
        "1341": "   * public constructor that accepts zero or more arguments, all of type {@code\n",
        "1342": "   * String} or {@code Throwable} (preferring constructors with at least one\n",
        "1343": "   * {@code String}) and calling the constructor via reflection. If the\n",
        "1344": "   * exception did not already have a cause, one is set by calling {@link\n",
        "1345": "   * Throwable#initCause(Throwable)} on it. If no such constructor exists, an\n",
        "1346": "   * {@code IllegalArgumentException} is thrown.\n",
        "1347": "   *\n",
        "1348": "   * @throws X if {@code get} throws any checked exception except for an {@code\n",
        "1349": "   *         ExecutionException} whose cause is not itself a checked exception\n",
        "1350": "   * @throws UncheckedExecutionException if {@code get} throws an {@code\n",
        "1351": "   *         ExecutionException} with a {@code RuntimeException} as its cause\n",
        "1352": "   * @throws ExecutionError if {@code get} throws an {@code ExecutionException}\n",
        "1353": "   *         with an {@code Error} as its cause\n",
        "1354": "   * @throws CancellationException if {@code get} throws a {@code\n",
        "1355": "   *         CancellationException}\n",
        "1356": "   * @throws IllegalArgumentException if {@code exceptionClass} extends {@code\n",
        "1357": "   *         RuntimeException} or does not have a suitable constructor\n",
        "1359": "   * @deprecated Use {@link #getChecked(Future, Class, long, TimeUnit)}, noting\n",
        "1360": "   *     the change in parameter order. This method will be removed in Guava\n",
        "1361": "   *     release 20.0.\n",
        "1366": "      Future<V> future, long timeout, TimeUnit unit, Class<X> exceptionClass)\n",
        "1367": "      throws X {\n",
        "1372": "   * Returns the result of {@link Future#get()}, converting most exceptions to a\n",
        "1373": "   * new instance of the given checked exception type. This reduces boilerplate\n",
        "1374": "   * for a common use of {@code Future} in which it is unnecessary to\n",
        "1375": "   * programmatically distinguish between exception types or to extract other\n",
        "1376": "   * information from the exception instance.\n",
        "1380": "   * <li>Any {@link ExecutionException} has its <i>cause</i> wrapped in an\n",
        "1381": "   *     {@code X} if the cause is a checked exception, an {@link\n",
        "1382": "   *     UncheckedExecutionException} if the cause is a {@code\n",
        "1383": "   *     RuntimeException}, or an {@link ExecutionError} if the cause is an\n",
        "1384": "   *     {@code Error}.\n",
        "1385": "   * <li>Any {@link InterruptedException} is wrapped in an {@code X} (after\n",
        "1386": "   *     restoring the interrupt).\n",
        "1387": "   * <li>Any {@link CancellationException} is propagated untouched, as is any\n",
        "1388": "   *     other {@link RuntimeException} (though {@code get} implementations are\n",
        "1389": "   *     discouraged from throwing such exceptions).\n",
        "1392": "   * <p>The overall principle is to continue to treat every checked exception as a\n",
        "1393": "   * checked exception, every unchecked exception as an unchecked exception, and\n",
        "1394": "   * every error as an error. In addition, the cause of any {@code\n",
        "1395": "   * ExecutionException} is wrapped in order to ensure that the new stack trace\n",
        "1396": "   * matches that of the current thread.\n",
        "1397": "   *\n",
        "1398": "   * <p>Instances of {@code exceptionClass} are created by choosing an arbitrary\n",
        "1399": "   * public constructor that accepts zero or more arguments, all of type {@code\n",
        "1400": "   * String} or {@code Throwable} (preferring constructors with at least one\n",
        "1401": "   * {@code String}) and calling the constructor via reflection. If the\n",
        "1402": "   * exception did not already have a cause, one is set by calling {@link\n",
        "1403": "   * Throwable#initCause(Throwable)} on it. If no such constructor exists, an\n",
        "1404": "   * {@code IllegalArgumentException} is thrown.\n",
        "1405": "   *\n",
        "1406": "   * @throws X if {@code get} throws any checked exception except for an {@code\n",
        "1407": "   *     ExecutionException} whose cause is not itself a checked exception\n",
        "1408": "   * @throws UncheckedExecutionException if {@code get} throws an {@code\n",
        "1409": "   *     ExecutionException} with a {@code RuntimeException} as its cause\n",
        "1410": "   * @throws ExecutionError if {@code get} throws an {@code ExecutionException}\n",
        "1411": "   *     with an {@code Error} as its cause\n",
        "1412": "   * @throws CancellationException if {@code get} throws a {@code\n",
        "1413": "   *     CancellationException}\n",
        "1414": "   * @throws IllegalArgumentException if {@code exceptionClass} extends {@code\n",
        "1415": "   *     RuntimeException} or does not have a suitable constructor\n",
        "1419": "  public static <V, X extends Exception> V getChecked(\n",
        "1420": "      Future<V> future, Class<X> exceptionClass) throws X {\n",
        "1425": "   * Returns the result of {@link Future#get(long, TimeUnit)}, converting most\n",
        "1426": "   * exceptions to a new instance of the given checked exception type. This\n",
        "1427": "   * reduces boilerplate for a common use of {@code Future} in which it is\n",
        "1428": "   * unnecessary to programmatically distinguish between exception types or to\n",
        "1429": "   * extract other information from the exception instance.\n",
        "1433": "   * <li>Any {@link ExecutionException} has its <i>cause</i> wrapped in an\n",
        "1434": "   *     {@code X} if the cause is a checked exception, an {@link\n",
        "1435": "   *     UncheckedExecutionException} if the cause is a {@code\n",
        "1436": "   *     RuntimeException}, or an {@link ExecutionError} if the cause is an\n",
        "1437": "   *     {@code Error}.\n",
        "1438": "   * <li>Any {@link InterruptedException} is wrapped in an {@code X} (after\n",
        "1439": "   *     restoring the interrupt).\n",
        "1441": "   * <li>Any {@link CancellationException} is propagated untouched, as is any\n",
        "1442": "   *     other {@link RuntimeException} (though {@code get} implementations are\n",
        "1443": "   *     discouraged from throwing such exceptions).\n",
        "1446": "   * <p>The overall principle is to continue to treat every checked exception as a\n",
        "1447": "   * checked exception, every unchecked exception as an unchecked exception, and\n",
        "1448": "   * every error as an error. In addition, the cause of any {@code\n",
        "1449": "   * ExecutionException} is wrapped in order to ensure that the new stack trace\n",
        "1450": "   * matches that of the current thread.\n",
        "1451": "   *\n",
        "1452": "   * <p>Instances of {@code exceptionClass} are created by choosing an arbitrary\n",
        "1453": "   * public constructor that accepts zero or more arguments, all of type {@code\n",
        "1454": "   * String} or {@code Throwable} (preferring constructors with at least one\n",
        "1455": "   * {@code String}) and calling the constructor via reflection. If the\n",
        "1456": "   * exception did not already have a cause, one is set by calling {@link\n",
        "1457": "   * Throwable#initCause(Throwable)} on it. If no such constructor exists, an\n",
        "1458": "   * {@code IllegalArgumentException} is thrown.\n",
        "1459": "   *\n",
        "1460": "   * @throws X if {@code get} throws any checked exception except for an {@code\n",
        "1461": "   *     ExecutionException} whose cause is not itself a checked exception\n",
        "1462": "   * @throws UncheckedExecutionException if {@code get} throws an {@code\n",
        "1463": "   *     ExecutionException} with a {@code RuntimeException} as its cause\n",
        "1464": "   * @throws ExecutionError if {@code get} throws an {@code ExecutionException}\n",
        "1465": "   *     with an {@code Error} as its cause\n",
        "1466": "   * @throws CancellationException if {@code get} throws a {@code\n",
        "1467": "   *     CancellationException}\n",
        "1468": "   * @throws IllegalArgumentException if {@code exceptionClass} extends {@code\n",
        "1469": "   *     RuntimeException} or does not have a suitable constructor\n",
        "1474": "      Future<V> future, Class<X> exceptionClass, long timeout, TimeUnit unit)\n",
        "1475": "      throws X {\n",
        "1480": "   * Returns the result of calling {@link Future#get()} uninterruptibly on a\n",
        "1481": "   * task known not to throw a checked exception. This makes {@code Future} more\n",
        "1482": "   * suitable for lightweight, fast-running tasks that, barring bugs in the\n",
        "1483": "   * code, will not fail. This gives it exception-handling behavior similar to\n",
        "1484": "   * that of {@code ForkJoinTask.join}.\n",
        "1488": "   * <li>Any {@link ExecutionException} has its <i>cause</i> wrapped in an\n",
        "1489": "   *     {@link UncheckedExecutionException} (if the cause is an {@code\n",
        "1490": "   *     Exception}) or {@link ExecutionError} (if the cause is an {@code\n",
        "1491": "   *     Error}).\n",
        "1492": "   * <li>Any {@link InterruptedException} causes a retry of the {@code get}\n",
        "1493": "   *     call. The interrupt is restored before {@code getUnchecked} returns.\n",
        "1494": "   * <li>Any {@link CancellationException} is propagated untouched. So is any\n",
        "1495": "   *     other {@link RuntimeException} ({@code get} implementations are\n",
        "1496": "   *     discouraged from throwing such exceptions).\n",
        "1499": "   * <p>The overall principle is to eliminate all checked exceptions: to loop to\n",
        "1500": "   * avoid {@code InterruptedException}, to pass through {@code\n",
        "1501": "   * CancellationException}, and to wrap any exception from the underlying\n",
        "1502": "   * computation in an {@code UncheckedExecutionException} or {@code\n",
        "1505": "   * <p>For an uninterruptible {@code get} that preserves other exceptions, see\n",
        "1506": "   * {@link Uninterruptibles#getUninterruptibly(Future)}.\n",
        "1508": "   * @throws UncheckedExecutionException if {@code get} throws an {@code\n",
        "1509": "   *         ExecutionException} with an {@code Exception} as its cause\n",
        "1510": "   * @throws ExecutionError if {@code get} throws an {@code ExecutionException}\n",
        "1511": "   *         with an {@code Error} as its cause\n",
        "1512": "   * @throws CancellationException if {@code get} throws a {@code\n",
        "1513": "   *         CancellationException}\n",
        "1533": "     * It's a non-Error, non-Exception Throwable. From my survey of such\n",
        "1534": "     * classes, I believe that most users intended to extend Exception, so we'll\n",
        "1535": "     * treat it like an Exception.\n",
        "1541": "   * Arguably we don't need a timed getUnchecked because any operation slow\n",
        "1542": "   * enough to require a timeout is heavyweight enough to throw a checked\n",
        "1543": "   * exception and therefore be inappropriate to use with getUnchecked. Further,\n",
        "1544": "   * it's not clear that converting the checked TimeoutException to a\n",
        "1545": "   * RuntimeException -- especially to an UncheckedExecutionException, since it\n",
        "1546": "   * wasn't thrown by the computation -- makes sense, and if we don't convert\n",
        "1547": "   * it, the user still has to write a try-catch block.\n",
        "1548": "   *\n",
        "1549": "   * If you think you would use this method, let us know. You might also also\n",
        "1550": "   * look into the Fork-Join framework:\n",
        "1551": "   * http://docs.oracle.com/javase/tutorial/essential/concurrency/forkjoin.html\n",
        "1555": "   * A checked future that uses a function to map from exceptions to the\n",
        "1556": "   * appropriate checked type.\n",
        "1559": "  private static class MappingCheckedFuture<V, X extends Exception> extends\n",
        "1560": "      AbstractCheckedFuture<V, X> {\n",
        "1564": "    MappingCheckedFuture(ListenableFuture<V> delegate,\n",
        "1565": "        Function<? super Exception, X> mapper) {\n"
    }
}