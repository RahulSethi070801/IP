{
    "addition": {
        "4": " * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not use this file except\n",
        "5": " * in compliance with the License. You may obtain a copy of the License at\n",
        "9": " * Unless required by applicable law or agreed to in writing, software distributed under the License\n",
        "10": " * is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express\n",
        "11": " * or implied. See the License for the specific language governing permissions and limitations under\n",
        "12": " * the License.\n",
        "43": "  private static final Logger logger = Logger.getLogger(AggregateFuture.class.getName());\n",
        "47": "  @Override\n",
        "48": "  final void done() {\n",
        "56": "  @Override\n",
        "57": "  public final boolean cancel(boolean mayInterruptIfRunning) {\n",
        "74": "  @Override\n",
        "75": "  protected final void interruptTask() {\n",
        "96": "    RunningState(\n",
        "97": "        ImmutableCollection<? extends ListenableFuture<? extends InputT>> futures,\n",
        "98": "        boolean allMustSucceed,\n",
        "99": "        boolean collectsValues) {\n",
        "107": "    @Override\n",
        "108": "    public final void run() {\n",
        "114": "     * futures are already complete, we would not initialize the subclass before calling {@link\n",
        "115": "     * #handleOneInputDone}. As this is called after the subclass is constructed, we're guaranteed\n",
        "116": "     * to have properly initialized the subclass.\n",
        "125": "      // NOTE: If we ever want to use a custom executor here, have a look at CombinedFuture as we'll\n",
        "126": "      // need to handle RejectedExecutionException\n",
        "132": "        // Register a listener on each Future in the list to update the state of this future.\n",
        "133": "        // Note that if all the futures on the list are done prior to completing this loop, the last\n",
        "134": "        // call to addListener() will callback to setOneValue(), transitively call our cleanup\n",
        "135": "        // listener, and set this.futures to null.\n",
        "136": "        // This is not actually a problem, since the foreach only needs this.futures to be non-null\n",
        "137": "        // at the beginning of the loop.\n",
        "141": "          listenable.addListener(\n",
        "142": "              new Runnable() {\n",
        "143": "                @Override\n",
        "144": "                public void run() {\n",
        "145": "                  try {\n",
        "146": "                    handleOneInputDone(index, listenable);\n",
        "147": "                  } finally {\n",
        "148": "                    decrementCountAndMaybeComplete();\n",
        "149": "                  }\n",
        "150": "                }\n",
        "151": "              },\n",
        "152": "              directExecutor());\n",
        "164": "     * Fails this future with the given Throwable if {@link #allMustSucceed} is true. Also, logs the\n",
        "165": "     * throwable if it is an {@link Error} or if {@link #allMustSucceed} is {@code true}, the\n",
        "166": "     * throwable did not cause this future to fail, and it is the first time we've seen that\n",
        "167": "     * particular Throwable.\n",
        "181": "          // Go up the causal chain to see if we've already seen this cause; if we have, even if\n",
        "182": "          // it's wrapped by a different exception, don't log it.\n",
        "209": "      // The only cases in which this Future should already be done are (a) if it was cancelled or\n",
        "210": "      // (b) if an input failed and we propagated that immediately because of allMustSucceed.\n",
        "211": "      checkState(\n",
        "212": "          allMustSucceed || !isDone() || isCancelled(),\n",
        "216": "        checkState(future.isDone(), \"Tried to set value from future which is not done\");\n",
        "219": "            // this.cancel propagates the cancellation to children; we use super.cancel to set our\n",
        "220": "            // own state but let the input futures keep running as some of them may be used\n",
        "221": "            // elsewhere.\n",
        "261": "     * Listeners implicitly keep a reference to {@link RunningState} as they're inner classes, so we\n",
        "262": "     * free resources here as well for the allMustSucceed=true case (i.e. when a future fails, we\n",
        "263": "     * immediately release resources we no longer need); additionally, the future will release its\n",
        "264": "     * reference to {@link RunningState}, which should free all associated memory when all the\n",
        "265": "     * futures complete and the listeners are released.\n",
        "276": "     * <p>If {@code allMustSucceed} is true, called as each future completes; otherwise, called for\n",
        "277": "     * each future when all futures complete.\n"
    },
    "removed": {
        "4": " * Licensed under the Apache License, Version 2.0 (the \"License\");\n",
        "5": " * you may not use this file except in compliance with the License.\n",
        "6": " * You may obtain a copy of the License at\n",
        "10": " * Unless required by applicable law or agreed to in writing, software\n",
        "11": " * distributed under the License is distributed on an \"AS IS\" BASIS,\n",
        "12": " * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n",
        "13": " * See the License for the specific language governing permissions and\n",
        "14": " * limitations under the License.\n",
        "45": "  private static final Logger logger =\n",
        "46": "      Logger.getLogger(AggregateFuture.class.getName());\n",
        "50": "  @Override final void done() {\n",
        "58": "  @Override public final boolean cancel(boolean mayInterruptIfRunning) {\n",
        "75": "  @Override protected final void interruptTask() {\n",
        "96": "    RunningState(ImmutableCollection<? extends ListenableFuture<? extends InputT>> futures,\n",
        "97": "        boolean allMustSucceed, boolean collectsValues) {\n",
        "105": "    @Override public final void run() {\n",
        "111": "     * futures are already complete, we would not initialize the subclass before calling\n",
        "112": "     * {@link #handleOneInputDone}. As this is called after the subclass is constructed, we're\n",
        "113": "     * guaranteed to have properly initialized the subclass.\n",
        "122": "      // NOTE: If we ever want to use a custom executor here, have a look at\n",
        "123": "      // CombinedFuture as we'll need to handle RejectedExecutionException\n",
        "129": "        // Register a listener on each Future in the list to update\n",
        "130": "        // the state of this future.\n",
        "131": "        // Note that if all the futures on the list are done prior to completing\n",
        "132": "        // this loop, the last call to addListener() will callback to\n",
        "133": "        // setOneValue(), transitively call our cleanup listener, and set\n",
        "134": "        // this.futures to null.\n",
        "135": "        // This is not actually a problem, since the foreach only needs\n",
        "136": "        // this.futures to be non-null at the beginning of the loop.\n",
        "140": "          listenable.addListener(new Runnable() {\n",
        "141": "            @Override\n",
        "142": "            public void run() {\n",
        "143": "              try {\n",
        "144": "                handleOneInputDone(index, listenable);\n",
        "145": "              } finally {\n",
        "146": "                decrementCountAndMaybeComplete();\n",
        "147": "              }\n",
        "148": "            }\n",
        "149": "          }, directExecutor());\n",
        "161": "     * Fails this future with the given Throwable if {@link #allMustSucceed} is\n",
        "162": "     * true. Also, logs the throwable if it is an {@link Error} or if\n",
        "163": "     * {@link #allMustSucceed} is {@code true}, the throwable did not cause\n",
        "164": "     * this future to fail, and it is the first time we've seen that particular Throwable.\n",
        "178": "          // Go up the causal chain to see if we've already seen this cause; if we have,\n",
        "179": "          // even if it's wrapped by a different exception, don't log it.\n",
        "206": "      // The only cases in which this Future should already be done are (a) if\n",
        "207": "      // it was cancelled or (b) if an input failed and we propagated that\n",
        "208": "      // immediately because of allMustSucceed.\n",
        "209": "      checkState(allMustSucceed || !isDone() || isCancelled(),\n",
        "213": "        checkState(future.isDone(),\n",
        "214": "            \"Tried to set value from future which is not done\");\n",
        "217": "            // this.cancel propagates the cancellation to children; we use super.cancel\n",
        "218": "            // to set our own state but let the input futures keep running\n",
        "219": "            // as some of them may be used elsewhere.\n",
        "259": "     * Listeners implicitly keep a reference to {@link RunningState} as they're inner classes,\n",
        "260": "     * so we free resources here as well for the allMustSucceed=true case (i.e. when a future fails,\n",
        "261": "     * we immediately release resources we no longer need); additionally, the future will release\n",
        "262": "     * its reference to {@link RunningState}, which should free all associated memory when all the\n",
        "263": "     * futures complete & the listeners are released.\n",
        "274": "     * <p>If {@code allMustSucceed} is true, called as each future completes; otherwise,\n",
        "275": "     * called for each future when all futures complete.\n"
    }
}