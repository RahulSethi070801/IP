{"id": "3f1d2e422a12a29e5ac7425dc323c4b99470f0d2", "code": [{"0": "guava-tests/test/com/google/common/io/ByteSourceTest.java", "added": {"1": ["import com.google.common.primitives.UnsignedBytes;\n", "import java.util.Arrays;\n"], "2": ["    assertCorrectSlice(100, 101, 10, 0);\n", "  }\n", "  /**\n", "   * Tests that the default slice() behavior is correct when the source is sliced starting at an\n", "   * offset that is greater than the current length of the source, a stream is then opened to that\n", "   * source, and finally additional bytes are appended to the source before the stream is read.\n", "   *\n", "   * <p>Without special handling, it's possible to have reads of the open stream start <i>before</i>\n", "   * the offset at which the slice is supposed to start.\n", "   */\n", "  // TODO(cgdecker): Maybe add a test for this to ByteSourceTester\n", "  public void testSlice_appendingAfterSlicing() throws IOException {\n", "    // Source of length 5\n", "    AppendableByteSource source = new AppendableByteSource(newPreFilledByteArray(5));\n", "\n", "    // Slice it starting at offset 10.\n", "    ByteSource slice = source.slice(10, 5);\n", "\n", "    // Open a stream to the slice.\n", "    InputStream in = slice.openStream();\n", "\n", "    // Append 10 more bytes to the source.\n", "    source.append(newPreFilledByteArray(5, 10));\n", "\n", "    // The stream reports no bytes... importantly, it doesn't read the byte at index 5 when it\n", "    // should be reading the byte at index 10.\n", "    // We could use a custom InputStream instead to make the read start at index 10, but since this\n", "    // is a racy situation anyway, this behavior seems reasonable.\n", "    assertEquals(-1, in.read());\n", "  }\n", "\n", "  private static class AppendableByteSource extends ByteSource {\n", "    private byte[] bytes;\n", "\n", "    public AppendableByteSource(byte[] initialBytes) {\n", "      this.bytes = initialBytes.clone();\n", "    }\n", "\n", "    @Override\n", "    public InputStream openStream() {\n", "      return new In();\n", "    }\n", "\n", "    public void append(byte[] b) {\n", "      byte[] newBytes = Arrays.copyOf(bytes, bytes.length + b.length);\n", "      System.arraycopy(b, 0, newBytes, bytes.length, b.length);\n", "      bytes = newBytes;\n", "    }\n", "\n", "    private class In extends InputStream {\n", "      private int pos;\n", "\n", "      @Override\n", "      public int read() throws IOException {\n", "        byte[] b = new byte[1];\n", "        return read(b) == -1\n", "            ? -1\n", "            : UnsignedBytes.toInt(b[0]);\n", "      }\n", "\n", "      @Override\n", "      public int read(byte[] b, int off, int len) {\n", "        if (pos >= bytes.length) {\n", "          return -1;\n", "        }\n", "\n", "        int lenToRead = Math.min(len, bytes.length - pos);\n", "        System.arraycopy(bytes, pos, b, off, lenToRead);\n", "        pos += lenToRead;\n", "        return lenToRead;\n", "      }\n"]}, "removed": {"1": ["import java.io.EOFException;\n"], "2": ["    try {\n", "      assertCorrectSlice(100, 101, 10, 0);\n", "      fail();\n", "    } catch (EOFException expected) {\n"]}, "added_lines": {"1": [33, 42], "2": [214, 215, 217, 218, 219, 220, 221, 222, 223, 224, 225, 226, 227, 228, 229, 230, 231, 232, 233, 234, 235, 236, 237, 238, 239, 240, 241, 242, 243, 244, 245, 246, 247, 248, 249, 250, 251, 252, 253, 254, 255, 256, 257, 258, 259, 260, 261, 262, 263, 264, 265, 266, 267, 268, 269, 270, 271, 272, 273, 274, 275, 276, 277, 278, 279, 280, 281, 282, 283, 284, 285]}, "removed_lines": {"1": [38], "2": [214, 215, 216, 217]}}, {"1": "guava-tests/test/com/google/common/io/ByteSourceTester.java", "added": {"1": ["\n", "      // test a slice() of the ByteSource starting at an offset greater than its size\n", "      ByteSourceFactory slicedOffsetPastEnd = SourceSinkFactories.asSlicedByteSourceFactory(\n", "          factory, expected.length + 2, expected.length + 10);\n", "      suite.addTest(suiteForBytes(slicedOffsetPastEnd, bytes, name + \".slice[size + 2, long]\",\n", "          desc, false));\n"]}, "removed": {}, "added_lines": {"1": [101, 102, 103, 104, 105, 106]}, "removed_lines": {}}, {"2": "guava/src/com/google/common/io/ByteSource.java", "added": {"1": ["   * starting at the given {@code offset}. If {@code offset} is greater than the size of this\n", "   * source, the returned source will be empty. If {@code offset + length} is greater than the size\n", "   * of this source, the returned source will contain the slice starting at {@code offset} and\n", "   * ending at the end of this source.\n"], "2": ["        long skipped;\n", "          skipped = ByteStreams.skipUpTo(in, offset);\n"], "3": ["\n", "        if (skipped < offset) {\n", "          // offset was beyond EOF\n", "          in.close();\n", "          return new ByteArrayInputStream(new byte[0]);\n", "        }\n"]}, "removed": {"1": ["   * starting at the given {@code offset}.\n"], "2": ["          ByteStreams.skipFully(in, offset);\n"]}, "added_lines": {"1": [108, 109, 110, 111], "2": [498, 500], "3": [510, 511, 512, 513, 514, 515]}, "removed_lines": {"1": [108], "2": [496]}}, {"3": "guava/src/com/google/common/io/ByteStreams.java", "added": {"1": ["    long skipped = skipUpTo(in, n);\n", "    if (skipped < n) {\n", "      throw new EOFException(\"reached end of stream after skipping \"\n", "          + skipped + \" bytes; \" + n + \" bytes expected\");\n", "    }\n", "  }\n", "\n", "  /**\n", "   * Discards up to {@code n} bytes of data from the input stream. This method\n", "   * will block until either the full amount has been skipped or until the end\n", "   * of the stream is reached, whichever happens first. Returns the total number\n", "   * of bytes skipped.\n", "   */\n", "  static long skipUpTo(InputStream in, final long n) throws IOException {\n", "    long totalSkipped = 0;\n", "\n", "    while (totalSkipped < n) {\n", "      long skipped = in.skip(n - totalSkipped);\n", "\n", "      if (skipped == 0) {\n", "          // Reached EOF\n", "          break;\n", "        } else {\n", "          skipped = 1;\n", "\n", "      totalSkipped += skipped;\n", "\n", "    return totalSkipped;\n"]}, "removed": {"1": ["    long toSkip = n;\n", "    while (n > 0) {\n", "      long amt = in.skip(n);\n", "      if (amt == 0) {\n", "          long skipped = toSkip - n;\n", "          throw new EOFException(\"reached end of stream after skipping \"\n", "              + skipped + \" bytes; \" + toSkip + \" bytes expected\");\n", "        n--;\n", "      } else {\n", "        n -= amt;\n"]}, "added_lines": {"1": [707, 708, 709, 710, 711, 712, 713, 714, 715, 716, 717, 718, 719, 720, 721, 722, 723, 724, 725, 726, 729, 730, 731, 732, 735, 736, 738, 739]}, "removed_lines": {"1": [707, 708, 709, 710, 713, 714, 715, 717, 718, 719]}}]}
