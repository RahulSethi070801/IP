{
    "addition": {
        "33": "import com.google.common.primitives.UnsignedBytes;\n",
        "42": "import java.util.Arrays;\n",
        "214": "    assertCorrectSlice(100, 101, 10, 0);\n",
        "215": "  }\n",
        "217": "  /**\n",
        "218": "   * Tests that the default slice() behavior is correct when the source is sliced starting at an\n",
        "219": "   * offset that is greater than the current length of the source, a stream is then opened to that\n",
        "220": "   * source, and finally additional bytes are appended to the source before the stream is read.\n",
        "221": "   *\n",
        "222": "   * <p>Without special handling, it's possible to have reads of the open stream start <i>before</i>\n",
        "223": "   * the offset at which the slice is supposed to start.\n",
        "224": "   */\n",
        "225": "  // TODO(cgdecker): Maybe add a test for this to ByteSourceTester\n",
        "226": "  public void testSlice_appendingAfterSlicing() throws IOException {\n",
        "227": "    // Source of length 5\n",
        "228": "    AppendableByteSource source = new AppendableByteSource(newPreFilledByteArray(5));\n",
        "229": "\n",
        "230": "    // Slice it starting at offset 10.\n",
        "231": "    ByteSource slice = source.slice(10, 5);\n",
        "232": "\n",
        "233": "    // Open a stream to the slice.\n",
        "234": "    InputStream in = slice.openStream();\n",
        "235": "\n",
        "236": "    // Append 10 more bytes to the source.\n",
        "237": "    source.append(newPreFilledByteArray(5, 10));\n",
        "238": "\n",
        "239": "    // The stream reports no bytes... importantly, it doesn't read the byte at index 5 when it\n",
        "240": "    // should be reading the byte at index 10.\n",
        "241": "    // We could use a custom InputStream instead to make the read start at index 10, but since this\n",
        "242": "    // is a racy situation anyway, this behavior seems reasonable.\n",
        "243": "    assertEquals(-1, in.read());\n",
        "244": "  }\n",
        "245": "\n",
        "246": "  private static class AppendableByteSource extends ByteSource {\n",
        "247": "    private byte[] bytes;\n",
        "248": "\n",
        "249": "    public AppendableByteSource(byte[] initialBytes) {\n",
        "250": "      this.bytes = initialBytes.clone();\n",
        "251": "    }\n",
        "252": "\n",
        "253": "    @Override\n",
        "254": "    public InputStream openStream() {\n",
        "255": "      return new In();\n",
        "256": "    }\n",
        "257": "\n",
        "258": "    public void append(byte[] b) {\n",
        "259": "      byte[] newBytes = Arrays.copyOf(bytes, bytes.length + b.length);\n",
        "260": "      System.arraycopy(b, 0, newBytes, bytes.length, b.length);\n",
        "261": "      bytes = newBytes;\n",
        "262": "    }\n",
        "263": "\n",
        "264": "    private class In extends InputStream {\n",
        "265": "      private int pos;\n",
        "266": "\n",
        "267": "      @Override\n",
        "268": "      public int read() throws IOException {\n",
        "269": "        byte[] b = new byte[1];\n",
        "270": "        return read(b) == -1\n",
        "271": "            ? -1\n",
        "272": "            : UnsignedBytes.toInt(b[0]);\n",
        "273": "      }\n",
        "274": "\n",
        "275": "      @Override\n",
        "276": "      public int read(byte[] b, int off, int len) {\n",
        "277": "        if (pos >= bytes.length) {\n",
        "278": "          return -1;\n",
        "279": "        }\n",
        "280": "\n",
        "281": "        int lenToRead = Math.min(len, bytes.length - pos);\n",
        "282": "        System.arraycopy(bytes, pos, b, off, lenToRead);\n",
        "283": "        pos += lenToRead;\n",
        "284": "        return lenToRead;\n",
        "285": "      }\n"
    },
    "removed": {
        "38": "import java.io.EOFException;\n",
        "214": "    try {\n",
        "215": "      assertCorrectSlice(100, 101, 10, 0);\n",
        "216": "      fail();\n",
        "217": "    } catch (EOFException expected) {\n"
    }
}