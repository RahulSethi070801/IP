{
    "addition": {
        "20": "import static java.util.Arrays.asList;\n",
        "21": "import static java.util.Collections.unmodifiableList;\n",
        "24": "import com.google.common.annotations.VisibleForTesting;\n",
        "28": "import java.lang.reflect.InvocationTargetException;\n",
        "29": "import java.lang.reflect.Method;\n",
        "30": "import java.util.AbstractList;\n",
        "41": " * \"http://code.google.com/p/guava-libraries/wiki/ThrowablesExplained\">Throwables</a>.\n",
        "51": "   * Propagates {@code throwable} exactly as-is, if and only if it is an instance of {@code\n",
        "52": "   * declaredType}.  Example usage:\n",
        "74": "   * Propagates {@code throwable} exactly as-is, if and only if it is an instance of {@link\n",
        "75": "   * RuntimeException} or {@link Error}.  Example usage:\n",
        "93": "   * Propagates {@code throwable} exactly as-is, if and only if it is an instance of {@link\n",
        "94": "   * RuntimeException}, {@link Error}, or {@code declaredType}. Example usage:\n",
        "107": "   * @param declaredType the single checked exception type declared by the calling method\n",
        "116": "   * Propagates {@code throwable} exactly as-is, if and only if it is an instance of {@link\n",
        "117": "   * RuntimeException}, {@link Error}, {@code declaredType1}, or {@code declaredType2}. In the\n",
        "118": "   * unlikely case that you have three or more declared checked exception types, you can handle them\n",
        "119": "   * all by invoking these methods repeatedly. See usage example in {@link\n",
        "123": "   * @param declaredType1 any checked exception type declared by the calling method\n",
        "124": "   * @param declaredType2 any other checked exception type declared by the calling method\n",
        "135": "   * Propagates {@code throwable} as-is if it is an instance of {@link RuntimeException} or {@link\n",
        "136": "   * Error}, or else as a last resort, wraps it in a {@code RuntimeException} and then propagates.\n",
        "138": "   * This method always throws an exception. The {@code RuntimeException} return type is only for\n",
        "139": "   * client code to make Java type system happy in case a return value is required by the enclosing\n",
        "140": "   * method. Example usage:\n",
        "154": "   * @return nothing will ever be returned; this return type is only for your convenience, as\n",
        "155": "   *     illustrated in the example above\n",
        "167": "   *   assertEquals(\"Unable to assign a customer id\", Throwables.getRootCause(e).getMessage());\n",
        "179": "   * Gets a {@code Throwable} cause chain as a list.  The first entry in the list will be {@code\n",
        "180": "   * throwable} followed by its cause hierarchy.  Note that this is a snapshot of the cause chain\n",
        "181": "   * and will not reflect any subsequent changes to the cause chain.\n",
        "183": "   * <p>Here's an example of how it can be used to find specific types of exceptions in the cause\n",
        "184": "   * chain:\n",
        "191": "   * @return an unmodifiable list containing the cause chain starting with {@code throwable}\n",
        "205": "   * Returns a string containing the result of {@link Throwable#toString() toString()}, followed by\n",
        "206": "   * the full, recursive stack trace of {@code throwable}. Note that you probably should not be\n",
        "207": "   * parsing the resulting string; if you need programmatic access to the stack frames, you can call\n",
        "208": "   * {@link Throwable#getStackTrace()}.\n",
        "215": "\n",
        "216": "  /**\n",
        "217": "   * Returns the stack trace of {@code throwable}, possibly providing slower iteration over the full\n",
        "218": "   * trace but faster iteration over parts of the trace. Here, \"slower\" and \"faster\" are defined in\n",
        "219": "   * comparison to the normal way to access the stack trace, {@link Throwable#getStackTrace()\n",
        "220": "   * throwable.getStackTrace()}. Note, however, that this method's special implementation is not\n",
        "221": "   * available for all platforms and configurations. If that implementation is unavailable, this\n",
        "222": "   * method falls back to {@code getStackTrace}. Callers that require the special implementation can\n",
        "223": "   * check its availability with {@link #lazyStackTraceIsLazy()}.\n",
        "224": "   *\n",
        "225": "   * <p>The expected (but not guaranteed) performance of the special implementation differs from\n",
        "226": "   * {@code getStackTrace} in one main way: The {@code lazyStackTrace} call itself returns quickly\n",
        "227": "   * by delaying the per-stack-frame work until each element is accessed. Roughly speaking:\n",
        "228": "   *\n",
        "229": "   * <ul>\n",
        "230": "   * <li>{@code getStackTrace} takes {@code stackSize} time to return but then negligible time to\n",
        "231": "   * retrieve each element of the returned list.\n",
        "232": "   * <li>{@code lazyStackTrace} takes negligible time to return but then {@code 1/stackSize} time to\n",
        "233": "   * retrieve each element of the returned list (probably slightly more than {@code 1/stackSize}).\n",
        "234": "   * </ul>\n",
        "235": "   *\n",
        "236": "   * <p>Note: The special implementation does not respect calls to {@link Throwable#setStackTrace\n",
        "237": "   * throwable.setStackTrace}. Instead, it always reflects the original stack trace from the\n",
        "238": "   * exception's creation.\n",
        "239": "   *\n",
        "240": "   * @since 19.0\n",
        "241": "   */\n",
        "242": "  // TODO(cpovirk): Say something about the possibility that List access could fail at runtime?\n",
        "243": "  @Beta\n",
        "244": "  public static List<StackTraceElement> lazyStackTrace(Throwable throwable) {\n",
        "245": "    return lazyStackTraceIsLazy()\n",
        "246": "        ? jlaStackTrace(throwable)\n",
        "247": "        : unmodifiableList(asList(throwable.getStackTrace()));\n",
        "248": "  }\n",
        "249": "\n",
        "250": "  /**\n",
        "251": "   * Returns whether {@link #lazyStackTrace} will use the special implementation described in its\n",
        "252": "   * documentation.\n",
        "253": "   *\n",
        "254": "   * @since 19.0\n",
        "255": "   */\n",
        "256": "  @Beta\n",
        "257": "  public static boolean lazyStackTraceIsLazy() {\n",
        "258": "    return getStackTraceElementMethod != null & getStackTraceDepthMethod != null;\n",
        "259": "  }\n",
        "260": "\n",
        "261": "  private static List<StackTraceElement> jlaStackTrace(final Throwable t) {\n",
        "262": "    checkNotNull(t);\n",
        "263": "    /*\n",
        "264": "     * TODO(cpovirk): Consider optimizing iterator() to catch IOOBE instead of doing bounds checks.\n",
        "265": "     *\n",
        "266": "     * TODO(cpovirk): Consider the UnsignedBytes pattern if it performs faster and doesn't cause\n",
        "267": "     * AOSP grief.\n",
        "268": "     */\n",
        "269": "    return new AbstractList<StackTraceElement>() {\n",
        "270": "      @Override\n",
        "271": "      public StackTraceElement get(int n) {\n",
        "272": "        return (StackTraceElement)\n",
        "273": "            invokeAccessibleNonThrowingMethod(getStackTraceElementMethod, jla, t, n);\n",
        "274": "      }\n",
        "275": "\n",
        "276": "      @Override\n",
        "277": "      public int size() {\n",
        "278": "        return (Integer) invokeAccessibleNonThrowingMethod(getStackTraceDepthMethod, jla, t);\n",
        "279": "      }\n",
        "280": "    };\n",
        "281": "  }\n",
        "282": "\n",
        "283": "  private static Object invokeAccessibleNonThrowingMethod(\n",
        "284": "      Method method, Object receiver, Object... params) {\n",
        "285": "    try {\n",
        "286": "      return method.invoke(receiver, params);\n",
        "287": "    } catch (IllegalAccessException e) {\n",
        "288": "      throw new RuntimeException(e);\n",
        "289": "    } catch (InvocationTargetException e) {\n",
        "290": "      throw propagate(e.getCause());\n",
        "291": "    }\n",
        "292": "  }\n",
        "293": "\n",
        "294": "  /** JavaLangAccess class name to load using reflection */\n",
        "295": "  private static final String JAVA_LANG_ACCESS_CLASSNAME = \"sun.misc.JavaLangAccess\";\n",
        "296": "\n",
        "297": "  /** SharedSecrets class name to load using reflection */\n",
        "298": "  @VisibleForTesting\n",
        "299": "  static final String SHARED_SECRETS_CLASSNAME = \"sun.misc.SharedSecrets\";\n",
        "300": "\n",
        "301": "  /** Access to some fancy internal JVM internals. */\n",
        "302": "  @Nullable\n",
        "303": "  private static final Object jla = getJLA();\n",
        "304": "\n",
        "305": "  /**\n",
        "306": "   * The \"getStackTraceElementMethod\" method, only available on some JDKs so we use reflection to\n",
        "307": "   * find it when available. When this is null, use the slow way.\n",
        "308": "   */\n",
        "309": "  @Nullable\n",
        "310": "  private static final Method getStackTraceElementMethod = (jla == null) ? null : getGetMethod();\n",
        "311": "\n",
        "312": "  /**\n",
        "313": "   * The \"getStackTraceDepth\" method, only available on some JDKs so we use reflection to find it\n",
        "314": "   * when available. When this is null, use the slow way.\n",
        "315": "   */\n",
        "316": "  @Nullable\n",
        "317": "  private static final Method getStackTraceDepthMethod = (jla == null) ? null : getSizeMethod();\n",
        "318": "\n",
        "319": "  /**\n",
        "320": "   * Returns the JavaLangAccess class that is present in all Sun JDKs. It is not whitelisted for\n",
        "321": "   * AppEngine, and not present in non-Sun JDKs.\n",
        "322": "   */\n",
        "323": "  @Nullable\n",
        "324": "  private static Object getJLA() {\n",
        "325": "    try {\n",
        "326": "      /*\n",
        "327": "       * We load sun.misc.* classes using reflection since Android doesn't support these classes and\n",
        "328": "       * would result in compilation failure if we directly refer to these classes.\n",
        "329": "       */\n",
        "330": "      Class<?> sharedSecrets = Class.forName(SHARED_SECRETS_CLASSNAME, false, null);\n",
        "331": "      Method langAccess = sharedSecrets.getMethod(\"getJavaLangAccess\");\n",
        "332": "      return langAccess.invoke(null);\n",
        "333": "    } catch (ThreadDeath death) {\n",
        "334": "      throw death;\n",
        "335": "    } catch (Throwable t) {\n",
        "336": "      /*\n",
        "337": "       * This is not one of AppEngine's whitelisted classes, so even in Sun JDKs, this can fail with\n",
        "338": "       * a NoClassDefFoundError. Other apps might deny access to sun.misc packages.\n",
        "339": "       */\n",
        "340": "      return null;\n",
        "341": "    }\n",
        "342": "  }\n",
        "343": "\n",
        "344": "  /**\n",
        "345": "   * Returns the Method that can be used to resolve an individual StackTraceElement, or null if that\n",
        "346": "   * method cannot be found (it is only to be found in fairly recent JDKs).\n",
        "347": "   */\n",
        "348": "  @Nullable\n",
        "349": "  private static Method getGetMethod() {\n",
        "350": "    return getJlaMethod(\"getStackTraceElement\", Throwable.class, int.class);\n",
        "351": "  }\n",
        "352": "\n",
        "353": "  /**\n",
        "354": "   * Returns the Method that can be used to return the size of a stack, or null if that method\n",
        "355": "   * cannot be found (it is only to be found in fairly recent JDKs).\n",
        "356": "   */\n",
        "357": "  @Nullable\n",
        "358": "  private static Method getSizeMethod() {\n",
        "359": "    return getJlaMethod(\"getStackTraceDepth\", Throwable.class);\n",
        "360": "  }\n",
        "361": "\n",
        "362": "  @Nullable\n",
        "363": "  private static Method getJlaMethod(String name, Class<?>... parameterTypes) throws ThreadDeath {\n",
        "364": "    try {\n",
        "365": "      return Class.forName(JAVA_LANG_ACCESS_CLASSNAME, false, null).getMethod(name, parameterTypes);\n",
        "366": "    } catch (ThreadDeath death) {\n",
        "367": "      throw death;\n",
        "368": "    } catch (Throwable t) {\n",
        "369": "      /*\n",
        "370": "       * Either the JavaLangAccess class itself is not found, or the method is not supported on the\n",
        "371": "       * JVM.\n",
        "372": "       */\n",
        "373": "      return null;\n",
        "374": "    }\n",
        "375": "  }\n"
    },
    "removed": {
        "35": " * \"http://code.google.com/p/guava-libraries/wiki/ThrowablesExplained\">\n",
        "36": " * Throwables</a>.\n",
        "46": "   * Propagates {@code throwable} exactly as-is, if and only if it is an\n",
        "47": "   * instance of {@code declaredType}.  Example usage:\n",
        "69": "   * Propagates {@code throwable} exactly as-is, if and only if it is an\n",
        "70": "   * instance of {@link RuntimeException} or {@link Error}.  Example usage:\n",
        "88": "   * Propagates {@code throwable} exactly as-is, if and only if it is an\n",
        "89": "   * instance of {@link RuntimeException}, {@link Error}, or\n",
        "90": "   * {@code declaredType}. Example usage:\n",
        "103": "   * @param declaredType the single checked exception type declared by the\n",
        "104": "   *     calling method\n",
        "113": "   * Propagates {@code throwable} exactly as-is, if and only if it is an\n",
        "114": "   * instance of {@link RuntimeException}, {@link Error}, {@code declaredType1},\n",
        "115": "   * or {@code declaredType2}.  In the unlikely case that you have three or more\n",
        "116": "   * declared checked exception types, you can handle them all by invoking these\n",
        "117": "   * methods repeatedly. See usage example in {@link\n",
        "121": "   * @param declaredType1 any checked exception type declared by the calling\n",
        "122": "   *     method\n",
        "123": "   * @param declaredType2 any other checked exception type declared by the\n",
        "124": "   *     calling method\n",
        "135": "   * Propagates {@code throwable} as-is if it is an instance of\n",
        "136": "   * {@link RuntimeException} or {@link Error}, or else as a last resort, wraps\n",
        "137": "   * it in a {@code RuntimeException} then propagates.\n",
        "139": "   * This method always throws an exception. The {@code RuntimeException} return\n",
        "140": "   * type is only for client code to make Java type system happy in case a\n",
        "141": "   * return value is required by the enclosing method. Example usage:\n",
        "155": "   * @return nothing will ever be returned; this return type is only for your\n",
        "156": "   *     convenience, as illustrated in the example above\n",
        "168": "   *   assertEquals(\"Unable to assign a customer id\",\n",
        "169": "   *       Throwables.getRootCause(e).getMessage());\n",
        "181": "   * Gets a {@code Throwable} cause chain as a list.  The first entry in the\n",
        "182": "   * list will be {@code throwable} followed by its cause hierarchy.  Note\n",
        "183": "   * that this is a snapshot of the cause chain and will not reflect\n",
        "184": "   * any subsequent changes to the cause chain.\n",
        "186": "   * <p>Here's an example of how it can be used to find specific types\n",
        "187": "   * of exceptions in the cause chain:\n",
        "194": "   * @return an unmodifiable list containing the cause chain starting with\n",
        "195": "   *     {@code throwable}\n",
        "209": "   * Returns a string containing the result of\n",
        "210": "   * {@link Throwable#toString() toString()}, followed by the full, recursive\n",
        "211": "   * stack trace of {@code throwable}. Note that you probably should not be\n",
        "212": "   * parsing the resulting string; if you need programmatic access to the stack\n",
        "213": "   * frames, you can call {@link Throwable#getStackTrace()}.\n"
    }
}