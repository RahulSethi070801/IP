{
    "addition": {
        "1": "/*\n",
        "2": " * Copyright (C) 2013 The Guava Authors\n",
        "3": " *\n",
        "4": " * Licensed under the Apache License, Version 2.0 (the \"License\");\n",
        "5": " * you may not use this file except in compliance with the License.\n",
        "6": " * You may obtain a copy of the License at\n",
        "7": " *\n",
        "8": " * http://www.apache.org/licenses/LICENSE-2.0\n",
        "9": " *\n",
        "10": " * Unless required by applicable law or agreed to in writing, software\n",
        "11": " * distributed under the License is distributed on an \"AS IS\" BASIS,\n",
        "12": " * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n",
        "13": " * See the License for the specific language governing permissions and\n",
        "14": " * limitations under the License.\n",
        "15": " */\n",
        "16": "\n",
        "17": "package com.google.common.base;\n",
        "18": "\n",
        "19": "import static com.google.common.base.Throwables.lazyStackTrace;\n",
        "20": "import static java.util.Arrays.asList;\n",
        "21": "\n",
        "22": "import com.google.caliper.BeforeExperiment;\n",
        "23": "import com.google.caliper.Benchmark;\n",
        "24": "import com.google.caliper.Param;\n",
        "25": "import com.google.caliper.api.SkipThisScenarioException;\n",
        "26": "\n",
        "27": "import java.util.List;\n",
        "28": "\n",
        "29": "/**\n",
        "30": " * Quick and dirty benchmark of {@link Throwables#lazyStackTrace(Throwable)}. We benchmark a \"caller\n",
        "31": " * finder\" implementation that might be used in a logging framework.\n",
        "32": " */\n",
        "33": "public class LazyStackTraceBenchmark {\n",
        "34": "  @Param({\"20\", \"200\", \"2000\"}) int stackDepth;\n",
        "35": "  @Param({\"-1\", \"3\", \"15\"}) int breakAt;\n",
        "36": "\n",
        "37": "  int recursionCount;\n",
        "38": "\n",
        "39": "  private static final Object duh = new Object();\n",
        "40": "\n",
        "41": "  @Param Mode mode;\n",
        "42": "\n",
        "43": "  enum Mode {\n",
        "44": "    LAZY_STACK_TRACE {\n",
        "45": "      @Override\n",
        "46": "      List<StackTraceElement> getStackTrace(Throwable t) {\n",
        "47": "        return lazyStackTrace(t);\n",
        "48": "      }\n",
        "49": "    },\n",
        "50": "    GET_STACK_TRACE {\n",
        "51": "      @Override\n",
        "52": "      List<StackTraceElement> getStackTrace(Throwable t) {\n",
        "53": "        return asList(t.getStackTrace());\n",
        "54": "      }\n",
        "55": "    };\n",
        "56": "\n",
        "57": "    boolean timeIt(int reps, int breakAt) {\n",
        "58": "      boolean dummy = false;\n",
        "59": "      for (int i = 0; i < reps; i++) {\n",
        "60": "        int f = 0;\n",
        "61": "        Throwable t = new Throwable();\n",
        "62": "        for (StackTraceElement ste : getStackTrace(t)) {\n",
        "63": "          dummy |= ste == duh;\n",
        "64": "          if (f++ == breakAt) {\n",
        "65": "            break;\n",
        "66": "          }\n",
        "67": "        }\n",
        "68": "      }\n",
        "69": "      return dummy;\n",
        "70": "    }\n",
        "71": "\n",
        "72": "    abstract List<StackTraceElement> getStackTrace(Throwable t);\n",
        "73": "  }\n",
        "74": "\n",
        "75": "  @BeforeExperiment\n",
        "76": "  public void doBefore() {\n",
        "77": "    recursionCount = stackDepth - new Throwable().getStackTrace().length - 1;\n",
        "78": "    if (recursionCount < 0) {\n",
        "79": "      throw new SkipThisScenarioException();\n",
        "80": "    }\n",
        "81": "  }\n",
        "82": "\n",
        "83": "  @Benchmark\n",
        "84": "  public boolean timeFindCaller(int reps) {\n",
        "85": "    return timeFindCaller(reps, recursionCount);\n",
        "86": "  }\n",
        "87": "\n",
        "88": "  private boolean timeFindCaller(int reps, int recurse) {\n",
        "89": "    return recurse > 0\n",
        "90": "        ? timeFindCaller(reps, recurse - 1)\n",
        "91": "        : mode.timeIt(reps, breakAt);\n",
        "92": "  }\n",
        "93": "}\n"
    },
    "removed": {}
}