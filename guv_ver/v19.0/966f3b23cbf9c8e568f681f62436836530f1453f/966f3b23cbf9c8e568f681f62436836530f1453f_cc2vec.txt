{"id": "966f3b23cbf9c8e568f681f62436836530f1453f", "code": [{"0": "guava-tests/benchmark/com/google/common/base/LazyStackTraceBenchmark.java", "added": {"1": ["/*\n", " * Copyright (C) 2013 The Guava Authors\n", " *\n", " * Licensed under the Apache License, Version 2.0 (the \"License\");\n", " * you may not use this file except in compliance with the License.\n", " * You may obtain a copy of the License at\n", " *\n", " * http://www.apache.org/licenses/LICENSE-2.0\n", " *\n", " * Unless required by applicable law or agreed to in writing, software\n", " * distributed under the License is distributed on an \"AS IS\" BASIS,\n", " * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n", " * See the License for the specific language governing permissions and\n", " * limitations under the License.\n", " */\n", "\n", "package com.google.common.base;\n", "\n", "import static com.google.common.base.Throwables.lazyStackTrace;\n", "import static java.util.Arrays.asList;\n", "\n", "import com.google.caliper.BeforeExperiment;\n", "import com.google.caliper.Benchmark;\n", "import com.google.caliper.Param;\n", "import com.google.caliper.api.SkipThisScenarioException;\n", "\n", "import java.util.List;\n", "\n", "/**\n", " * Quick and dirty benchmark of {@link Throwables#lazyStackTrace(Throwable)}. We benchmark a \"caller\n", " * finder\" implementation that might be used in a logging framework.\n", " */\n", "public class LazyStackTraceBenchmark {\n", "  @Param({\"20\", \"200\", \"2000\"}) int stackDepth;\n", "  @Param({\"-1\", \"3\", \"15\"}) int breakAt;\n", "\n", "  int recursionCount;\n", "\n", "  private static final Object duh = new Object();\n", "\n", "  @Param Mode mode;\n", "\n", "  enum Mode {\n", "    LAZY_STACK_TRACE {\n", "      @Override\n", "      List<StackTraceElement> getStackTrace(Throwable t) {\n", "        return lazyStackTrace(t);\n", "      }\n", "    },\n", "    GET_STACK_TRACE {\n", "      @Override\n", "      List<StackTraceElement> getStackTrace(Throwable t) {\n", "        return asList(t.getStackTrace());\n", "      }\n", "    };\n", "\n", "    boolean timeIt(int reps, int breakAt) {\n", "      boolean dummy = false;\n", "      for (int i = 0; i < reps; i++) {\n", "        int f = 0;\n", "        Throwable t = new Throwable();\n", "        for (StackTraceElement ste : getStackTrace(t)) {\n", "          dummy |= ste == duh;\n", "          if (f++ == breakAt) {\n", "            break;\n", "          }\n", "        }\n", "      }\n", "      return dummy;\n", "    }\n", "\n", "    abstract List<StackTraceElement> getStackTrace(Throwable t);\n", "  }\n", "\n", "  @BeforeExperiment\n", "  public void doBefore() {\n", "    recursionCount = stackDepth - new Throwable().getStackTrace().length - 1;\n", "    if (recursionCount < 0) {\n", "      throw new SkipThisScenarioException();\n", "    }\n", "  }\n", "\n", "  @Benchmark\n", "  public boolean timeFindCaller(int reps) {\n", "    return timeFindCaller(reps, recursionCount);\n", "  }\n", "\n", "  private boolean timeFindCaller(int reps, int recurse) {\n", "    return recurse > 0\n", "        ? timeFindCaller(reps, recurse - 1)\n", "        : mode.timeIt(reps, breakAt);\n", "  }\n", "}\n"]}, "removed": {}, "added_lines": {"1": [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 58, 59, 60, 61, 62, 63, 64, 65, 66, 67, 68, 69, 70, 71, 72, 73, 74, 75, 76, 77, 78, 79, 80, 81, 82, 83, 84, 85, 86, 87, 88, 89, 90, 91, 92, 93]}, "removed_lines": {}}, {"1": "guava-tests/test/com/google/common/base/ThrowablesTest.java", "added": {"1": ["import static com.google.common.base.Throwables.lazyStackTrace;\n", "import static com.google.common.base.Throwables.lazyStackTraceIsLazy;\n", "import static com.google.common.truth.Truth.assertThat;\n"], "2": ["import java.security.Permission;\n", "import java.security.Policy;\n", "import java.security.ProtectionDomain;\n"], "3": ["    } catch (SomeCheckedException expected) {\n"], "4": ["    } catch (SomeUncheckedException expected) {\n"], "5": ["    } catch (RuntimeException expected) {\n", "      assertTrue(expected.getCause() instanceof SomeOtherCheckedException);\n"], "6": ["  public void testLazyStackTrace() {\n", "    // Obviously this isn't guaranteed, but it works well enough for now:\n", "    assertTrue(lazyStackTraceIsLazy());\n", "\n", "    Exception e = new Exception();\n", "    StackTraceElement[] originalStackTrace = e.getStackTrace();\n", "\n", "    assertThat(lazyStackTrace(e)).containsExactly(originalStackTrace).inOrder();\n", "\n", "    try {\n", "      lazyStackTrace(e).set(0, null);\n", "      fail();\n", "    } catch (UnsupportedOperationException expected) {\n", "    }\n", "\n", "    e.setStackTrace(new StackTraceElement[0]);\n", "    assertThat(lazyStackTrace(e)).containsExactly(originalStackTrace).inOrder();\n", "  }\n", "\n", "  private void doTestLazyStackTraceFallback() {\n", "    assertFalse(lazyStackTraceIsLazy());\n", "\n", "    Exception e = new Exception();\n", "\n", "    assertThat(lazyStackTrace(e)).containsExactly(e.getStackTrace()).inOrder();\n", "\n", "    try {\n", "      lazyStackTrace(e).set(0, null);\n", "      fail();\n", "    } catch (UnsupportedOperationException expected) {\n", "    }\n", "\n", "    e.setStackTrace(new StackTraceElement[0]);\n", "    assertThat(lazyStackTrace(e)).isEmpty();\n", "  }\n", "\n", "  private static class AllowSettingSecurityManagerPolicy extends Policy {\n", "    @Override\n", "    public boolean implies(ProtectionDomain pd, Permission perm) {\n", "      return true;\n", "    }\n", "  }\n", "\n"]}, "removed": {"3": ["    } catch (SomeCheckedException e) {\n"], "4": ["    } catch (SomeUncheckedException e) {\n"], "5": ["    } catch (RuntimeException e) {\n", "      assertTrue(e.getCause() instanceof SomeOtherCheckedException);\n"]}, "added_lines": {"1": [20, 21, 22], "2": [32, 33, 34], "3": [381], "4": [402], "5": [423, 424], "6": [523, 524, 525, 526, 527, 528, 529, 530, 531, 532, 533, 534, 535, 536, 537, 538, 539, 540, 541, 542, 543, 544, 545, 546, 547, 548, 549, 550, 551, 552, 553, 554, 555, 556, 557, 558, 559, 560, 561, 562, 563, 564, 565]}, "removed_lines": {"3": [375], "4": [396], "5": [417, 418]}}, {"2": "guava/src/com/google/common/base/Throwables.java", "added": {"1": ["import static java.util.Arrays.asList;\n", "import static java.util.Collections.unmodifiableList;\n", "import com.google.common.annotations.VisibleForTesting;\n", "import java.lang.reflect.InvocationTargetException;\n", "import java.lang.reflect.Method;\n", "import java.util.AbstractList;\n"], "2": [" * \"http://code.google.com/p/guava-libraries/wiki/ThrowablesExplained\">Throwables</a>.\n"], "3": ["   * Propagates {@code throwable} exactly as-is, if and only if it is an instance of {@code\n", "   * declaredType}.  Example usage:\n"], "4": ["   * Propagates {@code throwable} exactly as-is, if and only if it is an instance of {@link\n", "   * RuntimeException} or {@link Error}.  Example usage:\n"], "5": ["   * Propagates {@code throwable} exactly as-is, if and only if it is an instance of {@link\n", "   * RuntimeException}, {@link Error}, or {@code declaredType}. Example usage:\n"], "6": ["   * @param declaredType the single checked exception type declared by the calling method\n"], "7": ["   * Propagates {@code throwable} exactly as-is, if and only if it is an instance of {@link\n", "   * RuntimeException}, {@link Error}, {@code declaredType1}, or {@code declaredType2}. In the\n", "   * unlikely case that you have three or more declared checked exception types, you can handle them\n", "   * all by invoking these methods repeatedly. See usage example in {@link\n", "   * @param declaredType1 any checked exception type declared by the calling method\n", "   * @param declaredType2 any other checked exception type declared by the calling method\n"], "8": ["   * Propagates {@code throwable} as-is if it is an instance of {@link RuntimeException} or {@link\n", "   * Error}, or else as a last resort, wraps it in a {@code RuntimeException} and then propagates.\n", "   * This method always throws an exception. The {@code RuntimeException} return type is only for\n", "   * client code to make Java type system happy in case a return value is required by the enclosing\n", "   * method. Example usage:\n"], "9": ["   * @return nothing will ever be returned; this return type is only for your convenience, as\n", "   *     illustrated in the example above\n"], "10": ["   *   assertEquals(\"Unable to assign a customer id\", Throwables.getRootCause(e).getMessage());\n"], "11": ["   * Gets a {@code Throwable} cause chain as a list.  The first entry in the list will be {@code\n", "   * throwable} followed by its cause hierarchy.  Note that this is a snapshot of the cause chain\n", "   * and will not reflect any subsequent changes to the cause chain.\n", "   * <p>Here's an example of how it can be used to find specific types of exceptions in the cause\n", "   * chain:\n", "   * @return an unmodifiable list containing the cause chain starting with {@code throwable}\n"], "12": ["   * Returns a string containing the result of {@link Throwable#toString() toString()}, followed by\n", "   * the full, recursive stack trace of {@code throwable}. Note that you probably should not be\n", "   * parsing the resulting string; if you need programmatic access to the stack frames, you can call\n", "   * {@link Throwable#getStackTrace()}.\n", "\n", "  /**\n", "   * Returns the stack trace of {@code throwable}, possibly providing slower iteration over the full\n", "   * trace but faster iteration over parts of the trace. Here, \"slower\" and \"faster\" are defined in\n", "   * comparison to the normal way to access the stack trace, {@link Throwable#getStackTrace()\n", "   * throwable.getStackTrace()}. Note, however, that this method's special implementation is not\n", "   * available for all platforms and configurations. If that implementation is unavailable, this\n", "   * method falls back to {@code getStackTrace}. Callers that require the special implementation can\n", "   * check its availability with {@link #lazyStackTraceIsLazy()}.\n", "   *\n", "   * <p>The expected (but not guaranteed) performance of the special implementation differs from\n", "   * {@code getStackTrace} in one main way: The {@code lazyStackTrace} call itself returns quickly\n", "   * by delaying the per-stack-frame work until each element is accessed. Roughly speaking:\n", "   *\n", "   * <ul>\n", "   * <li>{@code getStackTrace} takes {@code stackSize} time to return but then negligible time to\n", "   * retrieve each element of the returned list.\n", "   * <li>{@code lazyStackTrace} takes negligible time to return but then {@code 1/stackSize} time to\n", "   * retrieve each element of the returned list (probably slightly more than {@code 1/stackSize}).\n", "   * </ul>\n", "   *\n", "   * <p>Note: The special implementation does not respect calls to {@link Throwable#setStackTrace\n", "   * throwable.setStackTrace}. Instead, it always reflects the original stack trace from the\n", "   * exception's creation.\n", "   *\n", "   * @since 19.0\n", "   */\n", "  // TODO(cpovirk): Say something about the possibility that List access could fail at runtime?\n", "  @Beta\n", "  public static List<StackTraceElement> lazyStackTrace(Throwable throwable) {\n", "    return lazyStackTraceIsLazy()\n", "        ? jlaStackTrace(throwable)\n", "        : unmodifiableList(asList(throwable.getStackTrace()));\n", "  }\n", "\n", "  /**\n", "   * Returns whether {@link #lazyStackTrace} will use the special implementation described in its\n", "   * documentation.\n", "   *\n", "   * @since 19.0\n", "   */\n", "  @Beta\n", "  public static boolean lazyStackTraceIsLazy() {\n", "    return getStackTraceElementMethod != null & getStackTraceDepthMethod != null;\n", "  }\n", "\n", "  private static List<StackTraceElement> jlaStackTrace(final Throwable t) {\n", "    checkNotNull(t);\n", "    /*\n", "     * TODO(cpovirk): Consider optimizing iterator() to catch IOOBE instead of doing bounds checks.\n", "     *\n", "     * TODO(cpovirk): Consider the UnsignedBytes pattern if it performs faster and doesn't cause\n", "     * AOSP grief.\n", "     */\n", "    return new AbstractList<StackTraceElement>() {\n", "      @Override\n", "      public StackTraceElement get(int n) {\n", "        return (StackTraceElement)\n", "            invokeAccessibleNonThrowingMethod(getStackTraceElementMethod, jla, t, n);\n", "      }\n", "\n", "      @Override\n", "      public int size() {\n", "        return (Integer) invokeAccessibleNonThrowingMethod(getStackTraceDepthMethod, jla, t);\n", "      }\n", "    };\n", "  }\n", "\n", "  private static Object invokeAccessibleNonThrowingMethod(\n", "      Method method, Object receiver, Object... params) {\n", "    try {\n", "      return method.invoke(receiver, params);\n", "    } catch (IllegalAccessException e) {\n", "      throw new RuntimeException(e);\n", "    } catch (InvocationTargetException e) {\n", "      throw propagate(e.getCause());\n", "    }\n", "  }\n", "\n", "  /** JavaLangAccess class name to load using reflection */\n", "  private static final String JAVA_LANG_ACCESS_CLASSNAME = \"sun.misc.JavaLangAccess\";\n", "\n", "  /** SharedSecrets class name to load using reflection */\n", "  @VisibleForTesting\n", "  static final String SHARED_SECRETS_CLASSNAME = \"sun.misc.SharedSecrets\";\n", "\n", "  /** Access to some fancy internal JVM internals. */\n", "  @Nullable\n", "  private static final Object jla = getJLA();\n", "\n", "  /**\n", "   * The \"getStackTraceElementMethod\" method, only available on some JDKs so we use reflection to\n", "   * find it when available. When this is null, use the slow way.\n", "   */\n", "  @Nullable\n", "  private static final Method getStackTraceElementMethod = (jla == null) ? null : getGetMethod();\n", "\n", "  /**\n", "   * The \"getStackTraceDepth\" method, only available on some JDKs so we use reflection to find it\n", "   * when available. When this is null, use the slow way.\n", "   */\n", "  @Nullable\n", "  private static final Method getStackTraceDepthMethod = (jla == null) ? null : getSizeMethod();\n", "\n", "  /**\n", "   * Returns the JavaLangAccess class that is present in all Sun JDKs. It is not whitelisted for\n", "   * AppEngine, and not present in non-Sun JDKs.\n", "   */\n", "  @Nullable\n", "  private static Object getJLA() {\n", "    try {\n", "      /*\n", "       * We load sun.misc.* classes using reflection since Android doesn't support these classes and\n", "       * would result in compilation failure if we directly refer to these classes.\n", "       */\n", "      Class<?> sharedSecrets = Class.forName(SHARED_SECRETS_CLASSNAME, false, null);\n", "      Method langAccess = sharedSecrets.getMethod(\"getJavaLangAccess\");\n", "      return langAccess.invoke(null);\n", "    } catch (ThreadDeath death) {\n", "      throw death;\n", "    } catch (Throwable t) {\n", "      /*\n", "       * This is not one of AppEngine's whitelisted classes, so even in Sun JDKs, this can fail with\n", "       * a NoClassDefFoundError. Other apps might deny access to sun.misc packages.\n", "       */\n", "      return null;\n", "    }\n", "  }\n", "\n", "  /**\n", "   * Returns the Method that can be used to resolve an individual StackTraceElement, or null if that\n", "   * method cannot be found (it is only to be found in fairly recent JDKs).\n", "   */\n", "  @Nullable\n", "  private static Method getGetMethod() {\n", "    return getJlaMethod(\"getStackTraceElement\", Throwable.class, int.class);\n", "  }\n", "\n", "  /**\n", "   * Returns the Method that can be used to return the size of a stack, or null if that method\n", "   * cannot be found (it is only to be found in fairly recent JDKs).\n", "   */\n", "  @Nullable\n", "  private static Method getSizeMethod() {\n", "    return getJlaMethod(\"getStackTraceDepth\", Throwable.class);\n", "  }\n", "\n", "  @Nullable\n", "  private static Method getJlaMethod(String name, Class<?>... parameterTypes) throws ThreadDeath {\n", "    try {\n", "      return Class.forName(JAVA_LANG_ACCESS_CLASSNAME, false, null).getMethod(name, parameterTypes);\n", "    } catch (ThreadDeath death) {\n", "      throw death;\n", "    } catch (Throwable t) {\n", "      /*\n", "       * Either the JavaLangAccess class itself is not found, or the method is not supported on the\n", "       * JVM.\n", "       */\n", "      return null;\n", "    }\n", "  }\n"]}, "removed": {"2": [" * \"http://code.google.com/p/guava-libraries/wiki/ThrowablesExplained\">\n", " * Throwables</a>.\n"], "3": ["   * Propagates {@code throwable} exactly as-is, if and only if it is an\n", "   * instance of {@code declaredType}.  Example usage:\n"], "4": ["   * Propagates {@code throwable} exactly as-is, if and only if it is an\n", "   * instance of {@link RuntimeException} or {@link Error}.  Example usage:\n"], "5": ["   * Propagates {@code throwable} exactly as-is, if and only if it is an\n", "   * instance of {@link RuntimeException}, {@link Error}, or\n", "   * {@code declaredType}. Example usage:\n"], "6": ["   * @param declaredType the single checked exception type declared by the\n", "   *     calling method\n"], "7": ["   * Propagates {@code throwable} exactly as-is, if and only if it is an\n", "   * instance of {@link RuntimeException}, {@link Error}, {@code declaredType1},\n", "   * or {@code declaredType2}.  In the unlikely case that you have three or more\n", "   * declared checked exception types, you can handle them all by invoking these\n", "   * methods repeatedly. See usage example in {@link\n", "   * @param declaredType1 any checked exception type declared by the calling\n", "   *     method\n", "   * @param declaredType2 any other checked exception type declared by the\n", "   *     calling method\n"], "8": ["   * Propagates {@code throwable} as-is if it is an instance of\n", "   * {@link RuntimeException} or {@link Error}, or else as a last resort, wraps\n", "   * it in a {@code RuntimeException} then propagates.\n", "   * This method always throws an exception. The {@code RuntimeException} return\n", "   * type is only for client code to make Java type system happy in case a\n", "   * return value is required by the enclosing method. Example usage:\n"], "9": ["   * @return nothing will ever be returned; this return type is only for your\n", "   *     convenience, as illustrated in the example above\n"], "10": ["   *   assertEquals(\"Unable to assign a customer id\",\n", "   *       Throwables.getRootCause(e).getMessage());\n"], "11": ["   * Gets a {@code Throwable} cause chain as a list.  The first entry in the\n", "   * list will be {@code throwable} followed by its cause hierarchy.  Note\n", "   * that this is a snapshot of the cause chain and will not reflect\n", "   * any subsequent changes to the cause chain.\n", "   * <p>Here's an example of how it can be used to find specific types\n", "   * of exceptions in the cause chain:\n", "   * @return an unmodifiable list containing the cause chain starting with\n", "   *     {@code throwable}\n"], "12": ["   * Returns a string containing the result of\n", "   * {@link Throwable#toString() toString()}, followed by the full, recursive\n", "   * stack trace of {@code throwable}. Note that you probably should not be\n", "   * parsing the resulting string; if you need programmatic access to the stack\n", "   * frames, you can call {@link Throwable#getStackTrace()}.\n"]}, "added_lines": {"1": [20, 21, 24, 28, 29, 30], "2": [41], "3": [51, 52], "4": [74, 75], "5": [93, 94], "6": [107], "7": [116, 117, 118, 119, 123, 124], "8": [135, 136, 138, 139, 140], "9": [154, 155], "10": [167], "11": [179, 180, 181, 183, 184, 191], "12": [205, 206, 207, 208, 215, 216, 217, 218, 219, 220, 221, 222, 223, 224, 225, 226, 227, 228, 229, 230, 231, 232, 233, 234, 235, 236, 237, 238, 239, 240, 241, 242, 243, 244, 245, 246, 247, 248, 249, 250, 251, 252, 253, 254, 255, 256, 257, 258, 259, 260, 261, 262, 263, 264, 265, 266, 267, 268, 269, 270, 271, 272, 273, 274, 275, 276, 277, 278, 279, 280, 281, 282, 283, 284, 285, 286, 287, 288, 289, 290, 291, 292, 293, 294, 295, 296, 297, 298, 299, 300, 301, 302, 303, 304, 305, 306, 307, 308, 309, 310, 311, 312, 313, 314, 315, 316, 317, 318, 319, 320, 321, 322, 323, 324, 325, 326, 327, 328, 329, 330, 331, 332, 333, 334, 335, 336, 337, 338, 339, 340, 341, 342, 343, 344, 345, 346, 347, 348, 349, 350, 351, 352, 353, 354, 355, 356, 357, 358, 359, 360, 361, 362, 363, 364, 365, 366, 367, 368, 369, 370, 371, 372, 373, 374, 375]}, "removed_lines": {"2": [35, 36], "3": [46, 47], "4": [69, 70], "5": [88, 89, 90], "6": [103, 104], "7": [113, 114, 115, 116, 117, 121, 122, 123, 124], "8": [135, 136, 137, 139, 140, 141], "9": [155, 156], "10": [168, 169], "11": [181, 182, 183, 184, 186, 187, 194, 195], "12": [209, 210, 211, 212, 213]}}]}
