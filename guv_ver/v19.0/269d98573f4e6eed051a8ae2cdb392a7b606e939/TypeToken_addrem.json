{
    "addition": {
        "748": "      // if \"to\" is <? super Foo>, \"from\" can be:\n",
        "749": "      // Foo, SubFoo, <? extends Foo>.\n",
        "750": "      // if \"to\" is <? extends Foo>, nothing assignable.\n",
        "751": "      return isAssignableToAny(from, ((WildcardType) to).getLowerBounds());\n",
        "753": "    // if \"from\" is wildcard, it's assignable to \"to\" if any of its \"extends\"\n",
        "756": "      // <? super Base> is of no use in checking 'from' being a subtype of 'to'.\n",
        "759": "    // if \"from\" is type variable, it's assignable if any of its \"extends\"\n",
        "760": "    // bounds is assignable to \"to\".\n",
        "761": "    if (from instanceof TypeVariable) {\n",
        "762": "      return from.equals(to)\n",
        "763": "          || isAssignableFromAny(((TypeVariable<?>) from).getBounds(), to);\n",
        "764": "    }\n",
        "780": "  /** Returns true if at least one of {@code fromTypes} is subtype of {@code to}. */\n",
        "790": "  /** Returns true if {@code from} is subtype of every type in {@code toTypes}. */\n",
        "791": "  private static boolean isAssignableToAll(Type from, Type[] toTypes) {\n",
        "792": "    for (Type to : toTypes) {\n",
        "793": "      if (!isAssignable(from, to)) {\n",
        "794": "        return false;\n",
        "795": "      }\n",
        "796": "    }\n",
        "797": "    return true;\n",
        "800": "  /** Returns true if at least one of {@code toTypes} is supertype of {@code from}. */\n",
        "801": "  private static boolean isAssignableToAny(Type from, Type[] toTypes) {\n",
        "802": "    for (Type to : toTypes) {\n",
        "803": "      if (isAssignable(from, to)) {\n",
        "804": "        return true;\n",
        "805": "      }\n",
        "806": "    }\n",
        "807": "    return false;\n",
        "810": "  /** Returns true if all of {@code fromTypes} are subtypes of {@code to}. */\n",
        "811": "  private static boolean areAssignableTo(Type[] fromTypes, Type to) {\n",
        "812": "    for (Type from : fromTypes) {\n",
        "813": "      if (!isAssignable(from, to)) {\n",
        "814": "        return false;\n",
        "815": "      }\n",
        "817": "    return true;\n",
        "818": "  }\n",
        "819": "\n",
        "820": "  private static boolean isAssignableToClass(Type from, Class<?> to) {\n",
        "821": "    return to.isAssignableFrom(getRawType(from));\n",
        "884": "      // if \"to\" is <? extends Foo>, \"from\" can be:\n",
        "885": "      // Foo, SubFoo, <? extends Foo>, <? extends SubFoo>, <T extends Foo> or\n",
        "886": "      // <T extends SubFoo>.\n",
        "887": "      // if \"to\" is <? super Foo>, \"from\" can be:\n",
        "888": "      // Foo, SuperFoo, <? super Foo> or <? super SuperFoo>.\n",
        "889": "      return isAssignableToAll(from, ((WildcardType) to).getUpperBounds())\n",
        "890": "          && areAssignableTo(((WildcardType) to).getLowerBounds(), from);\n"
    },
    "removed": {
        "747": "    if (to.equals(from)) {\n",
        "748": "      return true;\n",
        "749": "    }\n",
        "751": "      return isAssignableToWildcardType(from, (WildcardType) to);\n",
        "753": "    // if \"from\" is type variable, it's assignable if any of its \"extends\"\n",
        "754": "    // bounds is assignable to \"to\".\n",
        "755": "    if (from instanceof TypeVariable) {\n",
        "756": "      return isAssignableFromAny(((TypeVariable<?>) from).getBounds(), to);\n",
        "757": "    }\n",
        "758": "    // if \"from\" is wildcard, it'a assignable to \"to\" if any of its \"extends\"\n",
        "787": "  private static boolean isAssignableToClass(Type from, Class<?> to) {\n",
        "788": "    return to.isAssignableFrom(getRawType(from));\n",
        "791": "  private static boolean isAssignableToWildcardType(\n",
        "792": "      Type from, WildcardType to) {\n",
        "793": "    // if \"to\" is <? extends Foo>, \"from\" can be:\n",
        "794": "    // Foo, SubFoo, <? extends Foo>, <? extends SubFoo>, <T extends Foo> or\n",
        "795": "    // <T extends SubFoo>.\n",
        "796": "    // if \"to\" is <? super Foo>, \"from\" can be:\n",
        "797": "    // Foo, SuperFoo, <? super Foo> or <? super SuperFoo>.\n",
        "798": "    return isAssignable(from, supertypeBound(to)) && isAssignableBySubtypeBound(from, to);\n",
        "801": "  private static boolean isAssignableBySubtypeBound(Type from, WildcardType to) {\n",
        "802": "    Type toSubtypeBound = subtypeBound(to);\n",
        "803": "    if (toSubtypeBound == null) {\n",
        "804": "      return true;\n",
        "805": "    }\n",
        "806": "    Type fromSubtypeBound = subtypeBound(from);\n",
        "807": "    if (fromSubtypeBound == null) {\n",
        "808": "      return false;\n",
        "810": "    return isAssignable(toSubtypeBound, fromSubtypeBound);\n",
        "872": "      return isAssignableToWildcardType(from, (WildcardType) to);\n",
        "877": "  private static Type supertypeBound(Type type) {\n",
        "878": "    if (type instanceof WildcardType) {\n",
        "879": "      return supertypeBound((WildcardType) type);\n",
        "880": "    }\n",
        "881": "    return type;\n",
        "882": "  }\n",
        "883": "\n",
        "884": "  private static Type supertypeBound(WildcardType type) {\n",
        "885": "    Type[] upperBounds = type.getUpperBounds();\n",
        "886": "    if (upperBounds.length == 1) {\n",
        "887": "      return supertypeBound(upperBounds[0]);\n",
        "888": "    } else if (upperBounds.length == 0) {\n",
        "889": "      return Object.class;\n",
        "890": "    } else {\n",
        "891": "      throw new AssertionError(\n",
        "892": "          \"There should be at most one upper bound for wildcard type: \" + type);\n",
        "893": "    }\n",
        "894": "  }\n",
        "895": "\n",
        "896": "  @Nullable private static Type subtypeBound(Type type) {\n",
        "897": "    if (type instanceof WildcardType) {\n",
        "898": "      return subtypeBound((WildcardType) type);\n",
        "899": "    } else {\n",
        "900": "      return type;\n",
        "901": "    }\n",
        "902": "  }\n",
        "903": "\n",
        "904": "  @Nullable private static Type subtypeBound(WildcardType type) {\n",
        "905": "    Type[] lowerBounds = type.getLowerBounds();\n",
        "906": "    if (lowerBounds.length == 1) {\n",
        "907": "      return subtypeBound(lowerBounds[0]);\n",
        "908": "    } else if (lowerBounds.length == 0) {\n",
        "909": "      return null;\n",
        "910": "    } else {\n",
        "911": "      throw new AssertionError(\n",
        "912": "          \"Wildcard should have at most one lower bound: \" + type);\n",
        "913": "    }\n",
        "914": "  }\n",
        "915": "\n"
    }
}