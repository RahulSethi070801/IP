{"id": "269d98573f4e6eed051a8ae2cdb392a7b606e939", "code": [{"0": "guava-tests/test/com/google/common/reflect/TypeTokenTest.java", "added": {"1": ["  public void testGenericArrayType() {\n", "  public void testMultiDimensionalGenericArrayType() {\n", "  public <T> void testGenericVariableTypeArrays() {\n"], "2": ["  void testResolveType_fromTypeVariable() {\n"], "3": ["  void testResolveType_fromTypeVariable_onlyDirectBoundsAreUsed() {\n", "  public void testResolveType_fromWildcard() {\n"], "4": ["  public void testAssignableWildcardBoundedByArrayToArrayClass() {\n", "    assertFalse(TypeToken.of(wildcardType).isAssignableFrom(wildcardType));\n", "  public void testAssignableWildcardTypeParameterToClassTypeParameter() {\n", "    TypeToken<?> wildcardType = new TypeToken<Iterable<? extends Object[]>>() {};\n", "    assertFalse(new TypeToken<Iterable<Object[]>>() {}.isAssignableFrom(wildcardType));\n", "    assertFalse(new TypeToken<Iterable<Object>>() {}.isAssignableFrom(wildcardType));\n", "    assertTrue(wildcardType.isAssignableFrom(wildcardType));\n", "    assertFalse(new TypeToken<Iterable<int[]>>() {}.isAssignableFrom(wildcardType));\n", "  }\n", "\n", "  public void testAssignableArrayClassToBoundedWildcard() {\n", "    TypeToken<?> subtypeOfArray = TypeToken.of(Types.subtypeOf(Object[].class));\n", "    TypeToken<?> supertypeOfArray = TypeToken.of(Types.supertypeOf(Object[].class));\n", "    assertFalse(subtypeOfArray.isAssignableFrom(Object[].class));\n", "    assertFalse(subtypeOfArray.isAssignableFrom(Object[][].class));\n", "    assertFalse(subtypeOfArray.isAssignableFrom(String[].class));\n", "    assertTrue(supertypeOfArray.isAssignableFrom(Object[].class));\n", "    assertFalse(supertypeOfArray.isAssignableFrom(Object.class));\n", "    assertTrue(supertypeOfArray.isAssignableFrom(Object[][].class));\n", "    assertTrue(supertypeOfArray.isAssignableFrom(String[].class));\n", "  }\n", "\n", "  public void testAssignableClassTypeParameterToWildcardTypeParameter() {\n", "    TypeToken<?> subtypeOfArray = new TypeToken<Iterable<? extends Object[]>>() {};\n", "    TypeToken<?> supertypeOfArray = new TypeToken<Iterable<? super Object[]>>() {};\n", "    assertTrue(subtypeOfArray.isAssignableFrom(new TypeToken<Iterable<Object[]>>() {}));\n", "    assertTrue(subtypeOfArray.isAssignableFrom(new TypeToken<Iterable<Object[][]>>() {}));\n", "    assertTrue(subtypeOfArray.isAssignableFrom(new TypeToken<Iterable<String[]>>() {}));\n", "    assertTrue(supertypeOfArray.isAssignableFrom(new TypeToken<Iterable<Object[]>>() {}));\n", "    assertTrue(supertypeOfArray.isAssignableFrom(new TypeToken<Iterable<Object>>() {}));\n", "    assertFalse(supertypeOfArray.isAssignableFrom(new TypeToken<Iterable<Object[][]>>() {}));\n", "    assertFalse(supertypeOfArray.isAssignableFrom(new TypeToken<Iterable<String[]>>() {}));\n", "  }\n", "\n", "  public void testAssignableNonParameterizedClassToWildcard() {\n", "    TypeToken<?> supertypeOfString = TypeToken.of(Types.supertypeOf(String.class));\n", "    assertFalse(supertypeOfString.isAssignableFrom(supertypeOfString));\n", "    assertFalse(supertypeOfString.isAssignableFrom(Object.class));\n", "    assertFalse(supertypeOfString.isAssignableFrom(CharSequence.class));\n", "    assertTrue(supertypeOfString.isAssignableFrom(String.class));\n", "    assertTrue(supertypeOfString.isAssignableFrom(Types.subtypeOf(String.class)));\n", "  }\n", "\n", "  public void testAssignableWildcardBoundedByIntArrayToArrayClass() {\n", "    assertFalse(TypeToken.of(wildcardType).isAssignableFrom(wildcardType));\n", "  public void testAssignableWildcardTypeParameterBoundedByIntArrayToArrayClassTypeParameter() {\n", "    TypeToken<?> wildcardType = new TypeToken<Iterable<? extends int[]>>() {};\n", "    assertFalse(new TypeToken<Iterable<int[]>>() {}.isAssignableFrom(wildcardType));\n", "    assertFalse(new TypeToken<Iterable<Object>>() {}.isAssignableFrom(wildcardType));\n", "    assertTrue(wildcardType.isAssignableFrom(wildcardType));\n", "    assertFalse(new TypeToken<Iterable<Object[]>>() {}.isAssignableFrom(wildcardType));\n", "  }\n", "\n", "  public void testAssignableWildcardToWildcard() {\n", "    TypeToken<?> subtypeOfArray = TypeToken.of(Types.subtypeOf(Object[].class));\n", "    TypeToken<?> supertypeOfArray = TypeToken.of(Types.supertypeOf(Object[].class));\n", "    assertTrue(supertypeOfArray.isAssignableFrom(subtypeOfArray));\n", "    assertFalse(supertypeOfArray.isAssignableFrom(supertypeOfArray));\n", "    assertFalse(subtypeOfArray.isAssignableFrom(subtypeOfArray));\n", "    assertFalse(subtypeOfArray.isAssignableFrom(supertypeOfArray));\n", "  }\n", "\n", "  public void testAssignableWildcardTypeParameterToWildcardTypeParameter() {\n", "    TypeToken<?> subtypeOfArray = new TypeToken<Iterable<? extends Object[]>>() {};\n", "    TypeToken<?> supertypeOfArray = new TypeToken<Iterable<? super Object[]>>() {};\n", "    assertFalse(supertypeOfArray.isAssignableFrom(subtypeOfArray));\n", "    assertTrue(supertypeOfArray.isAssignableFrom(supertypeOfArray));\n", "    assertTrue(subtypeOfArray.isAssignableFrom(subtypeOfArray));\n", "    assertFalse(subtypeOfArray.isAssignableFrom(supertypeOfArray));\n"], "5": ["  public void testAssignableArrayToClass() {\n"], "6": ["  public void testGenericArrayTypeToArrayType() {\n"], "7": ["  public void testIsArray_wildcardType() {\n"], "8": ["  public void testGetComponentType_wildcardType() {\n"], "9": ["  public void testRawTypes() {\n"]}, "removed": {"1": ["  public void testGenericArrayType() throws Exception {\n", "  public void testMultiDimensionalGenericArrayType() throws Exception {\n", "  public <T> void testGenericVariableTypeArrays() throws Exception {\n"], "2": ["  void testResolveType_fromTypeVariable() throws Exception {\n"], "3": ["  void testResolveType_fromTypeVariable_onlyDirectBoundsAreUsed() throws Exception {\n", "  public void testResolveType_fromWildcard() throws Exception {\n"], "4": ["  public void testAssignableWildcardBoundedByArrayToArrayClass() throws Exception {\n", "    assertTrue(TypeToken.of(wildcardType).isAssignableFrom(wildcardType));\n", "  public void testAssignableArrayClassToBoundedWildcard() throws Exception {\n", "    TypeToken<?> upperBounded = TypeToken.of(Types.subtypeOf(Object[].class));\n", "    TypeToken<?> lowerBounded = TypeToken.of(Types.supertypeOf(Object[].class));\n", "    assertTrue(upperBounded.isAssignableFrom(Object[].class));\n", "    assertTrue(upperBounded.isAssignableFrom(Object[][].class));\n", "    assertTrue(upperBounded.isAssignableFrom(String[].class));\n", "    assertTrue(lowerBounded.isAssignableFrom(Object[].class));\n", "    assertTrue(lowerBounded.isAssignableFrom(Object.class));\n", "    assertFalse(lowerBounded.isAssignableFrom(Object[][].class));\n", "    assertFalse(lowerBounded.isAssignableFrom(String[].class));\n", "  }\n", "\n", "  public void testAssignableWildcardBoundedByIntArrayToArrayClass() throws Exception {\n", "    assertTrue(TypeToken.of(wildcardType).isAssignableFrom(wildcardType));\n", "  public void testAssignableWildcardToWildcard() throws Exception {\n", "    TypeToken<?> upperBounded = TypeToken.of(Types.subtypeOf(Object[].class));\n", "    TypeToken<?> lowerBounded = TypeToken.of(Types.supertypeOf(Object[].class));\n", "    assertFalse(lowerBounded.isAssignableFrom(upperBounded));\n", "    assertTrue(lowerBounded.isAssignableFrom(lowerBounded));\n", "    assertTrue(upperBounded.isAssignableFrom(upperBounded));\n", "    assertFalse(upperBounded.isAssignableFrom(lowerBounded));\n"], "5": ["  public void testAssignableArrayToClass() throws Exception {\n"], "6": ["  public void testGenericArrayTypeToArrayType() throws Exception {\n"], "7": ["  public void testIsArray_wildcardType() throws Exception {\n"], "8": ["  public void testGetComponentType_wildcardType() throws Exception {\n"], "9": ["  public void testRawTypes() throws Exception {\n"]}, "added_lines": {"1": [112, 118, 124], "2": [136], "3": [147, 153], "4": [596, 600, 604, 605, 606, 607, 608, 609, 610, 611, 612, 613, 614, 615, 616, 617, 618, 619, 620, 621, 622, 623, 624, 625, 626, 627, 628, 629, 630, 631, 632, 633, 634, 635, 636, 637, 638, 639, 640, 641, 642, 643, 644, 645, 649, 653, 654, 655, 656, 657, 658, 659, 660, 661, 662, 663, 664, 665, 666, 667, 668, 669, 670, 671, 672, 673, 674, 675, 676], "5": [698], "6": [759], "7": [953], "8": [996], "9": [1483]}, "removed_lines": {"1": [112, 118, 124], "2": [136], "3": [147, 153], "4": [596, 600, 604, 605, 606, 607, 608, 609, 610, 611, 612, 613, 614, 615, 616, 620, 624, 625, 626, 627, 628, 629, 630], "5": [652], "6": [713], "7": [907], "8": [950], "9": [1437]}}, {"1": "guava/src/com/google/common/reflect/TypeToken.java", "added": {"1": ["      // if \"to\" is <? super Foo>, \"from\" can be:\n", "      // Foo, SubFoo, <? extends Foo>.\n", "      // if \"to\" is <? extends Foo>, nothing assignable.\n", "      return isAssignableToAny(from, ((WildcardType) to).getLowerBounds());\n", "    // if \"from\" is wildcard, it's assignable to \"to\" if any of its \"extends\"\n", "      // <? super Base> is of no use in checking 'from' being a subtype of 'to'.\n", "    // if \"from\" is type variable, it's assignable if any of its \"extends\"\n", "    // bounds is assignable to \"to\".\n", "    if (from instanceof TypeVariable) {\n", "      return from.equals(to)\n", "          || isAssignableFromAny(((TypeVariable<?>) from).getBounds(), to);\n", "    }\n"], "2": ["  /** Returns true if at least one of {@code fromTypes} is subtype of {@code to}. */\n"], "3": ["  /** Returns true if {@code from} is subtype of every type in {@code toTypes}. */\n", "  private static boolean isAssignableToAll(Type from, Type[] toTypes) {\n", "    for (Type to : toTypes) {\n", "      if (!isAssignable(from, to)) {\n", "        return false;\n", "      }\n", "    }\n", "    return true;\n", "  /** Returns true if at least one of {@code toTypes} is supertype of {@code from}. */\n", "  private static boolean isAssignableToAny(Type from, Type[] toTypes) {\n", "    for (Type to : toTypes) {\n", "      if (isAssignable(from, to)) {\n", "        return true;\n", "      }\n", "    }\n", "    return false;\n", "  /** Returns true if all of {@code fromTypes} are subtypes of {@code to}. */\n", "  private static boolean areAssignableTo(Type[] fromTypes, Type to) {\n", "    for (Type from : fromTypes) {\n", "      if (!isAssignable(from, to)) {\n", "        return false;\n", "      }\n", "    return true;\n", "  }\n", "\n", "  private static boolean isAssignableToClass(Type from, Class<?> to) {\n", "    return to.isAssignableFrom(getRawType(from));\n"], "4": ["      // if \"to\" is <? extends Foo>, \"from\" can be:\n", "      // Foo, SubFoo, <? extends Foo>, <? extends SubFoo>, <T extends Foo> or\n", "      // <T extends SubFoo>.\n", "      // if \"to\" is <? super Foo>, \"from\" can be:\n", "      // Foo, SuperFoo, <? super Foo> or <? super SuperFoo>.\n", "      return isAssignableToAll(from, ((WildcardType) to).getUpperBounds())\n", "          && areAssignableTo(((WildcardType) to).getLowerBounds(), from);\n"]}, "removed": {"1": ["    if (to.equals(from)) {\n", "      return true;\n", "    }\n", "      return isAssignableToWildcardType(from, (WildcardType) to);\n", "    // if \"from\" is type variable, it's assignable if any of its \"extends\"\n", "    // bounds is assignable to \"to\".\n", "    if (from instanceof TypeVariable) {\n", "      return isAssignableFromAny(((TypeVariable<?>) from).getBounds(), to);\n", "    }\n", "    // if \"from\" is wildcard, it'a assignable to \"to\" if any of its \"extends\"\n"], "3": ["  private static boolean isAssignableToClass(Type from, Class<?> to) {\n", "    return to.isAssignableFrom(getRawType(from));\n", "  private static boolean isAssignableToWildcardType(\n", "      Type from, WildcardType to) {\n", "    // if \"to\" is <? extends Foo>, \"from\" can be:\n", "    // Foo, SubFoo, <? extends Foo>, <? extends SubFoo>, <T extends Foo> or\n", "    // <T extends SubFoo>.\n", "    // if \"to\" is <? super Foo>, \"from\" can be:\n", "    // Foo, SuperFoo, <? super Foo> or <? super SuperFoo>.\n", "    return isAssignable(from, supertypeBound(to)) && isAssignableBySubtypeBound(from, to);\n", "  private static boolean isAssignableBySubtypeBound(Type from, WildcardType to) {\n", "    Type toSubtypeBound = subtypeBound(to);\n", "    if (toSubtypeBound == null) {\n", "      return true;\n", "    }\n", "    Type fromSubtypeBound = subtypeBound(from);\n", "    if (fromSubtypeBound == null) {\n", "      return false;\n", "    return isAssignable(toSubtypeBound, fromSubtypeBound);\n"], "4": ["      return isAssignableToWildcardType(from, (WildcardType) to);\n", "  private static Type supertypeBound(Type type) {\n", "    if (type instanceof WildcardType) {\n", "      return supertypeBound((WildcardType) type);\n", "    }\n", "    return type;\n", "  }\n", "\n", "  private static Type supertypeBound(WildcardType type) {\n", "    Type[] upperBounds = type.getUpperBounds();\n", "    if (upperBounds.length == 1) {\n", "      return supertypeBound(upperBounds[0]);\n", "    } else if (upperBounds.length == 0) {\n", "      return Object.class;\n", "    } else {\n", "      throw new AssertionError(\n", "          \"There should be at most one upper bound for wildcard type: \" + type);\n", "    }\n", "  }\n", "\n", "  @Nullable private static Type subtypeBound(Type type) {\n", "    if (type instanceof WildcardType) {\n", "      return subtypeBound((WildcardType) type);\n", "    } else {\n", "      return type;\n", "    }\n", "  }\n", "\n", "  @Nullable private static Type subtypeBound(WildcardType type) {\n", "    Type[] lowerBounds = type.getLowerBounds();\n", "    if (lowerBounds.length == 1) {\n", "      return subtypeBound(lowerBounds[0]);\n", "    } else if (lowerBounds.length == 0) {\n", "      return null;\n", "    } else {\n", "      throw new AssertionError(\n", "          \"Wildcard should have at most one lower bound: \" + type);\n", "    }\n", "  }\n", "\n"]}, "added_lines": {"1": [748, 749, 750, 751, 753, 756, 759, 760, 761, 762, 763, 764], "2": [780], "3": [790, 791, 792, 793, 794, 795, 796, 797, 800, 801, 802, 803, 804, 805, 806, 807, 810, 811, 812, 813, 814, 815, 817, 818, 819, 820, 821], "4": [884, 885, 886, 887, 888, 889, 890]}, "removed_lines": {"1": [747, 748, 749, 751, 753, 754, 755, 756, 757, 758], "3": [787, 788, 791, 792, 793, 794, 795, 796, 797, 798, 801, 802, 803, 804, 805, 806, 807, 808, 810], "4": [872, 877, 878, 879, 880, 881, 882, 883, 884, 885, 886, 887, 888, 889, 890, 891, 892, 893, 894, 895, 896, 897, 898, 899, 900, 901, 902, 903, 904, 905, 906, 907, 908, 909, 910, 911, 912, 913, 914, 915]}}]}
