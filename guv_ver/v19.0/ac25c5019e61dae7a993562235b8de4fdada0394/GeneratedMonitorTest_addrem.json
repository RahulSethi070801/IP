{
    "addition": {
        "1": "/*\n",
        "2": " * Copyright (C) 2014 The Guava Authors\n",
        "3": " *\n",
        "4": " * Licensed under the Apache License, Version 2.0 (the \"License\");\n",
        "5": " * you may not use this file except in compliance with the License.\n",
        "6": " * You may obtain a copy of the License at\n",
        "7": " *\n",
        "8": " * http://www.apache.org/licenses/LICENSE-2.0\n",
        "9": " *\n",
        "10": " * Unless required by applicable law or agreed to in writing, software\n",
        "11": " * distributed under the License is distributed on an \"AS IS\" BASIS,\n",
        "12": " * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n",
        "13": " * See the License for the specific language governing permissions and\n",
        "14": " * limitations under the License.\n",
        "15": " */\n",
        "16": "\n",
        "17": "package com.google.common.util.concurrent;\n",
        "18": "\n",
        "19": "import static com.google.common.util.concurrent.Uninterruptibles.awaitUninterruptibly;\n",
        "20": "\n",
        "21": "import com.google.common.base.CaseFormat;\n",
        "22": "import com.google.common.collect.ImmutableList;\n",
        "23": "import com.google.common.primitives.Ints;\n",
        "24": "import junit.framework.TestCase;\n",
        "25": "import junit.framework.TestSuite;\n",
        "26": "\n",
        "27": "import java.lang.reflect.InvocationTargetException;\n",
        "28": "import java.lang.reflect.Method;\n",
        "29": "import java.util.Arrays;\n",
        "30": "import java.util.Comparator;\n",
        "31": "import java.util.concurrent.CountDownLatch;\n",
        "32": "import java.util.concurrent.FutureTask;\n",
        "33": "import java.util.concurrent.TimeUnit;\n",
        "34": "\n",
        "35": "/**\n",
        "36": " * Generated tests for {@link Monitor}.\n",
        "37": " *\n",
        "38": " * <p>This test class generates all of its own test cases in the {@link #suite()} method. Every\n",
        "39": " * {@code enterXxx}, {@code tryEnterXxx}, and {@code waitForXxx} method of the {@code Monitor} class\n",
        "40": " * is analyzed reflectively to determine appropriate test cases based on its signature. Additional\n",
        "41": " * ad hoc test cases can be found in {@link SupplementalMonitorTest}.\n",
        "42": " *\n",
        "43": " * @author Justin T. Sampson\n",
        "44": " */\n",
        "45": "\n",
        "46": "public class GeneratedMonitorTest extends TestCase {\n",
        "47": "\n",
        "48": "  public static TestSuite suite() {\n",
        "49": "    TestSuite suite = new TestSuite();\n",
        "50": "\n",
        "51": "    Method[] methods = Monitor.class.getMethods();\n",
        "52": "    sortMethods(methods);\n",
        "53": "    for (Method method : methods) {\n",
        "54": "      if (isAnyEnter(method) || isWaitFor(method)) {\n",
        "55": "        validateMethod(method);\n",
        "56": "        addTests(suite, method);\n",
        "57": "      }\n",
        "58": "    }\n",
        "59": "\n",
        "60": "    assertEquals(548, suite.testCount());\n",
        "61": "\n",
        "62": "    return suite;\n",
        "63": "  }\n",
        "64": "\n",
        "65": "  /**\n",
        "66": "   * A typical timeout value we'll use in the tests.\n",
        "67": "   */\n",
        "68": "  private static final long SMALL_TIMEOUT_MILLIS = 10;\n",
        "69": "\n",
        "70": "  /**\n",
        "71": "   * How long to wait when determining that a thread is blocked if we expect it to be blocked.\n",
        "72": "   */\n",
        "73": "  private static final long EXPECTED_HANG_DELAY_MILLIS = 75;\n",
        "74": "\n",
        "75": "  /**\n",
        "76": "   * How long to wait when determining that a thread is blocked if we DON'T expect it to be blocked.\n",
        "77": "   */\n",
        "78": "  private static final long UNEXPECTED_HANG_DELAY_MILLIS = 10000;\n",
        "79": "\n",
        "80": "  /**\n",
        "81": "   * Various scenarios to be generated for each method under test. The actual scenario generation\n",
        "82": "   * (determining which scenarios are applicable to which methods and what the outcome should be)\n",
        "83": "   * takes place in {@link #addTests(TestSuite, Method)}.\n",
        "84": "   */\n",
        "85": "  private enum Scenario {\n",
        "86": "\n",
        "87": "    SATISFIED_AND_UNOCCUPIED_BEFORE_ENTERING,\n",
        "88": "    UNSATISFIED_AND_UNOCCUPIED_BEFORE_ENTERING,\n",
        "89": "    SATISFIED_AND_OCCUPIED_BEFORE_ENTERING,\n",
        "90": "    SATISFIED_UNOCCUPIED_AND_INTERRUPTED_BEFORE_ENTERING,\n",
        "91": "\n",
        "92": "    SATISFIED_BEFORE_WAITING,\n",
        "93": "    SATISFIED_WHILE_WAITING,\n",
        "94": "    SATISFIED_AND_INTERRUPTED_BEFORE_WAITING,\n",
        "95": "    UNSATISFIED_BEFORE_AND_WHILE_WAITING,\n",
        "96": "    UNSATISFIED_AND_INTERRUPTED_BEFORE_WAITING;\n",
        "97": "\n",
        "98": "    @Override\n",
        "99": "    public String toString() {\n",
        "100": "      return CaseFormat.UPPER_UNDERSCORE.to(CaseFormat.UPPER_CAMEL, name());\n",
        "101": "    }\n",
        "102": "\n",
        "103": "  }\n",
        "104": "\n",
        "105": "  /**\n",
        "106": "   * Timeout values to combine with each {@link Scenario}.\n",
        "107": "   */\n",
        "108": "  private enum Timeout {\n",
        "109": "\n",
        "110": "    MIN(Long.MIN_VALUE, \"-oo\"),\n",
        "111": "    MINUS_SMALL(-SMALL_TIMEOUT_MILLIS, \"-\" + SMALL_TIMEOUT_MILLIS + \"ms\"),\n",
        "112": "    ZERO(0L, \"0ms\"),\n",
        "113": "    SMALL(SMALL_TIMEOUT_MILLIS, SMALL_TIMEOUT_MILLIS + \"ms\"),\n",
        "114": "    LARGE(UNEXPECTED_HANG_DELAY_MILLIS * 2, (2 * UNEXPECTED_HANG_DELAY_MILLIS) + \"ms\"),\n",
        "115": "    MAX(Long.MAX_VALUE, \"+oo\");\n",
        "116": "\n",
        "117": "    final long millis;\n",
        "118": "    final String label;\n",
        "119": "\n",
        "120": "    private Timeout(long millis, String label) {\n",
        "121": "      this.millis = millis;\n",
        "122": "      this.label = label;\n",
        "123": "    }\n",
        "124": "\n",
        "125": "    @Override\n",
        "126": "    public String toString() {\n",
        "127": "      return label;\n",
        "128": "    }\n",
        "129": "\n",
        "130": "  }\n",
        "131": "\n",
        "132": "  /**\n",
        "133": "   * Convenient subsets of the {@link Timeout} enumeration for specifying scenario outcomes.\n",
        "134": "   */\n",
        "135": "  private enum TimeoutsToUse {\n",
        "136": "\n",
        "137": "    ANY(Timeout.values()),\n",
        "138": "    PAST(Timeout.MIN, Timeout.MINUS_SMALL, Timeout.ZERO),\n",
        "139": "    FUTURE(Timeout.SMALL, Timeout.MAX),\n",
        "140": "    SMALL(Timeout.SMALL),\n",
        "141": "    FINITE(Timeout.MIN, Timeout.MINUS_SMALL, Timeout.ZERO, Timeout.SMALL),\n",
        "142": "    INFINITE(Timeout.LARGE, Timeout.MAX);\n",
        "143": "\n",
        "144": "    final ImmutableList<Timeout> timeouts;\n",
        "145": "\n",
        "146": "    private TimeoutsToUse(Timeout... timeouts) {\n",
        "147": "      this.timeouts = ImmutableList.copyOf(timeouts);\n",
        "148": "    }\n",
        "149": "\n",
        "150": "  }\n",
        "151": "\n",
        "152": "  /**\n",
        "153": "   * Possible outcomes of calling any of the methods under test.\n",
        "154": "   */\n",
        "155": "  private enum Outcome {\n",
        "156": "\n",
        "157": "    /**\n",
        "158": "     * The method returned normally and is either void or returned true.\n",
        "159": "     */\n",
        "160": "    SUCCESS,\n",
        "161": "\n",
        "162": "    /**\n",
        "163": "     * The method returned false.\n",
        "164": "     */\n",
        "165": "    FAILURE,\n",
        "166": "\n",
        "167": "    /**\n",
        "168": "     * The method threw an InterruptedException.\n",
        "169": "     */\n",
        "170": "    INTERRUPT,\n",
        "171": "\n",
        "172": "    /**\n",
        "173": "     * The method did not return or throw anything.\n",
        "174": "     */\n",
        "175": "    HANG;\n",
        "176": "\n",
        "177": "    @Override\n",
        "178": "    public String toString() {\n",
        "179": "      return CaseFormat.UPPER_UNDERSCORE.to(CaseFormat.UPPER_CAMEL, name());\n",
        "180": "    }\n",
        "181": "\n",
        "182": "  }\n",
        "183": "\n",
        "184": "  /**\n",
        "185": "   * Identifies all enterXxx and tryEnterXxx methods.\n",
        "186": "   */\n",
        "187": "  private static boolean isAnyEnter(Method method) {\n",
        "188": "    return method.getName().startsWith(\"enter\") || method.getName().startsWith(\"tryEnter\");\n",
        "189": "  }\n",
        "190": "\n",
        "191": "  /**\n",
        "192": "   * Identifies just tryEnterXxx methods (a subset of {@link #isAnyEnter}), which never block.\n",
        "193": "   */\n",
        "194": "  private static boolean isTryEnter(Method method) {\n",
        "195": "    return method.getName().startsWith(\"tryEnter\");\n",
        "196": "  }\n",
        "197": "\n",
        "198": "  /**\n",
        "199": "   * Identifies just enterIfXxx methods (a subset of {@link #isAnyEnter}), which are mostly like the\n",
        "200": "   * enterXxx methods but behave like tryEnterXxx in some scenarios.\n",
        "201": "   */\n",
        "202": "  private static boolean isEnterIf(Method method) {\n",
        "203": "    return method.getName().startsWith(\"enterIf\");\n",
        "204": "  }\n",
        "205": "\n",
        "206": "  /**\n",
        "207": "   * Identifies all waitForXxx methods, which must be called while occupying the monitor.\n",
        "208": "   */\n",
        "209": "  private static boolean isWaitFor(Method method) {\n",
        "210": "    return method.getName().startsWith(\"waitFor\");\n",
        "211": "  }\n",
        "212": "\n",
        "213": "  /**\n",
        "214": "   * Determines whether the given method takes a Guard as its first parameter.\n",
        "215": "   */\n",
        "216": "  private static boolean isGuarded(Method method) {\n",
        "217": "    Class<?>[] parameterTypes = method.getParameterTypes();\n",
        "218": "    return parameterTypes.length >= 1 && parameterTypes[0] == Monitor.Guard.class;\n",
        "219": "  }\n",
        "220": "\n",
        "221": "  /**\n",
        "222": "   * Determines whether the given method takes a time and unit as its last two parameters.\n",
        "223": "   */\n",
        "224": "  private static boolean isTimed(Method method) {\n",
        "225": "    Class<?>[] parameterTypes = method.getParameterTypes();\n",
        "226": "    return parameterTypes.length >= 2\n",
        "227": "        && parameterTypes[parameterTypes.length - 2] == long.class\n",
        "228": "        && parameterTypes[parameterTypes.length - 1] == TimeUnit.class;\n",
        "229": "  }\n",
        "230": "\n",
        "231": "  /**\n",
        "232": "   * Determines whether the given method returns a boolean value.\n",
        "233": "   */\n",
        "234": "  private static boolean isBoolean(Method method) {\n",
        "235": "    return method.getReturnType() == boolean.class;\n",
        "236": "  }\n",
        "237": "\n",
        "238": "  /**\n",
        "239": "   * Determines whether the given method can throw InterruptedException.\n",
        "240": "   */\n",
        "241": "  private static boolean isInterruptible(Method method) {\n",
        "242": "    return Arrays.asList(method.getExceptionTypes()).contains(InterruptedException.class);\n",
        "243": "  }\n",
        "244": "\n",
        "245": "  /**\n",
        "246": "   * Sorts the given methods primarily by name and secondarily by number of parameters.\n",
        "247": "   */\n",
        "248": "  private static void sortMethods(Method[] methods) {\n",
        "249": "    Arrays.sort(methods, new Comparator<Method>() {\n",
        "250": "      @Override public int compare(Method m1, Method m2) {\n",
        "251": "        int nameComparison = m1.getName().compareTo(m2.getName());\n",
        "252": "        if (nameComparison != 0) {\n",
        "253": "          return nameComparison;\n",
        "254": "        } else {\n",
        "255": "          return Ints.compare(m1.getParameterTypes().length, m2.getParameterTypes().length);\n",
        "256": "        }\n",
        "257": "      }\n",
        "258": "    });\n",
        "259": "  }\n",
        "260": "\n",
        "261": "  /**\n",
        "262": "   * Validates that the given method's signature meets all of our assumptions.\n",
        "263": "   */\n",
        "264": "  private static void validateMethod(Method method) {\n",
        "265": "    String desc = method.toString();\n",
        "266": "\n",
        "267": "    assertTrue(desc, isAnyEnter(method) || isWaitFor(method));\n",
        "268": "\n",
        "269": "    switch (method.getParameterTypes().length) {\n",
        "270": "      case 0:\n",
        "271": "        assertFalse(desc, isGuarded(method));\n",
        "272": "        assertFalse(desc, isTimed(method));\n",
        "273": "        break;\n",
        "274": "      case 1:\n",
        "275": "        assertTrue(desc, isGuarded(method));\n",
        "276": "        assertFalse(desc, isTimed(method));\n",
        "277": "        break;\n",
        "278": "      case 2:\n",
        "279": "        assertFalse(desc, isGuarded(method));\n",
        "280": "        assertTrue(desc, isTimed(method));\n",
        "281": "        break;\n",
        "282": "      case 3:\n",
        "283": "        assertTrue(desc, isGuarded(method));\n",
        "284": "        assertTrue(desc, isTimed(method));\n",
        "285": "        break;\n",
        "286": "      default:\n",
        "287": "        fail(desc);\n",
        "288": "    }\n",
        "289": "\n",
        "290": "    if (method.getReturnType() == void.class) {\n",
        "291": "      assertFalse(desc, isBoolean(method));\n",
        "292": "    } else {\n",
        "293": "      assertTrue(desc, isBoolean(method));\n",
        "294": "    }\n",
        "295": "\n",
        "296": "    switch (method.getExceptionTypes().length) {\n",
        "297": "      case 0:\n",
        "298": "        assertFalse(desc, isInterruptible(method));\n",
        "299": "        break;\n",
        "300": "      case 1:\n",
        "301": "        assertTrue(desc, isInterruptible(method));\n",
        "302": "        break;\n",
        "303": "      default:\n",
        "304": "        fail(desc);\n",
        "305": "    }\n",
        "306": "\n",
        "307": "    if (isEnterIf(method)) {\n",
        "308": "      assertTrue(desc, isGuarded(method));\n",
        "309": "      assertTrue(desc, isBoolean(method));\n",
        "310": "    } else if (isTryEnter(method)) {\n",
        "311": "      assertFalse(desc, isTimed(method));\n",
        "312": "      assertTrue(desc, isBoolean(method));\n",
        "313": "      assertFalse(desc, isInterruptible(method));\n",
        "314": "    } else if (isWaitFor(method)) {\n",
        "315": "      assertTrue(desc, isGuarded(method));\n",
        "316": "      assertEquals(desc, isTimed(method), isBoolean(method));\n",
        "317": "    } else { // any other enterXxx method\n",
        "318": "      assertEquals(desc, isTimed(method), isBoolean(method));\n",
        "319": "    }\n",
        "320": "  }\n",
        "321": "\n",
        "322": "  /**\n",
        "323": "   * Generates all test cases appropriate for the given method.\n",
        "324": "   */\n",
        "325": "  private static void addTests(TestSuite suite, Method method) {\n",
        "326": "    if (isGuarded(method)) {\n",
        "327": "      for (boolean fair1 : new boolean[] { true, false }) {\n",
        "328": "        for (boolean fair2 : new boolean[] { true, false }) {\n",
        "329": "          suite.addTest(generateGuardWithWrongMonitorTestCase(method, fair1, fair2));\n",
        "330": "        }\n",
        "331": "      }\n",
        "332": "    }\n",
        "333": "    if (isAnyEnter(method)) {\n",
        "334": "      addTests(suite, method,\n",
        "335": "          Scenario.SATISFIED_AND_UNOCCUPIED_BEFORE_ENTERING,\n",
        "336": "          TimeoutsToUse.ANY,\n",
        "337": "          Outcome.SUCCESS);\n",
        "338": "      addTests(suite, method,\n",
        "339": "          Scenario.UNSATISFIED_AND_UNOCCUPIED_BEFORE_ENTERING,\n",
        "340": "          TimeoutsToUse.FINITE,\n",
        "341": "          isGuarded(method)\n",
        "342": "              ? (isBoolean(method) ? Outcome.FAILURE : Outcome.HANG)\n",
        "343": "              : Outcome.SUCCESS);\n",
        "344": "      addTests(suite, method,\n",
        "345": "          Scenario.UNSATISFIED_AND_UNOCCUPIED_BEFORE_ENTERING,\n",
        "346": "          TimeoutsToUse.INFINITE,\n",
        "347": "          isGuarded(method)\n",
        "348": "              ? (isTryEnter(method) || isEnterIf(method) ? Outcome.FAILURE : Outcome.HANG)\n",
        "349": "              : Outcome.SUCCESS);\n",
        "350": "      addTests(suite, method,\n",
        "351": "          Scenario.SATISFIED_AND_OCCUPIED_BEFORE_ENTERING,\n",
        "352": "          TimeoutsToUse.FINITE,\n",
        "353": "          isBoolean(method) ? Outcome.FAILURE : Outcome.HANG);\n",
        "354": "      addTests(suite, method,\n",
        "355": "          Scenario.SATISFIED_AND_OCCUPIED_BEFORE_ENTERING,\n",
        "356": "          TimeoutsToUse.INFINITE,\n",
        "357": "          isGuarded(method)\n",
        "358": "              ? Outcome.HANG\n",
        "359": "              : (isTryEnter(method) ? Outcome.FAILURE : Outcome.HANG));\n",
        "360": "      addTests(suite, method,\n",
        "361": "          Scenario.SATISFIED_UNOCCUPIED_AND_INTERRUPTED_BEFORE_ENTERING,\n",
        "362": "          TimeoutsToUse.ANY,\n",
        "363": "          isInterruptible(method) ? Outcome.INTERRUPT : Outcome.SUCCESS);\n",
        "364": "    } else { // any waitForXxx method\n",
        "365": "      suite.addTest(generateWaitForWhenNotOccupyingTestCase(method, true));\n",
        "366": "      suite.addTest(generateWaitForWhenNotOccupyingTestCase(method, false));\n",
        "367": "      addTests(suite, method,\n",
        "368": "          Scenario.SATISFIED_BEFORE_WAITING,\n",
        "369": "          TimeoutsToUse.ANY,\n",
        "370": "          Outcome.SUCCESS);\n",
        "371": "      addTests(suite, method,\n",
        "372": "          Scenario.SATISFIED_WHILE_WAITING,\n",
        "373": "          TimeoutsToUse.INFINITE,\n",
        "374": "          Outcome.SUCCESS);\n",
        "375": "      addTests(suite, method,\n",
        "376": "          Scenario.SATISFIED_WHILE_WAITING,\n",
        "377": "          TimeoutsToUse.PAST,\n",
        "378": "          Outcome.FAILURE);\n",
        "379": "      addTests(suite, method,\n",
        "380": "          Scenario.SATISFIED_AND_INTERRUPTED_BEFORE_WAITING,\n",
        "381": "          TimeoutsToUse.ANY,\n",
        "382": "          Outcome.SUCCESS);\n",
        "383": "      addTests(suite, method,\n",
        "384": "          Scenario.UNSATISFIED_BEFORE_AND_WHILE_WAITING,\n",
        "385": "          TimeoutsToUse.FINITE,\n",
        "386": "          Outcome.FAILURE);\n",
        "387": "      addTests(suite, method,\n",
        "388": "          Scenario.UNSATISFIED_BEFORE_AND_WHILE_WAITING,\n",
        "389": "          TimeoutsToUse.INFINITE,\n",
        "390": "          Outcome.HANG);\n",
        "391": "      addTests(suite, method,\n",
        "392": "          Scenario.UNSATISFIED_AND_INTERRUPTED_BEFORE_WAITING,\n",
        "393": "          TimeoutsToUse.PAST,\n",
        "394": "          // prefer responding to interrupt over timing out\n",
        "395": "          isInterruptible(method) ? Outcome.INTERRUPT : Outcome.FAILURE);\n",
        "396": "      addTests(suite, method,\n",
        "397": "          Scenario.UNSATISFIED_AND_INTERRUPTED_BEFORE_WAITING,\n",
        "398": "          TimeoutsToUse.SMALL,\n",
        "399": "          isInterruptible(method) ? Outcome.INTERRUPT : Outcome.FAILURE);\n",
        "400": "      addTests(suite, method,\n",
        "401": "          Scenario.UNSATISFIED_AND_INTERRUPTED_BEFORE_WAITING,\n",
        "402": "          TimeoutsToUse.INFINITE,\n",
        "403": "          isInterruptible(method) ? Outcome.INTERRUPT : Outcome.HANG);\n",
        "404": "    }\n",
        "405": "  }\n",
        "406": "\n",
        "407": "  /**\n",
        "408": "   * Generates test cases for the given combination of scenario and timeouts. For methods that take\n",
        "409": "   * an explicit timeout value, all of the given timeoutsToUse result in individual test cases. For\n",
        "410": "   * methods that do not take an explicit timeout value, a single test case is generated only if the\n",
        "411": "   * implicit timeout of that method matches the given timeoutsToUse. For example, enter() is\n",
        "412": "   * treated like enter(MAX, MILLIS) and tryEnter() is treated like enter(0, MILLIS).\n",
        "413": "   */\n",
        "414": "  private static void addTests(TestSuite suite, Method method, Scenario scenario,\n",
        "415": "      TimeoutsToUse timeoutsToUse, Outcome expectedOutcome) {\n",
        "416": "    for (boolean fair : new boolean[] { true, false }) {\n",
        "417": "      if (isTimed(method)) {\n",
        "418": "        for (Timeout timeout : timeoutsToUse.timeouts) {\n",
        "419": "          suite.addTest(new GeneratedMonitorTest(method, scenario, fair, timeout, expectedOutcome));\n",
        "420": "        }\n",
        "421": "      } else {\n",
        "422": "        Timeout implicitTimeout = (isTryEnter(method) ? Timeout.ZERO : Timeout.MAX);\n",
        "423": "        if (timeoutsToUse.timeouts.contains(implicitTimeout)) {\n",
        "424": "          suite.addTest(new GeneratedMonitorTest(method, scenario, fair, null, expectedOutcome));\n",
        "425": "        }\n",
        "426": "      }\n",
        "427": "    }\n",
        "428": "  }\n",
        "429": "\n",
        "430": "  /**\n",
        "431": "   * A guard that encapsulates a simple, mutable boolean flag.\n",
        "432": "   */\n",
        "433": "  static class FlagGuard extends Monitor.Guard {\n",
        "434": "\n",
        "435": "    private boolean satisfied;\n",
        "436": "\n",
        "437": "    protected FlagGuard(Monitor monitor) {\n",
        "438": "      super(monitor);\n",
        "439": "    }\n",
        "440": "\n",
        "441": "    @Override\n",
        "442": "    public boolean isSatisfied() {\n",
        "443": "      return satisfied;\n",
        "444": "    }\n",
        "445": "\n",
        "446": "    public void setSatisfied(boolean satisfied) {\n",
        "447": "      this.satisfied = satisfied;\n",
        "448": "    }\n",
        "449": "\n",
        "450": "  }\n",
        "451": "\n",
        "452": "  private final Method method;\n",
        "453": "  private final Scenario scenario;\n",
        "454": "  private final Timeout timeout;\n",
        "455": "  private final Outcome expectedOutcome;\n",
        "456": "  private final Monitor monitor;\n",
        "457": "  private final FlagGuard guard;\n",
        "458": "  private final CountDownLatch tearDownLatch;\n",
        "459": "  private final CountDownLatch doingCallLatch;\n",
        "460": "  private final CountDownLatch callCompletedLatch;\n",
        "461": "\n",
        "462": "  private GeneratedMonitorTest(\n",
        "463": "      Method method, Scenario scenario, boolean fair, Timeout timeout, Outcome expectedOutcome) {\n",
        "464": "    super(nameFor(method, scenario, fair, timeout, expectedOutcome));\n",
        "465": "    this.method = method;\n",
        "466": "    this.scenario = scenario;\n",
        "467": "    this.timeout = timeout;\n",
        "468": "    this.expectedOutcome = expectedOutcome;\n",
        "469": "    this.monitor = new Monitor(fair);\n",
        "470": "    this.guard = new FlagGuard(monitor);\n",
        "471": "    this.tearDownLatch = new CountDownLatch(1);\n",
        "472": "    this.doingCallLatch = new CountDownLatch(1);\n",
        "473": "    this.callCompletedLatch = new CountDownLatch(1);\n",
        "474": "  }\n",
        "475": "\n",
        "476": "  private static String nameFor(\n",
        "477": "      Method method, Scenario scenario, boolean fair, Timeout timeout, Outcome expectedOutcome) {\n",
        "478": "    return String.format(\"%s%s(%s)/%s->%s\",\n",
        "479": "                         method.getName(),\n",
        "480": "                         fair ? \"(fair)\" : \"(nonfair)\",\n",
        "481": "                         (timeout == null) ? \"untimed\" : timeout,\n",
        "482": "                         scenario,\n",
        "483": "                         expectedOutcome);\n",
        "484": "  }\n",
        "485": "\n",
        "486": "  @Override\n",
        "487": "  protected void runTest() throws Throwable {\n",
        "488": "    final Runnable runChosenTest = new Runnable() {\n",
        "489": "      @Override public void run() { runChosenTest(); }\n",
        "490": "    };\n",
        "491": "    final FutureTask<Void> task = new FutureTask<Void>(runChosenTest, null);\n",
        "492": "    startThread(new Runnable() {\n",
        "493": "        @Override public void run() { task.run(); }\n",
        "494": "      });\n",
        "495": "    awaitUninterruptibly(doingCallLatch);\n",
        "496": "    long hangDelayMillis = (expectedOutcome == Outcome.HANG)\n",
        "497": "        ? EXPECTED_HANG_DELAY_MILLIS\n",
        "498": "        : UNEXPECTED_HANG_DELAY_MILLIS;\n",
        "499": "    boolean hung = !awaitUninterruptibly(\n",
        "500": "        callCompletedLatch, hangDelayMillis, TimeUnit.MILLISECONDS);\n",
        "501": "    if (hung) {\n",
        "502": "      assertEquals(expectedOutcome, Outcome.HANG);\n",
        "503": "    } else {\n",
        "504": "      assertNull(task.get(UNEXPECTED_HANG_DELAY_MILLIS, TimeUnit.MILLISECONDS));\n",
        "505": "    }\n",
        "506": "  }\n",
        "507": "\n",
        "508": "  @Override\n",
        "509": "  protected void tearDown() throws Exception {\n",
        "510": "    // We don't want to leave stray threads running after each test. At this point, every thread\n",
        "511": "    // launched by this test is either:\n",
        "512": "    //\n",
        "513": "    // (a) Blocked attempting to enter the monitor.\n",
        "514": "    // (b) Waiting for the single guard to become satisfied.\n",
        "515": "    // (c) Occupying the monitor and awaiting the tearDownLatch.\n",
        "516": "    //\n",
        "517": "    // Except for (c), every thread should occupy the monitor very briefly, and every thread leaves\n",
        "518": "    // the monitor with the guard satisfied. Therefore as soon as tearDownLatch is triggered, we\n",
        "519": "    // should be able to enter the monitor, and then we set the guard to satisfied for the benefit\n",
        "520": "    // of any remaining waiting threads.\n",
        "521": "\n",
        "522": "    tearDownLatch.countDown();\n",
        "523": "    assertTrue(\"Monitor still occupied in tearDown()\",\n",
        "524": "        monitor.enter(UNEXPECTED_HANG_DELAY_MILLIS, TimeUnit.MILLISECONDS));\n",
        "525": "    try {\n",
        "526": "      guard.setSatisfied(true);\n",
        "527": "    } finally {\n",
        "528": "      monitor.leave();\n",
        "529": "    }\n",
        "530": "  }\n",
        "531": "\n",
        "532": "  private void runChosenTest() {\n",
        "533": "    if (isAnyEnter(method)) {\n",
        "534": "      runEnterTest();\n",
        "535": "    } else {\n",
        "536": "      runWaitTest();\n",
        "537": "    }\n",
        "538": "  }\n",
        "539": "\n",
        "540": "  private void runEnterTest() {\n",
        "541": "    assertFalse(Thread.currentThread().isInterrupted());\n",
        "542": "    assertFalse(monitor.isOccupiedByCurrentThread());\n",
        "543": "\n",
        "544": "    doEnterScenarioSetUp();\n",
        "545": "\n",
        "546": "    boolean interruptedBeforeCall = Thread.currentThread().isInterrupted();\n",
        "547": "    Outcome actualOutcome = doCall();\n",
        "548": "    boolean occupiedAfterCall = monitor.isOccupiedByCurrentThread();\n",
        "549": "    boolean interruptedAfterCall = Thread.currentThread().isInterrupted();\n",
        "550": "\n",
        "551": "    if (occupiedAfterCall) {\n",
        "552": "      guard.setSatisfied(true);\n",
        "553": "      monitor.leave();\n",
        "554": "      assertFalse(monitor.isOccupiedByCurrentThread());\n",
        "555": "    }\n",
        "556": "\n",
        "557": "    assertEquals(expectedOutcome, actualOutcome);\n",
        "558": "    assertEquals(expectedOutcome == Outcome.SUCCESS, occupiedAfterCall);\n",
        "559": "    assertEquals(interruptedBeforeCall && expectedOutcome != Outcome.INTERRUPT,\n",
        "560": "        interruptedAfterCall);\n",
        "561": "  }\n",
        "562": "\n",
        "563": "  private void doEnterScenarioSetUp() {\n",
        "564": "    switch (scenario) {\n",
        "565": "      case SATISFIED_AND_UNOCCUPIED_BEFORE_ENTERING:\n",
        "566": "        enterSatisfyGuardAndLeaveInCurrentThread();\n",
        "567": "        break;\n",
        "568": "      case UNSATISFIED_AND_UNOCCUPIED_BEFORE_ENTERING:\n",
        "569": "        break;\n",
        "570": "      case SATISFIED_AND_OCCUPIED_BEFORE_ENTERING:\n",
        "571": "        enterSatisfyGuardAndLeaveInCurrentThread();\n",
        "572": "        enterAndRemainOccupyingInAnotherThread();\n",
        "573": "        break;\n",
        "574": "      case SATISFIED_UNOCCUPIED_AND_INTERRUPTED_BEFORE_ENTERING:\n",
        "575": "        enterSatisfyGuardAndLeaveInCurrentThread();\n",
        "576": "        Thread.currentThread().interrupt();\n",
        "577": "        break;\n",
        "578": "      default:\n",
        "579": "        throw new AssertionError(\"unsupported scenario: \" + scenario);\n",
        "580": "    }\n",
        "581": "  }\n",
        "582": "\n",
        "583": "  private void runWaitTest() {\n",
        "584": "    assertFalse(Thread.currentThread().isInterrupted());\n",
        "585": "    assertFalse(monitor.isOccupiedByCurrentThread());\n",
        "586": "    monitor.enter();\n",
        "587": "    try {\n",
        "588": "      assertTrue(monitor.isOccupiedByCurrentThread());\n",
        "589": "\n",
        "590": "      doWaitScenarioSetUp();\n",
        "591": "\n",
        "592": "      boolean interruptedBeforeCall = Thread.currentThread().isInterrupted();\n",
        "593": "      Outcome actualOutcome = doCall();\n",
        "594": "      boolean occupiedAfterCall = monitor.isOccupiedByCurrentThread();\n",
        "595": "      boolean interruptedAfterCall = Thread.currentThread().isInterrupted();\n",
        "596": "\n",
        "597": "      assertEquals(expectedOutcome, actualOutcome);\n",
        "598": "      assertTrue(occupiedAfterCall);\n",
        "599": "      assertEquals(interruptedBeforeCall && expectedOutcome != Outcome.INTERRUPT,\n",
        "600": "          interruptedAfterCall);\n",
        "601": "    } finally {\n",
        "602": "      guard.setSatisfied(true);\n",
        "603": "      monitor.leave();\n",
        "604": "      assertFalse(monitor.isOccupiedByCurrentThread());\n",
        "605": "    }\n",
        "606": "  }\n",
        "607": "\n",
        "608": "  private void doWaitScenarioSetUp() {\n",
        "609": "    switch (scenario) {\n",
        "610": "      case SATISFIED_BEFORE_WAITING:\n",
        "611": "        guard.setSatisfied(true);\n",
        "612": "        break;\n",
        "613": "      case SATISFIED_WHILE_WAITING:\n",
        "614": "        guard.setSatisfied(false);\n",
        "615": "        enterSatisfyGuardAndLeaveInAnotherThread(); // enter blocks until we call waitFor\n",
        "616": "        break;\n",
        "617": "      case UNSATISFIED_BEFORE_AND_WHILE_WAITING:\n",
        "618": "        guard.setSatisfied(false);\n",
        "619": "        break;\n",
        "620": "      case SATISFIED_AND_INTERRUPTED_BEFORE_WAITING:\n",
        "621": "        guard.setSatisfied(true);\n",
        "622": "        Thread.currentThread().interrupt();\n",
        "623": "        break;\n",
        "624": "      case UNSATISFIED_AND_INTERRUPTED_BEFORE_WAITING:\n",
        "625": "        guard.setSatisfied(false);\n",
        "626": "        Thread.currentThread().interrupt();\n",
        "627": "        break;\n",
        "628": "      default:\n",
        "629": "        throw new AssertionError(\"unsupported scenario: \" + scenario);\n",
        "630": "    }\n",
        "631": "  }\n",
        "632": "\n",
        "633": "  private Outcome doCall() {\n",
        "634": "    boolean guarded = isGuarded(method);\n",
        "635": "    boolean timed = isTimed(method);\n",
        "636": "    Object[] arguments = new Object[(guarded ? 1 : 0) + (timed ? 2 : 0)];\n",
        "637": "    if (guarded) {\n",
        "638": "      arguments[0] = guard;\n",
        "639": "    }\n",
        "640": "    if (timed) {\n",
        "641": "      arguments[arguments.length - 2] = timeout.millis;\n",
        "642": "      arguments[arguments.length - 1] = TimeUnit.MILLISECONDS;\n",
        "643": "    }\n",
        "644": "    try {\n",
        "645": "      Object result;\n",
        "646": "      doingCallLatch.countDown();\n",
        "647": "      try {\n",
        "648": "        result = method.invoke(monitor, arguments);\n",
        "649": "      } finally {\n",
        "650": "        callCompletedLatch.countDown();\n",
        "651": "      }\n",
        "652": "      if (result == null) {\n",
        "653": "        return Outcome.SUCCESS;\n",
        "654": "      } else if ((Boolean) result) {\n",
        "655": "        return Outcome.SUCCESS;\n",
        "656": "      } else {\n",
        "657": "        return Outcome.FAILURE;\n",
        "658": "      }\n",
        "659": "    } catch (InvocationTargetException targetException) {\n",
        "660": "      Throwable actualException = targetException.getTargetException();\n",
        "661": "      if (actualException instanceof InterruptedException) {\n",
        "662": "        return Outcome.INTERRUPT;\n",
        "663": "      } else {\n",
        "664": "        throw new AssertionError(\"unexpected exception\", targetException);\n",
        "665": "      }\n",
        "666": "    } catch (IllegalAccessException e) {\n",
        "667": "      throw new AssertionError(\"unexpected exception\", e);\n",
        "668": "    }\n",
        "669": "  }\n",
        "670": "\n",
        "671": "  private void enterSatisfyGuardAndLeaveInCurrentThread() {\n",
        "672": "    monitor.enter();\n",
        "673": "    try {\n",
        "674": "      guard.setSatisfied(true);\n",
        "675": "    } finally {\n",
        "676": "      monitor.leave();\n",
        "677": "    }\n",
        "678": "  }\n",
        "679": "\n",
        "680": "  private void enterSatisfyGuardAndLeaveInAnotherThread() {\n",
        "681": "    final CountDownLatch startedLatch = new CountDownLatch(1);\n",
        "682": "    startThread(new Runnable() {\n",
        "683": "      @Override public void run() {\n",
        "684": "        startedLatch.countDown();\n",
        "685": "        enterSatisfyGuardAndLeaveInCurrentThread();\n",
        "686": "      }\n",
        "687": "    });\n",
        "688": "    awaitUninterruptibly(startedLatch);\n",
        "689": "  }\n",
        "690": "\n",
        "691": "  private void enterAndRemainOccupyingInAnotherThread() {\n",
        "692": "    final CountDownLatch enteredLatch = new CountDownLatch(1);\n",
        "693": "    startThread(new Runnable() {\n",
        "694": "      @Override public void run() {\n",
        "695": "        monitor.enter();\n",
        "696": "        try {\n",
        "697": "          enteredLatch.countDown();\n",
        "698": "          awaitUninterruptibly(tearDownLatch);\n",
        "699": "          guard.setSatisfied(true);\n",
        "700": "        } finally {\n",
        "701": "          monitor.leave();\n",
        "702": "        }\n",
        "703": "      }\n",
        "704": "    });\n",
        "705": "    awaitUninterruptibly(enteredLatch);\n",
        "706": "  }\n",
        "707": "\n",
        "708": "  static Thread startThread(Runnable runnable) {\n",
        "709": "    Thread thread = new Thread(runnable);\n",
        "710": "    thread.setDaemon(true);\n",
        "711": "    thread.start();\n",
        "712": "    return thread;\n",
        "713": "  }\n",
        "714": "\n",
        "715": "  /**\n",
        "716": "   * Generates a test case verifying that calling any enterXxx, tryEnterXxx, or waitForXxx method\n",
        "717": "   * with a guard that doesn't match the monitor produces an IllegalMonitorStateException.\n",
        "718": "   */\n",
        "719": "  private static TestCase generateGuardWithWrongMonitorTestCase(final Method method,\n",
        "720": "                                                                final boolean fair1,\n",
        "721": "                                                                final boolean fair2) {\n",
        "722": "    final boolean timed = isTimed(method); // Not going to bother with all timeouts, just 0ms.\n",
        "723": "    return new TestCase(method.getName() + (timed ? \"(0ms)\" : \"()\") + \"/WrongMonitor->IMSE\") {\n",
        "724": "      @Override protected void runTest() throws Throwable {\n",
        "725": "        Monitor monitor1 = new Monitor(fair1);\n",
        "726": "        Monitor monitor2 = new Monitor(fair2);\n",
        "727": "        FlagGuard guard = new FlagGuard(monitor2);\n",
        "728": "        Object[] arguments =\n",
        "729": "            (timed ? new Object[] {guard, 0L, TimeUnit.MILLISECONDS} : new Object[] {guard});\n",
        "730": "        boolean occupyMonitor = isWaitFor(method);\n",
        "731": "        if (occupyMonitor) {\n",
        "732": "          // If we don't already occupy the monitor, we'll get an IMSE regardless of the guard (see\n",
        "733": "          // generateWaitForWhenNotOccupyingTestCase).\n",
        "734": "          monitor1.enter();\n",
        "735": "        }\n",
        "736": "        try {\n",
        "737": "          method.invoke(monitor1, arguments);\n",
        "738": "          fail(\"expected IllegalMonitorStateException\");\n",
        "739": "        } catch (InvocationTargetException e) {\n",
        "740": "          assertEquals(IllegalMonitorStateException.class, e.getTargetException().getClass());\n",
        "741": "        } finally {\n",
        "742": "          if (occupyMonitor) {\n",
        "743": "            monitor1.leave();\n",
        "744": "          }\n",
        "745": "        }\n",
        "746": "      }\n",
        "747": "    };\n",
        "748": "  }\n",
        "749": "\n",
        "750": "  /**\n",
        "751": "   * Generates a test case verifying that calling any waitForXxx method when not occupying the\n",
        "752": "   * monitor produces an IllegalMonitorStateException.\n",
        "753": "   */\n",
        "754": "  private static TestCase generateWaitForWhenNotOccupyingTestCase(final Method method,\n",
        "755": "                                                                  final boolean fair) {\n",
        "756": "    final boolean timed = isTimed(method); // Not going to bother with all timeouts, just 0ms.\n",
        "757": "    String testName = method.getName()\n",
        "758": "        + (fair ? \"(fair)\" : \"(nonfair)\")\n",
        "759": "        + (timed ? \"(0ms)\" : \"()\")\n",
        "760": "        + \"/NotOccupying->IMSE\";\n",
        "761": "    return new TestCase(testName) {\n",
        "762": "      @Override protected void runTest() throws Throwable {\n",
        "763": "        Monitor monitor = new Monitor(fair);\n",
        "764": "        FlagGuard guard = new FlagGuard(monitor);\n",
        "765": "        Object[] arguments =\n",
        "766": "            (timed ? new Object[] {guard, 0L, TimeUnit.MILLISECONDS} : new Object[] {guard});\n",
        "767": "        try {\n",
        "768": "          method.invoke(monitor, arguments);\n",
        "769": "          fail(\"expected IllegalMonitorStateException\");\n",
        "770": "        } catch (InvocationTargetException e) {\n",
        "771": "          assertEquals(IllegalMonitorStateException.class, e.getTargetException().getClass());\n",
        "772": "        }\n",
        "773": "      }\n",
        "774": "    };\n",
        "775": "  }\n",
        "776": "\n",
        "777": "}\n"
    },
    "removed": {}
}