{
    "addition": {
        "279": "  /*\n",
        "280": "   * Timeout handling is intricate, especially given our ambitious goals:\n",
        "281": "   * - Avoid underflow and overflow of timeout values when specified timeouts are close to\n",
        "282": "   *   Long.MIN_VALUE or Long.MAX_VALUE.\n",
        "283": "   * - Favor responding to interrupts over timeouts.\n",
        "284": "   * - System.nanoTime() is expensive enough that we want to call it the minimum required number of\n",
        "285": "   *   times, typically once before invoking a blocking method.  This often requires keeping track\n",
        "286": "   *   of the first time in a method that nanoTime() has been invoked, for which the special value\n",
        "287": "   *   0L is reserved to mean \"uninitialized\".  If timeout is non-positive, then nanoTime need\n",
        "288": "   *   never be called.\n",
        "289": "   * - Keep behavior of fair and non-fair instances consistent.\n",
        "290": "   */\n",
        "291": "\n",
        "375": "   *\n",
        "376": "   * @throws InterruptedException if interrupted while waiting\n",
        "388": "    final long timeoutNanos = toSafeNanos(time, unit);\n",
        "395": "      final long startTime = System.nanoTime();\n",
        "396": "      for (long remainingNanos = timeoutNanos;;) {\n",
        "398": "          return lock.tryLock(remainingNanos, TimeUnit.NANOSECONDS);\n",
        "401": "          remainingNanos = remainingNanos(startTime, timeoutNanos);\n",
        "415": "   * @throws InterruptedException if interrupted while waiting\n",
        "434": "   *\n",
        "435": "   * @throws InterruptedException if interrupted while waiting\n",
        "488": "   * @throws InterruptedException if interrupted while waiting\n",
        "491": "    final long timeoutNanos = toSafeNanos(time, unit);\n",
        "497": "    long startTime = 0L;\n",
        "498": "\n",
        "499": " locked: {\n",
        "500": "      if (!fair) {\n",
        "501": "        // Check interrupt status to get behavior consistent with fair case.\n",
        "502": "        if (Thread.interrupted()) {\n",
        "503": "          throw new InterruptedException();\n",
        "504": "        }\n",
        "505": "        if (lock.tryLock()) {\n",
        "506": "          break locked;\n",
        "507": "        }\n",
        "508": "      }\n",
        "509": "      startTime = initNanoTime(timeoutNanos);\n",
        "518": "      satisfied = guard.isSatisfied()\n",
        "519": "          || awaitNanos(guard,\n",
        "520": "                        (startTime == 0L)\n",
        "521": "                            ? timeoutNanos\n",
        "522": "                            : remainingNanos(startTime, timeoutNanos),\n",
        "523": "                        reentrant);\n",
        "547": "    final long timeoutNanos = toSafeNanos(time, unit);\n",
        "552": "    long startTime = 0L;\n",
        "557": "        startTime = initNanoTime(timeoutNanos);\n",
        "558": "        for (long remainingNanos = timeoutNanos;;) {\n",
        "560": "            if (lock.tryLock(remainingNanos, TimeUnit.NANOSECONDS)) {\n",
        "561": "              break;\n",
        "562": "            } else {\n",
        "567": "            remainingNanos = remainingNanos(startTime, timeoutNanos);\n",
        "569": "        }\n",
        "576": "            if (guard.isSatisfied()) {\n",
        "577": "              satisfied = true;\n",
        "578": "            } else {\n",
        "579": "              final long remainingNanos;\n",
        "580": "              if (startTime == 0L) {\n",
        "581": "                startTime = initNanoTime(timeoutNanos);\n",
        "582": "                remainingNanos = timeoutNanos;\n",
        "583": "              } else {\n",
        "584": "                remainingNanos = remainingNanos(startTime, timeoutNanos);\n",
        "585": "              }\n",
        "586": "              satisfied = awaitNanos(guard, remainingNanos, signalBeforeWaiting);\n",
        "587": "            }\n",
        "588": "            return satisfied;\n",
        "634": "   * @throws InterruptedException if interrupted while waiting\n",
        "733": "   *\n",
        "734": "   * @throws InterruptedException if interrupted while waiting\n",
        "763": "   * @throws InterruptedException if interrupted while waiting\n",
        "766": "    final long timeoutNanos = toSafeNanos(time, unit);\n",
        "770": "    if (guard.isSatisfied()) {\n",
        "771": "      return true;\n",
        "772": "    }\n",
        "773": "    if (Thread.interrupted()) {\n",
        "774": "      throw new InterruptedException();\n",
        "775": "    }\n",
        "776": "    return awaitNanos(guard, timeoutNanos, true);\n",
        "786": "    final long timeoutNanos = toSafeNanos(time, unit);\n",
        "794": "    final long startTime = initNanoTime(timeoutNanos);\n",
        "797": "      for (long remainingNanos = timeoutNanos;;) {\n",
        "799": "          return awaitNanos(guard, remainingNanos, signalBeforeWaiting);\n",
        "806": "          remainingNanos = remainingNanos(startTime, timeoutNanos);\n",
        "920": "  /**\n",
        "921": "   * Returns unit.toNanos(time), additionally ensuring the returned value is not at risk of\n",
        "922": "   * overflowing or underflowing, by bounding the value between 0 and (Long.MAX_VALUE / 4) * 3.\n",
        "923": "   * Actually waiting for more than 219 years is not supported!\n",
        "924": "   */\n",
        "925": "  private static long toSafeNanos(long time, TimeUnit unit) {\n",
        "926": "    long timeoutNanos = unit.toNanos(time);\n",
        "927": "    return (timeoutNanos <= 0L) ? 0L\n",
        "928": "        : (timeoutNanos > (Long.MAX_VALUE / 4) * 3) ? (Long.MAX_VALUE / 4) * 3\n",
        "929": "        : timeoutNanos;\n",
        "930": "  }\n",
        "931": "\n",
        "932": "  /**\n",
        "933": "   * Returns System.nanoTime() unless the timeout has already elapsed.\n",
        "934": "   * Returns 0L if and only if the timeout has already elapsed.\n",
        "935": "   */\n",
        "936": "  private static long initNanoTime(long timeoutNanos) {\n",
        "937": "    if (timeoutNanos <= 0L) {\n",
        "938": "      return 0L;\n",
        "939": "    } else {\n",
        "940": "      long startTime = System.nanoTime();\n",
        "941": "      return (startTime == 0L) ? 1L : startTime;\n",
        "942": "    }\n",
        "943": "  }\n",
        "944": "\n",
        "945": "  /**\n",
        "946": "   * Returns the remaining nanos until the given timeout, or 0L if the timeout has already elapsed.\n",
        "947": "   * Caller must have previously sanitized timeoutNanos using toSafeNanos.\n",
        "948": "   */\n",
        "949": "  private static long remainingNanos(long startTime, long timeoutNanos) {\n",
        "950": "    // assert timeoutNanos == 0L || startTime != 0L;\n",
        "951": "\n",
        "952": "    // TODO : NOT CORRECT, BUT TESTS PASS ANYWAYS!\n",
        "953": "    // if (true) return timeoutNanos;\n",
        "954": "    // ONLY 2 TESTS FAIL IF WE DO:\n",
        "955": "    // if (true) return 0;\n",
        "956": "\n",
        "957": "    return (timeoutNanos <= 0L) ? 0L : timeoutNanos - (System.nanoTime() - startTime);\n",
        "958": "  }\n",
        "959": "\n",
        "1078": "  private void await(Guard guard, boolean signalBeforeWaiting)\n",
        "1108": "  /**\n",
        "1109": "   * Caller should check before calling that guard is not satisfied.\n",
        "1110": "   */\n",
        "1114": "    boolean firstTime = true;\n",
        "1117": "        if (nanos <= 0L) {\n",
        "1120": "        if (firstTime) {\n",
        "1121": "          if (signalBeforeWaiting) {\n",
        "1122": "            signalNextWaiter();\n",
        "1123": "          }\n",
        "1124": "          beginWaitingFor(guard);\n",
        "1125": "          firstTime = false;\n",
        "1126": "        }\n",
        "1131": "      if (!firstTime) {\n",
        "1132": "        endWaitingFor(guard);\n",
        "1133": "      }\n"
    },
    "removed": {
        "373": "    long timeoutNanos = unit.toNanos(time);\n",
        "378": "    long deadline = System.nanoTime() + timeoutNanos;\n",
        "381": "      while (true) {\n",
        "383": "          return lock.tryLock(timeoutNanos, TimeUnit.NANOSECONDS);\n",
        "386": "          timeoutNanos = deadline - System.nanoTime();\n",
        "472": "    long timeoutNanos = unit.toNanos(time);\n",
        "478": "    if (fair || !lock.tryLock()) {\n",
        "479": "      long deadline = System.nanoTime() + timeoutNanos;\n",
        "483": "      timeoutNanos = deadline - System.nanoTime();\n",
        "489": "      satisfied = guard.isSatisfied() || awaitNanos(guard, timeoutNanos, reentrant);\n",
        "513": "    long timeoutNanos = unit.toNanos(time);\n",
        "518": "    long deadline = System.nanoTime() + timeoutNanos;\n",
        "523": "        boolean locked = false;\n",
        "524": "        do {\n",
        "526": "            locked = lock.tryLock(timeoutNanos, TimeUnit.NANOSECONDS);\n",
        "527": "            if (!locked) {\n",
        "533": "          timeoutNanos = deadline - System.nanoTime();\n",
        "534": "        } while (!locked);\n",
        "541": "            return satisfied = guard.isSatisfied()\n",
        "542": "                || awaitNanos(guard, timeoutNanos, signalBeforeWaiting);\n",
        "546": "            timeoutNanos = deadline - System.nanoTime();\n",
        "717": "    long timeoutNanos = unit.toNanos(time);\n",
        "721": "    return guard.isSatisfied() || awaitNanos(guard, timeoutNanos, true);\n",
        "731": "    long timeoutNanos = unit.toNanos(time);\n",
        "739": "    long deadline = System.nanoTime() + timeoutNanos;\n",
        "742": "      while (true) {\n",
        "744": "          return awaitNanos(guard, timeoutNanos, signalBeforeWaiting);\n",
        "751": "          timeoutNanos = deadline - System.nanoTime();\n",
        "983": "    private void await(Guard guard, boolean signalBeforeWaiting)\n",
        "1016": "    if (signalBeforeWaiting) {\n",
        "1017": "      signalNextWaiter();\n",
        "1018": "    }\n",
        "1019": "    beginWaitingFor(guard);\n",
        "1022": "        if (nanos < 0L) {\n",
        "1029": "      endWaitingFor(guard);\n"
    }
}