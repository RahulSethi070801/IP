{
    "addition": {
        "1": "/*\n",
        "2": " * Copyright (C) 2014 The Guava Authors\n",
        "3": " *\n",
        "4": " * Licensed under the Apache License, Version 2.0 (the \"License\");\n",
        "5": " * you may not use this file except in compliance with the License.\n",
        "6": " * You may obtain a copy of the License at\n",
        "7": " *\n",
        "8": " * http://www.apache.org/licenses/LICENSE-2.0\n",
        "9": " *\n",
        "10": " * Unless required by applicable law or agreed to in writing, software\n",
        "11": " * distributed under the License is distributed on an \"AS IS\" BASIS,\n",
        "12": " * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n",
        "13": " * See the License for the specific language governing permissions and\n",
        "14": " * limitations under the License.\n",
        "15": " */\n",
        "16": "\n",
        "17": "package com.google.common.util.concurrent;\n",
        "18": "\n",
        "19": "import static com.google.common.util.concurrent.GeneratedMonitorTest.startThread;\n",
        "20": "import static com.google.common.util.concurrent.Uninterruptibles.joinUninterruptibly;\n",
        "21": "\n",
        "22": "import com.google.common.util.concurrent.GeneratedMonitorTest.FlagGuard;\n",
        "23": "\n",
        "24": "import junit.framework.TestCase;\n",
        "25": "\n",
        "26": "import java.util.concurrent.atomic.AtomicBoolean;\n",
        "27": "import java.util.concurrent.atomic.AtomicInteger;\n",
        "28": "import java.util.concurrent.atomic.AtomicReference;\n",
        "29": "\n",
        "30": "/**\n",
        "31": " * Supplemental tests for {@link Monitor}.\n",
        "32": " *\n",
        "33": " * <p>This test class contains various test cases that don't fit into the test case generation in\n",
        "34": " * {@link GeneratedMonitorTest}.\n",
        "35": " *\n",
        "36": " * @author Justin T. Sampson\n",
        "37": " */\n",
        "38": "\n",
        "39": "public class SupplementalMonitorTest extends TestCase {\n",
        "40": "\n",
        "41": "  public void testLeaveWithoutEnterThrowsIMSE() {\n",
        "42": "    Monitor monitor = new Monitor();\n",
        "43": "    try {\n",
        "44": "      monitor.leave();\n",
        "45": "      fail(\"expected IllegalMonitorStateException\");\n",
        "46": "    } catch (IllegalMonitorStateException e) {\n",
        "47": "      // expected\n",
        "48": "    }\n",
        "49": "  }\n",
        "50": "\n",
        "51": "  public void testGetWaitQueueLengthWithWrongMonitorThrowsIMSE() {\n",
        "52": "    Monitor monitor1 = new Monitor();\n",
        "53": "    Monitor monitor2 = new Monitor();\n",
        "54": "    FlagGuard guard = new FlagGuard(monitor2);\n",
        "55": "    try {\n",
        "56": "      monitor1.getWaitQueueLength(guard);\n",
        "57": "      fail(\"expected IllegalMonitorStateException\");\n",
        "58": "    } catch (IllegalMonitorStateException e) {\n",
        "59": "      // expected\n",
        "60": "    }\n",
        "61": "  }\n",
        "62": "\n",
        "63": "  public void testHasWaitersWithWrongMonitorThrowsIMSE() {\n",
        "64": "    Monitor monitor1 = new Monitor();\n",
        "65": "    Monitor monitor2 = new Monitor();\n",
        "66": "    FlagGuard guard = new FlagGuard(monitor2);\n",
        "67": "    try {\n",
        "68": "      monitor1.hasWaiters(guard);\n",
        "69": "      fail(\"expected IllegalMonitorStateException\");\n",
        "70": "    } catch (IllegalMonitorStateException e) {\n",
        "71": "      // expected\n",
        "72": "    }\n",
        "73": "  }\n",
        "74": "\n",
        "75": "  public void testNullMonitorInGuardConstructorThrowsNPE() {\n",
        "76": "    try {\n",
        "77": "      new FlagGuard(null);\n",
        "78": "      fail(\"expected NullPointerException\");\n",
        "79": "    } catch (NullPointerException e) {\n",
        "80": "      // expected\n",
        "81": "    }\n",
        "82": "  }\n",
        "83": "\n",
        "84": "  public void testIsFair() {\n",
        "85": "    assertTrue(new Monitor(true).isFair());\n",
        "86": "    assertFalse(new Monitor(false).isFair());\n",
        "87": "  }\n",
        "88": "\n",
        "89": "  public void testOccupiedMethods() {\n",
        "90": "    Monitor monitor = new Monitor();\n",
        "91": "    verifyOccupiedMethodsInCurrentThread(monitor, false, false, 0);\n",
        "92": "    verifyOccupiedMethodsInAnotherThread(monitor, false, false, 0);\n",
        "93": "    monitor.enter();\n",
        "94": "    try {\n",
        "95": "      verifyOccupiedMethodsInCurrentThread(monitor, true, true, 1);\n",
        "96": "      verifyOccupiedMethodsInAnotherThread(monitor, true, false, 0);\n",
        "97": "      monitor.enter();\n",
        "98": "      try {\n",
        "99": "        verifyOccupiedMethodsInCurrentThread(monitor, true, true, 2);\n",
        "100": "        verifyOccupiedMethodsInAnotherThread(monitor, true, false, 0);\n",
        "101": "      } finally {\n",
        "102": "        monitor.leave();\n",
        "103": "      }\n",
        "104": "      verifyOccupiedMethodsInCurrentThread(monitor, true, true, 1);\n",
        "105": "      verifyOccupiedMethodsInAnotherThread(monitor, true, false, 0);\n",
        "106": "    } finally {\n",
        "107": "      monitor.leave();\n",
        "108": "    }\n",
        "109": "    verifyOccupiedMethodsInCurrentThread(monitor, false, false, 0);\n",
        "110": "    verifyOccupiedMethodsInAnotherThread(monitor, false, false, 0);\n",
        "111": "  }\n",
        "112": "\n",
        "113": "  private static void verifyOccupiedMethodsInCurrentThread(Monitor monitor,\n",
        "114": "      boolean expectedIsOccupied, boolean expectedIsOccupiedByCurrentThread,\n",
        "115": "      int expectedOccupiedDepth) {\n",
        "116": "    assertEquals(expectedIsOccupied, monitor.isOccupied());\n",
        "117": "    assertEquals(expectedIsOccupiedByCurrentThread, monitor.isOccupiedByCurrentThread());\n",
        "118": "    assertEquals(expectedOccupiedDepth, monitor.getOccupiedDepth());\n",
        "119": "  }\n",
        "120": "\n",
        "121": "  private static void verifyOccupiedMethodsInAnotherThread(final Monitor monitor,\n",
        "122": "      boolean expectedIsOccupied, boolean expectedIsOccupiedByCurrentThread,\n",
        "123": "      int expectedOccupiedDepth) {\n",
        "124": "    final AtomicBoolean actualIsOccupied = new AtomicBoolean();\n",
        "125": "    final AtomicBoolean actualIsOccupiedByCurrentThread = new AtomicBoolean();\n",
        "126": "    final AtomicInteger actualOccupiedDepth = new AtomicInteger();\n",
        "127": "    final AtomicReference<Throwable> thrown = new AtomicReference<Throwable>();\n",
        "128": "    joinUninterruptibly(startThread(new Runnable() {\n",
        "129": "      @Override public void run() {\n",
        "130": "        try {\n",
        "131": "          actualIsOccupied.set(monitor.isOccupied());\n",
        "132": "          actualIsOccupiedByCurrentThread.set(monitor.isOccupiedByCurrentThread());\n",
        "133": "          actualOccupiedDepth.set(monitor.getOccupiedDepth());\n",
        "134": "        } catch (Throwable t) {\n",
        "135": "          thrown.set(t);\n",
        "136": "        }\n",
        "137": "      }\n",
        "138": "    }));\n",
        "139": "    assertNull(thrown.get());\n",
        "140": "    assertEquals(expectedIsOccupied, actualIsOccupied.get());\n",
        "141": "    assertEquals(expectedIsOccupiedByCurrentThread, actualIsOccupiedByCurrentThread.get());\n",
        "142": "    assertEquals(expectedOccupiedDepth, actualOccupiedDepth.get());\n",
        "143": "  }\n",
        "144": "\n",
        "145": "}\n"
    },
    "removed": {}
}