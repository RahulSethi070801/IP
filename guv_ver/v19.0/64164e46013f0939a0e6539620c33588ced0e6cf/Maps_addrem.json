{
    "addition": {
        "801": "    return new TransformedIterator<K, Entry<K, V>>(set.iterator()) {\n",
        "963": "   * Returns a map with the given {@code values}, indexed by keys derived from\n",
        "964": "   * those values. In other words, each input value produces an entry in the map\n",
        "965": "   * whose key is the result of applying {@code keyFunction} to that value.\n",
        "966": "   * These entries appear in the same order as the input values. Example usage:\n",
        "967": "   * <pre>   {@code\n",
        "968": "   *\n",
        "969": "   *   Color red = new Color(\"red\", 255, 0, 0);\n",
        "970": "   *   ...\n",
        "971": "   *   ImmutableSet<Color> allColors = ImmutableSet.of(red, green, blue);\n",
        "972": "   *\n",
        "973": "   *   Map<String, Color> colorForName =\n",
        "974": "   *       uniqueIndex(allColors, toStringFunction());\n",
        "975": "   *   assertThat(colorForName).containsEntry(\"red\", red);}</pre>\n",
        "976": "   *\n",
        "977": "   * <p>If your index may associate multiple values with each key, use {@link\n",
        "978": "   * Multimaps#index(Iterable, Function) Multimaps.index}.\n",
        "996": "   * Returns a map with the given {@code values}, indexed by keys derived from\n",
        "997": "   * those values. In other words, each input value produces an entry in the map\n",
        "998": "   * whose key is the result of applying {@code keyFunction} to that value.\n",
        "999": "   * These entries appear in the same order as the input values. Example usage:\n",
        "1000": "   * <pre>   {@code\n",
        "1001": "   *\n",
        "1002": "   *   Color red = new Color(\"red\", 255, 0, 0);\n",
        "1003": "   *   ...\n",
        "1004": "   *   Iterator<Color> allColors = ImmutableSet.of(red, green, blue).iterator();\n",
        "1005": "   *\n",
        "1006": "   *   Map<String, Color> colorForName =\n",
        "1007": "   *       uniqueIndex(allColors, toStringFunction());\n",
        "1008": "   *   assertThat(colorForName).containsEntry(\"red\", red);}</pre>\n",
        "1009": "   *\n",
        "1010": "   * <p>If your index may associate multiple values with each key, use {@link\n",
        "1011": "   * Multimaps#index(Iterator, Function) Multimaps.index}.\n",
        "1031": "    try {\n",
        "1032": "      return builder.build();\n",
        "1033": "    } catch (IllegalArgumentException duplicateKeys) {\n",
        "1034": "      throw new IllegalArgumentException(duplicateKeys.getMessage()\n",
        "1035": "          + \". To index multiple values under a key, use Multimaps.index.\");\n",
        "1036": "    }\n"
    },
    "removed": {
        "801": "    return new TransformedIterator<K, Entry<K,V>>(set.iterator()) {\n",
        "963": "   * Returns an immutable map for which the {@link Map#values} are the given\n",
        "964": "   * elements in the given order, and each key is the product of invoking a\n",
        "965": "   * supplied function on its corresponding value.\n",
        "983": "   * Returns an immutable map for which the {@link Map#values} are the given\n",
        "984": "   * elements in the given order, and each key is the product of invoking a\n",
        "985": "   * supplied function on its corresponding value.\n",
        "1005": "    return builder.build();\n"
    }
}