{
    "addition": {
        "838": "    return new TransformedIterator<K, Entry<K, V>>(set.iterator()) {\n",
        "1138": "   * Returns a map with the given {@code values}, indexed by keys derived from\n",
        "1139": "   * those values. In other words, each input value produces an entry in the map\n",
        "1140": "   * whose key is the result of applying {@code keyFunction} to that value.\n",
        "1141": "   * These entries appear in the same order as the input values. Example usage:\n",
        "1142": "   * <pre>   {@code\n",
        "1143": "   *\n",
        "1144": "   *   Color red = new Color(\"red\", 255, 0, 0);\n",
        "1145": "   *   ...\n",
        "1146": "   *   ImmutableSet<Color> allColors = ImmutableSet.of(red, green, blue);\n",
        "1147": "   *\n",
        "1148": "   *   Map<String, Color> colorForName =\n",
        "1149": "   *       uniqueIndex(allColors, toStringFunction());\n",
        "1150": "   *   assertThat(colorForName).containsEntry(\"red\", red);}</pre>\n",
        "1151": "   *\n",
        "1152": "   * <p>If your index may associate multiple values with each key, use {@link\n",
        "1153": "   * Multimaps#index(Iterable, Function) Multimaps.index}.\n",
        "1171": "   * Returns a map with the given {@code values}, indexed by keys derived from\n",
        "1172": "   * those values. In other words, each input value produces an entry in the map\n",
        "1173": "   * whose key is the result of applying {@code keyFunction} to that value.\n",
        "1174": "   * These entries appear in the same order as the input values. Example usage:\n",
        "1175": "   * <pre>   {@code\n",
        "1176": "   *\n",
        "1177": "   *   Color red = new Color(\"red\", 255, 0, 0);\n",
        "1178": "   *   ...\n",
        "1179": "   *   Iterator<Color> allColors = ImmutableSet.of(red, green, blue).iterator();\n",
        "1180": "   *\n",
        "1181": "   *   Map<String, Color> colorForName =\n",
        "1182": "   *       uniqueIndex(allColors, toStringFunction());\n",
        "1183": "   *   assertThat(colorForName).containsEntry(\"red\", red);}</pre>\n",
        "1184": "   *\n",
        "1185": "   * <p>If your index may associate multiple values with each key, use {@link\n",
        "1186": "   * Multimaps#index(Iterator, Function) Multimaps.index}.\n",
        "1206": "    try {\n",
        "1207": "      return builder.build();\n",
        "1208": "    } catch (IllegalArgumentException duplicateKeys) {\n",
        "1209": "      throw new IllegalArgumentException(duplicateKeys.getMessage()\n",
        "1210": "          + \". To index multiple values under a key, use Multimaps.index.\");\n",
        "1211": "    }\n"
    },
    "removed": {
        "838": "    return new TransformedIterator<K, Entry<K,V>>(set.iterator()) {\n",
        "1138": "   * Returns an immutable map for which the {@link Map#values} are the given\n",
        "1139": "   * elements in the given order, and each key is the product of invoking a\n",
        "1140": "   * supplied function on its corresponding value.\n",
        "1158": "   * Returns an immutable map for which the {@link Map#values} are the given\n",
        "1159": "   * elements in the given order, and each key is the product of invoking a\n",
        "1160": "   * supplied function on its corresponding value.\n",
        "1180": "    return builder.build();\n"
    }
}