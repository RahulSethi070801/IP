{
    "addition": {},
    "removed": {
        "1": "/*\n",
        "2": " * Copyright (C) 2011 The Guava Authors\n",
        "3": " *\n",
        "4": " * Licensed under the Apache License, Version 2.0 (the \"License\");\n",
        "5": " * you may not use this file except in compliance with the License.\n",
        "6": " * You may obtain a copy of the License at\n",
        "7": " *\n",
        "8": " * http://www.apache.org/licenses/LICENSE-2.0\n",
        "9": " *\n",
        "10": " * Unless required by applicable law or agreed to in writing, software\n",
        "11": " * distributed under the License is distributed on an \"AS IS\" BASIS,\n",
        "12": " * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n",
        "13": " * See the License for the specific language governing permissions and\n",
        "14": " * limitations under the License.\n",
        "15": " */\n",
        "16": "\n",
        "17": "package com.google.common.math;\n",
        "18": "\n",
        "19": "import static com.google.common.base.Preconditions.checkNotNull;\n",
        "20": "import static com.google.common.math.MathPreconditions.checkNoOverflow;\n",
        "21": "import static com.google.common.math.MathPreconditions.checkNonNegative;\n",
        "22": "import static com.google.common.math.MathPreconditions.checkPositive;\n",
        "23": "import static com.google.common.math.MathPreconditions.checkRoundingUnnecessary;\n",
        "24": "import static java.lang.Math.abs;\n",
        "25": "import static java.lang.Math.min;\n",
        "26": "import static java.math.RoundingMode.HALF_EVEN;\n",
        "27": "import static java.math.RoundingMode.HALF_UP;\n",
        "28": "\n",
        "29": "import com.google.common.annotations.GwtCompatible;\n",
        "30": "import com.google.common.annotations.VisibleForTesting;\n",
        "31": "\n",
        "32": "import java.math.RoundingMode;\n",
        "33": "\n",
        "34": "/**\n",
        "35": " * A class for arithmetic on values of type {@code int}. Where possible, methods are defined and\n",
        "36": " * named analogously to their {@code BigInteger} counterparts.\n",
        "37": " *\n",
        "38": " * <p>The implementations of many methods in this class are based on material from Henry S. Warren,\n",
        "39": " * Jr.'s <i>Hacker's Delight</i>, (Addison Wesley, 2002).\n",
        "40": " *\n",
        "41": " * <p>Similar functionality for {@code long} and for {@link BigInteger} can be found in\n",
        "42": " * {@link LongMath} and {@link BigIntegerMath} respectively.  For other common operations on\n",
        "43": " * {@code int} values, see {@link com.google.common.primitives.Ints}.\n",
        "44": " *\n",
        "45": " * @author Louis Wasserman\n",
        "46": " * @since 11.0\n",
        "47": " */\n",
        "48": "@GwtCompatible(emulated = true)\n",
        "49": "public final class IntMath {\n",
        "50": "  // NOTE: Whenever both tests are cheap and functional, it's faster to use &, | instead of &&, ||\n",
        "51": "\n",
        "52": "  /**\n",
        "53": "   * Returns {@code true} if {@code x} represents a power of two.\n",
        "54": "   *\n",
        "55": "   * <p>This differs from {@code Integer.bitCount(x) == 1}, because\n",
        "56": "   * {@code Integer.bitCount(Integer.MIN_VALUE) == 1}, but {@link Integer#MIN_VALUE} is not a power\n",
        "57": "   * of two.\n",
        "58": "   */\n",
        "59": "  public static boolean isPowerOfTwo(int x) {\n",
        "60": "    return x > 0 & (x & (x - 1)) == 0;\n",
        "61": "  }\n",
        "62": "  \n",
        "63": "  /**\n",
        "64": "   * Returns 1 if {@code x < y} as unsigned integers, and 0 otherwise. Assumes that x - y fits into\n",
        "65": "   * a signed int. The implementation is branch-free, and benchmarks suggest it is measurably (if\n",
        "66": "   * narrowly) faster than the straightforward ternary expression.\n",
        "67": "   */\n",
        "68": "  @VisibleForTesting\n",
        "69": "  static int lessThanBranchFree(int x, int y) {\n",
        "70": "    // The double negation is optimized away by normal Java, but is necessary for GWT\n",
        "71": "    // to make sure bit twiddling works as expected.\n",
        "72": "    return ~~(x - y) >>> (Integer.SIZE - 1);\n",
        "73": "  }\n",
        "74": "\n",
        "75": "  /**\n",
        "76": "   * Returns the base-2 logarithm of {@code x}, rounded according to the specified rounding mode.\n",
        "77": "   *\n",
        "78": "   * @throws IllegalArgumentException if {@code x <= 0}\n",
        "79": "   * @throws ArithmeticException if {@code mode} is {@link RoundingMode#UNNECESSARY} and {@code x}\n",
        "80": "   *         is not a power of two\n",
        "81": "   */\n",
        "82": "  @SuppressWarnings(\"fallthrough\")\n",
        "83": "  // TODO(kevinb): remove after this warning is disabled globally\n",
        "84": "  public static int log2(int x, RoundingMode mode) {\n",
        "85": "    checkPositive(\"x\", x);\n",
        "86": "    switch (mode) {\n",
        "87": "      case UNNECESSARY:\n",
        "88": "        checkRoundingUnnecessary(isPowerOfTwo(x));\n",
        "89": "        // fall through\n",
        "90": "      case DOWN:\n",
        "91": "      case FLOOR:\n",
        "92": "        return (Integer.SIZE - 1) - Integer.numberOfLeadingZeros(x);\n",
        "93": "\n",
        "94": "      case UP:\n",
        "95": "      case CEILING:\n",
        "96": "        return Integer.SIZE - Integer.numberOfLeadingZeros(x - 1);\n",
        "97": "\n",
        "98": "      case HALF_DOWN:\n",
        "99": "      case HALF_UP:\n",
        "100": "      case HALF_EVEN:\n",
        "101": "        // Since sqrt(2) is irrational, log2(x) - logFloor cannot be exactly 0.5\n",
        "102": "        int leadingZeros = Integer.numberOfLeadingZeros(x);\n",
        "103": "        int cmp = MAX_POWER_OF_SQRT2_UNSIGNED >>> leadingZeros;\n",
        "104": "          // floor(2^(logFloor + 0.5))\n",
        "105": "        int logFloor = (Integer.SIZE - 1) - leadingZeros;\n",
        "106": "        return logFloor + lessThanBranchFree(cmp, x);\n",
        "107": "\n",
        "108": "      default:\n",
        "109": "        throw new AssertionError();\n",
        "110": "    }\n",
        "111": "  }\n",
        "112": "\n",
        "113": "  /** The biggest half power of two that can fit in an unsigned int. */\n",
        "114": "  @VisibleForTesting static final int MAX_POWER_OF_SQRT2_UNSIGNED = 0xB504F333;\n",
        "115": "\n",
        "116": "  private static int log10Floor(int x) {\n",
        "117": "    /*\n",
        "118": "     * Based on Hacker's Delight Fig. 11-5, the two-table-lookup, branch-free implementation.\n",
        "119": "     *\n",
        "120": "     * The key idea is that based on the number of leading zeros (equivalently, floor(log2(x))),\n",
        "121": "     * we can narrow the possible floor(log10(x)) values to two.  For example, if floor(log2(x))\n",
        "122": "     * is 6, then 64 <= x < 128, so floor(log10(x)) is either 1 or 2.\n",
        "123": "     */\n",
        "124": "    int y = maxLog10ForLeadingZeros[Integer.numberOfLeadingZeros(x)];\n",
        "125": "    /*\n",
        "126": "     * y is the higher of the two possible values of floor(log10(x)). If x < 10^y, then we want the\n",
        "127": "     * lower of the two possible values, or y - 1, otherwise, we want y.\n",
        "128": "     */\n",
        "129": "    return y - lessThanBranchFree(x, powersOf10[y]);\n",
        "130": "  }\n",
        "131": "\n",
        "132": "  // maxLog10ForLeadingZeros[i] == floor(log10(2^(Long.SIZE - i)))\n",
        "133": "  @VisibleForTesting static final byte[] maxLog10ForLeadingZeros = {9, 9, 9, 8, 8, 8,\n",
        "134": "    7, 7, 7, 6, 6, 6, 6, 5, 5, 5, 4, 4, 4, 3, 3, 3, 3, 2, 2, 2, 1, 1, 1, 0, 0, 0, 0};\n",
        "135": "\n",
        "136": "  @VisibleForTesting static final int[] powersOf10 = {1, 10, 100, 1000, 10000,\n",
        "137": "    100000, 1000000, 10000000, 100000000, 1000000000};\n",
        "138": "\n",
        "139": "  // halfPowersOf10[i] = largest int less than 10^(i + 0.5)\n",
        "140": "  @VisibleForTesting static final int[] halfPowersOf10 =\n",
        "141": "      {3, 31, 316, 3162, 31622, 316227, 3162277, 31622776, 316227766, Integer.MAX_VALUE};\n",
        "142": "\n",
        "143": "  private static int sqrtFloor(int x) {\n",
        "144": "    // There is no loss of precision in converting an int to a double, according to\n",
        "145": "    // http://java.sun.com/docs/books/jls/third_edition/html/conversions.html#5.1.2\n",
        "146": "    return (int) Math.sqrt(x);\n",
        "147": "  }\n",
        "148": "\n",
        "149": "  /**\n",
        "150": "   * Returns the result of dividing {@code p} by {@code q}, rounding using the specified\n",
        "151": "   * {@code RoundingMode}.\n",
        "152": "   *\n",
        "153": "   * @throws ArithmeticException if {@code q == 0}, or if {@code mode == UNNECESSARY} and {@code a}\n",
        "154": "   *         is not an integer multiple of {@code b}\n",
        "155": "   */\n",
        "156": "  @SuppressWarnings(\"fallthrough\")\n",
        "157": "  public static int divide(int p, int q, RoundingMode mode) {\n",
        "158": "    checkNotNull(mode);\n",
        "159": "    if (q == 0) {\n",
        "160": "      throw new ArithmeticException(\"/ by zero\"); // for GWT\n",
        "161": "    }\n",
        "162": "    int div = p / q;\n",
        "163": "    int rem = p - q * div; // equal to p % q\n",
        "164": "\n",
        "165": "    if (rem == 0) {\n",
        "166": "      return div;\n",
        "167": "    }\n",
        "168": "\n",
        "169": "    /*\n",
        "170": "     * Normal Java division rounds towards 0, consistently with RoundingMode.DOWN. We just have to\n",
        "171": "     * deal with the cases where rounding towards 0 is wrong, which typically depends on the sign of\n",
        "172": "     * p / q.\n",
        "173": "     *\n",
        "174": "     * signum is 1 if p and q are both nonnegative or both negative, and -1 otherwise.\n",
        "175": "     */\n",
        "176": "    int signum = 1 | ((p ^ q) >> (Integer.SIZE - 1));\n",
        "177": "    boolean increment;\n",
        "178": "    switch (mode) {\n",
        "179": "      case UNNECESSARY:\n",
        "180": "        checkRoundingUnnecessary(rem == 0);\n",
        "181": "        // fall through\n",
        "182": "      case DOWN:\n",
        "183": "        increment = false;\n",
        "184": "        break;\n",
        "185": "      case UP:\n",
        "186": "        increment = true;\n",
        "187": "        break;\n",
        "188": "      case CEILING:\n",
        "189": "        increment = signum > 0;\n",
        "190": "        break;\n",
        "191": "      case FLOOR:\n",
        "192": "        increment = signum < 0;\n",
        "193": "        break;\n",
        "194": "      case HALF_EVEN:\n",
        "195": "      case HALF_DOWN:\n",
        "196": "      case HALF_UP:\n",
        "197": "        int absRem = abs(rem);\n",
        "198": "        int cmpRemToHalfDivisor = absRem - (abs(q) - absRem);\n",
        "199": "        // subtracting two nonnegative ints can't overflow\n",
        "200": "        // cmpRemToHalfDivisor has the same sign as compare(abs(rem), abs(q) / 2).\n",
        "201": "        if (cmpRemToHalfDivisor == 0) { // exactly on the half mark\n",
        "202": "          increment = (mode == HALF_UP || (mode == HALF_EVEN & (div & 1) != 0));\n",
        "203": "        } else {\n",
        "204": "          increment = cmpRemToHalfDivisor > 0; // closer to the UP value\n",
        "205": "        }\n",
        "206": "        break;\n",
        "207": "      default:\n",
        "208": "        throw new AssertionError();\n",
        "209": "    }\n",
        "210": "    return increment ? div + signum : div;\n",
        "211": "  }\n",
        "212": "\n",
        "213": "  /**\n",
        "214": "   * Returns {@code x mod m}, a non-negative value less than {@code m}.\n",
        "215": "   * This differs from {@code x % m}, which might be negative.\n",
        "216": "   *\n",
        "217": "   * <p>For example:<pre> {@code\n",
        "218": "   *\n",
        "219": "   * mod(7, 4) == 3\n",
        "220": "   * mod(-7, 4) == 1\n",
        "221": "   * mod(-1, 4) == 3\n",
        "222": "   * mod(-8, 4) == 0\n",
        "223": "   * mod(8, 4) == 0}</pre>\n",
        "224": "   *\n",
        "225": "   * @throws ArithmeticException if {@code m <= 0}\n",
        "226": "   * @see <a href=\"http://docs.oracle.com/javase/specs/jls/se7/html/jls-15.html#jls-15.17.3\">\n",
        "227": "   *      Remainder Operator</a>\n",
        "228": "   */\n",
        "229": "  public static int mod(int x, int m) {\n",
        "230": "    if (m <= 0) {\n",
        "231": "      throw new ArithmeticException(\"Modulus \" + m + \" must be > 0\");\n",
        "232": "    }\n",
        "233": "    int result = x % m;\n",
        "234": "    return (result >= 0) ? result : result + m;\n",
        "235": "  }\n",
        "236": "\n",
        "237": "  /**\n",
        "238": "   * Returns the greatest common divisor of {@code a, b}. Returns {@code 0} if\n",
        "239": "   * {@code a == 0 && b == 0}.\n",
        "240": "   *\n",
        "241": "   * @throws IllegalArgumentException if {@code a < 0} or {@code b < 0}\n",
        "242": "   */\n",
        "243": "  public static int gcd(int a, int b) {\n",
        "244": "    /*\n",
        "245": "     * The reason we require both arguments to be >= 0 is because otherwise, what do you return on\n",
        "246": "     * gcd(0, Integer.MIN_VALUE)? BigInteger.gcd would return positive 2^31, but positive 2^31\n",
        "247": "     * isn't an int.\n",
        "248": "     */\n",
        "249": "    checkNonNegative(\"a\", a);\n",
        "250": "    checkNonNegative(\"b\", b);\n",
        "251": "    if (a == 0) {\n",
        "252": "      // 0 % b == 0, so b divides a, but the converse doesn't hold.\n",
        "253": "      // BigInteger.gcd is consistent with this decision.\n",
        "254": "      return b;\n",
        "255": "    } else if (b == 0) {\n",
        "256": "      return a; // similar logic\n",
        "257": "    }\n",
        "258": "    /*\n",
        "259": "     * Uses the binary GCD algorithm; see http://en.wikipedia.org/wiki/Binary_GCD_algorithm.\n",
        "260": "     * This is >40% faster than the Euclidean algorithm in benchmarks.\n",
        "261": "     */\n",
        "262": "    int aTwos = Integer.numberOfTrailingZeros(a);\n",
        "263": "    a >>= aTwos; // divide out all 2s\n",
        "264": "    int bTwos = Integer.numberOfTrailingZeros(b);\n",
        "265": "    b >>= bTwos; // divide out all 2s\n",
        "266": "    while (a != b) { // both a, b are odd\n",
        "267": "      // The key to the binary GCD algorithm is as follows:\n",
        "268": "      // Both a and b are odd.  Assume a > b; then gcd(a - b, b) = gcd(a, b).\n",
        "269": "      // But in gcd(a - b, b), a - b is even and b is odd, so we can divide out powers of two.\n",
        "270": "\n",
        "271": "      // We bend over backwards to avoid branching, adapting a technique from\n",
        "272": "      // http://graphics.stanford.edu/~seander/bithacks.html#IntegerMinOrMax\n",
        "273": "\n",
        "274": "      int delta = a - b; // can't overflow, since a and b are nonnegative\n",
        "275": "\n",
        "276": "      int minDeltaOrZero = delta & (delta >> (Integer.SIZE - 1));\n",
        "277": "      // equivalent to Math.min(delta, 0)\n",
        "278": "\n",
        "279": "      a = delta - minDeltaOrZero - minDeltaOrZero; // sets a to Math.abs(a - b)\n",
        "280": "      // a is now nonnegative and even\n",
        "281": "\n",
        "282": "      b += minDeltaOrZero; // sets b to min(old a, b)\n",
        "283": "      a >>= Integer.numberOfTrailingZeros(a); // divide out all 2s, since 2 doesn't divide b\n",
        "284": "    }\n",
        "285": "    return a << min(aTwos, bTwos);\n",
        "286": "  }\n",
        "287": "\n",
        "288": "  /**\n",
        "289": "   * Returns the sum of {@code a} and {@code b}, provided it does not overflow.\n",
        "290": "   *\n",
        "291": "   * @throws ArithmeticException if {@code a + b} overflows in signed {@code int} arithmetic\n",
        "292": "   */\n",
        "293": "  public static int checkedAdd(int a, int b) {\n",
        "294": "    long result = (long) a + b;\n",
        "295": "    checkNoOverflow(result == (int) result);\n",
        "296": "    return (int) result;\n",
        "297": "  }\n",
        "298": "\n",
        "299": "  /**\n",
        "300": "   * Returns the difference of {@code a} and {@code b}, provided it does not overflow.\n",
        "301": "   *\n",
        "302": "   * @throws ArithmeticException if {@code a - b} overflows in signed {@code int} arithmetic\n",
        "303": "   */\n",
        "304": "  public static int checkedSubtract(int a, int b) {\n",
        "305": "    long result = (long) a - b;\n",
        "306": "    checkNoOverflow(result == (int) result);\n",
        "307": "    return (int) result;\n",
        "308": "  }\n",
        "309": "\n",
        "310": "  /**\n",
        "311": "   * Returns the product of {@code a} and {@code b}, provided it does not overflow.\n",
        "312": "   *\n",
        "313": "   * @throws ArithmeticException if {@code a * b} overflows in signed {@code int} arithmetic\n",
        "314": "   */\n",
        "315": "  public static int checkedMultiply(int a, int b) {\n",
        "316": "    long result = (long) a * b;\n",
        "317": "    checkNoOverflow(result == (int) result);\n",
        "318": "    return (int) result;\n",
        "319": "  }\n",
        "320": "\n",
        "321": "  /**\n",
        "322": "   * Returns the {@code b} to the {@code k}th power, provided it does not overflow.\n",
        "323": "   *\n",
        "324": "   * <p>{@link #pow} may be faster, but does not check for overflow.\n",
        "325": "   *\n",
        "326": "   * @throws ArithmeticException if {@code b} to the {@code k}th power overflows in signed\n",
        "327": "   *         {@code int} arithmetic\n",
        "328": "   */\n",
        "329": "  public static int checkedPow(int b, int k) {\n",
        "330": "    checkNonNegative(\"exponent\", k);\n",
        "331": "    switch (b) {\n",
        "332": "      case 0:\n",
        "333": "        return (k == 0) ? 1 : 0;\n",
        "334": "      case 1:\n",
        "335": "        return 1;\n",
        "336": "      case (-1):\n",
        "337": "        return ((k & 1) == 0) ? 1 : -1;\n",
        "338": "      case 2:\n",
        "339": "        checkNoOverflow(k < Integer.SIZE - 1);\n",
        "340": "        return 1 << k;\n",
        "341": "      case (-2):\n",
        "342": "        checkNoOverflow(k < Integer.SIZE);\n",
        "343": "        return ((k & 1) == 0) ? 1 << k : -1 << k;\n",
        "344": "      default:\n",
        "345": "        // continue below to handle the general case\n",
        "346": "    }\n",
        "347": "    int accum = 1;\n",
        "348": "    while (true) {\n",
        "349": "      switch (k) {\n",
        "350": "        case 0:\n",
        "351": "          return accum;\n",
        "352": "        case 1:\n",
        "353": "          return checkedMultiply(accum, b);\n",
        "354": "        default:\n",
        "355": "          if ((k & 1) != 0) {\n",
        "356": "            accum = checkedMultiply(accum, b);\n",
        "357": "          }\n",
        "358": "          k >>= 1;\n",
        "359": "          if (k > 0) {\n",
        "360": "            checkNoOverflow(-FLOOR_SQRT_MAX_INT <= b & b <= FLOOR_SQRT_MAX_INT);\n",
        "361": "            b *= b;\n",
        "362": "          }\n",
        "363": "      }\n",
        "364": "    }\n",
        "365": "  }\n",
        "366": "\n",
        "367": "  @VisibleForTesting static final int FLOOR_SQRT_MAX_INT = 46340;\n",
        "368": "\n",
        "369": "  /**\n",
        "370": "   * Returns {@code n!}, that is, the product of the first {@code n} positive\n",
        "371": "   * integers, {@code 1} if {@code n == 0}, or {@link Integer#MAX_VALUE} if the\n",
        "372": "   * result does not fit in a {@code int}.\n",
        "373": "   *\n",
        "374": "   * @throws IllegalArgumentException if {@code n < 0}\n",
        "375": "   */\n",
        "376": "  public static int factorial(int n) {\n",
        "377": "    checkNonNegative(\"n\", n);\n",
        "378": "    return (n < factorials.length) ? factorials[n] : Integer.MAX_VALUE;\n",
        "379": "  }\n",
        "380": "\n",
        "381": "  private static final int[] factorials = {\n",
        "382": "      1,\n",
        "383": "      1,\n",
        "384": "      1 * 2,\n",
        "385": "      1 * 2 * 3,\n",
        "386": "      1 * 2 * 3 * 4,\n",
        "387": "      1 * 2 * 3 * 4 * 5,\n",
        "388": "      1 * 2 * 3 * 4 * 5 * 6,\n",
        "389": "      1 * 2 * 3 * 4 * 5 * 6 * 7,\n",
        "390": "      1 * 2 * 3 * 4 * 5 * 6 * 7 * 8,\n",
        "391": "      1 * 2 * 3 * 4 * 5 * 6 * 7 * 8 * 9,\n",
        "392": "      1 * 2 * 3 * 4 * 5 * 6 * 7 * 8 * 9 * 10,\n",
        "393": "      1 * 2 * 3 * 4 * 5 * 6 * 7 * 8 * 9 * 10 * 11,\n",
        "394": "      1 * 2 * 3 * 4 * 5 * 6 * 7 * 8 * 9 * 10 * 11 * 12};\n",
        "395": "\n",
        "396": "  // binomial(biggestBinomials[k], k) fits in an int, but not binomial(biggestBinomials[k]+1,k).\n",
        "397": "  @VisibleForTesting static int[] biggestBinomials = {\n",
        "398": "    Integer.MAX_VALUE,\n",
        "399": "    Integer.MAX_VALUE,\n",
        "400": "    65536,\n",
        "401": "    2345,\n",
        "402": "    477,\n",
        "403": "    193,\n",
        "404": "    110,\n",
        "405": "    75,\n",
        "406": "    58,\n",
        "407": "    49,\n",
        "408": "    43,\n",
        "409": "    39,\n",
        "410": "    37,\n",
        "411": "    35,\n",
        "412": "    34,\n",
        "413": "    34,\n",
        "414": "    33\n",
        "415": "  };\n",
        "416": "\n",
        "417": "  /**\n",
        "418": "   * Returns the arithmetic mean of {@code x} and {@code y}, rounded towards\n",
        "419": "   * negative infinity. This method is overflow resilient.\n",
        "420": "   *\n",
        "421": "   * @since 14.0\n",
        "422": "   */\n",
        "423": "  public static int mean(int x, int y) {\n",
        "424": "    // Efficient method for computing the arithmetic mean.\n",
        "425": "    // The alternative (x + y) / 2 fails for large values.\n",
        "426": "    // The alternative (x + y) >>> 1 fails for negative values.\n",
        "427": "    return (x & y) + ((x ^ y) >> 1);\n",
        "428": "  }\n",
        "429": "\n",
        "430": "  private IntMath() {}\n",
        "431": "}\n",
        "432": "\n"
    }
}