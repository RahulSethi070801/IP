{
    "addition": {},
    "removed": {
        "1": "/*\n",
        "2": " * Copyright (C) 2006 The Guava Authors\n",
        "3": " *\n",
        "4": " * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not use this file except\n",
        "5": " * in compliance with the License. You may obtain a copy of the License at\n",
        "6": " *\n",
        "7": " * http://www.apache.org/licenses/LICENSE-2.0\n",
        "8": " *\n",
        "9": " * Unless required by applicable law or agreed to in writing, software distributed under the License\n",
        "10": " * is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express\n",
        "11": " * or implied. See the License for the specific language governing permissions and limitations under\n",
        "12": " * the License.\n",
        "13": " */\n",
        "14": "\n",
        "15": "package com.google.common.util.concurrent;\n",
        "16": "\n",
        "17": "import static com.google.common.base.Preconditions.checkNotNull;\n",
        "18": "import static com.google.common.util.concurrent.MoreExecutors.directExecutor;\n",
        "19": "import static com.google.common.util.concurrent.Uninterruptibles.getUninterruptibly;\n",
        "20": "\n",
        "21": "import com.google.common.annotations.Beta;\n",
        "22": "import com.google.common.annotations.GwtCompatible;\n",
        "23": "import com.google.common.base.Function;\n",
        "24": "import com.google.common.base.Preconditions;\n",
        "25": "import com.google.common.collect.ImmutableList;\n",
        "26": "import com.google.common.util.concurrent.CollectionFuture.ListFuture;\n",
        "27": "import com.google.common.util.concurrent.ImmediateFuture.ImmediateFailedFuture;\n",
        "28": "import com.google.common.util.concurrent.ImmediateFuture.ImmediateSuccessfulFuture;\n",
        "29": "\n",
        "30": "import java.util.List;\n",
        "31": "import java.util.concurrent.ExecutionException;\n",
        "32": "import java.util.concurrent.Executor;\n",
        "33": "\n",
        "34": "import javax.annotation.CheckReturnValue;\n",
        "35": "import javax.annotation.Nullable;\n",
        "36": "\n",
        "37": "/**\n",
        "38": " * Static utility methods pertaining to the {@link Future} interface.\n",
        "39": " *\n",
        "40": " * <p>Many of these methods use the {@link ListenableFuture} API; consult the\n",
        "41": " * Guava User Guide article on <a href=\n",
        "42": " * \"https://github.com/google/guava/wiki/ListenableFutureExplained\">\n",
        "43": " * {@code ListenableFuture}</a>.\n",
        "44": " *\n",
        "45": " * @author Kevin Bourrillion\n",
        "46": " * @author Nishant Thakkar\n",
        "47": " * @author Sven Mawson\n",
        "48": " * @since 1.0\n",
        "49": " */\n",
        "50": "@Beta\n",
        "51": "@GwtCompatible(emulated = true)\n",
        "52": "public final class Futures extends GwtFuturesCatchingSpecialization {\n",
        "53": "\n",
        "54": "  // A note on memory visibility.\n",
        "55": "  // Many of the utilities in this class (transform, withFallback, withTimeout, asList, combine)\n",
        "56": "  // have two requirements that significantly complicate their design.\n",
        "57": "  // 1. Cancellation should propagate from the returned future to the input future(s).\n",
        "58": "  // 2. The returned futures shouldn't unnecessarily 'pin' their inputs after completion.\n",
        "59": "  //\n",
        "60": "  // A consequence of these requirements is that the delegate futures cannot be stored in\n",
        "61": "  // final fields.\n",
        "62": "  //\n",
        "63": "  // For simplicity the rest of this description will discuss Futures.catching since it is the\n",
        "64": "  // simplest instance, though very similar descriptions apply to many other classes in this file.\n",
        "65": "  //\n",
        "66": "  // In the constructor of AbstractCatchingFuture, the delegate future is assigned to a field\n",
        "67": "  // 'inputFuture'. That field is non-final and non-volatile.  There are 2 places where the\n",
        "68": "  // 'inputFuture' field is read and where we will have to consider visibility of the write\n",
        "69": "  // operation in the constructor.\n",
        "70": "  //\n",
        "71": "  // 1. In the listener that performs the callback.  In this case it is fine since inputFuture is\n",
        "72": "  //    assigned prior to calling addListener, and addListener happens-before any invocation of the\n",
        "73": "  //    listener. Notably, this means that 'volatile' is unnecessary to make 'inputFuture' visible\n",
        "74": "  //    to the listener.\n",
        "75": "  //\n",
        "76": "  // 2. In done() where we may propagate cancellation to the input.  In this case it is _not_ fine.\n",
        "77": "  //    There is currently nothing that enforces that the write to inputFuture in the constructor is\n",
        "78": "  //    visible to done().  This is because there is no happens before edge between the write and a\n",
        "79": "  //    (hypothetical) unsafe read by our caller. Note: adding 'volatile' does not fix this issue,\n",
        "80": "  //    it would just add an edge such that if done() observed non-null, then it would also\n",
        "81": "  //    definitely observe all earlier writes, but we still have no guarantee that done() would see\n",
        "82": "  //    the inital write (just stronger guarantees if it does).\n",
        "83": "  //\n",
        "84": "  // See: http://cs.oswego.edu/pipermail/concurrency-interest/2015-January/013800.html\n",
        "85": "  // For a (long) discussion about this specific issue and the general futility of life.\n",
        "86": "  //\n",
        "87": "  // For the time being we are OK with the problem discussed above since it requires a caller to\n",
        "88": "  // introduce a very specific kind of data-race.  And given the other operations performed by these\n",
        "89": "  // methods that involve volatile read/write operations, in practice there is no issue.  Also, the\n",
        "90": "  // way in such a visibility issue would surface is most likely as a failure of cancel() to\n",
        "91": "  // propagate to the input.  Cancellation propagation is fundamentally racy so this is fine.\n",
        "92": "  //\n",
        "93": "  // Future versions of the JMM may revise safe construction semantics in such a way that we can\n",
        "94": "  // safely publish these objects and we won't need this whole discussion.\n",
        "95": "  // TODO(user,lukes): consider adding volatile to all these fields since in current known JVMs\n",
        "96": "  // that should resolve the issue.  This comes at the cost of adding more write barriers to the\n",
        "97": "  // implementations.\n",
        "98": "\n",
        "99": "  private Futures() {}\n",
        "100": "\n",
        "101": "  /**\n",
        "102": "   * Creates a {@code ListenableFuture} which has its value set immediately upon construction. The\n",
        "103": "   * getters just return the value. This {@code Future} can't be canceled or timed out and its\n",
        "104": "   * {@code isDone()} method always returns {@code true}.\n",
        "105": "   */\n",
        "106": "  @CheckReturnValue\n",
        "107": "  public static <V> ListenableFuture<V> immediateFuture(@Nullable V value) {\n",
        "108": "    if (value == null) {\n",
        "109": "      // This cast is safe because null is assignable to V for all V (i.e. it is covariant)\n",
        "110": "      @SuppressWarnings({\"unchecked\", \"rawtypes\"})\n",
        "111": "      ListenableFuture<V> typedNull = (ListenableFuture) ImmediateSuccessfulFuture.NULL;\n",
        "112": "      return typedNull;\n",
        "113": "    }\n",
        "114": "    return new ImmediateSuccessfulFuture<V>(value);\n",
        "115": "  }\n",
        "116": "\n",
        "117": "  /**\n",
        "118": "   * Returns a {@code ListenableFuture} which has an exception set immediately upon construction.\n",
        "119": "   *\n",
        "120": "   * <p>The returned {@code Future} can't be cancelled, and its {@code isDone()} method always\n",
        "121": "   * returns {@code true}. Calling {@code get()} will immediately throw the provided {@code\n",
        "122": "   * Throwable} wrapped in an {@code ExecutionException}.\n",
        "123": "   */\n",
        "124": "  @CheckReturnValue\n",
        "125": "  public static <V> ListenableFuture<V> immediateFailedFuture(Throwable throwable) {\n",
        "126": "    checkNotNull(throwable);\n",
        "127": "    return new ImmediateFailedFuture<V>(throwable);\n",
        "128": "  }\n",
        "129": "\n",
        "130": "  /**\n",
        "131": "   * Returns a {@code Future} whose result is taken from the given primary {@code input} or, if the\n",
        "132": "   * primary input fails, from the {@code Future} provided by the {@code fallback}. {@link\n",
        "133": "   * FutureFallback#create} is not invoked until the primary input has failed, so if the primary\n",
        "134": "   * input succeeds, it is never invoked. If, during the invocation of {@code fallback}, an\n",
        "135": "   * exception is thrown, this exception is used as the result of the output {@code Future}.\n",
        "136": "   *\n",
        "137": "   * <p>Below is an example of a fallback that returns a default value if an exception occurs:\n",
        "138": "   *\n",
        "139": "   * <pre>   {@code\n",
        "140": "   *   ListenableFuture<Integer> fetchCounterFuture = ...;\n",
        "141": "   *\n",
        "142": "   *   // Falling back to a zero counter in case an exception happens when\n",
        "143": "   *   // processing the RPC to fetch counters.\n",
        "144": "   *   ListenableFuture<Integer> faultTolerantFuture = Futures.withFallback(\n",
        "145": "   *       fetchCounterFuture, new FutureFallback<Integer>() {\n",
        "146": "   *         public ListenableFuture<Integer> create(Throwable t) {\n",
        "147": "   *           // Returning \"0\" as the default for the counter when the\n",
        "148": "   *           // exception happens.\n",
        "149": "   *           return immediateFuture(0);\n",
        "150": "   *         }\n",
        "151": "   *       });}</pre>\n",
        "152": "   *\n",
        "153": "   * <p>The fallback can also choose to propagate the original exception when desired:\n",
        "154": "   *\n",
        "155": "   * <pre>   {@code\n",
        "156": "   *   ListenableFuture<Integer> fetchCounterFuture = ...;\n",
        "157": "   *\n",
        "158": "   *   // Falling back to a zero counter only in case the exception was a\n",
        "159": "   *   // TimeoutException.\n",
        "160": "   *   ListenableFuture<Integer> faultTolerantFuture = Futures.withFallback(\n",
        "161": "   *       fetchCounterFuture, new FutureFallback<Integer>() {\n",
        "162": "   *         public ListenableFuture<Integer> create(Throwable t) {\n",
        "163": "   *           if (t instanceof TimeoutException) {\n",
        "164": "   *             return immediateFuture(0);\n",
        "165": "   *           }\n",
        "166": "   *           return immediateFailedFuture(t);\n",
        "167": "   *         }\n",
        "168": "   *       });}</pre>\n",
        "169": "   *\n",
        "170": "   * <p>This overload, which does not accept an executor, uses {@code directExecutor}, a dangerous\n",
        "171": "   * choice in some cases. See the discussion in the {@link ListenableFuture#addListener\n",
        "172": "   * ListenableFuture.addListener} documentation. The documentation's warnings about \"lightweight\n",
        "173": "   * listeners\" refer here to the work done during {@code FutureFallback.create}, not to any work\n",
        "174": "   * done to complete the returned {@code Future}.\n",
        "175": "   *\n",
        "176": "   * @param input the primary input {@code Future}\n",
        "177": "   * @param fallback the {@link FutureFallback} implementation to be called if {@code input} fails\n",
        "178": "   * @since 14.0\n",
        "179": "   * @deprecated Use {@link #catchingAsync(ListenableFuture, Class, AsyncFunction)\n",
        "180": "   *     catchingAsync(input, Throwable.class, fallbackImplementedAsAnAsyncFunction)}, usually\n",
        "181": "   *     replacing {@code Throwable.class} with the specific type you want to handle. This method\n",
        "182": "   *     will be removed in Guava release 20.0.\n",
        "183": "   */\n",
        "184": "  @Deprecated\n",
        "185": "  @CheckReturnValue\n",
        "186": "  public static <V> ListenableFuture<V> withFallback(\n",
        "187": "      ListenableFuture<? extends V> input, FutureFallback<? extends V> fallback) {\n",
        "188": "    return withFallback(input, fallback, directExecutor());\n",
        "189": "  }\n",
        "190": "\n",
        "191": "  /**\n",
        "192": "   * Returns a {@code Future} whose result is taken from the given primary {@code input} or, if the\n",
        "193": "   * primary input fails, from the {@code Future} provided by the {@code fallback}. {@link\n",
        "194": "   * FutureFallback#create} is not invoked until the primary input has failed, so if the primary\n",
        "195": "   * input succeeds, it is never invoked. If, during the invocation of {@code fallback}, an\n",
        "196": "   * exception is thrown, this exception is used as the result of the output {@code Future}.\n",
        "197": "   *\n",
        "198": "   * <p>Below is an example of a fallback that returns a default value if an exception occurs:\n",
        "199": "   *\n",
        "200": "   * <pre>   {@code\n",
        "201": "   *   ListenableFuture<Integer> fetchCounterFuture = ...;\n",
        "202": "   *\n",
        "203": "   *   // Falling back to a zero counter in case an exception happens when\n",
        "204": "   *   // processing the RPC to fetch counters.\n",
        "205": "   *   ListenableFuture<Integer> faultTolerantFuture = Futures.withFallback(\n",
        "206": "   *       fetchCounterFuture, new FutureFallback<Integer>() {\n",
        "207": "   *         public ListenableFuture<Integer> create(Throwable t) {\n",
        "208": "   *           // Returning \"0\" as the default for the counter when the\n",
        "209": "   *           // exception happens.\n",
        "210": "   *           return immediateFuture(0);\n",
        "211": "   *         }\n",
        "212": "   *       }, directExecutor());}</pre>\n",
        "213": "   *\n",
        "214": "   * <p>The fallback can also choose to propagate the original exception when desired:\n",
        "215": "   *\n",
        "216": "   * <pre>   {@code\n",
        "217": "   *   ListenableFuture<Integer> fetchCounterFuture = ...;\n",
        "218": "   *\n",
        "219": "   *   // Falling back to a zero counter only in case the exception was a\n",
        "220": "   *   // TimeoutException.\n",
        "221": "   *   ListenableFuture<Integer> faultTolerantFuture = Futures.withFallback(\n",
        "222": "   *       fetchCounterFuture, new FutureFallback<Integer>() {\n",
        "223": "   *         public ListenableFuture<Integer> create(Throwable t) {\n",
        "224": "   *           if (t instanceof TimeoutException) {\n",
        "225": "   *             return immediateFuture(0);\n",
        "226": "   *           }\n",
        "227": "   *           return immediateFailedFuture(t);\n",
        "228": "   *         }\n",
        "229": "   *       }, directExecutor());}</pre>\n",
        "230": "   *\n",
        "231": "   * <p>When selecting an executor, note that {@code directExecutor} is dangerous in some cases. See\n",
        "232": "   * the discussion in the {@link ListenableFuture#addListener ListenableFuture.addListener}\n",
        "233": "   * documentation. The documentation's warnings about \"lightweight listeners\" refer here to the\n",
        "234": "   * work done during {@code FutureFallback.create}, not to any work done to complete the returned\n",
        "235": "   * {@code Future}.\n",
        "236": "   *\n",
        "237": "   * @param input the primary input {@code Future}\n",
        "238": "   * @param fallback the {@link FutureFallback} implementation to be called if {@code input} fails\n",
        "239": "   * @param executor the executor that runs {@code fallback} if {@code input} fails\n",
        "240": "   * @since 14.0\n",
        "241": "   * @deprecated Use {@link #catchingAsync(ListenableFuture, Class, AsyncFunction, Executor)\n",
        "242": "   *     catchingAsync(input, Throwable.class, fallbackImplementedAsAnAsyncFunction, executor)},\n",
        "243": "   *     usually replacing {@code Throwable.class} with the specific type you want to handle. This\n",
        "244": "   *     method will be removed in Guava release 20.0.\n",
        "245": "   */\n",
        "246": "  @Deprecated\n",
        "247": "  @CheckReturnValue\n",
        "248": "  public static <V> ListenableFuture<V> withFallback(\n",
        "249": "      ListenableFuture<? extends V> input,\n",
        "250": "      FutureFallback<? extends V> fallback,\n",
        "251": "      Executor executor) {\n",
        "252": "    return catchingAsync(input, Throwable.class, asAsyncFunction(fallback), executor);\n",
        "253": "  }\n",
        "254": "\n",
        "255": "  @Deprecated\n",
        "256": "  static <V> AsyncFunction<Throwable, V> asAsyncFunction(final FutureFallback<V> fallback) {\n",
        "257": "    checkNotNull(fallback);\n",
        "258": "    return new AsyncFunction<Throwable, V>() {\n",
        "259": "      @Override\n",
        "260": "      public ListenableFuture<V> apply(Throwable t) throws Exception {\n",
        "261": "        return checkNotNull(\n",
        "262": "            fallback.create(t),\n",
        "263": "            \"FutureFallback.create returned null instead of a \"\n",
        "264": "                + \"Future. Did you mean to return immediateFuture(null)?\");\n",
        "265": "      }\n",
        "266": "    };\n",
        "267": "  }\n",
        "268": "\n",
        "269": "  /**\n",
        "270": "   * Returns a new {@code ListenableFuture} whose result is asynchronously derived from the result\n",
        "271": "   * of the given {@code Future}. More precisely, the returned {@code Future} takes its result from\n",
        "272": "   * a {@code Future} produced by applying the given {@code AsyncFunction} to the result of the\n",
        "273": "   * original {@code Future}. Example:\n",
        "274": "   *\n",
        "275": "   * <pre>   {@code\n",
        "276": "   *   ListenableFuture<RowKey> rowKeyFuture = indexService.lookUp(query);\n",
        "277": "   *   AsyncFunction<RowKey, QueryResult> queryFunction =\n",
        "278": "   *       new AsyncFunction<RowKey, QueryResult>() {\n",
        "279": "   *         public ListenableFuture<QueryResult> apply(RowKey rowKey) {\n",
        "280": "   *           return dataService.read(rowKey);\n",
        "281": "   *         }\n",
        "282": "   *       };\n",
        "283": "   *   ListenableFuture<QueryResult> queryFuture =\n",
        "284": "   *       transform(rowKeyFuture, queryFunction);}</pre>\n",
        "285": "   *\n",
        "286": "   * <p>This overload, which does not accept an executor, uses {@code directExecutor}, a dangerous\n",
        "287": "   * choice in some cases. See the discussion in the {@link ListenableFuture#addListener\n",
        "288": "   * ListenableFuture.addListener} documentation. The documentation's warnings about \"lightweight\n",
        "289": "   * listeners\" refer here to the work done during {@code AsyncFunction.apply}, not to any work done\n",
        "290": "   * to complete the returned {@code Future}.\n",
        "291": "   *\n",
        "292": "   * <p>The returned {@code Future} attempts to keep its cancellation state in sync with that of the\n",
        "293": "   * input future and that of the future returned by the function. That is, if the returned {@code\n",
        "294": "   * Future} is cancelled, it will attempt to cancel the other two, and if either of the other two\n",
        "295": "   * is cancelled, the returned {@code Future} will receive a callback in which it will attempt to\n",
        "296": "   * cancel itself.\n",
        "297": "   *\n",
        "298": "   * @param input The future to transform\n",
        "299": "   * @param function A function to transform the result of the input future to the result of the\n",
        "300": "   *     output future\n",
        "301": "   * @return A future that holds result of the function (if the input succeeded) or the original\n",
        "302": "   *     input's failure (if not)\n",
        "303": "   * @since 11.0\n",
        "304": "   * @deprecated These {@code AsyncFunction} overloads of {@code transform} are being renamed to\n",
        "305": "   *     {@code transformAsync}. (The {@code Function} overloads are keeping the \"transform\" name.)\n",
        "306": "   *     This method will be removed in Guava release 20.0.\n",
        "307": "   */\n",
        "308": "  @Deprecated\n",
        "309": "  public static <I, O> ListenableFuture<O> transform(\n",
        "310": "      ListenableFuture<I> input, AsyncFunction<? super I, ? extends O> function) {\n",
        "311": "    return transformAsync(input, function);\n",
        "312": "  }\n",
        "313": "\n",
        "314": "  /**\n",
        "315": "   * Returns a new {@code ListenableFuture} whose result is asynchronously derived from the result\n",
        "316": "   * of the given {@code Future}. More precisely, the returned {@code Future} takes its result from\n",
        "317": "   * a {@code Future} produced by applying the given {@code AsyncFunction} to the result of the\n",
        "318": "   * original {@code Future}. Example:\n",
        "319": "   *\n",
        "320": "   * <pre>   {@code\n",
        "321": "   *   ListenableFuture<RowKey> rowKeyFuture = indexService.lookUp(query);\n",
        "322": "   *   AsyncFunction<RowKey, QueryResult> queryFunction =\n",
        "323": "   *       new AsyncFunction<RowKey, QueryResult>() {\n",
        "324": "   *         public ListenableFuture<QueryResult> apply(RowKey rowKey) {\n",
        "325": "   *           return dataService.read(rowKey);\n",
        "326": "   *         }\n",
        "327": "   *       };\n",
        "328": "   *   ListenableFuture<QueryResult> queryFuture =\n",
        "329": "   *       transform(rowKeyFuture, queryFunction, executor);}</pre>\n",
        "330": "   *\n",
        "331": "   * <p>When selecting an executor, note that {@code directExecutor} is dangerous in some cases. See\n",
        "332": "   * the discussion in the {@link ListenableFuture#addListener ListenableFuture.addListener}\n",
        "333": "   * documentation. The documentation's warnings about \"lightweight listeners\" refer here to the\n",
        "334": "   * work done during {@code AsyncFunction.apply}, not to any work done to complete the returned\n",
        "335": "   * {@code Future}.\n",
        "336": "   *\n",
        "337": "   * <p>The returned {@code Future} attempts to keep its cancellation state in sync with that of the\n",
        "338": "   * input future and that of the future returned by the chain function. That is, if the returned\n",
        "339": "   * {@code Future} is cancelled, it will attempt to cancel the other two, and if either of the\n",
        "340": "   * other two is cancelled, the returned {@code Future} will receive a callback in which it will\n",
        "341": "   * attempt to cancel itself.\n",
        "342": "   *\n",
        "343": "   * @param input The future to transform\n",
        "344": "   * @param function A function to transform the result of the input future to the result of the\n",
        "345": "   *     output future\n",
        "346": "   * @param executor Executor to run the function in.\n",
        "347": "   * @return A future that holds result of the function (if the input succeeded) or the original\n",
        "348": "   *     input's failure (if not)\n",
        "349": "   * @since 11.0\n",
        "350": "   * @deprecated These {@code AsyncFunction} overloads of {@code transform} are being renamed to\n",
        "351": "   *     {@code transformAsync}. (The {@code Function} overloads are keeping the \"transform\" name.)\n",
        "352": "   *     This method will be removed in Guava release 20.0.\n",
        "353": "   */\n",
        "354": "  @Deprecated\n",
        "355": "  public static <I, O> ListenableFuture<O> transform(\n",
        "356": "      ListenableFuture<I> input,\n",
        "357": "      AsyncFunction<? super I, ? extends O> function,\n",
        "358": "      Executor executor) {\n",
        "359": "    return transformAsync(input, function, executor);\n",
        "360": "  }\n",
        "361": "\n",
        "362": "  /**\n",
        "363": "   * Returns a new {@code ListenableFuture} whose result is asynchronously derived from the result\n",
        "364": "   * of the given {@code Future}. More precisely, the returned {@code Future} takes its result from\n",
        "365": "   * a {@code Future} produced by applying the given {@code AsyncFunction} to the result of the\n",
        "366": "   * original {@code Future}. Example:\n",
        "367": "   *\n",
        "368": "   * <pre>   {@code\n",
        "369": "   *   ListenableFuture<RowKey> rowKeyFuture = indexService.lookUp(query);\n",
        "370": "   *   AsyncFunction<RowKey, QueryResult> queryFunction =\n",
        "371": "   *       new AsyncFunction<RowKey, QueryResult>() {\n",
        "372": "   *         public ListenableFuture<QueryResult> apply(RowKey rowKey) {\n",
        "373": "   *           return dataService.read(rowKey);\n",
        "374": "   *         }\n",
        "375": "   *       };\n",
        "376": "   *   ListenableFuture<QueryResult> queryFuture =\n",
        "377": "   *       transformAsync(rowKeyFuture, queryFunction);}</pre>\n",
        "378": "   *\n",
        "379": "   * <p>This overload, which does not accept an executor, uses {@code directExecutor}, a dangerous\n",
        "380": "   * choice in some cases. See the discussion in the {@link ListenableFuture#addListener\n",
        "381": "   * ListenableFuture.addListener} documentation. The documentation's warnings about \"lightweight\n",
        "382": "   * listeners\" refer here to the work done during {@code AsyncFunction.apply}, not to any work done\n",
        "383": "   * to complete the returned {@code Future}.\n",
        "384": "   *\n",
        "385": "   * <p>The returned {@code Future} attempts to keep its cancellation state in sync with that of the\n",
        "386": "   * input future and that of the future returned by the function. That is, if the returned {@code\n",
        "387": "   * Future} is cancelled, it will attempt to cancel the other two, and if either of the other two\n",
        "388": "   * is cancelled, the returned {@code Future} will receive a callback in which it will attempt to\n",
        "389": "   * cancel itself.\n",
        "390": "   *\n",
        "391": "   * @param input The future to transform\n",
        "392": "   * @param function A function to transform the result of the input future to the result of the\n",
        "393": "   *     output future\n",
        "394": "   * @return A future that holds result of the function (if the input succeeded) or the original\n",
        "395": "   *     input's failure (if not)\n",
        "396": "   * @since 19.0 (in 11.0 as {@code transform})\n",
        "397": "   */\n",
        "398": "  public static <I, O> ListenableFuture<O> transformAsync(\n",
        "399": "      ListenableFuture<I> input, AsyncFunction<? super I, ? extends O> function) {\n",
        "400": "    return AbstractTransformFuture.create(input, function);\n",
        "401": "  }\n",
        "402": "\n",
        "403": "  /**\n",
        "404": "   * Returns a new {@code ListenableFuture} whose result is asynchronously derived from the result\n",
        "405": "   * of the given {@code Future}. More precisely, the returned {@code Future} takes its result from\n",
        "406": "   * a {@code Future} produced by applying the given {@code AsyncFunction} to the result of the\n",
        "407": "   * original {@code Future}. Example:\n",
        "408": "   *\n",
        "409": "   * <pre>   {@code\n",
        "410": "   *   ListenableFuture<RowKey> rowKeyFuture = indexService.lookUp(query);\n",
        "411": "   *   AsyncFunction<RowKey, QueryResult> queryFunction =\n",
        "412": "   *       new AsyncFunction<RowKey, QueryResult>() {\n",
        "413": "   *         public ListenableFuture<QueryResult> apply(RowKey rowKey) {\n",
        "414": "   *           return dataService.read(rowKey);\n",
        "415": "   *         }\n",
        "416": "   *       };\n",
        "417": "   *   ListenableFuture<QueryResult> queryFuture =\n",
        "418": "   *       transformAsync(rowKeyFuture, queryFunction, executor);}</pre>\n",
        "419": "   *\n",
        "420": "   * <p>When selecting an executor, note that {@code directExecutor} is dangerous in some cases. See\n",
        "421": "   * the discussion in the {@link ListenableFuture#addListener ListenableFuture.addListener}\n",
        "422": "   * documentation. The documentation's warnings about \"lightweight listeners\" refer here to the\n",
        "423": "   * work done during {@code AsyncFunction.apply}, not to any work done to complete the returned\n",
        "424": "   * {@code Future}.\n",
        "425": "   *\n",
        "426": "   * <p>The returned {@code Future} attempts to keep its cancellation state in sync with that of the\n",
        "427": "   * input future and that of the future returned by the chain function. That is, if the returned\n",
        "428": "   * {@code Future} is cancelled, it will attempt to cancel the other two, and if either of the\n",
        "429": "   * other two is cancelled, the returned {@code Future} will receive a callback in which it will\n",
        "430": "   * attempt to cancel itself.\n",
        "431": "   *\n",
        "432": "   * @param input The future to transform\n",
        "433": "   * @param function A function to transform the result of the input future to the result of the\n",
        "434": "   *     output future\n",
        "435": "   * @param executor Executor to run the function in.\n",
        "436": "   * @return A future that holds result of the function (if the input succeeded) or the original\n",
        "437": "   *     input's failure (if not)\n",
        "438": "   * @since 19.0 (in 11.0 as {@code transform})\n",
        "439": "   */\n",
        "440": "  public static <I, O> ListenableFuture<O> transformAsync(\n",
        "441": "      ListenableFuture<I> input,\n",
        "442": "      AsyncFunction<? super I, ? extends O> function,\n",
        "443": "      Executor executor) {\n",
        "444": "    return AbstractTransformFuture.create(input, function, executor);\n",
        "445": "  }\n",
        "446": "\n",
        "447": "  /**\n",
        "448": "   * Returns a new {@code ListenableFuture} whose result is the product of applying the given {@code\n",
        "449": "   * Function} to the result of the given {@code Future}. Example:\n",
        "450": "   *\n",
        "451": "   * <pre>   {@code\n",
        "452": "   *   ListenableFuture<QueryResult> queryFuture = ...;\n",
        "453": "   *   Function<QueryResult, List<Row>> rowsFunction =\n",
        "454": "   *       new Function<QueryResult, List<Row>>() {\n",
        "455": "   *         public List<Row> apply(QueryResult queryResult) {\n",
        "456": "   *           return queryResult.getRows();\n",
        "457": "   *         }\n",
        "458": "   *       };\n",
        "459": "   *   ListenableFuture<List<Row>> rowsFuture =\n",
        "460": "   *       transform(queryFuture, rowsFunction);}</pre>\n",
        "461": "   *\n",
        "462": "   * <p>This overload, which does not accept an executor, uses {@code directExecutor}, a dangerous\n",
        "463": "   * choice in some cases. See the discussion in the {@link ListenableFuture#addListener\n",
        "464": "   * ListenableFuture.addListener} documentation. The documentation's warnings about \"lightweight\n",
        "465": "   * listeners\" refer here to the work done during {@code Function.apply}.\n",
        "466": "   *\n",
        "467": "   * <p>The returned {@code Future} attempts to keep its cancellation state in sync with that of the\n",
        "468": "   * input future. That is, if the returned {@code Future} is cancelled, it will attempt to cancel\n",
        "469": "   * the input, and if the input is cancelled, the returned {@code Future} will receive a callback\n",
        "470": "   * in which it will attempt to cancel itself.\n",
        "471": "   *\n",
        "472": "   * <p>An example use of this method is to convert a serializable object returned from an RPC into\n",
        "473": "   * a POJO.\n",
        "474": "   *\n",
        "475": "   * @param input The future to transform\n",
        "476": "   * @param function A Function to transform the results of the provided future to the results of\n",
        "477": "   *     the returned future.  This will be run in the thread that notifies input it is complete.\n",
        "478": "   * @return A future that holds result of the transformation.\n",
        "479": "   * @since 9.0 (in 1.0 as {@code compose})\n",
        "480": "   */\n",
        "481": "  public static <I, O> ListenableFuture<O> transform(\n",
        "482": "      ListenableFuture<I> input, Function<? super I, ? extends O> function) {\n",
        "483": "    return AbstractTransformFuture.create(input, function);\n",
        "484": "  }\n",
        "485": "\n",
        "486": "  /**\n",
        "487": "   * Returns a new {@code ListenableFuture} whose result is the product of applying the given {@code\n",
        "488": "   * Function} to the result of the given {@code Future}. Example:\n",
        "489": "   *\n",
        "490": "   * <pre>   {@code\n",
        "491": "   *   ListenableFuture<QueryResult> queryFuture = ...;\n",
        "492": "   *   Function<QueryResult, List<Row>> rowsFunction =\n",
        "493": "   *       new Function<QueryResult, List<Row>>() {\n",
        "494": "   *         public List<Row> apply(QueryResult queryResult) {\n",
        "495": "   *           return queryResult.getRows();\n",
        "496": "   *         }\n",
        "497": "   *       };\n",
        "498": "   *   ListenableFuture<List<Row>> rowsFuture =\n",
        "499": "   *       transform(queryFuture, rowsFunction, executor);}</pre>\n",
        "500": "   *\n",
        "501": "   * <p>When selecting an executor, note that {@code directExecutor} is dangerous in some cases. See\n",
        "502": "   * the discussion in the {@link ListenableFuture#addListener ListenableFuture.addListener}\n",
        "503": "   * documentation. The documentation's warnings about \"lightweight listeners\" refer here to the\n",
        "504": "   * work done during {@code Function.apply}.\n",
        "505": "   *\n",
        "506": "   * <p>The returned {@code Future} attempts to keep its cancellation state in sync with that of the\n",
        "507": "   * input future. That is, if the returned {@code Future} is cancelled, it will attempt to cancel\n",
        "508": "   * the input, and if the input is cancelled, the returned {@code Future} will receive a callback\n",
        "509": "   * in which it will attempt to cancel itself.\n",
        "510": "   *\n",
        "511": "   * <p>An example use of this method is to convert a serializable object returned from an RPC into\n",
        "512": "   * a POJO.\n",
        "513": "   *\n",
        "514": "   * @param input The future to transform\n",
        "515": "   * @param function A Function to transform the results of the provided future to the results of\n",
        "516": "   *     the returned future.\n",
        "517": "   * @param executor Executor to run the function in.\n",
        "518": "   * @return A future that holds result of the transformation.\n",
        "519": "   * @since 9.0 (in 2.0 as {@code compose})\n",
        "520": "   */\n",
        "521": "  public static <I, O> ListenableFuture<O> transform(\n",
        "522": "      ListenableFuture<I> input, Function<? super I, ? extends O> function, Executor executor) {\n",
        "523": "    return AbstractTransformFuture.create(input, function, executor);\n",
        "524": "  }\n",
        "525": "\n",
        "526": "  /**\n",
        "527": "   * Returns a new {@code ListenableFuture} whose result is the product of calling {@code get()} on\n",
        "528": "   * the {@code Future} nested within the given {@code Future}, effectively chaining the futures one\n",
        "529": "   * after the other.  Example:\n",
        "530": "   *\n",
        "531": "   * <pre>   {@code\n",
        "532": "   *   SettableFuture<ListenableFuture<String>> nested = SettableFuture.create();\n",
        "533": "   *   ListenableFuture<String> dereferenced = dereference(nested);}</pre>\n",
        "534": "   *\n",
        "535": "   * <p>This call has the same cancellation and execution semantics as {@link\n",
        "536": "   * #transform(ListenableFuture, AsyncFunction)}, in that the returned {@code Future} attempts to\n",
        "537": "   * keep its cancellation state in sync with both the input {@code Future} and the nested {@code\n",
        "538": "   * Future}.  The transformation is very lightweight and therefore takes place in the same thread\n",
        "539": "   * (either the thread that called {@code dereference}, or the thread in which the dereferenced\n",
        "540": "   * future completes).\n",
        "541": "   *\n",
        "542": "   * @param nested The nested future to transform.\n",
        "543": "   * @return A future that holds result of the inner future.\n",
        "544": "   * @since 13.0\n",
        "545": "   */\n",
        "546": "  @SuppressWarnings({\"rawtypes\", \"unchecked\"})\n",
        "547": "  @CheckReturnValue\n",
        "548": "  public static <V> ListenableFuture<V> dereference(\n",
        "549": "      ListenableFuture<? extends ListenableFuture<? extends V>> nested) {\n",
        "550": "    return transformAsync((ListenableFuture) nested, (AsyncFunction) DEREFERENCER);\n",
        "551": "  }\n",
        "552": "\n",
        "553": "  /**\n",
        "554": "   * Helper {@code Function} for {@link #dereference}.\n",
        "555": "   */\n",
        "556": "  private static final AsyncFunction<ListenableFuture<Object>, Object> DEREFERENCER =\n",
        "557": "      new AsyncFunction<ListenableFuture<Object>, Object>() {\n",
        "558": "        @Override\n",
        "559": "        public ListenableFuture<Object> apply(ListenableFuture<Object> input) {\n",
        "560": "          return input;\n",
        "561": "        }\n",
        "562": "      };\n",
        "563": "\n",
        "564": "  /**\n",
        "565": "   * Creates a new {@code ListenableFuture} whose value is a list containing the values of all its\n",
        "566": "   * input futures, if all succeed. If any input fails, the returned future fails immediately.\n",
        "567": "   *\n",
        "568": "   * <p>The list of results is in the same order as the input list.\n",
        "569": "   *\n",
        "570": "   * <p>Canceling this future will attempt to cancel all the component futures, and if any of the\n",
        "571": "   * provided futures fails or is canceled, this one is, too.\n",
        "572": "   *\n",
        "573": "   * @param futures futures to combine\n",
        "574": "   * @return a future that provides a list of the results of the component futures\n",
        "575": "   * @since 10.0\n",
        "576": "   */\n",
        "577": "  @Beta\n",
        "578": "  @SafeVarargs\n",
        "579": "  @CheckReturnValue\n",
        "580": "  public static <V> ListenableFuture<List<V>> allAsList(ListenableFuture<? extends V>... futures) {\n",
        "581": "    return new ListFuture<V>(ImmutableList.copyOf(futures), true);\n",
        "582": "  }\n",
        "583": "\n",
        "584": "  /**\n",
        "585": "   * Creates a new {@code ListenableFuture} whose value is a list containing the values of all its\n",
        "586": "   * input futures, if all succeed. If any input fails, the returned future fails immediately.\n",
        "587": "   *\n",
        "588": "   * <p>The list of results is in the same order as the input list.\n",
        "589": "   *\n",
        "590": "   * <p>Canceling this future will attempt to cancel all the component futures, and if any of the\n",
        "591": "   * provided futures fails or is canceled, this one is, too.\n",
        "592": "   *\n",
        "593": "   * @param futures futures to combine\n",
        "594": "   * @return a future that provides a list of the results of the component futures\n",
        "595": "   * @since 10.0\n",
        "596": "   */\n",
        "597": "  @Beta\n",
        "598": "  @CheckReturnValue\n",
        "599": "  public static <V> ListenableFuture<List<V>> allAsList(\n",
        "600": "      Iterable<? extends ListenableFuture<? extends V>> futures) {\n",
        "601": "    return new ListFuture<V>(ImmutableList.copyOf(futures), true);\n",
        "602": "  }\n",
        "603": "\n",
        "604": "  /**\n",
        "605": "   * Creates a new {@code ListenableFuture} whose value is a list containing the values of all its\n",
        "606": "   * successful input futures. The list of results is in the same order as the input list, and if\n",
        "607": "   * any of the provided futures fails or is canceled, its corresponding position will contain\n",
        "608": "   * {@code null} (which is indistinguishable from the future having a successful value of {@code\n",
        "609": "   * null}).\n",
        "610": "   *\n",
        "611": "   * <p>Canceling this future will attempt to cancel all the component futures.\n",
        "612": "   *\n",
        "613": "   * @param futures futures to combine\n",
        "614": "   * @return a future that provides a list of the results of the component futures\n",
        "615": "   * @since 10.0\n",
        "616": "   */\n",
        "617": "  @Beta\n",
        "618": "  @SafeVarargs\n",
        "619": "  @CheckReturnValue\n",
        "620": "  public static <V> ListenableFuture<List<V>> successfulAsList(\n",
        "621": "      ListenableFuture<? extends V>... futures) {\n",
        "622": "    return new ListFuture<V>(ImmutableList.copyOf(futures), false);\n",
        "623": "  }\n",
        "624": "\n",
        "625": "  /**\n",
        "626": "   * Creates a new {@code ListenableFuture} whose value is a list containing the values of all its\n",
        "627": "   * successful input futures. The list of results is in the same order as the input list, and if\n",
        "628": "   * any of the provided futures fails or is canceled, its corresponding position will contain\n",
        "629": "   * {@code null} (which is indistinguishable from the future having a successful value of {@code\n",
        "630": "   * null}).\n",
        "631": "   *\n",
        "632": "   * <p>Canceling this future will attempt to cancel all the component futures.\n",
        "633": "   *\n",
        "634": "   * @param futures futures to combine\n",
        "635": "   * @return a future that provides a list of the results of the component futures\n",
        "636": "   * @since 10.0\n",
        "637": "   */\n",
        "638": "  @Beta\n",
        "639": "  @CheckReturnValue\n",
        "640": "  public static <V> ListenableFuture<List<V>> successfulAsList(\n",
        "641": "      Iterable<? extends ListenableFuture<? extends V>> futures) {\n",
        "642": "    return new ListFuture<V>(ImmutableList.copyOf(futures), false);\n",
        "643": "  }\n",
        "644": "\n",
        "645": "  /**\n",
        "646": "   * Registers separate success and failure callbacks to be run when the {@code Future}'s\n",
        "647": "   * computation is {@linkplain java.util.concurrent.Future#isDone() complete} or, if the\n",
        "648": "   * computation is already complete, immediately.\n",
        "649": "   *\n",
        "650": "   * <p>There is no guaranteed ordering of execution of callbacks, but any callback added through\n",
        "651": "   * this method is guaranteed to be called once the computation is complete.\n",
        "652": "   *\n",
        "653": "   * Example: <pre> {@code\n",
        "654": "   * ListenableFuture<QueryResult> future = ...;\n",
        "655": "   * addCallback(future,\n",
        "656": "   *     new FutureCallback<QueryResult> {\n",
        "657": "   *       public void onSuccess(QueryResult result) {\n",
        "658": "   *         storeInCache(result);\n",
        "659": "   *       }\n",
        "660": "   *       public void onFailure(Throwable t) {\n",
        "661": "   *         reportError(t);\n",
        "662": "   *       }\n",
        "663": "   *     });}</pre>\n",
        "664": "   *\n",
        "665": "   * <p>This overload, which does not accept an executor, uses {@code directExecutor}, a dangerous\n",
        "666": "   * choice in some cases. See the discussion in the {@link ListenableFuture#addListener\n",
        "667": "   * ListenableFuture.addListener} documentation.\n",
        "668": "   *\n",
        "669": "   * <p>For a more general interface to attach a completion listener to a {@code Future}, see {@link\n",
        "670": "   * ListenableFuture#addListener addListener}.\n",
        "671": "   *\n",
        "672": "   * @param future The future attach the callback to.\n",
        "673": "   * @param callback The callback to invoke when {@code future} is completed.\n",
        "674": "   * @since 10.0\n",
        "675": "   */\n",
        "676": "  public static <V> void addCallback(\n",
        "677": "      ListenableFuture<V> future, FutureCallback<? super V> callback) {\n",
        "678": "    addCallback(future, callback, directExecutor());\n",
        "679": "  }\n",
        "680": "\n",
        "681": "  /**\n",
        "682": "   * Registers separate success and failure callbacks to be run when the {@code Future}'s\n",
        "683": "   * computation is {@linkplain java.util.concurrent.Future#isDone() complete} or, if the\n",
        "684": "   * computation is already complete, immediately.\n",
        "685": "   *\n",
        "686": "   * <p>The callback is run in {@code executor}. There is no guaranteed ordering of execution of\n",
        "687": "   * callbacks, but any callback added through this method is guaranteed to be called once the\n",
        "688": "   * computation is complete.\n",
        "689": "   *\n",
        "690": "   * Example: <pre> {@code\n",
        "691": "   * ListenableFuture<QueryResult> future = ...;\n",
        "692": "   * Executor e = ...\n",
        "693": "   * addCallback(future,\n",
        "694": "   *     new FutureCallback<QueryResult> {\n",
        "695": "   *       public void onSuccess(QueryResult result) {\n",
        "696": "   *         storeInCache(result);\n",
        "697": "   *       }\n",
        "698": "   *       public void onFailure(Throwable t) {\n",
        "699": "   *         reportError(t);\n",
        "700": "   *       }\n",
        "701": "   *     }, e);}</pre>\n",
        "702": "   *\n",
        "703": "   * <p>When selecting an executor, note that {@code directExecutor} is dangerous in some cases. See\n",
        "704": "   * the discussion in the {@link ListenableFuture#addListener ListenableFuture.addListener}\n",
        "705": "   * documentation.\n",
        "706": "   *\n",
        "707": "   * <p>For a more general interface to attach a completion listener to a {@code Future}, see {@link\n",
        "708": "   * ListenableFuture#addListener addListener}.\n",
        "709": "   *\n",
        "710": "   * @param future The future attach the callback to.\n",
        "711": "   * @param callback The callback to invoke when {@code future} is completed.\n",
        "712": "   * @param executor The executor to run {@code callback} when the future completes.\n",
        "713": "   * @since 10.0\n",
        "714": "   */\n",
        "715": "  public static <V> void addCallback(\n",
        "716": "      final ListenableFuture<V> future,\n",
        "717": "      final FutureCallback<? super V> callback,\n",
        "718": "      Executor executor) {\n",
        "719": "    Preconditions.checkNotNull(callback);\n",
        "720": "    Runnable callbackListener =\n",
        "721": "        new Runnable() {\n",
        "722": "          @Override\n",
        "723": "          public void run() {\n",
        "724": "            final V value;\n",
        "725": "            try {\n",
        "726": "              // TODO(user): (Before Guava release), validate that this\n",
        "727": "              // is the thing for IE.\n",
        "728": "              value = getUninterruptibly(future);\n",
        "729": "            } catch (ExecutionException e) {\n",
        "730": "              callback.onFailure(e.getCause());\n",
        "731": "              return;\n",
        "732": "            } catch (RuntimeException e) {\n",
        "733": "              callback.onFailure(e);\n",
        "734": "              return;\n",
        "735": "            } catch (Error e) {\n",
        "736": "              callback.onFailure(e);\n",
        "737": "              return;\n",
        "738": "            }\n",
        "739": "            callback.onSuccess(value);\n",
        "740": "          }\n",
        "741": "        };\n",
        "742": "    future.addListener(callbackListener, executor);\n",
        "743": "  }\n",
        "744": "\n",
        "745": "  /*\n",
        "746": "   * Arguably we don't need a timed getUnchecked because any operation slow enough to require a\n",
        "747": "   * timeout is heavyweight enough to throw a checked exception and therefore be inappropriate to\n",
        "748": "   * use with getUnchecked. Further, it's not clear that converting the checked TimeoutException to\n",
        "749": "   * a RuntimeException -- especially to an UncheckedExecutionException, since it wasn't thrown by\n",
        "750": "   * the computation -- makes sense, and if we don't convert it, the user still has to write a\n",
        "751": "   * try-catch block.\n",
        "752": "   *\n",
        "753": "   * If you think you would use this method, let us know. You might also also look into the\n",
        "754": "   * Fork-Join framework: http://docs.oracle.com/javase/tutorial/essential/concurrency/forkjoin.html\n",
        "755": "   */\n",
        "756": "}\n"
    }
}