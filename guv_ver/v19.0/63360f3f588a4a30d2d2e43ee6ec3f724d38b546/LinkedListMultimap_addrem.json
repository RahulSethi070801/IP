{
    "addition": {},
    "removed": {
        "1": "/*\n",
        "2": " * Copyright (C) 2007 The Guava Authors\n",
        "3": " *\n",
        "4": " * Licensed under the Apache License, Version 2.0 (the \"License\");\n",
        "5": " * you may not use this file except in compliance with the License.\n",
        "6": " * You may obtain a copy of the License at\n",
        "7": " *\n",
        "8": " * http://www.apache.org/licenses/LICENSE-2.0\n",
        "9": " *\n",
        "10": " * Unless required by applicable law or agreed to in writing, software\n",
        "11": " * distributed under the License is distributed on an \"AS IS\" BASIS,\n",
        "12": " * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n",
        "13": " * See the License for the specific language governing permissions and\n",
        "14": " * limitations under the License.\n",
        "15": " */\n",
        "16": "\n",
        "17": "package com.google.common.collect;\n",
        "18": "\n",
        "19": "import static com.google.common.base.Preconditions.checkPositionIndex;\n",
        "20": "import static com.google.common.base.Preconditions.checkState;\n",
        "21": "import static com.google.common.collect.CollectPreconditions.checkRemove;\n",
        "22": "import static java.util.Collections.unmodifiableList;\n",
        "23": "\n",
        "24": "import com.google.common.annotations.GwtCompatible;\n",
        "25": "import com.google.j2objc.annotations.WeakOuter;\n",
        "26": "\n",
        "27": "import java.io.Serializable;\n",
        "28": "import java.util.AbstractSequentialList;\n",
        "29": "import java.util.Collection;\n",
        "30": "import java.util.ConcurrentModificationException;\n",
        "31": "import java.util.HashMap;\n",
        "32": "import java.util.Iterator;\n",
        "33": "import java.util.List;\n",
        "34": "import java.util.ListIterator;\n",
        "35": "import java.util.Map;\n",
        "36": "import java.util.Map.Entry;\n",
        "37": "import java.util.NoSuchElementException;\n",
        "38": "import java.util.Set;\n",
        "39": "\n",
        "40": "import javax.annotation.Nullable;\n",
        "41": "\n",
        "42": "/**\n",
        "43": " * An implementation of {@code ListMultimap} that supports deterministic\n",
        "44": " * iteration order for both keys and values. The iteration order is preserved\n",
        "45": " * across non-distinct key values. For example, for the following multimap\n",
        "46": " * definition: <pre>   {@code\n",
        "47": " *\n",
        "48": " *   Multimap<K, V> multimap = LinkedListMultimap.create();\n",
        "49": " *   multimap.put(key1, foo);\n",
        "50": " *   multimap.put(key2, bar);\n",
        "51": " *   multimap.put(key1, baz);}</pre>\n",
        "52": " *\n",
        "53": " * ... the iteration order for {@link #keys()} is {@code [key1, key2, key1]},\n",
        "54": " * and similarly for {@link #entries()}. Unlike {@link LinkedHashMultimap}, the\n",
        "55": " * iteration order is kept consistent between keys, entries and values. For\n",
        "56": " * example, calling: <pre>   {@code\n",
        "57": " *\n",
        "58": " *   map.remove(key1, foo);}</pre>\n",
        "59": " *\n",
        "60": " * <p>changes the entries iteration order to {@code [key2=bar, key1=baz]} and the\n",
        "61": " * key iteration order to {@code [key2, key1]}. The {@link #entries()} iterator\n",
        "62": " * returns mutable map entries, and {@link #replaceValues} attempts to preserve\n",
        "63": " * iteration order as much as possible.\n",
        "64": " *\n",
        "65": " * <p>The collections returned by {@link #keySet()} and {@link #asMap} iterate\n",
        "66": " * through the keys in the order they were first added to the multimap.\n",
        "67": " * Similarly, {@link #get}, {@link #removeAll}, and {@link #replaceValues}\n",
        "68": " * return collections that iterate through the values in the order they were\n",
        "69": " * added. The collections generated by {@link #entries()}, {@link #keys()}, and\n",
        "70": " * {@link #values} iterate across the key-value mappings in the order they were\n",
        "71": " * added to the multimap.\n",
        "72": " *\n",
        "73": " * <p>The {@link #values()} and {@link #entries()} methods both return a\n",
        "74": " * {@code List}, instead of the {@code Collection} specified by the {@link\n",
        "75": " * ListMultimap} interface.\n",
        "76": " *\n",
        "77": " * <p>The methods {@link #get}, {@link #keySet()}, {@link #keys()},\n",
        "78": " * {@link #values}, {@link #entries()}, and {@link #asMap} return collections\n",
        "79": " * that are views of the multimap. If the multimap is modified while an\n",
        "80": " * iteration over any of those collections is in progress, except through the\n",
        "81": " * iterator's methods, the results of the iteration are undefined.\n",
        "82": " *\n",
        "83": " * <p>Keys and values may be null. All optional multimap methods are supported,\n",
        "84": " * and all returned views are modifiable.\n",
        "85": " *\n",
        "86": " * <p>This class is not threadsafe when any concurrent operations update the\n",
        "87": " * multimap. Concurrent read operations will work correctly. To allow concurrent\n",
        "88": " * update operations, wrap your multimap with a call to {@link\n",
        "89": " * Multimaps#synchronizedListMultimap}.\n",
        "90": " *\n",
        "91": " * <p>See the Guava User Guide article on <a href=\n",
        "92": " * \"https://github.com/google/guava/wiki/NewCollectionTypesExplained#multimap\">\n",
        "93": " * {@code Multimap}</a>.\n",
        "94": " *\n",
        "95": " * @author Mike Bostock\n",
        "96": " * @since 2.0\n",
        "97": " */\n",
        "98": "@GwtCompatible(serializable = true, emulated = true)\n",
        "99": "public class LinkedListMultimap<K, V> extends AbstractMultimap<K, V>\n",
        "100": "    implements ListMultimap<K, V>, Serializable {\n",
        "101": "  /*\n",
        "102": "   * Order is maintained using a linked list containing all key-value pairs. In\n",
        "103": "   * addition, a series of disjoint linked lists of \"siblings\", each containing\n",
        "104": "   * the values for a specific key, is used to implement {@link\n",
        "105": "   * ValueForKeyIterator} in constant time.\n",
        "106": "   */\n",
        "107": "\n",
        "108": "  private static final class Node<K, V> extends AbstractMapEntry<K, V> {\n",
        "109": "    final K key;\n",
        "110": "    V value;\n",
        "111": "    Node<K, V> next; // the next node (with any key)\n",
        "112": "    Node<K, V> previous; // the previous node (with any key)\n",
        "113": "    Node<K, V> nextSibling; // the next node with the same key\n",
        "114": "    Node<K, V> previousSibling; // the previous node with the same key\n",
        "115": "\n",
        "116": "    Node(@Nullable K key, @Nullable V value) {\n",
        "117": "      this.key = key;\n",
        "118": "      this.value = value;\n",
        "119": "    }\n",
        "120": "\n",
        "121": "    @Override\n",
        "122": "    public K getKey() {\n",
        "123": "      return key;\n",
        "124": "    }\n",
        "125": "\n",
        "126": "    @Override\n",
        "127": "    public V getValue() {\n",
        "128": "      return value;\n",
        "129": "    }\n",
        "130": "\n",
        "131": "    @Override\n",
        "132": "    public V setValue(@Nullable V newValue) {\n",
        "133": "      V result = value;\n",
        "134": "      this.value = newValue;\n",
        "135": "      return result;\n",
        "136": "    }\n",
        "137": "  }\n",
        "138": "\n",
        "139": "  private static class KeyList<K, V> {\n",
        "140": "    Node<K, V> head;\n",
        "141": "    Node<K, V> tail;\n",
        "142": "    int count;\n",
        "143": "\n",
        "144": "    KeyList(Node<K, V> firstNode) {\n",
        "145": "      this.head = firstNode;\n",
        "146": "      this.tail = firstNode;\n",
        "147": "      firstNode.previousSibling = null;\n",
        "148": "      firstNode.nextSibling = null;\n",
        "149": "      this.count = 1;\n",
        "150": "    }\n",
        "151": "  }\n",
        "152": "\n",
        "153": "  private transient Node<K, V> head; // the head for all keys\n",
        "154": "  private transient Node<K, V> tail; // the tail for all keys\n",
        "155": "  private transient Map<K, KeyList<K, V>> keyToKeyList;\n",
        "156": "  private transient int size;\n",
        "157": "\n",
        "158": "  /*\n",
        "159": "   * Tracks modifications to keyToKeyList so that addition or removal of keys invalidates\n",
        "160": "   * preexisting iterators. This does *not* track simple additions and removals of values\n",
        "161": "   * that are not the first to be added or last to be removed for their key.\n",
        "162": "   */\n",
        "163": "  private transient int modCount;\n",
        "164": "\n",
        "165": "  /**\n",
        "166": "   * Creates a new, empty {@code LinkedListMultimap} with the default initial\n",
        "167": "   * capacity.\n",
        "168": "   */\n",
        "169": "  public static <K, V> LinkedListMultimap<K, V> create() {\n",
        "170": "    return new LinkedListMultimap<K, V>();\n",
        "171": "  }\n",
        "172": "\n",
        "173": "  /**\n",
        "174": "   * Constructs an empty {@code LinkedListMultimap} with enough capacity to hold\n",
        "175": "   * the specified number of keys without rehashing.\n",
        "176": "   *\n",
        "177": "   * @param expectedKeys the expected number of distinct keys\n",
        "178": "   * @throws IllegalArgumentException if {@code expectedKeys} is negative\n",
        "179": "   */\n",
        "180": "  public static <K, V> LinkedListMultimap<K, V> create(int expectedKeys) {\n",
        "181": "    return new LinkedListMultimap<K, V>(expectedKeys);\n",
        "182": "  }\n",
        "183": "\n",
        "184": "  /**\n",
        "185": "   * Constructs a {@code LinkedListMultimap} with the same mappings as the\n",
        "186": "   * specified {@code Multimap}. The new multimap has the same\n",
        "187": "   * {@link Multimap#entries()} iteration order as the input multimap.\n",
        "188": "   *\n",
        "189": "   * @param multimap the multimap whose contents are copied to this multimap\n",
        "190": "   */\n",
        "191": "  public static <K, V> LinkedListMultimap<K, V> create(\n",
        "192": "      Multimap<? extends K, ? extends V> multimap) {\n",
        "193": "    return new LinkedListMultimap<K, V>(multimap);\n",
        "194": "  }\n",
        "195": "\n",
        "196": "  LinkedListMultimap() {\n",
        "197": "    keyToKeyList = Maps.newHashMap();\n",
        "198": "  }\n",
        "199": "\n",
        "200": "  private LinkedListMultimap(int expectedKeys) {\n",
        "201": "    keyToKeyList = new HashMap<K, KeyList<K, V>>(expectedKeys);\n",
        "202": "  }\n",
        "203": "\n",
        "204": "  private LinkedListMultimap(Multimap<? extends K, ? extends V> multimap) {\n",
        "205": "    this(multimap.keySet().size());\n",
        "206": "    putAll(multimap);\n",
        "207": "  }\n",
        "208": "\n",
        "209": "  /**\n",
        "210": "   * Adds a new node for the specified key-value pair before the specified\n",
        "211": "   * {@code nextSibling} element, or at the end of the list if {@code\n",
        "212": "   * nextSibling} is null. Note: if {@code nextSibling} is specified, it MUST be\n",
        "213": "   * for an node for the same {@code key}!\n",
        "214": "   */\n",
        "215": "  private Node<K, V> addNode(@Nullable K key, @Nullable V value, @Nullable Node<K, V> nextSibling) {\n",
        "216": "    Node<K, V> node = new Node<K, V>(key, value);\n",
        "217": "    if (head == null) { // empty list\n",
        "218": "      head = tail = node;\n",
        "219": "      keyToKeyList.put(key, new KeyList<K, V>(node));\n",
        "220": "      modCount++;\n",
        "221": "    } else if (nextSibling == null) { // non-empty list, add to tail\n",
        "222": "      tail.next = node;\n",
        "223": "      node.previous = tail;\n",
        "224": "      tail = node;\n",
        "225": "      KeyList<K, V> keyList = keyToKeyList.get(key);\n",
        "226": "      if (keyList == null) {\n",
        "227": "        keyToKeyList.put(key, keyList = new KeyList<K, V>(node));\n",
        "228": "        modCount++;\n",
        "229": "      } else {\n",
        "230": "        keyList.count++;\n",
        "231": "        Node<K, V> keyTail = keyList.tail;\n",
        "232": "        keyTail.nextSibling = node;\n",
        "233": "        node.previousSibling = keyTail;\n",
        "234": "        keyList.tail = node;\n",
        "235": "      }\n",
        "236": "    } else { // non-empty list, insert before nextSibling\n",
        "237": "      KeyList<K, V> keyList = keyToKeyList.get(key);\n",
        "238": "      keyList.count++;\n",
        "239": "      node.previous = nextSibling.previous;\n",
        "240": "      node.previousSibling = nextSibling.previousSibling;\n",
        "241": "      node.next = nextSibling;\n",
        "242": "      node.nextSibling = nextSibling;\n",
        "243": "      if (nextSibling.previousSibling == null) { // nextSibling was key head\n",
        "244": "        keyToKeyList.get(key).head = node;\n",
        "245": "      } else {\n",
        "246": "        nextSibling.previousSibling.nextSibling = node;\n",
        "247": "      }\n",
        "248": "      if (nextSibling.previous == null) { // nextSibling was head\n",
        "249": "        head = node;\n",
        "250": "      } else {\n",
        "251": "        nextSibling.previous.next = node;\n",
        "252": "      }\n",
        "253": "      nextSibling.previous = node;\n",
        "254": "      nextSibling.previousSibling = node;\n",
        "255": "    }\n",
        "256": "    size++;\n",
        "257": "    return node;\n",
        "258": "  }\n",
        "259": "\n",
        "260": "  /**\n",
        "261": "   * Removes the specified node from the linked list. This method is only\n",
        "262": "   * intended to be used from the {@code Iterator} classes. See also {@link\n",
        "263": "   * LinkedListMultimap#removeAllNodes(Object)}.\n",
        "264": "   */\n",
        "265": "  private void removeNode(Node<K, V> node) {\n",
        "266": "    if (node.previous != null) {\n",
        "267": "      node.previous.next = node.next;\n",
        "268": "    } else { // node was head\n",
        "269": "      head = node.next;\n",
        "270": "    }\n",
        "271": "    if (node.next != null) {\n",
        "272": "      node.next.previous = node.previous;\n",
        "273": "    } else { // node was tail\n",
        "274": "      tail = node.previous;\n",
        "275": "    }\n",
        "276": "    if (node.previousSibling == null && node.nextSibling == null) {\n",
        "277": "      KeyList<K, V> keyList = keyToKeyList.remove(node.key);\n",
        "278": "      keyList.count = 0;\n",
        "279": "      modCount++;\n",
        "280": "    } else {\n",
        "281": "      KeyList<K, V> keyList = keyToKeyList.get(node.key);\n",
        "282": "      keyList.count--;\n",
        "283": "\n",
        "284": "      if (node.previousSibling == null) {\n",
        "285": "        keyList.head = node.nextSibling;\n",
        "286": "      } else {\n",
        "287": "        node.previousSibling.nextSibling = node.nextSibling;\n",
        "288": "      }\n",
        "289": "\n",
        "290": "      if (node.nextSibling == null) {\n",
        "291": "        keyList.tail = node.previousSibling;\n",
        "292": "      } else {\n",
        "293": "        node.nextSibling.previousSibling = node.previousSibling;\n",
        "294": "      }\n",
        "295": "    }\n",
        "296": "    size--;\n",
        "297": "  }\n",
        "298": "\n",
        "299": "  /** Removes all nodes for the specified key. */\n",
        "300": "  private void removeAllNodes(@Nullable Object key) {\n",
        "301": "    Iterators.clear(new ValueForKeyIterator(key));\n",
        "302": "  }\n",
        "303": "\n",
        "304": "  /** Helper method for verifying that an iterator element is present. */\n",
        "305": "  private static void checkElement(@Nullable Object node) {\n",
        "306": "    if (node == null) {\n",
        "307": "      throw new NoSuchElementException();\n",
        "308": "    }\n",
        "309": "  }\n",
        "310": "\n",
        "311": "  /** An {@code Iterator} over all nodes. */\n",
        "312": "  private class NodeIterator implements ListIterator<Entry<K, V>> {\n",
        "313": "    int nextIndex;\n",
        "314": "    Node<K, V> next;\n",
        "315": "    Node<K, V> current;\n",
        "316": "    Node<K, V> previous;\n",
        "317": "    int expectedModCount = modCount;\n",
        "318": "\n",
        "319": "    NodeIterator(int index) {\n",
        "320": "      int size = size();\n",
        "321": "      checkPositionIndex(index, size);\n",
        "322": "      if (index >= (size / 2)) {\n",
        "323": "        previous = tail;\n",
        "324": "        nextIndex = size;\n",
        "325": "        while (index++ < size) {\n",
        "326": "          previous();\n",
        "327": "        }\n",
        "328": "      } else {\n",
        "329": "        next = head;\n",
        "330": "        while (index-- > 0) {\n",
        "331": "          next();\n",
        "332": "        }\n",
        "333": "      }\n",
        "334": "      current = null;\n",
        "335": "    }\n",
        "336": "\n",
        "337": "    private void checkForConcurrentModification() {\n",
        "338": "      if (modCount != expectedModCount) {\n",
        "339": "        throw new ConcurrentModificationException();\n",
        "340": "      }\n",
        "341": "    }\n",
        "342": "\n",
        "343": "    @Override\n",
        "344": "    public boolean hasNext() {\n",
        "345": "      checkForConcurrentModification();\n",
        "346": "      return next != null;\n",
        "347": "    }\n",
        "348": "\n",
        "349": "    @Override\n",
        "350": "    public Node<K, V> next() {\n",
        "351": "      checkForConcurrentModification();\n",
        "352": "      checkElement(next);\n",
        "353": "      previous = current = next;\n",
        "354": "      next = next.next;\n",
        "355": "      nextIndex++;\n",
        "356": "      return current;\n",
        "357": "    }\n",
        "358": "\n",
        "359": "    @Override\n",
        "360": "    public void remove() {\n",
        "361": "      checkForConcurrentModification();\n",
        "362": "      checkRemove(current != null);\n",
        "363": "      if (current != next) { // after call to next()\n",
        "364": "        previous = current.previous;\n",
        "365": "        nextIndex--;\n",
        "366": "      } else { // after call to previous()\n",
        "367": "        next = current.next;\n",
        "368": "      }\n",
        "369": "      removeNode(current);\n",
        "370": "      current = null;\n",
        "371": "      expectedModCount = modCount;\n",
        "372": "    }\n",
        "373": "\n",
        "374": "    @Override\n",
        "375": "    public boolean hasPrevious() {\n",
        "376": "      checkForConcurrentModification();\n",
        "377": "      return previous != null;\n",
        "378": "    }\n",
        "379": "\n",
        "380": "    @Override\n",
        "381": "    public Node<K, V> previous() {\n",
        "382": "      checkForConcurrentModification();\n",
        "383": "      checkElement(previous);\n",
        "384": "      next = current = previous;\n",
        "385": "      previous = previous.previous;\n",
        "386": "      nextIndex--;\n",
        "387": "      return current;\n",
        "388": "    }\n",
        "389": "\n",
        "390": "    @Override\n",
        "391": "    public int nextIndex() {\n",
        "392": "      return nextIndex;\n",
        "393": "    }\n",
        "394": "\n",
        "395": "    @Override\n",
        "396": "    public int previousIndex() {\n",
        "397": "      return nextIndex - 1;\n",
        "398": "    }\n",
        "399": "\n",
        "400": "    @Override\n",
        "401": "    public void set(Entry<K, V> e) {\n",
        "402": "      throw new UnsupportedOperationException();\n",
        "403": "    }\n",
        "404": "\n",
        "405": "    @Override\n",
        "406": "    public void add(Entry<K, V> e) {\n",
        "407": "      throw new UnsupportedOperationException();\n",
        "408": "    }\n",
        "409": "\n",
        "410": "    void setValue(V value) {\n",
        "411": "      checkState(current != null);\n",
        "412": "      current.value = value;\n",
        "413": "    }\n",
        "414": "  }\n",
        "415": "\n",
        "416": "  /** An {@code Iterator} over distinct keys in key head order. */\n",
        "417": "  private class DistinctKeyIterator implements Iterator<K> {\n",
        "418": "    final Set<K> seenKeys = Sets.<K>newHashSetWithExpectedSize(keySet().size());\n",
        "419": "    Node<K, V> next = head;\n",
        "420": "    Node<K, V> current;\n",
        "421": "    int expectedModCount = modCount;\n",
        "422": "\n",
        "423": "    private void checkForConcurrentModification() {\n",
        "424": "      if (modCount != expectedModCount) {\n",
        "425": "        throw new ConcurrentModificationException();\n",
        "426": "      }\n",
        "427": "    }\n",
        "428": "\n",
        "429": "    @Override\n",
        "430": "    public boolean hasNext() {\n",
        "431": "      checkForConcurrentModification();\n",
        "432": "      return next != null;\n",
        "433": "    }\n",
        "434": "\n",
        "435": "    @Override\n",
        "436": "    public K next() {\n",
        "437": "      checkForConcurrentModification();\n",
        "438": "      checkElement(next);\n",
        "439": "      current = next;\n",
        "440": "      seenKeys.add(current.key);\n",
        "441": "      do { // skip ahead to next unseen key\n",
        "442": "        next = next.next;\n",
        "443": "      } while ((next != null) && !seenKeys.add(next.key));\n",
        "444": "      return current.key;\n",
        "445": "    }\n",
        "446": "\n",
        "447": "    @Override\n",
        "448": "    public void remove() {\n",
        "449": "      checkForConcurrentModification();\n",
        "450": "      checkRemove(current != null);\n",
        "451": "      removeAllNodes(current.key);\n",
        "452": "      current = null;\n",
        "453": "      expectedModCount = modCount;\n",
        "454": "    }\n",
        "455": "  }\n",
        "456": "\n",
        "457": "  /** A {@code ListIterator} over values for a specified key. */\n",
        "458": "  private class ValueForKeyIterator implements ListIterator<V> {\n",
        "459": "    final Object key;\n",
        "460": "    int nextIndex;\n",
        "461": "    Node<K, V> next;\n",
        "462": "    Node<K, V> current;\n",
        "463": "    Node<K, V> previous;\n",
        "464": "\n",
        "465": "    /** Constructs a new iterator over all values for the specified key. */\n",
        "466": "    ValueForKeyIterator(@Nullable Object key) {\n",
        "467": "      this.key = key;\n",
        "468": "      KeyList<K, V> keyList = keyToKeyList.get(key);\n",
        "469": "      next = (keyList == null) ? null : keyList.head;\n",
        "470": "    }\n",
        "471": "\n",
        "472": "    /**\n",
        "473": "     * Constructs a new iterator over all values for the specified key starting\n",
        "474": "     * at the specified index. This constructor is optimized so that it starts\n",
        "475": "     * at either the head or the tail, depending on which is closer to the\n",
        "476": "     * specified index. This allows adds to the tail to be done in constant\n",
        "477": "     * time.\n",
        "478": "     *\n",
        "479": "     * @throws IndexOutOfBoundsException if index is invalid\n",
        "480": "     */\n",
        "481": "    public ValueForKeyIterator(@Nullable Object key, int index) {\n",
        "482": "      KeyList<K, V> keyList = keyToKeyList.get(key);\n",
        "483": "      int size = (keyList == null) ? 0 : keyList.count;\n",
        "484": "      checkPositionIndex(index, size);\n",
        "485": "      if (index >= (size / 2)) {\n",
        "486": "        previous = (keyList == null) ? null : keyList.tail;\n",
        "487": "        nextIndex = size;\n",
        "488": "        while (index++ < size) {\n",
        "489": "          previous();\n",
        "490": "        }\n",
        "491": "      } else {\n",
        "492": "        next = (keyList == null) ? null : keyList.head;\n",
        "493": "        while (index-- > 0) {\n",
        "494": "          next();\n",
        "495": "        }\n",
        "496": "      }\n",
        "497": "      this.key = key;\n",
        "498": "      current = null;\n",
        "499": "    }\n",
        "500": "\n",
        "501": "    @Override\n",
        "502": "    public boolean hasNext() {\n",
        "503": "      return next != null;\n",
        "504": "    }\n",
        "505": "\n",
        "506": "    @Override\n",
        "507": "    public V next() {\n",
        "508": "      checkElement(next);\n",
        "509": "      previous = current = next;\n",
        "510": "      next = next.nextSibling;\n",
        "511": "      nextIndex++;\n",
        "512": "      return current.value;\n",
        "513": "    }\n",
        "514": "\n",
        "515": "    @Override\n",
        "516": "    public boolean hasPrevious() {\n",
        "517": "      return previous != null;\n",
        "518": "    }\n",
        "519": "\n",
        "520": "    @Override\n",
        "521": "    public V previous() {\n",
        "522": "      checkElement(previous);\n",
        "523": "      next = current = previous;\n",
        "524": "      previous = previous.previousSibling;\n",
        "525": "      nextIndex--;\n",
        "526": "      return current.value;\n",
        "527": "    }\n",
        "528": "\n",
        "529": "    @Override\n",
        "530": "    public int nextIndex() {\n",
        "531": "      return nextIndex;\n",
        "532": "    }\n",
        "533": "\n",
        "534": "    @Override\n",
        "535": "    public int previousIndex() {\n",
        "536": "      return nextIndex - 1;\n",
        "537": "    }\n",
        "538": "\n",
        "539": "    @Override\n",
        "540": "    public void remove() {\n",
        "541": "      checkRemove(current != null);\n",
        "542": "      if (current != next) { // after call to next()\n",
        "543": "        previous = current.previousSibling;\n",
        "544": "        nextIndex--;\n",
        "545": "      } else { // after call to previous()\n",
        "546": "        next = current.nextSibling;\n",
        "547": "      }\n",
        "548": "      removeNode(current);\n",
        "549": "      current = null;\n",
        "550": "    }\n",
        "551": "\n",
        "552": "    @Override\n",
        "553": "    public void set(V value) {\n",
        "554": "      checkState(current != null);\n",
        "555": "      current.value = value;\n",
        "556": "    }\n",
        "557": "\n",
        "558": "    @Override\n",
        "559": "    @SuppressWarnings(\"unchecked\")\n",
        "560": "    public void add(V value) {\n",
        "561": "      previous = addNode((K) key, value, next);\n",
        "562": "      nextIndex++;\n",
        "563": "      current = null;\n",
        "564": "    }\n",
        "565": "  }\n",
        "566": "\n",
        "567": "  // Query Operations\n",
        "568": "\n",
        "569": "  @Override\n",
        "570": "  public int size() {\n",
        "571": "    return size;\n",
        "572": "  }\n",
        "573": "\n",
        "574": "  @Override\n",
        "575": "  public boolean isEmpty() {\n",
        "576": "    return head == null;\n",
        "577": "  }\n",
        "578": "\n",
        "579": "  @Override\n",
        "580": "  public boolean containsKey(@Nullable Object key) {\n",
        "581": "    return keyToKeyList.containsKey(key);\n",
        "582": "  }\n",
        "583": "\n",
        "584": "  @Override\n",
        "585": "  public boolean containsValue(@Nullable Object value) {\n",
        "586": "    return values().contains(value);\n",
        "587": "  }\n",
        "588": "\n",
        "589": "  // Modification Operations\n",
        "590": "\n",
        "591": "  /**\n",
        "592": "   * Stores a key-value pair in the multimap.\n",
        "593": "   *\n",
        "594": "   * @param key key to store in the multimap\n",
        "595": "   * @param value value to store in the multimap\n",
        "596": "   * @return {@code true} always\n",
        "597": "   */\n",
        "598": "  @Override\n",
        "599": "  public boolean put(@Nullable K key, @Nullable V value) {\n",
        "600": "    addNode(key, value, null);\n",
        "601": "    return true;\n",
        "602": "  }\n",
        "603": "\n",
        "604": "  // Bulk Operations\n",
        "605": "\n",
        "606": "  /**\n",
        "607": "   * {@inheritDoc}\n",
        "608": "   *\n",
        "609": "   * <p>If any entries for the specified {@code key} already exist in the\n",
        "610": "   * multimap, their values are changed in-place without affecting the iteration\n",
        "611": "   * order.\n",
        "612": "   *\n",
        "613": "   * <p>The returned list is immutable and implements\n",
        "614": "   * {@link java.util.RandomAccess}.\n",
        "615": "   */\n",
        "616": "  @Override\n",
        "617": "  public List<V> replaceValues(@Nullable K key, Iterable<? extends V> values) {\n",
        "618": "    List<V> oldValues = getCopy(key);\n",
        "619": "    ListIterator<V> keyValues = new ValueForKeyIterator(key);\n",
        "620": "    Iterator<? extends V> newValues = values.iterator();\n",
        "621": "\n",
        "622": "    // Replace existing values, if any.\n",
        "623": "    while (keyValues.hasNext() && newValues.hasNext()) {\n",
        "624": "      keyValues.next();\n",
        "625": "      keyValues.set(newValues.next());\n",
        "626": "    }\n",
        "627": "\n",
        "628": "    // Remove remaining old values, if any.\n",
        "629": "    while (keyValues.hasNext()) {\n",
        "630": "      keyValues.next();\n",
        "631": "      keyValues.remove();\n",
        "632": "    }\n",
        "633": "\n",
        "634": "    // Add remaining new values, if any.\n",
        "635": "    while (newValues.hasNext()) {\n",
        "636": "      keyValues.add(newValues.next());\n",
        "637": "    }\n",
        "638": "\n",
        "639": "    return oldValues;\n",
        "640": "  }\n",
        "641": "\n",
        "642": "  private List<V> getCopy(@Nullable Object key) {\n",
        "643": "    return unmodifiableList(Lists.newArrayList(new ValueForKeyIterator(key)));\n",
        "644": "  }\n",
        "645": "\n",
        "646": "  /**\n",
        "647": "   * {@inheritDoc}\n",
        "648": "   *\n",
        "649": "   * <p>The returned list is immutable and implements\n",
        "650": "   * {@link java.util.RandomAccess}.\n",
        "651": "   */\n",
        "652": "  @Override\n",
        "653": "  public List<V> removeAll(@Nullable Object key) {\n",
        "654": "    List<V> oldValues = getCopy(key);\n",
        "655": "    removeAllNodes(key);\n",
        "656": "    return oldValues;\n",
        "657": "  }\n",
        "658": "\n",
        "659": "  @Override\n",
        "660": "  public void clear() {\n",
        "661": "    head = null;\n",
        "662": "    tail = null;\n",
        "663": "    keyToKeyList.clear();\n",
        "664": "    size = 0;\n",
        "665": "    modCount++;\n",
        "666": "  }\n",
        "667": "\n",
        "668": "  // Views\n",
        "669": "\n",
        "670": "  /**\n",
        "671": "   * {@inheritDoc}\n",
        "672": "   *\n",
        "673": "   * <p>If the multimap is modified while an iteration over the list is in\n",
        "674": "   * progress (except through the iterator's own {@code add}, {@code set} or\n",
        "675": "   * {@code remove} operations) the results of the iteration are undefined.\n",
        "676": "   *\n",
        "677": "   * <p>The returned list is not serializable and does not have random access.\n",
        "678": "   */\n",
        "679": "  @Override\n",
        "680": "  public List<V> get(final @Nullable K key) {\n",
        "681": "    return new AbstractSequentialList<V>() {\n",
        "682": "      @Override\n",
        "683": "      public int size() {\n",
        "684": "        KeyList<K, V> keyList = keyToKeyList.get(key);\n",
        "685": "        return (keyList == null) ? 0 : keyList.count;\n",
        "686": "      }\n",
        "687": "\n",
        "688": "      @Override\n",
        "689": "      public ListIterator<V> listIterator(int index) {\n",
        "690": "        return new ValueForKeyIterator(key, index);\n",
        "691": "      }\n",
        "692": "    };\n",
        "693": "  }\n",
        "694": "\n",
        "695": "  @Override\n",
        "696": "  Set<K> createKeySet() {\n",
        "697": "    @WeakOuter\n",
        "698": "    class KeySetImpl extends Sets.ImprovedAbstractSet<K> {\n",
        "699": "      @Override\n",
        "700": "      public int size() {\n",
        "701": "        return keyToKeyList.size();\n",
        "702": "      }\n",
        "703": "\n",
        "704": "      @Override\n",
        "705": "      public Iterator<K> iterator() {\n",
        "706": "        return new DistinctKeyIterator();\n",
        "707": "      }\n",
        "708": "\n",
        "709": "      @Override\n",
        "710": "      public boolean contains(Object key) { // for performance\n",
        "711": "        return containsKey(key);\n",
        "712": "      }\n",
        "713": "\n",
        "714": "      @Override\n",
        "715": "      public boolean remove(Object o) { // for performance\n",
        "716": "        return !LinkedListMultimap.this.removeAll(o).isEmpty();\n",
        "717": "      }\n",
        "718": "    }\n",
        "719": "    return new KeySetImpl();\n",
        "720": "  }\n",
        "721": "\n",
        "722": "  /**\n",
        "723": "   * {@inheritDoc}\n",
        "724": "   *\n",
        "725": "   * <p>The iterator generated by the returned collection traverses the values\n",
        "726": "   * in the order they were added to the multimap. Because the values may have\n",
        "727": "   * duplicates and follow the insertion ordering, this method returns a {@link\n",
        "728": "   * List}, instead of the {@link Collection} specified in the {@link\n",
        "729": "   * ListMultimap} interface.\n",
        "730": "   */\n",
        "731": "  @Override\n",
        "732": "  public List<V> values() {\n",
        "733": "    return (List<V>) super.values();\n",
        "734": "  }\n",
        "735": "\n",
        "736": "  @Override\n",
        "737": "  List<V> createValues() {\n",
        "738": "    @WeakOuter\n",
        "739": "    class ValuesImpl extends AbstractSequentialList<V> {\n",
        "740": "      @Override\n",
        "741": "      public int size() {\n",
        "742": "        return size;\n",
        "743": "      }\n",
        "744": "\n",
        "745": "      @Override\n",
        "746": "      public ListIterator<V> listIterator(int index) {\n",
        "747": "        final NodeIterator nodeItr = new NodeIterator(index);\n",
        "748": "        return new TransformedListIterator<Entry<K, V>, V>(nodeItr) {\n",
        "749": "          @Override\n",
        "750": "          V transform(Entry<K, V> entry) {\n",
        "751": "            return entry.getValue();\n",
        "752": "          }\n",
        "753": "\n",
        "754": "          @Override\n",
        "755": "          public void set(V value) {\n",
        "756": "            nodeItr.setValue(value);\n",
        "757": "          }\n",
        "758": "        };\n",
        "759": "      }\n",
        "760": "    }\n",
        "761": "    return new ValuesImpl();\n",
        "762": "  }\n",
        "763": "\n",
        "764": "  /**\n",
        "765": "   * {@inheritDoc}\n",
        "766": "   *\n",
        "767": "   * <p>The iterator generated by the returned collection traverses the entries\n",
        "768": "   * in the order they were added to the multimap. Because the entries may have\n",
        "769": "   * duplicates and follow the insertion ordering, this method returns a {@link\n",
        "770": "   * List}, instead of the {@link Collection} specified in the {@link\n",
        "771": "   * ListMultimap} interface.\n",
        "772": "   *\n",
        "773": "   * <p>An entry's {@link Entry#getKey} method always returns the same key,\n",
        "774": "   * regardless of what happens subsequently. As long as the corresponding\n",
        "775": "   * key-value mapping is not removed from the multimap, {@link Entry#getValue}\n",
        "776": "   * returns the value from the multimap, which may change over time, and {@link\n",
        "777": "   * Entry#setValue} modifies that value. Removing the mapping from the\n",
        "778": "   * multimap does not alter the value returned by {@code getValue()}, though a\n",
        "779": "   * subsequent {@code setValue()} call won't update the multimap but will lead\n",
        "780": "   * to a revised value being returned by {@code getValue()}.\n",
        "781": "   */\n",
        "782": "  @Override\n",
        "783": "  public List<Entry<K, V>> entries() {\n",
        "784": "    return (List<Entry<K, V>>) super.entries();\n",
        "785": "  }\n",
        "786": "\n",
        "787": "  @Override\n",
        "788": "  List<Entry<K, V>> createEntries() {\n",
        "789": "    @WeakOuter\n",
        "790": "    class EntriesImpl extends AbstractSequentialList<Entry<K, V>> {\n",
        "791": "      @Override\n",
        "792": "      public int size() {\n",
        "793": "        return size;\n",
        "794": "      }\n",
        "795": "\n",
        "796": "      @Override\n",
        "797": "      public ListIterator<Entry<K, V>> listIterator(int index) {\n",
        "798": "        return new NodeIterator(index);\n",
        "799": "      }\n",
        "800": "    }\n",
        "801": "    return new EntriesImpl();\n",
        "802": "  }\n",
        "803": "\n",
        "804": "  @Override\n",
        "805": "  Iterator<Entry<K, V>> entryIterator() {\n",
        "806": "    throw new AssertionError(\"should never be called\");\n",
        "807": "  }\n",
        "808": "\n",
        "809": "  @Override\n",
        "810": "  Map<K, Collection<V>> createAsMap() {\n",
        "811": "    return new Multimaps.AsMap<K, V>(this);\n",
        "812": "  }\n",
        "813": "}\n",
        "814": "\n"
    }
}