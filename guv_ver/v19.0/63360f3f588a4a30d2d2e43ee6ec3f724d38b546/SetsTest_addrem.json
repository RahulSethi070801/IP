{
    "addition": {},
    "removed": {
        "1": "/*\n",
        "2": " * Copyright (C) 2007 The Guava Authors\n",
        "3": " *\n",
        "4": " * Licensed under the Apache License, Version 2.0 (the \"License\");\n",
        "5": " * you may not use this file except in compliance with the License.\n",
        "6": " * You may obtain a copy of the License at\n",
        "7": " *\n",
        "8": " * http://www.apache.org/licenses/LICENSE-2.0\n",
        "9": " *\n",
        "10": " * Unless required by applicable law or agreed to in writing, software\n",
        "11": " * distributed under the License is distributed on an \"AS IS\" BASIS,\n",
        "12": " * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n",
        "13": " * See the License for the specific language governing permissions and\n",
        "14": " * limitations under the License.\n",
        "15": " */\n",
        "16": "\n",
        "17": "package com.google.common.collect;\n",
        "18": "\n",
        "19": "import static com.google.common.collect.Iterables.unmodifiableIterable;\n",
        "20": "import static com.google.common.collect.Sets.newEnumSet;\n",
        "21": "import static com.google.common.collect.Sets.newHashSet;\n",
        "22": "import static com.google.common.collect.Sets.newLinkedHashSet;\n",
        "23": "import static com.google.common.collect.Sets.powerSet;\n",
        "24": "import static com.google.common.collect.testing.IteratorFeature.UNMODIFIABLE;\n",
        "25": "import static com.google.common.truth.Truth.assertThat;\n",
        "26": "import static java.util.Collections.emptySet;\n",
        "27": "import static java.util.Collections.singleton;\n",
        "28": "\n",
        "29": "import com.google.common.annotations.GwtCompatible;\n",
        "30": "import com.google.common.collect.testing.IteratorTester;\n",
        "31": "import com.google.common.collect.testing.MinimalIterable;\n",
        "32": "import com.google.common.testing.EqualsTester;\n",
        "33": "\n",
        "34": "import junit.framework.TestCase;\n",
        "35": "\n",
        "36": "import java.io.Serializable;\n",
        "37": "import java.util.ArrayList;\n",
        "38": "import java.util.Arrays;\n",
        "39": "import java.util.Collection;\n",
        "40": "import java.util.Collections;\n",
        "41": "import java.util.Comparator;\n",
        "42": "import java.util.EnumSet;\n",
        "43": "import java.util.HashMap;\n",
        "44": "import java.util.HashSet;\n",
        "45": "import java.util.Iterator;\n",
        "46": "import java.util.LinkedHashMap;\n",
        "47": "import java.util.LinkedHashSet;\n",
        "48": "import java.util.List;\n",
        "49": "import java.util.Map;\n",
        "50": "import java.util.NoSuchElementException;\n",
        "51": "import java.util.Set;\n",
        "52": "import java.util.SortedSet;\n",
        "53": "import java.util.TreeSet;\n",
        "54": "\n",
        "55": "import javax.annotation.Nullable;\n",
        "56": "\n",
        "57": "/**\n",
        "58": " * Unit test for {@code Sets}.\n",
        "59": " *\n",
        "60": " * @author Kevin Bourrillion\n",
        "61": " * @author Jared Levy\n",
        "62": " */\n",
        "63": "@GwtCompatible(emulated = true)\n",
        "64": "public class SetsTest extends TestCase {\n",
        "65": "\n",
        "66": "  private static final IteratorTester.KnownOrder KNOWN_ORDER =\n",
        "67": "      IteratorTester.KnownOrder.KNOWN_ORDER;\n",
        "68": "\n",
        "69": "  private static final Collection<Integer> EMPTY_COLLECTION\n",
        "70": "      = Arrays.<Integer>asList();\n",
        "71": "\n",
        "72": "  private static final Collection<Integer> SOME_COLLECTION\n",
        "73": "      = Arrays.asList(0, 1, 1);\n",
        "74": "\n",
        "75": "  private static final Iterable<Integer> SOME_ITERABLE\n",
        "76": "      = new Iterable<Integer>() {\n",
        "77": "        @Override\n",
        "78": "        public Iterator<Integer> iterator() {\n",
        "79": "          return SOME_COLLECTION.iterator();\n",
        "80": "        }\n",
        "81": "      };\n",
        "82": "\n",
        "83": "  private static final List<Integer> LONGER_LIST\n",
        "84": "      = Arrays.asList(8, 6, 7, 5, 3, 0, 9);\n",
        "85": "\n",
        "86": "  private static final Comparator<Integer> SOME_COMPARATOR\n",
        "87": "      = Collections.reverseOrder();\n",
        "88": "\n",
        "89": "  private enum SomeEnum { A, B, C, D }\n",
        "90": "\n",
        "91": "  public void testImmutableEnumSet() {\n",
        "92": "    Set<SomeEnum> units = Sets.immutableEnumSet(SomeEnum.D, SomeEnum.B);\n",
        "93": "\n",
        "94": "    assertThat(units).containsExactly(SomeEnum.B, SomeEnum.D).inOrder();\n",
        "95": "    try {\n",
        "96": "      units.remove(SomeEnum.B);\n",
        "97": "      fail(\"ImmutableEnumSet should throw an exception on remove()\");\n",
        "98": "    } catch (UnsupportedOperationException expected) {}\n",
        "99": "    try {\n",
        "100": "      units.add(SomeEnum.C);\n",
        "101": "      fail(\"ImmutableEnumSet should throw an exception on add()\");\n",
        "102": "    } catch (UnsupportedOperationException expected) {}\n",
        "103": "  }\n",
        "104": "\n",
        "105": "  public void testImmutableEnumSet_fromIterable() {\n",
        "106": "    ImmutableSet<SomeEnum> none\n",
        "107": "        = Sets.immutableEnumSet(MinimalIterable.<SomeEnum>of());\n",
        "108": "    assertThat(none).isEmpty();\n",
        "109": "\n",
        "110": "    ImmutableSet<SomeEnum> one\n",
        "111": "        = Sets.immutableEnumSet(MinimalIterable.of(SomeEnum.B));\n",
        "112": "    assertThat(one).contains(SomeEnum.B);\n",
        "113": "\n",
        "114": "    ImmutableSet<SomeEnum> two = Sets.immutableEnumSet(MinimalIterable.of(SomeEnum.D, SomeEnum.B));\n",
        "115": "    assertThat(two).containsExactly(SomeEnum.B, SomeEnum.D).inOrder();\n",
        "116": "  }\n",
        "117": "\n",
        "118": "  private static byte[] prepended(byte b, byte[] array) {\n",
        "119": "    byte[] out = new byte[array.length + 1];\n",
        "120": "    out[0] = b;\n",
        "121": "    System.arraycopy(array, 0, out, 1, array.length);\n",
        "122": "    return out;\n",
        "123": "  }\n",
        "124": "\n",
        "125": "  public void testNewEnumSet_empty() {\n",
        "126": "    EnumSet<SomeEnum> copy =\n",
        "127": "        newEnumSet(Collections.<SomeEnum>emptySet(), SomeEnum.class);\n",
        "128": "    assertEquals(EnumSet.noneOf(SomeEnum.class), copy);\n",
        "129": "  }\n",
        "130": "\n",
        "131": "  public void testNewEnumSet_enumSet() {\n",
        "132": "    EnumSet<SomeEnum> set = EnumSet.of(SomeEnum.A, SomeEnum.D);\n",
        "133": "    assertEquals(set, newEnumSet(set, SomeEnum.class));\n",
        "134": "  }\n",
        "135": "\n",
        "136": "  public void testNewEnumSet_collection() {\n",
        "137": "    Set<SomeEnum> set = ImmutableSet.of(SomeEnum.B, SomeEnum.C);\n",
        "138": "    assertEquals(set, newEnumSet(set, SomeEnum.class));\n",
        "139": "  }\n",
        "140": "\n",
        "141": "  public void testNewEnumSet_iterable() {\n",
        "142": "    Set<SomeEnum> set = ImmutableSet.of(SomeEnum.A, SomeEnum.B, SomeEnum.C);\n",
        "143": "    assertEquals(set, newEnumSet(unmodifiableIterable(set), SomeEnum.class));\n",
        "144": "  }\n",
        "145": "\n",
        "146": "  public void testNewHashSetEmpty() {\n",
        "147": "    HashSet<Integer> set = Sets.newHashSet();\n",
        "148": "    verifySetContents(set, EMPTY_COLLECTION);\n",
        "149": "  }\n",
        "150": "\n",
        "151": "  public void testNewHashSetVarArgs() {\n",
        "152": "    HashSet<Integer> set = Sets.newHashSet(0, 1, 1);\n",
        "153": "    verifySetContents(set, Arrays.asList(0, 1));\n",
        "154": "  }\n",
        "155": "\n",
        "156": "  public void testNewHashSetFromCollection() {\n",
        "157": "    HashSet<Integer> set = Sets.newHashSet(SOME_COLLECTION);\n",
        "158": "    verifySetContents(set, SOME_COLLECTION);\n",
        "159": "  }\n",
        "160": "\n",
        "161": "  public void testNewHashSetFromIterable() {\n",
        "162": "    HashSet<Integer> set = Sets.newHashSet(SOME_ITERABLE);\n",
        "163": "    verifySetContents(set, SOME_ITERABLE);\n",
        "164": "  }\n",
        "165": "\n",
        "166": "  public void testNewHashSetWithExpectedSizeSmall() {\n",
        "167": "    HashSet<Integer> set = Sets.newHashSetWithExpectedSize(0);\n",
        "168": "    verifySetContents(set, EMPTY_COLLECTION);\n",
        "169": "  }\n",
        "170": "\n",
        "171": "  public void testNewHashSetWithExpectedSizeLarge() {\n",
        "172": "    HashSet<Integer> set = Sets.newHashSetWithExpectedSize(1000);\n",
        "173": "    verifySetContents(set, EMPTY_COLLECTION);\n",
        "174": "  }\n",
        "175": "\n",
        "176": "  public void testNewHashSetFromIterator() {\n",
        "177": "    HashSet<Integer> set = Sets.newHashSet(SOME_COLLECTION.iterator());\n",
        "178": "    verifySetContents(set, SOME_COLLECTION);\n",
        "179": "  }\n",
        "180": "\n",
        "181": "  public void testNewConcurrentHashSetEmpty() {\n",
        "182": "    Set<Integer> set = Sets.newConcurrentHashSet();\n",
        "183": "    verifySetContents(set, EMPTY_COLLECTION);\n",
        "184": "  }\n",
        "185": "\n",
        "186": "  public void testNewConcurrentHashSetFromCollection() {\n",
        "187": "    Set<Integer> set = Sets.newConcurrentHashSet(SOME_COLLECTION);\n",
        "188": "    verifySetContents(set, SOME_COLLECTION);\n",
        "189": "  }\n",
        "190": "\n",
        "191": "  public void testNewLinkedHashSetEmpty() {\n",
        "192": "    LinkedHashSet<Integer> set = Sets.newLinkedHashSet();\n",
        "193": "    verifyLinkedHashSetContents(set, EMPTY_COLLECTION);\n",
        "194": "  }\n",
        "195": "\n",
        "196": "  public void testNewLinkedHashSetFromCollection() {\n",
        "197": "    LinkedHashSet<Integer> set = Sets.newLinkedHashSet(LONGER_LIST);\n",
        "198": "    verifyLinkedHashSetContents(set, LONGER_LIST);\n",
        "199": "  }\n",
        "200": "\n",
        "201": "  public void testNewLinkedHashSetFromIterable() {\n",
        "202": "    LinkedHashSet<Integer> set = Sets.newLinkedHashSet(new Iterable<Integer>()\n",
        "203": "    {\n",
        "204": "      @Override\n",
        "205": "      public Iterator<Integer> iterator() {\n",
        "206": "        return LONGER_LIST.iterator();\n",
        "207": "      }\n",
        "208": "    });\n",
        "209": "    verifyLinkedHashSetContents(set, LONGER_LIST);\n",
        "210": "  }\n",
        "211": "\n",
        "212": "  public void testNewLinkedHashSetWithExpectedSizeSmall() {\n",
        "213": "    LinkedHashSet<Integer> set = Sets.newLinkedHashSetWithExpectedSize(0);\n",
        "214": "    verifySetContents(set, EMPTY_COLLECTION);\n",
        "215": "  }\n",
        "216": "\n",
        "217": "  public void testNewLinkedHashSetWithExpectedSizeLarge() {\n",
        "218": "    LinkedHashSet<Integer> set = Sets.newLinkedHashSetWithExpectedSize(1000);\n",
        "219": "    verifySetContents(set, EMPTY_COLLECTION);\n",
        "220": "  }\n",
        "221": "\n",
        "222": "  public void testNewTreeSetEmpty() {\n",
        "223": "    TreeSet<Integer> set = Sets.newTreeSet();\n",
        "224": "    verifySortedSetContents(set, EMPTY_COLLECTION, null);\n",
        "225": "  }\n",
        "226": "\n",
        "227": "  public void testNewTreeSetEmptyDerived() {\n",
        "228": "    TreeSet<Derived> set = Sets.newTreeSet();\n",
        "229": "    assertTrue(set.isEmpty());\n",
        "230": "    set.add(new Derived(\"foo\"));\n",
        "231": "    set.add(new Derived(\"bar\"));\n",
        "232": "    assertThat(set).containsExactly(new Derived(\"bar\"), new Derived(\"foo\")).inOrder();\n",
        "233": "  }\n",
        "234": "\n",
        "235": "  public void testNewTreeSetEmptyNonGeneric() {\n",
        "236": "    TreeSet<LegacyComparable> set = Sets.newTreeSet();\n",
        "237": "    assertTrue(set.isEmpty());\n",
        "238": "    set.add(new LegacyComparable(\"foo\"));\n",
        "239": "    set.add(new LegacyComparable(\"bar\"));\n",
        "240": "    assertThat(set).containsExactly(\n",
        "241": "        new LegacyComparable(\"bar\"), new LegacyComparable(\"foo\")).inOrder();\n",
        "242": "  }\n",
        "243": "\n",
        "244": "  public void testNewTreeSetFromCollection() {\n",
        "245": "    TreeSet<Integer> set = Sets.newTreeSet(SOME_COLLECTION);\n",
        "246": "    verifySortedSetContents(set, SOME_COLLECTION, null);\n",
        "247": "  }\n",
        "248": "\n",
        "249": "  public void testNewTreeSetFromIterable() {\n",
        "250": "    TreeSet<Integer> set = Sets.newTreeSet(SOME_ITERABLE);\n",
        "251": "    verifySortedSetContents(set, SOME_ITERABLE, null);\n",
        "252": "  }\n",
        "253": "\n",
        "254": "  public void testNewTreeSetFromIterableDerived() {\n",
        "255": "    Iterable<Derived> iterable =\n",
        "256": "        Arrays.asList(new Derived(\"foo\"), new Derived(\"bar\"));\n",
        "257": "    TreeSet<Derived> set = Sets.newTreeSet(iterable);\n",
        "258": "    assertThat(set).containsExactly(\n",
        "259": "        new Derived(\"bar\"), new Derived(\"foo\")).inOrder();\n",
        "260": "  }\n",
        "261": "\n",
        "262": "  public void testNewTreeSetFromIterableNonGeneric() {\n",
        "263": "    Iterable<LegacyComparable> iterable =\n",
        "264": "        Arrays.asList(new LegacyComparable(\"foo\"), new LegacyComparable(\"bar\"));\n",
        "265": "    TreeSet<LegacyComparable> set = Sets.newTreeSet(iterable);\n",
        "266": "    assertThat(set).containsExactly(\n",
        "267": "        new LegacyComparable(\"bar\"), new LegacyComparable(\"foo\")).inOrder();\n",
        "268": "  }\n",
        "269": "\n",
        "270": "  public void testNewTreeSetEmptyWithComparator() {\n",
        "271": "    TreeSet<Integer> set = Sets.newTreeSet(SOME_COMPARATOR);\n",
        "272": "    verifySortedSetContents(set, EMPTY_COLLECTION, SOME_COMPARATOR);\n",
        "273": "  }\n",
        "274": "\n",
        "275": "  public void testNewIdentityHashSet() {\n",
        "276": "    Set<Integer> set = Sets.newIdentityHashSet();\n",
        "277": "    Integer value1 = new Integer(12357);\n",
        "278": "    Integer value2 = new Integer(12357);\n",
        "279": "    assertTrue(set.add(value1));\n",
        "280": "    assertFalse(set.contains(value2));\n",
        "281": "    assertTrue(set.contains(value1));\n",
        "282": "    assertTrue(set.add(value2));\n",
        "283": "    assertEquals(2, set.size());\n",
        "284": "  }\n",
        "285": "\n",
        "286": "  public void testComplementOfEnumSet() {\n",
        "287": "    Set<SomeEnum> units = EnumSet.of(SomeEnum.B, SomeEnum.D);\n",
        "288": "    EnumSet<SomeEnum> otherUnits = Sets.complementOf(units);\n",
        "289": "    verifySetContents(otherUnits, EnumSet.of(SomeEnum.A, SomeEnum.C));\n",
        "290": "  }\n",
        "291": "\n",
        "292": "  public void testComplementOfEnumSetWithType() {\n",
        "293": "    Set<SomeEnum> units = EnumSet.of(SomeEnum.B, SomeEnum.D);\n",
        "294": "    EnumSet<SomeEnum> otherUnits = Sets.complementOf(units, SomeEnum.class);\n",
        "295": "    verifySetContents(otherUnits, EnumSet.of(SomeEnum.A, SomeEnum.C));\n",
        "296": "  }\n",
        "297": "\n",
        "298": "  public void testComplementOfRegularSet() {\n",
        "299": "    Set<SomeEnum> units = Sets.newHashSet(SomeEnum.B, SomeEnum.D);\n",
        "300": "    EnumSet<SomeEnum> otherUnits = Sets.complementOf(units);\n",
        "301": "    verifySetContents(otherUnits, EnumSet.of(SomeEnum.A, SomeEnum.C));\n",
        "302": "  }\n",
        "303": "\n",
        "304": "  public void testComplementOfRegularSetWithType() {\n",
        "305": "    Set<SomeEnum> units = Sets.newHashSet(SomeEnum.B, SomeEnum.D);\n",
        "306": "    EnumSet<SomeEnum> otherUnits = Sets.complementOf(units, SomeEnum.class);\n",
        "307": "    verifySetContents(otherUnits, EnumSet.of(SomeEnum.A, SomeEnum.C));\n",
        "308": "  }\n",
        "309": "\n",
        "310": "  public void testComplementOfEmptySet() {\n",
        "311": "    Set<SomeEnum> noUnits = Collections.emptySet();\n",
        "312": "    EnumSet<SomeEnum> allUnits = Sets.complementOf(noUnits, SomeEnum.class);\n",
        "313": "    verifySetContents(EnumSet.allOf(SomeEnum.class), allUnits);\n",
        "314": "  }\n",
        "315": "\n",
        "316": "  public void testComplementOfFullSet() {\n",
        "317": "    Set<SomeEnum> allUnits = Sets.newHashSet(SomeEnum.values());\n",
        "318": "    EnumSet<SomeEnum> noUnits = Sets.complementOf(allUnits, SomeEnum.class);\n",
        "319": "    verifySetContents(noUnits, EnumSet.noneOf(SomeEnum.class));\n",
        "320": "  }\n",
        "321": "\n",
        "322": "  public void testComplementOfEmptyEnumSetWithoutType() {\n",
        "323": "    Set<SomeEnum> noUnits = EnumSet.noneOf(SomeEnum.class);\n",
        "324": "    EnumSet<SomeEnum> allUnits = Sets.complementOf(noUnits);\n",
        "325": "    verifySetContents(allUnits, EnumSet.allOf(SomeEnum.class));\n",
        "326": "  }\n",
        "327": "\n",
        "328": "  public void testComplementOfEmptySetWithoutTypeDoesntWork() {\n",
        "329": "    Set<SomeEnum> set = Collections.emptySet();\n",
        "330": "    try {\n",
        "331": "      Sets.complementOf(set);\n",
        "332": "      fail();\n",
        "333": "    } catch (IllegalArgumentException expected) {}\n",
        "334": "  }\n",
        "335": "\n",
        "336": "  public void testNewSetFromMap() {\n",
        "337": "    Set<Integer> set = Sets.newSetFromMap(new HashMap<Integer, Boolean>());\n",
        "338": "    set.addAll(SOME_COLLECTION);\n",
        "339": "    verifySetContents(set, SOME_COLLECTION);\n",
        "340": "  }\n",
        "341": "\n",
        "342": "  public void testNewSetFromMapIllegal() {\n",
        "343": "    Map<Integer, Boolean> map = new LinkedHashMap<Integer, Boolean>();\n",
        "344": "    map.put(2, true);\n",
        "345": "    try {\n",
        "346": "      Sets.newSetFromMap(map);\n",
        "347": "      fail();\n",
        "348": "    } catch (IllegalArgumentException expected) {}\n",
        "349": "  }\n",
        "350": "\n",
        "351": "  // TODO: the overwhelming number of suppressions below suggests that maybe\n",
        "352": "  // it's not worth having a varargs form of this method at all...\n",
        "353": "\n",
        "354": "  /**\n",
        "355": "   * The 0-ary cartesian product is a single empty list.\n",
        "356": "   */\n",
        "357": "  @SuppressWarnings(\"unchecked\") // varargs!\n",
        "358": "  public void testCartesianProduct_zeroary() {\n",
        "359": "    assertThat(Sets.cartesianProduct()).containsExactly(list());\n",
        "360": "  }\n",
        "361": "\n",
        "362": "  /**\n",
        "363": "   * A unary cartesian product is one list of size 1 for each element in the\n",
        "364": "   * input set.\n",
        "365": "   */\n",
        "366": "  @SuppressWarnings(\"unchecked\") // varargs!\n",
        "367": "  public void testCartesianProduct_unary() {\n",
        "368": "    assertThat(Sets.cartesianProduct(set(1, 2))).containsExactly(list(1), list(2));\n",
        "369": "  }\n",
        "370": "\n",
        "371": "  @SuppressWarnings(\"unchecked\") // varargs!\n",
        "372": "  public void testCartesianProduct_binary0x0() {\n",
        "373": "    Set<Integer> mt = emptySet();\n",
        "374": "    assertEmpty(Sets.cartesianProduct(mt, mt));\n",
        "375": "  }\n",
        "376": "\n",
        "377": "  @SuppressWarnings(\"unchecked\") // varargs!\n",
        "378": "  public void testCartesianProduct_binary0x1() {\n",
        "379": "    Set<Integer> mt = emptySet();\n",
        "380": "    assertEmpty(Sets.cartesianProduct(mt, set(1)));\n",
        "381": "  }\n",
        "382": "\n",
        "383": "  @SuppressWarnings(\"unchecked\") // varargs!\n",
        "384": "  public void testCartesianProduct_binary1x0() {\n",
        "385": "    Set<Integer> mt = emptySet();\n",
        "386": "    assertEmpty(Sets.cartesianProduct(set(1), mt));\n",
        "387": "  }\n",
        "388": "\n",
        "389": "  private static void assertEmpty(Set<? extends List<?>> set) {\n",
        "390": "    assertTrue(set.isEmpty());\n",
        "391": "    assertEquals(0, set.size());\n",
        "392": "    assertFalse(set.iterator().hasNext());\n",
        "393": "  }\n",
        "394": "\n",
        "395": "  @SuppressWarnings(\"unchecked\") // varargs!\n",
        "396": "  public void testCartesianProduct_binary1x1() {\n",
        "397": "    assertThat(Sets.cartesianProduct(set(1), set(2))).contains(list(1, 2));\n",
        "398": "  }\n",
        "399": "\n",
        "400": "  @SuppressWarnings(\"unchecked\") // varargs!\n",
        "401": "  public void testCartesianProduct_binary1x2() {\n",
        "402": "    assertThat(Sets.cartesianProduct(set(1), set(2, 3)))\n",
        "403": "        .containsExactly(list(1, 2), list(1, 3)).inOrder();\n",
        "404": "  }\n",
        "405": "\n",
        "406": "  @SuppressWarnings(\"unchecked\") // varargs!\n",
        "407": "  public void testCartesianProduct_binary2x2() {\n",
        "408": "    assertThat(Sets.cartesianProduct(set(1, 2), set(3, 4)))\n",
        "409": "        .containsExactly(list(1, 3), list(1, 4), list(2, 3), list(2, 4)).inOrder();\n",
        "410": "  }\n",
        "411": "\n",
        "412": "  @SuppressWarnings(\"unchecked\") // varargs!\n",
        "413": "  public void testCartesianProduct_2x2x2() {\n",
        "414": "    assertThat(Sets.cartesianProduct(set(0, 1), set(0, 1), set(0, 1))).containsExactly(\n",
        "415": "        list(0, 0, 0), list(0, 0, 1), list(0, 1, 0), list(0, 1, 1),\n",
        "416": "        list(1, 0, 0), list(1, 0, 1), list(1, 1, 0), list(1, 1, 1)).inOrder();\n",
        "417": "  }\n",
        "418": "\n",
        "419": "  @SuppressWarnings(\"unchecked\") // varargs!\n",
        "420": "  public void testCartesianProduct_contains() {\n",
        "421": "    Set<List<Integer>> actual = Sets.cartesianProduct(set(1, 2), set(3, 4));\n",
        "422": "    assertTrue(actual.contains(list(1, 3)));\n",
        "423": "    assertTrue(actual.contains(list(1, 4)));\n",
        "424": "    assertTrue(actual.contains(list(2, 3)));\n",
        "425": "    assertTrue(actual.contains(list(2, 4)));\n",
        "426": "    assertFalse(actual.contains(list(3, 1)));\n",
        "427": "  }\n",
        "428": "\n",
        "429": "  @SuppressWarnings(\"unchecked\") // varargs!\n",
        "430": "  public void testCartesianProduct_unrelatedTypes() {\n",
        "431": "    Set<Integer> x = set(1, 2);\n",
        "432": "    Set<String> y = set(\"3\", \"4\");\n",
        "433": "\n",
        "434": "    List<Object> exp1 = list((Object) 1, \"3\");\n",
        "435": "    List<Object> exp2 = list((Object) 1, \"4\");\n",
        "436": "    List<Object> exp3 = list((Object) 2, \"3\");\n",
        "437": "    List<Object> exp4 = list((Object) 2, \"4\");\n",
        "438": "\n",
        "439": "    assertThat(Sets.<Object>cartesianProduct(x, y))\n",
        "440": "        .containsExactly(exp1, exp2, exp3, exp4).inOrder();\n",
        "441": "  }\n",
        "442": "\n",
        "443": "  @SuppressWarnings(\"unchecked\") // varargs!\n",
        "444": "  public void testCartesianProductTooBig() {\n",
        "445": "    Set<Integer> set = ContiguousSet.create(Range.closed(0, 10000), DiscreteDomain.integers());\n",
        "446": "    try {\n",
        "447": "      Sets.cartesianProduct(set, set, set, set, set);\n",
        "448": "      fail(\"Expected IAE\");\n",
        "449": "    } catch (IllegalArgumentException expected) {}\n",
        "450": "  }\n",
        "451": "\n",
        "452": "  @SuppressWarnings(\"unchecked\") // varargs!\n",
        "453": "  public void testCartesianProduct_hashCode() {\n",
        "454": "    // Run through the same cartesian products we tested above\n",
        "455": "\n",
        "456": "    Set<List<Integer>> degenerate = Sets.cartesianProduct();\n",
        "457": "    checkHashCode(degenerate);\n",
        "458": "\n",
        "459": "    checkHashCode(Sets.cartesianProduct(set(1, 2)));\n",
        "460": "\n",
        "461": "    int num = Integer.MAX_VALUE / 3 * 2; // tickle overflow-related problems\n",
        "462": "    checkHashCode(Sets.cartesianProduct(set(1, 2, num)));\n",
        "463": "\n",
        "464": "    Set<Integer> mt = emptySet();\n",
        "465": "    checkHashCode(Sets.cartesianProduct(mt, mt));\n",
        "466": "    checkHashCode(Sets.cartesianProduct(mt, set(num)));\n",
        "467": "    checkHashCode(Sets.cartesianProduct(set(num), mt));\n",
        "468": "    checkHashCode(Sets.cartesianProduct(set(num), set(1)));\n",
        "469": "    checkHashCode(Sets.cartesianProduct(set(1), set(2, num)));\n",
        "470": "    checkHashCode(Sets.cartesianProduct(set(1, num), set(2, num - 1)));\n",
        "471": "    checkHashCode(Sets.cartesianProduct(\n",
        "472": "        set(1, num), set(2, num - 1), set(3, num + 1)));\n",
        "473": "\n",
        "474": "    // a bigger one\n",
        "475": "    checkHashCode(Sets.cartesianProduct(\n",
        "476": "        set(1, num, num + 1), set(2), set(3, num + 2), set(4, 5, 6, 7, 8)));\n",
        "477": "  }\n",
        "478": "\n",
        "479": "  public void testPowerSetEmpty() {\n",
        "480": "    ImmutableSet<Integer> elements = ImmutableSet.of();\n",
        "481": "    Set<Set<Integer>> powerSet = powerSet(elements);\n",
        "482": "    assertEquals(1, powerSet.size());\n",
        "483": "    assertEquals(ImmutableSet.of(ImmutableSet.of()), powerSet);\n",
        "484": "    assertEquals(0, powerSet.hashCode());\n",
        "485": "  }\n",
        "486": "\n",
        "487": "  public void testPowerSetContents() {\n",
        "488": "    ImmutableSet<Integer> elements = ImmutableSet.of(1, 2, 3);\n",
        "489": "    Set<Set<Integer>> powerSet = powerSet(elements);\n",
        "490": "    assertEquals(8, powerSet.size());\n",
        "491": "    assertEquals(4 * 1 + 4 * 2 + 4 * 3, powerSet.hashCode());\n",
        "492": "\n",
        "493": "    Set<Set<Integer>> expected = newHashSet();\n",
        "494": "    expected.add(ImmutableSet.<Integer>of());\n",
        "495": "    expected.add(ImmutableSet.of(1));\n",
        "496": "    expected.add(ImmutableSet.of(2));\n",
        "497": "    expected.add(ImmutableSet.of(3));\n",
        "498": "    expected.add(ImmutableSet.of(1, 2));\n",
        "499": "    expected.add(ImmutableSet.of(1, 3));\n",
        "500": "    expected.add(ImmutableSet.of(2, 3));\n",
        "501": "    expected.add(ImmutableSet.of(1, 2, 3));\n",
        "502": "\n",
        "503": "    Set<Set<Integer>> almostPowerSet = newHashSet(expected);\n",
        "504": "    almostPowerSet.remove(ImmutableSet.of(1, 2, 3));\n",
        "505": "    almostPowerSet.add(ImmutableSet.of(1, 2, 4));\n",
        "506": "\n",
        "507": "    new EqualsTester()\n",
        "508": "        .addEqualityGroup(expected, powerSet)\n",
        "509": "        .addEqualityGroup(ImmutableSet.of(1, 2, 3))\n",
        "510": "        .addEqualityGroup(almostPowerSet)\n",
        "511": "        .testEquals();\n",
        "512": "\n",
        "513": "    for (Set<Integer> subset : expected) {\n",
        "514": "      assertTrue(powerSet.contains(subset));\n",
        "515": "    }\n",
        "516": "    assertFalse(powerSet.contains(ImmutableSet.of(1, 2, 4)));\n",
        "517": "    assertFalse(powerSet.contains(singleton(null)));\n",
        "518": "    assertFalse(powerSet.contains(null));\n",
        "519": "    assertFalse(powerSet.contains(\"notASet\"));\n",
        "520": "  }\n",
        "521": "\n",
        "522": "  public void testPowerSetIteration_manual() {\n",
        "523": "    ImmutableSet<Integer> elements = ImmutableSet.of(1, 2, 3);\n",
        "524": "    Set<Set<Integer>> powerSet = powerSet(elements);\n",
        "525": "    // The API doesn't promise this iteration order, but it's convenient here.\n",
        "526": "    Iterator<Set<Integer>> i = powerSet.iterator();\n",
        "527": "    assertEquals(ImmutableSet.of(), i.next());\n",
        "528": "    assertEquals(ImmutableSet.of(1), i.next());\n",
        "529": "    assertEquals(ImmutableSet.of(2), i.next());\n",
        "530": "    assertEquals(ImmutableSet.of(2, 1), i.next());\n",
        "531": "    assertEquals(ImmutableSet.of(3), i.next());\n",
        "532": "    assertEquals(ImmutableSet.of(3, 1), i.next());\n",
        "533": "    assertEquals(ImmutableSet.of(3, 2), i.next());\n",
        "534": "    assertEquals(ImmutableSet.of(3, 2, 1), i.next());\n",
        "535": "    assertFalse(i.hasNext());\n",
        "536": "    try {\n",
        "537": "      i.next();\n",
        "538": "      fail();\n",
        "539": "    } catch (NoSuchElementException expected) {\n",
        "540": "    }\n",
        "541": "  }\n",
        "542": "\n",
        "543": "  public void testPowerSetIteration_iteratorTester_fast() {\n",
        "544": "    ImmutableSet<Integer> elements = ImmutableSet.of(1, 2);\n",
        "545": "\n",
        "546": "    Set<Set<Integer>> expected = newLinkedHashSet();\n",
        "547": "    expected.add(ImmutableSet.<Integer>of());\n",
        "548": "    expected.add(ImmutableSet.of(1));\n",
        "549": "    expected.add(ImmutableSet.of(2));\n",
        "550": "    expected.add(ImmutableSet.of(1, 2));\n",
        "551": "\n",
        "552": "    final Set<Set<Integer>> powerSet = powerSet(elements);\n",
        "553": "    new IteratorTester<Set<Integer>>(4, UNMODIFIABLE, expected, KNOWN_ORDER) {\n",
        "554": "      @Override protected Iterator<Set<Integer>> newTargetIterator() {\n",
        "555": "        return powerSet.iterator();\n",
        "556": "      }\n",
        "557": "    }.test();\n",
        "558": "  }\n",
        "559": "\n",
        "560": "  public void testPowerSetSize() {\n",
        "561": "    assertPowerSetSize(1);\n",
        "562": "    assertPowerSetSize(2, 'a');\n",
        "563": "    assertPowerSetSize(4, 'a', 'b');\n",
        "564": "    assertPowerSetSize(8, 'a', 'b', 'c');\n",
        "565": "    assertPowerSetSize(16, 'a', 'b', 'd', 'e');\n",
        "566": "    assertPowerSetSize(1 << 30,\n",
        "567": "        'a', 'b', 'c', 'd', 'e', 'f', 'g', 'h', 'i', 'j', 'k', 'l', 'm', 'n',\n",
        "568": "        'o', 'p', 'q', 'r', 's', 't', 'u', 'v', 'w', 'x', 'y', 'z', '1', '2',\n",
        "569": "        '3', '4');\n",
        "570": "  }\n",
        "571": "\n",
        "572": "  public void testPowerSetCreationErrors() {\n",
        "573": "    try {\n",
        "574": "      powerSet(newHashSet('a', 'b', 'c', 'd', 'e', 'f', 'g', 'h', 'i', 'j',\n",
        "575": "          'k', 'l', 'm', 'n', 'o', 'p', 'q', 'r', 's', 't', 'u', 'v', 'w', 'x',\n",
        "576": "          'y', 'z', '1', '2', '3', '4', '5'));\n",
        "577": "      fail();\n",
        "578": "    } catch (IllegalArgumentException expected) {\n",
        "579": "    }\n",
        "580": "\n",
        "581": "    try {\n",
        "582": "      powerSet(singleton(null));\n",
        "583": "      fail();\n",
        "584": "    } catch (NullPointerException expected) {\n",
        "585": "    }\n",
        "586": "  }\n",
        "587": "\n",
        "588": "  public void testPowerSetEqualsAndHashCode_verifyAgainstHashSet() {\n",
        "589": "    ImmutableList<Integer> allElements = ImmutableList.of(4233352, 3284593,\n",
        "590": "        3794208, 3849533, 4013967, 2902658, 1886275, 2131109, 985872, 1843868);\n",
        "591": "    for (int i = 0; i < allElements.size(); i++) {\n",
        "592": "      Set<Integer> elements = newHashSet(allElements.subList(0, i));\n",
        "593": "      Set<Set<Integer>> powerSet1 = powerSet(elements);\n",
        "594": "      Set<Set<Integer>> powerSet2 = powerSet(elements);\n",
        "595": "      new EqualsTester()\n",
        "596": "          .addEqualityGroup(powerSet1, powerSet2, toHashSets(powerSet1))\n",
        "597": "          .addEqualityGroup(ImmutableSet.of())\n",
        "598": "          .addEqualityGroup(ImmutableSet.of(9999999))\n",
        "599": "          .addEqualityGroup(\"notASet\")\n",
        "600": "          .testEquals();\n",
        "601": "      assertEquals(toHashSets(powerSet1).hashCode(), powerSet1.hashCode());\n",
        "602": "    }\n",
        "603": "  }\n",
        "604": "\n",
        "605": "  /**\n",
        "606": "   * Test that a hash code miscomputed by \"input.hashCode() * tooFarValue / 2\"\n",
        "607": "   * is correct under our {@code hashCode} implementation.\n",
        "608": "   */\n",
        "609": "  public void testPowerSetHashCode_inputHashCodeTimesTooFarValueIsZero() {\n",
        "610": "    Set<Object> sumToEighthMaxIntElements =\n",
        "611": "        newHashSet(objectWithHashCode(1 << 29), objectWithHashCode(0));\n",
        "612": "    assertPowerSetHashCode(1 << 30, sumToEighthMaxIntElements);\n",
        "613": "\n",
        "614": "    Set<Object> sumToQuarterMaxIntElements =\n",
        "615": "        newHashSet(objectWithHashCode(1 << 30), objectWithHashCode(0));\n",
        "616": "    assertPowerSetHashCode(1 << 31, sumToQuarterMaxIntElements);\n",
        "617": "  }\n",
        "618": "\n",
        "619": "  public void testPowerSetShowOff() {\n",
        "620": "    Set<Object> zero = ImmutableSet.of();\n",
        "621": "    Set<Set<Object>> one = powerSet(zero);\n",
        "622": "    Set<Set<Set<Object>>> two = powerSet(one);\n",
        "623": "    Set<Set<Set<Set<Object>>>> four = powerSet(two);\n",
        "624": "    Set<Set<Set<Set<Set<Object>>>>> sixteen = powerSet(four);\n",
        "625": "    Set<Set<Set<Set<Set<Set<Object>>>>>> sixtyFiveThousandish =\n",
        "626": "        powerSet(sixteen);\n",
        "627": "    assertEquals(1 << 16, sixtyFiveThousandish.size());\n",
        "628": "\n",
        "629": "    assertTrue(powerSet(makeSetOfZeroToTwentyNine())\n",
        "630": "        .contains(makeSetOfZeroToTwentyNine()));\n",
        "631": "    assertFalse(powerSet(makeSetOfZeroToTwentyNine())\n",
        "632": "        .contains(ImmutableSet.of(30)));\n",
        "633": "  }\n",
        "634": "\n",
        "635": "  private static Set<Integer> makeSetOfZeroToTwentyNine() {\n",
        "636": "    // TODO: use Range once it's publicly available\n",
        "637": "    Set<Integer> zeroToTwentyNine = newHashSet();\n",
        "638": "    for (int i = 0; i < 30; i++) {\n",
        "639": "      zeroToTwentyNine.add(i);\n",
        "640": "    }\n",
        "641": "    return zeroToTwentyNine;\n",
        "642": "  }\n",
        "643": "\n",
        "644": "  private static <E> Set<Set<E>> toHashSets(Set<Set<E>> powerSet) {\n",
        "645": "    Set<Set<E>> result = newHashSet();\n",
        "646": "    for (Set<E> subset : powerSet) {\n",
        "647": "      result.add(new HashSet<E>(subset));\n",
        "648": "    }\n",
        "649": "    return result;\n",
        "650": "  }\n",
        "651": "\n",
        "652": "  private static Object objectWithHashCode(final int hashCode) {\n",
        "653": "    return new Object() {\n",
        "654": "      @Override public int hashCode() {\n",
        "655": "        return hashCode;\n",
        "656": "      }\n",
        "657": "    };\n",
        "658": "  }\n",
        "659": "\n",
        "660": "  private static void assertPowerSetHashCode(int expected, Set<?> elements) {\n",
        "661": "    assertEquals(expected, powerSet(elements).hashCode());\n",
        "662": "  }\n",
        "663": "\n",
        "664": "  private static void assertPowerSetSize(int i, Object... elements) {\n",
        "665": "    assertEquals(i, powerSet(newHashSet(elements)).size());\n",
        "666": "  }\n",
        "667": "\n",
        "668": "  private static void checkHashCode(Set<?> set) {\n",
        "669": "    assertEquals(Sets.newHashSet(set).hashCode(), set.hashCode());\n",
        "670": "  }\n",
        "671": "\n",
        "672": "  private static <E> Set<E> set(E... elements) {\n",
        "673": "    return ImmutableSet.copyOf(elements);\n",
        "674": "  }\n",
        "675": "\n",
        "676": "  private static <E> List<E> list(E... elements) {\n",
        "677": "    return ImmutableList.copyOf(elements);\n",
        "678": "  }\n",
        "679": "\n",
        "680": "  /**\n",
        "681": "   * Utility method to verify that the given LinkedHashSet is equal to and\n",
        "682": "   * hashes identically to a set constructed with the elements in the given\n",
        "683": "   * collection.  Also verifies that the ordering in the set is the same\n",
        "684": "   * as the ordering of the given contents.\n",
        "685": "   */\n",
        "686": "  private static <E> void verifyLinkedHashSetContents(\n",
        "687": "      LinkedHashSet<E> set, Collection<E> contents) {\n",
        "688": "    assertEquals(\"LinkedHashSet should have preserved order for iteration\",\n",
        "689": "        new ArrayList<E>(set), new ArrayList<E>(contents));\n",
        "690": "    verifySetContents(set, contents);\n",
        "691": "  }\n",
        "692": "\n",
        "693": "  /**\n",
        "694": "   * Utility method to verify that the given SortedSet is equal to and\n",
        "695": "   * hashes identically to a set constructed with the elements in the\n",
        "696": "   * given iterable.  Also verifies that the comparator is the same as the\n",
        "697": "   * given comparator.\n",
        "698": "   */\n",
        "699": "  private static <E> void verifySortedSetContents(\n",
        "700": "      SortedSet<E> set, Iterable<E> iterable,\n",
        "701": "      @Nullable Comparator<E> comparator) {\n",
        "702": "    assertSame(comparator, set.comparator());\n",
        "703": "    verifySetContents(set, iterable);\n",
        "704": "  }\n",
        "705": "\n",
        "706": "  /**\n",
        "707": "   * Utility method that verifies that the given set is equal to and hashes\n",
        "708": "   * identically to a set constructed with the elements in the given iterable.\n",
        "709": "   */\n",
        "710": "  private static <E> void verifySetContents(Set<E> set, Iterable<E> contents) {\n",
        "711": "    Set<E> expected = null;\n",
        "712": "    if (contents instanceof Set) {\n",
        "713": "      expected = (Set<E>) contents;\n",
        "714": "    } else {\n",
        "715": "      expected = new HashSet<E>();\n",
        "716": "      for (E element : contents) {\n",
        "717": "        expected.add(element);\n",
        "718": "      }\n",
        "719": "    }\n",
        "720": "    assertEquals(expected, set);\n",
        "721": "  }\n",
        "722": "\n",
        "723": "  /**\n",
        "724": "   * Simple base class to verify that we handle generics correctly.\n",
        "725": "   */\n",
        "726": "  static class Base implements Comparable<Base>, Serializable {\n",
        "727": "    private final String s;\n",
        "728": "\n",
        "729": "    public Base(String s) {\n",
        "730": "      this.s = s;\n",
        "731": "    }\n",
        "732": "\n",
        "733": "    @Override public int hashCode() { // delegate to 's'\n",
        "734": "      return s.hashCode();\n",
        "735": "    }\n",
        "736": "\n",
        "737": "    @Override public boolean equals(Object other) {\n",
        "738": "      if (other == null) {\n",
        "739": "        return false;\n",
        "740": "      } else if (other instanceof Base) {\n",
        "741": "        return s.equals(((Base) other).s);\n",
        "742": "      } else {\n",
        "743": "        return false;\n",
        "744": "      }\n",
        "745": "    }\n",
        "746": "\n",
        "747": "    @Override\n",
        "748": "    public int compareTo(Base o) {\n",
        "749": "      return s.compareTo(o.s);\n",
        "750": "    }\n",
        "751": "\n",
        "752": "    private static final long serialVersionUID = 0;\n",
        "753": "  }\n",
        "754": "\n",
        "755": "  /**\n",
        "756": "   * Simple derived class to verify that we handle generics correctly.\n",
        "757": "   */\n",
        "758": "  static class Derived extends Base {\n",
        "759": "    public Derived(String s) {\n",
        "760": "      super(s);\n",
        "761": "    }\n",
        "762": "\n",
        "763": "    private static final long serialVersionUID = 0;\n",
        "764": "  }\n",
        "765": "\n",
        "766": "  void ensureNotDirectlyModifiable(SortedSet<Integer> unmod) {\n",
        "767": "    try {\n",
        "768": "      unmod.add(4);\n",
        "769": "      fail(\"UnsupportedOperationException expected\");\n",
        "770": "    } catch (UnsupportedOperationException expected) {\n",
        "771": "    }\n",
        "772": "    try {\n",
        "773": "      unmod.remove(4);\n",
        "774": "      fail(\"UnsupportedOperationException expected\");\n",
        "775": "    } catch (UnsupportedOperationException expected) {\n",
        "776": "    }\n",
        "777": "    try {\n",
        "778": "      unmod.addAll(Collections.singleton(4));\n",
        "779": "      fail(\"UnsupportedOperationException expected\");\n",
        "780": "    } catch (UnsupportedOperationException expected) {\n",
        "781": "    }\n",
        "782": "    try {\n",
        "783": "      Iterator<Integer> iterator = unmod.iterator();\n",
        "784": "      iterator.next();\n",
        "785": "      iterator.remove();\n",
        "786": "      fail(\"UnsupportedOperationException expected\");\n",
        "787": "    } catch (UnsupportedOperationException expected) {\n",
        "788": "    }\n",
        "789": "  }\n",
        "790": "}\n"
    }
}