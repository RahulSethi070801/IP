{
    "addition": {},
    "removed": {
        "1": "/*\n",
        "2": " * Copyright (C) 2013 The Guava Authors\n",
        "3": " *\n",
        "4": " * Licensed under the Apache License, Version 2.0 (the \"License\");\n",
        "5": " * you may not use this file except in compliance with the License.\n",
        "6": " * You may obtain a copy of the License at\n",
        "7": " *\n",
        "8": " * http://www.apache.org/licenses/LICENSE-2.0\n",
        "9": " *\n",
        "10": " * Unless required by applicable law or agreed to in writing, software\n",
        "11": " * distributed under the License is distributed on an \"AS IS\" BASIS,\n",
        "12": " * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n",
        "13": " * See the License for the specific language governing permissions and\n",
        "14": " * limitations under the License.\n",
        "15": " */\n",
        "16": "\n",
        "17": "package com.google.common.base;\n",
        "18": "\n",
        "19": "import static com.google.common.truth.Truth.assertThat;\n",
        "20": "import static java.lang.Character.MAX_CODE_POINT;\n",
        "21": "import static java.lang.Character.MAX_HIGH_SURROGATE;\n",
        "22": "import static java.lang.Character.MAX_LOW_SURROGATE;\n",
        "23": "import static java.lang.Character.MIN_HIGH_SURROGATE;\n",
        "24": "import static java.lang.Character.MIN_LOW_SURROGATE;\n",
        "25": "import static java.lang.Character.MIN_SUPPLEMENTARY_CODE_POINT;\n",
        "26": "\n",
        "27": "import com.google.common.annotations.GwtCompatible;\n",
        "28": "import com.google.common.collect.ImmutableList;\n",
        "29": "\n",
        "30": "import junit.framework.TestCase;\n",
        "31": "\n",
        "32": "import java.util.HashMap;\n",
        "33": "import java.util.Random;\n",
        "34": "\n",
        "35": "/**\n",
        "36": " * Unit tests for {@link Utf8}.\n",
        "37": " *\n",
        "38": " * @author Jon Perlow\n",
        "39": " * @author Martin Buchholz\n",
        "40": " * @author Cl\u00e9ment Roux\n",
        "41": " */\n",
        "42": "@GwtCompatible(emulated = true)\n",
        "43": "public class Utf8Test extends TestCase {\n",
        "44": "\n",
        "45": "  private static final ImmutableList<String> ILL_FORMED_STRINGS;\n",
        "46": "  static {\n",
        "47": "    ImmutableList.Builder<String> builder = ImmutableList.builder();\n",
        "48": "    char[] surrogates = {\n",
        "49": "      MAX_LOW_SURROGATE,\n",
        "50": "      MAX_HIGH_SURROGATE,\n",
        "51": "      MIN_LOW_SURROGATE,\n",
        "52": "      MIN_HIGH_SURROGATE,\n",
        "53": "    };\n",
        "54": "    for (char surrogate : surrogates) {\n",
        "55": "      builder.add(newString(surrogate));\n",
        "56": "      builder.add(newString(surrogate, 'n'));\n",
        "57": "      builder.add(newString('n', surrogate));\n",
        "58": "      builder.add(newString(surrogate, surrogate));\n",
        "59": "    }\n",
        "60": "    builder.add(newString(MIN_LOW_SURROGATE, MAX_HIGH_SURROGATE));\n",
        "61": "    ILL_FORMED_STRINGS = builder.build();\n",
        "62": "  }\n",
        "63": "\n",
        "64": "  public void testEncodedLength_validStrings() {\n",
        "65": "    assertEquals(0, Utf8.encodedLength(\"\"));\n",
        "66": "    assertEquals(11, Utf8.encodedLength(\"Hello world\"));\n",
        "67": "    assertEquals(8, Utf8.encodedLength(\"R\u00e9sum\u00e9\"));\n",
        "68": "    assertEquals(461, Utf8.encodedLength(\"\u5a01\u5ec9\u00b7\u838e\u58eb\u6bd4\u4e9e\uff08William Shakespeare\uff0c\"\n",
        "69": "        + \"1564\u5e744\u670826\u865f\u20141616\u5e744\u670823\u865f[1]\uff09\u4fc2\u96bb\u82f1\u570b\u55f0\u6f14\u54e1\u3001\u5287\u4f5c\u5bb6\u540c\u8a69\u4eba\uff0c\"\n",
        "70": "        + \"\u6709\u6642\u9593\u4f62\u7c21\u7a31\u838e\u7fc1\uff1b\u4e2d\u570b\u6e05\u672b\u6c11\u521d\u54c8\u62d5\u7ffb\u8b6f\u505a\u820c\u514b\u65af\u6bd5\u3001\u6c99\u65af\u76ae\u8033\u3001\u7b5b\u65af\u6bd4\u8033\u3001\"\n",
        "71": "        + \"\u838e\u57fa\u65af\u5e87\u5c14\u3001\u7d22\u58eb\u6bd4\u5c14\u3001\u590f\u514b\u601d\u8298\u5c14\u3001\u5e0c\u54c0\u82e6\u76ae\u963f\u3001\u53f6\u65af\u58c1\u3001\u6c99\u514b\u76ae\u5c14\u3001\"\n",
        "72": "        + \"\u72f9\u65af\u4e15\u723e\u3002[2]\u838e\u58eb\u6bd4\u4e9e\u7de8\u5beb\u904e\u597d\u591a\u4f5c\u54c1\uff0c\u4f62\u55f0\u5287\u4f5c\u97ff\u897f\u6d0b\u6587\u5b78\u597d\u6709\u5f71\u97ff\uff0c\"\n",
        "73": "        + \"\u54c8\u90fd\u62d5\u4eba\u7ffb\u8b6f\u505a\u597d\u591a\u8a71\u3002\"));\n",
        "74": "    // A surrogate pair\n",
        "75": "    assertEquals(4, Utf8.encodedLength(newString(MIN_HIGH_SURROGATE, MIN_LOW_SURROGATE)));\n",
        "76": "  }\n",
        "77": "\n",
        "78": "  public void testEncodedLength_validStrings2() {\n",
        "79": "    HashMap<Integer, Integer> utf8Lengths = new HashMap<Integer, Integer>();\n",
        "80": "    utf8Lengths.put(0x00, 1);\n",
        "81": "    utf8Lengths.put(0x7f, 1);\n",
        "82": "    utf8Lengths.put(0x80, 2);\n",
        "83": "    utf8Lengths.put(0x7ff, 2);\n",
        "84": "    utf8Lengths.put(0x800, 3);\n",
        "85": "    utf8Lengths.put(MIN_SUPPLEMENTARY_CODE_POINT - 1, 3);\n",
        "86": "    utf8Lengths.put(MIN_SUPPLEMENTARY_CODE_POINT, 4);\n",
        "87": "    utf8Lengths.put(MAX_CODE_POINT, 4);\n",
        "88": "\n",
        "89": "    Integer[] codePoints = utf8Lengths.keySet().toArray(new Integer[]{});\n",
        "90": "    StringBuilder sb = new StringBuilder();\n",
        "91": "    Random rnd = new Random();\n",
        "92": "    for (int trial = 0; trial < 100; trial++) {\n",
        "93": "      sb.setLength(0);\n",
        "94": "      int utf8Length = 0;\n",
        "95": "      for (int i = 0; i < 6; i++) {\n",
        "96": "        Integer randomCodePoint = codePoints[rnd.nextInt(codePoints.length)];\n",
        "97": "        sb.appendCodePoint(randomCodePoint);\n",
        "98": "        utf8Length += utf8Lengths.get(randomCodePoint);\n",
        "99": "        if (utf8Length != Utf8.encodedLength(sb)) {\n",
        "100": "          StringBuilder repro = new StringBuilder();\n",
        "101": "          for (int j = 0; j < sb.length(); j++) {\n",
        "102": "            repro.append(\" \" + (int) sb.charAt(j));  // GWT compatible\n",
        "103": "          }\n",
        "104": "          assertEquals(repro.toString(), utf8Length, Utf8.encodedLength(sb));\n",
        "105": "        }\n",
        "106": "      }\n",
        "107": "    }\n",
        "108": "  }\n",
        "109": "\n",
        "110": "  public void testEncodedLength_invalidStrings() {\n",
        "111": "    testEncodedLengthFails(newString(MIN_HIGH_SURROGATE), 0);\n",
        "112": "    testEncodedLengthFails(\"foobar\" + newString(MIN_HIGH_SURROGATE), 6);\n",
        "113": "    testEncodedLengthFails(newString(MIN_LOW_SURROGATE), 0);\n",
        "114": "    testEncodedLengthFails(\"foobar\" + newString(MIN_LOW_SURROGATE), 6);\n",
        "115": "    testEncodedLengthFails(newString(MIN_HIGH_SURROGATE, MIN_HIGH_SURROGATE), 0);\n",
        "116": "  }\n",
        "117": "\n",
        "118": "  @SuppressWarnings(\"CheckReturnValue\")\n",
        "119": "  private static void testEncodedLengthFails(String invalidString,\n",
        "120": "      int invalidCodePointIndex) {\n",
        "121": "    try {\n",
        "122": "      Utf8.encodedLength(invalidString);\n",
        "123": "      fail();\n",
        "124": "    } catch (IllegalArgumentException expected) {\n",
        "125": "      assertThat(expected).hasMessage(\"Unpaired surrogate at index \" + invalidCodePointIndex);\n",
        "126": "    }\n",
        "127": "  }\n",
        "128": "\n",
        "129": "  // 128 - [chars 0x0000 to 0x007f]\n",
        "130": "  private static final long ONE_BYTE_ROUNDTRIPPABLE_CHARACTERS =\n",
        "131": "      0x007f - 0x0000 + 1;\n",
        "132": "\n",
        "133": "  // 128\n",
        "134": "  private static final long EXPECTED_ONE_BYTE_ROUNDTRIPPABLE_COUNT =\n",
        "135": "      ONE_BYTE_ROUNDTRIPPABLE_CHARACTERS;\n",
        "136": "\n",
        "137": "  // 1920 [chars 0x0080 to 0x07FF]\n",
        "138": "  private static final long TWO_BYTE_ROUNDTRIPPABLE_CHARACTERS =\n",
        "139": "      0x07FF - 0x0080 + 1;\n",
        "140": "\n",
        "141": "  // 18,304\n",
        "142": "  private static final long EXPECTED_TWO_BYTE_ROUNDTRIPPABLE_COUNT =\n",
        "143": "      // Both bytes are one byte characters\n",
        "144": "      (long) Math.pow(EXPECTED_ONE_BYTE_ROUNDTRIPPABLE_COUNT, 2) +\n",
        "145": "      // The possible number of two byte characters\n",
        "146": "      TWO_BYTE_ROUNDTRIPPABLE_CHARACTERS;\n",
        "147": "\n",
        "148": "  // 2048\n",
        "149": "  private static final long THREE_BYTE_SURROGATES = 2 * 1024;\n",
        "150": "\n",
        "151": "  // 61,440 [chars 0x0800 to 0xFFFF, minus surrogates]\n",
        "152": "  private static final long THREE_BYTE_ROUNDTRIPPABLE_CHARACTERS =\n",
        "153": "      0xFFFF - 0x0800 + 1 - THREE_BYTE_SURROGATES;\n",
        "154": "\n",
        "155": "  // 2,650,112\n",
        "156": "  private static final long EXPECTED_THREE_BYTE_ROUNDTRIPPABLE_COUNT =\n",
        "157": "      // All one byte characters\n",
        "158": "      (long) Math.pow(EXPECTED_ONE_BYTE_ROUNDTRIPPABLE_COUNT, 3) +\n",
        "159": "      // One two byte character and a one byte character\n",
        "160": "      2 * TWO_BYTE_ROUNDTRIPPABLE_CHARACTERS *\n",
        "161": "          ONE_BYTE_ROUNDTRIPPABLE_CHARACTERS +\n",
        "162": "       // Three byte characters\n",
        "163": "      THREE_BYTE_ROUNDTRIPPABLE_CHARACTERS;\n",
        "164": "\n",
        "165": "  // 1,048,576 [chars 0x10000L to 0x10FFFF]\n",
        "166": "  private static final long FOUR_BYTE_ROUNDTRIPPABLE_CHARACTERS =\n",
        "167": "      0x10FFFF - 0x10000L + 1;\n",
        "168": "\n",
        "169": "  // 289,571,839\n",
        "170": "  private static final long EXPECTED_FOUR_BYTE_ROUNDTRIPPABLE_COUNT =\n",
        "171": "      // All one byte characters\n",
        "172": "      (long) Math.pow(EXPECTED_ONE_BYTE_ROUNDTRIPPABLE_COUNT, 4) +\n",
        "173": "      // One and three byte characters\n",
        "174": "      2 * THREE_BYTE_ROUNDTRIPPABLE_CHARACTERS *\n",
        "175": "          ONE_BYTE_ROUNDTRIPPABLE_CHARACTERS +\n",
        "176": "      // Two two byte characters\n",
        "177": "      TWO_BYTE_ROUNDTRIPPABLE_CHARACTERS * TWO_BYTE_ROUNDTRIPPABLE_CHARACTERS +\n",
        "178": "      // Permutations of one and two byte characters\n",
        "179": "      3 * TWO_BYTE_ROUNDTRIPPABLE_CHARACTERS *\n",
        "180": "          ONE_BYTE_ROUNDTRIPPABLE_CHARACTERS *\n",
        "181": "          ONE_BYTE_ROUNDTRIPPABLE_CHARACTERS +\n",
        "182": "      // Four byte characters\n",
        "183": "      FOUR_BYTE_ROUNDTRIPPABLE_CHARACTERS;\n",
        "184": "\n",
        "185": "  /**\n",
        "186": "   * Tests that round tripping of a sample of four byte permutations work.\n",
        "187": "   * All permutations are prohibitively expensive to test for automated runs.\n",
        "188": "   * This method tests specific four-byte cases.\n",
        "189": "   */\n",
        "190": "  public void testIsWellFormed_4BytesSamples() {\n",
        "191": "    // Valid 4 byte.\n",
        "192": "    assertWellFormed(0xF0, 0xA4, 0xAD, 0xA2);\n",
        "193": "    // Bad trailing bytes\n",
        "194": "    assertNotWellFormed(0xF0, 0xA4, 0xAD, 0x7F);\n",
        "195": "    assertNotWellFormed(0xF0, 0xA4, 0xAD, 0xC0);\n",
        "196": "    // Special cases for byte2\n",
        "197": "    assertNotWellFormed(0xF0, 0x8F, 0xAD, 0xA2);\n",
        "198": "    assertNotWellFormed(0xF4, 0x90, 0xAD, 0xA2);\n",
        "199": "  }\n",
        "200": "\n",
        "201": "  /** Tests some hard-coded test cases. */\n",
        "202": "  public void testSomeSequences() {\n",
        "203": "    // Empty\n",
        "204": "    assertWellFormed();\n",
        "205": "    // One-byte characters, including control characters\n",
        "206": "    assertWellFormed(0x00, 0x61, 0x62, 0x63, 0x7F); // \"\\u0000abc\\u007f\"\n",
        "207": "    // Two-byte characters\n",
        "208": "    assertWellFormed(0xC2, 0xA2, 0xC2, 0xA2); // \"\\u00a2\\u00a2\"\n",
        "209": "    // Three-byte characters\n",
        "210": "    assertWellFormed(0xc8, 0x8a, 0x63, 0xc8, 0x8a, 0x63); // \"\\u020ac\\u020ac\"\n",
        "211": "    // Four-byte characters\n",
        "212": "    // \"\\u024B62\\u024B62\"\n",
        "213": "    assertWellFormed(0xc9, 0x8b, 0x36, 0x32, 0xc9, 0x8b, 0x36, 0x32);\n",
        "214": "    // Mixed string\n",
        "215": "    // \"a\\u020ac\\u00a2b\\\\u024B62u020acc\\u00a2de\\u024B62\"\n",
        "216": "    assertWellFormed(0x61, 0xc8, 0x8a, 0x63, 0xc2, 0xa2, 0x62, 0x5c, 0x75, 0x30,\n",
        "217": "        0x32, 0x34, 0x42, 0x36, 0x32, 0x75, 0x30, 0x32, 0x30, 0x61, 0x63, 0x63,\n",
        "218": "        0xc2, 0xa2, 0x64, 0x65, 0xc9, 0x8b, 0x36, 0x32);\n",
        "219": "    // Not a valid string\n",
        "220": "    assertNotWellFormed(-1, 0, -1, 0);\n",
        "221": "  }\n",
        "222": "\n",
        "223": "  public void testShardsHaveExpectedRoundTrippables() {\n",
        "224": "    // A sanity check.\n",
        "225": "    long actual = 0;\n",
        "226": "    for (long expected : generateFourByteShardsExpectedRunnables()) {\n",
        "227": "      actual += expected;\n",
        "228": "    }\n",
        "229": "    assertEquals(EXPECTED_FOUR_BYTE_ROUNDTRIPPABLE_COUNT, actual);\n",
        "230": "  }\n",
        "231": "\n",
        "232": "  private static String newString(char... chars) {\n",
        "233": "    return new String(chars);\n",
        "234": "  }\n",
        "235": "\n",
        "236": "  private static byte[] toByteArray(int... bytes) {\n",
        "237": "    byte[] realBytes = new byte[bytes.length];\n",
        "238": "    for (int i = 0; i < bytes.length; i++) {\n",
        "239": "      realBytes[i] = (byte) bytes[i];\n",
        "240": "    }\n",
        "241": "    return realBytes;\n",
        "242": "  }\n",
        "243": "\n",
        "244": "  private static void assertWellFormed(int... bytes) {\n",
        "245": "    assertTrue(Utf8.isWellFormed(toByteArray(bytes)));\n",
        "246": "  }\n",
        "247": "\n",
        "248": "  private static void assertNotWellFormed(int... bytes) {\n",
        "249": "    assertFalse(Utf8.isWellFormed(toByteArray(bytes)));\n",
        "250": "  }\n",
        "251": "\n",
        "252": "  private static long[] generateFourByteShardsExpectedRunnables() {\n",
        "253": "    long[] expected = new long[128];\n",
        "254": "    // 0-63 are all 5300224\n",
        "255": "    for (int i = 0; i <= 63; i++) {\n",
        "256": "      expected[i] = 5300224;\n",
        "257": "    }\n",
        "258": "    // 97-111 are all 2342912\n",
        "259": "    for (int i = 97; i <= 111; i++) {\n",
        "260": "     expected[i] = 2342912;\n",
        "261": "    }\n",
        "262": "    // 113-117 are all 1048576\n",
        "263": "    for (int i = 113; i <= 117; i++) {\n",
        "264": "      expected[i] = 1048576;\n",
        "265": "    }\n",
        "266": "    // One offs\n",
        "267": "    expected[112] = 786432;\n",
        "268": "    expected[118] = 786432;\n",
        "269": "    expected[119] = 1048576;\n",
        "270": "    expected[120] = 458752;\n",
        "271": "    expected[121] = 524288;\n",
        "272": "    expected[122] = 65536;\n",
        "273": "    // Anything not assigned was the default 0.\n",
        "274": "    return expected;\n",
        "275": "  }\n",
        "276": "}\n"
    }
}