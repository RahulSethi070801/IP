{
    "addition": {},
    "removed": {
        "1": "/*\n",
        "2": " * Copyright (C) 2011 The Guava Authors\n",
        "3": " *\n",
        "4": " * Licensed under the Apache License, Version 2.0 (the \"License\");\n",
        "5": " * you may not use this file except in compliance with the License.\n",
        "6": " * You may obtain a copy of the License at\n",
        "7": " *\n",
        "8": " * http://www.apache.org/licenses/LICENSE-2.0\n",
        "9": " *\n",
        "10": " * Unless required by applicable law or agreed to in writing, software\n",
        "11": " * distributed under the License is distributed on an \"AS IS\" BASIS,\n",
        "12": " * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n",
        "13": " * See the License for the specific language governing permissions and\n",
        "14": " * limitations under the License.\n",
        "15": " */\n",
        "16": "\n",
        "17": "package com.google.common.math;\n",
        "18": "\n",
        "19": "import static com.google.common.base.Preconditions.checkArgument;\n",
        "20": "import static com.google.common.math.MathPreconditions.checkNonNegative;\n",
        "21": "import static java.lang.Math.log;\n",
        "22": "\n",
        "23": "import com.google.common.annotations.GwtCompatible;\n",
        "24": "import com.google.common.annotations.VisibleForTesting;\n",
        "25": "import com.google.common.primitives.Booleans;\n",
        "26": "\n",
        "27": "/**\n",
        "28": " * A class for arithmetic on doubles that is not covered by {@link java.lang.Math}.\n",
        "29": " *\n",
        "30": " * @author Louis Wasserman\n",
        "31": " * @since 11.0\n",
        "32": " */\n",
        "33": "@GwtCompatible(emulated = true)\n",
        "34": "public final class DoubleMath {\n",
        "35": "  /*\n",
        "36": "   * This method returns a value y such that rounding y DOWN (towards zero) gives the same result\n",
        "37": "   * as rounding x according to the specified mode.\n",
        "38": "   */\n",
        "39": "\n",
        "40": "  private static final double MIN_INT_AS_DOUBLE = -0x1p31;\n",
        "41": "  private static final double MAX_INT_AS_DOUBLE = 0x1p31 - 1.0;\n",
        "42": "\n",
        "43": "  private static final double MIN_LONG_AS_DOUBLE = -0x1p63;\n",
        "44": "  /*\n",
        "45": "   * We cannot store Long.MAX_VALUE as a double without losing precision.  Instead, we store\n",
        "46": "   * Long.MAX_VALUE + 1 == -Long.MIN_VALUE, and then offset all comparisons by 1.\n",
        "47": "   */\n",
        "48": "  private static final double MAX_LONG_AS_DOUBLE_PLUS_ONE = 0x1p63;\n",
        "49": "\n",
        "50": "  /**\n",
        "51": "   * Returns the base 2 logarithm of a double value.\n",
        "52": "   *\n",
        "53": "   * <p>Special cases:\n",
        "54": "   * <ul>\n",
        "55": "   * <li>If {@code x} is NaN or less than zero, the result is NaN.\n",
        "56": "   * <li>If {@code x} is positive infinity, the result is positive infinity.\n",
        "57": "   * <li>If {@code x} is positive or negative zero, the result is negative infinity.\n",
        "58": "   * </ul>\n",
        "59": "   *\n",
        "60": "   * <p>The computed result is within 1 ulp of the exact result.\n",
        "61": "   *\n",
        "62": "   * <p>If the result of this method will be immediately rounded to an {@code int},\n",
        "63": "   * {@link #log2(double, RoundingMode)} is faster.\n",
        "64": "   */\n",
        "65": "  public static double log2(double x) {\n",
        "66": "    return log(x) / LN_2; // surprisingly within 1 ulp according to tests\n",
        "67": "  }\n",
        "68": "\n",
        "69": "  private static final double LN_2 = log(2);\n",
        "70": "\n",
        "71": "  /**\n",
        "72": "   * Returns {@code n!}, that is, the product of the first {@code n} positive\n",
        "73": "   * integers, {@code 1} if {@code n == 0}, or {@code n!}, or\n",
        "74": "   * {@link Double#POSITIVE_INFINITY} if {@code n! > Double.MAX_VALUE}.\n",
        "75": "   *\n",
        "76": "   * <p>The result is within 1 ulp of the true value.\n",
        "77": "   *\n",
        "78": "   * @throws IllegalArgumentException if {@code n < 0}\n",
        "79": "   */\n",
        "80": "  public static double factorial(int n) {\n",
        "81": "    checkNonNegative(\"n\", n);\n",
        "82": "    if (n > MAX_FACTORIAL) {\n",
        "83": "      return Double.POSITIVE_INFINITY;\n",
        "84": "    } else {\n",
        "85": "      // Multiplying the last (n & 0xf) values into their own accumulator gives a more accurate\n",
        "86": "      // result than multiplying by everySixteenthFactorial[n >> 4] directly.\n",
        "87": "      double accum = 1.0;\n",
        "88": "      for (int i = 1 + (n & ~0xf); i <= n; i++) {\n",
        "89": "        accum *= i;\n",
        "90": "      }\n",
        "91": "      return accum * everySixteenthFactorial[n >> 4];\n",
        "92": "    }\n",
        "93": "  }\n",
        "94": "\n",
        "95": "  @VisibleForTesting\n",
        "96": "  static final int MAX_FACTORIAL = 170;\n",
        "97": "\n",
        "98": "  @VisibleForTesting\n",
        "99": "  static final double[] everySixteenthFactorial = {\n",
        "100": "      0x1.0p0,\n",
        "101": "      0x1.30777758p44,\n",
        "102": "      0x1.956ad0aae33a4p117,\n",
        "103": "      0x1.ee69a78d72cb6p202,\n",
        "104": "      0x1.fe478ee34844ap295,\n",
        "105": "      0x1.c619094edabffp394,\n",
        "106": "      0x1.3638dd7bd6347p498,\n",
        "107": "      0x1.7cac197cfe503p605,\n",
        "108": "      0x1.1e5dfc140e1e5p716,\n",
        "109": "      0x1.8ce85fadb707ep829,\n",
        "110": "      0x1.95d5f3d928edep945};\n",
        "111": "\n",
        "112": "  /**\n",
        "113": "   * Returns {@code true} if {@code a} and {@code b} are within {@code tolerance} of each other.\n",
        "114": "   *\n",
        "115": "   * <p>Technically speaking, this is equivalent to\n",
        "116": "   * {@code Math.abs(a - b) <= tolerance || Double.valueOf(a).equals(Double.valueOf(b))}.\n",
        "117": "   *\n",
        "118": "   * <p>Notable special cases include:\n",
        "119": "   * <ul>\n",
        "120": "   * <li>All NaNs are fuzzily equal.\n",
        "121": "   * <li>If {@code a == b}, then {@code a} and {@code b} are always fuzzily equal.\n",
        "122": "   * <li>Positive and negative zero are always fuzzily equal.\n",
        "123": "   * <li>If {@code tolerance} is zero, and neither {@code a} nor {@code b} is NaN, then\n",
        "124": "   * {@code a} and {@code b} are fuzzily equal if and only if {@code a == b}.\n",
        "125": "   * <li>With {@link Double#POSITIVE_INFINITY} tolerance, all non-NaN values are fuzzily equal.\n",
        "126": "   * <li>With finite tolerance, {@code Double.POSITIVE_INFINITY} and {@code\n",
        "127": "   * Double.NEGATIVE_INFINITY} are fuzzily equal only to themselves.\n",
        "128": "   * </li>\n",
        "129": "   *\n",
        "130": "   * <p>This is reflexive and symmetric, but <em>not</em> transitive, so it is <em>not</em> an\n",
        "131": "   * equivalence relation and <em>not</em> suitable for use in {@link Object#equals}\n",
        "132": "   * implementations.\n",
        "133": "   *\n",
        "134": "   * @throws IllegalArgumentException if {@code tolerance} is {@code < 0} or NaN\n",
        "135": "   * @since 13.0\n",
        "136": "   */\n",
        "137": "  public static boolean fuzzyEquals(double a, double b, double tolerance) {\n",
        "138": "    MathPreconditions.checkNonNegative(\"tolerance\", tolerance);\n",
        "139": "    return\n",
        "140": "          Math.copySign(a - b, 1.0) <= tolerance\n",
        "141": "           // copySign(x, 1.0) is a branch-free version of abs(x), but with different NaN semantics\n",
        "142": "          || (a == b) // needed to ensure that infinities equal themselves\n",
        "143": "          || (Double.isNaN(a) && Double.isNaN(b));\n",
        "144": "  }\n",
        "145": "\n",
        "146": "  /**\n",
        "147": "   * Compares {@code a} and {@code b} \"fuzzily,\" with a tolerance for nearly-equal values.\n",
        "148": "   *\n",
        "149": "   * <p>This method is equivalent to\n",
        "150": "   * {@code fuzzyEquals(a, b, tolerance) ? 0 : Double.compare(a, b)}. In particular, like\n",
        "151": "   * {@link Double#compare(double, double)}, it treats all NaN values as equal and greater than all\n",
        "152": "   * other values (including {@link Double#POSITIVE_INFINITY}).\n",
        "153": "   *\n",
        "154": "   * <p>This is <em>not</em> a total ordering and is <em>not</em> suitable for use in\n",
        "155": "   * {@link Comparable#compareTo} implementations.  In particular, it is not transitive.\n",
        "156": "   *\n",
        "157": "   * @throws IllegalArgumentException if {@code tolerance} is {@code < 0} or NaN\n",
        "158": "   * @since 13.0\n",
        "159": "   */\n",
        "160": "  public static int fuzzyCompare(double a, double b, double tolerance) {\n",
        "161": "    if (fuzzyEquals(a, b, tolerance)) {\n",
        "162": "      return 0;\n",
        "163": "    } else if (a < b) {\n",
        "164": "      return -1;\n",
        "165": "    } else if (a > b) {\n",
        "166": "      return 1;\n",
        "167": "    } else {\n",
        "168": "      return Booleans.compare(Double.isNaN(a), Double.isNaN(b));\n",
        "169": "    }\n",
        "170": "  }\n",
        "171": "\n",
        "172": "  /**\n",
        "173": "   * Returns the <a href=\"http://en.wikipedia.org/wiki/Arithmetic_mean\">arithmetic mean</a> of\n",
        "174": "   * {@code values}.\n",
        "175": "   *\n",
        "176": "   * <p>If these values are a sample drawn from a population, this is also an unbiased estimator of\n",
        "177": "   * the arithmetic mean of the population.\n",
        "178": "   *\n",
        "179": "   * @param values a nonempty series of values\n",
        "180": "   * @throws IllegalArgumentException if {@code values} is empty\n",
        "181": "   */\n",
        "182": "  public static double mean(int... values) {\n",
        "183": "    checkArgument(values.length > 0, \"Cannot take mean of 0 values\");\n",
        "184": "    // The upper bound on the the length of an array and the bounds on the int values mean that, in\n",
        "185": "    // this case only, we can compute the sum as a long without risking overflow or loss of\n",
        "186": "    // precision. So we do that, as it's slightly quicker than the Knuth algorithm.\n",
        "187": "    long sum = 0;\n",
        "188": "    for (int index = 0; index < values.length; ++index) {\n",
        "189": "      sum += values[index];\n",
        "190": "    }\n",
        "191": "    return (double) sum / values.length;\n",
        "192": "  }\n",
        "193": "\n",
        "194": "  /**\n",
        "195": "   * Returns the <a href=\"http://en.wikipedia.org/wiki/Arithmetic_mean\">arithmetic mean</a> of\n",
        "196": "   * {@code values}.\n",
        "197": "   *\n",
        "198": "   * <p>If these values are a sample drawn from a population, this is also an unbiased estimator of\n",
        "199": "   * the arithmetic mean of the population.\n",
        "200": "   *\n",
        "201": "   * @param values a nonempty series of values, which will be converted to {@code double} values\n",
        "202": "   *     (this may cause loss of precision for longs of magnitude over 2^53 (slightly over 9e15))\n",
        "203": "   * @throws IllegalArgumentException if {@code values} is empty\n",
        "204": "   */\n",
        "205": "  public static double mean(long... values) {\n",
        "206": "    checkArgument(values.length > 0, \"Cannot take mean of 0 values\");\n",
        "207": "    long count = 1;\n",
        "208": "    double mean = values[0];\n",
        "209": "    for (int index = 1; index < values.length; ++index) {\n",
        "210": "      count++;\n",
        "211": "      // Art of Computer Programming vol. 2, Knuth, 4.2.2, (15)\n",
        "212": "      mean += (values[index] - mean) / count;\n",
        "213": "    }\n",
        "214": "    return mean;\n",
        "215": "  }\n",
        "216": "\n",
        "217": "  private DoubleMath() {}\n",
        "218": "}\n",
        "219": "\n"
    }
}