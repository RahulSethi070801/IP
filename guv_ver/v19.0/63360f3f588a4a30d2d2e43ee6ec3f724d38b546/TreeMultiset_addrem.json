{
    "addition": {},
    "removed": {
        "1": "/*\n",
        "2": " * Copyright (C) 2007 The Guava Authors\n",
        "3": " *\n",
        "4": " * Licensed under the Apache License, Version 2.0 (the \"License\");\n",
        "5": " * you may not use this file except in compliance with the License.\n",
        "6": " * You may obtain a copy of the License at\n",
        "7": " *\n",
        "8": " * http://www.apache.org/licenses/LICENSE-2.0\n",
        "9": " *\n",
        "10": " * Unless required by applicable law or agreed to in writing, software\n",
        "11": " * distributed under the License is distributed on an \"AS IS\" BASIS,\n",
        "12": " * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n",
        "13": " * See the License for the specific language governing permissions and\n",
        "14": " * limitations under the License.\n",
        "15": " */\n",
        "16": "\n",
        "17": "package com.google.common.collect;\n",
        "18": "\n",
        "19": "import static com.google.common.base.Preconditions.checkArgument;\n",
        "20": "import static com.google.common.base.Preconditions.checkState;\n",
        "21": "import static com.google.common.collect.CollectPreconditions.checkNonnegative;\n",
        "22": "import static com.google.common.collect.CollectPreconditions.checkRemove;\n",
        "23": "\n",
        "24": "import com.google.common.annotations.GwtCompatible;\n",
        "25": "import com.google.common.base.MoreObjects;\n",
        "26": "import com.google.common.primitives.Ints;\n",
        "27": "\n",
        "28": "import java.io.Serializable;\n",
        "29": "import java.util.Comparator;\n",
        "30": "import java.util.ConcurrentModificationException;\n",
        "31": "import java.util.Iterator;\n",
        "32": "import java.util.NoSuchElementException;\n",
        "33": "\n",
        "34": "import javax.annotation.Nullable;\n",
        "35": "\n",
        "36": "/**\n",
        "37": " * A multiset which maintains the ordering of its elements, according to either their natural order\n",
        "38": " * or an explicit {@link Comparator}. In all cases, this implementation uses\n",
        "39": " * {@link Comparable#compareTo} or {@link Comparator#compare} instead of {@link Object#equals} to\n",
        "40": " * determine equivalence of instances.\n",
        "41": " *\n",
        "42": " * <p><b>Warning:</b> The comparison must be <i>consistent with equals</i> as explained by the\n",
        "43": " * {@link Comparable} class specification. Otherwise, the resulting multiset will violate the\n",
        "44": " * {@link java.util.Collection} contract, which is specified in terms of {@link Object#equals}.\n",
        "45": " *\n",
        "46": " * <p>See the Guava User Guide article on <a href=\n",
        "47": " * \"https://github.com/google/guava/wiki/NewCollectionTypesExplained#multiset\">\n",
        "48": " * {@code Multiset}</a>.\n",
        "49": " *\n",
        "50": " * @author Louis Wasserman\n",
        "51": " * @author Jared Levy\n",
        "52": " * @since 2.0\n",
        "53": " */\n",
        "54": "@GwtCompatible(emulated = true)\n",
        "55": "public final class TreeMultiset<E> extends AbstractSortedMultiset<E> implements Serializable {\n",
        "56": "\n",
        "57": "  /**\n",
        "58": "   * Creates a new, empty multiset, sorted according to the elements' natural order. All elements\n",
        "59": "   * inserted into the multiset must implement the {@code Comparable} interface. Furthermore, all\n",
        "60": "   * such elements must be <i>mutually comparable</i>: {@code e1.compareTo(e2)} must not throw a\n",
        "61": "   * {@code ClassCastException} for any elements {@code e1} and {@code e2} in the multiset. If the\n",
        "62": "   * user attempts to add an element to the multiset that violates this constraint (for example,\n",
        "63": "   * the user attempts to add a string element to a set whose elements are integers), the\n",
        "64": "   * {@code add(Object)} call will throw a {@code ClassCastException}.\n",
        "65": "   *\n",
        "66": "   * <p>The type specification is {@code <E extends Comparable>}, instead of the more specific\n",
        "67": "   * {@code <E extends Comparable<? super E>>}, to support classes defined without generics.\n",
        "68": "   */\n",
        "69": "  public static <E extends Comparable> TreeMultiset<E> create() {\n",
        "70": "    return new TreeMultiset<E>(Ordering.natural());\n",
        "71": "  }\n",
        "72": "\n",
        "73": "  /**\n",
        "74": "   * Creates a new, empty multiset, sorted according to the specified comparator. All elements\n",
        "75": "   * inserted into the multiset must be <i>mutually comparable</i> by the specified comparator:\n",
        "76": "   * {@code comparator.compare(e1,\n",
        "77": "   * e2)} must not throw a {@code ClassCastException} for any elements {@code e1} and {@code e2} in\n",
        "78": "   * the multiset. If the user attempts to add an element to the multiset that violates this\n",
        "79": "   * constraint, the {@code add(Object)} call will throw a {@code ClassCastException}.\n",
        "80": "   *\n",
        "81": "   * @param comparator\n",
        "82": "   *          the comparator that will be used to sort this multiset. A null value indicates that\n",
        "83": "   *          the elements' <i>natural ordering</i> should be used.\n",
        "84": "   */\n",
        "85": "  @SuppressWarnings(\"unchecked\")\n",
        "86": "  public static <E> TreeMultiset<E> create(@Nullable Comparator<? super E> comparator) {\n",
        "87": "    return (comparator == null)\n",
        "88": "        ? new TreeMultiset<E>((Comparator) Ordering.natural())\n",
        "89": "        : new TreeMultiset<E>(comparator);\n",
        "90": "  }\n",
        "91": "\n",
        "92": "  /**\n",
        "93": "   * Creates an empty multiset containing the given initial elements, sorted according to the\n",
        "94": "   * elements' natural order.\n",
        "95": "   *\n",
        "96": "   * <p>This implementation is highly efficient when {@code elements} is itself a {@link Multiset}.\n",
        "97": "   *\n",
        "98": "   * <p>The type specification is {@code <E extends Comparable>}, instead of the more specific\n",
        "99": "   * {@code <E extends Comparable<? super E>>}, to support classes defined without generics.\n",
        "100": "   */\n",
        "101": "  public static <E extends Comparable> TreeMultiset<E> create(Iterable<? extends E> elements) {\n",
        "102": "    TreeMultiset<E> multiset = create();\n",
        "103": "    Iterables.addAll(multiset, elements);\n",
        "104": "    return multiset;\n",
        "105": "  }\n",
        "106": "\n",
        "107": "  private final transient Reference<AvlNode<E>> rootReference;\n",
        "108": "  private final transient GeneralRange<E> range;\n",
        "109": "  private final transient AvlNode<E> header;\n",
        "110": "\n",
        "111": "  TreeMultiset(Reference<AvlNode<E>> rootReference, GeneralRange<E> range, AvlNode<E> endLink) {\n",
        "112": "    super(range.comparator());\n",
        "113": "    this.rootReference = rootReference;\n",
        "114": "    this.range = range;\n",
        "115": "    this.header = endLink;\n",
        "116": "  }\n",
        "117": "\n",
        "118": "  TreeMultiset(Comparator<? super E> comparator) {\n",
        "119": "    super(comparator);\n",
        "120": "    this.range = GeneralRange.all(comparator);\n",
        "121": "    this.header = new AvlNode<E>(null, 1);\n",
        "122": "    successor(header, header);\n",
        "123": "    this.rootReference = new Reference<AvlNode<E>>();\n",
        "124": "  }\n",
        "125": "\n",
        "126": "  /**\n",
        "127": "   * A function which can be summed across a subtree.\n",
        "128": "   */\n",
        "129": "  private enum Aggregate {\n",
        "130": "    SIZE {\n",
        "131": "      @Override\n",
        "132": "      int nodeAggregate(AvlNode<?> node) {\n",
        "133": "        return node.elemCount;\n",
        "134": "      }\n",
        "135": "\n",
        "136": "      @Override\n",
        "137": "      long treeAggregate(@Nullable AvlNode<?> root) {\n",
        "138": "        return (root == null) ? 0 : root.totalCount;\n",
        "139": "      }\n",
        "140": "    },\n",
        "141": "    DISTINCT {\n",
        "142": "      @Override\n",
        "143": "      int nodeAggregate(AvlNode<?> node) {\n",
        "144": "        return 1;\n",
        "145": "      }\n",
        "146": "\n",
        "147": "      @Override\n",
        "148": "      long treeAggregate(@Nullable AvlNode<?> root) {\n",
        "149": "        return (root == null) ? 0 : root.distinctElements;\n",
        "150": "      }\n",
        "151": "    };\n",
        "152": "\n",
        "153": "    abstract int nodeAggregate(AvlNode<?> node);\n",
        "154": "\n",
        "155": "    abstract long treeAggregate(@Nullable AvlNode<?> root);\n",
        "156": "  }\n",
        "157": "\n",
        "158": "  private long aggregateForEntries(Aggregate aggr) {\n",
        "159": "    AvlNode<E> root = rootReference.get();\n",
        "160": "    long total = aggr.treeAggregate(root);\n",
        "161": "    if (range.hasLowerBound()) {\n",
        "162": "      total -= aggregateBelowRange(aggr, root);\n",
        "163": "    }\n",
        "164": "    if (range.hasUpperBound()) {\n",
        "165": "      total -= aggregateAboveRange(aggr, root);\n",
        "166": "    }\n",
        "167": "    return total;\n",
        "168": "  }\n",
        "169": "\n",
        "170": "  private long aggregateBelowRange(Aggregate aggr, @Nullable AvlNode<E> node) {\n",
        "171": "    if (node == null) {\n",
        "172": "      return 0;\n",
        "173": "    }\n",
        "174": "    int cmp = comparator().compare(range.getLowerEndpoint(), node.elem);\n",
        "175": "    if (cmp < 0) {\n",
        "176": "      return aggregateBelowRange(aggr, node.left);\n",
        "177": "    } else if (cmp == 0) {\n",
        "178": "      switch (range.getLowerBoundType()) {\n",
        "179": "        case OPEN:\n",
        "180": "          return aggr.nodeAggregate(node) + aggr.treeAggregate(node.left);\n",
        "181": "        case CLOSED:\n",
        "182": "          return aggr.treeAggregate(node.left);\n",
        "183": "        default:\n",
        "184": "          throw new AssertionError();\n",
        "185": "      }\n",
        "186": "    } else {\n",
        "187": "      return aggr.treeAggregate(node.left)\n",
        "188": "          + aggr.nodeAggregate(node)\n",
        "189": "          + aggregateBelowRange(aggr, node.right);\n",
        "190": "    }\n",
        "191": "  }\n",
        "192": "\n",
        "193": "  private long aggregateAboveRange(Aggregate aggr, @Nullable AvlNode<E> node) {\n",
        "194": "    if (node == null) {\n",
        "195": "      return 0;\n",
        "196": "    }\n",
        "197": "    int cmp = comparator().compare(range.getUpperEndpoint(), node.elem);\n",
        "198": "    if (cmp > 0) {\n",
        "199": "      return aggregateAboveRange(aggr, node.right);\n",
        "200": "    } else if (cmp == 0) {\n",
        "201": "      switch (range.getUpperBoundType()) {\n",
        "202": "        case OPEN:\n",
        "203": "          return aggr.nodeAggregate(node) + aggr.treeAggregate(node.right);\n",
        "204": "        case CLOSED:\n",
        "205": "          return aggr.treeAggregate(node.right);\n",
        "206": "        default:\n",
        "207": "          throw new AssertionError();\n",
        "208": "      }\n",
        "209": "    } else {\n",
        "210": "      return aggr.treeAggregate(node.right)\n",
        "211": "          + aggr.nodeAggregate(node)\n",
        "212": "          + aggregateAboveRange(aggr, node.left);\n",
        "213": "    }\n",
        "214": "  }\n",
        "215": "\n",
        "216": "  @Override\n",
        "217": "  public int size() {\n",
        "218": "    return Ints.saturatedCast(aggregateForEntries(Aggregate.SIZE));\n",
        "219": "  }\n",
        "220": "\n",
        "221": "  @Override\n",
        "222": "  int distinctElements() {\n",
        "223": "    return Ints.saturatedCast(aggregateForEntries(Aggregate.DISTINCT));\n",
        "224": "  }\n",
        "225": "\n",
        "226": "  @Override\n",
        "227": "  public int count(@Nullable Object element) {\n",
        "228": "    try {\n",
        "229": "      @SuppressWarnings(\"unchecked\")\n",
        "230": "      E e = (E) element;\n",
        "231": "      AvlNode<E> root = rootReference.get();\n",
        "232": "      if (!range.contains(e) || root == null) {\n",
        "233": "        return 0;\n",
        "234": "      }\n",
        "235": "      return root.count(comparator(), e);\n",
        "236": "    } catch (ClassCastException e) {\n",
        "237": "      return 0;\n",
        "238": "    } catch (NullPointerException e) {\n",
        "239": "      return 0;\n",
        "240": "    }\n",
        "241": "  }\n",
        "242": "\n",
        "243": "  @Override\n",
        "244": "  public int add(@Nullable E element, int occurrences) {\n",
        "245": "    checkNonnegative(occurrences, \"occurrences\");\n",
        "246": "    if (occurrences == 0) {\n",
        "247": "      return count(element);\n",
        "248": "    }\n",
        "249": "    checkArgument(range.contains(element));\n",
        "250": "    AvlNode<E> root = rootReference.get();\n",
        "251": "    if (root == null) {\n",
        "252": "      comparator().compare(element, element);\n",
        "253": "      AvlNode<E> newRoot = new AvlNode<E>(element, occurrences);\n",
        "254": "      successor(header, newRoot, header);\n",
        "255": "      rootReference.checkAndSet(root, newRoot);\n",
        "256": "      return 0;\n",
        "257": "    }\n",
        "258": "    int[] result = new int[1]; // used as a mutable int reference to hold result\n",
        "259": "    AvlNode<E> newRoot = root.add(comparator(), element, occurrences, result);\n",
        "260": "    rootReference.checkAndSet(root, newRoot);\n",
        "261": "    return result[0];\n",
        "262": "  }\n",
        "263": "\n",
        "264": "  @Override\n",
        "265": "  public int remove(@Nullable Object element, int occurrences) {\n",
        "266": "    checkNonnegative(occurrences, \"occurrences\");\n",
        "267": "    if (occurrences == 0) {\n",
        "268": "      return count(element);\n",
        "269": "    }\n",
        "270": "    AvlNode<E> root = rootReference.get();\n",
        "271": "    int[] result = new int[1]; // used as a mutable int reference to hold result\n",
        "272": "    AvlNode<E> newRoot;\n",
        "273": "    try {\n",
        "274": "      @SuppressWarnings(\"unchecked\")\n",
        "275": "      E e = (E) element;\n",
        "276": "      if (!range.contains(e) || root == null) {\n",
        "277": "        return 0;\n",
        "278": "      }\n",
        "279": "      newRoot = root.remove(comparator(), e, occurrences, result);\n",
        "280": "    } catch (ClassCastException e) {\n",
        "281": "      return 0;\n",
        "282": "    } catch (NullPointerException e) {\n",
        "283": "      return 0;\n",
        "284": "    }\n",
        "285": "    rootReference.checkAndSet(root, newRoot);\n",
        "286": "    return result[0];\n",
        "287": "  }\n",
        "288": "\n",
        "289": "  @Override\n",
        "290": "  public int setCount(@Nullable E element, int count) {\n",
        "291": "    checkNonnegative(count, \"count\");\n",
        "292": "    if (!range.contains(element)) {\n",
        "293": "      checkArgument(count == 0);\n",
        "294": "      return 0;\n",
        "295": "    }\n",
        "296": "\n",
        "297": "    AvlNode<E> root = rootReference.get();\n",
        "298": "    if (root == null) {\n",
        "299": "      if (count > 0) {\n",
        "300": "        add(element, count);\n",
        "301": "      }\n",
        "302": "      return 0;\n",
        "303": "    }\n",
        "304": "    int[] result = new int[1]; // used as a mutable int reference to hold result\n",
        "305": "    AvlNode<E> newRoot = root.setCount(comparator(), element, count, result);\n",
        "306": "    rootReference.checkAndSet(root, newRoot);\n",
        "307": "    return result[0];\n",
        "308": "  }\n",
        "309": "\n",
        "310": "  @Override\n",
        "311": "  public boolean setCount(@Nullable E element, int oldCount, int newCount) {\n",
        "312": "    checkNonnegative(newCount, \"newCount\");\n",
        "313": "    checkNonnegative(oldCount, \"oldCount\");\n",
        "314": "    checkArgument(range.contains(element));\n",
        "315": "\n",
        "316": "    AvlNode<E> root = rootReference.get();\n",
        "317": "    if (root == null) {\n",
        "318": "      if (oldCount == 0) {\n",
        "319": "        if (newCount > 0) {\n",
        "320": "          add(element, newCount);\n",
        "321": "        }\n",
        "322": "        return true;\n",
        "323": "      } else {\n",
        "324": "        return false;\n",
        "325": "      }\n",
        "326": "    }\n",
        "327": "    int[] result = new int[1]; // used as a mutable int reference to hold result\n",
        "328": "    AvlNode<E> newRoot = root.setCount(comparator(), element, oldCount, newCount, result);\n",
        "329": "    rootReference.checkAndSet(root, newRoot);\n",
        "330": "    return result[0] == oldCount;\n",
        "331": "  }\n",
        "332": "\n",
        "333": "  private Entry<E> wrapEntry(final AvlNode<E> baseEntry) {\n",
        "334": "    return new Multisets.AbstractEntry<E>() {\n",
        "335": "      @Override\n",
        "336": "      public E getElement() {\n",
        "337": "        return baseEntry.getElement();\n",
        "338": "      }\n",
        "339": "\n",
        "340": "      @Override\n",
        "341": "      public int getCount() {\n",
        "342": "        int result = baseEntry.getCount();\n",
        "343": "        if (result == 0) {\n",
        "344": "          return count(getElement());\n",
        "345": "        } else {\n",
        "346": "          return result;\n",
        "347": "        }\n",
        "348": "      }\n",
        "349": "    };\n",
        "350": "  }\n",
        "351": "\n",
        "352": "  /**\n",
        "353": "   * Returns the first node in the tree that is in range.\n",
        "354": "   */\n",
        "355": "  @Nullable\n",
        "356": "  private AvlNode<E> firstNode() {\n",
        "357": "    AvlNode<E> root = rootReference.get();\n",
        "358": "    if (root == null) {\n",
        "359": "      return null;\n",
        "360": "    }\n",
        "361": "    AvlNode<E> node;\n",
        "362": "    if (range.hasLowerBound()) {\n",
        "363": "      E endpoint = range.getLowerEndpoint();\n",
        "364": "      node = rootReference.get().ceiling(comparator(), endpoint);\n",
        "365": "      if (node == null) {\n",
        "366": "        return null;\n",
        "367": "      }\n",
        "368": "      if (range.getLowerBoundType() == BoundType.OPEN\n",
        "369": "          && comparator().compare(endpoint, node.getElement()) == 0) {\n",
        "370": "        node = node.succ;\n",
        "371": "      }\n",
        "372": "    } else {\n",
        "373": "      node = header.succ;\n",
        "374": "    }\n",
        "375": "    return (node == header || !range.contains(node.getElement())) ? null : node;\n",
        "376": "  }\n",
        "377": "\n",
        "378": "  @Nullable\n",
        "379": "  private AvlNode<E> lastNode() {\n",
        "380": "    AvlNode<E> root = rootReference.get();\n",
        "381": "    if (root == null) {\n",
        "382": "      return null;\n",
        "383": "    }\n",
        "384": "    AvlNode<E> node;\n",
        "385": "    if (range.hasUpperBound()) {\n",
        "386": "      E endpoint = range.getUpperEndpoint();\n",
        "387": "      node = rootReference.get().floor(comparator(), endpoint);\n",
        "388": "      if (node == null) {\n",
        "389": "        return null;\n",
        "390": "      }\n",
        "391": "      if (range.getUpperBoundType() == BoundType.OPEN\n",
        "392": "          && comparator().compare(endpoint, node.getElement()) == 0) {\n",
        "393": "        node = node.pred;\n",
        "394": "      }\n",
        "395": "    } else {\n",
        "396": "      node = header.pred;\n",
        "397": "    }\n",
        "398": "    return (node == header || !range.contains(node.getElement())) ? null : node;\n",
        "399": "  }\n",
        "400": "\n",
        "401": "  @Override\n",
        "402": "  Iterator<Entry<E>> entryIterator() {\n",
        "403": "    return new Iterator<Entry<E>>() {\n",
        "404": "      AvlNode<E> current = firstNode();\n",
        "405": "      Entry<E> prevEntry;\n",
        "406": "\n",
        "407": "      @Override\n",
        "408": "      public boolean hasNext() {\n",
        "409": "        if (current == null) {\n",
        "410": "          return false;\n",
        "411": "        } else if (range.tooHigh(current.getElement())) {\n",
        "412": "          current = null;\n",
        "413": "          return false;\n",
        "414": "        } else {\n",
        "415": "          return true;\n",
        "416": "        }\n",
        "417": "      }\n",
        "418": "\n",
        "419": "      @Override\n",
        "420": "      public Entry<E> next() {\n",
        "421": "        if (!hasNext()) {\n",
        "422": "          throw new NoSuchElementException();\n",
        "423": "        }\n",
        "424": "        Entry<E> result = wrapEntry(current);\n",
        "425": "        prevEntry = result;\n",
        "426": "        if (current.succ == header) {\n",
        "427": "          current = null;\n",
        "428": "        } else {\n",
        "429": "          current = current.succ;\n",
        "430": "        }\n",
        "431": "        return result;\n",
        "432": "      }\n",
        "433": "\n",
        "434": "      @Override\n",
        "435": "      public void remove() {\n",
        "436": "        checkRemove(prevEntry != null);\n",
        "437": "        setCount(prevEntry.getElement(), 0);\n",
        "438": "        prevEntry = null;\n",
        "439": "      }\n",
        "440": "    };\n",
        "441": "  }\n",
        "442": "\n",
        "443": "  @Override\n",
        "444": "  Iterator<Entry<E>> descendingEntryIterator() {\n",
        "445": "    return new Iterator<Entry<E>>() {\n",
        "446": "      AvlNode<E> current = lastNode();\n",
        "447": "      Entry<E> prevEntry = null;\n",
        "448": "\n",
        "449": "      @Override\n",
        "450": "      public boolean hasNext() {\n",
        "451": "        if (current == null) {\n",
        "452": "          return false;\n",
        "453": "        } else if (range.tooLow(current.getElement())) {\n",
        "454": "          current = null;\n",
        "455": "          return false;\n",
        "456": "        } else {\n",
        "457": "          return true;\n",
        "458": "        }\n",
        "459": "      }\n",
        "460": "\n",
        "461": "      @Override\n",
        "462": "      public Entry<E> next() {\n",
        "463": "        if (!hasNext()) {\n",
        "464": "          throw new NoSuchElementException();\n",
        "465": "        }\n",
        "466": "        Entry<E> result = wrapEntry(current);\n",
        "467": "        prevEntry = result;\n",
        "468": "        if (current.pred == header) {\n",
        "469": "          current = null;\n",
        "470": "        } else {\n",
        "471": "          current = current.pred;\n",
        "472": "        }\n",
        "473": "        return result;\n",
        "474": "      }\n",
        "475": "\n",
        "476": "      @Override\n",
        "477": "      public void remove() {\n",
        "478": "        checkRemove(prevEntry != null);\n",
        "479": "        setCount(prevEntry.getElement(), 0);\n",
        "480": "        prevEntry = null;\n",
        "481": "      }\n",
        "482": "    };\n",
        "483": "  }\n",
        "484": "\n",
        "485": "  @Override\n",
        "486": "  public SortedMultiset<E> headMultiset(@Nullable E upperBound, BoundType boundType) {\n",
        "487": "    return new TreeMultiset<E>(\n",
        "488": "        rootReference,\n",
        "489": "        range.intersect(GeneralRange.upTo(comparator(), upperBound, boundType)),\n",
        "490": "        header);\n",
        "491": "  }\n",
        "492": "\n",
        "493": "  @Override\n",
        "494": "  public SortedMultiset<E> tailMultiset(@Nullable E lowerBound, BoundType boundType) {\n",
        "495": "    return new TreeMultiset<E>(\n",
        "496": "        rootReference,\n",
        "497": "        range.intersect(GeneralRange.downTo(comparator(), lowerBound, boundType)),\n",
        "498": "        header);\n",
        "499": "  }\n",
        "500": "\n",
        "501": "  static int distinctElements(@Nullable AvlNode<?> node) {\n",
        "502": "    return (node == null) ? 0 : node.distinctElements;\n",
        "503": "  }\n",
        "504": "\n",
        "505": "  private static final class Reference<T> {\n",
        "506": "    @Nullable private T value;\n",
        "507": "\n",
        "508": "    @Nullable\n",
        "509": "    public T get() {\n",
        "510": "      return value;\n",
        "511": "    }\n",
        "512": "\n",
        "513": "    public void checkAndSet(@Nullable T expected, T newValue) {\n",
        "514": "      if (value != expected) {\n",
        "515": "        throw new ConcurrentModificationException();\n",
        "516": "      }\n",
        "517": "      value = newValue;\n",
        "518": "    }\n",
        "519": "  }\n",
        "520": "\n",
        "521": "  private static final class AvlNode<E> extends Multisets.AbstractEntry<E> {\n",
        "522": "    @Nullable private final E elem;\n",
        "523": "\n",
        "524": "    // elemCount is 0 iff this node has been deleted.\n",
        "525": "    private int elemCount;\n",
        "526": "\n",
        "527": "    private int distinctElements;\n",
        "528": "    private long totalCount;\n",
        "529": "    private int height;\n",
        "530": "    private AvlNode<E> left;\n",
        "531": "    private AvlNode<E> right;\n",
        "532": "    private AvlNode<E> pred;\n",
        "533": "    private AvlNode<E> succ;\n",
        "534": "\n",
        "535": "    AvlNode(@Nullable E elem, int elemCount) {\n",
        "536": "      checkArgument(elemCount > 0);\n",
        "537": "      this.elem = elem;\n",
        "538": "      this.elemCount = elemCount;\n",
        "539": "      this.totalCount = elemCount;\n",
        "540": "      this.distinctElements = 1;\n",
        "541": "      this.height = 1;\n",
        "542": "      this.left = null;\n",
        "543": "      this.right = null;\n",
        "544": "    }\n",
        "545": "\n",
        "546": "    public int count(Comparator<? super E> comparator, E e) {\n",
        "547": "      int cmp = comparator.compare(e, elem);\n",
        "548": "      if (cmp < 0) {\n",
        "549": "        return (left == null) ? 0 : left.count(comparator, e);\n",
        "550": "      } else if (cmp > 0) {\n",
        "551": "        return (right == null) ? 0 : right.count(comparator, e);\n",
        "552": "      } else {\n",
        "553": "        return elemCount;\n",
        "554": "      }\n",
        "555": "    }\n",
        "556": "\n",
        "557": "    private AvlNode<E> addRightChild(E e, int count) {\n",
        "558": "      right = new AvlNode<E>(e, count);\n",
        "559": "      successor(this, right, succ);\n",
        "560": "      height = Math.max(2, height);\n",
        "561": "      distinctElements++;\n",
        "562": "      totalCount += count;\n",
        "563": "      return this;\n",
        "564": "    }\n",
        "565": "\n",
        "566": "    private AvlNode<E> addLeftChild(E e, int count) {\n",
        "567": "      left = new AvlNode<E>(e, count);\n",
        "568": "      successor(pred, left, this);\n",
        "569": "      height = Math.max(2, height);\n",
        "570": "      distinctElements++;\n",
        "571": "      totalCount += count;\n",
        "572": "      return this;\n",
        "573": "    }\n",
        "574": "\n",
        "575": "    AvlNode<E> add(Comparator<? super E> comparator, @Nullable E e, int count, int[] result) {\n",
        "576": "      /*\n",
        "577": "       * It speeds things up considerably to unconditionally add count to totalCount here,\n",
        "578": "       * but that destroys failure atomicity in the case of count overflow. =(\n",
        "579": "       */\n",
        "580": "      int cmp = comparator.compare(e, elem);\n",
        "581": "      if (cmp < 0) {\n",
        "582": "        AvlNode<E> initLeft = left;\n",
        "583": "        if (initLeft == null) {\n",
        "584": "          result[0] = 0;\n",
        "585": "          return addLeftChild(e, count);\n",
        "586": "        }\n",
        "587": "        int initHeight = initLeft.height;\n",
        "588": "\n",
        "589": "        left = initLeft.add(comparator, e, count, result);\n",
        "590": "        if (result[0] == 0) {\n",
        "591": "          distinctElements++;\n",
        "592": "        }\n",
        "593": "        this.totalCount += count;\n",
        "594": "        return (left.height == initHeight) ? this : rebalance();\n",
        "595": "      } else if (cmp > 0) {\n",
        "596": "        AvlNode<E> initRight = right;\n",
        "597": "        if (initRight == null) {\n",
        "598": "          result[0] = 0;\n",
        "599": "          return addRightChild(e, count);\n",
        "600": "        }\n",
        "601": "        int initHeight = initRight.height;\n",
        "602": "\n",
        "603": "        right = initRight.add(comparator, e, count, result);\n",
        "604": "        if (result[0] == 0) {\n",
        "605": "          distinctElements++;\n",
        "606": "        }\n",
        "607": "        this.totalCount += count;\n",
        "608": "        return (right.height == initHeight) ? this : rebalance();\n",
        "609": "      }\n",
        "610": "\n",
        "611": "      // adding count to me!  No rebalance possible.\n",
        "612": "      result[0] = elemCount;\n",
        "613": "      long resultCount = (long) elemCount + count;\n",
        "614": "      checkArgument(resultCount <= Integer.MAX_VALUE);\n",
        "615": "      this.elemCount += count;\n",
        "616": "      this.totalCount += count;\n",
        "617": "      return this;\n",
        "618": "    }\n",
        "619": "\n",
        "620": "    AvlNode<E> remove(Comparator<? super E> comparator, @Nullable E e, int count, int[] result) {\n",
        "621": "      int cmp = comparator.compare(e, elem);\n",
        "622": "      if (cmp < 0) {\n",
        "623": "        AvlNode<E> initLeft = left;\n",
        "624": "        if (initLeft == null) {\n",
        "625": "          result[0] = 0;\n",
        "626": "          return this;\n",
        "627": "        }\n",
        "628": "\n",
        "629": "        left = initLeft.remove(comparator, e, count, result);\n",
        "630": "\n",
        "631": "        if (result[0] > 0) {\n",
        "632": "          if (count >= result[0]) {\n",
        "633": "            this.distinctElements--;\n",
        "634": "            this.totalCount -= result[0];\n",
        "635": "          } else {\n",
        "636": "            this.totalCount -= count;\n",
        "637": "          }\n",
        "638": "        }\n",
        "639": "        return (result[0] == 0) ? this : rebalance();\n",
        "640": "      } else if (cmp > 0) {\n",
        "641": "        AvlNode<E> initRight = right;\n",
        "642": "        if (initRight == null) {\n",
        "643": "          result[0] = 0;\n",
        "644": "          return this;\n",
        "645": "        }\n",
        "646": "\n",
        "647": "        right = initRight.remove(comparator, e, count, result);\n",
        "648": "\n",
        "649": "        if (result[0] > 0) {\n",
        "650": "          if (count >= result[0]) {\n",
        "651": "            this.distinctElements--;\n",
        "652": "            this.totalCount -= result[0];\n",
        "653": "          } else {\n",
        "654": "            this.totalCount -= count;\n",
        "655": "          }\n",
        "656": "        }\n",
        "657": "        return rebalance();\n",
        "658": "      }\n",
        "659": "\n",
        "660": "      // removing count from me!\n",
        "661": "      result[0] = elemCount;\n",
        "662": "      if (count >= elemCount) {\n",
        "663": "        return deleteMe();\n",
        "664": "      } else {\n",
        "665": "        this.elemCount -= count;\n",
        "666": "        this.totalCount -= count;\n",
        "667": "        return this;\n",
        "668": "      }\n",
        "669": "    }\n",
        "670": "\n",
        "671": "    AvlNode<E> setCount(Comparator<? super E> comparator, @Nullable E e, int count, int[] result) {\n",
        "672": "      int cmp = comparator.compare(e, elem);\n",
        "673": "      if (cmp < 0) {\n",
        "674": "        AvlNode<E> initLeft = left;\n",
        "675": "        if (initLeft == null) {\n",
        "676": "          result[0] = 0;\n",
        "677": "          return (count > 0) ? addLeftChild(e, count) : this;\n",
        "678": "        }\n",
        "679": "\n",
        "680": "        left = initLeft.setCount(comparator, e, count, result);\n",
        "681": "\n",
        "682": "        if (count == 0 && result[0] != 0) {\n",
        "683": "          this.distinctElements--;\n",
        "684": "        } else if (count > 0 && result[0] == 0) {\n",
        "685": "          this.distinctElements++;\n",
        "686": "        }\n",
        "687": "\n",
        "688": "        this.totalCount += count - result[0];\n",
        "689": "        return rebalance();\n",
        "690": "      } else if (cmp > 0) {\n",
        "691": "        AvlNode<E> initRight = right;\n",
        "692": "        if (initRight == null) {\n",
        "693": "          result[0] = 0;\n",
        "694": "          return (count > 0) ? addRightChild(e, count) : this;\n",
        "695": "        }\n",
        "696": "\n",
        "697": "        right = initRight.setCount(comparator, e, count, result);\n",
        "698": "\n",
        "699": "        if (count == 0 && result[0] != 0) {\n",
        "700": "          this.distinctElements--;\n",
        "701": "        } else if (count > 0 && result[0] == 0) {\n",
        "702": "          this.distinctElements++;\n",
        "703": "        }\n",
        "704": "\n",
        "705": "        this.totalCount += count - result[0];\n",
        "706": "        return rebalance();\n",
        "707": "      }\n",
        "708": "\n",
        "709": "      // setting my count\n",
        "710": "      result[0] = elemCount;\n",
        "711": "      if (count == 0) {\n",
        "712": "        return deleteMe();\n",
        "713": "      }\n",
        "714": "      this.totalCount += count - elemCount;\n",
        "715": "      this.elemCount = count;\n",
        "716": "      return this;\n",
        "717": "    }\n",
        "718": "\n",
        "719": "    AvlNode<E> setCount(\n",
        "720": "        Comparator<? super E> comparator,\n",
        "721": "        @Nullable E e,\n",
        "722": "        int expectedCount,\n",
        "723": "        int newCount,\n",
        "724": "        int[] result) {\n",
        "725": "      int cmp = comparator.compare(e, elem);\n",
        "726": "      if (cmp < 0) {\n",
        "727": "        AvlNode<E> initLeft = left;\n",
        "728": "        if (initLeft == null) {\n",
        "729": "          result[0] = 0;\n",
        "730": "          if (expectedCount == 0 && newCount > 0) {\n",
        "731": "            return addLeftChild(e, newCount);\n",
        "732": "          }\n",
        "733": "          return this;\n",
        "734": "        }\n",
        "735": "\n",
        "736": "        left = initLeft.setCount(comparator, e, expectedCount, newCount, result);\n",
        "737": "\n",
        "738": "        if (result[0] == expectedCount) {\n",
        "739": "          if (newCount == 0 && result[0] != 0) {\n",
        "740": "            this.distinctElements--;\n",
        "741": "          } else if (newCount > 0 && result[0] == 0) {\n",
        "742": "            this.distinctElements++;\n",
        "743": "          }\n",
        "744": "          this.totalCount += newCount - result[0];\n",
        "745": "        }\n",
        "746": "        return rebalance();\n",
        "747": "      } else if (cmp > 0) {\n",
        "748": "        AvlNode<E> initRight = right;\n",
        "749": "        if (initRight == null) {\n",
        "750": "          result[0] = 0;\n",
        "751": "          if (expectedCount == 0 && newCount > 0) {\n",
        "752": "            return addRightChild(e, newCount);\n",
        "753": "          }\n",
        "754": "          return this;\n",
        "755": "        }\n",
        "756": "\n",
        "757": "        right = initRight.setCount(comparator, e, expectedCount, newCount, result);\n",
        "758": "\n",
        "759": "        if (result[0] == expectedCount) {\n",
        "760": "          if (newCount == 0 && result[0] != 0) {\n",
        "761": "            this.distinctElements--;\n",
        "762": "          } else if (newCount > 0 && result[0] == 0) {\n",
        "763": "            this.distinctElements++;\n",
        "764": "          }\n",
        "765": "          this.totalCount += newCount - result[0];\n",
        "766": "        }\n",
        "767": "        return rebalance();\n",
        "768": "      }\n",
        "769": "\n",
        "770": "      // setting my count\n",
        "771": "      result[0] = elemCount;\n",
        "772": "      if (expectedCount == elemCount) {\n",
        "773": "        if (newCount == 0) {\n",
        "774": "          return deleteMe();\n",
        "775": "        }\n",
        "776": "        this.totalCount += newCount - elemCount;\n",
        "777": "        this.elemCount = newCount;\n",
        "778": "      }\n",
        "779": "      return this;\n",
        "780": "    }\n",
        "781": "\n",
        "782": "    private AvlNode<E> deleteMe() {\n",
        "783": "      int oldElemCount = this.elemCount;\n",
        "784": "      this.elemCount = 0;\n",
        "785": "      successor(pred, succ);\n",
        "786": "      if (left == null) {\n",
        "787": "        return right;\n",
        "788": "      } else if (right == null) {\n",
        "789": "        return left;\n",
        "790": "      } else if (left.height >= right.height) {\n",
        "791": "        AvlNode<E> newTop = pred;\n",
        "792": "        // newTop is the maximum node in my left subtree\n",
        "793": "        newTop.left = left.removeMax(newTop);\n",
        "794": "        newTop.right = right;\n",
        "795": "        newTop.distinctElements = distinctElements - 1;\n",
        "796": "        newTop.totalCount = totalCount - oldElemCount;\n",
        "797": "        return newTop.rebalance();\n",
        "798": "      } else {\n",
        "799": "        AvlNode<E> newTop = succ;\n",
        "800": "        newTop.right = right.removeMin(newTop);\n",
        "801": "        newTop.left = left;\n",
        "802": "        newTop.distinctElements = distinctElements - 1;\n",
        "803": "        newTop.totalCount = totalCount - oldElemCount;\n",
        "804": "        return newTop.rebalance();\n",
        "805": "      }\n",
        "806": "    }\n",
        "807": "\n",
        "808": "    // Removes the minimum node from this subtree to be reused elsewhere\n",
        "809": "    private AvlNode<E> removeMin(AvlNode<E> node) {\n",
        "810": "      if (left == null) {\n",
        "811": "        return right;\n",
        "812": "      } else {\n",
        "813": "        left = left.removeMin(node);\n",
        "814": "        distinctElements--;\n",
        "815": "        totalCount -= node.elemCount;\n",
        "816": "        return rebalance();\n",
        "817": "      }\n",
        "818": "    }\n",
        "819": "\n",
        "820": "    // Removes the maximum node from this subtree to be reused elsewhere\n",
        "821": "    private AvlNode<E> removeMax(AvlNode<E> node) {\n",
        "822": "      if (right == null) {\n",
        "823": "        return left;\n",
        "824": "      } else {\n",
        "825": "        right = right.removeMax(node);\n",
        "826": "        distinctElements--;\n",
        "827": "        totalCount -= node.elemCount;\n",
        "828": "        return rebalance();\n",
        "829": "      }\n",
        "830": "    }\n",
        "831": "\n",
        "832": "    private void recomputeMultiset() {\n",
        "833": "      this.distinctElements =\n",
        "834": "          1 + TreeMultiset.distinctElements(left) + TreeMultiset.distinctElements(right);\n",
        "835": "      this.totalCount = elemCount + totalCount(left) + totalCount(right);\n",
        "836": "    }\n",
        "837": "\n",
        "838": "    private void recomputeHeight() {\n",
        "839": "      this.height = 1 + Math.max(height(left), height(right));\n",
        "840": "    }\n",
        "841": "\n",
        "842": "    private void recompute() {\n",
        "843": "      recomputeMultiset();\n",
        "844": "      recomputeHeight();\n",
        "845": "    }\n",
        "846": "\n",
        "847": "    private AvlNode<E> rebalance() {\n",
        "848": "      switch (balanceFactor()) {\n",
        "849": "        case -2:\n",
        "850": "          if (right.balanceFactor() > 0) {\n",
        "851": "            right = right.rotateRight();\n",
        "852": "          }\n",
        "853": "          return rotateLeft();\n",
        "854": "        case 2:\n",
        "855": "          if (left.balanceFactor() < 0) {\n",
        "856": "            left = left.rotateLeft();\n",
        "857": "          }\n",
        "858": "          return rotateRight();\n",
        "859": "        default:\n",
        "860": "          recomputeHeight();\n",
        "861": "          return this;\n",
        "862": "      }\n",
        "863": "    }\n",
        "864": "\n",
        "865": "    private int balanceFactor() {\n",
        "866": "      return height(left) - height(right);\n",
        "867": "    }\n",
        "868": "\n",
        "869": "    private AvlNode<E> rotateLeft() {\n",
        "870": "      checkState(right != null);\n",
        "871": "      AvlNode<E> newTop = right;\n",
        "872": "      this.right = newTop.left;\n",
        "873": "      newTop.left = this;\n",
        "874": "      newTop.totalCount = this.totalCount;\n",
        "875": "      newTop.distinctElements = this.distinctElements;\n",
        "876": "      this.recompute();\n",
        "877": "      newTop.recomputeHeight();\n",
        "878": "      return newTop;\n",
        "879": "    }\n",
        "880": "\n",
        "881": "    private AvlNode<E> rotateRight() {\n",
        "882": "      checkState(left != null);\n",
        "883": "      AvlNode<E> newTop = left;\n",
        "884": "      this.left = newTop.right;\n",
        "885": "      newTop.right = this;\n",
        "886": "      newTop.totalCount = this.totalCount;\n",
        "887": "      newTop.distinctElements = this.distinctElements;\n",
        "888": "      this.recompute();\n",
        "889": "      newTop.recomputeHeight();\n",
        "890": "      return newTop;\n",
        "891": "    }\n",
        "892": "\n",
        "893": "    private static long totalCount(@Nullable AvlNode<?> node) {\n",
        "894": "      return (node == null) ? 0 : node.totalCount;\n",
        "895": "    }\n",
        "896": "\n",
        "897": "    private static int height(@Nullable AvlNode<?> node) {\n",
        "898": "      return (node == null) ? 0 : node.height;\n",
        "899": "    }\n",
        "900": "\n",
        "901": "    @Nullable\n",
        "902": "    private AvlNode<E> ceiling(Comparator<? super E> comparator, E e) {\n",
        "903": "      int cmp = comparator.compare(e, elem);\n",
        "904": "      if (cmp < 0) {\n",
        "905": "        return (left == null) ? this : MoreObjects.firstNonNull(left.ceiling(comparator, e), this);\n",
        "906": "      } else if (cmp == 0) {\n",
        "907": "        return this;\n",
        "908": "      } else {\n",
        "909": "        return (right == null) ? null : right.ceiling(comparator, e);\n",
        "910": "      }\n",
        "911": "    }\n",
        "912": "\n",
        "913": "    @Nullable\n",
        "914": "    private AvlNode<E> floor(Comparator<? super E> comparator, E e) {\n",
        "915": "      int cmp = comparator.compare(e, elem);\n",
        "916": "      if (cmp > 0) {\n",
        "917": "        return (right == null) ? this : MoreObjects.firstNonNull(right.floor(comparator, e), this);\n",
        "918": "      } else if (cmp == 0) {\n",
        "919": "        return this;\n",
        "920": "      } else {\n",
        "921": "        return (left == null) ? null : left.floor(comparator, e);\n",
        "922": "      }\n",
        "923": "    }\n",
        "924": "\n",
        "925": "    @Override\n",
        "926": "    public E getElement() {\n",
        "927": "      return elem;\n",
        "928": "    }\n",
        "929": "\n",
        "930": "    @Override\n",
        "931": "    public int getCount() {\n",
        "932": "      return elemCount;\n",
        "933": "    }\n",
        "934": "\n",
        "935": "    @Override\n",
        "936": "    public String toString() {\n",
        "937": "      return Multisets.immutableEntry(getElement(), getCount()).toString();\n",
        "938": "    }\n",
        "939": "  }\n",
        "940": "\n",
        "941": "  private static <T> void successor(AvlNode<T> a, AvlNode<T> b) {\n",
        "942": "    a.succ = b;\n",
        "943": "    b.pred = a;\n",
        "944": "  }\n",
        "945": "\n",
        "946": "  private static <T> void successor(AvlNode<T> a, AvlNode<T> b, AvlNode<T> c) {\n",
        "947": "    successor(a, b);\n",
        "948": "    successor(b, c);\n",
        "949": "  }\n",
        "950": "\n",
        "951": "  /*\n",
        "952": "   * TODO(jlevy): Decide whether entrySet() should return entries with an equals() method that\n",
        "953": "   * calls the comparator to compare the two keys. If that change is made,\n",
        "954": "   * AbstractMultiset.equals() can simply check whether two multisets have equal entry sets.\n",
        "955": "   */\n",
        "956": "}\n",
        "957": "\n"
    }
}