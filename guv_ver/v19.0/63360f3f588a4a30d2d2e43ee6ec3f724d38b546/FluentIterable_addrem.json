{
    "addition": {},
    "removed": {
        "1": "/*\n",
        "2": " * Copyright (C) 2008 The Guava Authors\n",
        "3": " *\n",
        "4": " * Licensed under the Apache License, Version 2.0 (the \"License\");\n",
        "5": " * you may not use this file except in compliance with the License.\n",
        "6": " * You may obtain a copy of the License at\n",
        "7": " *\n",
        "8": " * http://www.apache.org/licenses/LICENSE-2.0\n",
        "9": " *\n",
        "10": " * Unless required by applicable law or agreed to in writing, software\n",
        "11": " * distributed under the License is distributed on an \"AS IS\" BASIS,\n",
        "12": " * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n",
        "13": " * See the License for the specific language governing permissions and\n",
        "14": " * limitations under the License.\n",
        "15": " */\n",
        "16": "\n",
        "17": "package com.google.common.collect;\n",
        "18": "\n",
        "19": "import static com.google.common.base.Preconditions.checkNotNull;\n",
        "20": "\n",
        "21": "import com.google.common.annotations.Beta;\n",
        "22": "import com.google.common.annotations.GwtCompatible;\n",
        "23": "import com.google.common.base.Function;\n",
        "24": "import com.google.common.base.Joiner;\n",
        "25": "import com.google.common.base.Optional;\n",
        "26": "import com.google.common.base.Predicate;\n",
        "27": "\n",
        "28": "import java.util.Arrays;\n",
        "29": "import java.util.Collection;\n",
        "30": "import java.util.Comparator;\n",
        "31": "import java.util.Iterator;\n",
        "32": "import java.util.List;\n",
        "33": "import java.util.SortedSet;\n",
        "34": "\n",
        "35": "import javax.annotation.CheckReturnValue;\n",
        "36": "import javax.annotation.Nullable;\n",
        "37": "\n",
        "38": "/**\n",
        "39": " * An expanded {@code Iterable} API, providing functionality similar to Java 8's powerful <a href=\n",
        "40": " * \"https://docs.oracle.com/javase/8/docs/api/java/util/stream/package-summary.html#package.description\"\n",
        "41": " * >streams library</a> in a slightly different way.\n",
        "42": " *\n",
        "43": " * <p>The following types of methods are provided:\n",
        "44": " *\n",
        "45": " * <ul>\n",
        "46": " * <li>chaining methods which return a new {@code FluentIterable} based in some way on the contents\n",
        "47": " *     of the current one (for example {@link #transform})\n",
        "48": " * <li>element extraction methods which facilitate the retrieval of certain elements (for example\n",
        "49": " *     {@link #last})\n",
        "50": " * <li>query methods which answer questions about the {@code FluentIterable}'s contents (for example\n",
        "51": " *     {@link #anyMatch})\n",
        "52": " * <li>conversion methods which copy the {@code FluentIterable}'s contents into a new collection or\n",
        "53": " *     array (for example {@link #toList})\n",
        "54": " * </ul>\n",
        "55": " *\n",
        "56": " * <p>Several lesser-used features are currently available only as static methods on the {@link\n",
        "57": " * Iterables} class.\n",
        "58": " *\n",
        "59": " * <a name=\"streams\"></a>\n",
        "60": " * <h3>Comparison to streams</h3>\n",
        "61": " *\n",
        "62": " * <p>Starting with Java 8, the core Java class libraries provide a new \"Streams\" library (in {@code\n",
        "63": " * java.util.stream}), which is similar to {@code FluentIterable} but generally more powerful. Key\n",
        "64": " * differences include:</b>\n",
        "65": " *\n",
        "66": " * <ul>\n",
        "67": " * <li>A stream is <i>single-use</i>; it becomes invalid as soon as any \"terminal operation\" such as\n",
        "68": " *     {@code findFirst()} or {@code iterator()} is invoked. (Even though {@code Stream} contains\n",
        "69": " *     all the right method <i>signatures</i> to implement {@link Iterable}, it does not actually\n",
        "70": " *     do so, to avoid implying repeat-iterability.) {@code FluentIterable}, on the other hand, is\n",
        "71": " *     multiple-use, and does implement {@link Iterable}.\n",
        "72": " * <li>Streams offer many features not found here, including {@code min/max}, {@code\n",
        "73": " *     distinct}, {@code reduce}, {@code sorted}, the very powerful {@code collect}, and built-in\n",
        "74": " *     support for parallelizing stream operations.\n",
        "75": " * <li>{@code FluentIterable} contains several features not available on {@code Stream}, which are\n",
        "76": " *     noted in the method descriptions below.\n",
        "77": " * <li>Streams include primitive-specialized variants such as {@code IntStream}, the use of which is\n",
        "78": " *     strongly recommended.\n",
        "79": " * <li>Streams are standard Java, not requiring a third-party dependency (but do render your code\n",
        "80": " *     incompatible with Java 7 and earlier).\n",
        "81": " * </ul>\n",
        "82": " *\n",
        "83": " * <h3>Example</h3>\n",
        "84": " *\n",
        "85": " * <p>Here is an example that accepts a list from a database call, filters it based on a predicate,\n",
        "86": " * transforms it by invoking {@code toString()} on each element, and returns the first 10 elements\n",
        "87": " * as a {@code List}: <pre>   {@code\n",
        "88": " *\n",
        "89": " *   List<String> results =\n",
        "90": " *       FluentIterable.from(database.getClientList())\n",
        "91": " *           .filter(activeInLastMonthPredicate)\n",
        "92": " *           .transform(Functions.toStringFunction())\n",
        "93": " *           .limit(10)\n",
        "94": " *           .toList();}</pre>\n",
        "95": " *\n",
        "96": " * The approximate stream equivalent is: <pre>   {@code\n",
        "97": " *\n",
        "98": " *   List<String> results =\n",
        "99": " *       database.getClientList()\n",
        "100": " *           .stream()\n",
        "101": " *           .filter(activeInLastMonthPredicate)\n",
        "102": " *           .map(Functions.toStringFunction())\n",
        "103": " *           .limit(10)\n",
        "104": " *           .collect(Collectors.toList());}</pre>\n",
        "105": " *\n",
        "106": " * @author Marcin Mikosik\n",
        "107": " * @since 12.0\n",
        "108": " */\n",
        "109": "@GwtCompatible(emulated = true)\n",
        "110": "public abstract class FluentIterable<E> implements Iterable<E> {\n",
        "111": "  // We store 'iterable' and use it instead of 'this' to allow Iterables to perform instanceof\n",
        "112": "  // checks on the _original_ iterable when FluentIterable.from is used.\n",
        "113": "  private final Iterable<E> iterable;\n",
        "114": "\n",
        "115": "  /** Constructor for use by subclasses. */\n",
        "116": "  protected FluentIterable() {\n",
        "117": "    this.iterable = this;\n",
        "118": "  }\n",
        "119": "\n",
        "120": "  FluentIterable(Iterable<E> iterable) {\n",
        "121": "    this.iterable = checkNotNull(iterable);\n",
        "122": "  }\n",
        "123": "\n",
        "124": "  /**\n",
        "125": "   * Returns a fluent iterable that wraps {@code iterable}, or {@code iterable} itself if it\n",
        "126": "   * is already a {@code FluentIterable}.\n",
        "127": "   *\n",
        "128": "   * <p><b>{@code Stream} equivalent:</b> {@code iterable.stream()} if {@code iterable} is a\n",
        "129": "   * {@link Collection}; {@code StreamSupport.stream(iterable.spliterator(), false)} otherwise.\n",
        "130": "   */\n",
        "131": "  @CheckReturnValue\n",
        "132": "  public static <E> FluentIterable<E> from(final Iterable<E> iterable) {\n",
        "133": "    return (iterable instanceof FluentIterable)\n",
        "134": "        ? (FluentIterable<E>) iterable\n",
        "135": "        : new FluentIterable<E>(iterable) {\n",
        "136": "          @Override\n",
        "137": "          public Iterator<E> iterator() {\n",
        "138": "            return iterable.iterator();\n",
        "139": "          }\n",
        "140": "        };\n",
        "141": "  }\n",
        "142": "\n",
        "143": "  /**\n",
        "144": "   * Returns a fluent iterable containing {@code elements} in the specified order.\n",
        "145": "   *\n",
        "146": "   * <p>The returned iterable is an unmodifiable view of the input array.\n",
        "147": "   *\n",
        "148": "   * <p><b>{@code Stream} equivalent:</b> {@code Stream.of(elements)} or {@code\n",
        "149": "   * Arrays.stream(elements)}.\n",
        "150": "   *\n",
        "151": "   * @since 20.0 (since 18.0 as an overload of {@code of})\n",
        "152": "   */\n",
        "153": "  @Beta\n",
        "154": "  @CheckReturnValue\n",
        "155": "  public static <E> FluentIterable<E> from(E[] elements) {\n",
        "156": "    return from(Arrays.asList(elements));\n",
        "157": "  }\n",
        "158": "\n",
        "159": "  /**\n",
        "160": "   * Construct a fluent iterable from another fluent iterable. This is obviously never necessary,\n",
        "161": "   * but is intended to help call out cases where one migration from {@code Iterable} to\n",
        "162": "   * {@code FluentIterable} has obviated the need to explicitly convert to a {@code FluentIterable}.\n",
        "163": "   *\n",
        "164": "   * @deprecated instances of {@code FluentIterable} don't need to be converted to\n",
        "165": "   *     {@code FluentIterable}\n",
        "166": "   */\n",
        "167": "  @Deprecated\n",
        "168": "  @CheckReturnValue\n",
        "169": "  public static <E> FluentIterable<E> from(FluentIterable<E> iterable) {\n",
        "170": "    return checkNotNull(iterable);\n",
        "171": "  }\n",
        "172": "\n",
        "173": "  /**\n",
        "174": "   * Returns a fluent iterable containing no elements.\n",
        "175": "   *\n",
        "176": "   * <p><b>{@code Stream} equivalent:</b> {@code Stream.empty()}.\n",
        "177": "   *\n",
        "178": "   * @since 20.0\n",
        "179": "   */\n",
        "180": "  @Beta\n",
        "181": "  @CheckReturnValue\n",
        "182": "  public static <E> FluentIterable<E> of() {\n",
        "183": "    return FluentIterable.from(ImmutableList.<E>of());\n",
        "184": "  }\n",
        "185": "\n",
        "186": "  /**\n",
        "187": "   * Returns a fluent iterable containing {@code elements} in the specified order.\n",
        "188": "   *\n",
        "189": "   * <p>The returned iterable is modifiable, but modifications do not affect the input array.\n",
        "190": "   *\n",
        "191": "   * <p><b>{@code Stream} equivalent:</b> {@code Stream.of(elements)} or {@code\n",
        "192": "   * Arrays.stream(elements)}.\n",
        "193": "   *\n",
        "194": "   * @since 18.0\n",
        "195": "   */\n",
        "196": "  @Beta\n",
        "197": "  @CheckReturnValue\n",
        "198": "  // TODO(kak): @deprecated Use {@link #from(E[])} instead.\n",
        "199": "  public static <E> FluentIterable<E> of(E[] elements) {\n",
        "200": "    return from(Lists.newArrayList(elements));\n",
        "201": "  }\n",
        "202": "\n",
        "203": "  /**\n",
        "204": "   * Returns a fluent iterable containing the specified elements in order.\n",
        "205": "   *\n",
        "206": "   * <p><b>{@code Stream} equivalent:</b> {@code Stream.of(...)}.\n",
        "207": "   *\n",
        "208": "   * @since 20.0\n",
        "209": "   */\n",
        "210": "  @Beta\n",
        "211": "  @CheckReturnValue\n",
        "212": "  public static <E> FluentIterable<E> of(@Nullable E element, E... elements) {\n",
        "213": "    return from(Lists.asList(element, elements));\n",
        "214": "  }\n",
        "215": "\n",
        "216": "  /**\n",
        "217": "   * Returns a string representation of this fluent iterable, with the format\n",
        "218": "   * {@code [e1, e2, ..., en]}.\n",
        "219": "   *\n",
        "220": "   * <p><b>{@code Stream} equivalent:</b> {@code stream.collect(Collectors.joining(\", \", \"[\", \"]\"))}\n",
        "221": "   * or (less efficiently) {@code collect(Collectors.toList()).toString()}.\n",
        "222": "   */\n",
        "223": "  @Override\n",
        "224": "  @CheckReturnValue\n",
        "225": "  public String toString() {\n",
        "226": "    return Iterables.toString(iterable);\n",
        "227": "  }\n",
        "228": "\n",
        "229": "  /**\n",
        "230": "   * Returns the number of elements in this fluent iterable.\n",
        "231": "   *\n",
        "232": "   * <p><b>{@code Stream} equivalent:</b> {@code stream.count()}.\n",
        "233": "   */\n",
        "234": "  @CheckReturnValue\n",
        "235": "  public final int size() {\n",
        "236": "    return Iterables.size(iterable);\n",
        "237": "  }\n",
        "238": "\n",
        "239": "  /**\n",
        "240": "   * Returns {@code true} if this fluent iterable contains any object for which\n",
        "241": "   * {@code equals(target)} is true.\n",
        "242": "   *\n",
        "243": "   * <p><b>{@code Stream} equivalent:</b> {@code stream.anyMatch(Predicate.isEqual(target))}.\n",
        "244": "   */\n",
        "245": "  @CheckReturnValue\n",
        "246": "  public final boolean contains(@Nullable Object target) {\n",
        "247": "    return Iterables.contains(iterable, target);\n",
        "248": "  }\n",
        "249": "\n",
        "250": "  /**\n",
        "251": "   * Returns a fluent iterable whose {@code Iterator} cycles indefinitely over the elements of\n",
        "252": "   * this fluent iterable.\n",
        "253": "   *\n",
        "254": "   * <p>That iterator supports {@code remove()} if {@code iterable.iterator()} does. After\n",
        "255": "   * {@code remove()} is called, subsequent cycles omit the removed element, which is no longer in\n",
        "256": "   * this fluent iterable. The iterator's {@code hasNext()} method returns {@code true} until\n",
        "257": "   * this fluent iterable is empty.\n",
        "258": "   *\n",
        "259": "   * <p><b>Warning:</b> Typical uses of the resulting iterator may produce an infinite loop. You\n",
        "260": "   * should use an explicit {@code break} or be certain that you will eventually remove all the\n",
        "261": "   * elements.\n",
        "262": "   *\n",
        "263": "   * <p><b>{@code Stream} equivalent:</b> if the source iterable has only a single element {@code\n",
        "264": "   * element}, use {@code Stream.generate(() -> element)}. Otherwise, if the source iterable has\n",
        "265": "   * a {@code stream} method (for example, if it is a {@link Collection}), use\n",
        "266": "   * {@code Stream.generate(iterable::stream).flatMap(s -> s)}.\n",
        "267": "   */\n",
        "268": "  @CheckReturnValue\n",
        "269": "  public final FluentIterable<E> cycle() {\n",
        "270": "    return from(Iterables.cycle(iterable));\n",
        "271": "  }\n",
        "272": "\n",
        "273": "  /**\n",
        "274": "   * Returns a fluent iterable whose iterators traverse first the elements of this fluent iterable,\n",
        "275": "   * followed by those of {@code other}. The iterators are not polled until necessary.\n",
        "276": "   *\n",
        "277": "   * <p>The returned iterable's {@code Iterator} supports {@code remove()} when the corresponding\n",
        "278": "   * {@code Iterator} supports it.\n",
        "279": "   *\n",
        "280": "   * <p><b>{@code Stream} equivalent:</b> {@code Stream.concat(thisStream, otherStream)}.\n",
        "281": "   *\n",
        "282": "   * @since 18.0\n",
        "283": "   */\n",
        "284": "  @Beta\n",
        "285": "  @CheckReturnValue\n",
        "286": "  public final FluentIterable<E> append(Iterable<? extends E> other) {\n",
        "287": "    return from(Iterables.concat(iterable, other));\n",
        "288": "  }\n",
        "289": "\n",
        "290": "  /**\n",
        "291": "   * Returns a fluent iterable whose iterators traverse first the elements of this fluent iterable,\n",
        "292": "   * followed by {@code elements}.\n",
        "293": "   *\n",
        "294": "   * <p><b>{@code Stream} equivalent:</b> {@code Stream.concat(thisStream, Stream.of(elements))}.\n",
        "295": "   *\n",
        "296": "   * @since 18.0\n",
        "297": "   */\n",
        "298": "  @Beta\n",
        "299": "  @CheckReturnValue\n",
        "300": "  public final FluentIterable<E> append(E... elements) {\n",
        "301": "    return from(Iterables.concat(iterable, Arrays.asList(elements)));\n",
        "302": "  }\n",
        "303": "\n",
        "304": "  /**\n",
        "305": "   * Returns the elements from this fluent iterable that satisfy a predicate. The\n",
        "306": "   * resulting fluent iterable's iterator does not support {@code remove()}.\n",
        "307": "   *\n",
        "308": "   * <p><b>{@code Stream} equivalent:</b> {@code stream.filter(predicate)} (same).\n",
        "309": "   */\n",
        "310": "  @CheckReturnValue\n",
        "311": "  public final FluentIterable<E> filter(Predicate<? super E> predicate) {\n",
        "312": "    return from(Iterables.filter(iterable, predicate));\n",
        "313": "  }\n",
        "314": "\n",
        "315": "  /**\n",
        "316": "   * Returns {@code true} if any element in this fluent iterable satisfies the predicate.\n",
        "317": "   *\n",
        "318": "   * <p><b>{@code Stream} equivalent:</b> {@code stream.anyMatch(predicate)} (same).\n",
        "319": "   */\n",
        "320": "  @CheckReturnValue\n",
        "321": "  public final boolean anyMatch(Predicate<? super E> predicate) {\n",
        "322": "    return Iterables.any(iterable, predicate);\n",
        "323": "  }\n",
        "324": "\n",
        "325": "  /**\n",
        "326": "   * Returns {@code true} if every element in this fluent iterable satisfies the predicate.\n",
        "327": "   * If this fluent iterable is empty, {@code true} is returned.\n",
        "328": "   *\n",
        "329": "   * <p><b>{@code Stream} equivalent:</b> {@code stream.allMatch(predicate)} (same).\n",
        "330": "   */\n",
        "331": "  @CheckReturnValue\n",
        "332": "  public final boolean allMatch(Predicate<? super E> predicate) {\n",
        "333": "    return Iterables.all(iterable, predicate);\n",
        "334": "  }\n",
        "335": "\n",
        "336": "  /**\n",
        "337": "   * Returns an {@link Optional} containing the first element in this fluent iterable that\n",
        "338": "   * satisfies the given predicate, if such an element exists.\n",
        "339": "   *\n",
        "340": "   * <p><b>Warning:</b> avoid using a {@code predicate} that matches {@code null}. If {@code null}\n",
        "341": "   * is matched in this fluent iterable, a {@link NullPointerException} will be thrown.\n",
        "342": "   *\n",
        "343": "   * <p><b>{@code Stream} equivalent:</b> {@code stream.filter(predicate).findFirst()}.\n",
        "344": "   */\n",
        "345": "  @CheckReturnValue\n",
        "346": "  public final Optional<E> firstMatch(Predicate<? super E> predicate) {\n",
        "347": "    return Iterables.tryFind(iterable, predicate);\n",
        "348": "  }\n",
        "349": "\n",
        "350": "  /**\n",
        "351": "   * Returns a fluent iterable that applies {@code function} to each element of this\n",
        "352": "   * fluent iterable.\n",
        "353": "   *\n",
        "354": "   * <p>The returned fluent iterable's iterator supports {@code remove()} if this iterable's\n",
        "355": "   * iterator does. After a successful {@code remove()} call, this fluent iterable no longer\n",
        "356": "   * contains the corresponding element.\n",
        "357": "   *\n",
        "358": "   * <p><b>{@code Stream} equivalent:</b> {@code stream.map(function)}.\n",
        "359": "   */\n",
        "360": "  @CheckReturnValue\n",
        "361": "  public final <T> FluentIterable<T> transform(Function<? super E, T> function) {\n",
        "362": "    return from(Iterables.transform(iterable, function));\n",
        "363": "  }\n",
        "364": "\n",
        "365": "  /**\n",
        "366": "   * Applies {@code function} to each element of this fluent iterable and returns\n",
        "367": "   * a fluent iterable with the concatenated combination of results.  {@code function}\n",
        "368": "   * returns an Iterable of results.\n",
        "369": "   *\n",
        "370": "   * <p>The returned fluent iterable's iterator supports {@code remove()} if this\n",
        "371": "   * function-returned iterables' iterator does. After a successful {@code remove()} call,\n",
        "372": "   * the returned fluent iterable no longer contains the corresponding element.\n",
        "373": "   *\n",
        "374": "   * <p><b>{@code Stream} equivalent:</b> {@code stream.flatMap(function)} (using a function that\n",
        "375": "   * produces streams, not iterables).\n",
        "376": "   *\n",
        "377": "   * @since 13.0 (required {@code Function<E, Iterable<T>>} until 14.0)\n",
        "378": "   */\n",
        "379": "  @CheckReturnValue\n",
        "380": "  public <T> FluentIterable<T> transformAndConcat(\n",
        "381": "      Function<? super E, ? extends Iterable<? extends T>> function) {\n",
        "382": "    return from(Iterables.concat(transform(function)));\n",
        "383": "  }\n",
        "384": "\n",
        "385": "  /**\n",
        "386": "   * Returns an {@link Optional} containing the first element in this fluent iterable.\n",
        "387": "   * If the iterable is empty, {@code Optional.absent()} is returned.\n",
        "388": "   *\n",
        "389": "   * <p><b>{@code Stream} equivalent:</b> if the goal is to obtain any element, {@code\n",
        "390": "   * stream.findAny()}; if it must specifically be the <i>first</i> element, {@code\n",
        "391": "   * stream.findFirst()}.\n",
        "392": "   *\n",
        "393": "   * @throws NullPointerException if the first element is null; if this is a possibility, use\n",
        "394": "   *     {@code iterator().next()} or {@link Iterables#getFirst} instead.\n",
        "395": "   */\n",
        "396": "  @CheckReturnValue\n",
        "397": "  public final Optional<E> first() {\n",
        "398": "    Iterator<E> iterator = iterable.iterator();\n",
        "399": "    return iterator.hasNext() ? Optional.of(iterator.next()) : Optional.<E>absent();\n",
        "400": "  }\n",
        "401": "\n",
        "402": "  /**\n",
        "403": "   * Returns an {@link Optional} containing the last element in this fluent iterable.\n",
        "404": "   * If the iterable is empty, {@code Optional.absent()} is returned.\n",
        "405": "   *\n",
        "406": "   * <p><b>{@code Stream} equivalent:</b> {@code stream.reduce((a, b) -> b)}.\n",
        "407": "   *\n",
        "408": "   * @throws NullPointerException if the last element is null; if this is a possibility, use\n",
        "409": "   *     {@link Iterables#getLast} instead.\n",
        "410": "   */\n",
        "411": "  @CheckReturnValue\n",
        "412": "  public final Optional<E> last() {\n",
        "413": "    // Iterables#getLast was inlined here so we don't have to throw/catch a NSEE\n",
        "414": "\n",
        "415": "    // TODO(kevinb): Support a concurrently modified collection?\n",
        "416": "    if (iterable instanceof List) {\n",
        "417": "      List<E> list = (List<E>) iterable;\n",
        "418": "      if (list.isEmpty()) {\n",
        "419": "        return Optional.absent();\n",
        "420": "      }\n",
        "421": "      return Optional.of(list.get(list.size() - 1));\n",
        "422": "    }\n",
        "423": "    Iterator<E> iterator = iterable.iterator();\n",
        "424": "    if (!iterator.hasNext()) {\n",
        "425": "      return Optional.absent();\n",
        "426": "    }\n",
        "427": "\n",
        "428": "    /*\n",
        "429": "     * TODO(kevinb): consider whether this \"optimization\" is worthwhile. Users\n",
        "430": "     * with SortedSets tend to know they are SortedSets and probably would not\n",
        "431": "     * call this method.\n",
        "432": "     */\n",
        "433": "    if (iterable instanceof SortedSet) {\n",
        "434": "      SortedSet<E> sortedSet = (SortedSet<E>) iterable;\n",
        "435": "      return Optional.of(sortedSet.last());\n",
        "436": "    }\n",
        "437": "\n",
        "438": "    while (true) {\n",
        "439": "      E current = iterator.next();\n",
        "440": "      if (!iterator.hasNext()) {\n",
        "441": "        return Optional.of(current);\n",
        "442": "      }\n",
        "443": "    }\n",
        "444": "  }\n",
        "445": "\n",
        "446": "  /**\n",
        "447": "   * Returns a view of this fluent iterable that skips its first {@code numberToSkip}\n",
        "448": "   * elements. If this fluent iterable contains fewer than {@code numberToSkip} elements,\n",
        "449": "   * the returned fluent iterable skips all of its elements.\n",
        "450": "   *\n",
        "451": "   * <p>Modifications to this fluent iterable before a call to {@code iterator()} are\n",
        "452": "   * reflected in the returned fluent iterable. That is, the its iterator skips the first\n",
        "453": "   * {@code numberToSkip} elements that exist when the iterator is created, not when {@code skip()}\n",
        "454": "   * is called.\n",
        "455": "   *\n",
        "456": "   * <p>The returned fluent iterable's iterator supports {@code remove()} if the\n",
        "457": "   * {@code Iterator} of this fluent iterable supports it. Note that it is <i>not</i>\n",
        "458": "   * possible to delete the last skipped element by immediately calling {@code remove()} on the\n",
        "459": "   * returned fluent iterable's iterator, as the {@code Iterator} contract states that a call\n",
        "460": "   * to {@code * remove()} before a call to {@code next()} will throw an\n",
        "461": "   * {@link IllegalStateException}.\n",
        "462": "   *\n",
        "463": "   * <p><b>{@code Stream} equivalent:</b> {@code stream.skip(numberToSkip)} (same).\n",
        "464": "   */\n",
        "465": "  @CheckReturnValue\n",
        "466": "  public final FluentIterable<E> skip(int numberToSkip) {\n",
        "467": "    return from(Iterables.skip(iterable, numberToSkip));\n",
        "468": "  }\n",
        "469": "\n",
        "470": "  /**\n",
        "471": "   * Creates a fluent iterable with the first {@code size} elements of this\n",
        "472": "   * fluent iterable. If this fluent iterable does not contain that many elements,\n",
        "473": "   * the returned fluent iterable will have the same behavior as this fluent iterable.\n",
        "474": "   * The returned fluent iterable's iterator supports {@code remove()} if this\n",
        "475": "   * fluent iterable's iterator does.\n",
        "476": "   *\n",
        "477": "   * <p><b>{@code Stream} equivalent:</b> {@code stream.limit(maxSize)} (same).\n",
        "478": "   *\n",
        "479": "   * @param maxSize the maximum number of elements in the returned fluent iterable\n",
        "480": "   * @throws IllegalArgumentException if {@code size} is negative\n",
        "481": "   */\n",
        "482": "  @CheckReturnValue\n",
        "483": "  public final FluentIterable<E> limit(int maxSize) {\n",
        "484": "    return from(Iterables.limit(iterable, maxSize));\n",
        "485": "  }\n",
        "486": "\n",
        "487": "  /**\n",
        "488": "   * Determines whether this fluent iterable is empty.\n",
        "489": "   *\n",
        "490": "   * <p><b>{@code Stream} equivalent:</b> {@code !stream.findAny().isPresent()}.\n",
        "491": "   */\n",
        "492": "  @CheckReturnValue\n",
        "493": "  public final boolean isEmpty() {\n",
        "494": "    return !iterable.iterator().hasNext();\n",
        "495": "  }\n",
        "496": "\n",
        "497": "  /**\n",
        "498": "   * Returns an {@code ImmutableList} containing all of the elements from this fluent iterable in\n",
        "499": "   * proper sequence.\n",
        "500": "   *\n",
        "501": "   * <p><b>{@code Stream} equivalent:</b> {@code ImmutableList.copyOf(stream.iterator())}.\n",
        "502": "   *\n",
        "503": "   * @since 14.0 (since 12.0 as {@code toImmutableList()}).\n",
        "504": "   */\n",
        "505": "  @CheckReturnValue\n",
        "506": "  public final ImmutableList<E> toList() {\n",
        "507": "    return ImmutableList.copyOf(iterable);\n",
        "508": "  }\n",
        "509": "\n",
        "510": "  /**\n",
        "511": "   * Returns an {@code ImmutableList} containing all of the elements from this {@code\n",
        "512": "   * FluentIterable} in the order specified by {@code comparator}.  To produce an {@code\n",
        "513": "   * ImmutableList} sorted by its natural ordering, use {@code toSortedList(Ordering.natural())}.\n",
        "514": "   *\n",
        "515": "   * <p><b>{@code Stream} equivalent:</b>\n",
        "516": "   * {@code ImmutableList.copyOf(stream.sorted(comparator).iterator())}.\n",
        "517": "   *\n",
        "518": "   * @param comparator the function by which to sort list elements\n",
        "519": "   * @throws NullPointerException if any element is null\n",
        "520": "   * @since 14.0 (since 13.0 as {@code toSortedImmutableList()}).\n",
        "521": "   */\n",
        "522": "  @CheckReturnValue\n",
        "523": "  public final ImmutableList<E> toSortedList(Comparator<? super E> comparator) {\n",
        "524": "    return Ordering.from(comparator).immutableSortedCopy(iterable);\n",
        "525": "  }\n",
        "526": "\n",
        "527": "  /**\n",
        "528": "   * Returns an {@code ImmutableSet} containing all of the elements from this fluent iterable with\n",
        "529": "   * duplicates removed.\n",
        "530": "   *\n",
        "531": "   * <p><b>{@code Stream} equivalent:</b> {@code ImmutableSet.copyOf(stream.iterator())}.\n",
        "532": "   *\n",
        "533": "   * @since 14.0 (since 12.0 as {@code toImmutableSet()}).\n",
        "534": "   */\n",
        "535": "  @CheckReturnValue\n",
        "536": "  public final ImmutableSet<E> toSet() {\n",
        "537": "    return ImmutableSet.copyOf(iterable);\n",
        "538": "  }\n",
        "539": "\n",
        "540": "  /**\n",
        "541": "   * Returns an {@code ImmutableSortedSet} containing all of the elements from this {@code\n",
        "542": "   * FluentIterable} in the order specified by {@code comparator}, with duplicates (determined by\n",
        "543": "   * {@code comparator.compare(x, y) == 0}) removed. To produce an {@code ImmutableSortedSet} sorted\n",
        "544": "   * by its natural ordering, use {@code toSortedSet(Ordering.natural())}.\n",
        "545": "   *\n",
        "546": "   * <p><b>{@code Stream} equivalent:</b>\n",
        "547": "   * {@code ImmutableSortedSet.copyOf(comparator, stream.iterator())}.\n",
        "548": "   *\n",
        "549": "   * @param comparator the function by which to sort set elements\n",
        "550": "   * @throws NullPointerException if any element is null\n",
        "551": "   * @since 14.0 (since 12.0 as {@code toImmutableSortedSet()}).\n",
        "552": "   */\n",
        "553": "  @CheckReturnValue\n",
        "554": "  public final ImmutableSortedSet<E> toSortedSet(Comparator<? super E> comparator) {\n",
        "555": "    return ImmutableSortedSet.copyOf(comparator, iterable);\n",
        "556": "  }\n",
        "557": "\n",
        "558": "  /**\n",
        "559": "   * Returns an {@code ImmutableMultiset} containing all of the elements from this fluent iterable.\n",
        "560": "   *\n",
        "561": "   * <p><b>{@code Stream} equivalent:</b> {@code ImmutableMultiset.copyOf(stream.iterator())}.\n",
        "562": "   *\n",
        "563": "   * @since 19.0\n",
        "564": "   */\n",
        "565": "  @CheckReturnValue\n",
        "566": "  public final ImmutableMultiset<E> toMultiset() {\n",
        "567": "    return ImmutableMultiset.copyOf(iterable);\n",
        "568": "  }\n",
        "569": "\n",
        "570": "  /**\n",
        "571": "   * Returns an immutable map whose keys are the distinct elements of this {@code FluentIterable}\n",
        "572": "   * and whose value for each key was computed by {@code valueFunction}. The map's iteration order\n",
        "573": "   * is the order of the first appearance of each key in this iterable.\n",
        "574": "   *\n",
        "575": "   * <p>When there are multiple instances of a key in this iterable, it is unspecified whether\n",
        "576": "   * {@code valueFunction} will be applied to more than one instance of that key and, if it is,\n",
        "577": "   * which result will be mapped to that key in the returned map.\n",
        "578": "   *\n",
        "579": "   * <p><b>{@code Stream} equivalent:</b> {@code\n",
        "580": "   * ImmutableMap.copyOf(stream.collect(Collectors.toMap(k -> k, valueFunction)))} (but note that\n",
        "581": "   * this may not preserve the order of entries).\n",
        "582": "   *\n",
        "583": "   * @throws NullPointerException if any element of this iterable is {@code null}, or if {@code\n",
        "584": "   *     valueFunction} produces {@code null} for any key\n",
        "585": "   * @since 14.0\n",
        "586": "   */\n",
        "587": "  @CheckReturnValue\n",
        "588": "  public final <V> ImmutableMap<E, V> toMap(Function<? super E, V> valueFunction) {\n",
        "589": "    return Maps.toMap(iterable, valueFunction);\n",
        "590": "  }\n",
        "591": "\n",
        "592": "  /**\n",
        "593": "   * Creates an index {@code ImmutableListMultimap} that contains the results of applying a\n",
        "594": "   * specified function to each item in this {@code FluentIterable} of values. Each element of this\n",
        "595": "   * iterable will be stored as a value in the resulting multimap, yielding a multimap with the same\n",
        "596": "   * size as this iterable. The key used to store that value in the multimap will be the result of\n",
        "597": "   * calling the function on that value. The resulting multimap is created as an immutable snapshot.\n",
        "598": "   * In the returned multimap, keys appear in the order they are first encountered, and the values\n",
        "599": "   * corresponding to each key appear in the same order as they are encountered.\n",
        "600": "   *\n",
        "601": "   * @param keyFunction the function used to produce the key for each value\n",
        "602": "   * @throws NullPointerException if any of the following cases is true:\n",
        "603": "   *     <ul>\n",
        "604": "   *       <li>{@code keyFunction} is null\n",
        "605": "   *       <li>An element in this fluent iterable is null\n",
        "606": "   *       <li>{@code keyFunction} returns {@code null} for any element of this iterable\n",
        "607": "   *     </ul>\n",
        "608": "   *\n",
        "609": "   * <p><b>{@code Stream} equivalent:</b> {@code stream.collect(Collectors.groupingBy(keyFunction))}\n",
        "610": "   * behaves similarly, but returns a mutable {@code Map<K, List<E>>} instead, and may not preserve\n",
        "611": "   * the order of entries).\n",
        "612": "   *\n",
        "613": "   * @since 14.0\n",
        "614": "   */\n",
        "615": "  @CheckReturnValue\n",
        "616": "  public final <K> ImmutableListMultimap<K, E> index(Function<? super E, K> keyFunction) {\n",
        "617": "    return Multimaps.index(iterable, keyFunction);\n",
        "618": "  }\n",
        "619": "\n",
        "620": "  /**\n",
        "621": "   * Returns a map with the contents of this {@code FluentIterable} as its {@code values}, indexed\n",
        "622": "   * by keys derived from those values. In other words, each input value produces an entry in the\n",
        "623": "   * map whose key is the result of applying {@code keyFunction} to that value. These entries appear\n",
        "624": "   * in the same order as they appeared in this fluent iterable. Example usage:\n",
        "625": "   * <pre>   {@code\n",
        "626": "   *\n",
        "627": "   *   Color red = new Color(\"red\", 255, 0, 0);\n",
        "628": "   *   ...\n",
        "629": "   *   FluentIterable<Color> allColors = FluentIterable.from(ImmutableSet.of(red, green, blue));\n",
        "630": "   *\n",
        "631": "   *   Map<String, Color> colorForName = allColors.uniqueIndex(toStringFunction());\n",
        "632": "   *   assertThat(colorForName).containsEntry(\"red\", red);}</pre>\n",
        "633": "   *\n",
        "634": "   * <p>If your index may associate multiple values with each key, use {@link #index(Function)\n",
        "635": "   * index}.\n",
        "636": "   *\n",
        "637": "   * <p><b>{@code Stream} equivalent:</b> {@code\n",
        "638": "   * ImmutableMap.copyOf(stream.collect(Collectors.toMap(keyFunction, v -> v)))} (but note that this\n",
        "639": "   * may not preserve the order of entries).\n",
        "640": "   *\n",
        "641": "   * @param keyFunction the function used to produce the key for each value\n",
        "642": "   * @return a map mapping the result of evaluating the function {@code\n",
        "643": "   *     keyFunction} on each value in this fluent iterable to that value\n",
        "644": "   * @throws IllegalArgumentException if {@code keyFunction} produces the same\n",
        "645": "   *     key for more than one value in this fluent iterable\n",
        "646": "   * @throws NullPointerException if any elements of this fluent iterable is null, or\n",
        "647": "   *     if {@code keyFunction} produces {@code null} for any value\n",
        "648": "   * @since 14.0\n",
        "649": "   */\n",
        "650": "  @CheckReturnValue\n",
        "651": "  public final <K> ImmutableMap<K, E> uniqueIndex(Function<? super E, K> keyFunction) {\n",
        "652": "    return Maps.uniqueIndex(iterable, keyFunction);\n",
        "653": "  }\n",
        "654": "\n",
        "655": "  /**\n",
        "656": "   * Copies all the elements from this fluent iterable to {@code collection}. This is equivalent to\n",
        "657": "   * calling {@code Iterables.addAll(collection, this)}.\n",
        "658": "   *\n",
        "659": "   * <p><b>{@code Stream} equivalent:</b> {@code stream.forEachOrdered(collection::add)} or\n",
        "660": "   * {@code stream.forEach(collection::add)}.\n",
        "661": "   *\n",
        "662": "   * @param collection the collection to copy elements to\n",
        "663": "   * @return {@code collection}, for convenience\n",
        "664": "   * @since 14.0\n",
        "665": "   */\n",
        "666": "  public final <C extends Collection<? super E>> C copyInto(C collection) {\n",
        "667": "    checkNotNull(collection);\n",
        "668": "    if (iterable instanceof Collection) {\n",
        "669": "      collection.addAll(Collections2.cast(iterable));\n",
        "670": "    } else {\n",
        "671": "      for (E item : iterable) {\n",
        "672": "        collection.add(item);\n",
        "673": "      }\n",
        "674": "    }\n",
        "675": "    return collection;\n",
        "676": "  }\n",
        "677": "\n",
        "678": "  /**\n",
        "679": "   * Returns a {@link String} containing all of the elements of this fluent iterable joined with\n",
        "680": "   * {@code joiner}.\n",
        "681": "   *\n",
        "682": "   * <p><b>{@code Stream} equivalent:</b> {@code joiner.join(stream.iterator())}, or, if you are not\n",
        "683": "   * using any optional {@code Joiner} features,\n",
        "684": "   * {@code stream.collect(Collectors.joining(delimiter)}.\n",
        "685": "   *\n",
        "686": "   * @since 18.0\n",
        "687": "   */\n",
        "688": "  @Beta\n",
        "689": "  @CheckReturnValue\n",
        "690": "  public final String join(Joiner joiner) {\n",
        "691": "    return joiner.join(this);\n",
        "692": "  }\n",
        "693": "\n",
        "694": "  /**\n",
        "695": "   * Returns the element at the specified position in this fluent iterable.\n",
        "696": "   *\n",
        "697": "   * <p><b>{@code Stream} equivalent:</b> {@code stream.skip(position).findFirst().get()} (but note\n",
        "698": "   * that this throws different exception types, and throws an exception if {@code null} would be\n",
        "699": "   * returned).\n",
        "700": "   *\n",
        "701": "   * @param position position of the element to return\n",
        "702": "   * @return the element at the specified position in this fluent iterable\n",
        "703": "   * @throws IndexOutOfBoundsException if {@code position} is negative or greater than or equal to\n",
        "704": "   *     the size of this fluent iterable\n",
        "705": "   */\n",
        "706": "  // TODO(kevinb): add @Nullable?\n",
        "707": "  @CheckReturnValue\n",
        "708": "  public final E get(int position) {\n",
        "709": "    return Iterables.get(iterable, position);\n",
        "710": "  }\n",
        "711": "\n",
        "712": "  /**\n",
        "713": "   * Function that transforms {@code Iterable<E>} into a fluent iterable.\n",
        "714": "   */\n",
        "715": "  private static class FromIterableFunction<E> implements Function<Iterable<E>, FluentIterable<E>> {\n",
        "716": "    @Override\n",
        "717": "    public FluentIterable<E> apply(Iterable<E> fromObject) {\n",
        "718": "      return FluentIterable.from(fromObject);\n",
        "719": "    }\n",
        "720": "  }\n",
        "721": "}\n"
    }
}