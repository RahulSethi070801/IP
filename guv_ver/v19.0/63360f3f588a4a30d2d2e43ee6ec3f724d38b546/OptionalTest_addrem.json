{
    "addition": {},
    "removed": {
        "1": "/*\n",
        "2": " * Copyright (C) 2011 The Guava Authors\n",
        "3": " *\n",
        "4": " * Licensed under the Apache License, Version 2.0 (the \"License\");\n",
        "5": " * you may not use this file except in compliance with the License.\n",
        "6": " * You may obtain a copy of the License at\n",
        "7": " *\n",
        "8": " * http://www.apache.org/licenses/LICENSE-2.0\n",
        "9": " *\n",
        "10": " * Unless required by applicable law or agreed to in writing, software\n",
        "11": " * distributed under the License is distributed on an \"AS IS\" BASIS,\n",
        "12": " * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n",
        "13": " * See the License for the specific language governing permissions and\n",
        "14": " * limitations under the License.\n",
        "15": " */\n",
        "16": "\n",
        "17": "package com.google.common.base;\n",
        "18": "\n",
        "19": "import static com.google.common.truth.Truth.assertThat;\n",
        "20": "\n",
        "21": "import com.google.common.annotations.GwtCompatible;\n",
        "22": "import com.google.common.collect.FluentIterable;\n",
        "23": "import com.google.common.collect.ImmutableList;\n",
        "24": "\n",
        "25": "import junit.framework.TestCase;\n",
        "26": "\n",
        "27": "import java.util.Collections;\n",
        "28": "import java.util.List;\n",
        "29": "import java.util.Set;\n",
        "30": "\n",
        "31": "/**\n",
        "32": " * Unit test for {@link Optional}.\n",
        "33": " *\n",
        "34": " * @author Kurt Alfred Kluever\n",
        "35": " */\n",
        "36": "@GwtCompatible(emulated = true)\n",
        "37": "public final class OptionalTest extends TestCase {\n",
        "38": "  public void testAbsent() {\n",
        "39": "    Optional<String> optionalName = Optional.absent();\n",
        "40": "    assertFalse(optionalName.isPresent());\n",
        "41": "  }\n",
        "42": "\n",
        "43": "  public void testOf() {\n",
        "44": "    assertEquals(\"training\", Optional.of(\"training\").get());\n",
        "45": "  }\n",
        "46": "\n",
        "47": "  @SuppressWarnings(\"CheckReturnValue\")\n",
        "48": "  public void testOf_null() {\n",
        "49": "    try {\n",
        "50": "      Optional.of(null);\n",
        "51": "      fail();\n",
        "52": "    } catch (NullPointerException expected) {\n",
        "53": "    }\n",
        "54": "  }\n",
        "55": "\n",
        "56": "  public void testFromNullable() {\n",
        "57": "    Optional<String> optionalName = Optional.fromNullable(\"bob\");\n",
        "58": "    assertEquals(\"bob\", optionalName.get());\n",
        "59": "  }\n",
        "60": "\n",
        "61": "  public void testFromNullable_null() {\n",
        "62": "    // not promised by spec, but easier to test\n",
        "63": "    assertSame(Optional.absent(), Optional.fromNullable(null));\n",
        "64": "  }\n",
        "65": "\n",
        "66": "  public void testIsPresent_no() {\n",
        "67": "    assertFalse(Optional.absent().isPresent());\n",
        "68": "  }\n",
        "69": "\n",
        "70": "  public void testIsPresent_yes() {\n",
        "71": "    assertTrue(Optional.of(\"training\").isPresent());\n",
        "72": "  }\n",
        "73": "\n",
        "74": "  @SuppressWarnings(\"CheckReturnValue\")\n",
        "75": "  public void testGet_absent() {\n",
        "76": "    Optional<String> optional = Optional.absent();\n",
        "77": "    try {\n",
        "78": "      optional.get();\n",
        "79": "      fail();\n",
        "80": "    } catch (IllegalStateException expected) {\n",
        "81": "    }\n",
        "82": "  }\n",
        "83": "\n",
        "84": "  public void testGet_present() {\n",
        "85": "    assertEquals(\"training\", Optional.of(\"training\").get());\n",
        "86": "  }\n",
        "87": "\n",
        "88": "  public void testOr_T_present() {\n",
        "89": "    assertEquals(\"a\", Optional.of(\"a\").or(\"default\"));\n",
        "90": "  }\n",
        "91": "\n",
        "92": "  public void testOr_T_absent() {\n",
        "93": "    assertEquals(\"default\", Optional.absent().or(\"default\"));\n",
        "94": "  }\n",
        "95": "\n",
        "96": "  public void testOr_supplier_present() {\n",
        "97": "    assertEquals(\"a\", Optional.of(\"a\").or(Suppliers.ofInstance(\"fallback\")));\n",
        "98": "  }\n",
        "99": "\n",
        "100": "  public void testOr_supplier_absent() {\n",
        "101": "    assertEquals(\"fallback\", Optional.absent().or(Suppliers.ofInstance(\"fallback\")));\n",
        "102": "  }\n",
        "103": "\n",
        "104": "  @SuppressWarnings(\"CheckReturnValue\")\n",
        "105": "  public void testOr_nullSupplier_absent() {\n",
        "106": "    Supplier<Object> nullSupplier = Suppliers.ofInstance(null);\n",
        "107": "    Optional<Object> absentOptional = Optional.absent();\n",
        "108": "    try {\n",
        "109": "      absentOptional.or(nullSupplier);\n",
        "110": "      fail();\n",
        "111": "    } catch (NullPointerException expected) {\n",
        "112": "    }\n",
        "113": "  }\n",
        "114": "\n",
        "115": "  public void testOr_nullSupplier_present() {\n",
        "116": "    Supplier<String> nullSupplier = Suppliers.ofInstance(null);\n",
        "117": "    assertEquals(\"a\", Optional.of(\"a\").or(nullSupplier));\n",
        "118": "  }\n",
        "119": "\n",
        "120": "  public void testOr_Optional_present() {\n",
        "121": "    assertEquals(Optional.of(\"a\"), Optional.of(\"a\").or(Optional.of(\"fallback\")));\n",
        "122": "  }\n",
        "123": "\n",
        "124": "  public void testOr_Optional_absent() {\n",
        "125": "    assertEquals(Optional.of(\"fallback\"), Optional.absent().or(Optional.of(\"fallback\")));\n",
        "126": "  }\n",
        "127": "\n",
        "128": "  public void testOrNull_present() {\n",
        "129": "    assertEquals(\"a\", Optional.of(\"a\").orNull());\n",
        "130": "  }\n",
        "131": "\n",
        "132": "  public void testOrNull_absent() {\n",
        "133": "    assertNull(Optional.absent().orNull());\n",
        "134": "  }\n",
        "135": "\n",
        "136": "  public void testAsSet_present() {\n",
        "137": "    Set<String> expected = Collections.singleton(\"a\");\n",
        "138": "    assertEquals(expected, Optional.of(\"a\").asSet());\n",
        "139": "  }\n",
        "140": "\n",
        "141": "  public void testAsSet_absent() {\n",
        "142": "    assertTrue(\"Returned set should be empty\", Optional.absent().asSet().isEmpty());\n",
        "143": "  }\n",
        "144": "\n",
        "145": "  public void testAsSet_presentIsImmutable() {\n",
        "146": "    Set<String> presentAsSet = Optional.of(\"a\").asSet();\n",
        "147": "    try {\n",
        "148": "      presentAsSet.add(\"b\");\n",
        "149": "      fail();\n",
        "150": "    } catch (UnsupportedOperationException expected) {\n",
        "151": "    }\n",
        "152": "  }\n",
        "153": "\n",
        "154": "  public void testAsSet_absentIsImmutable() {\n",
        "155": "    Set<Object> absentAsSet = Optional.absent().asSet();\n",
        "156": "    try {\n",
        "157": "      absentAsSet.add(\"foo\");\n",
        "158": "      fail();\n",
        "159": "    } catch (UnsupportedOperationException expected) {\n",
        "160": "    }\n",
        "161": "  }\n",
        "162": "\n",
        "163": "  public void testTransform_absent() {\n",
        "164": "    assertEquals(Optional.absent(), Optional.absent().transform(Functions.identity()));\n",
        "165": "    assertEquals(Optional.absent(), Optional.absent().transform(Functions.toStringFunction()));\n",
        "166": "  }\n",
        "167": "\n",
        "168": "  public void testTransform_presentIdentity() {\n",
        "169": "    assertEquals(Optional.of(\"a\"), Optional.of(\"a\").transform(Functions.identity()));\n",
        "170": "  }\n",
        "171": "\n",
        "172": "  public void testTransform_presentToString() {\n",
        "173": "    assertEquals(Optional.of(\"42\"), Optional.of(42).transform(Functions.toStringFunction()));\n",
        "174": "  }\n",
        "175": "\n",
        "176": "  @SuppressWarnings(\"CheckReturnValue\")\n",
        "177": "  public void testTransform_present_functionReturnsNull() {\n",
        "178": "    try {\n",
        "179": "      Optional.of(\"a\").transform(\n",
        "180": "          new Function<String, String>() {\n",
        "181": "            @Override public String apply(String input) {\n",
        "182": "              return null;\n",
        "183": "            }\n",
        "184": "          });\n",
        "185": "      fail(\"Should throw if Function returns null.\");\n",
        "186": "    } catch (NullPointerException expected) {\n",
        "187": "    }\n",
        "188": "  }\n",
        "189": "\n",
        "190": "  public void testTransform_abssent_functionReturnsNull() {\n",
        "191": "    assertEquals(Optional.absent(),\n",
        "192": "        Optional.absent().transform(\n",
        "193": "          new Function<Object, Object>() {\n",
        "194": "            @Override public Object apply(Object input) {\n",
        "195": "              return null;\n",
        "196": "            }\n",
        "197": "          }));\n",
        "198": "  }\n",
        "199": "\n",
        "200": "  // TODO(kevinb): use EqualsTester\n",
        "201": "\n",
        "202": "  public void testEqualsAndHashCode_absent() {\n",
        "203": "    assertEquals(Optional.<String>absent(), Optional.<Integer>absent());\n",
        "204": "    assertEquals(Optional.absent().hashCode(), Optional.absent().hashCode());\n",
        "205": "    assertThat(Optional.absent().hashCode())\n",
        "206": "        .isNotEqualTo(Optional.of(0).hashCode());\n",
        "207": "  }\n",
        "208": "\n",
        "209": "  public void testEqualsAndHashCode_present() {\n",
        "210": "    assertEquals(Optional.of(\"training\"), Optional.of(\"training\"));\n",
        "211": "    assertFalse(Optional.of(\"a\").equals(Optional.of(\"b\")));\n",
        "212": "    assertFalse(Optional.of(\"a\").equals(Optional.absent()));\n",
        "213": "    assertEquals(Optional.of(\"training\").hashCode(), Optional.of(\"training\").hashCode());\n",
        "214": "  }\n",
        "215": "\n",
        "216": "  public void testToString_absent() {\n",
        "217": "    assertEquals(\"Optional.absent()\", Optional.absent().toString());\n",
        "218": "  }\n",
        "219": "\n",
        "220": "  public void testToString_present() {\n",
        "221": "    assertEquals(\"Optional.of(training)\", Optional.of(\"training\").toString());\n",
        "222": "  }\n",
        "223": "\n",
        "224": "  public void testPresentInstances_allPresent() {\n",
        "225": "    List<Optional<String>> optionals =\n",
        "226": "        ImmutableList.of(Optional.of(\"a\"), Optional.of(\"b\"), Optional.of(\"c\"));\n",
        "227": "    assertThat(Optional.presentInstances(optionals)).containsExactly(\"a\", \"b\", \"c\").inOrder();\n",
        "228": "  }\n",
        "229": "\n",
        "230": "  public void testPresentInstances_allAbsent() {\n",
        "231": "    List<Optional<Object>> optionals =\n",
        "232": "        ImmutableList.of(Optional.absent(), Optional.absent());\n",
        "233": "    assertThat(Optional.presentInstances(optionals)).isEmpty();\n",
        "234": "  }\n",
        "235": "\n",
        "236": "  public void testPresentInstances_somePresent() {\n",
        "237": "    List<Optional<String>> optionals =\n",
        "238": "        ImmutableList.of(Optional.of(\"a\"), Optional.<String>absent(), Optional.of(\"c\"));\n",
        "239": "    assertThat(Optional.presentInstances(optionals)).containsExactly(\"a\", \"c\").inOrder();\n",
        "240": "  }\n",
        "241": "\n",
        "242": "  public void testPresentInstances_callingIteratorTwice() {\n",
        "243": "    List<Optional<String>> optionals =\n",
        "244": "        ImmutableList.of(Optional.of(\"a\"), Optional.<String>absent(), Optional.of(\"c\"));\n",
        "245": "    Iterable<String> onlyPresent = Optional.presentInstances(optionals);\n",
        "246": "    assertThat(onlyPresent).containsExactly(\"a\", \"c\").inOrder();\n",
        "247": "    assertThat(onlyPresent).containsExactly(\"a\", \"c\").inOrder();\n",
        "248": "  }\n",
        "249": "\n",
        "250": "  public void testPresentInstances_wildcards() {\n",
        "251": "    List<Optional<? extends Number>> optionals =\n",
        "252": "        ImmutableList.<Optional<? extends Number>>of(Optional.<Double>absent(), Optional.of(2));\n",
        "253": "    Iterable<Number> onlyPresent = Optional.presentInstances(optionals);\n",
        "254": "    assertThat(onlyPresent).containsExactly(2).inOrder();\n",
        "255": "  }\n",
        "256": "\n",
        "257": "  private static Optional<Integer> getSomeOptionalInt() {\n",
        "258": "    return Optional.of(1);\n",
        "259": "  }\n",
        "260": "\n",
        "261": "  private static FluentIterable<? extends Number> getSomeNumbers() {\n",
        "262": "    return FluentIterable.from(ImmutableList.<Number>of());\n",
        "263": "  }\n",
        "264": "\n",
        "265": "  /*\n",
        "266": "   * The following tests demonstrate the shortcomings of or() and test that the casting workaround\n",
        "267": "   * mentioned in the method Javadoc does in fact compile.\n",
        "268": "   */\n",
        "269": "\n",
        "270": "  @SuppressWarnings(\"unused\") // compilation test\n",
        "271": "  public void testSampleCodeError1() {\n",
        "272": "    Optional<Integer> optionalInt = getSomeOptionalInt();\n",
        "273": "    // Number value = optionalInt.or(0.5); // error\n",
        "274": "  }\n",
        "275": "\n",
        "276": "  @SuppressWarnings(\"unused\") // compilation test\n",
        "277": "  public void testSampleCodeError2() {\n",
        "278": "    FluentIterable<? extends Number> numbers = getSomeNumbers();\n",
        "279": "    Optional<? extends Number> first = numbers.first();\n",
        "280": "    // Number value = first.or(0.5); // error\n",
        "281": "  }\n",
        "282": "\n",
        "283": "  @SuppressWarnings(\"unused\") // compilation test\n",
        "284": "  public void testSampleCodeFine1() {\n",
        "285": "    Optional<Number> optionalInt = Optional.of((Number) 1);\n",
        "286": "    Number value = optionalInt.or(0.5); // fine\n",
        "287": "  }\n",
        "288": "\n",
        "289": "  @SuppressWarnings(\"unused\") // compilation test\n",
        "290": "  public void testSampleCodeFine2() {\n",
        "291": "    FluentIterable<? extends Number> numbers = getSomeNumbers();\n",
        "292": "\n",
        "293": "    // Sadly, the following is what users will have to do in some circumstances.\n",
        "294": "\n",
        "295": "    @SuppressWarnings(\"unchecked\") // safe covariant cast\n",
        "296": "    Optional<Number> first = (Optional) numbers.first();\n",
        "297": "    Number value = first.or(0.5); // fine\n",
        "298": "  }\n",
        "299": "}\n",
        "300": "\n"
    }
}