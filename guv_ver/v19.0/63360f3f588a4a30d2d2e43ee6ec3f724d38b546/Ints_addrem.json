{
    "addition": {},
    "removed": {
        "1": "/*\n",
        "2": " * Copyright (C) 2008 The Guava Authors\n",
        "3": " *\n",
        "4": " * Licensed under the Apache License, Version 2.0 (the \"License\");\n",
        "5": " * you may not use this file except in compliance with the License.\n",
        "6": " * You may obtain a copy of the License at\n",
        "7": " *\n",
        "8": " * http://www.apache.org/licenses/LICENSE-2.0\n",
        "9": " *\n",
        "10": " * Unless required by applicable law or agreed to in writing, software\n",
        "11": " * distributed under the License is distributed on an \"AS IS\" BASIS,\n",
        "12": " * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n",
        "13": " * See the License for the specific language governing permissions and\n",
        "14": " * limitations under the License.\n",
        "15": " */\n",
        "16": "\n",
        "17": "package com.google.common.primitives;\n",
        "18": "\n",
        "19": "import static com.google.common.base.Preconditions.checkArgument;\n",
        "20": "import static com.google.common.base.Preconditions.checkElementIndex;\n",
        "21": "import static com.google.common.base.Preconditions.checkNotNull;\n",
        "22": "import static com.google.common.base.Preconditions.checkPositionIndexes;\n",
        "23": "\n",
        "24": "import com.google.common.annotations.Beta;\n",
        "25": "import com.google.common.annotations.GwtCompatible;\n",
        "26": "import com.google.common.base.Converter;\n",
        "27": "\n",
        "28": "import java.io.Serializable;\n",
        "29": "import java.util.AbstractList;\n",
        "30": "import java.util.Collection;\n",
        "31": "import java.util.Collections;\n",
        "32": "import java.util.Comparator;\n",
        "33": "import java.util.List;\n",
        "34": "import java.util.RandomAccess;\n",
        "35": "\n",
        "36": "import javax.annotation.CheckForNull;\n",
        "37": "import javax.annotation.CheckReturnValue;\n",
        "38": "import javax.annotation.Nullable;\n",
        "39": "\n",
        "40": "/**\n",
        "41": " * Static utility methods pertaining to {@code int} primitives, that are not\n",
        "42": " * already found in either {@link Integer} or {@link Arrays}.\n",
        "43": " *\n",
        "44": " * <p>See the Guava User Guide article on <a href=\n",
        "45": " * \"https://github.com/google/guava/wiki/PrimitivesExplained\">\n",
        "46": " * primitive utilities</a>.\n",
        "47": " *\n",
        "48": " * @author Kevin Bourrillion\n",
        "49": " * @since 1.0\n",
        "50": " */\n",
        "51": "@CheckReturnValue\n",
        "52": "@GwtCompatible(emulated = true)\n",
        "53": "public final class Ints {\n",
        "54": "  private Ints() {}\n",
        "55": "\n",
        "56": "  /**\n",
        "57": "   * The number of bytes required to represent a primitive {@code int}\n",
        "58": "   * value.\n",
        "59": "   */\n",
        "60": "  public static final int BYTES = Integer.SIZE / Byte.SIZE;\n",
        "61": "\n",
        "62": "  /**\n",
        "63": "   * The largest power of two that can be represented as an {@code int}.\n",
        "64": "   *\n",
        "65": "   * @since 10.0\n",
        "66": "   */\n",
        "67": "  public static final int MAX_POWER_OF_TWO = 1 << (Integer.SIZE - 2);\n",
        "68": "\n",
        "69": "  /**\n",
        "70": "   * Returns a hash code for {@code value}; equal to the result of invoking\n",
        "71": "   * {@code ((Integer) value).hashCode()}.\n",
        "72": "   *\n",
        "73": "   * @param value a primitive {@code int} value\n",
        "74": "   * @return a hash code for the value\n",
        "75": "   */\n",
        "76": "  public static int hashCode(int value) {\n",
        "77": "    return value;\n",
        "78": "  }\n",
        "79": "\n",
        "80": "  /**\n",
        "81": "   * Returns the {@code int} value that is equal to {@code value}, if possible.\n",
        "82": "   *\n",
        "83": "   * @param value any value in the range of the {@code int} type\n",
        "84": "   * @return the {@code int} value that equals {@code value}\n",
        "85": "   * @throws IllegalArgumentException if {@code value} is greater than {@link\n",
        "86": "   *     Integer#MAX_VALUE} or less than {@link Integer#MIN_VALUE}\n",
        "87": "   */\n",
        "88": "  public static int checkedCast(long value) {\n",
        "89": "    int result = (int) value;\n",
        "90": "    if (result != value) {\n",
        "91": "      // don't use checkArgument here, to avoid boxing\n",
        "92": "      throw new IllegalArgumentException(\"Out of range: \" + value);\n",
        "93": "    }\n",
        "94": "    return result;\n",
        "95": "  }\n",
        "96": "\n",
        "97": "  /**\n",
        "98": "   * Returns the {@code int} nearest in value to {@code value}.\n",
        "99": "   *\n",
        "100": "   * @param value any {@code long} value\n",
        "101": "   * @return the same value cast to {@code int} if it is in the range of the\n",
        "102": "   *     {@code int} type, {@link Integer#MAX_VALUE} if it is too large,\n",
        "103": "   *     or {@link Integer#MIN_VALUE} if it is too small\n",
        "104": "   */\n",
        "105": "  public static int saturatedCast(long value) {\n",
        "106": "    if (value > Integer.MAX_VALUE) {\n",
        "107": "      return Integer.MAX_VALUE;\n",
        "108": "    }\n",
        "109": "    if (value < Integer.MIN_VALUE) {\n",
        "110": "      return Integer.MIN_VALUE;\n",
        "111": "    }\n",
        "112": "    return (int) value;\n",
        "113": "  }\n",
        "114": "\n",
        "115": "  /**\n",
        "116": "   * Compares the two specified {@code int} values. The sign of the value\n",
        "117": "   * returned is the same as that of {@code ((Integer) a).compareTo(b)}.\n",
        "118": "   *\n",
        "119": "   * <p><b>Note for Java 7 and later:</b> this method should be treated as\n",
        "120": "   * deprecated; use the equivalent {@link Integer#compare} method instead.\n",
        "121": "   *\n",
        "122": "   * @param a the first {@code int} to compare\n",
        "123": "   * @param b the second {@code int} to compare\n",
        "124": "   * @return a negative value if {@code a} is less than {@code b}; a positive\n",
        "125": "   *     value if {@code a} is greater than {@code b}; or zero if they are equal\n",
        "126": "   */\n",
        "127": "  public static int compare(int a, int b) {\n",
        "128": "    return (a < b) ? -1 : ((a > b) ? 1 : 0);\n",
        "129": "  }\n",
        "130": "\n",
        "131": "  /**\n",
        "132": "   * Returns {@code true} if {@code target} is present as an element anywhere in\n",
        "133": "   * {@code array}.\n",
        "134": "   *\n",
        "135": "   * @param array an array of {@code int} values, possibly empty\n",
        "136": "   * @param target a primitive {@code int} value\n",
        "137": "   * @return {@code true} if {@code array[i] == target} for some value of {@code\n",
        "138": "   *     i}\n",
        "139": "   */\n",
        "140": "  public static boolean contains(int[] array, int target) {\n",
        "141": "    for (int value : array) {\n",
        "142": "      if (value == target) {\n",
        "143": "        return true;\n",
        "144": "      }\n",
        "145": "    }\n",
        "146": "    return false;\n",
        "147": "  }\n",
        "148": "\n",
        "149": "  /**\n",
        "150": "   * Returns the index of the first appearance of the value {@code target} in\n",
        "151": "   * {@code array}.\n",
        "152": "   *\n",
        "153": "   * @param array an array of {@code int} values, possibly empty\n",
        "154": "   * @param target a primitive {@code int} value\n",
        "155": "   * @return the least index {@code i} for which {@code array[i] == target}, or\n",
        "156": "   *     {@code -1} if no such index exists.\n",
        "157": "   */\n",
        "158": "  public static int indexOf(int[] array, int target) {\n",
        "159": "    return indexOf(array, target, 0, array.length);\n",
        "160": "  }\n",
        "161": "\n",
        "162": "  // TODO(kevinb): consider making this public\n",
        "163": "  private static int indexOf(int[] array, int target, int start, int end) {\n",
        "164": "    for (int i = start; i < end; i++) {\n",
        "165": "      if (array[i] == target) {\n",
        "166": "        return i;\n",
        "167": "      }\n",
        "168": "    }\n",
        "169": "    return -1;\n",
        "170": "  }\n",
        "171": "\n",
        "172": "  /**\n",
        "173": "   * Returns the start position of the first occurrence of the specified {@code\n",
        "174": "   * target} within {@code array}, or {@code -1} if there is no such occurrence.\n",
        "175": "   *\n",
        "176": "   * <p>More formally, returns the lowest index {@code i} such that {@code\n",
        "177": "   * java.util.Arrays.copyOfRange(array, i, i + target.length)} contains exactly\n",
        "178": "   * the same elements as {@code target}.\n",
        "179": "   *\n",
        "180": "   * @param array the array to search for the sequence {@code target}\n",
        "181": "   * @param target the array to search for as a sub-sequence of {@code array}\n",
        "182": "   */\n",
        "183": "  public static int indexOf(int[] array, int[] target) {\n",
        "184": "    checkNotNull(array, \"array\");\n",
        "185": "    checkNotNull(target, \"target\");\n",
        "186": "    if (target.length == 0) {\n",
        "187": "      return 0;\n",
        "188": "    }\n",
        "189": "\n",
        "190": "    outer:\n",
        "191": "    for (int i = 0; i < array.length - target.length + 1; i++) {\n",
        "192": "      for (int j = 0; j < target.length; j++) {\n",
        "193": "        if (array[i + j] != target[j]) {\n",
        "194": "          continue outer;\n",
        "195": "        }\n",
        "196": "      }\n",
        "197": "      return i;\n",
        "198": "    }\n",
        "199": "    return -1;\n",
        "200": "  }\n",
        "201": "\n",
        "202": "  /**\n",
        "203": "   * Returns the index of the last appearance of the value {@code target} in\n",
        "204": "   * {@code array}.\n",
        "205": "   *\n",
        "206": "   * @param array an array of {@code int} values, possibly empty\n",
        "207": "   * @param target a primitive {@code int} value\n",
        "208": "   * @return the greatest index {@code i} for which {@code array[i] == target},\n",
        "209": "   *     or {@code -1} if no such index exists.\n",
        "210": "   */\n",
        "211": "  public static int lastIndexOf(int[] array, int target) {\n",
        "212": "    return lastIndexOf(array, target, 0, array.length);\n",
        "213": "  }\n",
        "214": "\n",
        "215": "  // TODO(kevinb): consider making this public\n",
        "216": "  private static int lastIndexOf(int[] array, int target, int start, int end) {\n",
        "217": "    for (int i = end - 1; i >= start; i--) {\n",
        "218": "      if (array[i] == target) {\n",
        "219": "        return i;\n",
        "220": "      }\n",
        "221": "    }\n",
        "222": "    return -1;\n",
        "223": "  }\n",
        "224": "\n",
        "225": "  /**\n",
        "226": "   * Returns the least value present in {@code array}.\n",
        "227": "   *\n",
        "228": "   * @param array a <i>nonempty</i> array of {@code int} values\n",
        "229": "   * @return the value present in {@code array} that is less than or equal to\n",
        "230": "   *     every other value in the array\n",
        "231": "   * @throws IllegalArgumentException if {@code array} is empty\n",
        "232": "   */\n",
        "233": "  public static int min(int... array) {\n",
        "234": "    checkArgument(array.length > 0);\n",
        "235": "    int min = array[0];\n",
        "236": "    for (int i = 1; i < array.length; i++) {\n",
        "237": "      if (array[i] < min) {\n",
        "238": "        min = array[i];\n",
        "239": "      }\n",
        "240": "    }\n",
        "241": "    return min;\n",
        "242": "  }\n",
        "243": "\n",
        "244": "  /**\n",
        "245": "   * Returns the greatest value present in {@code array}.\n",
        "246": "   *\n",
        "247": "   * @param array a <i>nonempty</i> array of {@code int} values\n",
        "248": "   * @return the value present in {@code array} that is greater than or equal to\n",
        "249": "   *     every other value in the array\n",
        "250": "   * @throws IllegalArgumentException if {@code array} is empty\n",
        "251": "   */\n",
        "252": "  public static int max(int... array) {\n",
        "253": "    checkArgument(array.length > 0);\n",
        "254": "    int max = array[0];\n",
        "255": "    for (int i = 1; i < array.length; i++) {\n",
        "256": "      if (array[i] > max) {\n",
        "257": "        max = array[i];\n",
        "258": "      }\n",
        "259": "    }\n",
        "260": "    return max;\n",
        "261": "  }\n",
        "262": "\n",
        "263": "  /**\n",
        "264": "   * Returns the values from each provided array combined into a single array.\n",
        "265": "   * For example, {@code concat(new int[] {a, b}, new int[] {}, new\n",
        "266": "   * int[] {c}} returns the array {@code {a, b, c}}.\n",
        "267": "   *\n",
        "268": "   * @param arrays zero or more {@code int} arrays\n",
        "269": "   * @return a single array containing all the values from the source arrays, in\n",
        "270": "   *     order\n",
        "271": "   */\n",
        "272": "  public static int[] concat(int[]... arrays) {\n",
        "273": "    int length = 0;\n",
        "274": "    for (int[] array : arrays) {\n",
        "275": "      length += array.length;\n",
        "276": "    }\n",
        "277": "    int[] result = new int[length];\n",
        "278": "    int pos = 0;\n",
        "279": "    for (int[] array : arrays) {\n",
        "280": "      System.arraycopy(array, 0, result, pos, array.length);\n",
        "281": "      pos += array.length;\n",
        "282": "    }\n",
        "283": "    return result;\n",
        "284": "  }\n",
        "285": "\n",
        "286": "  private static final class IntConverter extends Converter<String, Integer>\n",
        "287": "      implements Serializable {\n",
        "288": "    static final IntConverter INSTANCE = new IntConverter();\n",
        "289": "\n",
        "290": "    @Override\n",
        "291": "    protected Integer doForward(String value) {\n",
        "292": "      return Integer.decode(value);\n",
        "293": "    }\n",
        "294": "\n",
        "295": "    @Override\n",
        "296": "    protected String doBackward(Integer value) {\n",
        "297": "      return value.toString();\n",
        "298": "    }\n",
        "299": "\n",
        "300": "    @Override\n",
        "301": "    public String toString() {\n",
        "302": "      return \"Ints.stringConverter()\";\n",
        "303": "    }\n",
        "304": "\n",
        "305": "    private Object readResolve() {\n",
        "306": "      return INSTANCE;\n",
        "307": "    }\n",
        "308": "\n",
        "309": "    private static final long serialVersionUID = 1;\n",
        "310": "  }\n",
        "311": "\n",
        "312": "  /**\n",
        "313": "   * Returns a serializable converter object that converts between strings and\n",
        "314": "   * integers using {@link Integer#decode} and {@link Integer#toString()}.\n",
        "315": "   *\n",
        "316": "   * @since 16.0\n",
        "317": "   */\n",
        "318": "  @Beta\n",
        "319": "  public static Converter<String, Integer> stringConverter() {\n",
        "320": "    return IntConverter.INSTANCE;\n",
        "321": "  }\n",
        "322": "\n",
        "323": "  /**\n",
        "324": "   * Returns an array containing the same values as {@code array}, but\n",
        "325": "   * guaranteed to be of a specified minimum length. If {@code array} already\n",
        "326": "   * has a length of at least {@code minLength}, it is returned directly.\n",
        "327": "   * Otherwise, a new array of size {@code minLength + padding} is returned,\n",
        "328": "   * containing the values of {@code array}, and zeroes in the remaining places.\n",
        "329": "   *\n",
        "330": "   * @param array the source array\n",
        "331": "   * @param minLength the minimum length the returned array must guarantee\n",
        "332": "   * @param padding an extra amount to \"grow\" the array by if growth is\n",
        "333": "   *     necessary\n",
        "334": "   * @throws IllegalArgumentException if {@code minLength} or {@code padding} is\n",
        "335": "   *     negative\n",
        "336": "   * @return an array containing the values of {@code array}, with guaranteed\n",
        "337": "   *     minimum length {@code minLength}\n",
        "338": "   */\n",
        "339": "  public static int[] ensureCapacity(int[] array, int minLength, int padding) {\n",
        "340": "    checkArgument(minLength >= 0, \"Invalid minLength: %s\", minLength);\n",
        "341": "    checkArgument(padding >= 0, \"Invalid padding: %s\", padding);\n",
        "342": "    return (array.length < minLength)\n",
        "343": "        ? copyOf(array, minLength + padding)\n",
        "344": "        : array;\n",
        "345": "  }\n",
        "346": "\n",
        "347": "  // Arrays.copyOf() requires Java 6\n",
        "348": "  private static int[] copyOf(int[] original, int length) {\n",
        "349": "    int[] copy = new int[length];\n",
        "350": "    System.arraycopy(original, 0, copy, 0, Math.min(original.length, length));\n",
        "351": "    return copy;\n",
        "352": "  }\n",
        "353": "\n",
        "354": "  /**\n",
        "355": "   * Returns a string containing the supplied {@code int} values separated\n",
        "356": "   * by {@code separator}. For example, {@code join(\"-\", 1, 2, 3)} returns\n",
        "357": "   * the string {@code \"1-2-3\"}.\n",
        "358": "   *\n",
        "359": "   * @param separator the text that should appear between consecutive values in\n",
        "360": "   *     the resulting string (but not at the start or end)\n",
        "361": "   * @param array an array of {@code int} values, possibly empty\n",
        "362": "   */\n",
        "363": "  public static String join(String separator, int... array) {\n",
        "364": "    checkNotNull(separator);\n",
        "365": "    if (array.length == 0) {\n",
        "366": "      return \"\";\n",
        "367": "    }\n",
        "368": "\n",
        "369": "    // For pre-sizing a builder, just get the right order of magnitude\n",
        "370": "    StringBuilder builder = new StringBuilder(array.length * 5);\n",
        "371": "    builder.append(array[0]);\n",
        "372": "    for (int i = 1; i < array.length; i++) {\n",
        "373": "      builder.append(separator).append(array[i]);\n",
        "374": "    }\n",
        "375": "    return builder.toString();\n",
        "376": "  }\n",
        "377": "\n",
        "378": "  /**\n",
        "379": "   * Returns a comparator that compares two {@code int} arrays\n",
        "380": "   * lexicographically. That is, it compares, using {@link\n",
        "381": "   * #compare(int, int)}), the first pair of values that follow any\n",
        "382": "   * common prefix, or when one array is a prefix of the other, treats the\n",
        "383": "   * shorter array as the lesser. For example, {@code [] < [1] < [1, 2] < [2]}.\n",
        "384": "   *\n",
        "385": "   * <p>The returned comparator is inconsistent with {@link\n",
        "386": "   * Object#equals(Object)} (since arrays support only identity equality), but\n",
        "387": "   * it is consistent with {@link Arrays#equals(int[], int[])}.\n",
        "388": "   *\n",
        "389": "   * @see <a href=\"http://en.wikipedia.org/wiki/Lexicographical_order\">\n",
        "390": "   *     Lexicographical order article at Wikipedia</a>\n",
        "391": "   * @since 2.0\n",
        "392": "   */\n",
        "393": "  public static Comparator<int[]> lexicographicalComparator() {\n",
        "394": "    return LexicographicalComparator.INSTANCE;\n",
        "395": "  }\n",
        "396": "\n",
        "397": "  private enum LexicographicalComparator implements Comparator<int[]> {\n",
        "398": "    INSTANCE;\n",
        "399": "\n",
        "400": "    @Override\n",
        "401": "    public int compare(int[] left, int[] right) {\n",
        "402": "      int minLength = Math.min(left.length, right.length);\n",
        "403": "      for (int i = 0; i < minLength; i++) {\n",
        "404": "        int result = Ints.compare(left[i], right[i]);\n",
        "405": "        if (result != 0) {\n",
        "406": "          return result;\n",
        "407": "        }\n",
        "408": "      }\n",
        "409": "      return left.length - right.length;\n",
        "410": "    }\n",
        "411": "  }\n",
        "412": "\n",
        "413": "  /**\n",
        "414": "   * Returns an array containing each value of {@code collection}, converted to\n",
        "415": "   * a {@code int} value in the manner of {@link Number#intValue}.\n",
        "416": "   *\n",
        "417": "   * <p>Elements are copied from the argument collection as if by {@code\n",
        "418": "   * collection.toArray()}.  Calling this method is as thread-safe as calling\n",
        "419": "   * that method.\n",
        "420": "   *\n",
        "421": "   * @param collection a collection of {@code Number} instances\n",
        "422": "   * @return an array containing the same values as {@code collection}, in the\n",
        "423": "   *     same order, converted to primitives\n",
        "424": "   * @throws NullPointerException if {@code collection} or any of its elements\n",
        "425": "   *     is null\n",
        "426": "   * @since 1.0 (parameter was {@code Collection<Integer>} before 12.0)\n",
        "427": "   */\n",
        "428": "  public static int[] toArray(Collection<? extends Number> collection) {\n",
        "429": "    if (collection instanceof IntArrayAsList) {\n",
        "430": "      return ((IntArrayAsList) collection).toIntArray();\n",
        "431": "    }\n",
        "432": "\n",
        "433": "    Object[] boxedArray = collection.toArray();\n",
        "434": "    int len = boxedArray.length;\n",
        "435": "    int[] array = new int[len];\n",
        "436": "    for (int i = 0; i < len; i++) {\n",
        "437": "      // checkNotNull for GWT (do not optimize)\n",
        "438": "      array[i] = ((Number) checkNotNull(boxedArray[i])).intValue();\n",
        "439": "    }\n",
        "440": "    return array;\n",
        "441": "  }\n",
        "442": "\n",
        "443": "  /**\n",
        "444": "   * Returns a fixed-size list backed by the specified array, similar to {@link\n",
        "445": "   * Arrays#asList(Object[])}. The list supports {@link List#set(int, Object)},\n",
        "446": "   * but any attempt to set a value to {@code null} will result in a {@link\n",
        "447": "   * NullPointerException}.\n",
        "448": "   *\n",
        "449": "   * <p>The returned list maintains the values, but not the identities, of\n",
        "450": "   * {@code Integer} objects written to or read from it.  For example, whether\n",
        "451": "   * {@code list.get(0) == list.get(0)} is true for the returned list is\n",
        "452": "   * unspecified.\n",
        "453": "   *\n",
        "454": "   * @param backingArray the array to back the list\n",
        "455": "   * @return a list view of the array\n",
        "456": "   */\n",
        "457": "  public static List<Integer> asList(int... backingArray) {\n",
        "458": "    if (backingArray.length == 0) {\n",
        "459": "      return Collections.emptyList();\n",
        "460": "    }\n",
        "461": "    return new IntArrayAsList(backingArray);\n",
        "462": "  }\n",
        "463": "\n",
        "464": "  @GwtCompatible\n",
        "465": "  private static class IntArrayAsList extends AbstractList<Integer>\n",
        "466": "      implements RandomAccess, Serializable {\n",
        "467": "    final int[] array;\n",
        "468": "    final int start;\n",
        "469": "    final int end;\n",
        "470": "\n",
        "471": "    IntArrayAsList(int[] array) {\n",
        "472": "      this(array, 0, array.length);\n",
        "473": "    }\n",
        "474": "\n",
        "475": "    IntArrayAsList(int[] array, int start, int end) {\n",
        "476": "      this.array = array;\n",
        "477": "      this.start = start;\n",
        "478": "      this.end = end;\n",
        "479": "    }\n",
        "480": "\n",
        "481": "    @Override\n",
        "482": "    public int size() {\n",
        "483": "      return end - start;\n",
        "484": "    }\n",
        "485": "\n",
        "486": "    @Override\n",
        "487": "    public boolean isEmpty() {\n",
        "488": "      return false;\n",
        "489": "    }\n",
        "490": "\n",
        "491": "    @Override\n",
        "492": "    public Integer get(int index) {\n",
        "493": "      checkElementIndex(index, size());\n",
        "494": "      return array[start + index];\n",
        "495": "    }\n",
        "496": "\n",
        "497": "    @Override\n",
        "498": "    public boolean contains(Object target) {\n",
        "499": "      // Overridden to prevent a ton of boxing\n",
        "500": "      return (target instanceof Integer) && Ints.indexOf(array, (Integer) target, start, end) != -1;\n",
        "501": "    }\n",
        "502": "\n",
        "503": "    @Override\n",
        "504": "    public int indexOf(Object target) {\n",
        "505": "      // Overridden to prevent a ton of boxing\n",
        "506": "      if (target instanceof Integer) {\n",
        "507": "        int i = Ints.indexOf(array, (Integer) target, start, end);\n",
        "508": "        if (i >= 0) {\n",
        "509": "          return i - start;\n",
        "510": "        }\n",
        "511": "      }\n",
        "512": "      return -1;\n",
        "513": "    }\n",
        "514": "\n",
        "515": "    @Override\n",
        "516": "    public int lastIndexOf(Object target) {\n",
        "517": "      // Overridden to prevent a ton of boxing\n",
        "518": "      if (target instanceof Integer) {\n",
        "519": "        int i = Ints.lastIndexOf(array, (Integer) target, start, end);\n",
        "520": "        if (i >= 0) {\n",
        "521": "          return i - start;\n",
        "522": "        }\n",
        "523": "      }\n",
        "524": "      return -1;\n",
        "525": "    }\n",
        "526": "\n",
        "527": "    @Override\n",
        "528": "    public Integer set(int index, Integer element) {\n",
        "529": "      checkElementIndex(index, size());\n",
        "530": "      int oldValue = array[start + index];\n",
        "531": "      // checkNotNull for GWT (do not optimize)\n",
        "532": "      array[start + index] = checkNotNull(element);\n",
        "533": "      return oldValue;\n",
        "534": "    }\n",
        "535": "\n",
        "536": "    @Override\n",
        "537": "    public List<Integer> subList(int fromIndex, int toIndex) {\n",
        "538": "      int size = size();\n",
        "539": "      checkPositionIndexes(fromIndex, toIndex, size);\n",
        "540": "      if (fromIndex == toIndex) {\n",
        "541": "        return Collections.emptyList();\n",
        "542": "      }\n",
        "543": "      return new IntArrayAsList(array, start + fromIndex, start + toIndex);\n",
        "544": "    }\n",
        "545": "\n",
        "546": "    @Override\n",
        "547": "    public boolean equals(@Nullable Object object) {\n",
        "548": "      if (object == this) {\n",
        "549": "        return true;\n",
        "550": "      }\n",
        "551": "      if (object instanceof IntArrayAsList) {\n",
        "552": "        IntArrayAsList that = (IntArrayAsList) object;\n",
        "553": "        int size = size();\n",
        "554": "        if (that.size() != size) {\n",
        "555": "          return false;\n",
        "556": "        }\n",
        "557": "        for (int i = 0; i < size; i++) {\n",
        "558": "          if (array[start + i] != that.array[that.start + i]) {\n",
        "559": "            return false;\n",
        "560": "          }\n",
        "561": "        }\n",
        "562": "        return true;\n",
        "563": "      }\n",
        "564": "      return super.equals(object);\n",
        "565": "    }\n",
        "566": "\n",
        "567": "    @Override\n",
        "568": "    public int hashCode() {\n",
        "569": "      int result = 1;\n",
        "570": "      for (int i = start; i < end; i++) {\n",
        "571": "        result = 31 * result + Ints.hashCode(array[i]);\n",
        "572": "      }\n",
        "573": "      return result;\n",
        "574": "    }\n",
        "575": "\n",
        "576": "    @Override\n",
        "577": "    public String toString() {\n",
        "578": "      StringBuilder builder = new StringBuilder(size() * 5);\n",
        "579": "      builder.append('[').append(array[start]);\n",
        "580": "      for (int i = start + 1; i < end; i++) {\n",
        "581": "        builder.append(\", \").append(array[i]);\n",
        "582": "      }\n",
        "583": "      return builder.append(']').toString();\n",
        "584": "    }\n",
        "585": "\n",
        "586": "    int[] toIntArray() {\n",
        "587": "      // Arrays.copyOfRange() is not available under GWT\n",
        "588": "      int size = size();\n",
        "589": "      int[] result = new int[size];\n",
        "590": "      System.arraycopy(array, start, result, 0, size);\n",
        "591": "      return result;\n",
        "592": "    }\n",
        "593": "\n",
        "594": "    private static final long serialVersionUID = 0;\n",
        "595": "  }\n",
        "596": "\n",
        "597": "  /**\n",
        "598": "   * Parses the specified string as a signed decimal integer value. The ASCII\n",
        "599": "   * character {@code '-'} (<code>'&#92;u002D'</code>) is recognized as the\n",
        "600": "   * minus sign.\n",
        "601": "   *\n",
        "602": "   * <p>Unlike {@link Integer#parseInt(String)}, this method returns\n",
        "603": "   * {@code null} instead of throwing an exception if parsing fails.\n",
        "604": "   * Additionally, this method only accepts ASCII digits, and returns\n",
        "605": "   * {@code null} if non-ASCII digits are present in the string.\n",
        "606": "   *\n",
        "607": "   * <p>Note that strings prefixed with ASCII {@code '+'} are rejected, even\n",
        "608": "   * under JDK 7, despite the change to {@link Integer#parseInt(String)} for\n",
        "609": "   * that version.\n",
        "610": "   *\n",
        "611": "   * @param string the string representation of an integer value\n",
        "612": "   * @return the integer value represented by {@code string}, or {@code null} if\n",
        "613": "   *     {@code string} has a length of zero or cannot be parsed as an integer\n",
        "614": "   *     value\n",
        "615": "   * @since 11.0\n",
        "616": "   */\n",
        "617": "  @Beta\n",
        "618": "  @Nullable\n",
        "619": "  @CheckForNull\n",
        "620": "  public static Integer tryParse(String string) {\n",
        "621": "    return tryParse(string, 10);\n",
        "622": "  }\n",
        "623": "\n",
        "624": "  /**\n",
        "625": "   * Parses the specified string as a signed integer value using the specified\n",
        "626": "   * radix. The ASCII character {@code '-'} (<code>'&#92;u002D'</code>) is\n",
        "627": "   * recognized as the minus sign.\n",
        "628": "   *\n",
        "629": "   * <p>Unlike {@link Integer#parseInt(String, int)}, this method returns\n",
        "630": "   * {@code null} instead of throwing an exception if parsing fails.\n",
        "631": "   * Additionally, this method only accepts ASCII digits, and returns\n",
        "632": "   * {@code null} if non-ASCII digits are present in the string.\n",
        "633": "   *\n",
        "634": "   * <p>Note that strings prefixed with ASCII {@code '+'} are rejected, even\n",
        "635": "   * under JDK 7, despite the change to {@link Integer#parseInt(String, int)}\n",
        "636": "   * for that version.\n",
        "637": "   *\n",
        "638": "   * @param string the string representation of an integer value\n",
        "639": "   * @param radix the radix to use when parsing\n",
        "640": "   * @return the integer value represented by {@code string} using\n",
        "641": "   *     {@code radix}, or {@code null} if {@code string} has a length of zero\n",
        "642": "   *     or cannot be parsed as an integer value\n",
        "643": "   * @throws IllegalArgumentException if {@code radix < Character.MIN_RADIX} or\n",
        "644": "   *     {@code radix > Character.MAX_RADIX}\n",
        "645": "   * @since 19.0\n",
        "646": "   */\n",
        "647": "  @Beta\n",
        "648": "  @Nullable\n",
        "649": "  @CheckForNull\n",
        "650": "  public static Integer tryParse(\n",
        "651": "      String string, int radix) {\n",
        "652": "    Long result = Longs.tryParse(string, radix);\n",
        "653": "    if (result == null || result.longValue() != result.intValue()) {\n",
        "654": "      return null;\n",
        "655": "    } else {\n",
        "656": "      return result.intValue();\n",
        "657": "    }\n",
        "658": "  }\n",
        "659": "}\n"
    }
}