{
    "addition": {},
    "removed": {
        "1": "/*\n",
        "2": " * Copyright (C) 2007 The Guava Authors\n",
        "3": " *\n",
        "4": " * Licensed under the Apache License, Version 2.0 (the \"License\");\n",
        "5": " * you may not use this file except in compliance with the License.\n",
        "6": " * You may obtain a copy of the License at\n",
        "7": " *\n",
        "8": " * http://www.apache.org/licenses/LICENSE-2.0\n",
        "9": " *\n",
        "10": " * Unless required by applicable law or agreed to in writing, software\n",
        "11": " * distributed under the License is distributed on an \"AS IS\" BASIS,\n",
        "12": " * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n",
        "13": " * See the License for the specific language governing permissions and\n",
        "14": " * limitations under the License.\n",
        "15": " */\n",
        "16": "\n",
        "17": "package com.google.common.collect;\n",
        "18": "\n",
        "19": "import static com.google.common.base.Preconditions.checkArgument;\n",
        "20": "import static com.google.common.base.Preconditions.checkElementIndex;\n",
        "21": "import static com.google.common.base.Preconditions.checkNotNull;\n",
        "22": "import static com.google.common.base.Preconditions.checkPositionIndex;\n",
        "23": "import static com.google.common.base.Preconditions.checkPositionIndexes;\n",
        "24": "import static com.google.common.base.Preconditions.checkState;\n",
        "25": "import static com.google.common.collect.CollectPreconditions.checkNonnegative;\n",
        "26": "import static com.google.common.collect.CollectPreconditions.checkRemove;\n",
        "27": "\n",
        "28": "import com.google.common.annotations.Beta;\n",
        "29": "import com.google.common.annotations.GwtCompatible;\n",
        "30": "import com.google.common.annotations.VisibleForTesting;\n",
        "31": "import com.google.common.base.Function;\n",
        "32": "import com.google.common.base.Objects;\n",
        "33": "import com.google.common.math.IntMath;\n",
        "34": "import com.google.common.primitives.Ints;\n",
        "35": "\n",
        "36": "import java.io.Serializable;\n",
        "37": "import java.math.RoundingMode;\n",
        "38": "import java.util.AbstractList;\n",
        "39": "import java.util.AbstractSequentialList;\n",
        "40": "import java.util.ArrayList;\n",
        "41": "import java.util.Arrays;\n",
        "42": "import java.util.Collection;\n",
        "43": "import java.util.Collections;\n",
        "44": "import java.util.Iterator;\n",
        "45": "import java.util.LinkedList;\n",
        "46": "import java.util.List;\n",
        "47": "import java.util.ListIterator;\n",
        "48": "import java.util.NoSuchElementException;\n",
        "49": "import java.util.RandomAccess;\n",
        "50": "\n",
        "51": "import javax.annotation.CheckReturnValue;\n",
        "52": "import javax.annotation.Nullable;\n",
        "53": "\n",
        "54": "/**\n",
        "55": " * Static utility methods pertaining to {@link List} instances. Also see this\n",
        "56": " * class's counterparts {@link Sets}, {@link Maps} and {@link Queues}.\n",
        "57": " *\n",
        "58": " * <p>See the Guava User Guide article on <a href=\n",
        "59": " * \"https://github.com/google/guava/wiki/CollectionUtilitiesExplained#lists\">\n",
        "60": " * {@code Lists}</a>.\n",
        "61": " *\n",
        "62": " * @author Kevin Bourrillion\n",
        "63": " * @author Mike Bostock\n",
        "64": " * @author Louis Wasserman\n",
        "65": " * @since 2.0\n",
        "66": " */\n",
        "67": "@GwtCompatible(emulated = true)\n",
        "68": "public final class Lists {\n",
        "69": "  private Lists() {}\n",
        "70": "\n",
        "71": "  // ArrayList\n",
        "72": "\n",
        "73": "  /**\n",
        "74": "   * Creates a <i>mutable</i>, empty {@code ArrayList} instance (for Java 6 and\n",
        "75": "   * earlier).\n",
        "76": "   *\n",
        "77": "   * <p><b>Note:</b> if mutability is not required, use {@link\n",
        "78": "   * ImmutableList#of()} instead.\n",
        "79": "   *\n",
        "80": "   * <p><b>Note for Java 7 and later:</b> this method is now unnecessary and\n",
        "81": "   * should be treated as deprecated. Instead, use the {@code ArrayList}\n",
        "82": "   * {@linkplain ArrayList#ArrayList() constructor} directly, taking advantage\n",
        "83": "   * of the new <a href=\"http://goo.gl/iz2Wi\">\"diamond\" syntax</a>.\n",
        "84": "   */\n",
        "85": "  @GwtCompatible(serializable = true)\n",
        "86": "  public static <E> ArrayList<E> newArrayList() {\n",
        "87": "    return new ArrayList<E>();\n",
        "88": "  }\n",
        "89": "\n",
        "90": "  /**\n",
        "91": "   * Creates a <i>mutable</i> {@code ArrayList} instance containing the given\n",
        "92": "   * elements.\n",
        "93": "   *\n",
        "94": "   * <p><b>Note:</b> essentially the only reason to use this method is when you\n",
        "95": "   * will need to add or remove elements later. Otherwise, for non-null elements\n",
        "96": "   * use {@link ImmutableList#of()} (for varargs) or {@link\n",
        "97": "   * ImmutableList#copyOf(Object[])} (for an array) instead. If any elements\n",
        "98": "   * might be null, or you need support for {@link List#set(int, Object)}, use\n",
        "99": "   * {@link Arrays#asList}.\n",
        "100": "   *\n",
        "101": "   * <p>Note that even when you do need the ability to add or remove, this method\n",
        "102": "   * provides only a tiny bit of syntactic sugar for {@code newArrayList(}{@link\n",
        "103": "   * Arrays#asList asList}{@code (...))}, or for creating an empty list then\n",
        "104": "   * calling {@link Collections#addAll}. This method is not actually very useful\n",
        "105": "   * and will likely be deprecated in the future.\n",
        "106": "   */\n",
        "107": "  @GwtCompatible(serializable = true)\n",
        "108": "  public static <E> ArrayList<E> newArrayList(E... elements) {\n",
        "109": "    checkNotNull(elements); // for GWT\n",
        "110": "    // Avoid integer overflow when a large array is passed in\n",
        "111": "    int capacity = computeArrayListCapacity(elements.length);\n",
        "112": "    ArrayList<E> list = new ArrayList<E>(capacity);\n",
        "113": "    Collections.addAll(list, elements);\n",
        "114": "    return list;\n",
        "115": "  }\n",
        "116": "\n",
        "117": "  @VisibleForTesting\n",
        "118": "  static int computeArrayListCapacity(int arraySize) {\n",
        "119": "    checkNonnegative(arraySize, \"arraySize\");\n",
        "120": "\n",
        "121": "    // TODO(kevinb): Figure out the right behavior, and document it\n",
        "122": "    return Ints.saturatedCast(5L + arraySize + (arraySize / 10));\n",
        "123": "  }\n",
        "124": "\n",
        "125": "  /**\n",
        "126": "   * Creates a <i>mutable</i> {@code ArrayList} instance containing the given\n",
        "127": "   * elements; a very thin shortcut for creating an empty list then calling\n",
        "128": "   * {@link Iterables#addAll}.\n",
        "129": "   *\n",
        "130": "   * <p><b>Note:</b> if mutability is not required and the elements are\n",
        "131": "   * non-null, use {@link ImmutableList#copyOf(Iterable)} instead. (Or, change\n",
        "132": "   * {@code elements} to be a {@link FluentIterable} and call\n",
        "133": "   * {@code elements.toList()}.)\n",
        "134": "   *\n",
        "135": "   * <p><b>Note for Java 7 and later:</b> if {@code elements} is a {@link\n",
        "136": "   * Collection}, you don't need this method. Use the {@code ArrayList}\n",
        "137": "   * {@linkplain ArrayList#ArrayList(Collection) constructor} directly, taking\n",
        "138": "   * advantage of the new <a href=\"http://goo.gl/iz2Wi\">\"diamond\" syntax</a>.\n",
        "139": "   */\n",
        "140": "  @GwtCompatible(serializable = true)\n",
        "141": "  public static <E> ArrayList<E> newArrayList(Iterable<? extends E> elements) {\n",
        "142": "    checkNotNull(elements); // for GWT\n",
        "143": "    // Let ArrayList's sizing logic work, if possible\n",
        "144": "    return (elements instanceof Collection)\n",
        "145": "        ? new ArrayList<E>(Collections2.cast(elements))\n",
        "146": "        : newArrayList(elements.iterator());\n",
        "147": "  }\n",
        "148": "\n",
        "149": "  /**\n",
        "150": "   * Creates a <i>mutable</i> {@code ArrayList} instance containing the given\n",
        "151": "   * elements; a very thin shortcut for creating an empty list and then calling\n",
        "152": "   * {@link Iterators#addAll}.\n",
        "153": "   *\n",
        "154": "   * <p><b>Note:</b> if mutability is not required and the elements are\n",
        "155": "   * non-null, use {@link ImmutableList#copyOf(Iterator)} instead.\n",
        "156": "   */\n",
        "157": "  @GwtCompatible(serializable = true)\n",
        "158": "  public static <E> ArrayList<E> newArrayList(Iterator<? extends E> elements) {\n",
        "159": "    ArrayList<E> list = newArrayList();\n",
        "160": "    Iterators.addAll(list, elements);\n",
        "161": "    return list;\n",
        "162": "  }\n",
        "163": "\n",
        "164": "  /**\n",
        "165": "   * Creates an {@code ArrayList} instance backed by an array with the specified\n",
        "166": "   * initial size; simply delegates to {@link ArrayList#ArrayList(int)}.\n",
        "167": "   *\n",
        "168": "   * <p><b>Note for Java 7 and later:</b> this method is now unnecessary and\n",
        "169": "   * should be treated as deprecated. Instead, use {@code new }{@link\n",
        "170": "   * ArrayList#ArrayList(int) ArrayList}{@code <>(int)} directly, taking\n",
        "171": "   * advantage of the new <a href=\"http://goo.gl/iz2Wi\">\"diamond\" syntax</a>.\n",
        "172": "   * (Unlike here, there is no risk of overload ambiguity, since the {@code\n",
        "173": "   * ArrayList} constructors very wisely did not accept varargs.)\n",
        "174": "   *\n",
        "175": "   * @param initialArraySize the exact size of the initial backing array for\n",
        "176": "   *     the returned array list ({@code ArrayList} documentation calls this\n",
        "177": "   *     value the \"capacity\")\n",
        "178": "   * @return a new, empty {@code ArrayList} which is guaranteed not to resize\n",
        "179": "   *     itself unless its size reaches {@code initialArraySize + 1}\n",
        "180": "   * @throws IllegalArgumentException if {@code initialArraySize} is negative\n",
        "181": "   */\n",
        "182": "  @GwtCompatible(serializable = true)\n",
        "183": "  public static <E> ArrayList<E> newArrayListWithCapacity(int initialArraySize) {\n",
        "184": "    checkNonnegative(initialArraySize, \"initialArraySize\"); // for GWT.\n",
        "185": "    return new ArrayList<E>(initialArraySize);\n",
        "186": "  }\n",
        "187": "\n",
        "188": "  /**\n",
        "189": "   * Creates an {@code ArrayList} instance to hold {@code estimatedSize}\n",
        "190": "   * elements, <i>plus</i> an unspecified amount of padding; you almost\n",
        "191": "   * certainly mean to call {@link #newArrayListWithCapacity} (see that method\n",
        "192": "   * for further advice on usage).\n",
        "193": "   *\n",
        "194": "   * <p><b>Note:</b> This method will soon be deprecated. Even in the rare case\n",
        "195": "   * that you do want some amount of padding, it's best if you choose your\n",
        "196": "   * desired amount explicitly.\n",
        "197": "   *\n",
        "198": "   * @param estimatedSize an estimate of the eventual {@link List#size()} of\n",
        "199": "   *     the new list\n",
        "200": "   * @return a new, empty {@code ArrayList}, sized appropriately to hold the\n",
        "201": "   *     estimated number of elements\n",
        "202": "   * @throws IllegalArgumentException if {@code estimatedSize} is negative\n",
        "203": "   */\n",
        "204": "  @GwtCompatible(serializable = true)\n",
        "205": "  public static <E> ArrayList<E> newArrayListWithExpectedSize(int estimatedSize) {\n",
        "206": "    return new ArrayList<E>(computeArrayListCapacity(estimatedSize));\n",
        "207": "  }\n",
        "208": "\n",
        "209": "  // LinkedList\n",
        "210": "\n",
        "211": "  /**\n",
        "212": "   * Creates a <i>mutable</i>, empty {@code LinkedList} instance (for Java 6 and\n",
        "213": "   * earlier).\n",
        "214": "   *\n",
        "215": "   * <p><b>Note:</b> if you won't be adding any elements to the list, use {@link\n",
        "216": "   * ImmutableList#of()} instead.\n",
        "217": "   *\n",
        "218": "   * <p><b>Performance note:</b> {@link ArrayList} and {@link\n",
        "219": "   * java.util.ArrayDeque} consistently outperform {@code LinkedList} except in\n",
        "220": "   * certain rare and specific situations. Unless you have spent a lot of time\n",
        "221": "   * benchmarking your specific needs, use one of those instead.\n",
        "222": "   *\n",
        "223": "   * <p><b>Note for Java 7 and later:</b> this method is now unnecessary and\n",
        "224": "   * should be treated as deprecated. Instead, use the {@code LinkedList}\n",
        "225": "   * {@linkplain LinkedList#LinkedList() constructor} directly, taking advantage\n",
        "226": "   * of the new <a href=\"http://goo.gl/iz2Wi\">\"diamond\" syntax</a>.\n",
        "227": "   */\n",
        "228": "  @GwtCompatible(serializable = true)\n",
        "229": "  public static <E> LinkedList<E> newLinkedList() {\n",
        "230": "    return new LinkedList<E>();\n",
        "231": "  }\n",
        "232": "\n",
        "233": "  /**\n",
        "234": "   * Creates a <i>mutable</i> {@code LinkedList} instance containing the given\n",
        "235": "   * elements; a very thin shortcut for creating an empty list then calling\n",
        "236": "   * {@link Iterables#addAll}.\n",
        "237": "   *\n",
        "238": "   * <p><b>Note:</b> if mutability is not required and the elements are\n",
        "239": "   * non-null, use {@link ImmutableList#copyOf(Iterable)} instead. (Or, change\n",
        "240": "   * {@code elements} to be a {@link FluentIterable} and call\n",
        "241": "   * {@code elements.toList()}.)\n",
        "242": "   *\n",
        "243": "   * <p><b>Performance note:</b> {@link ArrayList} and {@link\n",
        "244": "   * java.util.ArrayDeque} consistently outperform {@code LinkedList} except in\n",
        "245": "   * certain rare and specific situations. Unless you have spent a lot of time\n",
        "246": "   * benchmarking your specific needs, use one of those instead.\n",
        "247": "   *\n",
        "248": "   * <p><b>Note for Java 7 and later:</b> if {@code elements} is a {@link\n",
        "249": "   * Collection}, you don't need this method. Use the {@code LinkedList}\n",
        "250": "   * {@linkplain LinkedList#LinkedList(Collection) constructor} directly, taking\n",
        "251": "   * advantage of the new <a href=\"http://goo.gl/iz2Wi\">\"diamond\" syntax</a>.\n",
        "252": "   */\n",
        "253": "  @GwtCompatible(serializable = true)\n",
        "254": "  public static <E> LinkedList<E> newLinkedList(Iterable<? extends E> elements) {\n",
        "255": "    LinkedList<E> list = newLinkedList();\n",
        "256": "    Iterables.addAll(list, elements);\n",
        "257": "    return list;\n",
        "258": "  }\n",
        "259": "\n",
        "260": "  /**\n",
        "261": "   * Returns an unmodifiable list containing the specified first element and\n",
        "262": "   * backed by the specified array of additional elements. Changes to the {@code\n",
        "263": "   * rest} array will be reflected in the returned list. Unlike {@link\n",
        "264": "   * Arrays#asList}, the returned list is unmodifiable.\n",
        "265": "   *\n",
        "266": "   * <p>This is useful when a varargs method needs to use a signature such as\n",
        "267": "   * {@code (Foo firstFoo, Foo... moreFoos)}, in order to avoid overload\n",
        "268": "   * ambiguity or to enforce a minimum argument count.\n",
        "269": "   *\n",
        "270": "   * <p>The returned list is serializable and implements {@link RandomAccess}.\n",
        "271": "   *\n",
        "272": "   * @param first the first element\n",
        "273": "   * @param rest an array of additional elements, possibly empty\n",
        "274": "   * @return an unmodifiable list containing the specified elements\n",
        "275": "   */\n",
        "276": "  public static <E> List<E> asList(@Nullable E first, E[] rest) {\n",
        "277": "    return new OnePlusArrayList<E>(first, rest);\n",
        "278": "  }\n",
        "279": "\n",
        "280": "  /** @see Lists#asList(Object, Object[]) */\n",
        "281": "  private static class OnePlusArrayList<E> extends AbstractList<E>\n",
        "282": "      implements Serializable, RandomAccess {\n",
        "283": "    final E first;\n",
        "284": "    final E[] rest;\n",
        "285": "\n",
        "286": "    OnePlusArrayList(@Nullable E first, E[] rest) {\n",
        "287": "      this.first = first;\n",
        "288": "      this.rest = checkNotNull(rest);\n",
        "289": "    }\n",
        "290": "\n",
        "291": "    @Override\n",
        "292": "    public int size() {\n",
        "293": "      return rest.length + 1;\n",
        "294": "    }\n",
        "295": "\n",
        "296": "    @Override\n",
        "297": "    public E get(int index) {\n",
        "298": "      // check explicitly so the IOOBE will have the right message\n",
        "299": "      checkElementIndex(index, size());\n",
        "300": "      return (index == 0) ? first : rest[index - 1];\n",
        "301": "    }\n",
        "302": "\n",
        "303": "    private static final long serialVersionUID = 0;\n",
        "304": "  }\n",
        "305": "\n",
        "306": "  /**\n",
        "307": "   * Returns an unmodifiable list containing the specified first and second\n",
        "308": "   * element, and backed by the specified array of additional elements. Changes\n",
        "309": "   * to the {@code rest} array will be reflected in the returned list. Unlike\n",
        "310": "   * {@link Arrays#asList}, the returned list is unmodifiable.\n",
        "311": "   *\n",
        "312": "   * <p>This is useful when a varargs method needs to use a signature such as\n",
        "313": "   * {@code (Foo firstFoo, Foo secondFoo, Foo... moreFoos)}, in order to avoid\n",
        "314": "   * overload ambiguity or to enforce a minimum argument count.\n",
        "315": "   *\n",
        "316": "   * <p>The returned list is serializable and implements {@link RandomAccess}.\n",
        "317": "   *\n",
        "318": "   * @param first the first element\n",
        "319": "   * @param second the second element\n",
        "320": "   * @param rest an array of additional elements, possibly empty\n",
        "321": "   * @return an unmodifiable list containing the specified elements\n",
        "322": "   */\n",
        "323": "  public static <E> List<E> asList(@Nullable E first, @Nullable E second, E[] rest) {\n",
        "324": "    return new TwoPlusArrayList<E>(first, second, rest);\n",
        "325": "  }\n",
        "326": "\n",
        "327": "  /** @see Lists#asList(Object, Object, Object[]) */\n",
        "328": "  private static class TwoPlusArrayList<E> extends AbstractList<E>\n",
        "329": "      implements Serializable, RandomAccess {\n",
        "330": "    final E first;\n",
        "331": "    final E second;\n",
        "332": "    final E[] rest;\n",
        "333": "\n",
        "334": "    TwoPlusArrayList(@Nullable E first, @Nullable E second, E[] rest) {\n",
        "335": "      this.first = first;\n",
        "336": "      this.second = second;\n",
        "337": "      this.rest = checkNotNull(rest);\n",
        "338": "    }\n",
        "339": "\n",
        "340": "    @Override\n",
        "341": "    public int size() {\n",
        "342": "      return rest.length + 2;\n",
        "343": "    }\n",
        "344": "\n",
        "345": "    @Override\n",
        "346": "    public E get(int index) {\n",
        "347": "      switch (index) {\n",
        "348": "        case 0:\n",
        "349": "          return first;\n",
        "350": "        case 1:\n",
        "351": "          return second;\n",
        "352": "        default:\n",
        "353": "          // check explicitly so the IOOBE will have the right message\n",
        "354": "          checkElementIndex(index, size());\n",
        "355": "          return rest[index - 2];\n",
        "356": "      }\n",
        "357": "    }\n",
        "358": "\n",
        "359": "    private static final long serialVersionUID = 0;\n",
        "360": "  }\n",
        "361": "\n",
        "362": "  /**\n",
        "363": "   * Returns every possible list that can be formed by choosing one element\n",
        "364": "   * from each of the given lists in order; the \"n-ary\n",
        "365": "   * <a href=\"http://en.wikipedia.org/wiki/Cartesian_product\">Cartesian\n",
        "366": "   * product</a>\" of the lists. For example: <pre>   {@code\n",
        "367": "   *\n",
        "368": "   *   Lists.cartesianProduct(ImmutableList.of(\n",
        "369": "   *       ImmutableList.of(1, 2),\n",
        "370": "   *       ImmutableList.of(\"A\", \"B\", \"C\")))}</pre>\n",
        "371": "   *\n",
        "372": "   * <p>returns a list containing six lists in the following order:\n",
        "373": "   *\n",
        "374": "   * <ul>\n",
        "375": "   * <li>{@code ImmutableList.of(1, \"A\")}\n",
        "376": "   * <li>{@code ImmutableList.of(1, \"B\")}\n",
        "377": "   * <li>{@code ImmutableList.of(1, \"C\")}\n",
        "378": "   * <li>{@code ImmutableList.of(2, \"A\")}\n",
        "379": "   * <li>{@code ImmutableList.of(2, \"B\")}\n",
        "380": "   * <li>{@code ImmutableList.of(2, \"C\")}\n",
        "381": "   * </ul>\n",
        "382": "   *\n",
        "383": "   * <p>The result is guaranteed to be in the \"traditional\", lexicographical\n",
        "384": "   * order for Cartesian products that you would get from nesting for loops:\n",
        "385": "   * <pre>   {@code\n",
        "386": "   *\n",
        "387": "   *   for (B b0 : lists.get(0)) {\n",
        "388": "   *     for (B b1 : lists.get(1)) {\n",
        "389": "   *       ...\n",
        "390": "   *       ImmutableList<B> tuple = ImmutableList.of(b0, b1, ...);\n",
        "391": "   *       // operate on tuple\n",
        "392": "   *     }\n",
        "393": "   *   }}</pre>\n",
        "394": "   *\n",
        "395": "   * <p>Note that if any input list is empty, the Cartesian product will also be\n",
        "396": "   * empty. If no lists at all are provided (an empty list), the resulting\n",
        "397": "   * Cartesian product has one element, an empty list (counter-intuitive, but\n",
        "398": "   * mathematically consistent).\n",
        "399": "   *\n",
        "400": "   * <p><i>Performance notes:</i> while the cartesian product of lists of size\n",
        "401": "   * {@code m, n, p} is a list of size {@code m x n x p}, its actual memory\n",
        "402": "   * consumption is much smaller. When the cartesian product is constructed, the\n",
        "403": "   * input lists are merely copied. Only as the resulting list is iterated are\n",
        "404": "   * the individual lists created, and these are not retained after iteration.\n",
        "405": "   *\n",
        "406": "   * @param lists the lists to choose elements from, in the order that\n",
        "407": "   *     the elements chosen from those lists should appear in the resulting\n",
        "408": "   *     lists\n",
        "409": "   * @param <B> any common base class shared by all axes (often just {@link\n",
        "410": "   *     Object})\n",
        "411": "   * @return the Cartesian product, as an immutable list containing immutable\n",
        "412": "   *     lists\n",
        "413": "   * @throws IllegalArgumentException if the size of the cartesian product would\n",
        "414": "   *     be greater than {@link Integer#MAX_VALUE}\n",
        "415": "   * @throws NullPointerException if {@code lists}, any one of the {@code lists},\n",
        "416": "   *     or any element of a provided list is null\n",
        "417": "   * @since 19.0\n",
        "418": "   */\n",
        "419": "  public static <B> List<List<B>> cartesianProduct(List<? extends List<? extends B>> lists) {\n",
        "420": "    return CartesianList.create(lists);\n",
        "421": "  }\n",
        "422": "\n",
        "423": "  /**\n",
        "424": "   * Returns every possible list that can be formed by choosing one element\n",
        "425": "   * from each of the given lists in order; the \"n-ary\n",
        "426": "   * <a href=\"http://en.wikipedia.org/wiki/Cartesian_product\">Cartesian\n",
        "427": "   * product</a>\" of the lists. For example: <pre>   {@code\n",
        "428": "   *\n",
        "429": "   *   Lists.cartesianProduct(ImmutableList.of(\n",
        "430": "   *       ImmutableList.of(1, 2),\n",
        "431": "   *       ImmutableList.of(\"A\", \"B\", \"C\")))}</pre>\n",
        "432": "   *\n",
        "433": "   * <p>returns a list containing six lists in the following order:\n",
        "434": "   *\n",
        "435": "   * <ul>\n",
        "436": "   * <li>{@code ImmutableList.of(1, \"A\")}\n",
        "437": "   * <li>{@code ImmutableList.of(1, \"B\")}\n",
        "438": "   * <li>{@code ImmutableList.of(1, \"C\")}\n",
        "439": "   * <li>{@code ImmutableList.of(2, \"A\")}\n",
        "440": "   * <li>{@code ImmutableList.of(2, \"B\")}\n",
        "441": "   * <li>{@code ImmutableList.of(2, \"C\")}\n",
        "442": "   * </ul>\n",
        "443": "   *\n",
        "444": "   * <p>The result is guaranteed to be in the \"traditional\", lexicographical\n",
        "445": "   * order for Cartesian products that you would get from nesting for loops:\n",
        "446": "   * <pre>   {@code\n",
        "447": "   *\n",
        "448": "   *   for (B b0 : lists.get(0)) {\n",
        "449": "   *     for (B b1 : lists.get(1)) {\n",
        "450": "   *       ...\n",
        "451": "   *       ImmutableList<B> tuple = ImmutableList.of(b0, b1, ...);\n",
        "452": "   *       // operate on tuple\n",
        "453": "   *     }\n",
        "454": "   *   }}</pre>\n",
        "455": "   *\n",
        "456": "   * <p>Note that if any input list is empty, the Cartesian product will also be\n",
        "457": "   * empty. If no lists at all are provided (an empty list), the resulting\n",
        "458": "   * Cartesian product has one element, an empty list (counter-intuitive, but\n",
        "459": "   * mathematically consistent).\n",
        "460": "   *\n",
        "461": "   * <p><i>Performance notes:</i> while the cartesian product of lists of size\n",
        "462": "   * {@code m, n, p} is a list of size {@code m x n x p}, its actual memory\n",
        "463": "   * consumption is much smaller. When the cartesian product is constructed, the\n",
        "464": "   * input lists are merely copied. Only as the resulting list is iterated are\n",
        "465": "   * the individual lists created, and these are not retained after iteration.\n",
        "466": "   *\n",
        "467": "   * @param lists the lists to choose elements from, in the order that\n",
        "468": "   *     the elements chosen from those lists should appear in the resulting\n",
        "469": "   *     lists\n",
        "470": "   * @param <B> any common base class shared by all axes (often just {@link\n",
        "471": "   *     Object})\n",
        "472": "   * @return the Cartesian product, as an immutable list containing immutable\n",
        "473": "   *     lists\n",
        "474": "   * @throws IllegalArgumentException if the size of the cartesian product would\n",
        "475": "   *     be greater than {@link Integer#MAX_VALUE}\n",
        "476": "   * @throws NullPointerException if {@code lists}, any one of the\n",
        "477": "   *     {@code lists}, or any element of a provided list is null\n",
        "478": "   * @since 19.0\n",
        "479": "   */\n",
        "480": "  public static <B> List<List<B>> cartesianProduct(List<? extends B>... lists) {\n",
        "481": "    return cartesianProduct(Arrays.asList(lists));\n",
        "482": "  }\n",
        "483": "\n",
        "484": "  /**\n",
        "485": "   * Returns a list that applies {@code function} to each element of {@code\n",
        "486": "   * fromList}. The returned list is a transformed view of {@code fromList};\n",
        "487": "   * changes to {@code fromList} will be reflected in the returned list and vice\n",
        "488": "   * versa.\n",
        "489": "   *\n",
        "490": "   * <p>Since functions are not reversible, the transform is one-way and new\n",
        "491": "   * items cannot be stored in the returned list. The {@code add},\n",
        "492": "   * {@code addAll} and {@code set} methods are unsupported in the returned\n",
        "493": "   * list.\n",
        "494": "   *\n",
        "495": "   * <p>The function is applied lazily, invoked when needed. This is necessary\n",
        "496": "   * for the returned list to be a view, but it means that the function will be\n",
        "497": "   * applied many times for bulk operations like {@link List#contains} and\n",
        "498": "   * {@link List#hashCode}. For this to perform well, {@code function} should be\n",
        "499": "   * fast. To avoid lazy evaluation when the returned list doesn't need to be a\n",
        "500": "   * view, copy the returned list into a new list of your choosing.\n",
        "501": "   *\n",
        "502": "   * <p>If {@code fromList} implements {@link RandomAccess}, so will the\n",
        "503": "   * returned list. The returned list is threadsafe if the supplied list and\n",
        "504": "   * function are.\n",
        "505": "   *\n",
        "506": "   * <p>If only a {@code Collection} or {@code Iterable} input is available, use\n",
        "507": "   * {@link Collections2#transform} or {@link Iterables#transform}.\n",
        "508": "   *\n",
        "509": "   * <p><b>Note:</b> serializing the returned list is implemented by serializing\n",
        "510": "   * {@code fromList}, its contents, and {@code function} -- <i>not</i> by\n",
        "511": "   * serializing the transformed values. This can lead to surprising behavior,\n",
        "512": "   * so serializing the returned list is <b>not recommended</b>. Instead,\n",
        "513": "   * copy the list using {@link ImmutableList#copyOf(Collection)} (for example),\n",
        "514": "   * then serialize the copy. Other methods similar to this do not implement\n",
        "515": "   * serialization at all for this reason.\n",
        "516": "   */\n",
        "517": "  @CheckReturnValue\n",
        "518": "  public static <F, T> List<T> transform(\n",
        "519": "      List<F> fromList, Function<? super F, ? extends T> function) {\n",
        "520": "    return (fromList instanceof RandomAccess)\n",
        "521": "        ? new TransformingRandomAccessList<F, T>(fromList, function)\n",
        "522": "        : new TransformingSequentialList<F, T>(fromList, function);\n",
        "523": "  }\n",
        "524": "\n",
        "525": "  /**\n",
        "526": "   * Implementation of a sequential transforming list.\n",
        "527": "   *\n",
        "528": "   * @see Lists#transform\n",
        "529": "   */\n",
        "530": "  private static class TransformingSequentialList<F, T> extends AbstractSequentialList<T>\n",
        "531": "      implements Serializable {\n",
        "532": "    final List<F> fromList;\n",
        "533": "    final Function<? super F, ? extends T> function;\n",
        "534": "\n",
        "535": "    TransformingSequentialList(List<F> fromList, Function<? super F, ? extends T> function) {\n",
        "536": "      this.fromList = checkNotNull(fromList);\n",
        "537": "      this.function = checkNotNull(function);\n",
        "538": "    }\n",
        "539": "    /**\n",
        "540": "     * The default implementation inherited is based on iteration and removal of\n",
        "541": "     * each element which can be overkill. That's why we forward this call\n",
        "542": "     * directly to the backing list.\n",
        "543": "     */\n",
        "544": "    @Override\n",
        "545": "    public void clear() {\n",
        "546": "      fromList.clear();\n",
        "547": "    }\n",
        "548": "\n",
        "549": "    @Override\n",
        "550": "    public int size() {\n",
        "551": "      return fromList.size();\n",
        "552": "    }\n",
        "553": "\n",
        "554": "    @Override\n",
        "555": "    public ListIterator<T> listIterator(final int index) {\n",
        "556": "      return new TransformedListIterator<F, T>(fromList.listIterator(index)) {\n",
        "557": "        @Override\n",
        "558": "        T transform(F from) {\n",
        "559": "          return function.apply(from);\n",
        "560": "        }\n",
        "561": "      };\n",
        "562": "    }\n",
        "563": "\n",
        "564": "    private static final long serialVersionUID = 0;\n",
        "565": "  }\n",
        "566": "\n",
        "567": "  /**\n",
        "568": "   * Implementation of a transforming random access list. We try to make as many\n",
        "569": "   * of these methods pass-through to the source list as possible so that the\n",
        "570": "   * performance characteristics of the source list and transformed list are\n",
        "571": "   * similar.\n",
        "572": "   *\n",
        "573": "   * @see Lists#transform\n",
        "574": "   */\n",
        "575": "  private static class TransformingRandomAccessList<F, T> extends AbstractList<T>\n",
        "576": "      implements RandomAccess, Serializable {\n",
        "577": "    final List<F> fromList;\n",
        "578": "    final Function<? super F, ? extends T> function;\n",
        "579": "\n",
        "580": "    TransformingRandomAccessList(List<F> fromList, Function<? super F, ? extends T> function) {\n",
        "581": "      this.fromList = checkNotNull(fromList);\n",
        "582": "      this.function = checkNotNull(function);\n",
        "583": "    }\n",
        "584": "\n",
        "585": "    @Override\n",
        "586": "    public void clear() {\n",
        "587": "      fromList.clear();\n",
        "588": "    }\n",
        "589": "\n",
        "590": "    @Override\n",
        "591": "    public T get(int index) {\n",
        "592": "      return function.apply(fromList.get(index));\n",
        "593": "    }\n",
        "594": "\n",
        "595": "    @Override\n",
        "596": "    public Iterator<T> iterator() {\n",
        "597": "      return listIterator();\n",
        "598": "    }\n",
        "599": "\n",
        "600": "    @Override\n",
        "601": "    public ListIterator<T> listIterator(int index) {\n",
        "602": "      return new TransformedListIterator<F, T>(fromList.listIterator(index)) {\n",
        "603": "        @Override\n",
        "604": "        T transform(F from) {\n",
        "605": "          return function.apply(from);\n",
        "606": "        }\n",
        "607": "      };\n",
        "608": "    }\n",
        "609": "\n",
        "610": "    @Override\n",
        "611": "    public boolean isEmpty() {\n",
        "612": "      return fromList.isEmpty();\n",
        "613": "    }\n",
        "614": "\n",
        "615": "    @Override\n",
        "616": "    public T remove(int index) {\n",
        "617": "      return function.apply(fromList.remove(index));\n",
        "618": "    }\n",
        "619": "\n",
        "620": "    @Override\n",
        "621": "    public int size() {\n",
        "622": "      return fromList.size();\n",
        "623": "    }\n",
        "624": "\n",
        "625": "    private static final long serialVersionUID = 0;\n",
        "626": "  }\n",
        "627": "\n",
        "628": "  /**\n",
        "629": "   * Returns consecutive {@linkplain List#subList(int, int) sublists} of a list,\n",
        "630": "   * each of the same size (the final list may be smaller). For example,\n",
        "631": "   * partitioning a list containing {@code [a, b, c, d, e]} with a partition\n",
        "632": "   * size of 3 yields {@code [[a, b, c], [d, e]]} -- an outer list containing\n",
        "633": "   * two inner lists of three and two elements, all in the original order.\n",
        "634": "   *\n",
        "635": "   * <p>The outer list is unmodifiable, but reflects the latest state of the\n",
        "636": "   * source list. The inner lists are sublist views of the original list,\n",
        "637": "   * produced on demand using {@link List#subList(int, int)}, and are subject\n",
        "638": "   * to all the usual caveats about modification as explained in that API.\n",
        "639": "   *\n",
        "640": "   * @param list the list to return consecutive sublists of\n",
        "641": "   * @param size the desired size of each sublist (the last may be\n",
        "642": "   *     smaller)\n",
        "643": "   * @return a list of consecutive sublists\n",
        "644": "   * @throws IllegalArgumentException if {@code partitionSize} is nonpositive\n",
        "645": "   */\n",
        "646": "  public static <T> List<List<T>> partition(List<T> list, int size) {\n",
        "647": "    checkNotNull(list);\n",
        "648": "    checkArgument(size > 0);\n",
        "649": "    return (list instanceof RandomAccess)\n",
        "650": "        ? new RandomAccessPartition<T>(list, size)\n",
        "651": "        : new Partition<T>(list, size);\n",
        "652": "  }\n",
        "653": "\n",
        "654": "  private static class Partition<T> extends AbstractList<List<T>> {\n",
        "655": "    final List<T> list;\n",
        "656": "    final int size;\n",
        "657": "\n",
        "658": "    Partition(List<T> list, int size) {\n",
        "659": "      this.list = list;\n",
        "660": "      this.size = size;\n",
        "661": "    }\n",
        "662": "\n",
        "663": "    @Override\n",
        "664": "    public List<T> get(int index) {\n",
        "665": "      checkElementIndex(index, size());\n",
        "666": "      int start = index * size;\n",
        "667": "      int end = Math.min(start + size, list.size());\n",
        "668": "      return list.subList(start, end);\n",
        "669": "    }\n",
        "670": "\n",
        "671": "    @Override\n",
        "672": "    public int size() {\n",
        "673": "      return IntMath.divide(list.size(), size, RoundingMode.CEILING);\n",
        "674": "    }\n",
        "675": "\n",
        "676": "    @Override\n",
        "677": "    public boolean isEmpty() {\n",
        "678": "      return list.isEmpty();\n",
        "679": "    }\n",
        "680": "  }\n",
        "681": "\n",
        "682": "  private static class RandomAccessPartition<T> extends Partition<T> implements RandomAccess {\n",
        "683": "    RandomAccessPartition(List<T> list, int size) {\n",
        "684": "      super(list, size);\n",
        "685": "    }\n",
        "686": "  }\n",
        "687": "\n",
        "688": "  /**\n",
        "689": "   * Returns a view of the specified string as an immutable list of {@code\n",
        "690": "   * Character} values.\n",
        "691": "   *\n",
        "692": "   * @since 7.0\n",
        "693": "   */\n",
        "694": "  @Beta\n",
        "695": "  public static ImmutableList<Character> charactersOf(String string) {\n",
        "696": "    return new StringAsImmutableList(checkNotNull(string));\n",
        "697": "  }\n",
        "698": "\n",
        "699": "  @SuppressWarnings(\"serial\") // serialized using ImmutableList serialization\n",
        "700": "  private static final class StringAsImmutableList extends ImmutableList<Character> {\n",
        "701": "\n",
        "702": "    private final String string;\n",
        "703": "\n",
        "704": "    StringAsImmutableList(String string) {\n",
        "705": "      this.string = string;\n",
        "706": "    }\n",
        "707": "\n",
        "708": "    @Override\n",
        "709": "    public int indexOf(@Nullable Object object) {\n",
        "710": "      return (object instanceof Character) ? string.indexOf((Character) object) : -1;\n",
        "711": "    }\n",
        "712": "\n",
        "713": "    @Override\n",
        "714": "    public int lastIndexOf(@Nullable Object object) {\n",
        "715": "      return (object instanceof Character) ? string.lastIndexOf((Character) object) : -1;\n",
        "716": "    }\n",
        "717": "\n",
        "718": "    @Override\n",
        "719": "    public ImmutableList<Character> subList(int fromIndex, int toIndex) {\n",
        "720": "      checkPositionIndexes(fromIndex, toIndex, size()); // for GWT\n",
        "721": "      return charactersOf(string.substring(fromIndex, toIndex));\n",
        "722": "    }\n",
        "723": "\n",
        "724": "    @Override\n",
        "725": "    boolean isPartialView() {\n",
        "726": "      return false;\n",
        "727": "    }\n",
        "728": "\n",
        "729": "    @Override\n",
        "730": "    public Character get(int index) {\n",
        "731": "      checkElementIndex(index, size()); // for GWT\n",
        "732": "      return string.charAt(index);\n",
        "733": "    }\n",
        "734": "\n",
        "735": "    @Override\n",
        "736": "    public int size() {\n",
        "737": "      return string.length();\n",
        "738": "    }\n",
        "739": "  }\n",
        "740": "\n",
        "741": "  /**\n",
        "742": "   * Returns a view of the specified {@code CharSequence} as a {@code\n",
        "743": "   * List<Character>}, viewing {@code sequence} as a sequence of Unicode code\n",
        "744": "   * units. The view does not support any modification operations, but reflects\n",
        "745": "   * any changes to the underlying character sequence.\n",
        "746": "   *\n",
        "747": "   * @param sequence the character sequence to view as a {@code List} of\n",
        "748": "   *        characters\n",
        "749": "   * @return an {@code List<Character>} view of the character sequence\n",
        "750": "   * @since 7.0\n",
        "751": "   */\n",
        "752": "  @Beta\n",
        "753": "  public static List<Character> charactersOf(CharSequence sequence) {\n",
        "754": "    return new CharSequenceAsList(checkNotNull(sequence));\n",
        "755": "  }\n",
        "756": "\n",
        "757": "  private static final class CharSequenceAsList extends AbstractList<Character> {\n",
        "758": "    private final CharSequence sequence;\n",
        "759": "\n",
        "760": "    CharSequenceAsList(CharSequence sequence) {\n",
        "761": "      this.sequence = sequence;\n",
        "762": "    }\n",
        "763": "\n",
        "764": "    @Override\n",
        "765": "    public Character get(int index) {\n",
        "766": "      checkElementIndex(index, size()); // for GWT\n",
        "767": "      return sequence.charAt(index);\n",
        "768": "    }\n",
        "769": "\n",
        "770": "    @Override\n",
        "771": "    public int size() {\n",
        "772": "      return sequence.length();\n",
        "773": "    }\n",
        "774": "  }\n",
        "775": "\n",
        "776": "  /**\n",
        "777": "   * Returns a reversed view of the specified list. For example, {@code\n",
        "778": "   * Lists.reverse(Arrays.asList(1, 2, 3))} returns a list containing {@code 3,\n",
        "779": "   * 2, 1}. The returned list is backed by this list, so changes in the returned\n",
        "780": "   * list are reflected in this list, and vice-versa. The returned list supports\n",
        "781": "   * all of the optional list operations supported by this list.\n",
        "782": "   *\n",
        "783": "   * <p>The returned list is random-access if the specified list is random\n",
        "784": "   * access.\n",
        "785": "   *\n",
        "786": "   * @since 7.0\n",
        "787": "   */\n",
        "788": "  @CheckReturnValue\n",
        "789": "  public static <T> List<T> reverse(List<T> list) {\n",
        "790": "    if (list instanceof ImmutableList) {\n",
        "791": "      return ((ImmutableList<T>) list).reverse();\n",
        "792": "    } else if (list instanceof ReverseList) {\n",
        "793": "      return ((ReverseList<T>) list).getForwardList();\n",
        "794": "    } else if (list instanceof RandomAccess) {\n",
        "795": "      return new RandomAccessReverseList<T>(list);\n",
        "796": "    } else {\n",
        "797": "      return new ReverseList<T>(list);\n",
        "798": "    }\n",
        "799": "  }\n",
        "800": "\n",
        "801": "  private static class ReverseList<T> extends AbstractList<T> {\n",
        "802": "    private final List<T> forwardList;\n",
        "803": "\n",
        "804": "    ReverseList(List<T> forwardList) {\n",
        "805": "      this.forwardList = checkNotNull(forwardList);\n",
        "806": "    }\n",
        "807": "\n",
        "808": "    List<T> getForwardList() {\n",
        "809": "      return forwardList;\n",
        "810": "    }\n",
        "811": "\n",
        "812": "    private int reverseIndex(int index) {\n",
        "813": "      int size = size();\n",
        "814": "      checkElementIndex(index, size);\n",
        "815": "      return (size - 1) - index;\n",
        "816": "    }\n",
        "817": "\n",
        "818": "    private int reversePosition(int index) {\n",
        "819": "      int size = size();\n",
        "820": "      checkPositionIndex(index, size);\n",
        "821": "      return size - index;\n",
        "822": "    }\n",
        "823": "\n",
        "824": "    @Override\n",
        "825": "    public void add(int index, @Nullable T element) {\n",
        "826": "      forwardList.add(reversePosition(index), element);\n",
        "827": "    }\n",
        "828": "\n",
        "829": "    @Override\n",
        "830": "    public void clear() {\n",
        "831": "      forwardList.clear();\n",
        "832": "    }\n",
        "833": "\n",
        "834": "    @Override\n",
        "835": "    public T remove(int index) {\n",
        "836": "      return forwardList.remove(reverseIndex(index));\n",
        "837": "    }\n",
        "838": "\n",
        "839": "    @Override\n",
        "840": "    protected void removeRange(int fromIndex, int toIndex) {\n",
        "841": "      subList(fromIndex, toIndex).clear();\n",
        "842": "    }\n",
        "843": "\n",
        "844": "    @Override\n",
        "845": "    public T set(int index, @Nullable T element) {\n",
        "846": "      return forwardList.set(reverseIndex(index), element);\n",
        "847": "    }\n",
        "848": "\n",
        "849": "    @Override\n",
        "850": "    public T get(int index) {\n",
        "851": "      return forwardList.get(reverseIndex(index));\n",
        "852": "    }\n",
        "853": "\n",
        "854": "    @Override\n",
        "855": "    public int size() {\n",
        "856": "      return forwardList.size();\n",
        "857": "    }\n",
        "858": "\n",
        "859": "    @Override\n",
        "860": "    public List<T> subList(int fromIndex, int toIndex) {\n",
        "861": "      checkPositionIndexes(fromIndex, toIndex, size());\n",
        "862": "      return reverse(forwardList.subList(reversePosition(toIndex), reversePosition(fromIndex)));\n",
        "863": "    }\n",
        "864": "\n",
        "865": "    @Override\n",
        "866": "    public Iterator<T> iterator() {\n",
        "867": "      return listIterator();\n",
        "868": "    }\n",
        "869": "\n",
        "870": "    @Override\n",
        "871": "    public ListIterator<T> listIterator(int index) {\n",
        "872": "      int start = reversePosition(index);\n",
        "873": "      final ListIterator<T> forwardIterator = forwardList.listIterator(start);\n",
        "874": "      return new ListIterator<T>() {\n",
        "875": "\n",
        "876": "        boolean canRemoveOrSet;\n",
        "877": "\n",
        "878": "        @Override\n",
        "879": "        public void add(T e) {\n",
        "880": "          forwardIterator.add(e);\n",
        "881": "          forwardIterator.previous();\n",
        "882": "          canRemoveOrSet = false;\n",
        "883": "        }\n",
        "884": "\n",
        "885": "        @Override\n",
        "886": "        public boolean hasNext() {\n",
        "887": "          return forwardIterator.hasPrevious();\n",
        "888": "        }\n",
        "889": "\n",
        "890": "        @Override\n",
        "891": "        public boolean hasPrevious() {\n",
        "892": "          return forwardIterator.hasNext();\n",
        "893": "        }\n",
        "894": "\n",
        "895": "        @Override\n",
        "896": "        public T next() {\n",
        "897": "          if (!hasNext()) {\n",
        "898": "            throw new NoSuchElementException();\n",
        "899": "          }\n",
        "900": "          canRemoveOrSet = true;\n",
        "901": "          return forwardIterator.previous();\n",
        "902": "        }\n",
        "903": "\n",
        "904": "        @Override\n",
        "905": "        public int nextIndex() {\n",
        "906": "          return reversePosition(forwardIterator.nextIndex());\n",
        "907": "        }\n",
        "908": "\n",
        "909": "        @Override\n",
        "910": "        public T previous() {\n",
        "911": "          if (!hasPrevious()) {\n",
        "912": "            throw new NoSuchElementException();\n",
        "913": "          }\n",
        "914": "          canRemoveOrSet = true;\n",
        "915": "          return forwardIterator.next();\n",
        "916": "        }\n",
        "917": "\n",
        "918": "        @Override\n",
        "919": "        public int previousIndex() {\n",
        "920": "          return nextIndex() - 1;\n",
        "921": "        }\n",
        "922": "\n",
        "923": "        @Override\n",
        "924": "        public void remove() {\n",
        "925": "          checkRemove(canRemoveOrSet);\n",
        "926": "          forwardIterator.remove();\n",
        "927": "          canRemoveOrSet = false;\n",
        "928": "        }\n",
        "929": "\n",
        "930": "        @Override\n",
        "931": "        public void set(T e) {\n",
        "932": "          checkState(canRemoveOrSet);\n",
        "933": "          forwardIterator.set(e);\n",
        "934": "        }\n",
        "935": "      };\n",
        "936": "    }\n",
        "937": "  }\n",
        "938": "\n",
        "939": "  private static class RandomAccessReverseList<T> extends ReverseList<T> implements RandomAccess {\n",
        "940": "    RandomAccessReverseList(List<T> forwardList) {\n",
        "941": "      super(forwardList);\n",
        "942": "    }\n",
        "943": "  }\n",
        "944": "\n",
        "945": "  /**\n",
        "946": "   * An implementation of {@link List#hashCode()}.\n",
        "947": "   */\n",
        "948": "  static int hashCodeImpl(List<?> list) {\n",
        "949": "    // TODO(lowasser): worth optimizing for RandomAccess?\n",
        "950": "    int hashCode = 1;\n",
        "951": "    for (Object o : list) {\n",
        "952": "      hashCode = 31 * hashCode + (o == null ? 0 : o.hashCode());\n",
        "953": "\n",
        "954": "      hashCode = ~~hashCode;\n",
        "955": "      // needed to deal with GWT integer overflow\n",
        "956": "    }\n",
        "957": "    return hashCode;\n",
        "958": "  }\n",
        "959": "\n",
        "960": "  /**\n",
        "961": "   * An implementation of {@link List#equals(Object)}.\n",
        "962": "   */\n",
        "963": "  static boolean equalsImpl(List<?> thisList, @Nullable Object other) {\n",
        "964": "    if (other == checkNotNull(thisList)) {\n",
        "965": "      return true;\n",
        "966": "    }\n",
        "967": "    if (!(other instanceof List)) {\n",
        "968": "      return false;\n",
        "969": "    }\n",
        "970": "    List<?> otherList = (List<?>) other;\n",
        "971": "    int size = thisList.size();\n",
        "972": "    if (size != otherList.size()) {\n",
        "973": "      return false;\n",
        "974": "    }\n",
        "975": "    if (thisList instanceof RandomAccess && otherList instanceof RandomAccess) {\n",
        "976": "      // avoid allocation and use the faster loop\n",
        "977": "      for (int i = 0; i < size; i++) {\n",
        "978": "        if (!Objects.equal(thisList.get(i), otherList.get(i))) {\n",
        "979": "          return false;\n",
        "980": "        }\n",
        "981": "      }\n",
        "982": "      return true;\n",
        "983": "    } else {\n",
        "984": "      return Iterators.elementsEqual(thisList.iterator(), otherList.iterator());\n",
        "985": "    }\n",
        "986": "  }\n",
        "987": "\n",
        "988": "  /**\n",
        "989": "   * An implementation of {@link List#addAll(int, Collection)}.\n",
        "990": "   */\n",
        "991": "  static <E> boolean addAllImpl(List<E> list, int index, Iterable<? extends E> elements) {\n",
        "992": "    boolean changed = false;\n",
        "993": "    ListIterator<E> listIterator = list.listIterator(index);\n",
        "994": "    for (E e : elements) {\n",
        "995": "      listIterator.add(e);\n",
        "996": "      changed = true;\n",
        "997": "    }\n",
        "998": "    return changed;\n",
        "999": "  }\n",
        "1000": "\n",
        "1001": "  /**\n",
        "1002": "   * An implementation of {@link List#indexOf(Object)}.\n",
        "1003": "   */\n",
        "1004": "  static int indexOfImpl(List<?> list, @Nullable Object element) {\n",
        "1005": "    if (list instanceof RandomAccess) {\n",
        "1006": "      return indexOfRandomAccess(list, element);\n",
        "1007": "    } else {\n",
        "1008": "      ListIterator<?> listIterator = list.listIterator();\n",
        "1009": "      while (listIterator.hasNext()) {\n",
        "1010": "        if (Objects.equal(element, listIterator.next())) {\n",
        "1011": "          return listIterator.previousIndex();\n",
        "1012": "        }\n",
        "1013": "      }\n",
        "1014": "      return -1;\n",
        "1015": "    }\n",
        "1016": "  }\n",
        "1017": "\n",
        "1018": "  private static int indexOfRandomAccess(List<?> list, @Nullable Object element) {\n",
        "1019": "    int size = list.size();\n",
        "1020": "    if (element == null) {\n",
        "1021": "      for (int i = 0; i < size; i++) {\n",
        "1022": "        if (list.get(i) == null) {\n",
        "1023": "          return i;\n",
        "1024": "        }\n",
        "1025": "      }\n",
        "1026": "    } else {\n",
        "1027": "      for (int i = 0; i < size; i++) {\n",
        "1028": "        if (element.equals(list.get(i))) {\n",
        "1029": "          return i;\n",
        "1030": "        }\n",
        "1031": "      }\n",
        "1032": "    }\n",
        "1033": "    return -1;\n",
        "1034": "  }\n",
        "1035": "\n",
        "1036": "  /**\n",
        "1037": "   * An implementation of {@link List#lastIndexOf(Object)}.\n",
        "1038": "   */\n",
        "1039": "  static int lastIndexOfImpl(List<?> list, @Nullable Object element) {\n",
        "1040": "    if (list instanceof RandomAccess) {\n",
        "1041": "      return lastIndexOfRandomAccess(list, element);\n",
        "1042": "    } else {\n",
        "1043": "      ListIterator<?> listIterator = list.listIterator(list.size());\n",
        "1044": "      while (listIterator.hasPrevious()) {\n",
        "1045": "        if (Objects.equal(element, listIterator.previous())) {\n",
        "1046": "          return listIterator.nextIndex();\n",
        "1047": "        }\n",
        "1048": "      }\n",
        "1049": "      return -1;\n",
        "1050": "    }\n",
        "1051": "  }\n",
        "1052": "\n",
        "1053": "  private static int lastIndexOfRandomAccess(List<?> list, @Nullable Object element) {\n",
        "1054": "    if (element == null) {\n",
        "1055": "      for (int i = list.size() - 1; i >= 0; i--) {\n",
        "1056": "        if (list.get(i) == null) {\n",
        "1057": "          return i;\n",
        "1058": "        }\n",
        "1059": "      }\n",
        "1060": "    } else {\n",
        "1061": "      for (int i = list.size() - 1; i >= 0; i--) {\n",
        "1062": "        if (element.equals(list.get(i))) {\n",
        "1063": "          return i;\n",
        "1064": "        }\n",
        "1065": "      }\n",
        "1066": "    }\n",
        "1067": "    return -1;\n",
        "1068": "  }\n",
        "1069": "\n",
        "1070": "  /**\n",
        "1071": "   * Returns an implementation of {@link List#listIterator(int)}.\n",
        "1072": "   */\n",
        "1073": "  static <E> ListIterator<E> listIteratorImpl(List<E> list, int index) {\n",
        "1074": "    return new AbstractListWrapper<E>(list).listIterator(index);\n",
        "1075": "  }\n",
        "1076": "\n",
        "1077": "  /**\n",
        "1078": "   * An implementation of {@link List#subList(int, int)}.\n",
        "1079": "   */\n",
        "1080": "  static <E> List<E> subListImpl(final List<E> list, int fromIndex, int toIndex) {\n",
        "1081": "    List<E> wrapper;\n",
        "1082": "    if (list instanceof RandomAccess) {\n",
        "1083": "      wrapper = new RandomAccessListWrapper<E>(list) {\n",
        "1084": "        @Override\n",
        "1085": "        public ListIterator<E> listIterator(int index) {\n",
        "1086": "          return backingList.listIterator(index);\n",
        "1087": "        }\n",
        "1088": "\n",
        "1089": "        private static final long serialVersionUID = 0;\n",
        "1090": "      };\n",
        "1091": "    } else {\n",
        "1092": "      wrapper = new AbstractListWrapper<E>(list) {\n",
        "1093": "        @Override\n",
        "1094": "        public ListIterator<E> listIterator(int index) {\n",
        "1095": "          return backingList.listIterator(index);\n",
        "1096": "        }\n",
        "1097": "\n",
        "1098": "        private static final long serialVersionUID = 0;\n",
        "1099": "      };\n",
        "1100": "    }\n",
        "1101": "    return wrapper.subList(fromIndex, toIndex);\n",
        "1102": "  }\n",
        "1103": "\n",
        "1104": "  private static class AbstractListWrapper<E> extends AbstractList<E> {\n",
        "1105": "    final List<E> backingList;\n",
        "1106": "\n",
        "1107": "    AbstractListWrapper(List<E> backingList) {\n",
        "1108": "      this.backingList = checkNotNull(backingList);\n",
        "1109": "    }\n",
        "1110": "\n",
        "1111": "    @Override\n",
        "1112": "    public void add(int index, E element) {\n",
        "1113": "      backingList.add(index, element);\n",
        "1114": "    }\n",
        "1115": "\n",
        "1116": "    @Override\n",
        "1117": "    public boolean addAll(int index, Collection<? extends E> c) {\n",
        "1118": "      return backingList.addAll(index, c);\n",
        "1119": "    }\n",
        "1120": "\n",
        "1121": "    @Override\n",
        "1122": "    public E get(int index) {\n",
        "1123": "      return backingList.get(index);\n",
        "1124": "    }\n",
        "1125": "\n",
        "1126": "    @Override\n",
        "1127": "    public E remove(int index) {\n",
        "1128": "      return backingList.remove(index);\n",
        "1129": "    }\n",
        "1130": "\n",
        "1131": "    @Override\n",
        "1132": "    public E set(int index, E element) {\n",
        "1133": "      return backingList.set(index, element);\n",
        "1134": "    }\n",
        "1135": "\n",
        "1136": "    @Override\n",
        "1137": "    public boolean contains(Object o) {\n",
        "1138": "      return backingList.contains(o);\n",
        "1139": "    }\n",
        "1140": "\n",
        "1141": "    @Override\n",
        "1142": "    public int size() {\n",
        "1143": "      return backingList.size();\n",
        "1144": "    }\n",
        "1145": "  }\n",
        "1146": "\n",
        "1147": "  private static class RandomAccessListWrapper<E> extends AbstractListWrapper<E>\n",
        "1148": "      implements RandomAccess {\n",
        "1149": "    RandomAccessListWrapper(List<E> backingList) {\n",
        "1150": "      super(backingList);\n",
        "1151": "    }\n",
        "1152": "  }\n",
        "1153": "\n",
        "1154": "  /**\n",
        "1155": "   * Used to avoid http://bugs.sun.com/view_bug.do?bug_id=6558557\n",
        "1156": "   */\n",
        "1157": "  static <T> List<T> cast(Iterable<T> iterable) {\n",
        "1158": "    return (List<T>) iterable;\n",
        "1159": "  }\n",
        "1160": "}\n"
    }
}