{
    "addition": {},
    "removed": {
        "1": "/*\n",
        "2": " * Copyright (C) 2009 The Guava Authors\n",
        "3": " *\n",
        "4": " * Licensed under the Apache License, Version 2.0 (the \"License\");\n",
        "5": " * you may not use this file except in compliance with the License.\n",
        "6": " * You may obtain a copy of the License at\n",
        "7": " *\n",
        "8": " * http://www.apache.org/licenses/LICENSE-2.0\n",
        "9": " *\n",
        "10": " * Unless required by applicable law or agreed to in writing, software\n",
        "11": " * distributed under the License is distributed on an \"AS IS\" BASIS,\n",
        "12": " * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n",
        "13": " * See the License for the specific language governing permissions and\n",
        "14": " * limitations under the License.\n",
        "15": " */\n",
        "16": "\n",
        "17": "package com.google.common.base;\n",
        "18": "\n",
        "19": "import static com.google.common.truth.Truth.assertThat;\n",
        "20": "\n",
        "21": "import com.google.common.annotations.GwtCompatible;\n",
        "22": "import com.google.common.collect.ImmutableMap;\n",
        "23": "\n",
        "24": "import junit.framework.TestCase;\n",
        "25": "\n",
        "26": "import java.util.Iterator;\n",
        "27": "import java.util.List;\n",
        "28": "import java.util.Map;\n",
        "29": "\n",
        "30": "/**\n",
        "31": " * @author Julien Silland\n",
        "32": " */\n",
        "33": "@GwtCompatible(emulated = true)\n",
        "34": "public class SplitterTest extends TestCase {\n",
        "35": "\n",
        "36": "  private static final Splitter COMMA_SPLITTER = Splitter.on(',');\n",
        "37": "\n",
        "38": "  @SuppressWarnings(\"CheckReturnValue\")\n",
        "39": "  public void testSplitNullString() {\n",
        "40": "    try {\n",
        "41": "      COMMA_SPLITTER.split(null);\n",
        "42": "      fail();\n",
        "43": "    } catch (NullPointerException expected) {\n",
        "44": "    }\n",
        "45": "  }\n",
        "46": "\n",
        "47": "  public void testCharacterSimpleSplit() {\n",
        "48": "    String simple = \"a,b,c\";\n",
        "49": "    Iterable<String> letters = COMMA_SPLITTER.split(simple);\n",
        "50": "    assertThat(letters).containsExactly(\"a\", \"b\", \"c\").inOrder();\n",
        "51": "  }\n",
        "52": "\n",
        "53": "  /**\n",
        "54": "   * All of the infrastructure of split and splitToString is identical, so we\n",
        "55": "   * do one test of splitToString. All other cases should be covered by testing\n",
        "56": "   * of split.\n",
        "57": "   *\n",
        "58": "   * <p>TODO(user): It would be good to make all the relevant tests run on\n",
        "59": "   * both split and splitToString automatically.\n",
        "60": "   */\n",
        "61": "  public void testCharacterSimpleSplitToList() {\n",
        "62": "    String simple = \"a,b,c\";\n",
        "63": "    List<String> letters = COMMA_SPLITTER.splitToList(simple);\n",
        "64": "    assertThat(letters).containsExactly(\"a\", \"b\", \"c\").inOrder();\n",
        "65": "  }\n",
        "66": "\n",
        "67": "  public void testToString() {\n",
        "68": "    assertEquals(\"[]\", Splitter.on(',').split(\"\").toString());\n",
        "69": "    assertEquals(\"[a, b, c]\", Splitter.on(',').split(\"a,b,c\").toString());\n",
        "70": "    assertEquals(\"[yam, bam, jam, ham]\", Splitter.on(\", \").split(\"yam, bam, jam, ham\").toString());\n",
        "71": "  }\n",
        "72": "\n",
        "73": "  public void testCharacterSimpleSplitWithNoDelimiter() {\n",
        "74": "    String simple = \"a,b,c\";\n",
        "75": "    Iterable<String> letters = Splitter.on('.').split(simple);\n",
        "76": "    assertThat(letters).containsExactly(\"a,b,c\").inOrder();\n",
        "77": "  }\n",
        "78": "\n",
        "79": "  public void testCharacterSplitWithDoubleDelimiter() {\n",
        "80": "    String doubled = \"a,,b,c\";\n",
        "81": "    Iterable<String> letters = COMMA_SPLITTER.split(doubled);\n",
        "82": "    assertThat(letters).containsExactly(\"a\", \"\", \"b\", \"c\").inOrder();\n",
        "83": "  }\n",
        "84": "\n",
        "85": "  public void testCharacterSplitWithDoubleDelimiterAndSpace() {\n",
        "86": "    String doubled = \"a,, b,c\";\n",
        "87": "    Iterable<String> letters = COMMA_SPLITTER.split(doubled);\n",
        "88": "    assertThat(letters).containsExactly(\"a\", \"\", \" b\", \"c\").inOrder();\n",
        "89": "  }\n",
        "90": "\n",
        "91": "  public void testCharacterSplitWithTrailingDelimiter() {\n",
        "92": "    String trailing = \"a,b,c,\";\n",
        "93": "    Iterable<String> letters = COMMA_SPLITTER.split(trailing);\n",
        "94": "    assertThat(letters).containsExactly(\"a\", \"b\", \"c\", \"\").inOrder();\n",
        "95": "  }\n",
        "96": "\n",
        "97": "  public void testCharacterSplitWithLeadingDelimiter() {\n",
        "98": "    String leading = \",a,b,c\";\n",
        "99": "    Iterable<String> letters = COMMA_SPLITTER.split(leading);\n",
        "100": "    assertThat(letters).containsExactly(\"\", \"a\", \"b\", \"c\").inOrder();\n",
        "101": "  }\n",
        "102": "\n",
        "103": "  public void testCharacterSplitWithMulitpleLetters() {\n",
        "104": "    Iterable<String> testCharacteringMotto = Splitter.on('-').split(\n",
        "105": "        \"Testing-rocks-Debugging-sucks\");\n",
        "106": "    assertThat(testCharacteringMotto)\n",
        "107": "        .containsExactly(\"Testing\", \"rocks\", \"Debugging\", \"sucks\")\n",
        "108": "        .inOrder();\n",
        "109": "  }\n",
        "110": "\n",
        "111": "  public void testCharacterSplitWithMatcherDelimiter() {\n",
        "112": "    Iterable<String> testCharacteringMotto = Splitter\n",
        "113": "        .on(CharMatcher.WHITESPACE)\n",
        "114": "        .split(\"Testing\\nrocks\\tDebugging sucks\");\n",
        "115": "    assertThat(testCharacteringMotto)\n",
        "116": "        .containsExactly(\"Testing\", \"rocks\", \"Debugging\", \"sucks\")\n",
        "117": "        .inOrder();\n",
        "118": "  }\n",
        "119": "\n",
        "120": "  public void testCharacterSplitWithDoubleDelimiterOmitEmptyStrings() {\n",
        "121": "    String doubled = \"a..b.c\";\n",
        "122": "    Iterable<String> letters = Splitter.on('.')\n",
        "123": "        .omitEmptyStrings().split(doubled);\n",
        "124": "    assertThat(letters).containsExactly(\"a\", \"b\", \"c\").inOrder();\n",
        "125": "  }\n",
        "126": "\n",
        "127": "  public void testCharacterSplitEmptyToken() {\n",
        "128": "    String emptyToken = \"a. .c\";\n",
        "129": "    Iterable<String> letters = Splitter.on('.').trimResults()\n",
        "130": "        .split(emptyToken);\n",
        "131": "    assertThat(letters).containsExactly(\"a\", \"\", \"c\").inOrder();\n",
        "132": "  }\n",
        "133": "\n",
        "134": "  public void testCharacterSplitEmptyTokenOmitEmptyStrings() {\n",
        "135": "    String emptyToken = \"a. .c\";\n",
        "136": "    Iterable<String> letters = Splitter.on('.')\n",
        "137": "        .omitEmptyStrings().trimResults().split(emptyToken);\n",
        "138": "    assertThat(letters).containsExactly(\"a\", \"c\").inOrder();\n",
        "139": "  }\n",
        "140": "\n",
        "141": "  public void testCharacterSplitOnEmptyString() {\n",
        "142": "    Iterable<String> nothing = Splitter.on('.').split(\"\");\n",
        "143": "    assertThat(nothing).containsExactly(\"\").inOrder();\n",
        "144": "  }\n",
        "145": "\n",
        "146": "  public void testCharacterSplitOnEmptyStringOmitEmptyStrings() {\n",
        "147": "    assertThat(Splitter.on('.').omitEmptyStrings().split(\"\")).isEmpty();\n",
        "148": "  }\n",
        "149": "\n",
        "150": "  public void testCharacterSplitOnOnlyDelimiter() {\n",
        "151": "    Iterable<String> blankblank = Splitter.on('.').split(\".\");\n",
        "152": "    assertThat(blankblank).containsExactly(\"\", \"\").inOrder();\n",
        "153": "  }\n",
        "154": "\n",
        "155": "  public void testCharacterSplitOnOnlyDelimitersOmitEmptyStrings() {\n",
        "156": "    Iterable<String> empty = Splitter.on('.').omitEmptyStrings().split(\"...\");\n",
        "157": "    assertThat(empty).isEmpty();\n",
        "158": "  }\n",
        "159": "\n",
        "160": "  public void testCharacterSplitWithTrim() {\n",
        "161": "    String jacksons = \"arfo(Marlon)aorf, (Michael)orfa, afro(Jackie)orfa, \"\n",
        "162": "        + \"ofar(Jemaine), aff(Tito)\";\n",
        "163": "    Iterable<String> family = COMMA_SPLITTER\n",
        "164": "        .trimResults(CharMatcher.anyOf(\"afro\").or(CharMatcher.WHITESPACE))\n",
        "165": "        .split(jacksons);\n",
        "166": "    assertThat(family)\n",
        "167": "        .containsExactly(\"(Marlon)\", \"(Michael)\", \"(Jackie)\", \"(Jemaine)\", \"(Tito)\")\n",
        "168": "        .inOrder();\n",
        "169": "  }\n",
        "170": "\n",
        "171": "  public void testStringSimpleSplit() {\n",
        "172": "    String simple = \"a,b,c\";\n",
        "173": "    Iterable<String> letters = Splitter.on(',').split(simple);\n",
        "174": "    assertThat(letters).containsExactly(\"a\", \"b\", \"c\").inOrder();\n",
        "175": "  }\n",
        "176": "\n",
        "177": "  public void testStringSimpleSplitWithNoDelimiter() {\n",
        "178": "    String simple = \"a,b,c\";\n",
        "179": "    Iterable<String> letters = Splitter.on('.').split(simple);\n",
        "180": "    assertThat(letters).containsExactly(\"a,b,c\").inOrder();\n",
        "181": "  }\n",
        "182": "\n",
        "183": "  public void testStringSplitWithDoubleDelimiter() {\n",
        "184": "    String doubled = \"a,,b,c\";\n",
        "185": "    Iterable<String> letters = Splitter.on(',').split(doubled);\n",
        "186": "    assertThat(letters).containsExactly(\"a\", \"\", \"b\", \"c\").inOrder();\n",
        "187": "  }\n",
        "188": "\n",
        "189": "  public void testStringSplitWithDoubleDelimiterAndSpace() {\n",
        "190": "    String doubled = \"a,, b,c\";\n",
        "191": "    Iterable<String> letters = Splitter.on(',').split(doubled);\n",
        "192": "    assertThat(letters).containsExactly(\"a\", \"\", \" b\", \"c\").inOrder();\n",
        "193": "  }\n",
        "194": "\n",
        "195": "  public void testStringSplitWithTrailingDelimiter() {\n",
        "196": "    String trailing = \"a,b,c,\";\n",
        "197": "    Iterable<String> letters = Splitter.on(',').split(trailing);\n",
        "198": "    assertThat(letters).containsExactly(\"a\", \"b\", \"c\", \"\").inOrder();\n",
        "199": "  }\n",
        "200": "\n",
        "201": "  public void testStringSplitWithLeadingDelimiter() {\n",
        "202": "    String leading = \",a,b,c\";\n",
        "203": "    Iterable<String> letters = Splitter.on(',').split(leading);\n",
        "204": "    assertThat(letters).containsExactly(\"\", \"a\", \"b\", \"c\").inOrder();\n",
        "205": "  }\n",
        "206": "\n",
        "207": "  public void testStringSplitWithMultipleLetters() {\n",
        "208": "    Iterable<String> testStringingMotto = Splitter.on('-').split(\n",
        "209": "        \"Testing-rocks-Debugging-sucks\");\n",
        "210": "    assertThat(testStringingMotto)\n",
        "211": "        .containsExactly(\"Testing\", \"rocks\", \"Debugging\", \"sucks\")\n",
        "212": "        .inOrder();\n",
        "213": "  }\n",
        "214": "\n",
        "215": "  public void testStringSplitWithDoubleDelimiterOmitEmptyStrings() {\n",
        "216": "    String doubled = \"a..b.c\";\n",
        "217": "    Iterable<String> letters = Splitter.on('.')\n",
        "218": "        .omitEmptyStrings().split(doubled);\n",
        "219": "    assertThat(letters).containsExactly(\"a\", \"b\", \"c\").inOrder();\n",
        "220": "  }\n",
        "221": "\n",
        "222": "  public void testStringSplitEmptyToken() {\n",
        "223": "    String emptyToken = \"a. .c\";\n",
        "224": "    Iterable<String> letters = Splitter.on('.').trimResults()\n",
        "225": "        .split(emptyToken);\n",
        "226": "    assertThat(letters).containsExactly(\"a\", \"\", \"c\").inOrder();\n",
        "227": "  }\n",
        "228": "\n",
        "229": "  public void testStringSplitEmptyTokenOmitEmptyStrings() {\n",
        "230": "    String emptyToken = \"a. .c\";\n",
        "231": "    Iterable<String> letters = Splitter.on('.')\n",
        "232": "        .omitEmptyStrings().trimResults().split(emptyToken);\n",
        "233": "    assertThat(letters).containsExactly(\"a\", \"c\").inOrder();\n",
        "234": "  }\n",
        "235": "\n",
        "236": "  public void testStringSplitWithLongDelimiter() {\n",
        "237": "    String longDelimiter = \"a, b, c\";\n",
        "238": "    Iterable<String> letters = Splitter.on(\", \").split(longDelimiter);\n",
        "239": "    assertThat(letters).containsExactly(\"a\", \"b\", \"c\").inOrder();\n",
        "240": "  }\n",
        "241": "\n",
        "242": "  public void testStringSplitWithLongLeadingDelimiter() {\n",
        "243": "    String longDelimiter = \", a, b, c\";\n",
        "244": "    Iterable<String> letters = Splitter.on(\", \").split(longDelimiter);\n",
        "245": "    assertThat(letters).containsExactly(\"\", \"a\", \"b\", \"c\").inOrder();\n",
        "246": "  }\n",
        "247": "\n",
        "248": "  public void testStringSplitWithLongTrailingDelimiter() {\n",
        "249": "    String longDelimiter = \"a, b, c, \";\n",
        "250": "    Iterable<String> letters = Splitter.on(\", \").split(longDelimiter);\n",
        "251": "    assertThat(letters).containsExactly(\"a\", \"b\", \"c\", \"\").inOrder();\n",
        "252": "  }\n",
        "253": "\n",
        "254": "  public void testStringSplitWithDelimiterSubstringInValue() {\n",
        "255": "    String fourCommasAndFourSpaces = \",,,,    \";\n",
        "256": "    Iterable<String> threeCommasThenThreeSpaces = Splitter.on(\", \").split(\n",
        "257": "        fourCommasAndFourSpaces);\n",
        "258": "    assertThat(threeCommasThenThreeSpaces).containsExactly(\",,,\", \"   \").inOrder();\n",
        "259": "  }\n",
        "260": "\n",
        "261": "  @SuppressWarnings(\"CheckReturnValue\")\n",
        "262": "  public void testStringSplitWithEmptyString() {\n",
        "263": "    try {\n",
        "264": "      Splitter.on(\"\");\n",
        "265": "      fail();\n",
        "266": "    } catch (IllegalArgumentException expected) {\n",
        "267": "    }\n",
        "268": "  }\n",
        "269": "\n",
        "270": "  public void testStringSplitOnEmptyString() {\n",
        "271": "    Iterable<String> notMuch = Splitter.on('.').split(\"\");\n",
        "272": "    assertThat(notMuch).containsExactly(\"\").inOrder();\n",
        "273": "  }\n",
        "274": "\n",
        "275": "  public void testStringSplitOnEmptyStringOmitEmptyString() {\n",
        "276": "    assertThat(Splitter.on('.').omitEmptyStrings().split(\"\")).isEmpty();\n",
        "277": "  }\n",
        "278": "\n",
        "279": "  public void testStringSplitOnOnlyDelimiter() {\n",
        "280": "    Iterable<String> blankblank = Splitter.on('.').split(\".\");\n",
        "281": "    assertThat(blankblank).containsExactly(\"\", \"\").inOrder();\n",
        "282": "  }\n",
        "283": "\n",
        "284": "  public void testStringSplitOnOnlyDelimitersOmitEmptyStrings() {\n",
        "285": "    Iterable<String> empty = Splitter.on('.').omitEmptyStrings().split(\"...\");\n",
        "286": "    assertThat(empty).isEmpty();\n",
        "287": "  }\n",
        "288": "\n",
        "289": "  public void testStringSplitWithTrim() {\n",
        "290": "    String jacksons = \"arfo(Marlon)aorf, (Michael)orfa, afro(Jackie)orfa, \"\n",
        "291": "        + \"ofar(Jemaine), aff(Tito)\";\n",
        "292": "    Iterable<String> family = Splitter.on(',')\n",
        "293": "        .trimResults(CharMatcher.anyOf(\"afro\").or(CharMatcher.WHITESPACE))\n",
        "294": "        .split(jacksons);\n",
        "295": "    assertThat(family)\n",
        "296": "        .containsExactly(\"(Marlon)\", \"(Michael)\", \"(Jackie)\", \"(Jemaine)\", \"(Tito)\")\n",
        "297": "        .inOrder();\n",
        "298": "  }\n",
        "299": "\n",
        "300": "  // TODO(kevinb): the name of this method suggests it might not actually be testing what it\n",
        "301": "  // intends to be testing?\n",
        "302": "\n",
        "303": "  public void testSplitterIterableIsUnmodifiable_char() {\n",
        "304": "    assertIteratorIsUnmodifiable(COMMA_SPLITTER.split(\"a,b\").iterator());\n",
        "305": "  }\n",
        "306": "\n",
        "307": "  public void testSplitterIterableIsUnmodifiable_string() {\n",
        "308": "    assertIteratorIsUnmodifiable(Splitter.on(',').split(\"a,b\").iterator());\n",
        "309": "  }\n",
        "310": "\n",
        "311": "  private void assertIteratorIsUnmodifiable(Iterator<?> iterator) {\n",
        "312": "    iterator.next();\n",
        "313": "    try {\n",
        "314": "      iterator.remove();\n",
        "315": "      fail();\n",
        "316": "    } catch (UnsupportedOperationException expected) {\n",
        "317": "    }\n",
        "318": "  }\n",
        "319": "\n",
        "320": "  public void testSplitterIterableIsLazy_char() {\n",
        "321": "    assertSplitterIterableIsLazy(COMMA_SPLITTER);\n",
        "322": "  }\n",
        "323": "\n",
        "324": "  public void testSplitterIterableIsLazy_string() {\n",
        "325": "    assertSplitterIterableIsLazy(Splitter.on(','));\n",
        "326": "  }\n",
        "327": "\n",
        "328": "  /**\n",
        "329": "   * This test really pushes the boundaries of what we support. In general the\n",
        "330": "   * splitter's behaviour is not well defined if the char sequence it's\n",
        "331": "   * splitting is mutated during iteration.\n",
        "332": "   */\n",
        "333": "  private void assertSplitterIterableIsLazy(Splitter splitter) {\n",
        "334": "    StringBuilder builder = new StringBuilder();\n",
        "335": "    Iterator<String> iterator = splitter.split(builder).iterator();\n",
        "336": "\n",
        "337": "    builder.append(\"A,\");\n",
        "338": "    assertEquals(\"A\", iterator.next());\n",
        "339": "    builder.append(\"B,\");\n",
        "340": "    assertEquals(\"B\", iterator.next());\n",
        "341": "    builder.append(\"C\");\n",
        "342": "    assertEquals(\"C\", iterator.next());\n",
        "343": "    assertFalse(iterator.hasNext());\n",
        "344": "  }\n",
        "345": "\n",
        "346": "  public void testFixedLengthSimpleSplit() {\n",
        "347": "    String simple = \"abcde\";\n",
        "348": "    Iterable<String> letters = Splitter.fixedLength(2).split(simple);\n",
        "349": "    assertThat(letters).containsExactly(\"ab\", \"cd\", \"e\").inOrder();\n",
        "350": "  }\n",
        "351": "\n",
        "352": "  public void testFixedLengthSplitEqualChunkLength() {\n",
        "353": "    String simple = \"abcdef\";\n",
        "354": "    Iterable<String> letters = Splitter.fixedLength(2).split(simple);\n",
        "355": "    assertThat(letters).containsExactly(\"ab\", \"cd\", \"ef\").inOrder();\n",
        "356": "  }\n",
        "357": "\n",
        "358": "  public void testFixedLengthSplitOnlyOneChunk() {\n",
        "359": "    String simple = \"abc\";\n",
        "360": "    Iterable<String> letters = Splitter.fixedLength(3).split(simple);\n",
        "361": "    assertThat(letters).containsExactly(\"abc\").inOrder();\n",
        "362": "  }\n",
        "363": "\n",
        "364": "  public void testFixedLengthSplitSmallerString() {\n",
        "365": "    String simple = \"ab\";\n",
        "366": "    Iterable<String> letters = Splitter.fixedLength(3).split(simple);\n",
        "367": "    assertThat(letters).containsExactly(\"ab\").inOrder();\n",
        "368": "  }\n",
        "369": "\n",
        "370": "  public void testFixedLengthSplitEmptyString() {\n",
        "371": "    String simple = \"\";\n",
        "372": "    Iterable<String> letters = Splitter.fixedLength(3).split(simple);\n",
        "373": "    assertThat(letters).containsExactly(\"\").inOrder();\n",
        "374": "  }\n",
        "375": "\n",
        "376": "  public void testFixedLengthSplitEmptyStringWithOmitEmptyStrings() {\n",
        "377": "    assertThat(Splitter.fixedLength(3).omitEmptyStrings().split(\"\")).isEmpty();\n",
        "378": "  }\n",
        "379": "\n",
        "380": "  public void testFixedLengthSplitIntoChars() {\n",
        "381": "    String simple = \"abcd\";\n",
        "382": "    Iterable<String> letters = Splitter.fixedLength(1).split(simple);\n",
        "383": "    assertThat(letters).containsExactly(\"a\", \"b\", \"c\", \"d\").inOrder();\n",
        "384": "  }\n",
        "385": "\n",
        "386": "  @SuppressWarnings(\"CheckReturnValue\")\n",
        "387": "  public void testFixedLengthSplitZeroChunkLen() {\n",
        "388": "    try {\n",
        "389": "      Splitter.fixedLength(0);\n",
        "390": "      fail();\n",
        "391": "    } catch (IllegalArgumentException expected) {\n",
        "392": "    }\n",
        "393": "  }\n",
        "394": "\n",
        "395": "  @SuppressWarnings(\"CheckReturnValue\")\n",
        "396": "  public void testFixedLengthSplitNegativeChunkLen() {\n",
        "397": "    try {\n",
        "398": "      Splitter.fixedLength(-1);\n",
        "399": "      fail();\n",
        "400": "    } catch (IllegalArgumentException expected) {\n",
        "401": "    }\n",
        "402": "  }\n",
        "403": "\n",
        "404": "  public void testLimitLarge() {\n",
        "405": "    String simple = \"abcd\";\n",
        "406": "    Iterable<String> letters = Splitter.fixedLength(1).limit(100).split(simple);\n",
        "407": "    assertThat(letters).containsExactly(\"a\", \"b\", \"c\", \"d\").inOrder();\n",
        "408": "  }\n",
        "409": "\n",
        "410": "  public void testLimitOne() {\n",
        "411": "    String simple = \"abcd\";\n",
        "412": "    Iterable<String> letters = Splitter.fixedLength(1).limit(1).split(simple);\n",
        "413": "    assertThat(letters).containsExactly(\"abcd\").inOrder();\n",
        "414": "  }\n",
        "415": "\n",
        "416": "  public void testLimitFixedLength() {\n",
        "417": "    String simple = \"abcd\";\n",
        "418": "    Iterable<String> letters = Splitter.fixedLength(1).limit(2).split(simple);\n",
        "419": "    assertThat(letters).containsExactly(\"a\", \"bcd\").inOrder();\n",
        "420": "  }\n",
        "421": "\n",
        "422": "  public void testLimitSeparator() {\n",
        "423": "    String simple = \"a,b,c,d\";\n",
        "424": "    Iterable<String> items = COMMA_SPLITTER.limit(2).split(simple);\n",
        "425": "    assertThat(items).containsExactly(\"a\", \"b,c,d\").inOrder();\n",
        "426": "  }\n",
        "427": "\n",
        "428": "  public void testLimitExtraSeparators() {\n",
        "429": "    String text = \"a,,,b,,c,d\";\n",
        "430": "    Iterable<String> items = COMMA_SPLITTER.limit(2).split(text);\n",
        "431": "    assertThat(items).containsExactly(\"a\", \",,b,,c,d\").inOrder();\n",
        "432": "  }\n",
        "433": "\n",
        "434": "  public void testLimitExtraSeparatorsOmitEmpty() {\n",
        "435": "    String text = \"a,,,b,,c,d\";\n",
        "436": "    Iterable<String> items = COMMA_SPLITTER.limit(2).omitEmptyStrings().split(text);\n",
        "437": "    assertThat(items).containsExactly(\"a\", \"b,,c,d\").inOrder();\n",
        "438": "  }\n",
        "439": "\n",
        "440": "  public void testLimitExtraSeparatorsOmitEmpty3() {\n",
        "441": "    String text = \"a,,,b,,c,d\";\n",
        "442": "    Iterable<String> items = COMMA_SPLITTER.limit(3).omitEmptyStrings().split(text);\n",
        "443": "    assertThat(items).containsExactly(\"a\", \"b\", \"c,d\").inOrder();\n",
        "444": "  }\n",
        "445": "\n",
        "446": "  public void testLimitExtraSeparatorsTrim() {\n",
        "447": "    String text = \",,a,,  , b ,, c,d \";\n",
        "448": "    Iterable<String> items = COMMA_SPLITTER.limit(2).omitEmptyStrings().trimResults().split(text);\n",
        "449": "    assertThat(items).containsExactly(\"a\", \"b ,, c,d\").inOrder();\n",
        "450": "  }\n",
        "451": "\n",
        "452": "  public void testLimitExtraSeparatorsTrim3() {\n",
        "453": "    String text = \",,a,,  , b ,, c,d \";\n",
        "454": "    Iterable<String> items = COMMA_SPLITTER.limit(3).omitEmptyStrings().trimResults().split(text);\n",
        "455": "    assertThat(items).containsExactly(\"a\", \"b\", \"c,d\").inOrder();\n",
        "456": "  }\n",
        "457": "\n",
        "458": "  public void testLimitExtraSeparatorsTrim1() {\n",
        "459": "    String text = \",,a,,  , b ,, c,d \";\n",
        "460": "    Iterable<String> items = COMMA_SPLITTER.limit(1).omitEmptyStrings().trimResults().split(text);\n",
        "461": "    assertThat(items).containsExactly(\"a,,  , b ,, c,d\").inOrder();\n",
        "462": "  }\n",
        "463": "\n",
        "464": "  public void testLimitExtraSeparatorsTrim1NoOmit() {\n",
        "465": "    String text = \",,a,,  , b ,, c,d \";\n",
        "466": "    Iterable<String> items = COMMA_SPLITTER.limit(1).trimResults().split(text);\n",
        "467": "    assertThat(items).containsExactly(\",,a,,  , b ,, c,d\").inOrder();\n",
        "468": "  }\n",
        "469": "\n",
        "470": "  public void testLimitExtraSeparatorsTrim1Empty() {\n",
        "471": "    String text = \"\";\n",
        "472": "    Iterable<String> items = COMMA_SPLITTER.limit(1).split(text);\n",
        "473": "    assertThat(items).containsExactly(\"\").inOrder();\n",
        "474": "  }\n",
        "475": "\n",
        "476": "  public void testLimitExtraSeparatorsTrim1EmptyOmit() {\n",
        "477": "    String text = \"\";\n",
        "478": "    Iterable<String> items = COMMA_SPLITTER.omitEmptyStrings().limit(1).split(text);\n",
        "479": "    assertThat(items).isEmpty();\n",
        "480": "  }\n",
        "481": "\n",
        "482": "  @SuppressWarnings(\"ReturnValueIgnored\") // testing for exception\n",
        "483": "  public void testInvalidZeroLimit() {\n",
        "484": "    try {\n",
        "485": "      COMMA_SPLITTER.limit(0);\n",
        "486": "      fail();\n",
        "487": "    } catch (IllegalArgumentException expected) {\n",
        "488": "    }\n",
        "489": "  }\n",
        "490": "\n",
        "491": "  public void testMapSplitter_trimmedBoth() {\n",
        "492": "    Map<String, String> m = COMMA_SPLITTER\n",
        "493": "        .trimResults()\n",
        "494": "        .withKeyValueSeparator(Splitter.on(':').trimResults())\n",
        "495": "        .split(\"boy  : tom , girl: tina , cat  : kitty , dog: tommy \");\n",
        "496": "    ImmutableMap<String, String> expected =\n",
        "497": "        ImmutableMap.of(\"boy\", \"tom\", \"girl\", \"tina\", \"cat\", \"kitty\", \"dog\", \"tommy\");\n",
        "498": "    assertThat(m).isEqualTo(expected);\n",
        "499": "    assertThat(m.entrySet()).containsExactlyElementsIn(expected.entrySet()).inOrder();\n",
        "500": "  }\n",
        "501": "\n",
        "502": "  public void testMapSplitter_trimmedEntries() {\n",
        "503": "    Map<String, String> m = COMMA_SPLITTER\n",
        "504": "        .trimResults()\n",
        "505": "        .withKeyValueSeparator(\":\")\n",
        "506": "        .split(\"boy  : tom , girl: tina , cat  : kitty , dog: tommy \");\n",
        "507": "    ImmutableMap<String, String> expected =\n",
        "508": "        ImmutableMap.of(\"boy  \", \" tom\", \"girl\", \" tina\", \"cat  \", \" kitty\", \"dog\", \" tommy\");\n",
        "509": "\n",
        "510": "    assertThat(m).isEqualTo(expected);\n",
        "511": "    assertThat(m.entrySet()).containsExactlyElementsIn(expected.entrySet()).inOrder();\n",
        "512": "  }\n",
        "513": "\n",
        "514": "  public void testMapSplitter_trimmedKeyValue() {\n",
        "515": "    Map<String, String> m =\n",
        "516": "        COMMA_SPLITTER.withKeyValueSeparator(Splitter.on(':').trimResults()).split(\n",
        "517": "            \"boy  : tom , girl: tina , cat  : kitty , dog: tommy \");\n",
        "518": "    ImmutableMap<String, String> expected =\n",
        "519": "        ImmutableMap.of(\"boy\", \"tom\", \"girl\", \"tina\", \"cat\", \"kitty\", \"dog\", \"tommy\");\n",
        "520": "    assertThat(m).isEqualTo(expected);\n",
        "521": "    assertThat(m.entrySet()).containsExactlyElementsIn(expected.entrySet()).inOrder();\n",
        "522": "  }\n",
        "523": "\n",
        "524": "  public void testMapSplitter_notTrimmed() {\n",
        "525": "    Map<String, String> m = COMMA_SPLITTER.withKeyValueSeparator(\":\").split(\n",
        "526": "        \" boy:tom , girl: tina , cat :kitty , dog:  tommy \");\n",
        "527": "    ImmutableMap<String, String> expected =\n",
        "528": "        ImmutableMap.of(\" boy\", \"tom \", \" girl\", \" tina \", \" cat \", \"kitty \", \" dog\", \"  tommy \");\n",
        "529": "    assertThat(m).isEqualTo(expected);\n",
        "530": "    assertThat(m.entrySet()).containsExactlyElementsIn(expected.entrySet()).inOrder();\n",
        "531": "  }\n",
        "532": "\n",
        "533": "  public void testMapSplitter_CharacterSeparator() {\n",
        "534": "    // try different delimiters.\n",
        "535": "    Map<String, String> m = Splitter\n",
        "536": "        .on(\",\")\n",
        "537": "        .withKeyValueSeparator(':')\n",
        "538": "        .split(\"boy:tom,girl:tina,cat:kitty,dog:tommy\");\n",
        "539": "    ImmutableMap<String, String> expected =\n",
        "540": "        ImmutableMap.of(\"boy\", \"tom\", \"girl\", \"tina\", \"cat\", \"kitty\", \"dog\", \"tommy\");\n",
        "541": "\n",
        "542": "    assertThat(m).isEqualTo(expected);\n",
        "543": "    assertThat(m.entrySet()).containsExactlyElementsIn(expected.entrySet()).inOrder();\n",
        "544": "  }\n",
        "545": "\n",
        "546": "  public void testMapSplitter_multiCharacterSeparator() {\n",
        "547": "    // try different delimiters.\n",
        "548": "    Map<String, String> m = Splitter\n",
        "549": "        .on(\",\")\n",
        "550": "        .withKeyValueSeparator(\":^&\")\n",
        "551": "        .split(\"boy:^&tom,girl:^&tina,cat:^&kitty,dog:^&tommy\");\n",
        "552": "    ImmutableMap<String, String> expected =\n",
        "553": "        ImmutableMap.of(\"boy\", \"tom\", \"girl\", \"tina\", \"cat\", \"kitty\", \"dog\", \"tommy\");\n",
        "554": "\n",
        "555": "    assertThat(m).isEqualTo(expected);\n",
        "556": "    assertThat(m.entrySet()).containsExactlyElementsIn(expected.entrySet()).inOrder();\n",
        "557": "  }\n",
        "558": "\n",
        "559": "  @SuppressWarnings(\"CheckReturnValue\")\n",
        "560": "  public void testMapSplitter_emptySeparator() {\n",
        "561": "    try {\n",
        "562": "      COMMA_SPLITTER.withKeyValueSeparator(\"\");\n",
        "563": "      fail();\n",
        "564": "    } catch (IllegalArgumentException expected) {\n",
        "565": "    }\n",
        "566": "  }\n",
        "567": "\n",
        "568": "  @SuppressWarnings(\"CheckReturnValue\")\n",
        "569": "  public void testMapSplitter_malformedEntry() {\n",
        "570": "    try {\n",
        "571": "      COMMA_SPLITTER.withKeyValueSeparator(\"=\").split(\"a=1,b,c=2\");\n",
        "572": "      fail();\n",
        "573": "    } catch (IllegalArgumentException expected) {\n",
        "574": "    }\n",
        "575": "  }\n",
        "576": "\n",
        "577": "  public void testMapSplitter_orderedResults() {\n",
        "578": "    Map<String, String> m = Splitter.on(',')\n",
        "579": "        .withKeyValueSeparator(\":\")\n",
        "580": "        .split(\"boy:tom,girl:tina,cat:kitty,dog:tommy\");\n",
        "581": "\n",
        "582": "    assertThat(m.keySet()).containsExactly(\"boy\", \"girl\", \"cat\", \"dog\").inOrder();\n",
        "583": "    assertThat(m).isEqualTo(\n",
        "584": "        ImmutableMap.of(\"boy\", \"tom\", \"girl\", \"tina\", \"cat\", \"kitty\", \"dog\", \"tommy\"));\n",
        "585": "\n",
        "586": "    // try in a different order\n",
        "587": "    m = Splitter.on(',')\n",
        "588": "        .withKeyValueSeparator(\":\")\n",
        "589": "        .split(\"girl:tina,boy:tom,dog:tommy,cat:kitty\");\n",
        "590": "\n",
        "591": "    assertThat(m.keySet()).containsExactly(\"girl\", \"boy\", \"dog\", \"cat\").inOrder();\n",
        "592": "    assertThat(m).isEqualTo(\n",
        "593": "        ImmutableMap.of(\"boy\", \"tom\", \"girl\", \"tina\", \"cat\", \"kitty\", \"dog\", \"tommy\"));\n",
        "594": "  }\n",
        "595": "\n",
        "596": "  @SuppressWarnings(\"CheckReturnValue\")\n",
        "597": "  public void testMapSplitter_duplicateKeys() {\n",
        "598": "    try {\n",
        "599": "      Splitter.on(',').withKeyValueSeparator(\":\").split(\"a:1,b:2,a:3\");\n",
        "600": "      fail();\n",
        "601": "    } catch (IllegalArgumentException expected) {\n",
        "602": "    }\n",
        "603": "  }\n",
        "604": "}\n"
    }
}