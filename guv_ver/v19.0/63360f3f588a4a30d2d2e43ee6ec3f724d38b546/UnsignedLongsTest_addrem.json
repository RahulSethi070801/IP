{
    "addition": {},
    "removed": {
        "1": "/*\n",
        "2": " * Copyright (C) 2011 The Guava Authors\n",
        "3": " *\n",
        "4": " * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not use this file except\n",
        "5": " * in compliance with the License. You may obtain a copy of the License at\n",
        "6": " *\n",
        "7": " * http://www.apache.org/licenses/LICENSE-2.0\n",
        "8": " *\n",
        "9": " * Unless required by applicable law or agreed to in writing, software distributed under the\n",
        "10": " * License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either\n",
        "11": " * express or implied. See the License for the specific language governing permissions and\n",
        "12": " * limitations under the License.\n",
        "13": " */\n",
        "14": "\n",
        "15": "package com.google.common.primitives;\n",
        "16": "\n",
        "17": "import static java.math.BigInteger.ONE;\n",
        "18": "\n",
        "19": "import com.google.common.annotations.GwtCompatible;\n",
        "20": "import com.google.common.collect.testing.Helpers;\n",
        "21": "\n",
        "22": "import junit.framework.TestCase;\n",
        "23": "\n",
        "24": "import java.math.BigInteger;\n",
        "25": "import java.util.Arrays;\n",
        "26": "import java.util.Comparator;\n",
        "27": "import java.util.List;\n",
        "28": "\n",
        "29": "/**\n",
        "30": " * Tests for UnsignedLongs\n",
        "31": " *\n",
        "32": " * @author Brian Milch\n",
        "33": " * @author Louis Wasserman\n",
        "34": " */\n",
        "35": "@GwtCompatible(emulated = true)\n",
        "36": "public class UnsignedLongsTest extends TestCase {\n",
        "37": "  private static final long LEAST = 0L;\n",
        "38": "  private static final long GREATEST = 0xffffffffffffffffL;\n",
        "39": "  \n",
        "40": "  public void testCompare() {\n",
        "41": "    // max value\n",
        "42": "    assertTrue(UnsignedLongs.compare(0, 0xffffffffffffffffL) < 0);\n",
        "43": "    assertTrue(UnsignedLongs.compare(0xffffffffffffffffL, 0) > 0);\n",
        "44": "\n",
        "45": "    // both with high bit set\n",
        "46": "    assertTrue(UnsignedLongs.compare(0xff1a618b7f65ea12L, 0xffffffffffffffffL) < 0);\n",
        "47": "    assertTrue(UnsignedLongs.compare(0xffffffffffffffffL, 0xff1a618b7f65ea12L) > 0);\n",
        "48": "\n",
        "49": "    // one with high bit set\n",
        "50": "    assertTrue(UnsignedLongs.compare(0x5a4316b8c153ac4dL, 0xff1a618b7f65ea12L) < 0);\n",
        "51": "    assertTrue(UnsignedLongs.compare(0xff1a618b7f65ea12L, 0x5a4316b8c153ac4dL) > 0);\n",
        "52": "\n",
        "53": "    // neither with high bit set\n",
        "54": "    assertTrue(UnsignedLongs.compare(0x5a4316b8c153ac4dL, 0x6cf78a4b139a4e2aL) < 0);\n",
        "55": "    assertTrue(UnsignedLongs.compare(0x6cf78a4b139a4e2aL, 0x5a4316b8c153ac4dL) > 0);\n",
        "56": "\n",
        "57": "    // same value\n",
        "58": "    assertTrue(UnsignedLongs.compare(0xff1a618b7f65ea12L, 0xff1a618b7f65ea12L) == 0);\n",
        "59": "  }\n",
        "60": "\n",
        "61": "  @SuppressWarnings(\"CheckReturnValue\")\n",
        "62": "  public void testMax_noArgs() {\n",
        "63": "    try {\n",
        "64": "      UnsignedLongs.max();\n",
        "65": "      fail();\n",
        "66": "    } catch (IllegalArgumentException expected) {\n",
        "67": "    }\n",
        "68": "  }\n",
        "69": "  \n",
        "70": "  public void testMax() {\n",
        "71": "    assertEquals(LEAST, UnsignedLongs.max(LEAST));\n",
        "72": "    assertEquals(GREATEST, UnsignedLongs.max(GREATEST));\n",
        "73": "    assertEquals(0xff1a618b7f65ea12L, UnsignedLongs.max(\n",
        "74": "        0x5a4316b8c153ac4dL, 8L, 100L,\n",
        "75": "        0L, 0x6cf78a4b139a4e2aL, 0xff1a618b7f65ea12L));\n",
        "76": "  }\n",
        "77": "\n",
        "78": "  @SuppressWarnings(\"CheckReturnValue\")\n",
        "79": "  public void testMin_noArgs() {\n",
        "80": "    try {\n",
        "81": "      UnsignedLongs.min();\n",
        "82": "      fail();\n",
        "83": "    } catch (IllegalArgumentException expected) {\n",
        "84": "    }\n",
        "85": "  }\n",
        "86": "  \n",
        "87": "  public void testMin() {\n",
        "88": "    assertEquals(LEAST, UnsignedLongs.min(LEAST));\n",
        "89": "    assertEquals(GREATEST, UnsignedLongs.min(GREATEST));\n",
        "90": "    assertEquals(0L, UnsignedLongs.min(\n",
        "91": "        0x5a4316b8c153ac4dL, 8L, 100L,\n",
        "92": "        0L, 0x6cf78a4b139a4e2aL, 0xff1a618b7f65ea12L));\n",
        "93": "  }\n",
        "94": "  \n",
        "95": "  public void testLexicographicalComparator() {\n",
        "96": "    List<long[]> ordered = Arrays.asList(\n",
        "97": "        new long[] {},\n",
        "98": "        new long[] {LEAST},\n",
        "99": "        new long[] {LEAST, LEAST},\n",
        "100": "        new long[] {LEAST, (long) 1},\n",
        "101": "        new long[] {(long) 1},\n",
        "102": "        new long[] {(long) 1, LEAST},\n",
        "103": "        new long[] {GREATEST, GREATEST - (long) 1},\n",
        "104": "        new long[] {GREATEST, GREATEST},\n",
        "105": "        new long[] {GREATEST, GREATEST, GREATEST});\n",
        "106": "    \n",
        "107": "    Comparator<long[]> comparator = UnsignedLongs.lexicographicalComparator();\n",
        "108": "    Helpers.testComparator(comparator, ordered);\n",
        "109": "  }\n",
        "110": "\n",
        "111": "  public void testDivide() {\n",
        "112": "    assertEquals(2, UnsignedLongs.divide(14, 5));\n",
        "113": "    assertEquals(0, UnsignedLongs.divide(0, 50));\n",
        "114": "    assertEquals(1, UnsignedLongs.divide(0xfffffffffffffffeL, 0xfffffffffffffffdL));\n",
        "115": "    assertEquals(0, UnsignedLongs.divide(0xfffffffffffffffdL, 0xfffffffffffffffeL));\n",
        "116": "    assertEquals(281479271743488L, UnsignedLongs.divide(0xfffffffffffffffeL, 65535));\n",
        "117": "    assertEquals(0x7fffffffffffffffL, UnsignedLongs.divide(0xfffffffffffffffeL, 2));\n",
        "118": "    assertEquals(3689348814741910322L, UnsignedLongs.divide(0xfffffffffffffffeL, 5));\n",
        "119": "  }\n",
        "120": "\n",
        "121": "  public void testRemainder() {\n",
        "122": "    assertEquals(4, UnsignedLongs.remainder(14, 5));\n",
        "123": "    assertEquals(0, UnsignedLongs.remainder(0, 50));\n",
        "124": "    assertEquals(1, UnsignedLongs.remainder(0xfffffffffffffffeL, 0xfffffffffffffffdL));\n",
        "125": "    assertEquals(0xfffffffffffffffdL,\n",
        "126": "        UnsignedLongs.remainder(0xfffffffffffffffdL, 0xfffffffffffffffeL));\n",
        "127": "    assertEquals(65534L, UnsignedLongs.remainder(0xfffffffffffffffeL, 65535));\n",
        "128": "    assertEquals(0, UnsignedLongs.remainder(0xfffffffffffffffeL, 2));\n",
        "129": "    assertEquals(4, UnsignedLongs.remainder(0xfffffffffffffffeL, 5));\n",
        "130": "  }\n",
        "131": "\n",
        "132": "  public void testParseLong() {\n",
        "133": "    assertEquals(0xffffffffffffffffL, UnsignedLongs.parseUnsignedLong(\"18446744073709551615\"));\n",
        "134": "    assertEquals(0x7fffffffffffffffL, UnsignedLongs.parseUnsignedLong(\"9223372036854775807\"));\n",
        "135": "    assertEquals(0xff1a618b7f65ea12L, UnsignedLongs.parseUnsignedLong(\"18382112080831834642\"));\n",
        "136": "    assertEquals(0x5a4316b8c153ac4dL, UnsignedLongs.parseUnsignedLong(\"6504067269626408013\"));\n",
        "137": "    assertEquals(0x6cf78a4b139a4e2aL, UnsignedLongs.parseUnsignedLong(\"7851896530399809066\"));\n",
        "138": "  }\n",
        "139": "\n",
        "140": "  @SuppressWarnings(\"CheckReturnValue\")\n",
        "141": "  public void testParseLongFails() {\n",
        "142": "    try {\n",
        "143": "      // One more than maximum value\n",
        "144": "      UnsignedLongs.parseUnsignedLong(\"18446744073709551616\");\n",
        "145": "      fail();\n",
        "146": "    } catch (NumberFormatException expected) {\n",
        "147": "    }\n",
        "148": "  }\n",
        "149": "\n",
        "150": "  public void testDecodeLong() {\n",
        "151": "    assertEquals(0xffffffffffffffffL, UnsignedLongs.decode(\"0xffffffffffffffff\"));\n",
        "152": "    assertEquals(01234567, UnsignedLongs.decode(\"01234567\")); // octal\n",
        "153": "    assertEquals(0x1234567890abcdefL, UnsignedLongs.decode(\"#1234567890abcdef\"));\n",
        "154": "    assertEquals(987654321012345678L, UnsignedLongs.decode(\"987654321012345678\"));\n",
        "155": "    assertEquals(0x135791357913579L, UnsignedLongs.decode(\"0x135791357913579\"));\n",
        "156": "    assertEquals(0x135791357913579L, UnsignedLongs.decode(\"0X135791357913579\"));\n",
        "157": "    assertEquals(0L, UnsignedLongs.decode(\"0\"));\n",
        "158": "  }\n",
        "159": "\n",
        "160": "  @SuppressWarnings(\"CheckReturnValue\")\n",
        "161": "  public void testDecodeLongFails() {\n",
        "162": "    try {\n",
        "163": "      // One more than maximum value\n",
        "164": "      UnsignedLongs.decode(\"0xfffffffffffffffff\");\n",
        "165": "      fail();\n",
        "166": "    } catch (NumberFormatException expected) {\n",
        "167": "    }\n",
        "168": "\n",
        "169": "    try {\n",
        "170": "      UnsignedLongs.decode(\"-5\");\n",
        "171": "      fail();\n",
        "172": "    } catch (NumberFormatException expected) {\n",
        "173": "    }\n",
        "174": "\n",
        "175": "    try {\n",
        "176": "      UnsignedLongs.decode(\"-0x5\");\n",
        "177": "      fail();\n",
        "178": "    } catch (NumberFormatException expected) {\n",
        "179": "    }\n",
        "180": "\n",
        "181": "    try {\n",
        "182": "      UnsignedLongs.decode(\"-05\");\n",
        "183": "      fail();\n",
        "184": "    } catch (NumberFormatException expected) {\n",
        "185": "    }\n",
        "186": "  }\n",
        "187": "\n",
        "188": "  public void testParseLongWithRadix() {\n",
        "189": "    assertEquals(0xffffffffffffffffL, UnsignedLongs.parseUnsignedLong(\"ffffffffffffffff\", 16));\n",
        "190": "    assertEquals(0x1234567890abcdefL, UnsignedLongs.parseUnsignedLong(\"1234567890abcdef\", 16));\n",
        "191": "  }\n",
        "192": "\n",
        "193": "  @SuppressWarnings(\"CheckReturnValue\")\n",
        "194": "  public void testParseLongWithRadixLimits() {\n",
        "195": "    BigInteger max = BigInteger.ZERO.setBit(64).subtract(ONE);\n",
        "196": "    // loops through all legal radix values.\n",
        "197": "    for (int radix = Character.MIN_RADIX; radix <= Character.MAX_RADIX; radix++) {\n",
        "198": "      // tests can successfully parse a number string with this radix.\n",
        "199": "      String maxAsString = max.toString(radix);\n",
        "200": "      assertEquals(max.longValue(), UnsignedLongs.parseUnsignedLong(maxAsString, radix));\n",
        "201": "\n",
        "202": "      try {\n",
        "203": "        // tests that we get exception whre an overflow would occur.\n",
        "204": "        BigInteger overflow = max.add(ONE);\n",
        "205": "        String overflowAsString = overflow.toString(radix);\n",
        "206": "        UnsignedLongs.parseUnsignedLong(overflowAsString, radix);\n",
        "207": "        fail();\n",
        "208": "      } catch (NumberFormatException expected) {\n",
        "209": "      }\n",
        "210": "    }\n",
        "211": "\n",
        "212": "    try {\n",
        "213": "      UnsignedLongs.parseUnsignedLong(\"1234567890abcdef1\", 16);\n",
        "214": "      fail();\n",
        "215": "    } catch (NumberFormatException expected) {\n",
        "216": "    }\n",
        "217": "  }\n",
        "218": "\n",
        "219": "  @SuppressWarnings(\"CheckReturnValue\")\n",
        "220": "  public void testParseLongThrowsExceptionForInvalidRadix() {\n",
        "221": "    // Valid radix values are Character.MIN_RADIX to Character.MAX_RADIX, inclusive.\n",
        "222": "    try {\n",
        "223": "      UnsignedLongs.parseUnsignedLong(\"0\", Character.MIN_RADIX - 1);\n",
        "224": "      fail();\n",
        "225": "    } catch (NumberFormatException expected) {\n",
        "226": "    }\n",
        "227": "\n",
        "228": "    try {\n",
        "229": "      UnsignedLongs.parseUnsignedLong(\"0\", Character.MAX_RADIX + 1);\n",
        "230": "      fail();\n",
        "231": "    } catch (NumberFormatException expected) {\n",
        "232": "    }\n",
        "233": "\n",
        "234": "    // The radix is used as an array index, so try a negative value.\n",
        "235": "    try {\n",
        "236": "      UnsignedLongs.parseUnsignedLong(\"0\", -1);\n",
        "237": "      fail();\n",
        "238": "    } catch (NumberFormatException expected) {\n",
        "239": "    }\n",
        "240": "  }\n",
        "241": "\n",
        "242": "  public void testToString() {\n",
        "243": "    String[] tests = {\n",
        "244": "        \"ffffffffffffffff\",\n",
        "245": "        \"7fffffffffffffff\",\n",
        "246": "        \"ff1a618b7f65ea12\",\n",
        "247": "        \"5a4316b8c153ac4d\",\n",
        "248": "        \"6cf78a4b139a4e2a\"\n",
        "249": "    };\n",
        "250": "    int[] bases = { 2, 5, 7, 8, 10, 16 };\n",
        "251": "    for (int base : bases) {\n",
        "252": "      for (String x : tests) {\n",
        "253": "        BigInteger xValue = new BigInteger(x, 16);\n",
        "254": "        long xLong = xValue.longValue(); // signed\n",
        "255": "        assertEquals(xValue.toString(base), UnsignedLongs.toString(xLong, base));\n",
        "256": "      }\n",
        "257": "    }\n",
        "258": "  }\n",
        "259": "\n",
        "260": "  public void testJoin() {\n",
        "261": "    assertEquals(\"\", UnsignedLongs.join(\",\"));\n",
        "262": "    assertEquals(\"1\", UnsignedLongs.join(\",\", 1));\n",
        "263": "    assertEquals(\"1,2\", UnsignedLongs.join(\",\", 1, 2));\n",
        "264": "    assertEquals(\"18446744073709551615,9223372036854775808\",\n",
        "265": "        UnsignedLongs.join(\",\", -1, Long.MIN_VALUE));\n",
        "266": "    assertEquals(\"123\", UnsignedLongs.join(\"\", 1, 2, 3));\n",
        "267": "    assertEquals(\"184467440737095516159223372036854775808\",\n",
        "268": "        UnsignedLongs.join(\"\", -1, Long.MIN_VALUE));\n",
        "269": "  }\n",
        "270": "}\n",
        "271": "\n"
    }
}