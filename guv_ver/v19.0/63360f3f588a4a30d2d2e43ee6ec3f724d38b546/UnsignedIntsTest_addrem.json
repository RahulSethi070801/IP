{
    "addition": {},
    "removed": {
        "1": "/*\n",
        "2": " * Copyright (C) 2011 The Guava Authors\n",
        "3": " *\n",
        "4": " * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not use this file except\n",
        "5": " * in compliance with the License. You may obtain a copy of the License at\n",
        "6": " *\n",
        "7": " * http://www.apache.org/licenses/LICENSE-2.0\n",
        "8": " *\n",
        "9": " * Unless required by applicable law or agreed to in writing, software distributed under the\n",
        "10": " * License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either\n",
        "11": " * express or implied. See the License for the specific language governing permissions and\n",
        "12": " * limitations under the License.\n",
        "13": " */\n",
        "14": "\n",
        "15": "package com.google.common.primitives;\n",
        "16": "\n",
        "17": "import com.google.common.annotations.GwtCompatible;\n",
        "18": "import com.google.common.collect.testing.Helpers;\n",
        "19": "\n",
        "20": "import junit.framework.TestCase;\n",
        "21": "\n",
        "22": "import java.util.Arrays;\n",
        "23": "import java.util.Comparator;\n",
        "24": "import java.util.List;\n",
        "25": "\n",
        "26": "/**\n",
        "27": " * Tests for UnsignedInts\n",
        "28": " *\n",
        "29": " * @author Louis Wasserman\n",
        "30": " */\n",
        "31": "@GwtCompatible(emulated = true)\n",
        "32": "public class UnsignedIntsTest extends TestCase {\n",
        "33": "  private static final long[] UNSIGNED_INTS = {\n",
        "34": "      0L,\n",
        "35": "      1L,\n",
        "36": "      2L,\n",
        "37": "      3L,\n",
        "38": "      0x12345678L,\n",
        "39": "      0x5a4316b8L,\n",
        "40": "      0x6cf78a4bL,\n",
        "41": "      0xff1a618bL,\n",
        "42": "      0xfffffffdL,\n",
        "43": "      0xfffffffeL,\n",
        "44": "      0xffffffffL};\n",
        "45": "\n",
        "46": "  private static final int LEAST = (int) 0L;\n",
        "47": "  private static final int GREATEST = (int) 0xffffffffL;\n",
        "48": "\n",
        "49": "  public void testToLong() {\n",
        "50": "    for (long a : UNSIGNED_INTS) {\n",
        "51": "      assertEquals(a, UnsignedInts.toLong((int) a));\n",
        "52": "    }\n",
        "53": "  }\n",
        "54": "\n",
        "55": "  public void testCompare() {\n",
        "56": "    for (long a : UNSIGNED_INTS) {\n",
        "57": "      for (long b : UNSIGNED_INTS) {\n",
        "58": "        int cmpAsLongs = Longs.compare(a, b);\n",
        "59": "        int cmpAsUInt = UnsignedInts.compare((int) a, (int) b);\n",
        "60": "        assertEquals(Integer.signum(cmpAsLongs), Integer.signum(cmpAsUInt));\n",
        "61": "      }\n",
        "62": "    }\n",
        "63": "  }\n",
        "64": "\n",
        "65": "  @SuppressWarnings(\"CheckReturnValue\")\n",
        "66": "  public void testMax_noArgs() {\n",
        "67": "    try {\n",
        "68": "      UnsignedInts.max();\n",
        "69": "      fail();\n",
        "70": "    } catch (IllegalArgumentException expected) {\n",
        "71": "    }\n",
        "72": "  }\n",
        "73": "\n",
        "74": "  public void testMax() {\n",
        "75": "    assertEquals(LEAST, UnsignedInts.max(LEAST));\n",
        "76": "    assertEquals(GREATEST, UnsignedInts.max(GREATEST));\n",
        "77": "    assertEquals((int) 0xff1a618bL, UnsignedInts.max(\n",
        "78": "        (int) 8L, (int) 6L, (int) 7L,\n",
        "79": "        (int) 0x12345678L, (int) 0x5a4316b8L,\n",
        "80": "        (int) 0xff1a618bL, (int) 0L));\n",
        "81": "  }\n",
        "82": "\n",
        "83": "  @SuppressWarnings(\"CheckReturnValue\")\n",
        "84": "  public void testMin_noArgs() {\n",
        "85": "    try {\n",
        "86": "      UnsignedInts.min();\n",
        "87": "      fail();\n",
        "88": "    } catch (IllegalArgumentException expected) {\n",
        "89": "    }\n",
        "90": "  }\n",
        "91": "  \n",
        "92": "  public void testMin() {\n",
        "93": "    assertEquals(LEAST, UnsignedInts.min(LEAST));\n",
        "94": "    assertEquals(GREATEST, UnsignedInts.min(GREATEST));\n",
        "95": "    assertEquals((int) 0L, UnsignedInts.min(\n",
        "96": "        (int) 8L, (int) 6L, (int) 7L,\n",
        "97": "        (int) 0x12345678L, (int) 0x5a4316b8L,\n",
        "98": "        (int) 0xff1a618bL, (int) 0L));\n",
        "99": "  }\n",
        "100": "  \n",
        "101": "  public void testLexicographicalComparator() {\n",
        "102": "    List<int[]> ordered = Arrays.asList(\n",
        "103": "        new int[] {},\n",
        "104": "        new int[] {LEAST},\n",
        "105": "        new int[] {LEAST, LEAST},\n",
        "106": "        new int[] {LEAST, (int) 1L},\n",
        "107": "        new int[] {(int) 1L},\n",
        "108": "        new int[] {(int) 1L, LEAST},\n",
        "109": "        new int[] {GREATEST, (GREATEST - (int) 1L)},\n",
        "110": "        new int[] {GREATEST, GREATEST},\n",
        "111": "        new int[] {GREATEST, GREATEST, GREATEST}\n",
        "112": "        );\n",
        "113": "\n",
        "114": "    Comparator<int[]> comparator = UnsignedInts.lexicographicalComparator();\n",
        "115": "    Helpers.testComparator(comparator, ordered);\n",
        "116": "  }\n",
        "117": "\n",
        "118": "  public void testDivide() {\n",
        "119": "    for (long a : UNSIGNED_INTS) {\n",
        "120": "      for (long b : UNSIGNED_INTS) {\n",
        "121": "        try {\n",
        "122": "          assertEquals((int) (a / b), UnsignedInts.divide((int) a, (int) b));\n",
        "123": "          assertFalse(b == 0);\n",
        "124": "        } catch (ArithmeticException e) {\n",
        "125": "          assertEquals(0, b);\n",
        "126": "        }\n",
        "127": "      }\n",
        "128": "    }\n",
        "129": "  }\n",
        "130": "\n",
        "131": "  public void testRemainder() {\n",
        "132": "    for (long a : UNSIGNED_INTS) {\n",
        "133": "      for (long b : UNSIGNED_INTS) {\n",
        "134": "        try {\n",
        "135": "          assertEquals((int) (a % b), UnsignedInts.remainder((int) a, (int) b));\n",
        "136": "          assertFalse(b == 0);\n",
        "137": "        } catch (ArithmeticException e) {\n",
        "138": "          assertEquals(0, b);\n",
        "139": "        }\n",
        "140": "      }\n",
        "141": "    }\n",
        "142": "  }\n",
        "143": "\n",
        "144": "  public void testParseInt() {\n",
        "145": "    for (long a : UNSIGNED_INTS) {\n",
        "146": "      assertEquals((int) a, UnsignedInts.parseUnsignedInt(Long.toString(a)));\n",
        "147": "    }\n",
        "148": "  }\n",
        "149": "\n",
        "150": "  @SuppressWarnings(\"CheckReturnValue\")\n",
        "151": "  public void testParseIntFail() {\n",
        "152": "    try {\n",
        "153": "      UnsignedInts.parseUnsignedInt(Long.toString(1L << 32));\n",
        "154": "      fail(\"Expected NumberFormatException\");\n",
        "155": "    } catch (NumberFormatException expected) {}\n",
        "156": "  }\n",
        "157": "\n",
        "158": "  public void testParseIntWithRadix() {\n",
        "159": "    for (long a : UNSIGNED_INTS) {\n",
        "160": "      for (int radix = Character.MIN_RADIX; radix <= Character.MAX_RADIX; radix++) {\n",
        "161": "        assertEquals((int) a, UnsignedInts.parseUnsignedInt(Long.toString(a, radix), radix));\n",
        "162": "      }\n",
        "163": "    }\n",
        "164": "  }\n",
        "165": "\n",
        "166": "  @SuppressWarnings(\"CheckReturnValue\")\n",
        "167": "  public void testParseIntWithRadixLimits() {\n",
        "168": "    // loops through all legal radix values.\n",
        "169": "    for (int radix = Character.MIN_RADIX; radix <= Character.MAX_RADIX; radix++) {\n",
        "170": "      // tests can successfully parse a number string with this radix.\n",
        "171": "      String maxAsString = Long.toString((1L << 32) - 1, radix);\n",
        "172": "      assertEquals(-1, UnsignedInts.parseUnsignedInt(maxAsString, radix));\n",
        "173": "\n",
        "174": "      try {\n",
        "175": "        // tests that we get exception whre an overflow would occur.\n",
        "176": "        long overflow = 1L << 32;\n",
        "177": "        String overflowAsString = Long.toString(overflow, radix);\n",
        "178": "        UnsignedInts.parseUnsignedInt(overflowAsString, radix);\n",
        "179": "        fail();\n",
        "180": "      } catch (NumberFormatException expected) {}\n",
        "181": "    }\n",
        "182": "  }\n",
        "183": "\n",
        "184": "  @SuppressWarnings(\"CheckReturnValue\")\n",
        "185": "  public void testParseIntThrowsExceptionForInvalidRadix() {\n",
        "186": "    // Valid radix values are Character.MIN_RADIX to Character.MAX_RADIX,\n",
        "187": "    // inclusive.\n",
        "188": "    try {\n",
        "189": "      UnsignedInts.parseUnsignedInt(\"0\", Character.MIN_RADIX - 1);\n",
        "190": "      fail();\n",
        "191": "    } catch (NumberFormatException expected) {}\n",
        "192": "\n",
        "193": "    try {\n",
        "194": "      UnsignedInts.parseUnsignedInt(\"0\", Character.MAX_RADIX + 1);\n",
        "195": "      fail();\n",
        "196": "    } catch (NumberFormatException expected) {}\n",
        "197": "\n",
        "198": "    // The radix is used as an array index, so try a negative value.\n",
        "199": "    try {\n",
        "200": "      UnsignedInts.parseUnsignedInt(\"0\", -1);\n",
        "201": "      fail();\n",
        "202": "    } catch (NumberFormatException expected) {}\n",
        "203": "  }\n",
        "204": "\n",
        "205": "  public void testDecodeInt() {\n",
        "206": "    assertEquals(0xffffffff, UnsignedInts.decode(\"0xffffffff\"));\n",
        "207": "    assertEquals(01234567, UnsignedInts.decode(\"01234567\")); // octal\n",
        "208": "    assertEquals(0x12345678, UnsignedInts.decode(\"#12345678\"));\n",
        "209": "    assertEquals(76543210, UnsignedInts.decode(\"76543210\"));\n",
        "210": "    assertEquals(0x13579135, UnsignedInts.decode(\"0x13579135\"));\n",
        "211": "    assertEquals(0x13579135, UnsignedInts.decode(\"0X13579135\"));\n",
        "212": "    assertEquals(0, UnsignedInts.decode(\"0\"));\n",
        "213": "  }\n",
        "214": "\n",
        "215": "  @SuppressWarnings(\"CheckReturnValue\")\n",
        "216": "  public void testDecodeIntFails() {\n",
        "217": "    try {\n",
        "218": "      // One more than maximum value\n",
        "219": "      UnsignedInts.decode(\"0xfffffffff\");\n",
        "220": "      fail();\n",
        "221": "    } catch (NumberFormatException expected) {\n",
        "222": "    }\n",
        "223": "\n",
        "224": "    try {\n",
        "225": "      UnsignedInts.decode(\"-5\");\n",
        "226": "      fail();\n",
        "227": "    } catch (NumberFormatException expected) {\n",
        "228": "    }\n",
        "229": "\n",
        "230": "    try {\n",
        "231": "      UnsignedInts.decode(\"-0x5\");\n",
        "232": "      fail();\n",
        "233": "    } catch (NumberFormatException expected) {\n",
        "234": "    }\n",
        "235": "\n",
        "236": "    try {\n",
        "237": "      UnsignedInts.decode(\"-05\");\n",
        "238": "      fail();\n",
        "239": "    } catch (NumberFormatException expected) {\n",
        "240": "    }\n",
        "241": "  }\n",
        "242": "\n",
        "243": "  public void testToString() {\n",
        "244": "    int[] bases = {2, 5, 7, 8, 10, 16};\n",
        "245": "    for (long a : UNSIGNED_INTS) {\n",
        "246": "      for (int base : bases) {\n",
        "247": "        assertEquals(UnsignedInts.toString((int) a, base), Long.toString(a, base));\n",
        "248": "      }\n",
        "249": "    }\n",
        "250": "  }\n",
        "251": "\n",
        "252": "  public void testJoin() {\n",
        "253": "    assertEquals(\"\", join());\n",
        "254": "    assertEquals(\"1\", join(1));\n",
        "255": "    assertEquals(\"1,2\", join(1, 2));\n",
        "256": "    assertEquals(\"4294967295,2147483648\", join(-1, Integer.MIN_VALUE));\n",
        "257": "\n",
        "258": "    assertEquals(\"123\", UnsignedInts.join(\"\", 1, 2, 3));\n",
        "259": "  }\n",
        "260": "\n",
        "261": "  private static String join(int... values) {\n",
        "262": "    return UnsignedInts.join(\",\", values);\n",
        "263": "  }\n",
        "264": "}\n",
        "265": "\n"
    }
}