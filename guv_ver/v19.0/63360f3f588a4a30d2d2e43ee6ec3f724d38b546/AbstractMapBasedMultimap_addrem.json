{
    "addition": {},
    "removed": {
        "1": "/*\n",
        "2": " * Copyright (C) 2007 The Guava Authors\n",
        "3": " *\n",
        "4": " * Licensed under the Apache License, Version 2.0 (the \"License\");\n",
        "5": " * you may not use this file except in compliance with the License.\n",
        "6": " * You may obtain a copy of the License at\n",
        "7": " *\n",
        "8": " * http://www.apache.org/licenses/LICENSE-2.0\n",
        "9": " *\n",
        "10": " * Unless required by applicable law or agreed to in writing, software\n",
        "11": " * distributed under the License is distributed on an \"AS IS\" BASIS,\n",
        "12": " * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n",
        "13": " * See the License for the specific language governing permissions and\n",
        "14": " * limitations under the License.\n",
        "15": " */\n",
        "16": "\n",
        "17": "package com.google.common.collect;\n",
        "18": "\n",
        "19": "import static com.google.common.base.Preconditions.checkArgument;\n",
        "20": "import static com.google.common.base.Preconditions.checkNotNull;\n",
        "21": "import static com.google.common.collect.CollectPreconditions.checkRemove;\n",
        "22": "\n",
        "23": "import com.google.common.annotations.GwtCompatible;\n",
        "24": "import com.google.common.collect.Maps.ViewCachingAbstractMap;\n",
        "25": "import com.google.j2objc.annotations.WeakOuter;\n",
        "26": "\n",
        "27": "import java.io.Serializable;\n",
        "28": "import java.util.AbstractCollection;\n",
        "29": "import java.util.Collection;\n",
        "30": "import java.util.Collections;\n",
        "31": "import java.util.Comparator;\n",
        "32": "import java.util.ConcurrentModificationException;\n",
        "33": "import java.util.Iterator;\n",
        "34": "import java.util.List;\n",
        "35": "import java.util.ListIterator;\n",
        "36": "import java.util.Map;\n",
        "37": "import java.util.Map.Entry;\n",
        "38": "import java.util.RandomAccess;\n",
        "39": "import java.util.Set;\n",
        "40": "import java.util.SortedMap;\n",
        "41": "import java.util.SortedSet;\n",
        "42": "\n",
        "43": "import javax.annotation.Nullable;\n",
        "44": "\n",
        "45": "/**\n",
        "46": " * Basic implementation of the {@link Multimap} interface. This class represents\n",
        "47": " * a multimap as a map that associates each key with a collection of values. All\n",
        "48": " * methods of {@link Multimap} are supported, including those specified as\n",
        "49": " * optional in the interface.\n",
        "50": " *\n",
        "51": " * <p>To implement a multimap, a subclass must define the method {@link\n",
        "52": " * #createCollection()}, which creates an empty collection of values for a key.\n",
        "53": " *\n",
        "54": " * <p>The multimap constructor takes a map that has a single entry for each\n",
        "55": " * distinct key. When you insert a key-value pair with a key that isn't already\n",
        "56": " * in the multimap, {@code AbstractMapBasedMultimap} calls {@link #createCollection()}\n",
        "57": " * to create the collection of values for that key. The subclass should not call\n",
        "58": " * {@link #createCollection()} directly, and a new instance should be created\n",
        "59": " * every time the method is called.\n",
        "60": " *\n",
        "61": " * <p>For example, the subclass could pass a {@link java.util.TreeMap} during\n",
        "62": " * construction, and {@link #createCollection()} could return a {@link\n",
        "63": " * java.util.TreeSet}, in which case the multimap's iterators would propagate\n",
        "64": " * through the keys and values in sorted order.\n",
        "65": " *\n",
        "66": " * <p>Keys and values may be null, as long as the underlying collection classes\n",
        "67": " * support null elements.\n",
        "68": " *\n",
        "69": " * <p>The collections created by {@link #createCollection()} may or may not\n",
        "70": " * allow duplicates. If the collection, such as a {@link Set}, does not support\n",
        "71": " * duplicates, an added key-value pair will replace an existing pair with the\n",
        "72": " * same key and value, if such a pair is present. With collections like {@link\n",
        "73": " * List} that allow duplicates, the collection will keep the existing key-value\n",
        "74": " * pairs while adding a new pair.\n",
        "75": " *\n",
        "76": " * <p>This class is not threadsafe when any concurrent operations update the\n",
        "77": " * multimap, even if the underlying map and {@link #createCollection()} method\n",
        "78": " * return threadsafe classes. Concurrent read operations will work correctly. To\n",
        "79": " * allow concurrent update operations, wrap your multimap with a call to {@link\n",
        "80": " * Multimaps#synchronizedMultimap}.\n",
        "81": " *\n",
        "82": " * <p>For serialization to work, the subclass must specify explicit\n",
        "83": " * {@code readObject} and {@code writeObject} methods.\n",
        "84": " *\n",
        "85": " * @author Jared Levy\n",
        "86": " * @author Louis Wasserman\n",
        "87": " */\n",
        "88": "@GwtCompatible(emulated = true)\n",
        "89": "abstract class AbstractMapBasedMultimap<K, V> extends AbstractMultimap<K, V>\n",
        "90": "    implements Serializable {\n",
        "91": "  /*\n",
        "92": "   * Here's an outline of the overall design.\n",
        "93": "   *\n",
        "94": "   * The map variable contains the collection of values associated with each\n",
        "95": "   * key. When a key-value pair is added to a multimap that didn't previously\n",
        "96": "   * contain any values for that key, a new collection generated by\n",
        "97": "   * createCollection is added to the map. That same collection instance\n",
        "98": "   * remains in the map as long as the multimap has any values for the key. If\n",
        "99": "   * all values for the key are removed, the key and collection are removed\n",
        "100": "   * from the map.\n",
        "101": "   *\n",
        "102": "   * The get method returns a WrappedCollection, which decorates the collection\n",
        "103": "   * in the map (if the key is present) or an empty collection (if the key is\n",
        "104": "   * not present). When the collection delegate in the WrappedCollection is\n",
        "105": "   * empty, the multimap may contain subsequently added values for that key. To\n",
        "106": "   * handle that situation, the WrappedCollection checks whether map contains\n",
        "107": "   * an entry for the provided key, and if so replaces the delegate.\n",
        "108": "   */\n",
        "109": "\n",
        "110": "  private transient Map<K, Collection<V>> map;\n",
        "111": "  private transient int totalSize;\n",
        "112": "\n",
        "113": "  /**\n",
        "114": "   * Creates a new multimap that uses the provided map.\n",
        "115": "   *\n",
        "116": "   * @param map place to store the mapping from each key to its corresponding\n",
        "117": "   *     values\n",
        "118": "   * @throws IllegalArgumentException if {@code map} is not empty\n",
        "119": "   */\n",
        "120": "  protected AbstractMapBasedMultimap(Map<K, Collection<V>> map) {\n",
        "121": "    checkArgument(map.isEmpty());\n",
        "122": "    this.map = map;\n",
        "123": "  }\n",
        "124": "\n",
        "125": "  /** Used during deserialization only. */\n",
        "126": "  final void setMap(Map<K, Collection<V>> map) {\n",
        "127": "    this.map = map;\n",
        "128": "    totalSize = 0;\n",
        "129": "    for (Collection<V> values : map.values()) {\n",
        "130": "      checkArgument(!values.isEmpty());\n",
        "131": "      totalSize += values.size();\n",
        "132": "    }\n",
        "133": "  }\n",
        "134": "\n",
        "135": "  /**\n",
        "136": "   * Creates an unmodifiable, empty collection of values.\n",
        "137": "   *\n",
        "138": "   * <p>This is used in {@link #removeAll} on an empty key.\n",
        "139": "   */\n",
        "140": "  Collection<V> createUnmodifiableEmptyCollection() {\n",
        "141": "    return unmodifiableCollectionSubclass(createCollection());\n",
        "142": "  }\n",
        "143": "\n",
        "144": "  /**\n",
        "145": "   * Creates the collection of values for a single key.\n",
        "146": "   *\n",
        "147": "   * <p>Collections with weak, soft, or phantom references are not supported.\n",
        "148": "   * Each call to {@code createCollection} should create a new instance.\n",
        "149": "   *\n",
        "150": "   * <p>The returned collection class determines whether duplicate key-value\n",
        "151": "   * pairs are allowed.\n",
        "152": "   *\n",
        "153": "   * @return an empty collection of values\n",
        "154": "   */\n",
        "155": "  abstract Collection<V> createCollection();\n",
        "156": "\n",
        "157": "  /**\n",
        "158": "   * Creates the collection of values for an explicitly provided key. By\n",
        "159": "   * default, it simply calls {@link #createCollection()}, which is the correct\n",
        "160": "   * behavior for most implementations. The {@link LinkedHashMultimap} class\n",
        "161": "   * overrides it.\n",
        "162": "   *\n",
        "163": "   * @param key key to associate with values in the collection\n",
        "164": "   * @return an empty collection of values\n",
        "165": "   */\n",
        "166": "  Collection<V> createCollection(@Nullable K key) {\n",
        "167": "    return createCollection();\n",
        "168": "  }\n",
        "169": "\n",
        "170": "  Map<K, Collection<V>> backingMap() {\n",
        "171": "    return map;\n",
        "172": "  }\n",
        "173": "\n",
        "174": "  // Query Operations\n",
        "175": "\n",
        "176": "  @Override\n",
        "177": "  public int size() {\n",
        "178": "    return totalSize;\n",
        "179": "  }\n",
        "180": "\n",
        "181": "  @Override\n",
        "182": "  public boolean containsKey(@Nullable Object key) {\n",
        "183": "    return map.containsKey(key);\n",
        "184": "  }\n",
        "185": "\n",
        "186": "  // Modification Operations\n",
        "187": "\n",
        "188": "  @Override\n",
        "189": "  public boolean put(@Nullable K key, @Nullable V value) {\n",
        "190": "    Collection<V> collection = map.get(key);\n",
        "191": "    if (collection == null) {\n",
        "192": "      collection = createCollection(key);\n",
        "193": "      if (collection.add(value)) {\n",
        "194": "        totalSize++;\n",
        "195": "        map.put(key, collection);\n",
        "196": "        return true;\n",
        "197": "      } else {\n",
        "198": "        throw new AssertionError(\"New Collection violated the Collection spec\");\n",
        "199": "      }\n",
        "200": "    } else if (collection.add(value)) {\n",
        "201": "      totalSize++;\n",
        "202": "      return true;\n",
        "203": "    } else {\n",
        "204": "      return false;\n",
        "205": "    }\n",
        "206": "  }\n",
        "207": "\n",
        "208": "  private Collection<V> getOrCreateCollection(@Nullable K key) {\n",
        "209": "    Collection<V> collection = map.get(key);\n",
        "210": "    if (collection == null) {\n",
        "211": "      collection = createCollection(key);\n",
        "212": "      map.put(key, collection);\n",
        "213": "    }\n",
        "214": "    return collection;\n",
        "215": "  }\n",
        "216": "\n",
        "217": "  // Bulk Operations\n",
        "218": "\n",
        "219": "  /**\n",
        "220": "   * {@inheritDoc}\n",
        "221": "   *\n",
        "222": "   * <p>The returned collection is immutable.\n",
        "223": "   */\n",
        "224": "  @Override\n",
        "225": "  public Collection<V> replaceValues(@Nullable K key, Iterable<? extends V> values) {\n",
        "226": "    Iterator<? extends V> iterator = values.iterator();\n",
        "227": "    if (!iterator.hasNext()) {\n",
        "228": "      return removeAll(key);\n",
        "229": "    }\n",
        "230": "\n",
        "231": "    // TODO(lowasser): investigate atomic failure?\n",
        "232": "    Collection<V> collection = getOrCreateCollection(key);\n",
        "233": "    Collection<V> oldValues = createCollection();\n",
        "234": "    oldValues.addAll(collection);\n",
        "235": "\n",
        "236": "    totalSize -= collection.size();\n",
        "237": "    collection.clear();\n",
        "238": "\n",
        "239": "    while (iterator.hasNext()) {\n",
        "240": "      if (collection.add(iterator.next())) {\n",
        "241": "        totalSize++;\n",
        "242": "      }\n",
        "243": "    }\n",
        "244": "\n",
        "245": "    return unmodifiableCollectionSubclass(oldValues);\n",
        "246": "  }\n",
        "247": "\n",
        "248": "  /**\n",
        "249": "   * {@inheritDoc}\n",
        "250": "   *\n",
        "251": "   * <p>The returned collection is immutable.\n",
        "252": "   */\n",
        "253": "  @Override\n",
        "254": "  public Collection<V> removeAll(@Nullable Object key) {\n",
        "255": "    Collection<V> collection = map.remove(key);\n",
        "256": "\n",
        "257": "    if (collection == null) {\n",
        "258": "      return createUnmodifiableEmptyCollection();\n",
        "259": "    }\n",
        "260": "\n",
        "261": "    Collection<V> output = createCollection();\n",
        "262": "    output.addAll(collection);\n",
        "263": "    totalSize -= collection.size();\n",
        "264": "    collection.clear();\n",
        "265": "\n",
        "266": "    return unmodifiableCollectionSubclass(output);\n",
        "267": "  }\n",
        "268": "\n",
        "269": "  Collection<V> unmodifiableCollectionSubclass(Collection<V> collection) {\n",
        "270": "    // We don't deal with NavigableSet here yet for GWT reasons -- instead,\n",
        "271": "    // non-GWT TreeMultimap explicitly overrides this and uses NavigableSet.\n",
        "272": "    if (collection instanceof SortedSet) {\n",
        "273": "      return Collections.unmodifiableSortedSet((SortedSet<V>) collection);\n",
        "274": "    } else if (collection instanceof Set) {\n",
        "275": "      return Collections.unmodifiableSet((Set<V>) collection);\n",
        "276": "    } else if (collection instanceof List) {\n",
        "277": "      return Collections.unmodifiableList((List<V>) collection);\n",
        "278": "    } else {\n",
        "279": "      return Collections.unmodifiableCollection(collection);\n",
        "280": "    }\n",
        "281": "  }\n",
        "282": "\n",
        "283": "  @Override\n",
        "284": "  public void clear() {\n",
        "285": "    // Clear each collection, to make previously returned collections empty.\n",
        "286": "    for (Collection<V> collection : map.values()) {\n",
        "287": "      collection.clear();\n",
        "288": "    }\n",
        "289": "    map.clear();\n",
        "290": "    totalSize = 0;\n",
        "291": "  }\n",
        "292": "\n",
        "293": "  // Views\n",
        "294": "\n",
        "295": "  /**\n",
        "296": "   * {@inheritDoc}\n",
        "297": "   *\n",
        "298": "   * <p>The returned collection is not serializable.\n",
        "299": "   */\n",
        "300": "  @Override\n",
        "301": "  public Collection<V> get(@Nullable K key) {\n",
        "302": "    Collection<V> collection = map.get(key);\n",
        "303": "    if (collection == null) {\n",
        "304": "      collection = createCollection(key);\n",
        "305": "    }\n",
        "306": "    return wrapCollection(key, collection);\n",
        "307": "  }\n",
        "308": "\n",
        "309": "  /**\n",
        "310": "   * Generates a decorated collection that remains consistent with the values in\n",
        "311": "   * the multimap for the provided key. Changes to the multimap may alter the\n",
        "312": "   * returned collection, and vice versa.\n",
        "313": "   */\n",
        "314": "  Collection<V> wrapCollection(@Nullable K key, Collection<V> collection) {\n",
        "315": "    // We don't deal with NavigableSet here yet for GWT reasons -- instead,\n",
        "316": "    // non-GWT TreeMultimap explicitly overrides this and uses NavigableSet.\n",
        "317": "    if (collection instanceof SortedSet) {\n",
        "318": "      return new WrappedSortedSet(key, (SortedSet<V>) collection, null);\n",
        "319": "    } else if (collection instanceof Set) {\n",
        "320": "      return new WrappedSet(key, (Set<V>) collection);\n",
        "321": "    } else if (collection instanceof List) {\n",
        "322": "      return wrapList(key, (List<V>) collection, null);\n",
        "323": "    } else {\n",
        "324": "      return new WrappedCollection(key, collection, null);\n",
        "325": "    }\n",
        "326": "  }\n",
        "327": "\n",
        "328": "  private List<V> wrapList(@Nullable K key, List<V> list, @Nullable WrappedCollection ancestor) {\n",
        "329": "    return (list instanceof RandomAccess)\n",
        "330": "        ? new RandomAccessWrappedList(key, list, ancestor)\n",
        "331": "        : new WrappedList(key, list, ancestor);\n",
        "332": "  }\n",
        "333": "\n",
        "334": "  /**\n",
        "335": "   * Collection decorator that stays in sync with the multimap values for a key.\n",
        "336": "   * There are two kinds of wrapped collections: full and subcollections. Both\n",
        "337": "   * have a delegate pointing to the underlying collection class.\n",
        "338": "   *\n",
        "339": "   * <p>Full collections, identified by a null ancestor field, contain all\n",
        "340": "   * multimap values for a given key. Its delegate is a value in {@link\n",
        "341": "   * AbstractMapBasedMultimap#map} whenever the delegate is non-empty. The {@code\n",
        "342": "   * refreshIfEmpty}, {@code removeIfEmpty}, and {@code addToMap} methods ensure\n",
        "343": "   * that the {@code WrappedCollection} and map remain consistent.\n",
        "344": "   *\n",
        "345": "   * <p>A subcollection, such as a sublist, contains some of the values for a\n",
        "346": "   * given key. Its ancestor field points to the full wrapped collection with\n",
        "347": "   * all values for the key. The subcollection {@code refreshIfEmpty}, {@code\n",
        "348": "   * removeIfEmpty}, and {@code addToMap} methods call the corresponding methods\n",
        "349": "   * of the full wrapped collection.\n",
        "350": "   */\n",
        "351": "  @WeakOuter\n",
        "352": "  private class WrappedCollection extends AbstractCollection<V> {\n",
        "353": "    final K key;\n",
        "354": "    Collection<V> delegate;\n",
        "355": "    final WrappedCollection ancestor;\n",
        "356": "    final Collection<V> ancestorDelegate;\n",
        "357": "\n",
        "358": "    WrappedCollection(\n",
        "359": "        @Nullable K key, Collection<V> delegate, @Nullable WrappedCollection ancestor) {\n",
        "360": "      this.key = key;\n",
        "361": "      this.delegate = delegate;\n",
        "362": "      this.ancestor = ancestor;\n",
        "363": "      this.ancestorDelegate = (ancestor == null) ? null : ancestor.getDelegate();\n",
        "364": "    }\n",
        "365": "\n",
        "366": "    /**\n",
        "367": "     * If the delegate collection is empty, but the multimap has values for the\n",
        "368": "     * key, replace the delegate with the new collection for the key.\n",
        "369": "     *\n",
        "370": "     * <p>For a subcollection, refresh its ancestor and validate that the\n",
        "371": "     * ancestor delegate hasn't changed.\n",
        "372": "     */\n",
        "373": "    void refreshIfEmpty() {\n",
        "374": "      if (ancestor != null) {\n",
        "375": "        ancestor.refreshIfEmpty();\n",
        "376": "        if (ancestor.getDelegate() != ancestorDelegate) {\n",
        "377": "          throw new ConcurrentModificationException();\n",
        "378": "        }\n",
        "379": "      } else if (delegate.isEmpty()) {\n",
        "380": "        Collection<V> newDelegate = map.get(key);\n",
        "381": "        if (newDelegate != null) {\n",
        "382": "          delegate = newDelegate;\n",
        "383": "        }\n",
        "384": "      }\n",
        "385": "    }\n",
        "386": "\n",
        "387": "    /**\n",
        "388": "     * If collection is empty, remove it from {@code AbstractMapBasedMultimap.this.map}.\n",
        "389": "     * For subcollections, check whether the ancestor collection is empty.\n",
        "390": "     */\n",
        "391": "    void removeIfEmpty() {\n",
        "392": "      if (ancestor != null) {\n",
        "393": "        ancestor.removeIfEmpty();\n",
        "394": "      } else if (delegate.isEmpty()) {\n",
        "395": "        map.remove(key);\n",
        "396": "      }\n",
        "397": "    }\n",
        "398": "\n",
        "399": "    K getKey() {\n",
        "400": "      return key;\n",
        "401": "    }\n",
        "402": "\n",
        "403": "    /**\n",
        "404": "     * Add the delegate to the map. Other {@code WrappedCollection} methods\n",
        "405": "     * should call this method after adding elements to a previously empty\n",
        "406": "     * collection.\n",
        "407": "     *\n",
        "408": "     * <p>Subcollection add the ancestor's delegate instead.\n",
        "409": "     */\n",
        "410": "    void addToMap() {\n",
        "411": "      if (ancestor != null) {\n",
        "412": "        ancestor.addToMap();\n",
        "413": "      } else {\n",
        "414": "        map.put(key, delegate);\n",
        "415": "      }\n",
        "416": "    }\n",
        "417": "\n",
        "418": "    @Override\n",
        "419": "    public int size() {\n",
        "420": "      refreshIfEmpty();\n",
        "421": "      return delegate.size();\n",
        "422": "    }\n",
        "423": "\n",
        "424": "    @Override\n",
        "425": "    public boolean equals(@Nullable Object object) {\n",
        "426": "      if (object == this) {\n",
        "427": "        return true;\n",
        "428": "      }\n",
        "429": "      refreshIfEmpty();\n",
        "430": "      return delegate.equals(object);\n",
        "431": "    }\n",
        "432": "\n",
        "433": "    @Override\n",
        "434": "    public int hashCode() {\n",
        "435": "      refreshIfEmpty();\n",
        "436": "      return delegate.hashCode();\n",
        "437": "    }\n",
        "438": "\n",
        "439": "    @Override\n",
        "440": "    public String toString() {\n",
        "441": "      refreshIfEmpty();\n",
        "442": "      return delegate.toString();\n",
        "443": "    }\n",
        "444": "\n",
        "445": "    Collection<V> getDelegate() {\n",
        "446": "      return delegate;\n",
        "447": "    }\n",
        "448": "\n",
        "449": "    @Override\n",
        "450": "    public Iterator<V> iterator() {\n",
        "451": "      refreshIfEmpty();\n",
        "452": "      return new WrappedIterator();\n",
        "453": "    }\n",
        "454": "\n",
        "455": "    /** Collection iterator for {@code WrappedCollection}. */\n",
        "456": "    class WrappedIterator implements Iterator<V> {\n",
        "457": "      final Iterator<V> delegateIterator;\n",
        "458": "      final Collection<V> originalDelegate = delegate;\n",
        "459": "\n",
        "460": "      WrappedIterator() {\n",
        "461": "        delegateIterator = iteratorOrListIterator(delegate);\n",
        "462": "      }\n",
        "463": "\n",
        "464": "      WrappedIterator(Iterator<V> delegateIterator) {\n",
        "465": "        this.delegateIterator = delegateIterator;\n",
        "466": "      }\n",
        "467": "\n",
        "468": "      /**\n",
        "469": "       * If the delegate changed since the iterator was created, the iterator is\n",
        "470": "       * no longer valid.\n",
        "471": "       */\n",
        "472": "      void validateIterator() {\n",
        "473": "        refreshIfEmpty();\n",
        "474": "        if (delegate != originalDelegate) {\n",
        "475": "          throw new ConcurrentModificationException();\n",
        "476": "        }\n",
        "477": "      }\n",
        "478": "\n",
        "479": "      @Override\n",
        "480": "      public boolean hasNext() {\n",
        "481": "        validateIterator();\n",
        "482": "        return delegateIterator.hasNext();\n",
        "483": "      }\n",
        "484": "\n",
        "485": "      @Override\n",
        "486": "      public V next() {\n",
        "487": "        validateIterator();\n",
        "488": "        return delegateIterator.next();\n",
        "489": "      }\n",
        "490": "\n",
        "491": "      @Override\n",
        "492": "      public void remove() {\n",
        "493": "        delegateIterator.remove();\n",
        "494": "        totalSize--;\n",
        "495": "        removeIfEmpty();\n",
        "496": "      }\n",
        "497": "\n",
        "498": "      Iterator<V> getDelegateIterator() {\n",
        "499": "        validateIterator();\n",
        "500": "        return delegateIterator;\n",
        "501": "      }\n",
        "502": "    }\n",
        "503": "\n",
        "504": "    @Override\n",
        "505": "    public boolean add(V value) {\n",
        "506": "      refreshIfEmpty();\n",
        "507": "      boolean wasEmpty = delegate.isEmpty();\n",
        "508": "      boolean changed = delegate.add(value);\n",
        "509": "      if (changed) {\n",
        "510": "        totalSize++;\n",
        "511": "        if (wasEmpty) {\n",
        "512": "          addToMap();\n",
        "513": "        }\n",
        "514": "      }\n",
        "515": "      return changed;\n",
        "516": "    }\n",
        "517": "\n",
        "518": "    WrappedCollection getAncestor() {\n",
        "519": "      return ancestor;\n",
        "520": "    }\n",
        "521": "\n",
        "522": "    // The following methods are provided for better performance.\n",
        "523": "\n",
        "524": "    @Override\n",
        "525": "    public boolean addAll(Collection<? extends V> collection) {\n",
        "526": "      if (collection.isEmpty()) {\n",
        "527": "        return false;\n",
        "528": "      }\n",
        "529": "      int oldSize = size(); // calls refreshIfEmpty\n",
        "530": "      boolean changed = delegate.addAll(collection);\n",
        "531": "      if (changed) {\n",
        "532": "        int newSize = delegate.size();\n",
        "533": "        totalSize += (newSize - oldSize);\n",
        "534": "        if (oldSize == 0) {\n",
        "535": "          addToMap();\n",
        "536": "        }\n",
        "537": "      }\n",
        "538": "      return changed;\n",
        "539": "    }\n",
        "540": "\n",
        "541": "    @Override\n",
        "542": "    public boolean contains(Object o) {\n",
        "543": "      refreshIfEmpty();\n",
        "544": "      return delegate.contains(o);\n",
        "545": "    }\n",
        "546": "\n",
        "547": "    @Override\n",
        "548": "    public boolean containsAll(Collection<?> c) {\n",
        "549": "      refreshIfEmpty();\n",
        "550": "      return delegate.containsAll(c);\n",
        "551": "    }\n",
        "552": "\n",
        "553": "    @Override\n",
        "554": "    public void clear() {\n",
        "555": "      int oldSize = size(); // calls refreshIfEmpty\n",
        "556": "      if (oldSize == 0) {\n",
        "557": "        return;\n",
        "558": "      }\n",
        "559": "      delegate.clear();\n",
        "560": "      totalSize -= oldSize;\n",
        "561": "      removeIfEmpty(); // maybe shouldn't be removed if this is a sublist\n",
        "562": "    }\n",
        "563": "\n",
        "564": "    @Override\n",
        "565": "    public boolean remove(Object o) {\n",
        "566": "      refreshIfEmpty();\n",
        "567": "      boolean changed = delegate.remove(o);\n",
        "568": "      if (changed) {\n",
        "569": "        totalSize--;\n",
        "570": "        removeIfEmpty();\n",
        "571": "      }\n",
        "572": "      return changed;\n",
        "573": "    }\n",
        "574": "\n",
        "575": "    @Override\n",
        "576": "    public boolean removeAll(Collection<?> c) {\n",
        "577": "      if (c.isEmpty()) {\n",
        "578": "        return false;\n",
        "579": "      }\n",
        "580": "      int oldSize = size(); // calls refreshIfEmpty\n",
        "581": "      boolean changed = delegate.removeAll(c);\n",
        "582": "      if (changed) {\n",
        "583": "        int newSize = delegate.size();\n",
        "584": "        totalSize += (newSize - oldSize);\n",
        "585": "        removeIfEmpty();\n",
        "586": "      }\n",
        "587": "      return changed;\n",
        "588": "    }\n",
        "589": "\n",
        "590": "    @Override\n",
        "591": "    public boolean retainAll(Collection<?> c) {\n",
        "592": "      checkNotNull(c);\n",
        "593": "      int oldSize = size(); // calls refreshIfEmpty\n",
        "594": "      boolean changed = delegate.retainAll(c);\n",
        "595": "      if (changed) {\n",
        "596": "        int newSize = delegate.size();\n",
        "597": "        totalSize += (newSize - oldSize);\n",
        "598": "        removeIfEmpty();\n",
        "599": "      }\n",
        "600": "      return changed;\n",
        "601": "    }\n",
        "602": "  }\n",
        "603": "\n",
        "604": "  private Iterator<V> iteratorOrListIterator(Collection<V> collection) {\n",
        "605": "    return (collection instanceof List)\n",
        "606": "        ? ((List<V>) collection).listIterator()\n",
        "607": "        : collection.iterator();\n",
        "608": "  }\n",
        "609": "\n",
        "610": "  /** Set decorator that stays in sync with the multimap values for a key. */\n",
        "611": "  @WeakOuter\n",
        "612": "  private class WrappedSet extends WrappedCollection implements Set<V> {\n",
        "613": "    WrappedSet(@Nullable K key, Set<V> delegate) {\n",
        "614": "      super(key, delegate, null);\n",
        "615": "    }\n",
        "616": "\n",
        "617": "    @Override\n",
        "618": "    public boolean removeAll(Collection<?> c) {\n",
        "619": "      if (c.isEmpty()) {\n",
        "620": "        return false;\n",
        "621": "      }\n",
        "622": "      int oldSize = size(); // calls refreshIfEmpty\n",
        "623": "\n",
        "624": "      // Guava issue 1013: AbstractSet and most JDK set implementations are\n",
        "625": "      // susceptible to quadratic removeAll performance on lists;\n",
        "626": "      // use a slightly smarter implementation here\n",
        "627": "      boolean changed = Sets.removeAllImpl((Set<V>) delegate, c);\n",
        "628": "      if (changed) {\n",
        "629": "        int newSize = delegate.size();\n",
        "630": "        totalSize += (newSize - oldSize);\n",
        "631": "        removeIfEmpty();\n",
        "632": "      }\n",
        "633": "      return changed;\n",
        "634": "    }\n",
        "635": "  }\n",
        "636": "\n",
        "637": "  /**\n",
        "638": "   * SortedSet decorator that stays in sync with the multimap values for a key.\n",
        "639": "   */\n",
        "640": "  @WeakOuter\n",
        "641": "  private class WrappedSortedSet extends WrappedCollection implements SortedSet<V> {\n",
        "642": "    WrappedSortedSet(@Nullable K key, SortedSet<V> delegate, @Nullable WrappedCollection ancestor) {\n",
        "643": "      super(key, delegate, ancestor);\n",
        "644": "    }\n",
        "645": "\n",
        "646": "    SortedSet<V> getSortedSetDelegate() {\n",
        "647": "      return (SortedSet<V>) getDelegate();\n",
        "648": "    }\n",
        "649": "\n",
        "650": "    @Override\n",
        "651": "    public Comparator<? super V> comparator() {\n",
        "652": "      return getSortedSetDelegate().comparator();\n",
        "653": "    }\n",
        "654": "\n",
        "655": "    @Override\n",
        "656": "    public V first() {\n",
        "657": "      refreshIfEmpty();\n",
        "658": "      return getSortedSetDelegate().first();\n",
        "659": "    }\n",
        "660": "\n",
        "661": "    @Override\n",
        "662": "    public V last() {\n",
        "663": "      refreshIfEmpty();\n",
        "664": "      return getSortedSetDelegate().last();\n",
        "665": "    }\n",
        "666": "\n",
        "667": "    @Override\n",
        "668": "    public SortedSet<V> headSet(V toElement) {\n",
        "669": "      refreshIfEmpty();\n",
        "670": "      return new WrappedSortedSet(\n",
        "671": "          getKey(),\n",
        "672": "          getSortedSetDelegate().headSet(toElement),\n",
        "673": "          (getAncestor() == null) ? this : getAncestor());\n",
        "674": "    }\n",
        "675": "\n",
        "676": "    @Override\n",
        "677": "    public SortedSet<V> subSet(V fromElement, V toElement) {\n",
        "678": "      refreshIfEmpty();\n",
        "679": "      return new WrappedSortedSet(\n",
        "680": "          getKey(),\n",
        "681": "          getSortedSetDelegate().subSet(fromElement, toElement),\n",
        "682": "          (getAncestor() == null) ? this : getAncestor());\n",
        "683": "    }\n",
        "684": "\n",
        "685": "    @Override\n",
        "686": "    public SortedSet<V> tailSet(V fromElement) {\n",
        "687": "      refreshIfEmpty();\n",
        "688": "      return new WrappedSortedSet(\n",
        "689": "          getKey(),\n",
        "690": "          getSortedSetDelegate().tailSet(fromElement),\n",
        "691": "          (getAncestor() == null) ? this : getAncestor());\n",
        "692": "    }\n",
        "693": "  }\n",
        "694": "\n",
        "695": "  /** List decorator that stays in sync with the multimap values for a key. */\n",
        "696": "  @WeakOuter\n",
        "697": "  private class WrappedList extends WrappedCollection implements List<V> {\n",
        "698": "    WrappedList(@Nullable K key, List<V> delegate, @Nullable WrappedCollection ancestor) {\n",
        "699": "      super(key, delegate, ancestor);\n",
        "700": "    }\n",
        "701": "\n",
        "702": "    List<V> getListDelegate() {\n",
        "703": "      return (List<V>) getDelegate();\n",
        "704": "    }\n",
        "705": "\n",
        "706": "    @Override\n",
        "707": "    public boolean addAll(int index, Collection<? extends V> c) {\n",
        "708": "      if (c.isEmpty()) {\n",
        "709": "        return false;\n",
        "710": "      }\n",
        "711": "      int oldSize = size(); // calls refreshIfEmpty\n",
        "712": "      boolean changed = getListDelegate().addAll(index, c);\n",
        "713": "      if (changed) {\n",
        "714": "        int newSize = getDelegate().size();\n",
        "715": "        totalSize += (newSize - oldSize);\n",
        "716": "        if (oldSize == 0) {\n",
        "717": "          addToMap();\n",
        "718": "        }\n",
        "719": "      }\n",
        "720": "      return changed;\n",
        "721": "    }\n",
        "722": "\n",
        "723": "    @Override\n",
        "724": "    public V get(int index) {\n",
        "725": "      refreshIfEmpty();\n",
        "726": "      return getListDelegate().get(index);\n",
        "727": "    }\n",
        "728": "\n",
        "729": "    @Override\n",
        "730": "    public V set(int index, V element) {\n",
        "731": "      refreshIfEmpty();\n",
        "732": "      return getListDelegate().set(index, element);\n",
        "733": "    }\n",
        "734": "\n",
        "735": "    @Override\n",
        "736": "    public void add(int index, V element) {\n",
        "737": "      refreshIfEmpty();\n",
        "738": "      boolean wasEmpty = getDelegate().isEmpty();\n",
        "739": "      getListDelegate().add(index, element);\n",
        "740": "      totalSize++;\n",
        "741": "      if (wasEmpty) {\n",
        "742": "        addToMap();\n",
        "743": "      }\n",
        "744": "    }\n",
        "745": "\n",
        "746": "    @Override\n",
        "747": "    public V remove(int index) {\n",
        "748": "      refreshIfEmpty();\n",
        "749": "      V value = getListDelegate().remove(index);\n",
        "750": "      totalSize--;\n",
        "751": "      removeIfEmpty();\n",
        "752": "      return value;\n",
        "753": "    }\n",
        "754": "\n",
        "755": "    @Override\n",
        "756": "    public int indexOf(Object o) {\n",
        "757": "      refreshIfEmpty();\n",
        "758": "      return getListDelegate().indexOf(o);\n",
        "759": "    }\n",
        "760": "\n",
        "761": "    @Override\n",
        "762": "    public int lastIndexOf(Object o) {\n",
        "763": "      refreshIfEmpty();\n",
        "764": "      return getListDelegate().lastIndexOf(o);\n",
        "765": "    }\n",
        "766": "\n",
        "767": "    @Override\n",
        "768": "    public ListIterator<V> listIterator() {\n",
        "769": "      refreshIfEmpty();\n",
        "770": "      return new WrappedListIterator();\n",
        "771": "    }\n",
        "772": "\n",
        "773": "    @Override\n",
        "774": "    public ListIterator<V> listIterator(int index) {\n",
        "775": "      refreshIfEmpty();\n",
        "776": "      return new WrappedListIterator(index);\n",
        "777": "    }\n",
        "778": "\n",
        "779": "    @Override\n",
        "780": "    public List<V> subList(int fromIndex, int toIndex) {\n",
        "781": "      refreshIfEmpty();\n",
        "782": "      return wrapList(\n",
        "783": "          getKey(),\n",
        "784": "          getListDelegate().subList(fromIndex, toIndex),\n",
        "785": "          (getAncestor() == null) ? this : getAncestor());\n",
        "786": "    }\n",
        "787": "\n",
        "788": "    /** ListIterator decorator. */\n",
        "789": "    private class WrappedListIterator extends WrappedIterator implements ListIterator<V> {\n",
        "790": "      WrappedListIterator() {}\n",
        "791": "\n",
        "792": "      public WrappedListIterator(int index) {\n",
        "793": "        super(getListDelegate().listIterator(index));\n",
        "794": "      }\n",
        "795": "\n",
        "796": "      private ListIterator<V> getDelegateListIterator() {\n",
        "797": "        return (ListIterator<V>) getDelegateIterator();\n",
        "798": "      }\n",
        "799": "\n",
        "800": "      @Override\n",
        "801": "      public boolean hasPrevious() {\n",
        "802": "        return getDelegateListIterator().hasPrevious();\n",
        "803": "      }\n",
        "804": "\n",
        "805": "      @Override\n",
        "806": "      public V previous() {\n",
        "807": "        return getDelegateListIterator().previous();\n",
        "808": "      }\n",
        "809": "\n",
        "810": "      @Override\n",
        "811": "      public int nextIndex() {\n",
        "812": "        return getDelegateListIterator().nextIndex();\n",
        "813": "      }\n",
        "814": "\n",
        "815": "      @Override\n",
        "816": "      public int previousIndex() {\n",
        "817": "        return getDelegateListIterator().previousIndex();\n",
        "818": "      }\n",
        "819": "\n",
        "820": "      @Override\n",
        "821": "      public void set(V value) {\n",
        "822": "        getDelegateListIterator().set(value);\n",
        "823": "      }\n",
        "824": "\n",
        "825": "      @Override\n",
        "826": "      public void add(V value) {\n",
        "827": "        boolean wasEmpty = isEmpty();\n",
        "828": "        getDelegateListIterator().add(value);\n",
        "829": "        totalSize++;\n",
        "830": "        if (wasEmpty) {\n",
        "831": "          addToMap();\n",
        "832": "        }\n",
        "833": "      }\n",
        "834": "    }\n",
        "835": "  }\n",
        "836": "\n",
        "837": "  /**\n",
        "838": "   * List decorator that stays in sync with the multimap values for a key and\n",
        "839": "   * supports rapid random access.\n",
        "840": "   */\n",
        "841": "  private class RandomAccessWrappedList extends WrappedList implements RandomAccess {\n",
        "842": "    RandomAccessWrappedList(\n",
        "843": "        @Nullable K key, List<V> delegate, @Nullable WrappedCollection ancestor) {\n",
        "844": "      super(key, delegate, ancestor);\n",
        "845": "    }\n",
        "846": "  }\n",
        "847": "\n",
        "848": "  @Override\n",
        "849": "  Set<K> createKeySet() {\n",
        "850": "    // TreeMultimap uses NavigableKeySet explicitly, but we don't handle that here for GWT\n",
        "851": "    // compatibility reasons\n",
        "852": "    return (map instanceof SortedMap)\n",
        "853": "        ? new SortedKeySet((SortedMap<K, Collection<V>>) map)\n",
        "854": "        : new KeySet(map);\n",
        "855": "  }\n",
        "856": "\n",
        "857": "  @WeakOuter\n",
        "858": "  private class KeySet extends Maps.KeySet<K, Collection<V>> {\n",
        "859": "    KeySet(final Map<K, Collection<V>> subMap) {\n",
        "860": "      super(subMap);\n",
        "861": "    }\n",
        "862": "\n",
        "863": "    @Override\n",
        "864": "    public Iterator<K> iterator() {\n",
        "865": "      final Iterator<Map.Entry<K, Collection<V>>> entryIterator = map().entrySet().iterator();\n",
        "866": "      return new Iterator<K>() {\n",
        "867": "        Map.Entry<K, Collection<V>> entry;\n",
        "868": "\n",
        "869": "        @Override\n",
        "870": "        public boolean hasNext() {\n",
        "871": "          return entryIterator.hasNext();\n",
        "872": "        }\n",
        "873": "\n",
        "874": "        @Override\n",
        "875": "        public K next() {\n",
        "876": "          entry = entryIterator.next();\n",
        "877": "          return entry.getKey();\n",
        "878": "        }\n",
        "879": "\n",
        "880": "        @Override\n",
        "881": "        public void remove() {\n",
        "882": "          checkRemove(entry != null);\n",
        "883": "          Collection<V> collection = entry.getValue();\n",
        "884": "          entryIterator.remove();\n",
        "885": "          totalSize -= collection.size();\n",
        "886": "          collection.clear();\n",
        "887": "        }\n",
        "888": "      };\n",
        "889": "    }\n",
        "890": "\n",
        "891": "    // The following methods are included for better performance.\n",
        "892": "\n",
        "893": "    @Override\n",
        "894": "    public boolean remove(Object key) {\n",
        "895": "      int count = 0;\n",
        "896": "      Collection<V> collection = map().remove(key);\n",
        "897": "      if (collection != null) {\n",
        "898": "        count = collection.size();\n",
        "899": "        collection.clear();\n",
        "900": "        totalSize -= count;\n",
        "901": "      }\n",
        "902": "      return count > 0;\n",
        "903": "    }\n",
        "904": "\n",
        "905": "    @Override\n",
        "906": "    public void clear() {\n",
        "907": "      Iterators.clear(iterator());\n",
        "908": "    }\n",
        "909": "\n",
        "910": "    @Override\n",
        "911": "    public boolean containsAll(Collection<?> c) {\n",
        "912": "      return map().keySet().containsAll(c);\n",
        "913": "    }\n",
        "914": "\n",
        "915": "    @Override\n",
        "916": "    public boolean equals(@Nullable Object object) {\n",
        "917": "      return this == object || this.map().keySet().equals(object);\n",
        "918": "    }\n",
        "919": "\n",
        "920": "    @Override\n",
        "921": "    public int hashCode() {\n",
        "922": "      return map().keySet().hashCode();\n",
        "923": "    }\n",
        "924": "  }\n",
        "925": "\n",
        "926": "  @WeakOuter\n",
        "927": "  private class SortedKeySet extends KeySet implements SortedSet<K> {\n",
        "928": "\n",
        "929": "    SortedKeySet(SortedMap<K, Collection<V>> subMap) {\n",
        "930": "      super(subMap);\n",
        "931": "    }\n",
        "932": "\n",
        "933": "    SortedMap<K, Collection<V>> sortedMap() {\n",
        "934": "      return (SortedMap<K, Collection<V>>) super.map();\n",
        "935": "    }\n",
        "936": "\n",
        "937": "    @Override\n",
        "938": "    public Comparator<? super K> comparator() {\n",
        "939": "      return sortedMap().comparator();\n",
        "940": "    }\n",
        "941": "\n",
        "942": "    @Override\n",
        "943": "    public K first() {\n",
        "944": "      return sortedMap().firstKey();\n",
        "945": "    }\n",
        "946": "\n",
        "947": "    @Override\n",
        "948": "    public SortedSet<K> headSet(K toElement) {\n",
        "949": "      return new SortedKeySet(sortedMap().headMap(toElement));\n",
        "950": "    }\n",
        "951": "\n",
        "952": "    @Override\n",
        "953": "    public K last() {\n",
        "954": "      return sortedMap().lastKey();\n",
        "955": "    }\n",
        "956": "\n",
        "957": "    @Override\n",
        "958": "    public SortedSet<K> subSet(K fromElement, K toElement) {\n",
        "959": "      return new SortedKeySet(sortedMap().subMap(fromElement, toElement));\n",
        "960": "    }\n",
        "961": "\n",
        "962": "    @Override\n",
        "963": "    public SortedSet<K> tailSet(K fromElement) {\n",
        "964": "      return new SortedKeySet(sortedMap().tailMap(fromElement));\n",
        "965": "    }\n",
        "966": "  }\n",
        "967": "\n",
        "968": "  /**\n",
        "969": "   * Removes all values for the provided key. Unlike {@link #removeAll}, it\n",
        "970": "   * returns the number of removed mappings.\n",
        "971": "   */\n",
        "972": "  private int removeValuesForKey(Object key) {\n",
        "973": "    Collection<V> collection = Maps.safeRemove(map, key);\n",
        "974": "\n",
        "975": "    int count = 0;\n",
        "976": "    if (collection != null) {\n",
        "977": "      count = collection.size();\n",
        "978": "      collection.clear();\n",
        "979": "      totalSize -= count;\n",
        "980": "    }\n",
        "981": "    return count;\n",
        "982": "  }\n",
        "983": "\n",
        "984": "  private abstract class Itr<T> implements Iterator<T> {\n",
        "985": "    final Iterator<Map.Entry<K, Collection<V>>> keyIterator;\n",
        "986": "    K key;\n",
        "987": "    Collection<V> collection;\n",
        "988": "    Iterator<V> valueIterator;\n",
        "989": "\n",
        "990": "    Itr() {\n",
        "991": "      keyIterator = map.entrySet().iterator();\n",
        "992": "      key = null;\n",
        "993": "      collection = null;\n",
        "994": "      valueIterator = Iterators.emptyModifiableIterator();\n",
        "995": "    }\n",
        "996": "\n",
        "997": "    abstract T output(K key, V value);\n",
        "998": "\n",
        "999": "    @Override\n",
        "1000": "    public boolean hasNext() {\n",
        "1001": "      return keyIterator.hasNext() || valueIterator.hasNext();\n",
        "1002": "    }\n",
        "1003": "\n",
        "1004": "    @Override\n",
        "1005": "    public T next() {\n",
        "1006": "      if (!valueIterator.hasNext()) {\n",
        "1007": "        Map.Entry<K, Collection<V>> mapEntry = keyIterator.next();\n",
        "1008": "        key = mapEntry.getKey();\n",
        "1009": "        collection = mapEntry.getValue();\n",
        "1010": "        valueIterator = collection.iterator();\n",
        "1011": "      }\n",
        "1012": "      return output(key, valueIterator.next());\n",
        "1013": "    }\n",
        "1014": "\n",
        "1015": "    @Override\n",
        "1016": "    public void remove() {\n",
        "1017": "      valueIterator.remove();\n",
        "1018": "      if (collection.isEmpty()) {\n",
        "1019": "        keyIterator.remove();\n",
        "1020": "      }\n",
        "1021": "      totalSize--;\n",
        "1022": "    }\n",
        "1023": "  }\n",
        "1024": "\n",
        "1025": "  /**\n",
        "1026": "   * {@inheritDoc}\n",
        "1027": "   *\n",
        "1028": "   * <p>The iterator generated by the returned collection traverses the values\n",
        "1029": "   * for one key, followed by the values of a second key, and so on.\n",
        "1030": "   */\n",
        "1031": "  @Override\n",
        "1032": "  public Collection<V> values() {\n",
        "1033": "    return super.values();\n",
        "1034": "  }\n",
        "1035": "\n",
        "1036": "  @Override\n",
        "1037": "  Iterator<V> valueIterator() {\n",
        "1038": "    return new Itr<V>() {\n",
        "1039": "      @Override\n",
        "1040": "      V output(K key, V value) {\n",
        "1041": "        return value;\n",
        "1042": "      }\n",
        "1043": "    };\n",
        "1044": "  }\n",
        "1045": "\n",
        "1046": "  /*\n",
        "1047": "   * TODO(kevinb): should we copy this javadoc to each concrete class, so that\n",
        "1048": "   * classes like LinkedHashMultimap that need to say something different are\n",
        "1049": "   * still able to {@inheritDoc} all the way from Multimap?\n",
        "1050": "   */\n",
        "1051": "\n",
        "1052": "  /**\n",
        "1053": "   * {@inheritDoc}\n",
        "1054": "   *\n",
        "1055": "   * <p>The iterator generated by the returned collection traverses the values\n",
        "1056": "   * for one key, followed by the values of a second key, and so on.\n",
        "1057": "   *\n",
        "1058": "   * <p>Each entry is an immutable snapshot of a key-value mapping in the\n",
        "1059": "   * multimap, taken at the time the entry is returned by a method call to the\n",
        "1060": "   * collection or its iterator.\n",
        "1061": "   */\n",
        "1062": "  @Override\n",
        "1063": "  public Collection<Map.Entry<K, V>> entries() {\n",
        "1064": "    return super.entries();\n",
        "1065": "  }\n",
        "1066": "\n",
        "1067": "  /**\n",
        "1068": "   * Returns an iterator across all key-value map entries, used by {@code\n",
        "1069": "   * entries().iterator()} and {@code values().iterator()}. The default\n",
        "1070": "   * behavior, which traverses the values for one key, the values for a second\n",
        "1071": "   * key, and so on, suffices for most {@code AbstractMapBasedMultimap} implementations.\n",
        "1072": "   *\n",
        "1073": "   * @return an iterator across map entries\n",
        "1074": "   */\n",
        "1075": "  @Override\n",
        "1076": "  Iterator<Map.Entry<K, V>> entryIterator() {\n",
        "1077": "    return new Itr<Map.Entry<K, V>>() {\n",
        "1078": "      @Override\n",
        "1079": "      Entry<K, V> output(K key, V value) {\n",
        "1080": "        return Maps.immutableEntry(key, value);\n",
        "1081": "      }\n",
        "1082": "    };\n",
        "1083": "  }\n",
        "1084": "\n",
        "1085": "  @Override\n",
        "1086": "  Map<K, Collection<V>> createAsMap() {\n",
        "1087": "    // TreeMultimap uses NavigableAsMap explicitly, but we don't handle that here for GWT\n",
        "1088": "    // compatibility reasons\n",
        "1089": "    return (map instanceof SortedMap)\n",
        "1090": "        ? new SortedAsMap((SortedMap<K, Collection<V>>) map)\n",
        "1091": "        : new AsMap(map);\n",
        "1092": "  }\n",
        "1093": "\n",
        "1094": "  @WeakOuter\n",
        "1095": "  private class AsMap extends ViewCachingAbstractMap<K, Collection<V>> {\n",
        "1096": "    /**\n",
        "1097": "     * Usually the same as map, but smaller for the headMap(), tailMap(), or\n",
        "1098": "     * subMap() of a SortedAsMap.\n",
        "1099": "     */\n",
        "1100": "    final transient Map<K, Collection<V>> submap;\n",
        "1101": "\n",
        "1102": "    AsMap(Map<K, Collection<V>> submap) {\n",
        "1103": "      this.submap = submap;\n",
        "1104": "    }\n",
        "1105": "\n",
        "1106": "    @Override\n",
        "1107": "    protected Set<Entry<K, Collection<V>>> createEntrySet() {\n",
        "1108": "      return new AsMapEntries();\n",
        "1109": "    }\n",
        "1110": "\n",
        "1111": "    // The following methods are included for performance.\n",
        "1112": "\n",
        "1113": "    @Override\n",
        "1114": "    public boolean containsKey(Object key) {\n",
        "1115": "      return Maps.safeContainsKey(submap, key);\n",
        "1116": "    }\n",
        "1117": "\n",
        "1118": "    @Override\n",
        "1119": "    public Collection<V> get(Object key) {\n",
        "1120": "      Collection<V> collection = Maps.safeGet(submap, key);\n",
        "1121": "      if (collection == null) {\n",
        "1122": "        return null;\n",
        "1123": "      }\n",
        "1124": "      @SuppressWarnings(\"unchecked\")\n",
        "1125": "      K k = (K) key;\n",
        "1126": "      return wrapCollection(k, collection);\n",
        "1127": "    }\n",
        "1128": "\n",
        "1129": "    @Override\n",
        "1130": "    public Set<K> keySet() {\n",
        "1131": "      return AbstractMapBasedMultimap.this.keySet();\n",
        "1132": "    }\n",
        "1133": "\n",
        "1134": "    @Override\n",
        "1135": "    public int size() {\n",
        "1136": "      return submap.size();\n",
        "1137": "    }\n",
        "1138": "\n",
        "1139": "    @Override\n",
        "1140": "    public Collection<V> remove(Object key) {\n",
        "1141": "      Collection<V> collection = submap.remove(key);\n",
        "1142": "      if (collection == null) {\n",
        "1143": "        return null;\n",
        "1144": "      }\n",
        "1145": "\n",
        "1146": "      Collection<V> output = createCollection();\n",
        "1147": "      output.addAll(collection);\n",
        "1148": "      totalSize -= collection.size();\n",
        "1149": "      collection.clear();\n",
        "1150": "      return output;\n",
        "1151": "    }\n",
        "1152": "\n",
        "1153": "    @Override\n",
        "1154": "    public boolean equals(@Nullable Object object) {\n",
        "1155": "      return this == object || submap.equals(object);\n",
        "1156": "    }\n",
        "1157": "\n",
        "1158": "    @Override\n",
        "1159": "    public int hashCode() {\n",
        "1160": "      return submap.hashCode();\n",
        "1161": "    }\n",
        "1162": "\n",
        "1163": "    @Override\n",
        "1164": "    public String toString() {\n",
        "1165": "      return submap.toString();\n",
        "1166": "    }\n",
        "1167": "\n",
        "1168": "    @Override\n",
        "1169": "    public void clear() {\n",
        "1170": "      if (submap == map) {\n",
        "1171": "        AbstractMapBasedMultimap.this.clear();\n",
        "1172": "      } else {\n",
        "1173": "        Iterators.clear(new AsMapIterator());\n",
        "1174": "      }\n",
        "1175": "    }\n",
        "1176": "\n",
        "1177": "    Entry<K, Collection<V>> wrapEntry(Entry<K, Collection<V>> entry) {\n",
        "1178": "      K key = entry.getKey();\n",
        "1179": "      return Maps.immutableEntry(key, wrapCollection(key, entry.getValue()));\n",
        "1180": "    }\n",
        "1181": "\n",
        "1182": "    @WeakOuter\n",
        "1183": "    class AsMapEntries extends Maps.EntrySet<K, Collection<V>> {\n",
        "1184": "      @Override\n",
        "1185": "      Map<K, Collection<V>> map() {\n",
        "1186": "        return AsMap.this;\n",
        "1187": "      }\n",
        "1188": "\n",
        "1189": "      @Override\n",
        "1190": "      public Iterator<Map.Entry<K, Collection<V>>> iterator() {\n",
        "1191": "        return new AsMapIterator();\n",
        "1192": "      }\n",
        "1193": "\n",
        "1194": "      // The following methods are included for performance.\n",
        "1195": "\n",
        "1196": "      @Override\n",
        "1197": "      public boolean contains(Object o) {\n",
        "1198": "        return Collections2.safeContains(submap.entrySet(), o);\n",
        "1199": "      }\n",
        "1200": "\n",
        "1201": "      @Override\n",
        "1202": "      public boolean remove(Object o) {\n",
        "1203": "        if (!contains(o)) {\n",
        "1204": "          return false;\n",
        "1205": "        }\n",
        "1206": "        Map.Entry<?, ?> entry = (Map.Entry<?, ?>) o;\n",
        "1207": "        removeValuesForKey(entry.getKey());\n",
        "1208": "        return true;\n",
        "1209": "      }\n",
        "1210": "    }\n",
        "1211": "\n",
        "1212": "    /** Iterator across all keys and value collections. */\n",
        "1213": "    class AsMapIterator implements Iterator<Map.Entry<K, Collection<V>>> {\n",
        "1214": "      final Iterator<Map.Entry<K, Collection<V>>> delegateIterator = submap.entrySet().iterator();\n",
        "1215": "      Collection<V> collection;\n",
        "1216": "\n",
        "1217": "      @Override\n",
        "1218": "      public boolean hasNext() {\n",
        "1219": "        return delegateIterator.hasNext();\n",
        "1220": "      }\n",
        "1221": "\n",
        "1222": "      @Override\n",
        "1223": "      public Map.Entry<K, Collection<V>> next() {\n",
        "1224": "        Map.Entry<K, Collection<V>> entry = delegateIterator.next();\n",
        "1225": "        collection = entry.getValue();\n",
        "1226": "        return wrapEntry(entry);\n",
        "1227": "      }\n",
        "1228": "\n",
        "1229": "      @Override\n",
        "1230": "      public void remove() {\n",
        "1231": "        delegateIterator.remove();\n",
        "1232": "        totalSize -= collection.size();\n",
        "1233": "        collection.clear();\n",
        "1234": "      }\n",
        "1235": "    }\n",
        "1236": "  }\n",
        "1237": "\n",
        "1238": "  @WeakOuter\n",
        "1239": "  private class SortedAsMap extends AsMap implements SortedMap<K, Collection<V>> {\n",
        "1240": "    SortedAsMap(SortedMap<K, Collection<V>> submap) {\n",
        "1241": "      super(submap);\n",
        "1242": "    }\n",
        "1243": "\n",
        "1244": "    SortedMap<K, Collection<V>> sortedMap() {\n",
        "1245": "      return (SortedMap<K, Collection<V>>) submap;\n",
        "1246": "    }\n",
        "1247": "\n",
        "1248": "    @Override\n",
        "1249": "    public Comparator<? super K> comparator() {\n",
        "1250": "      return sortedMap().comparator();\n",
        "1251": "    }\n",
        "1252": "\n",
        "1253": "    @Override\n",
        "1254": "    public K firstKey() {\n",
        "1255": "      return sortedMap().firstKey();\n",
        "1256": "    }\n",
        "1257": "\n",
        "1258": "    @Override\n",
        "1259": "    public K lastKey() {\n",
        "1260": "      return sortedMap().lastKey();\n",
        "1261": "    }\n",
        "1262": "\n",
        "1263": "    @Override\n",
        "1264": "    public SortedMap<K, Collection<V>> headMap(K toKey) {\n",
        "1265": "      return new SortedAsMap(sortedMap().headMap(toKey));\n",
        "1266": "    }\n",
        "1267": "\n",
        "1268": "    @Override\n",
        "1269": "    public SortedMap<K, Collection<V>> subMap(K fromKey, K toKey) {\n",
        "1270": "      return new SortedAsMap(sortedMap().subMap(fromKey, toKey));\n",
        "1271": "    }\n",
        "1272": "\n",
        "1273": "    @Override\n",
        "1274": "    public SortedMap<K, Collection<V>> tailMap(K fromKey) {\n",
        "1275": "      return new SortedAsMap(sortedMap().tailMap(fromKey));\n",
        "1276": "    }\n",
        "1277": "\n",
        "1278": "    SortedSet<K> sortedKeySet;\n",
        "1279": "\n",
        "1280": "    // returns a SortedSet, even though returning a Set would be sufficient to\n",
        "1281": "    // satisfy the SortedMap.keySet() interface\n",
        "1282": "    @Override\n",
        "1283": "    public SortedSet<K> keySet() {\n",
        "1284": "      SortedSet<K> result = sortedKeySet;\n",
        "1285": "      return (result == null) ? sortedKeySet = createKeySet() : result;\n",
        "1286": "    }\n",
        "1287": "\n",
        "1288": "    @Override\n",
        "1289": "    SortedSet<K> createKeySet() {\n",
        "1290": "      return new SortedKeySet(sortedMap());\n",
        "1291": "    }\n",
        "1292": "  }\n",
        "1293": "\n",
        "1294": "  private static final long serialVersionUID = 2447537837011683357L;\n",
        "1295": "}\n",
        "1296": "\n"
    }
}