{
    "addition": {},
    "removed": {
        "1": "/*\n",
        "2": " * Copyright (C) 2012 The Guava Authors\n",
        "3": " *\n",
        "4": " * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not use this file except\n",
        "5": " * in compliance with the License. You may obtain a copy of the License at\n",
        "6": " *\n",
        "7": " * http://www.apache.org/licenses/LICENSE-2.0\n",
        "8": " *\n",
        "9": " * Unless required by applicable law or agreed to in writing, software distributed under the License\n",
        "10": " * is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express\n",
        "11": " * or implied. See the License for the specific language governing permissions and limitations under\n",
        "12": " * the License.\n",
        "13": " */\n",
        "14": "\n",
        "15": "package com.google.common.io;\n",
        "16": "\n",
        "17": "import static com.google.common.io.BaseEncoding.base16;\n",
        "18": "import static com.google.common.io.BaseEncoding.base32;\n",
        "19": "import static com.google.common.io.BaseEncoding.base32Hex;\n",
        "20": "import static com.google.common.io.BaseEncoding.base64;\n",
        "21": "import static com.google.common.truth.Truth.assertThat;\n",
        "22": "\n",
        "23": "import com.google.common.annotations.GwtCompatible;\n",
        "24": "import com.google.common.base.Ascii;\n",
        "25": "import com.google.common.base.Joiner;\n",
        "26": "import com.google.common.base.Splitter;\n",
        "27": "import com.google.common.collect.ImmutableList;\n",
        "28": "import com.google.common.io.BaseEncoding.DecodingException;\n",
        "29": "\n",
        "30": "import junit.framework.TestCase;\n",
        "31": "\n",
        "32": "import java.io.UnsupportedEncodingException;\n",
        "33": "\n",
        "34": "import javax.annotation.Nullable;\n",
        "35": "\n",
        "36": "/**\n",
        "37": " * Tests for {@code BaseEncoding}.\n",
        "38": " *\n",
        "39": " * @author Louis Wasserman\n",
        "40": " */\n",
        "41": "@GwtCompatible(emulated = true)\n",
        "42": "public class BaseEncodingTest extends TestCase {\n",
        "43": "  public static void assertEquals(byte[] expected, byte[] actual) {\n",
        "44": "    assertEquals(expected.length, actual.length);\n",
        "45": "    for (int i = 0; i < expected.length; i++) {\n",
        "46": "      assertEquals(expected[i], actual[i]);\n",
        "47": "    }\n",
        "48": "  }\n",
        "49": "\n",
        "50": "  public void testSeparatorsExplicitly() {\n",
        "51": "    testEncodes(base64().withSeparator(\"\\n\", 3), \"foobar\", \"Zm9\\nvYm\\nFy\");\n",
        "52": "    testEncodes(base64().withSeparator(\"$\", 4), \"foobar\", \"Zm9v$YmFy\");\n",
        "53": "    testEncodes(base32().withSeparator(\"*\", 4), \"foobar\", \"MZXW*6YTB*OI==*====\");\n",
        "54": "  }\n",
        "55": "\n",
        "56": "  @SuppressWarnings(\"ReturnValueIgnored\")\n",
        "57": "  public void testSeparatorSameAsPadChar() {\n",
        "58": "    try {\n",
        "59": "      base64().withSeparator(\"=\", 3);\n",
        "60": "      fail(\"Expected IllegalArgumentException\");\n",
        "61": "    } catch (IllegalArgumentException expected) {}\n",
        "62": "\n",
        "63": "    try {\n",
        "64": "      base64().withPadChar('#').withSeparator(\"!#!\", 3);\n",
        "65": "      fail(\"Expected IllegalArgumentException\");\n",
        "66": "    } catch (IllegalArgumentException expected) {}\n",
        "67": "  }\n",
        "68": "\n",
        "69": "  @SuppressWarnings(\"ReturnValueIgnored\")\n",
        "70": "  public void testAtMostOneSeparator() {\n",
        "71": "    BaseEncoding separated = base64().withSeparator(\"\\n\", 3);\n",
        "72": "    try {\n",
        "73": "      separated.withSeparator(\"$\", 4);\n",
        "74": "      fail(\"Expected UnsupportedOperationException\");\n",
        "75": "    } catch (UnsupportedOperationException expected) {}\n",
        "76": "  }\n",
        "77": "\n",
        "78": "  public void testBase64() {\n",
        "79": "    // The following test vectors are specified in RFC 4648 itself\n",
        "80": "    testEncodingWithSeparators(base64(), \"\", \"\");\n",
        "81": "    testEncodingWithSeparators(base64(), \"f\", \"Zg==\");\n",
        "82": "    testEncodingWithSeparators(base64(), \"fo\", \"Zm8=\");\n",
        "83": "    testEncodingWithSeparators(base64(), \"foo\", \"Zm9v\");\n",
        "84": "    testEncodingWithSeparators(base64(), \"foob\", \"Zm9vYg==\");\n",
        "85": "    testEncodingWithSeparators(base64(), \"fooba\", \"Zm9vYmE=\");\n",
        "86": "    testEncodingWithSeparators(base64(), \"foobar\", \"Zm9vYmFy\");\n",
        "87": "  }\n",
        "88": "\n",
        "89": "  public void testBase64LenientPadding() {\n",
        "90": "    testDecodes(base64(), \"Zg\", \"f\");\n",
        "91": "    testDecodes(base64(), \"Zg=\", \"f\");\n",
        "92": "    testDecodes(base64(), \"Zg==\", \"f\"); // proper padding length\n",
        "93": "    testDecodes(base64(), \"Zg===\", \"f\");\n",
        "94": "    testDecodes(base64(), \"Zg====\", \"f\");\n",
        "95": "  }\n",
        "96": "\n",
        "97": "  public void testBase64InvalidDecodings() {\n",
        "98": "    // These contain bytes not in the decodabet.\n",
        "99": "    assertFailsToDecode(base64(), \"A\\u007f\", \"Unrecognized character: 0x7f\");\n",
        "100": "    assertFailsToDecode(base64(), \"Wf2!\", \"Unrecognized character: !\");\n",
        "101": "    // This sentence just isn't base64() encoded.\n",
        "102": "    assertFailsToDecode(base64(), \"let's not talk of love or chains!\");\n",
        "103": "    // A 4n+1 length string is never legal base64().\n",
        "104": "    assertFailsToDecode(base64(), \"12345\", \"Invalid input length 5\");\n",
        "105": "    // These have a combination of invalid length, unrecognized characters and wrong padding.\n",
        "106": "    assertFailsToDecode(base64(), \"AB=C\", \"Unrecognized character: =\");\n",
        "107": "    assertFailsToDecode(base64(), \"A=BCD\", \"Invalid input length 5\");\n",
        "108": "    assertFailsToDecode(base64(), \"?\", \"Invalid input length 1\");\n",
        "109": "  }\n",
        "110": "\n",
        "111": "  @SuppressWarnings(\"ReturnValueIgnored\")\n",
        "112": "  public void testBase64CannotUpperCase() {\n",
        "113": "    try {\n",
        "114": "      base64().upperCase();\n",
        "115": "      fail();\n",
        "116": "    } catch (IllegalStateException expected) {\n",
        "117": "      // success\n",
        "118": "    }\n",
        "119": "  }\n",
        "120": "\n",
        "121": "  @SuppressWarnings(\"ReturnValueIgnored\")\n",
        "122": "  public void testBase64CannotLowerCase() {\n",
        "123": "    try {\n",
        "124": "      base64().lowerCase();\n",
        "125": "      fail();\n",
        "126": "    } catch (IllegalStateException expected) {\n",
        "127": "      // success\n",
        "128": "    }\n",
        "129": "  }\n",
        "130": "\n",
        "131": "  public void testBase64AlternatePadding() {\n",
        "132": "    BaseEncoding enc = base64().withPadChar('~');\n",
        "133": "    testEncodingWithSeparators(enc, \"\", \"\");\n",
        "134": "    testEncodingWithSeparators(enc, \"f\", \"Zg~~\");\n",
        "135": "    testEncodingWithSeparators(enc, \"fo\", \"Zm8~\");\n",
        "136": "    testEncodingWithSeparators(enc, \"foo\", \"Zm9v\");\n",
        "137": "    testEncodingWithSeparators(enc, \"foob\", \"Zm9vYg~~\");\n",
        "138": "    testEncodingWithSeparators(enc, \"fooba\", \"Zm9vYmE~\");\n",
        "139": "    testEncodingWithSeparators(enc, \"foobar\", \"Zm9vYmFy\");\n",
        "140": "  }\n",
        "141": "\n",
        "142": "  public void testBase64OmitPadding() {\n",
        "143": "    BaseEncoding enc = base64().omitPadding();\n",
        "144": "    testEncodingWithSeparators(enc, \"\", \"\");\n",
        "145": "    testEncodingWithSeparators(enc, \"f\", \"Zg\");\n",
        "146": "    testEncodingWithSeparators(enc, \"fo\", \"Zm8\");\n",
        "147": "    testEncodingWithSeparators(enc, \"foo\", \"Zm9v\");\n",
        "148": "    testEncodingWithSeparators(enc, \"foob\", \"Zm9vYg\");\n",
        "149": "    testEncodingWithSeparators(enc, \"fooba\", \"Zm9vYmE\");\n",
        "150": "    testEncodingWithSeparators(enc, \"foobar\", \"Zm9vYmFy\");\n",
        "151": "  }\n",
        "152": "\n",
        "153": "  public void testBase64Offset() {\n",
        "154": "    testEncodesWithOffset(base64(), \"foobar\", 0, 6, \"Zm9vYmFy\");\n",
        "155": "    testEncodesWithOffset(base64(), \"foobar\", 1, 5, \"b29iYXI=\");\n",
        "156": "    testEncodesWithOffset(base64(), \"foobar\", 2, 3, \"b2Jh\");\n",
        "157": "    testEncodesWithOffset(base64(), \"foobar\", 3, 1, \"Yg==\");\n",
        "158": "    testEncodesWithOffset(base64(), \"foobar\", 4, 0, \"\");\n",
        "159": "  }\n",
        "160": "\n",
        "161": "  public void testBase32() {\n",
        "162": "    // The following test vectors are specified in RFC 4648 itself\n",
        "163": "    testEncodingWithCasing(base32(), \"\", \"\");\n",
        "164": "    testEncodingWithCasing(base32(), \"f\", \"MY======\");\n",
        "165": "    testEncodingWithCasing(base32(), \"fo\", \"MZXQ====\");\n",
        "166": "    testEncodingWithCasing(base32(), \"foo\", \"MZXW6===\");\n",
        "167": "    testEncodingWithCasing(base32(), \"foob\", \"MZXW6YQ=\");\n",
        "168": "    testEncodingWithCasing(base32(), \"fooba\", \"MZXW6YTB\");\n",
        "169": "    testEncodingWithCasing(base32(), \"foobar\", \"MZXW6YTBOI======\");\n",
        "170": "  }\n",
        "171": "\n",
        "172": "  public void testBase32LenientPadding() {\n",
        "173": "    testDecodes(base32(), \"MZXW6\", \"foo\");\n",
        "174": "    testDecodes(base32(), \"MZXW6=\", \"foo\");\n",
        "175": "    testDecodes(base32(), \"MZXW6==\", \"foo\");\n",
        "176": "    testDecodes(base32(), \"MZXW6===\", \"foo\"); // proper padding length\n",
        "177": "    testDecodes(base32(), \"MZXW6====\", \"foo\");\n",
        "178": "    testDecodes(base32(), \"MZXW6=====\", \"foo\");\n",
        "179": "  }\n",
        "180": "\n",
        "181": "  public void testBase32AlternatePadding() {\n",
        "182": "    BaseEncoding enc = base32().withPadChar('~');\n",
        "183": "    testEncodingWithCasing(enc, \"\", \"\");\n",
        "184": "    testEncodingWithCasing(enc, \"f\", \"MY~~~~~~\");\n",
        "185": "    testEncodingWithCasing(enc, \"fo\", \"MZXQ~~~~\");\n",
        "186": "    testEncodingWithCasing(enc, \"foo\", \"MZXW6~~~\");\n",
        "187": "    testEncodingWithCasing(enc, \"foob\", \"MZXW6YQ~\");\n",
        "188": "    testEncodingWithCasing(enc, \"fooba\", \"MZXW6YTB\");\n",
        "189": "    testEncodingWithCasing(enc, \"foobar\", \"MZXW6YTBOI~~~~~~\");\n",
        "190": "  }\n",
        "191": "\n",
        "192": "  public void testBase32InvalidDecodings() {\n",
        "193": "    // These contain bytes not in the decodabet.\n",
        "194": "    assertFailsToDecode(base32(), \"A \", \"Unrecognized character: 0x20\");\n",
        "195": "    assertFailsToDecode(base32(), \"Wf2!\", \"Unrecognized character: f\");\n",
        "196": "    // This sentence just isn't base32() encoded.\n",
        "197": "    assertFailsToDecode(base32(), \"let's not talk of love or chains!\");\n",
        "198": "    // An 8n+{1,3,6} length string is never legal base32.\n",
        "199": "    assertFailsToDecode(base32(), \"A\", \"Invalid input length 1\");\n",
        "200": "    assertFailsToDecode(base32(), \"ABC\");\n",
        "201": "    assertFailsToDecode(base32(), \"ABCDEF\");\n",
        "202": "    // These have a combination of invalid length, unrecognized characters and wrong padding.\n",
        "203": "    assertFailsToDecode(base32(), \"AB=C\", \"Unrecognized character: =\");\n",
        "204": "    assertFailsToDecode(base32(), \"A=BCDE\", \"Invalid input length 6\");\n",
        "205": "    assertFailsToDecode(base32(), \"?\", \"Invalid input length 1\");\n",
        "206": "  }\n",
        "207": "\n",
        "208": "  public void testBase32UpperCaseIsNoOp() {\n",
        "209": "    assertSame(base32(), base32().upperCase());\n",
        "210": "  }\n",
        "211": "\n",
        "212": "  public void testBase32Offset() {\n",
        "213": "    testEncodesWithOffset(base32(), \"foobar\", 0, 6, \"MZXW6YTBOI======\");\n",
        "214": "    testEncodesWithOffset(base32(), \"foobar\", 1, 5, \"N5XWEYLS\");\n",
        "215": "    testEncodesWithOffset(base32(), \"foobar\", 2, 3, \"N5RGC===\");\n",
        "216": "    testEncodesWithOffset(base32(), \"foobar\", 3, 1, \"MI======\");\n",
        "217": "    testEncodesWithOffset(base32(), \"foobar\", 4, 0, \"\");\n",
        "218": "  }\n",
        "219": "\n",
        "220": "  public void testBase32Hex() {\n",
        "221": "    // The following test vectors are specified in RFC 4648 itself\n",
        "222": "    testEncodingWithCasing(base32Hex(), \"\", \"\");\n",
        "223": "    testEncodingWithCasing(base32Hex(), \"f\", \"CO======\");\n",
        "224": "    testEncodingWithCasing(base32Hex(), \"fo\", \"CPNG====\");\n",
        "225": "    testEncodingWithCasing(base32Hex(), \"foo\", \"CPNMU===\");\n",
        "226": "    testEncodingWithCasing(base32Hex(), \"foob\", \"CPNMUOG=\");\n",
        "227": "    testEncodingWithCasing(base32Hex(), \"fooba\", \"CPNMUOJ1\");\n",
        "228": "    testEncodingWithCasing(base32Hex(), \"foobar\", \"CPNMUOJ1E8======\");\n",
        "229": "  }\n",
        "230": "\n",
        "231": "  public void testBase32HexLenientPadding() {\n",
        "232": "    testDecodes(base32Hex(), \"CPNMU\", \"foo\");\n",
        "233": "    testDecodes(base32Hex(), \"CPNMU=\", \"foo\");\n",
        "234": "    testDecodes(base32Hex(), \"CPNMU==\", \"foo\");\n",
        "235": "    testDecodes(base32Hex(), \"CPNMU===\", \"foo\"); // proper padding length\n",
        "236": "    testDecodes(base32Hex(), \"CPNMU====\", \"foo\");\n",
        "237": "    testDecodes(base32Hex(), \"CPNMU=====\", \"foo\");\n",
        "238": "  }\n",
        "239": "\n",
        "240": "  public void testBase32HexInvalidDecodings() {\n",
        "241": "    // These contain bytes not in the decodabet.\n",
        "242": "    assertFailsToDecode(base32Hex(), \"A\\u007f\", \"Unrecognized character: 0x7f\");\n",
        "243": "    assertFailsToDecode(base32Hex(), \"Wf2!\", \"Unrecognized character: W\");\n",
        "244": "    // This sentence just isn't base32 encoded.\n",
        "245": "    assertFailsToDecode(base32Hex(), \"let's not talk of love or chains!\");\n",
        "246": "    // An 8n+{1,3,6} length string is never legal base32.\n",
        "247": "    assertFailsToDecode(base32Hex(), \"A\");\n",
        "248": "    assertFailsToDecode(base32Hex(), \"ABC\");\n",
        "249": "    assertFailsToDecode(base32Hex(), \"ABCDEF\");\n",
        "250": "  }\n",
        "251": "\n",
        "252": "  public void testBase32HexUpperCaseIsNoOp() {\n",
        "253": "    assertSame(base32Hex(), base32Hex().upperCase());\n",
        "254": "  }\n",
        "255": "\n",
        "256": "  public void testBase16() {\n",
        "257": "    testEncodingWithCasing(base16(), \"\", \"\");\n",
        "258": "    testEncodingWithCasing(base16(), \"f\", \"66\");\n",
        "259": "    testEncodingWithCasing(base16(), \"fo\", \"666F\");\n",
        "260": "    testEncodingWithCasing(base16(), \"foo\", \"666F6F\");\n",
        "261": "    testEncodingWithCasing(base16(), \"foob\", \"666F6F62\");\n",
        "262": "    testEncodingWithCasing(base16(), \"fooba\", \"666F6F6261\");\n",
        "263": "    testEncodingWithCasing(base16(), \"foobar\", \"666F6F626172\");\n",
        "264": "  }\n",
        "265": "\n",
        "266": "  public void testBase16UpperCaseIsNoOp() {\n",
        "267": "    assertSame(base16(), base16().upperCase());\n",
        "268": "  }\n",
        "269": "\n",
        "270": "  public void testBase16InvalidDecodings() {\n",
        "271": "    // These contain bytes not in the decodabet.\n",
        "272": "    assertFailsToDecode(base16(), \"\\n\\n\", \"Unrecognized character: 0xa\");\n",
        "273": "    assertFailsToDecode(base16(), \"EFGH\", \"Unrecognized character: G\");\n",
        "274": "    // Valid base16 strings always have an even length.\n",
        "275": "    assertFailsToDecode(base16(), \"A\", \"Invalid input length 1\");\n",
        "276": "    assertFailsToDecode(base16(), \"ABC\");\n",
        "277": "    // These have a combination of invalid length and unrecognized characters.\n",
        "278": "    assertFailsToDecode(base16(), \"?\", \"Invalid input length 1\");\n",
        "279": "  }\n",
        "280": "\n",
        "281": "  public void testBase16Offset() {\n",
        "282": "    testEncodesWithOffset(base16(), \"foobar\", 0, 6, \"666F6F626172\");\n",
        "283": "    testEncodesWithOffset(base16(), \"foobar\", 1, 5, \"6F6F626172\");\n",
        "284": "    testEncodesWithOffset(base16(), \"foobar\", 2, 3, \"6F6261\");\n",
        "285": "    testEncodesWithOffset(base16(), \"foobar\", 3, 1, \"62\");\n",
        "286": "    testEncodesWithOffset(base16(), \"foobar\", 4, 0, \"\");\n",
        "287": "  }\n",
        "288": "\n",
        "289": "  private static void testEncodingWithCasing(\n",
        "290": "      BaseEncoding encoding, String decoded, String encoded) {\n",
        "291": "    testEncodingWithSeparators(encoding, decoded, encoded);\n",
        "292": "    testEncodingWithSeparators(encoding.upperCase(), decoded, Ascii.toUpperCase(encoded));\n",
        "293": "    testEncodingWithSeparators(encoding.lowerCase(), decoded, Ascii.toLowerCase(encoded));\n",
        "294": "  }\n",
        "295": "\n",
        "296": "  private static void testEncodingWithSeparators(\n",
        "297": "      BaseEncoding encoding, String decoded, String encoded) {\n",
        "298": "    testEncoding(encoding, decoded, encoded);\n",
        "299": "\n",
        "300": "    // test separators work\n",
        "301": "    for (int sepLength = 3; sepLength <= 5; sepLength++) {\n",
        "302": "      for (String separator : ImmutableList.of(\",\", \"\\n\", \";;\", \"\")) {\n",
        "303": "        testEncoding(encoding.withSeparator(separator, sepLength), decoded,\n",
        "304": "            Joiner.on(separator).join(Splitter.fixedLength(sepLength).split(encoded)));\n",
        "305": "      }\n",
        "306": "    }\n",
        "307": "  }\n",
        "308": "\n",
        "309": "  private static void testEncoding(BaseEncoding encoding, String decoded, String encoded) {\n",
        "310": "    testEncodes(encoding, decoded, encoded);\n",
        "311": "    testDecodes(encoding, encoded, decoded);\n",
        "312": "  }\n",
        "313": "\n",
        "314": "  private static void testEncodes(BaseEncoding encoding, String decoded, String encoded) {\n",
        "315": "    assertEquals(encoded, encoding.encode(getBytes(decoded)));\n",
        "316": "  }\n",
        "317": "\n",
        "318": "  private static void testEncodesWithOffset(\n",
        "319": "      BaseEncoding encoding, String decoded, int offset, int len, String encoded) {\n",
        "320": "    assertEquals(encoded, encoding.encode(getBytes(decoded), offset, len));\n",
        "321": "  }\n",
        "322": "\n",
        "323": "  private static void testDecodes(BaseEncoding encoding, String encoded, String decoded) {\n",
        "324": "    assertEquals(getBytes(decoded), encoding.decode(encoded));\n",
        "325": "  }\n",
        "326": "\n",
        "327": "  private static void assertFailsToDecode(BaseEncoding encoding, String cannotDecode) {\n",
        "328": "    assertFailsToDecode(encoding, cannotDecode, null);\n",
        "329": "  }\n",
        "330": "\n",
        "331": "  private static void assertFailsToDecode(\n",
        "332": "      BaseEncoding encoding, String cannotDecode, @Nullable String expectedMessage) {\n",
        "333": "    try {\n",
        "334": "      encoding.decode(cannotDecode);\n",
        "335": "      fail(\"Expected IllegalArgumentException\");\n",
        "336": "    } catch (IllegalArgumentException expected) {\n",
        "337": "      if (expectedMessage != null) {\n",
        "338": "        assertThat(expected.getCause()).hasMessage(expectedMessage);\n",
        "339": "      }\n",
        "340": "    }\n",
        "341": "    try {\n",
        "342": "      encoding.decodeChecked(cannotDecode);\n",
        "343": "      fail(\"Expected DecodingException\");\n",
        "344": "    } catch (DecodingException expected) {\n",
        "345": "      if (expectedMessage != null) {\n",
        "346": "        assertThat(expected).hasMessage(expectedMessage);\n",
        "347": "      }\n",
        "348": "    }\n",
        "349": "  }\n",
        "350": "\n",
        "351": "  private static byte[] getBytes(String decoded) {\n",
        "352": "    try {\n",
        "353": "      // GWT does not support String.getBytes(Charset)\n",
        "354": "      return decoded.getBytes(\"UTF-8\");\n",
        "355": "    } catch (UnsupportedEncodingException e) {\n",
        "356": "      throw new AssertionError();\n",
        "357": "    }\n",
        "358": "  }\n",
        "359": "\n",
        "360": "  public void testToString() {\n",
        "361": "    assertEquals(\"BaseEncoding.base64().withPadChar(=)\", BaseEncoding.base64().toString());\n",
        "362": "    assertEquals(\"BaseEncoding.base32Hex().omitPadding()\",\n",
        "363": "        BaseEncoding.base32Hex().omitPadding().toString());\n",
        "364": "    assertEquals(\"BaseEncoding.base32().lowerCase().withPadChar($)\",\n",
        "365": "        BaseEncoding.base32().lowerCase().withPadChar('$').toString());\n",
        "366": "    assertEquals(\"BaseEncoding.base16().withSeparator(\\\"\\n\\\", 10)\",\n",
        "367": "        BaseEncoding.base16().withSeparator(\"\\n\", 10).toString());\n",
        "368": "  }\n",
        "369": "}\n",
        "370": "\n"
    }
}