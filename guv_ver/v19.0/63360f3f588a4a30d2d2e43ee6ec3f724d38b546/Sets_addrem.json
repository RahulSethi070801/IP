{
    "addition": {},
    "removed": {
        "1": "/*\n",
        "2": " * Copyright (C) 2007 The Guava Authors\n",
        "3": " *\n",
        "4": " * Licensed under the Apache License, Version 2.0 (the \"License\");\n",
        "5": " * you may not use this file except in compliance with the License.\n",
        "6": " * You may obtain a copy of the License at\n",
        "7": " *\n",
        "8": " * http://www.apache.org/licenses/LICENSE-2.0\n",
        "9": " *\n",
        "10": " * Unless required by applicable law or agreed to in writing, software\n",
        "11": " * distributed under the License is distributed on an \"AS IS\" BASIS,\n",
        "12": " * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n",
        "13": " * See the License for the specific language governing permissions and\n",
        "14": " * limitations under the License.\n",
        "15": " */\n",
        "16": "\n",
        "17": "package com.google.common.collect;\n",
        "18": "\n",
        "19": "import static com.google.common.base.Preconditions.checkArgument;\n",
        "20": "import static com.google.common.base.Preconditions.checkNotNull;\n",
        "21": "\n",
        "22": "import com.google.common.annotations.GwtCompatible;\n",
        "23": "import com.google.common.base.Predicate;\n",
        "24": "import com.google.common.base.Predicates;\n",
        "25": "import com.google.common.collect.Collections2.FilteredCollection;\n",
        "26": "\n",
        "27": "import java.util.AbstractSet;\n",
        "28": "import java.util.Arrays;\n",
        "29": "import java.util.Collection;\n",
        "30": "import java.util.Collections;\n",
        "31": "import java.util.Comparator;\n",
        "32": "import java.util.EnumSet;\n",
        "33": "import java.util.HashSet;\n",
        "34": "import java.util.Iterator;\n",
        "35": "import java.util.LinkedHashSet;\n",
        "36": "import java.util.List;\n",
        "37": "import java.util.Map;\n",
        "38": "import java.util.NoSuchElementException;\n",
        "39": "import java.util.Set;\n",
        "40": "import java.util.SortedSet;\n",
        "41": "import java.util.TreeSet;\n",
        "42": "import java.util.concurrent.ConcurrentHashMap;\n",
        "43": "\n",
        "44": "import javax.annotation.CheckReturnValue;\n",
        "45": "import javax.annotation.Nullable;\n",
        "46": "\n",
        "47": "/**\n",
        "48": " * Static utility methods pertaining to {@link Set} instances. Also see this\n",
        "49": " * class's counterparts {@link Lists}, {@link Maps} and {@link Queues}.\n",
        "50": " *\n",
        "51": " * <p>See the Guava User Guide article on <a href=\n",
        "52": " * \"https://github.com/google/guava/wiki/CollectionUtilitiesExplained#sets\">\n",
        "53": " * {@code Sets}</a>.\n",
        "54": " *\n",
        "55": " * @author Kevin Bourrillion\n",
        "56": " * @author Jared Levy\n",
        "57": " * @author Chris Povirk\n",
        "58": " * @since 2.0\n",
        "59": " */\n",
        "60": "@GwtCompatible(emulated = true)\n",
        "61": "public final class Sets {\n",
        "62": "  private Sets() {}\n",
        "63": "\n",
        "64": "  /**\n",
        "65": "   * {@link AbstractSet} substitute without the potentially-quadratic\n",
        "66": "   * {@code removeAll} implementation.\n",
        "67": "   */\n",
        "68": "  abstract static class ImprovedAbstractSet<E> extends AbstractSet<E> {\n",
        "69": "    @Override\n",
        "70": "    public boolean removeAll(Collection<?> c) {\n",
        "71": "      return removeAllImpl(this, c);\n",
        "72": "    }\n",
        "73": "\n",
        "74": "    @Override\n",
        "75": "    public boolean retainAll(Collection<?> c) {\n",
        "76": "      return super.retainAll(checkNotNull(c)); // GWT compatibility\n",
        "77": "    }\n",
        "78": "  }\n",
        "79": "\n",
        "80": "  /**\n",
        "81": "   * Returns an immutable set instance containing the given enum elements.\n",
        "82": "   * Internally, the returned set will be backed by an {@link EnumSet}.\n",
        "83": "   *\n",
        "84": "   * <p>The iteration order of the returned set follows the enum's iteration\n",
        "85": "   * order, not the order in which the elements are provided to the method.\n",
        "86": "   *\n",
        "87": "   * @param anElement one of the elements the set should contain\n",
        "88": "   * @param otherElements the rest of the elements the set should contain\n",
        "89": "   * @return an immutable set containing those elements, minus duplicates\n",
        "90": "   */\n",
        "91": "  // http://code.google.com/p/google-web-toolkit/issues/detail?id=3028\n",
        "92": "  @GwtCompatible(serializable = true)\n",
        "93": "  public static <E extends Enum<E>> ImmutableSet<E> immutableEnumSet(\n",
        "94": "      E anElement, E... otherElements) {\n",
        "95": "    return ImmutableEnumSet.asImmutable(EnumSet.of(anElement, otherElements));\n",
        "96": "  }\n",
        "97": "\n",
        "98": "  /**\n",
        "99": "   * Returns an immutable set instance containing the given enum elements.\n",
        "100": "   * Internally, the returned set will be backed by an {@link EnumSet}.\n",
        "101": "   *\n",
        "102": "   * <p>The iteration order of the returned set follows the enum's iteration\n",
        "103": "   * order, not the order in which the elements appear in the given collection.\n",
        "104": "   *\n",
        "105": "   * @param elements the elements, all of the same {@code enum} type, that the\n",
        "106": "   *     set should contain\n",
        "107": "   * @return an immutable set containing those elements, minus duplicates\n",
        "108": "   */\n",
        "109": "  // http://code.google.com/p/google-web-toolkit/issues/detail?id=3028\n",
        "110": "  @GwtCompatible(serializable = true)\n",
        "111": "  public static <E extends Enum<E>> ImmutableSet<E> immutableEnumSet(Iterable<E> elements) {\n",
        "112": "    if (elements instanceof ImmutableEnumSet) {\n",
        "113": "      return (ImmutableEnumSet<E>) elements;\n",
        "114": "    } else if (elements instanceof Collection) {\n",
        "115": "      Collection<E> collection = (Collection<E>) elements;\n",
        "116": "      if (collection.isEmpty()) {\n",
        "117": "        return ImmutableSet.of();\n",
        "118": "      } else {\n",
        "119": "        return ImmutableEnumSet.asImmutable(EnumSet.copyOf(collection));\n",
        "120": "      }\n",
        "121": "    } else {\n",
        "122": "      Iterator<E> itr = elements.iterator();\n",
        "123": "      if (itr.hasNext()) {\n",
        "124": "        EnumSet<E> enumSet = EnumSet.of(itr.next());\n",
        "125": "        Iterators.addAll(enumSet, itr);\n",
        "126": "        return ImmutableEnumSet.asImmutable(enumSet);\n",
        "127": "      } else {\n",
        "128": "        return ImmutableSet.of();\n",
        "129": "      }\n",
        "130": "    }\n",
        "131": "  }\n",
        "132": "\n",
        "133": "  /**\n",
        "134": "   * Returns a new, <i>mutable</i> {@code EnumSet} instance containing the given elements in their\n",
        "135": "   * natural order. This method behaves identically to {@link EnumSet#copyOf(Collection)}, but also\n",
        "136": "   * accepts non-{@code Collection} iterables and empty iterables.\n",
        "137": "   */\n",
        "138": "  public static <E extends Enum<E>> EnumSet<E> newEnumSet(\n",
        "139": "      Iterable<E> iterable, Class<E> elementType) {\n",
        "140": "    EnumSet<E> set = EnumSet.noneOf(elementType);\n",
        "141": "    Iterables.addAll(set, iterable);\n",
        "142": "    return set;\n",
        "143": "  }\n",
        "144": "\n",
        "145": "  // HashSet\n",
        "146": "\n",
        "147": "  /**\n",
        "148": "   * Creates a <i>mutable</i>, initially empty {@code HashSet} instance.\n",
        "149": "   *\n",
        "150": "   * <p><b>Note:</b> if mutability is not required, use {@link ImmutableSet#of()} instead. If\n",
        "151": "   * {@code E} is an {@link Enum} type, use {@link EnumSet#noneOf} instead. Otherwise, strongly\n",
        "152": "   * consider using a {@code LinkedHashSet} instead, at the cost of increased memory footprint, to\n",
        "153": "   * get deterministic iteration behavior.\n",
        "154": "   *\n",
        "155": "   * <p><b>Note for Java 7 and later:</b> this method is now unnecessary and should be treated as\n",
        "156": "   * deprecated. Instead, use the {@code HashSet} constructor directly, taking advantage of the new\n",
        "157": "   * <a href=\"http://goo.gl/iz2Wi\">\"diamond\" syntax</a>.\n",
        "158": "   */\n",
        "159": "  public static <E> HashSet<E> newHashSet() {\n",
        "160": "    return new HashSet<E>();\n",
        "161": "  }\n",
        "162": "\n",
        "163": "  /**\n",
        "164": "   * Creates a <i>mutable</i> {@code HashSet} instance initially containing the given elements.\n",
        "165": "   *\n",
        "166": "   * <p><b>Note:</b> if elements are non-null and won't be added or removed after this point, use\n",
        "167": "   * {@link ImmutableSet#of()} or {@link ImmutableSet#copyOf(Object[])} instead. If {@code E} is an\n",
        "168": "   * {@link Enum} type, use {@link EnumSet#of(Enum, Enum[])} instead. Otherwise, strongly consider\n",
        "169": "   * using a {@code LinkedHashSet} instead, at the cost of increased memory footprint, to get\n",
        "170": "   * deterministic iteration behavior.\n",
        "171": "   *\n",
        "172": "   * <p>This method is just a small convenience, either for {@code newHashSet(}{@link Arrays#asList\n",
        "173": "   * asList}{@code (...))}, or for creating an empty set then calling {@link Collections#addAll}.\n",
        "174": "   * This method is not actually very useful and will likely be deprecated in the future.\n",
        "175": "   */\n",
        "176": "  public static <E> HashSet<E> newHashSet(E... elements) {\n",
        "177": "    HashSet<E> set = newHashSetWithExpectedSize(elements.length);\n",
        "178": "    Collections.addAll(set, elements);\n",
        "179": "    return set;\n",
        "180": "  }\n",
        "181": "\n",
        "182": "  /**\n",
        "183": "   * Creates a {@code HashSet} instance, with a high enough initial table size that it <i>should</i>\n",
        "184": "   * hold {@code expectedSize} elements without resizing. This behavior cannot be broadly\n",
        "185": "   * guaranteed, but it is observed to be true for OpenJDK 1.7. It also can't be guaranteed that the\n",
        "186": "   * method isn't inadvertently <i>oversizing</i> the returned set.\n",
        "187": "   *\n",
        "188": "   * @param expectedSize the number of elements you expect to add to the\n",
        "189": "   *        returned set\n",
        "190": "   * @return a new, empty {@code HashSet} with enough capacity to hold {@code\n",
        "191": "   *         expectedSize} elements without resizing\n",
        "192": "   * @throws IllegalArgumentException if {@code expectedSize} is negative\n",
        "193": "   */\n",
        "194": "  public static <E> HashSet<E> newHashSetWithExpectedSize(int expectedSize) {\n",
        "195": "    return new HashSet<E>(Maps.capacity(expectedSize));\n",
        "196": "  }\n",
        "197": "\n",
        "198": "  /**\n",
        "199": "   * Creates a <i>mutable</i> {@code HashSet} instance containing the given elements. A very thin\n",
        "200": "   * convenience for creating an empty set then calling {@link Collection#addAll} or {@link\n",
        "201": "   * Iterables#addAll}.\n",
        "202": "   *\n",
        "203": "   * <p><b>Note:</b> if mutability is not required and the elements are non-null, use {@link\n",
        "204": "   * ImmutableSet#copyOf(Iterable)} instead. (Or, change {@code elements} to be a {@link\n",
        "205": "   * FluentIterable} and call {@code elements.toSet()}.)\n",
        "206": "   *\n",
        "207": "   * <p><b>Note:</b> if {@code E} is an {@link Enum} type, use {@link #newEnumSet(Iterable, Class)}\n",
        "208": "   * instead.\n",
        "209": "   *\n",
        "210": "   * <p><b>Note for Java 7 and later:</b> if {@code elements} is a {@link Collection}, you don't\n",
        "211": "   * need this method. Instead, use the {@code HashSet} constructor directly, taking advantage of\n",
        "212": "   * the new <a href=\"http://goo.gl/iz2Wi\">\"diamond\" syntax</a>.\n",
        "213": "   *\n",
        "214": "   * <p>Overall, this method is not very useful and will likely be deprecated in the future.\n",
        "215": "   */\n",
        "216": "  public static <E> HashSet<E> newHashSet(Iterable<? extends E> elements) {\n",
        "217": "    return (elements instanceof Collection)\n",
        "218": "        ? new HashSet<E>(Collections2.cast(elements))\n",
        "219": "        : newHashSet(elements.iterator());\n",
        "220": "  }\n",
        "221": "\n",
        "222": "  /**\n",
        "223": "   * Creates a <i>mutable</i> {@code HashSet} instance containing the given elements. A very thin\n",
        "224": "   * convenience for creating an empty set and then calling {@link Iterators#addAll}.\n",
        "225": "   *\n",
        "226": "   * <p><b>Note:</b> if mutability is not required and the elements are non-null, use {@link\n",
        "227": "   * ImmutableSet#copyOf(Iterator)} instead.\n",
        "228": "   *\n",
        "229": "   * <p><b>Note:</b> if {@code E} is an {@link Enum} type, you should create an {@link EnumSet}\n",
        "230": "   * instead.\n",
        "231": "   *\n",
        "232": "   * <p>Overall, this method is not very useful and will likely be deprecated in the future.\n",
        "233": "   */\n",
        "234": "  public static <E> HashSet<E> newHashSet(Iterator<? extends E> elements) {\n",
        "235": "    HashSet<E> set = newHashSet();\n",
        "236": "    Iterators.addAll(set, elements);\n",
        "237": "    return set;\n",
        "238": "  }\n",
        "239": "\n",
        "240": "  /**\n",
        "241": "   * Creates a thread-safe set backed by a hash map. The set is backed by a\n",
        "242": "   * {@link ConcurrentHashMap} instance, and thus carries the same concurrency\n",
        "243": "   * guarantees.\n",
        "244": "   *\n",
        "245": "   * <p>Unlike {@code HashSet}, this class does NOT allow {@code null} to be\n",
        "246": "   * used as an element. The set is serializable.\n",
        "247": "   *\n",
        "248": "   * @return a new, empty thread-safe {@code Set}\n",
        "249": "   * @since 15.0\n",
        "250": "   */\n",
        "251": "  public static <E> Set<E> newConcurrentHashSet() {\n",
        "252": "    return newSetFromMap(new ConcurrentHashMap<E, Boolean>());\n",
        "253": "  }\n",
        "254": "\n",
        "255": "  /**\n",
        "256": "   * Creates a thread-safe set backed by a hash map and containing the given\n",
        "257": "   * elements. The set is backed by a {@link ConcurrentHashMap} instance, and\n",
        "258": "   * thus carries the same concurrency guarantees.\n",
        "259": "   *\n",
        "260": "   * <p>Unlike {@code HashSet}, this class does NOT allow {@code null} to be\n",
        "261": "   * used as an element. The set is serializable.\n",
        "262": "   *\n",
        "263": "   * @param elements the elements that the set should contain\n",
        "264": "   * @return a new thread-safe set containing those elements (minus duplicates)\n",
        "265": "   * @throws NullPointerException if {@code elements} or any of its contents is\n",
        "266": "   *      null\n",
        "267": "   * @since 15.0\n",
        "268": "   */\n",
        "269": "  public static <E> Set<E> newConcurrentHashSet(Iterable<? extends E> elements) {\n",
        "270": "    Set<E> set = newConcurrentHashSet();\n",
        "271": "    Iterables.addAll(set, elements);\n",
        "272": "    return set;\n",
        "273": "  }\n",
        "274": "\n",
        "275": "  // LinkedHashSet\n",
        "276": "\n",
        "277": "  /**\n",
        "278": "   * Creates a <i>mutable</i>, empty {@code LinkedHashSet} instance.\n",
        "279": "   *\n",
        "280": "   * <p><b>Note:</b> if mutability is not required, use {@link\n",
        "281": "   * ImmutableSet#of()} instead.\n",
        "282": "   *\n",
        "283": "   * @return a new, empty {@code LinkedHashSet}\n",
        "284": "   */\n",
        "285": "  public static <E> LinkedHashSet<E> newLinkedHashSet() {\n",
        "286": "    return new LinkedHashSet<E>();\n",
        "287": "  }\n",
        "288": "\n",
        "289": "  /**\n",
        "290": "   * Creates a {@code LinkedHashSet} instance, with a high enough \"initial\n",
        "291": "   * capacity\" that it <i>should</i> hold {@code expectedSize} elements without\n",
        "292": "   * growth. This behavior cannot be broadly guaranteed, but it is observed to\n",
        "293": "   * be true for OpenJDK 1.6. It also can't be guaranteed that the method isn't\n",
        "294": "   * inadvertently <i>oversizing</i> the returned set.\n",
        "295": "   *\n",
        "296": "   * @param expectedSize the number of elements you expect to add to the\n",
        "297": "   *        returned set\n",
        "298": "   * @return a new, empty {@code LinkedHashSet} with enough capacity to hold\n",
        "299": "   *         {@code expectedSize} elements without resizing\n",
        "300": "   * @throws IllegalArgumentException if {@code expectedSize} is negative\n",
        "301": "   * @since 11.0\n",
        "302": "   */\n",
        "303": "  public static <E> LinkedHashSet<E> newLinkedHashSetWithExpectedSize(int expectedSize) {\n",
        "304": "    return new LinkedHashSet<E>(Maps.capacity(expectedSize));\n",
        "305": "  }\n",
        "306": "\n",
        "307": "  /**\n",
        "308": "   * Creates a <i>mutable</i> {@code LinkedHashSet} instance containing the\n",
        "309": "   * given elements in order.\n",
        "310": "   *\n",
        "311": "   * <p><b>Note:</b> if mutability is not required and the elements are\n",
        "312": "   * non-null, use {@link ImmutableSet#copyOf(Iterable)} instead.\n",
        "313": "   *\n",
        "314": "   * @param elements the elements that the set should contain, in order\n",
        "315": "   * @return a new {@code LinkedHashSet} containing those elements (minus\n",
        "316": "   *     duplicates)\n",
        "317": "   */\n",
        "318": "  public static <E> LinkedHashSet<E> newLinkedHashSet(Iterable<? extends E> elements) {\n",
        "319": "    if (elements instanceof Collection) {\n",
        "320": "      return new LinkedHashSet<E>(Collections2.cast(elements));\n",
        "321": "    }\n",
        "322": "    LinkedHashSet<E> set = newLinkedHashSet();\n",
        "323": "    Iterables.addAll(set, elements);\n",
        "324": "    return set;\n",
        "325": "  }\n",
        "326": "\n",
        "327": "  // TreeSet\n",
        "328": "\n",
        "329": "  /**\n",
        "330": "   * Creates a <i>mutable</i>, empty {@code TreeSet} instance sorted by the\n",
        "331": "   * natural sort ordering of its elements.\n",
        "332": "   *\n",
        "333": "   * <p><b>Note:</b> if mutability is not required, use {@link\n",
        "334": "   * ImmutableSortedSet#of()} instead.\n",
        "335": "   *\n",
        "336": "   * @return a new, empty {@code TreeSet}\n",
        "337": "   */\n",
        "338": "  public static <E extends Comparable> TreeSet<E> newTreeSet() {\n",
        "339": "    return new TreeSet<E>();\n",
        "340": "  }\n",
        "341": "\n",
        "342": "  /**\n",
        "343": "   * Creates a <i>mutable</i> {@code TreeSet} instance containing the given\n",
        "344": "   * elements sorted by their natural ordering.\n",
        "345": "   *\n",
        "346": "   * <p><b>Note:</b> if mutability is not required, use {@link\n",
        "347": "   * ImmutableSortedSet#copyOf(Iterable)} instead.\n",
        "348": "   *\n",
        "349": "   * <p><b>Note:</b> If {@code elements} is a {@code SortedSet} with an explicit\n",
        "350": "   * comparator, this method has different behavior than\n",
        "351": "   * {@link TreeSet#TreeSet(SortedSet)}, which returns a {@code TreeSet} with\n",
        "352": "   * that comparator.\n",
        "353": "   *\n",
        "354": "   * @param elements the elements that the set should contain\n",
        "355": "   * @return a new {@code TreeSet} containing those elements (minus duplicates)\n",
        "356": "   */\n",
        "357": "  public static <E extends Comparable> TreeSet<E> newTreeSet(Iterable<? extends E> elements) {\n",
        "358": "    TreeSet<E> set = newTreeSet();\n",
        "359": "    Iterables.addAll(set, elements);\n",
        "360": "    return set;\n",
        "361": "  }\n",
        "362": "\n",
        "363": "  /**\n",
        "364": "   * Creates a <i>mutable</i>, empty {@code TreeSet} instance with the given\n",
        "365": "   * comparator.\n",
        "366": "   *\n",
        "367": "   * <p><b>Note:</b> if mutability is not required, use {@code\n",
        "368": "   * ImmutableSortedSet.orderedBy(comparator).build()} instead.\n",
        "369": "   *\n",
        "370": "   * @param comparator the comparator to use to sort the set\n",
        "371": "   * @return a new, empty {@code TreeSet}\n",
        "372": "   * @throws NullPointerException if {@code comparator} is null\n",
        "373": "   */\n",
        "374": "  public static <E> TreeSet<E> newTreeSet(Comparator<? super E> comparator) {\n",
        "375": "    return new TreeSet<E>(checkNotNull(comparator));\n",
        "376": "  }\n",
        "377": "\n",
        "378": "  /**\n",
        "379": "   * Creates an empty {@code Set} that uses identity to determine equality. It\n",
        "380": "   * compares object references, instead of calling {@code equals}, to\n",
        "381": "   * determine whether a provided object matches an element in the set. For\n",
        "382": "   * example, {@code contains} returns {@code false} when passed an object that\n",
        "383": "   * equals a set member, but isn't the same instance. This behavior is similar\n",
        "384": "   * to the way {@code IdentityHashMap} handles key lookups.\n",
        "385": "   *\n",
        "386": "   * @since 8.0\n",
        "387": "   */\n",
        "388": "  public static <E> Set<E> newIdentityHashSet() {\n",
        "389": "    return Sets.newSetFromMap(Maps.<E, Boolean>newIdentityHashMap());\n",
        "390": "  }\n",
        "391": "\n",
        "392": "  /**\n",
        "393": "   * Creates an {@code EnumSet} consisting of all enum values that are not in\n",
        "394": "   * the specified collection. If the collection is an {@link EnumSet}, this\n",
        "395": "   * method has the same behavior as {@link EnumSet#complementOf}. Otherwise,\n",
        "396": "   * the specified collection must contain at least one element, in order to\n",
        "397": "   * determine the element type. If the collection could be empty, use\n",
        "398": "   * {@link #complementOf(Collection, Class)} instead of this method.\n",
        "399": "   *\n",
        "400": "   * @param collection the collection whose complement should be stored in the\n",
        "401": "   *     enum set\n",
        "402": "   * @return a new, modifiable {@code EnumSet} containing all values of the enum\n",
        "403": "   *     that aren't present in the given collection\n",
        "404": "   * @throws IllegalArgumentException if {@code collection} is not an\n",
        "405": "   *     {@code EnumSet} instance and contains no elements\n",
        "406": "   */\n",
        "407": "  public static <E extends Enum<E>> EnumSet<E> complementOf(Collection<E> collection) {\n",
        "408": "    if (collection instanceof EnumSet) {\n",
        "409": "      return EnumSet.complementOf((EnumSet<E>) collection);\n",
        "410": "    }\n",
        "411": "    checkArgument(\n",
        "412": "        !collection.isEmpty(), \"collection is empty; use the other version of this method\");\n",
        "413": "    Class<E> type = collection.iterator().next().getDeclaringClass();\n",
        "414": "    return makeComplementByHand(collection, type);\n",
        "415": "  }\n",
        "416": "\n",
        "417": "  /**\n",
        "418": "   * Creates an {@code EnumSet} consisting of all enum values that are not in\n",
        "419": "   * the specified collection. This is equivalent to\n",
        "420": "   * {@link EnumSet#complementOf}, but can act on any input collection, as long\n",
        "421": "   * as the elements are of enum type.\n",
        "422": "   *\n",
        "423": "   * @param collection the collection whose complement should be stored in the\n",
        "424": "   *     {@code EnumSet}\n",
        "425": "   * @param type the type of the elements in the set\n",
        "426": "   * @return a new, modifiable {@code EnumSet} initially containing all the\n",
        "427": "   *     values of the enum not present in the given collection\n",
        "428": "   */\n",
        "429": "  public static <E extends Enum<E>> EnumSet<E> complementOf(\n",
        "430": "      Collection<E> collection, Class<E> type) {\n",
        "431": "    checkNotNull(collection);\n",
        "432": "    return (collection instanceof EnumSet)\n",
        "433": "        ? EnumSet.complementOf((EnumSet<E>) collection)\n",
        "434": "        : makeComplementByHand(collection, type);\n",
        "435": "  }\n",
        "436": "\n",
        "437": "  private static <E extends Enum<E>> EnumSet<E> makeComplementByHand(\n",
        "438": "      Collection<E> collection, Class<E> type) {\n",
        "439": "    EnumSet<E> result = EnumSet.allOf(type);\n",
        "440": "    result.removeAll(collection);\n",
        "441": "    return result;\n",
        "442": "  }\n",
        "443": "\n",
        "444": "  /**\n",
        "445": "   * Returns a set backed by the specified map. The resulting set displays\n",
        "446": "   * the same ordering, concurrency, and performance characteristics as the\n",
        "447": "   * backing map. In essence, this factory method provides a {@link Set}\n",
        "448": "   * implementation corresponding to any {@link Map} implementation. There is no\n",
        "449": "   * need to use this method on a {@link Map} implementation that already has a\n",
        "450": "   * corresponding {@link Set} implementation (such as {@link java.util.HashMap}\n",
        "451": "   * or {@link java.util.TreeMap}).\n",
        "452": "   *\n",
        "453": "   * <p>Each method invocation on the set returned by this method results in\n",
        "454": "   * exactly one method invocation on the backing map or its {@code keySet}\n",
        "455": "   * view, with one exception. The {@code addAll} method is implemented as a\n",
        "456": "   * sequence of {@code put} invocations on the backing map.\n",
        "457": "   *\n",
        "458": "   * <p>The specified map must be empty at the time this method is invoked,\n",
        "459": "   * and should not be accessed directly after this method returns. These\n",
        "460": "   * conditions are ensured if the map is created empty, passed directly\n",
        "461": "   * to this method, and no reference to the map is retained, as illustrated\n",
        "462": "   * in the following code fragment: <pre>  {@code\n",
        "463": "   *\n",
        "464": "   *   Set<Object> identityHashSet = Sets.newSetFromMap(\n",
        "465": "   *       new IdentityHashMap<Object, Boolean>());}</pre>\n",
        "466": "   *\n",
        "467": "   * <p>The returned set is serializable if the backing map is.\n",
        "468": "   *\n",
        "469": "   * @param map the backing map\n",
        "470": "   * @return the set backed by the map\n",
        "471": "   * @throws IllegalArgumentException if {@code map} is not empty\n",
        "472": "   * @deprecated Use {@link Collections#newSetFromMap} instead. This method\n",
        "473": "   *     will be removed in August 2017.\n",
        "474": "   */\n",
        "475": "  @Deprecated\n",
        "476": "  public static <E> Set<E> newSetFromMap(Map<E, Boolean> map) {\n",
        "477": "    return Platform.newSetFromMap(map);\n",
        "478": "  }\n",
        "479": "\n",
        "480": "  /**\n",
        "481": "   * An unmodifiable view of a set which may be backed by other sets; this view\n",
        "482": "   * will change as the backing sets do. Contains methods to copy the data into\n",
        "483": "   * a new set which will then remain stable. There is usually no reason to\n",
        "484": "   * retain a reference of type {@code SetView}; typically, you either use it\n",
        "485": "   * as a plain {@link Set}, or immediately invoke {@link #immutableCopy} or\n",
        "486": "   * {@link #copyInto} and forget the {@code SetView} itself.\n",
        "487": "   *\n",
        "488": "   * @since 2.0\n",
        "489": "   */\n",
        "490": "  public abstract static class SetView<E> extends AbstractSet<E> {\n",
        "491": "    private SetView() {} // no subclasses but our own\n",
        "492": "\n",
        "493": "    /**\n",
        "494": "     * Returns an immutable copy of the current contents of this set view.\n",
        "495": "     * Does not support null elements.\n",
        "496": "     *\n",
        "497": "     * <p><b>Warning:</b> this may have unexpected results if a backing set of\n",
        "498": "     * this view uses a nonstandard notion of equivalence, for example if it is\n",
        "499": "     * a {@link TreeSet} using a comparator that is inconsistent with {@link\n",
        "500": "     * Object#equals(Object)}.\n",
        "501": "     */\n",
        "502": "    public ImmutableSet<E> immutableCopy() {\n",
        "503": "      return ImmutableSet.copyOf(this);\n",
        "504": "    }\n",
        "505": "\n",
        "506": "    /**\n",
        "507": "     * Copies the current contents of this set view into an existing set. This\n",
        "508": "     * method has equivalent behavior to {@code set.addAll(this)}, assuming that\n",
        "509": "     * all the sets involved are based on the same notion of equivalence.\n",
        "510": "     *\n",
        "511": "     * @return a reference to {@code set}, for convenience\n",
        "512": "     */\n",
        "513": "    // Note: S should logically extend Set<? super E> but can't due to either\n",
        "514": "    // some javac bug or some weirdness in the spec, not sure which.\n",
        "515": "    public <S extends Set<E>> S copyInto(S set) {\n",
        "516": "      set.addAll(this);\n",
        "517": "      return set;\n",
        "518": "    }\n",
        "519": "  }\n",
        "520": "\n",
        "521": "  /**\n",
        "522": "   * Returns an unmodifiable <b>view</b> of the union of two sets. The returned\n",
        "523": "   * set contains all elements that are contained in either backing set.\n",
        "524": "   * Iterating over the returned set iterates first over all the elements of\n",
        "525": "   * {@code set1}, then over each element of {@code set2}, in order, that is not\n",
        "526": "   * contained in {@code set1}.\n",
        "527": "   *\n",
        "528": "   * <p>Results are undefined if {@code set1} and {@code set2} are sets based on\n",
        "529": "   * different equivalence relations (as {@link HashSet}, {@link TreeSet}, and\n",
        "530": "   * the {@link Map#keySet} of an {@code IdentityHashMap} all are).\n",
        "531": "   *\n",
        "532": "   * <p><b>Note:</b> The returned view performs better when {@code set1} is the\n",
        "533": "   * smaller of the two sets. If you have reason to believe one of your sets\n",
        "534": "   * will generally be smaller than the other, pass it first.\n",
        "535": "   *\n",
        "536": "   * <p>Further, note that the current implementation is not suitable for nested\n",
        "537": "   * {@code union} views, i.e. the following should be avoided when in a loop:\n",
        "538": "   * {@code union = Sets.union(union, anotherSet);}, since iterating over the resulting\n",
        "539": "   * set has a cubic complexity to the depth of the nesting.\n",
        "540": "   */\n",
        "541": "  public static <E> SetView<E> union(final Set<? extends E> set1, final Set<? extends E> set2) {\n",
        "542": "    checkNotNull(set1, \"set1\");\n",
        "543": "    checkNotNull(set2, \"set2\");\n",
        "544": "\n",
        "545": "    final Set<? extends E> set2minus1 = difference(set2, set1);\n",
        "546": "\n",
        "547": "    return new SetView<E>() {\n",
        "548": "      @Override\n",
        "549": "      public int size() {\n",
        "550": "        return set1.size() + set2minus1.size();\n",
        "551": "      }\n",
        "552": "\n",
        "553": "      @Override\n",
        "554": "      public boolean isEmpty() {\n",
        "555": "        return set1.isEmpty() && set2.isEmpty();\n",
        "556": "      }\n",
        "557": "\n",
        "558": "      @Override\n",
        "559": "      public Iterator<E> iterator() {\n",
        "560": "        return Iterators.unmodifiableIterator(\n",
        "561": "            Iterators.concat(set1.iterator(), set2minus1.iterator()));\n",
        "562": "      }\n",
        "563": "\n",
        "564": "      @Override\n",
        "565": "      public boolean contains(Object object) {\n",
        "566": "        return set1.contains(object) || set2.contains(object);\n",
        "567": "      }\n",
        "568": "\n",
        "569": "      @Override\n",
        "570": "      public <S extends Set<E>> S copyInto(S set) {\n",
        "571": "        set.addAll(set1);\n",
        "572": "        set.addAll(set2);\n",
        "573": "        return set;\n",
        "574": "      }\n",
        "575": "\n",
        "576": "      @Override\n",
        "577": "      public ImmutableSet<E> immutableCopy() {\n",
        "578": "        return new ImmutableSet.Builder<E>().addAll(set1).addAll(set2).build();\n",
        "579": "      }\n",
        "580": "    };\n",
        "581": "  }\n",
        "582": "\n",
        "583": "  /**\n",
        "584": "   * Returns an unmodifiable <b>view</b> of the intersection of two sets. The\n",
        "585": "   * returned set contains all elements that are contained by both backing sets.\n",
        "586": "   * The iteration order of the returned set matches that of {@code set1}.\n",
        "587": "   *\n",
        "588": "   * <p>Results are undefined if {@code set1} and {@code set2} are sets based\n",
        "589": "   * on different equivalence relations (as {@code HashSet}, {@code TreeSet},\n",
        "590": "   * and the keySet of an {@code IdentityHashMap} all are).\n",
        "591": "   *\n",
        "592": "   * <p><b>Note:</b> The returned view performs slightly better when {@code\n",
        "593": "   * set1} is the smaller of the two sets. If you have reason to believe one of\n",
        "594": "   * your sets will generally be smaller than the other, pass it first.\n",
        "595": "   * Unfortunately, since this method sets the generic type of the returned set\n",
        "596": "   * based on the type of the first set passed, this could in rare cases force\n",
        "597": "   * you to make a cast, for example: <pre>   {@code\n",
        "598": "   *\n",
        "599": "   *   Set<Object> aFewBadObjects = ...\n",
        "600": "   *   Set<String> manyBadStrings = ...\n",
        "601": "   *\n",
        "602": "   *   // impossible for a non-String to be in the intersection\n",
        "603": "   *   SuppressWarnings(\"unchecked\")\n",
        "604": "   *   Set<String> badStrings = (Set) Sets.intersection(\n",
        "605": "   *       aFewBadObjects, manyBadStrings);}</pre>\n",
        "606": "   *\n",
        "607": "   * <p>This is unfortunate, but should come up only very rarely.\n",
        "608": "   */\n",
        "609": "  public static <E> SetView<E> intersection(final Set<E> set1, final Set<?> set2) {\n",
        "610": "    checkNotNull(set1, \"set1\");\n",
        "611": "    checkNotNull(set2, \"set2\");\n",
        "612": "\n",
        "613": "    final Predicate<Object> inSet2 = Predicates.in(set2);\n",
        "614": "    return new SetView<E>() {\n",
        "615": "      @Override\n",
        "616": "      public Iterator<E> iterator() {\n",
        "617": "        return Iterators.filter(set1.iterator(), inSet2);\n",
        "618": "      }\n",
        "619": "\n",
        "620": "      @Override\n",
        "621": "      public int size() {\n",
        "622": "        return Iterators.size(iterator());\n",
        "623": "      }\n",
        "624": "\n",
        "625": "      @Override\n",
        "626": "      public boolean isEmpty() {\n",
        "627": "        return !iterator().hasNext();\n",
        "628": "      }\n",
        "629": "\n",
        "630": "      @Override\n",
        "631": "      public boolean contains(Object object) {\n",
        "632": "        return set1.contains(object) && set2.contains(object);\n",
        "633": "      }\n",
        "634": "\n",
        "635": "      @Override\n",
        "636": "      public boolean containsAll(Collection<?> collection) {\n",
        "637": "        return set1.containsAll(collection) && set2.containsAll(collection);\n",
        "638": "      }\n",
        "639": "    };\n",
        "640": "  }\n",
        "641": "\n",
        "642": "  /**\n",
        "643": "   * Returns an unmodifiable <b>view</b> of the difference of two sets. The\n",
        "644": "   * returned set contains all elements that are contained by {@code set1} and\n",
        "645": "   * not contained by {@code set2}. {@code set2} may also contain elements not\n",
        "646": "   * present in {@code set1}; these are simply ignored. The iteration order of\n",
        "647": "   * the returned set matches that of {@code set1}.\n",
        "648": "   *\n",
        "649": "   * <p>Results are undefined if {@code set1} and {@code set2} are sets based\n",
        "650": "   * on different equivalence relations (as {@code HashSet}, {@code TreeSet},\n",
        "651": "   * and the keySet of an {@code IdentityHashMap} all are).\n",
        "652": "   */\n",
        "653": "  public static <E> SetView<E> difference(final Set<E> set1, final Set<?> set2) {\n",
        "654": "    checkNotNull(set1, \"set1\");\n",
        "655": "    checkNotNull(set2, \"set2\");\n",
        "656": "\n",
        "657": "    final Predicate<Object> notInSet2 = Predicates.not(Predicates.in(set2));\n",
        "658": "    return new SetView<E>() {\n",
        "659": "      @Override\n",
        "660": "      public Iterator<E> iterator() {\n",
        "661": "        return Iterators.filter(set1.iterator(), notInSet2);\n",
        "662": "      }\n",
        "663": "\n",
        "664": "      @Override\n",
        "665": "      public int size() {\n",
        "666": "        return Iterators.size(iterator());\n",
        "667": "      }\n",
        "668": "\n",
        "669": "      @Override\n",
        "670": "      public boolean isEmpty() {\n",
        "671": "        return set2.containsAll(set1);\n",
        "672": "      }\n",
        "673": "\n",
        "674": "      @Override\n",
        "675": "      public boolean contains(Object element) {\n",
        "676": "        return set1.contains(element) && !set2.contains(element);\n",
        "677": "      }\n",
        "678": "    };\n",
        "679": "  }\n",
        "680": "\n",
        "681": "  /**\n",
        "682": "   * Returns an unmodifiable <b>view</b> of the symmetric difference of two\n",
        "683": "   * sets. The returned set contains all elements that are contained in either\n",
        "684": "   * {@code set1} or {@code set2} but not in both. The iteration order of the\n",
        "685": "   * returned set is undefined.\n",
        "686": "   *\n",
        "687": "   * <p>Results are undefined if {@code set1} and {@code set2} are sets based\n",
        "688": "   * on different equivalence relations (as {@code HashSet}, {@code TreeSet},\n",
        "689": "   * and the keySet of an {@code IdentityHashMap} all are).\n",
        "690": "   *\n",
        "691": "   * @since 3.0\n",
        "692": "   */\n",
        "693": "  public static <E> SetView<E> symmetricDifference(\n",
        "694": "      final Set<? extends E> set1, final Set<? extends E> set2) {\n",
        "695": "    checkNotNull(set1, \"set1\");\n",
        "696": "    checkNotNull(set2, \"set2\");\n",
        "697": "\n",
        "698": "    return new SetView<E>() {\n",
        "699": "      @Override\n",
        "700": "      public Iterator<E> iterator() {\n",
        "701": "        final Iterator<? extends E> itr1 = set1.iterator();\n",
        "702": "        final Iterator<? extends E> itr2 = set2.iterator();\n",
        "703": "        return new AbstractIterator<E>() {\n",
        "704": "          @Override\n",
        "705": "          public E computeNext() {\n",
        "706": "            while (itr1.hasNext()) {\n",
        "707": "              E elem1 = itr1.next();\n",
        "708": "              if (!set2.contains(elem1)) {\n",
        "709": "                return elem1;\n",
        "710": "              }\n",
        "711": "            }\n",
        "712": "            while (itr2.hasNext()) {\n",
        "713": "              E elem2 = itr2.next();\n",
        "714": "              if (!set1.contains(elem2)) {\n",
        "715": "                return elem2;\n",
        "716": "              }\n",
        "717": "            }\n",
        "718": "            return endOfData();\n",
        "719": "          }\n",
        "720": "        };\n",
        "721": "      }\n",
        "722": "\n",
        "723": "      @Override\n",
        "724": "      public int size() {\n",
        "725": "        return Iterators.size(iterator());\n",
        "726": "      }\n",
        "727": "\n",
        "728": "      @Override\n",
        "729": "      public boolean isEmpty() {\n",
        "730": "        return set1.equals(set2);\n",
        "731": "      }\n",
        "732": "\n",
        "733": "      @Override\n",
        "734": "      public boolean contains(Object element) {\n",
        "735": "        return set1.contains(element) ^ set2.contains(element);\n",
        "736": "      }\n",
        "737": "    };\n",
        "738": "  }\n",
        "739": "\n",
        "740": "  /**\n",
        "741": "   * Returns the elements of {@code unfiltered} that satisfy a predicate. The\n",
        "742": "   * returned set is a live view of {@code unfiltered}; changes to one affect\n",
        "743": "   * the other.\n",
        "744": "   *\n",
        "745": "   * <p>The resulting set's iterator does not support {@code remove()}, but all\n",
        "746": "   * other set methods are supported. When given an element that doesn't satisfy\n",
        "747": "   * the predicate, the set's {@code add()} and {@code addAll()} methods throw\n",
        "748": "   * an {@link IllegalArgumentException}. When methods such as {@code\n",
        "749": "   * removeAll()} and {@code clear()} are called on the filtered set, only\n",
        "750": "   * elements that satisfy the filter will be removed from the underlying set.\n",
        "751": "   *\n",
        "752": "   * <p>The returned set isn't threadsafe or serializable, even if\n",
        "753": "   * {@code unfiltered} is.\n",
        "754": "   *\n",
        "755": "   * <p>Many of the filtered set's methods, such as {@code size()}, iterate\n",
        "756": "   * across every element in the underlying set and determine which elements\n",
        "757": "   * satisfy the filter. When a live view is <i>not</i> needed, it may be faster\n",
        "758": "   * to copy {@code Iterables.filter(unfiltered, predicate)} and use the copy.\n",
        "759": "   *\n",
        "760": "   * <p><b>Warning:</b> {@code predicate} must be <i>consistent with equals</i>,\n",
        "761": "   * as documented at {@link Predicate#apply}. Do not provide a predicate such\n",
        "762": "   * as {@code Predicates.instanceOf(ArrayList.class)}, which is inconsistent\n",
        "763": "   * with equals. (See {@link Iterables#filter(Iterable, Class)} for related\n",
        "764": "   * functionality.)\n",
        "765": "   */\n",
        "766": "  // TODO(kevinb): how to omit that last sentence when building GWT javadoc?\n",
        "767": "  @CheckReturnValue\n",
        "768": "  public static <E> Set<E> filter(Set<E> unfiltered, Predicate<? super E> predicate) {\n",
        "769": "    if (unfiltered instanceof SortedSet) {\n",
        "770": "      return filter((SortedSet<E>) unfiltered, predicate);\n",
        "771": "    }\n",
        "772": "    if (unfiltered instanceof FilteredSet) {\n",
        "773": "      // Support clear(), removeAll(), and retainAll() when filtering a filtered\n",
        "774": "      // collection.\n",
        "775": "      FilteredSet<E> filtered = (FilteredSet<E>) unfiltered;\n",
        "776": "      Predicate<E> combinedPredicate = Predicates.<E>and(filtered.predicate, predicate);\n",
        "777": "      return new FilteredSet<E>((Set<E>) filtered.unfiltered, combinedPredicate);\n",
        "778": "    }\n",
        "779": "\n",
        "780": "    return new FilteredSet<E>(checkNotNull(unfiltered), checkNotNull(predicate));\n",
        "781": "  }\n",
        "782": "\n",
        "783": "  private static class FilteredSet<E> extends FilteredCollection<E> implements Set<E> {\n",
        "784": "    FilteredSet(Set<E> unfiltered, Predicate<? super E> predicate) {\n",
        "785": "      super(unfiltered, predicate);\n",
        "786": "    }\n",
        "787": "\n",
        "788": "    @Override\n",
        "789": "    public boolean equals(@Nullable Object object) {\n",
        "790": "      return equalsImpl(this, object);\n",
        "791": "    }\n",
        "792": "\n",
        "793": "    @Override\n",
        "794": "    public int hashCode() {\n",
        "795": "      return hashCodeImpl(this);\n",
        "796": "    }\n",
        "797": "  }\n",
        "798": "\n",
        "799": "  /**\n",
        "800": "   * Returns the elements of a {@code SortedSet}, {@code unfiltered}, that\n",
        "801": "   * satisfy a predicate. The returned set is a live view of {@code unfiltered};\n",
        "802": "   * changes to one affect the other.\n",
        "803": "   *\n",
        "804": "   * <p>The resulting set's iterator does not support {@code remove()}, but all\n",
        "805": "   * other set methods are supported. When given an element that doesn't satisfy\n",
        "806": "   * the predicate, the set's {@code add()} and {@code addAll()} methods throw\n",
        "807": "   * an {@link IllegalArgumentException}. When methods such as\n",
        "808": "   * {@code removeAll()} and {@code clear()} are called on the filtered set,\n",
        "809": "   * only elements that satisfy the filter will be removed from the underlying\n",
        "810": "   * set.\n",
        "811": "   *\n",
        "812": "   * <p>The returned set isn't threadsafe or serializable, even if\n",
        "813": "   * {@code unfiltered} is.\n",
        "814": "   *\n",
        "815": "   * <p>Many of the filtered set's methods, such as {@code size()}, iterate across\n",
        "816": "   * every element in the underlying set and determine which elements satisfy\n",
        "817": "   * the filter. When a live view is <i>not</i> needed, it may be faster to copy\n",
        "818": "   * {@code Iterables.filter(unfiltered, predicate)} and use the copy.\n",
        "819": "   *\n",
        "820": "   * <p><b>Warning:</b> {@code predicate} must be <i>consistent with equals</i>,\n",
        "821": "   * as documented at {@link Predicate#apply}. Do not provide a predicate such as\n",
        "822": "   * {@code Predicates.instanceOf(ArrayList.class)}, which is inconsistent with\n",
        "823": "   * equals. (See {@link Iterables#filter(Iterable, Class)} for related\n",
        "824": "   * functionality.)\n",
        "825": "   *\n",
        "826": "   * @since 11.0\n",
        "827": "   */\n",
        "828": "  @CheckReturnValue\n",
        "829": "  public static <E> SortedSet<E> filter(SortedSet<E> unfiltered, Predicate<? super E> predicate) {\n",
        "830": "    return Platform.setsFilterSortedSet(unfiltered, predicate);\n",
        "831": "  }\n",
        "832": "\n",
        "833": "  static <E> SortedSet<E> filterSortedIgnoreNavigable(\n",
        "834": "      SortedSet<E> unfiltered, Predicate<? super E> predicate) {\n",
        "835": "    if (unfiltered instanceof FilteredSet) {\n",
        "836": "      // Support clear(), removeAll(), and retainAll() when filtering a filtered\n",
        "837": "      // collection.\n",
        "838": "      FilteredSet<E> filtered = (FilteredSet<E>) unfiltered;\n",
        "839": "      Predicate<E> combinedPredicate = Predicates.<E>and(filtered.predicate, predicate);\n",
        "840": "      return new FilteredSortedSet<E>((SortedSet<E>) filtered.unfiltered, combinedPredicate);\n",
        "841": "    }\n",
        "842": "\n",
        "843": "    return new FilteredSortedSet<E>(checkNotNull(unfiltered), checkNotNull(predicate));\n",
        "844": "  }\n",
        "845": "\n",
        "846": "  private static class FilteredSortedSet<E> extends FilteredSet<E> implements SortedSet<E> {\n",
        "847": "\n",
        "848": "    FilteredSortedSet(SortedSet<E> unfiltered, Predicate<? super E> predicate) {\n",
        "849": "      super(unfiltered, predicate);\n",
        "850": "    }\n",
        "851": "\n",
        "852": "    @Override\n",
        "853": "    public Comparator<? super E> comparator() {\n",
        "854": "      return ((SortedSet<E>) unfiltered).comparator();\n",
        "855": "    }\n",
        "856": "\n",
        "857": "    @Override\n",
        "858": "    public SortedSet<E> subSet(E fromElement, E toElement) {\n",
        "859": "      return new FilteredSortedSet<E>(\n",
        "860": "          ((SortedSet<E>) unfiltered).subSet(fromElement, toElement), predicate);\n",
        "861": "    }\n",
        "862": "\n",
        "863": "    @Override\n",
        "864": "    public SortedSet<E> headSet(E toElement) {\n",
        "865": "      return new FilteredSortedSet<E>(((SortedSet<E>) unfiltered).headSet(toElement), predicate);\n",
        "866": "    }\n",
        "867": "\n",
        "868": "    @Override\n",
        "869": "    public SortedSet<E> tailSet(E fromElement) {\n",
        "870": "      return new FilteredSortedSet<E>(((SortedSet<E>) unfiltered).tailSet(fromElement), predicate);\n",
        "871": "    }\n",
        "872": "\n",
        "873": "    @Override\n",
        "874": "    public E first() {\n",
        "875": "      return iterator().next();\n",
        "876": "    }\n",
        "877": "\n",
        "878": "    @Override\n",
        "879": "    public E last() {\n",
        "880": "      SortedSet<E> sortedUnfiltered = (SortedSet<E>) unfiltered;\n",
        "881": "      while (true) {\n",
        "882": "        E element = sortedUnfiltered.last();\n",
        "883": "        if (predicate.apply(element)) {\n",
        "884": "          return element;\n",
        "885": "        }\n",
        "886": "        sortedUnfiltered = sortedUnfiltered.headSet(element);\n",
        "887": "      }\n",
        "888": "    }\n",
        "889": "  }\n",
        "890": "\n",
        "891": "  /**\n",
        "892": "   * Returns every possible list that can be formed by choosing one element\n",
        "893": "   * from each of the given sets in order; the \"n-ary\n",
        "894": "   * <a href=\"http://en.wikipedia.org/wiki/Cartesian_product\">Cartesian\n",
        "895": "   * product</a>\" of the sets. For example: <pre>   {@code\n",
        "896": "   *\n",
        "897": "   *   Sets.cartesianProduct(ImmutableList.of(\n",
        "898": "   *       ImmutableSet.of(1, 2),\n",
        "899": "   *       ImmutableSet.of(\"A\", \"B\", \"C\")))}</pre>\n",
        "900": "   *\n",
        "901": "   * <p>returns a set containing six lists:\n",
        "902": "   *\n",
        "903": "   * <ul>\n",
        "904": "   * <li>{@code ImmutableList.of(1, \"A\")}\n",
        "905": "   * <li>{@code ImmutableList.of(1, \"B\")}\n",
        "906": "   * <li>{@code ImmutableList.of(1, \"C\")}\n",
        "907": "   * <li>{@code ImmutableList.of(2, \"A\")}\n",
        "908": "   * <li>{@code ImmutableList.of(2, \"B\")}\n",
        "909": "   * <li>{@code ImmutableList.of(2, \"C\")}\n",
        "910": "   * </ul>\n",
        "911": "   *\n",
        "912": "   * <p>The result is guaranteed to be in the \"traditional\", lexicographical\n",
        "913": "   * order for Cartesian products that you would get from nesting for loops:\n",
        "914": "   * <pre>   {@code\n",
        "915": "   *\n",
        "916": "   *   for (B b0 : sets.get(0)) {\n",
        "917": "   *     for (B b1 : sets.get(1)) {\n",
        "918": "   *       ...\n",
        "919": "   *       ImmutableList<B> tuple = ImmutableList.of(b0, b1, ...);\n",
        "920": "   *       // operate on tuple\n",
        "921": "   *     }\n",
        "922": "   *   }}</pre>\n",
        "923": "   *\n",
        "924": "   * <p>Note that if any input set is empty, the Cartesian product will also be\n",
        "925": "   * empty. If no sets at all are provided (an empty list), the resulting\n",
        "926": "   * Cartesian product has one element, an empty list (counter-intuitive, but\n",
        "927": "   * mathematically consistent).\n",
        "928": "   *\n",
        "929": "   * <p><i>Performance notes:</i> while the cartesian product of sets of size\n",
        "930": "   * {@code m, n, p} is a set of size {@code m x n x p}, its actual memory\n",
        "931": "   * consumption is much smaller. When the cartesian set is constructed, the\n",
        "932": "   * input sets are merely copied. Only as the resulting set is iterated are the\n",
        "933": "   * individual lists created, and these are not retained after iteration.\n",
        "934": "   *\n",
        "935": "   * @param sets the sets to choose elements from, in the order that\n",
        "936": "   *     the elements chosen from those sets should appear in the resulting\n",
        "937": "   *     lists\n",
        "938": "   * @param <B> any common base class shared by all axes (often just {@link\n",
        "939": "   *     Object})\n",
        "940": "   * @return the Cartesian product, as an immutable set containing immutable\n",
        "941": "   *     lists\n",
        "942": "   * @throws NullPointerException if {@code sets}, any one of the {@code sets},\n",
        "943": "   *     or any element of a provided set is null\n",
        "944": "   * @since 2.0\n",
        "945": "   */\n",
        "946": "  public static <B> Set<List<B>> cartesianProduct(List<? extends Set<? extends B>> sets) {\n",
        "947": "    return CartesianSet.create(sets);\n",
        "948": "  }\n",
        "949": "\n",
        "950": "  /**\n",
        "951": "   * Returns every possible list that can be formed by choosing one element\n",
        "952": "   * from each of the given sets in order; the \"n-ary\n",
        "953": "   * <a href=\"http://en.wikipedia.org/wiki/Cartesian_product\">Cartesian\n",
        "954": "   * product</a>\" of the sets. For example: <pre>   {@code\n",
        "955": "   *\n",
        "956": "   *   Sets.cartesianProduct(\n",
        "957": "   *       ImmutableSet.of(1, 2),\n",
        "958": "   *       ImmutableSet.of(\"A\", \"B\", \"C\"))}</pre>\n",
        "959": "   *\n",
        "960": "   * <p>returns a set containing six lists:\n",
        "961": "   *\n",
        "962": "   * <ul>\n",
        "963": "   * <li>{@code ImmutableList.of(1, \"A\")}\n",
        "964": "   * <li>{@code ImmutableList.of(1, \"B\")}\n",
        "965": "   * <li>{@code ImmutableList.of(1, \"C\")}\n",
        "966": "   * <li>{@code ImmutableList.of(2, \"A\")}\n",
        "967": "   * <li>{@code ImmutableList.of(2, \"B\")}\n",
        "968": "   * <li>{@code ImmutableList.of(2, \"C\")}\n",
        "969": "   * </ul>\n",
        "970": "   *\n",
        "971": "   * <p>The result is guaranteed to be in the \"traditional\", lexicographical\n",
        "972": "   * order for Cartesian products that you would get from nesting for loops:\n",
        "973": "   * <pre>   {@code\n",
        "974": "   *\n",
        "975": "   *   for (B b0 : sets.get(0)) {\n",
        "976": "   *     for (B b1 : sets.get(1)) {\n",
        "977": "   *       ...\n",
        "978": "   *       ImmutableList<B> tuple = ImmutableList.of(b0, b1, ...);\n",
        "979": "   *       // operate on tuple\n",
        "980": "   *     }\n",
        "981": "   *   }}</pre>\n",
        "982": "   *\n",
        "983": "   * <p>Note that if any input set is empty, the Cartesian product will also be\n",
        "984": "   * empty. If no sets at all are provided (an empty list), the resulting\n",
        "985": "   * Cartesian product has one element, an empty list (counter-intuitive, but\n",
        "986": "   * mathematically consistent).\n",
        "987": "   *\n",
        "988": "   * <p><i>Performance notes:</i> while the cartesian product of sets of size\n",
        "989": "   * {@code m, n, p} is a set of size {@code m x n x p}, its actual memory\n",
        "990": "   * consumption is much smaller. When the cartesian set is constructed, the\n",
        "991": "   * input sets are merely copied. Only as the resulting set is iterated are the\n",
        "992": "   * individual lists created, and these are not retained after iteration.\n",
        "993": "   *\n",
        "994": "   * @param sets the sets to choose elements from, in the order that\n",
        "995": "   *     the elements chosen from those sets should appear in the resulting\n",
        "996": "   *     lists\n",
        "997": "   * @param <B> any common base class shared by all axes (often just {@link\n",
        "998": "   *     Object})\n",
        "999": "   * @return the Cartesian product, as an immutable set containing immutable\n",
        "1000": "   *     lists\n",
        "1001": "   * @throws NullPointerException if {@code sets}, any one of the {@code sets},\n",
        "1002": "   *     or any element of a provided set is null\n",
        "1003": "   * @since 2.0\n",
        "1004": "   */\n",
        "1005": "  public static <B> Set<List<B>> cartesianProduct(Set<? extends B>... sets) {\n",
        "1006": "    return cartesianProduct(Arrays.asList(sets));\n",
        "1007": "  }\n",
        "1008": "\n",
        "1009": "  private static final class CartesianSet<E> extends ForwardingCollection<List<E>>\n",
        "1010": "      implements Set<List<E>> {\n",
        "1011": "    private transient final ImmutableList<ImmutableSet<E>> axes;\n",
        "1012": "    private transient final CartesianList<E> delegate;\n",
        "1013": "\n",
        "1014": "    static <E> Set<List<E>> create(List<? extends Set<? extends E>> sets) {\n",
        "1015": "      ImmutableList.Builder<ImmutableSet<E>> axesBuilder =\n",
        "1016": "          new ImmutableList.Builder<ImmutableSet<E>>(sets.size());\n",
        "1017": "      for (Set<? extends E> set : sets) {\n",
        "1018": "        ImmutableSet<E> copy = ImmutableSet.copyOf(set);\n",
        "1019": "        if (copy.isEmpty()) {\n",
        "1020": "          return ImmutableSet.of();\n",
        "1021": "        }\n",
        "1022": "        axesBuilder.add(copy);\n",
        "1023": "      }\n",
        "1024": "      final ImmutableList<ImmutableSet<E>> axes = axesBuilder.build();\n",
        "1025": "      ImmutableList<List<E>> listAxes =\n",
        "1026": "          new ImmutableList<List<E>>() {\n",
        "1027": "            @Override\n",
        "1028": "            public int size() {\n",
        "1029": "              return axes.size();\n",
        "1030": "            }\n",
        "1031": "\n",
        "1032": "            @Override\n",
        "1033": "            public List<E> get(int index) {\n",
        "1034": "              return axes.get(index).asList();\n",
        "1035": "            }\n",
        "1036": "\n",
        "1037": "            @Override\n",
        "1038": "            boolean isPartialView() {\n",
        "1039": "              return true;\n",
        "1040": "            }\n",
        "1041": "          };\n",
        "1042": "      return new CartesianSet<E>(axes, new CartesianList<E>(listAxes));\n",
        "1043": "    }\n",
        "1044": "\n",
        "1045": "    private CartesianSet(ImmutableList<ImmutableSet<E>> axes, CartesianList<E> delegate) {\n",
        "1046": "      this.axes = axes;\n",
        "1047": "      this.delegate = delegate;\n",
        "1048": "    }\n",
        "1049": "\n",
        "1050": "    @Override\n",
        "1051": "    protected Collection<List<E>> delegate() {\n",
        "1052": "      return delegate;\n",
        "1053": "    }\n",
        "1054": "\n",
        "1055": "    @Override\n",
        "1056": "    public boolean equals(@Nullable Object object) {\n",
        "1057": "      // Warning: this is broken if size() == 0, so it is critical that we\n",
        "1058": "      // substitute an empty ImmutableSet to the user in place of this\n",
        "1059": "      if (object instanceof CartesianSet) {\n",
        "1060": "        CartesianSet<?> that = (CartesianSet<?>) object;\n",
        "1061": "        return this.axes.equals(that.axes);\n",
        "1062": "      }\n",
        "1063": "      return super.equals(object);\n",
        "1064": "    }\n",
        "1065": "\n",
        "1066": "    @Override\n",
        "1067": "    public int hashCode() {\n",
        "1068": "      // Warning: this is broken if size() == 0, so it is critical that we\n",
        "1069": "      // substitute an empty ImmutableSet to the user in place of this\n",
        "1070": "\n",
        "1071": "      // It's a weird formula, but tests prove it works.\n",
        "1072": "      int adjust = size() - 1;\n",
        "1073": "      for (int i = 0; i < axes.size(); i++) {\n",
        "1074": "        adjust *= 31;\n",
        "1075": "        adjust = ~~adjust;\n",
        "1076": "        // in GWT, we have to deal with integer overflow carefully\n",
        "1077": "      }\n",
        "1078": "      int hash = 1;\n",
        "1079": "      for (Set<E> axis : axes) {\n",
        "1080": "        hash = 31 * hash + (size() / axis.size() * axis.hashCode());\n",
        "1081": "\n",
        "1082": "        hash = ~~hash;\n",
        "1083": "      }\n",
        "1084": "      hash += adjust;\n",
        "1085": "      return ~~hash;\n",
        "1086": "    }\n",
        "1087": "  }\n",
        "1088": "\n",
        "1089": "  /**\n",
        "1090": "   * Returns the set of all possible subsets of {@code set}. For example,\n",
        "1091": "   * {@code powerSet(ImmutableSet.of(1, 2))} returns the set {@code {{},\n",
        "1092": "   * {1}, {2}, {1, 2}}}.\n",
        "1093": "   *\n",
        "1094": "   * <p>Elements appear in these subsets in the same iteration order as they\n",
        "1095": "   * appeared in the input set. The order in which these subsets appear in the\n",
        "1096": "   * outer set is undefined. Note that the power set of the empty set is not the\n",
        "1097": "   * empty set, but a one-element set containing the empty set.\n",
        "1098": "   *\n",
        "1099": "   * <p>The returned set and its constituent sets use {@code equals} to decide\n",
        "1100": "   * whether two elements are identical, even if the input set uses a different\n",
        "1101": "   * concept of equivalence.\n",
        "1102": "   *\n",
        "1103": "   * <p><i>Performance notes:</i> while the power set of a set with size {@code\n",
        "1104": "   * n} is of size {@code 2^n}, its memory usage is only {@code O(n)}. When the\n",
        "1105": "   * power set is constructed, the input set is merely copied. Only as the\n",
        "1106": "   * power set is iterated are the individual subsets created, and these subsets\n",
        "1107": "   * themselves occupy only a small constant amount of memory.\n",
        "1108": "   *\n",
        "1109": "   * @param set the set of elements to construct a power set from\n",
        "1110": "   * @return the power set, as an immutable set of immutable sets\n",
        "1111": "   * @throws IllegalArgumentException if {@code set} has more than 30 unique\n",
        "1112": "   *     elements (causing the power set size to exceed the {@code int} range)\n",
        "1113": "   * @throws NullPointerException if {@code set} is or contains {@code null}\n",
        "1114": "   * @see <a href=\"http://en.wikipedia.org/wiki/Power_set\">Power set article at\n",
        "1115": "   *      Wikipedia</a>\n",
        "1116": "   * @since 4.0\n",
        "1117": "   */\n",
        "1118": "  @GwtCompatible(serializable = false)\n",
        "1119": "  public static <E> Set<Set<E>> powerSet(Set<E> set) {\n",
        "1120": "    return new PowerSet<E>(set);\n",
        "1121": "  }\n",
        "1122": "\n",
        "1123": "  private static final class SubSet<E> extends AbstractSet<E> {\n",
        "1124": "    private final ImmutableMap<E, Integer> inputSet;\n",
        "1125": "    private final int mask;\n",
        "1126": "\n",
        "1127": "    SubSet(ImmutableMap<E, Integer> inputSet, int mask) {\n",
        "1128": "      this.inputSet = inputSet;\n",
        "1129": "      this.mask = mask;\n",
        "1130": "    }\n",
        "1131": "\n",
        "1132": "    @Override\n",
        "1133": "    public Iterator<E> iterator() {\n",
        "1134": "      return new UnmodifiableIterator<E>() {\n",
        "1135": "        final ImmutableList<E> elements = inputSet.keySet().asList();\n",
        "1136": "        int remainingSetBits = mask;\n",
        "1137": "\n",
        "1138": "        @Override\n",
        "1139": "        public boolean hasNext() {\n",
        "1140": "          return remainingSetBits != 0;\n",
        "1141": "        }\n",
        "1142": "\n",
        "1143": "        @Override\n",
        "1144": "        public E next() {\n",
        "1145": "          int index = Integer.numberOfTrailingZeros(remainingSetBits);\n",
        "1146": "          if (index == 32) {\n",
        "1147": "            throw new NoSuchElementException();\n",
        "1148": "          }\n",
        "1149": "          remainingSetBits &= ~(1 << index);\n",
        "1150": "          return elements.get(index);\n",
        "1151": "        }\n",
        "1152": "      };\n",
        "1153": "    }\n",
        "1154": "\n",
        "1155": "    @Override\n",
        "1156": "    public int size() {\n",
        "1157": "      return Integer.bitCount(mask);\n",
        "1158": "    }\n",
        "1159": "\n",
        "1160": "    @Override\n",
        "1161": "    public boolean contains(@Nullable Object o) {\n",
        "1162": "      Integer index = inputSet.get(o);\n",
        "1163": "      return index != null && (mask & (1 << index)) != 0;\n",
        "1164": "    }\n",
        "1165": "  }\n",
        "1166": "\n",
        "1167": "  private static final class PowerSet<E> extends AbstractSet<Set<E>> {\n",
        "1168": "    final ImmutableMap<E, Integer> inputSet;\n",
        "1169": "\n",
        "1170": "    PowerSet(Set<E> input) {\n",
        "1171": "      this.inputSet = Maps.indexMap(input);\n",
        "1172": "      checkArgument(\n",
        "1173": "          inputSet.size() <= 30, \"Too many elements to create power set: %s > 30\", inputSet.size());\n",
        "1174": "    }\n",
        "1175": "\n",
        "1176": "    @Override\n",
        "1177": "    public int size() {\n",
        "1178": "      return 1 << inputSet.size();\n",
        "1179": "    }\n",
        "1180": "\n",
        "1181": "    @Override\n",
        "1182": "    public boolean isEmpty() {\n",
        "1183": "      return false;\n",
        "1184": "    }\n",
        "1185": "\n",
        "1186": "    @Override\n",
        "1187": "    public Iterator<Set<E>> iterator() {\n",
        "1188": "      return new AbstractIndexedListIterator<Set<E>>(size()) {\n",
        "1189": "        @Override\n",
        "1190": "        protected Set<E> get(final int setBits) {\n",
        "1191": "          return new SubSet<E>(inputSet, setBits);\n",
        "1192": "        }\n",
        "1193": "      };\n",
        "1194": "    }\n",
        "1195": "\n",
        "1196": "    @Override\n",
        "1197": "    public boolean contains(@Nullable Object obj) {\n",
        "1198": "      if (obj instanceof Set) {\n",
        "1199": "        Set<?> set = (Set<?>) obj;\n",
        "1200": "        return inputSet.keySet().containsAll(set);\n",
        "1201": "      }\n",
        "1202": "      return false;\n",
        "1203": "    }\n",
        "1204": "\n",
        "1205": "    @Override\n",
        "1206": "    public boolean equals(@Nullable Object obj) {\n",
        "1207": "      if (obj instanceof PowerSet) {\n",
        "1208": "        PowerSet<?> that = (PowerSet<?>) obj;\n",
        "1209": "        return inputSet.equals(that.inputSet);\n",
        "1210": "      }\n",
        "1211": "      return super.equals(obj);\n",
        "1212": "    }\n",
        "1213": "\n",
        "1214": "    @Override\n",
        "1215": "    public int hashCode() {\n",
        "1216": "      /*\n",
        "1217": "       * The sum of the sums of the hash codes in each subset is just the sum of\n",
        "1218": "       * each input element's hash code times the number of sets that element\n",
        "1219": "       * appears in. Each element appears in exactly half of the 2^n sets, so:\n",
        "1220": "       */\n",
        "1221": "      return inputSet.keySet().hashCode() << (inputSet.size() - 1);\n",
        "1222": "    }\n",
        "1223": "\n",
        "1224": "    @Override\n",
        "1225": "    public String toString() {\n",
        "1226": "      return \"powerSet(\" + inputSet + \")\";\n",
        "1227": "    }\n",
        "1228": "  }\n",
        "1229": "\n",
        "1230": "  /**\n",
        "1231": "   * An implementation for {@link Set#hashCode()}.\n",
        "1232": "   */\n",
        "1233": "  static int hashCodeImpl(Set<?> s) {\n",
        "1234": "    int hashCode = 0;\n",
        "1235": "    for (Object o : s) {\n",
        "1236": "      hashCode += o != null ? o.hashCode() : 0;\n",
        "1237": "\n",
        "1238": "      hashCode = ~~hashCode;\n",
        "1239": "      // Needed to deal with unusual integer overflow in GWT.\n",
        "1240": "    }\n",
        "1241": "    return hashCode;\n",
        "1242": "  }\n",
        "1243": "\n",
        "1244": "  /**\n",
        "1245": "   * An implementation for {@link Set#equals(Object)}.\n",
        "1246": "   */\n",
        "1247": "  static boolean equalsImpl(Set<?> s, @Nullable Object object) {\n",
        "1248": "    if (s == object) {\n",
        "1249": "      return true;\n",
        "1250": "    }\n",
        "1251": "    if (object instanceof Set) {\n",
        "1252": "      Set<?> o = (Set<?>) object;\n",
        "1253": "\n",
        "1254": "      try {\n",
        "1255": "        return s.size() == o.size() && s.containsAll(o);\n",
        "1256": "      } catch (NullPointerException ignored) {\n",
        "1257": "        return false;\n",
        "1258": "      } catch (ClassCastException ignored) {\n",
        "1259": "        return false;\n",
        "1260": "      }\n",
        "1261": "    }\n",
        "1262": "    return false;\n",
        "1263": "  }\n",
        "1264": "\n",
        "1265": "  /**\n",
        "1266": "   * Remove each element in an iterable from a set.\n",
        "1267": "   */\n",
        "1268": "  static boolean removeAllImpl(Set<?> set, Iterator<?> iterator) {\n",
        "1269": "    boolean changed = false;\n",
        "1270": "    while (iterator.hasNext()) {\n",
        "1271": "      changed |= set.remove(iterator.next());\n",
        "1272": "    }\n",
        "1273": "    return changed;\n",
        "1274": "  }\n",
        "1275": "\n",
        "1276": "  static boolean removeAllImpl(Set<?> set, Collection<?> collection) {\n",
        "1277": "    checkNotNull(collection); // for GWT\n",
        "1278": "    if (collection instanceof Multiset) {\n",
        "1279": "      collection = ((Multiset<?>) collection).elementSet();\n",
        "1280": "    }\n",
        "1281": "    /*\n",
        "1282": "     * AbstractSet.removeAll(List) has quadratic behavior if the list size\n",
        "1283": "     * is just less than the set's size.  We augment the test by\n",
        "1284": "     * assuming that sets have fast contains() performance, and other\n",
        "1285": "     * collections don't.  See\n",
        "1286": "     * http://code.google.com/p/guava-libraries/issues/detail?id=1013\n",
        "1287": "     */\n",
        "1288": "    if (collection instanceof Set && collection.size() > set.size()) {\n",
        "1289": "      return Iterators.removeAll(set.iterator(), collection);\n",
        "1290": "    } else {\n",
        "1291": "      return removeAllImpl(set, collection.iterator());\n",
        "1292": "    }\n",
        "1293": "  }\n",
        "1294": "}\n"
    }
}