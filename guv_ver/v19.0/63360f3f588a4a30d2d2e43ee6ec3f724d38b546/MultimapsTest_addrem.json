{
    "addition": {},
    "removed": {
        "1": "/*\n",
        "2": " * Copyright (C) 2007 The Guava Authors\n",
        "3": " *\n",
        "4": " * Licensed under the Apache License, Version 2.0 (the \"License\");\n",
        "5": " * you may not use this file except in compliance with the License.\n",
        "6": " * You may obtain a copy of the License at\n",
        "7": " *\n",
        "8": " * http://www.apache.org/licenses/LICENSE-2.0\n",
        "9": " *\n",
        "10": " * Unless required by applicable law or agreed to in writing, software\n",
        "11": " * distributed under the License is distributed on an \"AS IS\" BASIS,\n",
        "12": " * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n",
        "13": " * See the License for the specific language governing permissions and\n",
        "14": " * limitations under the License.\n",
        "15": " */\n",
        "16": "\n",
        "17": "package com.google.common.collect;\n",
        "18": "\n",
        "19": "import static com.google.common.base.Preconditions.checkArgument;\n",
        "20": "import static com.google.common.collect.Sets.newHashSet;\n",
        "21": "import static com.google.common.collect.testing.Helpers.nefariousMapEntry;\n",
        "22": "import static com.google.common.collect.testing.IteratorFeature.MODIFIABLE;\n",
        "23": "import static com.google.common.truth.Truth.assertThat;\n",
        "24": "import static java.util.Arrays.asList;\n",
        "25": "\n",
        "26": "import com.google.common.annotations.GwtCompatible;\n",
        "27": "import com.google.common.base.Function;\n",
        "28": "import com.google.common.base.Functions;\n",
        "29": "import com.google.common.base.Predicates;\n",
        "30": "import com.google.common.base.Supplier;\n",
        "31": "import com.google.common.collect.testing.IteratorTester;\n",
        "32": "import com.google.common.collect.testing.google.UnmodifiableCollectionTests;\n",
        "33": "\n",
        "34": "import junit.framework.TestCase;\n",
        "35": "\n",
        "36": "import java.io.Serializable;\n",
        "37": "import java.util.Arrays;\n",
        "38": "import java.util.Collection;\n",
        "39": "import java.util.Collections;\n",
        "40": "import java.util.Comparator;\n",
        "41": "import java.util.HashMap;\n",
        "42": "import java.util.HashSet;\n",
        "43": "import java.util.Iterator;\n",
        "44": "import java.util.LinkedList;\n",
        "45": "import java.util.List;\n",
        "46": "import java.util.Map;\n",
        "47": "import java.util.Map.Entry;\n",
        "48": "import java.util.Queue;\n",
        "49": "import java.util.RandomAccess;\n",
        "50": "import java.util.Set;\n",
        "51": "import java.util.SortedMap;\n",
        "52": "import java.util.SortedSet;\n",
        "53": "import java.util.TreeSet;\n",
        "54": "\n",
        "55": "import javax.annotation.Nullable;\n",
        "56": "\n",
        "57": "/**\n",
        "58": " * Unit test for {@code Multimaps}.\n",
        "59": " *\n",
        "60": " * @author Jared Levy\n",
        "61": " */\n",
        "62": "@GwtCompatible(emulated = true)\n",
        "63": "public class MultimapsTest extends TestCase {\n",
        "64": "\n",
        "65": "  private static final Comparator<Integer> INT_COMPARATOR =\n",
        "66": "      Ordering.<Integer>natural().reverse().nullsFirst();\n",
        "67": "\n",
        "68": "  @SuppressWarnings(\"deprecation\")\n",
        "69": "  public void testUnmodifiableListMultimapShortCircuit() {\n",
        "70": "    ListMultimap<String, Integer> mod = ArrayListMultimap.create();\n",
        "71": "    ListMultimap<String, Integer> unmod = Multimaps.unmodifiableListMultimap(mod);\n",
        "72": "    assertNotSame(mod, unmod);\n",
        "73": "    assertSame(unmod, Multimaps.unmodifiableListMultimap(unmod));\n",
        "74": "    ImmutableListMultimap<String, Integer> immutable =\n",
        "75": "        ImmutableListMultimap.of(\"a\", 1, \"b\", 2, \"a\", 3);\n",
        "76": "    assertSame(immutable, Multimaps.unmodifiableListMultimap(immutable));\n",
        "77": "    assertSame(\n",
        "78": "        immutable, Multimaps.unmodifiableListMultimap((ListMultimap<String, Integer>) immutable));\n",
        "79": "  }\n",
        "80": "\n",
        "81": "  @SuppressWarnings(\"deprecation\")\n",
        "82": "  public void testUnmodifiableSetMultimapShortCircuit() {\n",
        "83": "    SetMultimap<String, Integer> mod = HashMultimap.create();\n",
        "84": "    SetMultimap<String, Integer> unmod = Multimaps.unmodifiableSetMultimap(mod);\n",
        "85": "    assertNotSame(mod, unmod);\n",
        "86": "    assertSame(unmod, Multimaps.unmodifiableSetMultimap(unmod));\n",
        "87": "    ImmutableSetMultimap<String, Integer> immutable =\n",
        "88": "        ImmutableSetMultimap.of(\"a\", 1, \"b\", 2, \"a\", 3);\n",
        "89": "    assertSame(immutable, Multimaps.unmodifiableSetMultimap(immutable));\n",
        "90": "    assertSame(\n",
        "91": "        immutable, Multimaps.unmodifiableSetMultimap((SetMultimap<String, Integer>) immutable));\n",
        "92": "  }\n",
        "93": "\n",
        "94": "  @SuppressWarnings(\"deprecation\")\n",
        "95": "  public void testUnmodifiableMultimapShortCircuit() {\n",
        "96": "    Multimap<String, Integer> mod = HashMultimap.create();\n",
        "97": "    Multimap<String, Integer> unmod = Multimaps.unmodifiableMultimap(mod);\n",
        "98": "    assertNotSame(mod, unmod);\n",
        "99": "    assertSame(unmod, Multimaps.unmodifiableMultimap(unmod));\n",
        "100": "    ImmutableMultimap<String, Integer> immutable = ImmutableMultimap.of(\"a\", 1, \"b\", 2, \"a\", 3);\n",
        "101": "    assertSame(immutable, Multimaps.unmodifiableMultimap(immutable));\n",
        "102": "    assertSame(immutable, Multimaps.unmodifiableMultimap((Multimap<String, Integer>) immutable));\n",
        "103": "  }\n",
        "104": "\n",
        "105": "  public void testUnmodifiableArrayListMultimapRandomAccess() {\n",
        "106": "    ListMultimap<String, Integer> delegate = ArrayListMultimap.create();\n",
        "107": "    delegate.put(\"foo\", 1);\n",
        "108": "    delegate.put(\"foo\", 3);\n",
        "109": "    ListMultimap<String, Integer> multimap\n",
        "110": "        = Multimaps.unmodifiableListMultimap(delegate);\n",
        "111": "    assertTrue(multimap.get(\"foo\") instanceof RandomAccess);\n",
        "112": "    assertTrue(multimap.get(\"bar\") instanceof RandomAccess);\n",
        "113": "  }\n",
        "114": "\n",
        "115": "  public void testUnmodifiableLinkedListMultimapRandomAccess() {\n",
        "116": "    ListMultimap<String, Integer> delegate = LinkedListMultimap.create();\n",
        "117": "    delegate.put(\"foo\", 1);\n",
        "118": "    delegate.put(\"foo\", 3);\n",
        "119": "    ListMultimap<String, Integer> multimap = Multimaps.unmodifiableListMultimap(delegate);\n",
        "120": "    assertThat(multimap.get(\"foo\")).isNotInstanceOf(RandomAccess.class);\n",
        "121": "    assertThat(multimap.get(\"bar\")).isNotInstanceOf(RandomAccess.class);\n",
        "122": "  }\n",
        "123": "\n",
        "124": "  public void testUnmodifiableMultimapIsView() {\n",
        "125": "    Multimap<String, Integer> mod = HashMultimap.create();\n",
        "126": "    Multimap<String, Integer> unmod = Multimaps.unmodifiableMultimap(mod);\n",
        "127": "    assertEquals(mod, unmod);\n",
        "128": "    mod.put(\"foo\", 1);\n",
        "129": "    assertTrue(unmod.containsEntry(\"foo\", 1));\n",
        "130": "    assertEquals(mod, unmod);\n",
        "131": "  }\n",
        "132": "\n",
        "133": "  @SuppressWarnings(\"unchecked\")\n",
        "134": "  public void testUnmodifiableMultimapEntries() {\n",
        "135": "    Multimap<String, Integer> mod = HashMultimap.create();\n",
        "136": "    Multimap<String, Integer> unmod = Multimaps.unmodifiableMultimap(mod);\n",
        "137": "    mod.put(\"foo\", 1);\n",
        "138": "    Entry<String, Integer> entry = unmod.entries().iterator().next();\n",
        "139": "    try {\n",
        "140": "      entry.setValue(2);\n",
        "141": "      fail(\"UnsupportedOperationException expected\");\n",
        "142": "    } catch (UnsupportedOperationException expected) {}\n",
        "143": "    entry = (Entry<String, Integer>) unmod.entries().toArray()[0];\n",
        "144": "    try {\n",
        "145": "      entry.setValue(2);\n",
        "146": "      fail(\"UnsupportedOperationException expected\");\n",
        "147": "    } catch (UnsupportedOperationException expected) {}\n",
        "148": "    Entry<String, Integer>[] array\n",
        "149": "        = (Entry<String, Integer>[]) new Entry<?, ?>[2];\n",
        "150": "    assertSame(array, unmod.entries().toArray(array));\n",
        "151": "    try {\n",
        "152": "      array[0].setValue(2);\n",
        "153": "      fail(\"UnsupportedOperationException expected\");\n",
        "154": "    } catch (UnsupportedOperationException expected) {}\n",
        "155": "    assertFalse(unmod.entries().contains(nefariousMapEntry(\"pwnd\", 2)));\n",
        "156": "    assertFalse(unmod.keys().contains(\"pwnd\"));\n",
        "157": "  }\n",
        "158": "\n",
        "159": "  /**\n",
        "160": "   * The supplied multimap will be mutated and an unmodifiable instance used\n",
        "161": "   * in its stead. The multimap must support null keys and values.\n",
        "162": "   */\n",
        "163": "  private static void checkUnmodifiableMultimap(\n",
        "164": "      Multimap<String, Integer> multimap, boolean permitsDuplicates) {\n",
        "165": "    checkUnmodifiableMultimap(multimap, permitsDuplicates, null, null);\n",
        "166": "  }\n",
        "167": "\n",
        "168": "  /**\n",
        "169": "   * The supplied multimap will be mutated and an unmodifiable instance used\n",
        "170": "   * in its stead. If the multimap does not support null keys or values,\n",
        "171": "   * alternatives may be specified for tests involving nulls.\n",
        "172": "   */\n",
        "173": "  private static void checkUnmodifiableMultimap(\n",
        "174": "      Multimap<String, Integer> multimap, boolean permitsDuplicates,\n",
        "175": "      @Nullable String nullKey, @Nullable Integer nullValue) {\n",
        "176": "    Multimap<String, Integer> unmodifiable =\n",
        "177": "        prepareUnmodifiableTests(multimap, permitsDuplicates, nullKey, nullValue);\n",
        "178": "\n",
        "179": "    UnmodifiableCollectionTests.assertMultimapIsUnmodifiable(\n",
        "180": "        unmodifiable, \"test\", 123);\n",
        "181": "\n",
        "182": "    assertUnmodifiableIterableInTandem(\n",
        "183": "        unmodifiable.keys(), multimap.keys());\n",
        "184": "\n",
        "185": "    assertUnmodifiableIterableInTandem(\n",
        "186": "        unmodifiable.keySet(), multimap.keySet());\n",
        "187": "\n",
        "188": "    assertUnmodifiableIterableInTandem(\n",
        "189": "        unmodifiable.entries(), multimap.entries());\n",
        "190": "\n",
        "191": "    assertUnmodifiableIterableInTandem(\n",
        "192": "        unmodifiable.asMap().entrySet(), multimap.asMap().entrySet());\n",
        "193": "\n",
        "194": "    assertEquals(multimap.toString(), unmodifiable.toString());\n",
        "195": "    assertEquals(multimap.hashCode(), unmodifiable.hashCode());\n",
        "196": "    assertEquals(multimap, unmodifiable);\n",
        "197": "\n",
        "198": "    assertThat(unmodifiable.asMap().get(\"bar\")).containsExactly(5, -1);\n",
        "199": "    assertNull(unmodifiable.asMap().get(\"missing\"));\n",
        "200": "\n",
        "201": "    assertThat(unmodifiable.entries()).isNotInstanceOf(Serializable.class);\n",
        "202": "  }\n",
        "203": "\n",
        "204": "  /**\n",
        "205": "   * Prepares the multimap for unmodifiable tests, returning an unmodifiable view\n",
        "206": "   * of the map.\n",
        "207": "   */\n",
        "208": "  private static Multimap<String, Integer> prepareUnmodifiableTests(\n",
        "209": "      Multimap<String, Integer> multimap, boolean permitsDuplicates,\n",
        "210": "      @Nullable String nullKey, @Nullable Integer nullValue) {\n",
        "211": "    multimap.clear();\n",
        "212": "    multimap.put(\"foo\", 1);\n",
        "213": "    multimap.put(\"foo\", 2);\n",
        "214": "    multimap.put(\"foo\", 3);\n",
        "215": "    multimap.put(\"bar\", 5);\n",
        "216": "    multimap.put(\"bar\", -1);\n",
        "217": "    multimap.put(nullKey, nullValue);\n",
        "218": "    multimap.put(\"foo\", nullValue);\n",
        "219": "    multimap.put(nullKey, 5);\n",
        "220": "    multimap.put(\"foo\", 2);\n",
        "221": "\n",
        "222": "    if (permitsDuplicates) {\n",
        "223": "      assertEquals(9, multimap.size());\n",
        "224": "    } else {\n",
        "225": "      assertEquals(8, multimap.size());\n",
        "226": "    }\n",
        "227": "\n",
        "228": "    Multimap<String, Integer> unmodifiable;\n",
        "229": "    if (multimap instanceof SortedSetMultimap) {\n",
        "230": "      unmodifiable = Multimaps.unmodifiableSortedSetMultimap(\n",
        "231": "          (SortedSetMultimap<String, Integer>) multimap);\n",
        "232": "    } else if (multimap instanceof SetMultimap) {\n",
        "233": "      unmodifiable = Multimaps.unmodifiableSetMultimap(\n",
        "234": "          (SetMultimap<String, Integer>) multimap);\n",
        "235": "    } else if (multimap instanceof ListMultimap) {\n",
        "236": "      unmodifiable = Multimaps.unmodifiableListMultimap(\n",
        "237": "          (ListMultimap<String, Integer>) multimap);\n",
        "238": "    } else {\n",
        "239": "      unmodifiable = Multimaps.unmodifiableMultimap(multimap);\n",
        "240": "    }\n",
        "241": "    return unmodifiable;\n",
        "242": "  }\n",
        "243": "\n",
        "244": "  private static <T> void assertUnmodifiableIterableInTandem(\n",
        "245": "      Iterable<T> unmodifiable, Iterable<T> modifiable) {\n",
        "246": "    UnmodifiableCollectionTests.assertIteratorIsUnmodifiable(\n",
        "247": "        unmodifiable.iterator());\n",
        "248": "    UnmodifiableCollectionTests.assertIteratorsInOrder(\n",
        "249": "        unmodifiable.iterator(), modifiable.iterator());\n",
        "250": "  }\n",
        "251": "\n",
        "252": "  public void testInvertFrom() {\n",
        "253": "    ImmutableMultimap<Integer, String> empty = ImmutableMultimap.of();\n",
        "254": "\n",
        "255": "    // typical usage example - sad that ArrayListMultimap.create() won't work\n",
        "256": "    Multimap<String, Integer> multimap = Multimaps.invertFrom(empty,\n",
        "257": "        ArrayListMultimap.<String, Integer>create());\n",
        "258": "    assertTrue(multimap.isEmpty());\n",
        "259": "\n",
        "260": "    ImmutableMultimap<Integer, String> single\n",
        "261": "        = new ImmutableMultimap.Builder<Integer, String>()\n",
        "262": "            .put(1, \"one\")\n",
        "263": "            .put(2, \"two\")\n",
        "264": "            .build();\n",
        "265": "\n",
        "266": "    // copy into existing multimap\n",
        "267": "    assertSame(multimap, Multimaps.invertFrom(single, multimap));\n",
        "268": "\n",
        "269": "    ImmutableMultimap<String, Integer> expected\n",
        "270": "        = new ImmutableMultimap.Builder<String, Integer>()\n",
        "271": "        .put(\"one\", 1)\n",
        "272": "        .put(\"two\", 2)\n",
        "273": "        .build();\n",
        "274": "\n",
        "275": "    assertEquals(expected, multimap);\n",
        "276": "  }\n",
        "277": "\n",
        "278": "  public void testAsMap_multimap() {\n",
        "279": "    Multimap<String, Integer> multimap = Multimaps.newMultimap(\n",
        "280": "        new HashMap<String, Collection<Integer>>(), new QueueSupplier());\n",
        "281": "    Map<String, Collection<Integer>> map = Multimaps.asMap(multimap);\n",
        "282": "    assertSame(multimap.asMap(), map);\n",
        "283": "  }\n",
        "284": "\n",
        "285": "  public void testAsMap_listMultimap() {\n",
        "286": "    ListMultimap<String, Integer> listMultimap = ArrayListMultimap.create();\n",
        "287": "    Map<String, List<Integer>> map = Multimaps.asMap(listMultimap);\n",
        "288": "    assertSame(listMultimap.asMap(), map);\n",
        "289": "  }\n",
        "290": "\n",
        "291": "  public void testAsMap_setMultimap() {\n",
        "292": "    SetMultimap<String, Integer> setMultimap = LinkedHashMultimap.create();\n",
        "293": "    Map<String, Set<Integer>> map = Multimaps.asMap(setMultimap);\n",
        "294": "    assertSame(setMultimap.asMap(), map);\n",
        "295": "  }\n",
        "296": "\n",
        "297": "  public void testAsMap_sortedSetMultimap() {\n",
        "298": "    SortedSetMultimap<String, Integer> sortedSetMultimap =\n",
        "299": "        TreeMultimap.create();\n",
        "300": "    Map<String, SortedSet<Integer>> map = Multimaps.asMap(sortedSetMultimap);\n",
        "301": "    assertSame(sortedSetMultimap.asMap(), map);\n",
        "302": "  }\n",
        "303": "\n",
        "304": "  public void testForMap() {\n",
        "305": "    Map<String, Integer> map = Maps.newHashMap();\n",
        "306": "    map.put(\"foo\", 1);\n",
        "307": "    map.put(\"bar\", 2);\n",
        "308": "    Multimap<String, Integer> multimap = HashMultimap.create();\n",
        "309": "    multimap.put(\"foo\", 1);\n",
        "310": "    multimap.put(\"bar\", 2);\n",
        "311": "    Multimap<String, Integer> multimapView = Multimaps.forMap(map);\n",
        "312": "    assertTrue(multimap.equals(multimapView));\n",
        "313": "    assertTrue(multimapView.equals(multimap));\n",
        "314": "    assertTrue(multimapView.equals(multimapView));\n",
        "315": "    assertFalse(multimapView.equals(map));\n",
        "316": "    Multimap<String, Integer> multimap2 = HashMultimap.create();\n",
        "317": "    multimap2.put(\"foo\", 1);\n",
        "318": "    assertFalse(multimapView.equals(multimap2));\n",
        "319": "    multimap2.put(\"bar\", 1);\n",
        "320": "    assertFalse(multimapView.equals(multimap2));\n",
        "321": "    ListMultimap<String, Integer> listMultimap\n",
        "322": "        = new ImmutableListMultimap.Builder<String, Integer>()\n",
        "323": "            .put(\"foo\", 1).put(\"bar\", 2).build();\n",
        "324": "    assertFalse(\"SetMultimap equals ListMultimap\",\n",
        "325": "        multimapView.equals(listMultimap));\n",
        "326": "    assertEquals(multimap.toString(), multimapView.toString());\n",
        "327": "    assertEquals(multimap.hashCode(), multimapView.hashCode());\n",
        "328": "    assertEquals(multimap.size(), multimapView.size());\n",
        "329": "    assertTrue(multimapView.containsKey(\"foo\"));\n",
        "330": "    assertTrue(multimapView.containsValue(1));\n",
        "331": "    assertTrue(multimapView.containsEntry(\"bar\", 2));\n",
        "332": "    assertEquals(Collections.singleton(1), multimapView.get(\"foo\"));\n",
        "333": "    assertEquals(Collections.singleton(2), multimapView.get(\"bar\"));\n",
        "334": "    try {\n",
        "335": "      multimapView.put(\"baz\", 3);\n",
        "336": "      fail(\"UnsupportedOperationException expected\");\n",
        "337": "    } catch (UnsupportedOperationException expected) {}\n",
        "338": "    try {\n",
        "339": "      multimapView.putAll(\"baz\", Collections.singleton(3));\n",
        "340": "      fail(\"UnsupportedOperationException expected\");\n",
        "341": "    } catch (UnsupportedOperationException expected) {}\n",
        "342": "    try {\n",
        "343": "      multimapView.putAll(multimap);\n",
        "344": "      fail(\"UnsupportedOperationException expected\");\n",
        "345": "    } catch (UnsupportedOperationException expected) {}\n",
        "346": "    try {\n",
        "347": "      multimapView.replaceValues(\"foo\", Collections.<Integer>emptySet());\n",
        "348": "      fail(\"UnsupportedOperationException expected\");\n",
        "349": "    } catch (UnsupportedOperationException expected) {}\n",
        "350": "    multimapView.remove(\"bar\", 2);\n",
        "351": "    assertFalse(multimapView.containsKey(\"bar\"));\n",
        "352": "    assertFalse(map.containsKey(\"bar\"));\n",
        "353": "    assertEquals(map.keySet(), multimapView.keySet());\n",
        "354": "    assertEquals(map.keySet(), multimapView.keys().elementSet());\n",
        "355": "    assertThat(multimapView.keys()).contains(\"foo\");\n",
        "356": "    assertThat(multimapView.values()).contains(1);\n",
        "357": "    assertThat(multimapView.entries()).contains(Maps.immutableEntry(\"foo\", 1));\n",
        "358": "    assertThat(multimapView.asMap().entrySet())\n",
        "359": "        .contains(Maps.immutableEntry(\"foo\", (Collection<Integer>) Collections.singleton(1)));\n",
        "360": "    multimapView.clear();\n",
        "361": "    assertFalse(multimapView.containsKey(\"foo\"));\n",
        "362": "    assertFalse(map.containsKey(\"foo\"));\n",
        "363": "    assertTrue(map.isEmpty());\n",
        "364": "    assertTrue(multimapView.isEmpty());\n",
        "365": "    multimap.clear();\n",
        "366": "    assertEquals(multimap.toString(), multimapView.toString());\n",
        "367": "    assertEquals(multimap.hashCode(), multimapView.hashCode());\n",
        "368": "    assertEquals(multimap.size(), multimapView.size());\n",
        "369": "    assertEquals(multimapView, ArrayListMultimap.create());\n",
        "370": "  }\n",
        "371": "\n",
        "372": "  public void testForMapRemoveAll() {\n",
        "373": "    Map<String, Integer> map = Maps.newHashMap();\n",
        "374": "    map.put(\"foo\", 1);\n",
        "375": "    map.put(\"bar\", 2);\n",
        "376": "    map.put(\"cow\", 3);\n",
        "377": "    Multimap<String, Integer> multimap = Multimaps.forMap(map);\n",
        "378": "    assertEquals(3, multimap.size());\n",
        "379": "    assertEquals(Collections.emptySet(), multimap.removeAll(\"dog\"));\n",
        "380": "    assertEquals(3, multimap.size());\n",
        "381": "    assertTrue(multimap.containsKey(\"bar\"));\n",
        "382": "    assertEquals(Collections.singleton(2), multimap.removeAll(\"bar\"));\n",
        "383": "    assertEquals(2, multimap.size());\n",
        "384": "    assertFalse(multimap.containsKey(\"bar\"));\n",
        "385": "  }\n",
        "386": "\n",
        "387": "  public void testForMapAsMap() {\n",
        "388": "    Map<String, Integer> map = Maps.newHashMap();\n",
        "389": "    map.put(\"foo\", 1);\n",
        "390": "    map.put(\"bar\", 2);\n",
        "391": "    Map<String, Collection<Integer>> asMap = Multimaps.forMap(map).asMap();\n",
        "392": "    assertEquals(Collections.singleton(1), asMap.get(\"foo\"));\n",
        "393": "    assertNull(asMap.get(\"cow\"));\n",
        "394": "    assertTrue(asMap.containsKey(\"foo\"));\n",
        "395": "    assertFalse(asMap.containsKey(\"cow\"));\n",
        "396": "\n",
        "397": "    Set<Entry<String, Collection<Integer>>> entries = asMap.entrySet();\n",
        "398": "    assertFalse(entries.contains(4.5));\n",
        "399": "    assertFalse(entries.remove(4.5));\n",
        "400": "    assertFalse(entries.contains(Maps.immutableEntry(\"foo\",\n",
        "401": "        Collections.singletonList(1))));\n",
        "402": "    assertFalse(entries.remove(Maps.immutableEntry(\"foo\",\n",
        "403": "        Collections.singletonList(1))));\n",
        "404": "    assertFalse(entries.contains(Maps.immutableEntry(\"foo\",\n",
        "405": "        Sets.newLinkedHashSet(asList(1, 2)))));\n",
        "406": "    assertFalse(entries.remove(Maps.immutableEntry(\"foo\",\n",
        "407": "        Sets.newLinkedHashSet(asList(1, 2)))));\n",
        "408": "    assertFalse(entries.contains(Maps.immutableEntry(\"foo\",\n",
        "409": "        Collections.singleton(2))));\n",
        "410": "    assertFalse(entries.remove(Maps.immutableEntry(\"foo\",\n",
        "411": "        Collections.singleton(2))));\n",
        "412": "    assertTrue(map.containsKey(\"foo\"));\n",
        "413": "    assertTrue(entries.contains(Maps.immutableEntry(\"foo\",\n",
        "414": "        Collections.singleton(1))));\n",
        "415": "    assertTrue(entries.remove(Maps.immutableEntry(\"foo\",\n",
        "416": "        Collections.singleton(1))));\n",
        "417": "    assertFalse(map.containsKey(\"foo\"));\n",
        "418": "  }\n",
        "419": "\n",
        "420": "  public void testForMapGetIteration() {\n",
        "421": "    IteratorTester<Integer> tester =\n",
        "422": "        new IteratorTester<Integer>(4, MODIFIABLE, newHashSet(1),\n",
        "423": "            IteratorTester.KnownOrder.KNOWN_ORDER) {\n",
        "424": "          private Multimap<String, Integer> multimap;\n",
        "425": "\n",
        "426": "          @Override protected Iterator<Integer> newTargetIterator() {\n",
        "427": "            Map<String, Integer> map = Maps.newHashMap();\n",
        "428": "            map.put(\"foo\", 1);\n",
        "429": "            map.put(\"bar\", 2);\n",
        "430": "            multimap = Multimaps.forMap(map);\n",
        "431": "            return multimap.get(\"foo\").iterator();\n",
        "432": "          }\n",
        "433": "\n",
        "434": "          @Override protected void verify(List<Integer> elements) {\n",
        "435": "            assertEquals(newHashSet(elements), multimap.get(\"foo\"));\n",
        "436": "          }\n",
        "437": "        };\n",
        "438": "\n",
        "439": "    tester.test();\n",
        "440": "  }\n",
        "441": "\n",
        "442": "  private enum Color {BLUE, RED, YELLOW, GREEN}\n",
        "443": "\n",
        "444": "  private abstract static class CountingSupplier<E>\n",
        "445": "      implements Supplier<E>, Serializable {\n",
        "446": "    int count;\n",
        "447": "\n",
        "448": "    abstract E getImpl();\n",
        "449": "\n",
        "450": "    @Override\n",
        "451": "    public E get() {\n",
        "452": "      count++;\n",
        "453": "      return getImpl();\n",
        "454": "    }\n",
        "455": "  }\n",
        "456": "\n",
        "457": "  private static class QueueSupplier extends CountingSupplier<Queue<Integer>> {\n",
        "458": "    @Override public Queue<Integer> getImpl() {\n",
        "459": "      return new LinkedList<Integer>();\n",
        "460": "    }\n",
        "461": "    private static final long serialVersionUID = 0;\n",
        "462": "  }\n",
        "463": "\n",
        "464": "  public void testNewMultimapWithCollectionRejectingNegativeElements() {\n",
        "465": "    CountingSupplier<Set<Integer>> factory = new SetSupplier() {\n",
        "466": "      @Override\n",
        "467": "      public Set<Integer> getImpl() {\n",
        "468": "        final Set<Integer> backing = super.getImpl();\n",
        "469": "        return new ForwardingSet<Integer>() {\n",
        "470": "          @Override\n",
        "471": "          protected Set<Integer> delegate() {\n",
        "472": "            return backing;\n",
        "473": "          }\n",
        "474": "\n",
        "475": "          @Override\n",
        "476": "          public boolean add(Integer element) {\n",
        "477": "            checkArgument(element >= 0);\n",
        "478": "            return super.add(element);\n",
        "479": "          }\n",
        "480": "\n",
        "481": "          @Override\n",
        "482": "          public boolean addAll(Collection<? extends Integer> collection) {\n",
        "483": "            return standardAddAll(collection);\n",
        "484": "          }\n",
        "485": "        };\n",
        "486": "      }\n",
        "487": "    };\n",
        "488": "\n",
        "489": "    Map<Color, Collection<Integer>> map = Maps.newEnumMap(Color.class);\n",
        "490": "    Multimap<Color, Integer> multimap = Multimaps.newMultimap(map, factory);\n",
        "491": "    try {\n",
        "492": "      multimap.put(Color.BLUE, -1);\n",
        "493": "      fail(\"Expected IllegalArgumentException\");\n",
        "494": "    } catch (IllegalArgumentException expected) {\n",
        "495": "      // expected\n",
        "496": "    }\n",
        "497": "    multimap.put(Color.RED, 1);\n",
        "498": "    multimap.put(Color.BLUE, 2);\n",
        "499": "    try {\n",
        "500": "      multimap.put(Color.GREEN, -1);\n",
        "501": "      fail(\"Expected IllegalArgumentException\");\n",
        "502": "    } catch (IllegalArgumentException expected) {\n",
        "503": "      // expected\n",
        "504": "    }\n",
        "505": "    assertThat(multimap.entries()).containsExactly(\n",
        "506": "        Maps.immutableEntry(Color.RED, 1),\n",
        "507": "        Maps.immutableEntry(Color.BLUE, 2));\n",
        "508": "  }\n",
        "509": "\n",
        "510": "  public void testNewMultimap() {\n",
        "511": "    // The ubiquitous EnumArrayBlockingQueueMultimap\n",
        "512": "    CountingSupplier<Queue<Integer>> factory = new QueueSupplier();\n",
        "513": "\n",
        "514": "    Map<Color, Collection<Integer>> map = Maps.newEnumMap(Color.class);\n",
        "515": "    Multimap<Color, Integer> multimap = Multimaps.newMultimap(map, factory);\n",
        "516": "    assertEquals(0, factory.count);\n",
        "517": "    multimap.putAll(Color.BLUE, asList(3, 1, 4));\n",
        "518": "    assertEquals(1, factory.count);\n",
        "519": "    multimap.putAll(Color.RED, asList(2, 7, 1, 8));\n",
        "520": "    assertEquals(2, factory.count);\n",
        "521": "    assertEquals(\"[3, 1, 4]\", multimap.get(Color.BLUE).toString());\n",
        "522": "\n",
        "523": "    Multimap<Color, Integer> ummodifiable =\n",
        "524": "        Multimaps.unmodifiableMultimap(multimap);\n",
        "525": "    assertEquals(\"[3, 1, 4]\", ummodifiable.get(Color.BLUE).toString());\n",
        "526": "\n",
        "527": "    Collection<Integer> collection = multimap.get(Color.BLUE);\n",
        "528": "    assertEquals(collection, collection);\n",
        "529": "\n",
        "530": "    assertThat(multimap.keySet()).isNotInstanceOf(SortedSet.class);\n",
        "531": "    assertThat(multimap.asMap()).isNotInstanceOf(SortedMap.class);\n",
        "532": "  }\n",
        "533": "\n",
        "534": "  private static class ListSupplier extends\n",
        "535": "      CountingSupplier<LinkedList<Integer>> {\n",
        "536": "    @Override public LinkedList<Integer> getImpl() {\n",
        "537": "      return new LinkedList<Integer>();\n",
        "538": "    }\n",
        "539": "    private static final long serialVersionUID = 0;\n",
        "540": "  }\n",
        "541": "\n",
        "542": "  public void testNewListMultimap() {\n",
        "543": "    CountingSupplier<LinkedList<Integer>> factory = new ListSupplier();\n",
        "544": "    Map<Color, Collection<Integer>> map = Maps.newTreeMap();\n",
        "545": "    ListMultimap<Color, Integer> multimap =\n",
        "546": "        Multimaps.newListMultimap(map, factory);\n",
        "547": "    assertEquals(0, factory.count);\n",
        "548": "    multimap.putAll(Color.BLUE, asList(3, 1, 4, 1));\n",
        "549": "    assertEquals(1, factory.count);\n",
        "550": "    multimap.putAll(Color.RED, asList(2, 7, 1, 8));\n",
        "551": "    assertEquals(2, factory.count);\n",
        "552": "    assertEquals(\"{BLUE=[3, 1, 4, 1], RED=[2, 7, 1, 8]}\", multimap.toString());\n",
        "553": "    assertThat(multimap.get(Color.BLUE)).isNotInstanceOf(RandomAccess.class);\n",
        "554": "\n",
        "555": "    assertTrue(multimap.keySet() instanceof SortedSet);\n",
        "556": "    assertTrue(multimap.asMap() instanceof SortedMap);\n",
        "557": "  }\n",
        "558": "\n",
        "559": "  private static class SetSupplier extends CountingSupplier<Set<Integer>> {\n",
        "560": "    @Override public Set<Integer> getImpl() {\n",
        "561": "      return new HashSet<Integer>(4);\n",
        "562": "    }\n",
        "563": "    private static final long serialVersionUID = 0;\n",
        "564": "  }\n",
        "565": "\n",
        "566": "  public void testNewSetMultimap() {\n",
        "567": "    CountingSupplier<Set<Integer>> factory = new SetSupplier();\n",
        "568": "    Map<Color, Collection<Integer>> map = Maps.newHashMap();\n",
        "569": "    SetMultimap<Color, Integer> multimap =\n",
        "570": "        Multimaps.newSetMultimap(map, factory);\n",
        "571": "    assertEquals(0, factory.count);\n",
        "572": "    multimap.putAll(Color.BLUE, asList(3, 1, 4));\n",
        "573": "    assertEquals(1, factory.count);\n",
        "574": "    multimap.putAll(Color.RED, asList(2, 7, 1, 8));\n",
        "575": "    assertEquals(2, factory.count);\n",
        "576": "    assertEquals(Sets.newHashSet(4, 3, 1), multimap.get(Color.BLUE));\n",
        "577": "  }\n",
        "578": "\n",
        "579": "  private static class SortedSetSupplier extends\n",
        "580": "      CountingSupplier<TreeSet<Integer>> {\n",
        "581": "    @Override public TreeSet<Integer> getImpl() {\n",
        "582": "      return Sets.newTreeSet(INT_COMPARATOR);\n",
        "583": "    }\n",
        "584": "    private static final long serialVersionUID = 0;\n",
        "585": "  }\n",
        "586": "\n",
        "587": "  public void testNewSortedSetMultimap() {\n",
        "588": "    CountingSupplier<TreeSet<Integer>> factory = new SortedSetSupplier();\n",
        "589": "    Map<Color, Collection<Integer>> map = Maps.newEnumMap(Color.class);\n",
        "590": "    SortedSetMultimap<Color, Integer> multimap =\n",
        "591": "        Multimaps.newSortedSetMultimap(map, factory);\n",
        "592": "    // newSortedSetMultimap calls the factory once to determine the comparator.\n",
        "593": "    assertEquals(1, factory.count);\n",
        "594": "    multimap.putAll(Color.BLUE, asList(3, 1, 4));\n",
        "595": "    assertEquals(2, factory.count);\n",
        "596": "    multimap.putAll(Color.RED, asList(2, 7, 1, 8));\n",
        "597": "    assertEquals(3, factory.count);\n",
        "598": "    assertEquals(\"[4, 3, 1]\", multimap.get(Color.BLUE).toString());\n",
        "599": "    assertEquals(INT_COMPARATOR, multimap.valueComparator());\n",
        "600": "  }\n",
        "601": "\n",
        "602": "  public void testIndex() {\n",
        "603": "    final Multimap<String, Object> stringToObject =\n",
        "604": "        new ImmutableMultimap.Builder<String, Object>()\n",
        "605": "            .put(\"1\", 1)\n",
        "606": "            .put(\"1\", 1L)\n",
        "607": "            .put(\"1\", \"1\")\n",
        "608": "            .put(\"2\", 2)\n",
        "609": "            .put(\"2\", 2L)\n",
        "610": "            .build();\n",
        "611": "\n",
        "612": "    ImmutableMultimap<String, Object> outputMap =\n",
        "613": "        Multimaps.index(stringToObject.values(),\n",
        "614": "            Functions.toStringFunction());\n",
        "615": "    assertEquals(stringToObject, outputMap);\n",
        "616": "  }\n",
        "617": "\n",
        "618": "  public void testIndexIterator() {\n",
        "619": "    final Multimap<String, Object> stringToObject =\n",
        "620": "        new ImmutableMultimap.Builder<String, Object>()\n",
        "621": "            .put(\"1\", 1)\n",
        "622": "            .put(\"1\", 1L)\n",
        "623": "            .put(\"1\", \"1\")\n",
        "624": "            .put(\"2\", 2)\n",
        "625": "            .put(\"2\", 2L)\n",
        "626": "            .build();\n",
        "627": "\n",
        "628": "    ImmutableMultimap<String, Object> outputMap =\n",
        "629": "        Multimaps.index(stringToObject.values().iterator(),\n",
        "630": "            Functions.toStringFunction());\n",
        "631": "    assertEquals(stringToObject, outputMap);\n",
        "632": "  }\n",
        "633": "\n",
        "634": "  public void testIndex_ordering() {\n",
        "635": "    final Multimap<Integer, String> expectedIndex =\n",
        "636": "        new ImmutableListMultimap.Builder<Integer, String>()\n",
        "637": "            .put(4, \"Inky\")\n",
        "638": "            .put(6, \"Blinky\")\n",
        "639": "            .put(5, \"Pinky\")\n",
        "640": "            .put(5, \"Pinky\")\n",
        "641": "            .put(5, \"Clyde\")\n",
        "642": "            .build();\n",
        "643": "\n",
        "644": "    final List<String> badGuys =\n",
        "645": "        Arrays.asList(\"Inky\", \"Blinky\", \"Pinky\", \"Pinky\", \"Clyde\");\n",
        "646": "    final Function<String, Integer> stringLengthFunction =\n",
        "647": "        new Function<String, Integer>() {\n",
        "648": "          @Override\n",
        "649": "          public Integer apply(String input) {\n",
        "650": "            return input.length();\n",
        "651": "          }\n",
        "652": "        };\n",
        "653": "\n",
        "654": "    Multimap<Integer, String> index =\n",
        "655": "        Multimaps.index(badGuys, stringLengthFunction);\n",
        "656": "\n",
        "657": "    assertEquals(expectedIndex, index);\n",
        "658": "  }\n",
        "659": "\n",
        "660": "  public void testIndex_nullValue() {\n",
        "661": "    List<Integer> values = Arrays.asList(1, null);\n",
        "662": "    try {\n",
        "663": "      Multimaps.index(values, Functions.identity());\n",
        "664": "      fail();\n",
        "665": "    } catch (NullPointerException e) {}\n",
        "666": "  }\n",
        "667": "\n",
        "668": "  public void testIndex_nullKey() {\n",
        "669": "    List<Integer> values = Arrays.asList(1, 2);\n",
        "670": "    try {\n",
        "671": "      Multimaps.index(values, Functions.constant(null));\n",
        "672": "      fail();\n",
        "673": "    } catch (NullPointerException e) {}\n",
        "674": "  }\n",
        "675": "\n",
        "676": "  public <K, V> void testSynchronizedMultimapSampleCodeCompilation() {\n",
        "677": "    K key = null;\n",
        "678": "\n",
        "679": "    Multimap<K, V> multimap = Multimaps.synchronizedMultimap(\n",
        "680": "        HashMultimap.<K, V>create());\n",
        "681": "    Collection<V> values = multimap.get(key);  // Needn't be in synchronized block\n",
        "682": "    synchronized (multimap) {  // Synchronizing on multimap, not values!\n",
        "683": "      Iterator<V> i = values.iterator(); // Must be in synchronized block\n",
        "684": "      while (i.hasNext()) {\n",
        "685": "        foo(i.next());\n",
        "686": "      }\n",
        "687": "    }\n",
        "688": "  }\n",
        "689": "\n",
        "690": "  private static void foo(Object o) {}\n",
        "691": "  \n",
        "692": "  public void testFilteredKeysSetMultimapReplaceValues() {\n",
        "693": "    SetMultimap<String, Integer> multimap = LinkedHashMultimap.create();\n",
        "694": "    multimap.put(\"foo\", 1);\n",
        "695": "    multimap.put(\"bar\", 2);\n",
        "696": "    multimap.put(\"baz\", 3);\n",
        "697": "    multimap.put(\"bar\", 4);\n",
        "698": "    \n",
        "699": "    SetMultimap<String, Integer> filtered = Multimaps.filterKeys(\n",
        "700": "        multimap, Predicates.in(ImmutableSet.of(\"foo\", \"bar\")));\n",
        "701": "    \n",
        "702": "    assertEquals(\n",
        "703": "        ImmutableSet.of(),\n",
        "704": "        filtered.replaceValues(\"baz\", ImmutableSet.<Integer>of()));\n",
        "705": "    \n",
        "706": "    try {\n",
        "707": "      filtered.replaceValues(\"baz\", ImmutableSet.of(5));\n",
        "708": "      fail(\"Expected IllegalArgumentException\");\n",
        "709": "    } catch (IllegalArgumentException expected) {\n",
        "710": "    }\n",
        "711": "  }\n",
        "712": "  \n",
        "713": "  public void testFilteredKeysSetMultimapGetBadValue() {\n",
        "714": "    SetMultimap<String, Integer> multimap = LinkedHashMultimap.create();\n",
        "715": "    multimap.put(\"foo\", 1);\n",
        "716": "    multimap.put(\"bar\", 2);\n",
        "717": "    multimap.put(\"baz\", 3);\n",
        "718": "    multimap.put(\"bar\", 4);\n",
        "719": "    \n",
        "720": "    SetMultimap<String, Integer> filtered = Multimaps.filterKeys(\n",
        "721": "        multimap, Predicates.in(ImmutableSet.of(\"foo\", \"bar\")));\n",
        "722": "    Set<Integer> bazSet = filtered.get(\"baz\");\n",
        "723": "    assertThat(bazSet).isEmpty();\n",
        "724": "    try {\n",
        "725": "      bazSet.add(5);\n",
        "726": "      fail(\"Expected IllegalArgumentException\");\n",
        "727": "    } catch (IllegalArgumentException expected) {\n",
        "728": "    }\n",
        "729": "    try {\n",
        "730": "      bazSet.addAll(ImmutableSet.of(6, 7));\n",
        "731": "      fail(\"Expected IllegalArgumentException\");\n",
        "732": "    } catch (IllegalArgumentException expected) {\n",
        "733": "    }\n",
        "734": "  }\n",
        "735": "  \n",
        "736": "  public void testFilteredKeysListMultimapGetBadValue() {\n",
        "737": "    ListMultimap<String, Integer> multimap = ArrayListMultimap.create();\n",
        "738": "    multimap.put(\"foo\", 1);\n",
        "739": "    multimap.put(\"bar\", 2);\n",
        "740": "    multimap.put(\"baz\", 3);\n",
        "741": "    multimap.put(\"bar\", 4);\n",
        "742": "    \n",
        "743": "    ListMultimap<String, Integer> filtered = Multimaps.filterKeys(\n",
        "744": "        multimap, Predicates.in(ImmutableSet.of(\"foo\", \"bar\")));\n",
        "745": "    List<Integer> bazList = filtered.get(\"baz\");\n",
        "746": "    assertThat(bazList).isEmpty();\n",
        "747": "    try {\n",
        "748": "      bazList.add(5);\n",
        "749": "      fail(\"Expected IllegalArgumentException\");\n",
        "750": "    } catch (IllegalArgumentException expected) {\n",
        "751": "    }\n",
        "752": "    try {\n",
        "753": "      bazList.add(0, 6);\n",
        "754": "      fail(\"Expected IllegalArgumentException\");\n",
        "755": "    } catch (IllegalArgumentException expected) {\n",
        "756": "    }\n",
        "757": "    try {\n",
        "758": "      bazList.addAll(ImmutableList.of(7, 8));\n",
        "759": "      fail(\"Expected IllegalArgumentException\");\n",
        "760": "    } catch (IllegalArgumentException expected) {\n",
        "761": "    }\n",
        "762": "    try {\n",
        "763": "      bazList.addAll(0, ImmutableList.of(9, 10));\n",
        "764": "      fail(\"Expected IllegalArgumentException\");\n",
        "765": "    } catch (IllegalArgumentException expected) {\n",
        "766": "    }\n",
        "767": "  }\n",
        "768": "}\n",
        "769": "\n"
    }
}