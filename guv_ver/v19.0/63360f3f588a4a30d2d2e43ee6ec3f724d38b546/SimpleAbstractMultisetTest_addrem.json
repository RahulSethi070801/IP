{
    "addition": {},
    "removed": {
        "1": "/*\n",
        "2": " * Copyright (C) 2007 The Guava Authors\n",
        "3": " *\n",
        "4": " * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not use this file except\n",
        "5": " * in compliance with the License. You may obtain a copy of the License at\n",
        "6": " *\n",
        "7": " * http://www.apache.org/licenses/LICENSE-2.0\n",
        "8": " *\n",
        "9": " * Unless required by applicable law or agreed to in writing, software distributed under the License\n",
        "10": " * is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express\n",
        "11": " * or implied. See the License for the specific language governing permissions and limitations under\n",
        "12": " * the License.\n",
        "13": " */\n",
        "14": "\n",
        "15": "package com.google.common.collect;\n",
        "16": "\n",
        "17": "import static com.google.common.base.Preconditions.checkArgument;\n",
        "18": "\n",
        "19": "import com.google.common.annotations.GwtCompatible;\n",
        "20": "\n",
        "21": "import junit.framework.TestCase;\n",
        "22": "\n",
        "23": "import java.io.Serializable;\n",
        "24": "import java.util.Iterator;\n",
        "25": "import java.util.Map;\n",
        "26": "import java.util.concurrent.atomic.AtomicInteger;\n",
        "27": "\n",
        "28": "import javax.annotation.Nullable;\n",
        "29": "\n",
        "30": "/**\n",
        "31": " * Unit test for {@link AbstractMultiset}.\n",
        "32": " *\n",
        "33": " * @author Kevin Bourrillion\n",
        "34": " * @author Louis Wasserman\n",
        "35": " */\n",
        "36": "@SuppressWarnings(\"serial\") // No serialization is used in this test\n",
        "37": "@GwtCompatible(emulated = true)\n",
        "38": "public class SimpleAbstractMultisetTest extends TestCase {\n",
        "39": "\n",
        "40": "  public void testFastAddAllMultiset() {\n",
        "41": "    final AtomicInteger addCalls = new AtomicInteger();\n",
        "42": "    Multiset<String> multiset = new NoRemoveMultiset<String>() {\n",
        "43": "      @Override\n",
        "44": "      public int add(String element, int occurrences) {\n",
        "45": "        addCalls.incrementAndGet();\n",
        "46": "        return super.add(element, occurrences);\n",
        "47": "      }\n",
        "48": "    };\n",
        "49": "    ImmutableMultiset<String> adds =\n",
        "50": "        new ImmutableMultiset.Builder<String>().addCopies(\"x\", 10).build();\n",
        "51": "    multiset.addAll(adds);\n",
        "52": "    assertEquals(addCalls.get(), 1);\n",
        "53": "  }\n",
        "54": "\n",
        "55": "  public void testRemoveUnsupported() {\n",
        "56": "    Multiset<String> multiset = new NoRemoveMultiset<String>();\n",
        "57": "    multiset.add(\"a\");\n",
        "58": "    try {\n",
        "59": "      multiset.remove(\"a\");\n",
        "60": "      fail();\n",
        "61": "    } catch (UnsupportedOperationException expected) {}\n",
        "62": "    assertTrue(multiset.contains(\"a\"));\n",
        "63": "  }\n",
        "64": "\n",
        "65": "  private static class NoRemoveMultiset<E> extends AbstractMultiset<E>\n",
        "66": "      implements Serializable {\n",
        "67": "    final Map<E, Integer> backingMap = Maps.newHashMap();\n",
        "68": "\n",
        "69": "    @Override public int add(@Nullable E element, int occurrences) {\n",
        "70": "      checkArgument(occurrences >= 0);\n",
        "71": "      Integer frequency = backingMap.get(element);\n",
        "72": "      if (frequency == null) {\n",
        "73": "        frequency = 0;\n",
        "74": "      }\n",
        "75": "      if (occurrences == 0) {\n",
        "76": "        return frequency;\n",
        "77": "      }\n",
        "78": "      checkArgument(occurrences <= Integer.MAX_VALUE - frequency);\n",
        "79": "      backingMap.put(element, frequency + occurrences);\n",
        "80": "      return frequency;\n",
        "81": "    }\n",
        "82": "\n",
        "83": "    @Override\n",
        "84": "    Iterator<Entry<E>> entryIterator() {\n",
        "85": "      final Iterator<Map.Entry<E, Integer>> backingEntries = backingMap.entrySet().iterator();\n",
        "86": "      return new UnmodifiableIterator<Multiset.Entry<E>>() {\n",
        "87": "        @Override\n",
        "88": "        public boolean hasNext() {\n",
        "89": "          return backingEntries.hasNext();\n",
        "90": "        }\n",
        "91": "\n",
        "92": "        @Override\n",
        "93": "        public Multiset.Entry<E> next() {\n",
        "94": "          final Map.Entry<E, Integer> mapEntry = backingEntries.next();\n",
        "95": "          return new Multisets.AbstractEntry<E>() {\n",
        "96": "            @Override\n",
        "97": "            public E getElement() {\n",
        "98": "              return mapEntry.getKey();\n",
        "99": "            }\n",
        "100": "\n",
        "101": "            @Override\n",
        "102": "            public int getCount() {\n",
        "103": "              Integer frequency = backingMap.get(getElement());\n",
        "104": "              return (frequency == null) ? 0 : frequency;\n",
        "105": "            }\n",
        "106": "          };\n",
        "107": "        }\n",
        "108": "      };\n",
        "109": "    }\n",
        "110": "\n",
        "111": "    @Override\n",
        "112": "    int distinctElements() {\n",
        "113": "      return backingMap.size();\n",
        "114": "    }\n",
        "115": "  }\n",
        "116": "}\n",
        "117": "\n"
    }
}