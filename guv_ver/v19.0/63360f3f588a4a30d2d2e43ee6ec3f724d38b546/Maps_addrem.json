{
    "addition": {},
    "removed": {
        "1": "/*\n",
        "2": " * Copyright (C) 2007 The Guava Authors\n",
        "3": " *\n",
        "4": " * Licensed under the Apache License, Version 2.0 (the \"License\");\n",
        "5": " * you may not use this file except in compliance with the License.\n",
        "6": " * You may obtain a copy of the License at\n",
        "7": " *\n",
        "8": " * http://www.apache.org/licenses/LICENSE-2.0\n",
        "9": " *\n",
        "10": " * Unless required by applicable law or agreed to in writing, software\n",
        "11": " * distributed under the License is distributed on an \"AS IS\" BASIS,\n",
        "12": " * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n",
        "13": " * See the License for the specific language governing permissions and\n",
        "14": " * limitations under the License.\n",
        "15": " */\n",
        "16": "\n",
        "17": "package com.google.common.collect;\n",
        "18": "\n",
        "19": "import static com.google.common.base.Preconditions.checkArgument;\n",
        "20": "import static com.google.common.base.Preconditions.checkNotNull;\n",
        "21": "import static com.google.common.base.Predicates.compose;\n",
        "22": "import static com.google.common.base.Predicates.equalTo;\n",
        "23": "import static com.google.common.base.Predicates.in;\n",
        "24": "import static com.google.common.base.Predicates.not;\n",
        "25": "import static com.google.common.collect.CollectPreconditions.checkNonnegative;\n",
        "26": "\n",
        "27": "import com.google.common.annotations.Beta;\n",
        "28": "import com.google.common.annotations.GwtCompatible;\n",
        "29": "import com.google.common.base.Converter;\n",
        "30": "import com.google.common.base.Equivalence;\n",
        "31": "import com.google.common.base.Function;\n",
        "32": "import com.google.common.base.Joiner.MapJoiner;\n",
        "33": "import com.google.common.base.Objects;\n",
        "34": "import com.google.common.base.Preconditions;\n",
        "35": "import com.google.common.base.Predicate;\n",
        "36": "import com.google.common.base.Predicates;\n",
        "37": "import com.google.common.collect.MapDifference.ValueDifference;\n",
        "38": "import com.google.common.primitives.Ints;\n",
        "39": "import com.google.j2objc.annotations.Weak;\n",
        "40": "import com.google.j2objc.annotations.WeakOuter;\n",
        "41": "\n",
        "42": "import java.io.Serializable;\n",
        "43": "import java.util.AbstractCollection;\n",
        "44": "import java.util.AbstractMap;\n",
        "45": "import java.util.Collection;\n",
        "46": "import java.util.Collections;\n",
        "47": "import java.util.Comparator;\n",
        "48": "import java.util.EnumMap;\n",
        "49": "import java.util.HashMap;\n",
        "50": "import java.util.IdentityHashMap;\n",
        "51": "import java.util.Iterator;\n",
        "52": "import java.util.LinkedHashMap;\n",
        "53": "import java.util.Map;\n",
        "54": "import java.util.Map.Entry;\n",
        "55": "import java.util.Set;\n",
        "56": "import java.util.SortedMap;\n",
        "57": "import java.util.SortedSet;\n",
        "58": "import java.util.TreeMap;\n",
        "59": "import java.util.concurrent.ConcurrentMap;\n",
        "60": "\n",
        "61": "import javax.annotation.CheckReturnValue;\n",
        "62": "import javax.annotation.Nullable;\n",
        "63": "\n",
        "64": "/**\n",
        "65": " * Static utility methods pertaining to {@link Map} instances (including instances of\n",
        "66": " * {@link SortedMap}, {@link BiMap}, etc.). Also see this class's counterparts\n",
        "67": " * {@link Lists}, {@link Sets} and {@link Queues}.\n",
        "68": " *\n",
        "69": " * <p>See the Guava User Guide article on <a href=\n",
        "70": " * \"https://github.com/google/guava/wiki/CollectionUtilitiesExplained#maps\">\n",
        "71": " * {@code Maps}</a>.\n",
        "72": " *\n",
        "73": " * @author Kevin Bourrillion\n",
        "74": " * @author Mike Bostock\n",
        "75": " * @author Isaac Shum\n",
        "76": " * @author Louis Wasserman\n",
        "77": " * @since 2.0\n",
        "78": " */\n",
        "79": "@GwtCompatible(emulated = true)\n",
        "80": "public final class Maps {\n",
        "81": "  private Maps() {}\n",
        "82": "\n",
        "83": "  private enum EntryFunction implements Function<Entry<?, ?>, Object> {\n",
        "84": "    KEY {\n",
        "85": "      @Override\n",
        "86": "      @Nullable\n",
        "87": "      public Object apply(Entry<?, ?> entry) {\n",
        "88": "        return entry.getKey();\n",
        "89": "      }\n",
        "90": "    },\n",
        "91": "    VALUE {\n",
        "92": "      @Override\n",
        "93": "      @Nullable\n",
        "94": "      public Object apply(Entry<?, ?> entry) {\n",
        "95": "        return entry.getValue();\n",
        "96": "      }\n",
        "97": "    };\n",
        "98": "  }\n",
        "99": "\n",
        "100": "  @SuppressWarnings(\"unchecked\")\n",
        "101": "  static <K> Function<Entry<K, ?>, K> keyFunction() {\n",
        "102": "    return (Function) EntryFunction.KEY;\n",
        "103": "  }\n",
        "104": "\n",
        "105": "  @SuppressWarnings(\"unchecked\")\n",
        "106": "  static <V> Function<Entry<?, V>, V> valueFunction() {\n",
        "107": "    return (Function) EntryFunction.VALUE;\n",
        "108": "  }\n",
        "109": "\n",
        "110": "  static <K, V> Iterator<K> keyIterator(Iterator<Entry<K, V>> entryIterator) {\n",
        "111": "    return Iterators.transform(entryIterator, Maps.<K>keyFunction());\n",
        "112": "  }\n",
        "113": "\n",
        "114": "  static <K, V> Iterator<V> valueIterator(Iterator<Entry<K, V>> entryIterator) {\n",
        "115": "    return Iterators.transform(entryIterator, Maps.<V>valueFunction());\n",
        "116": "  }\n",
        "117": "\n",
        "118": "  /**\n",
        "119": "   * Returns an immutable map instance containing the given entries.\n",
        "120": "   * Internally, the returned map will be backed by an {@link EnumMap}.\n",
        "121": "   *\n",
        "122": "   * <p>The iteration order of the returned map follows the enum's iteration\n",
        "123": "   * order, not the order in which the elements appear in the given map.\n",
        "124": "   *\n",
        "125": "   * @param map the map to make an immutable copy of\n",
        "126": "   * @return an immutable map containing those entries\n",
        "127": "   * @since 14.0\n",
        "128": "   */\n",
        "129": "  @GwtCompatible(serializable = true)\n",
        "130": "  @Beta\n",
        "131": "  public static <K extends Enum<K>, V> ImmutableMap<K, V> immutableEnumMap(\n",
        "132": "      Map<K, ? extends V> map) {\n",
        "133": "    if (map instanceof ImmutableEnumMap) {\n",
        "134": "      @SuppressWarnings(\"unchecked\") // safe covariant cast\n",
        "135": "      ImmutableEnumMap<K, V> result = (ImmutableEnumMap<K, V>) map;\n",
        "136": "      return result;\n",
        "137": "    } else if (map.isEmpty()) {\n",
        "138": "      return ImmutableMap.of();\n",
        "139": "    } else {\n",
        "140": "      for (Map.Entry<K, ? extends V> entry : map.entrySet()) {\n",
        "141": "        checkNotNull(entry.getKey());\n",
        "142": "        checkNotNull(entry.getValue());\n",
        "143": "      }\n",
        "144": "      return ImmutableEnumMap.asImmutable(new EnumMap<K, V>(map));\n",
        "145": "    }\n",
        "146": "  }\n",
        "147": "\n",
        "148": "  /**\n",
        "149": "   * Creates a <i>mutable</i>, empty {@code HashMap} instance.\n",
        "150": "   *\n",
        "151": "   * <p><b>Note:</b> if mutability is not required, use {@link\n",
        "152": "   * ImmutableMap#of()} instead.\n",
        "153": "   *\n",
        "154": "   * <p><b>Note:</b> if {@code K} is an {@code enum} type, use {@link\n",
        "155": "   * #newEnumMap} instead.\n",
        "156": "   *\n",
        "157": "   * @return a new, empty {@code HashMap}\n",
        "158": "   */\n",
        "159": "  public static <K, V> HashMap<K, V> newHashMap() {\n",
        "160": "    return new HashMap<K, V>();\n",
        "161": "  }\n",
        "162": "\n",
        "163": "  /**\n",
        "164": "   * Creates a {@code HashMap} instance, with a high enough \"initial capacity\"\n",
        "165": "   * that it <i>should</i> hold {@code expectedSize} elements without growth.\n",
        "166": "   * This behavior cannot be broadly guaranteed, but it is observed to be true\n",
        "167": "   * for OpenJDK 1.7. It also can't be guaranteed that the method isn't\n",
        "168": "   * inadvertently <i>oversizing</i> the returned map.\n",
        "169": "   *\n",
        "170": "   * @param expectedSize the number of entries you expect to add to the\n",
        "171": "   *        returned map\n",
        "172": "   * @return a new, empty {@code HashMap} with enough capacity to hold {@code\n",
        "173": "   *         expectedSize} entries without resizing\n",
        "174": "   * @throws IllegalArgumentException if {@code expectedSize} is negative\n",
        "175": "   */\n",
        "176": "  public static <K, V> HashMap<K, V> newHashMapWithExpectedSize(int expectedSize) {\n",
        "177": "    return new HashMap<K, V>(capacity(expectedSize));\n",
        "178": "  }\n",
        "179": "\n",
        "180": "  /**\n",
        "181": "   * Returns a capacity that is sufficient to keep the map from being resized as\n",
        "182": "   * long as it grows no larger than expectedSize and the load factor is >= its\n",
        "183": "   * default (0.75).\n",
        "184": "   */\n",
        "185": "  static int capacity(int expectedSize) {\n",
        "186": "    if (expectedSize < 3) {\n",
        "187": "      checkNonnegative(expectedSize, \"expectedSize\");\n",
        "188": "      return expectedSize + 1;\n",
        "189": "    }\n",
        "190": "    if (expectedSize < Ints.MAX_POWER_OF_TWO) {\n",
        "191": "      // This is the calculation used in JDK8 to resize when a putAll\n",
        "192": "      // happens; it seems to be the most conservative calculation we\n",
        "193": "      // can make.  0.75 is the default load factor.\n",
        "194": "      return (int) ((float) expectedSize / 0.75F + 1.0F);\n",
        "195": "    }\n",
        "196": "    return Integer.MAX_VALUE; // any large value\n",
        "197": "  }\n",
        "198": "\n",
        "199": "  /**\n",
        "200": "   * Creates a <i>mutable</i> {@code HashMap} instance with the same mappings as\n",
        "201": "   * the specified map.\n",
        "202": "   *\n",
        "203": "   * <p><b>Note:</b> if mutability is not required, use {@link\n",
        "204": "   * ImmutableMap#copyOf(Map)} instead.\n",
        "205": "   *\n",
        "206": "   * <p><b>Note:</b> if {@code K} is an {@link Enum} type, use {@link\n",
        "207": "   * #newEnumMap} instead.\n",
        "208": "   *\n",
        "209": "   * @param map the mappings to be placed in the new map\n",
        "210": "   * @return a new {@code HashMap} initialized with the mappings from {@code\n",
        "211": "   *         map}\n",
        "212": "   */\n",
        "213": "  public static <K, V> HashMap<K, V> newHashMap(Map<? extends K, ? extends V> map) {\n",
        "214": "    return new HashMap<K, V>(map);\n",
        "215": "  }\n",
        "216": "\n",
        "217": "  /**\n",
        "218": "   * Creates a <i>mutable</i>, empty, insertion-ordered {@code LinkedHashMap}\n",
        "219": "   * instance.\n",
        "220": "   *\n",
        "221": "   * <p><b>Note:</b> if mutability is not required, use {@link\n",
        "222": "   * ImmutableMap#of()} instead.\n",
        "223": "   *\n",
        "224": "   * @return a new, empty {@code LinkedHashMap}\n",
        "225": "   */\n",
        "226": "  public static <K, V> LinkedHashMap<K, V> newLinkedHashMap() {\n",
        "227": "    return new LinkedHashMap<K, V>();\n",
        "228": "  }\n",
        "229": "\n",
        "230": "  /**\n",
        "231": "   * Creates a {@code LinkedHashMap} instance, with a high enough\n",
        "232": "   * \"initial capacity\" that it <i>should</i> hold {@code expectedSize}\n",
        "233": "   * elements without growth. This behavior cannot be broadly guaranteed, but\n",
        "234": "   * it is observed to be true for OpenJDK 1.7. It also can't be guaranteed\n",
        "235": "   * that the method isn't inadvertently <i>oversizing</i> the returned map.\n",
        "236": "   *\n",
        "237": "   * @param expectedSize the number of entries you expect to add to the\n",
        "238": "   *        returned map\n",
        "239": "   * @return a new, empty {@code LinkedHashMap} with enough capacity to hold\n",
        "240": "   *         {@code expectedSize} entries without resizing\n",
        "241": "   * @throws IllegalArgumentException if {@code expectedSize} is negative\n",
        "242": "   * @since 19.0\n",
        "243": "   */\n",
        "244": "  public static <K, V> LinkedHashMap<K, V> newLinkedHashMapWithExpectedSize(int expectedSize) {\n",
        "245": "    return new LinkedHashMap<K, V>(capacity(expectedSize));\n",
        "246": "  }\n",
        "247": "\n",
        "248": "  /**\n",
        "249": "   * Creates a <i>mutable</i>, insertion-ordered {@code LinkedHashMap} instance\n",
        "250": "   * with the same mappings as the specified map.\n",
        "251": "   *\n",
        "252": "   * <p><b>Note:</b> if mutability is not required, use {@link\n",
        "253": "   * ImmutableMap#copyOf(Map)} instead.\n",
        "254": "   *\n",
        "255": "   * @param map the mappings to be placed in the new map\n",
        "256": "   * @return a new, {@code LinkedHashMap} initialized with the mappings from\n",
        "257": "   *         {@code map}\n",
        "258": "   */\n",
        "259": "  public static <K, V> LinkedHashMap<K, V> newLinkedHashMap(Map<? extends K, ? extends V> map) {\n",
        "260": "    return new LinkedHashMap<K, V>(map);\n",
        "261": "  }\n",
        "262": "\n",
        "263": "  /**\n",
        "264": "   * Returns a general-purpose instance of {@code ConcurrentMap}, which supports\n",
        "265": "   * all optional operations of the ConcurrentMap interface. It does not permit\n",
        "266": "   * null keys or values. It is serializable.\n",
        "267": "   *\n",
        "268": "   * <p>This is currently accomplished by calling {@link MapMaker#makeMap()}.\n",
        "269": "   *\n",
        "270": "   * <p>It is preferable to use {@code MapMaker} directly (rather than through\n",
        "271": "   * this method), as it presents numerous useful configuration options,\n",
        "272": "   * such as the concurrency level, load factor, key/value reference types,\n",
        "273": "   * and value computation.\n",
        "274": "   *\n",
        "275": "   * @return a new, empty {@code ConcurrentMap}\n",
        "276": "   * @since 3.0\n",
        "277": "   */\n",
        "278": "  public static <K, V> ConcurrentMap<K, V> newConcurrentMap() {\n",
        "279": "    return new MapMaker().<K, V>makeMap();\n",
        "280": "  }\n",
        "281": "\n",
        "282": "  /**\n",
        "283": "   * Creates a <i>mutable</i>, empty {@code TreeMap} instance using the natural\n",
        "284": "   * ordering of its elements.\n",
        "285": "   *\n",
        "286": "   * <p><b>Note:</b> if mutability is not required, use {@link\n",
        "287": "   * ImmutableSortedMap#of()} instead.\n",
        "288": "   *\n",
        "289": "   * @return a new, empty {@code TreeMap}\n",
        "290": "   */\n",
        "291": "  public static <K extends Comparable, V> TreeMap<K, V> newTreeMap() {\n",
        "292": "    return new TreeMap<K, V>();\n",
        "293": "  }\n",
        "294": "\n",
        "295": "  /**\n",
        "296": "   * Creates a <i>mutable</i> {@code TreeMap} instance with the same mappings as\n",
        "297": "   * the specified map and using the same ordering as the specified map.\n",
        "298": "   *\n",
        "299": "   * <p><b>Note:</b> if mutability is not required, use {@link\n",
        "300": "   * ImmutableSortedMap#copyOfSorted(SortedMap)} instead.\n",
        "301": "   *\n",
        "302": "   * @param map the sorted map whose mappings are to be placed in the new map\n",
        "303": "   *        and whose comparator is to be used to sort the new map\n",
        "304": "   * @return a new {@code TreeMap} initialized with the mappings from {@code\n",
        "305": "   *         map} and using the comparator of {@code map}\n",
        "306": "   */\n",
        "307": "  public static <K, V> TreeMap<K, V> newTreeMap(SortedMap<K, ? extends V> map) {\n",
        "308": "    return new TreeMap<K, V>(map);\n",
        "309": "  }\n",
        "310": "\n",
        "311": "  /**\n",
        "312": "   * Creates a <i>mutable</i>, empty {@code TreeMap} instance using the given\n",
        "313": "   * comparator.\n",
        "314": "   *\n",
        "315": "   * <p><b>Note:</b> if mutability is not required, use {@code\n",
        "316": "   * ImmutableSortedMap.orderedBy(comparator).build()} instead.\n",
        "317": "   *\n",
        "318": "   * @param comparator the comparator to sort the keys with\n",
        "319": "   * @return a new, empty {@code TreeMap}\n",
        "320": "   */\n",
        "321": "  public static <C, K extends C, V> TreeMap<K, V> newTreeMap(@Nullable Comparator<C> comparator) {\n",
        "322": "    // Ideally, the extra type parameter \"C\" shouldn't be necessary. It is a\n",
        "323": "    // work-around of a compiler type inference quirk that prevents the\n",
        "324": "    // following code from being compiled:\n",
        "325": "    // Comparator<Class<?>> comparator = null;\n",
        "326": "    // Map<Class<? extends Throwable>, String> map = newTreeMap(comparator);\n",
        "327": "    return new TreeMap<K, V>(comparator);\n",
        "328": "  }\n",
        "329": "\n",
        "330": "  /**\n",
        "331": "   * Creates an {@code EnumMap} instance.\n",
        "332": "   *\n",
        "333": "   * @param type the key type for this map\n",
        "334": "   * @return a new, empty {@code EnumMap}\n",
        "335": "   */\n",
        "336": "  public static <K extends Enum<K>, V> EnumMap<K, V> newEnumMap(Class<K> type) {\n",
        "337": "    return new EnumMap<K, V>(checkNotNull(type));\n",
        "338": "  }\n",
        "339": "\n",
        "340": "  /**\n",
        "341": "   * Creates an {@code EnumMap} with the same mappings as the specified map.\n",
        "342": "   *\n",
        "343": "   * @param map the map from which to initialize this {@code EnumMap}\n",
        "344": "   * @return a new {@code EnumMap} initialized with the mappings from {@code\n",
        "345": "   *         map}\n",
        "346": "   * @throws IllegalArgumentException if {@code m} is not an {@code EnumMap}\n",
        "347": "   *         instance and contains no mappings\n",
        "348": "   */\n",
        "349": "  public static <K extends Enum<K>, V> EnumMap<K, V> newEnumMap(Map<K, ? extends V> map) {\n",
        "350": "    return new EnumMap<K, V>(map);\n",
        "351": "  }\n",
        "352": "\n",
        "353": "  /**\n",
        "354": "   * Creates an {@code IdentityHashMap} instance.\n",
        "355": "   *\n",
        "356": "   * @return a new, empty {@code IdentityHashMap}\n",
        "357": "   */\n",
        "358": "  public static <K, V> IdentityHashMap<K, V> newIdentityHashMap() {\n",
        "359": "    return new IdentityHashMap<K, V>();\n",
        "360": "  }\n",
        "361": "\n",
        "362": "  /**\n",
        "363": "   * Computes the difference between two maps. This difference is an immutable\n",
        "364": "   * snapshot of the state of the maps at the time this method is called. It\n",
        "365": "   * will never change, even if the maps change at a later time.\n",
        "366": "   *\n",
        "367": "   * <p>Since this method uses {@code HashMap} instances internally, the keys of\n",
        "368": "   * the supplied maps must be well-behaved with respect to\n",
        "369": "   * {@link Object#equals} and {@link Object#hashCode}.\n",
        "370": "   *\n",
        "371": "   * <p><b>Note:</b>If you only need to know whether two maps have the same\n",
        "372": "   * mappings, call {@code left.equals(right)} instead of this method.\n",
        "373": "   *\n",
        "374": "   * @param left the map to treat as the \"left\" map for purposes of comparison\n",
        "375": "   * @param right the map to treat as the \"right\" map for purposes of comparison\n",
        "376": "   * @return the difference between the two maps\n",
        "377": "   */\n",
        "378": "  @SuppressWarnings(\"unchecked\")\n",
        "379": "  public static <K, V> MapDifference<K, V> difference(\n",
        "380": "      Map<? extends K, ? extends V> left, Map<? extends K, ? extends V> right) {\n",
        "381": "    if (left instanceof SortedMap) {\n",
        "382": "      SortedMap<K, ? extends V> sortedLeft = (SortedMap<K, ? extends V>) left;\n",
        "383": "      SortedMapDifference<K, V> result = difference(sortedLeft, right);\n",
        "384": "      return result;\n",
        "385": "    }\n",
        "386": "    return difference(left, right, Equivalence.equals());\n",
        "387": "  }\n",
        "388": "\n",
        "389": "  /**\n",
        "390": "   * Computes the difference between two maps. This difference is an immutable\n",
        "391": "   * snapshot of the state of the maps at the time this method is called. It\n",
        "392": "   * will never change, even if the maps change at a later time.\n",
        "393": "   *\n",
        "394": "   * <p>Values are compared using a provided equivalence, in the case of\n",
        "395": "   * equality, the value on the 'left' is returned in the difference.\n",
        "396": "   *\n",
        "397": "   * <p>Since this method uses {@code HashMap} instances internally, the keys of\n",
        "398": "   * the supplied maps must be well-behaved with respect to\n",
        "399": "   * {@link Object#equals} and {@link Object#hashCode}.\n",
        "400": "   *\n",
        "401": "   * @param left the map to treat as the \"left\" map for purposes of comparison\n",
        "402": "   * @param right the map to treat as the \"right\" map for purposes of comparison\n",
        "403": "   * @param valueEquivalence the equivalence relationship to use to compare\n",
        "404": "   *    values\n",
        "405": "   * @return the difference between the two maps\n",
        "406": "   * @since 10.0\n",
        "407": "   */\n",
        "408": "  @Beta\n",
        "409": "  public static <K, V> MapDifference<K, V> difference(\n",
        "410": "      Map<? extends K, ? extends V> left,\n",
        "411": "      Map<? extends K, ? extends V> right,\n",
        "412": "      Equivalence<? super V> valueEquivalence) {\n",
        "413": "    Preconditions.checkNotNull(valueEquivalence);\n",
        "414": "\n",
        "415": "    Map<K, V> onlyOnLeft = newLinkedHashMap();\n",
        "416": "    Map<K, V> onlyOnRight = new LinkedHashMap<K, V>(right); // will whittle it down\n",
        "417": "    Map<K, V> onBoth = newLinkedHashMap();\n",
        "418": "    Map<K, MapDifference.ValueDifference<V>> differences = newLinkedHashMap();\n",
        "419": "    doDifference(left, right, valueEquivalence, onlyOnLeft, onlyOnRight, onBoth, differences);\n",
        "420": "    return new MapDifferenceImpl<K, V>(onlyOnLeft, onlyOnRight, onBoth, differences);\n",
        "421": "  }\n",
        "422": "\n",
        "423": "  private static <K, V> void doDifference(\n",
        "424": "      Map<? extends K, ? extends V> left,\n",
        "425": "      Map<? extends K, ? extends V> right,\n",
        "426": "      Equivalence<? super V> valueEquivalence,\n",
        "427": "      Map<K, V> onlyOnLeft,\n",
        "428": "      Map<K, V> onlyOnRight,\n",
        "429": "      Map<K, V> onBoth,\n",
        "430": "      Map<K, MapDifference.ValueDifference<V>> differences) {\n",
        "431": "    for (Entry<? extends K, ? extends V> entry : left.entrySet()) {\n",
        "432": "      K leftKey = entry.getKey();\n",
        "433": "      V leftValue = entry.getValue();\n",
        "434": "      if (right.containsKey(leftKey)) {\n",
        "435": "        V rightValue = onlyOnRight.remove(leftKey);\n",
        "436": "        if (valueEquivalence.equivalent(leftValue, rightValue)) {\n",
        "437": "          onBoth.put(leftKey, leftValue);\n",
        "438": "        } else {\n",
        "439": "          differences.put(leftKey, ValueDifferenceImpl.create(leftValue, rightValue));\n",
        "440": "        }\n",
        "441": "      } else {\n",
        "442": "        onlyOnLeft.put(leftKey, leftValue);\n",
        "443": "      }\n",
        "444": "    }\n",
        "445": "  }\n",
        "446": "\n",
        "447": "  private static <K, V> Map<K, V> unmodifiableMap(Map<K, V> map) {\n",
        "448": "    if (map instanceof SortedMap) {\n",
        "449": "      return Collections.unmodifiableSortedMap((SortedMap<K, ? extends V>) map);\n",
        "450": "    } else {\n",
        "451": "      return Collections.unmodifiableMap(map);\n",
        "452": "    }\n",
        "453": "  }\n",
        "454": "\n",
        "455": "  static class MapDifferenceImpl<K, V> implements MapDifference<K, V> {\n",
        "456": "    final Map<K, V> onlyOnLeft;\n",
        "457": "    final Map<K, V> onlyOnRight;\n",
        "458": "    final Map<K, V> onBoth;\n",
        "459": "    final Map<K, ValueDifference<V>> differences;\n",
        "460": "\n",
        "461": "    MapDifferenceImpl(\n",
        "462": "        Map<K, V> onlyOnLeft,\n",
        "463": "        Map<K, V> onlyOnRight,\n",
        "464": "        Map<K, V> onBoth,\n",
        "465": "        Map<K, ValueDifference<V>> differences) {\n",
        "466": "      this.onlyOnLeft = unmodifiableMap(onlyOnLeft);\n",
        "467": "      this.onlyOnRight = unmodifiableMap(onlyOnRight);\n",
        "468": "      this.onBoth = unmodifiableMap(onBoth);\n",
        "469": "      this.differences = unmodifiableMap(differences);\n",
        "470": "    }\n",
        "471": "\n",
        "472": "    @Override\n",
        "473": "    public boolean areEqual() {\n",
        "474": "      return onlyOnLeft.isEmpty() && onlyOnRight.isEmpty() && differences.isEmpty();\n",
        "475": "    }\n",
        "476": "\n",
        "477": "    @Override\n",
        "478": "    public Map<K, V> entriesOnlyOnLeft() {\n",
        "479": "      return onlyOnLeft;\n",
        "480": "    }\n",
        "481": "\n",
        "482": "    @Override\n",
        "483": "    public Map<K, V> entriesOnlyOnRight() {\n",
        "484": "      return onlyOnRight;\n",
        "485": "    }\n",
        "486": "\n",
        "487": "    @Override\n",
        "488": "    public Map<K, V> entriesInCommon() {\n",
        "489": "      return onBoth;\n",
        "490": "    }\n",
        "491": "\n",
        "492": "    @Override\n",
        "493": "    public Map<K, ValueDifference<V>> entriesDiffering() {\n",
        "494": "      return differences;\n",
        "495": "    }\n",
        "496": "\n",
        "497": "    @Override\n",
        "498": "    public boolean equals(Object object) {\n",
        "499": "      if (object == this) {\n",
        "500": "        return true;\n",
        "501": "      }\n",
        "502": "      if (object instanceof MapDifference) {\n",
        "503": "        MapDifference<?, ?> other = (MapDifference<?, ?>) object;\n",
        "504": "        return entriesOnlyOnLeft().equals(other.entriesOnlyOnLeft())\n",
        "505": "            && entriesOnlyOnRight().equals(other.entriesOnlyOnRight())\n",
        "506": "            && entriesInCommon().equals(other.entriesInCommon())\n",
        "507": "            && entriesDiffering().equals(other.entriesDiffering());\n",
        "508": "      }\n",
        "509": "      return false;\n",
        "510": "    }\n",
        "511": "\n",
        "512": "    @Override\n",
        "513": "    public int hashCode() {\n",
        "514": "      return Objects.hashCode(\n",
        "515": "          entriesOnlyOnLeft(), entriesOnlyOnRight(), entriesInCommon(), entriesDiffering());\n",
        "516": "    }\n",
        "517": "\n",
        "518": "    @Override\n",
        "519": "    public String toString() {\n",
        "520": "      if (areEqual()) {\n",
        "521": "        return \"equal\";\n",
        "522": "      }\n",
        "523": "\n",
        "524": "      StringBuilder result = new StringBuilder(\"not equal\");\n",
        "525": "      if (!onlyOnLeft.isEmpty()) {\n",
        "526": "        result.append(\": only on left=\").append(onlyOnLeft);\n",
        "527": "      }\n",
        "528": "      if (!onlyOnRight.isEmpty()) {\n",
        "529": "        result.append(\": only on right=\").append(onlyOnRight);\n",
        "530": "      }\n",
        "531": "      if (!differences.isEmpty()) {\n",
        "532": "        result.append(\": value differences=\").append(differences);\n",
        "533": "      }\n",
        "534": "      return result.toString();\n",
        "535": "    }\n",
        "536": "  }\n",
        "537": "\n",
        "538": "  static class ValueDifferenceImpl<V> implements MapDifference.ValueDifference<V> {\n",
        "539": "    private final V left;\n",
        "540": "    private final V right;\n",
        "541": "\n",
        "542": "    static <V> ValueDifference<V> create(@Nullable V left, @Nullable V right) {\n",
        "543": "      return new ValueDifferenceImpl<V>(left, right);\n",
        "544": "    }\n",
        "545": "\n",
        "546": "    private ValueDifferenceImpl(@Nullable V left, @Nullable V right) {\n",
        "547": "      this.left = left;\n",
        "548": "      this.right = right;\n",
        "549": "    }\n",
        "550": "\n",
        "551": "    @Override\n",
        "552": "    public V leftValue() {\n",
        "553": "      return left;\n",
        "554": "    }\n",
        "555": "\n",
        "556": "    @Override\n",
        "557": "    public V rightValue() {\n",
        "558": "      return right;\n",
        "559": "    }\n",
        "560": "\n",
        "561": "    @Override\n",
        "562": "    public boolean equals(@Nullable Object object) {\n",
        "563": "      if (object instanceof MapDifference.ValueDifference) {\n",
        "564": "        MapDifference.ValueDifference<?> that = (MapDifference.ValueDifference<?>) object;\n",
        "565": "        return Objects.equal(this.left, that.leftValue())\n",
        "566": "            && Objects.equal(this.right, that.rightValue());\n",
        "567": "      }\n",
        "568": "      return false;\n",
        "569": "    }\n",
        "570": "\n",
        "571": "    @Override\n",
        "572": "    public int hashCode() {\n",
        "573": "      return Objects.hashCode(left, right);\n",
        "574": "    }\n",
        "575": "\n",
        "576": "    @Override\n",
        "577": "    public String toString() {\n",
        "578": "      return \"(\" + left + \", \" + right + \")\";\n",
        "579": "    }\n",
        "580": "  }\n",
        "581": "\n",
        "582": "  /**\n",
        "583": "   * Computes the difference between two sorted maps, using the comparator of\n",
        "584": "   * the left map, or {@code Ordering.natural()} if the left map uses the\n",
        "585": "   * natural ordering of its elements. This difference is an immutable snapshot\n",
        "586": "   * of the state of the maps at the time this method is called. It will never\n",
        "587": "   * change, even if the maps change at a later time.\n",
        "588": "   *\n",
        "589": "   * <p>Since this method uses {@code TreeMap} instances internally, the keys of\n",
        "590": "   * the right map must all compare as distinct according to the comparator\n",
        "591": "   * of the left map.\n",
        "592": "   *\n",
        "593": "   * <p><b>Note:</b>If you only need to know whether two sorted maps have the\n",
        "594": "   * same mappings, call {@code left.equals(right)} instead of this method.\n",
        "595": "   *\n",
        "596": "   * @param left the map to treat as the \"left\" map for purposes of comparison\n",
        "597": "   * @param right the map to treat as the \"right\" map for purposes of comparison\n",
        "598": "   * @return the difference between the two maps\n",
        "599": "   * @since 11.0\n",
        "600": "   */\n",
        "601": "  public static <K, V> SortedMapDifference<K, V> difference(\n",
        "602": "      SortedMap<K, ? extends V> left, Map<? extends K, ? extends V> right) {\n",
        "603": "    checkNotNull(left);\n",
        "604": "    checkNotNull(right);\n",
        "605": "    Comparator<? super K> comparator = orNaturalOrder(left.comparator());\n",
        "606": "    SortedMap<K, V> onlyOnLeft = Maps.newTreeMap(comparator);\n",
        "607": "    SortedMap<K, V> onlyOnRight = Maps.newTreeMap(comparator);\n",
        "608": "    onlyOnRight.putAll(right); // will whittle it down\n",
        "609": "    SortedMap<K, V> onBoth = Maps.newTreeMap(comparator);\n",
        "610": "    SortedMap<K, MapDifference.ValueDifference<V>> differences = Maps.newTreeMap(comparator);\n",
        "611": "    doDifference(left, right, Equivalence.equals(), onlyOnLeft, onlyOnRight, onBoth, differences);\n",
        "612": "    return new SortedMapDifferenceImpl<K, V>(onlyOnLeft, onlyOnRight, onBoth, differences);\n",
        "613": "  }\n",
        "614": "\n",
        "615": "  static class SortedMapDifferenceImpl<K, V> extends MapDifferenceImpl<K, V>\n",
        "616": "      implements SortedMapDifference<K, V> {\n",
        "617": "    SortedMapDifferenceImpl(\n",
        "618": "        SortedMap<K, V> onlyOnLeft,\n",
        "619": "        SortedMap<K, V> onlyOnRight,\n",
        "620": "        SortedMap<K, V> onBoth,\n",
        "621": "        SortedMap<K, ValueDifference<V>> differences) {\n",
        "622": "      super(onlyOnLeft, onlyOnRight, onBoth, differences);\n",
        "623": "    }\n",
        "624": "\n",
        "625": "    @Override\n",
        "626": "    public SortedMap<K, ValueDifference<V>> entriesDiffering() {\n",
        "627": "      return (SortedMap<K, ValueDifference<V>>) super.entriesDiffering();\n",
        "628": "    }\n",
        "629": "\n",
        "630": "    @Override\n",
        "631": "    public SortedMap<K, V> entriesInCommon() {\n",
        "632": "      return (SortedMap<K, V>) super.entriesInCommon();\n",
        "633": "    }\n",
        "634": "\n",
        "635": "    @Override\n",
        "636": "    public SortedMap<K, V> entriesOnlyOnLeft() {\n",
        "637": "      return (SortedMap<K, V>) super.entriesOnlyOnLeft();\n",
        "638": "    }\n",
        "639": "\n",
        "640": "    @Override\n",
        "641": "    public SortedMap<K, V> entriesOnlyOnRight() {\n",
        "642": "      return (SortedMap<K, V>) super.entriesOnlyOnRight();\n",
        "643": "    }\n",
        "644": "  }\n",
        "645": "\n",
        "646": "  /**\n",
        "647": "   * Returns the specified comparator if not null; otherwise returns {@code\n",
        "648": "   * Ordering.natural()}. This method is an abomination of generics; the only\n",
        "649": "   * purpose of this method is to contain the ugly type-casting in one place.\n",
        "650": "   */\n",
        "651": "  @SuppressWarnings(\"unchecked\")\n",
        "652": "  static <E> Comparator<? super E> orNaturalOrder(@Nullable Comparator<? super E> comparator) {\n",
        "653": "    if (comparator != null) { // can't use ? : because of javac bug 5080917\n",
        "654": "      return comparator;\n",
        "655": "    }\n",
        "656": "    return (Comparator<E>) Ordering.natural();\n",
        "657": "  }\n",
        "658": "\n",
        "659": "  /**\n",
        "660": "   * Returns a live {@link Map} view whose keys are the contents of {@code set}\n",
        "661": "   * and whose values are computed on demand using {@code function}. To get an\n",
        "662": "   * immutable <i>copy</i> instead, use {@link #toMap(Iterable, Function)}.\n",
        "663": "   *\n",
        "664": "   * <p>Specifically, for each {@code k} in the backing set, the returned map\n",
        "665": "   * has an entry mapping {@code k} to {@code function.apply(k)}. The {@code\n",
        "666": "   * keySet}, {@code values}, and {@code entrySet} views of the returned map\n",
        "667": "   * iterate in the same order as the backing set.\n",
        "668": "   *\n",
        "669": "   * <p>Modifications to the backing set are read through to the returned map.\n",
        "670": "   * The returned map supports removal operations if the backing set does.\n",
        "671": "   * Removal operations write through to the backing set.  The returned map\n",
        "672": "   * does not support put operations.\n",
        "673": "   *\n",
        "674": "   * <p><b>Warning:</b> If the function rejects {@code null}, caution is\n",
        "675": "   * required to make sure the set does not contain {@code null}, because the\n",
        "676": "   * view cannot stop {@code null} from being added to the set.\n",
        "677": "   *\n",
        "678": "   * <p><b>Warning:</b> This method assumes that for any instance {@code k} of\n",
        "679": "   * key type {@code K}, {@code k.equals(k2)} implies that {@code k2} is also\n",
        "680": "   * of type {@code K}. Using a key type for which this may not hold, such as\n",
        "681": "   * {@code ArrayList}, may risk a {@code ClassCastException} when calling\n",
        "682": "   * methods on the resulting map view.\n",
        "683": "   *\n",
        "684": "   * @since 14.0\n",
        "685": "   */\n",
        "686": "  public static <K, V> Map<K, V> asMap(Set<K> set, Function<? super K, V> function) {\n",
        "687": "    if (set instanceof SortedSet) {\n",
        "688": "      return asMap((SortedSet<K>) set, function);\n",
        "689": "    } else {\n",
        "690": "      return new AsMapView<K, V>(set, function);\n",
        "691": "    }\n",
        "692": "  }\n",
        "693": "\n",
        "694": "  /**\n",
        "695": "   * Returns a view of the sorted set as a map, mapping keys from the set\n",
        "696": "   * according to the specified function.\n",
        "697": "   *\n",
        "698": "   * <p>Specifically, for each {@code k} in the backing set, the returned map\n",
        "699": "   * has an entry mapping {@code k} to {@code function.apply(k)}. The {@code\n",
        "700": "   * keySet}, {@code values}, and {@code entrySet} views of the returned map\n",
        "701": "   * iterate in the same order as the backing set.\n",
        "702": "   *\n",
        "703": "   * <p>Modifications to the backing set are read through to the returned map.\n",
        "704": "   * The returned map supports removal operations if the backing set does.\n",
        "705": "   * Removal operations write through to the backing set.  The returned map does\n",
        "706": "   * not support put operations.\n",
        "707": "   *\n",
        "708": "   * <p><b>Warning:</b> If the function rejects {@code null}, caution is\n",
        "709": "   * required to make sure the set does not contain {@code null}, because the\n",
        "710": "   * view cannot stop {@code null} from being added to the set.\n",
        "711": "   *\n",
        "712": "   * <p><b>Warning:</b> This method assumes that for any instance {@code k} of\n",
        "713": "   * key type {@code K}, {@code k.equals(k2)} implies that {@code k2} is also of\n",
        "714": "   * type {@code K}. Using a key type for which this may not hold, such as\n",
        "715": "   * {@code ArrayList}, may risk a {@code ClassCastException} when calling\n",
        "716": "   * methods on the resulting map view.\n",
        "717": "   *\n",
        "718": "   * @since 14.0\n",
        "719": "   */\n",
        "720": "  public static <K, V> SortedMap<K, V> asMap(SortedSet<K> set, Function<? super K, V> function) {\n",
        "721": "    return Platform.mapsAsMapSortedSet(set, function);\n",
        "722": "  }\n",
        "723": "\n",
        "724": "  static <K, V> SortedMap<K, V> asMapSortedIgnoreNavigable(\n",
        "725": "      SortedSet<K> set, Function<? super K, V> function) {\n",
        "726": "    return new SortedAsMapView<K, V>(set, function);\n",
        "727": "  }\n",
        "728": "\n",
        "729": "  private static class AsMapView<K, V> extends ViewCachingAbstractMap<K, V> {\n",
        "730": "\n",
        "731": "    private final Set<K> set;\n",
        "732": "    final Function<? super K, V> function;\n",
        "733": "\n",
        "734": "    Set<K> backingSet() {\n",
        "735": "      return set;\n",
        "736": "    }\n",
        "737": "\n",
        "738": "    AsMapView(Set<K> set, Function<? super K, V> function) {\n",
        "739": "      this.set = checkNotNull(set);\n",
        "740": "      this.function = checkNotNull(function);\n",
        "741": "    }\n",
        "742": "\n",
        "743": "    @Override\n",
        "744": "    public Set<K> createKeySet() {\n",
        "745": "      return removeOnlySet(backingSet());\n",
        "746": "    }\n",
        "747": "\n",
        "748": "    @Override\n",
        "749": "    Collection<V> createValues() {\n",
        "750": "      return Collections2.transform(set, function);\n",
        "751": "    }\n",
        "752": "\n",
        "753": "    @Override\n",
        "754": "    public int size() {\n",
        "755": "      return backingSet().size();\n",
        "756": "    }\n",
        "757": "\n",
        "758": "    @Override\n",
        "759": "    public boolean containsKey(@Nullable Object key) {\n",
        "760": "      return backingSet().contains(key);\n",
        "761": "    }\n",
        "762": "\n",
        "763": "    @Override\n",
        "764": "    public V get(@Nullable Object key) {\n",
        "765": "      if (Collections2.safeContains(backingSet(), key)) {\n",
        "766": "        @SuppressWarnings(\"unchecked\") // unsafe, but Javadoc warns about it\n",
        "767": "        K k = (K) key;\n",
        "768": "        return function.apply(k);\n",
        "769": "      } else {\n",
        "770": "        return null;\n",
        "771": "      }\n",
        "772": "    }\n",
        "773": "\n",
        "774": "    @Override\n",
        "775": "    public V remove(@Nullable Object key) {\n",
        "776": "      if (backingSet().remove(key)) {\n",
        "777": "        @SuppressWarnings(\"unchecked\") // unsafe, but Javadoc warns about it\n",
        "778": "        K k = (K) key;\n",
        "779": "        return function.apply(k);\n",
        "780": "      } else {\n",
        "781": "        return null;\n",
        "782": "      }\n",
        "783": "    }\n",
        "784": "\n",
        "785": "    @Override\n",
        "786": "    public void clear() {\n",
        "787": "      backingSet().clear();\n",
        "788": "    }\n",
        "789": "\n",
        "790": "    @Override\n",
        "791": "    protected Set<Entry<K, V>> createEntrySet() {\n",
        "792": "      @WeakOuter\n",
        "793": "      class EntrySetImpl extends EntrySet<K, V> {\n",
        "794": "        @Override\n",
        "795": "        Map<K, V> map() {\n",
        "796": "          return AsMapView.this;\n",
        "797": "        }\n",
        "798": "\n",
        "799": "        @Override\n",
        "800": "        public Iterator<Entry<K, V>> iterator() {\n",
        "801": "          return asMapEntryIterator(backingSet(), function);\n",
        "802": "        }\n",
        "803": "      }\n",
        "804": "      return new EntrySetImpl();\n",
        "805": "    }\n",
        "806": "  }\n",
        "807": "\n",
        "808": "  static <K, V> Iterator<Entry<K, V>> asMapEntryIterator(\n",
        "809": "      Set<K> set, final Function<? super K, V> function) {\n",
        "810": "    return new TransformedIterator<K, Entry<K, V>>(set.iterator()) {\n",
        "811": "      @Override\n",
        "812": "      Entry<K, V> transform(final K key) {\n",
        "813": "        return immutableEntry(key, function.apply(key));\n",
        "814": "      }\n",
        "815": "    };\n",
        "816": "  }\n",
        "817": "\n",
        "818": "  private static class SortedAsMapView<K, V> extends AsMapView<K, V> implements SortedMap<K, V> {\n",
        "819": "\n",
        "820": "    SortedAsMapView(SortedSet<K> set, Function<? super K, V> function) {\n",
        "821": "      super(set, function);\n",
        "822": "    }\n",
        "823": "\n",
        "824": "    @Override\n",
        "825": "    SortedSet<K> backingSet() {\n",
        "826": "      return (SortedSet<K>) super.backingSet();\n",
        "827": "    }\n",
        "828": "\n",
        "829": "    @Override\n",
        "830": "    public Comparator<? super K> comparator() {\n",
        "831": "      return backingSet().comparator();\n",
        "832": "    }\n",
        "833": "\n",
        "834": "    @Override\n",
        "835": "    public Set<K> keySet() {\n",
        "836": "      return removeOnlySortedSet(backingSet());\n",
        "837": "    }\n",
        "838": "\n",
        "839": "    @Override\n",
        "840": "    public SortedMap<K, V> subMap(K fromKey, K toKey) {\n",
        "841": "      return asMap(backingSet().subSet(fromKey, toKey), function);\n",
        "842": "    }\n",
        "843": "\n",
        "844": "    @Override\n",
        "845": "    public SortedMap<K, V> headMap(K toKey) {\n",
        "846": "      return asMap(backingSet().headSet(toKey), function);\n",
        "847": "    }\n",
        "848": "\n",
        "849": "    @Override\n",
        "850": "    public SortedMap<K, V> tailMap(K fromKey) {\n",
        "851": "      return asMap(backingSet().tailSet(fromKey), function);\n",
        "852": "    }\n",
        "853": "\n",
        "854": "    @Override\n",
        "855": "    public K firstKey() {\n",
        "856": "      return backingSet().first();\n",
        "857": "    }\n",
        "858": "\n",
        "859": "    @Override\n",
        "860": "    public K lastKey() {\n",
        "861": "      return backingSet().last();\n",
        "862": "    }\n",
        "863": "  }\n",
        "864": "\n",
        "865": "  private static <E> Set<E> removeOnlySet(final Set<E> set) {\n",
        "866": "    return new ForwardingSet<E>() {\n",
        "867": "      @Override\n",
        "868": "      protected Set<E> delegate() {\n",
        "869": "        return set;\n",
        "870": "      }\n",
        "871": "\n",
        "872": "      @Override\n",
        "873": "      public boolean add(E element) {\n",
        "874": "        throw new UnsupportedOperationException();\n",
        "875": "      }\n",
        "876": "\n",
        "877": "      @Override\n",
        "878": "      public boolean addAll(Collection<? extends E> es) {\n",
        "879": "        throw new UnsupportedOperationException();\n",
        "880": "      }\n",
        "881": "    };\n",
        "882": "  }\n",
        "883": "\n",
        "884": "  private static <E> SortedSet<E> removeOnlySortedSet(final SortedSet<E> set) {\n",
        "885": "    return new ForwardingSortedSet<E>() {\n",
        "886": "      @Override\n",
        "887": "      protected SortedSet<E> delegate() {\n",
        "888": "        return set;\n",
        "889": "      }\n",
        "890": "\n",
        "891": "      @Override\n",
        "892": "      public boolean add(E element) {\n",
        "893": "        throw new UnsupportedOperationException();\n",
        "894": "      }\n",
        "895": "\n",
        "896": "      @Override\n",
        "897": "      public boolean addAll(Collection<? extends E> es) {\n",
        "898": "        throw new UnsupportedOperationException();\n",
        "899": "      }\n",
        "900": "\n",
        "901": "      @Override\n",
        "902": "      public SortedSet<E> headSet(E toElement) {\n",
        "903": "        return removeOnlySortedSet(super.headSet(toElement));\n",
        "904": "      }\n",
        "905": "\n",
        "906": "      @Override\n",
        "907": "      public SortedSet<E> subSet(E fromElement, E toElement) {\n",
        "908": "        return removeOnlySortedSet(super.subSet(fromElement, toElement));\n",
        "909": "      }\n",
        "910": "\n",
        "911": "      @Override\n",
        "912": "      public SortedSet<E> tailSet(E fromElement) {\n",
        "913": "        return removeOnlySortedSet(super.tailSet(fromElement));\n",
        "914": "      }\n",
        "915": "    };\n",
        "916": "  }\n",
        "917": "\n",
        "918": "  /**\n",
        "919": "   * Returns an immutable map whose keys are the distinct elements of {@code\n",
        "920": "   * keys} and whose value for each key was computed by {@code valueFunction}.\n",
        "921": "   * The map's iteration order is the order of the first appearance of each key\n",
        "922": "   * in {@code keys}.\n",
        "923": "   *\n",
        "924": "   * <p>When there are multiple instances of a key in {@code keys}, it is\n",
        "925": "   * unspecified whether {@code valueFunction} will be applied to more than one\n",
        "926": "   * instance of that key and, if it is, which result will be mapped to that\n",
        "927": "   * key in the returned map.\n",
        "928": "   *\n",
        "929": "   * <p>If {@code keys} is a {@link Set}, a live view can be obtained instead of\n",
        "930": "   * a copy using {@link Maps#asMap(Set, Function)}.\n",
        "931": "   *\n",
        "932": "   * @throws NullPointerException if any element of {@code keys} is\n",
        "933": "   *     {@code null}, or if {@code valueFunction} produces {@code null}\n",
        "934": "   *     for any key\n",
        "935": "   * @since 14.0\n",
        "936": "   */\n",
        "937": "  public static <K, V> ImmutableMap<K, V> toMap(\n",
        "938": "      Iterable<K> keys, Function<? super K, V> valueFunction) {\n",
        "939": "    return toMap(keys.iterator(), valueFunction);\n",
        "940": "  }\n",
        "941": "\n",
        "942": "  /**\n",
        "943": "   * Returns an immutable map whose keys are the distinct elements of {@code\n",
        "944": "   * keys} and whose value for each key was computed by {@code valueFunction}.\n",
        "945": "   * The map's iteration order is the order of the first appearance of each key\n",
        "946": "   * in {@code keys}.\n",
        "947": "   *\n",
        "948": "   * <p>When there are multiple instances of a key in {@code keys}, it is\n",
        "949": "   * unspecified whether {@code valueFunction} will be applied to more than one\n",
        "950": "   * instance of that key and, if it is, which result will be mapped to that\n",
        "951": "   * key in the returned map.\n",
        "952": "   *\n",
        "953": "   * @throws NullPointerException if any element of {@code keys} is\n",
        "954": "   *     {@code null}, or if {@code valueFunction} produces {@code null}\n",
        "955": "   *     for any key\n",
        "956": "   * @since 14.0\n",
        "957": "   */\n",
        "958": "  public static <K, V> ImmutableMap<K, V> toMap(\n",
        "959": "      Iterator<K> keys, Function<? super K, V> valueFunction) {\n",
        "960": "    checkNotNull(valueFunction);\n",
        "961": "    // Using LHM instead of a builder so as not to fail on duplicate keys\n",
        "962": "    Map<K, V> builder = newLinkedHashMap();\n",
        "963": "    while (keys.hasNext()) {\n",
        "964": "      K key = keys.next();\n",
        "965": "      builder.put(key, valueFunction.apply(key));\n",
        "966": "    }\n",
        "967": "    return ImmutableMap.copyOf(builder);\n",
        "968": "  }\n",
        "969": "\n",
        "970": "  /**\n",
        "971": "   * Returns a map with the given {@code values}, indexed by keys derived from\n",
        "972": "   * those values. In other words, each input value produces an entry in the map\n",
        "973": "   * whose key is the result of applying {@code keyFunction} to that value.\n",
        "974": "   * These entries appear in the same order as the input values. Example usage:\n",
        "975": "   * <pre>   {@code\n",
        "976": "   *\n",
        "977": "   *   Color red = new Color(\"red\", 255, 0, 0);\n",
        "978": "   *   ...\n",
        "979": "   *   ImmutableSet<Color> allColors = ImmutableSet.of(red, green, blue);\n",
        "980": "   *\n",
        "981": "   *   Map<String, Color> colorForName =\n",
        "982": "   *       uniqueIndex(allColors, toStringFunction());\n",
        "983": "   *   assertThat(colorForName).containsEntry(\"red\", red);}</pre>\n",
        "984": "   *\n",
        "985": "   * <p>If your index may associate multiple values with each key, use {@link\n",
        "986": "   * Multimaps#index(Iterable, Function) Multimaps.index}.\n",
        "987": "   *\n",
        "988": "   * @param values the values to use when constructing the {@code Map}\n",
        "989": "   * @param keyFunction the function used to produce the key for each value\n",
        "990": "   * @return a map mapping the result of evaluating the function {@code\n",
        "991": "   *         keyFunction} on each value in the input collection to that value\n",
        "992": "   * @throws IllegalArgumentException if {@code keyFunction} produces the same\n",
        "993": "   *         key for more than one value in the input collection\n",
        "994": "   * @throws NullPointerException if any elements of {@code values} is null, or\n",
        "995": "   *         if {@code keyFunction} produces {@code null} for any value\n",
        "996": "   */\n",
        "997": "  public static <K, V> ImmutableMap<K, V> uniqueIndex(\n",
        "998": "      Iterable<V> values, Function<? super V, K> keyFunction) {\n",
        "999": "    // TODO(lowasser): consider presizing the builder if values is a Collection\n",
        "1000": "    return uniqueIndex(values.iterator(), keyFunction);\n",
        "1001": "  }\n",
        "1002": "\n",
        "1003": "  /**\n",
        "1004": "   * Returns a map with the given {@code values}, indexed by keys derived from\n",
        "1005": "   * those values. In other words, each input value produces an entry in the map\n",
        "1006": "   * whose key is the result of applying {@code keyFunction} to that value.\n",
        "1007": "   * These entries appear in the same order as the input values. Example usage:\n",
        "1008": "   * <pre>   {@code\n",
        "1009": "   *\n",
        "1010": "   *   Color red = new Color(\"red\", 255, 0, 0);\n",
        "1011": "   *   ...\n",
        "1012": "   *   Iterator<Color> allColors = ImmutableSet.of(red, green, blue).iterator();\n",
        "1013": "   *\n",
        "1014": "   *   Map<String, Color> colorForName =\n",
        "1015": "   *       uniqueIndex(allColors, toStringFunction());\n",
        "1016": "   *   assertThat(colorForName).containsEntry(\"red\", red);}</pre>\n",
        "1017": "   *\n",
        "1018": "   * <p>If your index may associate multiple values with each key, use {@link\n",
        "1019": "   * Multimaps#index(Iterator, Function) Multimaps.index}.\n",
        "1020": "   *\n",
        "1021": "   * @param values the values to use when constructing the {@code Map}\n",
        "1022": "   * @param keyFunction the function used to produce the key for each value\n",
        "1023": "   * @return a map mapping the result of evaluating the function {@code\n",
        "1024": "   *         keyFunction} on each value in the input collection to that value\n",
        "1025": "   * @throws IllegalArgumentException if {@code keyFunction} produces the same\n",
        "1026": "   *         key for more than one value in the input collection\n",
        "1027": "   * @throws NullPointerException if any elements of {@code values} is null, or\n",
        "1028": "   *         if {@code keyFunction} produces {@code null} for any value\n",
        "1029": "   * @since 10.0\n",
        "1030": "   */\n",
        "1031": "  public static <K, V> ImmutableMap<K, V> uniqueIndex(\n",
        "1032": "      Iterator<V> values, Function<? super V, K> keyFunction) {\n",
        "1033": "    checkNotNull(keyFunction);\n",
        "1034": "    ImmutableMap.Builder<K, V> builder = ImmutableMap.builder();\n",
        "1035": "    while (values.hasNext()) {\n",
        "1036": "      V value = values.next();\n",
        "1037": "      builder.put(keyFunction.apply(value), value);\n",
        "1038": "    }\n",
        "1039": "    try {\n",
        "1040": "      return builder.build();\n",
        "1041": "    } catch (IllegalArgumentException duplicateKeys) {\n",
        "1042": "      throw new IllegalArgumentException(\n",
        "1043": "          duplicateKeys.getMessage()\n",
        "1044": "              + \". To index multiple values under a key, use Multimaps.index.\");\n",
        "1045": "    }\n",
        "1046": "  }\n",
        "1047": "\n",
        "1048": "  /**\n",
        "1049": "   * Returns an immutable map entry with the specified key and value. The {@link\n",
        "1050": "   * Entry#setValue} operation throws an {@link UnsupportedOperationException}.\n",
        "1051": "   *\n",
        "1052": "   * <p>The returned entry is serializable.\n",
        "1053": "   *\n",
        "1054": "   * @param key the key to be associated with the returned entry\n",
        "1055": "   * @param value the value to be associated with the returned entry\n",
        "1056": "   */\n",
        "1057": "  @GwtCompatible(serializable = true)\n",
        "1058": "  public static <K, V> Entry<K, V> immutableEntry(@Nullable K key, @Nullable V value) {\n",
        "1059": "    return new ImmutableEntry<K, V>(key, value);\n",
        "1060": "  }\n",
        "1061": "\n",
        "1062": "  /**\n",
        "1063": "   * Returns an unmodifiable view of the specified set of entries. The {@link\n",
        "1064": "   * Entry#setValue} operation throws an {@link UnsupportedOperationException},\n",
        "1065": "   * as do any operations that would modify the returned set.\n",
        "1066": "   *\n",
        "1067": "   * @param entrySet the entries for which to return an unmodifiable view\n",
        "1068": "   * @return an unmodifiable view of the entries\n",
        "1069": "   */\n",
        "1070": "  static <K, V> Set<Entry<K, V>> unmodifiableEntrySet(Set<Entry<K, V>> entrySet) {\n",
        "1071": "    return new UnmodifiableEntrySet<K, V>(Collections.unmodifiableSet(entrySet));\n",
        "1072": "  }\n",
        "1073": "\n",
        "1074": "  /**\n",
        "1075": "   * Returns an unmodifiable view of the specified map entry. The {@link\n",
        "1076": "   * Entry#setValue} operation throws an {@link UnsupportedOperationException}.\n",
        "1077": "   * This also has the side-effect of redefining {@code equals} to comply with\n",
        "1078": "   * the Entry contract, to avoid a possible nefarious implementation of equals.\n",
        "1079": "   *\n",
        "1080": "   * @param entry the entry for which to return an unmodifiable view\n",
        "1081": "   * @return an unmodifiable view of the entry\n",
        "1082": "   */\n",
        "1083": "  static <K, V> Entry<K, V> unmodifiableEntry(final Entry<? extends K, ? extends V> entry) {\n",
        "1084": "    checkNotNull(entry);\n",
        "1085": "    return new AbstractMapEntry<K, V>() {\n",
        "1086": "      @Override\n",
        "1087": "      public K getKey() {\n",
        "1088": "        return entry.getKey();\n",
        "1089": "      }\n",
        "1090": "\n",
        "1091": "      @Override\n",
        "1092": "      public V getValue() {\n",
        "1093": "        return entry.getValue();\n",
        "1094": "      }\n",
        "1095": "    };\n",
        "1096": "  }\n",
        "1097": "\n",
        "1098": "  static <K, V> UnmodifiableIterator<Entry<K, V>> unmodifiableEntryIterator(\n",
        "1099": "      final Iterator<Entry<K, V>> entryIterator) {\n",
        "1100": "    return new UnmodifiableIterator<Entry<K, V>>() {\n",
        "1101": "      @Override\n",
        "1102": "      public boolean hasNext() {\n",
        "1103": "        return entryIterator.hasNext();\n",
        "1104": "      }\n",
        "1105": "\n",
        "1106": "      @Override\n",
        "1107": "      public Entry<K, V> next() {\n",
        "1108": "        return unmodifiableEntry(entryIterator.next());\n",
        "1109": "      }\n",
        "1110": "    };\n",
        "1111": "  }\n",
        "1112": "\n",
        "1113": "  /** @see Multimaps#unmodifiableEntries */\n",
        "1114": "  static class UnmodifiableEntries<K, V> extends ForwardingCollection<Entry<K, V>> {\n",
        "1115": "    private final Collection<Entry<K, V>> entries;\n",
        "1116": "\n",
        "1117": "    UnmodifiableEntries(Collection<Entry<K, V>> entries) {\n",
        "1118": "      this.entries = entries;\n",
        "1119": "    }\n",
        "1120": "\n",
        "1121": "    @Override\n",
        "1122": "    protected Collection<Entry<K, V>> delegate() {\n",
        "1123": "      return entries;\n",
        "1124": "    }\n",
        "1125": "\n",
        "1126": "    @Override\n",
        "1127": "    public Iterator<Entry<K, V>> iterator() {\n",
        "1128": "      return unmodifiableEntryIterator(entries.iterator());\n",
        "1129": "    }\n",
        "1130": "\n",
        "1131": "    // See java.util.Collections.UnmodifiableEntrySet for details on attacks.\n",
        "1132": "\n",
        "1133": "    @Override\n",
        "1134": "    public Object[] toArray() {\n",
        "1135": "      return standardToArray();\n",
        "1136": "    }\n",
        "1137": "\n",
        "1138": "    @Override\n",
        "1139": "    public <T> T[] toArray(T[] array) {\n",
        "1140": "      return standardToArray(array);\n",
        "1141": "    }\n",
        "1142": "  }\n",
        "1143": "\n",
        "1144": "  /** @see Maps#unmodifiableEntrySet(Set) */\n",
        "1145": "  static class UnmodifiableEntrySet<K, V> extends UnmodifiableEntries<K, V>\n",
        "1146": "      implements Set<Entry<K, V>> {\n",
        "1147": "    UnmodifiableEntrySet(Set<Entry<K, V>> entries) {\n",
        "1148": "      super(entries);\n",
        "1149": "    }\n",
        "1150": "\n",
        "1151": "    // See java.util.Collections.UnmodifiableEntrySet for details on attacks.\n",
        "1152": "\n",
        "1153": "    @Override\n",
        "1154": "    public boolean equals(@Nullable Object object) {\n",
        "1155": "      return Sets.equalsImpl(this, object);\n",
        "1156": "    }\n",
        "1157": "\n",
        "1158": "    @Override\n",
        "1159": "    public int hashCode() {\n",
        "1160": "      return Sets.hashCodeImpl(this);\n",
        "1161": "    }\n",
        "1162": "  }\n",
        "1163": "\n",
        "1164": "  /**\n",
        "1165": "   * Returns a {@link Converter} that converts values using {@link BiMap#get bimap.get()},\n",
        "1166": "   * and whose inverse view converts values using\n",
        "1167": "   * {@link BiMap#inverse bimap.inverse()}{@code .get()}.\n",
        "1168": "   *\n",
        "1169": "   * <p>To use a plain {@link Map} as a {@link Function}, see\n",
        "1170": "   * {@link com.google.common.base.Functions#forMap(Map)} or\n",
        "1171": "   * {@link com.google.common.base.Functions#forMap(Map, Object)}.\n",
        "1172": "   *\n",
        "1173": "   * @since 16.0\n",
        "1174": "   */\n",
        "1175": "  @Beta\n",
        "1176": "  public static <A, B> Converter<A, B> asConverter(final BiMap<A, B> bimap) {\n",
        "1177": "    return new BiMapConverter<A, B>(bimap);\n",
        "1178": "  }\n",
        "1179": "\n",
        "1180": "  private static final class BiMapConverter<A, B> extends Converter<A, B> implements Serializable {\n",
        "1181": "    private final BiMap<A, B> bimap;\n",
        "1182": "\n",
        "1183": "    BiMapConverter(BiMap<A, B> bimap) {\n",
        "1184": "      this.bimap = checkNotNull(bimap);\n",
        "1185": "    }\n",
        "1186": "\n",
        "1187": "    @Override\n",
        "1188": "    protected B doForward(A a) {\n",
        "1189": "      return convert(bimap, a);\n",
        "1190": "    }\n",
        "1191": "\n",
        "1192": "    @Override\n",
        "1193": "    protected A doBackward(B b) {\n",
        "1194": "      return convert(bimap.inverse(), b);\n",
        "1195": "    }\n",
        "1196": "\n",
        "1197": "    private static <X, Y> Y convert(BiMap<X, Y> bimap, X input) {\n",
        "1198": "      Y output = bimap.get(input);\n",
        "1199": "      checkArgument(output != null, \"No non-null mapping present for input: %s\", input);\n",
        "1200": "      return output;\n",
        "1201": "    }\n",
        "1202": "\n",
        "1203": "    @Override\n",
        "1204": "    public boolean equals(@Nullable Object object) {\n",
        "1205": "      if (object instanceof BiMapConverter) {\n",
        "1206": "        BiMapConverter<?, ?> that = (BiMapConverter<?, ?>) object;\n",
        "1207": "        return this.bimap.equals(that.bimap);\n",
        "1208": "      }\n",
        "1209": "      return false;\n",
        "1210": "    }\n",
        "1211": "\n",
        "1212": "    @Override\n",
        "1213": "    public int hashCode() {\n",
        "1214": "      return bimap.hashCode();\n",
        "1215": "    }\n",
        "1216": "\n",
        "1217": "    // There's really no good way to implement toString() without printing the entire BiMap, right?\n",
        "1218": "    @Override\n",
        "1219": "    public String toString() {\n",
        "1220": "      return \"Maps.asConverter(\" + bimap + \")\";\n",
        "1221": "    }\n",
        "1222": "\n",
        "1223": "    private static final long serialVersionUID = 0L;\n",
        "1224": "  }\n",
        "1225": "\n",
        "1226": "  /**\n",
        "1227": "   * Returns a synchronized (thread-safe) bimap backed by the specified bimap.\n",
        "1228": "   * In order to guarantee serial access, it is critical that <b>all</b> access\n",
        "1229": "   * to the backing bimap is accomplished through the returned bimap.\n",
        "1230": "   *\n",
        "1231": "   * <p>It is imperative that the user manually synchronize on the returned map\n",
        "1232": "   * when accessing any of its collection views: <pre>   {@code\n",
        "1233": "   *\n",
        "1234": "   *   BiMap<Long, String> map = Maps.synchronizedBiMap(\n",
        "1235": "   *       HashBiMap.<Long, String>create());\n",
        "1236": "   *   ...\n",
        "1237": "   *   Set<Long> set = map.keySet();  // Needn't be in synchronized block\n",
        "1238": "   *   ...\n",
        "1239": "   *   synchronized (map) {  // Synchronizing on map, not set!\n",
        "1240": "   *     Iterator<Long> it = set.iterator(); // Must be in synchronized block\n",
        "1241": "   *     while (it.hasNext()) {\n",
        "1242": "   *       foo(it.next());\n",
        "1243": "   *     }\n",
        "1244": "   *   }}</pre>\n",
        "1245": "   *\n",
        "1246": "   * <p>Failure to follow this advice may result in non-deterministic behavior.\n",
        "1247": "   *\n",
        "1248": "   * <p>The returned bimap will be serializable if the specified bimap is\n",
        "1249": "   * serializable.\n",
        "1250": "   *\n",
        "1251": "   * @param bimap the bimap to be wrapped in a synchronized view\n",
        "1252": "   * @return a sychronized view of the specified bimap\n",
        "1253": "   */\n",
        "1254": "  public static <K, V> BiMap<K, V> synchronizedBiMap(BiMap<K, V> bimap) {\n",
        "1255": "    return Synchronized.biMap(bimap, null);\n",
        "1256": "  }\n",
        "1257": "\n",
        "1258": "  /**\n",
        "1259": "   * Returns an unmodifiable view of the specified bimap. This method allows\n",
        "1260": "   * modules to provide users with \"read-only\" access to internal bimaps. Query\n",
        "1261": "   * operations on the returned bimap \"read through\" to the specified bimap, and\n",
        "1262": "   * attempts to modify the returned map, whether direct or via its collection\n",
        "1263": "   * views, result in an {@code UnsupportedOperationException}.\n",
        "1264": "   *\n",
        "1265": "   * <p>The returned bimap will be serializable if the specified bimap is\n",
        "1266": "   * serializable.\n",
        "1267": "   *\n",
        "1268": "   * @param bimap the bimap for which an unmodifiable view is to be returned\n",
        "1269": "   * @return an unmodifiable view of the specified bimap\n",
        "1270": "   */\n",
        "1271": "  public static <K, V> BiMap<K, V> unmodifiableBiMap(BiMap<? extends K, ? extends V> bimap) {\n",
        "1272": "    return new UnmodifiableBiMap<K, V>(bimap, null);\n",
        "1273": "  }\n",
        "1274": "\n",
        "1275": "  /** @see Maps#unmodifiableBiMap(BiMap) */\n",
        "1276": "  private static class UnmodifiableBiMap<K, V> extends ForwardingMap<K, V>\n",
        "1277": "      implements BiMap<K, V>, Serializable {\n",
        "1278": "    final Map<K, V> unmodifiableMap;\n",
        "1279": "    final BiMap<? extends K, ? extends V> delegate;\n",
        "1280": "    BiMap<V, K> inverse;\n",
        "1281": "    transient Set<V> values;\n",
        "1282": "\n",
        "1283": "    UnmodifiableBiMap(BiMap<? extends K, ? extends V> delegate, @Nullable BiMap<V, K> inverse) {\n",
        "1284": "      unmodifiableMap = Collections.unmodifiableMap(delegate);\n",
        "1285": "      this.delegate = delegate;\n",
        "1286": "      this.inverse = inverse;\n",
        "1287": "    }\n",
        "1288": "\n",
        "1289": "    @Override\n",
        "1290": "    protected Map<K, V> delegate() {\n",
        "1291": "      return unmodifiableMap;\n",
        "1292": "    }\n",
        "1293": "\n",
        "1294": "    @Override\n",
        "1295": "    public V forcePut(K key, V value) {\n",
        "1296": "      throw new UnsupportedOperationException();\n",
        "1297": "    }\n",
        "1298": "\n",
        "1299": "    @Override\n",
        "1300": "    public BiMap<V, K> inverse() {\n",
        "1301": "      BiMap<V, K> result = inverse;\n",
        "1302": "      return (result == null)\n",
        "1303": "          ? inverse = new UnmodifiableBiMap<V, K>(delegate.inverse(), this)\n",
        "1304": "          : result;\n",
        "1305": "    }\n",
        "1306": "\n",
        "1307": "    @Override\n",
        "1308": "    public Set<V> values() {\n",
        "1309": "      Set<V> result = values;\n",
        "1310": "      return (result == null)\n",
        "1311": "          ? values = Collections.unmodifiableSet(delegate.values())\n",
        "1312": "          : result;\n",
        "1313": "    }\n",
        "1314": "\n",
        "1315": "    private static final long serialVersionUID = 0;\n",
        "1316": "  }\n",
        "1317": "\n",
        "1318": "  /**\n",
        "1319": "   * Returns a view of a map where each value is transformed by a function. All\n",
        "1320": "   * other properties of the map, such as iteration order, are left intact. For\n",
        "1321": "   * example, the code: <pre>   {@code\n",
        "1322": "   *\n",
        "1323": "   *   Map<String, Integer> map = ImmutableMap.of(\"a\", 4, \"b\", 9);\n",
        "1324": "   *   Function<Integer, Double> sqrt =\n",
        "1325": "   *       new Function<Integer, Double>() {\n",
        "1326": "   *         public Double apply(Integer in) {\n",
        "1327": "   *           return Math.sqrt((int) in);\n",
        "1328": "   *         }\n",
        "1329": "   *       };\n",
        "1330": "   *   Map<String, Double> transformed = Maps.transformValues(map, sqrt);\n",
        "1331": "   *   System.out.println(transformed);}</pre>\n",
        "1332": "   *\n",
        "1333": "   * ... prints {@code {a=2.0, b=3.0}}.\n",
        "1334": "   *\n",
        "1335": "   * <p>Changes in the underlying map are reflected in this view. Conversely,\n",
        "1336": "   * this view supports removal operations, and these are reflected in the\n",
        "1337": "   * underlying map.\n",
        "1338": "   *\n",
        "1339": "   * <p>It's acceptable for the underlying map to contain null keys, and even\n",
        "1340": "   * null values provided that the function is capable of accepting null input.\n",
        "1341": "   * The transformed map might contain null values, if the function sometimes\n",
        "1342": "   * gives a null result.\n",
        "1343": "   *\n",
        "1344": "   * <p>The returned map is not thread-safe or serializable, even if the\n",
        "1345": "   * underlying map is.\n",
        "1346": "   *\n",
        "1347": "   * <p>The function is applied lazily, invoked when needed. This is necessary\n",
        "1348": "   * for the returned map to be a view, but it means that the function will be\n",
        "1349": "   * applied many times for bulk operations like {@link Map#containsValue} and\n",
        "1350": "   * {@code Map.toString()}. For this to perform well, {@code function} should\n",
        "1351": "   * be fast. To avoid lazy evaluation when the returned map doesn't need to be\n",
        "1352": "   * a view, copy the returned map into a new map of your choosing.\n",
        "1353": "   */\n",
        "1354": "  public static <K, V1, V2> Map<K, V2> transformValues(\n",
        "1355": "      Map<K, V1> fromMap, Function<? super V1, V2> function) {\n",
        "1356": "    return transformEntries(fromMap, asEntryTransformer(function));\n",
        "1357": "  }\n",
        "1358": "\n",
        "1359": "  /**\n",
        "1360": "   * Returns a view of a sorted map where each value is transformed by a\n",
        "1361": "   * function. All other properties of the map, such as iteration order, are\n",
        "1362": "   * left intact. For example, the code: <pre>   {@code\n",
        "1363": "   *\n",
        "1364": "   *   SortedMap<String, Integer> map = ImmutableSortedMap.of(\"a\", 4, \"b\", 9);\n",
        "1365": "   *   Function<Integer, Double> sqrt =\n",
        "1366": "   *       new Function<Integer, Double>() {\n",
        "1367": "   *         public Double apply(Integer in) {\n",
        "1368": "   *           return Math.sqrt((int) in);\n",
        "1369": "   *         }\n",
        "1370": "   *       };\n",
        "1371": "   *   SortedMap<String, Double> transformed =\n",
        "1372": "   *        Maps.transformValues(map, sqrt);\n",
        "1373": "   *   System.out.println(transformed);}</pre>\n",
        "1374": "   *\n",
        "1375": "   * ... prints {@code {a=2.0, b=3.0}}.\n",
        "1376": "   *\n",
        "1377": "   * <p>Changes in the underlying map are reflected in this view. Conversely,\n",
        "1378": "   * this view supports removal operations, and these are reflected in the\n",
        "1379": "   * underlying map.\n",
        "1380": "   *\n",
        "1381": "   * <p>It's acceptable for the underlying map to contain null keys, and even\n",
        "1382": "   * null values provided that the function is capable of accepting null input.\n",
        "1383": "   * The transformed map might contain null values, if the function sometimes\n",
        "1384": "   * gives a null result.\n",
        "1385": "   *\n",
        "1386": "   * <p>The returned map is not thread-safe or serializable, even if the\n",
        "1387": "   * underlying map is.\n",
        "1388": "   *\n",
        "1389": "   * <p>The function is applied lazily, invoked when needed. This is necessary\n",
        "1390": "   * for the returned map to be a view, but it means that the function will be\n",
        "1391": "   * applied many times for bulk operations like {@link Map#containsValue} and\n",
        "1392": "   * {@code Map.toString()}. For this to perform well, {@code function} should\n",
        "1393": "   * be fast. To avoid lazy evaluation when the returned map doesn't need to be\n",
        "1394": "   * a view, copy the returned map into a new map of your choosing.\n",
        "1395": "   *\n",
        "1396": "   * @since 11.0\n",
        "1397": "   */\n",
        "1398": "  public static <K, V1, V2> SortedMap<K, V2> transformValues(\n",
        "1399": "      SortedMap<K, V1> fromMap, Function<? super V1, V2> function) {\n",
        "1400": "    return transformEntries(fromMap, asEntryTransformer(function));\n",
        "1401": "  }\n",
        "1402": "\n",
        "1403": "  /**\n",
        "1404": "   * Returns a view of a map whose values are derived from the original map's\n",
        "1405": "   * entries. In contrast to {@link #transformValues}, this method's\n",
        "1406": "   * entry-transformation logic may depend on the key as well as the value.\n",
        "1407": "   *\n",
        "1408": "   * <p>All other properties of the transformed map, such as iteration order,\n",
        "1409": "   * are left intact. For example, the code: <pre>   {@code\n",
        "1410": "   *\n",
        "1411": "   *   Map<String, Boolean> options =\n",
        "1412": "   *       ImmutableMap.of(\"verbose\", true, \"sort\", false);\n",
        "1413": "   *   EntryTransformer<String, Boolean, String> flagPrefixer =\n",
        "1414": "   *       new EntryTransformer<String, Boolean, String>() {\n",
        "1415": "   *         public String transformEntry(String key, Boolean value) {\n",
        "1416": "   *           return value ? key : \"no\" + key;\n",
        "1417": "   *         }\n",
        "1418": "   *       };\n",
        "1419": "   *   Map<String, String> transformed =\n",
        "1420": "   *       Maps.transformEntries(options, flagPrefixer);\n",
        "1421": "   *   System.out.println(transformed);}</pre>\n",
        "1422": "   *\n",
        "1423": "   * ... prints {@code {verbose=verbose, sort=nosort}}.\n",
        "1424": "   *\n",
        "1425": "   * <p>Changes in the underlying map are reflected in this view. Conversely,\n",
        "1426": "   * this view supports removal operations, and these are reflected in the\n",
        "1427": "   * underlying map.\n",
        "1428": "   *\n",
        "1429": "   * <p>It's acceptable for the underlying map to contain null keys and null\n",
        "1430": "   * values provided that the transformer is capable of accepting null inputs.\n",
        "1431": "   * The transformed map might contain null values if the transformer sometimes\n",
        "1432": "   * gives a null result.\n",
        "1433": "   *\n",
        "1434": "   * <p>The returned map is not thread-safe or serializable, even if the\n",
        "1435": "   * underlying map is.\n",
        "1436": "   *\n",
        "1437": "   * <p>The transformer is applied lazily, invoked when needed. This is\n",
        "1438": "   * necessary for the returned map to be a view, but it means that the\n",
        "1439": "   * transformer will be applied many times for bulk operations like {@link\n",
        "1440": "   * Map#containsValue} and {@link Object#toString}. For this to perform well,\n",
        "1441": "   * {@code transformer} should be fast. To avoid lazy evaluation when the\n",
        "1442": "   * returned map doesn't need to be a view, copy the returned map into a new\n",
        "1443": "   * map of your choosing.\n",
        "1444": "   *\n",
        "1445": "   * <p><b>Warning:</b> This method assumes that for any instance {@code k} of\n",
        "1446": "   * {@code EntryTransformer} key type {@code K}, {@code k.equals(k2)} implies\n",
        "1447": "   * that {@code k2} is also of type {@code K}. Using an {@code\n",
        "1448": "   * EntryTransformer} key type for which this may not hold, such as {@code\n",
        "1449": "   * ArrayList}, may risk a {@code ClassCastException} when calling methods on\n",
        "1450": "   * the transformed map.\n",
        "1451": "   *\n",
        "1452": "   * @since 7.0\n",
        "1453": "   */\n",
        "1454": "  public static <K, V1, V2> Map<K, V2> transformEntries(\n",
        "1455": "      Map<K, V1> fromMap, EntryTransformer<? super K, ? super V1, V2> transformer) {\n",
        "1456": "    if (fromMap instanceof SortedMap) {\n",
        "1457": "      return transformEntries((SortedMap<K, V1>) fromMap, transformer);\n",
        "1458": "    }\n",
        "1459": "    return new TransformedEntriesMap<K, V1, V2>(fromMap, transformer);\n",
        "1460": "  }\n",
        "1461": "\n",
        "1462": "  /**\n",
        "1463": "   * Returns a view of a sorted map whose values are derived from the original\n",
        "1464": "   * sorted map's entries. In contrast to {@link #transformValues}, this\n",
        "1465": "   * method's entry-transformation logic may depend on the key as well as the\n",
        "1466": "   * value.\n",
        "1467": "   *\n",
        "1468": "   * <p>All other properties of the transformed map, such as iteration order,\n",
        "1469": "   * are left intact. For example, the code: <pre>   {@code\n",
        "1470": "   *\n",
        "1471": "   *   Map<String, Boolean> options =\n",
        "1472": "   *       ImmutableSortedMap.of(\"verbose\", true, \"sort\", false);\n",
        "1473": "   *   EntryTransformer<String, Boolean, String> flagPrefixer =\n",
        "1474": "   *       new EntryTransformer<String, Boolean, String>() {\n",
        "1475": "   *         public String transformEntry(String key, Boolean value) {\n",
        "1476": "   *           return value ? key : \"yes\" + key;\n",
        "1477": "   *         }\n",
        "1478": "   *       };\n",
        "1479": "   *   SortedMap<String, String> transformed =\n",
        "1480": "   *       Maps.transformEntries(options, flagPrefixer);\n",
        "1481": "   *   System.out.println(transformed);}</pre>\n",
        "1482": "   *\n",
        "1483": "   * ... prints {@code {sort=yessort, verbose=verbose}}.\n",
        "1484": "   *\n",
        "1485": "   * <p>Changes in the underlying map are reflected in this view. Conversely,\n",
        "1486": "   * this view supports removal operations, and these are reflected in the\n",
        "1487": "   * underlying map.\n",
        "1488": "   *\n",
        "1489": "   * <p>It's acceptable for the underlying map to contain null keys and null\n",
        "1490": "   * values provided that the transformer is capable of accepting null inputs.\n",
        "1491": "   * The transformed map might contain null values if the transformer sometimes\n",
        "1492": "   * gives a null result.\n",
        "1493": "   *\n",
        "1494": "   * <p>The returned map is not thread-safe or serializable, even if the\n",
        "1495": "   * underlying map is.\n",
        "1496": "   *\n",
        "1497": "   * <p>The transformer is applied lazily, invoked when needed. This is\n",
        "1498": "   * necessary for the returned map to be a view, but it means that the\n",
        "1499": "   * transformer will be applied many times for bulk operations like {@link\n",
        "1500": "   * Map#containsValue} and {@link Object#toString}. For this to perform well,\n",
        "1501": "   * {@code transformer} should be fast. To avoid lazy evaluation when the\n",
        "1502": "   * returned map doesn't need to be a view, copy the returned map into a new\n",
        "1503": "   * map of your choosing.\n",
        "1504": "   *\n",
        "1505": "   * <p><b>Warning:</b> This method assumes that for any instance {@code k} of\n",
        "1506": "   * {@code EntryTransformer} key type {@code K}, {@code k.equals(k2)} implies\n",
        "1507": "   * that {@code k2} is also of type {@code K}. Using an {@code\n",
        "1508": "   * EntryTransformer} key type for which this may not hold, such as {@code\n",
        "1509": "   * ArrayList}, may risk a {@code ClassCastException} when calling methods on\n",
        "1510": "   * the transformed map.\n",
        "1511": "   *\n",
        "1512": "   * @since 11.0\n",
        "1513": "   */\n",
        "1514": "  public static <K, V1, V2> SortedMap<K, V2> transformEntries(\n",
        "1515": "      SortedMap<K, V1> fromMap, EntryTransformer<? super K, ? super V1, V2> transformer) {\n",
        "1516": "    return Platform.mapsTransformEntriesSortedMap(fromMap, transformer);\n",
        "1517": "  }\n",
        "1518": "\n",
        "1519": "  static <K, V1, V2> SortedMap<K, V2> transformEntriesIgnoreNavigable(\n",
        "1520": "      SortedMap<K, V1> fromMap, EntryTransformer<? super K, ? super V1, V2> transformer) {\n",
        "1521": "    return new TransformedEntriesSortedMap<K, V1, V2>(fromMap, transformer);\n",
        "1522": "  }\n",
        "1523": "\n",
        "1524": "  /**\n",
        "1525": "   * A transformation of the value of a key-value pair, using both key and value\n",
        "1526": "   * as inputs. To apply the transformation to a map, use\n",
        "1527": "   * {@link Maps#transformEntries(Map, EntryTransformer)}.\n",
        "1528": "   *\n",
        "1529": "   * @param <K> the key type of the input and output entries\n",
        "1530": "   * @param <V1> the value type of the input entry\n",
        "1531": "   * @param <V2> the value type of the output entry\n",
        "1532": "   * @since 7.0\n",
        "1533": "   */\n",
        "1534": "  public interface EntryTransformer<K, V1, V2> {\n",
        "1535": "    /**\n",
        "1536": "     * Determines an output value based on a key-value pair. This method is\n",
        "1537": "     * <i>generally expected</i>, but not absolutely required, to have the\n",
        "1538": "     * following properties:\n",
        "1539": "     *\n",
        "1540": "     * <ul>\n",
        "1541": "     * <li>Its execution does not cause any observable side effects.\n",
        "1542": "     * <li>The computation is <i>consistent with equals</i>; that is,\n",
        "1543": "     *     {@link Objects#equal Objects.equal}{@code (k1, k2) &&}\n",
        "1544": "     *     {@link Objects#equal}{@code (v1, v2)} implies that {@code\n",
        "1545": "     *     Objects.equal(transformer.transform(k1, v1),\n",
        "1546": "     *     transformer.transform(k2, v2))}.\n",
        "1547": "     * </ul>\n",
        "1548": "     *\n",
        "1549": "     * @throws NullPointerException if the key or value is null and this\n",
        "1550": "     *     transformer does not accept null arguments\n",
        "1551": "     */\n",
        "1552": "    V2 transformEntry(@Nullable K key, @Nullable V1 value);\n",
        "1553": "  }\n",
        "1554": "\n",
        "1555": "  /**\n",
        "1556": "   * Views a function as an entry transformer that ignores the entry key.\n",
        "1557": "   */\n",
        "1558": "  static <K, V1, V2> EntryTransformer<K, V1, V2> asEntryTransformer(\n",
        "1559": "      final Function<? super V1, V2> function) {\n",
        "1560": "    checkNotNull(function);\n",
        "1561": "    return new EntryTransformer<K, V1, V2>() {\n",
        "1562": "      @Override\n",
        "1563": "      public V2 transformEntry(K key, V1 value) {\n",
        "1564": "        return function.apply(value);\n",
        "1565": "      }\n",
        "1566": "    };\n",
        "1567": "  }\n",
        "1568": "\n",
        "1569": "  static <K, V1, V2> Function<V1, V2> asValueToValueFunction(\n",
        "1570": "      final EntryTransformer<? super K, V1, V2> transformer, final K key) {\n",
        "1571": "    checkNotNull(transformer);\n",
        "1572": "    return new Function<V1, V2>() {\n",
        "1573": "      @Override\n",
        "1574": "      public V2 apply(@Nullable V1 v1) {\n",
        "1575": "        return transformer.transformEntry(key, v1);\n",
        "1576": "      }\n",
        "1577": "    };\n",
        "1578": "  }\n",
        "1579": "\n",
        "1580": "  /**\n",
        "1581": "   * Views an entry transformer as a function from {@code Entry} to values.\n",
        "1582": "   */\n",
        "1583": "  static <K, V1, V2> Function<Entry<K, V1>, V2> asEntryToValueFunction(\n",
        "1584": "      final EntryTransformer<? super K, ? super V1, V2> transformer) {\n",
        "1585": "    checkNotNull(transformer);\n",
        "1586": "    return new Function<Entry<K, V1>, V2>() {\n",
        "1587": "      @Override\n",
        "1588": "      public V2 apply(Entry<K, V1> entry) {\n",
        "1589": "        return transformer.transformEntry(entry.getKey(), entry.getValue());\n",
        "1590": "      }\n",
        "1591": "    };\n",
        "1592": "  }\n",
        "1593": "\n",
        "1594": "  /**\n",
        "1595": "   * Returns a view of an entry transformed by the specified transformer.\n",
        "1596": "   */\n",
        "1597": "  static <V2, K, V1> Entry<K, V2> transformEntry(\n",
        "1598": "      final EntryTransformer<? super K, ? super V1, V2> transformer, final Entry<K, V1> entry) {\n",
        "1599": "    checkNotNull(transformer);\n",
        "1600": "    checkNotNull(entry);\n",
        "1601": "    return new AbstractMapEntry<K, V2>() {\n",
        "1602": "      @Override\n",
        "1603": "      public K getKey() {\n",
        "1604": "        return entry.getKey();\n",
        "1605": "      }\n",
        "1606": "\n",
        "1607": "      @Override\n",
        "1608": "      public V2 getValue() {\n",
        "1609": "        return transformer.transformEntry(entry.getKey(), entry.getValue());\n",
        "1610": "      }\n",
        "1611": "    };\n",
        "1612": "  }\n",
        "1613": "\n",
        "1614": "  /**\n",
        "1615": "   * Views an entry transformer as a function from entries to entries.\n",
        "1616": "   */\n",
        "1617": "  static <K, V1, V2> Function<Entry<K, V1>, Entry<K, V2>> asEntryToEntryFunction(\n",
        "1618": "      final EntryTransformer<? super K, ? super V1, V2> transformer) {\n",
        "1619": "    checkNotNull(transformer);\n",
        "1620": "    return new Function<Entry<K, V1>, Entry<K, V2>>() {\n",
        "1621": "      @Override\n",
        "1622": "      public Entry<K, V2> apply(final Entry<K, V1> entry) {\n",
        "1623": "        return transformEntry(transformer, entry);\n",
        "1624": "      }\n",
        "1625": "    };\n",
        "1626": "  }\n",
        "1627": "\n",
        "1628": "  static class TransformedEntriesMap<K, V1, V2> extends IteratorBasedAbstractMap<K, V2> {\n",
        "1629": "    final Map<K, V1> fromMap;\n",
        "1630": "    final EntryTransformer<? super K, ? super V1, V2> transformer;\n",
        "1631": "\n",
        "1632": "    TransformedEntriesMap(\n",
        "1633": "        Map<K, V1> fromMap, EntryTransformer<? super K, ? super V1, V2> transformer) {\n",
        "1634": "      this.fromMap = checkNotNull(fromMap);\n",
        "1635": "      this.transformer = checkNotNull(transformer);\n",
        "1636": "    }\n",
        "1637": "\n",
        "1638": "    @Override\n",
        "1639": "    public int size() {\n",
        "1640": "      return fromMap.size();\n",
        "1641": "    }\n",
        "1642": "\n",
        "1643": "    @Override\n",
        "1644": "    public boolean containsKey(Object key) {\n",
        "1645": "      return fromMap.containsKey(key);\n",
        "1646": "    }\n",
        "1647": "\n",
        "1648": "    // safe as long as the user followed the <b>Warning</b> in the javadoc\n",
        "1649": "    @SuppressWarnings(\"unchecked\")\n",
        "1650": "    @Override\n",
        "1651": "    public V2 get(Object key) {\n",
        "1652": "      V1 value = fromMap.get(key);\n",
        "1653": "      return (value != null || fromMap.containsKey(key))\n",
        "1654": "          ? transformer.transformEntry((K) key, value)\n",
        "1655": "          : null;\n",
        "1656": "    }\n",
        "1657": "\n",
        "1658": "    // safe as long as the user followed the <b>Warning</b> in the javadoc\n",
        "1659": "    @SuppressWarnings(\"unchecked\")\n",
        "1660": "    @Override\n",
        "1661": "    public V2 remove(Object key) {\n",
        "1662": "      return fromMap.containsKey(key)\n",
        "1663": "          ? transformer.transformEntry((K) key, fromMap.remove(key))\n",
        "1664": "          : null;\n",
        "1665": "    }\n",
        "1666": "\n",
        "1667": "    @Override\n",
        "1668": "    public void clear() {\n",
        "1669": "      fromMap.clear();\n",
        "1670": "    }\n",
        "1671": "\n",
        "1672": "    @Override\n",
        "1673": "    public Set<K> keySet() {\n",
        "1674": "      return fromMap.keySet();\n",
        "1675": "    }\n",
        "1676": "\n",
        "1677": "    @Override\n",
        "1678": "    Iterator<Entry<K, V2>> entryIterator() {\n",
        "1679": "      return Iterators.transform(\n",
        "1680": "          fromMap.entrySet().iterator(), Maps.<K, V1, V2>asEntryToEntryFunction(transformer));\n",
        "1681": "    }\n",
        "1682": "\n",
        "1683": "    @Override\n",
        "1684": "    public Collection<V2> values() {\n",
        "1685": "      return new Values<K, V2>(this);\n",
        "1686": "    }\n",
        "1687": "  }\n",
        "1688": "\n",
        "1689": "  static class TransformedEntriesSortedMap<K, V1, V2> extends TransformedEntriesMap<K, V1, V2>\n",
        "1690": "      implements SortedMap<K, V2> {\n",
        "1691": "\n",
        "1692": "    protected SortedMap<K, V1> fromMap() {\n",
        "1693": "      return (SortedMap<K, V1>) fromMap;\n",
        "1694": "    }\n",
        "1695": "\n",
        "1696": "    TransformedEntriesSortedMap(\n",
        "1697": "        SortedMap<K, V1> fromMap, EntryTransformer<? super K, ? super V1, V2> transformer) {\n",
        "1698": "      super(fromMap, transformer);\n",
        "1699": "    }\n",
        "1700": "\n",
        "1701": "    @Override\n",
        "1702": "    public Comparator<? super K> comparator() {\n",
        "1703": "      return fromMap().comparator();\n",
        "1704": "    }\n",
        "1705": "\n",
        "1706": "    @Override\n",
        "1707": "    public K firstKey() {\n",
        "1708": "      return fromMap().firstKey();\n",
        "1709": "    }\n",
        "1710": "\n",
        "1711": "    @Override\n",
        "1712": "    public SortedMap<K, V2> headMap(K toKey) {\n",
        "1713": "      return transformEntries(fromMap().headMap(toKey), transformer);\n",
        "1714": "    }\n",
        "1715": "\n",
        "1716": "    @Override\n",
        "1717": "    public K lastKey() {\n",
        "1718": "      return fromMap().lastKey();\n",
        "1719": "    }\n",
        "1720": "\n",
        "1721": "    @Override\n",
        "1722": "    public SortedMap<K, V2> subMap(K fromKey, K toKey) {\n",
        "1723": "      return transformEntries(fromMap().subMap(fromKey, toKey), transformer);\n",
        "1724": "    }\n",
        "1725": "\n",
        "1726": "    @Override\n",
        "1727": "    public SortedMap<K, V2> tailMap(K fromKey) {\n",
        "1728": "      return transformEntries(fromMap().tailMap(fromKey), transformer);\n",
        "1729": "    }\n",
        "1730": "  }\n",
        "1731": "\n",
        "1732": "  static <K> Predicate<Entry<K, ?>> keyPredicateOnEntries(Predicate<? super K> keyPredicate) {\n",
        "1733": "    return compose(keyPredicate, Maps.<K>keyFunction());\n",
        "1734": "  }\n",
        "1735": "\n",
        "1736": "  static <V> Predicate<Entry<?, V>> valuePredicateOnEntries(Predicate<? super V> valuePredicate) {\n",
        "1737": "    return compose(valuePredicate, Maps.<V>valueFunction());\n",
        "1738": "  }\n",
        "1739": "\n",
        "1740": "  /**\n",
        "1741": "   * Returns a map containing the mappings in {@code unfiltered} whose keys\n",
        "1742": "   * satisfy a predicate. The returned map is a live view of {@code unfiltered};\n",
        "1743": "   * changes to one affect the other.\n",
        "1744": "   *\n",
        "1745": "   * <p>The resulting map's {@code keySet()}, {@code entrySet()}, and {@code\n",
        "1746": "   * values()} views have iterators that don't support {@code remove()}, but all\n",
        "1747": "   * other methods are supported by the map and its views. When given a key that\n",
        "1748": "   * doesn't satisfy the predicate, the map's {@code put()} and {@code putAll()}\n",
        "1749": "   * methods throw an {@link IllegalArgumentException}.\n",
        "1750": "   *\n",
        "1751": "   * <p>When methods such as {@code removeAll()} and {@code clear()} are called\n",
        "1752": "   * on the filtered map or its views, only mappings whose keys satisfy the\n",
        "1753": "   * filter will be removed from the underlying map.\n",
        "1754": "   *\n",
        "1755": "   * <p>The returned map isn't threadsafe or serializable, even if {@code\n",
        "1756": "   * unfiltered} is.\n",
        "1757": "   *\n",
        "1758": "   * <p>Many of the filtered map's methods, such as {@code size()},\n",
        "1759": "   * iterate across every key/value mapping in the underlying map and determine\n",
        "1760": "   * which satisfy the filter. When a live view is <i>not</i> needed, it may be\n",
        "1761": "   * faster to copy the filtered map and use the copy.\n",
        "1762": "   *\n",
        "1763": "   * <p><b>Warning:</b> {@code keyPredicate} must be <i>consistent with\n",
        "1764": "   * equals</i>, as documented at {@link Predicate#apply}. Do not provide a\n",
        "1765": "   * predicate such as {@code Predicates.instanceOf(ArrayList.class)}, which is\n",
        "1766": "   * inconsistent with equals.\n",
        "1767": "   */\n",
        "1768": "  @CheckReturnValue\n",
        "1769": "  public static <K, V> Map<K, V> filterKeys(\n",
        "1770": "      Map<K, V> unfiltered, final Predicate<? super K> keyPredicate) {\n",
        "1771": "    if (unfiltered instanceof SortedMap) {\n",
        "1772": "      return filterKeys((SortedMap<K, V>) unfiltered, keyPredicate);\n",
        "1773": "    } else if (unfiltered instanceof BiMap) {\n",
        "1774": "      return filterKeys((BiMap<K, V>) unfiltered, keyPredicate);\n",
        "1775": "    }\n",
        "1776": "    checkNotNull(keyPredicate);\n",
        "1777": "    Predicate<Entry<K, ?>> entryPredicate = keyPredicateOnEntries(keyPredicate);\n",
        "1778": "    return (unfiltered instanceof AbstractFilteredMap)\n",
        "1779": "        ? filterFiltered((AbstractFilteredMap<K, V>) unfiltered, entryPredicate)\n",
        "1780": "        : new FilteredKeyMap<K, V>(checkNotNull(unfiltered), keyPredicate, entryPredicate);\n",
        "1781": "  }\n",
        "1782": "\n",
        "1783": "  /**\n",
        "1784": "   * Returns a sorted map containing the mappings in {@code unfiltered} whose\n",
        "1785": "   * keys satisfy a predicate. The returned map is a live view of {@code\n",
        "1786": "   * unfiltered}; changes to one affect the other.\n",
        "1787": "   *\n",
        "1788": "   * <p>The resulting map's {@code keySet()}, {@code entrySet()}, and {@code\n",
        "1789": "   * values()} views have iterators that don't support {@code remove()}, but all\n",
        "1790": "   * other methods are supported by the map and its views. When given a key that\n",
        "1791": "   * doesn't satisfy the predicate, the map's {@code put()} and {@code putAll()}\n",
        "1792": "   * methods throw an {@link IllegalArgumentException}.\n",
        "1793": "   *\n",
        "1794": "   * <p>When methods such as {@code removeAll()} and {@code clear()} are called\n",
        "1795": "   * on the filtered map or its views, only mappings whose keys satisfy the\n",
        "1796": "   * filter will be removed from the underlying map.\n",
        "1797": "   *\n",
        "1798": "   * <p>The returned map isn't threadsafe or serializable, even if {@code\n",
        "1799": "   * unfiltered} is.\n",
        "1800": "   *\n",
        "1801": "   * <p>Many of the filtered map's methods, such as {@code size()},\n",
        "1802": "   * iterate across every key/value mapping in the underlying map and determine\n",
        "1803": "   * which satisfy the filter. When a live view is <i>not</i> needed, it may be\n",
        "1804": "   * faster to copy the filtered map and use the copy.\n",
        "1805": "   *\n",
        "1806": "   * <p><b>Warning:</b> {@code keyPredicate} must be <i>consistent with\n",
        "1807": "   * equals</i>, as documented at {@link Predicate#apply}. Do not provide a\n",
        "1808": "   * predicate such as {@code Predicates.instanceOf(ArrayList.class)}, which is\n",
        "1809": "   * inconsistent with equals.\n",
        "1810": "   *\n",
        "1811": "   * @since 11.0\n",
        "1812": "   */\n",
        "1813": "  @CheckReturnValue\n",
        "1814": "  public static <K, V> SortedMap<K, V> filterKeys(\n",
        "1815": "      SortedMap<K, V> unfiltered, final Predicate<? super K> keyPredicate) {\n",
        "1816": "    // TODO(lowasser): Return a subclass of Maps.FilteredKeyMap for slightly better\n",
        "1817": "    // performance.\n",
        "1818": "    return filterEntries(unfiltered, Maps.<K>keyPredicateOnEntries(keyPredicate));\n",
        "1819": "  }\n",
        "1820": "\n",
        "1821": "  /**\n",
        "1822": "   * Returns a bimap containing the mappings in {@code unfiltered} whose keys satisfy a predicate.\n",
        "1823": "   * The returned bimap is a live view of {@code unfiltered}; changes to one affect the other.\n",
        "1824": "   *\n",
        "1825": "   * <p>The resulting bimap's {@code keySet()}, {@code entrySet()}, and {@code values()} views have\n",
        "1826": "   * iterators that don't support {@code remove()}, but all other methods are supported by the\n",
        "1827": "   * bimap and its views. When given a key that doesn't satisfy the predicate, the bimap's {@code\n",
        "1828": "   * put()}, {@code forcePut()} and {@code putAll()} methods throw an {@link\n",
        "1829": "   * IllegalArgumentException}.\n",
        "1830": "   *\n",
        "1831": "   * <p>When methods such as {@code removeAll()} and {@code clear()} are called on the filtered\n",
        "1832": "   * bimap or its views, only mappings that satisfy the filter will be removed from the underlying\n",
        "1833": "   * bimap.\n",
        "1834": "   *\n",
        "1835": "   * <p>The returned bimap isn't threadsafe or serializable, even if {@code unfiltered} is.\n",
        "1836": "   *\n",
        "1837": "   * <p>Many of the filtered bimap's methods, such as {@code size()}, iterate across every key in\n",
        "1838": "   * the underlying bimap and determine which satisfy the filter. When a live view is <i>not</i>\n",
        "1839": "   * needed, it may be faster to copy the filtered bimap and use the copy.\n",
        "1840": "   *\n",
        "1841": "   * <p><b>Warning:</b> {@code entryPredicate} must be <i>consistent with equals </i>, as\n",
        "1842": "   * documented at {@link Predicate#apply}.\n",
        "1843": "   *\n",
        "1844": "   * @since 14.0\n",
        "1845": "   */\n",
        "1846": "  @CheckReturnValue\n",
        "1847": "  public static <K, V> BiMap<K, V> filterKeys(\n",
        "1848": "      BiMap<K, V> unfiltered, final Predicate<? super K> keyPredicate) {\n",
        "1849": "    checkNotNull(keyPredicate);\n",
        "1850": "    return filterEntries(unfiltered, Maps.<K>keyPredicateOnEntries(keyPredicate));\n",
        "1851": "  }\n",
        "1852": "\n",
        "1853": "  /**\n",
        "1854": "   * Returns a map containing the mappings in {@code unfiltered} whose values\n",
        "1855": "   * satisfy a predicate. The returned map is a live view of {@code unfiltered};\n",
        "1856": "   * changes to one affect the other.\n",
        "1857": "   *\n",
        "1858": "   * <p>The resulting map's {@code keySet()}, {@code entrySet()}, and {@code\n",
        "1859": "   * values()} views have iterators that don't support {@code remove()}, but all\n",
        "1860": "   * other methods are supported by the map and its views. When given a value\n",
        "1861": "   * that doesn't satisfy the predicate, the map's {@code put()}, {@code\n",
        "1862": "   * putAll()}, and {@link Entry#setValue} methods throw an {@link\n",
        "1863": "   * IllegalArgumentException}.\n",
        "1864": "   *\n",
        "1865": "   * <p>When methods such as {@code removeAll()} and {@code clear()} are called\n",
        "1866": "   * on the filtered map or its views, only mappings whose values satisfy the\n",
        "1867": "   * filter will be removed from the underlying map.\n",
        "1868": "   *\n",
        "1869": "   * <p>The returned map isn't threadsafe or serializable, even if {@code\n",
        "1870": "   * unfiltered} is.\n",
        "1871": "   *\n",
        "1872": "   * <p>Many of the filtered map's methods, such as {@code size()},\n",
        "1873": "   * iterate across every key/value mapping in the underlying map and determine\n",
        "1874": "   * which satisfy the filter. When a live view is <i>not</i> needed, it may be\n",
        "1875": "   * faster to copy the filtered map and use the copy.\n",
        "1876": "   *\n",
        "1877": "   * <p><b>Warning:</b> {@code valuePredicate} must be <i>consistent with\n",
        "1878": "   * equals</i>, as documented at {@link Predicate#apply}. Do not provide a\n",
        "1879": "   * predicate such as {@code Predicates.instanceOf(ArrayList.class)}, which is\n",
        "1880": "   * inconsistent with equals.\n",
        "1881": "   */\n",
        "1882": "  @CheckReturnValue\n",
        "1883": "  public static <K, V> Map<K, V> filterValues(\n",
        "1884": "      Map<K, V> unfiltered, final Predicate<? super V> valuePredicate) {\n",
        "1885": "    if (unfiltered instanceof SortedMap) {\n",
        "1886": "      return filterValues((SortedMap<K, V>) unfiltered, valuePredicate);\n",
        "1887": "    } else if (unfiltered instanceof BiMap) {\n",
        "1888": "      return filterValues((BiMap<K, V>) unfiltered, valuePredicate);\n",
        "1889": "    }\n",
        "1890": "    return filterEntries(unfiltered, Maps.<V>valuePredicateOnEntries(valuePredicate));\n",
        "1891": "  }\n",
        "1892": "\n",
        "1893": "  /**\n",
        "1894": "   * Returns a sorted map containing the mappings in {@code unfiltered} whose\n",
        "1895": "   * values satisfy a predicate. The returned map is a live view of {@code\n",
        "1896": "   * unfiltered}; changes to one affect the other.\n",
        "1897": "   *\n",
        "1898": "   * <p>The resulting map's {@code keySet()}, {@code entrySet()}, and {@code\n",
        "1899": "   * values()} views have iterators that don't support {@code remove()}, but all\n",
        "1900": "   * other methods are supported by the map and its views. When given a value\n",
        "1901": "   * that doesn't satisfy the predicate, the map's {@code put()}, {@code\n",
        "1902": "   * putAll()}, and {@link Entry#setValue} methods throw an {@link\n",
        "1903": "   * IllegalArgumentException}.\n",
        "1904": "   *\n",
        "1905": "   * <p>When methods such as {@code removeAll()} and {@code clear()} are called\n",
        "1906": "   * on the filtered map or its views, only mappings whose values satisfy the\n",
        "1907": "   * filter will be removed from the underlying map.\n",
        "1908": "   *\n",
        "1909": "   * <p>The returned map isn't threadsafe or serializable, even if {@code\n",
        "1910": "   * unfiltered} is.\n",
        "1911": "   *\n",
        "1912": "   * <p>Many of the filtered map's methods, such as {@code size()},\n",
        "1913": "   * iterate across every key/value mapping in the underlying map and determine\n",
        "1914": "   * which satisfy the filter. When a live view is <i>not</i> needed, it may be\n",
        "1915": "   * faster to copy the filtered map and use the copy.\n",
        "1916": "   *\n",
        "1917": "   * <p><b>Warning:</b> {@code valuePredicate} must be <i>consistent with\n",
        "1918": "   * equals</i>, as documented at {@link Predicate#apply}. Do not provide a\n",
        "1919": "   * predicate such as {@code Predicates.instanceOf(ArrayList.class)}, which is\n",
        "1920": "   * inconsistent with equals.\n",
        "1921": "   *\n",
        "1922": "   * @since 11.0\n",
        "1923": "   */\n",
        "1924": "  @CheckReturnValue\n",
        "1925": "  public static <K, V> SortedMap<K, V> filterValues(\n",
        "1926": "      SortedMap<K, V> unfiltered, final Predicate<? super V> valuePredicate) {\n",
        "1927": "    return filterEntries(unfiltered, Maps.<V>valuePredicateOnEntries(valuePredicate));\n",
        "1928": "  }\n",
        "1929": "\n",
        "1930": "  /**\n",
        "1931": "   * Returns a bimap containing the mappings in {@code unfiltered} whose values satisfy a\n",
        "1932": "   * predicate. The returned bimap is a live view of {@code unfiltered}; changes to one affect the\n",
        "1933": "   * other.\n",
        "1934": "   *\n",
        "1935": "   * <p>The resulting bimap's {@code keySet()}, {@code entrySet()}, and {@code values()} views have\n",
        "1936": "   * iterators that don't support {@code remove()}, but all other methods are supported by the\n",
        "1937": "   * bimap and its views. When given a value that doesn't satisfy the predicate, the bimap's\n",
        "1938": "   * {@code put()}, {@code forcePut()} and {@code putAll()} methods throw an {@link\n",
        "1939": "   * IllegalArgumentException}. Similarly, the map's entries have a {@link Entry#setValue} method\n",
        "1940": "   * that throws an {@link IllegalArgumentException} when the provided value doesn't satisfy the\n",
        "1941": "   * predicate.\n",
        "1942": "   *\n",
        "1943": "   * <p>When methods such as {@code removeAll()} and {@code clear()} are called on the filtered\n",
        "1944": "   * bimap or its views, only mappings that satisfy the filter will be removed from the underlying\n",
        "1945": "   * bimap.\n",
        "1946": "   *\n",
        "1947": "   * <p>The returned bimap isn't threadsafe or serializable, even if {@code unfiltered} is.\n",
        "1948": "   *\n",
        "1949": "   * <p>Many of the filtered bimap's methods, such as {@code size()}, iterate across every value in\n",
        "1950": "   * the underlying bimap and determine which satisfy the filter. When a live view is <i>not</i>\n",
        "1951": "   * needed, it may be faster to copy the filtered bimap and use the copy.\n",
        "1952": "   *\n",
        "1953": "   * <p><b>Warning:</b> {@code entryPredicate} must be <i>consistent with equals </i>, as\n",
        "1954": "   * documented at {@link Predicate#apply}.\n",
        "1955": "   *\n",
        "1956": "   * @since 14.0\n",
        "1957": "   */\n",
        "1958": "  @CheckReturnValue\n",
        "1959": "  public static <K, V> BiMap<K, V> filterValues(\n",
        "1960": "      BiMap<K, V> unfiltered, final Predicate<? super V> valuePredicate) {\n",
        "1961": "    return filterEntries(unfiltered, Maps.<V>valuePredicateOnEntries(valuePredicate));\n",
        "1962": "  }\n",
        "1963": "\n",
        "1964": "  /**\n",
        "1965": "   * Returns a map containing the mappings in {@code unfiltered} that satisfy a\n",
        "1966": "   * predicate. The returned map is a live view of {@code unfiltered}; changes\n",
        "1967": "   * to one affect the other.\n",
        "1968": "   *\n",
        "1969": "   * <p>The resulting map's {@code keySet()}, {@code entrySet()}, and {@code\n",
        "1970": "   * values()} views have iterators that don't support {@code remove()}, but all\n",
        "1971": "   * other methods are supported by the map and its views. When given a\n",
        "1972": "   * key/value pair that doesn't satisfy the predicate, the map's {@code put()}\n",
        "1973": "   * and {@code putAll()} methods throw an {@link IllegalArgumentException}.\n",
        "1974": "   * Similarly, the map's entries have a {@link Entry#setValue} method that\n",
        "1975": "   * throws an {@link IllegalArgumentException} when the existing key and the\n",
        "1976": "   * provided value don't satisfy the predicate.\n",
        "1977": "   *\n",
        "1978": "   * <p>When methods such as {@code removeAll()} and {@code clear()} are called\n",
        "1979": "   * on the filtered map or its views, only mappings that satisfy the filter\n",
        "1980": "   * will be removed from the underlying map.\n",
        "1981": "   *\n",
        "1982": "   * <p>The returned map isn't threadsafe or serializable, even if {@code\n",
        "1983": "   * unfiltered} is.\n",
        "1984": "   *\n",
        "1985": "   * <p>Many of the filtered map's methods, such as {@code size()},\n",
        "1986": "   * iterate across every key/value mapping in the underlying map and determine\n",
        "1987": "   * which satisfy the filter. When a live view is <i>not</i> needed, it may be\n",
        "1988": "   * faster to copy the filtered map and use the copy.\n",
        "1989": "   *\n",
        "1990": "   * <p><b>Warning:</b> {@code entryPredicate} must be <i>consistent with\n",
        "1991": "   * equals</i>, as documented at {@link Predicate#apply}.\n",
        "1992": "   */\n",
        "1993": "  @CheckReturnValue\n",
        "1994": "  public static <K, V> Map<K, V> filterEntries(\n",
        "1995": "      Map<K, V> unfiltered, Predicate<? super Entry<K, V>> entryPredicate) {\n",
        "1996": "    if (unfiltered instanceof SortedMap) {\n",
        "1997": "      return filterEntries((SortedMap<K, V>) unfiltered, entryPredicate);\n",
        "1998": "    } else if (unfiltered instanceof BiMap) {\n",
        "1999": "      return filterEntries((BiMap<K, V>) unfiltered, entryPredicate);\n",
        "2000": "    }\n",
        "2001": "    checkNotNull(entryPredicate);\n",
        "2002": "    return (unfiltered instanceof AbstractFilteredMap)\n",
        "2003": "        ? filterFiltered((AbstractFilteredMap<K, V>) unfiltered, entryPredicate)\n",
        "2004": "        : new FilteredEntryMap<K, V>(checkNotNull(unfiltered), entryPredicate);\n",
        "2005": "  }\n",
        "2006": "\n",
        "2007": "  /**\n",
        "2008": "   * Returns a sorted map containing the mappings in {@code unfiltered} that\n",
        "2009": "   * satisfy a predicate. The returned map is a live view of {@code unfiltered};\n",
        "2010": "   * changes to one affect the other.\n",
        "2011": "   *\n",
        "2012": "   * <p>The resulting map's {@code keySet()}, {@code entrySet()}, and {@code\n",
        "2013": "   * values()} views have iterators that don't support {@code remove()}, but all\n",
        "2014": "   * other methods are supported by the map and its views. When given a\n",
        "2015": "   * key/value pair that doesn't satisfy the predicate, the map's {@code put()}\n",
        "2016": "   * and {@code putAll()} methods throw an {@link IllegalArgumentException}.\n",
        "2017": "   * Similarly, the map's entries have a {@link Entry#setValue} method that\n",
        "2018": "   * throws an {@link IllegalArgumentException} when the existing key and the\n",
        "2019": "   * provided value don't satisfy the predicate.\n",
        "2020": "   *\n",
        "2021": "   * <p>When methods such as {@code removeAll()} and {@code clear()} are called\n",
        "2022": "   * on the filtered map or its views, only mappings that satisfy the filter\n",
        "2023": "   * will be removed from the underlying map.\n",
        "2024": "   *\n",
        "2025": "   * <p>The returned map isn't threadsafe or serializable, even if {@code\n",
        "2026": "   * unfiltered} is.\n",
        "2027": "   *\n",
        "2028": "   * <p>Many of the filtered map's methods, such as {@code size()},\n",
        "2029": "   * iterate across every key/value mapping in the underlying map and determine\n",
        "2030": "   * which satisfy the filter. When a live view is <i>not</i> needed, it may be\n",
        "2031": "   * faster to copy the filtered map and use the copy.\n",
        "2032": "   *\n",
        "2033": "   * <p><b>Warning:</b> {@code entryPredicate} must be <i>consistent with\n",
        "2034": "   * equals</i>, as documented at {@link Predicate#apply}.\n",
        "2035": "   *\n",
        "2036": "   * @since 11.0\n",
        "2037": "   */\n",
        "2038": "  @CheckReturnValue\n",
        "2039": "  public static <K, V> SortedMap<K, V> filterEntries(\n",
        "2040": "      SortedMap<K, V> unfiltered, Predicate<? super Entry<K, V>> entryPredicate) {\n",
        "2041": "    return Platform.mapsFilterSortedMap(unfiltered, entryPredicate);\n",
        "2042": "  }\n",
        "2043": "\n",
        "2044": "  static <K, V> SortedMap<K, V> filterSortedIgnoreNavigable(\n",
        "2045": "      SortedMap<K, V> unfiltered, Predicate<? super Entry<K, V>> entryPredicate) {\n",
        "2046": "    checkNotNull(entryPredicate);\n",
        "2047": "    return (unfiltered instanceof FilteredEntrySortedMap)\n",
        "2048": "        ? filterFiltered((FilteredEntrySortedMap<K, V>) unfiltered, entryPredicate)\n",
        "2049": "        : new FilteredEntrySortedMap<K, V>(checkNotNull(unfiltered), entryPredicate);\n",
        "2050": "  }\n",
        "2051": "\n",
        "2052": "  /**\n",
        "2053": "   * Returns a bimap containing the mappings in {@code unfiltered} that satisfy a predicate. The\n",
        "2054": "   * returned bimap is a live view of {@code unfiltered}; changes to one affect the other.\n",
        "2055": "   *\n",
        "2056": "   * <p>The resulting bimap's {@code keySet()}, {@code entrySet()}, and {@code values()} views have\n",
        "2057": "   * iterators that don't support {@code remove()}, but all other methods are supported by the bimap\n",
        "2058": "   * and its views. When given a key/value pair that doesn't satisfy the predicate, the bimap's\n",
        "2059": "   * {@code put()}, {@code forcePut()} and {@code putAll()} methods throw an\n",
        "2060": "   * {@link IllegalArgumentException}. Similarly, the map's entries have an {@link Entry#setValue}\n",
        "2061": "   * method that throws an {@link IllegalArgumentException} when the existing key and the provided\n",
        "2062": "   * value don't satisfy the predicate.\n",
        "2063": "   *\n",
        "2064": "   * <p>When methods such as {@code removeAll()} and {@code clear()} are called on the filtered\n",
        "2065": "   * bimap or its views, only mappings that satisfy the filter will be removed from the underlying\n",
        "2066": "   * bimap.\n",
        "2067": "   *\n",
        "2068": "   * <p>The returned bimap isn't threadsafe or serializable, even if {@code unfiltered} is.\n",
        "2069": "   *\n",
        "2070": "   * <p>Many of the filtered bimap's methods, such as {@code size()}, iterate across every\n",
        "2071": "   * key/value mapping in the underlying bimap and determine which satisfy the filter. When a live\n",
        "2072": "   * view is <i>not</i> needed, it may be faster to copy the filtered bimap and use the copy.\n",
        "2073": "   *\n",
        "2074": "   * <p><b>Warning:</b> {@code entryPredicate} must be <i>consistent with equals </i>, as\n",
        "2075": "   * documented at {@link Predicate#apply}.\n",
        "2076": "   *\n",
        "2077": "   * @since 14.0\n",
        "2078": "   */\n",
        "2079": "  @CheckReturnValue\n",
        "2080": "  public static <K, V> BiMap<K, V> filterEntries(\n",
        "2081": "      BiMap<K, V> unfiltered, Predicate<? super Entry<K, V>> entryPredicate) {\n",
        "2082": "    checkNotNull(unfiltered);\n",
        "2083": "    checkNotNull(entryPredicate);\n",
        "2084": "    return (unfiltered instanceof FilteredEntryBiMap)\n",
        "2085": "        ? filterFiltered((FilteredEntryBiMap<K, V>) unfiltered, entryPredicate)\n",
        "2086": "        : new FilteredEntryBiMap<K, V>(unfiltered, entryPredicate);\n",
        "2087": "  }\n",
        "2088": "\n",
        "2089": "  /**\n",
        "2090": "   * Support {@code clear()}, {@code removeAll()}, and {@code retainAll()} when\n",
        "2091": "   * filtering a filtered map.\n",
        "2092": "   */\n",
        "2093": "  private static <K, V> Map<K, V> filterFiltered(\n",
        "2094": "      AbstractFilteredMap<K, V> map, Predicate<? super Entry<K, V>> entryPredicate) {\n",
        "2095": "    return new FilteredEntryMap<K, V>(\n",
        "2096": "        map.unfiltered, Predicates.<Entry<K, V>>and(map.predicate, entryPredicate));\n",
        "2097": "  }\n",
        "2098": "\n",
        "2099": "  private abstract static class AbstractFilteredMap<K, V> extends ViewCachingAbstractMap<K, V> {\n",
        "2100": "    final Map<K, V> unfiltered;\n",
        "2101": "    final Predicate<? super Entry<K, V>> predicate;\n",
        "2102": "\n",
        "2103": "    AbstractFilteredMap(Map<K, V> unfiltered, Predicate<? super Entry<K, V>> predicate) {\n",
        "2104": "      this.unfiltered = unfiltered;\n",
        "2105": "      this.predicate = predicate;\n",
        "2106": "    }\n",
        "2107": "\n",
        "2108": "    boolean apply(@Nullable Object key, @Nullable V value) {\n",
        "2109": "      // This method is called only when the key is in the map, implying that\n",
        "2110": "      // key is a K.\n",
        "2111": "      @SuppressWarnings(\"unchecked\")\n",
        "2112": "      K k = (K) key;\n",
        "2113": "      return predicate.apply(Maps.immutableEntry(k, value));\n",
        "2114": "    }\n",
        "2115": "\n",
        "2116": "    @Override\n",
        "2117": "    public V put(K key, V value) {\n",
        "2118": "      checkArgument(apply(key, value));\n",
        "2119": "      return unfiltered.put(key, value);\n",
        "2120": "    }\n",
        "2121": "\n",
        "2122": "    @Override\n",
        "2123": "    public void putAll(Map<? extends K, ? extends V> map) {\n",
        "2124": "      for (Entry<? extends K, ? extends V> entry : map.entrySet()) {\n",
        "2125": "        checkArgument(apply(entry.getKey(), entry.getValue()));\n",
        "2126": "      }\n",
        "2127": "      unfiltered.putAll(map);\n",
        "2128": "    }\n",
        "2129": "\n",
        "2130": "    @Override\n",
        "2131": "    public boolean containsKey(Object key) {\n",
        "2132": "      return unfiltered.containsKey(key) && apply(key, unfiltered.get(key));\n",
        "2133": "    }\n",
        "2134": "\n",
        "2135": "    @Override\n",
        "2136": "    public V get(Object key) {\n",
        "2137": "      V value = unfiltered.get(key);\n",
        "2138": "      return ((value != null) && apply(key, value)) ? value : null;\n",
        "2139": "    }\n",
        "2140": "\n",
        "2141": "    @Override\n",
        "2142": "    public boolean isEmpty() {\n",
        "2143": "      return entrySet().isEmpty();\n",
        "2144": "    }\n",
        "2145": "\n",
        "2146": "    @Override\n",
        "2147": "    public V remove(Object key) {\n",
        "2148": "      return containsKey(key) ? unfiltered.remove(key) : null;\n",
        "2149": "    }\n",
        "2150": "\n",
        "2151": "    @Override\n",
        "2152": "    Collection<V> createValues() {\n",
        "2153": "      return new FilteredMapValues<K, V>(this, unfiltered, predicate);\n",
        "2154": "    }\n",
        "2155": "  }\n",
        "2156": "\n",
        "2157": "  private static final class FilteredMapValues<K, V> extends Maps.Values<K, V> {\n",
        "2158": "    Map<K, V> unfiltered;\n",
        "2159": "    Predicate<? super Entry<K, V>> predicate;\n",
        "2160": "\n",
        "2161": "    FilteredMapValues(\n",
        "2162": "        Map<K, V> filteredMap, Map<K, V> unfiltered, Predicate<? super Entry<K, V>> predicate) {\n",
        "2163": "      super(filteredMap);\n",
        "2164": "      this.unfiltered = unfiltered;\n",
        "2165": "      this.predicate = predicate;\n",
        "2166": "    }\n",
        "2167": "\n",
        "2168": "    @Override\n",
        "2169": "    public boolean remove(Object o) {\n",
        "2170": "      return Iterables.removeFirstMatching(\n",
        "2171": "              unfiltered.entrySet(),\n",
        "2172": "              Predicates.<Entry<K, V>>and(predicate, Maps.<V>valuePredicateOnEntries(equalTo(o))))\n",
        "2173": "          != null;\n",
        "2174": "    }\n",
        "2175": "\n",
        "2176": "    private boolean removeIf(Predicate<? super V> valuePredicate) {\n",
        "2177": "      return Iterables.removeIf(\n",
        "2178": "          unfiltered.entrySet(),\n",
        "2179": "          Predicates.<Entry<K, V>>and(predicate, Maps.<V>valuePredicateOnEntries(valuePredicate)));\n",
        "2180": "    }\n",
        "2181": "\n",
        "2182": "    @Override\n",
        "2183": "    public boolean removeAll(Collection<?> collection) {\n",
        "2184": "      return removeIf(in(collection));\n",
        "2185": "    }\n",
        "2186": "\n",
        "2187": "    @Override\n",
        "2188": "    public boolean retainAll(Collection<?> collection) {\n",
        "2189": "      return removeIf(not(in(collection)));\n",
        "2190": "    }\n",
        "2191": "\n",
        "2192": "    @Override\n",
        "2193": "    public Object[] toArray() {\n",
        "2194": "      // creating an ArrayList so filtering happens once\n",
        "2195": "      return Lists.newArrayList(iterator()).toArray();\n",
        "2196": "    }\n",
        "2197": "\n",
        "2198": "    @Override\n",
        "2199": "    public <T> T[] toArray(T[] array) {\n",
        "2200": "      return Lists.newArrayList(iterator()).toArray(array);\n",
        "2201": "    }\n",
        "2202": "  }\n",
        "2203": "\n",
        "2204": "  private static class FilteredKeyMap<K, V> extends AbstractFilteredMap<K, V> {\n",
        "2205": "    Predicate<? super K> keyPredicate;\n",
        "2206": "\n",
        "2207": "    FilteredKeyMap(\n",
        "2208": "        Map<K, V> unfiltered,\n",
        "2209": "        Predicate<? super K> keyPredicate,\n",
        "2210": "        Predicate<? super Entry<K, V>> entryPredicate) {\n",
        "2211": "      super(unfiltered, entryPredicate);\n",
        "2212": "      this.keyPredicate = keyPredicate;\n",
        "2213": "    }\n",
        "2214": "\n",
        "2215": "    @Override\n",
        "2216": "    protected Set<Entry<K, V>> createEntrySet() {\n",
        "2217": "      return Sets.filter(unfiltered.entrySet(), predicate);\n",
        "2218": "    }\n",
        "2219": "\n",
        "2220": "    @Override\n",
        "2221": "    Set<K> createKeySet() {\n",
        "2222": "      return Sets.filter(unfiltered.keySet(), keyPredicate);\n",
        "2223": "    }\n",
        "2224": "\n",
        "2225": "    // The cast is called only when the key is in the unfiltered map, implying\n",
        "2226": "    // that key is a K.\n",
        "2227": "    @Override\n",
        "2228": "    @SuppressWarnings(\"unchecked\")\n",
        "2229": "    public boolean containsKey(Object key) {\n",
        "2230": "      return unfiltered.containsKey(key) && keyPredicate.apply((K) key);\n",
        "2231": "    }\n",
        "2232": "  }\n",
        "2233": "\n",
        "2234": "  static class FilteredEntryMap<K, V> extends AbstractFilteredMap<K, V> {\n",
        "2235": "    /**\n",
        "2236": "     * Entries in this set satisfy the predicate, but they don't validate the\n",
        "2237": "     * input to {@code Entry.setValue()}.\n",
        "2238": "     */\n",
        "2239": "    final Set<Entry<K, V>> filteredEntrySet;\n",
        "2240": "\n",
        "2241": "    FilteredEntryMap(Map<K, V> unfiltered, Predicate<? super Entry<K, V>> entryPredicate) {\n",
        "2242": "      super(unfiltered, entryPredicate);\n",
        "2243": "      filteredEntrySet = Sets.filter(unfiltered.entrySet(), predicate);\n",
        "2244": "    }\n",
        "2245": "\n",
        "2246": "    @Override\n",
        "2247": "    protected Set<Entry<K, V>> createEntrySet() {\n",
        "2248": "      return new EntrySet();\n",
        "2249": "    }\n",
        "2250": "\n",
        "2251": "    @WeakOuter\n",
        "2252": "    private class EntrySet extends ForwardingSet<Entry<K, V>> {\n",
        "2253": "      @Override\n",
        "2254": "      protected Set<Entry<K, V>> delegate() {\n",
        "2255": "        return filteredEntrySet;\n",
        "2256": "      }\n",
        "2257": "\n",
        "2258": "      @Override\n",
        "2259": "      public Iterator<Entry<K, V>> iterator() {\n",
        "2260": "        return new TransformedIterator<Entry<K, V>, Entry<K, V>>(filteredEntrySet.iterator()) {\n",
        "2261": "          @Override\n",
        "2262": "          Entry<K, V> transform(final Entry<K, V> entry) {\n",
        "2263": "            return new ForwardingMapEntry<K, V>() {\n",
        "2264": "              @Override\n",
        "2265": "              protected Entry<K, V> delegate() {\n",
        "2266": "                return entry;\n",
        "2267": "              }\n",
        "2268": "\n",
        "2269": "              @Override\n",
        "2270": "              public V setValue(V newValue) {\n",
        "2271": "                checkArgument(apply(getKey(), newValue));\n",
        "2272": "                return super.setValue(newValue);\n",
        "2273": "              }\n",
        "2274": "            };\n",
        "2275": "          }\n",
        "2276": "        };\n",
        "2277": "      }\n",
        "2278": "    }\n",
        "2279": "\n",
        "2280": "    @Override\n",
        "2281": "    Set<K> createKeySet() {\n",
        "2282": "      return new KeySet();\n",
        "2283": "    }\n",
        "2284": "\n",
        "2285": "    @WeakOuter\n",
        "2286": "    class KeySet extends Maps.KeySet<K, V> {\n",
        "2287": "      KeySet() {\n",
        "2288": "        super(FilteredEntryMap.this);\n",
        "2289": "      }\n",
        "2290": "\n",
        "2291": "      @Override\n",
        "2292": "      public boolean remove(Object o) {\n",
        "2293": "        if (containsKey(o)) {\n",
        "2294": "          unfiltered.remove(o);\n",
        "2295": "          return true;\n",
        "2296": "        }\n",
        "2297": "        return false;\n",
        "2298": "      }\n",
        "2299": "\n",
        "2300": "      private boolean removeIf(Predicate<? super K> keyPredicate) {\n",
        "2301": "        return Iterables.removeIf(\n",
        "2302": "            unfiltered.entrySet(),\n",
        "2303": "            Predicates.<Entry<K, V>>and(predicate, Maps.<K>keyPredicateOnEntries(keyPredicate)));\n",
        "2304": "      }\n",
        "2305": "\n",
        "2306": "      @Override\n",
        "2307": "      public boolean removeAll(Collection<?> c) {\n",
        "2308": "        return removeIf(in(c));\n",
        "2309": "      }\n",
        "2310": "\n",
        "2311": "      @Override\n",
        "2312": "      public boolean retainAll(Collection<?> c) {\n",
        "2313": "        return removeIf(not(in(c)));\n",
        "2314": "      }\n",
        "2315": "\n",
        "2316": "      @Override\n",
        "2317": "      public Object[] toArray() {\n",
        "2318": "        // creating an ArrayList so filtering happens once\n",
        "2319": "        return Lists.newArrayList(iterator()).toArray();\n",
        "2320": "      }\n",
        "2321": "\n",
        "2322": "      @Override\n",
        "2323": "      public <T> T[] toArray(T[] array) {\n",
        "2324": "        return Lists.newArrayList(iterator()).toArray(array);\n",
        "2325": "      }\n",
        "2326": "    }\n",
        "2327": "  }\n",
        "2328": "\n",
        "2329": "  /**\n",
        "2330": "   * Support {@code clear()}, {@code removeAll()}, and {@code retainAll()} when\n",
        "2331": "   * filtering a filtered sorted map.\n",
        "2332": "   */\n",
        "2333": "  private static <K, V> SortedMap<K, V> filterFiltered(\n",
        "2334": "      FilteredEntrySortedMap<K, V> map, Predicate<? super Entry<K, V>> entryPredicate) {\n",
        "2335": "    Predicate<Entry<K, V>> predicate = Predicates.and(map.predicate, entryPredicate);\n",
        "2336": "    return new FilteredEntrySortedMap<K, V>(map.sortedMap(), predicate);\n",
        "2337": "  }\n",
        "2338": "\n",
        "2339": "  private static class FilteredEntrySortedMap<K, V> extends FilteredEntryMap<K, V>\n",
        "2340": "      implements SortedMap<K, V> {\n",
        "2341": "\n",
        "2342": "    FilteredEntrySortedMap(\n",
        "2343": "        SortedMap<K, V> unfiltered, Predicate<? super Entry<K, V>> entryPredicate) {\n",
        "2344": "      super(unfiltered, entryPredicate);\n",
        "2345": "    }\n",
        "2346": "\n",
        "2347": "    SortedMap<K, V> sortedMap() {\n",
        "2348": "      return (SortedMap<K, V>) unfiltered;\n",
        "2349": "    }\n",
        "2350": "\n",
        "2351": "    @Override\n",
        "2352": "    public SortedSet<K> keySet() {\n",
        "2353": "      return (SortedSet<K>) super.keySet();\n",
        "2354": "    }\n",
        "2355": "\n",
        "2356": "    @Override\n",
        "2357": "    SortedSet<K> createKeySet() {\n",
        "2358": "      return new SortedKeySet();\n",
        "2359": "    }\n",
        "2360": "\n",
        "2361": "    @WeakOuter\n",
        "2362": "    class SortedKeySet extends KeySet implements SortedSet<K> {\n",
        "2363": "      @Override\n",
        "2364": "      public Comparator<? super K> comparator() {\n",
        "2365": "        return sortedMap().comparator();\n",
        "2366": "      }\n",
        "2367": "\n",
        "2368": "      @Override\n",
        "2369": "      public SortedSet<K> subSet(K fromElement, K toElement) {\n",
        "2370": "        return (SortedSet<K>) subMap(fromElement, toElement).keySet();\n",
        "2371": "      }\n",
        "2372": "\n",
        "2373": "      @Override\n",
        "2374": "      public SortedSet<K> headSet(K toElement) {\n",
        "2375": "        return (SortedSet<K>) headMap(toElement).keySet();\n",
        "2376": "      }\n",
        "2377": "\n",
        "2378": "      @Override\n",
        "2379": "      public SortedSet<K> tailSet(K fromElement) {\n",
        "2380": "        return (SortedSet<K>) tailMap(fromElement).keySet();\n",
        "2381": "      }\n",
        "2382": "\n",
        "2383": "      @Override\n",
        "2384": "      public K first() {\n",
        "2385": "        return firstKey();\n",
        "2386": "      }\n",
        "2387": "\n",
        "2388": "      @Override\n",
        "2389": "      public K last() {\n",
        "2390": "        return lastKey();\n",
        "2391": "      }\n",
        "2392": "    }\n",
        "2393": "\n",
        "2394": "    @Override\n",
        "2395": "    public Comparator<? super K> comparator() {\n",
        "2396": "      return sortedMap().comparator();\n",
        "2397": "    }\n",
        "2398": "\n",
        "2399": "    @Override\n",
        "2400": "    public K firstKey() {\n",
        "2401": "      // correctly throws NoSuchElementException when filtered map is empty.\n",
        "2402": "      return keySet().iterator().next();\n",
        "2403": "    }\n",
        "2404": "\n",
        "2405": "    @Override\n",
        "2406": "    public K lastKey() {\n",
        "2407": "      SortedMap<K, V> headMap = sortedMap();\n",
        "2408": "      while (true) {\n",
        "2409": "        // correctly throws NoSuchElementException when filtered map is empty.\n",
        "2410": "        K key = headMap.lastKey();\n",
        "2411": "        if (apply(key, unfiltered.get(key))) {\n",
        "2412": "          return key;\n",
        "2413": "        }\n",
        "2414": "        headMap = sortedMap().headMap(key);\n",
        "2415": "      }\n",
        "2416": "    }\n",
        "2417": "\n",
        "2418": "    @Override\n",
        "2419": "    public SortedMap<K, V> headMap(K toKey) {\n",
        "2420": "      return new FilteredEntrySortedMap<K, V>(sortedMap().headMap(toKey), predicate);\n",
        "2421": "    }\n",
        "2422": "\n",
        "2423": "    @Override\n",
        "2424": "    public SortedMap<K, V> subMap(K fromKey, K toKey) {\n",
        "2425": "      return new FilteredEntrySortedMap<K, V>(sortedMap().subMap(fromKey, toKey), predicate);\n",
        "2426": "    }\n",
        "2427": "\n",
        "2428": "    @Override\n",
        "2429": "    public SortedMap<K, V> tailMap(K fromKey) {\n",
        "2430": "      return new FilteredEntrySortedMap<K, V>(sortedMap().tailMap(fromKey), predicate);\n",
        "2431": "    }\n",
        "2432": "  }\n",
        "2433": "\n",
        "2434": "  /**\n",
        "2435": "   * Support {@code clear()}, {@code removeAll()}, and {@code retainAll()} when\n",
        "2436": "   * filtering a filtered map.\n",
        "2437": "   */\n",
        "2438": "  private static <K, V> BiMap<K, V> filterFiltered(\n",
        "2439": "      FilteredEntryBiMap<K, V> map, Predicate<? super Entry<K, V>> entryPredicate) {\n",
        "2440": "    Predicate<Entry<K, V>> predicate = Predicates.and(map.predicate, entryPredicate);\n",
        "2441": "    return new FilteredEntryBiMap<K, V>(map.unfiltered(), predicate);\n",
        "2442": "  }\n",
        "2443": "\n",
        "2444": "  static final class FilteredEntryBiMap<K, V> extends FilteredEntryMap<K, V>\n",
        "2445": "      implements BiMap<K, V> {\n",
        "2446": "    private final BiMap<V, K> inverse;\n",
        "2447": "\n",
        "2448": "    private static <K, V> Predicate<Entry<V, K>> inversePredicate(\n",
        "2449": "        final Predicate<? super Entry<K, V>> forwardPredicate) {\n",
        "2450": "      return new Predicate<Entry<V, K>>() {\n",
        "2451": "        @Override\n",
        "2452": "        public boolean apply(Entry<V, K> input) {\n",
        "2453": "          return forwardPredicate.apply(Maps.immutableEntry(input.getValue(), input.getKey()));\n",
        "2454": "        }\n",
        "2455": "      };\n",
        "2456": "    }\n",
        "2457": "\n",
        "2458": "    FilteredEntryBiMap(BiMap<K, V> delegate, Predicate<? super Entry<K, V>> predicate) {\n",
        "2459": "      super(delegate, predicate);\n",
        "2460": "      this.inverse =\n",
        "2461": "          new FilteredEntryBiMap<V, K>(delegate.inverse(), inversePredicate(predicate), this);\n",
        "2462": "    }\n",
        "2463": "\n",
        "2464": "    private FilteredEntryBiMap(\n",
        "2465": "        BiMap<K, V> delegate, Predicate<? super Entry<K, V>> predicate, BiMap<V, K> inverse) {\n",
        "2466": "      super(delegate, predicate);\n",
        "2467": "      this.inverse = inverse;\n",
        "2468": "    }\n",
        "2469": "\n",
        "2470": "    BiMap<K, V> unfiltered() {\n",
        "2471": "      return (BiMap<K, V>) unfiltered;\n",
        "2472": "    }\n",
        "2473": "\n",
        "2474": "    @Override\n",
        "2475": "    public V forcePut(@Nullable K key, @Nullable V value) {\n",
        "2476": "      checkArgument(apply(key, value));\n",
        "2477": "      return unfiltered().forcePut(key, value);\n",
        "2478": "    }\n",
        "2479": "\n",
        "2480": "    @Override\n",
        "2481": "    public BiMap<V, K> inverse() {\n",
        "2482": "      return inverse;\n",
        "2483": "    }\n",
        "2484": "\n",
        "2485": "    @Override\n",
        "2486": "    public Set<V> values() {\n",
        "2487": "      return inverse.keySet();\n",
        "2488": "    }\n",
        "2489": "  }\n",
        "2490": "\n",
        "2491": "  @Nullable\n",
        "2492": "  private static <K, V> Entry<K, V> unmodifiableOrNull(@Nullable Entry<K, V> entry) {\n",
        "2493": "    return (entry == null) ? null : Maps.unmodifiableEntry(entry);\n",
        "2494": "  }\n",
        "2495": "\n",
        "2496": "  /**\n",
        "2497": "   * {@code AbstractMap} extension that makes it easy to cache customized keySet, values,\n",
        "2498": "   * and entrySet views.\n",
        "2499": "   */\n",
        "2500": "  @GwtCompatible\n",
        "2501": "  abstract static class ViewCachingAbstractMap<K, V> extends AbstractMap<K, V> {\n",
        "2502": "    /**\n",
        "2503": "     * Creates the entry set to be returned by {@link #entrySet()}. This method\n",
        "2504": "     * is invoked at most once on a given map, at the time when {@code entrySet}\n",
        "2505": "     * is first called.\n",
        "2506": "     */\n",
        "2507": "    abstract Set<Entry<K, V>> createEntrySet();\n",
        "2508": "\n",
        "2509": "    private transient Set<Entry<K, V>> entrySet;\n",
        "2510": "\n",
        "2511": "    @Override\n",
        "2512": "    public Set<Entry<K, V>> entrySet() {\n",
        "2513": "      Set<Entry<K, V>> result = entrySet;\n",
        "2514": "      return (result == null) ? entrySet = createEntrySet() : result;\n",
        "2515": "    }\n",
        "2516": "\n",
        "2517": "    private transient Set<K> keySet;\n",
        "2518": "\n",
        "2519": "    @Override\n",
        "2520": "    public Set<K> keySet() {\n",
        "2521": "      Set<K> result = keySet;\n",
        "2522": "      return (result == null) ? keySet = createKeySet() : result;\n",
        "2523": "    }\n",
        "2524": "\n",
        "2525": "    Set<K> createKeySet() {\n",
        "2526": "      return new KeySet<K, V>(this);\n",
        "2527": "    }\n",
        "2528": "\n",
        "2529": "    private transient Collection<V> values;\n",
        "2530": "\n",
        "2531": "    @Override\n",
        "2532": "    public Collection<V> values() {\n",
        "2533": "      Collection<V> result = values;\n",
        "2534": "      return (result == null) ? values = createValues() : result;\n",
        "2535": "    }\n",
        "2536": "\n",
        "2537": "    Collection<V> createValues() {\n",
        "2538": "      return new Values<K, V>(this);\n",
        "2539": "    }\n",
        "2540": "  }\n",
        "2541": "\n",
        "2542": "  abstract static class IteratorBasedAbstractMap<K, V> extends AbstractMap<K, V> {\n",
        "2543": "    @Override\n",
        "2544": "    public abstract int size();\n",
        "2545": "\n",
        "2546": "    abstract Iterator<Entry<K, V>> entryIterator();\n",
        "2547": "\n",
        "2548": "    @Override\n",
        "2549": "    public Set<Entry<K, V>> entrySet() {\n",
        "2550": "      return new EntrySet<K, V>() {\n",
        "2551": "        @Override\n",
        "2552": "        Map<K, V> map() {\n",
        "2553": "          return IteratorBasedAbstractMap.this;\n",
        "2554": "        }\n",
        "2555": "\n",
        "2556": "        @Override\n",
        "2557": "        public Iterator<Entry<K, V>> iterator() {\n",
        "2558": "          return entryIterator();\n",
        "2559": "        }\n",
        "2560": "      };\n",
        "2561": "    }\n",
        "2562": "\n",
        "2563": "    @Override\n",
        "2564": "    public void clear() {\n",
        "2565": "      Iterators.clear(entryIterator());\n",
        "2566": "    }\n",
        "2567": "  }\n",
        "2568": "\n",
        "2569": "  /**\n",
        "2570": "   * Delegates to {@link Map#get}. Returns {@code null} on {@code\n",
        "2571": "   * ClassCastException} and {@code NullPointerException}.\n",
        "2572": "   */\n",
        "2573": "  static <V> V safeGet(Map<?, V> map, @Nullable Object key) {\n",
        "2574": "    checkNotNull(map);\n",
        "2575": "    try {\n",
        "2576": "      return map.get(key);\n",
        "2577": "    } catch (ClassCastException e) {\n",
        "2578": "      return null;\n",
        "2579": "    } catch (NullPointerException e) {\n",
        "2580": "      return null;\n",
        "2581": "    }\n",
        "2582": "  }\n",
        "2583": "\n",
        "2584": "  /**\n",
        "2585": "   * Delegates to {@link Map#containsKey}. Returns {@code false} on {@code\n",
        "2586": "   * ClassCastException} and {@code NullPointerException}.\n",
        "2587": "   */\n",
        "2588": "  static boolean safeContainsKey(Map<?, ?> map, Object key) {\n",
        "2589": "    checkNotNull(map);\n",
        "2590": "    try {\n",
        "2591": "      return map.containsKey(key);\n",
        "2592": "    } catch (ClassCastException e) {\n",
        "2593": "      return false;\n",
        "2594": "    } catch (NullPointerException e) {\n",
        "2595": "      return false;\n",
        "2596": "    }\n",
        "2597": "  }\n",
        "2598": "\n",
        "2599": "  /**\n",
        "2600": "   * Delegates to {@link Map#remove}. Returns {@code null} on {@code\n",
        "2601": "   * ClassCastException} and {@code NullPointerException}.\n",
        "2602": "   */\n",
        "2603": "  static <V> V safeRemove(Map<?, V> map, Object key) {\n",
        "2604": "    checkNotNull(map);\n",
        "2605": "    try {\n",
        "2606": "      return map.remove(key);\n",
        "2607": "    } catch (ClassCastException e) {\n",
        "2608": "      return null;\n",
        "2609": "    } catch (NullPointerException e) {\n",
        "2610": "      return null;\n",
        "2611": "    }\n",
        "2612": "  }\n",
        "2613": "\n",
        "2614": "  /**\n",
        "2615": "   * An admittedly inefficient implementation of {@link Map#containsKey}.\n",
        "2616": "   */\n",
        "2617": "  static boolean containsKeyImpl(Map<?, ?> map, @Nullable Object key) {\n",
        "2618": "    return Iterators.contains(keyIterator(map.entrySet().iterator()), key);\n",
        "2619": "  }\n",
        "2620": "\n",
        "2621": "  /**\n",
        "2622": "   * An implementation of {@link Map#containsValue}.\n",
        "2623": "   */\n",
        "2624": "  static boolean containsValueImpl(Map<?, ?> map, @Nullable Object value) {\n",
        "2625": "    return Iterators.contains(valueIterator(map.entrySet().iterator()), value);\n",
        "2626": "  }\n",
        "2627": "\n",
        "2628": "  /**\n",
        "2629": "   * Implements {@code Collection.contains} safely for forwarding collections of\n",
        "2630": "   * map entries. If {@code o} is an instance of {@code Map.Entry}, it is\n",
        "2631": "   * wrapped using {@link #unmodifiableEntry} to protect against a possible\n",
        "2632": "   * nefarious equals method.\n",
        "2633": "   *\n",
        "2634": "   * <p>Note that {@code c} is the backing (delegate) collection, rather than\n",
        "2635": "   * the forwarding collection.\n",
        "2636": "   *\n",
        "2637": "   * @param c the delegate (unwrapped) collection of map entries\n",
        "2638": "   * @param o the object that might be contained in {@code c}\n",
        "2639": "   * @return {@code true} if {@code c} contains {@code o}\n",
        "2640": "   */\n",
        "2641": "  static <K, V> boolean containsEntryImpl(Collection<Entry<K, V>> c, Object o) {\n",
        "2642": "    if (!(o instanceof Entry)) {\n",
        "2643": "      return false;\n",
        "2644": "    }\n",
        "2645": "    return c.contains(unmodifiableEntry((Entry<?, ?>) o));\n",
        "2646": "  }\n",
        "2647": "\n",
        "2648": "  /**\n",
        "2649": "   * Implements {@code Collection.remove} safely for forwarding collections of\n",
        "2650": "   * map entries. If {@code o} is an instance of {@code Map.Entry}, it is\n",
        "2651": "   * wrapped using {@link #unmodifiableEntry} to protect against a possible\n",
        "2652": "   * nefarious equals method.\n",
        "2653": "   *\n",
        "2654": "   * <p>Note that {@code c} is backing (delegate) collection, rather than the\n",
        "2655": "   * forwarding collection.\n",
        "2656": "   *\n",
        "2657": "   * @param c the delegate (unwrapped) collection of map entries\n",
        "2658": "   * @param o the object to remove from {@code c}\n",
        "2659": "   * @return {@code true} if {@code c} was changed\n",
        "2660": "   */\n",
        "2661": "  static <K, V> boolean removeEntryImpl(Collection<Entry<K, V>> c, Object o) {\n",
        "2662": "    if (!(o instanceof Entry)) {\n",
        "2663": "      return false;\n",
        "2664": "    }\n",
        "2665": "    return c.remove(unmodifiableEntry((Entry<?, ?>) o));\n",
        "2666": "  }\n",
        "2667": "\n",
        "2668": "  /**\n",
        "2669": "   * An implementation of {@link Map#equals}.\n",
        "2670": "   */\n",
        "2671": "  static boolean equalsImpl(Map<?, ?> map, Object object) {\n",
        "2672": "    if (map == object) {\n",
        "2673": "      return true;\n",
        "2674": "    } else if (object instanceof Map) {\n",
        "2675": "      Map<?, ?> o = (Map<?, ?>) object;\n",
        "2676": "      return map.entrySet().equals(o.entrySet());\n",
        "2677": "    }\n",
        "2678": "    return false;\n",
        "2679": "  }\n",
        "2680": "\n",
        "2681": "  static final MapJoiner STANDARD_JOINER = Collections2.STANDARD_JOINER.withKeyValueSeparator(\"=\");\n",
        "2682": "\n",
        "2683": "  /**\n",
        "2684": "   * An implementation of {@link Map#toString}.\n",
        "2685": "   */\n",
        "2686": "  static String toStringImpl(Map<?, ?> map) {\n",
        "2687": "    StringBuilder sb = Collections2.newStringBuilderForCollection(map.size()).append('{');\n",
        "2688": "    STANDARD_JOINER.appendTo(sb, map);\n",
        "2689": "    return sb.append('}').toString();\n",
        "2690": "  }\n",
        "2691": "\n",
        "2692": "  /**\n",
        "2693": "   * An implementation of {@link Map#putAll}.\n",
        "2694": "   */\n",
        "2695": "  static <K, V> void putAllImpl(Map<K, V> self, Map<? extends K, ? extends V> map) {\n",
        "2696": "    for (Map.Entry<? extends K, ? extends V> entry : map.entrySet()) {\n",
        "2697": "      self.put(entry.getKey(), entry.getValue());\n",
        "2698": "    }\n",
        "2699": "  }\n",
        "2700": "\n",
        "2701": "  static class KeySet<K, V> extends Sets.ImprovedAbstractSet<K> {\n",
        "2702": "    @Weak final Map<K, V> map;\n",
        "2703": "\n",
        "2704": "    KeySet(Map<K, V> map) {\n",
        "2705": "      this.map = checkNotNull(map);\n",
        "2706": "    }\n",
        "2707": "\n",
        "2708": "    Map<K, V> map() {\n",
        "2709": "      return map;\n",
        "2710": "    }\n",
        "2711": "\n",
        "2712": "    @Override\n",
        "2713": "    public Iterator<K> iterator() {\n",
        "2714": "      return keyIterator(map().entrySet().iterator());\n",
        "2715": "    }\n",
        "2716": "\n",
        "2717": "    @Override\n",
        "2718": "    public int size() {\n",
        "2719": "      return map().size();\n",
        "2720": "    }\n",
        "2721": "\n",
        "2722": "    @Override\n",
        "2723": "    public boolean isEmpty() {\n",
        "2724": "      return map().isEmpty();\n",
        "2725": "    }\n",
        "2726": "\n",
        "2727": "    @Override\n",
        "2728": "    public boolean contains(Object o) {\n",
        "2729": "      return map().containsKey(o);\n",
        "2730": "    }\n",
        "2731": "\n",
        "2732": "    @Override\n",
        "2733": "    public boolean remove(Object o) {\n",
        "2734": "      if (contains(o)) {\n",
        "2735": "        map().remove(o);\n",
        "2736": "        return true;\n",
        "2737": "      }\n",
        "2738": "      return false;\n",
        "2739": "    }\n",
        "2740": "\n",
        "2741": "    @Override\n",
        "2742": "    public void clear() {\n",
        "2743": "      map().clear();\n",
        "2744": "    }\n",
        "2745": "  }\n",
        "2746": "\n",
        "2747": "  @Nullable\n",
        "2748": "  static <K> K keyOrNull(@Nullable Entry<K, ?> entry) {\n",
        "2749": "    return (entry == null) ? null : entry.getKey();\n",
        "2750": "  }\n",
        "2751": "\n",
        "2752": "  @Nullable\n",
        "2753": "  static <V> V valueOrNull(@Nullable Entry<?, V> entry) {\n",
        "2754": "    return (entry == null) ? null : entry.getValue();\n",
        "2755": "  }\n",
        "2756": "\n",
        "2757": "  static class SortedKeySet<K, V> extends KeySet<K, V> implements SortedSet<K> {\n",
        "2758": "    SortedKeySet(SortedMap<K, V> map) {\n",
        "2759": "      super(map);\n",
        "2760": "    }\n",
        "2761": "\n",
        "2762": "    @Override\n",
        "2763": "    SortedMap<K, V> map() {\n",
        "2764": "      return (SortedMap<K, V>) super.map();\n",
        "2765": "    }\n",
        "2766": "\n",
        "2767": "    @Override\n",
        "2768": "    public Comparator<? super K> comparator() {\n",
        "2769": "      return map().comparator();\n",
        "2770": "    }\n",
        "2771": "\n",
        "2772": "    @Override\n",
        "2773": "    public SortedSet<K> subSet(K fromElement, K toElement) {\n",
        "2774": "      return new SortedKeySet<K, V>(map().subMap(fromElement, toElement));\n",
        "2775": "    }\n",
        "2776": "\n",
        "2777": "    @Override\n",
        "2778": "    public SortedSet<K> headSet(K toElement) {\n",
        "2779": "      return new SortedKeySet<K, V>(map().headMap(toElement));\n",
        "2780": "    }\n",
        "2781": "\n",
        "2782": "    @Override\n",
        "2783": "    public SortedSet<K> tailSet(K fromElement) {\n",
        "2784": "      return new SortedKeySet<K, V>(map().tailMap(fromElement));\n",
        "2785": "    }\n",
        "2786": "\n",
        "2787": "    @Override\n",
        "2788": "    public K first() {\n",
        "2789": "      return map().firstKey();\n",
        "2790": "    }\n",
        "2791": "\n",
        "2792": "    @Override\n",
        "2793": "    public K last() {\n",
        "2794": "      return map().lastKey();\n",
        "2795": "    }\n",
        "2796": "  }\n",
        "2797": "\n",
        "2798": "  static class Values<K, V> extends AbstractCollection<V> {\n",
        "2799": "    @Weak final Map<K, V> map;\n",
        "2800": "\n",
        "2801": "    Values(Map<K, V> map) {\n",
        "2802": "      this.map = checkNotNull(map);\n",
        "2803": "    }\n",
        "2804": "\n",
        "2805": "    final Map<K, V> map() {\n",
        "2806": "      return map;\n",
        "2807": "    }\n",
        "2808": "\n",
        "2809": "    @Override\n",
        "2810": "    public Iterator<V> iterator() {\n",
        "2811": "      return valueIterator(map().entrySet().iterator());\n",
        "2812": "    }\n",
        "2813": "\n",
        "2814": "    @Override\n",
        "2815": "    public boolean remove(Object o) {\n",
        "2816": "      try {\n",
        "2817": "        return super.remove(o);\n",
        "2818": "      } catch (UnsupportedOperationException e) {\n",
        "2819": "        for (Entry<K, V> entry : map().entrySet()) {\n",
        "2820": "          if (Objects.equal(o, entry.getValue())) {\n",
        "2821": "            map().remove(entry.getKey());\n",
        "2822": "            return true;\n",
        "2823": "          }\n",
        "2824": "        }\n",
        "2825": "        return false;\n",
        "2826": "      }\n",
        "2827": "    }\n",
        "2828": "\n",
        "2829": "    @Override\n",
        "2830": "    public boolean removeAll(Collection<?> c) {\n",
        "2831": "      try {\n",
        "2832": "        return super.removeAll(checkNotNull(c));\n",
        "2833": "      } catch (UnsupportedOperationException e) {\n",
        "2834": "        Set<K> toRemove = Sets.newHashSet();\n",
        "2835": "        for (Entry<K, V> entry : map().entrySet()) {\n",
        "2836": "          if (c.contains(entry.getValue())) {\n",
        "2837": "            toRemove.add(entry.getKey());\n",
        "2838": "          }\n",
        "2839": "        }\n",
        "2840": "        return map().keySet().removeAll(toRemove);\n",
        "2841": "      }\n",
        "2842": "    }\n",
        "2843": "\n",
        "2844": "    @Override\n",
        "2845": "    public boolean retainAll(Collection<?> c) {\n",
        "2846": "      try {\n",
        "2847": "        return super.retainAll(checkNotNull(c));\n",
        "2848": "      } catch (UnsupportedOperationException e) {\n",
        "2849": "        Set<K> toRetain = Sets.newHashSet();\n",
        "2850": "        for (Entry<K, V> entry : map().entrySet()) {\n",
        "2851": "          if (c.contains(entry.getValue())) {\n",
        "2852": "            toRetain.add(entry.getKey());\n",
        "2853": "          }\n",
        "2854": "        }\n",
        "2855": "        return map().keySet().retainAll(toRetain);\n",
        "2856": "      }\n",
        "2857": "    }\n",
        "2858": "\n",
        "2859": "    @Override\n",
        "2860": "    public int size() {\n",
        "2861": "      return map().size();\n",
        "2862": "    }\n",
        "2863": "\n",
        "2864": "    @Override\n",
        "2865": "    public boolean isEmpty() {\n",
        "2866": "      return map().isEmpty();\n",
        "2867": "    }\n",
        "2868": "\n",
        "2869": "    @Override\n",
        "2870": "    public boolean contains(@Nullable Object o) {\n",
        "2871": "      return map().containsValue(o);\n",
        "2872": "    }\n",
        "2873": "\n",
        "2874": "    @Override\n",
        "2875": "    public void clear() {\n",
        "2876": "      map().clear();\n",
        "2877": "    }\n",
        "2878": "  }\n",
        "2879": "\n",
        "2880": "  abstract static class EntrySet<K, V> extends Sets.ImprovedAbstractSet<Entry<K, V>> {\n",
        "2881": "    abstract Map<K, V> map();\n",
        "2882": "\n",
        "2883": "    @Override\n",
        "2884": "    public int size() {\n",
        "2885": "      return map().size();\n",
        "2886": "    }\n",
        "2887": "\n",
        "2888": "    @Override\n",
        "2889": "    public void clear() {\n",
        "2890": "      map().clear();\n",
        "2891": "    }\n",
        "2892": "\n",
        "2893": "    @Override\n",
        "2894": "    public boolean contains(Object o) {\n",
        "2895": "      if (o instanceof Entry) {\n",
        "2896": "        Entry<?, ?> entry = (Entry<?, ?>) o;\n",
        "2897": "        Object key = entry.getKey();\n",
        "2898": "        V value = Maps.safeGet(map(), key);\n",
        "2899": "        return Objects.equal(value, entry.getValue()) && (value != null || map().containsKey(key));\n",
        "2900": "      }\n",
        "2901": "      return false;\n",
        "2902": "    }\n",
        "2903": "\n",
        "2904": "    @Override\n",
        "2905": "    public boolean isEmpty() {\n",
        "2906": "      return map().isEmpty();\n",
        "2907": "    }\n",
        "2908": "\n",
        "2909": "    @Override\n",
        "2910": "    public boolean remove(Object o) {\n",
        "2911": "      if (contains(o)) {\n",
        "2912": "        Entry<?, ?> entry = (Entry<?, ?>) o;\n",
        "2913": "        return map().keySet().remove(entry.getKey());\n",
        "2914": "      }\n",
        "2915": "      return false;\n",
        "2916": "    }\n",
        "2917": "\n",
        "2918": "    @Override\n",
        "2919": "    public boolean removeAll(Collection<?> c) {\n",
        "2920": "      try {\n",
        "2921": "        return super.removeAll(checkNotNull(c));\n",
        "2922": "      } catch (UnsupportedOperationException e) {\n",
        "2923": "        // if the iterators don't support remove\n",
        "2924": "        return Sets.removeAllImpl(this, c.iterator());\n",
        "2925": "      }\n",
        "2926": "    }\n",
        "2927": "\n",
        "2928": "    @Override\n",
        "2929": "    public boolean retainAll(Collection<?> c) {\n",
        "2930": "      try {\n",
        "2931": "        return super.retainAll(checkNotNull(c));\n",
        "2932": "      } catch (UnsupportedOperationException e) {\n",
        "2933": "        // if the iterators don't support remove\n",
        "2934": "        Set<Object> keys = Sets.newHashSetWithExpectedSize(c.size());\n",
        "2935": "        for (Object o : c) {\n",
        "2936": "          if (contains(o)) {\n",
        "2937": "            Entry<?, ?> entry = (Entry<?, ?>) o;\n",
        "2938": "            keys.add(entry.getKey());\n",
        "2939": "          }\n",
        "2940": "        }\n",
        "2941": "        return map().keySet().retainAll(keys);\n",
        "2942": "      }\n",
        "2943": "    }\n",
        "2944": "  }\n",
        "2945": "\n",
        "2946": "  /**\n",
        "2947": "   * Returns a map from the ith element of list to i.\n",
        "2948": "   */\n",
        "2949": "  static <E> ImmutableMap<E, Integer> indexMap(Collection<E> list) {\n",
        "2950": "    ImmutableMap.Builder<E, Integer> builder = new ImmutableMap.Builder<E, Integer>(list.size());\n",
        "2951": "    int i = 0;\n",
        "2952": "    for (E e : list) {\n",
        "2953": "      builder.put(e, i++);\n",
        "2954": "    }\n",
        "2955": "    return builder.build();\n",
        "2956": "  }\n",
        "2957": "}\n",
        "2958": "\n"
    }
}