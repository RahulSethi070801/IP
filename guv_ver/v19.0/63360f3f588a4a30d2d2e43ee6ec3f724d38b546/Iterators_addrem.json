{
    "addition": {},
    "removed": {
        "1": "/*\n",
        "2": " * Copyright (C) 2007 The Guava Authors\n",
        "3": " *\n",
        "4": " * Licensed under the Apache License, Version 2.0 (the \"License\");\n",
        "5": " * you may not use this file except in compliance with the License.\n",
        "6": " * You may obtain a copy of the License at\n",
        "7": " *\n",
        "8": " * http://www.apache.org/licenses/LICENSE-2.0\n",
        "9": " *\n",
        "10": " * Unless required by applicable law or agreed to in writing, software\n",
        "11": " * distributed under the License is distributed on an \"AS IS\" BASIS,\n",
        "12": " * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n",
        "13": " * See the License for the specific language governing permissions and\n",
        "14": " * limitations under the License.\n",
        "15": " */\n",
        "16": "\n",
        "17": "package com.google.common.collect;\n",
        "18": "\n",
        "19": "import static com.google.common.base.Preconditions.checkArgument;\n",
        "20": "import static com.google.common.base.Preconditions.checkNotNull;\n",
        "21": "import static com.google.common.base.Preconditions.checkState;\n",
        "22": "import static com.google.common.base.Predicates.equalTo;\n",
        "23": "import static com.google.common.base.Predicates.in;\n",
        "24": "import static com.google.common.base.Predicates.not;\n",
        "25": "import static com.google.common.collect.CollectPreconditions.checkRemove;\n",
        "26": "\n",
        "27": "import com.google.common.annotations.Beta;\n",
        "28": "import com.google.common.annotations.GwtCompatible;\n",
        "29": "import com.google.common.base.Function;\n",
        "30": "import com.google.common.base.Objects;\n",
        "31": "import com.google.common.base.Optional;\n",
        "32": "import com.google.common.base.Preconditions;\n",
        "33": "import com.google.common.base.Predicate;\n",
        "34": "\n",
        "35": "import java.util.Arrays;\n",
        "36": "import java.util.Collection;\n",
        "37": "import java.util.Collections;\n",
        "38": "import java.util.Comparator;\n",
        "39": "import java.util.Enumeration;\n",
        "40": "import java.util.Iterator;\n",
        "41": "import java.util.List;\n",
        "42": "import java.util.ListIterator;\n",
        "43": "import java.util.NoSuchElementException;\n",
        "44": "import java.util.PriorityQueue;\n",
        "45": "import java.util.Queue;\n",
        "46": "\n",
        "47": "import javax.annotation.CheckReturnValue;\n",
        "48": "import javax.annotation.Nullable;\n",
        "49": "\n",
        "50": "/**\n",
        "51": " * This class contains static utility methods that operate on or return objects\n",
        "52": " * of type {@link Iterator}. Except as noted, each method has a corresponding\n",
        "53": " * {@link Iterable}-based method in the {@link Iterables} class.\n",
        "54": " *\n",
        "55": " * <p><i>Performance notes:</i> Unless otherwise noted, all of the iterators\n",
        "56": " * produced in this class are <i>lazy</i>, which means that they only advance\n",
        "57": " * the backing iteration when absolutely necessary.\n",
        "58": " *\n",
        "59": " * <p>See the Guava User Guide section on <a href=\n",
        "60": " * \"https://github.com/google/guava/wiki/CollectionUtilitiesExplained#iterables\">\n",
        "61": " * {@code Iterators}</a>.\n",
        "62": " *\n",
        "63": " * @author Kevin Bourrillion\n",
        "64": " * @author Jared Levy\n",
        "65": " * @since 2.0\n",
        "66": " */\n",
        "67": "@GwtCompatible(emulated = true)\n",
        "68": "public final class Iterators {\n",
        "69": "  private Iterators() {}\n",
        "70": "\n",
        "71": "  static final UnmodifiableListIterator<Object> EMPTY_LIST_ITERATOR =\n",
        "72": "      new UnmodifiableListIterator<Object>() {\n",
        "73": "        @Override\n",
        "74": "        public boolean hasNext() {\n",
        "75": "          return false;\n",
        "76": "        }\n",
        "77": "\n",
        "78": "        @Override\n",
        "79": "        public Object next() {\n",
        "80": "          throw new NoSuchElementException();\n",
        "81": "        }\n",
        "82": "\n",
        "83": "        @Override\n",
        "84": "        public boolean hasPrevious() {\n",
        "85": "          return false;\n",
        "86": "        }\n",
        "87": "\n",
        "88": "        @Override\n",
        "89": "        public Object previous() {\n",
        "90": "          throw new NoSuchElementException();\n",
        "91": "        }\n",
        "92": "\n",
        "93": "        @Override\n",
        "94": "        public int nextIndex() {\n",
        "95": "          return 0;\n",
        "96": "        }\n",
        "97": "\n",
        "98": "        @Override\n",
        "99": "        public int previousIndex() {\n",
        "100": "          return -1;\n",
        "101": "        }\n",
        "102": "      };\n",
        "103": "\n",
        "104": "  /**\n",
        "105": "   * Returns the empty iterator.\n",
        "106": "   *\n",
        "107": "   * <p>The {@link Iterable} equivalent of this method is {@link\n",
        "108": "   * ImmutableSet#of()}.\n",
        "109": "   *\n",
        "110": "   * @deprecated Use {@code ImmutableSet.<T>of().iterator()} instead; or for\n",
        "111": "   *     Java 7 or later, {@link Collections#emptyIterator}. This method is\n",
        "112": "   *     scheduled for removal in May 2016.\n",
        "113": "   */\n",
        "114": "  @Deprecated\n",
        "115": "  public static <T> UnmodifiableIterator<T> emptyIterator() {\n",
        "116": "    return emptyListIterator();\n",
        "117": "  }\n",
        "118": "\n",
        "119": "  /**\n",
        "120": "   * Returns the empty iterator.\n",
        "121": "   *\n",
        "122": "   * <p>The {@link Iterable} equivalent of this method is {@link\n",
        "123": "   * ImmutableSet#of()}.\n",
        "124": "   */\n",
        "125": "  // Casting to any type is safe since there are no actual elements.\n",
        "126": "  @SuppressWarnings(\"unchecked\")\n",
        "127": "  static <T> UnmodifiableListIterator<T> emptyListIterator() {\n",
        "128": "    return (UnmodifiableListIterator<T>) EMPTY_LIST_ITERATOR;\n",
        "129": "  }\n",
        "130": "\n",
        "131": "  private static final Iterator<Object> EMPTY_MODIFIABLE_ITERATOR =\n",
        "132": "      new Iterator<Object>() {\n",
        "133": "        @Override\n",
        "134": "        public boolean hasNext() {\n",
        "135": "          return false;\n",
        "136": "        }\n",
        "137": "\n",
        "138": "        @Override\n",
        "139": "        public Object next() {\n",
        "140": "          throw new NoSuchElementException();\n",
        "141": "        }\n",
        "142": "\n",
        "143": "        @Override\n",
        "144": "        public void remove() {\n",
        "145": "          checkRemove(false);\n",
        "146": "        }\n",
        "147": "      };\n",
        "148": "\n",
        "149": "  /**\n",
        "150": "   * Returns the empty {@code Iterator} that throws\n",
        "151": "   * {@link IllegalStateException} instead of\n",
        "152": "   * {@link UnsupportedOperationException} on a call to\n",
        "153": "   * {@link Iterator#remove()}.\n",
        "154": "   */\n",
        "155": "  // Casting to any type is safe since there are no actual elements.\n",
        "156": "  @SuppressWarnings(\"unchecked\")\n",
        "157": "  static <T> Iterator<T> emptyModifiableIterator() {\n",
        "158": "    return (Iterator<T>) EMPTY_MODIFIABLE_ITERATOR;\n",
        "159": "  }\n",
        "160": "\n",
        "161": "  /** Returns an unmodifiable view of {@code iterator}. */\n",
        "162": "  public static <T> UnmodifiableIterator<T> unmodifiableIterator(final Iterator<T> iterator) {\n",
        "163": "    checkNotNull(iterator);\n",
        "164": "    if (iterator instanceof UnmodifiableIterator) {\n",
        "165": "      return (UnmodifiableIterator<T>) iterator;\n",
        "166": "    }\n",
        "167": "    return new UnmodifiableIterator<T>() {\n",
        "168": "      @Override\n",
        "169": "      public boolean hasNext() {\n",
        "170": "        return iterator.hasNext();\n",
        "171": "      }\n",
        "172": "\n",
        "173": "      @Override\n",
        "174": "      public T next() {\n",
        "175": "        return iterator.next();\n",
        "176": "      }\n",
        "177": "    };\n",
        "178": "  }\n",
        "179": "\n",
        "180": "  /**\n",
        "181": "   * Simply returns its argument.\n",
        "182": "   *\n",
        "183": "   * @deprecated no need to use this\n",
        "184": "   * @since 10.0\n",
        "185": "   */\n",
        "186": "  @Deprecated\n",
        "187": "  public static <T> UnmodifiableIterator<T> unmodifiableIterator(UnmodifiableIterator<T> iterator) {\n",
        "188": "    return checkNotNull(iterator);\n",
        "189": "  }\n",
        "190": "\n",
        "191": "  /**\n",
        "192": "   * Returns the number of elements remaining in {@code iterator}. The iterator\n",
        "193": "   * will be left exhausted: its {@code hasNext()} method will return\n",
        "194": "   * {@code false}.\n",
        "195": "   */\n",
        "196": "  public static int size(Iterator<?> iterator) {\n",
        "197": "    int count = 0;\n",
        "198": "    while (iterator.hasNext()) {\n",
        "199": "      iterator.next();\n",
        "200": "      count++;\n",
        "201": "    }\n",
        "202": "    return count;\n",
        "203": "  }\n",
        "204": "\n",
        "205": "  /**\n",
        "206": "   * Returns {@code true} if {@code iterator} contains {@code element}.\n",
        "207": "   */\n",
        "208": "  public static boolean contains(Iterator<?> iterator, @Nullable Object element) {\n",
        "209": "    return any(iterator, equalTo(element));\n",
        "210": "  }\n",
        "211": "\n",
        "212": "  /**\n",
        "213": "   * Traverses an iterator and removes every element that belongs to the\n",
        "214": "   * provided collection. The iterator will be left exhausted: its\n",
        "215": "   * {@code hasNext()} method will return {@code false}.\n",
        "216": "   *\n",
        "217": "   * @param removeFrom the iterator to (potentially) remove elements from\n",
        "218": "   * @param elementsToRemove the elements to remove\n",
        "219": "   * @return {@code true} if any element was removed from {@code iterator}\n",
        "220": "   */\n",
        "221": "  public static boolean removeAll(Iterator<?> removeFrom, Collection<?> elementsToRemove) {\n",
        "222": "    return removeIf(removeFrom, in(elementsToRemove));\n",
        "223": "  }\n",
        "224": "\n",
        "225": "  /**\n",
        "226": "   * Removes every element that satisfies the provided predicate from the\n",
        "227": "   * iterator. The iterator will be left exhausted: its {@code hasNext()}\n",
        "228": "   * method will return {@code false}.\n",
        "229": "   *\n",
        "230": "   * @param removeFrom the iterator to (potentially) remove elements from\n",
        "231": "   * @param predicate a predicate that determines whether an element should\n",
        "232": "   *     be removed\n",
        "233": "   * @return {@code true} if any elements were removed from the iterator\n",
        "234": "   * @since 2.0\n",
        "235": "   */\n",
        "236": "  public static <T> boolean removeIf(Iterator<T> removeFrom, Predicate<? super T> predicate) {\n",
        "237": "    checkNotNull(predicate);\n",
        "238": "    boolean modified = false;\n",
        "239": "    while (removeFrom.hasNext()) {\n",
        "240": "      if (predicate.apply(removeFrom.next())) {\n",
        "241": "        removeFrom.remove();\n",
        "242": "        modified = true;\n",
        "243": "      }\n",
        "244": "    }\n",
        "245": "    return modified;\n",
        "246": "  }\n",
        "247": "\n",
        "248": "  /**\n",
        "249": "   * Traverses an iterator and removes every element that does not belong to the\n",
        "250": "   * provided collection. The iterator will be left exhausted: its\n",
        "251": "   * {@code hasNext()} method will return {@code false}.\n",
        "252": "   *\n",
        "253": "   * @param removeFrom the iterator to (potentially) remove elements from\n",
        "254": "   * @param elementsToRetain the elements to retain\n",
        "255": "   * @return {@code true} if any element was removed from {@code iterator}\n",
        "256": "   */\n",
        "257": "  public static boolean retainAll(Iterator<?> removeFrom, Collection<?> elementsToRetain) {\n",
        "258": "    return removeIf(removeFrom, not(in(elementsToRetain)));\n",
        "259": "  }\n",
        "260": "\n",
        "261": "  /**\n",
        "262": "   * Determines whether two iterators contain equal elements in the same order.\n",
        "263": "   * More specifically, this method returns {@code true} if {@code iterator1}\n",
        "264": "   * and {@code iterator2} contain the same number of elements and every element\n",
        "265": "   * of {@code iterator1} is equal to the corresponding element of\n",
        "266": "   * {@code iterator2}.\n",
        "267": "   *\n",
        "268": "   * <p>Note that this will modify the supplied iterators, since they will have\n",
        "269": "   * been advanced some number of elements forward.\n",
        "270": "   */\n",
        "271": "  public static boolean elementsEqual(Iterator<?> iterator1, Iterator<?> iterator2) {\n",
        "272": "    while (iterator1.hasNext()) {\n",
        "273": "      if (!iterator2.hasNext()) {\n",
        "274": "        return false;\n",
        "275": "      }\n",
        "276": "      Object o1 = iterator1.next();\n",
        "277": "      Object o2 = iterator2.next();\n",
        "278": "      if (!Objects.equal(o1, o2)) {\n",
        "279": "        return false;\n",
        "280": "      }\n",
        "281": "    }\n",
        "282": "    return !iterator2.hasNext();\n",
        "283": "  }\n",
        "284": "\n",
        "285": "  /**\n",
        "286": "   * Returns a string representation of {@code iterator}, with the format\n",
        "287": "   * {@code [e1, e2, ..., en]}. The iterator will be left exhausted: its\n",
        "288": "   * {@code hasNext()} method will return {@code false}.\n",
        "289": "   */\n",
        "290": "  public static String toString(Iterator<?> iterator) {\n",
        "291": "    return Collections2.STANDARD_JOINER\n",
        "292": "        .appendTo(new StringBuilder().append('['), iterator)\n",
        "293": "        .append(']')\n",
        "294": "        .toString();\n",
        "295": "  }\n",
        "296": "\n",
        "297": "  /**\n",
        "298": "   * Returns the single element contained in {@code iterator}.\n",
        "299": "   *\n",
        "300": "   * @throws NoSuchElementException if the iterator is empty\n",
        "301": "   * @throws IllegalArgumentException if the iterator contains multiple\n",
        "302": "   *     elements.  The state of the iterator is unspecified.\n",
        "303": "   */\n",
        "304": "  public static <T> T getOnlyElement(Iterator<T> iterator) {\n",
        "305": "    T first = iterator.next();\n",
        "306": "    if (!iterator.hasNext()) {\n",
        "307": "      return first;\n",
        "308": "    }\n",
        "309": "\n",
        "310": "    StringBuilder sb = new StringBuilder();\n",
        "311": "    sb.append(\"expected one element but was: <\" + first);\n",
        "312": "    for (int i = 0; i < 4 && iterator.hasNext(); i++) {\n",
        "313": "      sb.append(\", \" + iterator.next());\n",
        "314": "    }\n",
        "315": "    if (iterator.hasNext()) {\n",
        "316": "      sb.append(\", ...\");\n",
        "317": "    }\n",
        "318": "    sb.append('>');\n",
        "319": "\n",
        "320": "    throw new IllegalArgumentException(sb.toString());\n",
        "321": "  }\n",
        "322": "\n",
        "323": "  /**\n",
        "324": "   * Returns the single element contained in {@code iterator}, or {@code\n",
        "325": "   * defaultValue} if the iterator is empty.\n",
        "326": "   *\n",
        "327": "   * @throws IllegalArgumentException if the iterator contains multiple\n",
        "328": "   *     elements.  The state of the iterator is unspecified.\n",
        "329": "   */\n",
        "330": "  @Nullable\n",
        "331": "  public static <T> T getOnlyElement(Iterator<? extends T> iterator, @Nullable T defaultValue) {\n",
        "332": "    return iterator.hasNext() ? getOnlyElement(iterator) : defaultValue;\n",
        "333": "  }\n",
        "334": "\n",
        "335": "  /**\n",
        "336": "   * Adds all elements in {@code iterator} to {@code collection}. The iterator\n",
        "337": "   * will be left exhausted: its {@code hasNext()} method will return\n",
        "338": "   * {@code false}.\n",
        "339": "   *\n",
        "340": "   * @return {@code true} if {@code collection} was modified as a result of this\n",
        "341": "   *         operation\n",
        "342": "   */\n",
        "343": "  public static <T> boolean addAll(Collection<T> addTo, Iterator<? extends T> iterator) {\n",
        "344": "    checkNotNull(addTo);\n",
        "345": "    checkNotNull(iterator);\n",
        "346": "    boolean wasModified = false;\n",
        "347": "    while (iterator.hasNext()) {\n",
        "348": "      wasModified |= addTo.add(iterator.next());\n",
        "349": "    }\n",
        "350": "    return wasModified;\n",
        "351": "  }\n",
        "352": "\n",
        "353": "  /**\n",
        "354": "   * Returns the number of elements in the specified iterator that equal the\n",
        "355": "   * specified object. The iterator will be left exhausted: its\n",
        "356": "   * {@code hasNext()} method will return {@code false}.\n",
        "357": "   *\n",
        "358": "   * @see Collections#frequency\n",
        "359": "   */\n",
        "360": "  public static int frequency(Iterator<?> iterator, @Nullable Object element) {\n",
        "361": "    return size(filter(iterator, equalTo(element)));\n",
        "362": "  }\n",
        "363": "\n",
        "364": "  /**\n",
        "365": "   * Returns an iterator that cycles indefinitely over the elements of {@code\n",
        "366": "   * iterable}.\n",
        "367": "   *\n",
        "368": "   * <p>The returned iterator supports {@code remove()} if the provided iterator\n",
        "369": "   * does. After {@code remove()} is called, subsequent cycles omit the removed\n",
        "370": "   * element, which is no longer in {@code iterable}. The iterator's\n",
        "371": "   * {@code hasNext()} method returns {@code true} until {@code iterable} is\n",
        "372": "   * empty.\n",
        "373": "   *\n",
        "374": "   * <p><b>Warning:</b> Typical uses of the resulting iterator may produce an\n",
        "375": "   * infinite loop. You should use an explicit {@code break} or be certain that\n",
        "376": "   * you will eventually remove all the elements.\n",
        "377": "   */\n",
        "378": "  public static <T> Iterator<T> cycle(final Iterable<T> iterable) {\n",
        "379": "    checkNotNull(iterable);\n",
        "380": "    return new Iterator<T>() {\n",
        "381": "      Iterator<T> iterator = emptyModifiableIterator();\n",
        "382": "\n",
        "383": "      @Override\n",
        "384": "      public boolean hasNext() {\n",
        "385": "        /*\n",
        "386": "         * Don't store a new Iterator until we know the user can't remove() the last returned\n",
        "387": "         * element anymore. Otherwise, when we remove from the old iterator, we may be invalidating\n",
        "388": "         * the new one. The result is a ConcurrentModificationException or other bad behavior.\n",
        "389": "         *\n",
        "390": "         * (If we decide that we really, really hate allocating two Iterators per cycle instead of\n",
        "391": "         * one, we can optimistically store the new Iterator and then be willing to throw it out if\n",
        "392": "         * the user calls remove().)\n",
        "393": "         */\n",
        "394": "        return iterator.hasNext() || iterable.iterator().hasNext();\n",
        "395": "      }\n",
        "396": "\n",
        "397": "      @Override\n",
        "398": "      public T next() {\n",
        "399": "        if (!iterator.hasNext()) {\n",
        "400": "          iterator = iterable.iterator();\n",
        "401": "          if (!iterator.hasNext()) {\n",
        "402": "            throw new NoSuchElementException();\n",
        "403": "          }\n",
        "404": "        }\n",
        "405": "        return iterator.next();\n",
        "406": "      }\n",
        "407": "\n",
        "408": "      @Override\n",
        "409": "      public void remove() {\n",
        "410": "        iterator.remove();\n",
        "411": "      }\n",
        "412": "    };\n",
        "413": "  }\n",
        "414": "\n",
        "415": "  /**\n",
        "416": "   * Returns an iterator that cycles indefinitely over the provided elements.\n",
        "417": "   *\n",
        "418": "   * <p>The returned iterator supports {@code remove()}. After {@code remove()}\n",
        "419": "   * is called, subsequent cycles omit the removed\n",
        "420": "   * element, but {@code elements} does not change. The iterator's\n",
        "421": "   * {@code hasNext()} method returns {@code true} until all of the original\n",
        "422": "   * elements have been removed.\n",
        "423": "   *\n",
        "424": "   * <p><b>Warning:</b> Typical uses of the resulting iterator may produce an\n",
        "425": "   * infinite loop. You should use an explicit {@code break} or be certain that\n",
        "426": "   * you will eventually remove all the elements.\n",
        "427": "   */\n",
        "428": "  public static <T> Iterator<T> cycle(T... elements) {\n",
        "429": "    return cycle(Lists.newArrayList(elements));\n",
        "430": "  }\n",
        "431": "\n",
        "432": "  /**\n",
        "433": "   * Combines two iterators into a single iterator. The returned iterator\n",
        "434": "   * iterates across the elements in {@code a}, followed by the elements in\n",
        "435": "   * {@code b}. The source iterators are not polled until necessary.\n",
        "436": "   *\n",
        "437": "   * <p>The returned iterator supports {@code remove()} when the corresponding\n",
        "438": "   * input iterator supports it.\n",
        "439": "   *\n",
        "440": "   * <p><b>Note:</b> the current implementation is not suitable for nested\n",
        "441": "   * concatenated iterators, i.e. the following should be avoided when in a loop:\n",
        "442": "   * {@code iterator = Iterators.concat(iterator, suffix);}, since iteration over the\n",
        "443": "   * resulting iterator has a cubic complexity to the depth of the nesting.\n",
        "444": "   */\n",
        "445": "  public static <T> Iterator<T> concat(Iterator<? extends T> a, Iterator<? extends T> b) {\n",
        "446": "    checkNotNull(a);\n",
        "447": "    checkNotNull(b);\n",
        "448": "    return concat(new ConsumingQueueIterator<Iterator<? extends T>>(a, b));\n",
        "449": "  }\n",
        "450": "\n",
        "451": "  /**\n",
        "452": "   * Combines three iterators into a single iterator. The returned iterator\n",
        "453": "   * iterates across the elements in {@code a}, followed by the elements in\n",
        "454": "   * {@code b}, followed by the elements in {@code c}. The source iterators\n",
        "455": "   * are not polled until necessary.\n",
        "456": "   *\n",
        "457": "   * <p>The returned iterator supports {@code remove()} when the corresponding\n",
        "458": "   * input iterator supports it.\n",
        "459": "   *\n",
        "460": "   * <p><b>Note:</b> the current implementation is not suitable for nested\n",
        "461": "   * concatenated iterators, i.e. the following should be avoided when in a loop:\n",
        "462": "   * {@code iterator = Iterators.concat(iterator, suffix);}, since iteration over the\n",
        "463": "   * resulting iterator has a cubic complexity to the depth of the nesting.\n",
        "464": "   */\n",
        "465": "  public static <T> Iterator<T> concat(\n",
        "466": "      Iterator<? extends T> a, Iterator<? extends T> b, Iterator<? extends T> c) {\n",
        "467": "    checkNotNull(a);\n",
        "468": "    checkNotNull(b);\n",
        "469": "    checkNotNull(c);\n",
        "470": "    return concat(new ConsumingQueueIterator<Iterator<? extends T>>(a, b, c));\n",
        "471": "  }\n",
        "472": "\n",
        "473": "  /**\n",
        "474": "   * Combines four iterators into a single iterator. The returned iterator\n",
        "475": "   * iterates across the elements in {@code a}, followed by the elements in\n",
        "476": "   * {@code b}, followed by the elements in {@code c}, followed by the elements\n",
        "477": "   * in {@code d}. The source iterators are not polled until necessary.\n",
        "478": "   *\n",
        "479": "   * <p>The returned iterator supports {@code remove()} when the corresponding\n",
        "480": "   * input iterator supports it.\n",
        "481": "   *\n",
        "482": "   * <p><b>Note:</b> the current implementation is not suitable for nested\n",
        "483": "   * concatenated iterators, i.e. the following should be avoided when in a loop:\n",
        "484": "   * {@code iterator = Iterators.concat(iterator, suffix);}, since iteration over the\n",
        "485": "   * resulting iterator has a cubic complexity to the depth of the nesting.\n",
        "486": "   */\n",
        "487": "  public static <T> Iterator<T> concat(\n",
        "488": "      Iterator<? extends T> a,\n",
        "489": "      Iterator<? extends T> b,\n",
        "490": "      Iterator<? extends T> c,\n",
        "491": "      Iterator<? extends T> d) {\n",
        "492": "    checkNotNull(a);\n",
        "493": "    checkNotNull(b);\n",
        "494": "    checkNotNull(c);\n",
        "495": "    checkNotNull(d);\n",
        "496": "    return concat(new ConsumingQueueIterator<Iterator<? extends T>>(a, b, c, d));\n",
        "497": "  }\n",
        "498": "\n",
        "499": "  /**\n",
        "500": "   * Combines multiple iterators into a single iterator. The returned iterator\n",
        "501": "   * iterates across the elements of each iterator in {@code inputs}. The input\n",
        "502": "   * iterators are not polled until necessary.\n",
        "503": "   *\n",
        "504": "   * <p>The returned iterator supports {@code remove()} when the corresponding\n",
        "505": "   * input iterator supports it.\n",
        "506": "   *\n",
        "507": "   * <p><b>Note:</b> the current implementation is not suitable for nested\n",
        "508": "   * concatenated iterators, i.e. the following should be avoided when in a loop:\n",
        "509": "   * {@code iterator = Iterators.concat(iterator, suffix);}, since iteration over the\n",
        "510": "   * resulting iterator has a cubic complexity to the depth of the nesting.\n",
        "511": "   *\n",
        "512": "   * @throws NullPointerException if any of the provided iterators is null\n",
        "513": "   */\n",
        "514": "  public static <T> Iterator<T> concat(Iterator<? extends T>... inputs) {\n",
        "515": "    for (Iterator<? extends T> input : checkNotNull(inputs)) {\n",
        "516": "      checkNotNull(input);\n",
        "517": "    }\n",
        "518": "    return concat(new ConsumingQueueIterator<Iterator<? extends T>>(inputs));\n",
        "519": "  }\n",
        "520": "\n",
        "521": "  /**\n",
        "522": "   * Combines multiple iterators into a single iterator. The returned iterator\n",
        "523": "   * iterates across the elements of each iterator in {@code inputs}. The input\n",
        "524": "   * iterators are not polled until necessary.\n",
        "525": "   *\n",
        "526": "   * <p>The returned iterator supports {@code remove()} when the corresponding\n",
        "527": "   * input iterator supports it. The methods of the returned iterator may throw\n",
        "528": "   * {@code NullPointerException} if any of the input iterators is null.\n",
        "529": "   *\n",
        "530": "   * <p><b>Note:</b> the current implementation is not suitable for nested\n",
        "531": "   * concatenated iterators, i.e. the following should be avoided when in a loop:\n",
        "532": "   * {@code iterator = Iterators.concat(iterator, suffix);}, since iteration over the\n",
        "533": "   * resulting iterator has a cubic complexity to the depth of the nesting.\n",
        "534": "   */\n",
        "535": "  public static <T> Iterator<T> concat(final Iterator<? extends Iterator<? extends T>> inputs) {\n",
        "536": "    checkNotNull(inputs);\n",
        "537": "    return new Iterator<T>() {\n",
        "538": "      Iterator<? extends T> current = emptyIterator();\n",
        "539": "      Iterator<? extends T> removeFrom;\n",
        "540": "\n",
        "541": "      @Override\n",
        "542": "      public boolean hasNext() {\n",
        "543": "        // http://code.google.com/p/google-collections/issues/detail?id=151\n",
        "544": "        // current.hasNext() might be relatively expensive, worth minimizing.\n",
        "545": "        boolean currentHasNext;\n",
        "546": "        // checkNotNull eager for GWT\n",
        "547": "        // note: it must be here & not where 'current' is assigned,\n",
        "548": "        // because otherwise we'll have called inputs.next() before throwing\n",
        "549": "        // the first NPE, and the next time around we'll call inputs.next()\n",
        "550": "        // again, incorrectly moving beyond the error.\n",
        "551": "        while (!(currentHasNext = checkNotNull(current).hasNext()) && inputs.hasNext()) {\n",
        "552": "          current = inputs.next();\n",
        "553": "        }\n",
        "554": "        return currentHasNext;\n",
        "555": "      }\n",
        "556": "\n",
        "557": "      @Override\n",
        "558": "      public T next() {\n",
        "559": "        if (!hasNext()) {\n",
        "560": "          throw new NoSuchElementException();\n",
        "561": "        }\n",
        "562": "        removeFrom = current;\n",
        "563": "        return current.next();\n",
        "564": "      }\n",
        "565": "\n",
        "566": "      @Override\n",
        "567": "      public void remove() {\n",
        "568": "        checkRemove(removeFrom != null);\n",
        "569": "        removeFrom.remove();\n",
        "570": "        removeFrom = null;\n",
        "571": "      }\n",
        "572": "    };\n",
        "573": "  }\n",
        "574": "\n",
        "575": "  /**\n",
        "576": "   * Divides an iterator into unmodifiable sublists of the given size (the final\n",
        "577": "   * list may be smaller). For example, partitioning an iterator containing\n",
        "578": "   * {@code [a, b, c, d, e]} with a partition size of 3 yields {@code\n",
        "579": "   * [[a, b, c], [d, e]]} -- an outer iterator containing two inner lists of\n",
        "580": "   * three and two elements, all in the original order.\n",
        "581": "   *\n",
        "582": "   * <p>The returned lists implement {@link java.util.RandomAccess}.\n",
        "583": "   *\n",
        "584": "   * @param iterator the iterator to return a partitioned view of\n",
        "585": "   * @param size the desired size of each partition (the last may be smaller)\n",
        "586": "   * @return an iterator of immutable lists containing the elements of {@code\n",
        "587": "   *     iterator} divided into partitions\n",
        "588": "   * @throws IllegalArgumentException if {@code size} is nonpositive\n",
        "589": "   */\n",
        "590": "  public static <T> UnmodifiableIterator<List<T>> partition(Iterator<T> iterator, int size) {\n",
        "591": "    return partitionImpl(iterator, size, false);\n",
        "592": "  }\n",
        "593": "\n",
        "594": "  /**\n",
        "595": "   * Divides an iterator into unmodifiable sublists of the given size, padding\n",
        "596": "   * the final iterator with null values if necessary. For example, partitioning\n",
        "597": "   * an iterator containing {@code [a, b, c, d, e]} with a partition size of 3\n",
        "598": "   * yields {@code [[a, b, c], [d, e, null]]} -- an outer iterator containing\n",
        "599": "   * two inner lists of three elements each, all in the original order.\n",
        "600": "   *\n",
        "601": "   * <p>The returned lists implement {@link java.util.RandomAccess}.\n",
        "602": "   *\n",
        "603": "   * @param iterator the iterator to return a partitioned view of\n",
        "604": "   * @param size the desired size of each partition\n",
        "605": "   * @return an iterator of immutable lists containing the elements of {@code\n",
        "606": "   *     iterator} divided into partitions (the final iterable may have\n",
        "607": "   *     trailing null elements)\n",
        "608": "   * @throws IllegalArgumentException if {@code size} is nonpositive\n",
        "609": "   */\n",
        "610": "  public static <T> UnmodifiableIterator<List<T>> paddedPartition(Iterator<T> iterator, int size) {\n",
        "611": "    return partitionImpl(iterator, size, true);\n",
        "612": "  }\n",
        "613": "\n",
        "614": "  private static <T> UnmodifiableIterator<List<T>> partitionImpl(\n",
        "615": "      final Iterator<T> iterator, final int size, final boolean pad) {\n",
        "616": "    checkNotNull(iterator);\n",
        "617": "    checkArgument(size > 0);\n",
        "618": "    return new UnmodifiableIterator<List<T>>() {\n",
        "619": "      @Override\n",
        "620": "      public boolean hasNext() {\n",
        "621": "        return iterator.hasNext();\n",
        "622": "      }\n",
        "623": "\n",
        "624": "      @Override\n",
        "625": "      public List<T> next() {\n",
        "626": "        if (!hasNext()) {\n",
        "627": "          throw new NoSuchElementException();\n",
        "628": "        }\n",
        "629": "        Object[] array = new Object[size];\n",
        "630": "        int count = 0;\n",
        "631": "        for (; count < size && iterator.hasNext(); count++) {\n",
        "632": "          array[count] = iterator.next();\n",
        "633": "        }\n",
        "634": "        for (int i = count; i < size; i++) {\n",
        "635": "          array[i] = null; // for GWT\n",
        "636": "        }\n",
        "637": "\n",
        "638": "        @SuppressWarnings(\"unchecked\") // we only put Ts in it\n",
        "639": "        List<T> list = Collections.unmodifiableList((List<T>) Arrays.asList(array));\n",
        "640": "        return (pad || count == size) ? list : list.subList(0, count);\n",
        "641": "      }\n",
        "642": "    };\n",
        "643": "  }\n",
        "644": "\n",
        "645": "  /**\n",
        "646": "   * Returns the elements of {@code unfiltered} that satisfy the input predicate\n",
        "647": "   * {@code retainIfTrue}.\n",
        "648": "   */\n",
        "649": "  @CheckReturnValue\n",
        "650": "  public static <T> UnmodifiableIterator<T> filter(\n",
        "651": "      final Iterator<T> unfiltered, final Predicate<? super T> retainIfTrue) {\n",
        "652": "    checkNotNull(unfiltered);\n",
        "653": "    checkNotNull(retainIfTrue);\n",
        "654": "    return new AbstractIterator<T>() {\n",
        "655": "      @Override\n",
        "656": "      protected T computeNext() {\n",
        "657": "        while (unfiltered.hasNext()) {\n",
        "658": "          T element = unfiltered.next();\n",
        "659": "          if (retainIfTrue.apply(element)) {\n",
        "660": "            return element;\n",
        "661": "          }\n",
        "662": "        }\n",
        "663": "        return endOfData();\n",
        "664": "      }\n",
        "665": "    };\n",
        "666": "  }\n",
        "667": "\n",
        "668": "  /**\n",
        "669": "   * Returns {@code true} if one or more elements returned by {@code iterator}\n",
        "670": "   * satisfy the given predicate.\n",
        "671": "   */\n",
        "672": "  public static <T> boolean any(Iterator<T> iterator, Predicate<? super T> predicate) {\n",
        "673": "    return indexOf(iterator, predicate) != -1;\n",
        "674": "  }\n",
        "675": "\n",
        "676": "  /**\n",
        "677": "   * Returns {@code true} if every element returned by {@code iterator}\n",
        "678": "   * satisfies the given predicate. If {@code iterator} is empty, {@code true}\n",
        "679": "   * is returned.\n",
        "680": "   */\n",
        "681": "  public static <T> boolean all(Iterator<T> iterator, Predicate<? super T> predicate) {\n",
        "682": "    checkNotNull(predicate);\n",
        "683": "    while (iterator.hasNext()) {\n",
        "684": "      T element = iterator.next();\n",
        "685": "      if (!predicate.apply(element)) {\n",
        "686": "        return false;\n",
        "687": "      }\n",
        "688": "    }\n",
        "689": "    return true;\n",
        "690": "  }\n",
        "691": "\n",
        "692": "  /**\n",
        "693": "   * Returns the first element in {@code iterator} that satisfies the given\n",
        "694": "   * predicate; use this method only when such an element is known to exist. If\n",
        "695": "   * no such element is found, the iterator will be left exhausted: its {@code\n",
        "696": "   * hasNext()} method will return {@code false}. If it is possible that\n",
        "697": "   * <i>no</i> element will match, use {@link #tryFind} or {@link\n",
        "698": "   * #find(Iterator, Predicate, Object)} instead.\n",
        "699": "   *\n",
        "700": "   * @throws NoSuchElementException if no element in {@code iterator} matches\n",
        "701": "   *     the given predicate\n",
        "702": "   */\n",
        "703": "  public static <T> T find(Iterator<T> iterator, Predicate<? super T> predicate) {\n",
        "704": "    return filter(iterator, predicate).next();\n",
        "705": "  }\n",
        "706": "\n",
        "707": "  /**\n",
        "708": "   * Returns the first element in {@code iterator} that satisfies the given\n",
        "709": "   * predicate. If no such element is found, {@code defaultValue} will be\n",
        "710": "   * returned from this method and the iterator will be left exhausted: its\n",
        "711": "   * {@code hasNext()} method will return {@code false}. Note that this can\n",
        "712": "   * usually be handled more naturally using {@code\n",
        "713": "   * tryFind(iterator, predicate).or(defaultValue)}.\n",
        "714": "   *\n",
        "715": "   * @since 7.0\n",
        "716": "   */\n",
        "717": "  @Nullable\n",
        "718": "  public static <T> T find(\n",
        "719": "      Iterator<? extends T> iterator, Predicate<? super T> predicate, @Nullable T defaultValue) {\n",
        "720": "    return getNext(filter(iterator, predicate), defaultValue);\n",
        "721": "  }\n",
        "722": "\n",
        "723": "  /**\n",
        "724": "   * Returns an {@link Optional} containing the first element in {@code\n",
        "725": "   * iterator} that satisfies the given predicate, if such an element exists. If\n",
        "726": "   * no such element is found, an empty {@link Optional} will be returned from\n",
        "727": "   * this method and the iterator will be left exhausted: its {@code\n",
        "728": "   * hasNext()} method will return {@code false}.\n",
        "729": "   *\n",
        "730": "   * <p><b>Warning:</b> avoid using a {@code predicate} that matches {@code\n",
        "731": "   * null}. If {@code null} is matched in {@code iterator}, a\n",
        "732": "   * NullPointerException will be thrown.\n",
        "733": "   *\n",
        "734": "   * @since 11.0\n",
        "735": "   */\n",
        "736": "  public static <T> Optional<T> tryFind(Iterator<T> iterator, Predicate<? super T> predicate) {\n",
        "737": "    UnmodifiableIterator<T> filteredIterator = filter(iterator, predicate);\n",
        "738": "    return filteredIterator.hasNext()\n",
        "739": "        ? Optional.of(filteredIterator.next())\n",
        "740": "        : Optional.<T>absent();\n",
        "741": "  }\n",
        "742": "\n",
        "743": "  /**\n",
        "744": "   * Returns the index in {@code iterator} of the first element that satisfies\n",
        "745": "   * the provided {@code predicate}, or {@code -1} if the Iterator has no such\n",
        "746": "   * elements.\n",
        "747": "   *\n",
        "748": "   * <p>More formally, returns the lowest index {@code i} such that\n",
        "749": "   * {@code predicate.apply(Iterators.get(iterator, i))} returns {@code true},\n",
        "750": "   * or {@code -1} if there is no such index.\n",
        "751": "   *\n",
        "752": "   * <p>If -1 is returned, the iterator will be left exhausted: its\n",
        "753": "   * {@code hasNext()} method will return {@code false}.  Otherwise,\n",
        "754": "   * the iterator will be set to the element which satisfies the\n",
        "755": "   * {@code predicate}.\n",
        "756": "   *\n",
        "757": "   * @since 2.0\n",
        "758": "   */\n",
        "759": "  public static <T> int indexOf(Iterator<T> iterator, Predicate<? super T> predicate) {\n",
        "760": "    checkNotNull(predicate, \"predicate\");\n",
        "761": "    for (int i = 0; iterator.hasNext(); i++) {\n",
        "762": "      T current = iterator.next();\n",
        "763": "      if (predicate.apply(current)) {\n",
        "764": "        return i;\n",
        "765": "      }\n",
        "766": "    }\n",
        "767": "    return -1;\n",
        "768": "  }\n",
        "769": "\n",
        "770": "  /**\n",
        "771": "   * Returns an iterator that applies {@code function} to each element of {@code\n",
        "772": "   * fromIterator}.\n",
        "773": "   *\n",
        "774": "   * <p>The returned iterator supports {@code remove()} if the provided iterator\n",
        "775": "   * does. After a successful {@code remove()} call, {@code fromIterator} no\n",
        "776": "   * longer contains the corresponding element.\n",
        "777": "   */\n",
        "778": "  public static <F, T> Iterator<T> transform(\n",
        "779": "      final Iterator<F> fromIterator, final Function<? super F, ? extends T> function) {\n",
        "780": "    checkNotNull(function);\n",
        "781": "    return new TransformedIterator<F, T>(fromIterator) {\n",
        "782": "      @Override\n",
        "783": "      T transform(F from) {\n",
        "784": "        return function.apply(from);\n",
        "785": "      }\n",
        "786": "    };\n",
        "787": "  }\n",
        "788": "\n",
        "789": "  /**\n",
        "790": "   * Advances {@code iterator} {@code position + 1} times, returning the\n",
        "791": "   * element at the {@code position}th position.\n",
        "792": "   *\n",
        "793": "   * @param position position of the element to return\n",
        "794": "   * @return the element at the specified position in {@code iterator}\n",
        "795": "   * @throws IndexOutOfBoundsException if {@code position} is negative or\n",
        "796": "   *     greater than or equal to the number of elements remaining in\n",
        "797": "   *     {@code iterator}\n",
        "798": "   */\n",
        "799": "  public static <T> T get(Iterator<T> iterator, int position) {\n",
        "800": "    checkNonnegative(position);\n",
        "801": "    int skipped = advance(iterator, position);\n",
        "802": "    if (!iterator.hasNext()) {\n",
        "803": "      throw new IndexOutOfBoundsException(\n",
        "804": "          \"position (\"\n",
        "805": "              + position\n",
        "806": "              + \") must be less than the number of elements that remained (\"\n",
        "807": "              + skipped\n",
        "808": "              + \")\");\n",
        "809": "    }\n",
        "810": "    return iterator.next();\n",
        "811": "  }\n",
        "812": "\n",
        "813": "  static void checkNonnegative(int position) {\n",
        "814": "    if (position < 0) {\n",
        "815": "      throw new IndexOutOfBoundsException(\"position (\" + position + \") must not be negative\");\n",
        "816": "    }\n",
        "817": "  }\n",
        "818": "\n",
        "819": "  /**\n",
        "820": "   * Advances {@code iterator} {@code position + 1} times, returning the\n",
        "821": "   * element at the {@code position}th position or {@code defaultValue}\n",
        "822": "   * otherwise.\n",
        "823": "   *\n",
        "824": "   * @param position position of the element to return\n",
        "825": "   * @param defaultValue the default value to return if the iterator is empty\n",
        "826": "   *     or if {@code position} is greater than the number of elements\n",
        "827": "   *     remaining in {@code iterator}\n",
        "828": "   * @return the element at the specified position in {@code iterator} or\n",
        "829": "   *     {@code defaultValue} if {@code iterator} produces fewer than\n",
        "830": "   *     {@code position + 1} elements.\n",
        "831": "   * @throws IndexOutOfBoundsException if {@code position} is negative\n",
        "832": "   * @since 4.0\n",
        "833": "   */\n",
        "834": "  @Nullable\n",
        "835": "  public static <T> T get(Iterator<? extends T> iterator, int position, @Nullable T defaultValue) {\n",
        "836": "    checkNonnegative(position);\n",
        "837": "    advance(iterator, position);\n",
        "838": "    return getNext(iterator, defaultValue);\n",
        "839": "  }\n",
        "840": "\n",
        "841": "  /**\n",
        "842": "   * Returns the next element in {@code iterator} or {@code defaultValue} if\n",
        "843": "   * the iterator is empty.  The {@link Iterables} analog to this method is\n",
        "844": "   * {@link Iterables#getFirst}.\n",
        "845": "   *\n",
        "846": "   * @param defaultValue the default value to return if the iterator is empty\n",
        "847": "   * @return the next element of {@code iterator} or the default value\n",
        "848": "   * @since 7.0\n",
        "849": "   */\n",
        "850": "  @Nullable\n",
        "851": "  public static <T> T getNext(Iterator<? extends T> iterator, @Nullable T defaultValue) {\n",
        "852": "    return iterator.hasNext() ? iterator.next() : defaultValue;\n",
        "853": "  }\n",
        "854": "\n",
        "855": "  /**\n",
        "856": "   * Advances {@code iterator} to the end, returning the last element.\n",
        "857": "   *\n",
        "858": "   * @return the last element of {@code iterator}\n",
        "859": "   * @throws NoSuchElementException if the iterator is empty\n",
        "860": "   */\n",
        "861": "  public static <T> T getLast(Iterator<T> iterator) {\n",
        "862": "    while (true) {\n",
        "863": "      T current = iterator.next();\n",
        "864": "      if (!iterator.hasNext()) {\n",
        "865": "        return current;\n",
        "866": "      }\n",
        "867": "    }\n",
        "868": "  }\n",
        "869": "\n",
        "870": "  /**\n",
        "871": "   * Advances {@code iterator} to the end, returning the last element or\n",
        "872": "   * {@code defaultValue} if the iterator is empty.\n",
        "873": "   *\n",
        "874": "   * @param defaultValue the default value to return if the iterator is empty\n",
        "875": "   * @return the last element of {@code iterator}\n",
        "876": "   * @since 3.0\n",
        "877": "   */\n",
        "878": "  @Nullable\n",
        "879": "  public static <T> T getLast(Iterator<? extends T> iterator, @Nullable T defaultValue) {\n",
        "880": "    return iterator.hasNext() ? getLast(iterator) : defaultValue;\n",
        "881": "  }\n",
        "882": "\n",
        "883": "  /**\n",
        "884": "   * Calls {@code next()} on {@code iterator}, either {@code numberToAdvance} times\n",
        "885": "   * or until {@code hasNext()} returns {@code false}, whichever comes first.\n",
        "886": "   *\n",
        "887": "   * @return the number of elements the iterator was advanced\n",
        "888": "   * @since 13.0 (since 3.0 as {@code Iterators.skip})\n",
        "889": "   */\n",
        "890": "  public static int advance(Iterator<?> iterator, int numberToAdvance) {\n",
        "891": "    checkNotNull(iterator);\n",
        "892": "    checkArgument(numberToAdvance >= 0, \"numberToAdvance must be nonnegative\");\n",
        "893": "\n",
        "894": "    int i;\n",
        "895": "    for (i = 0; i < numberToAdvance && iterator.hasNext(); i++) {\n",
        "896": "      iterator.next();\n",
        "897": "    }\n",
        "898": "    return i;\n",
        "899": "  }\n",
        "900": "\n",
        "901": "  /**\n",
        "902": "   * Creates an iterator returning the first {@code limitSize} elements of the\n",
        "903": "   * given iterator. If the original iterator does not contain that many\n",
        "904": "   * elements, the returned iterator will have the same behavior as the original\n",
        "905": "   * iterator. The returned iterator supports {@code remove()} if the original\n",
        "906": "   * iterator does.\n",
        "907": "   *\n",
        "908": "   * @param iterator the iterator to limit\n",
        "909": "   * @param limitSize the maximum number of elements in the returned iterator\n",
        "910": "   * @throws IllegalArgumentException if {@code limitSize} is negative\n",
        "911": "   * @since 3.0\n",
        "912": "   */\n",
        "913": "  public static <T> Iterator<T> limit(final Iterator<T> iterator, final int limitSize) {\n",
        "914": "    checkNotNull(iterator);\n",
        "915": "    checkArgument(limitSize >= 0, \"limit is negative\");\n",
        "916": "    return new Iterator<T>() {\n",
        "917": "      private int count;\n",
        "918": "\n",
        "919": "      @Override\n",
        "920": "      public boolean hasNext() {\n",
        "921": "        return count < limitSize && iterator.hasNext();\n",
        "922": "      }\n",
        "923": "\n",
        "924": "      @Override\n",
        "925": "      public T next() {\n",
        "926": "        if (!hasNext()) {\n",
        "927": "          throw new NoSuchElementException();\n",
        "928": "        }\n",
        "929": "        count++;\n",
        "930": "        return iterator.next();\n",
        "931": "      }\n",
        "932": "\n",
        "933": "      @Override\n",
        "934": "      public void remove() {\n",
        "935": "        iterator.remove();\n",
        "936": "      }\n",
        "937": "    };\n",
        "938": "  }\n",
        "939": "\n",
        "940": "  /**\n",
        "941": "   * Returns a view of the supplied {@code iterator} that removes each element\n",
        "942": "   * from the supplied {@code iterator} as it is returned.\n",
        "943": "   *\n",
        "944": "   * <p>The provided iterator must support {@link Iterator#remove()} or\n",
        "945": "   * else the returned iterator will fail on the first call to {@code\n",
        "946": "   * next}.\n",
        "947": "   *\n",
        "948": "   * @param iterator the iterator to remove and return elements from\n",
        "949": "   * @return an iterator that removes and returns elements from the\n",
        "950": "   *     supplied iterator\n",
        "951": "   * @since 2.0\n",
        "952": "   */\n",
        "953": "  public static <T> Iterator<T> consumingIterator(final Iterator<T> iterator) {\n",
        "954": "    checkNotNull(iterator);\n",
        "955": "    return new UnmodifiableIterator<T>() {\n",
        "956": "      @Override\n",
        "957": "      public boolean hasNext() {\n",
        "958": "        return iterator.hasNext();\n",
        "959": "      }\n",
        "960": "\n",
        "961": "      @Override\n",
        "962": "      public T next() {\n",
        "963": "        T next = iterator.next();\n",
        "964": "        iterator.remove();\n",
        "965": "        return next;\n",
        "966": "      }\n",
        "967": "\n",
        "968": "      @Override\n",
        "969": "      public String toString() {\n",
        "970": "        return \"Iterators.consumingIterator(...)\";\n",
        "971": "      }\n",
        "972": "    };\n",
        "973": "  }\n",
        "974": "\n",
        "975": "  /**\n",
        "976": "   * Deletes and returns the next value from the iterator, or returns\n",
        "977": "   * {@code null} if there is no such value.\n",
        "978": "   */\n",
        "979": "  @Nullable\n",
        "980": "  static <T> T pollNext(Iterator<T> iterator) {\n",
        "981": "    if (iterator.hasNext()) {\n",
        "982": "      T result = iterator.next();\n",
        "983": "      iterator.remove();\n",
        "984": "      return result;\n",
        "985": "    } else {\n",
        "986": "      return null;\n",
        "987": "    }\n",
        "988": "  }\n",
        "989": "\n",
        "990": "  // Methods only in Iterators, not in Iterables\n",
        "991": "\n",
        "992": "  /**\n",
        "993": "   * Clears the iterator using its remove method.\n",
        "994": "   */\n",
        "995": "  static void clear(Iterator<?> iterator) {\n",
        "996": "    checkNotNull(iterator);\n",
        "997": "    while (iterator.hasNext()) {\n",
        "998": "      iterator.next();\n",
        "999": "      iterator.remove();\n",
        "1000": "    }\n",
        "1001": "  }\n",
        "1002": "\n",
        "1003": "  /**\n",
        "1004": "   * Returns an iterator containing the elements of {@code array} in order. The\n",
        "1005": "   * returned iterator is a view of the array; subsequent changes to the array\n",
        "1006": "   * will be reflected in the iterator.\n",
        "1007": "   *\n",
        "1008": "   * <p><b>Note:</b> It is often preferable to represent your data using a\n",
        "1009": "   * collection type, for example using {@link Arrays#asList(Object[])}, making\n",
        "1010": "   * this method unnecessary.\n",
        "1011": "   *\n",
        "1012": "   * <p>The {@code Iterable} equivalent of this method is either {@link\n",
        "1013": "   * Arrays#asList(Object[])}, {@link ImmutableList#copyOf(Object[])}},\n",
        "1014": "   * or {@link ImmutableList#of}.\n",
        "1015": "   */\n",
        "1016": "  public static <T> UnmodifiableIterator<T> forArray(final T... array) {\n",
        "1017": "    return forArray(array, 0, array.length, 0);\n",
        "1018": "  }\n",
        "1019": "\n",
        "1020": "  /**\n",
        "1021": "   * Returns a list iterator containing the elements in the specified range of\n",
        "1022": "   * {@code array} in order, starting at the specified index.\n",
        "1023": "   *\n",
        "1024": "   * <p>The {@code Iterable} equivalent of this method is {@code\n",
        "1025": "   * Arrays.asList(array).subList(offset, offset + length).listIterator(index)}.\n",
        "1026": "   */\n",
        "1027": "  static <T> UnmodifiableListIterator<T> forArray(\n",
        "1028": "      final T[] array, final int offset, int length, int index) {\n",
        "1029": "    checkArgument(length >= 0);\n",
        "1030": "    int end = offset + length;\n",
        "1031": "\n",
        "1032": "    // Technically we should give a slightly more descriptive error on overflow\n",
        "1033": "    Preconditions.checkPositionIndexes(offset, end, array.length);\n",
        "1034": "    Preconditions.checkPositionIndex(index, length);\n",
        "1035": "    if (length == 0) {\n",
        "1036": "      return emptyListIterator();\n",
        "1037": "    }\n",
        "1038": "\n",
        "1039": "    /*\n",
        "1040": "     * We can't use call the two-arg constructor with arguments (offset, end)\n",
        "1041": "     * because the returned Iterator is a ListIterator that may be moved back\n",
        "1042": "     * past the beginning of the iteration.\n",
        "1043": "     */\n",
        "1044": "    return new AbstractIndexedListIterator<T>(length, index) {\n",
        "1045": "      @Override\n",
        "1046": "      protected T get(int index) {\n",
        "1047": "        return array[offset + index];\n",
        "1048": "      }\n",
        "1049": "    };\n",
        "1050": "  }\n",
        "1051": "\n",
        "1052": "  /**\n",
        "1053": "   * Returns an iterator containing only {@code value}.\n",
        "1054": "   *\n",
        "1055": "   * <p>The {@link Iterable} equivalent of this method is {@link\n",
        "1056": "   * Collections#singleton}.\n",
        "1057": "   */\n",
        "1058": "  public static <T> UnmodifiableIterator<T> singletonIterator(@Nullable final T value) {\n",
        "1059": "    return new UnmodifiableIterator<T>() {\n",
        "1060": "      boolean done;\n",
        "1061": "\n",
        "1062": "      @Override\n",
        "1063": "      public boolean hasNext() {\n",
        "1064": "        return !done;\n",
        "1065": "      }\n",
        "1066": "\n",
        "1067": "      @Override\n",
        "1068": "      public T next() {\n",
        "1069": "        if (done) {\n",
        "1070": "          throw new NoSuchElementException();\n",
        "1071": "        }\n",
        "1072": "        done = true;\n",
        "1073": "        return value;\n",
        "1074": "      }\n",
        "1075": "    };\n",
        "1076": "  }\n",
        "1077": "\n",
        "1078": "  /**\n",
        "1079": "   * Adapts an {@code Enumeration} to the {@code Iterator} interface.\n",
        "1080": "   *\n",
        "1081": "   * <p>This method has no equivalent in {@link Iterables} because viewing an\n",
        "1082": "   * {@code Enumeration} as an {@code Iterable} is impossible. However, the\n",
        "1083": "   * contents can be <i>copied</i> into a collection using {@link\n",
        "1084": "   * Collections#list}.\n",
        "1085": "   */\n",
        "1086": "  public static <T> UnmodifiableIterator<T> forEnumeration(final Enumeration<T> enumeration) {\n",
        "1087": "    checkNotNull(enumeration);\n",
        "1088": "    return new UnmodifiableIterator<T>() {\n",
        "1089": "      @Override\n",
        "1090": "      public boolean hasNext() {\n",
        "1091": "        return enumeration.hasMoreElements();\n",
        "1092": "      }\n",
        "1093": "\n",
        "1094": "      @Override\n",
        "1095": "      public T next() {\n",
        "1096": "        return enumeration.nextElement();\n",
        "1097": "      }\n",
        "1098": "    };\n",
        "1099": "  }\n",
        "1100": "\n",
        "1101": "  /**\n",
        "1102": "   * Adapts an {@code Iterator} to the {@code Enumeration} interface.\n",
        "1103": "   *\n",
        "1104": "   * <p>The {@code Iterable} equivalent of this method is either {@link\n",
        "1105": "   * Collections#enumeration} (if you have a {@link Collection}), or\n",
        "1106": "   * {@code Iterators.asEnumeration(collection.iterator())}.\n",
        "1107": "   */\n",
        "1108": "  public static <T> Enumeration<T> asEnumeration(final Iterator<T> iterator) {\n",
        "1109": "    checkNotNull(iterator);\n",
        "1110": "    return new Enumeration<T>() {\n",
        "1111": "      @Override\n",
        "1112": "      public boolean hasMoreElements() {\n",
        "1113": "        return iterator.hasNext();\n",
        "1114": "      }\n",
        "1115": "\n",
        "1116": "      @Override\n",
        "1117": "      public T nextElement() {\n",
        "1118": "        return iterator.next();\n",
        "1119": "      }\n",
        "1120": "    };\n",
        "1121": "  }\n",
        "1122": "\n",
        "1123": "  /**\n",
        "1124": "   * Implementation of PeekingIterator that avoids peeking unless necessary.\n",
        "1125": "   */\n",
        "1126": "  private static class PeekingImpl<E> implements PeekingIterator<E> {\n",
        "1127": "\n",
        "1128": "    private final Iterator<? extends E> iterator;\n",
        "1129": "    private boolean hasPeeked;\n",
        "1130": "    private E peekedElement;\n",
        "1131": "\n",
        "1132": "    public PeekingImpl(Iterator<? extends E> iterator) {\n",
        "1133": "      this.iterator = checkNotNull(iterator);\n",
        "1134": "    }\n",
        "1135": "\n",
        "1136": "    @Override\n",
        "1137": "    public boolean hasNext() {\n",
        "1138": "      return hasPeeked || iterator.hasNext();\n",
        "1139": "    }\n",
        "1140": "\n",
        "1141": "    @Override\n",
        "1142": "    public E next() {\n",
        "1143": "      if (!hasPeeked) {\n",
        "1144": "        return iterator.next();\n",
        "1145": "      }\n",
        "1146": "      E result = peekedElement;\n",
        "1147": "      hasPeeked = false;\n",
        "1148": "      peekedElement = null;\n",
        "1149": "      return result;\n",
        "1150": "    }\n",
        "1151": "\n",
        "1152": "    @Override\n",
        "1153": "    public void remove() {\n",
        "1154": "      checkState(!hasPeeked, \"Can't remove after you've peeked at next\");\n",
        "1155": "      iterator.remove();\n",
        "1156": "    }\n",
        "1157": "\n",
        "1158": "    @Override\n",
        "1159": "    public E peek() {\n",
        "1160": "      if (!hasPeeked) {\n",
        "1161": "        peekedElement = iterator.next();\n",
        "1162": "        hasPeeked = true;\n",
        "1163": "      }\n",
        "1164": "      return peekedElement;\n",
        "1165": "    }\n",
        "1166": "  }\n",
        "1167": "\n",
        "1168": "  /**\n",
        "1169": "   * Returns a {@code PeekingIterator} backed by the given iterator.\n",
        "1170": "   *\n",
        "1171": "   * <p>Calls to the {@code peek} method with no intervening calls to {@code\n",
        "1172": "   * next} do not affect the iteration, and hence return the same object each\n",
        "1173": "   * time. A subsequent call to {@code next} is guaranteed to return the same\n",
        "1174": "   * object again. For example: <pre>   {@code\n",
        "1175": "   *\n",
        "1176": "   *   PeekingIterator<String> peekingIterator =\n",
        "1177": "   *       Iterators.peekingIterator(Iterators.forArray(\"a\", \"b\"));\n",
        "1178": "   *   String a1 = peekingIterator.peek(); // returns \"a\"\n",
        "1179": "   *   String a2 = peekingIterator.peek(); // also returns \"a\"\n",
        "1180": "   *   String a3 = peekingIterator.next(); // also returns \"a\"}</pre>\n",
        "1181": "   *\n",
        "1182": "   * <p>Any structural changes to the underlying iteration (aside from those\n",
        "1183": "   * performed by the iterator's own {@link PeekingIterator#remove()} method)\n",
        "1184": "   * will leave the iterator in an undefined state.\n",
        "1185": "   *\n",
        "1186": "   * <p>The returned iterator does not support removal after peeking, as\n",
        "1187": "   * explained by {@link PeekingIterator#remove()}.\n",
        "1188": "   *\n",
        "1189": "   * <p>Note: If the given iterator is already a {@code PeekingIterator},\n",
        "1190": "   * it <i>might</i> be returned to the caller, although this is neither\n",
        "1191": "   * guaranteed to occur nor required to be consistent.  For example, this\n",
        "1192": "   * method <i>might</i> choose to pass through recognized implementations of\n",
        "1193": "   * {@code PeekingIterator} when the behavior of the implementation is\n",
        "1194": "   * known to meet the contract guaranteed by this method.\n",
        "1195": "   *\n",
        "1196": "   * <p>There is no {@link Iterable} equivalent to this method, so use this\n",
        "1197": "   * method to wrap each individual iterator as it is generated.\n",
        "1198": "   *\n",
        "1199": "   * @param iterator the backing iterator. The {@link PeekingIterator} assumes\n",
        "1200": "   *     ownership of this iterator, so users should cease making direct calls\n",
        "1201": "   *     to it after calling this method.\n",
        "1202": "   * @return a peeking iterator backed by that iterator. Apart from the\n",
        "1203": "   *     additional {@link PeekingIterator#peek()} method, this iterator behaves\n",
        "1204": "   *     exactly the same as {@code iterator}.\n",
        "1205": "   */\n",
        "1206": "  public static <T> PeekingIterator<T> peekingIterator(Iterator<? extends T> iterator) {\n",
        "1207": "    if (iterator instanceof PeekingImpl) {\n",
        "1208": "      // Safe to cast <? extends T> to <T> because PeekingImpl only uses T\n",
        "1209": "      // covariantly (and cannot be subclassed to add non-covariant uses).\n",
        "1210": "      @SuppressWarnings(\"unchecked\")\n",
        "1211": "      PeekingImpl<T> peeking = (PeekingImpl<T>) iterator;\n",
        "1212": "      return peeking;\n",
        "1213": "    }\n",
        "1214": "    return new PeekingImpl<T>(iterator);\n",
        "1215": "  }\n",
        "1216": "\n",
        "1217": "  /**\n",
        "1218": "   * Simply returns its argument.\n",
        "1219": "   *\n",
        "1220": "   * @deprecated no need to use this\n",
        "1221": "   * @since 10.0\n",
        "1222": "   */\n",
        "1223": "  @Deprecated\n",
        "1224": "  public static <T> PeekingIterator<T> peekingIterator(PeekingIterator<T> iterator) {\n",
        "1225": "    return checkNotNull(iterator);\n",
        "1226": "  }\n",
        "1227": "\n",
        "1228": "  /**\n",
        "1229": "   * Returns an iterator over the merged contents of all given\n",
        "1230": "   * {@code iterators}, traversing every element of the input iterators.\n",
        "1231": "   * Equivalent entries will not be de-duplicated.\n",
        "1232": "   *\n",
        "1233": "   * <p>Callers must ensure that the source {@code iterators} are in\n",
        "1234": "   * non-descending order as this method does not sort its input.\n",
        "1235": "   *\n",
        "1236": "   * <p>For any equivalent elements across all {@code iterators}, it is\n",
        "1237": "   * undefined which element is returned first.\n",
        "1238": "   *\n",
        "1239": "   * @since 11.0\n",
        "1240": "   */\n",
        "1241": "  @Beta\n",
        "1242": "  public static <T> UnmodifiableIterator<T> mergeSorted(\n",
        "1243": "      Iterable<? extends Iterator<? extends T>> iterators, Comparator<? super T> comparator) {\n",
        "1244": "    checkNotNull(iterators, \"iterators\");\n",
        "1245": "    checkNotNull(comparator, \"comparator\");\n",
        "1246": "\n",
        "1247": "    return new MergingIterator<T>(iterators, comparator);\n",
        "1248": "  }\n",
        "1249": "\n",
        "1250": "  /**\n",
        "1251": "   * An iterator that performs a lazy N-way merge, calculating the next value\n",
        "1252": "   * each time the iterator is polled. This amortizes the sorting cost over the\n",
        "1253": "   * iteration and requires less memory than sorting all elements at once.\n",
        "1254": "   *\n",
        "1255": "   * <p>Retrieving a single element takes approximately O(log(M)) time, where M\n",
        "1256": "   * is the number of iterators. (Retrieving all elements takes approximately\n",
        "1257": "   * O(N*log(M)) time, where N is the total number of elements.)\n",
        "1258": "   */\n",
        "1259": "  private static class MergingIterator<T> extends UnmodifiableIterator<T> {\n",
        "1260": "    final Queue<PeekingIterator<T>> queue;\n",
        "1261": "\n",
        "1262": "    public MergingIterator(\n",
        "1263": "        Iterable<? extends Iterator<? extends T>> iterators,\n",
        "1264": "        final Comparator<? super T> itemComparator) {\n",
        "1265": "      // A comparator that's used by the heap, allowing the heap\n",
        "1266": "      // to be sorted based on the top of each iterator.\n",
        "1267": "      Comparator<PeekingIterator<T>> heapComparator =\n",
        "1268": "          new Comparator<PeekingIterator<T>>() {\n",
        "1269": "            @Override\n",
        "1270": "            public int compare(PeekingIterator<T> o1, PeekingIterator<T> o2) {\n",
        "1271": "              return itemComparator.compare(o1.peek(), o2.peek());\n",
        "1272": "            }\n",
        "1273": "          };\n",
        "1274": "\n",
        "1275": "      queue = new PriorityQueue<PeekingIterator<T>>(2, heapComparator);\n",
        "1276": "\n",
        "1277": "      for (Iterator<? extends T> iterator : iterators) {\n",
        "1278": "        if (iterator.hasNext()) {\n",
        "1279": "          queue.add(Iterators.peekingIterator(iterator));\n",
        "1280": "        }\n",
        "1281": "      }\n",
        "1282": "    }\n",
        "1283": "\n",
        "1284": "    @Override\n",
        "1285": "    public boolean hasNext() {\n",
        "1286": "      return !queue.isEmpty();\n",
        "1287": "    }\n",
        "1288": "\n",
        "1289": "    @Override\n",
        "1290": "    public T next() {\n",
        "1291": "      PeekingIterator<T> nextIter = queue.remove();\n",
        "1292": "      T next = nextIter.next();\n",
        "1293": "      if (nextIter.hasNext()) {\n",
        "1294": "        queue.add(nextIter);\n",
        "1295": "      }\n",
        "1296": "      return next;\n",
        "1297": "    }\n",
        "1298": "  }\n",
        "1299": "\n",
        "1300": "  /**\n",
        "1301": "   * Used to avoid http://bugs.sun.com/view_bug.do?bug_id=6558557\n",
        "1302": "   */\n",
        "1303": "  static <T> ListIterator<T> cast(Iterator<T> iterator) {\n",
        "1304": "    return (ListIterator<T>) iterator;\n",
        "1305": "  }\n",
        "1306": "}\n"
    }
}