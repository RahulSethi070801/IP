{
    "addition": {},
    "removed": {
        "1": "/*\n",
        "2": " * Copyright (C) 2009 The Guava Authors\n",
        "3": " *\n",
        "4": " * Licensed under the Apache License, Version 2.0 (the \"License\");\n",
        "5": " * you may not use this file except in compliance with the License.\n",
        "6": " * You may obtain a copy of the License at\n",
        "7": " *\n",
        "8": " * http://www.apache.org/licenses/LICENSE-2.0\n",
        "9": " *\n",
        "10": " * Unless required by applicable law or agreed to in writing, software\n",
        "11": " * distributed under the License is distributed on an \"AS IS\" BASIS,\n",
        "12": " * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n",
        "13": " * See the License for the specific language governing permissions and\n",
        "14": " * limitations under the License.\n",
        "15": " */\n",
        "16": "\n",
        "17": "package com.google.common.cache;\n",
        "18": "\n",
        "19": "import static com.google.common.base.Preconditions.checkArgument;\n",
        "20": "import static com.google.common.base.Preconditions.checkNotNull;\n",
        "21": "import static com.google.common.base.Preconditions.checkState;\n",
        "22": "\n",
        "23": "import com.google.common.annotations.GwtCompatible;\n",
        "24": "import com.google.common.base.Ascii;\n",
        "25": "import com.google.common.base.Equivalence;\n",
        "26": "import com.google.common.base.MoreObjects;\n",
        "27": "import com.google.common.base.Supplier;\n",
        "28": "import com.google.common.base.Suppliers;\n",
        "29": "import com.google.common.base.Ticker;\n",
        "30": "import com.google.common.cache.AbstractCache.SimpleStatsCounter;\n",
        "31": "import com.google.common.cache.AbstractCache.StatsCounter;\n",
        "32": "import com.google.common.cache.LocalCache.Strength;\n",
        "33": "\n",
        "34": "import java.util.concurrent.TimeUnit;\n",
        "35": "import java.util.logging.Level;\n",
        "36": "import java.util.logging.Logger;\n",
        "37": "\n",
        "38": "import javax.annotation.CheckReturnValue;\n",
        "39": "\n",
        "40": "/**\n",
        "41": " * <p>A builder of {@link LoadingCache} and {@link Cache} instances having any combination of the\n",
        "42": " * following features:\n",
        "43": " *\n",
        "44": " * <ul>\n",
        "45": " * <li>automatic loading of entries into the cache\n",
        "46": " * <li>least-recently-used eviction when a maximum size is exceeded\n",
        "47": " * <li>time-based expiration of entries, measured since last access or last write\n",
        "48": " * <li>keys automatically wrapped in {@linkplain WeakReference weak} references\n",
        "49": " * <li>values automatically wrapped in {@linkplain WeakReference weak} or\n",
        "50": " *     {@linkplain SoftReference soft} references\n",
        "51": " * <li>notification of evicted (or otherwise removed) entries\n",
        "52": " * <li>accumulation of cache access statistics\n",
        "53": " * </ul>\n",
        "54": " *\n",
        "55": " *\n",
        "56": " * <p>These features are all optional; caches can be created using all or none of them. By default\n",
        "57": " * cache instances created by {@code CacheBuilder} will not perform any type of eviction.\n",
        "58": " *\n",
        "59": " * <p>Usage example: <pre>   {@code\n",
        "60": " *\n",
        "61": " *   LoadingCache<Key, Graph> graphs = CacheBuilder.newBuilder()\n",
        "62": " *       .maximumSize(10000)\n",
        "63": " *       .expireAfterWrite(10, TimeUnit.MINUTES)\n",
        "64": " *       .removalListener(MY_LISTENER)\n",
        "65": " *       .build(\n",
        "66": " *           new CacheLoader<Key, Graph>() {\n",
        "67": " *             public Graph load(Key key) throws AnyException {\n",
        "68": " *               return createExpensiveGraph(key);\n",
        "69": " *             }\n",
        "70": " *           });}</pre>\n",
        "71": " *\n",
        "72": " * <p>Or equivalently, <pre>   {@code\n",
        "73": " *\n",
        "74": " *   // In real life this would come from a command-line flag or config file\n",
        "75": " *   String spec = \"maximumSize=10000,expireAfterWrite=10m\";\n",
        "76": " *\n",
        "77": " *   LoadingCache<Key, Graph> graphs = CacheBuilder.from(spec)\n",
        "78": " *       .removalListener(MY_LISTENER)\n",
        "79": " *       .build(\n",
        "80": " *           new CacheLoader<Key, Graph>() {\n",
        "81": " *             public Graph load(Key key) throws AnyException {\n",
        "82": " *               return createExpensiveGraph(key);\n",
        "83": " *             }\n",
        "84": " *           });}</pre>\n",
        "85": " *\n",
        "86": " * <p>The returned cache is implemented as a hash table with similar performance characteristics to\n",
        "87": " * {@link ConcurrentHashMap}. It implements all optional operations of the {@link LoadingCache} and\n",
        "88": " * {@link Cache} interfaces. The {@code asMap} view (and its collection views) have <i>weakly\n",
        "89": " * consistent iterators</i>. This means that they are safe for concurrent use, but if other threads\n",
        "90": " * modify the cache after the iterator is created, it is undefined which of these changes, if any,\n",
        "91": " * are reflected in that iterator. These iterators never throw {@link\n",
        "92": " * ConcurrentModificationException}.\n",
        "93": " *\n",
        "94": " * <p><b>Note:</b> by default, the returned cache uses equality comparisons (the\n",
        "95": " * {@link Object#equals equals} method) to determine equality for keys or values. However, if\n",
        "96": " * {@link #weakKeys} was specified, the cache uses identity ({@code ==})\n",
        "97": " * comparisons instead for keys. Likewise, if {@link #weakValues} or {@link #softValues} was\n",
        "98": " * specified, the cache uses identity comparisons for values.\n",
        "99": " *\n",
        "100": " * <p>Entries are automatically evicted from the cache when any of\n",
        "101": " * {@linkplain #maximumSize(long) maximumSize}, {@linkplain #maximumWeight(long) maximumWeight},\n",
        "102": " * {@linkplain #expireAfterWrite expireAfterWrite},\n",
        "103": " * {@linkplain #expireAfterAccess expireAfterAccess}, {@linkplain #weakKeys weakKeys},\n",
        "104": " * {@linkplain #weakValues weakValues}, or {@linkplain #softValues softValues} are requested.\n",
        "105": " *\n",
        "106": " * <p>If {@linkplain #maximumSize(long) maximumSize} or\n",
        "107": " * {@linkplain #maximumWeight(long) maximumWeight} is requested entries may be evicted on each cache\n",
        "108": " * modification.\n",
        "109": " *\n",
        "110": " * <p>If {@linkplain #expireAfterWrite expireAfterWrite} or\n",
        "111": " * {@linkplain #expireAfterAccess expireAfterAccess} is requested entries may be evicted on each\n",
        "112": " * cache modification, on occasional cache accesses, or on calls to {@link Cache#cleanUp}. Expired\n",
        "113": " * entries may be counted by {@link Cache#size}, but will never be visible to read or write\n",
        "114": " * operations.\n",
        "115": " *\n",
        "116": " * <p>If {@linkplain #weakKeys weakKeys}, {@linkplain #weakValues weakValues}, or\n",
        "117": " * {@linkplain #softValues softValues} are requested, it is possible for a key or value present in\n",
        "118": " * the cache to be reclaimed by the garbage collector. Entries with reclaimed keys or values may be\n",
        "119": " * removed from the cache on each cache modification, on occasional cache accesses, or on calls to\n",
        "120": " * {@link Cache#cleanUp}; such entries may be counted in {@link Cache#size}, but will never be\n",
        "121": " * visible to read or write operations.\n",
        "122": " *\n",
        "123": " * <p>Certain cache configurations will result in the accrual of periodic maintenance tasks which\n",
        "124": " * will be performed during write operations, or during occasional read operations in the absence of\n",
        "125": " * writes. The {@link Cache#cleanUp} method of the returned cache will also perform maintenance, but\n",
        "126": " * calling it should not be necessary with a high throughput cache. Only caches built with\n",
        "127": " * {@linkplain #removalListener removalListener}, {@linkplain #expireAfterWrite expireAfterWrite},\n",
        "128": " * {@linkplain #expireAfterAccess expireAfterAccess}, {@linkplain #weakKeys weakKeys},\n",
        "129": " * {@linkplain #weakValues weakValues}, or {@linkplain #softValues softValues} perform periodic\n",
        "130": " * maintenance.\n",
        "131": " *\n",
        "132": " * <p>The caches produced by {@code CacheBuilder} are serializable, and the deserialized caches\n",
        "133": " * retain all the configuration properties of the original cache. Note that the serialized form does\n",
        "134": " * <i>not</i> include cache contents, but only configuration.\n",
        "135": " *\n",
        "136": " * <p>See the Guava User Guide article on <a href=\n",
        "137": " * \"https://github.com/google/guava/wiki/CachesExplained\">caching</a> for a higher-level\n",
        "138": " * explanation.\n",
        "139": " *\n",
        "140": " * @param <K> the base key type for all caches created by this builder\n",
        "141": " * @param <V> the base value type for all caches created by this builder\n",
        "142": " * @author Charles Fry\n",
        "143": " * @author Kevin Bourrillion\n",
        "144": " * @since 10.0\n",
        "145": " */\n",
        "146": "@GwtCompatible(emulated = true)\n",
        "147": "public final class CacheBuilder<K, V> {\n",
        "148": "  private static final int DEFAULT_INITIAL_CAPACITY = 16;\n",
        "149": "  private static final int DEFAULT_CONCURRENCY_LEVEL = 4;\n",
        "150": "  private static final int DEFAULT_EXPIRATION_NANOS = 0;\n",
        "151": "  private static final int DEFAULT_REFRESH_NANOS = 0;\n",
        "152": "\n",
        "153": "  static final Supplier<? extends StatsCounter> NULL_STATS_COUNTER = Suppliers.ofInstance(\n",
        "154": "      new StatsCounter() {\n",
        "155": "        @Override\n",
        "156": "        public void recordHits(int count) {}\n",
        "157": "\n",
        "158": "        @Override\n",
        "159": "        public void recordMisses(int count) {}\n",
        "160": "\n",
        "161": "        @Override\n",
        "162": "        public void recordLoadSuccess(long loadTime) {}\n",
        "163": "\n",
        "164": "        @Override\n",
        "165": "        public void recordLoadException(long loadTime) {}\n",
        "166": "\n",
        "167": "        @Override\n",
        "168": "        public void recordEviction() {}\n",
        "169": "\n",
        "170": "        @Override\n",
        "171": "        public CacheStats snapshot() {\n",
        "172": "          return EMPTY_STATS;\n",
        "173": "        }\n",
        "174": "      });\n",
        "175": "  static final CacheStats EMPTY_STATS = new CacheStats(0, 0, 0, 0, 0, 0);\n",
        "176": "\n",
        "177": "  static final Supplier<StatsCounter> CACHE_STATS_COUNTER =\n",
        "178": "      new Supplier<StatsCounter>() {\n",
        "179": "    @Override\n",
        "180": "    public StatsCounter get() {\n",
        "181": "      return new SimpleStatsCounter();\n",
        "182": "    }\n",
        "183": "  };\n",
        "184": "\n",
        "185": "  enum NullListener implements RemovalListener<Object, Object> {\n",
        "186": "    INSTANCE;\n",
        "187": "\n",
        "188": "    @Override\n",
        "189": "    public void onRemoval(RemovalNotification<Object, Object> notification) {}\n",
        "190": "  }\n",
        "191": "\n",
        "192": "  enum OneWeigher implements Weigher<Object, Object> {\n",
        "193": "    INSTANCE;\n",
        "194": "\n",
        "195": "    @Override\n",
        "196": "    public int weigh(Object key, Object value) {\n",
        "197": "      return 1;\n",
        "198": "    }\n",
        "199": "  }\n",
        "200": "\n",
        "201": "  static final Ticker NULL_TICKER = new Ticker() {\n",
        "202": "    @Override\n",
        "203": "    public long read() {\n",
        "204": "      return 0;\n",
        "205": "    }\n",
        "206": "  };\n",
        "207": "\n",
        "208": "  private static final Logger logger = Logger.getLogger(CacheBuilder.class.getName());\n",
        "209": "\n",
        "210": "  static final int UNSET_INT = -1;\n",
        "211": "\n",
        "212": "  boolean strictParsing = true;\n",
        "213": "\n",
        "214": "  int initialCapacity = UNSET_INT;\n",
        "215": "  int concurrencyLevel = UNSET_INT;\n",
        "216": "  long maximumSize = UNSET_INT;\n",
        "217": "  long maximumWeight = UNSET_INT;\n",
        "218": "  Weigher<? super K, ? super V> weigher;\n",
        "219": "\n",
        "220": "  Strength keyStrength;\n",
        "221": "  Strength valueStrength;\n",
        "222": "\n",
        "223": "  long expireAfterWriteNanos = UNSET_INT;\n",
        "224": "  long expireAfterAccessNanos = UNSET_INT;\n",
        "225": "  long refreshNanos = UNSET_INT;\n",
        "226": "\n",
        "227": "  Equivalence<Object> keyEquivalence;\n",
        "228": "  Equivalence<Object> valueEquivalence;\n",
        "229": "\n",
        "230": "  RemovalListener<? super K, ? super V> removalListener;\n",
        "231": "  Ticker ticker;\n",
        "232": "\n",
        "233": "  Supplier<? extends StatsCounter> statsCounterSupplier = NULL_STATS_COUNTER;\n",
        "234": "\n",
        "235": "  // TODO(fry): make constructor private and update tests to use newBuilder\n",
        "236": "  CacheBuilder() {}\n",
        "237": "\n",
        "238": "  /**\n",
        "239": "   * Constructs a new {@code CacheBuilder} instance with default settings, including strong keys,\n",
        "240": "   * strong values, and no automatic eviction of any kind.\n",
        "241": "   */\n",
        "242": "  public static CacheBuilder<Object, Object> newBuilder() {\n",
        "243": "    return new CacheBuilder<Object, Object>();\n",
        "244": "  }\n",
        "245": "\n",
        "246": "  Equivalence<Object> getKeyEquivalence() {\n",
        "247": "    return MoreObjects.firstNonNull(keyEquivalence, getKeyStrength().defaultEquivalence());\n",
        "248": "  }\n",
        "249": "\n",
        "250": "  Equivalence<Object> getValueEquivalence() {\n",
        "251": "    return MoreObjects.firstNonNull(valueEquivalence, getValueStrength().defaultEquivalence());\n",
        "252": "  }\n",
        "253": "\n",
        "254": "  /**\n",
        "255": "   * Sets the minimum total size for the internal hash tables. For example, if the initial capacity\n",
        "256": "   * is {@code 60}, and the concurrency level is {@code 8}, then eight segments are created, each\n",
        "257": "   * having a hash table of size eight. Providing a large enough estimate at construction time\n",
        "258": "   * avoids the need for expensive resizing operations later, but setting this value unnecessarily\n",
        "259": "   * high wastes memory.\n",
        "260": "   *\n",
        "261": "   * @throws IllegalArgumentException if {@code initialCapacity} is negative\n",
        "262": "   * @throws IllegalStateException if an initial capacity was already set\n",
        "263": "   */\n",
        "264": "  public CacheBuilder<K, V> initialCapacity(int initialCapacity) {\n",
        "265": "    checkState(this.initialCapacity == UNSET_INT, \"initial capacity was already set to %s\",\n",
        "266": "        this.initialCapacity);\n",
        "267": "    checkArgument(initialCapacity >= 0);\n",
        "268": "    this.initialCapacity = initialCapacity;\n",
        "269": "    return this;\n",
        "270": "  }\n",
        "271": "\n",
        "272": "  int getInitialCapacity() {\n",
        "273": "    return (initialCapacity == UNSET_INT) ? DEFAULT_INITIAL_CAPACITY : initialCapacity;\n",
        "274": "  }\n",
        "275": "\n",
        "276": "  /**\n",
        "277": "   * Guides the allowed concurrency among update operations. Used as a hint for internal sizing. The\n",
        "278": "   * table is internally partitioned to try to permit the indicated number of concurrent updates\n",
        "279": "   * without contention. Because assignment of entries to these partitions is not necessarily\n",
        "280": "   * uniform, the actual concurrency observed may vary. Ideally, you should choose a value to\n",
        "281": "   * accommodate as many threads as will ever concurrently modify the table. Using a significantly\n",
        "282": "   * higher value than you need can waste space and time, and a significantly lower value can lead\n",
        "283": "   * to thread contention. But overestimates and underestimates within an order of magnitude do not\n",
        "284": "   * usually have much noticeable impact. A value of one permits only one thread to modify the cache\n",
        "285": "   * at a time, but since read operations and cache loading computations can proceed concurrently,\n",
        "286": "   * this still yields higher concurrency than full synchronization.\n",
        "287": "   *\n",
        "288": "   * <p> Defaults to 4. <b>Note:</b>The default may change in the future. If you care about this\n",
        "289": "   * value, you should always choose it explicitly.\n",
        "290": "   *\n",
        "291": "   * <p>The current implementation uses the concurrency level to create a fixed number of hashtable\n",
        "292": "   * segments, each governed by its own write lock. The segment lock is taken once for each explicit\n",
        "293": "   * write, and twice for each cache loading computation (once prior to loading the new value,\n",
        "294": "   * and once after loading completes). Much internal cache management is performed at the segment\n",
        "295": "   * granularity. For example, access queues and write queues are kept per segment when they are\n",
        "296": "   * required by the selected eviction algorithm. As such, when writing unit tests it is not\n",
        "297": "   * uncommon to specify {@code concurrencyLevel(1)} in order to achieve more deterministic eviction\n",
        "298": "   * behavior.\n",
        "299": "   *\n",
        "300": "   * <p>Note that future implementations may abandon segment locking in favor of more advanced\n",
        "301": "   * concurrency controls.\n",
        "302": "   *\n",
        "303": "   * @throws IllegalArgumentException if {@code concurrencyLevel} is nonpositive\n",
        "304": "   * @throws IllegalStateException if a concurrency level was already set\n",
        "305": "   */\n",
        "306": "  public CacheBuilder<K, V> concurrencyLevel(int concurrencyLevel) {\n",
        "307": "    checkState(this.concurrencyLevel == UNSET_INT, \"concurrency level was already set to %s\",\n",
        "308": "        this.concurrencyLevel);\n",
        "309": "    checkArgument(concurrencyLevel > 0);\n",
        "310": "    this.concurrencyLevel = concurrencyLevel;\n",
        "311": "    return this;\n",
        "312": "  }\n",
        "313": "\n",
        "314": "  int getConcurrencyLevel() {\n",
        "315": "    return (concurrencyLevel == UNSET_INT) ? DEFAULT_CONCURRENCY_LEVEL : concurrencyLevel;\n",
        "316": "  }\n",
        "317": "\n",
        "318": "  /**\n",
        "319": "   * Specifies the maximum number of entries the cache may contain. Note that the cache <b>may evict\n",
        "320": "   * an entry before this limit is exceeded</b>. As the cache size grows close to the maximum, the\n",
        "321": "   * cache evicts entries that are less likely to be used again. For example, the cache may evict an\n",
        "322": "   * entry because it hasn't been used recently or very often.\n",
        "323": "   *\n",
        "324": "   * <p>When {@code size} is zero, elements will be evicted immediately after being loaded into the\n",
        "325": "   * cache. This can be useful in testing, or to disable caching temporarily without a code change.\n",
        "326": "   *\n",
        "327": "   * <p>This feature cannot be used in conjunction with {@link #maximumWeight}.\n",
        "328": "   *\n",
        "329": "   * @param size the maximum size of the cache\n",
        "330": "   * @throws IllegalArgumentException if {@code size} is negative\n",
        "331": "   * @throws IllegalStateException if a maximum size or weight was already set\n",
        "332": "   */\n",
        "333": "  public CacheBuilder<K, V> maximumSize(long size) {\n",
        "334": "    checkState(this.maximumSize == UNSET_INT, \"maximum size was already set to %s\",\n",
        "335": "        this.maximumSize);\n",
        "336": "    checkState(this.maximumWeight == UNSET_INT, \"maximum weight was already set to %s\",\n",
        "337": "        this.maximumWeight);\n",
        "338": "    checkState(this.weigher == null, \"maximum size can not be combined with weigher\");\n",
        "339": "    checkArgument(size >= 0, \"maximum size must not be negative\");\n",
        "340": "    this.maximumSize = size;\n",
        "341": "    return this;\n",
        "342": "  }\n",
        "343": "\n",
        "344": "  long getMaximumWeight() {\n",
        "345": "    if (expireAfterWriteNanos == 0 || expireAfterAccessNanos == 0) {\n",
        "346": "      return 0;\n",
        "347": "    }\n",
        "348": "    return (weigher == null) ? maximumSize : maximumWeight;\n",
        "349": "  }\n",
        "350": "\n",
        "351": "  // Make a safe contravariant cast now so we don't have to do it over and over.\n",
        "352": "  @SuppressWarnings(\"unchecked\")\n",
        "353": "  <K1 extends K, V1 extends V> Weigher<K1, V1> getWeigher() {\n",
        "354": "    return (Weigher<K1, V1>) MoreObjects.firstNonNull(weigher, OneWeigher.INSTANCE);\n",
        "355": "  }\n",
        "356": "\n",
        "357": "  CacheBuilder<K, V> setKeyStrength(Strength strength) {\n",
        "358": "    checkState(keyStrength == null, \"Key strength was already set to %s\", keyStrength);\n",
        "359": "    keyStrength = checkNotNull(strength);\n",
        "360": "    return this;\n",
        "361": "  }\n",
        "362": "\n",
        "363": "  Strength getKeyStrength() {\n",
        "364": "    return MoreObjects.firstNonNull(keyStrength, Strength.STRONG);\n",
        "365": "  }\n",
        "366": "\n",
        "367": "  CacheBuilder<K, V> setValueStrength(Strength strength) {\n",
        "368": "    checkState(valueStrength == null, \"Value strength was already set to %s\", valueStrength);\n",
        "369": "    valueStrength = checkNotNull(strength);\n",
        "370": "    return this;\n",
        "371": "  }\n",
        "372": "\n",
        "373": "  Strength getValueStrength() {\n",
        "374": "    return MoreObjects.firstNonNull(valueStrength, Strength.STRONG);\n",
        "375": "  }\n",
        "376": "\n",
        "377": "  /**\n",
        "378": "   * Specifies that each entry should be automatically removed from the cache once a fixed duration\n",
        "379": "   * has elapsed after the entry's creation, or the most recent replacement of its value.\n",
        "380": "   *\n",
        "381": "   * <p>When {@code duration} is zero, this method hands off to\n",
        "382": "   * {@link #maximumSize(long) maximumSize}{@code (0)}, ignoring any otherwise-specificed maximum\n",
        "383": "   * size or weight. This can be useful in testing, or to disable caching temporarily without a code\n",
        "384": "   * change.\n",
        "385": "   *\n",
        "386": "   * <p>Expired entries may be counted in {@link Cache#size}, but will never be visible to read or\n",
        "387": "   * write operations. Expired entries are cleaned up as part of the routine maintenance described\n",
        "388": "   * in the class javadoc.\n",
        "389": "   *\n",
        "390": "   * @param duration the length of time after an entry is created that it should be automatically\n",
        "391": "   *     removed\n",
        "392": "   * @param unit the unit that {@code duration} is expressed in\n",
        "393": "   * @throws IllegalArgumentException if {@code duration} is negative\n",
        "394": "   * @throws IllegalStateException if the time to live or time to idle was already set\n",
        "395": "   */\n",
        "396": "  public CacheBuilder<K, V> expireAfterWrite(long duration, TimeUnit unit) {\n",
        "397": "    checkState(expireAfterWriteNanos == UNSET_INT, \"expireAfterWrite was already set to %s ns\",\n",
        "398": "        expireAfterWriteNanos);\n",
        "399": "    checkArgument(duration >= 0, \"duration cannot be negative: %s %s\", duration, unit);\n",
        "400": "    this.expireAfterWriteNanos = unit.toNanos(duration);\n",
        "401": "    return this;\n",
        "402": "  }\n",
        "403": "\n",
        "404": "  long getExpireAfterWriteNanos() {\n",
        "405": "    return (expireAfterWriteNanos == UNSET_INT) ? DEFAULT_EXPIRATION_NANOS : expireAfterWriteNanos;\n",
        "406": "  }\n",
        "407": "\n",
        "408": "  /**\n",
        "409": "   * Specifies that each entry should be automatically removed from the cache once a fixed duration\n",
        "410": "   * has elapsed after the entry's creation, the most recent replacement of its value, or its last\n",
        "411": "   * access. Access time is reset by all cache read and write operations (including\n",
        "412": "   * {@code Cache.asMap().get(Object)} and {@code Cache.asMap().put(K, V)}), but not by operations\n",
        "413": "   * on the collection-views of {@link Cache#asMap}.\n",
        "414": "   *\n",
        "415": "   * <p>When {@code duration} is zero, this method hands off to\n",
        "416": "   * {@link #maximumSize(long) maximumSize}{@code (0)}, ignoring any otherwise-specificed maximum\n",
        "417": "   * size or weight. This can be useful in testing, or to disable caching temporarily without a code\n",
        "418": "   * change.\n",
        "419": "   *\n",
        "420": "   * <p>Expired entries may be counted in {@link Cache#size}, but will never be visible to read or\n",
        "421": "   * write operations. Expired entries are cleaned up as part of the routine maintenance described\n",
        "422": "   * in the class javadoc.\n",
        "423": "   *\n",
        "424": "   * @param duration the length of time after an entry is last accessed that it should be\n",
        "425": "   *     automatically removed\n",
        "426": "   * @param unit the unit that {@code duration} is expressed in\n",
        "427": "   * @throws IllegalArgumentException if {@code duration} is negative\n",
        "428": "   * @throws IllegalStateException if the time to idle or time to live was already set\n",
        "429": "   */\n",
        "430": "  public CacheBuilder<K, V> expireAfterAccess(long duration, TimeUnit unit) {\n",
        "431": "    checkState(expireAfterAccessNanos == UNSET_INT, \"expireAfterAccess was already set to %s ns\",\n",
        "432": "        expireAfterAccessNanos);\n",
        "433": "    checkArgument(duration >= 0, \"duration cannot be negative: %s %s\", duration, unit);\n",
        "434": "    this.expireAfterAccessNanos = unit.toNanos(duration);\n",
        "435": "    return this;\n",
        "436": "  }\n",
        "437": "\n",
        "438": "  long getExpireAfterAccessNanos() {\n",
        "439": "    return (expireAfterAccessNanos == UNSET_INT)\n",
        "440": "        ? DEFAULT_EXPIRATION_NANOS : expireAfterAccessNanos;\n",
        "441": "  }\n",
        "442": "\n",
        "443": "  long getRefreshNanos() {\n",
        "444": "    return (refreshNanos == UNSET_INT) ? DEFAULT_REFRESH_NANOS : refreshNanos;\n",
        "445": "  }\n",
        "446": "\n",
        "447": "  /**\n",
        "448": "   * Specifies a nanosecond-precision time source for this cache. By default,\n",
        "449": "   * {@link System#nanoTime} is used.\n",
        "450": "   *\n",
        "451": "   * <p>The primary intent of this method is to facilitate testing of caches with a fake or mock\n",
        "452": "   * time source.\n",
        "453": "   *\n",
        "454": "   * @throws IllegalStateException if a ticker was already set\n",
        "455": "   */\n",
        "456": "  public CacheBuilder<K, V> ticker(Ticker ticker) {\n",
        "457": "    checkState(this.ticker == null);\n",
        "458": "    this.ticker = checkNotNull(ticker);\n",
        "459": "    return this;\n",
        "460": "  }\n",
        "461": "\n",
        "462": "  Ticker getTicker(boolean recordsTime) {\n",
        "463": "    if (ticker != null) {\n",
        "464": "      return ticker;\n",
        "465": "    }\n",
        "466": "    return recordsTime ? Ticker.systemTicker() : NULL_TICKER;\n",
        "467": "  }\n",
        "468": "\n",
        "469": "  /**\n",
        "470": "   * Specifies a listener instance that caches should notify each time an entry is removed for any\n",
        "471": "   * {@linkplain RemovalCause reason}. Each cache created by this builder will invoke this listener\n",
        "472": "   * as part of the routine maintenance described in the class documentation above.\n",
        "473": "   *\n",
        "474": "   * <p><b>Warning:</b> after invoking this method, do not continue to use <i>this</i> cache\n",
        "475": "   * builder reference; instead use the reference this method <i>returns</i>. At runtime, these\n",
        "476": "   * point to the same instance, but only the returned reference has the correct generic type\n",
        "477": "   * information so as to ensure type safety. For best results, use the standard method-chaining\n",
        "478": "   * idiom illustrated in the class documentation above, configuring a builder and building your\n",
        "479": "   * cache in a single statement. Failure to heed this advice can result in a {@link\n",
        "480": "   * ClassCastException} being thrown by a cache operation at some <i>undefined</i> point in the\n",
        "481": "   * future.\n",
        "482": "   *\n",
        "483": "   * <p><b>Warning:</b> any exception thrown by {@code listener} will <i>not</i> be propagated to\n",
        "484": "   * the {@code Cache} user, only logged via a {@link Logger}.\n",
        "485": "   *\n",
        "486": "   * @return the cache builder reference that should be used instead of {@code this} for any\n",
        "487": "   *     remaining configuration and cache building\n",
        "488": "   * @throws IllegalStateException if a removal listener was already set\n",
        "489": "   */\n",
        "490": "  @CheckReturnValue\n",
        "491": "  public <K1 extends K, V1 extends V> CacheBuilder<K1, V1> removalListener(\n",
        "492": "      RemovalListener<? super K1, ? super V1> listener) {\n",
        "493": "    checkState(this.removalListener == null);\n",
        "494": "\n",
        "495": "    // safely limiting the kinds of caches this can produce\n",
        "496": "    @SuppressWarnings(\"unchecked\")\n",
        "497": "    CacheBuilder<K1, V1> me = (CacheBuilder<K1, V1>) this;\n",
        "498": "    me.removalListener = checkNotNull(listener);\n",
        "499": "    return me;\n",
        "500": "  }\n",
        "501": "\n",
        "502": "  // Make a safe contravariant cast now so we don't have to do it over and over.\n",
        "503": "  @SuppressWarnings(\"unchecked\")\n",
        "504": "  <K1 extends K, V1 extends V> RemovalListener<K1, V1> getRemovalListener() {\n",
        "505": "    return (RemovalListener<K1, V1>)\n",
        "506": "        MoreObjects.firstNonNull(removalListener, NullListener.INSTANCE);\n",
        "507": "  }\n",
        "508": "\n",
        "509": "  /**\n",
        "510": "   * Enable the accumulation of {@link CacheStats} during the operation of the cache. Without this\n",
        "511": "   * {@link Cache#stats} will return zero for all statistics. Note that recording stats requires\n",
        "512": "   * bookkeeping to be performed with each operation, and thus imposes a performance penalty on\n",
        "513": "   * cache operation.\n",
        "514": "   *\n",
        "515": "   * @since 12.0 (previously, stats collection was automatic)\n",
        "516": "   */\n",
        "517": "  public CacheBuilder<K, V> recordStats() {\n",
        "518": "    statsCounterSupplier = CACHE_STATS_COUNTER;\n",
        "519": "    return this;\n",
        "520": "  }\n",
        "521": "\n",
        "522": "  boolean isRecordingStats() {\n",
        "523": "    return statsCounterSupplier == CACHE_STATS_COUNTER;\n",
        "524": "  }\n",
        "525": "\n",
        "526": "  Supplier<? extends StatsCounter> getStatsCounterSupplier() {\n",
        "527": "    return statsCounterSupplier;\n",
        "528": "  }\n",
        "529": "\n",
        "530": "  /**\n",
        "531": "   * Builds a cache, which either returns an already-loaded value for a given key or atomically\n",
        "532": "   * computes or retrieves it using the supplied {@code CacheLoader}. If another thread is currently\n",
        "533": "   * loading the value for this key, simply waits for that thread to finish and returns its\n",
        "534": "   * loaded value. Note that multiple threads can concurrently load values for distinct keys.\n",
        "535": "   *\n",
        "536": "   * <p>This method does not alter the state of this {@code CacheBuilder} instance, so it can be\n",
        "537": "   * invoked again to create multiple independent caches.\n",
        "538": "   *\n",
        "539": "   * @param loader the cache loader used to obtain new values\n",
        "540": "   * @return a cache having the requested features\n",
        "541": "   */\n",
        "542": "  public <K1 extends K, V1 extends V> LoadingCache<K1, V1> build(\n",
        "543": "          CacheLoader<? super K1, V1> loader) {\n",
        "544": "    checkWeightWithWeigher();\n",
        "545": "    return new LocalCache.LocalLoadingCache<K1, V1>(this, loader);\n",
        "546": "  }\n",
        "547": "\n",
        "548": "  /**\n",
        "549": "   * Builds a cache which does not automatically load values when keys are requested.\n",
        "550": "   *\n",
        "551": "   * <p>Consider {@link #build(CacheLoader)} instead, if it is feasible to implement a\n",
        "552": "   * {@code CacheLoader}.\n",
        "553": "   *\n",
        "554": "   * <p>This method does not alter the state of this {@code CacheBuilder} instance, so it can be\n",
        "555": "   * invoked again to create multiple independent caches.\n",
        "556": "   *\n",
        "557": "   * @return a cache having the requested features\n",
        "558": "   * @since 11.0\n",
        "559": "   */\n",
        "560": "  public <K1 extends K, V1 extends V> Cache<K1, V1> build() {\n",
        "561": "    checkWeightWithWeigher();\n",
        "562": "    checkNonLoadingCache();\n",
        "563": "    return new LocalCache.LocalManualCache<K1, V1>(this);\n",
        "564": "  }\n",
        "565": "\n",
        "566": "  private void checkNonLoadingCache() {\n",
        "567": "    checkState(refreshNanos == UNSET_INT, \"refreshAfterWrite requires a LoadingCache\");\n",
        "568": "  }\n",
        "569": "\n",
        "570": "  private void checkWeightWithWeigher() {\n",
        "571": "    if (weigher == null) {\n",
        "572": "      checkState(maximumWeight == UNSET_INT, \"maximumWeight requires weigher\");\n",
        "573": "    } else {\n",
        "574": "      if (strictParsing) {\n",
        "575": "        checkState(maximumWeight != UNSET_INT, \"weigher requires maximumWeight\");\n",
        "576": "      } else {\n",
        "577": "        if (maximumWeight == UNSET_INT) {\n",
        "578": "          logger.log(Level.WARNING, \"ignoring weigher specified without maximumWeight\");\n",
        "579": "        }\n",
        "580": "      }\n",
        "581": "    }\n",
        "582": "  }\n",
        "583": "\n",
        "584": "  /**\n",
        "585": "   * Returns a string representation for this CacheBuilder instance. The exact form of the returned\n",
        "586": "   * string is not specified.\n",
        "587": "   */\n",
        "588": "  @Override\n",
        "589": "  public String toString() {\n",
        "590": "    MoreObjects.ToStringHelper s = MoreObjects.toStringHelper(this);\n",
        "591": "    if (initialCapacity != UNSET_INT) {\n",
        "592": "      s.add(\"initialCapacity\", initialCapacity);\n",
        "593": "    }\n",
        "594": "    if (concurrencyLevel != UNSET_INT) {\n",
        "595": "      s.add(\"concurrencyLevel\", concurrencyLevel);\n",
        "596": "    }\n",
        "597": "    if (maximumSize != UNSET_INT) {\n",
        "598": "      s.add(\"maximumSize\", maximumSize);\n",
        "599": "    }\n",
        "600": "    if (maximumWeight != UNSET_INT) {\n",
        "601": "      s.add(\"maximumWeight\", maximumWeight);\n",
        "602": "    }\n",
        "603": "    if (expireAfterWriteNanos != UNSET_INT) {\n",
        "604": "      s.add(\"expireAfterWrite\", expireAfterWriteNanos + \"ns\");\n",
        "605": "    }\n",
        "606": "    if (expireAfterAccessNanos != UNSET_INT) {\n",
        "607": "      s.add(\"expireAfterAccess\", expireAfterAccessNanos + \"ns\");\n",
        "608": "    }\n",
        "609": "    if (keyStrength != null) {\n",
        "610": "      s.add(\"keyStrength\", Ascii.toLowerCase(keyStrength.toString()));\n",
        "611": "    }\n",
        "612": "    if (valueStrength != null) {\n",
        "613": "      s.add(\"valueStrength\", Ascii.toLowerCase(valueStrength.toString()));\n",
        "614": "    }\n",
        "615": "    if (keyEquivalence != null) {\n",
        "616": "      s.addValue(\"keyEquivalence\");\n",
        "617": "    }\n",
        "618": "    if (valueEquivalence != null) {\n",
        "619": "      s.addValue(\"valueEquivalence\");\n",
        "620": "    }\n",
        "621": "    if (removalListener != null) {\n",
        "622": "      s.addValue(\"removalListener\");\n",
        "623": "    }\n",
        "624": "    return s.toString();\n",
        "625": "  }\n",
        "626": "}\n"
    }
}