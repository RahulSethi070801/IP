{
    "addition": {},
    "removed": {
        "1": "/*\n",
        "2": " * Copyright (C) 2007 The Guava Authors\n",
        "3": " *\n",
        "4": " * Licensed under the Apache License, Version 2.0 (the \"License\");\n",
        "5": " * you may not use this file except in compliance with the License.\n",
        "6": " * You may obtain a copy of the License at\n",
        "7": " *\n",
        "8": " * http://www.apache.org/licenses/LICENSE-2.0\n",
        "9": " *\n",
        "10": " * Unless required by applicable law or agreed to in writing, software\n",
        "11": " * distributed under the License is distributed on an \"AS IS\" BASIS,\n",
        "12": " * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n",
        "13": " * See the License for the specific language governing permissions and\n",
        "14": " * limitations under the License.\n",
        "15": " */\n",
        "16": "\n",
        "17": "package com.google.common.collect;\n",
        "18": "\n",
        "19": "import static com.google.common.collect.Maps.transformEntries;\n",
        "20": "import static com.google.common.collect.Maps.transformValues;\n",
        "21": "import static com.google.common.collect.testing.Helpers.mapEntry;\n",
        "22": "import static com.google.common.truth.Truth.assertThat;\n",
        "23": "\n",
        "24": "import com.google.common.annotations.GwtCompatible;\n",
        "25": "import com.google.common.base.Converter;\n",
        "26": "import com.google.common.base.Equivalence;\n",
        "27": "import com.google.common.base.Function;\n",
        "28": "import com.google.common.base.Functions;\n",
        "29": "import com.google.common.base.Predicate;\n",
        "30": "import com.google.common.base.Predicates;\n",
        "31": "import com.google.common.collect.Maps.EntryTransformer;\n",
        "32": "import com.google.common.collect.Maps.ValueDifferenceImpl;\n",
        "33": "import com.google.common.collect.SetsTest.Derived;\n",
        "34": "import com.google.common.testing.EqualsTester;\n",
        "35": "import com.google.common.testing.SerializableTester;\n",
        "36": "\n",
        "37": "import junit.framework.TestCase;\n",
        "38": "\n",
        "39": "import java.util.Arrays;\n",
        "40": "import java.util.Collections;\n",
        "41": "import java.util.Comparator;\n",
        "42": "import java.util.EnumMap;\n",
        "43": "import java.util.HashMap;\n",
        "44": "import java.util.IdentityHashMap;\n",
        "45": "import java.util.Iterator;\n",
        "46": "import java.util.LinkedHashMap;\n",
        "47": "import java.util.List;\n",
        "48": "import java.util.Map;\n",
        "49": "import java.util.Map.Entry;\n",
        "50": "import java.util.Set;\n",
        "51": "import java.util.SortedMap;\n",
        "52": "import java.util.SortedSet;\n",
        "53": "import java.util.TreeMap;\n",
        "54": "import java.util.concurrent.ConcurrentMap;\n",
        "55": "\n",
        "56": "/**\n",
        "57": " * Unit test for {@code Maps}.\n",
        "58": " *\n",
        "59": " * @author Kevin Bourrillion\n",
        "60": " * @author Mike Bostock\n",
        "61": " * @author Jared Levy\n",
        "62": " */\n",
        "63": "@GwtCompatible(emulated = true)\n",
        "64": "public class MapsTest extends TestCase {\n",
        "65": "\n",
        "66": "  private static final Comparator<Integer> SOME_COMPARATOR =\n",
        "67": "      Collections.reverseOrder();\n",
        "68": "\n",
        "69": "  public void testHashMap() {\n",
        "70": "    HashMap<Integer, Integer> map = Maps.newHashMap();\n",
        "71": "    assertEquals(Collections.emptyMap(), map);\n",
        "72": "  }\n",
        "73": "\n",
        "74": "  public void testHashMapWithInitialMap() {\n",
        "75": "    Map<String, Integer> original = new TreeMap<String, Integer>();\n",
        "76": "    original.put(\"a\", 1);\n",
        "77": "    original.put(\"b\", 2);\n",
        "78": "    original.put(\"c\", 3);\n",
        "79": "    HashMap<String, Integer> map = Maps.newHashMap(original);\n",
        "80": "    assertEquals(original, map);\n",
        "81": "  }\n",
        "82": "\n",
        "83": "  public void testHashMapGeneralizesTypes() {\n",
        "84": "    Map<String, Integer> original = new TreeMap<String, Integer>();\n",
        "85": "    original.put(\"a\", 1);\n",
        "86": "    original.put(\"b\", 2);\n",
        "87": "    original.put(\"c\", 3);\n",
        "88": "    HashMap<Object, Object> map =\n",
        "89": "        Maps.newHashMap((Map<? extends Object, ? extends Object>) original);\n",
        "90": "    assertEquals(original, map);\n",
        "91": "  }\n",
        "92": "\n",
        "93": "  public void testCapacityForNegativeSizeFails() {\n",
        "94": "    try {\n",
        "95": "      Maps.capacity(-1);\n",
        "96": "      fail(\"Negative expected size must result in IllegalArgumentException\");\n",
        "97": "    } catch (IllegalArgumentException expected) {\n",
        "98": "    }\n",
        "99": "  }\n",
        "100": "\n",
        "101": "  public void testCapacityForLargeSizes() {\n",
        "102": "    int[] largeExpectedSizes = new int[] {\n",
        "103": "      Integer.MAX_VALUE / 2 - 1,\n",
        "104": "      Integer.MAX_VALUE / 2,\n",
        "105": "      Integer.MAX_VALUE / 2 + 1,\n",
        "106": "      Integer.MAX_VALUE - 1,\n",
        "107": "      Integer.MAX_VALUE};\n",
        "108": "    for (int expectedSize : largeExpectedSizes) {\n",
        "109": "      int capacity = Maps.capacity(expectedSize);\n",
        "110": "      assertTrue(\n",
        "111": "          \"capacity (\" + capacity + \") must be >= expectedSize (\" + expectedSize + \")\",\n",
        "112": "          capacity >= expectedSize);\n",
        "113": "    }\n",
        "114": "  }\n",
        "115": "\n",
        "116": "  public void testLinkedHashMap() {\n",
        "117": "    LinkedHashMap<Integer, Integer> map = Maps.newLinkedHashMap();\n",
        "118": "    assertEquals(Collections.emptyMap(), map);\n",
        "119": "  }\n",
        "120": "\n",
        "121": "  @SuppressWarnings(\"serial\")\n",
        "122": "  public void testLinkedHashMapWithInitialMap() {\n",
        "123": "    Map<String, String> map = new LinkedHashMap<String, String>() {{\n",
        "124": "      put(\"Hello\", \"World\");\n",
        "125": "      put(\"first\", \"second\");\n",
        "126": "      put(\"polygene\", \"lubricants\");\n",
        "127": "      put(\"alpha\", \"betical\");\n",
        "128": "    }};\n",
        "129": "\n",
        "130": "    LinkedHashMap<String, String> copy = Maps.newLinkedHashMap(map);\n",
        "131": "\n",
        "132": "    Iterator<Entry<String, String>> iter = copy.entrySet().iterator();\n",
        "133": "    assertTrue(iter.hasNext());\n",
        "134": "    Entry<String, String> entry = iter.next();\n",
        "135": "    assertEquals(\"Hello\", entry.getKey());\n",
        "136": "    assertEquals(\"World\", entry.getValue());\n",
        "137": "    assertTrue(iter.hasNext());\n",
        "138": "\n",
        "139": "    entry = iter.next();\n",
        "140": "    assertEquals(\"first\", entry.getKey());\n",
        "141": "    assertEquals(\"second\", entry.getValue());\n",
        "142": "    assertTrue(iter.hasNext());\n",
        "143": "\n",
        "144": "    entry = iter.next();\n",
        "145": "    assertEquals(\"polygene\", entry.getKey());\n",
        "146": "    assertEquals(\"lubricants\", entry.getValue());\n",
        "147": "    assertTrue(iter.hasNext());\n",
        "148": "\n",
        "149": "    entry = iter.next();\n",
        "150": "    assertEquals(\"alpha\", entry.getKey());\n",
        "151": "    assertEquals(\"betical\", entry.getValue());\n",
        "152": "    assertFalse(iter.hasNext());\n",
        "153": "  }\n",
        "154": "\n",
        "155": "  public void testLinkedHashMapGeneralizesTypes() {\n",
        "156": "    Map<String, Integer> original = new LinkedHashMap<String, Integer>();\n",
        "157": "    original.put(\"a\", 1);\n",
        "158": "    original.put(\"b\", 2);\n",
        "159": "    original.put(\"c\", 3);\n",
        "160": "    HashMap<Object, Object> map\n",
        "161": "        = Maps.<Object, Object>newLinkedHashMap(original);\n",
        "162": "    assertEquals(original, map);\n",
        "163": "  }\n",
        "164": "\n",
        "165": "  public void testIdentityHashMap() {\n",
        "166": "    IdentityHashMap<Integer, Integer> map = Maps.newIdentityHashMap();\n",
        "167": "    assertEquals(Collections.emptyMap(), map);\n",
        "168": "  }\n",
        "169": "\n",
        "170": "  public void testConcurrentMap() {\n",
        "171": "    ConcurrentMap<Integer, Integer> map = Maps.newConcurrentMap();\n",
        "172": "    assertEquals(Collections.emptyMap(), map);\n",
        "173": "  }\n",
        "174": "\n",
        "175": "  public void testTreeMap() {\n",
        "176": "    TreeMap<Integer, Integer> map = Maps.newTreeMap();\n",
        "177": "    assertEquals(Collections.emptyMap(), map);\n",
        "178": "    assertNull(map.comparator());\n",
        "179": "  }\n",
        "180": "\n",
        "181": "  public void testTreeMapDerived() {\n",
        "182": "    TreeMap<Derived, Integer> map = Maps.newTreeMap();\n",
        "183": "    assertEquals(Collections.emptyMap(), map);\n",
        "184": "    map.put(new Derived(\"foo\"), 1);\n",
        "185": "    map.put(new Derived(\"bar\"), 2);\n",
        "186": "    assertThat(map.keySet()).containsExactly(\n",
        "187": "        new Derived(\"bar\"), new Derived(\"foo\")).inOrder();\n",
        "188": "    assertThat(map.values()).containsExactly(2, 1).inOrder();\n",
        "189": "    assertNull(map.comparator());\n",
        "190": "  }\n",
        "191": "\n",
        "192": "  public void testTreeMapNonGeneric() {\n",
        "193": "    TreeMap<LegacyComparable, Integer> map = Maps.newTreeMap();\n",
        "194": "    assertEquals(Collections.emptyMap(), map);\n",
        "195": "    map.put(new LegacyComparable(\"foo\"), 1);\n",
        "196": "    map.put(new LegacyComparable(\"bar\"), 2);\n",
        "197": "    assertThat(map.keySet()).containsExactly(\n",
        "198": "        new LegacyComparable(\"bar\"), new LegacyComparable(\"foo\")).inOrder();\n",
        "199": "    assertThat(map.values()).containsExactly(2, 1).inOrder();\n",
        "200": "    assertNull(map.comparator());\n",
        "201": "  }\n",
        "202": "\n",
        "203": "  public void testTreeMapWithComparator() {\n",
        "204": "    TreeMap<Integer, Integer> map = Maps.newTreeMap(SOME_COMPARATOR);\n",
        "205": "    assertEquals(Collections.emptyMap(), map);\n",
        "206": "    assertSame(SOME_COMPARATOR, map.comparator());\n",
        "207": "  }\n",
        "208": "\n",
        "209": "  public void testTreeMapWithInitialMap() {\n",
        "210": "    SortedMap<Integer, Integer> map = Maps.newTreeMap();\n",
        "211": "    map.put(5, 10);\n",
        "212": "    map.put(3, 20);\n",
        "213": "    map.put(1, 30);\n",
        "214": "    TreeMap<Integer, Integer> copy = Maps.newTreeMap(map);\n",
        "215": "    assertEquals(copy, map);\n",
        "216": "    assertSame(copy.comparator(), map.comparator());\n",
        "217": "  }\n",
        "218": "\n",
        "219": "  public enum SomeEnum { SOME_INSTANCE }\n",
        "220": "\n",
        "221": "  public void testEnumMap() {\n",
        "222": "    EnumMap<SomeEnum, Integer> map = Maps.newEnumMap(SomeEnum.class);\n",
        "223": "    assertEquals(Collections.emptyMap(), map);\n",
        "224": "    map.put(SomeEnum.SOME_INSTANCE, 0);\n",
        "225": "    assertEquals(Collections.singletonMap(SomeEnum.SOME_INSTANCE, 0), map);\n",
        "226": "  }\n",
        "227": "\n",
        "228": "  public void testEnumMapNullClass() {\n",
        "229": "    try {\n",
        "230": "      Maps.<SomeEnum, Long>newEnumMap((Class<MapsTest.SomeEnum>) null);\n",
        "231": "      fail(\"no exception thrown\");\n",
        "232": "    } catch (NullPointerException expected) {\n",
        "233": "    }\n",
        "234": "  }\n",
        "235": "\n",
        "236": "  public void testEnumMapWithInitialEnumMap() {\n",
        "237": "    EnumMap<SomeEnum, Integer> original = Maps.newEnumMap(SomeEnum.class);\n",
        "238": "    original.put(SomeEnum.SOME_INSTANCE, 0);\n",
        "239": "    EnumMap<SomeEnum, Integer> copy = Maps.newEnumMap(original);\n",
        "240": "    assertEquals(original, copy);\n",
        "241": "  }\n",
        "242": "\n",
        "243": "  public void testEnumMapWithInitialEmptyEnumMap() {\n",
        "244": "    EnumMap<SomeEnum, Integer> original = Maps.newEnumMap(SomeEnum.class);\n",
        "245": "    EnumMap<SomeEnum, Integer> copy = Maps.newEnumMap(original);\n",
        "246": "    assertEquals(original, copy);\n",
        "247": "    assertNotSame(original, copy);\n",
        "248": "  }\n",
        "249": "\n",
        "250": "  public void testEnumMapWithInitialMap() {\n",
        "251": "    HashMap<SomeEnum, Integer> original = Maps.newHashMap();\n",
        "252": "    original.put(SomeEnum.SOME_INSTANCE, 0);\n",
        "253": "    EnumMap<SomeEnum, Integer> copy = Maps.newEnumMap(original);\n",
        "254": "    assertEquals(original, copy);\n",
        "255": "  }\n",
        "256": "\n",
        "257": "  public void testEnumMapWithInitialEmptyMap() {\n",
        "258": "    Map<SomeEnum, Integer> original = Maps.newHashMap();\n",
        "259": "    try {\n",
        "260": "      Maps.newEnumMap(original);\n",
        "261": "      fail(\"Empty map must result in an IllegalArgumentException\");\n",
        "262": "    } catch (IllegalArgumentException expected) {}\n",
        "263": "  }\n",
        "264": "\n",
        "265": "  public void testToStringImplWithNullKeys() throws Exception {\n",
        "266": "    Map<String, String> hashmap = Maps.newHashMap();\n",
        "267": "    hashmap.put(\"foo\", \"bar\");\n",
        "268": "    hashmap.put(null, \"baz\");\n",
        "269": "\n",
        "270": "    assertEquals(hashmap.toString(), Maps.toStringImpl(hashmap));\n",
        "271": "  }\n",
        "272": "\n",
        "273": "  public void testToStringImplWithNullValues() throws Exception {\n",
        "274": "    Map<String, String> hashmap = Maps.newHashMap();\n",
        "275": "    hashmap.put(\"foo\", \"bar\");\n",
        "276": "    hashmap.put(\"baz\", null);\n",
        "277": "\n",
        "278": "    assertEquals(hashmap.toString(), Maps.toStringImpl(hashmap));\n",
        "279": "  }\n",
        "280": "\n",
        "281": "  private static final Map<Integer, Integer> EMPTY\n",
        "282": "      = Collections.emptyMap();\n",
        "283": "  private static final Map<Integer, Integer> SINGLETON\n",
        "284": "      = Collections.singletonMap(1, 2);\n",
        "285": "\n",
        "286": "  public void testMapDifferenceEmptyEmpty() {\n",
        "287": "    MapDifference<Integer, Integer> diff = Maps.difference(EMPTY, EMPTY);\n",
        "288": "    assertTrue(diff.areEqual());\n",
        "289": "    assertEquals(EMPTY, diff.entriesOnlyOnLeft());\n",
        "290": "    assertEquals(EMPTY, diff.entriesOnlyOnRight());\n",
        "291": "    assertEquals(EMPTY, diff.entriesInCommon());\n",
        "292": "    assertEquals(EMPTY, diff.entriesDiffering());\n",
        "293": "    assertEquals(\"equal\", diff.toString());\n",
        "294": "  }\n",
        "295": "\n",
        "296": "  public void testMapDifferenceEmptySingleton() {\n",
        "297": "    MapDifference<Integer, Integer> diff = Maps.difference(EMPTY, SINGLETON);\n",
        "298": "    assertFalse(diff.areEqual());\n",
        "299": "    assertEquals(EMPTY, diff.entriesOnlyOnLeft());\n",
        "300": "    assertEquals(SINGLETON, diff.entriesOnlyOnRight());\n",
        "301": "    assertEquals(EMPTY, diff.entriesInCommon());\n",
        "302": "    assertEquals(EMPTY, diff.entriesDiffering());\n",
        "303": "    assertEquals(\"not equal: only on right={1=2}\", diff.toString());\n",
        "304": "  }\n",
        "305": "\n",
        "306": "  public void testMapDifferenceSingletonEmpty() {\n",
        "307": "    MapDifference<Integer, Integer> diff = Maps.difference(SINGLETON, EMPTY);\n",
        "308": "    assertFalse(diff.areEqual());\n",
        "309": "    assertEquals(SINGLETON, diff.entriesOnlyOnLeft());\n",
        "310": "    assertEquals(EMPTY, diff.entriesOnlyOnRight());\n",
        "311": "    assertEquals(EMPTY, diff.entriesInCommon());\n",
        "312": "    assertEquals(EMPTY, diff.entriesDiffering());\n",
        "313": "    assertEquals(\"not equal: only on left={1=2}\", diff.toString());\n",
        "314": "  }\n",
        "315": "\n",
        "316": "  public void testMapDifferenceTypical() {\n",
        "317": "    Map<Integer, String> left = ImmutableMap.of(\n",
        "318": "        1, \"a\", 2, \"b\", 3, \"c\", 4, \"d\", 5, \"e\");\n",
        "319": "    Map<Integer, String> right = ImmutableMap.of(\n",
        "320": "        1, \"a\", 3, \"f\", 5, \"g\", 6, \"z\");\n",
        "321": "\n",
        "322": "    MapDifference<Integer, String> diff1 = Maps.difference(left, right);\n",
        "323": "    assertFalse(diff1.areEqual());\n",
        "324": "    assertEquals(ImmutableMap.of(2, \"b\", 4, \"d\"), diff1.entriesOnlyOnLeft());\n",
        "325": "    assertEquals(ImmutableMap.of(6, \"z\"), diff1.entriesOnlyOnRight());\n",
        "326": "    assertEquals(ImmutableMap.of(1, \"a\"), diff1.entriesInCommon());\n",
        "327": "    assertEquals(ImmutableMap.of(3,\n",
        "328": "        ValueDifferenceImpl.create(\"c\", \"f\"), 5,\n",
        "329": "        ValueDifferenceImpl.create(\"e\", \"g\")),\n",
        "330": "        diff1.entriesDiffering());\n",
        "331": "    assertEquals(\"not equal: only on left={2=b, 4=d}: only on right={6=z}: \"\n",
        "332": "        + \"value differences={3=(c, f), 5=(e, g)}\", diff1.toString());\n",
        "333": "\n",
        "334": "    MapDifference<Integer, String> diff2 = Maps.difference(right, left);\n",
        "335": "    assertFalse(diff2.areEqual());\n",
        "336": "    assertEquals(ImmutableMap.of(6, \"z\"), diff2.entriesOnlyOnLeft());\n",
        "337": "    assertEquals(ImmutableMap.of(2, \"b\", 4, \"d\"), diff2.entriesOnlyOnRight());\n",
        "338": "    assertEquals(ImmutableMap.of(1, \"a\"), diff2.entriesInCommon());\n",
        "339": "    assertEquals(ImmutableMap.of(3,\n",
        "340": "        ValueDifferenceImpl.create(\"f\", \"c\"), 5,\n",
        "341": "        ValueDifferenceImpl.create(\"g\", \"e\")),\n",
        "342": "        diff2.entriesDiffering());\n",
        "343": "    assertEquals(\"not equal: only on left={6=z}: only on right={2=b, 4=d}: \"\n",
        "344": "        + \"value differences={3=(f, c), 5=(g, e)}\", diff2.toString());\n",
        "345": "  }\n",
        "346": "\n",
        "347": "  public void testMapDifferenceEquals() {\n",
        "348": "    Map<Integer, String> left = ImmutableMap.of(\n",
        "349": "        1, \"a\", 2, \"b\", 3, \"c\", 4, \"d\", 5, \"e\");\n",
        "350": "    Map<Integer, String> right = ImmutableMap.of(\n",
        "351": "        1, \"a\", 3, \"f\", 5, \"g\", 6, \"z\");\n",
        "352": "    Map<Integer, String> right2 = ImmutableMap.of(\n",
        "353": "        1, \"a\", 3, \"h\", 5, \"g\", 6, \"z\");\n",
        "354": "    MapDifference<Integer, String> original = Maps.difference(left, right);\n",
        "355": "    MapDifference<Integer, String> same = Maps.difference(left, right);\n",
        "356": "    MapDifference<Integer, String> reverse = Maps.difference(right, left);\n",
        "357": "    MapDifference<Integer, String> diff2 = Maps.difference(left, right2);\n",
        "358": "\n",
        "359": "    new EqualsTester()\n",
        "360": "        .addEqualityGroup(original, same)\n",
        "361": "        .addEqualityGroup(reverse)\n",
        "362": "        .addEqualityGroup(diff2)\n",
        "363": "        .testEquals();\n",
        "364": "  }\n",
        "365": "\n",
        "366": "  public void testMapDifferencePredicateTypical() {\n",
        "367": "    Map<Integer, String> left = ImmutableMap.of(\n",
        "368": "        1, \"a\", 2, \"b\", 3, \"c\", 4, \"d\", 5, \"e\");\n",
        "369": "    Map<Integer, String> right = ImmutableMap.of(\n",
        "370": "        1, \"A\", 3, \"F\", 5, \"G\", 6, \"Z\");\n",
        "371": "\n",
        "372": "    // TODO(kevinb): replace with Ascii.caseInsensitiveEquivalence() when it\n",
        "373": "    // exists\n",
        "374": "    Equivalence<String> caseInsensitiveEquivalence = Equivalence.equals().onResultOf(\n",
        "375": "        new Function<String, String>() {\n",
        "376": "          @Override public String apply(String input) {\n",
        "377": "            return input.toLowerCase();\n",
        "378": "          }\n",
        "379": "        });\n",
        "380": "\n",
        "381": "    MapDifference<Integer, String> diff1 = Maps.difference(left, right,\n",
        "382": "        caseInsensitiveEquivalence);\n",
        "383": "    assertFalse(diff1.areEqual());\n",
        "384": "    assertEquals(ImmutableMap.of(2, \"b\", 4, \"d\"), diff1.entriesOnlyOnLeft());\n",
        "385": "    assertEquals(ImmutableMap.of(6, \"Z\"), diff1.entriesOnlyOnRight());\n",
        "386": "    assertEquals(ImmutableMap.of(1, \"a\"), diff1.entriesInCommon());\n",
        "387": "    assertEquals(ImmutableMap.of(3,\n",
        "388": "        ValueDifferenceImpl.create(\"c\", \"F\"), 5,\n",
        "389": "        ValueDifferenceImpl.create(\"e\", \"G\")),\n",
        "390": "        diff1.entriesDiffering());\n",
        "391": "    assertEquals(\"not equal: only on left={2=b, 4=d}: only on right={6=Z}: \"\n",
        "392": "        + \"value differences={3=(c, F), 5=(e, G)}\", diff1.toString());\n",
        "393": "\n",
        "394": "    MapDifference<Integer, String> diff2 = Maps.difference(right, left,\n",
        "395": "        caseInsensitiveEquivalence);\n",
        "396": "    assertFalse(diff2.areEqual());\n",
        "397": "    assertEquals(ImmutableMap.of(6, \"Z\"), diff2.entriesOnlyOnLeft());\n",
        "398": "    assertEquals(ImmutableMap.of(2, \"b\", 4, \"d\"), diff2.entriesOnlyOnRight());\n",
        "399": "    assertEquals(ImmutableMap.of(1, \"A\"), diff2.entriesInCommon());\n",
        "400": "    assertEquals(ImmutableMap.of(3,\n",
        "401": "        ValueDifferenceImpl.create(\"F\", \"c\"), 5,\n",
        "402": "        ValueDifferenceImpl.create(\"G\", \"e\")),\n",
        "403": "        diff2.entriesDiffering());\n",
        "404": "    assertEquals(\"not equal: only on left={6=Z}: only on right={2=b, 4=d}: \"\n",
        "405": "        + \"value differences={3=(F, c), 5=(G, e)}\", diff2.toString());\n",
        "406": "  }\n",
        "407": "\n",
        "408": "  private static final SortedMap<Integer, Integer> SORTED_EMPTY = Maps.newTreeMap();\n",
        "409": "  private static final SortedMap<Integer, Integer> SORTED_SINGLETON =\n",
        "410": "      ImmutableSortedMap.of(1, 2);\n",
        "411": "\n",
        "412": "  public void testMapDifferenceOfSortedMapIsSorted() {\n",
        "413": "    Map<Integer, Integer> map = SORTED_SINGLETON;\n",
        "414": "    MapDifference<Integer, Integer> difference = Maps.difference(map, EMPTY);\n",
        "415": "    assertTrue(difference instanceof SortedMapDifference);\n",
        "416": "  }\n",
        "417": "\n",
        "418": "  public void testSortedMapDifferenceEmptyEmpty() {\n",
        "419": "    SortedMapDifference<Integer, Integer> diff =\n",
        "420": "        Maps.difference(SORTED_EMPTY, SORTED_EMPTY);\n",
        "421": "    assertTrue(diff.areEqual());\n",
        "422": "    assertEquals(SORTED_EMPTY, diff.entriesOnlyOnLeft());\n",
        "423": "    assertEquals(SORTED_EMPTY, diff.entriesOnlyOnRight());\n",
        "424": "    assertEquals(SORTED_EMPTY, diff.entriesInCommon());\n",
        "425": "    assertEquals(SORTED_EMPTY, diff.entriesDiffering());\n",
        "426": "    assertEquals(\"equal\", diff.toString());\n",
        "427": "  }\n",
        "428": "\n",
        "429": "  public void testSortedMapDifferenceEmptySingleton() {\n",
        "430": "    SortedMapDifference<Integer, Integer> diff =\n",
        "431": "        Maps.difference(SORTED_EMPTY, SORTED_SINGLETON);\n",
        "432": "    assertFalse(diff.areEqual());\n",
        "433": "    assertEquals(SORTED_EMPTY, diff.entriesOnlyOnLeft());\n",
        "434": "    assertEquals(SORTED_SINGLETON, diff.entriesOnlyOnRight());\n",
        "435": "    assertEquals(SORTED_EMPTY, diff.entriesInCommon());\n",
        "436": "    assertEquals(SORTED_EMPTY, diff.entriesDiffering());\n",
        "437": "    assertEquals(\"not equal: only on right={1=2}\", diff.toString());\n",
        "438": "  }\n",
        "439": "\n",
        "440": "  public void testSortedMapDifferenceSingletonEmpty() {\n",
        "441": "    SortedMapDifference<Integer, Integer> diff =\n",
        "442": "        Maps.difference(SORTED_SINGLETON, SORTED_EMPTY);\n",
        "443": "    assertFalse(diff.areEqual());\n",
        "444": "    assertEquals(SORTED_SINGLETON, diff.entriesOnlyOnLeft());\n",
        "445": "    assertEquals(SORTED_EMPTY, diff.entriesOnlyOnRight());\n",
        "446": "    assertEquals(SORTED_EMPTY, diff.entriesInCommon());\n",
        "447": "    assertEquals(SORTED_EMPTY, diff.entriesDiffering());\n",
        "448": "    assertEquals(\"not equal: only on left={1=2}\", diff.toString());\n",
        "449": "  }\n",
        "450": "\n",
        "451": "  public void testSortedMapDifferenceTypical() {\n",
        "452": "    SortedMap<Integer, String> left =\n",
        "453": "        ImmutableSortedMap.<Integer, String>reverseOrder()\n",
        "454": "        .put(1, \"a\").put(2, \"b\").put(3, \"c\").put(4, \"d\").put(5, \"e\")\n",
        "455": "        .build();\n",
        "456": "\n",
        "457": "    SortedMap<Integer, String> right =\n",
        "458": "        ImmutableSortedMap.of(1, \"a\", 3, \"f\", 5, \"g\", 6, \"z\");\n",
        "459": "\n",
        "460": "    SortedMapDifference<Integer, String> diff1 =\n",
        "461": "        Maps.difference(left, right);\n",
        "462": "    assertFalse(diff1.areEqual());\n",
        "463": "    assertThat(diff1.entriesOnlyOnLeft().entrySet()).containsExactly(\n",
        "464": "        Maps.immutableEntry(4, \"d\"), Maps.immutableEntry(2, \"b\")).inOrder();\n",
        "465": "    assertThat(diff1.entriesOnlyOnRight().entrySet()).contains(\n",
        "466": "        Maps.immutableEntry(6, \"z\"));\n",
        "467": "    assertThat(diff1.entriesInCommon().entrySet()).contains(\n",
        "468": "        Maps.immutableEntry(1, \"a\"));\n",
        "469": "    assertThat(diff1.entriesDiffering().entrySet()).containsExactly(\n",
        "470": "        Maps.immutableEntry(5, ValueDifferenceImpl.create(\"e\", \"g\")),\n",
        "471": "        Maps.immutableEntry(3, ValueDifferenceImpl.create(\"c\", \"f\"))).inOrder();\n",
        "472": "    assertEquals(\"not equal: only on left={4=d, 2=b}: only on right={6=z}: \"\n",
        "473": "        + \"value differences={5=(e, g), 3=(c, f)}\", diff1.toString());\n",
        "474": "\n",
        "475": "    SortedMapDifference<Integer, String> diff2 =\n",
        "476": "        Maps.difference(right, left);\n",
        "477": "    assertFalse(diff2.areEqual());\n",
        "478": "    assertThat(diff2.entriesOnlyOnLeft().entrySet()).contains(\n",
        "479": "        Maps.immutableEntry(6, \"z\"));\n",
        "480": "    assertThat(diff2.entriesOnlyOnRight().entrySet()).containsExactly(\n",
        "481": "        Maps.immutableEntry(2, \"b\"), Maps.immutableEntry(4, \"d\")).inOrder();\n",
        "482": "    assertThat(diff1.entriesInCommon().entrySet()).contains(\n",
        "483": "        Maps.immutableEntry(1, \"a\"));\n",
        "484": "    assertEquals(ImmutableMap.of(\n",
        "485": "            3, ValueDifferenceImpl.create(\"f\", \"c\"),\n",
        "486": "            5, ValueDifferenceImpl.create(\"g\", \"e\")),\n",
        "487": "        diff2.entriesDiffering());\n",
        "488": "    assertEquals(\"not equal: only on left={6=z}: only on right={2=b, 4=d}: \"\n",
        "489": "        + \"value differences={3=(f, c), 5=(g, e)}\", diff2.toString());\n",
        "490": "  }\n",
        "491": "\n",
        "492": "  public void testSortedMapDifferenceImmutable() {\n",
        "493": "    SortedMap<Integer, String> left = Maps.newTreeMap(\n",
        "494": "        ImmutableSortedMap.of(1, \"a\", 2, \"b\", 3, \"c\", 4, \"d\", 5, \"e\"));\n",
        "495": "    SortedMap<Integer, String> right =\n",
        "496": "        Maps.newTreeMap(ImmutableSortedMap.of(1, \"a\", 3, \"f\", 5, \"g\", 6, \"z\"));\n",
        "497": "\n",
        "498": "    SortedMapDifference<Integer, String> diff1 =\n",
        "499": "        Maps.difference(left, right);\n",
        "500": "    left.put(6, \"z\");\n",
        "501": "    assertFalse(diff1.areEqual());\n",
        "502": "    assertThat(diff1.entriesOnlyOnLeft().entrySet()).containsExactly(\n",
        "503": "        Maps.immutableEntry(2, \"b\"), Maps.immutableEntry(4, \"d\")).inOrder();\n",
        "504": "    assertThat(diff1.entriesOnlyOnRight().entrySet()).contains(\n",
        "505": "        Maps.immutableEntry(6, \"z\"));\n",
        "506": "    assertThat(diff1.entriesInCommon().entrySet()).contains(\n",
        "507": "        Maps.immutableEntry(1, \"a\"));\n",
        "508": "    assertThat(diff1.entriesDiffering().entrySet()).containsExactly(\n",
        "509": "        Maps.immutableEntry(3, ValueDifferenceImpl.create(\"c\", \"f\")),\n",
        "510": "        Maps.immutableEntry(5, ValueDifferenceImpl.create(\"e\", \"g\"))).inOrder();\n",
        "511": "    try {\n",
        "512": "      diff1.entriesInCommon().put(7, \"x\");\n",
        "513": "      fail();\n",
        "514": "    } catch (UnsupportedOperationException expected) {\n",
        "515": "    }\n",
        "516": "    try {\n",
        "517": "      diff1.entriesOnlyOnLeft().put(7, \"x\");\n",
        "518": "      fail();\n",
        "519": "    } catch (UnsupportedOperationException expected) {\n",
        "520": "    }\n",
        "521": "    try {\n",
        "522": "      diff1.entriesOnlyOnRight().put(7, \"x\");\n",
        "523": "      fail();\n",
        "524": "    } catch (UnsupportedOperationException expected) {\n",
        "525": "    }\n",
        "526": "  }\n",
        "527": "\n",
        "528": "  public void testSortedMapDifferenceEquals() {\n",
        "529": "    SortedMap<Integer, String> left =\n",
        "530": "        ImmutableSortedMap.of(1, \"a\", 2, \"b\", 3, \"c\", 4, \"d\", 5, \"e\");\n",
        "531": "    SortedMap<Integer, String> right =\n",
        "532": "        ImmutableSortedMap.of(1, \"a\", 3, \"f\", 5, \"g\", 6, \"z\");\n",
        "533": "    SortedMap<Integer, String> right2 =\n",
        "534": "        ImmutableSortedMap.of(1, \"a\", 3, \"h\", 5, \"g\", 6, \"z\");\n",
        "535": "    SortedMapDifference<Integer, String> original =\n",
        "536": "        Maps.difference(left, right);\n",
        "537": "    SortedMapDifference<Integer, String> same =\n",
        "538": "        Maps.difference(left, right);\n",
        "539": "    SortedMapDifference<Integer, String> reverse =\n",
        "540": "        Maps.difference(right, left);\n",
        "541": "    SortedMapDifference<Integer, String> diff2 =\n",
        "542": "        Maps.difference(left, right2);\n",
        "543": "\n",
        "544": "    new EqualsTester()\n",
        "545": "        .addEqualityGroup(original, same)\n",
        "546": "        .addEqualityGroup(reverse)\n",
        "547": "        .addEqualityGroup(diff2)\n",
        "548": "        .testEquals();\n",
        "549": "  }\n",
        "550": "\n",
        "551": "  private static final Function<String, Integer> LENGTH_FUNCTION =\n",
        "552": "      new Function<String, Integer>() {\n",
        "553": "        @Override\n",
        "554": "        public Integer apply(String input) {\n",
        "555": "          return input.length();\n",
        "556": "        }\n",
        "557": "      };\n",
        "558": "\n",
        "559": "  public void testAsMap() {\n",
        "560": "    Set<String> strings = ImmutableSet.of(\"one\", \"two\", \"three\");\n",
        "561": "    Map<String, Integer> map = Maps.asMap(strings, LENGTH_FUNCTION);\n",
        "562": "    assertEquals(ImmutableMap.of(\"one\", 3, \"two\", 3, \"three\", 5), map);\n",
        "563": "    assertEquals(Integer.valueOf(5), map.get(\"three\"));\n",
        "564": "    assertNull(map.get(\"five\"));\n",
        "565": "    assertThat(map.entrySet()).containsExactly(\n",
        "566": "        mapEntry(\"one\", 3),\n",
        "567": "        mapEntry(\"two\", 3),\n",
        "568": "        mapEntry(\"three\", 5)).inOrder();\n",
        "569": "  }\n",
        "570": "\n",
        "571": "  public void testAsMapReadsThrough() {\n",
        "572": "    Set<String> strings = Sets.newLinkedHashSet();\n",
        "573": "    Collections.addAll(strings, \"one\", \"two\", \"three\");\n",
        "574": "    Map<String, Integer> map = Maps.asMap(strings, LENGTH_FUNCTION);\n",
        "575": "    assertEquals(ImmutableMap.of(\"one\", 3, \"two\", 3, \"three\", 5), map);\n",
        "576": "    assertNull(map.get(\"four\"));\n",
        "577": "    strings.add(\"four\");\n",
        "578": "    assertEquals(ImmutableMap.of(\"one\", 3, \"two\", 3, \"three\", 5, \"four\", 4), map);\n",
        "579": "    assertEquals(Integer.valueOf(4), map.get(\"four\"));\n",
        "580": "  }\n",
        "581": "\n",
        "582": "  public void testAsMapWritesThrough() {\n",
        "583": "    Set<String> strings = Sets.newLinkedHashSet();\n",
        "584": "    Collections.addAll(strings, \"one\", \"two\", \"three\");\n",
        "585": "    Map<String, Integer> map = Maps.asMap(strings, LENGTH_FUNCTION);\n",
        "586": "    assertEquals(ImmutableMap.of(\"one\", 3, \"two\", 3, \"three\", 5), map);\n",
        "587": "    assertEquals(Integer.valueOf(3), map.remove(\"two\"));\n",
        "588": "    assertThat(strings).containsExactly(\"one\", \"three\").inOrder();\n",
        "589": "  }\n",
        "590": "\n",
        "591": "  public void testAsMapEmpty() {\n",
        "592": "    Set<String> strings = ImmutableSet.of();\n",
        "593": "    Map<String, Integer> map = Maps.asMap(strings, LENGTH_FUNCTION);\n",
        "594": "    assertThat(map.entrySet()).isEmpty();\n",
        "595": "    assertTrue(map.isEmpty());\n",
        "596": "    assertNull(map.get(\"five\"));\n",
        "597": "  }\n",
        "598": "\n",
        "599": "  private static class NonNavigableSortedSet\n",
        "600": "      extends ForwardingSortedSet<String> {\n",
        "601": "    private final SortedSet<String> delegate = Sets.newTreeSet();\n",
        "602": "\n",
        "603": "    @Override\n",
        "604": "    protected SortedSet<String> delegate() {\n",
        "605": "      return delegate;\n",
        "606": "    }\n",
        "607": "  }\n",
        "608": "\n",
        "609": "  public void testAsMapReturnsSortedMapForSortedSetInput() {\n",
        "610": "    Set<String> set = new NonNavigableSortedSet();\n",
        "611": "    assertTrue(Maps.asMap(set, Functions.identity()) instanceof SortedMap);\n",
        "612": "  }\n",
        "613": "\n",
        "614": "  public void testAsMapSorted() {\n",
        "615": "    SortedSet<String> strings = new NonNavigableSortedSet();\n",
        "616": "    Collections.addAll(strings, \"one\", \"two\", \"three\");\n",
        "617": "    SortedMap<String, Integer> map = Maps.asMap(strings, LENGTH_FUNCTION);\n",
        "618": "    assertEquals(ImmutableMap.of(\"one\", 3, \"two\", 3, \"three\", 5), map);\n",
        "619": "    assertEquals(Integer.valueOf(5), map.get(\"three\"));\n",
        "620": "    assertNull(map.get(\"five\"));\n",
        "621": "    assertThat(map.entrySet()).containsExactly(\n",
        "622": "        mapEntry(\"one\", 3),\n",
        "623": "        mapEntry(\"three\", 5),\n",
        "624": "        mapEntry(\"two\", 3)).inOrder();\n",
        "625": "    assertThat(map.tailMap(\"onea\").entrySet()).containsExactly(\n",
        "626": "        mapEntry(\"three\", 5),\n",
        "627": "        mapEntry(\"two\", 3)).inOrder();\n",
        "628": "    assertThat(map.subMap(\"one\", \"two\").entrySet()).containsExactly(\n",
        "629": "        mapEntry(\"one\", 3),\n",
        "630": "        mapEntry(\"three\", 5)).inOrder();\n",
        "631": "  }\n",
        "632": "\n",
        "633": "  public void testAsMapSortedReadsThrough() {\n",
        "634": "    SortedSet<String> strings = new NonNavigableSortedSet();\n",
        "635": "    Collections.addAll(strings, \"one\", \"two\", \"three\");\n",
        "636": "    SortedMap<String, Integer> map = Maps.asMap(strings, LENGTH_FUNCTION);\n",
        "637": "    assertNull(map.comparator());\n",
        "638": "    assertEquals(ImmutableSortedMap.of(\"one\", 3, \"two\", 3, \"three\", 5), map);\n",
        "639": "    assertNull(map.get(\"four\"));\n",
        "640": "    strings.add(\"four\");\n",
        "641": "    assertEquals(\n",
        "642": "        ImmutableSortedMap.of(\"one\", 3, \"two\", 3, \"three\", 5, \"four\", 4),\n",
        "643": "        map);\n",
        "644": "    assertEquals(Integer.valueOf(4), map.get(\"four\"));\n",
        "645": "    SortedMap<String, Integer> headMap = map.headMap(\"two\");\n",
        "646": "    assertEquals(\n",
        "647": "        ImmutableSortedMap.of(\"four\", 4, \"one\", 3, \"three\", 5),\n",
        "648": "        headMap);\n",
        "649": "    strings.add(\"five\");\n",
        "650": "    strings.remove(\"one\");\n",
        "651": "    assertEquals(\n",
        "652": "        ImmutableSortedMap.of(\"five\", 4, \"four\", 4, \"three\", 5),\n",
        "653": "        headMap);\n",
        "654": "    assertThat(map.entrySet()).containsExactly(\n",
        "655": "        mapEntry(\"five\", 4),\n",
        "656": "        mapEntry(\"four\", 4),\n",
        "657": "        mapEntry(\"three\", 5),\n",
        "658": "        mapEntry(\"two\", 3)).inOrder();\n",
        "659": "  }\n",
        "660": "\n",
        "661": "  public void testAsMapSortedWritesThrough() {\n",
        "662": "    SortedSet<String> strings = new NonNavigableSortedSet();\n",
        "663": "    Collections.addAll(strings, \"one\", \"two\", \"three\");\n",
        "664": "    SortedMap<String, Integer> map = Maps.asMap(strings, LENGTH_FUNCTION);\n",
        "665": "    assertEquals(ImmutableMap.of(\"one\", 3, \"two\", 3, \"three\", 5), map);\n",
        "666": "    assertEquals(Integer.valueOf(3), map.remove(\"two\"));\n",
        "667": "    assertThat(strings).containsExactly(\"one\", \"three\").inOrder();\n",
        "668": "  }\n",
        "669": "\n",
        "670": "  public void testAsMapSortedSubViewKeySetsDoNotSupportAdd() {\n",
        "671": "    SortedMap<String, Integer> map = Maps.asMap(\n",
        "672": "        new NonNavigableSortedSet(), LENGTH_FUNCTION);\n",
        "673": "    try {\n",
        "674": "      map.subMap(\"a\", \"z\").keySet().add(\"a\");\n",
        "675": "      fail();\n",
        "676": "    } catch (UnsupportedOperationException expected) {\n",
        "677": "    }\n",
        "678": "    try {\n",
        "679": "      map.tailMap(\"a\").keySet().add(\"a\");\n",
        "680": "      fail();\n",
        "681": "    } catch (UnsupportedOperationException expected) {\n",
        "682": "    }\n",
        "683": "    try {\n",
        "684": "      map.headMap(\"r\").keySet().add(\"a\");\n",
        "685": "      fail();\n",
        "686": "    } catch (UnsupportedOperationException expected) {\n",
        "687": "    }\n",
        "688": "    try {\n",
        "689": "      map.headMap(\"r\").tailMap(\"m\").keySet().add(\"a\");\n",
        "690": "      fail();\n",
        "691": "    } catch (UnsupportedOperationException expected) {\n",
        "692": "    }\n",
        "693": "  }\n",
        "694": "\n",
        "695": "  public void testAsMapSortedEmpty() {\n",
        "696": "    SortedSet<String> strings = new NonNavigableSortedSet();\n",
        "697": "    SortedMap<String, Integer> map = Maps.asMap(strings, LENGTH_FUNCTION);\n",
        "698": "    assertThat(map.entrySet()).isEmpty();\n",
        "699": "    assertTrue(map.isEmpty());\n",
        "700": "    assertNull(map.get(\"five\"));\n",
        "701": "  }\n",
        "702": "\n",
        "703": "  public void testToMap() {\n",
        "704": "    Iterable<String> strings = ImmutableList.of(\"one\", \"two\", \"three\");\n",
        "705": "    ImmutableMap<String, Integer> map = Maps.toMap(strings, LENGTH_FUNCTION);\n",
        "706": "    assertEquals(ImmutableMap.of(\"one\", 3, \"two\", 3, \"three\", 5), map);\n",
        "707": "    assertThat(map.entrySet()).containsExactly(\n",
        "708": "        mapEntry(\"one\", 3),\n",
        "709": "        mapEntry(\"two\", 3),\n",
        "710": "        mapEntry(\"three\", 5)).inOrder();\n",
        "711": "  }\n",
        "712": "\n",
        "713": "  public void testToMapIterator() {\n",
        "714": "    Iterator<String> strings = ImmutableList.of(\"one\", \"two\", \"three\").iterator();\n",
        "715": "    ImmutableMap<String, Integer> map = Maps.toMap(strings, LENGTH_FUNCTION);\n",
        "716": "    assertEquals(ImmutableMap.of(\"one\", 3, \"two\", 3, \"three\", 5), map);\n",
        "717": "    assertThat(map.entrySet()).containsExactly(\n",
        "718": "        mapEntry(\"one\", 3),\n",
        "719": "        mapEntry(\"two\", 3),\n",
        "720": "        mapEntry(\"three\", 5)).inOrder();\n",
        "721": "  }\n",
        "722": "\n",
        "723": "  public void testToMapWithDuplicateKeys() {\n",
        "724": "    Iterable<String> strings = ImmutableList.of(\"one\", \"two\", \"three\", \"two\", \"one\");\n",
        "725": "    ImmutableMap<String, Integer> map = Maps.toMap(strings, LENGTH_FUNCTION);\n",
        "726": "    assertEquals(ImmutableMap.of(\"one\", 3, \"two\", 3, \"three\", 5), map);\n",
        "727": "    assertThat(map.entrySet()).containsExactly(\n",
        "728": "        mapEntry(\"one\", 3),\n",
        "729": "        mapEntry(\"two\", 3),\n",
        "730": "        mapEntry(\"three\", 5)).inOrder();\n",
        "731": "  }\n",
        "732": "\n",
        "733": "  public void testToMapWithNullKeys() {\n",
        "734": "    Iterable<String> strings = Arrays.asList(\"one\", null, \"three\");\n",
        "735": "    try {\n",
        "736": "      Maps.toMap(strings, Functions.constant(\"foo\"));\n",
        "737": "      fail();\n",
        "738": "    } catch (NullPointerException expected) {\n",
        "739": "    }\n",
        "740": "  }\n",
        "741": "\n",
        "742": "  public void testToMapWithNullValues() {\n",
        "743": "    Iterable<String> strings = ImmutableList.of(\"one\", \"two\", \"three\");\n",
        "744": "    try {\n",
        "745": "      Maps.toMap(strings, Functions.constant(null));\n",
        "746": "      fail();\n",
        "747": "    } catch (NullPointerException expected) {\n",
        "748": "    }\n",
        "749": "  }\n",
        "750": "\n",
        "751": "  private static final BiMap<Integer, String> INT_TO_STRING_MAP =\n",
        "752": "      new ImmutableBiMap.Builder<Integer, String>()\n",
        "753": "          .put(1, \"one\")\n",
        "754": "          .put(2, \"two\")\n",
        "755": "          .put(3, \"three\")\n",
        "756": "          .build();\n",
        "757": "\n",
        "758": "  public void testUniqueIndexCollection() {\n",
        "759": "    ImmutableMap<Integer, String> outputMap =\n",
        "760": "        Maps.uniqueIndex(INT_TO_STRING_MAP.values(),\n",
        "761": "            Functions.forMap(INT_TO_STRING_MAP.inverse()));\n",
        "762": "    assertEquals(INT_TO_STRING_MAP, outputMap);\n",
        "763": "  }\n",
        "764": "\n",
        "765": "  public void testUniqueIndexIterable() {\n",
        "766": "    ImmutableMap<Integer, String> outputMap =\n",
        "767": "        Maps.uniqueIndex(new Iterable<String>() {\n",
        "768": "          @Override\n",
        "769": "          public Iterator<String> iterator() {\n",
        "770": "            return INT_TO_STRING_MAP.values().iterator();\n",
        "771": "          }\n",
        "772": "        },\n",
        "773": "        Functions.forMap(INT_TO_STRING_MAP.inverse()));\n",
        "774": "    assertEquals(INT_TO_STRING_MAP, outputMap);\n",
        "775": "  }\n",
        "776": "\n",
        "777": "  public void testUniqueIndexIterator() {\n",
        "778": "    ImmutableMap<Integer, String> outputMap =\n",
        "779": "        Maps.uniqueIndex(INT_TO_STRING_MAP.values().iterator(),\n",
        "780": "            Functions.forMap(INT_TO_STRING_MAP.inverse()));\n",
        "781": "    assertEquals(INT_TO_STRING_MAP, outputMap);\n",
        "782": "  }\n",
        "783": "\n",
        "784": "  /** Can't create the map if more than one value maps to the same key. */\n",
        "785": "  public void testUniqueIndexDuplicates() {\n",
        "786": "    try {\n",
        "787": "      Maps.uniqueIndex(ImmutableSet.of(\"one\", \"uno\"), Functions.constant(1));\n",
        "788": "      fail();\n",
        "789": "    } catch (IllegalArgumentException expected) {\n",
        "790": "      assertThat(expected.getMessage()).contains(\"Multimaps.index\");\n",
        "791": "    }\n",
        "792": "  }\n",
        "793": "\n",
        "794": "  /** Null values are not allowed. */\n",
        "795": "  public void testUniqueIndexNullValue() {\n",
        "796": "    List<String> listWithNull = Lists.newArrayList((String) null);\n",
        "797": "    try {\n",
        "798": "      Maps.uniqueIndex(listWithNull, Functions.constant(1));\n",
        "799": "      fail();\n",
        "800": "    } catch (NullPointerException expected) {\n",
        "801": "    }\n",
        "802": "  }\n",
        "803": "\n",
        "804": "  /** Null keys aren't allowed either. */\n",
        "805": "  public void testUniqueIndexNullKey() {\n",
        "806": "    List<String> oneStringList = Lists.newArrayList(\"foo\");\n",
        "807": "    try {\n",
        "808": "      Maps.uniqueIndex(oneStringList, Functions.constant(null));\n",
        "809": "      fail();\n",
        "810": "    } catch (NullPointerException expected) {\n",
        "811": "    }\n",
        "812": "  }\n",
        "813": "\n",
        "814": "  public void testAsConverter_nominal() throws Exception {\n",
        "815": "    ImmutableBiMap<String, Integer> biMap = ImmutableBiMap.of(\n",
        "816": "        \"one\", 1,\n",
        "817": "        \"two\", 2);\n",
        "818": "    Converter<String, Integer> converter = Maps.asConverter(biMap);\n",
        "819": "    for (Entry<String, Integer> entry : biMap.entrySet()) {\n",
        "820": "      assertSame(entry.getValue(), converter.convert(entry.getKey()));\n",
        "821": "    }\n",
        "822": "  }\n",
        "823": "\n",
        "824": "  public void testAsConverter_inverse() throws Exception {\n",
        "825": "    ImmutableBiMap<String, Integer> biMap = ImmutableBiMap.of(\n",
        "826": "        \"one\", 1,\n",
        "827": "        \"two\", 2);\n",
        "828": "    Converter<String, Integer> converter = Maps.asConverter(biMap);\n",
        "829": "    for (Entry<String, Integer> entry : biMap.entrySet()) {\n",
        "830": "      assertSame(entry.getKey(), converter.reverse().convert(entry.getValue()));\n",
        "831": "    }\n",
        "832": "  }\n",
        "833": "\n",
        "834": "  public void testAsConverter_noMapping() throws Exception {\n",
        "835": "    ImmutableBiMap<String, Integer> biMap = ImmutableBiMap.of(\n",
        "836": "        \"one\", 1,\n",
        "837": "        \"two\", 2);\n",
        "838": "    Converter<String, Integer> converter = Maps.asConverter(biMap);\n",
        "839": "    try {\n",
        "840": "      converter.convert(\"three\");\n",
        "841": "      fail();\n",
        "842": "    } catch (IllegalArgumentException expected) {\n",
        "843": "    }\n",
        "844": "  }\n",
        "845": "\n",
        "846": "  public void testAsConverter_nullConversions() throws Exception {\n",
        "847": "    ImmutableBiMap<String, Integer> biMap = ImmutableBiMap.of(\n",
        "848": "        \"one\", 1,\n",
        "849": "        \"two\", 2);\n",
        "850": "    Converter<String, Integer> converter = Maps.asConverter(biMap);\n",
        "851": "    assertNull(converter.convert(null));\n",
        "852": "    assertNull(converter.reverse().convert(null));\n",
        "853": "  }\n",
        "854": "\n",
        "855": "  public void testAsConverter_isAView() throws Exception {\n",
        "856": "    BiMap<String, Integer> biMap = HashBiMap.create();\n",
        "857": "    biMap.put(\"one\", 1);\n",
        "858": "    biMap.put(\"two\", 2);\n",
        "859": "    Converter<String, Integer> converter = Maps.asConverter(biMap);\n",
        "860": "\n",
        "861": "    assertSame(1, converter.convert(\"one\"));\n",
        "862": "    assertSame(2, converter.convert(\"two\"));\n",
        "863": "    try {\n",
        "864": "      converter.convert(\"three\");\n",
        "865": "      fail();\n",
        "866": "    } catch (IllegalArgumentException expected) {\n",
        "867": "    }\n",
        "868": "\n",
        "869": "    biMap.put(\"three\", 3);\n",
        "870": "\n",
        "871": "    assertSame(1, converter.convert(\"one\"));\n",
        "872": "    assertSame(2, converter.convert(\"two\"));\n",
        "873": "    assertSame(3, converter.convert(\"three\"));\n",
        "874": "  }\n",
        "875": "\n",
        "876": "  public void testAsConverter_withNullMapping() throws Exception {\n",
        "877": "    BiMap<String, Integer> biMap = HashBiMap.create();\n",
        "878": "    biMap.put(\"one\", 1);\n",
        "879": "    biMap.put(\"two\", 2);\n",
        "880": "    biMap.put(\"three\", null);\n",
        "881": "    try {\n",
        "882": "      Maps.asConverter(biMap).convert(\"three\");\n",
        "883": "      fail();\n",
        "884": "    } catch (IllegalArgumentException expected) {\n",
        "885": "    }\n",
        "886": "  }\n",
        "887": "\n",
        "888": "  public void testAsConverter_toString() {\n",
        "889": "    ImmutableBiMap<String, Integer> biMap = ImmutableBiMap.of(\n",
        "890": "        \"one\", 1,\n",
        "891": "        \"two\", 2);\n",
        "892": "    Converter<String, Integer> converter = Maps.asConverter(biMap);\n",
        "893": "    assertEquals(\"Maps.asConverter({one=1, two=2})\", converter.toString());\n",
        "894": "  }\n",
        "895": "\n",
        "896": "  public void testAsConverter_serialization() {\n",
        "897": "    ImmutableBiMap<String, Integer> biMap = ImmutableBiMap.of(\n",
        "898": "        \"one\", 1,\n",
        "899": "        \"two\", 2);\n",
        "900": "    Converter<String, Integer> converter = Maps.asConverter(biMap);\n",
        "901": "    SerializableTester.reserializeAndAssert(converter);\n",
        "902": "  }\n",
        "903": "\n",
        "904": "  public void testUnmodifiableBiMap() {\n",
        "905": "    BiMap<Integer, String> mod = HashBiMap.create();\n",
        "906": "    mod.put(1, \"one\");\n",
        "907": "    mod.put(2, \"two\");\n",
        "908": "    mod.put(3, \"three\");\n",
        "909": "\n",
        "910": "    BiMap<Number, String> unmod = Maps.<Number, String>unmodifiableBiMap(mod);\n",
        "911": "\n",
        "912": "    /* No aliasing on inverse operations. */\n",
        "913": "    assertSame(unmod.inverse(), unmod.inverse());\n",
        "914": "    assertSame(unmod, unmod.inverse().inverse());\n",
        "915": "\n",
        "916": "    /* Unmodifiable is a view. */\n",
        "917": "    mod.put(4, \"four\");\n",
        "918": "    assertEquals(true, unmod.get(4).equals(\"four\"));\n",
        "919": "    assertEquals(true, unmod.inverse().get(\"four\").equals(4));\n",
        "920": "\n",
        "921": "    /* UnsupportedOperationException on direct modifications. */\n",
        "922": "    try {\n",
        "923": "      unmod.put(4, \"four\");\n",
        "924": "      fail(\"UnsupportedOperationException expected\");\n",
        "925": "    } catch (UnsupportedOperationException expected) {}\n",
        "926": "    try {\n",
        "927": "      unmod.forcePut(4, \"four\");\n",
        "928": "      fail(\"UnsupportedOperationException expected\");\n",
        "929": "    } catch (UnsupportedOperationException expected) {}\n",
        "930": "    try {\n",
        "931": "      unmod.putAll(Collections.singletonMap(4, \"four\"));\n",
        "932": "      fail(\"UnsupportedOperationException expected\");\n",
        "933": "    } catch (UnsupportedOperationException expected) {}\n",
        "934": "\n",
        "935": "    /* UnsupportedOperationException on indirect modifications. */\n",
        "936": "    BiMap<String, Number> inverse = unmod.inverse();\n",
        "937": "    try {\n",
        "938": "      inverse.put(\"four\", 4);\n",
        "939": "      fail(\"UnsupportedOperationException expected\");\n",
        "940": "    } catch (UnsupportedOperationException expected) {}\n",
        "941": "    try {\n",
        "942": "      inverse.forcePut(\"four\", 4);\n",
        "943": "      fail(\"UnsupportedOperationException expected\");\n",
        "944": "    } catch (UnsupportedOperationException expected) {}\n",
        "945": "    try {\n",
        "946": "      inverse.putAll(Collections.singletonMap(\"four\", 4));\n",
        "947": "      fail(\"UnsupportedOperationException expected\");\n",
        "948": "    } catch (UnsupportedOperationException expected) {}\n",
        "949": "    Set<String> values = unmod.values();\n",
        "950": "    try {\n",
        "951": "      values.remove(\"four\");\n",
        "952": "      fail(\"UnsupportedOperationException expected\");\n",
        "953": "    } catch (UnsupportedOperationException expected) {}\n",
        "954": "    Set<Map.Entry<Number, String>> entries = unmod.entrySet();\n",
        "955": "    Map.Entry<Number, String> entry = entries.iterator().next();\n",
        "956": "    try {\n",
        "957": "      entry.setValue(\"four\");\n",
        "958": "      fail(\"UnsupportedOperationException expected\");\n",
        "959": "    } catch (UnsupportedOperationException expected) {}\n",
        "960": "    @SuppressWarnings(\"unchecked\")\n",
        "961": "    Map.Entry<Integer, String> entry2\n",
        "962": "        = (Map.Entry<Integer, String>) entries.toArray()[0];\n",
        "963": "    try {\n",
        "964": "      entry2.setValue(\"four\");\n",
        "965": "      fail(\"UnsupportedOperationException expected\");\n",
        "966": "    } catch (UnsupportedOperationException expected) {}\n",
        "967": "  }\n",
        "968": "\n",
        "969": "  public void testImmutableEntry() {\n",
        "970": "    Map.Entry<String, Integer> e = Maps.immutableEntry(\"foo\", 1);\n",
        "971": "    assertEquals(\"foo\", e.getKey());\n",
        "972": "    assertEquals(1, (int) e.getValue());\n",
        "973": "    try {\n",
        "974": "      e.setValue(2);\n",
        "975": "      fail(\"UnsupportedOperationException expected\");\n",
        "976": "    } catch (UnsupportedOperationException expected) {}\n",
        "977": "    assertEquals(\"foo=1\", e.toString());\n",
        "978": "    assertEquals(101575, e.hashCode());\n",
        "979": "  }\n",
        "980": "\n",
        "981": "  public void testImmutableEntryNull() {\n",
        "982": "    Map.Entry<String, Integer> e\n",
        "983": "        = Maps.immutableEntry((String) null, (Integer) null);\n",
        "984": "    assertNull(e.getKey());\n",
        "985": "    assertNull(e.getValue());\n",
        "986": "    try {\n",
        "987": "      e.setValue(null);\n",
        "988": "      fail(\"UnsupportedOperationException expected\");\n",
        "989": "    } catch (UnsupportedOperationException expected) {}\n",
        "990": "    assertEquals(\"null=null\", e.toString());\n",
        "991": "    assertEquals(0, e.hashCode());\n",
        "992": "  }\n",
        "993": "\n",
        "994": "  /** See {@link SynchronizedBiMapTest} for more tests. */\n",
        "995": "  public void testSynchronizedBiMap() {\n",
        "996": "    BiMap<String, Integer> bimap = HashBiMap.create();\n",
        "997": "    bimap.put(\"one\", 1);\n",
        "998": "    BiMap<String, Integer> sync = Maps.synchronizedBiMap(bimap);\n",
        "999": "    bimap.put(\"two\", 2);\n",
        "1000": "    sync.put(\"three\", 3);\n",
        "1001": "    assertEquals(ImmutableSet.of(1, 2, 3), bimap.inverse().keySet());\n",
        "1002": "    assertEquals(ImmutableSet.of(1, 2, 3), sync.inverse().keySet());\n",
        "1003": "  }\n",
        "1004": "\n",
        "1005": "  private static final Predicate<String> NOT_LENGTH_3\n",
        "1006": "      = new Predicate<String>() {\n",
        "1007": "        @Override\n",
        "1008": "        public boolean apply(String input) {\n",
        "1009": "          return input == null || input.length() != 3;\n",
        "1010": "        }\n",
        "1011": "      };\n",
        "1012": "\n",
        "1013": "  private static final Predicate<Integer> EVEN\n",
        "1014": "      = new Predicate<Integer>() {\n",
        "1015": "        @Override\n",
        "1016": "        public boolean apply(Integer input) {\n",
        "1017": "          return input == null || input % 2 == 0;\n",
        "1018": "        }\n",
        "1019": "      };\n",
        "1020": "\n",
        "1021": "  private static final Predicate<Entry<String, Integer>> CORRECT_LENGTH\n",
        "1022": "      = new Predicate<Entry<String, Integer>>() {\n",
        "1023": "        @Override\n",
        "1024": "        public boolean apply(Entry<String, Integer> input) {\n",
        "1025": "          return input.getKey().length() == input.getValue();\n",
        "1026": "        }\n",
        "1027": "      };\n",
        "1028": "\n",
        "1029": "  private static final Function<Integer, Double> SQRT_FUNCTION = new Function<Integer, Double>() {\n",
        "1030": "      @Override\n",
        "1031": "      public Double apply(Integer in) {\n",
        "1032": "        return Math.sqrt(in);\n",
        "1033": "      }\n",
        "1034": "    };\n",
        "1035": "\n",
        "1036": "  public static class FilteredMapTest extends TestCase {\n",
        "1037": "    Map<String, Integer> createUnfiltered() {\n",
        "1038": "      return Maps.newHashMap();\n",
        "1039": "    }\n",
        "1040": "\n",
        "1041": "    public void testFilteredKeysIllegalPut() {\n",
        "1042": "      Map<String, Integer> unfiltered = createUnfiltered();\n",
        "1043": "      Map<String, Integer> filtered = Maps.filterKeys(unfiltered, NOT_LENGTH_3);\n",
        "1044": "      filtered.put(\"a\", 1);\n",
        "1045": "      filtered.put(\"b\", 2);\n",
        "1046": "      assertEquals(ImmutableMap.of(\"a\", 1, \"b\", 2), filtered);\n",
        "1047": "\n",
        "1048": "      try {\n",
        "1049": "        filtered.put(\"yyy\", 3);\n",
        "1050": "        fail();\n",
        "1051": "      } catch (IllegalArgumentException expected) {}\n",
        "1052": "    }\n",
        "1053": "\n",
        "1054": "    public void testFilteredKeysIllegalPutAll() {\n",
        "1055": "      Map<String, Integer> unfiltered = createUnfiltered();\n",
        "1056": "      Map<String, Integer> filtered = Maps.filterKeys(unfiltered, NOT_LENGTH_3);\n",
        "1057": "      filtered.put(\"a\", 1);\n",
        "1058": "      filtered.put(\"b\", 2);\n",
        "1059": "      assertEquals(ImmutableMap.of(\"a\", 1, \"b\", 2), filtered);\n",
        "1060": "\n",
        "1061": "      try {\n",
        "1062": "        filtered.putAll(ImmutableMap.of(\"c\", 3, \"zzz\", 4, \"b\", 5));\n",
        "1063": "        fail();\n",
        "1064": "      } catch (IllegalArgumentException expected) {}\n",
        "1065": "\n",
        "1066": "      assertEquals(ImmutableMap.of(\"a\", 1, \"b\", 2), filtered);\n",
        "1067": "    }\n",
        "1068": "\n",
        "1069": "    public void testFilteredKeysFilteredReflectsBackingChanges() {\n",
        "1070": "      Map<String, Integer> unfiltered = createUnfiltered();\n",
        "1071": "      Map<String, Integer> filtered = Maps.filterKeys(unfiltered, NOT_LENGTH_3);\n",
        "1072": "      unfiltered.put(\"two\", 2);\n",
        "1073": "      unfiltered.put(\"three\", 3);\n",
        "1074": "      unfiltered.put(\"four\", 4);\n",
        "1075": "      assertEquals(ImmutableMap.of(\"two\", 2, \"three\", 3, \"four\", 4), unfiltered);\n",
        "1076": "      assertEquals(ImmutableMap.of(\"three\", 3, \"four\", 4), filtered);\n",
        "1077": "\n",
        "1078": "      unfiltered.remove(\"three\");\n",
        "1079": "      assertEquals(ImmutableMap.of(\"two\", 2, \"four\", 4), unfiltered);\n",
        "1080": "      assertEquals(ImmutableMap.of(\"four\", 4), filtered);\n",
        "1081": "\n",
        "1082": "      unfiltered.clear();\n",
        "1083": "      assertEquals(ImmutableMap.of(), unfiltered);\n",
        "1084": "      assertEquals(ImmutableMap.of(), filtered);\n",
        "1085": "    }\n",
        "1086": "\n",
        "1087": "    public void testFilteredValuesIllegalPut() {\n",
        "1088": "      Map<String, Integer> unfiltered = createUnfiltered();\n",
        "1089": "      Map<String, Integer> filtered = Maps.filterValues(unfiltered, EVEN);\n",
        "1090": "      filtered.put(\"a\", 2);\n",
        "1091": "      unfiltered.put(\"b\", 4);\n",
        "1092": "      unfiltered.put(\"c\", 5);\n",
        "1093": "      assertEquals(ImmutableMap.of(\"a\", 2, \"b\", 4), filtered);\n",
        "1094": "\n",
        "1095": "      try {\n",
        "1096": "        filtered.put(\"yyy\", 3);\n",
        "1097": "        fail();\n",
        "1098": "      } catch (IllegalArgumentException expected) {}\n",
        "1099": "      assertEquals(ImmutableMap.of(\"a\", 2, \"b\", 4), filtered);\n",
        "1100": "    }\n",
        "1101": "\n",
        "1102": "    public void testFilteredValuesIllegalPutAll() {\n",
        "1103": "      Map<String, Integer> unfiltered = createUnfiltered();\n",
        "1104": "      Map<String, Integer> filtered = Maps.filterValues(unfiltered, EVEN);\n",
        "1105": "      filtered.put(\"a\", 2);\n",
        "1106": "      unfiltered.put(\"b\", 4);\n",
        "1107": "      unfiltered.put(\"c\", 5);\n",
        "1108": "      assertEquals(ImmutableMap.of(\"a\", 2, \"b\", 4), filtered);\n",
        "1109": "\n",
        "1110": "      try {\n",
        "1111": "        filtered.putAll(ImmutableMap.of(\"c\", 4, \"zzz\", 5, \"b\", 6));\n",
        "1112": "        fail();\n",
        "1113": "      } catch (IllegalArgumentException expected) {}\n",
        "1114": "      assertEquals(ImmutableMap.of(\"a\", 2, \"b\", 4), filtered);\n",
        "1115": "    }\n",
        "1116": "\n",
        "1117": "    public void testFilteredValuesIllegalSetValue() {\n",
        "1118": "      Map<String, Integer> unfiltered = createUnfiltered();\n",
        "1119": "      Map<String, Integer> filtered = Maps.filterValues(unfiltered, EVEN);\n",
        "1120": "      filtered.put(\"a\", 2);\n",
        "1121": "      filtered.put(\"b\", 4);\n",
        "1122": "      assertEquals(ImmutableMap.of(\"a\", 2, \"b\", 4), filtered);\n",
        "1123": "\n",
        "1124": "      Entry<String, Integer> entry = filtered.entrySet().iterator().next();\n",
        "1125": "      try {\n",
        "1126": "        entry.setValue(5);\n",
        "1127": "        fail();\n",
        "1128": "      } catch (IllegalArgumentException expected) {}\n",
        "1129": "\n",
        "1130": "      assertEquals(ImmutableMap.of(\"a\", 2, \"b\", 4), filtered);\n",
        "1131": "    }\n",
        "1132": "\n",
        "1133": "    public void testFilteredValuesClear() {\n",
        "1134": "      Map<String, Integer> unfiltered = createUnfiltered();\n",
        "1135": "      unfiltered.put(\"one\", 1);\n",
        "1136": "      unfiltered.put(\"two\", 2);\n",
        "1137": "      unfiltered.put(\"three\", 3);\n",
        "1138": "      unfiltered.put(\"four\", 4);\n",
        "1139": "      Map<String, Integer> filtered = Maps.filterValues(unfiltered, EVEN);\n",
        "1140": "      assertEquals(ImmutableMap.of(\"one\", 1, \"two\", 2, \"three\", 3, \"four\", 4),\n",
        "1141": "          unfiltered);\n",
        "1142": "      assertEquals(ImmutableMap.of(\"two\", 2, \"four\", 4), filtered);\n",
        "1143": "\n",
        "1144": "      filtered.clear();\n",
        "1145": "      assertEquals(ImmutableMap.of(\"one\", 1, \"three\", 3), unfiltered);\n",
        "1146": "      assertTrue(filtered.isEmpty());\n",
        "1147": "    }\n",
        "1148": "\n",
        "1149": "    public void testFilteredEntriesIllegalPut() {\n",
        "1150": "      Map<String, Integer> unfiltered = createUnfiltered();\n",
        "1151": "      unfiltered.put(\"cat\", 3);\n",
        "1152": "      unfiltered.put(\"dog\", 2);\n",
        "1153": "      unfiltered.put(\"horse\", 5);\n",
        "1154": "      Map<String, Integer> filtered\n",
        "1155": "          = Maps.filterEntries(unfiltered, CORRECT_LENGTH);\n",
        "1156": "      assertEquals(ImmutableMap.of(\"cat\", 3, \"horse\", 5), filtered);\n",
        "1157": "\n",
        "1158": "      filtered.put(\"chicken\", 7);\n",
        "1159": "      assertEquals(ImmutableMap.of(\"cat\", 3, \"horse\", 5, \"chicken\", 7), filtered);\n",
        "1160": "\n",
        "1161": "      try {\n",
        "1162": "        filtered.put(\"cow\", 7);\n",
        "1163": "        fail();\n",
        "1164": "      } catch (IllegalArgumentException expected) {}\n",
        "1165": "      assertEquals(ImmutableMap.of(\"cat\", 3, \"horse\", 5, \"chicken\", 7), filtered);\n",
        "1166": "    }\n",
        "1167": "\n",
        "1168": "    public void testFilteredEntriesIllegalPutAll() {\n",
        "1169": "      Map<String, Integer> unfiltered = createUnfiltered();\n",
        "1170": "      unfiltered.put(\"cat\", 3);\n",
        "1171": "      unfiltered.put(\"dog\", 2);\n",
        "1172": "      unfiltered.put(\"horse\", 5);\n",
        "1173": "      Map<String, Integer> filtered\n",
        "1174": "          = Maps.filterEntries(unfiltered, CORRECT_LENGTH);\n",
        "1175": "      assertEquals(ImmutableMap.of(\"cat\", 3, \"horse\", 5), filtered);\n",
        "1176": "\n",
        "1177": "      filtered.put(\"chicken\", 7);\n",
        "1178": "      assertEquals(ImmutableMap.of(\"cat\", 3, \"horse\", 5, \"chicken\", 7), filtered);\n",
        "1179": "\n",
        "1180": "      try {\n",
        "1181": "        filtered.putAll(ImmutableMap.of(\"sheep\", 5, \"cow\", 7));\n",
        "1182": "        fail();\n",
        "1183": "      } catch (IllegalArgumentException expected) {}\n",
        "1184": "      assertEquals(ImmutableMap.of(\"cat\", 3, \"horse\", 5, \"chicken\", 7), filtered);\n",
        "1185": "    }\n",
        "1186": "\n",
        "1187": "    public void testFilteredEntriesObjectPredicate() {\n",
        "1188": "      Map<String, Integer> unfiltered = createUnfiltered();\n",
        "1189": "      unfiltered.put(\"cat\", 3);\n",
        "1190": "      unfiltered.put(\"dog\", 2);\n",
        "1191": "      unfiltered.put(\"horse\", 5);\n",
        "1192": "      Predicate<Object> predicate = Predicates.alwaysFalse();\n",
        "1193": "      Map<String, Integer> filtered\n",
        "1194": "          = Maps.filterEntries(unfiltered, predicate);\n",
        "1195": "      assertTrue(filtered.isEmpty());\n",
        "1196": "    }\n",
        "1197": "\n",
        "1198": "    public void testFilteredEntriesWildCardEntryPredicate() {\n",
        "1199": "      Map<String, Integer> unfiltered = createUnfiltered();\n",
        "1200": "      unfiltered.put(\"cat\", 3);\n",
        "1201": "      unfiltered.put(\"dog\", 2);\n",
        "1202": "      unfiltered.put(\"horse\", 5);\n",
        "1203": "      Predicate<Entry<?, ?>> predicate = new Predicate<Entry<?, ?>>() {\n",
        "1204": "        @Override\n",
        "1205": "        public boolean apply(Entry<?, ?> input) {\n",
        "1206": "          return \"cat\".equals(input.getKey())\n",
        "1207": "              || Integer.valueOf(2) == input.getValue();\n",
        "1208": "        }\n",
        "1209": "      };\n",
        "1210": "      Map<String, Integer> filtered\n",
        "1211": "          = Maps.filterEntries(unfiltered, predicate);\n",
        "1212": "      assertEquals(ImmutableMap.of(\"cat\", 3, \"dog\", 2), filtered);\n",
        "1213": "    }\n",
        "1214": "  }\n",
        "1215": "\n",
        "1216": "  public static class FilteredSortedMapTest extends FilteredMapTest {\n",
        "1217": "    @Override\n",
        "1218": "    SortedMap<String, Integer> createUnfiltered() {\n",
        "1219": "      return Maps.newTreeMap();\n",
        "1220": "    }\n",
        "1221": "\n",
        "1222": "    public void testFilterKeysIdentifiesSortedMap() {\n",
        "1223": "      SortedMap<String, Integer> map = createUnfiltered();\n",
        "1224": "      assertTrue(Maps.filterKeys((Map<String, Integer>) map, NOT_LENGTH_3)\n",
        "1225": "          instanceof SortedMap);\n",
        "1226": "    }\n",
        "1227": "\n",
        "1228": "    public void testFilterValuesIdentifiesSortedMap() {\n",
        "1229": "      SortedMap<String, Integer> map = createUnfiltered();\n",
        "1230": "      assertTrue(Maps.filterValues((Map<String, Integer>) map, EVEN)\n",
        "1231": "          instanceof SortedMap);\n",
        "1232": "    }\n",
        "1233": "\n",
        "1234": "    public void testFilterEntriesIdentifiesSortedMap() {\n",
        "1235": "      SortedMap<String, Integer> map = createUnfiltered();\n",
        "1236": "      assertTrue(Maps.filterEntries((Map<String, Integer>) map, CORRECT_LENGTH)\n",
        "1237": "          instanceof SortedMap);\n",
        "1238": "    }\n",
        "1239": "\n",
        "1240": "    public void testFirstAndLastKeyFilteredMap() {\n",
        "1241": "      SortedMap<String, Integer> unfiltered = createUnfiltered();\n",
        "1242": "      unfiltered.put(\"apple\", 2);\n",
        "1243": "      unfiltered.put(\"banana\", 6);\n",
        "1244": "      unfiltered.put(\"cat\", 3);\n",
        "1245": "      unfiltered.put(\"dog\", 5);\n",
        "1246": "\n",
        "1247": "      SortedMap<String, Integer> filtered = Maps.filterEntries(unfiltered, CORRECT_LENGTH);\n",
        "1248": "      assertEquals(\"banana\", filtered.firstKey());\n",
        "1249": "      assertEquals(\"cat\", filtered.lastKey());\n",
        "1250": "    }\n",
        "1251": "\n",
        "1252": "    public void testHeadSubTailMap_FilteredMap() {\n",
        "1253": "      SortedMap<String, Integer> unfiltered = createUnfiltered();\n",
        "1254": "      unfiltered.put(\"apple\", 2);\n",
        "1255": "      unfiltered.put(\"banana\", 6);\n",
        "1256": "      unfiltered.put(\"cat\", 4);\n",
        "1257": "      unfiltered.put(\"dog\", 3);\n",
        "1258": "      SortedMap<String, Integer> filtered = Maps.filterEntries(unfiltered, CORRECT_LENGTH);\n",
        "1259": "\n",
        "1260": "      assertEquals(ImmutableMap.of(\"banana\", 6), filtered.headMap(\"dog\"));\n",
        "1261": "      assertEquals(ImmutableMap.of(), filtered.headMap(\"banana\"));\n",
        "1262": "      assertEquals(ImmutableMap.of(\"banana\", 6, \"dog\", 3), filtered.headMap(\"emu\"));\n",
        "1263": "\n",
        "1264": "      assertEquals(ImmutableMap.of(\"banana\", 6), filtered.subMap(\"banana\", \"dog\"));\n",
        "1265": "      assertEquals(ImmutableMap.of(\"dog\", 3), filtered.subMap(\"cat\", \"emu\"));\n",
        "1266": "\n",
        "1267": "      assertEquals(ImmutableMap.of(\"dog\", 3), filtered.tailMap(\"cat\"));\n",
        "1268": "      assertEquals(ImmutableMap.of(\"banana\", 6, \"dog\", 3), filtered.tailMap(\"banana\"));\n",
        "1269": "    }\n",
        "1270": "  }\n",
        "1271": "\n",
        "1272": "  public static class FilteredBiMapTest extends FilteredMapTest {\n",
        "1273": "    @Override\n",
        "1274": "    BiMap<String, Integer> createUnfiltered() {\n",
        "1275": "      return HashBiMap.create();\n",
        "1276": "    }\n",
        "1277": "\n",
        "1278": "    public void testFilterKeysIdentifiesBiMap() {\n",
        "1279": "      BiMap<String, Integer> map = createUnfiltered();\n",
        "1280": "      assertTrue(Maps.filterKeys((Map<String, Integer>) map, NOT_LENGTH_3)\n",
        "1281": "          instanceof BiMap);\n",
        "1282": "    }\n",
        "1283": "\n",
        "1284": "    public void testFilterValuesIdentifiesBiMap() {\n",
        "1285": "      BiMap<String, Integer> map = createUnfiltered();\n",
        "1286": "      assertTrue(Maps.filterValues((Map<String, Integer>) map, EVEN)\n",
        "1287": "          instanceof BiMap);\n",
        "1288": "    }\n",
        "1289": "\n",
        "1290": "    public void testFilterEntriesIdentifiesBiMap() {\n",
        "1291": "      BiMap<String, Integer> map = createUnfiltered();\n",
        "1292": "      assertTrue(Maps.filterEntries((Map<String, Integer>) map, CORRECT_LENGTH)\n",
        "1293": "          instanceof BiMap);\n",
        "1294": "    }\n",
        "1295": "  }\n",
        "1296": "\n",
        "1297": "  public void testTransformValues() {\n",
        "1298": "    Map<String, Integer> map = ImmutableMap.of(\"a\", 4, \"b\", 9);\n",
        "1299": "    Map<String, Double> transformed = transformValues(map, SQRT_FUNCTION);\n",
        "1300": "\n",
        "1301": "    assertEquals(ImmutableMap.of(\"a\", 2.0, \"b\", 3.0), transformed);\n",
        "1302": "  }\n",
        "1303": "\n",
        "1304": "  public void testTransformValuesSecretlySorted() {\n",
        "1305": "    Map<String, Integer> map =\n",
        "1306": "        sortedNotNavigable(ImmutableSortedMap.of(\"a\", 4, \"b\", 9));\n",
        "1307": "    Map<String, Double> transformed = transformValues(map, SQRT_FUNCTION);\n",
        "1308": "\n",
        "1309": "    assertEquals(ImmutableMap.of(\"a\", 2.0, \"b\", 3.0), transformed);\n",
        "1310": "    assertTrue(transformed instanceof SortedMap);\n",
        "1311": "  }\n",
        "1312": "\n",
        "1313": "  public void testTransformEntries() {\n",
        "1314": "    Map<String, String> map = ImmutableMap.of(\"a\", \"4\", \"b\", \"9\");\n",
        "1315": "    EntryTransformer<String, String, String> concat =\n",
        "1316": "        new EntryTransformer<String, String, String>() {\n",
        "1317": "          @Override\n",
        "1318": "          public String transformEntry(String key, String value) {\n",
        "1319": "            return key + value;\n",
        "1320": "          }\n",
        "1321": "        };\n",
        "1322": "    Map<String, String> transformed = transformEntries(map, concat);\n",
        "1323": "\n",
        "1324": "    assertEquals(ImmutableMap.of(\"a\", \"a4\", \"b\", \"b9\"), transformed);\n",
        "1325": "  }\n",
        "1326": "\n",
        "1327": "  public void testTransformEntriesSecretlySorted() {\n",
        "1328": "    Map<String, String> map = ImmutableSortedMap.of(\"a\", \"4\", \"b\", \"9\");\n",
        "1329": "    EntryTransformer<String, String, String> concat =\n",
        "1330": "        new EntryTransformer<String, String, String>() {\n",
        "1331": "          @Override\n",
        "1332": "          public String transformEntry(String key, String value) {\n",
        "1333": "            return key + value;\n",
        "1334": "          }\n",
        "1335": "        };\n",
        "1336": "    Map<String, String> transformed = transformEntries(map, concat);\n",
        "1337": "\n",
        "1338": "    assertEquals(ImmutableMap.of(\"a\", \"a4\", \"b\", \"b9\"), transformed);\n",
        "1339": "    assertTrue(transformed instanceof SortedMap);\n",
        "1340": "  }\n",
        "1341": "\n",
        "1342": "  @SuppressWarnings(\"unused\")\n",
        "1343": "  public void testTransformEntriesGenerics() {\n",
        "1344": "    Map<Object, Object> map1 = ImmutableMap.<Object, Object>of(1, 2);\n",
        "1345": "    Map<Object, Number> map2 = ImmutableMap.<Object, Number>of(1, 2);\n",
        "1346": "    Map<Object, Integer> map3 = ImmutableMap.<Object, Integer>of(1, 2);\n",
        "1347": "    Map<Number, Object> map4 = ImmutableMap.<Number, Object>of(1, 2);\n",
        "1348": "    Map<Number, Number> map5 = ImmutableMap.<Number, Number>of(1, 2);\n",
        "1349": "    Map<Number, Integer> map6 = ImmutableMap.<Number, Integer>of(1, 2);\n",
        "1350": "    Map<Integer, Object> map7 = ImmutableMap.<Integer, Object>of(1, 2);\n",
        "1351": "    Map<Integer, Number> map8 = ImmutableMap.<Integer, Number>of(1, 2);\n",
        "1352": "    Map<Integer, Integer> map9 = ImmutableMap.<Integer, Integer>of(1, 2);\n",
        "1353": "    Map<? extends Number, ? extends Number> map0 = ImmutableMap.of(1, 2);\n",
        "1354": "\n",
        "1355": "    EntryTransformer<Number, Number, Double> transformer =\n",
        "1356": "        new EntryTransformer<Number, Number, Double>() {\n",
        "1357": "          @Override\n",
        "1358": "          public Double transformEntry(Number key, Number value) {\n",
        "1359": "            return key.doubleValue() + value.doubleValue();\n",
        "1360": "          }\n",
        "1361": "        };\n",
        "1362": "\n",
        "1363": "    Map<Object, Double> objectKeyed;\n",
        "1364": "    Map<Number, Double> numberKeyed;\n",
        "1365": "    Map<Integer, Double> integerKeyed;\n",
        "1366": "\n",
        "1367": "    numberKeyed = transformEntries(map5, transformer);\n",
        "1368": "    numberKeyed = transformEntries(map6, transformer);\n",
        "1369": "    integerKeyed = transformEntries(map8, transformer);\n",
        "1370": "    integerKeyed = transformEntries(map9, transformer);\n",
        "1371": "\n",
        "1372": "    Map<? extends Number, Double> wildcarded = transformEntries(map0, transformer);\n",
        "1373": "\n",
        "1374": "    // Can't loosen the key type:\n",
        "1375": "    // objectKeyed = transformEntries(map5, transformer);\n",
        "1376": "    // objectKeyed = transformEntries(map6, transformer);\n",
        "1377": "    // objectKeyed = transformEntries(map8, transformer);\n",
        "1378": "    // objectKeyed = transformEntries(map9, transformer);\n",
        "1379": "    // numberKeyed = transformEntries(map8, transformer);\n",
        "1380": "    // numberKeyed = transformEntries(map9, transformer);\n",
        "1381": "\n",
        "1382": "    // Can't loosen the value type:\n",
        "1383": "    // Map<Number, Number> looseValued1 = transformEntries(map5, transformer);\n",
        "1384": "    // Map<Number, Number> looseValued2 = transformEntries(map6, transformer);\n",
        "1385": "    // Map<Integer, Number> looseValued3 = transformEntries(map8, transformer);\n",
        "1386": "    // Map<Integer, Number> looseValued4 = transformEntries(map9, transformer);\n",
        "1387": "\n",
        "1388": "    // Can't call with too loose a key:\n",
        "1389": "    // transformEntries(map1, transformer);\n",
        "1390": "    // transformEntries(map2, transformer);\n",
        "1391": "    // transformEntries(map3, transformer);\n",
        "1392": "\n",
        "1393": "    // Can't call with too loose a value:\n",
        "1394": "    // transformEntries(map1, transformer);\n",
        "1395": "    // transformEntries(map4, transformer);\n",
        "1396": "    // transformEntries(map7, transformer);\n",
        "1397": "  }\n",
        "1398": "\n",
        "1399": "  public void testTransformEntriesExample() {\n",
        "1400": "    Map<String, Boolean> options =\n",
        "1401": "        ImmutableMap.of(\"verbose\", true, \"sort\", false);\n",
        "1402": "    EntryTransformer<String, Boolean, String> flagPrefixer =\n",
        "1403": "        new EntryTransformer<String, Boolean, String>() {\n",
        "1404": "          @Override\n",
        "1405": "          public String transformEntry(String key, Boolean value) {\n",
        "1406": "            return value ? key : \"no\" + key;\n",
        "1407": "          }\n",
        "1408": "        };\n",
        "1409": "    Map<String, String> transformed = transformEntries(options, flagPrefixer);\n",
        "1410": "    assertEquals(\"{verbose=verbose, sort=nosort}\", transformed.toString());\n",
        "1411": "  }\n",
        "1412": "\n",
        "1413": "  // Logically this would accept a NavigableMap, but that won't work under GWT.\n",
        "1414": "  private static <K, V> SortedMap<K, V> sortedNotNavigable(\n",
        "1415": "      final SortedMap<K, V> map) {\n",
        "1416": "    return new ForwardingSortedMap<K, V>() {\n",
        "1417": "      @Override protected SortedMap<K, V> delegate() {\n",
        "1418": "        return map;\n",
        "1419": "      }\n",
        "1420": "    };\n",
        "1421": "  }\n",
        "1422": "\n",
        "1423": "  public void testSortedMapTransformValues() {\n",
        "1424": "    SortedMap<String, Integer> map =\n",
        "1425": "        sortedNotNavigable(ImmutableSortedMap.of(\"a\", 4, \"b\", 9));\n",
        "1426": "    SortedMap<String, Double> transformed =\n",
        "1427": "        transformValues(map, SQRT_FUNCTION);\n",
        "1428": "\n",
        "1429": "    /*\n",
        "1430": "     * We'd like to sanity check that we didn't get a NavigableMap out, but we\n",
        "1431": "     * can't easily do so while maintaining GWT compatibility.\n",
        "1432": "     */\n",
        "1433": "    assertEquals(ImmutableSortedMap.of(\"a\", 2.0, \"b\", 3.0), transformed);\n",
        "1434": "  }\n",
        "1435": "\n",
        "1436": "  public void testSortedMapTransformEntries() {\n",
        "1437": "    SortedMap<String, String> map =\n",
        "1438": "        sortedNotNavigable(ImmutableSortedMap.of(\"a\", \"4\", \"b\", \"9\"));\n",
        "1439": "    EntryTransformer<String, String, String> concat =\n",
        "1440": "        new EntryTransformer<String, String, String>() {\n",
        "1441": "          @Override\n",
        "1442": "          public String transformEntry(String key, String value) {\n",
        "1443": "            return key + value;\n",
        "1444": "          }\n",
        "1445": "        };\n",
        "1446": "    SortedMap<String, String> transformed = transformEntries(map, concat);\n",
        "1447": "\n",
        "1448": "    /*\n",
        "1449": "     * We'd like to sanity check that we didn't get a NavigableMap out, but we\n",
        "1450": "     * can't easily do so while maintaining GWT compatibility.\n",
        "1451": "     */\n",
        "1452": "    assertEquals(ImmutableSortedMap.of(\"a\", \"a4\", \"b\", \"b9\"), transformed);\n",
        "1453": "  }\n",
        "1454": "}\n",
        "1455": "\n"
    }
}