{
    "addition": {},
    "removed": {
        "1": "/*\n",
        "2": " * Copyright (C) 2007 The Guava Authors\n",
        "3": " *\n",
        "4": " * Licensed under the Apache License, Version 2.0 (the \"License\");\n",
        "5": " * you may not use this file except in compliance with the License.\n",
        "6": " * You may obtain a copy of the License at\n",
        "7": " *\n",
        "8": " * http://www.apache.org/licenses/LICENSE-2.0\n",
        "9": " *\n",
        "10": " * Unless required by applicable law or agreed to in writing, software\n",
        "11": " * distributed under the License is distributed on an \"AS IS\" BASIS,\n",
        "12": " * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n",
        "13": " * See the License for the specific language governing permissions and\n",
        "14": " * limitations under the License.\n",
        "15": " */\n",
        "16": "\n",
        "17": "package com.google.common.collect;\n",
        "18": "\n",
        "19": "import static com.google.common.base.Preconditions.checkArgument;\n",
        "20": "import static com.google.common.collect.Lists.newArrayList;\n",
        "21": "import static com.google.common.testing.SerializableTester.reserialize;\n",
        "22": "import static com.google.common.testing.SerializableTester.reserializeAndAssert;\n",
        "23": "import static com.google.common.truth.Truth.assertThat;\n",
        "24": "import static java.util.Arrays.asList;\n",
        "25": "\n",
        "26": "import com.google.common.annotations.GwtCompatible;\n",
        "27": "import com.google.common.base.Function;\n",
        "28": "import com.google.common.base.Functions;\n",
        "29": "import com.google.common.collect.Ordering.ArbitraryOrdering;\n",
        "30": "import com.google.common.collect.Ordering.IncomparableValueException;\n",
        "31": "import com.google.common.collect.testing.Helpers;\n",
        "32": "import com.google.common.primitives.Ints;\n",
        "33": "import com.google.common.testing.EqualsTester;\n",
        "34": "\n",
        "35": "import junit.framework.TestCase;\n",
        "36": "\n",
        "37": "import java.util.Arrays;\n",
        "38": "import java.util.Collections;\n",
        "39": "import java.util.Comparator;\n",
        "40": "import java.util.Iterator;\n",
        "41": "import java.util.List;\n",
        "42": "import java.util.Random;\n",
        "43": "import java.util.RandomAccess;\n",
        "44": "\n",
        "45": "import javax.annotation.Nullable;\n",
        "46": "\n",
        "47": "/**\n",
        "48": " * Unit tests for {@code Ordering}.\n",
        "49": " *\n",
        "50": " * @author Jesse Wilson\n",
        "51": " */\n",
        "52": "@GwtCompatible(emulated = true)\n",
        "53": "public class OrderingTest extends TestCase {\n",
        "54": "  // TODO(cpovirk): some of these are inexplicably slow (20-30s) under GWT\n",
        "55": "\n",
        "56": "  private final Ordering<Number> numberOrdering = new NumberOrdering();\n",
        "57": "\n",
        "58": "  public void testAllEqual() {\n",
        "59": "    Ordering<Object> comparator = Ordering.allEqual();\n",
        "60": "    assertSame(comparator, comparator.reverse());\n",
        "61": "\n",
        "62": "    assertEquals(comparator.compare(null, null), 0);\n",
        "63": "    assertEquals(comparator.compare(new Object(), new Object()), 0);\n",
        "64": "    assertEquals(comparator.compare(\"apples\", \"oranges\"), 0);\n",
        "65": "    assertSame(comparator, reserialize(comparator));\n",
        "66": "    assertEquals(\"Ordering.allEqual()\", comparator.toString());\n",
        "67": "\n",
        "68": "    List<String> strings = ImmutableList.of(\"b\", \"a\", \"d\", \"c\");\n",
        "69": "    assertEquals(strings, comparator.sortedCopy(strings));\n",
        "70": "    assertEquals(strings, comparator.immutableSortedCopy(strings));\n",
        "71": "  }\n",
        "72": "\n",
        "73": "  // From https://github.com/google/guava/issues/1342\n",
        "74": "  public void testComplicatedOrderingExample() {\n",
        "75": "    Integer nullInt = (Integer) null;\n",
        "76": "    Ordering<Iterable<Integer>> example =\n",
        "77": "        Ordering.<Integer>natural().nullsFirst().reverse().lexicographical().reverse().nullsLast();\n",
        "78": "    List<Integer> list1 = Lists.newArrayList();\n",
        "79": "    List<Integer> list2 = Lists.newArrayList(1);\n",
        "80": "    List<Integer> list3 = Lists.newArrayList(1, 1);\n",
        "81": "    List<Integer> list4 = Lists.newArrayList(1, 2);\n",
        "82": "    List<Integer> list5 = Lists.newArrayList(1, null, 2);\n",
        "83": "    List<Integer> list6 = Lists.newArrayList(2);\n",
        "84": "    List<Integer> list7 = Lists.newArrayList(nullInt);\n",
        "85": "    List<Integer> list8 = Lists.newArrayList(nullInt, nullInt);\n",
        "86": "    List<List<Integer>> list =\n",
        "87": "        Lists.newArrayList(list1, list2, list3, list4, list5, list6, list7, list8, null);\n",
        "88": "    List<List<Integer>> sorted = example.sortedCopy(list);\n",
        "89": "\n",
        "90": "    // [[null, null], [null], [1, null, 2], [1, 1], [1, 2], [1], [2], [], null]\n",
        "91": "    assertThat(sorted)\n",
        "92": "        .containsExactly(\n",
        "93": "            Lists.newArrayList(nullInt, nullInt),\n",
        "94": "            Lists.newArrayList(nullInt),\n",
        "95": "            Lists.newArrayList(1, null, 2),\n",
        "96": "            Lists.newArrayList(1, 1),\n",
        "97": "            Lists.newArrayList(1, 2),\n",
        "98": "            Lists.newArrayList(1),\n",
        "99": "            Lists.newArrayList(2),\n",
        "100": "            Lists.newArrayList(),\n",
        "101": "            null)\n",
        "102": "        .inOrder();\n",
        "103": "  }\n",
        "104": "\n",
        "105": "  public void testNatural() {\n",
        "106": "    Ordering<Integer> comparator = Ordering.natural();\n",
        "107": "    Helpers.testComparator(comparator,\n",
        "108": "        Integer.MIN_VALUE, -1, 0, 1, Integer.MAX_VALUE);\n",
        "109": "    try {\n",
        "110": "      comparator.compare(1, null);\n",
        "111": "      fail();\n",
        "112": "    } catch (NullPointerException expected) {}\n",
        "113": "    try {\n",
        "114": "      comparator.compare(null, 2);\n",
        "115": "      fail();\n",
        "116": "    } catch (NullPointerException expected) {}\n",
        "117": "    try {\n",
        "118": "      comparator.compare(null, null);\n",
        "119": "      fail();\n",
        "120": "    } catch (NullPointerException expected) {}\n",
        "121": "    assertSame(comparator, reserialize(comparator));\n",
        "122": "    assertEquals(\"Ordering.natural()\", comparator.toString());\n",
        "123": "  }\n",
        "124": "\n",
        "125": "  public void testFrom() {\n",
        "126": "    Ordering<String> caseInsensitiveOrdering\n",
        "127": "        = Ordering.from(String.CASE_INSENSITIVE_ORDER);\n",
        "128": "    assertEquals(0, caseInsensitiveOrdering.compare(\"A\", \"a\"));\n",
        "129": "    assertTrue(caseInsensitiveOrdering.compare(\"a\", \"B\") < 0);\n",
        "130": "    assertTrue(caseInsensitiveOrdering.compare(\"B\", \"a\") > 0);\n",
        "131": "\n",
        "132": "    @SuppressWarnings(\"deprecation\") // test of deprecated method\n",
        "133": "    Ordering<String> orderingFromOrdering =\n",
        "134": "        Ordering.from(Ordering.<String>natural());\n",
        "135": "    new EqualsTester()\n",
        "136": "        .addEqualityGroup(caseInsensitiveOrdering, Ordering.from(String.CASE_INSENSITIVE_ORDER))\n",
        "137": "        .addEqualityGroup(orderingFromOrdering, Ordering.natural())\n",
        "138": "        .testEquals();\n",
        "139": "  }\n",
        "140": "\n",
        "141": "  public void testExplicit_none() {\n",
        "142": "    Comparator<Integer> c\n",
        "143": "        = Ordering.explicit(Collections.<Integer>emptyList());\n",
        "144": "    try {\n",
        "145": "      c.compare(0, 0);\n",
        "146": "      fail();\n",
        "147": "    } catch (IncomparableValueException expected) {\n",
        "148": "      assertEquals(0, expected.value);\n",
        "149": "    }\n",
        "150": "    reserializeAndAssert(c);\n",
        "151": "  }\n",
        "152": "\n",
        "153": "  public void testExplicit_one() {\n",
        "154": "    Comparator<Integer> c = Ordering.explicit(0);\n",
        "155": "    assertEquals(0, c.compare(0, 0));\n",
        "156": "    try {\n",
        "157": "      c.compare(0, 1);\n",
        "158": "      fail();\n",
        "159": "    } catch (IncomparableValueException expected) {\n",
        "160": "      assertEquals(1, expected.value);\n",
        "161": "    }\n",
        "162": "    reserializeAndAssert(c);\n",
        "163": "    assertEquals(\"Ordering.explicit([0])\", c.toString());\n",
        "164": "  }\n",
        "165": "\n",
        "166": "  public void testExplicit_two() {\n",
        "167": "    Comparator<Integer> c = Ordering.explicit(42, 5);\n",
        "168": "    assertEquals(0, c.compare(5, 5));\n",
        "169": "    assertTrue(c.compare(5, 42) > 0);\n",
        "170": "    assertTrue(c.compare(42, 5) < 0);\n",
        "171": "    try {\n",
        "172": "      c.compare(5, 666);\n",
        "173": "      fail();\n",
        "174": "    } catch (IncomparableValueException expected) {\n",
        "175": "      assertEquals(666, expected.value);\n",
        "176": "    }\n",
        "177": "    new EqualsTester()\n",
        "178": "        .addEqualityGroup(c, Ordering.explicit(42, 5))\n",
        "179": "        .addEqualityGroup(Ordering.explicit(5, 42))\n",
        "180": "        .addEqualityGroup(Ordering.explicit(42))\n",
        "181": "        .testEquals();\n",
        "182": "    reserializeAndAssert(c);\n",
        "183": "  }\n",
        "184": "\n",
        "185": "  public void testExplicit_sortingExample() {\n",
        "186": "    Comparator<Integer> c\n",
        "187": "        = Ordering.explicit(2, 8, 6, 1, 7, 5, 3, 4, 0, 9);\n",
        "188": "    List<Integer> list = Arrays.asList(0, 3, 5, 6, 7, 8, 9);\n",
        "189": "    Collections.sort(list, c);\n",
        "190": "    assertThat(list).containsExactly(8, 6, 7, 5, 3, 0, 9).inOrder();\n",
        "191": "    reserializeAndAssert(c);\n",
        "192": "  }\n",
        "193": "\n",
        "194": "  public void testExplicit_withDuplicates() {\n",
        "195": "    try {\n",
        "196": "      Ordering.explicit(1, 2, 3, 4, 2);\n",
        "197": "      fail();\n",
        "198": "    } catch (IllegalArgumentException expected) {\n",
        "199": "    }\n",
        "200": "  }\n",
        "201": "\n",
        "202": "  // A more limited test than the one that follows, but this one uses the\n",
        "203": "  // actual public API.\n",
        "204": "  public void testArbitrary_withoutCollisions() {\n",
        "205": "    List<Object> list = Lists.newArrayList();\n",
        "206": "    for (int i = 0; i < 50; i++) {\n",
        "207": "      list.add(new Object());\n",
        "208": "    }\n",
        "209": "\n",
        "210": "    Ordering<Object> arbitrary = Ordering.arbitrary();\n",
        "211": "    Collections.sort(list, arbitrary);\n",
        "212": "\n",
        "213": "    // Now we don't care what order it's put the list in, only that\n",
        "214": "    // comparing any pair of elements gives the answer we expect.\n",
        "215": "    Helpers.testComparator(arbitrary, list);\n",
        "216": "\n",
        "217": "    assertEquals(\"Ordering.arbitrary()\", arbitrary.toString());\n",
        "218": "  }\n",
        "219": "\n",
        "220": "  public void testArbitrary_withCollisions() {\n",
        "221": "    List<Integer> list = Lists.newArrayList();\n",
        "222": "    for (int i = 0; i < 50; i++) {\n",
        "223": "      list.add(i);\n",
        "224": "    }\n",
        "225": "\n",
        "226": "    Ordering<Object> arbitrary = new ArbitraryOrdering() {\n",
        "227": "      @Override int identityHashCode(Object object) {\n",
        "228": "        return ((Integer) object) % 5; // fake tons of collisions!\n",
        "229": "      }\n",
        "230": "    };\n",
        "231": "\n",
        "232": "    // Don't let the elements be in such a predictable order\n",
        "233": "    list = shuffledCopy(list, new Random(1));\n",
        "234": "\n",
        "235": "    Collections.sort(list, arbitrary);\n",
        "236": "\n",
        "237": "    // Now we don't care what order it's put the list in, only that\n",
        "238": "    // comparing any pair of elements gives the answer we expect.\n",
        "239": "    Helpers.testComparator(arbitrary, list);\n",
        "240": "  }\n",
        "241": "\n",
        "242": "  public void testUsingToString() {\n",
        "243": "    Ordering<Object> ordering = Ordering.usingToString();\n",
        "244": "    Helpers.testComparator(ordering, 1, 12, 124, 2);\n",
        "245": "    assertEquals(\"Ordering.usingToString()\", ordering.toString());\n",
        "246": "    assertSame(ordering, reserialize(ordering));\n",
        "247": "  }\n",
        "248": "\n",
        "249": "  // use an enum to get easy serializability\n",
        "250": "  private enum CharAtFunction implements Function<String, Character> {\n",
        "251": "    AT0(0),\n",
        "252": "    AT1(1),\n",
        "253": "    AT2(2),\n",
        "254": "    AT3(3),\n",
        "255": "    AT4(4),\n",
        "256": "    AT5(5),\n",
        "257": "    ;\n",
        "258": "\n",
        "259": "    final int index;\n",
        "260": "    CharAtFunction(int index) {\n",
        "261": "      this.index = index;\n",
        "262": "    }\n",
        "263": "    @Override\n",
        "264": "    public Character apply(String string) {\n",
        "265": "      return string.charAt(index);\n",
        "266": "    }\n",
        "267": "  }\n",
        "268": "\n",
        "269": "  private static Ordering<String> byCharAt(int index) {\n",
        "270": "    return Ordering.natural().onResultOf(CharAtFunction.values()[index]);\n",
        "271": "  }\n",
        "272": "\n",
        "273": "  public void testCompound_static() {\n",
        "274": "    Comparator<String> comparator = Ordering.compound(ImmutableList.of(\n",
        "275": "        byCharAt(0), byCharAt(1), byCharAt(2),\n",
        "276": "        byCharAt(3), byCharAt(4), byCharAt(5)));\n",
        "277": "    Helpers.testComparator(comparator, ImmutableList.of(\n",
        "278": "        \"applesauce\",\n",
        "279": "        \"apricot\",\n",
        "280": "        \"artichoke\",\n",
        "281": "        \"banality\",\n",
        "282": "        \"banana\",\n",
        "283": "        \"banquet\",\n",
        "284": "        \"tangelo\",\n",
        "285": "        \"tangerine\"));\n",
        "286": "    reserializeAndAssert(comparator);\n",
        "287": "  }\n",
        "288": "\n",
        "289": "  public void testCompound_instance() {\n",
        "290": "    Comparator<String> comparator = byCharAt(1).compound(byCharAt(0));\n",
        "291": "    Helpers.testComparator(comparator, ImmutableList.of(\n",
        "292": "        \"red\",\n",
        "293": "        \"yellow\",\n",
        "294": "        \"violet\",\n",
        "295": "        \"blue\",\n",
        "296": "        \"indigo\",\n",
        "297": "        \"green\",\n",
        "298": "        \"orange\"));\n",
        "299": "  }\n",
        "300": "\n",
        "301": "  public void testCompound_instance_generics() {\n",
        "302": "    Ordering<Object> objects = Ordering.explicit((Object) 1);\n",
        "303": "    Ordering<Number> numbers = Ordering.explicit((Number) 1);\n",
        "304": "    Ordering<Integer> integers = Ordering.explicit(1);\n",
        "305": "\n",
        "306": "    // Like by like equals like\n",
        "307": "    Ordering<Number> a = numbers.compound(numbers);\n",
        "308": "\n",
        "309": "    // The compound takes the more specific type of the two, regardless of order\n",
        "310": "\n",
        "311": "    Ordering<Number> b = numbers.compound(objects);\n",
        "312": "    Ordering<Number> c = objects.compound(numbers);\n",
        "313": "\n",
        "314": "    Ordering<Integer> d = numbers.compound(integers);\n",
        "315": "    Ordering<Integer> e = integers.compound(numbers);\n",
        "316": "\n",
        "317": "    // This works with three levels too (IDEA falsely reports errors as noted\n",
        "318": "    // below. Both javac and eclipse handle these cases correctly.)\n",
        "319": "\n",
        "320": "    Ordering<Number> f = numbers.compound(objects).compound(objects); //bad IDEA\n",
        "321": "    Ordering<Number> g = objects.compound(numbers).compound(objects);\n",
        "322": "    Ordering<Number> h = objects.compound(objects).compound(numbers);\n",
        "323": "\n",
        "324": "    Ordering<Number> i = numbers.compound(objects.compound(objects));\n",
        "325": "    Ordering<Number> j = objects.compound(numbers.compound(objects)); //bad IDEA\n",
        "326": "    Ordering<Number> k = objects.compound(objects.compound(numbers));\n",
        "327": "\n",
        "328": "    // You can also arbitrarily assign a more restricted type - not an intended\n",
        "329": "    // feature, exactly, but unavoidable (I think) and harmless\n",
        "330": "    Ordering<Integer> l = objects.compound(numbers);\n",
        "331": "\n",
        "332": "    // This correctly doesn't work:\n",
        "333": "    // Ordering<Object> m = numbers.compound(objects);\n",
        "334": "\n",
        "335": "    // Sadly, the following works in javac 1.6, but at least it fails for\n",
        "336": "    // eclipse, and is *correctly* highlighted red in IDEA.\n",
        "337": "    // Ordering<Object> n = objects.compound(numbers);\n",
        "338": "  }\n",
        "339": "\n",
        "340": "  public void testReverse() {\n",
        "341": "    Ordering<Number> reverseOrder = numberOrdering.reverse();\n",
        "342": "    Helpers.testComparator(reverseOrder,\n",
        "343": "        Integer.MAX_VALUE, 1, 0, -1, Integer.MIN_VALUE);\n",
        "344": "\n",
        "345": "    new EqualsTester()\n",
        "346": "        .addEqualityGroup(reverseOrder, numberOrdering.reverse())\n",
        "347": "        .addEqualityGroup(Ordering.natural().reverse())\n",
        "348": "        .addEqualityGroup(Collections.reverseOrder())\n",
        "349": "        .testEquals();\n",
        "350": "  }\n",
        "351": "\n",
        "352": "  public void testReverseOfReverseSameAsForward() {\n",
        "353": "    // Not guaranteed by spec, but it works, and saves us from testing\n",
        "354": "    // exhaustively\n",
        "355": "    assertSame(numberOrdering, numberOrdering.reverse().reverse());\n",
        "356": "  }\n",
        "357": "\n",
        "358": "  private enum StringLengthFunction implements Function<String, Integer> {\n",
        "359": "    StringLength;\n",
        "360": "\n",
        "361": "    @Override\n",
        "362": "    public Integer apply(String string) {\n",
        "363": "      return string.length();\n",
        "364": "    }\n",
        "365": "  }\n",
        "366": "\n",
        "367": "  private static final Ordering<Integer> DECREASING_INTEGER\n",
        "368": "      = Ordering.natural().reverse();\n",
        "369": "\n",
        "370": "  public void testOnResultOf_natural() {\n",
        "371": "    Comparator<String> comparator\n",
        "372": "        = Ordering.natural().onResultOf(StringLengthFunction.StringLength);\n",
        "373": "    assertTrue(comparator.compare(\"to\", \"be\") == 0);\n",
        "374": "    assertTrue(comparator.compare(\"or\", \"not\") < 0);\n",
        "375": "    assertTrue(comparator.compare(\"that\", \"to\") > 0);\n",
        "376": "\n",
        "377": "    new EqualsTester()\n",
        "378": "        .addEqualityGroup(\n",
        "379": "            comparator,\n",
        "380": "            Ordering.natural().onResultOf(StringLengthFunction.StringLength))\n",
        "381": "        .addEqualityGroup(DECREASING_INTEGER)\n",
        "382": "        .testEquals();\n",
        "383": "    reserializeAndAssert(comparator);\n",
        "384": "    assertEquals(\"Ordering.natural().onResultOf(StringLength)\",\n",
        "385": "        comparator.toString());\n",
        "386": "  }\n",
        "387": "\n",
        "388": "  public void testOnResultOf_chained() {\n",
        "389": "    Comparator<String> comparator = DECREASING_INTEGER.onResultOf(\n",
        "390": "        StringLengthFunction.StringLength);\n",
        "391": "    assertTrue(comparator.compare(\"to\", \"be\") == 0);\n",
        "392": "    assertTrue(comparator.compare(\"not\", \"or\") < 0);\n",
        "393": "    assertTrue(comparator.compare(\"to\", \"that\") > 0);\n",
        "394": "\n",
        "395": "    new EqualsTester()\n",
        "396": "        .addEqualityGroup(\n",
        "397": "            comparator,\n",
        "398": "            DECREASING_INTEGER.onResultOf(StringLengthFunction.StringLength))\n",
        "399": "        .addEqualityGroup(\n",
        "400": "            DECREASING_INTEGER.onResultOf(Functions.constant(1)))\n",
        "401": "        .addEqualityGroup(Ordering.natural())\n",
        "402": "        .testEquals();\n",
        "403": "    reserializeAndAssert(comparator);\n",
        "404": "    assertEquals(\"Ordering.natural().reverse().onResultOf(StringLength)\",\n",
        "405": "        comparator.toString());\n",
        "406": "  }\n",
        "407": "\n",
        "408": "  @SuppressWarnings(\"unchecked\") // dang varargs\n",
        "409": "  public void testLexicographical() {\n",
        "410": "    Ordering<String> ordering = Ordering.natural();\n",
        "411": "    Ordering<Iterable<String>> lexy = ordering.lexicographical();\n",
        "412": "\n",
        "413": "    ImmutableList<String> empty = ImmutableList.of();\n",
        "414": "    ImmutableList<String> a = ImmutableList.of(\"a\");\n",
        "415": "    ImmutableList<String> aa = ImmutableList.of(\"a\", \"a\");\n",
        "416": "    ImmutableList<String> ab = ImmutableList.of(\"a\", \"b\");\n",
        "417": "    ImmutableList<String> b = ImmutableList.of(\"b\");\n",
        "418": "\n",
        "419": "    Helpers.testComparator(lexy, empty, a, aa, ab, b);\n",
        "420": "\n",
        "421": "    new EqualsTester()\n",
        "422": "        .addEqualityGroup(lexy, ordering.lexicographical())\n",
        "423": "        .addEqualityGroup(numberOrdering.lexicographical())\n",
        "424": "        .addEqualityGroup(Ordering.natural())\n",
        "425": "        .testEquals();\n",
        "426": "  }\n",
        "427": "\n",
        "428": "  public void testNullsFirst() {\n",
        "429": "    Ordering<Integer> ordering = Ordering.natural().nullsFirst();\n",
        "430": "    Helpers.testComparator(ordering, null, Integer.MIN_VALUE, 0, 1);\n",
        "431": "\n",
        "432": "    new EqualsTester()\n",
        "433": "        .addEqualityGroup(ordering, Ordering.natural().nullsFirst())\n",
        "434": "        .addEqualityGroup(numberOrdering.nullsFirst())\n",
        "435": "        .addEqualityGroup(Ordering.natural())\n",
        "436": "        .testEquals();\n",
        "437": "  }\n",
        "438": "\n",
        "439": "  public void testNullsLast() {\n",
        "440": "    Ordering<Integer> ordering = Ordering.natural().nullsLast();\n",
        "441": "    Helpers.testComparator(ordering, 0, 1, Integer.MAX_VALUE, null);\n",
        "442": "\n",
        "443": "    new EqualsTester()\n",
        "444": "        .addEqualityGroup(ordering, Ordering.natural().nullsLast())\n",
        "445": "        .addEqualityGroup(numberOrdering.nullsLast())\n",
        "446": "        .addEqualityGroup(Ordering.natural())\n",
        "447": "        .testEquals();\n",
        "448": "  }\n",
        "449": "\n",
        "450": "  public void testBinarySearch() {\n",
        "451": "    List<Integer> ints = Lists.newArrayList(0, 2, 3, 5, 7, 9);\n",
        "452": "    assertEquals(4, numberOrdering.binarySearch(ints, 7));\n",
        "453": "  }\n",
        "454": "\n",
        "455": "  public void testSortedCopy() {\n",
        "456": "    List<Integer> unsortedInts = Collections.unmodifiableList(\n",
        "457": "        Arrays.asList(5, 0, 3, null, 0, 9));\n",
        "458": "    List<Integer> sortedInts =\n",
        "459": "        numberOrdering.nullsLast().sortedCopy(unsortedInts);\n",
        "460": "    assertEquals(Arrays.asList(0, 0, 3, 5, 9, null), sortedInts);\n",
        "461": "\n",
        "462": "    assertEquals(Collections.emptyList(),\n",
        "463": "        numberOrdering.sortedCopy(Collections.<Integer>emptyList()));\n",
        "464": "  }\n",
        "465": "\n",
        "466": "  public void testImmutableSortedCopy() {\n",
        "467": "    ImmutableList<Integer> unsortedInts = ImmutableList.of(5, 3, 0, 9, 3);\n",
        "468": "    ImmutableList<Integer> sortedInts\n",
        "469": "        = numberOrdering.immutableSortedCopy(unsortedInts);\n",
        "470": "    assertEquals(Arrays.asList(0, 3, 3, 5, 9), sortedInts);\n",
        "471": "\n",
        "472": "    assertEquals(Collections.<Integer>emptyList(),\n",
        "473": "        numberOrdering.immutableSortedCopy(Collections.<Integer>emptyList()));\n",
        "474": "\n",
        "475": "    List<Integer> listWithNull = Arrays.asList(5, 3, null, 9);\n",
        "476": "    try {\n",
        "477": "      Ordering.natural().nullsFirst().immutableSortedCopy(listWithNull);\n",
        "478": "      fail();\n",
        "479": "    } catch (NullPointerException expected) {\n",
        "480": "    }\n",
        "481": "  }\n",
        "482": "\n",
        "483": "  public void testIsOrdered() {\n",
        "484": "    assertFalse(numberOrdering.isOrdered(asList(5, 3, 0, 9)));\n",
        "485": "    assertFalse(numberOrdering.isOrdered(asList(0, 5, 3, 9)));\n",
        "486": "    assertTrue(numberOrdering.isOrdered(asList(0, 3, 5, 9)));\n",
        "487": "    assertTrue(numberOrdering.isOrdered(asList(0, 0, 3, 3)));\n",
        "488": "    assertTrue(numberOrdering.isOrdered(asList(0, 3)));\n",
        "489": "    assertTrue(numberOrdering.isOrdered(Collections.singleton(1)));\n",
        "490": "    assertTrue(numberOrdering.isOrdered(Collections.<Integer>emptyList()));\n",
        "491": "  }\n",
        "492": "\n",
        "493": "  public void testIsStrictlyOrdered() {\n",
        "494": "    assertFalse(numberOrdering.isStrictlyOrdered(asList(5, 3, 0, 9)));\n",
        "495": "    assertFalse(numberOrdering.isStrictlyOrdered(asList(0, 5, 3, 9)));\n",
        "496": "    assertTrue(numberOrdering.isStrictlyOrdered(asList(0, 3, 5, 9)));\n",
        "497": "    assertFalse(numberOrdering.isStrictlyOrdered(asList(0, 0, 3, 3)));\n",
        "498": "    assertTrue(numberOrdering.isStrictlyOrdered(asList(0, 3)));\n",
        "499": "    assertTrue(numberOrdering.isStrictlyOrdered(Collections.singleton(1)));\n",
        "500": "    assertTrue(numberOrdering.isStrictlyOrdered(\n",
        "501": "        Collections.<Integer>emptyList()));\n",
        "502": "  }\n",
        "503": "\n",
        "504": "  public void testLeastOfIterable_empty_0() {\n",
        "505": "    List<Integer> result = numberOrdering.leastOf(Arrays.<Integer>asList(), 0);\n",
        "506": "    assertTrue(result instanceof RandomAccess);\n",
        "507": "    assertListImmutable(result);\n",
        "508": "    assertEquals(ImmutableList.<Integer>of(), result);\n",
        "509": "  }\n",
        "510": "\n",
        "511": "  public void testLeastOfIterator_empty_0() {\n",
        "512": "    List<Integer> result = numberOrdering.leastOf(\n",
        "513": "        Iterators.<Integer>emptyIterator(), 0);\n",
        "514": "    assertTrue(result instanceof RandomAccess);\n",
        "515": "    assertListImmutable(result);\n",
        "516": "    assertEquals(ImmutableList.<Integer>of(), result);\n",
        "517": "  }\n",
        "518": "\n",
        "519": "  public void testLeastOfIterable_empty_1() {\n",
        "520": "    List<Integer> result = numberOrdering.leastOf(Arrays.<Integer>asList(), 1);\n",
        "521": "    assertTrue(result instanceof RandomAccess);\n",
        "522": "    assertListImmutable(result);\n",
        "523": "    assertEquals(ImmutableList.<Integer>of(), result);\n",
        "524": "  }\n",
        "525": "\n",
        "526": "  public void testLeastOfIterator_empty_1() {\n",
        "527": "    List<Integer> result = numberOrdering.leastOf(\n",
        "528": "        Iterators.<Integer>emptyIterator(), 1);\n",
        "529": "    assertTrue(result instanceof RandomAccess);\n",
        "530": "    assertListImmutable(result);\n",
        "531": "    assertEquals(ImmutableList.<Integer>of(), result);\n",
        "532": "  }\n",
        "533": "\n",
        "534": "  public void testLeastOfIterable_simple_negativeOne() {\n",
        "535": "    try {\n",
        "536": "      numberOrdering.leastOf(Arrays.asList(3, 4, 5, -1), -1);\n",
        "537": "      fail();\n",
        "538": "    } catch (IllegalArgumentException expected) {\n",
        "539": "    }\n",
        "540": "  }\n",
        "541": "\n",
        "542": "  public void testLeastOfIterator_simple_negativeOne() {\n",
        "543": "    try {\n",
        "544": "      numberOrdering.leastOf(Iterators.forArray(3, 4, 5, -1), -1);\n",
        "545": "      fail();\n",
        "546": "    } catch (IllegalArgumentException expected) {\n",
        "547": "    }\n",
        "548": "  }\n",
        "549": "\n",
        "550": "  public void testLeastOfIterable_singleton_0() {\n",
        "551": "    List<Integer> result = numberOrdering.leastOf(Arrays.asList(3), 0);\n",
        "552": "    assertTrue(result instanceof RandomAccess);\n",
        "553": "    assertListImmutable(result);\n",
        "554": "    assertEquals(ImmutableList.<Integer>of(), result);\n",
        "555": "  }\n",
        "556": "\n",
        "557": "  public void testLeastOfIterator_singleton_0() {\n",
        "558": "    List<Integer> result = numberOrdering.leastOf(\n",
        "559": "        Iterators.singletonIterator(3), 0);\n",
        "560": "    assertTrue(result instanceof RandomAccess);\n",
        "561": "    assertListImmutable(result);\n",
        "562": "    assertEquals(ImmutableList.<Integer>of(), result);\n",
        "563": "  }\n",
        "564": "\n",
        "565": "  public void testLeastOfIterable_simple_0() {\n",
        "566": "    List<Integer> result = numberOrdering.leastOf(Arrays.asList(3, 4, 5, -1), 0);\n",
        "567": "    assertTrue(result instanceof RandomAccess);\n",
        "568": "    assertListImmutable(result);\n",
        "569": "    assertEquals(ImmutableList.<Integer>of(), result);\n",
        "570": "  }\n",
        "571": "\n",
        "572": "  public void testLeastOfIterator_simple_0() {\n",
        "573": "    List<Integer> result = numberOrdering.leastOf(\n",
        "574": "        Iterators.forArray(3, 4, 5, -1), 0);\n",
        "575": "    assertTrue(result instanceof RandomAccess);\n",
        "576": "    assertListImmutable(result);\n",
        "577": "    assertEquals(ImmutableList.<Integer>of(), result);\n",
        "578": "  }\n",
        "579": "\n",
        "580": "  public void testLeastOfIterable_simple_1() {\n",
        "581": "    List<Integer> result = numberOrdering.leastOf(Arrays.asList(3, 4, 5, -1), 1);\n",
        "582": "    assertTrue(result instanceof RandomAccess);\n",
        "583": "    assertListImmutable(result);\n",
        "584": "    assertEquals(ImmutableList.of(-1), result);\n",
        "585": "  }\n",
        "586": "\n",
        "587": "  public void testLeastOfIterator_simple_1() {\n",
        "588": "    List<Integer> result = numberOrdering.leastOf(\n",
        "589": "        Iterators.forArray(3, 4, 5, -1), 1);\n",
        "590": "    assertTrue(result instanceof RandomAccess);\n",
        "591": "    assertListImmutable(result);\n",
        "592": "    assertEquals(ImmutableList.of(-1), result);\n",
        "593": "  }\n",
        "594": "\n",
        "595": "  public void testLeastOfIterable_simple_nMinusOne_withNullElement() {\n",
        "596": "    List<Integer> list = Arrays.asList(3, null, 5, -1);\n",
        "597": "    List<Integer> result = Ordering.natural().nullsLast().leastOf(list, list.size() - 1);\n",
        "598": "    assertTrue(result instanceof RandomAccess);\n",
        "599": "    assertListImmutable(result);\n",
        "600": "    assertEquals(ImmutableList.of(-1, 3, 5), result);\n",
        "601": "  }\n",
        "602": "\n",
        "603": "  public void testLeastOfIterator_simple_nMinusOne_withNullElement() {\n",
        "604": "    Iterator<Integer> itr = Iterators.forArray(3, null, 5, -1);\n",
        "605": "    List<Integer> result = Ordering.natural().nullsLast().leastOf(itr, 3);\n",
        "606": "    assertTrue(result instanceof RandomAccess);\n",
        "607": "    assertListImmutable(result);\n",
        "608": "    assertEquals(ImmutableList.of(-1, 3, 5), result);\n",
        "609": "  }\n",
        "610": "\n",
        "611": "  public void testLeastOfIterable_simple_nMinusOne() {\n",
        "612": "    List<Integer> list = Arrays.asList(3, 4, 5, -1);\n",
        "613": "    List<Integer> result = numberOrdering.leastOf(list, list.size() - 1);\n",
        "614": "    assertTrue(result instanceof RandomAccess);\n",
        "615": "    assertListImmutable(result);\n",
        "616": "    assertEquals(ImmutableList.of(-1, 3, 4), result);\n",
        "617": "  }\n",
        "618": "\n",
        "619": "  public void testLeastOfIterator_simple_nMinusOne() {\n",
        "620": "    List<Integer> list = Arrays.asList(3, 4, 5, -1);\n",
        "621": "    List<Integer> result = numberOrdering.leastOf(list.iterator(), list.size() - 1);\n",
        "622": "    assertTrue(result instanceof RandomAccess);\n",
        "623": "    assertListImmutable(result);\n",
        "624": "    assertEquals(ImmutableList.of(-1, 3, 4), result);\n",
        "625": "  }\n",
        "626": "\n",
        "627": "  public void testLeastOfIterable_simple_n() {\n",
        "628": "    List<Integer> list = Arrays.asList(3, 4, 5, -1);\n",
        "629": "    List<Integer> result = numberOrdering.leastOf(list, list.size());\n",
        "630": "    assertTrue(result instanceof RandomAccess);\n",
        "631": "    assertListImmutable(result);\n",
        "632": "    assertEquals(ImmutableList.of(-1, 3, 4, 5), result);\n",
        "633": "  }\n",
        "634": "\n",
        "635": "  public void testLeastOfIterator_simple_n() {\n",
        "636": "    List<Integer> list = Arrays.asList(3, 4, 5, -1);\n",
        "637": "    List<Integer> result = numberOrdering.leastOf(list.iterator(), list.size());\n",
        "638": "    assertTrue(result instanceof RandomAccess);\n",
        "639": "    assertListImmutable(result);\n",
        "640": "    assertEquals(ImmutableList.of(-1, 3, 4, 5), result);\n",
        "641": "  }\n",
        "642": "\n",
        "643": "  public void testLeastOfIterable_simple_n_withNullElement() {\n",
        "644": "    List<Integer> list = Arrays.asList(3, 4, 5, null, -1);\n",
        "645": "    List<Integer> result = Ordering.natural().nullsLast().leastOf(list, list.size());\n",
        "646": "    assertTrue(result instanceof RandomAccess);\n",
        "647": "    assertListImmutable(result);\n",
        "648": "    assertEquals(Arrays.asList(-1, 3, 4, 5, null), result);\n",
        "649": "  }\n",
        "650": "\n",
        "651": "  public void testLeastOfIterator_simple_n_withNullElement() {\n",
        "652": "    List<Integer> list = Arrays.asList(3, 4, 5, null, -1);\n",
        "653": "    List<Integer> result = Ordering.natural().nullsLast().leastOf(\n",
        "654": "        list.iterator(), list.size());\n",
        "655": "    assertTrue(result instanceof RandomAccess);\n",
        "656": "    assertListImmutable(result);\n",
        "657": "    assertEquals(Arrays.asList(-1, 3, 4, 5, null), result);\n",
        "658": "  }\n",
        "659": "\n",
        "660": "  public void testLeastOfIterable_simple_nPlusOne() {\n",
        "661": "    List<Integer> list = Arrays.asList(3, 4, 5, -1);\n",
        "662": "    List<Integer> result = numberOrdering.leastOf(list, list.size() + 1);\n",
        "663": "    assertTrue(result instanceof RandomAccess);\n",
        "664": "    assertListImmutable(result);\n",
        "665": "    assertEquals(ImmutableList.of(-1, 3, 4, 5), result);\n",
        "666": "  }\n",
        "667": "\n",
        "668": "  public void testLeastOfIterator_simple_nPlusOne() {\n",
        "669": "    List<Integer> list = Arrays.asList(3, 4, 5, -1);\n",
        "670": "    List<Integer> result = numberOrdering.leastOf(list.iterator(), list.size() + 1);\n",
        "671": "    assertTrue(result instanceof RandomAccess);\n",
        "672": "    assertListImmutable(result);\n",
        "673": "    assertEquals(ImmutableList.of(-1, 3, 4, 5), result);\n",
        "674": "  }\n",
        "675": "\n",
        "676": "  public void testLeastOfIterable_ties() {\n",
        "677": "    Integer foo = new Integer(Integer.MAX_VALUE - 10);\n",
        "678": "    Integer bar = new Integer(Integer.MAX_VALUE - 10);\n",
        "679": "\n",
        "680": "    assertNotSame(foo, bar);\n",
        "681": "    assertEquals(foo, bar);\n",
        "682": "\n",
        "683": "    List<Integer> list = Arrays.asList(3, foo, bar, -1);\n",
        "684": "    List<Integer> result = numberOrdering.leastOf(list, list.size());\n",
        "685": "    assertEquals(ImmutableList.of(-1, 3, foo, bar), result);\n",
        "686": "  }\n",
        "687": "\n",
        "688": "  public void testLeastOfIterator_ties() {\n",
        "689": "    Integer foo = new Integer(Integer.MAX_VALUE - 10);\n",
        "690": "    Integer bar = new Integer(Integer.MAX_VALUE - 10);\n",
        "691": "\n",
        "692": "    assertNotSame(foo, bar);\n",
        "693": "    assertEquals(foo, bar);\n",
        "694": "\n",
        "695": "    List<Integer> list = Arrays.asList(3, foo, bar, -1);\n",
        "696": "    List<Integer> result = numberOrdering.leastOf(list.iterator(), list.size());\n",
        "697": "    assertEquals(ImmutableList.of(-1, 3, foo, bar), result);\n",
        "698": "  }\n",
        "699": "\n",
        "700": "  public void testLeastOf_reconcileAgainstSortAndSublistSmall() {\n",
        "701": "    runLeastOfComparison(10, 30, 2);\n",
        "702": "  }\n",
        "703": "\n",
        "704": "  private static void runLeastOfComparison(\n",
        "705": "      int iterations, int elements, int seeds) {\n",
        "706": "    Random random = new Random(42);\n",
        "707": "    Ordering<Integer> ordering = Ordering.natural();\n",
        "708": "\n",
        "709": "    for (int i = 0; i < iterations; i++) {\n",
        "710": "      List<Integer> list = Lists.newArrayList();\n",
        "711": "      for (int j = 0; j < elements; j++) {\n",
        "712": "        list.add(random.nextInt(10 * i + j + 1));\n",
        "713": "      }\n",
        "714": "\n",
        "715": "      for (int seed = 1; seed < seeds; seed++) {\n",
        "716": "        int k = random.nextInt(10 * seed);\n",
        "717": "        assertEquals(ordering.sortedCopy(list).subList(0, k),\n",
        "718": "            ordering.leastOf(list, k));\n",
        "719": "      }\n",
        "720": "    }\n",
        "721": "  }\n",
        "722": "\n",
        "723": "  public void testLeastOfIterableLargeK() {\n",
        "724": "    List<Integer> list = Arrays.asList(4, 2, 3, 5, 1);\n",
        "725": "    assertEquals(Arrays.asList(1, 2, 3, 4, 5), Ordering.natural()\n",
        "726": "        .leastOf(list, Integer.MAX_VALUE));\n",
        "727": "  }\n",
        "728": "\n",
        "729": "  public void testLeastOfIteratorLargeK() {\n",
        "730": "    List<Integer> list = Arrays.asList(4, 2, 3, 5, 1);\n",
        "731": "    assertEquals(Arrays.asList(1, 2, 3, 4, 5), Ordering.natural()\n",
        "732": "        .leastOf(list.iterator(), Integer.MAX_VALUE));\n",
        "733": "  }\n",
        "734": "\n",
        "735": "  public void testGreatestOfIterable_simple() {\n",
        "736": "    /*\n",
        "737": "     * If greatestOf() promised to be implemented as reverse().leastOf(), this\n",
        "738": "     * test would be enough. It doesn't... but we'll cheat and act like it does\n",
        "739": "     * anyway. There's a comment there to remind us to fix this if we change it.\n",
        "740": "     */\n",
        "741": "    List<Integer> list = Arrays.asList(3, 1, 3, 2, 4, 2, 4, 3);\n",
        "742": "    assertEquals(Arrays.asList(4, 4, 3, 3), numberOrdering.greatestOf(list, 4));\n",
        "743": "  }\n",
        "744": "\n",
        "745": "  public void testGreatestOfIterator_simple() {\n",
        "746": "    /*\n",
        "747": "     * If greatestOf() promised to be implemented as reverse().leastOf(), this\n",
        "748": "     * test would be enough. It doesn't... but we'll cheat and act like it does\n",
        "749": "     * anyway. There's a comment there to remind us to fix this if we change it.\n",
        "750": "     */\n",
        "751": "    List<Integer> list = Arrays.asList(3, 1, 3, 2, 4, 2, 4, 3);\n",
        "752": "    assertEquals(Arrays.asList(4, 4, 3, 3),\n",
        "753": "        numberOrdering.greatestOf(list.iterator(), 4));\n",
        "754": "  }\n",
        "755": "\n",
        "756": "  private static void assertListImmutable(List<Integer> result) {\n",
        "757": "    try {\n",
        "758": "      result.set(0, 1);\n",
        "759": "      fail();\n",
        "760": "    } catch (UnsupportedOperationException expected) {\n",
        "761": "      // pass\n",
        "762": "    }\n",
        "763": "  }\n",
        "764": "\n",
        "765": "  public void testIteratorMinAndMax() {\n",
        "766": "    List<Integer> ints = Lists.newArrayList(5, 3, 0, 9);\n",
        "767": "    assertEquals(9, (int) numberOrdering.max(ints.iterator()));\n",
        "768": "    assertEquals(0, (int) numberOrdering.min(ints.iterator()));\n",
        "769": "\n",
        "770": "    // when the values are the same, the first argument should be returned\n",
        "771": "    Integer a = new Integer(4);\n",
        "772": "    Integer b = new Integer(4);\n",
        "773": "    ints = Lists.newArrayList(a, b, b);\n",
        "774": "    assertSame(a, numberOrdering.max(ints.iterator()));\n",
        "775": "    assertSame(a, numberOrdering.min(ints.iterator()));\n",
        "776": "  }\n",
        "777": "\n",
        "778": "  public void testIteratorMinExhaustsIterator() {\n",
        "779": "    List<Integer> ints = Lists.newArrayList(9, 0, 3, 5);\n",
        "780": "    Iterator<Integer> iterator = ints.iterator();\n",
        "781": "    assertEquals(0, (int) numberOrdering.min(iterator));\n",
        "782": "    assertFalse(iterator.hasNext());\n",
        "783": "  }\n",
        "784": "\n",
        "785": "  public void testIteratorMaxExhaustsIterator() {\n",
        "786": "    List<Integer> ints = Lists.newArrayList(9, 0, 3, 5);\n",
        "787": "    Iterator<Integer> iterator = ints.iterator();\n",
        "788": "    assertEquals(9, (int) numberOrdering.max(iterator));\n",
        "789": "    assertFalse(iterator.hasNext());\n",
        "790": "  }\n",
        "791": "\n",
        "792": "  public void testIterableMinAndMax() {\n",
        "793": "    List<Integer> ints = Lists.newArrayList(5, 3, 0, 9);\n",
        "794": "    assertEquals(9, (int) numberOrdering.max(ints));\n",
        "795": "    assertEquals(0, (int) numberOrdering.min(ints));\n",
        "796": "\n",
        "797": "    // when the values are the same, the first argument should be returned\n",
        "798": "    Integer a = new Integer(4);\n",
        "799": "    Integer b = new Integer(4);\n",
        "800": "    ints = Lists.newArrayList(a, b, b);\n",
        "801": "    assertSame(a, numberOrdering.max(ints));\n",
        "802": "    assertSame(a, numberOrdering.min(ints));\n",
        "803": "  }\n",
        "804": "\n",
        "805": "  public void testVarargsMinAndMax() {\n",
        "806": "    // try the min and max values in all positions, since some values are proper\n",
        "807": "    // parameters and others are from the varargs array\n",
        "808": "    assertEquals(9, (int) numberOrdering.max(9, 3, 0, 5, 8));\n",
        "809": "    assertEquals(9, (int) numberOrdering.max(5, 9, 0, 3, 8));\n",
        "810": "    assertEquals(9, (int) numberOrdering.max(5, 3, 9, 0, 8));\n",
        "811": "    assertEquals(9, (int) numberOrdering.max(5, 3, 0, 9, 8));\n",
        "812": "    assertEquals(9, (int) numberOrdering.max(5, 3, 0, 8, 9));\n",
        "813": "    assertEquals(0, (int) numberOrdering.min(0, 3, 5, 9, 8));\n",
        "814": "    assertEquals(0, (int) numberOrdering.min(5, 0, 3, 9, 8));\n",
        "815": "    assertEquals(0, (int) numberOrdering.min(5, 3, 0, 9, 8));\n",
        "816": "    assertEquals(0, (int) numberOrdering.min(5, 3, 9, 0, 8));\n",
        "817": "    assertEquals(0, (int) numberOrdering.min(5, 3, 0, 9, 0));\n",
        "818": "\n",
        "819": "    // when the values are the same, the first argument should be returned\n",
        "820": "    Integer a = new Integer(4);\n",
        "821": "    Integer b = new Integer(4);\n",
        "822": "    assertSame(a, numberOrdering.max(a, b, b));\n",
        "823": "    assertSame(a, numberOrdering.min(a, b, b));\n",
        "824": "  }\n",
        "825": "\n",
        "826": "  public void testParameterMinAndMax() {\n",
        "827": "    assertEquals(5, (int) numberOrdering.max(3, 5));\n",
        "828": "    assertEquals(5, (int) numberOrdering.max(5, 3));\n",
        "829": "    assertEquals(3, (int) numberOrdering.min(3, 5));\n",
        "830": "    assertEquals(3, (int) numberOrdering.min(5, 3));\n",
        "831": "\n",
        "832": "    // when the values are the same, the first argument should be returned\n",
        "833": "    Integer a = new Integer(4);\n",
        "834": "    Integer b = new Integer(4);\n",
        "835": "    assertSame(a, numberOrdering.max(a, b));\n",
        "836": "    assertSame(a, numberOrdering.min(a, b));\n",
        "837": "  }\n",
        "838": "\n",
        "839": "  private static class NumberOrdering extends Ordering<Number> {\n",
        "840": "    @Override public int compare(Number a, Number b) {\n",
        "841": "      return ((Double) a.doubleValue()).compareTo(b.doubleValue());\n",
        "842": "    }\n",
        "843": "    @Override public int hashCode() {\n",
        "844": "      return NumberOrdering.class.hashCode();\n",
        "845": "    }\n",
        "846": "    @Override public boolean equals(Object other) {\n",
        "847": "      return other instanceof NumberOrdering;\n",
        "848": "    }\n",
        "849": "    private static final long serialVersionUID = 0;\n",
        "850": "  }\n",
        "851": "\n",
        "852": "  /*\n",
        "853": "   * Now we have monster tests that create hundreds of Orderings using different\n",
        "854": "   * combinations of methods, then checks compare(), binarySearch() and so\n",
        "855": "   * forth on each one.\n",
        "856": "   */\n",
        "857": "\n",
        "858": "  // should periodically try increasing this, but it makes the test run long\n",
        "859": "  private static final int RECURSE_DEPTH = 2;\n",
        "860": "  \n",
        "861": "  public void testCombinationsExhaustively_startingFromNatural() {\n",
        "862": "    testExhaustively(Ordering.<String>natural(), \"a\", \"b\", \"d\");\n",
        "863": "  }\n",
        "864": "\n",
        "865": "  /**\n",
        "866": "   * Requires at least 3 elements in {@code strictlyOrderedElements} in order to\n",
        "867": "   * test the varargs version of min/max.\n",
        "868": "   */\n",
        "869": "  private static <T> void testExhaustively(\n",
        "870": "      Ordering<? super T> ordering, T... strictlyOrderedElements) {\n",
        "871": "    checkArgument(strictlyOrderedElements.length >= 3, \"strictlyOrderedElements \"\n",
        "872": "        + \"requires at least 3 elements\");\n",
        "873": "    List<T> list = Arrays.asList(strictlyOrderedElements);\n",
        "874": "\n",
        "875": "    // for use calling Collection.toArray later\n",
        "876": "    T[] emptyArray = Platform.newArray(strictlyOrderedElements, 0);\n",
        "877": "\n",
        "878": "    // shoot me, but I didn't want to deal with wildcards through the whole test\n",
        "879": "    @SuppressWarnings(\"unchecked\")\n",
        "880": "    Scenario<T> starter = new Scenario<T>((Ordering) ordering, list, emptyArray);\n",
        "881": "    verifyScenario(starter, 0);\n",
        "882": "  }\n",
        "883": "\n",
        "884": "  private static <T> void verifyScenario(Scenario<T> scenario, int level) {\n",
        "885": "    scenario.testCompareTo();\n",
        "886": "    scenario.testIsOrdered();\n",
        "887": "    scenario.testMinAndMax();\n",
        "888": "    scenario.testBinarySearch();\n",
        "889": "    scenario.testSortedCopy();\n",
        "890": "\n",
        "891": "    if (level < RECURSE_DEPTH) {\n",
        "892": "      for (OrderingMutation alteration : OrderingMutation.values()) {\n",
        "893": "        verifyScenario(alteration.mutate(scenario), level + 1);\n",
        "894": "      }\n",
        "895": "    }\n",
        "896": "  }\n",
        "897": "\n",
        "898": "  /**\n",
        "899": "   * An aggregation of an ordering with a list (of size > 1) that should prove\n",
        "900": "   * to be in strictly increasing order according to that ordering.\n",
        "901": "   */\n",
        "902": "  private static class Scenario<T> {\n",
        "903": "    final Ordering<T> ordering;\n",
        "904": "    final List<T> strictlyOrderedList;\n",
        "905": "    final T[] emptyArray;\n",
        "906": "\n",
        "907": "    Scenario(Ordering<T> ordering, List<T> strictlyOrderedList, T[] emptyArray) {\n",
        "908": "      this.ordering = ordering;\n",
        "909": "      this.strictlyOrderedList = strictlyOrderedList;\n",
        "910": "      this.emptyArray = emptyArray;\n",
        "911": "    }\n",
        "912": "\n",
        "913": "    void testCompareTo() {\n",
        "914": "      Helpers.testComparator(ordering, strictlyOrderedList);\n",
        "915": "    }\n",
        "916": "\n",
        "917": "    void testIsOrdered() {\n",
        "918": "      assertTrue(ordering.isOrdered(strictlyOrderedList));\n",
        "919": "      assertTrue(ordering.isStrictlyOrdered(strictlyOrderedList));\n",
        "920": "    }\n",
        "921": "\n",
        "922": "    @SuppressWarnings(\"unchecked\") // generic arrays and unchecked cast\n",
        "923": "    void testMinAndMax() {\n",
        "924": "      List<T> shuffledList = Lists.newArrayList(strictlyOrderedList);\n",
        "925": "      shuffledList = shuffledCopy(shuffledList, new Random(5));\n",
        "926": "\n",
        "927": "      T min = strictlyOrderedList.get(0);\n",
        "928": "      T max = strictlyOrderedList.get(strictlyOrderedList.size() - 1);\n",
        "929": "\n",
        "930": "      T first = shuffledList.get(0);\n",
        "931": "      T second = shuffledList.get(1);\n",
        "932": "      T third = shuffledList.get(2);\n",
        "933": "      T[] rest = shuffledList.subList(3, shuffledList.size()).toArray(emptyArray);\n",
        "934": "\n",
        "935": "      assertEquals(min, ordering.min(shuffledList));\n",
        "936": "      assertEquals(min, ordering.min(shuffledList.iterator()));\n",
        "937": "      assertEquals(min, ordering.min(first, second, third, rest));\n",
        "938": "      assertEquals(min, ordering.min(min, max));\n",
        "939": "      assertEquals(min, ordering.min(max, min));\n",
        "940": "\n",
        "941": "      assertEquals(max, ordering.max(shuffledList));\n",
        "942": "      assertEquals(max, ordering.max(shuffledList.iterator()));\n",
        "943": "      assertEquals(max, ordering.max(first, second, third, rest));\n",
        "944": "      assertEquals(max, ordering.max(min, max));\n",
        "945": "      assertEquals(max, ordering.max(max, min));\n",
        "946": "    }\n",
        "947": "\n",
        "948": "    void testBinarySearch() {\n",
        "949": "      for (int i = 0; i < strictlyOrderedList.size(); i++) {\n",
        "950": "        assertEquals(i, ordering.binarySearch(\n",
        "951": "            strictlyOrderedList, strictlyOrderedList.get(i)));\n",
        "952": "      }\n",
        "953": "      List<T> newList = Lists.newArrayList(strictlyOrderedList);\n",
        "954": "      T valueNotInList = newList.remove(1);\n",
        "955": "      assertEquals(-2, ordering.binarySearch(newList, valueNotInList));\n",
        "956": "    }\n",
        "957": "\n",
        "958": "    void testSortedCopy() {\n",
        "959": "      List<T> shuffledList = Lists.newArrayList(strictlyOrderedList);\n",
        "960": "      shuffledList = shuffledCopy(shuffledList, new Random(5));\n",
        "961": "\n",
        "962": "      assertEquals(strictlyOrderedList, ordering.sortedCopy(shuffledList));\n",
        "963": "\n",
        "964": "      if (!strictlyOrderedList.contains(null)) {\n",
        "965": "        assertEquals(strictlyOrderedList, ordering.immutableSortedCopy(shuffledList));\n",
        "966": "      }\n",
        "967": "    }\n",
        "968": "  }\n",
        "969": "\n",
        "970": "  /**\n",
        "971": "   * A means for changing an Ordering into another Ordering. Each instance is\n",
        "972": "   * responsible for creating the alternate Ordering, and providing a List that\n",
        "973": "   * is known to be ordered, based on an input List known to be ordered\n",
        "974": "   * according to the input Ordering.\n",
        "975": "   */\n",
        "976": "  private enum OrderingMutation {\n",
        "977": "    REVERSE {\n",
        "978": "      @Override <T> Scenario<?> mutate(Scenario<T> scenario) {\n",
        "979": "        List<T> newList = Lists.newArrayList(scenario.strictlyOrderedList);\n",
        "980": "        Collections.reverse(newList);\n",
        "981": "        return new Scenario<T>(scenario.ordering.reverse(), newList, scenario.emptyArray);\n",
        "982": "      }\n",
        "983": "    },\n",
        "984": "    NULLS_FIRST {\n",
        "985": "      @Override <T> Scenario<?> mutate(Scenario<T> scenario) {\n",
        "986": "        @SuppressWarnings(\"unchecked\")\n",
        "987": "        List<T> newList = Lists.newArrayList((T) null);\n",
        "988": "        for (T t : scenario.strictlyOrderedList) {\n",
        "989": "          if (t != null) {\n",
        "990": "            newList.add(t);\n",
        "991": "          }\n",
        "992": "        }\n",
        "993": "        return new Scenario<T>(scenario.ordering.nullsFirst(), newList, scenario.emptyArray);\n",
        "994": "      }\n",
        "995": "    },\n",
        "996": "    NULLS_LAST {\n",
        "997": "      @Override <T> Scenario<?> mutate(Scenario<T> scenario) {\n",
        "998": "        List<T> newList = Lists.newArrayList();\n",
        "999": "        for (T t : scenario.strictlyOrderedList) {\n",
        "1000": "          if (t != null) {\n",
        "1001": "            newList.add(t);\n",
        "1002": "          }\n",
        "1003": "        }\n",
        "1004": "        newList.add(null);\n",
        "1005": "        return new Scenario<T>(scenario.ordering.nullsLast(), newList, scenario.emptyArray);\n",
        "1006": "      }\n",
        "1007": "    },\n",
        "1008": "    ON_RESULT_OF {\n",
        "1009": "      @Override <T> Scenario<?> mutate(final Scenario<T> scenario) {\n",
        "1010": "        Ordering<Integer> ordering = scenario.ordering.onResultOf(\n",
        "1011": "            new Function<Integer, T>() {\n",
        "1012": "              @Override\n",
        "1013": "              public T apply(@Nullable Integer from) {\n",
        "1014": "                return scenario.strictlyOrderedList.get(from);\n",
        "1015": "              }\n",
        "1016": "            });\n",
        "1017": "        List<Integer> list = Lists.newArrayList();\n",
        "1018": "        for (int i = 0; i < scenario.strictlyOrderedList.size(); i++) {\n",
        "1019": "          list.add(i);\n",
        "1020": "        }\n",
        "1021": "        return new Scenario<Integer>(ordering, list, new Integer[0]);\n",
        "1022": "      }\n",
        "1023": "    },\n",
        "1024": "    COMPOUND_THIS_WITH_NATURAL {\n",
        "1025": "      @SuppressWarnings(\"unchecked\") // raw array\n",
        "1026": "      @Override <T> Scenario<?> mutate(Scenario<T> scenario) {\n",
        "1027": "        List<Composite<T>> composites = Lists.newArrayList();\n",
        "1028": "        for (T t : scenario.strictlyOrderedList) {\n",
        "1029": "          composites.add(new Composite<T>(t, 1));\n",
        "1030": "          composites.add(new Composite<T>(t, 2));\n",
        "1031": "        }\n",
        "1032": "        Ordering<Composite<T>> ordering =\n",
        "1033": "            scenario.ordering.onResultOf(Composite.<T>getValueFunction())\n",
        "1034": "                .compound(Ordering.natural());\n",
        "1035": "        return new Scenario<Composite<T>>(ordering, composites, new Composite[0]);\n",
        "1036": "      }\n",
        "1037": "    },\n",
        "1038": "    COMPOUND_NATURAL_WITH_THIS {\n",
        "1039": "      @SuppressWarnings(\"unchecked\") // raw array\n",
        "1040": "      @Override <T> Scenario<?> mutate(Scenario<T> scenario) {\n",
        "1041": "        List<Composite<T>> composites = Lists.newArrayList();\n",
        "1042": "        for (T t : scenario.strictlyOrderedList) {\n",
        "1043": "          composites.add(new Composite<T>(t, 1));\n",
        "1044": "        }\n",
        "1045": "        for (T t : scenario.strictlyOrderedList) {\n",
        "1046": "          composites.add(new Composite<T>(t, 2));\n",
        "1047": "        }\n",
        "1048": "        Ordering<Composite<T>> ordering = Ordering.natural().compound(\n",
        "1049": "            scenario.ordering.onResultOf(Composite.<T>getValueFunction()));\n",
        "1050": "        return new Scenario<Composite<T>>(ordering, composites, new Composite[0]);\n",
        "1051": "      }\n",
        "1052": "    },\n",
        "1053": "    LEXICOGRAPHICAL {\n",
        "1054": "      @SuppressWarnings(\"unchecked\") // dang varargs\n",
        "1055": "      @Override <T> Scenario<?> mutate(Scenario<T> scenario) {\n",
        "1056": "        List<Iterable<T>> words = Lists.newArrayList();\n",
        "1057": "        words.add(Collections.<T>emptyList());\n",
        "1058": "        for (T t : scenario.strictlyOrderedList) {\n",
        "1059": "          words.add(Arrays.asList(t));\n",
        "1060": "          for (T s : scenario.strictlyOrderedList) {\n",
        "1061": "            words.add(Arrays.asList(t, s));\n",
        "1062": "          }\n",
        "1063": "        }\n",
        "1064": "        return new Scenario<Iterable<T>>(\n",
        "1065": "            scenario.ordering.lexicographical(), words, new Iterable[0]);\n",
        "1066": "      }\n",
        "1067": "    },\n",
        "1068": "    ;\n",
        "1069": "\n",
        "1070": "    abstract <T> Scenario<?> mutate(Scenario<T> scenario);\n",
        "1071": "  }\n",
        "1072": "\n",
        "1073": "  /**\n",
        "1074": "   * A dummy object we create so that we can have something meaningful to have\n",
        "1075": "   * a compound ordering over.\n",
        "1076": "   */\n",
        "1077": "  private static class Composite<T> implements Comparable<Composite<T>> {\n",
        "1078": "    final T value;\n",
        "1079": "    final int rank;\n",
        "1080": "\n",
        "1081": "    Composite(T value, int rank) {\n",
        "1082": "      this.value = value;\n",
        "1083": "      this.rank = rank;\n",
        "1084": "    }\n",
        "1085": "\n",
        "1086": "    // natural order is by rank only; the test will compound() this with the\n",
        "1087": "    // order of 't'.\n",
        "1088": "    @Override\n",
        "1089": "    public int compareTo(Composite<T> that) {\n",
        "1090": "      return Ints.compare(rank, that.rank);\n",
        "1091": "    }\n",
        "1092": "\n",
        "1093": "    static <T> Function<Composite<T>, T> getValueFunction() {\n",
        "1094": "      return new Function<Composite<T>, T>() {\n",
        "1095": "        @Override\n",
        "1096": "        public T apply(Composite<T> from) {\n",
        "1097": "          return from.value;\n",
        "1098": "        }\n",
        "1099": "      };\n",
        "1100": "    }\n",
        "1101": "  }\n",
        "1102": "\n",
        "1103": "  private static <T> List<T> shuffledCopy(List<T> in, Random random) {\n",
        "1104": "    List<T> mutable = newArrayList(in);\n",
        "1105": "    List<T> out = newArrayList();\n",
        "1106": "    while (!mutable.isEmpty()) {\n",
        "1107": "      out.add(mutable.remove(random.nextInt(mutable.size())));\n",
        "1108": "    }\n",
        "1109": "    return out;\n",
        "1110": "  }\n",
        "1111": "}\n",
        "1112": "\n"
    }
}