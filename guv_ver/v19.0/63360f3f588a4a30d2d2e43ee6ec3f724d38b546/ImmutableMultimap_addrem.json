{
    "addition": {},
    "removed": {
        "1": "/*\n",
        "2": " * Copyright (C) 2008 The Guava Authors\n",
        "3": " *\n",
        "4": " * Licensed under the Apache License, Version 2.0 (the \"License\");\n",
        "5": " * you may not use this file except in compliance with the License.\n",
        "6": " * You may obtain a copy of the License at\n",
        "7": " *\n",
        "8": " * http://www.apache.org/licenses/LICENSE-2.0\n",
        "9": " *\n",
        "10": " * Unless required by applicable law or agreed to in writing, software\n",
        "11": " * distributed under the License is distributed on an \"AS IS\" BASIS,\n",
        "12": " * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n",
        "13": " * See the License for the specific language governing permissions and\n",
        "14": " * limitations under the License.\n",
        "15": " */\n",
        "16": "\n",
        "17": "package com.google.common.collect;\n",
        "18": "\n",
        "19": "import static com.google.common.base.Preconditions.checkNotNull;\n",
        "20": "import static com.google.common.collect.CollectPreconditions.checkEntryNotNull;\n",
        "21": "\n",
        "22": "import com.google.common.annotations.Beta;\n",
        "23": "import com.google.common.annotations.GwtCompatible;\n",
        "24": "import com.google.j2objc.annotations.Weak;\n",
        "25": "import com.google.j2objc.annotations.WeakOuter;\n",
        "26": "\n",
        "27": "import java.io.Serializable;\n",
        "28": "import java.util.Arrays;\n",
        "29": "import java.util.Collection;\n",
        "30": "import java.util.Collections;\n",
        "31": "import java.util.Comparator;\n",
        "32": "import java.util.Iterator;\n",
        "33": "import java.util.List;\n",
        "34": "import java.util.Map;\n",
        "35": "import java.util.Map.Entry;\n",
        "36": "import java.util.Set;\n",
        "37": "\n",
        "38": "import javax.annotation.Nullable;\n",
        "39": "\n",
        "40": "/**\n",
        "41": " * A {@link Multimap} whose contents will never change, with many other important properties\n",
        "42": " * detailed at {@link ImmutableCollection}.\n",
        "43": " *\n",
        "44": " * <p><b>Warning:</b> avoid <i>direct</i> usage of {@link ImmutableMultimap} as a type (as with\n",
        "45": " * {@link Multimap} itself). Prefer subtypes such as {@link ImmutableSetMultimap} or {@link\n",
        "46": " * ImmutableListMultimap}, which have well-defined {@link #equals} semantics, thus avoiding a common\n",
        "47": " * source of bugs and confusion.\n",
        "48": " *\n",
        "49": " * <p><b>Note:</b> every {@link ImmutableMultimap} offers an {@link #inverse} view, so there is no\n",
        "50": " * need for a distinct {@code ImmutableBiMultimap} type.\n",
        "51": " *\n",
        "52": " * <a name=\"iteration\"></a>\n",
        "53": " * <p><b>Key-grouped iteration.</b> All view collections follow the same iteration order. In all\n",
        "54": " * current implementations, the iteration order always keeps multiple entries with the same key\n",
        "55": " * together. Any creation method that would customarily respect insertion order (such as {@link\n",
        "56": " * #copyOf(Multimap)}) instead preserves key-grouped order by inserting entries for an existing key\n",
        "57": " * immediately after the last entry having that key.\n",
        "58": " *\n",
        "59": " * <p>See the Guava User Guide article on <a href=\n",
        "60": " * \"https://github.com/google/guava/wiki/ImmutableCollectionsExplained\">\n",
        "61": " * immutable collections</a>.\n",
        "62": " *\n",
        "63": " * @author Jared Levy\n",
        "64": " * @since 2.0\n",
        "65": " */\n",
        "66": "@GwtCompatible(emulated = true)\n",
        "67": "public abstract class ImmutableMultimap<K, V> extends AbstractMultimap<K, V>\n",
        "68": "    implements Serializable {\n",
        "69": "\n",
        "70": "  /** Returns an empty multimap. */\n",
        "71": "  public static <K, V> ImmutableMultimap<K, V> of() {\n",
        "72": "    return ImmutableListMultimap.of();\n",
        "73": "  }\n",
        "74": "\n",
        "75": "  /**\n",
        "76": "   * Returns an immutable multimap containing a single entry.\n",
        "77": "   */\n",
        "78": "  public static <K, V> ImmutableMultimap<K, V> of(K k1, V v1) {\n",
        "79": "    return ImmutableListMultimap.of(k1, v1);\n",
        "80": "  }\n",
        "81": "\n",
        "82": "  /**\n",
        "83": "   * Returns an immutable multimap containing the given entries, in order.\n",
        "84": "   */\n",
        "85": "  public static <K, V> ImmutableMultimap<K, V> of(K k1, V v1, K k2, V v2) {\n",
        "86": "    return ImmutableListMultimap.of(k1, v1, k2, v2);\n",
        "87": "  }\n",
        "88": "\n",
        "89": "  /**\n",
        "90": "   * Returns an immutable multimap containing the given entries, in the\n",
        "91": "   * \"key-grouped\" insertion order described in the\n",
        "92": "   * <a href=\"#iteration\">class documentation</a>.\n",
        "93": "   */\n",
        "94": "  public static <K, V> ImmutableMultimap<K, V> of(K k1, V v1, K k2, V v2, K k3, V v3) {\n",
        "95": "    return ImmutableListMultimap.of(k1, v1, k2, v2, k3, v3);\n",
        "96": "  }\n",
        "97": "\n",
        "98": "  /**\n",
        "99": "   * Returns an immutable multimap containing the given entries, in the\n",
        "100": "   * \"key-grouped\" insertion order described in the\n",
        "101": "   * <a href=\"#iteration\">class documentation</a>.\n",
        "102": "   */\n",
        "103": "  public static <K, V> ImmutableMultimap<K, V> of(K k1, V v1, K k2, V v2, K k3, V v3, K k4, V v4) {\n",
        "104": "    return ImmutableListMultimap.of(k1, v1, k2, v2, k3, v3, k4, v4);\n",
        "105": "  }\n",
        "106": "\n",
        "107": "  /**\n",
        "108": "   * Returns an immutable multimap containing the given entries, in the\n",
        "109": "   * \"key-grouped\" insertion order described in the\n",
        "110": "   * <a href=\"#iteration\">class documentation</a>.\n",
        "111": "   */\n",
        "112": "  public static <K, V> ImmutableMultimap<K, V> of(\n",
        "113": "      K k1, V v1, K k2, V v2, K k3, V v3, K k4, V v4, K k5, V v5) {\n",
        "114": "    return ImmutableListMultimap.of(k1, v1, k2, v2, k3, v3, k4, v4, k5, v5);\n",
        "115": "  }\n",
        "116": "\n",
        "117": "  // looking for of() with > 5 entries? Use the builder instead.\n",
        "118": "\n",
        "119": "  /**\n",
        "120": "   * Returns a new builder. The generated builder is equivalent to the builder\n",
        "121": "   * created by the {@link Builder} constructor.\n",
        "122": "   */\n",
        "123": "  public static <K, V> Builder<K, V> builder() {\n",
        "124": "    return new Builder<K, V>();\n",
        "125": "  }\n",
        "126": "\n",
        "127": "  /**\n",
        "128": "   * A builder for creating immutable multimap instances, especially\n",
        "129": "   * {@code public static final} multimaps (\"constant multimaps\"). Example:\n",
        "130": "   * <pre>   {@code\n",
        "131": "   *\n",
        "132": "   *   static final Multimap<String, Integer> STRING_TO_INTEGER_MULTIMAP =\n",
        "133": "   *       new ImmutableMultimap.Builder<String, Integer>()\n",
        "134": "   *           .put(\"one\", 1)\n",
        "135": "   *           .putAll(\"several\", 1, 2, 3)\n",
        "136": "   *           .putAll(\"many\", 1, 2, 3, 4, 5)\n",
        "137": "   *           .build();}</pre>\n",
        "138": "   *\n",
        "139": "   * <p>Builder instances can be reused; it is safe to call {@link #build} multiple\n",
        "140": "   * times to build multiple multimaps in series. Each multimap contains the\n",
        "141": "   * key-value mappings in the previously created multimaps.\n",
        "142": "   *\n",
        "143": "   * @since 2.0\n",
        "144": "   */\n",
        "145": "  public static class Builder<K, V> {\n",
        "146": "    Multimap<K, V> builderMultimap;\n",
        "147": "    Comparator<? super K> keyComparator;\n",
        "148": "    Comparator<? super V> valueComparator;\n",
        "149": "\n",
        "150": "    /**\n",
        "151": "     * Creates a new builder. The returned builder is equivalent to the builder\n",
        "152": "     * generated by {@link ImmutableMultimap#builder}.\n",
        "153": "     */\n",
        "154": "    public Builder() {\n",
        "155": "      this(MultimapBuilder.linkedHashKeys().arrayListValues().<K, V>build());\n",
        "156": "    }\n",
        "157": "    \n",
        "158": "    Builder(Multimap<K, V> builderMultimap) {\n",
        "159": "      this.builderMultimap = builderMultimap;\n",
        "160": "    }\n",
        "161": "\n",
        "162": "    /**\n",
        "163": "     * Adds a key-value mapping to the built multimap.\n",
        "164": "     */\n",
        "165": "    public Builder<K, V> put(K key, V value) {\n",
        "166": "      checkEntryNotNull(key, value);\n",
        "167": "      builderMultimap.put(key, value);\n",
        "168": "      return this;\n",
        "169": "    }\n",
        "170": "\n",
        "171": "    /**\n",
        "172": "     * Adds an entry to the built multimap.\n",
        "173": "     *\n",
        "174": "     * @since 11.0\n",
        "175": "     */\n",
        "176": "    public Builder<K, V> put(Entry<? extends K, ? extends V> entry) {\n",
        "177": "      return put(entry.getKey(), entry.getValue());\n",
        "178": "    }\n",
        "179": "\n",
        "180": "    /**\n",
        "181": "     * Adds entries to the built multimap.\n",
        "182": "     *\n",
        "183": "     * @since 19.0\n",
        "184": "     */\n",
        "185": "    @Beta\n",
        "186": "    public Builder<K, V> putAll(Iterable<? extends Entry<? extends K, ? extends V>> entries) {\n",
        "187": "      for (Entry<? extends K, ? extends V> entry : entries) {\n",
        "188": "        put(entry);\n",
        "189": "      }\n",
        "190": "      return this;\n",
        "191": "    }\n",
        "192": "\n",
        "193": "    /**\n",
        "194": "     * Stores a collection of values with the same key in the built multimap.\n",
        "195": "     *\n",
        "196": "     * @throws NullPointerException if {@code key}, {@code values}, or any\n",
        "197": "     *     element in {@code values} is null. The builder is left in an invalid\n",
        "198": "     *     state.\n",
        "199": "     */\n",
        "200": "    public Builder<K, V> putAll(K key, Iterable<? extends V> values) {\n",
        "201": "      if (key == null) {\n",
        "202": "        throw new NullPointerException(\"null key in entry: null=\" + Iterables.toString(values));\n",
        "203": "      }\n",
        "204": "      Collection<V> valueList = builderMultimap.get(key);\n",
        "205": "      for (V value : values) {\n",
        "206": "        checkEntryNotNull(key, value);\n",
        "207": "        valueList.add(value);\n",
        "208": "      }\n",
        "209": "      return this;\n",
        "210": "    }\n",
        "211": "\n",
        "212": "    /**\n",
        "213": "     * Stores an array of values with the same key in the built multimap.\n",
        "214": "     *\n",
        "215": "     * @throws NullPointerException if the key or any value is null. The builder\n",
        "216": "     *     is left in an invalid state.\n",
        "217": "     */\n",
        "218": "    public Builder<K, V> putAll(K key, V... values) {\n",
        "219": "      return putAll(key, Arrays.asList(values));\n",
        "220": "    }\n",
        "221": "\n",
        "222": "    /**\n",
        "223": "     * Stores another multimap's entries in the built multimap. The generated\n",
        "224": "     * multimap's key and value orderings correspond to the iteration ordering\n",
        "225": "     * of the {@code multimap.asMap()} view, with new keys and values following\n",
        "226": "     * any existing keys and values.\n",
        "227": "     *\n",
        "228": "     * @throws NullPointerException if any key or value in {@code multimap} is\n",
        "229": "     *     null. The builder is left in an invalid state.\n",
        "230": "     */\n",
        "231": "    public Builder<K, V> putAll(Multimap<? extends K, ? extends V> multimap) {\n",
        "232": "      for (Entry<? extends K, ? extends Collection<? extends V>> entry :\n",
        "233": "          multimap.asMap().entrySet()) {\n",
        "234": "        putAll(entry.getKey(), entry.getValue());\n",
        "235": "      }\n",
        "236": "      return this;\n",
        "237": "    }\n",
        "238": "\n",
        "239": "    /**\n",
        "240": "     * Specifies the ordering of the generated multimap's keys.\n",
        "241": "     *\n",
        "242": "     * @since 8.0\n",
        "243": "     */\n",
        "244": "    public Builder<K, V> orderKeysBy(Comparator<? super K> keyComparator) {\n",
        "245": "      this.keyComparator = checkNotNull(keyComparator);\n",
        "246": "      return this;\n",
        "247": "    }\n",
        "248": "\n",
        "249": "    /**\n",
        "250": "     * Specifies the ordering of the generated multimap's values for each key.\n",
        "251": "     *\n",
        "252": "     * @since 8.0\n",
        "253": "     */\n",
        "254": "    public Builder<K, V> orderValuesBy(Comparator<? super V> valueComparator) {\n",
        "255": "      this.valueComparator = checkNotNull(valueComparator);\n",
        "256": "      return this;\n",
        "257": "    }\n",
        "258": "\n",
        "259": "    /**\n",
        "260": "     * Returns a newly-created immutable multimap.\n",
        "261": "     */\n",
        "262": "    public ImmutableMultimap<K, V> build() {\n",
        "263": "      if (valueComparator != null) {\n",
        "264": "        for (Collection<V> values : builderMultimap.asMap().values()) {\n",
        "265": "          List<V> list = (List<V>) values;\n",
        "266": "          Collections.sort(list, valueComparator);\n",
        "267": "        }\n",
        "268": "      }\n",
        "269": "      if (keyComparator != null) {\n",
        "270": "        Multimap<K, V> sortedCopy =\n",
        "271": "            MultimapBuilder.linkedHashKeys().arrayListValues().<K, V>build();\n",
        "272": "        List<Map.Entry<K, Collection<V>>> entries =\n",
        "273": "            Ordering.from(keyComparator)\n",
        "274": "                .<K>onKeys()\n",
        "275": "                .immutableSortedCopy(builderMultimap.asMap().entrySet());\n",
        "276": "        for (Map.Entry<K, Collection<V>> entry : entries) {\n",
        "277": "          sortedCopy.putAll(entry.getKey(), entry.getValue());\n",
        "278": "        }\n",
        "279": "        builderMultimap = sortedCopy;\n",
        "280": "      }\n",
        "281": "      return copyOf(builderMultimap);\n",
        "282": "    }\n",
        "283": "  }\n",
        "284": "\n",
        "285": "  /**\n",
        "286": "   * Returns an immutable multimap containing the same mappings as {@code\n",
        "287": "   * multimap}, in the \"key-grouped\" iteration order described in the class\n",
        "288": "   * documentation.\n",
        "289": "   *\n",
        "290": "   * <p>Despite the method name, this method attempts to avoid actually copying\n",
        "291": "   * the data when it is safe to do so. The exact circumstances under which a\n",
        "292": "   * copy will or will not be performed are undocumented and subject to change.\n",
        "293": "   *\n",
        "294": "   * @throws NullPointerException if any key or value in {@code multimap} is\n",
        "295": "   *         null\n",
        "296": "   */\n",
        "297": "  public static <K, V> ImmutableMultimap<K, V> copyOf(Multimap<? extends K, ? extends V> multimap) {\n",
        "298": "    if (multimap instanceof ImmutableMultimap) {\n",
        "299": "      @SuppressWarnings(\"unchecked\") // safe since multimap is not writable\n",
        "300": "      ImmutableMultimap<K, V> kvMultimap = (ImmutableMultimap<K, V>) multimap;\n",
        "301": "      if (!kvMultimap.isPartialView()) {\n",
        "302": "        return kvMultimap;\n",
        "303": "      }\n",
        "304": "    }\n",
        "305": "    return ImmutableListMultimap.copyOf(multimap);\n",
        "306": "  }\n",
        "307": "\n",
        "308": "  /**\n",
        "309": "   * Returns an immutable multimap containing the specified entries.  The\n",
        "310": "   * returned multimap iterates over keys in the order they were first\n",
        "311": "   * encountered in the input, and the values for each key are iterated in the\n",
        "312": "   * order they were encountered.\n",
        "313": "   *\n",
        "314": "   * @throws NullPointerException if any key, value, or entry is null\n",
        "315": "   * @since 19.0\n",
        "316": "   */\n",
        "317": "  @Beta\n",
        "318": "  public static <K, V> ImmutableMultimap<K, V> copyOf(\n",
        "319": "      Iterable<? extends Entry<? extends K, ? extends V>> entries) {\n",
        "320": "    return ImmutableListMultimap.copyOf(entries);\n",
        "321": "  }\n",
        "322": "\n",
        "323": "  final transient ImmutableMap<K, ? extends ImmutableCollection<V>> map;\n",
        "324": "  final transient int size;\n",
        "325": "\n",
        "326": "  // These constants allow the deserialization code to set final fields. This\n",
        "327": "  // holder class makes sure they are not initialized unless an instance is\n",
        "328": "  // deserialized.\n",
        "329": "\n",
        "330": "  ImmutableMultimap(ImmutableMap<K, ? extends ImmutableCollection<V>> map, int size) {\n",
        "331": "    this.map = map;\n",
        "332": "    this.size = size;\n",
        "333": "  }\n",
        "334": "\n",
        "335": "  // mutators (not supported)\n",
        "336": "\n",
        "337": "  /**\n",
        "338": "   * Guaranteed to throw an exception and leave the multimap unmodified.\n",
        "339": "   *\n",
        "340": "   * @throws UnsupportedOperationException always\n",
        "341": "   * @deprecated Unsupported operation.\n",
        "342": "   */\n",
        "343": "  @Deprecated\n",
        "344": "  @Override\n",
        "345": "  public ImmutableCollection<V> removeAll(Object key) {\n",
        "346": "    throw new UnsupportedOperationException();\n",
        "347": "  }\n",
        "348": "\n",
        "349": "  /**\n",
        "350": "   * Guaranteed to throw an exception and leave the multimap unmodified.\n",
        "351": "   *\n",
        "352": "   * @throws UnsupportedOperationException always\n",
        "353": "   * @deprecated Unsupported operation.\n",
        "354": "   */\n",
        "355": "  @Deprecated\n",
        "356": "  @Override\n",
        "357": "  public ImmutableCollection<V> replaceValues(K key, Iterable<? extends V> values) {\n",
        "358": "    throw new UnsupportedOperationException();\n",
        "359": "  }\n",
        "360": "\n",
        "361": "  /**\n",
        "362": "   * Guaranteed to throw an exception and leave the multimap unmodified.\n",
        "363": "   *\n",
        "364": "   * @throws UnsupportedOperationException always\n",
        "365": "   * @deprecated Unsupported operation.\n",
        "366": "   */\n",
        "367": "  @Deprecated\n",
        "368": "  @Override\n",
        "369": "  public void clear() {\n",
        "370": "    throw new UnsupportedOperationException();\n",
        "371": "  }\n",
        "372": "\n",
        "373": "  /**\n",
        "374": "   * Returns an immutable collection of the values for the given key.  If no\n",
        "375": "   * mappings in the multimap have the provided key, an empty immutable\n",
        "376": "   * collection is returned. The values are in the same order as the parameters\n",
        "377": "   * used to build this multimap.\n",
        "378": "   */\n",
        "379": "  @Override\n",
        "380": "  public abstract ImmutableCollection<V> get(K key);\n",
        "381": "\n",
        "382": "  /**\n",
        "383": "   * Returns an immutable multimap which is the inverse of this one. For every\n",
        "384": "   * key-value mapping in the original, the result will have a mapping with\n",
        "385": "   * key and value reversed.\n",
        "386": "   *\n",
        "387": "   * @since 11.0\n",
        "388": "   */\n",
        "389": "  public abstract ImmutableMultimap<V, K> inverse();\n",
        "390": "\n",
        "391": "  /**\n",
        "392": "   * Guaranteed to throw an exception and leave the multimap unmodified.\n",
        "393": "   *\n",
        "394": "   * @throws UnsupportedOperationException always\n",
        "395": "   * @deprecated Unsupported operation.\n",
        "396": "   */\n",
        "397": "  @Deprecated\n",
        "398": "  @Override\n",
        "399": "  public boolean put(K key, V value) {\n",
        "400": "    throw new UnsupportedOperationException();\n",
        "401": "  }\n",
        "402": "\n",
        "403": "  /**\n",
        "404": "   * Guaranteed to throw an exception and leave the multimap unmodified.\n",
        "405": "   *\n",
        "406": "   * @throws UnsupportedOperationException always\n",
        "407": "   * @deprecated Unsupported operation.\n",
        "408": "   */\n",
        "409": "  @Deprecated\n",
        "410": "  @Override\n",
        "411": "  public boolean putAll(K key, Iterable<? extends V> values) {\n",
        "412": "    throw new UnsupportedOperationException();\n",
        "413": "  }\n",
        "414": "\n",
        "415": "  /**\n",
        "416": "   * Guaranteed to throw an exception and leave the multimap unmodified.\n",
        "417": "   *\n",
        "418": "   * @throws UnsupportedOperationException always\n",
        "419": "   * @deprecated Unsupported operation.\n",
        "420": "   */\n",
        "421": "  @Deprecated\n",
        "422": "  @Override\n",
        "423": "  public boolean putAll(Multimap<? extends K, ? extends V> multimap) {\n",
        "424": "    throw new UnsupportedOperationException();\n",
        "425": "  }\n",
        "426": "\n",
        "427": "  /**\n",
        "428": "   * Guaranteed to throw an exception and leave the multimap unmodified.\n",
        "429": "   *\n",
        "430": "   * @throws UnsupportedOperationException always\n",
        "431": "   * @deprecated Unsupported operation.\n",
        "432": "   */\n",
        "433": "  @Deprecated\n",
        "434": "  @Override\n",
        "435": "  public boolean remove(Object key, Object value) {\n",
        "436": "    throw new UnsupportedOperationException();\n",
        "437": "  }\n",
        "438": "\n",
        "439": "  /**\n",
        "440": "   * Returns {@code true} if this immutable multimap's implementation contains references to\n",
        "441": "   * user-created objects that aren't accessible via this multimap's methods. This is generally\n",
        "442": "   * used to determine whether {@code copyOf} implementations should make an explicit copy to avoid\n",
        "443": "   * memory leaks.\n",
        "444": "   */\n",
        "445": "  boolean isPartialView() {\n",
        "446": "    return map.isPartialView();\n",
        "447": "  }\n",
        "448": "\n",
        "449": "  // accessors\n",
        "450": "\n",
        "451": "  @Override\n",
        "452": "  public boolean containsKey(@Nullable Object key) {\n",
        "453": "    return map.containsKey(key);\n",
        "454": "  }\n",
        "455": "\n",
        "456": "  @Override\n",
        "457": "  public boolean containsValue(@Nullable Object value) {\n",
        "458": "    return value != null && super.containsValue(value);\n",
        "459": "  }\n",
        "460": "\n",
        "461": "  @Override\n",
        "462": "  public int size() {\n",
        "463": "    return size;\n",
        "464": "  }\n",
        "465": "\n",
        "466": "  // views\n",
        "467": "\n",
        "468": "  /**\n",
        "469": "   * Returns an immutable set of the distinct keys in this multimap, in the same\n",
        "470": "   * order as they appear in this multimap.\n",
        "471": "   */\n",
        "472": "  @Override\n",
        "473": "  public ImmutableSet<K> keySet() {\n",
        "474": "    return map.keySet();\n",
        "475": "  }\n",
        "476": "\n",
        "477": "  /**\n",
        "478": "   * Returns an immutable map that associates each key with its corresponding\n",
        "479": "   * values in the multimap. Keys and values appear in the same order as in this\n",
        "480": "   * multimap.\n",
        "481": "   */\n",
        "482": "  @Override\n",
        "483": "  @SuppressWarnings(\"unchecked\") // a widening cast\n",
        "484": "  public ImmutableMap<K, Collection<V>> asMap() {\n",
        "485": "    return (ImmutableMap) map;\n",
        "486": "  }\n",
        "487": "\n",
        "488": "  @Override\n",
        "489": "  Map<K, Collection<V>> createAsMap() {\n",
        "490": "    throw new AssertionError(\"should never be called\");\n",
        "491": "  }\n",
        "492": "\n",
        "493": "  /**\n",
        "494": "   * Returns an immutable collection of all key-value pairs in the multimap.\n",
        "495": "   */\n",
        "496": "  @Override\n",
        "497": "  public ImmutableCollection<Entry<K, V>> entries() {\n",
        "498": "    return (ImmutableCollection<Entry<K, V>>) super.entries();\n",
        "499": "  }\n",
        "500": "\n",
        "501": "  @Override\n",
        "502": "  ImmutableCollection<Entry<K, V>> createEntries() {\n",
        "503": "    return new EntryCollection<K, V>(this);\n",
        "504": "  }\n",
        "505": "\n",
        "506": "  private static class EntryCollection<K, V> extends ImmutableCollection<Entry<K, V>> {\n",
        "507": "    @Weak final ImmutableMultimap<K, V> multimap;\n",
        "508": "\n",
        "509": "    EntryCollection(ImmutableMultimap<K, V> multimap) {\n",
        "510": "      this.multimap = multimap;\n",
        "511": "    }\n",
        "512": "\n",
        "513": "    @Override\n",
        "514": "    public UnmodifiableIterator<Entry<K, V>> iterator() {\n",
        "515": "      return multimap.entryIterator();\n",
        "516": "    }\n",
        "517": "\n",
        "518": "    @Override\n",
        "519": "    boolean isPartialView() {\n",
        "520": "      return multimap.isPartialView();\n",
        "521": "    }\n",
        "522": "\n",
        "523": "    @Override\n",
        "524": "    public int size() {\n",
        "525": "      return multimap.size();\n",
        "526": "    }\n",
        "527": "\n",
        "528": "    @Override\n",
        "529": "    public boolean contains(Object object) {\n",
        "530": "      if (object instanceof Entry) {\n",
        "531": "        Entry<?, ?> entry = (Entry<?, ?>) object;\n",
        "532": "        return multimap.containsEntry(entry.getKey(), entry.getValue());\n",
        "533": "      }\n",
        "534": "      return false;\n",
        "535": "    }\n",
        "536": "\n",
        "537": "    private static final long serialVersionUID = 0;\n",
        "538": "  }\n",
        "539": "\n",
        "540": "  private abstract class Itr<T> extends UnmodifiableIterator<T> {\n",
        "541": "    final Iterator<Entry<K, Collection<V>>> mapIterator = asMap().entrySet().iterator();\n",
        "542": "    K key = null;\n",
        "543": "    Iterator<V> valueIterator = Iterators.emptyIterator();\n",
        "544": "\n",
        "545": "    abstract T output(K key, V value);\n",
        "546": "\n",
        "547": "    @Override\n",
        "548": "    public boolean hasNext() {\n",
        "549": "      return mapIterator.hasNext() || valueIterator.hasNext();\n",
        "550": "    }\n",
        "551": "\n",
        "552": "    @Override\n",
        "553": "    public T next() {\n",
        "554": "      if (!valueIterator.hasNext()) {\n",
        "555": "        Entry<K, Collection<V>> mapEntry = mapIterator.next();\n",
        "556": "        key = mapEntry.getKey();\n",
        "557": "        valueIterator = mapEntry.getValue().iterator();\n",
        "558": "      }\n",
        "559": "      return output(key, valueIterator.next());\n",
        "560": "    }\n",
        "561": "  }\n",
        "562": "\n",
        "563": "  @Override\n",
        "564": "  UnmodifiableIterator<Entry<K, V>> entryIterator() {\n",
        "565": "    return new Itr<Entry<K, V>>() {\n",
        "566": "      @Override\n",
        "567": "      Entry<K, V> output(K key, V value) {\n",
        "568": "        return Maps.immutableEntry(key, value);\n",
        "569": "      }\n",
        "570": "    };\n",
        "571": "  }\n",
        "572": "\n",
        "573": "  /**\n",
        "574": "   * Returns an immutable multiset containing all the keys in this multimap, in\n",
        "575": "   * the same order and with the same frequencies as they appear in this\n",
        "576": "   * multimap; to get only a single occurrence of each key, use {@link #keySet}.\n",
        "577": "   */\n",
        "578": "  @Override\n",
        "579": "  public ImmutableMultiset<K> keys() {\n",
        "580": "    return (ImmutableMultiset<K>) super.keys();\n",
        "581": "  }\n",
        "582": "\n",
        "583": "  @Override\n",
        "584": "  ImmutableMultiset<K> createKeys() {\n",
        "585": "    return new Keys();\n",
        "586": "  }\n",
        "587": "\n",
        "588": "  @SuppressWarnings(\"serial\") // Uses writeReplace, not default serialization\n",
        "589": "  @WeakOuter\n",
        "590": "  class Keys extends ImmutableMultiset<K> {\n",
        "591": "    @Override\n",
        "592": "    public boolean contains(@Nullable Object object) {\n",
        "593": "      return containsKey(object);\n",
        "594": "    }\n",
        "595": "\n",
        "596": "    @Override\n",
        "597": "    public int count(@Nullable Object element) {\n",
        "598": "      Collection<V> values = map.get(element);\n",
        "599": "      return (values == null) ? 0 : values.size();\n",
        "600": "    }\n",
        "601": "\n",
        "602": "    @Override\n",
        "603": "    public Set<K> elementSet() {\n",
        "604": "      return keySet();\n",
        "605": "    }\n",
        "606": "\n",
        "607": "    @Override\n",
        "608": "    public int size() {\n",
        "609": "      return ImmutableMultimap.this.size();\n",
        "610": "    }\n",
        "611": "\n",
        "612": "    @Override\n",
        "613": "    Multiset.Entry<K> getEntry(int index) {\n",
        "614": "      Map.Entry<K, ? extends Collection<V>> entry = map.entrySet().asList().get(index);\n",
        "615": "      return Multisets.immutableEntry(entry.getKey(), entry.getValue().size());\n",
        "616": "    }\n",
        "617": "\n",
        "618": "    @Override\n",
        "619": "    boolean isPartialView() {\n",
        "620": "      return true;\n",
        "621": "    }\n",
        "622": "  }\n",
        "623": "\n",
        "624": "  /**\n",
        "625": "   * Returns an immutable collection of the values in this multimap. Its\n",
        "626": "   * iterator traverses the values for the first key, the values for the second\n",
        "627": "   * key, and so on.\n",
        "628": "   */\n",
        "629": "  @Override\n",
        "630": "  public ImmutableCollection<V> values() {\n",
        "631": "    return (ImmutableCollection<V>) super.values();\n",
        "632": "  }\n",
        "633": "\n",
        "634": "  @Override\n",
        "635": "  ImmutableCollection<V> createValues() {\n",
        "636": "    return new Values<K, V>(this);\n",
        "637": "  }\n",
        "638": "\n",
        "639": "  @Override\n",
        "640": "  UnmodifiableIterator<V> valueIterator() {\n",
        "641": "    return new Itr<V>() {\n",
        "642": "      @Override\n",
        "643": "      V output(K key, V value) {\n",
        "644": "        return value;\n",
        "645": "      }\n",
        "646": "    };\n",
        "647": "  }\n",
        "648": "\n",
        "649": "  private static final class Values<K, V> extends ImmutableCollection<V> {\n",
        "650": "    @Weak private final transient ImmutableMultimap<K, V> multimap;\n",
        "651": "\n",
        "652": "    Values(ImmutableMultimap<K, V> multimap) {\n",
        "653": "      this.multimap = multimap;\n",
        "654": "    }\n",
        "655": "\n",
        "656": "    @Override\n",
        "657": "    public boolean contains(@Nullable Object object) {\n",
        "658": "      return multimap.containsValue(object);\n",
        "659": "    }\n",
        "660": "\n",
        "661": "    @Override\n",
        "662": "    public UnmodifiableIterator<V> iterator() {\n",
        "663": "      return multimap.valueIterator();\n",
        "664": "    }\n",
        "665": "\n",
        "666": "    @Override\n",
        "667": "    public int size() {\n",
        "668": "      return multimap.size();\n",
        "669": "    }\n",
        "670": "\n",
        "671": "    @Override\n",
        "672": "    boolean isPartialView() {\n",
        "673": "      return true;\n",
        "674": "    }\n",
        "675": "\n",
        "676": "    private static final long serialVersionUID = 0;\n",
        "677": "  }\n",
        "678": "\n",
        "679": "  private static final long serialVersionUID = 0;\n",
        "680": "}\n",
        "681": "\n"
    }
}