{
    "addition": {},
    "removed": {
        "1": "/*\n",
        "2": " * Copyright (C) 2007 The Guava Authors\n",
        "3": " *\n",
        "4": " * Licensed under the Apache License, Version 2.0 (the \"License\");\n",
        "5": " * you may not use this file except in compliance with the License.\n",
        "6": " * You may obtain a copy of the License at\n",
        "7": " *\n",
        "8": " * http://www.apache.org/licenses/LICENSE-2.0\n",
        "9": " *\n",
        "10": " * Unless required by applicable law or agreed to in writing, software\n",
        "11": " * distributed under the License is distributed on an \"AS IS\" BASIS,\n",
        "12": " * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n",
        "13": " * See the License for the specific language governing permissions and\n",
        "14": " * limitations under the License.\n",
        "15": " */\n",
        "16": "\n",
        "17": "package com.google.common.collect;\n",
        "18": "\n",
        "19": "import static com.google.common.base.Preconditions.checkArgument;\n",
        "20": "import static com.google.common.base.Preconditions.checkNotNull;\n",
        "21": "import static com.google.common.collect.CollectPreconditions.checkRemove;\n",
        "22": "\n",
        "23": "import com.google.common.annotations.Beta;\n",
        "24": "import com.google.common.annotations.GwtCompatible;\n",
        "25": "import com.google.common.base.Function;\n",
        "26": "import com.google.common.base.Optional;\n",
        "27": "import com.google.common.base.Predicate;\n",
        "28": "\n",
        "29": "import java.util.Collection;\n",
        "30": "import java.util.Comparator;\n",
        "31": "import java.util.Iterator;\n",
        "32": "import java.util.List;\n",
        "33": "import java.util.NoSuchElementException;\n",
        "34": "import java.util.Queue;\n",
        "35": "import java.util.RandomAccess;\n",
        "36": "import java.util.Set;\n",
        "37": "\n",
        "38": "import javax.annotation.CheckReturnValue;\n",
        "39": "import javax.annotation.Nullable;\n",
        "40": "\n",
        "41": "/**\n",
        "42": " * This class contains static utility methods that operate on or return objects\n",
        "43": " * of type {@code Iterable}. Except as noted, each method has a corresponding\n",
        "44": " * {@link Iterator}-based method in the {@link Iterators} class.\n",
        "45": " *\n",
        "46": " * <p><i>Performance notes:</i> Unless otherwise noted, all of the iterables\n",
        "47": " * produced in this class are <i>lazy</i>, which means that their iterators\n",
        "48": " * only advance the backing iteration when absolutely necessary.\n",
        "49": " *\n",
        "50": " * <p>See the Guava User Guide article on <a href=\n",
        "51": " * \"https://github.com/google/guava/wiki/CollectionUtilitiesExplained#iterables\">\n",
        "52": " * {@code Iterables}</a>.\n",
        "53": " *\n",
        "54": " * @author Kevin Bourrillion\n",
        "55": " * @author Jared Levy\n",
        "56": " * @since 2.0\n",
        "57": " */\n",
        "58": "@GwtCompatible(emulated = true)\n",
        "59": "public final class Iterables {\n",
        "60": "  private Iterables() {}\n",
        "61": "\n",
        "62": "  /** Returns an unmodifiable view of {@code iterable}. */\n",
        "63": "  public static <T> Iterable<T> unmodifiableIterable(final Iterable<T> iterable) {\n",
        "64": "    checkNotNull(iterable);\n",
        "65": "    if (iterable instanceof UnmodifiableIterable || iterable instanceof ImmutableCollection) {\n",
        "66": "      return iterable;\n",
        "67": "    }\n",
        "68": "    return new UnmodifiableIterable<T>(iterable);\n",
        "69": "  }\n",
        "70": "\n",
        "71": "  /**\n",
        "72": "   * Simply returns its argument.\n",
        "73": "   *\n",
        "74": "   * @deprecated no need to use this\n",
        "75": "   * @since 10.0\n",
        "76": "   */\n",
        "77": "  @Deprecated\n",
        "78": "  public static <E> Iterable<E> unmodifiableIterable(ImmutableCollection<E> iterable) {\n",
        "79": "    return checkNotNull(iterable);\n",
        "80": "  }\n",
        "81": "\n",
        "82": "  private static final class UnmodifiableIterable<T> extends FluentIterable<T> {\n",
        "83": "    private final Iterable<T> iterable;\n",
        "84": "\n",
        "85": "    private UnmodifiableIterable(Iterable<T> iterable) {\n",
        "86": "      this.iterable = iterable;\n",
        "87": "    }\n",
        "88": "\n",
        "89": "    @Override\n",
        "90": "    public Iterator<T> iterator() {\n",
        "91": "      return Iterators.unmodifiableIterator(iterable.iterator());\n",
        "92": "    }\n",
        "93": "\n",
        "94": "    @Override\n",
        "95": "    public String toString() {\n",
        "96": "      return iterable.toString();\n",
        "97": "    }\n",
        "98": "    // no equals and hashCode; it would break the contract!\n",
        "99": "  }\n",
        "100": "\n",
        "101": "  /**\n",
        "102": "   * Returns the number of elements in {@code iterable}.\n",
        "103": "   */\n",
        "104": "  public static int size(Iterable<?> iterable) {\n",
        "105": "    return (iterable instanceof Collection)\n",
        "106": "        ? ((Collection<?>) iterable).size()\n",
        "107": "        : Iterators.size(iterable.iterator());\n",
        "108": "  }\n",
        "109": "\n",
        "110": "  /**\n",
        "111": "   * Returns {@code true} if {@code iterable} contains any object for which {@code equals(element)}\n",
        "112": "   * is true.\n",
        "113": "   */\n",
        "114": "  public static boolean contains(Iterable<?> iterable, @Nullable Object element) {\n",
        "115": "    if (iterable instanceof Collection) {\n",
        "116": "      Collection<?> collection = (Collection<?>) iterable;\n",
        "117": "      return Collections2.safeContains(collection, element);\n",
        "118": "    }\n",
        "119": "    return Iterators.contains(iterable.iterator(), element);\n",
        "120": "  }\n",
        "121": "\n",
        "122": "  /**\n",
        "123": "   * Removes, from an iterable, every element that belongs to the provided\n",
        "124": "   * collection.\n",
        "125": "   *\n",
        "126": "   * <p>This method calls {@link Collection#removeAll} if {@code iterable} is a\n",
        "127": "   * collection, and {@link Iterators#removeAll} otherwise.\n",
        "128": "   *\n",
        "129": "   * @param removeFrom the iterable to (potentially) remove elements from\n",
        "130": "   * @param elementsToRemove the elements to remove\n",
        "131": "   * @return {@code true} if any element was removed from {@code iterable}\n",
        "132": "   */\n",
        "133": "  public static boolean removeAll(Iterable<?> removeFrom, Collection<?> elementsToRemove) {\n",
        "134": "    return (removeFrom instanceof Collection)\n",
        "135": "        ? ((Collection<?>) removeFrom).removeAll(checkNotNull(elementsToRemove))\n",
        "136": "        : Iterators.removeAll(removeFrom.iterator(), elementsToRemove);\n",
        "137": "  }\n",
        "138": "\n",
        "139": "  /**\n",
        "140": "   * Removes, from an iterable, every element that does not belong to the\n",
        "141": "   * provided collection.\n",
        "142": "   *\n",
        "143": "   * <p>This method calls {@link Collection#retainAll} if {@code iterable} is a\n",
        "144": "   * collection, and {@link Iterators#retainAll} otherwise.\n",
        "145": "   *\n",
        "146": "   * @param removeFrom the iterable to (potentially) remove elements from\n",
        "147": "   * @param elementsToRetain the elements to retain\n",
        "148": "   * @return {@code true} if any element was removed from {@code iterable}\n",
        "149": "   */\n",
        "150": "  public static boolean retainAll(Iterable<?> removeFrom, Collection<?> elementsToRetain) {\n",
        "151": "    return (removeFrom instanceof Collection)\n",
        "152": "        ? ((Collection<?>) removeFrom).retainAll(checkNotNull(elementsToRetain))\n",
        "153": "        : Iterators.retainAll(removeFrom.iterator(), elementsToRetain);\n",
        "154": "  }\n",
        "155": "\n",
        "156": "  /**\n",
        "157": "   * Removes, from an iterable, every element that satisfies the provided\n",
        "158": "   * predicate.\n",
        "159": "   *\n",
        "160": "   * <p>Removals may or may not happen immediately as each element is tested\n",
        "161": "   * against the predicate.  The behavior of this method is not specified if\n",
        "162": "   * {@code predicate} is dependent on {@code removeFrom}.\n",
        "163": "   *\n",
        "164": "   * @param removeFrom the iterable to (potentially) remove elements from\n",
        "165": "   * @param predicate a predicate that determines whether an element should\n",
        "166": "   *     be removed\n",
        "167": "   * @return {@code true} if any elements were removed from the iterable\n",
        "168": "   *\n",
        "169": "   * @throws UnsupportedOperationException if the iterable does not support\n",
        "170": "   *     {@code remove()}.\n",
        "171": "   * @since 2.0\n",
        "172": "   */\n",
        "173": "  public static <T> boolean removeIf(Iterable<T> removeFrom, Predicate<? super T> predicate) {\n",
        "174": "    if (removeFrom instanceof RandomAccess && removeFrom instanceof List) {\n",
        "175": "      return removeIfFromRandomAccessList((List<T>) removeFrom, checkNotNull(predicate));\n",
        "176": "    }\n",
        "177": "    return Iterators.removeIf(removeFrom.iterator(), predicate);\n",
        "178": "  }\n",
        "179": "\n",
        "180": "  private static <T> boolean removeIfFromRandomAccessList(\n",
        "181": "      List<T> list, Predicate<? super T> predicate) {\n",
        "182": "    // Note: Not all random access lists support set() so we need to deal with\n",
        "183": "    // those that don't and attempt the slower remove() based solution.\n",
        "184": "    int from = 0;\n",
        "185": "    int to = 0;\n",
        "186": "\n",
        "187": "    for (; from < list.size(); from++) {\n",
        "188": "      T element = list.get(from);\n",
        "189": "      if (!predicate.apply(element)) {\n",
        "190": "        if (from > to) {\n",
        "191": "          try {\n",
        "192": "            list.set(to, element);\n",
        "193": "          } catch (UnsupportedOperationException e) {\n",
        "194": "            slowRemoveIfForRemainingElements(list, predicate, to, from);\n",
        "195": "            return true;\n",
        "196": "          }\n",
        "197": "        }\n",
        "198": "        to++;\n",
        "199": "      }\n",
        "200": "    }\n",
        "201": "\n",
        "202": "    // Clear the tail of any remaining items\n",
        "203": "    list.subList(to, list.size()).clear();\n",
        "204": "    return from != to;\n",
        "205": "  }\n",
        "206": "\n",
        "207": "  private static <T> void slowRemoveIfForRemainingElements(\n",
        "208": "      List<T> list, Predicate<? super T> predicate, int to, int from) {\n",
        "209": "    // Here we know that:\n",
        "210": "    // * (to < from) and that both are valid indices.\n",
        "211": "    // * Everything with (index < to) should be kept.\n",
        "212": "    // * Everything with (to <= index < from) should be removed.\n",
        "213": "    // * The element with (index == from) should be kept.\n",
        "214": "    // * Everything with (index > from) has not been checked yet.\n",
        "215": "\n",
        "216": "    // Check from the end of the list backwards (minimize expected cost of\n",
        "217": "    // moving elements when remove() is called). Stop before 'from' because\n",
        "218": "    // we already know that should be kept.\n",
        "219": "    for (int n = list.size() - 1; n > from; n--) {\n",
        "220": "      if (predicate.apply(list.get(n))) {\n",
        "221": "        list.remove(n);\n",
        "222": "      }\n",
        "223": "    }\n",
        "224": "    // And now remove everything in the range [to, from) (going backwards).\n",
        "225": "    for (int n = from - 1; n >= to; n--) {\n",
        "226": "      list.remove(n);\n",
        "227": "    }\n",
        "228": "  }\n",
        "229": "\n",
        "230": "  /**\n",
        "231": "   * Removes and returns the first matching element, or returns {@code null} if there is none.\n",
        "232": "   */\n",
        "233": "  @Nullable\n",
        "234": "  static <T> T removeFirstMatching(Iterable<T> removeFrom, Predicate<? super T> predicate) {\n",
        "235": "    checkNotNull(predicate);\n",
        "236": "    Iterator<T> iterator = removeFrom.iterator();\n",
        "237": "    while (iterator.hasNext()) {\n",
        "238": "      T next = iterator.next();\n",
        "239": "      if (predicate.apply(next)) {\n",
        "240": "        iterator.remove();\n",
        "241": "        return next;\n",
        "242": "      }\n",
        "243": "    }\n",
        "244": "    return null;\n",
        "245": "  }\n",
        "246": "\n",
        "247": "  /**\n",
        "248": "   * Determines whether two iterables contain equal elements in the same order.\n",
        "249": "   * More specifically, this method returns {@code true} if {@code iterable1}\n",
        "250": "   * and {@code iterable2} contain the same number of elements and every element\n",
        "251": "   * of {@code iterable1} is equal to the corresponding element of\n",
        "252": "   * {@code iterable2}.\n",
        "253": "   */\n",
        "254": "  @CheckReturnValue\n",
        "255": "  public static boolean elementsEqual(Iterable<?> iterable1, Iterable<?> iterable2) {\n",
        "256": "    if (iterable1 instanceof Collection && iterable2 instanceof Collection) {\n",
        "257": "      Collection<?> collection1 = (Collection<?>) iterable1;\n",
        "258": "      Collection<?> collection2 = (Collection<?>) iterable2;\n",
        "259": "      if (collection1.size() != collection2.size()) {\n",
        "260": "        return false;\n",
        "261": "      }\n",
        "262": "    }\n",
        "263": "    return Iterators.elementsEqual(iterable1.iterator(), iterable2.iterator());\n",
        "264": "  }\n",
        "265": "\n",
        "266": "  /**\n",
        "267": "   * Returns a string representation of {@code iterable}, with the format {@code\n",
        "268": "   * [e1, e2, ..., en]} (that is, identical to {@link java.util.Arrays\n",
        "269": "   * Arrays}{@code .toString(Iterables.toArray(iterable))}). Note that for\n",
        "270": "   * <i>most</i> implementations of {@link Collection}, {@code\n",
        "271": "   * collection.toString()} also gives the same result, but that behavior is not\n",
        "272": "   * generally guaranteed.\n",
        "273": "   */\n",
        "274": "  public static String toString(Iterable<?> iterable) {\n",
        "275": "    return Iterators.toString(iterable.iterator());\n",
        "276": "  }\n",
        "277": "\n",
        "278": "  /**\n",
        "279": "   * Returns the single element contained in {@code iterable}.\n",
        "280": "   *\n",
        "281": "   * @throws NoSuchElementException if the iterable is empty\n",
        "282": "   * @throws IllegalArgumentException if the iterable contains multiple\n",
        "283": "   *     elements\n",
        "284": "   */\n",
        "285": "  public static <T> T getOnlyElement(Iterable<T> iterable) {\n",
        "286": "    return Iterators.getOnlyElement(iterable.iterator());\n",
        "287": "  }\n",
        "288": "\n",
        "289": "  /**\n",
        "290": "   * Returns the single element contained in {@code iterable}, or {@code\n",
        "291": "   * defaultValue} if the iterable is empty.\n",
        "292": "   *\n",
        "293": "   * @throws IllegalArgumentException if the iterator contains multiple\n",
        "294": "   *     elements\n",
        "295": "   */\n",
        "296": "  @Nullable\n",
        "297": "  public static <T> T getOnlyElement(Iterable<? extends T> iterable, @Nullable T defaultValue) {\n",
        "298": "    return Iterators.getOnlyElement(iterable.iterator(), defaultValue);\n",
        "299": "  }\n",
        "300": "\n",
        "301": "  static <T> T[] toArray(Iterable<? extends T> iterable, T[] array) {\n",
        "302": "    Collection<? extends T> collection = castOrCopyToCollection(iterable);\n",
        "303": "    return collection.toArray(array);\n",
        "304": "  }\n",
        "305": "\n",
        "306": "  /**\n",
        "307": "   * Copies an iterable's elements into an array.\n",
        "308": "   *\n",
        "309": "   * @param iterable the iterable to copy\n",
        "310": "   * @return a newly-allocated array into which all the elements of the iterable\n",
        "311": "   *     have been copied\n",
        "312": "   */\n",
        "313": "  static Object[] toArray(Iterable<?> iterable) {\n",
        "314": "    return castOrCopyToCollection(iterable).toArray();\n",
        "315": "  }\n",
        "316": "\n",
        "317": "  /**\n",
        "318": "   * Converts an iterable into a collection. If the iterable is already a\n",
        "319": "   * collection, it is returned. Otherwise, an {@link java.util.ArrayList} is\n",
        "320": "   * created with the contents of the iterable in the same iteration order.\n",
        "321": "   */\n",
        "322": "  private static <E> Collection<E> castOrCopyToCollection(Iterable<E> iterable) {\n",
        "323": "    return (iterable instanceof Collection)\n",
        "324": "        ? (Collection<E>) iterable\n",
        "325": "        : Lists.newArrayList(iterable.iterator());\n",
        "326": "  }\n",
        "327": "\n",
        "328": "  /**\n",
        "329": "   * Adds all elements in {@code iterable} to {@code collection}.\n",
        "330": "   *\n",
        "331": "   * @return {@code true} if {@code collection} was modified as a result of this\n",
        "332": "   *     operation.\n",
        "333": "   */\n",
        "334": "  public static <T> boolean addAll(Collection<T> addTo, Iterable<? extends T> elementsToAdd) {\n",
        "335": "    if (elementsToAdd instanceof Collection) {\n",
        "336": "      Collection<? extends T> c = Collections2.cast(elementsToAdd);\n",
        "337": "      return addTo.addAll(c);\n",
        "338": "    }\n",
        "339": "    return Iterators.addAll(addTo, checkNotNull(elementsToAdd).iterator());\n",
        "340": "  }\n",
        "341": "\n",
        "342": "  /**\n",
        "343": "   * Returns the number of elements in the specified iterable that equal the\n",
        "344": "   * specified object. This implementation avoids a full iteration when the\n",
        "345": "   * iterable is a {@link Multiset} or {@link Set}.\n",
        "346": "   *\n",
        "347": "   * @see Collections#frequency\n",
        "348": "   */\n",
        "349": "  public static int frequency(Iterable<?> iterable, @Nullable Object element) {\n",
        "350": "    if ((iterable instanceof Multiset)) {\n",
        "351": "      return ((Multiset<?>) iterable).count(element);\n",
        "352": "    } else if ((iterable instanceof Set)) {\n",
        "353": "      return ((Set<?>) iterable).contains(element) ? 1 : 0;\n",
        "354": "    }\n",
        "355": "    return Iterators.frequency(iterable.iterator(), element);\n",
        "356": "  }\n",
        "357": "\n",
        "358": "  /**\n",
        "359": "   * Returns an iterable whose iterators cycle indefinitely over the elements of\n",
        "360": "   * {@code iterable}.\n",
        "361": "   *\n",
        "362": "   * <p>That iterator supports {@code remove()} if {@code iterable.iterator()}\n",
        "363": "   * does. After {@code remove()} is called, subsequent cycles omit the removed\n",
        "364": "   * element, which is no longer in {@code iterable}. The iterator's\n",
        "365": "   * {@code hasNext()} method returns {@code true} until {@code iterable} is\n",
        "366": "   * empty.\n",
        "367": "   *\n",
        "368": "   * <p><b>Warning:</b> Typical uses of the resulting iterator may produce an\n",
        "369": "   * infinite loop. You should use an explicit {@code break} or be certain that\n",
        "370": "   * you will eventually remove all the elements.\n",
        "371": "   *\n",
        "372": "   * <p>To cycle over the iterable {@code n} times, use the following:\n",
        "373": "   * {@code Iterables.concat(Collections.nCopies(n, iterable))}\n",
        "374": "   */\n",
        "375": "  public static <T> Iterable<T> cycle(final Iterable<T> iterable) {\n",
        "376": "    checkNotNull(iterable);\n",
        "377": "    return new FluentIterable<T>() {\n",
        "378": "      @Override\n",
        "379": "      public Iterator<T> iterator() {\n",
        "380": "        return Iterators.cycle(iterable);\n",
        "381": "      }\n",
        "382": "\n",
        "383": "      @Override\n",
        "384": "      public String toString() {\n",
        "385": "        return iterable.toString() + \" (cycled)\";\n",
        "386": "      }\n",
        "387": "    };\n",
        "388": "  }\n",
        "389": "\n",
        "390": "  /**\n",
        "391": "   * Returns an iterable whose iterators cycle indefinitely over the provided\n",
        "392": "   * elements.\n",
        "393": "   *\n",
        "394": "   * <p>After {@code remove} is invoked on a generated iterator, the removed\n",
        "395": "   * element will no longer appear in either that iterator or any other iterator\n",
        "396": "   * created from the same source iterable. That is, this method behaves exactly\n",
        "397": "   * as {@code Iterables.cycle(Lists.newArrayList(elements))}. The iterator's\n",
        "398": "   * {@code hasNext} method returns {@code true} until all of the original\n",
        "399": "   * elements have been removed.\n",
        "400": "   *\n",
        "401": "   * <p><b>Warning:</b> Typical uses of the resulting iterator may produce an\n",
        "402": "   * infinite loop. You should use an explicit {@code break} or be certain that\n",
        "403": "   * you will eventually remove all the elements.\n",
        "404": "   *\n",
        "405": "   * <p>To cycle over the elements {@code n} times, use the following:\n",
        "406": "   * {@code Iterables.concat(Collections.nCopies(n, Arrays.asList(elements)))}\n",
        "407": "   */\n",
        "408": "  public static <T> Iterable<T> cycle(T... elements) {\n",
        "409": "    return cycle(Lists.newArrayList(elements));\n",
        "410": "  }\n",
        "411": "\n",
        "412": "  /**\n",
        "413": "   * Combines two iterables into a single iterable. The returned iterable has an\n",
        "414": "   * iterator that traverses the elements in {@code a}, followed by the elements\n",
        "415": "   * in {@code b}. The source iterators are not polled until necessary.\n",
        "416": "   *\n",
        "417": "   * <p>The returned iterable's iterator supports {@code remove()} when the\n",
        "418": "   * corresponding input iterator supports it.\n",
        "419": "   */\n",
        "420": "  public static <T> Iterable<T> concat(Iterable<? extends T> a, Iterable<? extends T> b) {\n",
        "421": "    return concat(ImmutableList.of(a, b));\n",
        "422": "  }\n",
        "423": "\n",
        "424": "  /**\n",
        "425": "   * Combines three iterables into a single iterable. The returned iterable has\n",
        "426": "   * an iterator that traverses the elements in {@code a}, followed by the\n",
        "427": "   * elements in {@code b}, followed by the elements in {@code c}. The source\n",
        "428": "   * iterators are not polled until necessary.\n",
        "429": "   *\n",
        "430": "   * <p>The returned iterable's iterator supports {@code remove()} when the\n",
        "431": "   * corresponding input iterator supports it.\n",
        "432": "   */\n",
        "433": "  public static <T> Iterable<T> concat(\n",
        "434": "      Iterable<? extends T> a, Iterable<? extends T> b, Iterable<? extends T> c) {\n",
        "435": "    return concat(ImmutableList.of(a, b, c));\n",
        "436": "  }\n",
        "437": "\n",
        "438": "  /**\n",
        "439": "   * Combines four iterables into a single iterable. The returned iterable has\n",
        "440": "   * an iterator that traverses the elements in {@code a}, followed by the\n",
        "441": "   * elements in {@code b}, followed by the elements in {@code c}, followed by\n",
        "442": "   * the elements in {@code d}. The source iterators are not polled until\n",
        "443": "   * necessary.\n",
        "444": "   *\n",
        "445": "   * <p>The returned iterable's iterator supports {@code remove()} when the\n",
        "446": "   * corresponding input iterator supports it.\n",
        "447": "   */\n",
        "448": "  public static <T> Iterable<T> concat(\n",
        "449": "      Iterable<? extends T> a,\n",
        "450": "      Iterable<? extends T> b,\n",
        "451": "      Iterable<? extends T> c,\n",
        "452": "      Iterable<? extends T> d) {\n",
        "453": "    return concat(ImmutableList.of(a, b, c, d));\n",
        "454": "  }\n",
        "455": "\n",
        "456": "  /**\n",
        "457": "   * Combines multiple iterables into a single iterable. The returned iterable\n",
        "458": "   * has an iterator that traverses the elements of each iterable in\n",
        "459": "   * {@code inputs}. The input iterators are not polled until necessary.\n",
        "460": "   *\n",
        "461": "   * <p>The returned iterable's iterator supports {@code remove()} when the\n",
        "462": "   * corresponding input iterator supports it.\n",
        "463": "   *\n",
        "464": "   * @throws NullPointerException if any of the provided iterables is null\n",
        "465": "   */\n",
        "466": "  public static <T> Iterable<T> concat(Iterable<? extends T>... inputs) {\n",
        "467": "    return concat(ImmutableList.copyOf(inputs));\n",
        "468": "  }\n",
        "469": "\n",
        "470": "  /**\n",
        "471": "   * Combines multiple iterables into a single iterable. The returned iterable\n",
        "472": "   * has an iterator that traverses the elements of each iterable in\n",
        "473": "   * {@code inputs}. The input iterators are not polled until necessary.\n",
        "474": "   *\n",
        "475": "   * <p>The returned iterable's iterator supports {@code remove()} when the\n",
        "476": "   * corresponding input iterator supports it. The methods of the returned\n",
        "477": "   * iterable may throw {@code NullPointerException} if any of the input\n",
        "478": "   * iterators is null.\n",
        "479": "   */\n",
        "480": "  public static <T> Iterable<T> concat(final Iterable<? extends Iterable<? extends T>> inputs) {\n",
        "481": "    checkNotNull(inputs);\n",
        "482": "    return new FluentIterable<T>() {\n",
        "483": "      @Override\n",
        "484": "      public Iterator<T> iterator() {\n",
        "485": "        return Iterators.concat(iterators(inputs));\n",
        "486": "      }\n",
        "487": "    };\n",
        "488": "  }\n",
        "489": "\n",
        "490": "  /**\n",
        "491": "   * Returns an iterator over the iterators of the given iterables.\n",
        "492": "   */\n",
        "493": "  private static <T> Iterator<Iterator<? extends T>> iterators(\n",
        "494": "      Iterable<? extends Iterable<? extends T>> iterables) {\n",
        "495": "    return new TransformedIterator<Iterable<? extends T>, Iterator<? extends T>>(\n",
        "496": "        iterables.iterator()) {\n",
        "497": "      @Override\n",
        "498": "      Iterator<? extends T> transform(Iterable<? extends T> from) {\n",
        "499": "        return from.iterator();\n",
        "500": "      }\n",
        "501": "    };\n",
        "502": "  }\n",
        "503": "\n",
        "504": "  /**\n",
        "505": "   * Divides an iterable into unmodifiable sublists of the given size (the final\n",
        "506": "   * iterable may be smaller). For example, partitioning an iterable containing\n",
        "507": "   * {@code [a, b, c, d, e]} with a partition size of 3 yields {@code\n",
        "508": "   * [[a, b, c], [d, e]]} -- an outer iterable containing two inner lists of\n",
        "509": "   * three and two elements, all in the original order.\n",
        "510": "   *\n",
        "511": "   * <p>Iterators returned by the returned iterable do not support the {@link\n",
        "512": "   * Iterator#remove()} method. The returned lists implement {@link\n",
        "513": "   * RandomAccess}, whether or not the input list does.\n",
        "514": "   *\n",
        "515": "   * <p><b>Note:</b> if {@code iterable} is a {@link List}, use {@link\n",
        "516": "   * Lists#partition(List, int)} instead.\n",
        "517": "   *\n",
        "518": "   * @param iterable the iterable to return a partitioned view of\n",
        "519": "   * @param size the desired size of each partition (the last may be smaller)\n",
        "520": "   * @return an iterable of unmodifiable lists containing the elements of {@code\n",
        "521": "   *     iterable} divided into partitions\n",
        "522": "   * @throws IllegalArgumentException if {@code size} is nonpositive\n",
        "523": "   */\n",
        "524": "  public static <T> Iterable<List<T>> partition(final Iterable<T> iterable, final int size) {\n",
        "525": "    checkNotNull(iterable);\n",
        "526": "    checkArgument(size > 0);\n",
        "527": "    return new FluentIterable<List<T>>() {\n",
        "528": "      @Override\n",
        "529": "      public Iterator<List<T>> iterator() {\n",
        "530": "        return Iterators.partition(iterable.iterator(), size);\n",
        "531": "      }\n",
        "532": "    };\n",
        "533": "  }\n",
        "534": "\n",
        "535": "  /**\n",
        "536": "   * Divides an iterable into unmodifiable sublists of the given size, padding\n",
        "537": "   * the final iterable with null values if necessary. For example, partitioning\n",
        "538": "   * an iterable containing {@code [a, b, c, d, e]} with a partition size of 3\n",
        "539": "   * yields {@code [[a, b, c], [d, e, null]]} -- an outer iterable containing\n",
        "540": "   * two inner lists of three elements each, all in the original order.\n",
        "541": "   *\n",
        "542": "   * <p>Iterators returned by the returned iterable do not support the {@link\n",
        "543": "   * Iterator#remove()} method.\n",
        "544": "   *\n",
        "545": "   * @param iterable the iterable to return a partitioned view of\n",
        "546": "   * @param size the desired size of each partition\n",
        "547": "   * @return an iterable of unmodifiable lists containing the elements of {@code\n",
        "548": "   *     iterable} divided into partitions (the final iterable may have\n",
        "549": "   *     trailing null elements)\n",
        "550": "   * @throws IllegalArgumentException if {@code size} is nonpositive\n",
        "551": "   */\n",
        "552": "  public static <T> Iterable<List<T>> paddedPartition(final Iterable<T> iterable, final int size) {\n",
        "553": "    checkNotNull(iterable);\n",
        "554": "    checkArgument(size > 0);\n",
        "555": "    return new FluentIterable<List<T>>() {\n",
        "556": "      @Override\n",
        "557": "      public Iterator<List<T>> iterator() {\n",
        "558": "        return Iterators.paddedPartition(iterable.iterator(), size);\n",
        "559": "      }\n",
        "560": "    };\n",
        "561": "  }\n",
        "562": "\n",
        "563": "  /**\n",
        "564": "   * Returns the elements of {@code unfiltered} that satisfy the input predicate\n",
        "565": "   * {@code retainIfTrue}. The resulting iterable's iterator does not support {@code remove()}.\n",
        "566": "   */\n",
        "567": "  @CheckReturnValue\n",
        "568": "  public static <T> Iterable<T> filter(\n",
        "569": "      final Iterable<T> unfiltered, final Predicate<? super T> retainIfTrue) {\n",
        "570": "    checkNotNull(unfiltered);\n",
        "571": "    checkNotNull(retainIfTrue);\n",
        "572": "    return new FluentIterable<T>() {\n",
        "573": "      @Override\n",
        "574": "      public Iterator<T> iterator() {\n",
        "575": "        return Iterators.filter(unfiltered.iterator(), retainIfTrue);\n",
        "576": "      }\n",
        "577": "    };\n",
        "578": "  }\n",
        "579": "\n",
        "580": "  /**\n",
        "581": "   * Returns {@code true} if any element in {@code iterable} satisfies the predicate.\n",
        "582": "   */\n",
        "583": "  public static <T> boolean any(Iterable<T> iterable, Predicate<? super T> predicate) {\n",
        "584": "    return Iterators.any(iterable.iterator(), predicate);\n",
        "585": "  }\n",
        "586": "\n",
        "587": "  /**\n",
        "588": "   * Returns {@code true} if every element in {@code iterable} satisfies the\n",
        "589": "   * predicate. If {@code iterable} is empty, {@code true} is returned.\n",
        "590": "   */\n",
        "591": "  public static <T> boolean all(Iterable<T> iterable, Predicate<? super T> predicate) {\n",
        "592": "    return Iterators.all(iterable.iterator(), predicate);\n",
        "593": "  }\n",
        "594": "\n",
        "595": "  /**\n",
        "596": "   * Returns the first element in {@code iterable} that satisfies the given\n",
        "597": "   * predicate; use this method only when such an element is known to exist. If\n",
        "598": "   * it is possible that <i>no</i> element will match, use {@link #tryFind} or\n",
        "599": "   * {@link #find(Iterable, Predicate, Object)} instead.\n",
        "600": "   *\n",
        "601": "   * @throws NoSuchElementException if no element in {@code iterable} matches\n",
        "602": "   *     the given predicate\n",
        "603": "   */\n",
        "604": "  public static <T> T find(Iterable<T> iterable, Predicate<? super T> predicate) {\n",
        "605": "    return Iterators.find(iterable.iterator(), predicate);\n",
        "606": "  }\n",
        "607": "\n",
        "608": "  /**\n",
        "609": "   * Returns the first element in {@code iterable} that satisfies the given\n",
        "610": "   * predicate, or {@code defaultValue} if none found. Note that this can\n",
        "611": "   * usually be handled more naturally using {@code\n",
        "612": "   * tryFind(iterable, predicate).or(defaultValue)}.\n",
        "613": "   *\n",
        "614": "   * @since 7.0\n",
        "615": "   */\n",
        "616": "  @Nullable\n",
        "617": "  public static <T> T find(\n",
        "618": "      Iterable<? extends T> iterable, Predicate<? super T> predicate, @Nullable T defaultValue) {\n",
        "619": "    return Iterators.find(iterable.iterator(), predicate, defaultValue);\n",
        "620": "  }\n",
        "621": "\n",
        "622": "  /**\n",
        "623": "   * Returns an {@link Optional} containing the first element in {@code\n",
        "624": "   * iterable} that satisfies the given predicate, if such an element exists.\n",
        "625": "   *\n",
        "626": "   * <p><b>Warning:</b> avoid using a {@code predicate} that matches {@code\n",
        "627": "   * null}. If {@code null} is matched in {@code iterable}, a\n",
        "628": "   * NullPointerException will be thrown.\n",
        "629": "   *\n",
        "630": "   * @since 11.0\n",
        "631": "   */\n",
        "632": "  public static <T> Optional<T> tryFind(Iterable<T> iterable, Predicate<? super T> predicate) {\n",
        "633": "    return Iterators.tryFind(iterable.iterator(), predicate);\n",
        "634": "  }\n",
        "635": "\n",
        "636": "  /**\n",
        "637": "   * Returns the index in {@code iterable} of the first element that satisfies\n",
        "638": "   * the provided {@code predicate}, or {@code -1} if the Iterable has no such\n",
        "639": "   * elements.\n",
        "640": "   *\n",
        "641": "   * <p>More formally, returns the lowest index {@code i} such that\n",
        "642": "   * {@code predicate.apply(Iterables.get(iterable, i))} returns {@code true},\n",
        "643": "   * or {@code -1} if there is no such index.\n",
        "644": "   *\n",
        "645": "   * @since 2.0\n",
        "646": "   */\n",
        "647": "  public static <T> int indexOf(Iterable<T> iterable, Predicate<? super T> predicate) {\n",
        "648": "    return Iterators.indexOf(iterable.iterator(), predicate);\n",
        "649": "  }\n",
        "650": "\n",
        "651": "  /**\n",
        "652": "   * Returns an iterable that applies {@code function} to each element of {@code\n",
        "653": "   * fromIterable}.\n",
        "654": "   *\n",
        "655": "   * <p>The returned iterable's iterator supports {@code remove()} if the\n",
        "656": "   * provided iterator does. After a successful {@code remove()} call,\n",
        "657": "   * {@code fromIterable} no longer contains the corresponding element.\n",
        "658": "   *\n",
        "659": "   * <p>If the input {@code Iterable} is known to be a {@code List} or other\n",
        "660": "   * {@code Collection}, consider {@link Lists#transform} and {@link\n",
        "661": "   * Collections2#transform}.\n",
        "662": "   */\n",
        "663": "  @CheckReturnValue\n",
        "664": "  public static <F, T> Iterable<T> transform(\n",
        "665": "      final Iterable<F> fromIterable, final Function<? super F, ? extends T> function) {\n",
        "666": "    checkNotNull(fromIterable);\n",
        "667": "    checkNotNull(function);\n",
        "668": "    return new FluentIterable<T>() {\n",
        "669": "      @Override\n",
        "670": "      public Iterator<T> iterator() {\n",
        "671": "        return Iterators.transform(fromIterable.iterator(), function);\n",
        "672": "      }\n",
        "673": "    };\n",
        "674": "  }\n",
        "675": "\n",
        "676": "  /**\n",
        "677": "   * Returns the element at the specified position in an iterable.\n",
        "678": "   *\n",
        "679": "   * @param position position of the element to return\n",
        "680": "   * @return the element at the specified position in {@code iterable}\n",
        "681": "   * @throws IndexOutOfBoundsException if {@code position} is negative or\n",
        "682": "   *     greater than or equal to the size of {@code iterable}\n",
        "683": "   */\n",
        "684": "  public static <T> T get(Iterable<T> iterable, int position) {\n",
        "685": "    checkNotNull(iterable);\n",
        "686": "    return (iterable instanceof List)\n",
        "687": "        ? ((List<T>) iterable).get(position)\n",
        "688": "        : Iterators.get(iterable.iterator(), position);\n",
        "689": "  }\n",
        "690": "\n",
        "691": "  /**\n",
        "692": "   * Returns the element at the specified position in an iterable or a default\n",
        "693": "   * value otherwise.\n",
        "694": "   *\n",
        "695": "   * @param position position of the element to return\n",
        "696": "   * @param defaultValue the default value to return if {@code position} is\n",
        "697": "   *     greater than or equal to the size of the iterable\n",
        "698": "   * @return the element at the specified position in {@code iterable} or\n",
        "699": "   *     {@code defaultValue} if {@code iterable} contains fewer than\n",
        "700": "   *     {@code position + 1} elements.\n",
        "701": "   * @throws IndexOutOfBoundsException if {@code position} is negative\n",
        "702": "   * @since 4.0\n",
        "703": "   */\n",
        "704": "  @Nullable\n",
        "705": "  public static <T> T get(Iterable<? extends T> iterable, int position, @Nullable T defaultValue) {\n",
        "706": "    checkNotNull(iterable);\n",
        "707": "    Iterators.checkNonnegative(position);\n",
        "708": "    if (iterable instanceof List) {\n",
        "709": "      List<? extends T> list = Lists.cast(iterable);\n",
        "710": "      return (position < list.size()) ? list.get(position) : defaultValue;\n",
        "711": "    } else {\n",
        "712": "      Iterator<? extends T> iterator = iterable.iterator();\n",
        "713": "      Iterators.advance(iterator, position);\n",
        "714": "      return Iterators.getNext(iterator, defaultValue);\n",
        "715": "    }\n",
        "716": "  }\n",
        "717": "\n",
        "718": "  /**\n",
        "719": "   * Returns the first element in {@code iterable} or {@code defaultValue} if\n",
        "720": "   * the iterable is empty.  The {@link Iterators} analog to this method is\n",
        "721": "   * {@link Iterators#getNext}.\n",
        "722": "   *\n",
        "723": "   * <p>If no default value is desired (and the caller instead wants a\n",
        "724": "   * {@link NoSuchElementException} to be thrown), it is recommended that\n",
        "725": "   * {@code iterable.iterator().next()} is used instead.\n",
        "726": "   *\n",
        "727": "   * @param defaultValue the default value to return if the iterable is empty\n",
        "728": "   * @return the first element of {@code iterable} or the default value\n",
        "729": "   * @since 7.0\n",
        "730": "   */\n",
        "731": "  @Nullable\n",
        "732": "  public static <T> T getFirst(Iterable<? extends T> iterable, @Nullable T defaultValue) {\n",
        "733": "    return Iterators.getNext(iterable.iterator(), defaultValue);\n",
        "734": "  }\n",
        "735": "\n",
        "736": "  /**\n",
        "737": "   * Returns the last element of {@code iterable}.\n",
        "738": "   *\n",
        "739": "   * @return the last element of {@code iterable}\n",
        "740": "   * @throws NoSuchElementException if the iterable is empty\n",
        "741": "   */\n",
        "742": "  public static <T> T getLast(Iterable<T> iterable) {\n",
        "743": "    // TODO(kevinb): Support a concurrently modified collection?\n",
        "744": "    if (iterable instanceof List) {\n",
        "745": "      List<T> list = (List<T>) iterable;\n",
        "746": "      if (list.isEmpty()) {\n",
        "747": "        throw new NoSuchElementException();\n",
        "748": "      }\n",
        "749": "      return getLastInNonemptyList(list);\n",
        "750": "    }\n",
        "751": "\n",
        "752": "    return Iterators.getLast(iterable.iterator());\n",
        "753": "  }\n",
        "754": "\n",
        "755": "  /**\n",
        "756": "   * Returns the last element of {@code iterable} or {@code defaultValue} if\n",
        "757": "   * the iterable is empty.\n",
        "758": "   *\n",
        "759": "   * @param defaultValue the value to return if {@code iterable} is empty\n",
        "760": "   * @return the last element of {@code iterable} or the default value\n",
        "761": "   * @since 3.0\n",
        "762": "   */\n",
        "763": "  @Nullable\n",
        "764": "  public static <T> T getLast(Iterable<? extends T> iterable, @Nullable T defaultValue) {\n",
        "765": "    if (iterable instanceof Collection) {\n",
        "766": "      Collection<? extends T> c = Collections2.cast(iterable);\n",
        "767": "      if (c.isEmpty()) {\n",
        "768": "        return defaultValue;\n",
        "769": "      } else if (iterable instanceof List) {\n",
        "770": "        return getLastInNonemptyList(Lists.cast(iterable));\n",
        "771": "      }\n",
        "772": "    }\n",
        "773": "\n",
        "774": "    return Iterators.getLast(iterable.iterator(), defaultValue);\n",
        "775": "  }\n",
        "776": "\n",
        "777": "  private static <T> T getLastInNonemptyList(List<T> list) {\n",
        "778": "    return list.get(list.size() - 1);\n",
        "779": "  }\n",
        "780": "\n",
        "781": "  /**\n",
        "782": "   * Returns a view of {@code iterable} that skips its first\n",
        "783": "   * {@code numberToSkip} elements. If {@code iterable} contains fewer than\n",
        "784": "   * {@code numberToSkip} elements, the returned iterable skips all of its\n",
        "785": "   * elements.\n",
        "786": "   *\n",
        "787": "   * <p>Modifications to the underlying {@link Iterable} before a call to\n",
        "788": "   * {@code iterator()} are reflected in the returned iterator. That is, the\n",
        "789": "   * iterator skips the first {@code numberToSkip} elements that exist when the\n",
        "790": "   * {@code Iterator} is created, not when {@code skip()} is called.\n",
        "791": "   *\n",
        "792": "   * <p>The returned iterable's iterator supports {@code remove()} if the\n",
        "793": "   * iterator of the underlying iterable supports it. Note that it is\n",
        "794": "   * <i>not</i> possible to delete the last skipped element by immediately\n",
        "795": "   * calling {@code remove()} on that iterator, as the {@code Iterator}\n",
        "796": "   * contract states that a call to {@code remove()} before a call to\n",
        "797": "   * {@code next()} will throw an {@link IllegalStateException}.\n",
        "798": "   *\n",
        "799": "   * @since 3.0\n",
        "800": "   */\n",
        "801": "  public static <T> Iterable<T> skip(final Iterable<T> iterable, final int numberToSkip) {\n",
        "802": "    checkNotNull(iterable);\n",
        "803": "    checkArgument(numberToSkip >= 0, \"number to skip cannot be negative\");\n",
        "804": "\n",
        "805": "    if (iterable instanceof List) {\n",
        "806": "      final List<T> list = (List<T>) iterable;\n",
        "807": "      return new FluentIterable<T>() {\n",
        "808": "        @Override\n",
        "809": "        public Iterator<T> iterator() {\n",
        "810": "          // TODO(kevinb): Support a concurrently modified collection?\n",
        "811": "          int toSkip = Math.min(list.size(), numberToSkip);\n",
        "812": "          return list.subList(toSkip, list.size()).iterator();\n",
        "813": "        }\n",
        "814": "      };\n",
        "815": "    }\n",
        "816": "\n",
        "817": "    return new FluentIterable<T>() {\n",
        "818": "      @Override\n",
        "819": "      public Iterator<T> iterator() {\n",
        "820": "        final Iterator<T> iterator = iterable.iterator();\n",
        "821": "\n",
        "822": "        Iterators.advance(iterator, numberToSkip);\n",
        "823": "\n",
        "824": "        /*\n",
        "825": "         * We can't just return the iterator because an immediate call to its\n",
        "826": "         * remove() method would remove one of the skipped elements instead of\n",
        "827": "         * throwing an IllegalStateException.\n",
        "828": "         */\n",
        "829": "        return new Iterator<T>() {\n",
        "830": "          boolean atStart = true;\n",
        "831": "\n",
        "832": "          @Override\n",
        "833": "          public boolean hasNext() {\n",
        "834": "            return iterator.hasNext();\n",
        "835": "          }\n",
        "836": "\n",
        "837": "          @Override\n",
        "838": "          public T next() {\n",
        "839": "            T result = iterator.next();\n",
        "840": "            atStart = false; // not called if next() fails\n",
        "841": "            return result;\n",
        "842": "          }\n",
        "843": "\n",
        "844": "          @Override\n",
        "845": "          public void remove() {\n",
        "846": "            checkRemove(!atStart);\n",
        "847": "            iterator.remove();\n",
        "848": "          }\n",
        "849": "        };\n",
        "850": "      }\n",
        "851": "    };\n",
        "852": "  }\n",
        "853": "\n",
        "854": "  /**\n",
        "855": "   * Creates an iterable with the first {@code limitSize} elements of the given\n",
        "856": "   * iterable. If the original iterable does not contain that many elements, the\n",
        "857": "   * returned iterable will have the same behavior as the original iterable. The\n",
        "858": "   * returned iterable's iterator supports {@code remove()} if the original\n",
        "859": "   * iterator does.\n",
        "860": "   *\n",
        "861": "   * @param iterable the iterable to limit\n",
        "862": "   * @param limitSize the maximum number of elements in the returned iterable\n",
        "863": "   * @throws IllegalArgumentException if {@code limitSize} is negative\n",
        "864": "   * @since 3.0\n",
        "865": "   */\n",
        "866": "  public static <T> Iterable<T> limit(final Iterable<T> iterable, final int limitSize) {\n",
        "867": "    checkNotNull(iterable);\n",
        "868": "    checkArgument(limitSize >= 0, \"limit is negative\");\n",
        "869": "    return new FluentIterable<T>() {\n",
        "870": "      @Override\n",
        "871": "      public Iterator<T> iterator() {\n",
        "872": "        return Iterators.limit(iterable.iterator(), limitSize);\n",
        "873": "      }\n",
        "874": "    };\n",
        "875": "  }\n",
        "876": "\n",
        "877": "  /**\n",
        "878": "   * Returns a view of the supplied iterable that wraps each generated\n",
        "879": "   * {@link Iterator} through {@link Iterators#consumingIterator(Iterator)}.\n",
        "880": "   *\n",
        "881": "   * <p>Note: If {@code iterable} is a {@link Queue}, the returned iterable will\n",
        "882": "   * get entries from {@link Queue#remove()} since {@link Queue}'s iteration\n",
        "883": "   * order is undefined.  Calling {@link Iterator#hasNext()} on a generated\n",
        "884": "   * iterator from the returned iterable may cause an item to be immediately\n",
        "885": "   * dequeued for return on a subsequent call to {@link Iterator#next()}.\n",
        "886": "   *\n",
        "887": "   * @param iterable the iterable to wrap\n",
        "888": "   * @return a view of the supplied iterable that wraps each generated iterator\n",
        "889": "   *     through {@link Iterators#consumingIterator(Iterator)}; for queues,\n",
        "890": "   *     an iterable that generates iterators that return and consume the\n",
        "891": "   *     queue's elements in queue order\n",
        "892": "   *\n",
        "893": "   * @see Iterators#consumingIterator(Iterator)\n",
        "894": "   * @since 2.0\n",
        "895": "   */\n",
        "896": "  public static <T> Iterable<T> consumingIterable(final Iterable<T> iterable) {\n",
        "897": "    if (iterable instanceof Queue) {\n",
        "898": "      return new FluentIterable<T>() {\n",
        "899": "        @Override\n",
        "900": "        public Iterator<T> iterator() {\n",
        "901": "          return new ConsumingQueueIterator<T>((Queue<T>) iterable);\n",
        "902": "        }\n",
        "903": "\n",
        "904": "        @Override\n",
        "905": "        public String toString() {\n",
        "906": "          return \"Iterables.consumingIterable(...)\";\n",
        "907": "        }\n",
        "908": "      };\n",
        "909": "    }\n",
        "910": "\n",
        "911": "    checkNotNull(iterable);\n",
        "912": "\n",
        "913": "    return new FluentIterable<T>() {\n",
        "914": "      @Override\n",
        "915": "      public Iterator<T> iterator() {\n",
        "916": "        return Iterators.consumingIterator(iterable.iterator());\n",
        "917": "      }\n",
        "918": "\n",
        "919": "      @Override\n",
        "920": "      public String toString() {\n",
        "921": "        return \"Iterables.consumingIterable(...)\";\n",
        "922": "      }\n",
        "923": "    };\n",
        "924": "  }\n",
        "925": "\n",
        "926": "  // Methods only in Iterables, not in Iterators\n",
        "927": "\n",
        "928": "  /**\n",
        "929": "   * Determines if the given iterable contains no elements.\n",
        "930": "   *\n",
        "931": "   * <p>There is no precise {@link Iterator} equivalent to this method, since\n",
        "932": "   * one can only ask an iterator whether it has any elements <i>remaining</i>\n",
        "933": "   * (which one does using {@link Iterator#hasNext}).\n",
        "934": "   *\n",
        "935": "   * @return {@code true} if the iterable contains no elements\n",
        "936": "   */\n",
        "937": "  public static boolean isEmpty(Iterable<?> iterable) {\n",
        "938": "    if (iterable instanceof Collection) {\n",
        "939": "      return ((Collection<?>) iterable).isEmpty();\n",
        "940": "    }\n",
        "941": "    return !iterable.iterator().hasNext();\n",
        "942": "  }\n",
        "943": "\n",
        "944": "  /**\n",
        "945": "   * Returns an iterable over the merged contents of all given\n",
        "946": "   * {@code iterables}. Equivalent entries will not be de-duplicated.\n",
        "947": "   *\n",
        "948": "   * <p>Callers must ensure that the source {@code iterables} are in\n",
        "949": "   * non-descending order as this method does not sort its input.\n",
        "950": "   *\n",
        "951": "   * <p>For any equivalent elements across all {@code iterables}, it is\n",
        "952": "   * undefined which element is returned first.\n",
        "953": "   *\n",
        "954": "   * @since 11.0\n",
        "955": "   */\n",
        "956": "  @Beta\n",
        "957": "  public static <T> Iterable<T> mergeSorted(\n",
        "958": "      final Iterable<? extends Iterable<? extends T>> iterables,\n",
        "959": "      final Comparator<? super T> comparator) {\n",
        "960": "    checkNotNull(iterables, \"iterables\");\n",
        "961": "    checkNotNull(comparator, \"comparator\");\n",
        "962": "    Iterable<T> iterable =\n",
        "963": "        new FluentIterable<T>() {\n",
        "964": "          @Override\n",
        "965": "          public Iterator<T> iterator() {\n",
        "966": "            return Iterators.mergeSorted(\n",
        "967": "                Iterables.transform(iterables, Iterables.<T>toIterator()),\n",
        "968": "                comparator);\n",
        "969": "          }\n",
        "970": "        };\n",
        "971": "    return new UnmodifiableIterable<T>(iterable);\n",
        "972": "  }\n",
        "973": "\n",
        "974": "  // TODO(user): Is this the best place for this? Move to fluent functions?\n",
        "975": "  // Useful as a public method?\n",
        "976": "  private static <T> Function<Iterable<? extends T>, Iterator<? extends T>> toIterator() {\n",
        "977": "    return new Function<Iterable<? extends T>, Iterator<? extends T>>() {\n",
        "978": "      @Override\n",
        "979": "      public Iterator<? extends T> apply(Iterable<? extends T> iterable) {\n",
        "980": "        return iterable.iterator();\n",
        "981": "      }\n",
        "982": "    };\n",
        "983": "  }\n",
        "984": "}\n"
    }
}