{
    "addition": {},
    "removed": {
        "1": "/*\n",
        "2": " * Copyright (C) 2012 The Guava Authors\n",
        "3": " *\n",
        "4": " * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not use this file except\n",
        "5": " * in compliance with the License. You may obtain a copy of the License at\n",
        "6": " *\n",
        "7": " * http://www.apache.org/licenses/LICENSE-2.0\n",
        "8": " *\n",
        "9": " * Unless required by applicable law or agreed to in writing, software distributed under the License\n",
        "10": " * is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express\n",
        "11": " * or implied. See the License for the specific language governing permissions and limitations under\n",
        "12": " * the License.\n",
        "13": " */\n",
        "14": "\n",
        "15": "package com.google.common.io;\n",
        "16": "\n",
        "17": "import static com.google.common.base.Preconditions.checkArgument;\n",
        "18": "import static com.google.common.base.Preconditions.checkNotNull;\n",
        "19": "import static com.google.common.base.Preconditions.checkPositionIndexes;\n",
        "20": "import static com.google.common.base.Preconditions.checkState;\n",
        "21": "import static com.google.common.math.IntMath.divide;\n",
        "22": "import static com.google.common.math.IntMath.log2;\n",
        "23": "import static java.math.RoundingMode.CEILING;\n",
        "24": "import static java.math.RoundingMode.FLOOR;\n",
        "25": "import static java.math.RoundingMode.UNNECESSARY;\n",
        "26": "\n",
        "27": "import com.google.common.annotations.Beta;\n",
        "28": "import com.google.common.annotations.GwtCompatible;\n",
        "29": "import com.google.common.base.Ascii;\n",
        "30": "import com.google.common.base.CharMatcher;\n",
        "31": "\n",
        "32": "import java.io.IOException;\n",
        "33": "import java.util.Arrays;\n",
        "34": "\n",
        "35": "import javax.annotation.CheckReturnValue;\n",
        "36": "import javax.annotation.Nullable;\n",
        "37": "\n",
        "38": "/**\n",
        "39": " * A binary encoding scheme for reversibly translating between byte sequences and printable ASCII\n",
        "40": " * strings. This class includes several constants for encoding schemes specified by <a\n",
        "41": " * href=\"http://tools.ietf.org/html/rfc4648\">RFC 4648</a>. For example, the expression:\n",
        "42": " *\n",
        "43": " * <pre>   {@code\n",
        "44": " *   BaseEncoding.base32().encode(\"foo\".getBytes(Charsets.US_ASCII))}</pre>\n",
        "45": " *\n",
        "46": " * <p>returns the string {@code \"MZXW6===\"}, and <pre>   {@code\n",
        "47": " *  byte[] decoded = BaseEncoding.base32().decode(\"MZXW6===\");}</pre>\n",
        "48": " *\n",
        "49": " * <p>...returns the ASCII bytes of the string {@code \"foo\"}.\n",
        "50": " *\n",
        "51": " * <p>By default, {@code BaseEncoding}'s behavior is relatively strict and in accordance with\n",
        "52": " * RFC 4648.  Decoding rejects characters in the wrong case, though padding is optional.\n",
        "53": " * To modify encoding and decoding behavior, use configuration methods to obtain a new encoding\n",
        "54": " * with modified behavior:\n",
        "55": " *\n",
        "56": " * <pre>   {@code\n",
        "57": " *  BaseEncoding.base16().lowerCase().decode(\"deadbeef\");}</pre>\n",
        "58": " *\n",
        "59": " * <p>Warning: BaseEncoding instances are immutable.  Invoking a configuration method has no effect\n",
        "60": " * on the receiving instance; you must store and use the new encoding instance it returns, instead.\n",
        "61": " *\n",
        "62": " * <pre>   {@code\n",
        "63": " *   // Do NOT do this\n",
        "64": " *   BaseEncoding hex = BaseEncoding.base16();\n",
        "65": " *   hex.lowerCase(); // does nothing!\n",
        "66": " *   return hex.decode(\"deadbeef\"); // throws an IllegalArgumentException}</pre>\n",
        "67": " *\n",
        "68": " * <p>It is guaranteed that {@code encoding.decode(encoding.encode(x))} is always equal to\n",
        "69": " * {@code x}, but the reverse does not necessarily hold.\n",
        "70": " *\n",
        "71": " * <p>\n",
        "72": " * <table>\n",
        "73": " * <tr>\n",
        "74": " * <th>Encoding\n",
        "75": " * <th>Alphabet\n",
        "76": " * <th>{@code char:byte} ratio\n",
        "77": " * <th>Default padding\n",
        "78": " * <th>Comments\n",
        "79": " * <tr>\n",
        "80": " * <td>{@link #base16()}\n",
        "81": " * <td>0-9 A-F\n",
        "82": " * <td>2.00\n",
        "83": " * <td>N/A\n",
        "84": " * <td>Traditional hexadecimal.  Defaults to upper case.\n",
        "85": " * <tr>\n",
        "86": " * <td>{@link #base32()}\n",
        "87": " * <td>A-Z 2-7\n",
        "88": " * <td>1.60\n",
        "89": " * <td>=\n",
        "90": " * <td>Human-readable; no possibility of mixing up 0/O or 1/I.  Defaults to upper case.\n",
        "91": " * <tr>\n",
        "92": " * <td>{@link #base32Hex()}\n",
        "93": " * <td>0-9 A-V\n",
        "94": " * <td>1.60\n",
        "95": " * <td>=\n",
        "96": " * <td>\"Numerical\" base 32; extended from the traditional hex alphabet.  Defaults to upper case.\n",
        "97": " * <tr>\n",
        "98": " * <td>{@link #base64()}\n",
        "99": " * <td>A-Z a-z 0-9 + /\n",
        "100": " * <td>1.33\n",
        "101": " * <td>=\n",
        "102": " * <td>\n",
        "103": " * <tr>\n",
        "104": " * <td>{@link #base64Url()}\n",
        "105": " * <td>A-Z a-z 0-9 - _\n",
        "106": " * <td>1.33\n",
        "107": " * <td>=\n",
        "108": " * <td>Safe to use as filenames, or to pass in URLs without escaping\n",
        "109": " * </table>\n",
        "110": " *\n",
        "111": " * <p>\n",
        "112": " * All instances of this class are immutable, so they may be stored safely as static constants.\n",
        "113": " *\n",
        "114": " * @author Louis Wasserman\n",
        "115": " * @since 14.0\n",
        "116": " */\n",
        "117": "@Beta\n",
        "118": "@GwtCompatible(emulated = true)\n",
        "119": "public abstract class BaseEncoding {\n",
        "120": "  // TODO(lowasser): consider making encodeTo(Appendable, byte[], int, int) public.\n",
        "121": "\n",
        "122": "  BaseEncoding() {}\n",
        "123": "\n",
        "124": "  /**\n",
        "125": "   * Exception indicating invalid base-encoded input encountered while decoding.\n",
        "126": "   *\n",
        "127": "   * @author Louis Wasserman\n",
        "128": "   * @since 15.0\n",
        "129": "   */\n",
        "130": "  public static final class DecodingException extends IOException {\n",
        "131": "    DecodingException(String message) {\n",
        "132": "      super(message);\n",
        "133": "    }\n",
        "134": "\n",
        "135": "    DecodingException(Throwable cause) {\n",
        "136": "      super(cause);\n",
        "137": "    }\n",
        "138": "  }\n",
        "139": "\n",
        "140": "  /**\n",
        "141": "   * Encodes the specified byte array, and returns the encoded {@code String}.\n",
        "142": "   */\n",
        "143": "  public String encode(byte[] bytes) {\n",
        "144": "    return encode(bytes, 0, bytes.length);\n",
        "145": "  }\n",
        "146": "\n",
        "147": "  /**\n",
        "148": "   * Encodes the specified range of the specified byte array, and returns the encoded\n",
        "149": "   * {@code String}.\n",
        "150": "   */\n",
        "151": "  public final String encode(byte[] bytes, int off, int len) {\n",
        "152": "    checkPositionIndexes(off, off + len, bytes.length);\n",
        "153": "    StringBuilder result = new StringBuilder(maxEncodedSize(len));\n",
        "154": "    try {\n",
        "155": "      encodeTo(result, bytes, off, len);\n",
        "156": "    } catch (IOException impossible) {\n",
        "157": "      throw new AssertionError(impossible);\n",
        "158": "    }\n",
        "159": "    return result.toString();\n",
        "160": "  }\n",
        "161": "\n",
        "162": "  // TODO(lowasser): document the extent of leniency, probably after adding ignore(CharMatcher)\n",
        "163": "\n",
        "164": "  private static byte[] extract(byte[] result, int length) {\n",
        "165": "    if (length == result.length) {\n",
        "166": "      return result;\n",
        "167": "    } else {\n",
        "168": "      byte[] trunc = new byte[length];\n",
        "169": "      System.arraycopy(result, 0, trunc, 0, length);\n",
        "170": "      return trunc;\n",
        "171": "    }\n",
        "172": "  }\n",
        "173": "\n",
        "174": "  /**\n",
        "175": "   * Decodes the specified character sequence, and returns the resulting {@code byte[]}.\n",
        "176": "   * This is the inverse operation to {@link #encode(byte[])}.\n",
        "177": "   *\n",
        "178": "   * @throws IllegalArgumentException if the input is not a valid encoded string according to this\n",
        "179": "   *         encoding.\n",
        "180": "   */\n",
        "181": "  public final byte[] decode(CharSequence chars) {\n",
        "182": "    try {\n",
        "183": "      return decodeChecked(chars);\n",
        "184": "    } catch (DecodingException badInput) {\n",
        "185": "      throw new IllegalArgumentException(badInput);\n",
        "186": "    }\n",
        "187": "  }\n",
        "188": "\n",
        "189": "  /**\n",
        "190": "   * Decodes the specified character sequence, and returns the resulting {@code byte[]}.\n",
        "191": "   * This is the inverse operation to {@link #encode(byte[])}.\n",
        "192": "   *\n",
        "193": "   * @throws DecodingException if the input is not a valid encoded string according to this\n",
        "194": "   *         encoding.\n",
        "195": "   */\n",
        "196": "  final byte[] decodeChecked(CharSequence chars) throws DecodingException {\n",
        "197": "    chars = padding().trimTrailingFrom(chars);\n",
        "198": "    byte[] tmp = new byte[maxDecodedSize(chars.length())];\n",
        "199": "    int len = decodeTo(tmp, chars);\n",
        "200": "    return extract(tmp, len);\n",
        "201": "  }\n",
        "202": "\n",
        "203": "  // Implementations for encoding/decoding\n",
        "204": "\n",
        "205": "  abstract int maxEncodedSize(int bytes);\n",
        "206": "\n",
        "207": "  abstract void encodeTo(Appendable target, byte[] bytes, int off, int len) throws IOException;\n",
        "208": "\n",
        "209": "  abstract int maxDecodedSize(int chars);\n",
        "210": "\n",
        "211": "  abstract int decodeTo(byte[] target, CharSequence chars) throws DecodingException;\n",
        "212": "\n",
        "213": "  abstract CharMatcher padding();\n",
        "214": "\n",
        "215": "  // Modified encoding generators\n",
        "216": "\n",
        "217": "  /**\n",
        "218": "   * Returns an encoding that behaves equivalently to this encoding, but omits any padding\n",
        "219": "   * characters as specified by <a href=\"http://tools.ietf.org/html/rfc4648#section-3.2\">RFC 4648\n",
        "220": "   * section 3.2</a>, Padding of Encoded Data.\n",
        "221": "   */\n",
        "222": "  @CheckReturnValue\n",
        "223": "  public abstract BaseEncoding omitPadding();\n",
        "224": "\n",
        "225": "  /**\n",
        "226": "   * Returns an encoding that behaves equivalently to this encoding, but uses an alternate character\n",
        "227": "   * for padding.\n",
        "228": "   *\n",
        "229": "   * @throws IllegalArgumentException if this padding character is already used in the alphabet or a\n",
        "230": "   *         separator\n",
        "231": "   */\n",
        "232": "  @CheckReturnValue\n",
        "233": "  public abstract BaseEncoding withPadChar(char padChar);\n",
        "234": "\n",
        "235": "  /**\n",
        "236": "   * Returns an encoding that behaves equivalently to this encoding, but adds a separator string\n",
        "237": "   * after every {@code n} characters. Any occurrences of any characters that occur in the separator\n",
        "238": "   * are skipped over in decoding.\n",
        "239": "   *\n",
        "240": "   * @throws IllegalArgumentException if any alphabet or padding characters appear in the separator\n",
        "241": "   *         string, or if {@code n <= 0}\n",
        "242": "   * @throws UnsupportedOperationException if this encoding already uses a separator\n",
        "243": "   */\n",
        "244": "  @CheckReturnValue\n",
        "245": "  public abstract BaseEncoding withSeparator(String separator, int n);\n",
        "246": "\n",
        "247": "  /**\n",
        "248": "   * Returns an encoding that behaves equivalently to this encoding, but encodes and decodes with\n",
        "249": "   * uppercase letters. Padding and separator characters remain in their original case.\n",
        "250": "   *\n",
        "251": "   * @throws IllegalStateException if the alphabet used by this encoding contains mixed upper- and\n",
        "252": "   *         lower-case characters\n",
        "253": "   */\n",
        "254": "  @CheckReturnValue\n",
        "255": "  public abstract BaseEncoding upperCase();\n",
        "256": "\n",
        "257": "  /**\n",
        "258": "   * Returns an encoding that behaves equivalently to this encoding, but encodes and decodes with\n",
        "259": "   * lowercase letters. Padding and separator characters remain in their original case.\n",
        "260": "   *\n",
        "261": "   * @throws IllegalStateException if the alphabet used by this encoding contains mixed upper- and\n",
        "262": "   *         lower-case characters\n",
        "263": "   */\n",
        "264": "  @CheckReturnValue\n",
        "265": "  public abstract BaseEncoding lowerCase();\n",
        "266": "\n",
        "267": "  private static final BaseEncoding BASE64 = new Base64Encoding(\n",
        "268": "      \"base64()\", \"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/\", '=');\n",
        "269": "\n",
        "270": "  /**\n",
        "271": "   * The \"base64\" base encoding specified by <a\n",
        "272": "   * href=\"http://tools.ietf.org/html/rfc4648#section-4\">RFC 4648 section 4</a>, Base 64 Encoding.\n",
        "273": "   * (This is the same as the base 64 encoding from <a\n",
        "274": "   * href=\"http://tools.ietf.org/html/rfc3548#section-3\">RFC 3548</a>.)\n",
        "275": "   *\n",
        "276": "   * <p>The character {@code '='} is used for padding, but can be {@linkplain #omitPadding()\n",
        "277": "   * omitted} or {@linkplain #withPadChar(char) replaced}.\n",
        "278": "   *\n",
        "279": "   * <p>No line feeds are added by default, as per <a\n",
        "280": "   * href=\"http://tools.ietf.org/html/rfc4648#section-3.1\"> RFC 4648 section 3.1</a>, Line Feeds in\n",
        "281": "   * Encoded Data. Line feeds may be added using {@link #withSeparator(String, int)}.\n",
        "282": "   */\n",
        "283": "  public static BaseEncoding base64() {\n",
        "284": "    return BASE64;\n",
        "285": "  }\n",
        "286": "\n",
        "287": "  private static final BaseEncoding BASE64_URL = new Base64Encoding(\n",
        "288": "      \"base64Url()\", \"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_\", '=');\n",
        "289": "\n",
        "290": "  /**\n",
        "291": "   * The \"base64url\" encoding specified by <a\n",
        "292": "   * href=\"http://tools.ietf.org/html/rfc4648#section-5\">RFC 4648 section 5</a>, Base 64 Encoding\n",
        "293": "   * with URL and Filename Safe Alphabet, also sometimes referred to as the \"web safe Base64.\"\n",
        "294": "   * (This is the same as the base 64 encoding with URL and filename safe alphabet from <a\n",
        "295": "   * href=\"http://tools.ietf.org/html/rfc3548#section-4\">RFC 3548</a>.)\n",
        "296": "   *\n",
        "297": "   * <p>The character {@code '='} is used for padding, but can be {@linkplain #omitPadding()\n",
        "298": "   * omitted} or {@linkplain #withPadChar(char) replaced}.\n",
        "299": "   *\n",
        "300": "   * <p>No line feeds are added by default, as per <a\n",
        "301": "   * href=\"http://tools.ietf.org/html/rfc4648#section-3.1\"> RFC 4648 section 3.1</a>, Line Feeds in\n",
        "302": "   * Encoded Data. Line feeds may be added using {@link #withSeparator(String, int)}.\n",
        "303": "   */\n",
        "304": "  public static BaseEncoding base64Url() {\n",
        "305": "    return BASE64_URL;\n",
        "306": "  }\n",
        "307": "\n",
        "308": "  private static final BaseEncoding BASE32 =\n",
        "309": "      new StandardBaseEncoding(\"base32()\", \"ABCDEFGHIJKLMNOPQRSTUVWXYZ234567\", '=');\n",
        "310": "\n",
        "311": "  /**\n",
        "312": "   * The \"base32\" encoding specified by <a\n",
        "313": "   * href=\"http://tools.ietf.org/html/rfc4648#section-6\">RFC 4648 section 6</a>, Base 32 Encoding.\n",
        "314": "   * (This is the same as the base 32 encoding from <a\n",
        "315": "   * href=\"http://tools.ietf.org/html/rfc3548#section-5\">RFC 3548</a>.)\n",
        "316": "   *\n",
        "317": "   * <p>The character {@code '='} is used for padding, but can be {@linkplain #omitPadding()\n",
        "318": "   * omitted} or {@linkplain #withPadChar(char) replaced}.\n",
        "319": "   *\n",
        "320": "   * <p>No line feeds are added by default, as per <a\n",
        "321": "   * href=\"http://tools.ietf.org/html/rfc4648#section-3.1\"> RFC 4648 section 3.1</a>, Line Feeds in\n",
        "322": "   * Encoded Data. Line feeds may be added using {@link #withSeparator(String, int)}.\n",
        "323": "   */\n",
        "324": "  public static BaseEncoding base32() {\n",
        "325": "    return BASE32;\n",
        "326": "  }\n",
        "327": "\n",
        "328": "  private static final BaseEncoding BASE32_HEX =\n",
        "329": "      new StandardBaseEncoding(\"base32Hex()\", \"0123456789ABCDEFGHIJKLMNOPQRSTUV\", '=');\n",
        "330": "\n",
        "331": "  /**\n",
        "332": "   * The \"base32hex\" encoding specified by <a\n",
        "333": "   * href=\"http://tools.ietf.org/html/rfc4648#section-7\">RFC 4648 section 7</a>, Base 32 Encoding\n",
        "334": "   * with Extended Hex Alphabet.  There is no corresponding encoding in RFC 3548.\n",
        "335": "   *\n",
        "336": "   * <p>The character {@code '='} is used for padding, but can be {@linkplain #omitPadding()\n",
        "337": "   * omitted} or {@linkplain #withPadChar(char) replaced}.\n",
        "338": "   *\n",
        "339": "   * <p>No line feeds are added by default, as per <a\n",
        "340": "   * href=\"http://tools.ietf.org/html/rfc4648#section-3.1\"> RFC 4648 section 3.1</a>, Line Feeds in\n",
        "341": "   * Encoded Data. Line feeds may be added using {@link #withSeparator(String, int)}.\n",
        "342": "   */\n",
        "343": "  public static BaseEncoding base32Hex() {\n",
        "344": "    return BASE32_HEX;\n",
        "345": "  }\n",
        "346": "\n",
        "347": "  private static final BaseEncoding BASE16 = new Base16Encoding(\"base16()\", \"0123456789ABCDEF\");\n",
        "348": "\n",
        "349": "  /**\n",
        "350": "   * The \"base16\" encoding specified by <a\n",
        "351": "   * href=\"http://tools.ietf.org/html/rfc4648#section-8\">RFC 4648 section 8</a>, Base 16 Encoding.\n",
        "352": "   * (This is the same as the base 16 encoding from <a\n",
        "353": "   * href=\"http://tools.ietf.org/html/rfc3548#section-6\">RFC 3548</a>.) This is commonly known as\n",
        "354": "   * \"hexadecimal\" format.\n",
        "355": "   *\n",
        "356": "   * <p>No padding is necessary in base 16, so {@link #withPadChar(char)} and\n",
        "357": "   * {@link #omitPadding()} have no effect.\n",
        "358": "   *\n",
        "359": "   * <p>No line feeds are added by default, as per <a\n",
        "360": "   * href=\"http://tools.ietf.org/html/rfc4648#section-3.1\"> RFC 4648 section 3.1</a>, Line Feeds in\n",
        "361": "   * Encoded Data. Line feeds may be added using {@link #withSeparator(String, int)}.\n",
        "362": "   */\n",
        "363": "  public static BaseEncoding base16() {\n",
        "364": "    return BASE16;\n",
        "365": "  }\n",
        "366": "\n",
        "367": "  private static final class Alphabet extends CharMatcher {\n",
        "368": "    private final String name;\n",
        "369": "    // this is meant to be immutable -- don't modify it!\n",
        "370": "    private final char[] chars;\n",
        "371": "    final int mask;\n",
        "372": "    final int bitsPerChar;\n",
        "373": "    final int charsPerChunk;\n",
        "374": "    final int bytesPerChunk;\n",
        "375": "    private final byte[] decodabet;\n",
        "376": "    private final boolean[] validPadding;\n",
        "377": "\n",
        "378": "    Alphabet(String name, char[] chars) {\n",
        "379": "      this.name = checkNotNull(name);\n",
        "380": "      this.chars = checkNotNull(chars);\n",
        "381": "      try {\n",
        "382": "        this.bitsPerChar = log2(chars.length, UNNECESSARY);\n",
        "383": "      } catch (ArithmeticException e) {\n",
        "384": "        throw new IllegalArgumentException(\"Illegal alphabet length \" + chars.length, e);\n",
        "385": "      }\n",
        "386": "\n",
        "387": "      /*\n",
        "388": "       * e.g. for base64, bitsPerChar == 6, charsPerChunk == 4, and bytesPerChunk == 3. This makes\n",
        "389": "       * for the smallest chunk size that still has charsPerChunk * bitsPerChar be a multiple of 8.\n",
        "390": "       */\n",
        "391": "      int gcd = Math.min(8, Integer.lowestOneBit(bitsPerChar));\n",
        "392": "      this.charsPerChunk = 8 / gcd;\n",
        "393": "      this.bytesPerChunk = bitsPerChar / gcd;\n",
        "394": "\n",
        "395": "      this.mask = chars.length - 1;\n",
        "396": "\n",
        "397": "      byte[] decodabet = new byte[Ascii.MAX + 1];\n",
        "398": "      Arrays.fill(decodabet, (byte) -1);\n",
        "399": "      for (int i = 0; i < chars.length; i++) {\n",
        "400": "        char c = chars[i];\n",
        "401": "        checkArgument(CharMatcher.ASCII.matches(c), \"Non-ASCII character: %s\", c);\n",
        "402": "        checkArgument(decodabet[c] == -1, \"Duplicate character: %s\", c);\n",
        "403": "        decodabet[c] = (byte) i;\n",
        "404": "      }\n",
        "405": "      this.decodabet = decodabet;\n",
        "406": "\n",
        "407": "      boolean[] validPadding = new boolean[charsPerChunk];\n",
        "408": "      for (int i = 0; i < bytesPerChunk; i++) {\n",
        "409": "        validPadding[divide(i * 8, bitsPerChar, CEILING)] = true;\n",
        "410": "      }\n",
        "411": "      this.validPadding = validPadding;\n",
        "412": "    }\n",
        "413": "\n",
        "414": "    char encode(int bits) {\n",
        "415": "      return chars[bits];\n",
        "416": "    }\n",
        "417": "\n",
        "418": "    boolean isValidPaddingStartPosition(int index) {\n",
        "419": "      return validPadding[index % charsPerChunk];\n",
        "420": "    }\n",
        "421": "\n",
        "422": "    int decode(char ch) throws DecodingException {\n",
        "423": "      if (ch > Ascii.MAX || decodabet[ch] == -1) {\n",
        "424": "        throw new DecodingException(\"Unrecognized character: \"\n",
        "425": "            + (CharMatcher.INVISIBLE.matches(ch) ? \"0x\" + Integer.toHexString(ch) : ch));\n",
        "426": "      }\n",
        "427": "      return decodabet[ch];\n",
        "428": "    }\n",
        "429": "\n",
        "430": "    private boolean hasLowerCase() {\n",
        "431": "      for (char c : chars) {\n",
        "432": "        if (Ascii.isLowerCase(c)) {\n",
        "433": "          return true;\n",
        "434": "        }\n",
        "435": "      }\n",
        "436": "      return false;\n",
        "437": "    }\n",
        "438": "\n",
        "439": "    private boolean hasUpperCase() {\n",
        "440": "      for (char c : chars) {\n",
        "441": "        if (Ascii.isUpperCase(c)) {\n",
        "442": "          return true;\n",
        "443": "        }\n",
        "444": "      }\n",
        "445": "      return false;\n",
        "446": "    }\n",
        "447": "\n",
        "448": "    Alphabet upperCase() {\n",
        "449": "      if (!hasLowerCase()) {\n",
        "450": "        return this;\n",
        "451": "      } else {\n",
        "452": "        checkState(!hasUpperCase(), \"Cannot call upperCase() on a mixed-case alphabet\");\n",
        "453": "        char[] upperCased = new char[chars.length];\n",
        "454": "        for (int i = 0; i < chars.length; i++) {\n",
        "455": "          upperCased[i] = Ascii.toUpperCase(chars[i]);\n",
        "456": "        }\n",
        "457": "        return new Alphabet(name + \".upperCase()\", upperCased);\n",
        "458": "      }\n",
        "459": "    }\n",
        "460": "\n",
        "461": "    Alphabet lowerCase() {\n",
        "462": "      if (!hasUpperCase()) {\n",
        "463": "        return this;\n",
        "464": "      } else {\n",
        "465": "        checkState(!hasLowerCase(), \"Cannot call lowerCase() on a mixed-case alphabet\");\n",
        "466": "        char[] lowerCased = new char[chars.length];\n",
        "467": "        for (int i = 0; i < chars.length; i++) {\n",
        "468": "          lowerCased[i] = Ascii.toLowerCase(chars[i]);\n",
        "469": "        }\n",
        "470": "        return new Alphabet(name + \".lowerCase()\", lowerCased);\n",
        "471": "      }\n",
        "472": "    }\n",
        "473": "\n",
        "474": "    @Override\n",
        "475": "    public boolean matches(char c) {\n",
        "476": "      return CharMatcher.ASCII.matches(c) && decodabet[c] != -1;\n",
        "477": "    }\n",
        "478": "\n",
        "479": "    @Override\n",
        "480": "    public String toString() {\n",
        "481": "      return name;\n",
        "482": "    }\n",
        "483": "  }\n",
        "484": "\n",
        "485": "  static class StandardBaseEncoding extends BaseEncoding {\n",
        "486": "    // TODO(lowasser): provide a useful toString\n",
        "487": "    final Alphabet alphabet;\n",
        "488": "\n",
        "489": "    @Nullable\n",
        "490": "    final Character paddingChar;\n",
        "491": "\n",
        "492": "    StandardBaseEncoding(String name, String alphabetChars, @Nullable Character paddingChar) {\n",
        "493": "      this(new Alphabet(name, alphabetChars.toCharArray()), paddingChar);\n",
        "494": "    }\n",
        "495": "\n",
        "496": "    StandardBaseEncoding(Alphabet alphabet, @Nullable Character paddingChar) {\n",
        "497": "      this.alphabet = checkNotNull(alphabet);\n",
        "498": "      checkArgument(paddingChar == null || !alphabet.matches(paddingChar),\n",
        "499": "          \"Padding character %s was already in alphabet\", paddingChar);\n",
        "500": "      this.paddingChar = paddingChar;\n",
        "501": "    }\n",
        "502": "\n",
        "503": "    @Override\n",
        "504": "    CharMatcher padding() {\n",
        "505": "      return (paddingChar == null) ? CharMatcher.NONE : CharMatcher.is(paddingChar.charValue());\n",
        "506": "    }\n",
        "507": "\n",
        "508": "    @Override\n",
        "509": "    int maxEncodedSize(int bytes) {\n",
        "510": "      return alphabet.charsPerChunk * divide(bytes, alphabet.bytesPerChunk, CEILING);\n",
        "511": "    }\n",
        "512": "\n",
        "513": "    @Override\n",
        "514": "    void encodeTo(Appendable target, byte[] bytes, int off, int len) throws IOException {\n",
        "515": "      checkNotNull(target);\n",
        "516": "      checkPositionIndexes(off, off + len, bytes.length);\n",
        "517": "      for (int i = 0; i < len; i += alphabet.bytesPerChunk) {\n",
        "518": "        encodeChunkTo(target, bytes, off + i, Math.min(alphabet.bytesPerChunk, len - i));\n",
        "519": "      }\n",
        "520": "    }\n",
        "521": "\n",
        "522": "    void encodeChunkTo(Appendable target, byte[] bytes, int off, int len)\n",
        "523": "        throws IOException {\n",
        "524": "      checkNotNull(target);\n",
        "525": "      checkPositionIndexes(off, off + len, bytes.length);\n",
        "526": "      checkArgument(len <= alphabet.bytesPerChunk);\n",
        "527": "      long bitBuffer = 0;\n",
        "528": "      for (int i = 0; i < len; ++i) {\n",
        "529": "        bitBuffer |= bytes[off + i] & 0xFF;\n",
        "530": "        bitBuffer <<= 8; // Add additional zero byte in the end.\n",
        "531": "      }\n",
        "532": "      // Position of first character is length of bitBuffer minus bitsPerChar.\n",
        "533": "      final int bitOffset = (len + 1) * 8 - alphabet.bitsPerChar;\n",
        "534": "      int bitsProcessed = 0;\n",
        "535": "      while (bitsProcessed < len * 8) {\n",
        "536": "        int charIndex = (int) (bitBuffer >>> (bitOffset - bitsProcessed)) & alphabet.mask;\n",
        "537": "        target.append(alphabet.encode(charIndex));\n",
        "538": "        bitsProcessed += alphabet.bitsPerChar;\n",
        "539": "      }\n",
        "540": "      if (paddingChar != null) {\n",
        "541": "        while (bitsProcessed < alphabet.bytesPerChunk * 8) {\n",
        "542": "          target.append(paddingChar.charValue());\n",
        "543": "          bitsProcessed += alphabet.bitsPerChar;\n",
        "544": "        }\n",
        "545": "      }\n",
        "546": "    }\n",
        "547": "\n",
        "548": "    @Override\n",
        "549": "    int maxDecodedSize(int chars) {\n",
        "550": "      return (int) ((alphabet.bitsPerChar * (long) chars + 7L) / 8L);\n",
        "551": "    }\n",
        "552": "\n",
        "553": "    @Override\n",
        "554": "    int decodeTo(byte[] target, CharSequence chars) throws DecodingException {\n",
        "555": "      checkNotNull(target);\n",
        "556": "      chars = padding().trimTrailingFrom(chars);\n",
        "557": "      if (!alphabet.isValidPaddingStartPosition(chars.length())) {\n",
        "558": "        throw new DecodingException(\"Invalid input length \" + chars.length());\n",
        "559": "      }\n",
        "560": "      int bytesWritten = 0;\n",
        "561": "      for (int charIdx = 0; charIdx < chars.length(); charIdx += alphabet.charsPerChunk) {\n",
        "562": "        long chunk = 0;\n",
        "563": "        int charsProcessed = 0;\n",
        "564": "        for (int i = 0; i < alphabet.charsPerChunk; i++) {\n",
        "565": "          chunk <<= alphabet.bitsPerChar;\n",
        "566": "          if (charIdx + i < chars.length()) {\n",
        "567": "            chunk |= alphabet.decode(chars.charAt(charIdx + charsProcessed++));\n",
        "568": "          }\n",
        "569": "        }\n",
        "570": "        final int minOffset = alphabet.bytesPerChunk * 8 - charsProcessed * alphabet.bitsPerChar;\n",
        "571": "        for (int offset = (alphabet.bytesPerChunk - 1) * 8; offset >= minOffset; offset -= 8) {\n",
        "572": "          target[bytesWritten++] = (byte) ((chunk >>> offset) & 0xFF);\n",
        "573": "        }\n",
        "574": "      }\n",
        "575": "      return bytesWritten;\n",
        "576": "    }\n",
        "577": "\n",
        "578": "    @Override\n",
        "579": "    public BaseEncoding omitPadding() {\n",
        "580": "      return (paddingChar == null) ? this : newInstance(alphabet, null);\n",
        "581": "    }\n",
        "582": "\n",
        "583": "    @Override\n",
        "584": "    public BaseEncoding withPadChar(char padChar) {\n",
        "585": "      if (8 % alphabet.bitsPerChar == 0 ||\n",
        "586": "          (paddingChar != null && paddingChar.charValue() == padChar)) {\n",
        "587": "        return this;\n",
        "588": "      } else {\n",
        "589": "        return newInstance(alphabet, padChar);\n",
        "590": "      }\n",
        "591": "    }\n",
        "592": "\n",
        "593": "    @Override\n",
        "594": "    public BaseEncoding withSeparator(String separator, int afterEveryChars) {\n",
        "595": "      checkArgument(padding().or(alphabet).matchesNoneOf(separator),\n",
        "596": "          \"Separator (%s) cannot contain alphabet or padding characters\", separator);\n",
        "597": "      return new SeparatedBaseEncoding(this, separator, afterEveryChars);\n",
        "598": "    }\n",
        "599": "\n",
        "600": "    private transient BaseEncoding upperCase;\n",
        "601": "    private transient BaseEncoding lowerCase;\n",
        "602": "\n",
        "603": "    @Override\n",
        "604": "    public BaseEncoding upperCase() {\n",
        "605": "      BaseEncoding result = upperCase;\n",
        "606": "      if (result == null) {\n",
        "607": "        Alphabet upper = alphabet.upperCase();\n",
        "608": "        result = upperCase =\n",
        "609": "            (upper == alphabet) ? this : newInstance(upper, paddingChar);\n",
        "610": "      }\n",
        "611": "      return result;\n",
        "612": "    }\n",
        "613": "\n",
        "614": "    @Override\n",
        "615": "    public BaseEncoding lowerCase() {\n",
        "616": "      BaseEncoding result = lowerCase;\n",
        "617": "      if (result == null) {\n",
        "618": "        Alphabet lower = alphabet.lowerCase();\n",
        "619": "        result = lowerCase =\n",
        "620": "            (lower == alphabet) ? this : newInstance(lower, paddingChar);\n",
        "621": "      }\n",
        "622": "      return result;\n",
        "623": "    }\n",
        "624": "\n",
        "625": "    BaseEncoding newInstance(Alphabet alphabet, @Nullable Character paddingChar) {\n",
        "626": "      return new StandardBaseEncoding(alphabet, paddingChar);\n",
        "627": "    }\n",
        "628": "\n",
        "629": "    @Override\n",
        "630": "    public String toString() {\n",
        "631": "      StringBuilder builder = new StringBuilder(\"BaseEncoding.\");\n",
        "632": "      builder.append(alphabet.toString());\n",
        "633": "      if (8 % alphabet.bitsPerChar != 0) {\n",
        "634": "        if (paddingChar == null) {\n",
        "635": "          builder.append(\".omitPadding()\");\n",
        "636": "        } else {\n",
        "637": "          builder.append(\".withPadChar(\").append(paddingChar).append(')');\n",
        "638": "        }\n",
        "639": "      }\n",
        "640": "      return builder.toString();\n",
        "641": "    }\n",
        "642": "  }\n",
        "643": "\n",
        "644": "  static final class Base16Encoding extends StandardBaseEncoding {\n",
        "645": "    final char[] encoding = new char[512];\n",
        "646": "\n",
        "647": "    Base16Encoding(String name, String alphabetChars) {\n",
        "648": "      this(new Alphabet(name, alphabetChars.toCharArray()));\n",
        "649": "    }\n",
        "650": "\n",
        "651": "    private Base16Encoding(Alphabet alphabet) {\n",
        "652": "      super(alphabet, null);\n",
        "653": "      checkArgument(alphabet.chars.length == 16);\n",
        "654": "      for (int i = 0; i < 256; ++i) {\n",
        "655": "        encoding[i] = alphabet.encode(i >>> 4);\n",
        "656": "        encoding[i | 0x100] = alphabet.encode(i & 0xF);\n",
        "657": "      }\n",
        "658": "    }\n",
        "659": "\n",
        "660": "    @Override\n",
        "661": "    void encodeTo(Appendable target, byte[] bytes, int off, int len) throws IOException {\n",
        "662": "      checkNotNull(target);\n",
        "663": "      checkPositionIndexes(off, off + len, bytes.length);\n",
        "664": "      for (int i = 0; i < len; ++i) {\n",
        "665": "        int b = bytes[off + i] & 0xFF;\n",
        "666": "        target.append(encoding[b]);\n",
        "667": "        target.append(encoding[b | 0x100]);\n",
        "668": "      }\n",
        "669": "    }\n",
        "670": "\n",
        "671": "    @Override\n",
        "672": "    int decodeTo(byte[] target, CharSequence chars) throws DecodingException {\n",
        "673": "      checkNotNull(target);\n",
        "674": "      if (chars.length() % 2 == 1) {\n",
        "675": "        throw new DecodingException(\"Invalid input length \" + chars.length());\n",
        "676": "      }\n",
        "677": "      int bytesWritten = 0;\n",
        "678": "      for (int i = 0; i < chars.length(); i += 2) {\n",
        "679": "        int decoded = alphabet.decode(chars.charAt(i)) << 4 | alphabet.decode(chars.charAt(i + 1));\n",
        "680": "        target[bytesWritten++] = (byte) decoded;\n",
        "681": "      }\n",
        "682": "      return bytesWritten;\n",
        "683": "    }\n",
        "684": "\n",
        "685": "    @Override\n",
        "686": "    BaseEncoding newInstance(Alphabet alphabet, @Nullable Character paddingChar) {\n",
        "687": "      return new Base16Encoding(alphabet);\n",
        "688": "    }\n",
        "689": "  }\n",
        "690": "\n",
        "691": "  static final class Base64Encoding extends StandardBaseEncoding {\n",
        "692": "    Base64Encoding(String name, String alphabetChars, @Nullable Character paddingChar) {\n",
        "693": "      this(new Alphabet(name, alphabetChars.toCharArray()), paddingChar);\n",
        "694": "    }\n",
        "695": "\n",
        "696": "    private Base64Encoding(Alphabet alphabet, @Nullable Character paddingChar) {\n",
        "697": "      super(alphabet, paddingChar);\n",
        "698": "      checkArgument(alphabet.chars.length == 64);\n",
        "699": "    }\n",
        "700": "\n",
        "701": "    @Override\n",
        "702": "    void encodeTo(Appendable target, byte[] bytes, int off, int len) throws IOException {\n",
        "703": "      checkNotNull(target);\n",
        "704": "      checkPositionIndexes(off, off + len, bytes.length);\n",
        "705": "      int i = off;\n",
        "706": "      for (int remaining = len; remaining >= 3; remaining -= 3) {\n",
        "707": "        int chunk = (bytes[i++] & 0xFF) << 16 | (bytes[i++] & 0xFF) << 8 | bytes[i++] & 0xFF;\n",
        "708": "        target.append(alphabet.encode(chunk >>> 18));\n",
        "709": "        target.append(alphabet.encode((chunk >>> 12) & 0x3F));\n",
        "710": "        target.append(alphabet.encode((chunk >>> 6) & 0x3F));\n",
        "711": "        target.append(alphabet.encode(chunk & 0x3F));\n",
        "712": "      }\n",
        "713": "      if (i < off + len) {\n",
        "714": "        encodeChunkTo(target, bytes, i, off + len - i);\n",
        "715": "      }\n",
        "716": "    }\n",
        "717": "\n",
        "718": "    @Override\n",
        "719": "    int decodeTo(byte[] target, CharSequence chars) throws DecodingException {\n",
        "720": "      checkNotNull(target);\n",
        "721": "      chars = padding().trimTrailingFrom(chars);\n",
        "722": "      if (!alphabet.isValidPaddingStartPosition(chars.length())) {\n",
        "723": "        throw new DecodingException(\"Invalid input length \" + chars.length());\n",
        "724": "      }\n",
        "725": "      int bytesWritten = 0;\n",
        "726": "      for (int i = 0; i < chars.length();) {\n",
        "727": "        int chunk = alphabet.decode(chars.charAt(i++)) << 18;\n",
        "728": "        chunk |= alphabet.decode(chars.charAt(i++)) << 12;\n",
        "729": "        target[bytesWritten++] = (byte) (chunk >>> 16);\n",
        "730": "        if (i < chars.length()) {\n",
        "731": "          chunk |= alphabet.decode(chars.charAt(i++)) << 6;\n",
        "732": "          target[bytesWritten++] = (byte) ((chunk >>> 8) & 0xFF);\n",
        "733": "          if (i < chars.length()) {\n",
        "734": "            chunk |= alphabet.decode(chars.charAt(i++));\n",
        "735": "            target[bytesWritten++] = (byte) (chunk & 0xFF);\n",
        "736": "          }\n",
        "737": "        }\n",
        "738": "      }\n",
        "739": "      return bytesWritten;\n",
        "740": "    }\n",
        "741": "\n",
        "742": "    @Override\n",
        "743": "    BaseEncoding newInstance(Alphabet alphabet, @Nullable Character paddingChar) {\n",
        "744": "      return new Base64Encoding(alphabet, paddingChar);\n",
        "745": "    }\n",
        "746": "  }\n",
        "747": "\n",
        "748": "  static Appendable separatingAppendable(\n",
        "749": "      final Appendable delegate, final String separator, final int afterEveryChars) {\n",
        "750": "    checkNotNull(delegate);\n",
        "751": "    checkNotNull(separator);\n",
        "752": "    checkArgument(afterEveryChars > 0);\n",
        "753": "    return new Appendable() {\n",
        "754": "      int charsUntilSeparator = afterEveryChars;\n",
        "755": "\n",
        "756": "      @Override\n",
        "757": "      public Appendable append(char c) throws IOException {\n",
        "758": "        if (charsUntilSeparator == 0) {\n",
        "759": "          delegate.append(separator);\n",
        "760": "          charsUntilSeparator = afterEveryChars;\n",
        "761": "        }\n",
        "762": "        delegate.append(c);\n",
        "763": "        charsUntilSeparator--;\n",
        "764": "        return this;\n",
        "765": "      }\n",
        "766": "\n",
        "767": "      @Override\n",
        "768": "      public Appendable append(CharSequence chars, int off, int len) throws IOException {\n",
        "769": "        throw new UnsupportedOperationException();\n",
        "770": "      }\n",
        "771": "\n",
        "772": "      @Override\n",
        "773": "      public Appendable append(CharSequence chars) throws IOException {\n",
        "774": "        throw new UnsupportedOperationException();\n",
        "775": "      }\n",
        "776": "    };\n",
        "777": "  }\n",
        "778": "\n",
        "779": "  static final class SeparatedBaseEncoding extends BaseEncoding {\n",
        "780": "    private final BaseEncoding delegate;\n",
        "781": "    private final String separator;\n",
        "782": "    private final int afterEveryChars;\n",
        "783": "    private final CharMatcher separatorChars;\n",
        "784": "\n",
        "785": "    SeparatedBaseEncoding(BaseEncoding delegate, String separator, int afterEveryChars) {\n",
        "786": "      this.delegate = checkNotNull(delegate);\n",
        "787": "      this.separator = checkNotNull(separator);\n",
        "788": "      this.afterEveryChars = afterEveryChars;\n",
        "789": "      checkArgument(\n",
        "790": "          afterEveryChars > 0, \"Cannot add a separator after every %s chars\", afterEveryChars);\n",
        "791": "      this.separatorChars = CharMatcher.anyOf(separator).precomputed();\n",
        "792": "    }\n",
        "793": "\n",
        "794": "    @Override\n",
        "795": "    CharMatcher padding() {\n",
        "796": "      return delegate.padding();\n",
        "797": "    }\n",
        "798": "\n",
        "799": "    @Override\n",
        "800": "    int maxEncodedSize(int bytes) {\n",
        "801": "      int unseparatedSize = delegate.maxEncodedSize(bytes);\n",
        "802": "      return unseparatedSize + separator.length()\n",
        "803": "          * divide(Math.max(0, unseparatedSize - 1), afterEveryChars, FLOOR);\n",
        "804": "    }\n",
        "805": "\n",
        "806": "    @Override\n",
        "807": "    void encodeTo(Appendable target, byte[] bytes, int off, int len) throws IOException {\n",
        "808": "      delegate.encodeTo(separatingAppendable(target, separator, afterEveryChars), bytes, off, len);\n",
        "809": "    }\n",
        "810": "\n",
        "811": "    @Override\n",
        "812": "    int maxDecodedSize(int chars) {\n",
        "813": "      return delegate.maxDecodedSize(chars);\n",
        "814": "    }\n",
        "815": "\n",
        "816": "    @Override\n",
        "817": "    int decodeTo(byte[] target, CharSequence chars) throws DecodingException {\n",
        "818": "      return delegate.decodeTo(target, separatorChars.removeFrom(chars));\n",
        "819": "    }\n",
        "820": "\n",
        "821": "    @Override\n",
        "822": "    public BaseEncoding omitPadding() {\n",
        "823": "      return delegate.omitPadding().withSeparator(separator, afterEveryChars);\n",
        "824": "    }\n",
        "825": "\n",
        "826": "    @Override\n",
        "827": "    public BaseEncoding withPadChar(char padChar) {\n",
        "828": "      return delegate.withPadChar(padChar).withSeparator(separator, afterEveryChars);\n",
        "829": "    }\n",
        "830": "\n",
        "831": "    @Override\n",
        "832": "    public BaseEncoding withSeparator(String separator, int afterEveryChars) {\n",
        "833": "      throw new UnsupportedOperationException(\"Already have a separator\");\n",
        "834": "    }\n",
        "835": "\n",
        "836": "    @Override\n",
        "837": "    public BaseEncoding upperCase() {\n",
        "838": "      return delegate.upperCase().withSeparator(separator, afterEveryChars);\n",
        "839": "    }\n",
        "840": "\n",
        "841": "    @Override\n",
        "842": "    public BaseEncoding lowerCase() {\n",
        "843": "      return delegate.lowerCase().withSeparator(separator, afterEveryChars);\n",
        "844": "    }\n",
        "845": "\n",
        "846": "    @Override\n",
        "847": "    public String toString() {\n",
        "848": "      return delegate.toString() +\n",
        "849": "          \".withSeparator(\\\"\" + separator + \"\\\", \" + afterEveryChars + \")\";\n",
        "850": "    }\n",
        "851": "  }\n",
        "852": "}\n"
    }
}