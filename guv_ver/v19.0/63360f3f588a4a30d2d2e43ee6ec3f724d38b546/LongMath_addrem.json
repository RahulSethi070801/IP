{
    "addition": {},
    "removed": {
        "1": "/*\n",
        "2": " * Copyright (C) 2011 The Guava Authors\n",
        "3": " *\n",
        "4": " * Licensed under the Apache License, Version 2.0 (the \"License\");\n",
        "5": " * you may not use this file except in compliance with the License.\n",
        "6": " * You may obtain a copy of the License at\n",
        "7": " *\n",
        "8": " * http://www.apache.org/licenses/LICENSE-2.0\n",
        "9": " *\n",
        "10": " * Unless required by applicable law or agreed to in writing, software\n",
        "11": " * distributed under the License is distributed on an \"AS IS\" BASIS,\n",
        "12": " * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n",
        "13": " * See the License for the specific language governing permissions and\n",
        "14": " * limitations under the License.\n",
        "15": " */\n",
        "16": "\n",
        "17": "package com.google.common.math;\n",
        "18": "\n",
        "19": "import static com.google.common.base.Preconditions.checkArgument;\n",
        "20": "import static com.google.common.math.MathPreconditions.checkNonNegative;\n",
        "21": "import static com.google.common.math.MathPreconditions.checkPositive;\n",
        "22": "import static com.google.common.math.MathPreconditions.checkRoundingUnnecessary;\n",
        "23": "import static java.lang.Math.min;\n",
        "24": "import static java.math.RoundingMode.HALF_EVEN;\n",
        "25": "import static java.math.RoundingMode.HALF_UP;\n",
        "26": "\n",
        "27": "import com.google.common.annotations.GwtCompatible;\n",
        "28": "import com.google.common.annotations.VisibleForTesting;\n",
        "29": "import com.google.common.primitives.UnsignedLongs;\n",
        "30": "\n",
        "31": "import java.math.RoundingMode;\n",
        "32": "\n",
        "33": "/**\n",
        "34": " * A class for arithmetic on values of type {@code long}. Where possible, methods are defined and\n",
        "35": " * named analogously to their {@code BigInteger} counterparts.\n",
        "36": " *\n",
        "37": " * <p>The implementations of many methods in this class are based on material from Henry S. Warren,\n",
        "38": " * Jr.'s <i>Hacker's Delight</i>, (Addison Wesley, 2002).\n",
        "39": " *\n",
        "40": " * <p>Similar functionality for {@code int} and for {@link BigInteger} can be found in\n",
        "41": " * {@link IntMath} and {@link BigIntegerMath} respectively.  For other common operations on\n",
        "42": " * {@code long} values, see {@link com.google.common.primitives.Longs}.\n",
        "43": " *\n",
        "44": " * @author Louis Wasserman\n",
        "45": " * @since 11.0\n",
        "46": " */\n",
        "47": "@GwtCompatible(emulated = true)\n",
        "48": "public final class LongMath {\n",
        "49": "  // NOTE: Whenever both tests are cheap and functional, it's faster to use &, | instead of &&, ||\n",
        "50": "\n",
        "51": "  /**\n",
        "52": "   * Returns {@code true} if {@code x} represents a power of two.\n",
        "53": "   *\n",
        "54": "   * <p>This differs from {@code Long.bitCount(x) == 1}, because\n",
        "55": "   * {@code Long.bitCount(Long.MIN_VALUE) == 1}, but {@link Long#MIN_VALUE} is not a power of two.\n",
        "56": "   */\n",
        "57": "  public static boolean isPowerOfTwo(long x) {\n",
        "58": "    return x > 0 & (x & (x - 1)) == 0;\n",
        "59": "  }\n",
        "60": "  \n",
        "61": "  /**\n",
        "62": "   * Returns 1 if {@code x < y} as unsigned longs, and 0 otherwise.  Assumes that x - y fits into a\n",
        "63": "   * signed long.  The implementation is branch-free, and benchmarks suggest it is measurably\n",
        "64": "   * faster than the straightforward ternary expression.\n",
        "65": "   */\n",
        "66": "  @VisibleForTesting\n",
        "67": "  static int lessThanBranchFree(long x, long y) {\n",
        "68": "    // Returns the sign bit of x - y.\n",
        "69": "    return (int) (~~(x - y) >>> (Long.SIZE - 1));\n",
        "70": "  }\n",
        "71": "\n",
        "72": "  /**\n",
        "73": "   * Returns the base-2 logarithm of {@code x}, rounded according to the specified rounding mode.\n",
        "74": "   *\n",
        "75": "   * @throws IllegalArgumentException if {@code x <= 0}\n",
        "76": "   * @throws ArithmeticException if {@code mode} is {@link RoundingMode#UNNECESSARY} and {@code x}\n",
        "77": "   *         is not a power of two\n",
        "78": "   */\n",
        "79": "  @SuppressWarnings(\"fallthrough\")\n",
        "80": "  // TODO(kevinb): remove after this warning is disabled globally\n",
        "81": "  public static int log2(long x, RoundingMode mode) {\n",
        "82": "    checkPositive(\"x\", x);\n",
        "83": "    switch (mode) {\n",
        "84": "      case UNNECESSARY:\n",
        "85": "        checkRoundingUnnecessary(isPowerOfTwo(x));\n",
        "86": "        // fall through\n",
        "87": "      case DOWN:\n",
        "88": "      case FLOOR:\n",
        "89": "        return (Long.SIZE - 1) - Long.numberOfLeadingZeros(x);\n",
        "90": "\n",
        "91": "      case UP:\n",
        "92": "      case CEILING:\n",
        "93": "        return Long.SIZE - Long.numberOfLeadingZeros(x - 1);\n",
        "94": "\n",
        "95": "      case HALF_DOWN:\n",
        "96": "      case HALF_UP:\n",
        "97": "      case HALF_EVEN:\n",
        "98": "        // Since sqrt(2) is irrational, log2(x) - logFloor cannot be exactly 0.5\n",
        "99": "        int leadingZeros = Long.numberOfLeadingZeros(x);\n",
        "100": "        long cmp = MAX_POWER_OF_SQRT2_UNSIGNED >>> leadingZeros;\n",
        "101": "        // floor(2^(logFloor + 0.5))\n",
        "102": "        int logFloor = (Long.SIZE - 1) - leadingZeros;\n",
        "103": "        return logFloor + lessThanBranchFree(cmp, x);\n",
        "104": "\n",
        "105": "      default:\n",
        "106": "        throw new AssertionError(\"impossible\");\n",
        "107": "    }\n",
        "108": "  }\n",
        "109": "\n",
        "110": "  /** The biggest half power of two that fits into an unsigned long */\n",
        "111": "  @VisibleForTesting static final long MAX_POWER_OF_SQRT2_UNSIGNED = 0xB504F333F9DE6484L;\n",
        "112": "\n",
        "113": "  // maxLog10ForLeadingZeros[i] == floor(log10(2^(Long.SIZE - i)))\n",
        "114": "  @VisibleForTesting static final byte[] maxLog10ForLeadingZeros = {\n",
        "115": "      19, 18, 18, 18, 18, 17, 17, 17, 16, 16, 16, 15, 15, 15, 15, 14, 14, 14, 13, 13, 13, 12, 12,\n",
        "116": "      12, 12, 11, 11, 11, 10, 10, 10, 9, 9, 9, 9, 8, 8, 8, 7, 7, 7, 6, 6, 6, 6, 5, 5, 5, 4, 4, 4,\n",
        "117": "      3, 3, 3, 3, 2, 2, 2, 1, 1, 1, 0, 0, 0 };\n",
        "118": "\n",
        "119": "  // halfPowersOf10[i] = largest long less than 10^(i + 0.5)\n",
        "120": "\n",
        "121": "  /**\n",
        "122": "   * Returns the greatest common divisor of {@code a, b}. Returns {@code 0} if\n",
        "123": "   * {@code a == 0 && b == 0}.\n",
        "124": "   *\n",
        "125": "   * @throws IllegalArgumentException if {@code a < 0} or {@code b < 0}\n",
        "126": "   */\n",
        "127": "  public static long gcd(long a, long b) {\n",
        "128": "    /*\n",
        "129": "     * The reason we require both arguments to be >= 0 is because otherwise, what do you return on\n",
        "130": "     * gcd(0, Long.MIN_VALUE)? BigInteger.gcd would return positive 2^63, but positive 2^63 isn't\n",
        "131": "     * an int.\n",
        "132": "     */\n",
        "133": "    checkNonNegative(\"a\", a);\n",
        "134": "    checkNonNegative(\"b\", b);\n",
        "135": "    if (a == 0) {\n",
        "136": "      // 0 % b == 0, so b divides a, but the converse doesn't hold.\n",
        "137": "      // BigInteger.gcd is consistent with this decision.\n",
        "138": "      return b;\n",
        "139": "    } else if (b == 0) {\n",
        "140": "      return a; // similar logic\n",
        "141": "    }\n",
        "142": "    /*\n",
        "143": "     * Uses the binary GCD algorithm; see http://en.wikipedia.org/wiki/Binary_GCD_algorithm.\n",
        "144": "     * This is >60% faster than the Euclidean algorithm in benchmarks.\n",
        "145": "     */\n",
        "146": "    int aTwos = Long.numberOfTrailingZeros(a);\n",
        "147": "    a >>= aTwos; // divide out all 2s\n",
        "148": "    int bTwos = Long.numberOfTrailingZeros(b);\n",
        "149": "    b >>= bTwos; // divide out all 2s\n",
        "150": "    while (a != b) { // both a, b are odd\n",
        "151": "      // The key to the binary GCD algorithm is as follows:\n",
        "152": "      // Both a and b are odd.  Assume a > b; then gcd(a - b, b) = gcd(a, b).\n",
        "153": "      // But in gcd(a - b, b), a - b is even and b is odd, so we can divide out powers of two.\n",
        "154": "\n",
        "155": "      // We bend over backwards to avoid branching, adapting a technique from\n",
        "156": "      // http://graphics.stanford.edu/~seander/bithacks.html#IntegerMinOrMax\n",
        "157": "\n",
        "158": "      long delta = a - b; // can't overflow, since a and b are nonnegative\n",
        "159": "\n",
        "160": "      long minDeltaOrZero = delta & (delta >> (Long.SIZE - 1));\n",
        "161": "      // equivalent to Math.min(delta, 0)\n",
        "162": "\n",
        "163": "      a = delta - minDeltaOrZero - minDeltaOrZero; // sets a to Math.abs(a - b)\n",
        "164": "      // a is now nonnegative and even\n",
        "165": "\n",
        "166": "      b += minDeltaOrZero; // sets b to min(old a, b)\n",
        "167": "      a >>= Long.numberOfTrailingZeros(a); // divide out all 2s, since 2 doesn't divide b\n",
        "168": "    }\n",
        "169": "    return a << min(aTwos, bTwos);\n",
        "170": "  }\n",
        "171": "\n",
        "172": "  @VisibleForTesting static final long FLOOR_SQRT_MAX_LONG = 3037000499L;\n",
        "173": "\n",
        "174": "  static final long[] factorials = {\n",
        "175": "      1L,\n",
        "176": "      1L,\n",
        "177": "      1L * 2,\n",
        "178": "      1L * 2 * 3,\n",
        "179": "      1L * 2 * 3 * 4,\n",
        "180": "      1L * 2 * 3 * 4 * 5,\n",
        "181": "      1L * 2 * 3 * 4 * 5 * 6,\n",
        "182": "      1L * 2 * 3 * 4 * 5 * 6 * 7,\n",
        "183": "      1L * 2 * 3 * 4 * 5 * 6 * 7 * 8,\n",
        "184": "      1L * 2 * 3 * 4 * 5 * 6 * 7 * 8 * 9,\n",
        "185": "      1L * 2 * 3 * 4 * 5 * 6 * 7 * 8 * 9 * 10,\n",
        "186": "      1L * 2 * 3 * 4 * 5 * 6 * 7 * 8 * 9 * 10 * 11,\n",
        "187": "      1L * 2 * 3 * 4 * 5 * 6 * 7 * 8 * 9 * 10 * 11 * 12,\n",
        "188": "      1L * 2 * 3 * 4 * 5 * 6 * 7 * 8 * 9 * 10 * 11 * 12 * 13,\n",
        "189": "      1L * 2 * 3 * 4 * 5 * 6 * 7 * 8 * 9 * 10 * 11 * 12 * 13 * 14,\n",
        "190": "      1L * 2 * 3 * 4 * 5 * 6 * 7 * 8 * 9 * 10 * 11 * 12 * 13 * 14 * 15,\n",
        "191": "      1L * 2 * 3 * 4 * 5 * 6 * 7 * 8 * 9 * 10 * 11 * 12 * 13 * 14 * 15 * 16,\n",
        "192": "      1L * 2 * 3 * 4 * 5 * 6 * 7 * 8 * 9 * 10 * 11 * 12 * 13 * 14 * 15 * 16 * 17,\n",
        "193": "      1L * 2 * 3 * 4 * 5 * 6 * 7 * 8 * 9 * 10 * 11 * 12 * 13 * 14 * 15 * 16 * 17 * 18,\n",
        "194": "      1L * 2 * 3 * 4 * 5 * 6 * 7 * 8 * 9 * 10 * 11 * 12 * 13 * 14 * 15 * 16 * 17 * 18 * 19,\n",
        "195": "      1L * 2 * 3 * 4 * 5 * 6 * 7 * 8 * 9 * 10 * 11 * 12 * 13 * 14 * 15 * 16 * 17 * 18 * 19 * 20\n",
        "196": "  };\n",
        "197": "\n",
        "198": "  /**\n",
        "199": "   * Returns {@code n} choose {@code k}, also known as the binomial coefficient of {@code n} and\n",
        "200": "   * {@code k}, or {@link Long#MAX_VALUE} if the result does not fit in a {@code long}.\n",
        "201": "   *\n",
        "202": "   * @throws IllegalArgumentException if {@code n < 0}, {@code k < 0}, or {@code k > n}\n",
        "203": "   */\n",
        "204": "  public static long binomial(int n, int k) {\n",
        "205": "    checkNonNegative(\"n\", n);\n",
        "206": "    checkNonNegative(\"k\", k);\n",
        "207": "    checkArgument(k <= n, \"k (%s) > n (%s)\", k, n);\n",
        "208": "    if (k > (n >> 1)) {\n",
        "209": "      k = n - k;\n",
        "210": "    }\n",
        "211": "    switch (k) {\n",
        "212": "      case 0:\n",
        "213": "        return 1;\n",
        "214": "      case 1:\n",
        "215": "        return n;\n",
        "216": "      default:\n",
        "217": "        if (n < factorials.length) {\n",
        "218": "          return factorials[n] / (factorials[k] * factorials[n - k]);\n",
        "219": "        } else if (k >= biggestBinomials.length || n > biggestBinomials[k]) {\n",
        "220": "          return Long.MAX_VALUE;\n",
        "221": "        } else if (k < biggestSimpleBinomials.length && n <= biggestSimpleBinomials[k]) {\n",
        "222": "          // guaranteed not to overflow\n",
        "223": "          long result = n--;\n",
        "224": "          for (int i = 2; i <= k; n--, i++) {\n",
        "225": "            result *= n;\n",
        "226": "            result /= i;\n",
        "227": "          }\n",
        "228": "          return result;\n",
        "229": "        } else {\n",
        "230": "          int nBits = LongMath.log2(n, RoundingMode.CEILING);\n",
        "231": "          \n",
        "232": "          long result = 1;\n",
        "233": "          long numerator = n--;\n",
        "234": "          long denominator = 1;\n",
        "235": "          \n",
        "236": "          int numeratorBits = nBits;\n",
        "237": "          // This is an upper bound on log2(numerator, ceiling).\n",
        "238": "          \n",
        "239": "          /*\n",
        "240": "           * We want to do this in long math for speed, but want to avoid overflow. We adapt the\n",
        "241": "           * technique previously used by BigIntegerMath: maintain separate numerator and\n",
        "242": "           * denominator accumulators, multiplying the fraction into result when near overflow.\n",
        "243": "           */\n",
        "244": "          for (int i = 2; i <= k; i++, n--) {\n",
        "245": "            if (numeratorBits + nBits < Long.SIZE - 1) {\n",
        "246": "              // It's definitely safe to multiply into numerator and denominator.\n",
        "247": "              numerator *= n;\n",
        "248": "              denominator *= i;\n",
        "249": "              numeratorBits += nBits;\n",
        "250": "            } else {\n",
        "251": "              // It might not be safe to multiply into numerator and denominator,\n",
        "252": "              // so multiply (numerator / denominator) into result.\n",
        "253": "              result = multiplyFraction(result, numerator, denominator);\n",
        "254": "              numerator = n;\n",
        "255": "              denominator = i;\n",
        "256": "              numeratorBits = nBits;\n",
        "257": "            }\n",
        "258": "          }\n",
        "259": "          return multiplyFraction(result, numerator, denominator);\n",
        "260": "        }\n",
        "261": "    }\n",
        "262": "  }\n",
        "263": "  \n",
        "264": "  /**\n",
        "265": "   * Returns (x * numerator / denominator), which is assumed to come out to an integral value.\n",
        "266": "   */\n",
        "267": "  static long multiplyFraction(long x, long numerator, long denominator) {\n",
        "268": "    if (x == 1) {\n",
        "269": "      return numerator / denominator;\n",
        "270": "    }\n",
        "271": "    long commonDivisor = gcd(x, denominator);\n",
        "272": "    x /= commonDivisor;\n",
        "273": "    denominator /= commonDivisor;\n",
        "274": "    // We know gcd(x, denominator) = 1, and x * numerator / denominator is exact,\n",
        "275": "    // so denominator must be a divisor of numerator.\n",
        "276": "    return x * (numerator / denominator);\n",
        "277": "  }\n",
        "278": "\n",
        "279": "  /*\n",
        "280": "   * binomial(biggestBinomials[k], k) fits in a long, but not\n",
        "281": "   * binomial(biggestBinomials[k] + 1, k).\n",
        "282": "   */\n",
        "283": "  static final int[] biggestBinomials =\n",
        "284": "      {Integer.MAX_VALUE, Integer.MAX_VALUE, Integer.MAX_VALUE, 3810779, 121977, 16175, 4337, 1733,\n",
        "285": "          887, 534, 361, 265, 206, 169, 143, 125, 111, 101, 94, 88, 83, 79, 76, 74, 72, 70, 69, 68,\n",
        "286": "          67, 67, 66, 66, 66, 66};\n",
        "287": "\n",
        "288": "  /*\n",
        "289": "   * binomial(biggestSimpleBinomials[k], k) doesn't need to use the slower GCD-based impl,\n",
        "290": "   * but binomial(biggestSimpleBinomials[k] + 1, k) does.\n",
        "291": "   */\n",
        "292": "  @VisibleForTesting static final int[] biggestSimpleBinomials =\n",
        "293": "      {Integer.MAX_VALUE, Integer.MAX_VALUE, Integer.MAX_VALUE, 2642246, 86251, 11724, 3218, 1313,\n",
        "294": "          684, 419, 287, 214, 169, 139, 119, 105, 95, 87, 81, 76, 73, 70, 68, 66, 64, 63, 62, 62,\n",
        "295": "          61, 61, 61};\n",
        "296": "  // These values were generated by using checkedMultiply to see when the simple multiply/divide\n",
        "297": "  // algorithm would lead to an overflow.\n",
        "298": "\n",
        "299": "  static boolean fitsInInt(long x) {\n",
        "300": "    return (int) x == x;\n",
        "301": "  }\n",
        "302": "\n",
        "303": "  /**\n",
        "304": "   * Returns the arithmetic mean of {@code x} and {@code y}, rounded toward\n",
        "305": "   * negative infinity. This method is resilient to overflow.\n",
        "306": "   *\n",
        "307": "   * @since 14.0\n",
        "308": "   */\n",
        "309": "  public static long mean(long x, long y) {\n",
        "310": "    // Efficient method for computing the arithmetic mean.\n",
        "311": "    // The alternative (x + y) / 2 fails for large values.\n",
        "312": "    // The alternative (x + y) >>> 1 fails for negative values.\n",
        "313": "    return (x & y) + ((x ^ y) >> 1);\n",
        "314": "  }\n",
        "315": "  \n",
        "316": "  /*\n",
        "317": "   * If n <= millerRabinBases[i][0], then testing n against bases millerRabinBases[i][1..]\n",
        "318": "   * suffices to prove its primality.  Values from miller-rabin.appspot.com.\n",
        "319": "   * \n",
        "320": "   * NOTE: We could get slightly better bases that would be treated as unsigned, but benchmarks\n",
        "321": "   * showed negligible performance improvements.\n",
        "322": "   */\n",
        "323": "  private static final long[][] millerRabinBaseSets = {\n",
        "324": "    {291830, 126401071349994536L},\n",
        "325": "    {885594168, 725270293939359937L, 3569819667048198375L},\n",
        "326": "    {273919523040L, 15, 7363882082L, 992620450144556L},\n",
        "327": "    {47636622961200L, 2, 2570940, 211991001, 3749873356L},\n",
        "328": "    {7999252175582850L,\n",
        "329": "      2, 4130806001517L, 149795463772692060L, 186635894390467037L, 3967304179347715805L},\n",
        "330": "    {585226005592931976L,\n",
        "331": "      2, 123635709730000L, 9233062284813009L, 43835965440333360L, 761179012939631437L,\n",
        "332": "      1263739024124850375L},\n",
        "333": "    {Long.MAX_VALUE,\n",
        "334": "        2, 325, 9375, 28178, 450775, 9780504, 1795265022}\n",
        "335": "  };\n",
        "336": "  \n",
        "337": "  private enum MillerRabinTester {\n",
        "338": "    /**\n",
        "339": "     * Works for inputs <= FLOOR_SQRT_MAX_LONG.\n",
        "340": "     */\n",
        "341": "    SMALL {\n",
        "342": "      @Override\n",
        "343": "      long mulMod(long a, long b, long m) {\n",
        "344": "        /* \n",
        "345": "         * NOTE(lowasser, 2015-Feb-12): Benchmarks suggest that changing this to \n",
        "346": "         * UnsignedLongs.remainder and increasing the threshold to 2^32 doesn't pay for itself,\n",
        "347": "         * and adding another enum constant hurts performance further -- I suspect because\n",
        "348": "         * bimorphic implementation is a sweet spot for the JVM.\n",
        "349": "         */ \n",
        "350": "        return (a * b) % m;\n",
        "351": "      }\n",
        "352": "      \n",
        "353": "      @Override\n",
        "354": "      long squareMod(long a, long m) {\n",
        "355": "        return (a * a) % m;\n",
        "356": "      }\n",
        "357": "    },\n",
        "358": "    /**\n",
        "359": "     * Works for all nonnegative signed longs.\n",
        "360": "     */\n",
        "361": "    LARGE {\n",
        "362": "      /**\n",
        "363": "       * Returns (a + b) mod m.  Precondition: 0 <= a, b < m < 2^63.\n",
        "364": "       */\n",
        "365": "      private long plusMod(long a, long b, long m) {\n",
        "366": "        return (a >= m - b) ? (a + b - m) : (a + b);\n",
        "367": "      }\n",
        "368": "\n",
        "369": "      /**\n",
        "370": "       * Returns (a * 2^32) mod m.  a may be any unsigned long.\n",
        "371": "       */\n",
        "372": "      private long times2ToThe32Mod(long a, long m) {\n",
        "373": "        int remainingPowersOf2 = 32;\n",
        "374": "        do {\n",
        "375": "          int shift = Math.min(remainingPowersOf2, Long.numberOfLeadingZeros(a));\n",
        "376": "          // shift is either the number of powers of 2 left to multiply a by, or the biggest shift\n",
        "377": "          // possible while keeping a in an unsigned long.\n",
        "378": "          a = UnsignedLongs.remainder(a << shift, m);\n",
        "379": "          remainingPowersOf2 -= shift;\n",
        "380": "        } while (remainingPowersOf2 > 0);\n",
        "381": "        return a;\n",
        "382": "      }\n",
        "383": "\n",
        "384": "      @Override\n",
        "385": "      long mulMod(long a, long b, long m) {\n",
        "386": "        long aHi = a >>> 32; // < 2^31\n",
        "387": "        long bHi = b >>> 32; // < 2^31\n",
        "388": "        long aLo = a & 0xFFFFFFFFL; // < 2^32\n",
        "389": "        long bLo = b & 0xFFFFFFFFL; // < 2^32\n",
        "390": "        \n",
        "391": "        /*\n",
        "392": "         * a * b == aHi * bHi * 2^64 + (aHi * bLo + aLo * bHi) * 2^63 + aLo * bLo.\n",
        "393": "         *       == (aHi * bHi * 2^32 + aHi * bLo + aLo * bHi) * 2^32 + aLo * bLo\n",
        "394": "         * \n",
        "395": "         * We carry out this computation in modular arithmetic.  Since times2ToThe32Mod accepts\n",
        "396": "         * any unsigned long, we don't have to do a mod on every operation, only when intermediate\n",
        "397": "         * results can exceed 2^63.\n",
        "398": "         */\n",
        "399": "        long result = times2ToThe32Mod(aHi * bHi /* < 2^62 */, m); // < m < 2^63\n",
        "400": "        result += aHi * bLo; // aHi * bLo < 2^63, result < 2^64\n",
        "401": "        if (result < 0) {\n",
        "402": "          result = UnsignedLongs.remainder(result, m);\n",
        "403": "        }\n",
        "404": "        // result < 2^63 again\n",
        "405": "        result += aLo * bHi; // aLo * bHi < 2^63, result < 2^64\n",
        "406": "        result = times2ToThe32Mod(result, m); // result < m < 2^63\n",
        "407": "        return plusMod(\n",
        "408": "            result,\n",
        "409": "            UnsignedLongs.remainder(aLo * bLo /* < 2^64 */, m),\n",
        "410": "            m);\n",
        "411": "      }\n",
        "412": "\n",
        "413": "      @Override\n",
        "414": "      long squareMod(long a, long m) {\n",
        "415": "        long aHi = a >>> 32; // < 2^31\n",
        "416": "        long aLo = a & 0xFFFFFFFFL; // < 2^32\n",
        "417": "        \n",
        "418": "        /*\n",
        "419": "         * a^2 == aHi^2 * 2^64 + aHi * aLo * 2^33 + aLo^2\n",
        "420": "         *     == (aHi^2 * 2^32 + aHi * aLo * 2) * 2^32 + aLo^2\n",
        "421": "         * We carry out this computation in modular arithmetic.  Since times2ToThe32Mod accepts\n",
        "422": "         * any unsigned long, we don't have to do a mod on every operation, only when intermediate\n",
        "423": "         * results can exceed 2^63.  \n",
        "424": "         */\n",
        "425": "        long result = times2ToThe32Mod(aHi * aHi /* < 2^62 */, m); // < m < 2^63\n",
        "426": "        long hiLo = aHi * aLo * 2;\n",
        "427": "        if (hiLo < 0) {\n",
        "428": "          hiLo = UnsignedLongs.remainder(hiLo, m);\n",
        "429": "        }\n",
        "430": "        // hiLo < 2^63\n",
        "431": "        result += hiLo; // result < 2^64\n",
        "432": "        result = times2ToThe32Mod(result, m); // result < m < 2^63\n",
        "433": "        return plusMod(\n",
        "434": "            result,\n",
        "435": "            UnsignedLongs.remainder(aLo * aLo /* < 2^64 */, m),\n",
        "436": "            m);\n",
        "437": "      }\n",
        "438": "    };\n",
        "439": "    \n",
        "440": "    static boolean test(long base, long n) {\n",
        "441": "      // Since base will be considered % n, it's okay if base > FLOOR_SQRT_MAX_LONG,\n",
        "442": "      // so long as n <= FLOOR_SQRT_MAX_LONG.\n",
        "443": "      return ((n <= FLOOR_SQRT_MAX_LONG) ? SMALL : LARGE).testWitness(base, n);\n",
        "444": "    }\n",
        "445": "    \n",
        "446": "    /**\n",
        "447": "     * Returns a * b mod m.\n",
        "448": "     */\n",
        "449": "    abstract long mulMod(long a, long b, long m);\n",
        "450": "    \n",
        "451": "    /**\n",
        "452": "     * Returns a^2 mod m.\n",
        "453": "     */\n",
        "454": "    abstract long squareMod(long a, long m);\n",
        "455": "    \n",
        "456": "    /**\n",
        "457": "     * Returns a^p mod m.\n",
        "458": "     */\n",
        "459": "    private long powMod(long a, long p, long m) {\n",
        "460": "      long res = 1;\n",
        "461": "      for (; p != 0; p >>= 1) {\n",
        "462": "        if ((p & 1) != 0) {\n",
        "463": "          res = mulMod(res, a, m);\n",
        "464": "        }\n",
        "465": "        a = squareMod(a, m);\n",
        "466": "      }\n",
        "467": "      return res;\n",
        "468": "    }\n",
        "469": "    \n",
        "470": "    /**\n",
        "471": "     * Returns true if n is a strong probable prime relative to the specified base.\n",
        "472": "     */\n",
        "473": "    private boolean testWitness(long base, long n) {\n",
        "474": "      int r = Long.numberOfTrailingZeros(n - 1);\n",
        "475": "      long d = (n - 1) >> r;\n",
        "476": "      base %= n;\n",
        "477": "      if (base == 0) {\n",
        "478": "        return true;\n",
        "479": "      }\n",
        "480": "      // Calculate a := base^d mod n.\n",
        "481": "      long a = powMod(base, d, n);\n",
        "482": "      // n passes this test if\n",
        "483": "      //    base^d = 1 (mod n)\n",
        "484": "      // or base^(2^j * d) = -1 (mod n) for some 0 <= j < r.\n",
        "485": "      if (a == 1) {\n",
        "486": "        return true;\n",
        "487": "      }\n",
        "488": "      int j = 0;\n",
        "489": "      while (a != n - 1) {\n",
        "490": "        if (++j == r) {\n",
        "491": "          return false;\n",
        "492": "        }\n",
        "493": "        a = squareMod(a, n);\n",
        "494": "      }\n",
        "495": "      return true;\n",
        "496": "    }\n",
        "497": "  }\n",
        "498": "\n",
        "499": "  private LongMath() {}\n",
        "500": "}\n",
        "501": "\n"
    }
}