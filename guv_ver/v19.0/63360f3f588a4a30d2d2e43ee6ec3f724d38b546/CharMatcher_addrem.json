{
    "addition": {},
    "removed": {
        "1": "/*\n",
        "2": " * Copyright (C) 2008 The Guava Authors\n",
        "3": " *\n",
        "4": " * Licensed under the Apache License, Version 2.0 (the \"License\");\n",
        "5": " * you may not use this file except in compliance with the License.\n",
        "6": " * You may obtain a copy of the License at\n",
        "7": " *\n",
        "8": " * http://www.apache.org/licenses/LICENSE-2.0\n",
        "9": " *\n",
        "10": " * Unless required by applicable law or agreed to in writing, software\n",
        "11": " * distributed under the License is distributed on an \"AS IS\" BASIS,\n",
        "12": " * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n",
        "13": " * See the License for the specific language governing permissions and\n",
        "14": " * limitations under the License.\n",
        "15": " */\n",
        "16": "\n",
        "17": "package com.google.common.base;\n",
        "18": "\n",
        "19": "import static com.google.common.base.Preconditions.checkArgument;\n",
        "20": "import static com.google.common.base.Preconditions.checkNotNull;\n",
        "21": "import static com.google.common.base.Preconditions.checkPositionIndex;\n",
        "22": "\n",
        "23": "import com.google.common.annotations.Beta;\n",
        "24": "import com.google.common.annotations.GwtCompatible;\n",
        "25": "import com.google.common.annotations.VisibleForTesting;\n",
        "26": "\n",
        "27": "import java.util.Arrays;\n",
        "28": "\n",
        "29": "import javax.annotation.CheckReturnValue;\n",
        "30": "\n",
        "31": "/**\n",
        "32": " * Determines a true or false value for any Java {@code char} value, just as {@link Predicate} does\n",
        "33": " * for any {@link Object}. Also offers basic text processing methods based on this function.\n",
        "34": " * Implementations are strongly encouraged to be side-effect-free and immutable.\n",
        "35": " *\n",
        "36": " * <p>Throughout the documentation of this class, the phrase \"matching character\" is used to mean\n",
        "37": " * \"any character {@code c} for which {@code this.matches(c)} returns {@code true}\".\n",
        "38": " *\n",
        "39": " * <p><b>Note:</b> This class deals only with {@code char} values; it does not understand\n",
        "40": " * supplementary Unicode code points in the range {@code 0x10000} to {@code 0x10FFFF}. Such logical\n",
        "41": " * characters are encoded into a {@code String} using surrogate pairs, and a {@code CharMatcher}\n",
        "42": " * treats these just as two separate characters.\n",
        "43": " *\n",
        "44": " * <p>Example usages: <pre>\n",
        "45": " *   String trimmed = {@link #whitespace() whitespace()}.{@link #trimFrom trimFrom}(userInput);\n",
        "46": " *   if ({@link #ascii() ascii()}.{@link #matchesAllOf matchesAllOf}(s)) { ... }</pre>\n",
        "47": " *\n",
        "48": " * <p>See the Guava User Guide article on <a href=\n",
        "49": " * \"https://github.com/google/guava/wiki/StringsExplained#charmatcher\">\n",
        "50": " * {@code CharMatcher}</a>.\n",
        "51": " *\n",
        "52": " * @author Kevin Bourrillion\n",
        "53": " * @since 1.0\n",
        "54": " */\n",
        "55": "@Beta // Possibly change from chars to code points; decide constants vs. methods\n",
        "56": "@GwtCompatible(emulated = true)\n",
        "57": "public abstract class CharMatcher implements Predicate<Character> {\n",
        "58": "\n",
        "59": "  // Constant matcher factory methods\n",
        "60": "\n",
        "61": "  /**\n",
        "62": "   * Matches any character.\n",
        "63": "   *\n",
        "64": "   * @since 19.0 (since 1.0 as constant {@code ANY})\n",
        "65": "   */\n",
        "66": "  public static CharMatcher any() {\n",
        "67": "    return Any.INSTANCE;\n",
        "68": "  }\n",
        "69": "\n",
        "70": "  /**\n",
        "71": "   * Matches no characters.\n",
        "72": "   *\n",
        "73": "   * @since 19.0 (since 1.0 as constant {@code NONE})\n",
        "74": "   */\n",
        "75": "  public static CharMatcher none() {\n",
        "76": "    return None.INSTANCE;\n",
        "77": "  }\n",
        "78": "\n",
        "79": "  /**\n",
        "80": "   * Determines whether a character is whitespace according to the latest Unicode standard, as\n",
        "81": "   * illustrated <a href=\"http://unicode.org/cldr/utility/list-unicodeset.jsp?a=%5Cp%7Bwhitespace%7D\">here</a>.\n",
        "82": "   * This is not the same definition used by other Java APIs. (See a <a\n",
        "83": "   * href=\"http://spreadsheets.google.com/pub?key=pd8dAQyHbdewRsnE5x5GzKQ\">comparison of several\n",
        "84": "   * definitions of \"whitespace\"</a>.)\n",
        "85": "   *\n",
        "86": "   * <p><b>Note:</b> as the Unicode definition evolves, we will modify this matcher to keep it up\n",
        "87": "   * to date.\n",
        "88": "   *\n",
        "89": "   * @since 19.0 (since 1.0 as constant {@code WHITESPACE})\n",
        "90": "   */\n",
        "91": "  public static CharMatcher whitespace() {\n",
        "92": "    return Whitespace.INSTANCE;\n",
        "93": "  }\n",
        "94": "\n",
        "95": "  /**\n",
        "96": "   * Determines whether a character is a breaking whitespace (that is, a whitespace which can be\n",
        "97": "   * interpreted as a break between words for formatting purposes). See {@link #whitespace()} for a\n",
        "98": "   * discussion of that term.\n",
        "99": "   *\n",
        "100": "   * @since 19.0 (since 2.0 as constant {@code BREAKING_WHITESPACE})\n",
        "101": "   */\n",
        "102": "  public static CharMatcher breakingWhitespace() {\n",
        "103": "    return BreakingWhitespace.INSTANCE;\n",
        "104": "  }\n",
        "105": "\n",
        "106": "  /**\n",
        "107": "   * Determines whether a character is ASCII, meaning that its code point is less than 128.\n",
        "108": "   *\n",
        "109": "   * @since 19.0 (since 1.0 as constant {@code ASCII})\n",
        "110": "   */\n",
        "111": "  public static CharMatcher ascii() {\n",
        "112": "    return Ascii.INSTANCE;\n",
        "113": "  }\n",
        "114": "\n",
        "115": "  /**\n",
        "116": "   * Determines whether a character is a digit according to\n",
        "117": "   * <a href=\"http://unicode.org/cldr/utility/list-unicodeset.jsp?a=%5Cp%7Bdigit%7D\">Unicode</a>.\n",
        "118": "   * If you only care to match ASCII digits, you can use {@code inRange('0', '9')}.\n",
        "119": "   *\n",
        "120": "   * @since 19.0 (since 1.0 as constant {@code DIGIT})\n",
        "121": "   */\n",
        "122": "  public static CharMatcher digit() {\n",
        "123": "    return Digit.INSTANCE;\n",
        "124": "  }\n",
        "125": "\n",
        "126": "  /**\n",
        "127": "   * Determines whether a character is a digit according to {@linkplain Character#isDigit(char)\n",
        "128": "   * Java's definition}. If you only care to match ASCII digits, you can use {@code inRange('0',\n",
        "129": "   * '9')}.\n",
        "130": "   *\n",
        "131": "   * @since 19.0 (since 1.0 as constant {@code JAVA_DIGIT})\n",
        "132": "   */\n",
        "133": "  public static CharMatcher javaDigit() {\n",
        "134": "    return JavaDigit.INSTANCE;\n",
        "135": "  }\n",
        "136": "\n",
        "137": "  /**\n",
        "138": "   * Determines whether a character is a letter according to {@linkplain Character#isLetter(char)\n",
        "139": "   * Java's definition}. If you only care to match letters of the Latin alphabet, you can use {@code\n",
        "140": "   * inRange('a', 'z').or(inRange('A', 'Z'))}.\n",
        "141": "   *\n",
        "142": "   * @since 19.0 (since 1.0 as constant {@code JAVA_LETTER})\n",
        "143": "   */\n",
        "144": "  public static CharMatcher javaLetter() {\n",
        "145": "    return JavaLetter.INSTANCE;\n",
        "146": "  }\n",
        "147": "\n",
        "148": "  /**\n",
        "149": "   * Determines whether a character is a letter or digit according to {@linkplain\n",
        "150": "   * Character#isLetterOrDigit(char) Java's definition}.\n",
        "151": "   *\n",
        "152": "   * @since 19.0 (since 1.0 as constant {@code JAVA_LETTER_OR_DIGIT}).\n",
        "153": "   */\n",
        "154": "  public static CharMatcher javaLetterOrDigit() {\n",
        "155": "    return JavaLetterOrDigit.INSTANCE;\n",
        "156": "  }\n",
        "157": "\n",
        "158": "  /**\n",
        "159": "   * Determines whether a character is upper case according to {@linkplain\n",
        "160": "   * Character#isUpperCase(char) Java's definition}.\n",
        "161": "   *\n",
        "162": "   * @since 19.0 (since 1.0 as constant {@code JAVA_UPPER_CASE})\n",
        "163": "   */\n",
        "164": "  public static CharMatcher javaUpperCase() {\n",
        "165": "    return JavaUpperCase.INSTANCE;\n",
        "166": "  }\n",
        "167": "\n",
        "168": "  /**\n",
        "169": "   * Determines whether a character is lower case according to {@linkplain\n",
        "170": "   * Character#isLowerCase(char) Java's definition}.\n",
        "171": "   *\n",
        "172": "   * @since 19.0 (since 1.0 as constant {@code JAVA_LOWER_CASE})\n",
        "173": "   */\n",
        "174": "  public static CharMatcher javaLowerCase() {\n",
        "175": "    return JavaLowerCase.INSTANCE;\n",
        "176": "  }\n",
        "177": "\n",
        "178": "  /**\n",
        "179": "   * Determines whether a character is an ISO control character as specified by {@link\n",
        "180": "   * Character#isISOControl(char)}.\n",
        "181": "   *\n",
        "182": "   * @since 19.0 (since 1.0 as constant {@code JAVA_ISO_CONTROL})\n",
        "183": "   */\n",
        "184": "  public static CharMatcher javaIsoControl() {\n",
        "185": "    return JavaIsoControl.INSTANCE;\n",
        "186": "  }\n",
        "187": "\n",
        "188": "  /**\n",
        "189": "   * Determines whether a character is invisible; that is, if its Unicode category is any of\n",
        "190": "   * SPACE_SEPARATOR, LINE_SEPARATOR, PARAGRAPH_SEPARATOR, CONTROL, FORMAT, SURROGATE, and\n",
        "191": "   * PRIVATE_USE according to ICU4J.\n",
        "192": "   *\n",
        "193": "   * @since 19.0 (since 1.0 as constant {@code INVISIBLE})\n",
        "194": "   */\n",
        "195": "  public static CharMatcher invisible() {\n",
        "196": "    return Invisible.INSTANCE;\n",
        "197": "  }\n",
        "198": "\n",
        "199": "  /**\n",
        "200": "   * Determines whether a character is single-width (not double-width). When in doubt, this matcher\n",
        "201": "   * errs on the side of returning {@code false} (that is, it tends to assume a character is\n",
        "202": "   * double-width).\n",
        "203": "   *\n",
        "204": "   * <p><b>Note:</b> as the reference file evolves, we will modify this matcher to keep it up to\n",
        "205": "   * date.\n",
        "206": "   *\n",
        "207": "   * @since 19.0 (since 1.0 as constant {@code SINGLE_WIDTH})\n",
        "208": "   */\n",
        "209": "  public static CharMatcher singleWidth() {\n",
        "210": "    return SingleWidth.INSTANCE;\n",
        "211": "  }\n",
        "212": "\n",
        "213": "  // Legacy constants\n",
        "214": "  // TODO(cgdecker): Deprecate these so they can be removed eventually\n",
        "215": "\n",
        "216": "  /**\n",
        "217": "   * Determines whether a character is whitespace according to the latest Unicode standard, as\n",
        "218": "   * illustrated <a href=\"http://unicode.org/cldr/utility/list-unicodeset.jsp?a=%5Cp%7Bwhitespace%7D\">here</a>.\n",
        "219": "   * This is not the same definition used by other Java APIs. (See a <a\n",
        "220": "   * href=\"http://spreadsheets.google.com/pub?key=pd8dAQyHbdewRsnE5x5GzKQ\">comparison of several\n",
        "221": "   * definitions of \"whitespace\"</a>.)\n",
        "222": "   *\n",
        "223": "   * <p><b>Note:</b> as the Unicode definition evolves, we will modify this constant to keep it up\n",
        "224": "   * to date.\n",
        "225": "   */\n",
        "226": "  public static final CharMatcher WHITESPACE = whitespace();\n",
        "227": "\n",
        "228": "  /**\n",
        "229": "   * Determines whether a character is a breaking whitespace (that is, a whitespace which can be\n",
        "230": "   * interpreted as a break between words for formatting purposes). See {@link #WHITESPACE} for a\n",
        "231": "   * discussion of that term.\n",
        "232": "   *\n",
        "233": "   * @since 2.0\n",
        "234": "   */\n",
        "235": "  public static final CharMatcher BREAKING_WHITESPACE = breakingWhitespace();\n",
        "236": "\n",
        "237": "  /**\n",
        "238": "   * Determines whether a character is ASCII, meaning that its code point is less than 128.\n",
        "239": "   */\n",
        "240": "  public static final CharMatcher ASCII = ascii();\n",
        "241": "\n",
        "242": "  /**\n",
        "243": "   * Determines whether a character is a digit according to\n",
        "244": "   * <a href=\"http://unicode.org/cldr/utility/list-unicodeset.jsp?a=%5Cp%7Bdigit%7D\">Unicode</a>.\n",
        "245": "   * If you only care to match ASCII digits, you can use {@code inRange('0', '9')}.\n",
        "246": "   */\n",
        "247": "  public static final CharMatcher DIGIT = digit();\n",
        "248": "\n",
        "249": "  /**\n",
        "250": "   * Determines whether a character is a digit according to {@linkplain Character#isDigit(char)\n",
        "251": "   * Java's definition}. If you only care to match ASCII digits, you can use {@code\n",
        "252": "   * inRange('0', '9')}.\n",
        "253": "   */\n",
        "254": "  public static final CharMatcher JAVA_DIGIT = javaDigit();\n",
        "255": "\n",
        "256": "  /**\n",
        "257": "   * Determines whether a character is a letter according to {@linkplain Character#isLetter(char)\n",
        "258": "   * Java's definition}. If you only care to match letters of the Latin alphabet, you can use {@code\n",
        "259": "   * inRange('a', 'z').or(inRange('A', 'Z'))}.\n",
        "260": "   */\n",
        "261": "  public static final CharMatcher JAVA_LETTER = javaLetter();\n",
        "262": "\n",
        "263": "  /**\n",
        "264": "   * Determines whether a character is a letter or digit according to {@linkplain\n",
        "265": "   * Character#isLetterOrDigit(char) Java's definition}.\n",
        "266": "   */\n",
        "267": "  public static final CharMatcher JAVA_LETTER_OR_DIGIT = javaLetterOrDigit();\n",
        "268": "\n",
        "269": "  /**\n",
        "270": "   * Determines whether a character is upper case according to {@linkplain\n",
        "271": "   * Character#isUpperCase(char) Java's definition}.\n",
        "272": "   */\n",
        "273": "  public static final CharMatcher JAVA_UPPER_CASE = javaUpperCase();\n",
        "274": "\n",
        "275": "  /**\n",
        "276": "   * Determines whether a character is lower case according to {@linkplain\n",
        "277": "   * Character#isLowerCase(char) Java's definition}.\n",
        "278": "   */\n",
        "279": "  public static final CharMatcher JAVA_LOWER_CASE = javaLowerCase();\n",
        "280": "\n",
        "281": "  /**\n",
        "282": "   * Determines whether a character is an ISO control character as specified by {@link\n",
        "283": "   * Character#isISOControl(char)}.\n",
        "284": "   */\n",
        "285": "  public static final CharMatcher JAVA_ISO_CONTROL = javaIsoControl();\n",
        "286": "\n",
        "287": "  /**\n",
        "288": "   * Determines whether a character is invisible; that is, if its Unicode category is any of\n",
        "289": "   * SPACE_SEPARATOR, LINE_SEPARATOR, PARAGRAPH_SEPARATOR, CONTROL, FORMAT, SURROGATE, and\n",
        "290": "   * PRIVATE_USE according to ICU4J.\n",
        "291": "   */\n",
        "292": "  public static final CharMatcher INVISIBLE = invisible();\n",
        "293": "\n",
        "294": "  /**\n",
        "295": "   * Determines whether a character is single-width (not double-width). When in doubt, this matcher\n",
        "296": "   * errs on the side of returning {@code false} (that is, it tends to assume a character is\n",
        "297": "   * double-width).\n",
        "298": "   *\n",
        "299": "   * <p><b>Note:</b> as the reference file evolves, we will modify this constant to keep it up to\n",
        "300": "   * date.\n",
        "301": "   */\n",
        "302": "  public static final CharMatcher SINGLE_WIDTH = singleWidth();\n",
        "303": "\n",
        "304": "  /** Matches any character. */\n",
        "305": "  public static final CharMatcher ANY = any();\n",
        "306": "\n",
        "307": "  /** Matches no characters. */\n",
        "308": "  public static final CharMatcher NONE = none();\n",
        "309": "\n",
        "310": "  // Static factories\n",
        "311": "\n",
        "312": "  /**\n",
        "313": "   * Returns a {@code char} matcher that matches only one specified character.\n",
        "314": "   */\n",
        "315": "  public static CharMatcher is(final char match) {\n",
        "316": "    return new Is(match);\n",
        "317": "  }\n",
        "318": "\n",
        "319": "  /**\n",
        "320": "   * Returns a {@code char} matcher that matches any character except the one specified.\n",
        "321": "   *\n",
        "322": "   * <p>To negate another {@code CharMatcher}, use {@link #negate()}.\n",
        "323": "   */\n",
        "324": "  public static CharMatcher isNot(final char match) {\n",
        "325": "    return new IsNot(match);\n",
        "326": "  }\n",
        "327": "\n",
        "328": "  /**\n",
        "329": "   * Returns a {@code char} matcher that matches any character present in the given character\n",
        "330": "   * sequence.\n",
        "331": "   */\n",
        "332": "  public static CharMatcher anyOf(final CharSequence sequence) {\n",
        "333": "    switch (sequence.length()) {\n",
        "334": "      case 0:\n",
        "335": "        return none();\n",
        "336": "      case 1:\n",
        "337": "        return is(sequence.charAt(0));\n",
        "338": "      case 2:\n",
        "339": "        return isEither(sequence.charAt(0), sequence.charAt(1));\n",
        "340": "      default:\n",
        "341": "        // TODO(lowasser): is it potentially worth just going ahead and building a precomputed\n",
        "342": "        // matcher?\n",
        "343": "        return new AnyOf(sequence);\n",
        "344": "    }\n",
        "345": "  }\n",
        "346": "\n",
        "347": "  /**\n",
        "348": "   * Returns a {@code char} matcher that matches any character not present in the given character\n",
        "349": "   * sequence.\n",
        "350": "   */\n",
        "351": "  public static CharMatcher noneOf(CharSequence sequence) {\n",
        "352": "    return anyOf(sequence).negate();\n",
        "353": "  }\n",
        "354": "\n",
        "355": "  /**\n",
        "356": "   * Returns a {@code char} matcher that matches any character in a given range (both endpoints are\n",
        "357": "   * inclusive). For example, to match any lowercase letter of the English alphabet, use {@code\n",
        "358": "   * CharMatcher.inRange('a', 'z')}.\n",
        "359": "   *\n",
        "360": "   * @throws IllegalArgumentException if {@code endInclusive < startInclusive}\n",
        "361": "   */\n",
        "362": "  public static CharMatcher inRange(final char startInclusive, final char endInclusive) {\n",
        "363": "    return new InRange(startInclusive, endInclusive);\n",
        "364": "  }\n",
        "365": "\n",
        "366": "  /**\n",
        "367": "   * Returns a matcher with identical behavior to the given {@link Character}-based predicate, but\n",
        "368": "   * which operates on primitive {@code char} instances instead.\n",
        "369": "   */\n",
        "370": "  public static CharMatcher forPredicate(final Predicate<? super Character> predicate) {\n",
        "371": "    return predicate instanceof CharMatcher ? (CharMatcher) predicate : new ForPredicate(predicate);\n",
        "372": "  }\n",
        "373": "\n",
        "374": "  // Constructors\n",
        "375": "\n",
        "376": "  /**\n",
        "377": "   * Constructor for use by subclasses. When subclassing, you may want to override\n",
        "378": "   * {@code toString()} to provide a useful description.\n",
        "379": "   */\n",
        "380": "  protected CharMatcher() {}\n",
        "381": "\n",
        "382": "  // Abstract methods\n",
        "383": "\n",
        "384": "  /** Determines a true or false value for the given character. */\n",
        "385": "  public abstract boolean matches(char c);\n",
        "386": "\n",
        "387": "  // Non-static factories\n",
        "388": "\n",
        "389": "  /**\n",
        "390": "   * Returns a matcher that matches any character not matched by this matcher.\n",
        "391": "   */\n",
        "392": "  public CharMatcher negate() {\n",
        "393": "    return new Negated(this);\n",
        "394": "  }\n",
        "395": "\n",
        "396": "  /**\n",
        "397": "   * Returns a matcher that matches any character matched by both this matcher and {@code other}.\n",
        "398": "   */\n",
        "399": "  public CharMatcher and(CharMatcher other) {\n",
        "400": "    return new And(this, other);\n",
        "401": "  }\n",
        "402": "\n",
        "403": "  /**\n",
        "404": "   * Returns a matcher that matches any character matched by either this matcher or {@code other}.\n",
        "405": "   */\n",
        "406": "  public CharMatcher or(CharMatcher other) {\n",
        "407": "    return new Or(this, other);\n",
        "408": "  }\n",
        "409": "\n",
        "410": "  /**\n",
        "411": "   * Returns a {@code char} matcher functionally equivalent to this one, but which may be faster to\n",
        "412": "   * query than the original; your mileage may vary. Precomputation takes time and is likely to be\n",
        "413": "   * worthwhile only if the precomputed matcher is queried many thousands of times.\n",
        "414": "   *\n",
        "415": "   * <p>This method has no effect (returns {@code this}) when called in GWT: it's unclear whether a\n",
        "416": "   * precomputed matcher is faster, but it certainly consumes more memory, which doesn't seem like a\n",
        "417": "   * worthwhile tradeoff in a browser.\n",
        "418": "   */\n",
        "419": "  public CharMatcher precomputed() {\n",
        "420": "    return Platform.precomputeCharMatcher(this);\n",
        "421": "  }\n",
        "422": "\n",
        "423": "  private static final int DISTINCT_CHARS = Character.MAX_VALUE - Character.MIN_VALUE + 1;\n",
        "424": "\n",
        "425": "  // Text processing routines\n",
        "426": "\n",
        "427": "  /**\n",
        "428": "   * Returns {@code true} if a character sequence contains at least one matching character.\n",
        "429": "   * Equivalent to {@code !matchesNoneOf(sequence)}.\n",
        "430": "   *\n",
        "431": "   * <p>The default implementation iterates over the sequence, invoking {@link #matches} for each\n",
        "432": "   * character, until this returns {@code true} or the end is reached.\n",
        "433": "   *\n",
        "434": "   * @param sequence the character sequence to examine, possibly empty\n",
        "435": "   * @return {@code true} if this matcher matches at least one character in the sequence\n",
        "436": "   * @since 8.0\n",
        "437": "   */\n",
        "438": "  public boolean matchesAnyOf(CharSequence sequence) {\n",
        "439": "    return !matchesNoneOf(sequence);\n",
        "440": "  }\n",
        "441": "\n",
        "442": "  /**\n",
        "443": "   * Returns {@code true} if a character sequence contains only matching characters.\n",
        "444": "   *\n",
        "445": "   * <p>The default implementation iterates over the sequence, invoking {@link #matches} for each\n",
        "446": "   * character, until this returns {@code false} or the end is reached.\n",
        "447": "   *\n",
        "448": "   * @param sequence the character sequence to examine, possibly empty\n",
        "449": "   * @return {@code true} if this matcher matches every character in the sequence, including when\n",
        "450": "   *         the sequence is empty\n",
        "451": "   */\n",
        "452": "  public boolean matchesAllOf(CharSequence sequence) {\n",
        "453": "    for (int i = sequence.length() - 1; i >= 0; i--) {\n",
        "454": "      if (!matches(sequence.charAt(i))) {\n",
        "455": "        return false;\n",
        "456": "      }\n",
        "457": "    }\n",
        "458": "    return true;\n",
        "459": "  }\n",
        "460": "\n",
        "461": "  /**\n",
        "462": "   * Returns {@code true} if a character sequence contains no matching characters. Equivalent to\n",
        "463": "   * {@code !matchesAnyOf(sequence)}.\n",
        "464": "   *\n",
        "465": "   * <p>The default implementation iterates over the sequence, invoking {@link #matches} for each\n",
        "466": "   * character, until this returns {@code false} or the end is reached.\n",
        "467": "   *\n",
        "468": "   * @param sequence the character sequence to examine, possibly empty\n",
        "469": "   * @return {@code true} if this matcher matches every character in the sequence, including when\n",
        "470": "   *         the sequence is empty\n",
        "471": "   */\n",
        "472": "  public boolean matchesNoneOf(CharSequence sequence) {\n",
        "473": "    return indexIn(sequence) == -1;\n",
        "474": "  }\n",
        "475": "\n",
        "476": "  /**\n",
        "477": "   * Returns the index of the first matching character in a character sequence, or {@code -1} if no\n",
        "478": "   * matching character is present.\n",
        "479": "   *\n",
        "480": "   * <p>The default implementation iterates over the sequence in forward order calling {@link\n",
        "481": "   * #matches} for each character.\n",
        "482": "   *\n",
        "483": "   * @param sequence the character sequence to examine from the beginning\n",
        "484": "   * @return an index, or {@code -1} if no character matches\n",
        "485": "   */\n",
        "486": "  public int indexIn(CharSequence sequence) {\n",
        "487": "    return indexIn(sequence, 0);\n",
        "488": "  }\n",
        "489": "\n",
        "490": "  /**\n",
        "491": "   * Returns the index of the first matching character in a character sequence, starting from a\n",
        "492": "   * given position, or {@code -1} if no character matches after that position.\n",
        "493": "   *\n",
        "494": "   * <p>The default implementation iterates over the sequence in forward order, beginning at {@code\n",
        "495": "   * start}, calling {@link #matches} for each character.\n",
        "496": "   *\n",
        "497": "   * @param sequence the character sequence to examine\n",
        "498": "   * @param start the first index to examine; must be nonnegative and no greater than {@code\n",
        "499": "   *        sequence.length()}\n",
        "500": "   * @return the index of the first matching character, guaranteed to be no less than {@code start},\n",
        "501": "   *         or {@code -1} if no character matches\n",
        "502": "   * @throws IndexOutOfBoundsException if start is negative or greater than {@code\n",
        "503": "   *         sequence.length()}\n",
        "504": "   */\n",
        "505": "  public int indexIn(CharSequence sequence, int start) {\n",
        "506": "    int length = sequence.length();\n",
        "507": "    checkPositionIndex(start, length);\n",
        "508": "    for (int i = start; i < length; i++) {\n",
        "509": "      if (matches(sequence.charAt(i))) {\n",
        "510": "        return i;\n",
        "511": "      }\n",
        "512": "    }\n",
        "513": "    return -1;\n",
        "514": "  }\n",
        "515": "\n",
        "516": "  /**\n",
        "517": "   * Returns the index of the last matching character in a character sequence, or {@code -1} if no\n",
        "518": "   * matching character is present.\n",
        "519": "   *\n",
        "520": "   * <p>The default implementation iterates over the sequence in reverse order calling {@link\n",
        "521": "   * #matches} for each character.\n",
        "522": "   *\n",
        "523": "   * @param sequence the character sequence to examine from the end\n",
        "524": "   * @return an index, or {@code -1} if no character matches\n",
        "525": "   */\n",
        "526": "  public int lastIndexIn(CharSequence sequence) {\n",
        "527": "    for (int i = sequence.length() - 1; i >= 0; i--) {\n",
        "528": "      if (matches(sequence.charAt(i))) {\n",
        "529": "        return i;\n",
        "530": "      }\n",
        "531": "    }\n",
        "532": "    return -1;\n",
        "533": "  }\n",
        "534": "\n",
        "535": "  /**\n",
        "536": "   * Returns the number of matching characters found in a character sequence.\n",
        "537": "   */\n",
        "538": "  public int countIn(CharSequence sequence) {\n",
        "539": "    int count = 0;\n",
        "540": "    for (int i = 0; i < sequence.length(); i++) {\n",
        "541": "      if (matches(sequence.charAt(i))) {\n",
        "542": "        count++;\n",
        "543": "      }\n",
        "544": "    }\n",
        "545": "    return count;\n",
        "546": "  }\n",
        "547": "\n",
        "548": "  /**\n",
        "549": "   * Returns a string containing all non-matching characters of a character sequence, in order. For\n",
        "550": "   * example: <pre>   {@code\n",
        "551": "   *\n",
        "552": "   *   CharMatcher.is('a').removeFrom(\"bazaar\")}</pre>\n",
        "553": "   *\n",
        "554": "   * ... returns {@code \"bzr\"}.\n",
        "555": "   */\n",
        "556": "  @CheckReturnValue\n",
        "557": "  public String removeFrom(CharSequence sequence) {\n",
        "558": "    String string = sequence.toString();\n",
        "559": "    int pos = indexIn(string);\n",
        "560": "    if (pos == -1) {\n",
        "561": "      return string;\n",
        "562": "    }\n",
        "563": "\n",
        "564": "    char[] chars = string.toCharArray();\n",
        "565": "    int spread = 1;\n",
        "566": "\n",
        "567": "    // This unusual loop comes from extensive benchmarking\n",
        "568": "    OUT:\n",
        "569": "    while (true) {\n",
        "570": "      pos++;\n",
        "571": "      while (true) {\n",
        "572": "        if (pos == chars.length) {\n",
        "573": "          break OUT;\n",
        "574": "        }\n",
        "575": "        if (matches(chars[pos])) {\n",
        "576": "          break;\n",
        "577": "        }\n",
        "578": "        chars[pos - spread] = chars[pos];\n",
        "579": "        pos++;\n",
        "580": "      }\n",
        "581": "      spread++;\n",
        "582": "    }\n",
        "583": "    return new String(chars, 0, pos - spread);\n",
        "584": "  }\n",
        "585": "\n",
        "586": "  /**\n",
        "587": "   * Returns a string containing all matching characters of a character sequence, in order. For\n",
        "588": "   * example: <pre>   {@code\n",
        "589": "   *\n",
        "590": "   *   CharMatcher.is('a').retainFrom(\"bazaar\")}</pre>\n",
        "591": "   *\n",
        "592": "   * ... returns {@code \"aaa\"}.\n",
        "593": "   */\n",
        "594": "  @CheckReturnValue\n",
        "595": "  public String retainFrom(CharSequence sequence) {\n",
        "596": "    return negate().removeFrom(sequence);\n",
        "597": "  }\n",
        "598": "\n",
        "599": "  /**\n",
        "600": "   * Returns a string copy of the input character sequence, with each character that matches this\n",
        "601": "   * matcher replaced by a given replacement character. For example: <pre>   {@code\n",
        "602": "   *\n",
        "603": "   *   CharMatcher.is('a').replaceFrom(\"radar\", 'o')}</pre>\n",
        "604": "   *\n",
        "605": "   * ... returns {@code \"rodor\"}.\n",
        "606": "   *\n",
        "607": "   * <p>The default implementation uses {@link #indexIn(CharSequence)} to find the first matching\n",
        "608": "   * character, then iterates the remainder of the sequence calling {@link #matches(char)} for each\n",
        "609": "   * character.\n",
        "610": "   *\n",
        "611": "   * @param sequence the character sequence to replace matching characters in\n",
        "612": "   * @param replacement the character to append to the result string in place of each matching\n",
        "613": "   *        character in {@code sequence}\n",
        "614": "   * @return the new string\n",
        "615": "   */\n",
        "616": "  @CheckReturnValue\n",
        "617": "  public String replaceFrom(CharSequence sequence, char replacement) {\n",
        "618": "    String string = sequence.toString();\n",
        "619": "    int pos = indexIn(string);\n",
        "620": "    if (pos == -1) {\n",
        "621": "      return string;\n",
        "622": "    }\n",
        "623": "    char[] chars = string.toCharArray();\n",
        "624": "    chars[pos] = replacement;\n",
        "625": "    for (int i = pos + 1; i < chars.length; i++) {\n",
        "626": "      if (matches(chars[i])) {\n",
        "627": "        chars[i] = replacement;\n",
        "628": "      }\n",
        "629": "    }\n",
        "630": "    return new String(chars);\n",
        "631": "  }\n",
        "632": "\n",
        "633": "  /**\n",
        "634": "   * Returns a string copy of the input character sequence, with each character that matches this\n",
        "635": "   * matcher replaced by a given replacement sequence. For example: <pre>   {@code\n",
        "636": "   *\n",
        "637": "   *   CharMatcher.is('a').replaceFrom(\"yaha\", \"oo\")}</pre>\n",
        "638": "   *\n",
        "639": "   * ... returns {@code \"yoohoo\"}.\n",
        "640": "   *\n",
        "641": "   * <p><b>Note:</b> If the replacement is a fixed string with only one character, you are better\n",
        "642": "   * off calling {@link #replaceFrom(CharSequence, char)} directly.\n",
        "643": "   *\n",
        "644": "   * @param sequence the character sequence to replace matching characters in\n",
        "645": "   * @param replacement the characters to append to the result string in place of each matching\n",
        "646": "   *        character in {@code sequence}\n",
        "647": "   * @return the new string\n",
        "648": "   */\n",
        "649": "  @CheckReturnValue\n",
        "650": "  public String replaceFrom(CharSequence sequence, CharSequence replacement) {\n",
        "651": "    int replacementLen = replacement.length();\n",
        "652": "    if (replacementLen == 0) {\n",
        "653": "      return removeFrom(sequence);\n",
        "654": "    }\n",
        "655": "    if (replacementLen == 1) {\n",
        "656": "      return replaceFrom(sequence, replacement.charAt(0));\n",
        "657": "    }\n",
        "658": "\n",
        "659": "    String string = sequence.toString();\n",
        "660": "    int pos = indexIn(string);\n",
        "661": "    if (pos == -1) {\n",
        "662": "      return string;\n",
        "663": "    }\n",
        "664": "\n",
        "665": "    int len = string.length();\n",
        "666": "    StringBuilder buf = new StringBuilder((len * 3 / 2) + 16);\n",
        "667": "\n",
        "668": "    int oldpos = 0;\n",
        "669": "    do {\n",
        "670": "      buf.append(string, oldpos, pos);\n",
        "671": "      buf.append(replacement);\n",
        "672": "      oldpos = pos + 1;\n",
        "673": "      pos = indexIn(string, oldpos);\n",
        "674": "    } while (pos != -1);\n",
        "675": "\n",
        "676": "    buf.append(string, oldpos, len);\n",
        "677": "    return buf.toString();\n",
        "678": "  }\n",
        "679": "\n",
        "680": "  /**\n",
        "681": "   * Returns a substring of the input character sequence that omits all characters this matcher\n",
        "682": "   * matches from the beginning and from the end of the string. For example: <pre>   {@code\n",
        "683": "   *\n",
        "684": "   *   CharMatcher.anyOf(\"ab\").trimFrom(\"abacatbab\")}</pre>\n",
        "685": "   *\n",
        "686": "   * ... returns {@code \"cat\"}.\n",
        "687": "   *\n",
        "688": "   * <p>Note that: <pre>   {@code\n",
        "689": "   *\n",
        "690": "   *   CharMatcher.inRange('\\0', ' ').trimFrom(str)}</pre>\n",
        "691": "   *\n",
        "692": "   * ... is equivalent to {@link String#trim()}.\n",
        "693": "   */\n",
        "694": "  @CheckReturnValue\n",
        "695": "  public String trimFrom(CharSequence sequence) {\n",
        "696": "    int len = sequence.length();\n",
        "697": "    int first;\n",
        "698": "    int last;\n",
        "699": "\n",
        "700": "    for (first = 0; first < len; first++) {\n",
        "701": "      if (!matches(sequence.charAt(first))) {\n",
        "702": "        break;\n",
        "703": "      }\n",
        "704": "    }\n",
        "705": "    for (last = len - 1; last > first; last--) {\n",
        "706": "      if (!matches(sequence.charAt(last))) {\n",
        "707": "        break;\n",
        "708": "      }\n",
        "709": "    }\n",
        "710": "\n",
        "711": "    return sequence.subSequence(first, last + 1).toString();\n",
        "712": "  }\n",
        "713": "\n",
        "714": "  /**\n",
        "715": "   * Returns a substring of the input character sequence that omits all characters this matcher\n",
        "716": "   * matches from the beginning of the string. For example: <pre> {@code\n",
        "717": "   *\n",
        "718": "   *   CharMatcher.anyOf(\"ab\").trimLeadingFrom(\"abacatbab\")}</pre>\n",
        "719": "   *\n",
        "720": "   * ... returns {@code \"catbab\"}.\n",
        "721": "   */\n",
        "722": "  @CheckReturnValue\n",
        "723": "  public String trimLeadingFrom(CharSequence sequence) {\n",
        "724": "    int len = sequence.length();\n",
        "725": "    for (int first = 0; first < len; first++) {\n",
        "726": "      if (!matches(sequence.charAt(first))) {\n",
        "727": "        return sequence.subSequence(first, len).toString();\n",
        "728": "      }\n",
        "729": "    }\n",
        "730": "    return \"\";\n",
        "731": "  }\n",
        "732": "\n",
        "733": "  /**\n",
        "734": "   * Returns a substring of the input character sequence that omits all characters this matcher\n",
        "735": "   * matches from the end of the string. For example: <pre> {@code\n",
        "736": "   *\n",
        "737": "   *   CharMatcher.anyOf(\"ab\").trimTrailingFrom(\"abacatbab\")}</pre>\n",
        "738": "   *\n",
        "739": "   * ... returns {@code \"abacat\"}.\n",
        "740": "   */\n",
        "741": "  @CheckReturnValue\n",
        "742": "  public String trimTrailingFrom(CharSequence sequence) {\n",
        "743": "    int len = sequence.length();\n",
        "744": "    for (int last = len - 1; last >= 0; last--) {\n",
        "745": "      if (!matches(sequence.charAt(last))) {\n",
        "746": "        return sequence.subSequence(0, last + 1).toString();\n",
        "747": "      }\n",
        "748": "    }\n",
        "749": "    return \"\";\n",
        "750": "  }\n",
        "751": "\n",
        "752": "  /**\n",
        "753": "   * Returns a string copy of the input character sequence, with each group of consecutive\n",
        "754": "   * characters that match this matcher replaced by a single replacement character. For example:\n",
        "755": "   * <pre>   {@code\n",
        "756": "   *\n",
        "757": "   *   CharMatcher.anyOf(\"eko\").collapseFrom(\"bookkeeper\", '-')}</pre>\n",
        "758": "   *\n",
        "759": "   * ... returns {@code \"b-p-r\"}.\n",
        "760": "   *\n",
        "761": "   * <p>The default implementation uses {@link #indexIn(CharSequence)} to find the first matching\n",
        "762": "   * character, then iterates the remainder of the sequence calling {@link #matches(char)} for each\n",
        "763": "   * character.\n",
        "764": "   *\n",
        "765": "   * @param sequence the character sequence to replace matching groups of characters in\n",
        "766": "   * @param replacement the character to append to the result string in place of each group of\n",
        "767": "   *        matching characters in {@code sequence}\n",
        "768": "   * @return the new string\n",
        "769": "   */\n",
        "770": "  @CheckReturnValue\n",
        "771": "  public String collapseFrom(CharSequence sequence, char replacement) {\n",
        "772": "    // This implementation avoids unnecessary allocation.\n",
        "773": "    int len = sequence.length();\n",
        "774": "    for (int i = 0; i < len; i++) {\n",
        "775": "      char c = sequence.charAt(i);\n",
        "776": "      if (matches(c)) {\n",
        "777": "        if (c == replacement && (i == len - 1 || !matches(sequence.charAt(i + 1)))) {\n",
        "778": "          // a no-op replacement\n",
        "779": "          i++;\n",
        "780": "        } else {\n",
        "781": "          StringBuilder builder =\n",
        "782": "              new StringBuilder(len).append(sequence.subSequence(0, i)).append(replacement);\n",
        "783": "          return finishCollapseFrom(sequence, i + 1, len, replacement, builder, true);\n",
        "784": "        }\n",
        "785": "      }\n",
        "786": "    }\n",
        "787": "    // no replacement needed\n",
        "788": "    return sequence.toString();\n",
        "789": "  }\n",
        "790": "\n",
        "791": "  /**\n",
        "792": "   * Collapses groups of matching characters exactly as {@link #collapseFrom} does, except that\n",
        "793": "   * groups of matching characters at the start or end of the sequence are removed without\n",
        "794": "   * replacement.\n",
        "795": "   */\n",
        "796": "  @CheckReturnValue\n",
        "797": "  public String trimAndCollapseFrom(CharSequence sequence, char replacement) {\n",
        "798": "    // This implementation avoids unnecessary allocation.\n",
        "799": "    int len = sequence.length();\n",
        "800": "    int first = 0;\n",
        "801": "    int last = len - 1;\n",
        "802": "\n",
        "803": "    while (first < len && matches(sequence.charAt(first))) {\n",
        "804": "      first++;\n",
        "805": "    }\n",
        "806": "\n",
        "807": "    while (last > first && matches(sequence.charAt(last))) {\n",
        "808": "      last--;\n",
        "809": "    }\n",
        "810": "\n",
        "811": "    return (first == 0 && last == len - 1)\n",
        "812": "        ? collapseFrom(sequence, replacement)\n",
        "813": "        : finishCollapseFrom(\n",
        "814": "            sequence, first, last + 1, replacement, new StringBuilder(last + 1 - first), false);\n",
        "815": "  }\n",
        "816": "\n",
        "817": "  private String finishCollapseFrom(\n",
        "818": "      CharSequence sequence,\n",
        "819": "      int start,\n",
        "820": "      int end,\n",
        "821": "      char replacement,\n",
        "822": "      StringBuilder builder,\n",
        "823": "      boolean inMatchingGroup) {\n",
        "824": "    for (int i = start; i < end; i++) {\n",
        "825": "      char c = sequence.charAt(i);\n",
        "826": "      if (matches(c)) {\n",
        "827": "        if (!inMatchingGroup) {\n",
        "828": "          builder.append(replacement);\n",
        "829": "          inMatchingGroup = true;\n",
        "830": "        }\n",
        "831": "      } else {\n",
        "832": "        builder.append(c);\n",
        "833": "        inMatchingGroup = false;\n",
        "834": "      }\n",
        "835": "    }\n",
        "836": "    return builder.toString();\n",
        "837": "  }\n",
        "838": "\n",
        "839": "  /**\n",
        "840": "   * @deprecated Provided only to satisfy the {@link Predicate} interface; use {@link #matches}\n",
        "841": "   *     instead.\n",
        "842": "   */\n",
        "843": "  @Deprecated\n",
        "844": "  @Override\n",
        "845": "  public boolean apply(Character character) {\n",
        "846": "    return matches(character);\n",
        "847": "  }\n",
        "848": "\n",
        "849": "  /**\n",
        "850": "   * Returns a string representation of this {@code CharMatcher}, such as\n",
        "851": "   * {@code CharMatcher.or(WHITESPACE, JAVA_DIGIT)}.\n",
        "852": "   */\n",
        "853": "  @Override\n",
        "854": "  public String toString() {\n",
        "855": "    return super.toString();\n",
        "856": "  }\n",
        "857": "\n",
        "858": "  /**\n",
        "859": "   * Returns the Java Unicode escape sequence for the given character, in the form \"\\u12AB\" where\n",
        "860": "   * \"12AB\" is the four hexadecimal digits representing the 16 bits of the UTF-16 character.\n",
        "861": "   */\n",
        "862": "  private static String showCharacter(char c) {\n",
        "863": "    String hex = \"0123456789ABCDEF\";\n",
        "864": "    char[] tmp = {'\\\\', 'u', '\\0', '\\0', '\\0', '\\0'};\n",
        "865": "    for (int i = 0; i < 4; i++) {\n",
        "866": "      tmp[5 - i] = hex.charAt(c & 0xF);\n",
        "867": "      c = (char) (c >> 4);\n",
        "868": "    }\n",
        "869": "    return String.copyValueOf(tmp);\n",
        "870": "  }\n",
        "871": "\n",
        "872": "  // Fast matchers\n",
        "873": "\n",
        "874": "  /** A matcher for which precomputation will not yield any significant benefit. */\n",
        "875": "  abstract static class FastMatcher extends CharMatcher {\n",
        "876": "\n",
        "877": "    @Override\n",
        "878": "    public final CharMatcher precomputed() {\n",
        "879": "      return this;\n",
        "880": "    }\n",
        "881": "\n",
        "882": "    @Override\n",
        "883": "    public CharMatcher negate() {\n",
        "884": "      return new NegatedFastMatcher(this);\n",
        "885": "    }\n",
        "886": "  }\n",
        "887": "\n",
        "888": "  /** {@link FastMatcher} which overrides {@code toString()} with a custom name. */\n",
        "889": "  abstract static class NamedFastMatcher extends FastMatcher {\n",
        "890": "\n",
        "891": "    private final String description;\n",
        "892": "\n",
        "893": "    NamedFastMatcher(String description) {\n",
        "894": "      this.description = checkNotNull(description);\n",
        "895": "    }\n",
        "896": "\n",
        "897": "    @Override\n",
        "898": "    public final String toString() {\n",
        "899": "      return description;\n",
        "900": "    }\n",
        "901": "  }\n",
        "902": "\n",
        "903": "  /** Negation of a {@link FastMatcher}. */\n",
        "904": "  static class NegatedFastMatcher extends Negated {\n",
        "905": "\n",
        "906": "    NegatedFastMatcher(CharMatcher original) {\n",
        "907": "      super(original);\n",
        "908": "    }\n",
        "909": "\n",
        "910": "    @Override\n",
        "911": "    public final CharMatcher precomputed() {\n",
        "912": "      return this;\n",
        "913": "    }\n",
        "914": "  }\n",
        "915": "\n",
        "916": "  // Static constant implementation classes\n",
        "917": "\n",
        "918": "  /** Implementation of {@link #any()}. */\n",
        "919": "  private static final class Any extends NamedFastMatcher {\n",
        "920": "\n",
        "921": "    static final Any INSTANCE = new Any();\n",
        "922": "\n",
        "923": "    private Any() {\n",
        "924": "      super(\"CharMatcher.any()\");\n",
        "925": "    }\n",
        "926": "\n",
        "927": "    @Override\n",
        "928": "    public boolean matches(char c) {\n",
        "929": "      return true;\n",
        "930": "    }\n",
        "931": "\n",
        "932": "    @Override\n",
        "933": "    public int indexIn(CharSequence sequence) {\n",
        "934": "      return (sequence.length() == 0) ? -1 : 0;\n",
        "935": "    }\n",
        "936": "\n",
        "937": "    @Override\n",
        "938": "    public int indexIn(CharSequence sequence, int start) {\n",
        "939": "      int length = sequence.length();\n",
        "940": "      checkPositionIndex(start, length);\n",
        "941": "      return (start == length) ? -1 : start;\n",
        "942": "    }\n",
        "943": "\n",
        "944": "    @Override\n",
        "945": "    public int lastIndexIn(CharSequence sequence) {\n",
        "946": "      return sequence.length() - 1;\n",
        "947": "    }\n",
        "948": "\n",
        "949": "    @Override\n",
        "950": "    public boolean matchesAllOf(CharSequence sequence) {\n",
        "951": "      checkNotNull(sequence);\n",
        "952": "      return true;\n",
        "953": "    }\n",
        "954": "\n",
        "955": "    @Override\n",
        "956": "    public boolean matchesNoneOf(CharSequence sequence) {\n",
        "957": "      return sequence.length() == 0;\n",
        "958": "    }\n",
        "959": "\n",
        "960": "    @Override\n",
        "961": "    public String removeFrom(CharSequence sequence) {\n",
        "962": "      checkNotNull(sequence);\n",
        "963": "      return \"\";\n",
        "964": "    }\n",
        "965": "\n",
        "966": "    @Override\n",
        "967": "    public String replaceFrom(CharSequence sequence, char replacement) {\n",
        "968": "      char[] array = new char[sequence.length()];\n",
        "969": "      Arrays.fill(array, replacement);\n",
        "970": "      return new String(array);\n",
        "971": "    }\n",
        "972": "\n",
        "973": "    @Override\n",
        "974": "    public String replaceFrom(CharSequence sequence, CharSequence replacement) {\n",
        "975": "      StringBuilder result = new StringBuilder(sequence.length() * replacement.length());\n",
        "976": "      for (int i = 0; i < sequence.length(); i++) {\n",
        "977": "        result.append(replacement);\n",
        "978": "      }\n",
        "979": "      return result.toString();\n",
        "980": "    }\n",
        "981": "\n",
        "982": "    @Override\n",
        "983": "    public String collapseFrom(CharSequence sequence, char replacement) {\n",
        "984": "      return (sequence.length() == 0) ? \"\" : String.valueOf(replacement);\n",
        "985": "    }\n",
        "986": "\n",
        "987": "    @Override\n",
        "988": "    public String trimFrom(CharSequence sequence) {\n",
        "989": "      checkNotNull(sequence);\n",
        "990": "      return \"\";\n",
        "991": "    }\n",
        "992": "\n",
        "993": "    @Override\n",
        "994": "    public int countIn(CharSequence sequence) {\n",
        "995": "      return sequence.length();\n",
        "996": "    }\n",
        "997": "\n",
        "998": "    @Override\n",
        "999": "    public CharMatcher and(CharMatcher other) {\n",
        "1000": "      return checkNotNull(other);\n",
        "1001": "    }\n",
        "1002": "\n",
        "1003": "    @Override\n",
        "1004": "    public CharMatcher or(CharMatcher other) {\n",
        "1005": "      checkNotNull(other);\n",
        "1006": "      return this;\n",
        "1007": "    }\n",
        "1008": "\n",
        "1009": "    @Override\n",
        "1010": "    public CharMatcher negate() {\n",
        "1011": "      return none();\n",
        "1012": "    }\n",
        "1013": "  }\n",
        "1014": "\n",
        "1015": "  /** Implementation of {@link #none()}. */\n",
        "1016": "  private static final class None extends NamedFastMatcher {\n",
        "1017": "\n",
        "1018": "    static final None INSTANCE = new None();\n",
        "1019": "\n",
        "1020": "    private None() {\n",
        "1021": "      super(\"CharMatcher.none()\");\n",
        "1022": "    }\n",
        "1023": "\n",
        "1024": "    @Override\n",
        "1025": "    public boolean matches(char c) {\n",
        "1026": "      return false;\n",
        "1027": "    }\n",
        "1028": "\n",
        "1029": "    @Override\n",
        "1030": "    public int indexIn(CharSequence sequence) {\n",
        "1031": "      checkNotNull(sequence);\n",
        "1032": "      return -1;\n",
        "1033": "    }\n",
        "1034": "\n",
        "1035": "    @Override\n",
        "1036": "    public int indexIn(CharSequence sequence, int start) {\n",
        "1037": "      int length = sequence.length();\n",
        "1038": "      checkPositionIndex(start, length);\n",
        "1039": "      return -1;\n",
        "1040": "    }\n",
        "1041": "\n",
        "1042": "    @Override\n",
        "1043": "    public int lastIndexIn(CharSequence sequence) {\n",
        "1044": "      checkNotNull(sequence);\n",
        "1045": "      return -1;\n",
        "1046": "    }\n",
        "1047": "\n",
        "1048": "    @Override\n",
        "1049": "    public boolean matchesAllOf(CharSequence sequence) {\n",
        "1050": "      return sequence.length() == 0;\n",
        "1051": "    }\n",
        "1052": "\n",
        "1053": "    @Override\n",
        "1054": "    public boolean matchesNoneOf(CharSequence sequence) {\n",
        "1055": "      checkNotNull(sequence);\n",
        "1056": "      return true;\n",
        "1057": "    }\n",
        "1058": "\n",
        "1059": "    @Override\n",
        "1060": "    public String removeFrom(CharSequence sequence) {\n",
        "1061": "      return sequence.toString();\n",
        "1062": "    }\n",
        "1063": "\n",
        "1064": "    @Override\n",
        "1065": "    public String replaceFrom(CharSequence sequence, char replacement) {\n",
        "1066": "      return sequence.toString();\n",
        "1067": "    }\n",
        "1068": "\n",
        "1069": "    @Override\n",
        "1070": "    public String replaceFrom(CharSequence sequence, CharSequence replacement) {\n",
        "1071": "      checkNotNull(replacement);\n",
        "1072": "      return sequence.toString();\n",
        "1073": "    }\n",
        "1074": "\n",
        "1075": "    @Override\n",
        "1076": "    public String collapseFrom(CharSequence sequence, char replacement) {\n",
        "1077": "      return sequence.toString();\n",
        "1078": "    }\n",
        "1079": "\n",
        "1080": "    @Override\n",
        "1081": "    public String trimFrom(CharSequence sequence) {\n",
        "1082": "      return sequence.toString();\n",
        "1083": "    }\n",
        "1084": "\n",
        "1085": "    @Override\n",
        "1086": "    public String trimLeadingFrom(CharSequence sequence) {\n",
        "1087": "      return sequence.toString();\n",
        "1088": "    }\n",
        "1089": "\n",
        "1090": "    @Override\n",
        "1091": "    public String trimTrailingFrom(CharSequence sequence) {\n",
        "1092": "      return sequence.toString();\n",
        "1093": "    }\n",
        "1094": "\n",
        "1095": "    @Override\n",
        "1096": "    public int countIn(CharSequence sequence) {\n",
        "1097": "      checkNotNull(sequence);\n",
        "1098": "      return 0;\n",
        "1099": "    }\n",
        "1100": "\n",
        "1101": "    @Override\n",
        "1102": "    public CharMatcher and(CharMatcher other) {\n",
        "1103": "      checkNotNull(other);\n",
        "1104": "      return this;\n",
        "1105": "    }\n",
        "1106": "\n",
        "1107": "    @Override\n",
        "1108": "    public CharMatcher or(CharMatcher other) {\n",
        "1109": "      return checkNotNull(other);\n",
        "1110": "    }\n",
        "1111": "\n",
        "1112": "    @Override\n",
        "1113": "    public CharMatcher negate() {\n",
        "1114": "      return any();\n",
        "1115": "    }\n",
        "1116": "  }\n",
        "1117": "\n",
        "1118": "  /** Implementation of {@link #whitespace()}. */\n",
        "1119": "  @VisibleForTesting\n",
        "1120": "  static final class Whitespace extends NamedFastMatcher {\n",
        "1121": "\n",
        "1122": "    static final String TABLE =\n",
        "1123": "        \"\\u2002\\u3000\\r\\u0085\\u200A\\u2005\\u2000\\u3000\"\n",
        "1124": "            + \"\\u2029\\u000B\\u3000\\u2008\\u2003\\u205F\\u3000\\u1680\"\n",
        "1125": "            + \"\\u0009\\u0020\\u2006\\u2001\\u202F\\u00A0\\u000C\\u2009\"\n",
        "1126": "            + \"\\u3000\\u2004\\u3000\\u3000\\u2028\\n\\u2007\\u3000\";\n",
        "1127": "    static final int MULTIPLIER = 1682554634;\n",
        "1128": "    static final int SHIFT = Integer.numberOfLeadingZeros(TABLE.length() - 1);\n",
        "1129": "\n",
        "1130": "    static final Whitespace INSTANCE = new Whitespace();\n",
        "1131": "\n",
        "1132": "    Whitespace() {\n",
        "1133": "      super(\"CharMatcher.whitespace()\");\n",
        "1134": "    }\n",
        "1135": "\n",
        "1136": "    @Override\n",
        "1137": "    public boolean matches(char c) {\n",
        "1138": "      return TABLE.charAt((MULTIPLIER * c) >>> SHIFT) == c;\n",
        "1139": "    }\n",
        "1140": "  }\n",
        "1141": "\n",
        "1142": "  /** Implementation of {@link #breakingWhitespace()}. */\n",
        "1143": "  private static final class BreakingWhitespace extends CharMatcher {\n",
        "1144": "\n",
        "1145": "    static final CharMatcher INSTANCE = new BreakingWhitespace();\n",
        "1146": "\n",
        "1147": "    @Override\n",
        "1148": "    public boolean matches(char c) {\n",
        "1149": "      switch (c) {\n",
        "1150": "        case '\\t':\n",
        "1151": "        case '\\n':\n",
        "1152": "        case '\\013':\n",
        "1153": "        case '\\f':\n",
        "1154": "        case '\\r':\n",
        "1155": "        case ' ':\n",
        "1156": "        case '\\u0085':\n",
        "1157": "        case '\\u1680':\n",
        "1158": "        case '\\u2028':\n",
        "1159": "        case '\\u2029':\n",
        "1160": "        case '\\u205f':\n",
        "1161": "        case '\\u3000':\n",
        "1162": "          return true;\n",
        "1163": "        case '\\u2007':\n",
        "1164": "          return false;\n",
        "1165": "        default:\n",
        "1166": "          return c >= '\\u2000' && c <= '\\u200a';\n",
        "1167": "      }\n",
        "1168": "    }\n",
        "1169": "\n",
        "1170": "    @Override\n",
        "1171": "    public String toString() {\n",
        "1172": "      return \"CharMatcher.breakingWhitespace()\";\n",
        "1173": "    }\n",
        "1174": "  }\n",
        "1175": "\n",
        "1176": "  /** Implementation of {@link #ascii()}. */\n",
        "1177": "  private static final class Ascii extends NamedFastMatcher {\n",
        "1178": "\n",
        "1179": "    static final Ascii INSTANCE = new Ascii();\n",
        "1180": "\n",
        "1181": "    Ascii() {\n",
        "1182": "      super(\"CharMatcher.ascii()\");\n",
        "1183": "    }\n",
        "1184": "\n",
        "1185": "    @Override\n",
        "1186": "    public boolean matches(char c) {\n",
        "1187": "      return c <= '\\u007f';\n",
        "1188": "    }\n",
        "1189": "  }\n",
        "1190": "\n",
        "1191": "  /** Implementation that matches characters that fall within multiple ranges. */\n",
        "1192": "  private static class RangesMatcher extends CharMatcher {\n",
        "1193": "\n",
        "1194": "    private final String description;\n",
        "1195": "    private final char[] rangeStarts;\n",
        "1196": "    private final char[] rangeEnds;\n",
        "1197": "\n",
        "1198": "    RangesMatcher(String description, char[] rangeStarts, char[] rangeEnds) {\n",
        "1199": "      this.description = description;\n",
        "1200": "      this.rangeStarts = rangeStarts;\n",
        "1201": "      this.rangeEnds = rangeEnds;\n",
        "1202": "      checkArgument(rangeStarts.length == rangeEnds.length);\n",
        "1203": "      for (int i = 0; i < rangeStarts.length; i++) {\n",
        "1204": "        checkArgument(rangeStarts[i] <= rangeEnds[i]);\n",
        "1205": "        if (i + 1 < rangeStarts.length) {\n",
        "1206": "          checkArgument(rangeEnds[i] < rangeStarts[i + 1]);\n",
        "1207": "        }\n",
        "1208": "      }\n",
        "1209": "    }\n",
        "1210": "\n",
        "1211": "    @Override\n",
        "1212": "    public boolean matches(char c) {\n",
        "1213": "      int index = Arrays.binarySearch(rangeStarts, c);\n",
        "1214": "      if (index >= 0) {\n",
        "1215": "        return true;\n",
        "1216": "      } else {\n",
        "1217": "        index = ~index - 1;\n",
        "1218": "        return index >= 0 && c <= rangeEnds[index];\n",
        "1219": "      }\n",
        "1220": "    }\n",
        "1221": "\n",
        "1222": "    @Override\n",
        "1223": "    public String toString() {\n",
        "1224": "      return description;\n",
        "1225": "    }\n",
        "1226": "  }\n",
        "1227": "\n",
        "1228": "  /** Implementation of {@link #digit()}. */\n",
        "1229": "  private static final class Digit extends RangesMatcher {\n",
        "1230": "\n",
        "1231": "    // Must be in ascending order.\n",
        "1232": "    private static final String ZEROES =\n",
        "1233": "        \"0\\u0660\\u06f0\\u07c0\\u0966\\u09e6\\u0a66\\u0ae6\\u0b66\"\n",
        "1234": "            + \"\\u0be6\\u0c66\\u0ce6\\u0d66\\u0e50\\u0ed0\\u0f20\\u1040\\u1090\\u17e0\\u1810\"\n",
        "1235": "            + \"\\u1946\\u19d0\\u1b50\\u1bb0\\u1c40\\u1c50\\ua620\\ua8d0\\ua900\\uaa50\\uff10\";\n",
        "1236": "\n",
        "1237": "    private static char[] zeroes() {\n",
        "1238": "      return ZEROES.toCharArray();\n",
        "1239": "    }\n",
        "1240": "\n",
        "1241": "    private static char[] nines() {\n",
        "1242": "      char[] nines = new char[ZEROES.length()];\n",
        "1243": "      for (int i = 0; i < ZEROES.length(); i++) {\n",
        "1244": "        nines[i] = (char) (ZEROES.charAt(i) + 9);\n",
        "1245": "      }\n",
        "1246": "      return nines;\n",
        "1247": "    }\n",
        "1248": "\n",
        "1249": "    static final Digit INSTANCE = new Digit();\n",
        "1250": "\n",
        "1251": "    private Digit() {\n",
        "1252": "      super(\"CharMatcher.digit()\", zeroes(), nines());\n",
        "1253": "    }\n",
        "1254": "  }\n",
        "1255": "\n",
        "1256": "  /** Implementation of {@link #javaDigit()}. */\n",
        "1257": "  private static final class JavaDigit extends CharMatcher {\n",
        "1258": "\n",
        "1259": "    static final JavaDigit INSTANCE = new JavaDigit();\n",
        "1260": "\n",
        "1261": "    @Override\n",
        "1262": "    public boolean matches(char c) {\n",
        "1263": "      return Character.isDigit(c);\n",
        "1264": "    }\n",
        "1265": "\n",
        "1266": "    @Override\n",
        "1267": "    public String toString() {\n",
        "1268": "      return \"CharMatcher.javaDigit()\";\n",
        "1269": "    }\n",
        "1270": "  }\n",
        "1271": "\n",
        "1272": "  /** Implementation of {@link #javaLetter()}. */\n",
        "1273": "  private static final class JavaLetter extends CharMatcher {\n",
        "1274": "\n",
        "1275": "    static final JavaLetter INSTANCE = new JavaLetter();\n",
        "1276": "\n",
        "1277": "    @Override\n",
        "1278": "    public boolean matches(char c) {\n",
        "1279": "      return Character.isLetter(c);\n",
        "1280": "    }\n",
        "1281": "\n",
        "1282": "    @Override\n",
        "1283": "    public String toString() {\n",
        "1284": "      return \"CharMatcher.javaLetter()\";\n",
        "1285": "    }\n",
        "1286": "  }\n",
        "1287": "\n",
        "1288": "  /** Implementation of {@link #javaLetterOrDigit()}. */\n",
        "1289": "  private static final class JavaLetterOrDigit extends CharMatcher {\n",
        "1290": "\n",
        "1291": "    static final JavaLetterOrDigit INSTANCE = new JavaLetterOrDigit();\n",
        "1292": "\n",
        "1293": "    @Override\n",
        "1294": "    public boolean matches(char c) {\n",
        "1295": "      return Character.isLetterOrDigit(c);\n",
        "1296": "    }\n",
        "1297": "\n",
        "1298": "    @Override\n",
        "1299": "    public String toString() {\n",
        "1300": "      return \"CharMatcher.javaLetterOrDigit()\";\n",
        "1301": "    }\n",
        "1302": "  }\n",
        "1303": "\n",
        "1304": "  /** Implementation of {@link #javaUpperCase()}. */\n",
        "1305": "  private static final class JavaUpperCase extends CharMatcher {\n",
        "1306": "\n",
        "1307": "    static final JavaUpperCase INSTANCE = new JavaUpperCase();\n",
        "1308": "\n",
        "1309": "    @Override\n",
        "1310": "    public boolean matches(char c) {\n",
        "1311": "      return Character.isUpperCase(c);\n",
        "1312": "    }\n",
        "1313": "\n",
        "1314": "    @Override\n",
        "1315": "    public String toString() {\n",
        "1316": "      return \"CharMatcher.javaUpperCase()\";\n",
        "1317": "    }\n",
        "1318": "  }\n",
        "1319": "\n",
        "1320": "  /** Implementation of {@link #javaLowerCase()}. */\n",
        "1321": "  private static final class JavaLowerCase extends CharMatcher {\n",
        "1322": "\n",
        "1323": "    static final JavaLowerCase INSTANCE = new JavaLowerCase();\n",
        "1324": "\n",
        "1325": "    @Override\n",
        "1326": "    public boolean matches(char c) {\n",
        "1327": "      return Character.isLowerCase(c);\n",
        "1328": "    }\n",
        "1329": "\n",
        "1330": "    @Override\n",
        "1331": "    public String toString() {\n",
        "1332": "      return \"CharMatcher.javaLowerCase()\";\n",
        "1333": "    }\n",
        "1334": "  }\n",
        "1335": "\n",
        "1336": "  /** Implementation of {@link #javaIsoControl()}. */\n",
        "1337": "  private static final class JavaIsoControl extends NamedFastMatcher {\n",
        "1338": "\n",
        "1339": "    static final JavaIsoControl INSTANCE = new JavaIsoControl();\n",
        "1340": "\n",
        "1341": "    private JavaIsoControl() {\n",
        "1342": "      super(\"CharMatcher.javaIsoControl()\");\n",
        "1343": "    }\n",
        "1344": "\n",
        "1345": "    @Override\n",
        "1346": "    public boolean matches(char c) {\n",
        "1347": "      return c <= '\\u001f' || (c >= '\\u007f' && c <= '\\u009f');\n",
        "1348": "    }\n",
        "1349": "  }\n",
        "1350": "\n",
        "1351": "  /** Implementation of {@link #invisible()}. */\n",
        "1352": "  private static final class Invisible extends RangesMatcher {\n",
        "1353": "\n",
        "1354": "    private static final String RANGE_STARTS =\n",
        "1355": "      \"\\u0000\\u007f\\u00ad\\u0600\\u061c\\u06dd\\u070f\\u1680\\u180e\\u2000\\u2028\\u205f\\u2066\\u2067\"\n",
        "1356": "          + \"\\u2068\\u2069\\u206a\\u3000\\ud800\\ufeff\\ufff9\\ufffa\";\n",
        "1357": "    private static final String RANGE_ENDS =\n",
        "1358": "      \"\\u0020\\u00a0\\u00ad\\u0604\\u061c\\u06dd\\u070f\\u1680\\u180e\\u200f\\u202f\\u2064\\u2066\\u2067\"\n",
        "1359": "          + \"\\u2068\\u2069\\u206f\\u3000\\uf8ff\\ufeff\\ufff9\\ufffb\";\n",
        "1360": "\n",
        "1361": "    static final Invisible INSTANCE = new Invisible();\n",
        "1362": "\n",
        "1363": "    private Invisible() {\n",
        "1364": "      super(\n",
        "1365": "          \"CharMatcher.invisible()\",\n",
        "1366": "          RANGE_STARTS.toCharArray(),\n",
        "1367": "          RANGE_ENDS.toCharArray());\n",
        "1368": "    }\n",
        "1369": "  }\n",
        "1370": "\n",
        "1371": "  /** Implementation of {@link #singleWidth()}. */\n",
        "1372": "  private static final class SingleWidth extends RangesMatcher {\n",
        "1373": "\n",
        "1374": "    static final SingleWidth INSTANCE = new SingleWidth();\n",
        "1375": "\n",
        "1376": "    private SingleWidth() {\n",
        "1377": "      super(\n",
        "1378": "          \"CharMatcher.singleWidth()\",\n",
        "1379": "          \"\\u0000\\u05be\\u05d0\\u05f3\\u0600\\u0750\\u0e00\\u1e00\\u2100\\ufb50\\ufe70\\uff61\".toCharArray(),\n",
        "1380": "          \"\\u04f9\\u05be\\u05ea\\u05f4\\u06ff\\u077f\\u0e7f\\u20af\\u213a\\ufdff\\ufeff\\uffdc\".toCharArray());\n",
        "1381": "    }\n",
        "1382": "  }\n",
        "1383": "\n",
        "1384": "  // Non-static factory implementation classes\n",
        "1385": "\n",
        "1386": "  /** Implementation of {@link #negate()}. */\n",
        "1387": "  private static class Negated extends CharMatcher {\n",
        "1388": "\n",
        "1389": "    final CharMatcher original;\n",
        "1390": "\n",
        "1391": "    Negated(CharMatcher original) {\n",
        "1392": "      this.original = checkNotNull(original);\n",
        "1393": "    }\n",
        "1394": "\n",
        "1395": "    @Override\n",
        "1396": "    public boolean matches(char c) {\n",
        "1397": "      return !original.matches(c);\n",
        "1398": "    }\n",
        "1399": "\n",
        "1400": "    @Override\n",
        "1401": "    public boolean matchesAllOf(CharSequence sequence) {\n",
        "1402": "      return original.matchesNoneOf(sequence);\n",
        "1403": "    }\n",
        "1404": "\n",
        "1405": "    @Override\n",
        "1406": "    public boolean matchesNoneOf(CharSequence sequence) {\n",
        "1407": "      return original.matchesAllOf(sequence);\n",
        "1408": "    }\n",
        "1409": "\n",
        "1410": "    @Override\n",
        "1411": "    public int countIn(CharSequence sequence) {\n",
        "1412": "      return sequence.length() - original.countIn(sequence);\n",
        "1413": "    }\n",
        "1414": "\n",
        "1415": "    @Override\n",
        "1416": "    public CharMatcher negate() {\n",
        "1417": "      return original;\n",
        "1418": "    }\n",
        "1419": "\n",
        "1420": "    @Override\n",
        "1421": "    public String toString() {\n",
        "1422": "      return original + \".negate()\";\n",
        "1423": "    }\n",
        "1424": "  }\n",
        "1425": "\n",
        "1426": "  /** Implementation of {@link #and(CharMatcher)}. */\n",
        "1427": "  private static final class And extends CharMatcher {\n",
        "1428": "\n",
        "1429": "    final CharMatcher first;\n",
        "1430": "    final CharMatcher second;\n",
        "1431": "\n",
        "1432": "    And(CharMatcher a, CharMatcher b) {\n",
        "1433": "      first = checkNotNull(a);\n",
        "1434": "      second = checkNotNull(b);\n",
        "1435": "    }\n",
        "1436": "\n",
        "1437": "    @Override\n",
        "1438": "    public boolean matches(char c) {\n",
        "1439": "      return first.matches(c) && second.matches(c);\n",
        "1440": "    }\n",
        "1441": "\n",
        "1442": "    @Override\n",
        "1443": "    public String toString() {\n",
        "1444": "      return \"CharMatcher.and(\" + first + \", \" + second + \")\";\n",
        "1445": "    }\n",
        "1446": "  }\n",
        "1447": "\n",
        "1448": "  /** Implementation of {@link #or(CharMatcher)}. */\n",
        "1449": "  private static final class Or extends CharMatcher {\n",
        "1450": "\n",
        "1451": "    final CharMatcher first;\n",
        "1452": "    final CharMatcher second;\n",
        "1453": "\n",
        "1454": "    Or(CharMatcher a, CharMatcher b) {\n",
        "1455": "      first = checkNotNull(a);\n",
        "1456": "      second = checkNotNull(b);\n",
        "1457": "    }\n",
        "1458": "\n",
        "1459": "    @Override\n",
        "1460": "    public boolean matches(char c) {\n",
        "1461": "      return first.matches(c) || second.matches(c);\n",
        "1462": "    }\n",
        "1463": "\n",
        "1464": "    @Override\n",
        "1465": "    public String toString() {\n",
        "1466": "      return \"CharMatcher.or(\" + first + \", \" + second + \")\";\n",
        "1467": "    }\n",
        "1468": "  }\n",
        "1469": "\n",
        "1470": "  // Static factory implementations\n",
        "1471": "\n",
        "1472": "  /** Implementation of {@link #is(char)}. */\n",
        "1473": "  private static final class Is extends FastMatcher {\n",
        "1474": "\n",
        "1475": "    private final char match;\n",
        "1476": "\n",
        "1477": "    Is(char match) {\n",
        "1478": "      this.match = match;\n",
        "1479": "    }\n",
        "1480": "\n",
        "1481": "    @Override\n",
        "1482": "    public boolean matches(char c) {\n",
        "1483": "      return c == match;\n",
        "1484": "    }\n",
        "1485": "\n",
        "1486": "    @Override\n",
        "1487": "    public String replaceFrom(CharSequence sequence, char replacement) {\n",
        "1488": "      return sequence.toString().replace(match, replacement);\n",
        "1489": "    }\n",
        "1490": "\n",
        "1491": "    @Override\n",
        "1492": "    public CharMatcher and(CharMatcher other) {\n",
        "1493": "      return other.matches(match) ? this : none();\n",
        "1494": "    }\n",
        "1495": "\n",
        "1496": "    @Override\n",
        "1497": "    public CharMatcher or(CharMatcher other) {\n",
        "1498": "      return other.matches(match) ? other : super.or(other);\n",
        "1499": "    }\n",
        "1500": "\n",
        "1501": "    @Override\n",
        "1502": "    public CharMatcher negate() {\n",
        "1503": "      return isNot(match);\n",
        "1504": "    }\n",
        "1505": "\n",
        "1506": "    @Override\n",
        "1507": "    public String toString() {\n",
        "1508": "      return \"CharMatcher.is('\" + showCharacter(match) + \"')\";\n",
        "1509": "    }\n",
        "1510": "  }\n",
        "1511": "\n",
        "1512": "  /** Implementation of {@link #isNot(char)}. */\n",
        "1513": "  private static final class IsNot extends FastMatcher {\n",
        "1514": "\n",
        "1515": "    private final char match;\n",
        "1516": "\n",
        "1517": "    IsNot(char match) {\n",
        "1518": "      this.match = match;\n",
        "1519": "    }\n",
        "1520": "\n",
        "1521": "    @Override\n",
        "1522": "    public boolean matches(char c) {\n",
        "1523": "      return c != match;\n",
        "1524": "    }\n",
        "1525": "\n",
        "1526": "    @Override\n",
        "1527": "    public CharMatcher and(CharMatcher other) {\n",
        "1528": "      return other.matches(match) ? super.and(other) : other;\n",
        "1529": "    }\n",
        "1530": "\n",
        "1531": "    @Override\n",
        "1532": "    public CharMatcher or(CharMatcher other) {\n",
        "1533": "      return other.matches(match) ? any() : this;\n",
        "1534": "    }\n",
        "1535": "\n",
        "1536": "    @Override\n",
        "1537": "    public CharMatcher negate() {\n",
        "1538": "      return is(match);\n",
        "1539": "    }\n",
        "1540": "\n",
        "1541": "    @Override\n",
        "1542": "    public String toString() {\n",
        "1543": "      return \"CharMatcher.isNot('\" + showCharacter(match) + \"')\";\n",
        "1544": "    }\n",
        "1545": "  }\n",
        "1546": "\n",
        "1547": "  private static CharMatcher.IsEither isEither(char c1, char c2) {\n",
        "1548": "    return new CharMatcher.IsEither(c1, c2);\n",
        "1549": "  }\n",
        "1550": "\n",
        "1551": "  /** Implementation of {@link #anyOf(CharSequence)} for exactly two characters. */\n",
        "1552": "  private static final class IsEither extends FastMatcher {\n",
        "1553": "\n",
        "1554": "    private final char match1;\n",
        "1555": "    private final char match2;\n",
        "1556": "\n",
        "1557": "    IsEither(char match1, char match2) {\n",
        "1558": "      this.match1 = match1;\n",
        "1559": "      this.match2 = match2;\n",
        "1560": "    }\n",
        "1561": "\n",
        "1562": "    @Override\n",
        "1563": "    public boolean matches(char c) {\n",
        "1564": "      return c == match1 || c == match2;\n",
        "1565": "    }\n",
        "1566": "\n",
        "1567": "    @Override\n",
        "1568": "    public String toString() {\n",
        "1569": "      return \"CharMatcher.anyOf(\\\"\" + showCharacter(match1) + showCharacter(match2) + \"\\\")\";\n",
        "1570": "    }\n",
        "1571": "  }\n",
        "1572": "\n",
        "1573": "  /** Implementation of {@link #anyOf(CharSequence)} for three or more characters. */\n",
        "1574": "  private static final class AnyOf extends CharMatcher {\n",
        "1575": "\n",
        "1576": "    private final char[] chars;\n",
        "1577": "\n",
        "1578": "    public AnyOf(CharSequence chars) {\n",
        "1579": "      this.chars = chars.toString().toCharArray();\n",
        "1580": "      Arrays.sort(this.chars);\n",
        "1581": "    }\n",
        "1582": "\n",
        "1583": "    @Override\n",
        "1584": "    public boolean matches(char c) {\n",
        "1585": "      return Arrays.binarySearch(chars, c) >= 0;\n",
        "1586": "    }\n",
        "1587": "\n",
        "1588": "    @Override\n",
        "1589": "    public String toString() {\n",
        "1590": "      StringBuilder description = new StringBuilder(\"CharMatcher.anyOf(\\\"\");\n",
        "1591": "      for (char c : chars) {\n",
        "1592": "        description.append(showCharacter(c));\n",
        "1593": "      }\n",
        "1594": "      description.append(\"\\\")\");\n",
        "1595": "      return description.toString();\n",
        "1596": "    }\n",
        "1597": "  }\n",
        "1598": "\n",
        "1599": "  /** Implementation of {@link #inRange(char, char)}. */\n",
        "1600": "  private static final class InRange extends FastMatcher {\n",
        "1601": "\n",
        "1602": "    private final char startInclusive;\n",
        "1603": "    private final char endInclusive;\n",
        "1604": "\n",
        "1605": "    InRange(char startInclusive, char endInclusive) {\n",
        "1606": "      checkArgument(endInclusive >= startInclusive);\n",
        "1607": "      this.startInclusive = startInclusive;\n",
        "1608": "      this.endInclusive = endInclusive;\n",
        "1609": "    }\n",
        "1610": "\n",
        "1611": "    @Override\n",
        "1612": "    public boolean matches(char c) {\n",
        "1613": "      return startInclusive <= c && c <= endInclusive;\n",
        "1614": "    }\n",
        "1615": "\n",
        "1616": "    @Override\n",
        "1617": "    public String toString() {\n",
        "1618": "      return \"CharMatcher.inRange('\"\n",
        "1619": "          + showCharacter(startInclusive)\n",
        "1620": "          + \"', '\"\n",
        "1621": "          + showCharacter(endInclusive)\n",
        "1622": "          + \"')\";\n",
        "1623": "    }\n",
        "1624": "  }\n",
        "1625": "\n",
        "1626": "  /** Implementation of {@link #forPredicate(Predicate)}. */\n",
        "1627": "  private static final class ForPredicate extends CharMatcher {\n",
        "1628": "\n",
        "1629": "    private final Predicate<? super Character> predicate;\n",
        "1630": "\n",
        "1631": "    ForPredicate(Predicate<? super Character> predicate) {\n",
        "1632": "      this.predicate = checkNotNull(predicate);\n",
        "1633": "    }\n",
        "1634": "\n",
        "1635": "    @Override\n",
        "1636": "    public boolean matches(char c) {\n",
        "1637": "      return predicate.apply(c);\n",
        "1638": "    }\n",
        "1639": "\n",
        "1640": "    @SuppressWarnings(\"deprecation\") // intentional; deprecation is for callers primarily\n",
        "1641": "    @Override\n",
        "1642": "    public boolean apply(Character character) {\n",
        "1643": "      return predicate.apply(checkNotNull(character));\n",
        "1644": "    }\n",
        "1645": "\n",
        "1646": "    @Override\n",
        "1647": "    public String toString() {\n",
        "1648": "      return \"CharMatcher.forPredicate(\" + predicate + \")\";\n",
        "1649": "    }\n",
        "1650": "  }\n",
        "1651": "}\n"
    }
}